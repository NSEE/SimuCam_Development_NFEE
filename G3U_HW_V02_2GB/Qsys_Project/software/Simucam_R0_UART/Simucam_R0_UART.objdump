
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0004f634 memsz 0x00069878 flags rwx
    LOAD off    0x00051000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00051000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00047e8c  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005778  811480e8  811480e8  000490e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  8114d860  8114d860  0004e860  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a244  8114f654  8114f654  00050654  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  81169898  81169898  00051000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00051000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00051000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  00051028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00070b00  00000000  00000000  00052d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00016766  00000000  00000000  000c3880  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0002251f  00000000  00000000  000d9fe6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009758  00000000  00000000  000fc508  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000c826  00000000  00000000  00105c60  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  00112486  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  00139354  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  00139398  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  001478ed  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  001478f3  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  001478ff  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00147900  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00147901  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00147905  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00147909  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0014790d  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  00147918  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  00147922  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0014792c  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  0014793d  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     002827ef  00000000  00000000  0014797c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
811480e8 l    d  .rodata	00000000 .rodata
8114d860 l    d  .rwdata	00000000 .rwdata
8114f654 l    d  .bss	00000000 .bss
81169898 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
8110474c l     F .text	00000050 uliCommReadReg
811046f8 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81104f8c l     F .text	00000050 uliDpktReadReg
81104f38 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
8114f678 l     O .bss	00000004 viCh1HoldContext
8114f67c l     O .bss	00000004 viCh2HoldContext
8114f680 l     O .bss	00000004 viCh3HoldContext
8114f684 l     O .bss	00000004 viCh4HoldContext
8114f688 l     O .bss	00000004 viCh5HoldContext
8114f68c l     O .bss	00000004 viCh6HoldContext
8114f690 l     O .bss	00000004 viCh7HoldContext
8114f694 l     O .bss	00000004 viCh8HoldContext
8110678c l     F .text	00000054 vFeebWriteReg
811067e0 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
8114f698 l     O .bss	00000004 viCh1HoldContext
8114f69c l     O .bss	00000004 viCh2HoldContext
8114f6a0 l     O .bss	00000004 viCh3HoldContext
8114f6a4 l     O .bss	00000004 viCh4HoldContext
8114f6a8 l     O .bss	00000004 viCh5HoldContext
8114f6ac l     O .bss	00000004 viCh6HoldContext
8114f6b0 l     O .bss	00000004 viCh7HoldContext
8114f6b4 l     O .bss	00000004 viCh8HoldContext
811095e0 l     F .text	00000054 vRmapWriteReg
81109684 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
81109fb8 l     F .text	00000050 uliSpwcReadReg
81109f64 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8114f57c l     O .rwdata	00000001 ucIoValue
8110a1b8 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110aaa8 l     F .text	0000013c msgdma_write_extended_descriptor
8110abe4 l     F .text	00000164 msgdma_construct_extended_descriptor
8110ad48 l     F .text	00000318 msgdma_descriptor_async_transfer
8110b060 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110bbdc l     F .text	00000054 vRstcWriteReg
8110bc30 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8114f6bc l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
8114f6c4 l     O .bss	00000004 pxNFee.5548
8114f6c8 l     O .bss	00000004 tCodFeeTask.5551
8114f6cc l     O .bss	00000004 incrementador.5553
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
8114f6d0 l     O .bss	00000004 xRAckLocal.5527
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
8114f6d4 l     O .bss	00000004 bDmaBack.5525
8114f6d8 l     O .bss	00000001 ucWhoGetDMA.5526
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8114f6da l     O .bss	00000004 xSAckLocal.5512
00000000 l    df *ABS*	00000000 parser_comm_task.c
8114f854 l     O .bss	0000004c PreParsedLocal.5601
8114f8a0 l     O .bss	00000054 xTcPusL.5600
00000000 l    df *ABS*	00000000 receiver_uart_task.c
8114f8f4 l     O .bss	0000004c xPreParsedReader.5593
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8114f940 l     O .bss	00000054 xPusLocal.5790
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114b1ab l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8114cca1 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
8114d860 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
8111ec74 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114ce6e l     O .rodata	00000010 zeroes.4389
8114ce7e l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8114ce8e l     O .rodata	00000010 zeroes.4404
811238ec l     F .text	000000c4 __sbprintf
8114ce9e l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8114ceb6 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
811255d4 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
81127124 l     F .text	00000008 __fp_unlock
81127138 l     F .text	000001a4 __sinit.part.1
811272dc l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
8114e0ac l     O .rwdata	00000020 lc_ctype_charset
8114e08c l     O .rwdata	00000020 lc_message_charset
8114e0cc l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8114cef4 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8112a14c l     F .text	0000006c sulp
8114d03c l     O .rodata	00000014 fpi.2737
8114d050 l     O .rodata	00000028 tinytens
8114d028 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114d088 l     O .rodata	00000010 blanks.4332
8114d078 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112d7bc l     F .text	00000104 __sprint_r.part.0
8114d0a8 l     O .rodata	00000010 blanks.4348
8114d098 l     O .rodata	00000010 zeroes.4349
8112ed58 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8112f20c l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81132fa8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
811330ec l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81133120 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
811333a4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
8113349c l       .text	00000000 tx_next_char
811334c4 l       .text	00000000 end_tx
811334a4 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
81133fa0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
8113421c l     F .text	00000044 alt_get_errno
81134260 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81134488 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
8114f5c4 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81134a28 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
8114f5d0 l     O .rwdata	00000004 lockid
8114f79c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
8114f5d4 l     O .rwdata	00000004 lockid
8114f7a4 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
811364b4 l     F .text	00000050 OS_InitMisc
81136504 l     F .text	00000074 OS_InitRdyList
81136688 l     F .text	000000ec OS_InitTCBList
811363cc l     F .text	000000e8 OS_InitEventList
81136578 l     F .text	00000088 OS_InitTaskIdle
81136600 l     F .text	00000088 OS_InitTaskStat
81136918 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
81138730 l     F .text	000000fc OS_FlagTaskRdy
811384e0 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113a01c l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8113ea4c l     F .text	00000044 OSTmr_Lock
8113e4ec l     F .text	00000074 OSTmr_Alloc
8113ea90 l     F .text	0000003c OSTmr_Unlock
8113e950 l     F .text	000000fc OSTmr_Unlink
8113e560 l     F .text	000000a4 OSTmr_Free
8113e800 l     F .text	00000150 OSTmr_Link
8113e778 l     F .text	00000088 OSTmr_InitTask
8113eacc l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
8113ebdc l     F .text	0000003c alt_dev_reg
8114e348 l     O .rwdata	0000106c jtag_uart_0
8114f3b4 l     O .rwdata	000000d0 rs232_uart
8114f484 l     O .rwdata	00000064 dma_DDR_M1
8114f4e8 l     O .rwdata	00000064 dma_DDR_M2
8114f54c l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
8114346c l     F .text	000002bc altera_avalon_jtag_uart_irq
81143728 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81143f2c l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
811442c4 l     F .text	000000a4 altera_avalon_uart_irq
81144368 l     F .text	00000140 altera_avalon_uart_rxirq
811444a8 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
811446b0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81144964 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81144be8 l     F .text	00000044 alt_get_errno
81144c2c l     F .text	0000009c alt_msgdma_write_standard_descriptor
81144cc8 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81144dfc l     F .text	0000018c alt_msgdma_irq
81144f88 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
8114501c l     F .text	0000015c alt_msgdma_construct_extended_descriptor
81145178 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
811454b8 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81145bc0 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81145c6c l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
81146e38 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8114747c l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
8114f84c l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8114f850 g     O .bss	00000004 alt_instruction_exception_handler
81106cb0 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
811500ec g     O .bss	00001000 vFeeTask0_stk
81118b7c g     F .text	0000004c vFailDeleteInitialization
8114f820 g     O .bss	00000004 aux_status_register
811510ec g     O .bss	00001000 vInAckHandlerTask_stk
81146bf4 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
81106ff8 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110c2c0 g     F .text	0000004c vSyncInitIrq
81114c58 g     F .text	00000284 vCheckRetransmission128
811297d0 g     F .text	0000007c _mprec_log10
8110c4c8 g     F .text	00000040 bSyncSetMbt
8111a140 g     F .text	00000054 vFailRequestDMAFromIRQ
8110a39c g     F .text	00000108 I2C_Read
8114f622 g     O .rwdata	00000002 OSTaskNameSize
8114f6e4 g     O .bss	00000004 xWaitSyncQFee
811520ec g     O .bss	00000260 xBuffer64
811298c4 g     F .text	0000008c __any_on
81128298 g     F .text	0000005c _isatty_r
8114cf00 g     O .rodata	00000028 __mprec_tinytens
81106fa0 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
811340c0 g     F .text	0000015c alt_main
8111eb98 g     F .text	000000c8 _puts_r
81105600 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
8114f7ac g     O .bss	00000004 OSTmrFreeList
81169798 g     O .bss	00000100 alt_irq
81128408 g     F .text	00000068 _lseek_r
8111b368 g     F .text	00000030 vChangeDefaultAutoResetSync
81138f90 g     F .text	000000d4 OS_MemInit
8111a0ec g     F .text	00000054 vFailRequestDMA
81117660 g     F .text	000009d4 vLoadDefaultETHConf
8111017c g     F .text	0000014c bCheckInAck64
8115234c g     O .bss	00000150 xPus
8113da2c g     F .text	00000068 OSTimeSet
8111389c g     F .text	0000008c vPusType250run
811274dc g     F .text	000000ac __sflags
81119ac0 g     F .text	00000068 vCoudlNotCreateNFee2Task
81119eac g     F .text	0000004c vCouldNotGetMutexMebPus
81132108 g     F .text	00000088 .hidden __eqdf2
81113f68 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111b254 g     F .text	00000034 vLoadDefaultSyncSource
81118614 g     F .text	0000004c vFailCreateMutexDMA
8113f0dc g     F .text	000001ac Check_for_Master_Boot_Record
811631ac g     O .bss	00000010 OSTmrWheelTbl
81107098 g     F .text	00000050 uliRmapCh3WriteCmdAddress
81145980 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8115249c g     O .bss	00000020 xFeeQueueTBL3
81135118 g     F .text	00000594 OSEventPendMulti
8114f6e8 g     O .bss	00000004 xNfeeSchedule
81169898 g       *ABS*	00000000 __alt_heap_start
81147ab4 g     F .text	0000002c OSTaskCreateHook
81142f54 g     F .text	000001c4 alt_up_sd_card_fclose
8114f6ec g     O .bss	00000004 xSemCountBuffer64
811044b0 g     F .text	0000016c bCommSetGlobalIrqEn
8110749c g     F .text	00000088 bRmapGetIrqControl
8111e9dc g     F .text	00000044 printf
8114f6b9 g     O .bss	00000001 SspdConfigControl
8110c8e4 g     F .text	00000054 bSyncCtrReset
8114f5fa g     O .rwdata	00000002 OSMboxEn
8111bec8 g     F .text	000000a4 aatoh
81135710 g     F .text	00000054 OSIntEnter
8112fe78 g     F .text	000000a4 _wcrtomb_r
8110550c g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
81118ae4 g     F .text	0000004c vFailReceiverCreate
8114f6f0 g     O .bss	00000004 xQMaskDataCtrl
8110501c g     F .text	00000084 vFeebCh2HandleIrq
8111f100 g     F .text	00000064 __sseek
8112748c g     F .text	00000010 __sinit
8110b51c g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
81125254 g     F .text	00000148 __swbuf_r
81115430 g     F .text	00000470 bResourcesInitRTOS
81109b04 g     F .text	000000f4 bSpwcGetLinkError
8114f60a g     O .rwdata	00000002 OSQEn
8110e85c g     F .text	000004a8 vQCmdFeeRMAPinStandBy
811069d8 g     F .text	00000040 vRmapCh4HandleIrq
81128324 g     F .text	00000084 _setlocale_r
811524bc g     O .bss	00000020 SyncTBL2
8114f580 g     O .rwdata	00000004 LedsPainelControl
8114f9bc g     O .bss	00000100 cDebugBuffer
811272e4 g     F .text	00000070 __sfmoreglue
8112d7a4 g     F .text	00000018 ungetc
81105810 g     F .text	000000d4 bFeebCh1SetBufferSize
81134dd4 g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
81147b34 g     F .text	00000028 OSTaskStatHook
81113dc4 g     F .text	00000088 vSendCmdQToNFeeCTRL
8111b2c4 g     F .text	00000030 vChangeDefaultSyncSource
8114f7b0 g     O .bss	00000001 OSLockNesting
8114f7b4 g     O .bss	00000004 OSTmrSemSignal
8111a56c g     F .text	00000178 vNFeeStructureInit
8114f6f4 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
8112a1b8 g     F .text	00001600 _strtod_r
8114f6f8 g     O .bss	00000004 xSemCountSenderACK
8111c004 g     F .text	00000448 .hidden __divsf3
8114f844 g     O .bss	00000004 current_sector_modified
8114f648 g     O .rwdata	00000002 OSDataSize
8114f7b8 g     O .bss	00000001 OSRunning
81109de0 g     F .text	00000184 bSpwcInitCh
81133d88 g     F .text	00000064 alt_log_jtag_uart_isr_proc
811524dc g     O .bss	00001000 senderTask_stk
81107f90 g     F .text	00000094 bRmapGetMemConfigStat
8114f6fc g     O .bss	00000004 fp
811534dc g     O .bss	00000048 xNfeeScheduleTBL
81110034 g     F .text	00000148 bCheckInAck128
81128798 g     F .text	0000015c memmove
81147bb0 g     F .text	0000002c OSInitHookBegin
8110cd80 g     F .text	00000074 bSyncCtrCh8OutEnable
8110f14c g     F .text	00000084 bEnableDbBuffer
8114f640 g     O .rwdata	00000002 OSTmrSize
81127474 g     F .text	00000018 _cleanup
8111b790 g     F .text	00000040 siCloseFile
81106608 g     F .text	00000184 bFeebInitCh
811288f4 g     F .text	000000b0 _Balloc
8111b2f4 g     F .text	00000038 vLoadDefaultAutoResetSync
811075ac g     F .text	000000d8 bRmapSetCodecConfig
81141b30 g     F .text	000000cc alt_up_sd_card_is_Present
811458c0 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8114f65c g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
8113ee04 g     F .text	00000054 Save_Modified_Sector
81105760 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
8114f7bc g     O .bss	00000004 OSIdleCtr
8114f778 g     O .bss	00000001 alt_log_write_on_flag
8110a008 g     F .text	0000003c bEnableIsoDrivers
81132190 g     F .text	000000dc .hidden __gtdf2
81147844 g     F .text	0000002c altera_nios2_gen2_irq_init
8114792c g       .text	00000000 OSStartTsk
8110c63c g     F .text	00000070 bSyncSetNCycles
81136c88 g     F .text	000002dc OS_TCBInit
8114f77b g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111aedc g     F .text	00000078 vInitSimucamBasicHW
81153524 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110cc98 g     F .text	00000074 bSyncCtrCh6OutEnable
8110a718 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
8114f83c g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
8114f7c0 g     O .bss	00000002 OSTmrUsed
8114f700 g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
811073f4 g     F .text	000000a8 bRmapSetIrqControl
81105b60 g     F .text	000000d4 bFeebCh5SetBufferSize
81154524 g     O .bss	00001000 vDataControlTask_stk
81105124 g     F .text	00000084 vFeebCh4HandleIrq
8114f646 g     O .rwdata	00000002 OSTmrWheelTblSize
8111ab84 g     F .text	0000002c cFeeSpwChannelDisable
8114f5e6 g     O .rwdata	00000002 OSEventSize
8114f7c2 g     O .bss	00000001 OSPrioHighRdy
8111db78 g     F .text	00000064 _fstat_r
81147ae0 g     F .text	0000002c OSTaskDelHook
8114f754 g     O .bss	00000004 errno
8110d074 g     F .text	0000003c uliSyncGetCtr
811251e4 g     F .text	0000001c __svfscanf
8111f074 g     F .text	00000008 __seofread
8114790c g       .text	00000000 OSStartHighRdy
8111a4cc g     F .text	00000028 vEvtChangeFeeControllerMode
8110f37c g     F .text	00000968 vPrintConsoleNFee
81110fa8 g     F .text	000000c8 bSendCmdQToNFeeInst
81106a98 g     F .text	00000040 vRmapCh7HandleIrq
8113c45c g     F .text	000001ec OSTaskCreateExt
81163180 g     O .bss	00000011 alt_log_write_buf
811049c8 g     F .text	0000012c bDpktGetPacketConfig
81107228 g     F .text	00000050 uliRmapCh8WriteCmdAddress
81118ea0 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112c2e8 g     F .text	00001244 ___svfiprintf_internal_r
81112a7c g     F .text	00000364 bPreParserV2
81138010 g     F .text	00000068 OSFlagPendGetFlagsRdy
8114f626 g     O .rwdata	00000002 OSTaskStatStkSize
8113715c g     F .text	00000310 OSFlagAccept
8113a738 g     F .text	000000c0 OSQFlush
8114febc g     O .bss	00000118 xRmap
8113a1b4 g     F .text	00000148 OSQAccept
8114f78c g     O .bss	00000004 alt_argv
81157578 g       *ABS*	00000000 _gp
811187ac g     F .text	0000004c vFailSendPreAckReceiverSemaphore
811348ec g     F .text	0000013c usleep
81142108 g     F .text	00000384 alt_up_sd_card_fopen
8111b5fc g     F .text	00000030 bSDcardIsPresent
81112de0 g     F .text	00000178 vSenderComTask
81141c70 g     F .text	000000d8 alt_up_sd_card_find_first
8113c2a8 g     F .text	000001b4 OSTaskCreate
81119040 g     F .text	00000068 vFailSendNack
8114f830 g     O .bss	00000004 command_argument_register
8113bdb0 g     F .text	000004f8 OSTaskChangePrio
81113460 g     F .text	000000ac vPusMebInTaskConfigMode
811197b8 g     F .text	00000088 vCouldNotSendTMPusCommand
8114f7a8 g     O .bss	00000004 alt_heapsem
8111aa24 g     F .text	000000b0 vResetMemCCDFEE
8110a9b0 g     F .text	00000080 bSetBoardLeds
81136f64 g     F .text	000001f8 OSDebugInit
8113c648 g     F .text	0000034c OSTaskDel
81139064 g     F .text	000001ac OSMutexAccept
81155524 g     O .bss	000002b8 xSimMeb
8111adc0 g     F .text	00000040 vSetTimeCode
81146468 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
8114f704 g     O .bss	00000004 xSemCountPreParsed
8114e12c g     O .rwdata	00000180 alt_fd_list
811056b0 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
8114e2c8 g     O .rwdata	0000001d alt_log_msg_alt_main
811631bc g     O .bss	00000840 OSFlagTbl
81106d38 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
81118914 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
81107138 g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111b1ac g     F .text	0000003c vLoadDefaultRTValue
81136194 g     F .text	000000c0 OS_EventTaskRemove
811557dc g     O .bss	00001000 vFeeTask5_stk
8114f77a g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
81141384 g     F .text	00000134 find_first_empty_record_in_root_directory
81146f28 g     F .text	00000098 alt_find_dev
8111e6c4 g     F .text	00000150 memcpy
8112fb44 g     F .text	00000264 __hexnan
81104dc4 g     F .text	00000174 bDpktInitCh
811567dc g     O .bss	00000160 xBuffer32
8114f610 g     O .rwdata	00000002 OSRdyTblSize
811639fc g     O .bss	000001a0 OSTmrTbl
8112712c g     F .text	0000000c _cleanup_r
81132ce4 g     F .text	000000e4 .hidden __floatsidf
81117288 g     F .text	000001a8 vSendPusTM64
8110c438 g     F .text	0000004c ucSyncStatusErrorCode
81113ed4 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111ac80 g     F .text	00000034 cFeeRMAPLogDisable
81111368 g     F .text	00000df0 vParserCommTask
81147548 g     F .text	00000084 alt_io_redirect
8111ac14 g     F .text	00000034 cFeeRMAPEchoingDisable
8113226c g     F .text	000000f4 .hidden __ltdf2
81119df8 g     F .text	0000004c vFailSendPUStoMebTask
81106f48 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
8110602c g     F .text	000000d4 bFeebSetIrqControl
811195b0 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
8114f708 g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
8114f66c g     O .bss	00000004 EDpktMode
811468f0 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81146c38 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110c98c g     F .text	00000054 bSyncCtrErrInj
81146b98 g     F .text	0000005c alt_msgdma_register_callback
81118034 g     F .text	00000330 vShowEthConfig
8111af54 g     F .text	00000030 bLogWriteSDCard
81118c30 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
8111ec60 g     F .text	00000014 puts
8111b810 g     F .text	00000270 bInitSync
81147c58 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110c128 g     F .text	0000016c vSyncHandleIrq
81134ea8 g     F .text	00000128 OSEventNameGet
81105374 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8114f5f4 g     O .rwdata	00000002 OSFlagMax
81128524 g     F .text	000000e0 mbrtowc
81140f7c g     F .text	000001b4 find_first_empty_cluster
81113ff0 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110cc24 g     F .text	00000074 bSyncCtrCh5OutEnable
8114f6c0 g     O .bss	00000001 vucN
81129f24 g     F .text	00000074 __fpclassifyd
8110c398 g     F .text	00000054 bSyncStatusExtnIrq
81125200 g     F .text	00000054 _vfscanf_r
811396e4 g     F .text	000005a4 OSMutexPend
81129724 g     F .text	000000ac __ratio
81141a6c g     F .text	000000c4 alt_up_sd_card_open_dev
81119840 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81135764 g     F .text	00000100 OSIntExit
8110c508 g     F .text	00000040 bSyncSetBt
8112ed3c g     F .text	0000001c __vfiprintf_internal
81119ef8 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
8114f62e g     O .rwdata	00000002 OSTCBSize
81105330 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
8114f7c3 g     O .bss	00000001 OSPrioCur
8114399c g     F .text	000002c4 altera_avalon_jtag_uart_read
81146130 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8111e9a4 g     F .text	00000038 _printf_r
81130cac g     F .text	00000064 .hidden __udivsi3
811333e8 g     F .text	000000ac isatty
8114f6b8 g     O .bss	00000001 LedsBoardControl
8114f70c g     O .bss	00000004 xSemCountReceivedACK
8114f614 g     O .rwdata	00000002 OSStkWidth
811282f4 g     F .text	00000030 iswspace
8114cf50 g     O .rodata	000000c8 __mprec_tens
8114f608 g     O .rwdata	00000002 OSPtrSize
8111a194 g     F .text	00000054 vFailSendRMAPFromIRQ
81119c60 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
811283a8 g     F .text	0000000c __locale_charset
8110cb3c g     F .text	00000074 bSyncCtrCh3OutEnable
81130e9c g     F .text	000000c8 .hidden __lesf2
8114f5e8 g     O .rwdata	00000002 OSEventTblSize
81130078 g     F .text	0000007c .hidden __fixunsdfsi
81147870 g       .text	00000000 OSCtxSw
8110a4a4 g     F .text	00000160 I2C_MultipleRead
81133f2c g     F .text	00000074 alt_log_system_clock
8114f760 g     O .bss	00000004 __malloc_top_pad
8114f7c4 g     O .bss	00000004 OSTCBList
8113e4ac g     F .text	00000040 OSTmrSignal
8114f770 g     O .bss	00000004 alt_fd_list_lock
8112be14 g     F .text	0000001c strtoul
8114f598 g     O .rwdata	00000004 __mb_cur_max
811283d8 g     F .text	0000000c _localeconv_r
8112be30 g     F .text	000002e0 _strtoull_r
8110bb6c g     F .text	00000070 vRstcHoldDeviceReset
81128d18 g     F .text	00000044 __i2b
81127c3c g     F .text	000004c4 __sfvwrite_r
8114025c g     F .text	000000c0 get_dir_divider_location
81106be4 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
81163b9c g     O .bss	00000c30 OSMemTbl
8114f7c8 g     O .bss	00000001 OSTickStepState
81133b3c g     F .text	00000060 alt_log_printf_proc
81104d00 g     F .text	000000c4 bDpktGetPixelDelay
8115693c g     O .bss	00001800 vReceiverUartTask_stk
8111ee6c g     F .text	0000005c _sbrk_r
8114f710 g     O .bss	00000004 xSemTimeoutChecker
8113ff1c g     F .text	000000cc filename_to_upper_case
8114f77c g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
8114f60c g     O .rwdata	00000002 OSQMax
8114248c g     F .text	00000090 alt_up_sd_card_set_attributes
811393e0 g     F .text	00000304 OSMutexDel
811647cc g     O .bss	00001000 OSTaskStatStk
8111b62c g     F .text	00000030 bSDcardFAT16Check
81138bac g     F .text	000000f8 OSMemNameGet
811185b4 g     F .text	00000060 vFailCreateMutexSResources
8113f288 g     F .text	00000284 Read_File_Record_At_Offset
8115813c g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8114f5ec g     O .rwdata	00000002 OSFlagEn
81129950 g     F .text	00000068 _read_r
8114f632 g     O .rwdata	00000002 OSTimeTickHookEn
8113882c g     F .text	000000ac OS_FlagUnlink
8113ac00 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
8114f5b4 g     O .rwdata	00000004 alt_max_fd
8111935c g     F .text	0000004c vFailTimeoutCheckerTaskCreate
811367d0 g     F .text	00000070 OS_MemCopy
81136840 g     F .text	000000d8 OS_Sched
81140b00 g     F .text	0000047c find_file_in_directory
8112eee8 g     F .text	000000f8 _fclose_r
81138ab4 g     F .text	000000f8 OSMemGet
8113cc8c g     F .text	000001bc OSTaskNameSet
811270f4 g     F .text	00000030 fflush
8114f75c g     O .bss	00000004 __malloc_max_sbrked_mem
8114f7cc g     O .bss	00000004 OSCtxSwCtr
81105c34 g     F .text	000000d4 bFeebCh6SetBufferSize
81147b5c g     F .text	00000054 OSTimeTickHook
8115817c g     O .bss	00001000 vOutAckHandlerTask_stk
8113321c g     F .text	00000188 alt_irq_register
8114f5f6 g     O .rwdata	00000002 OSFlagNameSize
8111d194 g     F .text	00000118 .hidden __extendsfdf2
81136254 g     F .text	00000108 OS_EventTaskRemoveMulti
81119980 g     F .text	00000070 vFailCreateNFEESyncQueue
81141bfc g     F .text	00000074 alt_up_sd_card_is_FAT16
8110a234 g     F .text	00000088 I2C_TestAdress
81130f64 g     F .text	000008b4 .hidden __adddf3
81163194 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81130d68 g     F .text	00000078 .hidden __nesf2
81106ba0 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
8113603c g     F .text	00000158 OS_EventTaskWaitMulti
8115917c g     O .bss	00000020 SyncTBL4
811294bc g     F .text	00000114 __b2d
81145e68 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
8114f60e g     O .rwdata	00000002 OSQSize
81130674 g     F .text	00000540 .hidden __umoddi3
81133fe4 g     F .text	000000dc lseek
8113b6f0 g     F .text	00000214 OSSemPend
81119e44 g     F .text	00000068 vCouldNotGetCmdQueueMeb
81107710 g     F .text	00000160 bRmapGetCodecStatus
81109bf8 g     F .text	000000d0 bSpwcGetLinkStatus
811063e8 g     F .text	00000088 bFeebGetWindowing
8114f588 g     O .rwdata	00000004 _global_impure_ptr
8110c0dc g     F .text	0000004c bSSDisplayUpdate
811405c0 g     F .text	00000540 get_home_directory_cluster_for_file
811299b8 g     F .text	0000056c _realloc_r
8114f5f8 g     O .rwdata	00000002 OSLowestPrio
81169898 g       *ABS*	00000000 __bss_end
81147384 g     F .text	000000f8 alt_iic_isr_register
81147c2c g     F .text	0000002c OSTCBInitHook
8114f63e g     O .rwdata	00000002 OSTmrCfgTicksPerSec
811347dc g     F .text	00000110 alt_tick
81107278 g     F .text	0000017c vRmapInitIrq
811188ac g     F .text	00000068 vFailGetMutexSenderTask
8110ba8c g     F .text	0000006c vRstcSimucamReset
8110f234 g     F .text	000000a4 bSendRequestNFeeCtrl
8114d0b8 g     O .rodata	00000100 __hexdig
811469e4 g     F .text	000001b4 alt_msgdma_init
811300f4 g     F .text	00000580 .hidden __udivdi3
81112764 g     F .text	0000017c setPreAckSenderFreePos
8112f160 g     F .text	00000024 _fputwc_r
8114f5e0 g     O .rwdata	00000002 OSEventEn
8114cf28 g     O .rodata	00000028 __mprec_bigtens
81128af4 g     F .text	0000010c __s2b
8114f63a g     O .rwdata	00000002 OSTmrCfgNameSize
8115919c g     O .bss	00000020 xFeeQueueTBL4
8110c5c8 g     F .text	00000074 bSyncSetPolarity
81114edc g     F .text	0000028c vCheckRetransmission64
81132dc8 g     F .text	000000b0 .hidden __floatunsidf
8114f780 g     O .bss	00000004 alt_system_clock_in_sec
81133d34 g     F .text	00000054 alt_log_jtag_uart_startup_info
81118e38 g     F .text	00000068 vFailFoundBufferRetransmission
811291f4 g     F .text	00000060 __mcmp
8114f848 g     O .bss	00000004 current_sector_index
8114415c g     F .text	00000168 altera_avalon_uart_init
81146cc0 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
8110409c g     F .text	00000414 bSdmaDmaM2Transfer
8111ae00 g     F .text	00000034 vResetTimeCode
8111ab58 g     F .text	0000002c cFeeSpwChannelEnable
811274ac g     F .text	00000018 __fp_lock_all
8111a328 g     F .text	0000004c vFailSendMsgDataCTRL
81147330 g     F .text	00000054 alt_ic_irq_enabled
8110a2bc g     F .text	000000e0 I2C_Write
81106de8 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
8114f7d0 g     O .bss	00000002 OSTmrFree
81138648 g     F .text	000000e8 OS_FlagInit
81134738 g     F .text	000000a4 alt_alarm_stop
8111f4d4 g     F .text	0000001c strtol
8114f779 g     O .bss	00000001 alt_log_sys_clk_on_flag
8113dc58 g     F .text	00000140 OSTmrDel
8113eff4 g     F .text	000000e8 mark_cluster
8114f61c g     O .rwdata	00000002 OSTaskIdleStkSize
8114f774 g     O .bss	00000004 alt_irq_active
8113b310 g     F .text	000000b8 OSSemAccept
8111d710 g     F .text	0000044c _fseeko_r
81115d40 g     F .text	00000260 vFillMemmoryPattern
8111f250 g     F .text	00000044 strnlen
81138dc0 g     F .text	000000e0 OSMemPut
811388d8 g     F .text	000001dc OSMemCreate
8114f7d4 g     O .bss	00000004 OSIdleCtrMax
81117430 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81133584 g     F .text	000005b8 alt_log_private_printf
8114e104 g     O .rwdata	00000028 alt_dev_null
81145a78 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110c588 g     F .text	00000040 bSyncSetOst
8114f630 g     O .rwdata	00000002 OSTicksPerSec
8114e2ac g     O .rwdata	00000019 alt_log_msg_bss
811414b8 g     F .text	00000194 convert_filename_to_name_extension
81108024 g     F .text	00000c4c bRmapSetRmapMemHKArea
81112f58 g     F .text	000003ac vSimMebTask
8110a604 g     F .text	00000094 i2c_start
81147870 g       .text	00000000 OSIntCtxSw
8111a1e8 g     F .text	00000054 vFailSendMsgSync
8110cbb0 g     F .text	00000074 bSyncCtrCh4OutEnable
8114685c g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
811330c4 g     F .text	00000028 alt_dcache_flush_all
81128c00 g     F .text	00000068 __hi0bits
81113928 g     F .text	00000114 vPusType251run
81107188 g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111b1e8 g     F .text	0000003c vChangeRTValue
8114f81c g     O .bss	00000004 is_sd_card_formated_as_FAT16
81114ad4 g     F .text	00000184 vCheck
8111a51c g     F .text	00000050 vNFeeNotInUse
81132c64 g     F .text	00000080 .hidden __fixdfsi
81105ddc g     F .text	000000d4 bFeebCh8SetBufferSize
811064f8 g     F .text	00000088 bFeebStopCh
81110998 g     F .text	0000041c vNFeeControlTask
811591bc g     O .bss	00001000 vInitialTask_stk
8114f714 g     O .bss	00000002 usiIdCMD
8115a1bc g     O .bss	00000020 SyncTBL3
8110c890 g     F .text	00000054 bSyncCtrStart
81141130 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8112b7b8 g     F .text	00000018 strtod
81106580 g     F .text	00000088 bFeebClrCh
8114f7d8 g     O .bss	00000004 OSTCBFreeList
81106ef0 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113b904 g     F .text	00000174 OSSemPendAbort
81118a4c g     F .text	0000004c vFailGetMacRTC
811070e8 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
811192c4 g     F .text	0000004c vFailCreateTimerRetransmisison
81118dd0 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
811162f8 g     F .text	000002f0 bSendUART128v2
8111b01c g     F .text	000000ec vSimucamStructureInit
8114f5ac g     O .rwdata	00000008 alt_dev_list
8111d640 g     F .text	0000004c _fputc_r
81134a6c g     F .text	0000010c write
8111ea20 g     F .text	000000a8 _putc_r
8114f840 g     O .bss	00000004 device_pointer
8114f634 g     O .rwdata	00000002 OSVersionNbr
81130de0 g     F .text	000000bc .hidden __gtsf2
8111a40c g     F .text	0000004c vFailFlushMEBQueue
81112158 g     F .text	00000118 getPreParsedPacket
8110f0ec g     F .text	00000060 bEnableSPWChannel
81133164 g     F .text	000000b8 fstat
8111ae68 g     F .text	00000040 vChangeIdNFEEMaster
8111d614 g     F .text	0000002c fprintf
8111ac48 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105708 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
81119410 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111bba8 g     F .text	00000058 _reg_write
8111aea8 g     F .text	00000034 vChangeDefaultIdNFEEMaster
8113226c g     F .text	000000f4 .hidden __ledf2
81106a18 g     F .text	00000040 vRmapCh5HandleIrq
8110efc4 g     F .text	00000054 bDisableRmapIRQ
8115a1dc g     O .bss	00001000 vStackMonitor_stk
81119750 g     F .text	00000068 vCouldNotSendLog
8113ded8 g     F .text	000001b8 OSTmrRemainGet
8114f5dc g     O .rwdata	00000004 OSEndiannessTest
8110bc80 g     F .text	00000058 v_spi_start
81128f5c g     F .text	00000148 __pow5mult
81107048 g     F .text	00000050 uliRmapCh2WriteCmdAddress
8112d8d8 g     F .text	00001464 ___vfiprintf_internal_r
8114f76c g     O .bss	00000004 __nlocale_changed
81130d10 g     F .text	00000058 .hidden __umodsi3
8110c9e0 g     F .text	00000074 bSyncCtrSyncOutEnable
8111b65c g     F .text	000000f8 bInitializeSDCard
811191e0 g     F .text	0000004c vFailParserCommTaskCreate
811196e8 g     F .text	00000068 vCouldNotSendReset
8111ef0c g     F .text	00000038 _scanf_r
81119278 g     F .text	0000004c vFailOutAckHandlerTaskCreate
8114f5ee g     O .rwdata	00000002 OSFlagGrpSize
8111350c g     F .text	0000008c vPusType250conf
8115b1dc g     O .bss	00000058 xInUseRetrans
8110c348 g     F .text	00000050 bSyncIrqFlagSync
81145ec8 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8113e090 g     F .text	000000ec OSTmrStateGet
81169898 g       *ABS*	00000000 end
8110522c g     F .text	00000084 vFeebCh6HandleIrq
81115fa0 g     F .text	00000260 vPrintMemmoryPattern
81118f70 g     F .text	00000068 vNoContentInPreParsedBuffer
8111db5c g     F .text	0000001c fseeko
81112270 g     F .text	00000168 bSendMessagePUStoMebTask
81119910 g     F .text	00000070 vFailCreateNFEEQueue
8111d4c4 g     F .text	0000000c _atoi_r
811449a8 g     F .text	00000240 altera_avalon_uart_write
811334c8 g     F .text	00000054 alt_log_txchar
8111d6f4 g     F .text	0000001c fseek
81116268 g     F .text	00000090 vCCDChangeValues
8114329c g     F .text	000001d0 altera_avalon_jtag_uart_init
81136ad0 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
811186ac g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
81143fb0 g     F .text	00000084 alt_avalon_timer_sc_init
81106340 g     F .text	000000a8 bFeebSetWindowing
8114409c g     F .text	00000068 altera_avalon_uart_write_fd
8111d454 g     F .text	00000064 .hidden __clzsi2
81144104 g     F .text	00000058 altera_avalon_uart_close_fd
8115b234 g     O .bss	00000020 xMebQTBL
81143c60 g     F .text	000002cc altera_avalon_jtag_uart_write
8113e604 g     F .text	00000174 OSTmr_Init
8115b254 g     O .bss	00000348 xBuffer128
8112749c g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
811286b4 g     F .text	000000e4 memchr
81136774 g     F .text	0000005c OS_MemClr
811216d0 g     F .text	00002200 ___vfprintf_internal_r
81147950 g     F .text	00000164 OSTaskStkInit
8111ef44 g     F .text	00000060 _sprintf_r
81107cbc g     F .text	000002d4 bRmapGetMemConfigArea
8114f716 g     O .bss	00000001 SemCount32
81127924 g     F .text	00000318 _free_r
811475cc g     F .text	00000234 alt_printf
81117238 g     F .text	00000050 vTimeoutCheck
8111bc58 g     F .text	000001fc _print_codec_status
811283b4 g     F .text	00000010 __locale_mb_cur_max
81135d84 g     F .text	000001a0 OS_EventTaskRdy
81107524 g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
81147ea4 g     F .text	00000188 __call_exitprocs
81110e7c g     F .text	0000012c vPerformActionNFCRunning
8114f7dc g     O .bss	00000001 OSCPUUsage
81119b90 g     F .text	00000068 vCoudlNotCreateNFee4Task
8114f768 g     O .bss	00000004 __mlocale_changed
81110db4 g     F .text	000000c8 vPerformActionNFCConfig
8110c938 g     F .text	00000054 bSyncCtrOneShot
8114f590 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110d0b0 g     F .text	0000003c uliSyncReadStatus
8114f794 g     O .bss	00000004 _alt_tick_rate
8113a7f8 g     F .text	00000294 OSQPend
8112b8d8 g     F .text	000002e8 _strtoll_r
8115b59c g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8113d57c g     F .text	0000010c OSTimeDly
811137f0 g     F .text	000000ac vPusMebInTaskRunningMode
8110c30c g     F .text	0000003c vSyncIrqFlagClrSync
811290a4 g     F .text	00000150 __lshift
81111070 g     F .text	000002f8 vOutAckHandlerTask
81145920 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8114f798 g     O .bss	00000004 _alt_nticks
811344cc g     F .text	00000104 read
8113ec58 g     F .text	000000f0 alt_sys_init
8111c850 g     F .text	0000012c .hidden __floatsisf
81106b5c g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112c110 g     F .text	000001d8 __ssprint_r
8111e93c g     F .text	00000068 _open_r
8111bb20 g     F .text	00000088 bTestSimucamCriticalHW
81106234 g     F .text	0000010c bFeebGetBuffersStatus
81118364 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
8114f7dd g     O .bss	00000001 OSTaskCtr
81133494 g       .text	00000000 tx_log_str
81113304 g     F .text	0000015c vPusMebTask
811171e8 g     F .text	00000050 siPosStr
81113e4c g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
8112fda8 g     F .text	000000d0 strncmp
8110d0ec g     F .text	0000005c bSyncWriteReg
81106e98 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
8113d688 g     F .text	00000164 OSTimeDlyHMSM
81128d5c g     F .text	00000200 __multiply
81143834 g     F .text	00000070 altera_avalon_jtag_uart_close
8110be50 g     F .text	00000058 v_spi_end
8111b7d0 g     F .text	00000040 cGetNextChar
81147db8 g     F .text	000000ec strncpy
8114f994 g     O .bss	00000028 __malloc_current_mallinfo
8114f5e2 g     O .rwdata	00000002 OSEventMax
81130d68 g     F .text	00000078 .hidden __eqsf2
811295d0 g     F .text	00000154 __d2b
8113ba78 g     F .text	00000118 OSSemPost
811053fc g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111b224 g     F .text	00000030 vChangeDefaultRTValue
811052f0 g     F .text	00000040 vFeebCh8HandleIrq
8114f818 g     O .bss	00000004 initialized
81117098 g     F .text	00000100 vSendLog
811358f8 g     F .text	000000e4 OSSchedUnlock
8110bea8 g     F .text	00000164 RTCC_SPI_R_MAC
8114f5c0 g     O .rwdata	00000004 alt_log_boot_on_flag
81143118 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112bbc0 g     F .text	00000254 _strtoul_r
8115b5dc g     O .bss	00000020 xFeeQueueTBL5
811470d0 g     F .text	000000e4 alt_get_fd
8114f7e0 g     O .bss	00000004 OSMemFreeList
81135a54 g     F .text	000000b8 OSStatInit
8111baec g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
81169230 g     O .bss	00000014 search_data
811098ec g     F .text	00000134 bSpwcSetLink
81132e78 g     F .text	00000130 alt_busy_sleep
81138414 g     F .text	000000cc OSFlagQuery
8110ca54 g     F .text	00000074 bSyncCtrCh1OutEnable
8114f618 g     O .rwdata	00000002 OSTaskCreateExtEn
8111be54 g     F .text	00000074 _split_codec_status
81125578 g     F .text	0000005c _close_r
81118fd8 g     F .text	00000068 vCouldNotSendEthConfUART
81110414 g     F .text	00000584 vInitialTask
81133c3c g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
81145e08 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81147d3c g     F .text	0000007c memcmp
81135d5c g     F .text	00000028 OS_Dummy
811431e8 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
81169898 g       *ABS*	00000000 __alt_stack_base
81105d08 g     F .text	000000d4 bFeebCh7SetBufferSize
81143240 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105440 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8111dbdc g     F .text	000000d4 _fwrite_r
811141e8 g     F .text	000000a4 vReleaseSyncMessages
81145f28 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105550 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
8112541c g     F .text	0000015c __swsetup_r
811657cc g     O .bss	00000300 OSQTbl
81119fc8 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
81163164 g     O .bss	0000001c xConfEth
81131818 g     F .text	000008f0 .hidden __divdf3
8111b288 g     F .text	0000003c vChangeSyncSource
81127354 g     F .text	00000120 __sfp
81169244 g     O .bss	00000054 boot_sector_data
81119f60 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
81109d58 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112984c g     F .text	00000078 __copybits
8114dc84 g     O .rwdata	00000408 __malloc_av_
811274a8 g     F .text	00000004 __sinit_lock_release
8114f654 g     O .bss	00000004 uliInitialState
8110a698 g     F .text	00000080 i2c_stop
8111bf6c g     F .text	00000064 Verif_Error
8111bfd0 g     F .text	00000034 toInt
811187f8 g     F .text	0000004c vFailSendPreAckSenderSemaphore
8114f7e4 g     O .bss	00000004 OSTCBHighRdy
8111ca74 g     F .text	00000720 .hidden __muldf3
8111f018 g     F .text	0000005c __sread
811277bc g     F .text	0000003c fread
8114f7e8 g     O .bss	00000004 OSQFreeList
81146fc0 g     F .text	00000110 alt_find_file
81146e7c g     F .text	000000ac alt_dev_llist_insert
81134cac g     F .text	00000128 __malloc_lock
8111d5e4 g     F .text	00000030 _fprintf_r
8113463c g     F .text	000000fc sbrk
8111aad4 g     F .text	0000002c vFeeSpwRMAPLoadDefault
81118d68 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
8111f4f0 g     F .text	000021e0 ___svfprintf_internal_r
811175d8 g     F .text	00000088 vTMPusTestConnection
8114f718 g     O .bss	00000004 xMebQ
81134fd0 g     F .text	00000148 OSEventNameSet
81127090 g     F .text	00000064 _fflush_r
8112ee1c g     F .text	000000cc _calloc_r
8114f7ec g     O .bss	00000001 OSRdyGrp
8111a2dc g     F .text	0000004c vFailSendMsgFeeCTRL
8110c484 g     F .text	00000044 ucSyncStatusCycleNumber
81107684 g     F .text	0000008c bRmapGetCodecConfig
8113e17c g     F .text	00000148 OSTmrStart
811051a8 g     F .text	00000084 vFeebCh5HandleIrq
8111d5cc g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8114f654 g       *ABS*	00000000 __bss_start
81105a8c g     F .text	000000d4 bFeebCh4SetBufferSize
8111e814 g     F .text	00000128 memset
81112628 g     F .text	0000013c setPreParsedFreePos
8110e4c0 g     F .text	000001bc vQCmdFEEinStandBy
81146984 g     F .text	00000060 alt_msgdma_open
8111b3e0 g     F .text	0000021c pattern_createPattern
81115bb4 g     F .text	0000018c main
8111897c g     F .text	00000068 vFailGetMutexReceiverTask
8115b5fc g     O .bss	00001000 vNFeeControlTask_stk
81106cf4 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111b140 g     F .text	0000003c vChangeEPValue
81106e40 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
8114f790 g     O .bss	00000004 alt_envp
8111a374 g     F .text	0000004c vFailFlushQueue
8114f758 g     O .bss	00000004 __malloc_max_total_mem
81146228 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
81118408 g     F .text	0000005c ucCrc8wInit
81119310 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
81143180 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110a850 g     F .text	00000160 i2c_read
8115c5fc g     O .bss	00000020 SyncTBL5
8112539c g     F .text	00000018 __swbuf
8114d3b8 g     O .rodata	00000100 OSUnMapTbl
81130e9c g     F .text	000000c8 .hidden __ltsf2
8114251c g     F .text	00000090 alt_up_sd_card_get_attributes
81127588 g     F .text	00000234 _fread_r
81118844 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
8110a044 g     F .text	0000003c bDisableIsoDrivers
8114f612 g     O .rwdata	00000002 OSSemEn
8113ed48 g     F .text	000000bc Write_Sector_Data
8114292c g     F .text	00000628 alt_up_sd_card_write
8114f71c g     O .bss	00000004 xFeeQ
81138078 g     F .text	0000039c OSFlagPost
8111f164 g     F .text	00000008 __sclose
81119618 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
8112efe0 g     F .text	00000014 fclose
81135f24 g     F .text	00000118 OS_EventTaskWait
811194e0 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
8111f294 g     F .text	00000240 _strtol_r
8111d2ac g     F .text	000001a8 .hidden __truncdfsf2
8115c61c g     O .bss	00000020 xFeeQueueTBL2
81136bb4 g     F .text	000000d4 OS_TaskStatStkChk
8113c994 g     F .text	00000158 OSTaskDelReq
81104af4 g     F .text	000000c4 bDpktGetPacketHeader
81106830 g     F .text	00000128 vRmapCh1HandleIrq
811257dc g     F .text	00001690 _dtoa_r
81146544 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
8111deb0 g     F .text	00000814 _malloc_r
8115c63c g     O .bss	00000020 SyncTBL0
8112ffe4 g     F .text	00000030 __ascii_wctomb
81139210 g     F .text	000001d0 OSMutexCreate
81119478 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
811102c8 g     F .text	0000014c bCheckInAck32
8114f5b8 g     O .rwdata	00000004 alt_errno
81146070 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
811359dc g     F .text	00000078 OSStart
81109a20 g     F .text	000000e4 bSpwcGetLink
8110b5a4 g     F .text	000004e8 POWER_SPI_RW
8112d52c g     F .text	000000dc __submore
81133b9c g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81134c44 g     F .text	00000068 __env_unlock
81119a58 g     F .text	00000068 vCoudlNotCreateNFee1Task
81128100 g     F .text	000000cc _fwalk
8113ce48 g     F .text	000001dc OSTaskResume
81138ea0 g     F .text	000000f0 OSMemQuery
8114f624 g     O .rwdata	00000002 OSTaskStatEn
81169898 g       *ABS*	00000000 __alt_stack_limit
8114f670 g     O .bss	00000004 ECommSpwCh
8111b32c g     F .text	0000003c vChangeAutoResetSync
81128650 g     F .text	00000064 _mbtowc_r
8110fce4 g     F .text	00000350 vInAckHandlerTaskV2
8114f5fe g     O .rwdata	00000002 OSMemMax
8113ad70 g     F .text	00000178 OSQPostFront
8111eac8 g     F .text	000000d0 putc
81130bb4 g     F .text	00000084 .hidden __divsi3
8114f7ed g     O .bss	00000006 OSRdyTbl
8114f5d8 g     O .rwdata	00000002 OSDebugEn
8114e31c g     O .rwdata	0000002a alt_log_msg_cache
811277f8 g     F .text	0000012c _malloc_trim_r
8110943c g     F .text	000001a4 bRmapInitCh
8114f74c g     O .bss	00000008 xSdHandle
8111c44c g     F .text	00000404 .hidden __mulsf3
8114f5f0 g     O .rwdata	00000002 OSFlagNodeSize
8114f658 g     O .bss	00000004 pnt_memory
8111b398 g     F .text	00000048 vSyncReset
8110c548 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
8114f824 g     O .bss	00000004 status_register
8114f638 g     O .rwdata	00000002 OSTmrCfgMax
8110cedc g     F .text	00000074 bSyncIrqFlagClrError
811190a8 g     F .text	00000068 vFailSetPreAckSenderBuffer
8112a070 g     F .text	000000dc strcmp
8114f82c g     O .bss	00000004 command_register
8113a2fc g     F .text	000001b4 OSQCreate
8113caec g     F .text	000001a0 OSTaskNameGet
8115c65c g     O .bss	00001000 vFeeTask4_stk
8115d65c g     O .bss	00000018 xReceivedACK
8113aee8 g     F .text	00000214 OSQPostOpt
81135b0c g     F .text	00000228 OSTimeTick
8114f620 g     O .rwdata	00000002 OSTaskMax
8113b3c8 g     F .text	000000e0 OSSemCreate
8114f644 g     O .rwdata	00000002 OSTmrWheelSize
811198a8 g     F .text	00000068 vFailCreateScheduleQueue
8111bc00 g     F .text	00000058 _reg_read
81139ea8 g     F .text	00000174 OSMutexQuery
8110f2d8 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81132108 g     F .text	00000088 .hidden __nedf2
8114f61a g     O .rwdata	00000002 OSTaskDelEn
8111b108 g     F .text	00000038 vLoadDefaultEPValue
8115d674 g     O .bss	00001000 vFeeTask1_stk
8110cd0c g     F .text	00000074 bSyncCtrCh7OutEnable
8113bb90 g     F .text	00000118 OSSemQuery
8113a4b0 g     F .text	00000288 OSQDel
8113aa8c g     F .text	00000174 OSQPendAbort
8114f720 g     O .bss	00000004 xMutexPreParsed
8113ec18 g     F .text	00000040 alt_irq_init
811345d0 g     F .text	0000006c alt_release_fd
8113ef38 g     F .text	000000bc get_cluster_flag
8110cf50 g     F .text	00000074 bSyncIrqFlagClrBlank
81146c7c g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110c294 g     F .text	0000002c vSyncClearCounter
8114e2e8 g     O .rwdata	00000031 alt_log_msg_stackpointer
8111efa4 g     F .text	00000074 sprintf
8114caa0 g     O .rodata	00000100 .hidden __clz_tab
8113f50c g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
811189e4 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
8114f764 g     O .bss	00000004 _PathLocale
8110d01c g     F .text	00000058 bSyncIrqFlagBlank
8110b45c g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113e2c4 g     F .text	000001e8 OSTmrStop
81109634 g     F .text	00000050 uliRmapReadReg
81117198 g     F .text	00000050 usiGetIdCMD
8110d148 g     F .text	00000058 uliSyncReadReg
8112b7d0 g     F .text	00000108 strtof
811050a0 g     F .text	00000084 vFeebCh3HandleIrq
81130de0 g     F .text	000000bc .hidden __gesf2
8111f16c g     F .text	0000004c strcspn
811253b4 g     F .text	00000068 _write_r
8110baf8 g     F .text	00000074 vRstcReleaseDeviceReset
8111922c g     F .text	0000004c vFailInAckHandlerTaskCreate
81135864 g     F .text	00000094 OSSchedLock
81119b28 g     F .text	00000068 vCoudlNotCreateNFee3Task
811283e4 g     F .text	00000018 setlocale
81145fd0 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
81165acc g     O .bss	00000800 OSTmrTaskStk
8111eec8 g     F .text	00000044 scanf
81119d98 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
8113746c g     F .text	00000110 OSFlagCreate
8113f7a0 g     F .text	00000688 Check_for_DOS_FAT
81114078 g     F .text	00000064 vMebInit
8114164c g     F .text	000002d0 create_file
8112a068 g     F .text	00000008 nanf
8114f58c g     O .rwdata	00000004 _impure_ptr
8114f828 g     O .bss	00000004 CSD_register_w0
8114f788 g     O .bss	00000004 alt_argc
81118d00 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
81126e6c g     F .text	00000224 __sflush_r
81128470 g     F .text	000000b4 _mbrtowc_r
81109cc8 g     F .text	00000090 bSpwcGetTimecode
811283d0 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
8114f664 g     O .bss	00000004 ESdmaBufferSide
8114f5ea g     O .rwdata	00000002 OSEventMultiEn
8111d6f0 g     F .text	00000004 _fseek_r
8115e674 g     O .bss	00001800 vParserCommTask_stk
81118544 g     F .text	00000070 printErrorTask
8111b17c g     F .text	00000030 vChangeDefaultEPValue
81115168 g     F .text	000002c8 vCheckRetransmission32
8113da94 g     F .text	000001c4 OSTmrCreate
8111428c g     F .text	000007dc vStackMonitor
8111ec90 g     F .text	000001dc __srefill_r
8110a080 g     F .text	0000003c bEnableLvdsBoard
8114f724 g     O .bss	00000004 xMutexBuffer32
81106958 g     F .text	00000040 vRmapCh2HandleIrq
8113757c g     F .text	00000250 OSFlagDel
8114f7f4 g     O .bss	00000004 OSEventFreeList
8110a0f8 g     F .text	000000c0 bSetPreEmphasys
8110e310 g     F .text	000001b0 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
81128604 g     F .text	0000004c __ascii_mbtowc
8110c818 g     F .text	00000078 bSyncCtrExtnIrq
81129458 g     F .text	00000064 __ulp
8111acb4 g     F .text	0000010c vNFeeControlInit
811140dc g     F .text	0000010c vSwapMemmory
81137a50 g     F .text	000005c0 OSFlagPend
8114f636 g     O .rwdata	00000002 OSTmrEn
811274c4 g     F .text	00000018 __fp_unlock_all
8115fe74 g     O .bss	00000010 xDma
8111d68c g     F .text	00000064 fputc
8110f018 g     F .text	00000074 bEnableRmapIRQ
811168e0 g     F .text	000002f8 bSendUART32v2
811128e0 g     F .text	0000019c setPreAckReceiverFreePos
8110c7d8 g     F .text	00000040 bSyncErrInj
8114f5a4 g     O .rwdata	00000008 alt_fs_list
8115fe84 g     O .bss	00001000 vSimMebTask_stk
81119d30 g     F .text	00000068 vCoudlNotCreateMebTask
8113ffe8 g     F .text	00000274 check_file_name_for_FAT16_compliance
81160e84 g     O .bss	00001000 vFeeTask3_stk
8113dd98 g     F .text	00000140 OSTmrNameGet
8114fabc g     O .bss	00000400 xSZData
8110e67c g     F .text	000001e0 vQCmdFEEinFullPattern
81136994 g     F .text	0000007c OS_StrCopy
8114f834 g     O .bss	00000004 buffer_memory
81118f08 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
8111af84 g     F .text	00000098 vLogWriteNUC
8114f600 g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110ce68 g     F .text	00000074 bSyncIrqEnableBlank
81147bdc g     F .text	00000028 OSInitHookEnd
8111a6e4 g     F .text	00000340 vUpdateMemMapFEE
81119178 g     F .text	00000068 vFailSetPreAckReceiverBuffer
811057b8 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
8114f62c g     O .rwdata	00000002 OSTCBPrioTblMax
811283fc g     F .text	0000000c localeconv
81119cc8 g     F .text	00000068 vCoudlNotCreateDataControllerTask
8114f728 g     O .bss	00000004 xTimerRetransmission
811123d8 g     F .text	00000250 vReceiverUartTask
8114f784 g     O .bss	00000004 alt_log_sys_clk_count
8114f628 g     O .rwdata	00000002 OSTaskStatStkChkEn
81133dec g     F .text	00000140 alt_log_write
81161e84 g     O .bss	00001000 vFeeTask2_stk
8114f72c g     O .bss	00000004 xMutexBuffer128
81104fdc g     F .text	00000040 vFeebCh1HandleIrq
8111ba80 g     F .text	0000003c bStartSync
811052b0 g     F .text	00000040 vFeebCh7HandleIrq
8111babc g     F .text	00000030 bStopSync
8114f674 g     O .bss	00000004 ECommBufferSide
811471b4 g     F .text	00000058 alt_ic_isr_register
8114f5fc g     O .rwdata	00000002 OSMemEn
81106998 g     F .text	00000040 vRmapCh3HandleIrq
8114f578 g     O .rwdata	00000004 alt_stack_limit_value
81113a3c g     F .text	00000388 vPusType252run
8111a290 g     F .text	0000004c vFailSendMsgMasterSyncMeb
8111dcb0 g     F .text	0000003c fwrite
8114f838 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8114f606 g     O .rwdata	00000002 OSMutexEn
8111a030 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
8114f654 g       *ABS*	00000000 _edata
81144034 g     F .text	00000068 altera_avalon_uart_read_fd
8111ae34 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81169898 g       *ABS*	00000000 _end
81169298 g     O .bss	00000500 active_files
8114f7f8 g     O .bss	00000001 OSIntNesting
81118a98 g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111abb0 g     F .text	0000002c cFeeRMAPDump
811059b8 g     F .text	000000d4 bFeebCh3SetBufferSize
8114f730 g     O .bss	00000004 xSemCountBuffer32
8112eff4 g     F .text	0000016c __fputwc
8114f734 g     O .bss	00000004 xQMaskFeeCtrl
8111ab00 g     F .text	0000002c vFeeSpwRMAPChangeConfig
81125174 g     F .text	00000070 vfscanf
8114191c g     F .text	00000150 copy_file_record_name_to_string
811438a4 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8113d7ec g     F .text	000001dc OSTimeDlyResume
8113fe28 g     F .text	000000f4 Look_for_FAT16
8110f08c g     F .text	00000060 bDisableSPWChannel
811378fc g     F .text	00000154 OSFlagNameSet
8110f1d0 g     F .text	00000064 bDisAndClrDbBuffer
8114f738 g     O .bss	00000004 xMutexBuffer64
81107870 g     F .text	00000160 bRmapGetCodecError
8113d024 g     F .text	000001c8 OSTaskStkChk
8114729c g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	0000040c bSdmaDmaM1Transfer
8114f602 g     O .rwdata	00000002 OSMemSize
811135ec g     F .text	00000204 vPusType252conf
81118bc8 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
8111f07c g     F .text	00000084 __swrite
8114f594 g     O .rwdata	00000004 __malloc_trim_threshold
811283c4 g     F .text	0000000c __locale_msgcharset
81162e84 g     O .bss	00000020 xFeeQueueTBL1
8114f7fc g     O .bss	00000004 OSTCBCur
81119548 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110b560 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
81147cfc g     F .text	00000040 exit
81139c88 g     F .text	00000220 OSMutexPost
8110cfc4 g     F .text	00000058 bSyncIrqFlagError
81141d48 g     F .text	000003c0 alt_up_sd_card_find_next
8114f604 g     O .rwdata	00000002 OSMemTblSize
811281cc g     F .text	000000cc _fwalk_reent
811463c8 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111c97c g     F .text	000000f8 .hidden __floatunsisf
81129254 g     F .text	00000204 __mdiff
811199f0 g     F .text	00000068 vCoudlNotCreateNFee0Task
81105eb0 g     F .text	0000017c vFeebInitIrq
8110479c g     F .text	0000022c bDpktSetPacketConfig
81118b30 g     F .text	0000004c vFailSenderCreate
81130c38 g     F .text	00000074 .hidden __modsi3
81119bf8 g     F .text	00000068 vCoudlNotCreateNFee5Task
8110c724 g     F .text	0000003c uliSyncGetPer
81106a58 g     F .text	00000040 vRmapCh6HandleIrq
8114f73c g     O .bss	00000004 xMutexSenderACK
811193a8 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
8114f584 g     O .rwdata	00000004 __ctype_ptr__
81119110 g     F .text	00000068 vFailSetPreParsedBuffer
8113ee58 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
811274a0 g     F .text	00000004 __sfp_lock_release
81106100 g     F .text	000000ac bFeebGetIrqControl
81119680 g     F .text	00000068 vCouldNotSendTurnOff
811356ac g     F .text	00000064 OSInit
8110aa30 g     F .text	00000078 bSetPainelLeds
81145b10 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8114f800 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
811079d0 g     F .text	000002ec bRmapSetMemConfigArea
8113d3d8 g     F .text	0000012c OSTaskQuery
8110cdf4 g     F .text	00000074 bSyncIrqEnableError
8114f740 g     O .bss	00000004 xMutexPus
8113b260 g     F .text	000000b0 OS_QInit
81129f98 g     F .text	000000d0 __sccl
8111d4b8 g     F .text	0000000c atoi
8110d240 g     F .text	000010d0 vFeeTask
81136a10 g     F .text	0000005c OS_StrLen
8111a458 g     F .text	0000004c vFailFlushNFEEQueue
811055a8 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
81118464 g     F .text	000000e0 vDataControllerInit
81138ca4 g     F .text	0000011c OSMemNameSet
8114cba0 g     O .rodata	00000101 _ctype_
8110c6e8 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
81118c98 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
8114f61e g     O .rwdata	00000002 OSTaskProfileEn
8111a4a4 g     F .text	00000028 vEvtChangeMebMode
811459e0 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8114f744 g     O .bss	00000004 xTxUARTMutex
8114f804 g     O .bss	00000004 OSTime
8114f59c g     O .rwdata	00000004 __mbtowc
81144654 g     F .text	0000005c altera_avalon_uart_close
8114f808 g     O .bss	00000004 OSTmrSem
81113598 g     F .text	00000054 vPusType251conf
811662cc g     O .bss	00001000 OSTaskIdleStk
8111d4d0 g     F .text	000000fc _fopen_r
8114f6e0 g     O .bss	00000004 pdata
8114802c g     F .text	000000bc _exit
81146d04 g     F .text	00000134 alt_alarm_start
811377cc g     F .text	00000130 OSFlagNameGet
8113d9c8 g     F .text	00000064 OSTimeGet
8114f668 g     O .bss	00000004 ESdmaChBufferId
811425ac g     F .text	00000380 alt_up_sd_card_read
81106c28 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8111dcec g     F .text	000001c4 __smakebuf_r
8114f748 g     O .bss	00000001 SemCount64
811165e8 g     F .text	000002f8 bSendUART64v2
8111a3c0 g     F .text	0000004c vFailFlushQueueData
81105658 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
8114f64c g     O .rwdata	00000008 alt_msgdma_list
8111f1b8 g     F .text	00000098 strlen
8110bd9c g     F .text	000000b4 uc_spi_get_byte
81106c6c g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111a098 g     F .text	00000054 vFailSendMsgAccessDMA
81147b0c g     F .text	00000028 OSTaskSwHook
8113432c g     F .text	0000015c open
81108c70 g     F .text	000007cc bRmapGetRmapMemHKArea
811672cc g     O .bss	00000d00 OSEventTbl
8111ab2c g     F .text	0000002c vFeeSpwRMAPChangeDefault
81132190 g     F .text	000000dc .hidden __gedf2
81162ea4 g     O .bss	00000020 xSenderACK
8111a23c g     F .text	00000054 vFailSendMsgSyncRMAPTRIGGER
81147800 g     F .text	00000044 alt_putchar
81167fcc g     O .bss	000011b8 OSTCBTbl
8112f30c g     F .text	00000838 __gethex
8113bca8 g     F .text	00000108 OSSemSet
81114a68 g     F .text	0000006c vTimeoutCheckerTaskv2
8111abdc g     F .text	00000038 cFeeRMAPEchoingEnable
8114f5a0 g     O .rwdata	00000004 __wctomb
811158a0 g     F .text	00000314 vVariablesInitialization
8112d8c0 g     F .text	00000018 __sprint_r
8110ed04 g     F .text	000002c0 vQCmdFeeRMAPinFullPattern
811061ac g     F .text	00000088 bFeebGetIrqFlags
8114f660 g     O .bss	00000004 pxDmaM2Dev
81118660 g     F .text	0000004c vFailCreateSemaphoreResources
8114f5bc g     O .rwdata	00000004 alt_priority_mask
8110a0bc g     F .text	0000003c bDisableLvdsBoard
8113b4a8 g     F .text	00000248 OSSemDel
811058e4 g     F .text	000000d4 bFeebCh2SetBufferSize
8114f80c g     O .bss	00000004 OSFlagFreeList
8110bcd8 g     F .text	000000c4 v_spi_send_byte
8110c00c g     F .text	000000d0 bSSDisplayConfig
8114720c g     F .text	00000090 alt_ic_irq_enable
8114f5e4 g     O .rwdata	00000002 OSEventNameSize
811238d0 g     F .text	0000001c __vfprintf_internal
8114f810 g     O .bss	00000001 OSStatRdy
8110cac8 g     F .text	00000074 bSyncCtrCh2OutEnable
81169184 g     O .bss	000000ac OSTCBPrioTbl
811446f4 g     F .text	00000270 altera_avalon_uart_read
81130014 g     F .text	00000064 _wctomb_r
81134b78 g     F .text	000000cc __env_lock
8114f62a g     O .rwdata	00000002 OSTaskSwHookEn
811053b8 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81132360 g     F .text	00000904 .hidden __subdf3
81162ec4 g     O .bss	00000260 xPreParsed
8110c760 g     F .text	0000003c uliSyncGetOst
8114ffd4 g     O .bss	00000118 RmapConfAreaL
8114f749 g     O .bss	00000001 SemCount128
81106ad8 g     F .text	00000040 vRmapCh8HandleIrq
81105484 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81116bd8 g     F .text	00000290 vSendEthConf
8110461c g     F .text	000000dc bCommInitCh
81128c68 g     F .text	000000b0 __lo0bits
811239b0 g     F .text	000017c4 __svfscanf_r
8114f5c8 g     O .rwdata	00000008 alt_alarm_list
8112d608 g     F .text	0000019c _ungetc_r
8114f5f2 g     O .rwdata	00000002 OSFlagWidth
81106b18 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
8112ff1c g     F .text	000000c8 wcrtomb
81104bb8 g     F .text	00000148 bDpktSetPixelDelay
81116200 g     F .text	00000068 vCCDLoadDefaultValues
81132fec g     F .text	000000d8 close
8110c79c g     F .text	0000003c uliSyncGetGeneral
8111a4f4 g     F .text	00000028 vEvtChangeDataControllerMode
8114f7a0 g     O .bss	00000004 alt_envsem
8113351c g     F .text	00000068 alt_log_repchar
8114f814 g     O .bss	00000004 OSIdleCtrRun
81135d34 g     F .text	00000028 OSVersion
8114f63c g     O .rwdata	00000002 OSTmrCfgWheelSize
8113d504 g     F .text	00000078 OS_TaskStkClr
8111b754 g     F .text	0000003c siOpenFile
8110d1a0 g     F .text	000000a0 vDataControlTask
8114f616 g     O .rwdata	00000002 OSTaskCreateEn
81106d90 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
811071d8 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81106470 g     F .text	00000088 bFeebStartCh
81116e68 g     F .text	00000118 vSendTurnOff
81118760 g     F .text	0000004c vFailSendPreParsedSemaphore
8114031c g     F .text	000002a4 match_file_record_to_name_ext
8113635c g     F .text	00000070 OS_EventWaitListInit
8112f184 g     F .text	00000088 fputwc
81163124 g     O .bss	00000020 xFeeQueueTBL0
811186f8 g     F .text	00000068 vFailSendxSemCommInit
81147c04 g     F .text	00000028 OSTaskIdleHook
81116f80 g     F .text	00000118 vSendReset
811274a4 g     F .text	00000004 __sinit_lock_acquire
811289cc g     F .text	00000128 __multadd
81163144 g     O .bss	00000020 SyncTBL1
811054c8 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110c3ec g     F .text	0000004c ucSyncStatusState
8113d1ec g     F .text	000001ec OSTaskSuspend
811289a4 g     F .text	00000028 _Bfree
8110c6ac g     F .text	0000003c uliSyncGetMbt
81136a6c g     F .text	00000064 OS_TaskIdle
8114f642 g     O .rwdata	00000002 OSTmrTblSize
8113b0fc g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	11357100 	call	81135710 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10a5e604 	addi	r2,r2,-26728
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10a5e604 	addi	r2,r2,-26728
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	11357640 	call	81135764 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b617 	ldw	r2,-32040(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b617 	ldw	r2,-32040(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	213d7004 	addi	r4,r4,-2624
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	2138c704 	addi	r4,r4,-7396
81100274:	11334940 	call	81133494 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	213d7004 	addi	r4,r4,-2624
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	2138ba04 	addi	r4,r4,-7448
81100290:	11334940 	call	81133494 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d69d5e14 	ori	gp,gp,30072
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	213d7004 	addi	r4,r4,-2624
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	2138ab04 	addi	r4,r4,-7508
811002bc:	11334940 	call	81133494 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	10bd9514 	ori	r2,r2,63060

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18e62614 	ori	r3,r3,39064

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	213d7004 	addi	r4,r4,-2624
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	2138b204 	addi	r4,r4,-7480
811002fc:	11334940 	call	81133494 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11340c00 	call	811340c0 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18fe6f04 	addi	r3,r3,-1604
81100330:	00a04574 	movhi	r2,33045
81100334:	10a03a04 	addi	r2,r2,-32536
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06117 	ldw	r2,-32380(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	297e6f04 	addi	r5,r5,-1604
8110035c:	1009883a 	mov	r4,r2
81100360:	111d6140 	call	8111d614 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18fe6f04 	addi	r3,r3,-1604
811003cc:	00a04574 	movhi	r2,33045
811003d0:	10a04304 	addi	r2,r2,-32500
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	111e6c40 	call	8111e6c4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a06117 	ldw	r2,-32380(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	297e6f04 	addi	r5,r5,-1604
811003f8:	1009883a 	mov	r4,r2
811003fc:	111d6140 	call	8111d614 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18fe6f04 	addi	r3,r3,-1604
81100410:	00a04574 	movhi	r2,33045
81100414:	10a04f04 	addi	r2,r2,-32452
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a06117 	ldw	r2,-32380(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	297e6f04 	addi	r5,r5,-1604
8110043c:	1009883a 	mov	r4,r2
81100440:	111d6140 	call	8111d614 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	11348ec0 	call	811348ec <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110a39c0 	call	8110a39c <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604574 	movhi	r5,33045
811004b0:	29605504 	addi	r5,r5,-32428
811004b4:	01204574 	movhi	r4,33045
811004b8:	213e6f04 	addi	r4,r4,-1604
811004bc:	111efa40 	call	8111efa4 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a06117 	ldw	r2,-32380(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	297e6f04 	addi	r5,r5,-1604
811004cc:	1009883a 	mov	r4,r2
811004d0:	111d6140 	call	8111d614 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18fe6f04 	addi	r3,r3,-1604
811004e0:	00a04574 	movhi	r2,33045
811004e4:	10a05a04 	addi	r2,r2,-32408
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	111e6c40 	call	8111e6c4 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a06117 	ldw	r2,-32380(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	297e6f04 	addi	r5,r5,-1604
8110050c:	1009883a 	mov	r4,r2
81100510:	111d6140 	call	8111d614 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18fe6f04 	addi	r3,r3,-1604
81100544:	00a04574 	movhi	r2,33045
81100548:	10a06004 	addi	r2,r2,-32384
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a06117 	ldw	r2,-32380(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	297e6f04 	addi	r5,r5,-1604
81100570:	1009883a 	mov	r4,r2
81100574:	111d6140 	call	8111d614 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18fe6f04 	addi	r3,r3,-1604
81100584:	00a04574 	movhi	r2,33045
81100588:	10a06904 	addi	r2,r2,-32348
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a06117 	ldw	r2,-32380(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	297e6f04 	addi	r5,r5,-1604
811005b0:	1009883a 	mov	r4,r2
811005b4:	111d6140 	call	8111d614 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18fe6f04 	addi	r3,r3,-1604
811005c0:	00a04574 	movhi	r2,33045
811005c4:	10a07104 	addi	r2,r2,-32316
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a06117 	ldw	r2,-32380(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	297e6f04 	addi	r5,r5,-1604
811005ec:	1009883a 	mov	r4,r2
811005f0:	111d6140 	call	8111d614 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	11348ec0 	call	811348ec <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110a2bc0 	call	8110a2bc <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18fe6f04 	addi	r3,r3,-1604
81100650:	00a04574 	movhi	r2,33045
81100654:	10a07704 	addi	r2,r2,-32292
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a06117 	ldw	r2,-32380(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	297e6f04 	addi	r5,r5,-1604
8110067c:	1009883a 	mov	r4,r2
81100680:	111d6140 	call	8111d614 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110a39c0 	call	8110a39c <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18fe6f04 	addi	r3,r3,-1604
811006cc:	00a04574 	movhi	r2,33045
811006d0:	10a07d04 	addi	r2,r2,-32268
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	111e6c40 	call	8111e6c4 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a06117 	ldw	r2,-32380(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	297e6f04 	addi	r5,r5,-1604
811006f8:	1009883a 	mov	r4,r2
811006fc:	111d6140 	call	8111d614 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604574 	movhi	r5,33045
81100730:	29608604 	addi	r5,r5,-32232
81100734:	01204574 	movhi	r4,33045
81100738:	213e6f04 	addi	r4,r4,-1604
8110073c:	111efa40 	call	8111efa4 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a06117 	ldw	r2,-32380(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	297e6f04 	addi	r5,r5,-1604
8110074c:	1009883a 	mov	r4,r2
81100750:	111d6140 	call	8111d614 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18fe6f04 	addi	r3,r3,-1604
81100764:	00a04574 	movhi	r2,33045
81100768:	10a09504 	addi	r2,r2,-32172
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a06117 	ldw	r2,-32380(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	297e6f04 	addi	r5,r5,-1604
81100790:	1009883a 	mov	r4,r2
81100794:	111d6140 	call	8111d614 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18fe6f04 	addi	r3,r3,-1604
811007a4:	00a04574 	movhi	r2,33045
811007a8:	10a09e04 	addi	r2,r2,-32136
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a06117 	ldw	r2,-32380(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	297e6f04 	addi	r5,r5,-1604
811007d0:	1009883a 	mov	r4,r2
811007d4:	111d6140 	call	8111d614 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10be6f04 	addi	r2,r2,-1604
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a06117 	ldw	r2,-32380(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	297e6f04 	addi	r5,r5,-1604
811007f8:	1009883a 	mov	r4,r2
811007fc:	111d6140 	call	8111d614 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18fe6f04 	addi	r3,r3,-1604
81100840:	00a04574 	movhi	r2,33045
81100844:	10a0a604 	addi	r2,r2,-32104
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a06117 	ldw	r2,-32380(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	297e6f04 	addi	r5,r5,-1604
8110086c:	1009883a 	mov	r4,r2
81100870:	111d6140 	call	8111d614 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18fe6f04 	addi	r3,r3,-1604
811008dc:	00a04574 	movhi	r2,33045
811008e0:	10a0af04 	addi	r2,r2,-32068
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	111e6c40 	call	8111e6c4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a06117 	ldw	r2,-32380(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	297e6f04 	addi	r5,r5,-1604
81100908:	1009883a 	mov	r4,r2
8110090c:	111d6140 	call	8111d614 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	110a4a40 	call	8110a4a4 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604574 	movhi	r5,33045
81100984:	2960bb04 	addi	r5,r5,-32020
81100988:	01204574 	movhi	r4,33045
8110098c:	213e6f04 	addi	r4,r4,-1604
81100990:	111efa40 	call	8111efa4 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a06117 	ldw	r2,-32380(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	297e6f04 	addi	r5,r5,-1604
811009a0:	1009883a 	mov	r4,r2
811009a4:	111d6140 	call	8111d614 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18fe6f04 	addi	r3,r3,-1604
811009c0:	00a04574 	movhi	r2,33045
811009c4:	10a0c704 	addi	r2,r2,-31972
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	111e6c40 	call	8111e6c4 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a06117 	ldw	r2,-32380(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	297e6f04 	addi	r5,r5,-1604
811009ec:	1009883a 	mov	r4,r2
811009f0:	111d6140 	call	8111d614 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18fe6f04 	addi	r3,r3,-1604
81100a0c:	00a04574 	movhi	r2,33045
81100a10:	10a0d304 	addi	r2,r2,-31924
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a06117 	ldw	r2,-32380(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	297e6f04 	addi	r5,r5,-1604
81100a38:	1009883a 	mov	r4,r2
81100a3c:	111d6140 	call	8111d614 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18fe6f04 	addi	r3,r3,-1604
81100a58:	00a04574 	movhi	r2,33045
81100a5c:	10a0db04 	addi	r2,r2,-31892
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	111e6c40 	call	8111e6c4 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a06117 	ldw	r2,-32380(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	297e6f04 	addi	r5,r5,-1604
81100a84:	1009883a 	mov	r4,r2
81100a88:	111d6140 	call	8111d614 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18fe6f04 	addi	r3,r3,-1604
81100aa4:	00a04574 	movhi	r2,33045
81100aa8:	10a0e504 	addi	r2,r2,-31852
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	111e6c40 	call	8111e6c4 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a06117 	ldw	r2,-32380(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	297e6f04 	addi	r5,r5,-1604
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	111d6140 	call	8111d614 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18fe6f04 	addi	r3,r3,-1604
81100af0:	00a04574 	movhi	r2,33045
81100af4:	10a0f004 	addi	r2,r2,-31808
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	111e6c40 	call	8111e6c4 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a06117 	ldw	r2,-32380(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	297e6f04 	addi	r5,r5,-1604
81100b1c:	1009883a 	mov	r4,r2
81100b20:	111d6140 	call	8111d614 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18fe6f04 	addi	r3,r3,-1604
81100b3c:	00a04574 	movhi	r2,33045
81100b40:	10a0fc04 	addi	r2,r2,-31760
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a06117 	ldw	r2,-32380(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	297e6f04 	addi	r5,r5,-1604
81100b68:	1009883a 	mov	r4,r2
81100b6c:	111d6140 	call	8111d614 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18fe6f04 	addi	r3,r3,-1604
81100b88:	00a04574 	movhi	r2,33045
81100b8c:	10a10204 	addi	r2,r2,-31736
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a06117 	ldw	r2,-32380(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	297e6f04 	addi	r5,r5,-1604
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	111d6140 	call	8111d614 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18fe6f04 	addi	r3,r3,-1604
81100bd4:	00a04574 	movhi	r2,33045
81100bd8:	10a10a04 	addi	r2,r2,-31704
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	111e6c40 	call	8111e6c4 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a06117 	ldw	r2,-32380(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	297e6f04 	addi	r5,r5,-1604
81100c00:	1009883a 	mov	r4,r2
81100c04:	111d6140 	call	8111d614 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18fe6f04 	addi	r3,r3,-1604
81100c20:	00a04574 	movhi	r2,33045
81100c24:	10a11704 	addi	r2,r2,-31652
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a06117 	ldw	r2,-32380(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	297e6f04 	addi	r5,r5,-1604
81100c4c:	1009883a 	mov	r4,r2
81100c50:	111d6140 	call	8111d614 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18fe6f04 	addi	r3,r3,-1604
81100c6c:	00a04574 	movhi	r2,33045
81100c70:	10a11d04 	addi	r2,r2,-31628
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a06117 	ldw	r2,-32380(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	297e6f04 	addi	r5,r5,-1604
81100c98:	1009883a 	mov	r4,r2
81100c9c:	111d6140 	call	8111d614 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18fe6f04 	addi	r3,r3,-1604
81100cb8:	00a04574 	movhi	r2,33045
81100cbc:	10a12204 	addi	r2,r2,-31608
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a06117 	ldw	r2,-32380(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	297e6f04 	addi	r5,r5,-1604
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	111d6140 	call	8111d614 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18fe6f04 	addi	r3,r3,-1604
81100d04:	00a04574 	movhi	r2,33045
81100d08:	10a12904 	addi	r2,r2,-31580
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	111e6c40 	call	8111e6c4 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a06117 	ldw	r2,-32380(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	297e6f04 	addi	r5,r5,-1604
81100d30:	1009883a 	mov	r4,r2
81100d34:	111d6140 	call	8111d614 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18fe6f04 	addi	r3,r3,-1604
81100d50:	00a04574 	movhi	r2,33045
81100d54:	10a13704 	addi	r2,r2,-31524
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	111e6c40 	call	8111e6c4 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a06117 	ldw	r2,-32380(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	297e6f04 	addi	r5,r5,-1604
81100d7c:	1009883a 	mov	r4,r2
81100d80:	111d6140 	call	8111d614 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18fe6f04 	addi	r3,r3,-1604
81100d9c:	00a04574 	movhi	r2,33045
81100da0:	10a14904 	addi	r2,r2,-31452
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a06117 	ldw	r2,-32380(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	297e6f04 	addi	r5,r5,-1604
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	111d6140 	call	8111d614 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18fe6f04 	addi	r3,r3,-1604
81100de8:	00a04574 	movhi	r2,33045
81100dec:	10a15104 	addi	r2,r2,-31420
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	111e6c40 	call	8111e6c4 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a06117 	ldw	r2,-32380(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	297e6f04 	addi	r5,r5,-1604
81100e14:	1009883a 	mov	r4,r2
81100e18:	111d6140 	call	8111d614 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18fe6f04 	addi	r3,r3,-1604
81100e34:	00a04574 	movhi	r2,33045
81100e38:	10a15b04 	addi	r2,r2,-31380
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	111e6c40 	call	8111e6c4 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a06117 	ldw	r2,-32380(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	297e6f04 	addi	r5,r5,-1604
81100e60:	1009883a 	mov	r4,r2
81100e64:	111d6140 	call	8111d614 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18fe6f04 	addi	r3,r3,-1604
81100e80:	00a04574 	movhi	r2,33045
81100e84:	10a16804 	addi	r2,r2,-31328
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	111e6c40 	call	8111e6c4 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a06117 	ldw	r2,-32380(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	297e6f04 	addi	r5,r5,-1604
81100eac:	1009883a 	mov	r4,r2
81100eb0:	111d6140 	call	8111d614 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18fe6f04 	addi	r3,r3,-1604
81100ecc:	00a04574 	movhi	r2,33045
81100ed0:	10a17204 	addi	r2,r2,-31288
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	111e6c40 	call	8111e6c4 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a06117 	ldw	r2,-32380(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	297e6f04 	addi	r5,r5,-1604
81100ef8:	1009883a 	mov	r4,r2
81100efc:	111d6140 	call	8111d614 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18fe6f04 	addi	r3,r3,-1604
81100f18:	00a04574 	movhi	r2,33045
81100f1c:	10a17d04 	addi	r2,r2,-31244
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	111e6c40 	call	8111e6c4 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a06117 	ldw	r2,-32380(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	297e6f04 	addi	r5,r5,-1604
81100f44:	1009883a 	mov	r4,r2
81100f48:	111d6140 	call	8111d614 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18fe6f04 	addi	r3,r3,-1604
81100f64:	00a04574 	movhi	r2,33045
81100f68:	10a18e04 	addi	r2,r2,-31176
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	111e6c40 	call	8111e6c4 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a06117 	ldw	r2,-32380(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	297e6f04 	addi	r5,r5,-1604
81100f90:	1009883a 	mov	r4,r2
81100f94:	111d6140 	call	8111d614 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18fe6f04 	addi	r3,r3,-1604
81100fb0:	00a04574 	movhi	r2,33045
81100fb4:	10a19904 	addi	r2,r2,-31132
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	111e6c40 	call	8111e6c4 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a06117 	ldw	r2,-32380(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	297e6f04 	addi	r5,r5,-1604
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	111d6140 	call	8111d614 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18fe6f04 	addi	r3,r3,-1604
81100ffc:	00a04574 	movhi	r2,33045
81101000:	10a1a604 	addi	r2,r2,-31080
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	111e6c40 	call	8111e6c4 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a06117 	ldw	r2,-32380(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	297e6f04 	addi	r5,r5,-1604
81101028:	1009883a 	mov	r4,r2
8110102c:	111d6140 	call	8111d614 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18fe6f04 	addi	r3,r3,-1604
81101048:	00a04574 	movhi	r2,33045
8110104c:	10a1b404 	addi	r2,r2,-31024
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	111e6c40 	call	8111e6c4 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a06117 	ldw	r2,-32380(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	297e6f04 	addi	r5,r5,-1604
81101074:	1009883a 	mov	r4,r2
81101078:	111d6140 	call	8111d614 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18fe6f04 	addi	r3,r3,-1604
81101094:	00a04574 	movhi	r2,33045
81101098:	10a1c104 	addi	r2,r2,-30972
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	111e6c40 	call	8111e6c4 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a06117 	ldw	r2,-32380(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	297e6f04 	addi	r5,r5,-1604
811010c0:	1009883a 	mov	r4,r2
811010c4:	111d6140 	call	8111d614 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18fe6f04 	addi	r3,r3,-1604
811010e0:	00a04574 	movhi	r2,33045
811010e4:	10a1ce04 	addi	r2,r2,-30920
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a06117 	ldw	r2,-32380(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	297e6f04 	addi	r5,r5,-1604
8110110c:	1009883a 	mov	r4,r2
81101110:	111d6140 	call	8111d614 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10be6f04 	addi	r2,r2,-1604
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a06117 	ldw	r2,-32380(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	297e6f04 	addi	r5,r5,-1604
81101194:	1009883a 	mov	r4,r2
81101198:	111d6140 	call	8111d614 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18fe6f04 	addi	r3,r3,-1604
811011b4:	00a04574 	movhi	r2,33045
811011b8:	10a1d204 	addi	r2,r2,-30904
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a06117 	ldw	r2,-32380(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	297e6f04 	addi	r5,r5,-1604
811011e0:	1009883a 	mov	r4,r2
811011e4:	111d6140 	call	8111d614 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18fe6f04 	addi	r3,r3,-1604
81101200:	00a04574 	movhi	r2,33045
81101204:	10a1da04 	addi	r2,r2,-30872
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	111e6c40 	call	8111e6c4 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a06117 	ldw	r2,-32380(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	297e6f04 	addi	r5,r5,-1604
8110122c:	1009883a 	mov	r4,r2
81101230:	111d6140 	call	8111d614 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18fe6f04 	addi	r3,r3,-1604
8110124c:	00a04574 	movhi	r2,33045
81101250:	10a1e804 	addi	r2,r2,-30816
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a06117 	ldw	r2,-32380(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	297e6f04 	addi	r5,r5,-1604
81101278:	1009883a 	mov	r4,r2
8110127c:	111d6140 	call	8111d614 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18fe6f04 	addi	r3,r3,-1604
81101298:	00a04574 	movhi	r2,33045
8110129c:	10a1f004 	addi	r2,r2,-30784
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a06117 	ldw	r2,-32380(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	297e6f04 	addi	r5,r5,-1604
811012c4:	1009883a 	mov	r4,r2
811012c8:	111d6140 	call	8111d614 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18fe6f04 	addi	r3,r3,-1604
811012e4:	00a04574 	movhi	r2,33045
811012e8:	10a1f804 	addi	r2,r2,-30752
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	111e6c40 	call	8111e6c4 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a06117 	ldw	r2,-32380(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	297e6f04 	addi	r5,r5,-1604
81101310:	1009883a 	mov	r4,r2
81101314:	111d6140 	call	8111d614 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18fe6f04 	addi	r3,r3,-1604
81101330:	00a04574 	movhi	r2,33045
81101334:	10a20204 	addi	r2,r2,-30712
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a06117 	ldw	r2,-32380(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	297e6f04 	addi	r5,r5,-1604
8110135c:	1009883a 	mov	r4,r2
81101360:	111d6140 	call	8111d614 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18fe6f04 	addi	r3,r3,-1604
8110137c:	00a04574 	movhi	r2,33045
81101380:	10a20904 	addi	r2,r2,-30684
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	111e6c40 	call	8111e6c4 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a06117 	ldw	r2,-32380(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	297e6f04 	addi	r5,r5,-1604
811013a8:	1009883a 	mov	r4,r2
811013ac:	111d6140 	call	8111d614 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18fe6f04 	addi	r3,r3,-1604
811013c8:	00a04574 	movhi	r2,33045
811013cc:	10a21304 	addi	r2,r2,-30644
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a06117 	ldw	r2,-32380(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	297e6f04 	addi	r5,r5,-1604
811013f4:	1009883a 	mov	r4,r2
811013f8:	111d6140 	call	8111d614 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10be6f04 	addi	r2,r2,-1604
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a06117 	ldw	r2,-32380(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	297e6f04 	addi	r5,r5,-1604
81101420:	1009883a 	mov	r4,r2
81101424:	111d6140 	call	8111d614 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18fe6f04 	addi	r3,r3,-1604
81101454:	00a04574 	movhi	r2,33045
81101458:	10a21d04 	addi	r2,r2,-30604
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a06117 	ldw	r2,-32380(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	297e6f04 	addi	r5,r5,-1604
81101480:	1009883a 	mov	r4,r2
81101484:	111d6140 	call	8111d614 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10be6f04 	addi	r2,r2,-1604
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a06117 	ldw	r2,-32380(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	297e6f04 	addi	r5,r5,-1604
811014a8:	1009883a 	mov	r4,r2
811014ac:	111d6140 	call	8111d614 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18fe6f04 	addi	r3,r3,-1604
81101538:	00a04574 	movhi	r2,33045
8110153c:	10a22304 	addi	r2,r2,-30580
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	111e6c40 	call	8111e6c4 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a06117 	ldw	r2,-32380(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	297e6f04 	addi	r5,r5,-1604
81101564:	1009883a 	mov	r4,r2
81101568:	111d6140 	call	8111d614 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18fe6f04 	addi	r3,r3,-1604
811015b4:	00a04574 	movhi	r2,33045
811015b8:	10a23204 	addi	r2,r2,-30520
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a06117 	ldw	r2,-32380(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	297e6f04 	addi	r5,r5,-1604
811015e0:	1009883a 	mov	r4,r2
811015e4:	111d6140 	call	8111d614 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18fe6f04 	addi	r3,r3,-1604
81101648:	00a04574 	movhi	r2,33045
8110164c:	10a04304 	addi	r2,r2,-32500
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	111e6c40 	call	8111e6c4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a06117 	ldw	r2,-32380(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	297e6f04 	addi	r5,r5,-1604
81101674:	1009883a 	mov	r4,r2
81101678:	111d6140 	call	8111d614 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604574 	movhi	r5,33045
81101694:	29623c04 	addi	r5,r5,-30480
81101698:	01204574 	movhi	r4,33045
8110169c:	213e6f04 	addi	r4,r4,-1604
811016a0:	111efa40 	call	8111efa4 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a06117 	ldw	r2,-32380(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	297e6f04 	addi	r5,r5,-1604
811016b0:	1009883a 	mov	r4,r2
811016b4:	111d6140 	call	8111d614 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08817 	ldw	r2,-32224(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10beaf04 	addi	r2,r2,-1348
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10beaf04 	addi	r2,r2,-1348
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10beaf04 	addi	r2,r2,-1348
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10beaf04 	addi	r2,r2,-1348
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10beaf04 	addi	r2,r2,-1348
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10beaf04 	addi	r2,r2,-1348
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10beaf04 	addi	r2,r2,-1348
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18fe6f04 	addi	r3,r3,-1604
81101868:	00a04574 	movhi	r2,33045
8110186c:	10a24204 	addi	r2,r2,-30456
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a06117 	ldw	r2,-32380(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	297e6f04 	addi	r5,r5,-1604
81101894:	1009883a 	mov	r4,r2
81101898:	111d6140 	call	8111d614 <fprintf>
8110189c:	d0a08817 	ldw	r2,-32224(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	297eaf04 	addi	r5,r5,-1348
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	111e6c40 	call	8111e6c4 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604574 	movhi	r5,33045
81101990:	29624704 	addi	r5,r5,-30436
81101994:	01204574 	movhi	r4,33045
81101998:	213e6f04 	addi	r4,r4,-1604
8110199c:	111efa40 	call	8111efa4 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a06117 	ldw	r2,-32380(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	297e6f04 	addi	r5,r5,-1604
811019ac:	1009883a 	mov	r4,r2
811019b0:	111d6140 	call	8111d614 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11330c40 	call	811330c4 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10be6f04 	addi	r2,r2,-1604
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a06117 	ldw	r2,-32380(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	297e6f04 	addi	r5,r5,-1604
811019e4:	1009883a 	mov	r4,r2
811019e8:	111d6140 	call	8111d614 <fprintf>
811019ec:	d0e08817 	ldw	r3,-32224(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111c8500 	call	8111c850 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08717 	ldw	r2,-32228(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111c97c0 	call	8111c97c <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111c0040 	call	8111c004 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	111d1940 	call	8111d194 <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604574 	movhi	r5,33045
81101a54:	29624904 	addi	r5,r5,-30428
81101a58:	01204574 	movhi	r4,33045
81101a5c:	213e6f04 	addi	r4,r4,-1604
81101a60:	111efa40 	call	8111efa4 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a06117 	ldw	r2,-32380(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	297e6f04 	addi	r5,r5,-1604
81101a70:	1009883a 	mov	r4,r2
81101a74:	111d6140 	call	8111d614 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18fe6f04 	addi	r3,r3,-1604
81101a84:	00a04574 	movhi	r2,33045
81101a88:	10a25504 	addi	r2,r2,-30380
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a06117 	ldw	r2,-32380(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	297e6f04 	addi	r5,r5,-1604
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	111d6140 	call	8111d614 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10be6f04 	addi	r2,r2,-1604
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a06117 	ldw	r2,-32380(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	297e6f04 	addi	r5,r5,-1604
81101ad8:	1009883a 	mov	r4,r2
81101adc:	111d6140 	call	8111d614 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18fe6f04 	addi	r3,r3,-1604
81101b30:	00a04574 	movhi	r2,33045
81101b34:	10a25b04 	addi	r2,r2,-30356
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a06117 	ldw	r2,-32380(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	297e6f04 	addi	r5,r5,-1604
81101b5c:	1009883a 	mov	r4,r2
81101b60:	111d6140 	call	8111d614 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18fe6f04 	addi	r3,r3,-1604
81101bc4:	00a04574 	movhi	r2,33045
81101bc8:	10a04304 	addi	r2,r2,-32500
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	111e6c40 	call	8111e6c4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a06117 	ldw	r2,-32380(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	297e6f04 	addi	r5,r5,-1604
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	111d6140 	call	8111d614 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604574 	movhi	r5,33045
81101c10:	29626504 	addi	r5,r5,-30316
81101c14:	01204574 	movhi	r4,33045
81101c18:	213e6f04 	addi	r4,r4,-1604
81101c1c:	111efa40 	call	8111efa4 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a06117 	ldw	r2,-32380(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	297e6f04 	addi	r5,r5,-1604
81101c2c:	1009883a 	mov	r4,r2
81101c30:	111d6140 	call	8111d614 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18fe6f04 	addi	r3,r3,-1604
81101cd0:	00a04574 	movhi	r2,33045
81101cd4:	10a26b04 	addi	r2,r2,-30292
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a06117 	ldw	r2,-32380(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	297e6f04 	addi	r5,r5,-1604
81101cfc:	1009883a 	mov	r4,r2
81101d00:	111d6140 	call	8111d614 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08817 	ldw	r2,-32224(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10beaf04 	addi	r2,r2,-1348
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10beaf04 	addi	r2,r2,-1348
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604574 	movhi	r5,33045
81101df4:	29627204 	addi	r5,r5,-30264
81101df8:	01204574 	movhi	r4,33045
81101dfc:	213e6f04 	addi	r4,r4,-1604
81101e00:	111efa40 	call	8111efa4 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a06117 	ldw	r2,-32380(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	297e6f04 	addi	r5,r5,-1604
81101e10:	1009883a 	mov	r4,r2
81101e14:	111d6140 	call	8111d614 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604574 	movhi	r5,33045
81101e98:	29624704 	addi	r5,r5,-30436
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	213e6f04 	addi	r4,r4,-1604
81101ea4:	111efa40 	call	8111efa4 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a06117 	ldw	r2,-32380(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	297e6f04 	addi	r5,r5,-1604
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	111d6140 	call	8111d614 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10be6f04 	addi	r2,r2,-1604
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a06117 	ldw	r2,-32380(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	297e6f04 	addi	r5,r5,-1604
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	111d6140 	call	8111d614 <fprintf>
81101ef8:	d0e08817 	ldw	r3,-32224(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111c8500 	call	8111c850 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08717 	ldw	r2,-32228(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111c97c0 	call	8111c97c <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111c0040 	call	8111c004 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	111d1940 	call	8111d194 <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604574 	movhi	r5,33045
81101f60:	29628004 	addi	r5,r5,-30208
81101f64:	01204574 	movhi	r4,33045
81101f68:	213e6f04 	addi	r4,r4,-1604
81101f6c:	111efa40 	call	8111efa4 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a06117 	ldw	r2,-32380(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	297e6f04 	addi	r5,r5,-1604
81101f7c:	1009883a 	mov	r4,r2
81101f80:	111d6140 	call	8111d614 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18fe6f04 	addi	r3,r3,-1604
81101f90:	00a04574 	movhi	r2,33045
81101f94:	10a28c04 	addi	r2,r2,-30160
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a06117 	ldw	r2,-32380(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	297e6f04 	addi	r5,r5,-1604
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	111d6140 	call	8111d614 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10be6f04 	addi	r2,r2,-1604
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a06117 	ldw	r2,-32380(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	297e6f04 	addi	r5,r5,-1604
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	111d6140 	call	8111d614 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18fe6f04 	addi	r3,r3,-1604
8110204c:	00a04574 	movhi	r2,33045
81102050:	10a29204 	addi	r2,r2,-30136
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a06117 	ldw	r2,-32380(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	297e6f04 	addi	r5,r5,-1604
81102078:	1009883a 	mov	r4,r2
8110207c:	111d6140 	call	8111d614 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18fe6f04 	addi	r3,r3,-1604
811020e0:	00a04574 	movhi	r2,33045
811020e4:	10a04304 	addi	r2,r2,-32500
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	111e6c40 	call	8111e6c4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a06117 	ldw	r2,-32380(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	297e6f04 	addi	r5,r5,-1604
8110210c:	1009883a 	mov	r4,r2
81102110:	111d6140 	call	8111d614 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604574 	movhi	r5,33045
8110212c:	29623c04 	addi	r5,r5,-30480
81102130:	01204574 	movhi	r4,33045
81102134:	213e6f04 	addi	r4,r4,-1604
81102138:	111efa40 	call	8111efa4 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a06117 	ldw	r2,-32380(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	297e6f04 	addi	r5,r5,-1604
81102148:	1009883a 	mov	r4,r2
8110214c:	111d6140 	call	8111d614 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08817 	ldw	r2,-32224(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18fe6f04 	addi	r3,r3,-1604
811021ac:	00a04574 	movhi	r2,33045
811021b0:	10a29e04 	addi	r2,r2,-30088
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a06117 	ldw	r2,-32380(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	297e6f04 	addi	r5,r5,-1604
811021d8:	1009883a 	mov	r4,r2
811021dc:	111d6140 	call	8111d614 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604574 	movhi	r5,33045
811021f0:	2962a404 	addi	r5,r5,-30064
811021f4:	01204574 	movhi	r4,33045
811021f8:	213e6f04 	addi	r4,r4,-1604
811021fc:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a06117 	ldw	r2,-32380(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	297e6f04 	addi	r5,r5,-1604
8110220c:	1009883a 	mov	r4,r2
81102210:	111d6140 	call	8111d614 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08817 	ldw	r2,-32224(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604574 	movhi	r5,33045
81102274:	2962a604 	addi	r5,r5,-30056
81102278:	01204574 	movhi	r4,33045
8110227c:	213e6f04 	addi	r4,r4,-1604
81102280:	111efa40 	call	8111efa4 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a06117 	ldw	r2,-32380(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	297e6f04 	addi	r5,r5,-1604
81102290:	1009883a 	mov	r4,r2
81102294:	111d6140 	call	8111d614 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11330c40 	call	811330c4 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604574 	movhi	r5,33045
811022fc:	2962a904 	addi	r5,r5,-30044
81102300:	01204574 	movhi	r4,33045
81102304:	213e6f04 	addi	r4,r4,-1604
81102308:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a06117 	ldw	r2,-32380(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	297e6f04 	addi	r5,r5,-1604
81102318:	1009883a 	mov	r4,r2
8110231c:	111d6140 	call	8111d614 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08817 	ldw	r3,-32224(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111c8500 	call	8111c850 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08717 	ldw	r2,-32228(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111c97c0 	call	8111c97c <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111c0040 	call	8111c004 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	111d1940 	call	8111d194 <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604574 	movhi	r5,33045
81102394:	2962ac04 	addi	r5,r5,-30032
81102398:	01204574 	movhi	r4,33045
8110239c:	213e6f04 	addi	r4,r4,-1604
811023a0:	111efa40 	call	8111efa4 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a06117 	ldw	r2,-32380(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	297e6f04 	addi	r5,r5,-1604
811023b0:	1009883a 	mov	r4,r2
811023b4:	111d6140 	call	8111d614 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604574 	movhi	r5,33045
811023c4:	2962b804 	addi	r5,r5,-29984
811023c8:	01204574 	movhi	r4,33045
811023cc:	213e6f04 	addi	r4,r4,-1604
811023d0:	111efa40 	call	8111efa4 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a06117 	ldw	r2,-32380(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	297e6f04 	addi	r5,r5,-1604
811023e0:	1009883a 	mov	r4,r2
811023e4:	111d6140 	call	8111d614 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18fe6f04 	addi	r3,r3,-1604
811023f4:	00a04574 	movhi	r2,33045
811023f8:	10a25504 	addi	r2,r2,-30380
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a06117 	ldw	r2,-32380(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	297e6f04 	addi	r5,r5,-1604
81102420:	1009883a 	mov	r4,r2
81102424:	111d6140 	call	8111d614 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10be6f04 	addi	r2,r2,-1604
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a06117 	ldw	r2,-32380(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	297e6f04 	addi	r5,r5,-1604
81102448:	1009883a 	mov	r4,r2
8110244c:	111d6140 	call	8111d614 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18fe6f04 	addi	r3,r3,-1604
811024b8:	00a04574 	movhi	r2,33045
811024bc:	10a2c204 	addi	r2,r2,-29944
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a06117 	ldw	r2,-32380(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	297e6f04 	addi	r5,r5,-1604
811024e4:	1009883a 	mov	r4,r2
811024e8:	111d6140 	call	8111d614 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18fe6f04 	addi	r3,r3,-1604
8110254c:	00a04574 	movhi	r2,33045
81102550:	10a04304 	addi	r2,r2,-32500
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	111e6c40 	call	8111e6c4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a06117 	ldw	r2,-32380(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	297e6f04 	addi	r5,r5,-1604
81102578:	1009883a 	mov	r4,r2
8110257c:	111d6140 	call	8111d614 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604574 	movhi	r5,33045
81102598:	29623c04 	addi	r5,r5,-30480
8110259c:	01204574 	movhi	r4,33045
811025a0:	213e6f04 	addi	r4,r4,-1604
811025a4:	111efa40 	call	8111efa4 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a06117 	ldw	r2,-32380(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	297e6f04 	addi	r5,r5,-1604
811025b4:	1009883a 	mov	r4,r2
811025b8:	111d6140 	call	8111d614 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18fe6f04 	addi	r3,r3,-1604
81102610:	00a04574 	movhi	r2,33045
81102614:	10a2ce04 	addi	r2,r2,-29896
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a06117 	ldw	r2,-32380(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	297e6f04 	addi	r5,r5,-1604
8110263c:	1009883a 	mov	r4,r2
81102640:	111d6140 	call	8111d614 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604574 	movhi	r5,33045
81102654:	2962a404 	addi	r5,r5,-30064
81102658:	01204574 	movhi	r4,33045
8110265c:	213e6f04 	addi	r4,r4,-1604
81102660:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a06117 	ldw	r2,-32380(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	297e6f04 	addi	r5,r5,-1604
81102670:	1009883a 	mov	r4,r2
81102674:	111d6140 	call	8111d614 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08817 	ldw	r2,-32224(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604574 	movhi	r5,33045
811026c8:	2962d404 	addi	r5,r5,-29872
811026cc:	01204574 	movhi	r4,33045
811026d0:	213e6f04 	addi	r4,r4,-1604
811026d4:	111efa40 	call	8111efa4 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a06117 	ldw	r2,-32380(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	297e6f04 	addi	r5,r5,-1604
811026e4:	1009883a 	mov	r4,r2
811026e8:	111d6140 	call	8111d614 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604574 	movhi	r5,33045
81102710:	2962a604 	addi	r5,r5,-30056
81102714:	01204574 	movhi	r4,33045
81102718:	213e6f04 	addi	r4,r4,-1604
8110271c:	111efa40 	call	8111efa4 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a06117 	ldw	r2,-32380(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	297e6f04 	addi	r5,r5,-1604
8110272c:	1009883a 	mov	r4,r2
81102730:	111d6140 	call	8111d614 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604574 	movhi	r5,33045
81102794:	2962a904 	addi	r5,r5,-30044
81102798:	01204574 	movhi	r4,33045
8110279c:	213e6f04 	addi	r4,r4,-1604
811027a0:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a06117 	ldw	r2,-32380(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	297e6f04 	addi	r5,r5,-1604
811027b0:	1009883a 	mov	r4,r2
811027b4:	111d6140 	call	8111d614 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08817 	ldw	r3,-32224(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111c8500 	call	8111c850 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08717 	ldw	r2,-32228(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111c97c0 	call	8111c97c <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111c0040 	call	8111c004 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	111d1940 	call	8111d194 <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604574 	movhi	r5,33045
8110282c:	2962dc04 	addi	r5,r5,-29840
81102830:	01204574 	movhi	r4,33045
81102834:	213e6f04 	addi	r4,r4,-1604
81102838:	111efa40 	call	8111efa4 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a06117 	ldw	r2,-32380(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	297e6f04 	addi	r5,r5,-1604
81102848:	1009883a 	mov	r4,r2
8110284c:	111d6140 	call	8111d614 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604574 	movhi	r5,33045
8110285c:	2962e804 	addi	r5,r5,-29792
81102860:	01204574 	movhi	r4,33045
81102864:	213e6f04 	addi	r4,r4,-1604
81102868:	111efa40 	call	8111efa4 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a06117 	ldw	r2,-32380(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	297e6f04 	addi	r5,r5,-1604
81102878:	1009883a 	mov	r4,r2
8110287c:	111d6140 	call	8111d614 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18fe6f04 	addi	r3,r3,-1604
8110288c:	00a04574 	movhi	r2,33045
81102890:	10a28c04 	addi	r2,r2,-30160
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	111e6c40 	call	8111e6c4 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a06117 	ldw	r2,-32380(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	297e6f04 	addi	r5,r5,-1604
811028b8:	1009883a 	mov	r4,r2
811028bc:	111d6140 	call	8111d614 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10be6f04 	addi	r2,r2,-1604
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a06117 	ldw	r2,-32380(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	297e6f04 	addi	r5,r5,-1604
811028e0:	1009883a 	mov	r4,r2
811028e4:	111d6140 	call	8111d614 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	11469840 	call	81146984 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	11348ec0 	call	811348ec <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	11348ec0 	call	811348ec <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	11348ec0 	call	811348ec <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	11348ec0 	call	811348ec <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	11459800 	call	81145980 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	1146bf40 	call	81146bf4 <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	11348ec0 	call	811348ec <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	11348ec0 	call	811348ec <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	11459800 	call	81145980 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	1146bf40 	call	81146bf4 <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	11459800 	call	81145980 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	1146bf40 	call	81146bf4 <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	11348ec0 	call	811348ec <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	11348ec0 	call	811348ec <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110b5a40 	call	8110b5a4 <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110b5a40 	call	8110b5a4 <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604574 	movhi	r5,33045
811030d0:	2962f204 	addi	r5,r5,-29752
811030d4:	01204574 	movhi	r4,33045
811030d8:	213e6f04 	addi	r4,r4,-1604
811030dc:	111efa40 	call	8111efa4 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a06117 	ldw	r2,-32380(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	297e6f04 	addi	r5,r5,-1604
811030ec:	1009883a 	mov	r4,r2
811030f0:	111d6140 	call	8111d614 <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604574 	movhi	r5,33045
8110311c:	2962f804 	addi	r5,r5,-29728
81103120:	01204574 	movhi	r4,33045
81103124:	213e6f04 	addi	r4,r4,-1604
81103128:	111efa40 	call	8111efa4 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a06117 	ldw	r2,-32380(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	297e6f04 	addi	r5,r5,-1604
81103138:	1009883a 	mov	r4,r2
8110313c:	111d6140 	call	8111d614 <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	29630404 	addi	r5,r5,-29680
81103160:	01204574 	movhi	r4,33045
81103164:	213e6f04 	addi	r4,r4,-1604
81103168:	111efa40 	call	8111efa4 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a06117 	ldw	r2,-32380(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	297e6f04 	addi	r5,r5,-1604
81103178:	1009883a 	mov	r4,r2
8110317c:	111d6140 	call	8111d614 <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18fe6f04 	addi	r3,r3,-1604
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10a30a04 	addi	r2,r2,-29656
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	111e6c40 	call	8111e6c4 <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a06117 	ldw	r2,-32380(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	297e6f04 	addi	r5,r5,-1604
811031ec:	1009883a 	mov	r4,r2
811031f0:	111d6140 	call	8111d614 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	110a39c0 	call	8110a39c <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	110a39c0 	call	8110a39c <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10a34104 	addi	r2,r2,-29436
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	111e6c40 	call	8111e6c4 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111c97c0 	call	8111c97c <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111c0040 	call	8111c004 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111c44c0 	call	8111c44c <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	111d1940 	call	8111d194 <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	29630f04 	addi	r5,r5,-29636
8110365c:	01204574 	movhi	r4,33045
81103660:	213e6f04 	addi	r4,r4,-1604
81103664:	111efa40 	call	8111efa4 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a06117 	ldw	r2,-32380(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	297e6f04 	addi	r5,r5,-1604
81103674:	1009883a 	mov	r4,r2
81103678:	111d6140 	call	8111d614 <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	111d1940 	call	8111d194 <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111ca740 	call	8111ca74 <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	111d1940 	call	8111d194 <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111ca740 	call	8111ca74 <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	111d2ac0 	call	8111d2ac <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111c0040 	call	8111c004 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111c44c0 	call	8111c44c <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	111d1940 	call	8111d194 <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	111d1940 	call	8111d194 <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	111d1940 	call	8111d194 <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	29631804 	addi	r5,r5,-29600
811037f4:	01204574 	movhi	r4,33045
811037f8:	213e6f04 	addi	r4,r4,-1604
811037fc:	111efa40 	call	8111efa4 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a06117 	ldw	r2,-32380(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	297e6f04 	addi	r5,r5,-1604
8110380c:	1009883a 	mov	r4,r2
81103810:	111d6140 	call	8111d614 <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	111d1940 	call	8111d194 <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111ca740 	call	8111ca74 <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	111d1940 	call	8111d194 <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111ca740 	call	8111ca74 <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	111d2ac0 	call	8111d2ac <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111c0040 	call	8111c004 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111c44c0 	call	8111c44c <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	111d1940 	call	8111d194 <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	111d1940 	call	8111d194 <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	111d1940 	call	8111d194 <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	29632804 	addi	r5,r5,-29536
8110398c:	01204574 	movhi	r4,33045
81103990:	213e6f04 	addi	r4,r4,-1604
81103994:	111efa40 	call	8111efa4 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a06117 	ldw	r2,-32380(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	297e6f04 	addi	r5,r5,-1604
811039a4:	1009883a 	mov	r4,r2
811039a8:	111d6140 	call	8111d614 <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111c44c0 	call	8111c44c <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	111d1940 	call	8111d194 <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	29633804 	addi	r5,r5,-29472
81103a34:	01204574 	movhi	r4,33045
81103a38:	213e6f04 	addi	r4,r4,-1604
81103a3c:	111efa40 	call	8111efa4 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a06117 	ldw	r2,-32380(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	297e6f04 	addi	r5,r5,-1604
81103a4c:	1009883a 	mov	r4,r2
81103a50:	111d6140 	call	8111d614 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	10be6f04 	addi	r2,r2,-1604
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a06117 	ldw	r2,-32380(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	297e6f04 	addi	r5,r5,-1604
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	111d6140 	call	8111d614 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	10be6f04 	addi	r2,r2,-1604
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a06117 	ldw	r2,-32380(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	297e6f04 	addi	r5,r5,-1604
81103af8:	1009883a 	mov	r4,r2
81103afc:	111d6140 	call	8111d614 <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	21240104 	addi	r4,r4,-28668
81103b5c:	11469840 	call	81146984 <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	11348ec0 	call	811348ec <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204574 	movhi	r4,33045
81103c08:	21240604 	addi	r4,r4,-28648
81103c0c:	11469840 	call	81146984 <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	11348ec0 	call	811348ec <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe904 	addi	sp,sp,-92
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01615 	stw	ra,88(sp)
81103ca0:	df001515 	stw	fp,84(sp)
81103ca4:	dc001415 	stw	r16,80(sp)
81103ca8:	df001504 	addi	fp,sp,84
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103cfc:	e0bffe03 	ldbu	r2,-8(fp)
81103d00:	10c00228 	cmpgeui	r3,r2,8
81103d04:	18009c1e 	bne	r3,zero,81103f78 <bSdmaDmaM1Transfer+0x2e8>
81103d08:	100690ba 	slli	r3,r2,2
81103d0c:	00a04434 	movhi	r2,33040
81103d10:	108f4804 	addi	r2,r2,15648
81103d14:	1885883a 	add	r2,r3,r2
81103d18:	10800017 	ldw	r2,0(r2)
81103d1c:	1000683a 	jmp	r2
81103d20:	81103d40 	call	881103d4 <__reset+0x20f03d4>
81103d24:	81103d80 	call	881103d8 <__reset+0x20f03d8>
81103d28:	81103dc8 	cmpgei	r4,r16,16631
81103d2c:	81103e10 	cmplti	r4,r16,16632
81103d30:	81103e58 	cmpnei	r4,r16,16633
81103d34:	81103ea0 	cmpeqi	r4,r16,16634
81103d38:	81103ee8 	cmpgeui	r4,r16,16635
81103d3c:	81103f30 	cmpltui	r4,r16,16636
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d40:	e0bffd03 	ldbu	r2,-12(fp)
81103d44:	10000626 	beq	r2,zero,81103d60 <bSdmaDmaM1Transfer+0xd0>
81103d48:	10800060 	cmpeqi	r2,r2,1
81103d4c:	10000926 	beq	r2,zero,81103d74 <bSdmaDmaM1Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d50:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d54:	00800044 	movi	r2,1
81103d58:	e0bff715 	stw	r2,-36(fp)
			break;
81103d5c:	00000706 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d60:	00800074 	movhi	r2,1
81103d64:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d68:	00800044 	movi	r2,1
81103d6c:	e0bff715 	stw	r2,-36(fp)
			break;
81103d70:	00000206 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		default:
			bStatus = FALSE;
81103d74:	e03ff415 	stw	zero,-48(fp)
			break;
81103d78:	0001883a 	nop
		}
		break;
81103d7c:	00008006 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d80:	e0bffd03 	ldbu	r2,-12(fp)
81103d84:	10000726 	beq	r2,zero,81103da4 <bSdmaDmaM1Transfer+0x114>
81103d88:	10800060 	cmpeqi	r2,r2,1
81103d8c:	10000b26 	beq	r2,zero,81103dbc <bSdmaDmaM1Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103d90:	00880004 	movi	r2,8192
81103d94:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103d98:	00800044 	movi	r2,1
81103d9c:	e0bff715 	stw	r2,-36(fp)
			break;
81103da0:	00000806 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103da4:	00800074 	movhi	r2,1
81103da8:	10880004 	addi	r2,r2,8192
81103dac:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff715 	stw	r2,-36(fp)
			break;
81103db8:	00000206 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		default:
			bStatus = FALSE;
81103dbc:	e03ff415 	stw	zero,-48(fp)
			break;
81103dc0:	0001883a 	nop
		}
		break;
81103dc4:	00006e06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103dc8:	e0bffd03 	ldbu	r2,-12(fp)
81103dcc:	10000726 	beq	r2,zero,81103dec <bSdmaDmaM1Transfer+0x15c>
81103dd0:	10800060 	cmpeqi	r2,r2,1
81103dd4:	10000b26 	beq	r2,zero,81103e04 <bSdmaDmaM1Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103dd8:	00900004 	movi	r2,16384
81103ddc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103de0:	00800044 	movi	r2,1
81103de4:	e0bff715 	stw	r2,-36(fp)
			break;
81103de8:	00000806 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103dec:	00800074 	movhi	r2,1
81103df0:	10900004 	addi	r2,r2,16384
81103df4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103df8:	00800044 	movi	r2,1
81103dfc:	e0bff715 	stw	r2,-36(fp)
			break;
81103e00:	00000206 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		default:
			bStatus = FALSE;
81103e04:	e03ff415 	stw	zero,-48(fp)
			break;
81103e08:	0001883a 	nop
		}
		break;
81103e0c:	00005c06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e10:	e0bffd03 	ldbu	r2,-12(fp)
81103e14:	10000726 	beq	r2,zero,81103e34 <bSdmaDmaM1Transfer+0x1a4>
81103e18:	10800060 	cmpeqi	r2,r2,1
81103e1c:	10000b26 	beq	r2,zero,81103e4c <bSdmaDmaM1Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e20:	00980004 	movi	r2,24576
81103e24:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e30:	00000806 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e34:	00800074 	movhi	r2,1
81103e38:	10980004 	addi	r2,r2,24576
81103e3c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e40:	00800044 	movi	r2,1
81103e44:	e0bff715 	stw	r2,-36(fp)
			break;
81103e48:	00000206 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		default:
			bStatus = FALSE;
81103e4c:	e03ff415 	stw	zero,-48(fp)
			break;
81103e50:	0001883a 	nop
		}
		break;
81103e54:	00004a06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e58:	e0bffd03 	ldbu	r2,-12(fp)
81103e5c:	10000726 	beq	r2,zero,81103e7c <bSdmaDmaM1Transfer+0x1ec>
81103e60:	10800060 	cmpeqi	r2,r2,1
81103e64:	10000b26 	beq	r2,zero,81103e94 <bSdmaDmaM1Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e68:	00a00014 	movui	r2,32768
81103e6c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e70:	00800044 	movi	r2,1
81103e74:	e0bff715 	stw	r2,-36(fp)
			break;
81103e78:	00000806 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103e7c:	008000b4 	movhi	r2,2
81103e80:	10a00004 	addi	r2,r2,-32768
81103e84:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103e88:	00800044 	movi	r2,1
81103e8c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e90:	00000206 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		default:
			bStatus = FALSE;
81103e94:	e03ff415 	stw	zero,-48(fp)
			break;
81103e98:	0001883a 	nop
		}
		break;
81103e9c:	00003806 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ea0:	e0bffd03 	ldbu	r2,-12(fp)
81103ea4:	10000726 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea8:	10800060 	cmpeqi	r2,r2,1
81103eac:	10000b26 	beq	r2,zero,81103edc <bSdmaDmaM1Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103eb0:	00a80014 	movui	r2,40960
81103eb4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103eb8:	00800044 	movi	r2,1
81103ebc:	e0bff715 	stw	r2,-36(fp)
			break;
81103ec0:	00000806 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a80004 	addi	r2,r2,-24576
81103ecc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff715 	stw	r2,-36(fp)
			break;
81103ed8:	00000206 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		default:
			bStatus = FALSE;
81103edc:	e03ff415 	stw	zero,-48(fp)
			break;
81103ee0:	0001883a 	nop
		}
		break;
81103ee4:	00002606 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103ee8:	e0bffd03 	ldbu	r2,-12(fp)
81103eec:	10000726 	beq	r2,zero,81103f0c <bSdmaDmaM1Transfer+0x27c>
81103ef0:	10800060 	cmpeqi	r2,r2,1
81103ef4:	10000b26 	beq	r2,zero,81103f24 <bSdmaDmaM1Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103ef8:	00b00014 	movui	r2,49152
81103efc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f00:	00800044 	movi	r2,1
81103f04:	e0bff715 	stw	r2,-36(fp)
			break;
81103f08:	00000806 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f0c:	008000b4 	movhi	r2,2
81103f10:	10b00004 	addi	r2,r2,-16384
81103f14:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f18:	00800044 	movi	r2,1
81103f1c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f20:	00000206 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		default:
			bStatus = FALSE;
81103f24:	e03ff415 	stw	zero,-48(fp)
			break;
81103f28:	0001883a 	nop
		}
		break;
81103f2c:	00001406 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f30:	e0bffd03 	ldbu	r2,-12(fp)
81103f34:	10000726 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x2c4>
81103f38:	10800060 	cmpeqi	r2,r2,1
81103f3c:	10000b26 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f40:	00b80014 	movui	r2,57344
81103f44:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f48:	00800044 	movi	r2,1
81103f4c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f50:	00000806 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f54:	008000b4 	movhi	r2,2
81103f58:	10b80004 	addi	r2,r2,-8192
81103f5c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f60:	00800044 	movi	r2,1
81103f64:	e0bff715 	stw	r2,-36(fp)
			break;
81103f68:	00000206 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		default:
			bStatus = FALSE;
81103f6c:	e03ff415 	stw	zero,-48(fp)
			break;
81103f70:	0001883a 	nop
		}
		break;
81103f74:	00000206 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	default:
		bStatus = FALSE;
81103f78:	e03ff415 	stw	zero,-48(fp)
		break;
81103f7c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103f80:	e0bffb17 	ldw	r2,-20(fp)
81103f84:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103f88:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103f8c:	e0bff417 	ldw	r2,-48(fp)
81103f90:	10003b26 	beq	r2,zero,81104080 <bSdmaDmaM1Transfer+0x3f0>
		if (pxDmaM1Dev == NULL) {
81103f94:	d0a03917 	ldw	r2,-32540(gp)
81103f98:	1000021e 	bne	r2,zero,81103fa4 <bSdmaDmaM1Transfer+0x314>
			bStatus = FALSE;
81103f9c:	e03ff415 	stw	zero,-48(fp)
81103fa0:	00003706 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103fa4:	e03ff50d 	sth	zero,-44(fp)
81103fa8:	00003206 	br	81104074 <bSdmaDmaM1Transfer+0x3e4>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103fac:	01000044 	movi	r4,1
81103fb0:	1132e780 	call	81132e78 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103fb4:	d0a03917 	ldw	r2,-32540(gp)
81103fb8:	10800317 	ldw	r2,12(r2)
81103fbc:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103fc0:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103fc4:	103ff91e 	bne	r2,zero,81103fac <__reset+0xfb0e3fac>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103fc8:	d2203917 	ldw	r8,-32540(gp)
81103fcc:	e17ff817 	ldw	r5,-32(fp)
81103fd0:	e1bff617 	ldw	r6,-40(fp)
81103fd4:	e0bff917 	ldw	r2,-28(fp)
81103fd8:	e0fff717 	ldw	r3,-36(fp)
81103fdc:	01000044 	movi	r4,1
81103fe0:	d9000815 	stw	r4,32(sp)
81103fe4:	01000044 	movi	r4,1
81103fe8:	d9000715 	stw	r4,28(sp)
81103fec:	01000044 	movi	r4,1
81103ff0:	d9000615 	stw	r4,24(sp)
81103ff4:	01000044 	movi	r4,1
81103ff8:	d9000515 	stw	r4,20(sp)
81103ffc:	01000044 	movi	r4,1
81104000:	d9000415 	stw	r4,16(sp)
81104004:	d8c00315 	stw	r3,12(sp)
81104008:	d8800215 	stw	r2,8(sp)
8110400c:	e0bffa17 	ldw	r2,-24(fp)
81104010:	d8800115 	stw	r2,4(sp)
81104014:	00802204 	movi	r2,136
81104018:	d8800015 	stw	r2,0(sp)
8110401c:	300f883a 	mov	r7,r6
81104020:	280d883a 	mov	r6,r5
81104024:	800b883a 	mov	r5,r16
81104028:	4009883a 	mov	r4,r8
8110402c:	110b45c0 	call	8110b45c <iMsgdmaConstructExtendedMmToMmDescriptor>
81104030:	10000226 	beq	r2,zero,8110403c <bSdmaDmaM1Transfer+0x3ac>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104034:	e03ff415 	stw	zero,-48(fp)
					break;
81104038:	00001106 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
8110403c:	d0a03917 	ldw	r2,-32540(gp)
81104040:	800b883a 	mov	r5,r16
81104044:	1009883a 	mov	r4,r2
81104048:	110b5600 	call	8110b560 <iMsgdmaExtendedDescriptorSyncTransfer>
8110404c:	10000226 	beq	r2,zero,81104058 <bSdmaDmaM1Transfer+0x3c8>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104050:	e03ff415 	stw	zero,-48(fp)
						break;
81104054:	00000a06 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104058:	e0bff817 	ldw	r2,-32(fp)
8110405c:	10802204 	addi	r2,r2,136
81104060:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104064:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104068:	e0bff50b 	ldhu	r2,-44(fp)
8110406c:	10800044 	addi	r2,r2,1
81104070:	e0bff50d 	sth	r2,-44(fp)
81104074:	e0fff50b 	ldhu	r3,-44(fp)
81104078:	e0bffc0b 	ldhu	r2,-16(fp)
8110407c:	18bfcd36 	bltu	r3,r2,81103fb4 <__reset+0xfb0e3fb4>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104080:	e0bff417 	ldw	r2,-48(fp)
}
81104084:	e6ffff04 	addi	sp,fp,-4
81104088:	dfc00217 	ldw	ra,8(sp)
8110408c:	df000117 	ldw	fp,4(sp)
81104090:	dc000017 	ldw	r16,0(sp)
81104094:	dec00304 	addi	sp,sp,12
81104098:	f800283a 	ret

8110409c <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
8110409c:	deffe904 	addi	sp,sp,-92
811040a0:	de00012e 	bgeu	sp,et,811040a8 <bSdmaDmaM2Transfer+0xc>
811040a4:	003b68fa 	trap	3
811040a8:	dfc01615 	stw	ra,88(sp)
811040ac:	df001515 	stw	fp,84(sp)
811040b0:	dc001415 	stw	r16,80(sp)
811040b4:	df001504 	addi	fp,sp,84
811040b8:	e13ffb15 	stw	r4,-20(fp)
811040bc:	2809883a 	mov	r4,r5
811040c0:	3007883a 	mov	r3,r6
811040c4:	3805883a 	mov	r2,r7
811040c8:	e13ffc0d 	sth	r4,-16(fp)
811040cc:	e0fffd05 	stb	r3,-12(fp)
811040d0:	e0bffe05 	stb	r2,-8(fp)
811040d4:	defff004 	addi	sp,sp,-64
811040d8:	d8800904 	addi	r2,sp,36
811040dc:	108007c4 	addi	r2,r2,31
811040e0:	1004d17a 	srli	r2,r2,5
811040e4:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
811040e8:	00800044 	movi	r2,1
811040ec:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
811040f0:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
811040f4:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
811040f8:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
811040fc:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104100:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104104:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104108:	e0bffe03 	ldbu	r2,-8(fp)
8110410c:	10c00228 	cmpgeui	r3,r2,8
81104110:	18009c1e 	bne	r3,zero,81104384 <bSdmaDmaM2Transfer+0x2e8>
81104114:	100690ba 	slli	r3,r2,2
81104118:	00a04434 	movhi	r2,33040
8110411c:	10904b04 	addi	r2,r2,16684
81104120:	1885883a 	add	r2,r3,r2
81104124:	10800017 	ldw	r2,0(r2)
81104128:	1000683a 	jmp	r2
8110412c:	8110414c 	andi	r4,r16,16645
81104130:	8110418c 	andi	r4,r16,16646
81104134:	811041d4 	ori	r4,r16,16647
81104138:	8110421c 	xori	r4,r16,16648
8110413c:	81104264 	muli	r4,r16,16649
81104140:	811042ac 	andhi	r4,r16,16650
81104144:	811042f4 	orhi	r4,r16,16651
81104148:	8110433c 	xorhi	r4,r16,16652
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
8110414c:	e0bffd03 	ldbu	r2,-12(fp)
81104150:	10000626 	beq	r2,zero,8110416c <bSdmaDmaM2Transfer+0xd0>
81104154:	10800060 	cmpeqi	r2,r2,1
81104158:	10000926 	beq	r2,zero,81104180 <bSdmaDmaM2Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
8110415c:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104160:	00800044 	movi	r2,1
81104164:	e0bff715 	stw	r2,-36(fp)
			break;
81104168:	00000706 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
8110416c:	00800074 	movhi	r2,1
81104170:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81104174:	00800044 	movi	r2,1
81104178:	e0bff715 	stw	r2,-36(fp)
			break;
8110417c:	00000206 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		default:
			bStatus = FALSE;
81104180:	e03ff415 	stw	zero,-48(fp)
			break;
81104184:	0001883a 	nop
		}
		break;
81104188:	00008006 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
8110418c:	e0bffd03 	ldbu	r2,-12(fp)
81104190:	10000726 	beq	r2,zero,811041b0 <bSdmaDmaM2Transfer+0x114>
81104194:	10800060 	cmpeqi	r2,r2,1
81104198:	10000b26 	beq	r2,zero,811041c8 <bSdmaDmaM2Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
8110419c:	00880004 	movi	r2,8192
811041a0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811041a4:	00800044 	movi	r2,1
811041a8:	e0bff715 	stw	r2,-36(fp)
			break;
811041ac:	00000806 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811041b0:	00800074 	movhi	r2,1
811041b4:	10880004 	addi	r2,r2,8192
811041b8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811041bc:	00800044 	movi	r2,1
811041c0:	e0bff715 	stw	r2,-36(fp)
			break;
811041c4:	00000206 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		default:
			bStatus = FALSE;
811041c8:	e03ff415 	stw	zero,-48(fp)
			break;
811041cc:	0001883a 	nop
		}
		break;
811041d0:	00006e06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811041d4:	e0bffd03 	ldbu	r2,-12(fp)
811041d8:	10000726 	beq	r2,zero,811041f8 <bSdmaDmaM2Transfer+0x15c>
811041dc:	10800060 	cmpeqi	r2,r2,1
811041e0:	10000b26 	beq	r2,zero,81104210 <bSdmaDmaM2Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
811041e4:	00900004 	movi	r2,16384
811041e8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
811041ec:	00800044 	movi	r2,1
811041f0:	e0bff715 	stw	r2,-36(fp)
			break;
811041f4:	00000806 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
811041f8:	00800074 	movhi	r2,1
811041fc:	10900004 	addi	r2,r2,16384
81104200:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104204:	00800044 	movi	r2,1
81104208:	e0bff715 	stw	r2,-36(fp)
			break;
8110420c:	00000206 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		default:
			bStatus = FALSE;
81104210:	e03ff415 	stw	zero,-48(fp)
			break;
81104214:	0001883a 	nop
		}
		break;
81104218:	00005c06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
8110421c:	e0bffd03 	ldbu	r2,-12(fp)
81104220:	10000726 	beq	r2,zero,81104240 <bSdmaDmaM2Transfer+0x1a4>
81104224:	10800060 	cmpeqi	r2,r2,1
81104228:	10000b26 	beq	r2,zero,81104258 <bSdmaDmaM2Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
8110422c:	00980004 	movi	r2,24576
81104230:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104234:	00800044 	movi	r2,1
81104238:	e0bff715 	stw	r2,-36(fp)
			break;
8110423c:	00000806 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104240:	00800074 	movhi	r2,1
81104244:	10980004 	addi	r2,r2,24576
81104248:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
8110424c:	00800044 	movi	r2,1
81104250:	e0bff715 	stw	r2,-36(fp)
			break;
81104254:	00000206 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		default:
			bStatus = FALSE;
81104258:	e03ff415 	stw	zero,-48(fp)
			break;
8110425c:	0001883a 	nop
		}
		break;
81104260:	00004a06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104264:	e0bffd03 	ldbu	r2,-12(fp)
81104268:	10000726 	beq	r2,zero,81104288 <bSdmaDmaM2Transfer+0x1ec>
8110426c:	10800060 	cmpeqi	r2,r2,1
81104270:	10000b26 	beq	r2,zero,811042a0 <bSdmaDmaM2Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104274:	00a00014 	movui	r2,32768
81104278:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
8110427c:	00800044 	movi	r2,1
81104280:	e0bff715 	stw	r2,-36(fp)
			break;
81104284:	00000806 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104288:	008000b4 	movhi	r2,2
8110428c:	10a00004 	addi	r2,r2,-32768
81104290:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104294:	00800044 	movi	r2,1
81104298:	e0bff715 	stw	r2,-36(fp)
			break;
8110429c:	00000206 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		default:
			bStatus = FALSE;
811042a0:	e03ff415 	stw	zero,-48(fp)
			break;
811042a4:	0001883a 	nop
		}
		break;
811042a8:	00003806 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811042ac:	e0bffd03 	ldbu	r2,-12(fp)
811042b0:	10000726 	beq	r2,zero,811042d0 <bSdmaDmaM2Transfer+0x234>
811042b4:	10800060 	cmpeqi	r2,r2,1
811042b8:	10000b26 	beq	r2,zero,811042e8 <bSdmaDmaM2Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811042bc:	00a80014 	movui	r2,40960
811042c0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811042c4:	00800044 	movi	r2,1
811042c8:	e0bff715 	stw	r2,-36(fp)
			break;
811042cc:	00000806 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811042d0:	008000b4 	movhi	r2,2
811042d4:	10a80004 	addi	r2,r2,-24576
811042d8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
811042dc:	00800044 	movi	r2,1
811042e0:	e0bff715 	stw	r2,-36(fp)
			break;
811042e4:	00000206 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		default:
			bStatus = FALSE;
811042e8:	e03ff415 	stw	zero,-48(fp)
			break;
811042ec:	0001883a 	nop
		}
		break;
811042f0:	00002606 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811042f4:	e0bffd03 	ldbu	r2,-12(fp)
811042f8:	10000726 	beq	r2,zero,81104318 <bSdmaDmaM2Transfer+0x27c>
811042fc:	10800060 	cmpeqi	r2,r2,1
81104300:	10000b26 	beq	r2,zero,81104330 <bSdmaDmaM2Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104304:	00b00014 	movui	r2,49152
81104308:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
8110430c:	00800044 	movi	r2,1
81104310:	e0bff715 	stw	r2,-36(fp)
			break;
81104314:	00000806 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104318:	008000b4 	movhi	r2,2
8110431c:	10b00004 	addi	r2,r2,-16384
81104320:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104324:	00800044 	movi	r2,1
81104328:	e0bff715 	stw	r2,-36(fp)
			break;
8110432c:	00000206 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		default:
			bStatus = FALSE;
81104330:	e03ff415 	stw	zero,-48(fp)
			break;
81104334:	0001883a 	nop
		}
		break;
81104338:	00001406 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110433c:	e0bffd03 	ldbu	r2,-12(fp)
81104340:	10000726 	beq	r2,zero,81104360 <bSdmaDmaM2Transfer+0x2c4>
81104344:	10800060 	cmpeqi	r2,r2,1
81104348:	10000b26 	beq	r2,zero,81104378 <bSdmaDmaM2Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110434c:	00b80014 	movui	r2,57344
81104350:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104354:	00800044 	movi	r2,1
81104358:	e0bff715 	stw	r2,-36(fp)
			break;
8110435c:	00000806 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104360:	008000b4 	movhi	r2,2
81104364:	10b80004 	addi	r2,r2,-8192
81104368:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
8110436c:	00800044 	movi	r2,1
81104370:	e0bff715 	stw	r2,-36(fp)
			break;
81104374:	00000206 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		default:
			bStatus = FALSE;
81104378:	e03ff415 	stw	zero,-48(fp)
			break;
8110437c:	0001883a 	nop
		}
		break;
81104380:	00000206 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	default:
		bStatus = FALSE;
81104384:	e03ff415 	stw	zero,-48(fp)
		break;
81104388:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
8110438c:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104390:	00a00034 	movhi	r2,32768
81104394:	1885883a 	add	r2,r3,r2
81104398:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
8110439c:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
811043a0:	e0bff417 	ldw	r2,-48(fp)
811043a4:	10003b26 	beq	r2,zero,81104494 <bSdmaDmaM2Transfer+0x3f8>
		if (pxDmaM2Dev == NULL) {
811043a8:	d0a03a17 	ldw	r2,-32536(gp)
811043ac:	1000021e 	bne	r2,zero,811043b8 <bSdmaDmaM2Transfer+0x31c>
			bStatus = FALSE;
811043b0:	e03ff415 	stw	zero,-48(fp)
811043b4:	00003706 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811043b8:	e03ff50d 	sth	zero,-44(fp)
811043bc:	00003206 	br	81104488 <bSdmaDmaM2Transfer+0x3ec>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811043c0:	01000044 	movi	r4,1
811043c4:	1132e780 	call	81132e78 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811043c8:	d0a03a17 	ldw	r2,-32536(gp)
811043cc:	10800317 	ldw	r2,12(r2)
811043d0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811043d4:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
811043d8:	103ff91e 	bne	r2,zero,811043c0 <__reset+0xfb0e43c0>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811043dc:	d2203a17 	ldw	r8,-32536(gp)
811043e0:	e17ff817 	ldw	r5,-32(fp)
811043e4:	e1bff617 	ldw	r6,-40(fp)
811043e8:	e0bff917 	ldw	r2,-28(fp)
811043ec:	e0fff717 	ldw	r3,-36(fp)
811043f0:	01000044 	movi	r4,1
811043f4:	d9000815 	stw	r4,32(sp)
811043f8:	01000044 	movi	r4,1
811043fc:	d9000715 	stw	r4,28(sp)
81104400:	01000044 	movi	r4,1
81104404:	d9000615 	stw	r4,24(sp)
81104408:	01000044 	movi	r4,1
8110440c:	d9000515 	stw	r4,20(sp)
81104410:	01000044 	movi	r4,1
81104414:	d9000415 	stw	r4,16(sp)
81104418:	d8c00315 	stw	r3,12(sp)
8110441c:	d8800215 	stw	r2,8(sp)
81104420:	e0bffa17 	ldw	r2,-24(fp)
81104424:	d8800115 	stw	r2,4(sp)
81104428:	00802204 	movi	r2,136
8110442c:	d8800015 	stw	r2,0(sp)
81104430:	300f883a 	mov	r7,r6
81104434:	280d883a 	mov	r6,r5
81104438:	800b883a 	mov	r5,r16
8110443c:	4009883a 	mov	r4,r8
81104440:	110b45c0 	call	8110b45c <iMsgdmaConstructExtendedMmToMmDescriptor>
81104444:	10000226 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x3b4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104448:	e03ff415 	stw	zero,-48(fp)
					break;
8110444c:	00001106 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104450:	d0a03a17 	ldw	r2,-32536(gp)
81104454:	800b883a 	mov	r5,r16
81104458:	1009883a 	mov	r4,r2
8110445c:	110b5600 	call	8110b560 <iMsgdmaExtendedDescriptorSyncTransfer>
81104460:	10000226 	beq	r2,zero,8110446c <bSdmaDmaM2Transfer+0x3d0>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104464:	e03ff415 	stw	zero,-48(fp)
						break;
81104468:	00000a06 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
8110446c:	e0bff817 	ldw	r2,-32(fp)
81104470:	10802204 	addi	r2,r2,136
81104474:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104478:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
8110447c:	e0bff50b 	ldhu	r2,-44(fp)
81104480:	10800044 	addi	r2,r2,1
81104484:	e0bff50d 	sth	r2,-44(fp)
81104488:	e0fff50b 	ldhu	r3,-44(fp)
8110448c:	e0bffc0b 	ldhu	r2,-16(fp)
81104490:	18bfcd36 	bltu	r3,r2,811043c8 <__reset+0xfb0e43c8>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104494:	e0bff417 	ldw	r2,-48(fp)
}
81104498:	e6ffff04 	addi	sp,fp,-4
8110449c:	dfc00217 	ldw	ra,8(sp)
811044a0:	df000117 	ldw	fp,4(sp)
811044a4:	dc000017 	ldw	r16,0(sp)
811044a8:	dec00304 	addi	sp,sp,12
811044ac:	f800283a 	ret

811044b0 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
811044b0:	defff904 	addi	sp,sp,-28
811044b4:	de00012e 	bgeu	sp,et,811044bc <bCommSetGlobalIrqEn+0xc>
811044b8:	003b68fa 	trap	3
811044bc:	dfc00615 	stw	ra,24(sp)
811044c0:	df000515 	stw	fp,20(sp)
811044c4:	df000504 	addi	fp,sp,20
811044c8:	e13ffe15 	stw	r4,-8(fp)
811044cc:	2805883a 	mov	r2,r5
811044d0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811044d4:	00800044 	movi	r2,1
811044d8:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
811044dc:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
811044e0:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
811044e4:	e0bfff03 	ldbu	r2,-4(fp)
811044e8:	10c00228 	cmpgeui	r3,r2,8
811044ec:	18002e1e 	bne	r3,zero,811045a8 <bCommSetGlobalIrqEn+0xf8>
811044f0:	100690ba 	slli	r3,r2,2
811044f4:	00a04434 	movhi	r2,33040
811044f8:	10914204 	addi	r2,r2,17672
811044fc:	1885883a 	add	r2,r3,r2
81104500:	10800017 	ldw	r2,0(r2)
81104504:	1000683a 	jmp	r2
81104508:	81104528 	cmpgeui	r4,r16,16660
8110450c:	81104538 	rdprs	r4,r16,16660
81104510:	81104548 	cmpgei	r4,r16,16661
81104514:	81104558 	cmpnei	r4,r16,16661
81104518:	81104568 	cmpgeui	r4,r16,16661
8110451c:	81104578 	rdprs	r4,r16,16661
81104520:	81104588 	cmpgei	r4,r16,16662
81104524:	81104598 	cmpnei	r4,r16,16662
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104528:	00a04834 	movhi	r2,33056
8110452c:	108b0004 	addi	r2,r2,11264
81104530:	e0bffd15 	stw	r2,-12(fp)
		break;
81104534:	00001e06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104538:	00a04834 	movhi	r2,33056
8110453c:	108a0004 	addi	r2,r2,10240
81104540:	e0bffd15 	stw	r2,-12(fp)
		break;
81104544:	00001a06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104548:	00a04834 	movhi	r2,33056
8110454c:	10890004 	addi	r2,r2,9216
81104550:	e0bffd15 	stw	r2,-12(fp)
		break;
81104554:	00001606 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104558:	00a04834 	movhi	r2,33056
8110455c:	10880004 	addi	r2,r2,8192
81104560:	e0bffd15 	stw	r2,-12(fp)
		break;
81104564:	00001206 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104568:	00a04834 	movhi	r2,33056
8110456c:	10870004 	addi	r2,r2,7168
81104570:	e0bffd15 	stw	r2,-12(fp)
		break;
81104574:	00000e06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104578:	00a04834 	movhi	r2,33056
8110457c:	10860004 	addi	r2,r2,6144
81104580:	e0bffd15 	stw	r2,-12(fp)
		break;
81104584:	00000a06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104588:	00a04834 	movhi	r2,33056
8110458c:	10850004 	addi	r2,r2,5120
81104590:	e0bffd15 	stw	r2,-12(fp)
		break;
81104594:	00000606 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104598:	00a04834 	movhi	r2,33056
8110459c:	10840004 	addi	r2,r2,4096
811045a0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045a4:	00000206 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
811045a8:	e03ffb15 	stw	zero,-20(fp)
		break;
811045ac:	0001883a 	nop
	}

	if (bStatus) {
811045b0:	e0bffb17 	ldw	r2,-20(fp)
811045b4:	10001326 	beq	r2,zero,81104604 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
811045b8:	01400444 	movi	r5,17
811045bc:	e13ffd17 	ldw	r4,-12(fp)
811045c0:	110474c0 	call	8110474c <uliCommReadReg>
811045c4:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
811045c8:	e0bffe17 	ldw	r2,-8(fp)
811045cc:	10000426 	beq	r2,zero,811045e0 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
811045d0:	e0bffc17 	ldw	r2,-16(fp)
811045d4:	10800074 	orhi	r2,r2,1
811045d8:	e0bffc15 	stw	r2,-16(fp)
811045dc:	00000506 	br	811045f4 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
811045e0:	e0fffc17 	ldw	r3,-16(fp)
811045e4:	00bffff4 	movhi	r2,65535
811045e8:	10bfffc4 	addi	r2,r2,-1
811045ec:	1884703a 	and	r2,r3,r2
811045f0:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
811045f4:	e1bffc17 	ldw	r6,-16(fp)
811045f8:	01400444 	movi	r5,17
811045fc:	e13ffd17 	ldw	r4,-12(fp)
81104600:	11046f80 	call	811046f8 <vCommWriteReg>
	}

	return bStatus;
81104604:	e0bffb17 	ldw	r2,-20(fp)
}
81104608:	e037883a 	mov	sp,fp
8110460c:	dfc00117 	ldw	ra,4(sp)
81104610:	df000017 	ldw	fp,0(sp)
81104614:	dec00204 	addi	sp,sp,8
81104618:	f800283a 	ret

8110461c <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
8110461c:	defffb04 	addi	sp,sp,-20
81104620:	de00012e 	bgeu	sp,et,81104628 <bCommInitCh+0xc>
81104624:	003b68fa 	trap	3
81104628:	dfc00415 	stw	ra,16(sp)
8110462c:	df000315 	stw	fp,12(sp)
81104630:	df000304 	addi	fp,sp,12
81104634:	e13ffe15 	stw	r4,-8(fp)
81104638:	2805883a 	mov	r2,r5
8110463c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104640:	00800044 	movi	r2,1
81104644:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
81104648:	e0bffe17 	ldw	r2,-8(fp)
8110464c:	10805704 	addi	r2,r2,348
81104650:	e0ffff03 	ldbu	r3,-4(fp)
81104654:	180b883a 	mov	r5,r3
81104658:	1009883a 	mov	r4,r2
8110465c:	1109de00 	call	81109de0 <bSpwcInitCh>
81104660:	1000011e 	bne	r2,zero,81104668 <bCommInitCh+0x4c>
		bStatus = FALSE;
81104664:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
81104668:	e0bfff03 	ldbu	r2,-4(fp)
8110466c:	1009883a 	mov	r4,r2
81104670:	1105eb00 	call	81105eb0 <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104674:	e0bffe17 	ldw	r2,-8(fp)
81104678:	10800904 	addi	r2,r2,36
8110467c:	e0ffff03 	ldbu	r3,-4(fp)
81104680:	180b883a 	mov	r5,r3
81104684:	1009883a 	mov	r4,r2
81104688:	11066080 	call	81106608 <bFeebInitCh>
8110468c:	1000011e 	bne	r2,zero,81104694 <bCommInitCh+0x78>
		bStatus = FALSE;
81104690:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104694:	e0bffe17 	ldw	r2,-8(fp)
81104698:	10801104 	addi	r2,r2,68
8110469c:	e0ffff03 	ldbu	r3,-4(fp)
811046a0:	180b883a 	mov	r5,r3
811046a4:	1009883a 	mov	r4,r2
811046a8:	110943c0 	call	8110943c <bRmapInitCh>
811046ac:	1000011e 	bne	r2,zero,811046b4 <bCommInitCh+0x98>
		bStatus = FALSE;
811046b0:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
811046b4:	e0bfff03 	ldbu	r2,-4(fp)
811046b8:	1009883a 	mov	r4,r2
811046bc:	11072780 	call	81107278 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
811046c0:	e0bffe17 	ldw	r2,-8(fp)
811046c4:	10800104 	addi	r2,r2,4
811046c8:	e0ffff03 	ldbu	r3,-4(fp)
811046cc:	180b883a 	mov	r5,r3
811046d0:	1009883a 	mov	r4,r2
811046d4:	1104dc40 	call	81104dc4 <bDpktInitCh>
811046d8:	1000011e 	bne	r2,zero,811046e0 <bCommInitCh+0xc4>
		bStatus = FALSE;
811046dc:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
811046e0:	e0bffd17 	ldw	r2,-12(fp)
}
811046e4:	e037883a 	mov	sp,fp
811046e8:	dfc00117 	ldw	ra,4(sp)
811046ec:	df000017 	ldw	fp,0(sp)
811046f0:	dec00204 	addi	sp,sp,8
811046f4:	f800283a 	ret

811046f8 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811046f8:	defffc04 	addi	sp,sp,-16
811046fc:	de00012e 	bgeu	sp,et,81104704 <vCommWriteReg+0xc>
81104700:	003b68fa 	trap	3
81104704:	df000315 	stw	fp,12(sp)
81104708:	df000304 	addi	fp,sp,12
8110470c:	e13ffd15 	stw	r4,-12(fp)
81104710:	e17ffe15 	stw	r5,-8(fp)
81104714:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104718:	e0bffe17 	ldw	r2,-8(fp)
8110471c:	1085883a 	add	r2,r2,r2
81104720:	1085883a 	add	r2,r2,r2
81104724:	1007883a 	mov	r3,r2
81104728:	e0bffd17 	ldw	r2,-12(fp)
8110472c:	10c5883a 	add	r2,r2,r3
81104730:	e0ffff17 	ldw	r3,-4(fp)
81104734:	10c00015 	stw	r3,0(r2)
}
81104738:	0001883a 	nop
8110473c:	e037883a 	mov	sp,fp
81104740:	df000017 	ldw	fp,0(sp)
81104744:	dec00104 	addi	sp,sp,4
81104748:	f800283a 	ret

8110474c <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110474c:	defffc04 	addi	sp,sp,-16
81104750:	de00012e 	bgeu	sp,et,81104758 <uliCommReadReg+0xc>
81104754:	003b68fa 	trap	3
81104758:	df000315 	stw	fp,12(sp)
8110475c:	df000304 	addi	fp,sp,12
81104760:	e13ffe15 	stw	r4,-8(fp)
81104764:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104768:	e0bfff17 	ldw	r2,-4(fp)
8110476c:	1085883a 	add	r2,r2,r2
81104770:	1085883a 	add	r2,r2,r2
81104774:	1007883a 	mov	r3,r2
81104778:	e0bffe17 	ldw	r2,-8(fp)
8110477c:	10c5883a 	add	r2,r2,r3
81104780:	10800017 	ldw	r2,0(r2)
81104784:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104788:	e0bffd17 	ldw	r2,-12(fp)
}
8110478c:	e037883a 	mov	sp,fp
81104790:	df000017 	ldw	fp,0(sp)
81104794:	dec00104 	addi	sp,sp,4
81104798:	f800283a 	ret

8110479c <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
8110479c:	defffb04 	addi	sp,sp,-20
811047a0:	de00012e 	bgeu	sp,et,811047a8 <bDpktSetPacketConfig+0xc>
811047a4:	003b68fa 	trap	3
811047a8:	dfc00415 	stw	ra,16(sp)
811047ac:	df000315 	stw	fp,12(sp)
811047b0:	df000304 	addi	fp,sp,12
811047b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811047b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811047bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811047c0:	e0bfff17 	ldw	r2,-4(fp)
811047c4:	10007a26 	beq	r2,zero,811049b0 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811047c8:	e0bfff17 	ldw	r2,-4(fp)
811047cc:	10800017 	ldw	r2,0(r2)
811047d0:	01400204 	movi	r5,8
811047d4:	1009883a 	mov	r4,r2
811047d8:	1104f8c0 	call	81104f8c <uliDpktReadReg>
811047dc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
811047e0:	e0bffe17 	ldw	r2,-8(fp)
811047e4:	10bfffec 	andhi	r2,r2,65535
811047e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
811047ec:	e0bfff17 	ldw	r2,-4(fp)
811047f0:	1080010b 	ldhu	r2,4(r2)
811047f4:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
811047f8:	e0fffe17 	ldw	r3,-8(fp)
811047fc:	1884b03a 	or	r2,r3,r2
81104800:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104804:	e0bffe17 	ldw	r2,-8(fp)
81104808:	10bfffcc 	andi	r2,r2,65535
8110480c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81104810:	e0bfff17 	ldw	r2,-4(fp)
81104814:	1080018b 	ldhu	r2,6(r2)
81104818:	10bfffcc 	andi	r2,r2,65535
8110481c:	1004943a 	slli	r2,r2,16
81104820:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81104824:	e0bffe17 	ldw	r2,-8(fp)
81104828:	10c4b03a 	or	r2,r2,r3
8110482c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
81104830:	e0bfff17 	ldw	r2,-4(fp)
81104834:	10800017 	ldw	r2,0(r2)
81104838:	e1bffe17 	ldw	r6,-8(fp)
8110483c:	01400204 	movi	r5,8
81104840:	1009883a 	mov	r4,r2
81104844:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104848:	e0bfff17 	ldw	r2,-4(fp)
8110484c:	10800017 	ldw	r2,0(r2)
81104850:	01400244 	movi	r5,9
81104854:	1009883a 	mov	r4,r2
81104858:	1104f8c0 	call	81104f8c <uliDpktReadReg>
8110485c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104860:	e0bffe17 	ldw	r2,-8(fp)
81104864:	10bfffec 	andhi	r2,r2,65535
81104868:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
8110486c:	e0bfff17 	ldw	r2,-4(fp)
81104870:	1080020b 	ldhu	r2,8(r2)
81104874:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104878:	e0fffe17 	ldw	r3,-8(fp)
8110487c:	1884b03a 	or	r2,r3,r2
81104880:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104884:	e0bffe17 	ldw	r2,-8(fp)
81104888:	10bfffcc 	andi	r2,r2,65535
8110488c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104890:	e0bfff17 	ldw	r2,-4(fp)
81104894:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104898:	10bfffcc 	andi	r2,r2,65535
8110489c:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
811048a0:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
811048a4:	e0bffe17 	ldw	r2,-8(fp)
811048a8:	10c4b03a 	or	r2,r2,r3
811048ac:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
811048b0:	e0bfff17 	ldw	r2,-4(fp)
811048b4:	10800017 	ldw	r2,0(r2)
811048b8:	e1bffe17 	ldw	r6,-8(fp)
811048bc:	01400244 	movi	r5,9
811048c0:	1009883a 	mov	r4,r2
811048c4:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048c8:	e0bfff17 	ldw	r2,-4(fp)
811048cc:	10800017 	ldw	r2,0(r2)
811048d0:	01400284 	movi	r5,10
811048d4:	1009883a 	mov	r4,r2
811048d8:	1104f8c0 	call	81104f8c <uliDpktReadReg>
811048dc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
811048e0:	e0bffe17 	ldw	r2,-8(fp)
811048e4:	10bfffec 	andhi	r2,r2,65535
811048e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
811048ec:	e0bfff17 	ldw	r2,-4(fp)
811048f0:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
811048f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
811048f8:	e0fffe17 	ldw	r3,-8(fp)
811048fc:	1884b03a 	or	r2,r3,r2
81104900:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104904:	e0bfff17 	ldw	r2,-4(fp)
81104908:	10800017 	ldw	r2,0(r2)
8110490c:	e1bffe17 	ldw	r6,-8(fp)
81104910:	01400284 	movi	r5,10
81104914:	1009883a 	mov	r4,r2
81104918:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110491c:	e0bfff17 	ldw	r2,-4(fp)
81104920:	10800017 	ldw	r2,0(r2)
81104924:	014002c4 	movi	r5,11
81104928:	1009883a 	mov	r4,r2
8110492c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104930:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104934:	e0fffe17 	ldw	r3,-8(fp)
81104938:	00bfc004 	movi	r2,-256
8110493c:	1884703a 	and	r2,r3,r2
81104940:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104944:	e0bfff17 	ldw	r2,-4(fp)
81104948:	10800383 	ldbu	r2,14(r2)
8110494c:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81104950:	e0fffe17 	ldw	r3,-8(fp)
81104954:	1884b03a 	or	r2,r3,r2
81104958:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
8110495c:	e0fffe17 	ldw	r3,-8(fp)
81104960:	00bffff4 	movhi	r2,65535
81104964:	10803fc4 	addi	r2,r2,255
81104968:	1884703a 	and	r2,r3,r2
8110496c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104970:	e0bfff17 	ldw	r2,-4(fp)
81104974:	108003c3 	ldbu	r2,15(r2)
81104978:	10803fcc 	andi	r2,r2,255
8110497c:	1004923a 	slli	r2,r2,8
81104980:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104984:	e0fffe17 	ldw	r3,-8(fp)
81104988:	1884b03a 	or	r2,r3,r2
8110498c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104990:	e0bfff17 	ldw	r2,-4(fp)
81104994:	10800017 	ldw	r2,0(r2)
81104998:	e1bffe17 	ldw	r6,-8(fp)
8110499c:	014002c4 	movi	r5,11
811049a0:	1009883a 	mov	r4,r2
811049a4:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
811049a8:	00800044 	movi	r2,1
811049ac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811049b0:	e0bffd17 	ldw	r2,-12(fp)
}
811049b4:	e037883a 	mov	sp,fp
811049b8:	dfc00117 	ldw	ra,4(sp)
811049bc:	df000017 	ldw	fp,0(sp)
811049c0:	dec00204 	addi	sp,sp,8
811049c4:	f800283a 	ret

811049c8 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
811049c8:	defffb04 	addi	sp,sp,-20
811049cc:	de00012e 	bgeu	sp,et,811049d4 <bDpktGetPacketConfig+0xc>
811049d0:	003b68fa 	trap	3
811049d4:	dfc00415 	stw	ra,16(sp)
811049d8:	df000315 	stw	fp,12(sp)
811049dc:	df000304 	addi	fp,sp,12
811049e0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811049e4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811049e8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811049ec:	e0bfff17 	ldw	r2,-4(fp)
811049f0:	10003a26 	beq	r2,zero,81104adc <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049f4:	e0bfff17 	ldw	r2,-4(fp)
811049f8:	10800017 	ldw	r2,0(r2)
811049fc:	01400204 	movi	r5,8
81104a00:	1009883a 	mov	r4,r2
81104a04:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a08:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104a0c:	e0bffe17 	ldw	r2,-8(fp)
81104a10:	1007883a 	mov	r3,r2
81104a14:	e0bfff17 	ldw	r2,-4(fp)
81104a18:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104a1c:	e0bffe17 	ldw	r2,-8(fp)
81104a20:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104a24:	1007883a 	mov	r3,r2
81104a28:	e0bfff17 	ldw	r2,-4(fp)
81104a2c:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a30:	e0bfff17 	ldw	r2,-4(fp)
81104a34:	10800017 	ldw	r2,0(r2)
81104a38:	01400244 	movi	r5,9
81104a3c:	1009883a 	mov	r4,r2
81104a40:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a44:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104a48:	e0bffe17 	ldw	r2,-8(fp)
81104a4c:	1007883a 	mov	r3,r2
81104a50:	e0bfff17 	ldw	r2,-4(fp)
81104a54:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104a58:	e0bffe17 	ldw	r2,-8(fp)
81104a5c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104a60:	1007883a 	mov	r3,r2
81104a64:	e0bfff17 	ldw	r2,-4(fp)
81104a68:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a6c:	e0bfff17 	ldw	r2,-4(fp)
81104a70:	10800017 	ldw	r2,0(r2)
81104a74:	01400284 	movi	r5,10
81104a78:	1009883a 	mov	r4,r2
81104a7c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a80:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104a84:	e0bffe17 	ldw	r2,-8(fp)
81104a88:	1007883a 	mov	r3,r2
81104a8c:	e0bfff17 	ldw	r2,-4(fp)
81104a90:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a94:	e0bfff17 	ldw	r2,-4(fp)
81104a98:	10800017 	ldw	r2,0(r2)
81104a9c:	014002c4 	movi	r5,11
81104aa0:	1009883a 	mov	r4,r2
81104aa4:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104aa8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104aac:	e0bffe17 	ldw	r2,-8(fp)
81104ab0:	1007883a 	mov	r3,r2
81104ab4:	e0bfff17 	ldw	r2,-4(fp)
81104ab8:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104abc:	e0bffe17 	ldw	r2,-8(fp)
81104ac0:	10bfc00c 	andi	r2,r2,65280
81104ac4:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104ac8:	1007883a 	mov	r3,r2
81104acc:	e0bfff17 	ldw	r2,-4(fp)
81104ad0:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104ad4:	00800044 	movi	r2,1
81104ad8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104adc:	e0bffd17 	ldw	r2,-12(fp)
}
81104ae0:	e037883a 	mov	sp,fp
81104ae4:	dfc00117 	ldw	ra,4(sp)
81104ae8:	df000017 	ldw	fp,0(sp)
81104aec:	dec00204 	addi	sp,sp,8
81104af0:	f800283a 	ret

81104af4 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104af4:	defffb04 	addi	sp,sp,-20
81104af8:	de00012e 	bgeu	sp,et,81104b00 <bDpktGetPacketHeader+0xc>
81104afc:	003b68fa 	trap	3
81104b00:	dfc00415 	stw	ra,16(sp)
81104b04:	df000315 	stw	fp,12(sp)
81104b08:	df000304 	addi	fp,sp,12
81104b0c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b10:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b14:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104b18:	e0bfff17 	ldw	r2,-4(fp)
81104b1c:	10002026 	beq	r2,zero,81104ba0 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b20:	e0bfff17 	ldw	r2,-4(fp)
81104b24:	10800017 	ldw	r2,0(r2)
81104b28:	01400304 	movi	r5,12
81104b2c:	1009883a 	mov	r4,r2
81104b30:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104b34:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104b38:	e0bffe17 	ldw	r2,-8(fp)
81104b3c:	1007883a 	mov	r3,r2
81104b40:	e0bfff17 	ldw	r2,-4(fp)
81104b44:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104b48:	e0bffe17 	ldw	r2,-8(fp)
81104b4c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104b50:	1007883a 	mov	r3,r2
81104b54:	e0bfff17 	ldw	r2,-4(fp)
81104b58:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b5c:	e0bfff17 	ldw	r2,-4(fp)
81104b60:	10800017 	ldw	r2,0(r2)
81104b64:	01400344 	movi	r5,13
81104b68:	1009883a 	mov	r4,r2
81104b6c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104b70:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104b74:	e0bffe17 	ldw	r2,-8(fp)
81104b78:	1007883a 	mov	r3,r2
81104b7c:	e0bfff17 	ldw	r2,-4(fp)
81104b80:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104b84:	e0bffe17 	ldw	r2,-8(fp)
81104b88:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104b8c:	1007883a 	mov	r3,r2
81104b90:	e0bfff17 	ldw	r2,-4(fp)
81104b94:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104b98:	00800044 	movi	r2,1
81104b9c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ba0:	e0bffd17 	ldw	r2,-12(fp)
}
81104ba4:	e037883a 	mov	sp,fp
81104ba8:	dfc00117 	ldw	ra,4(sp)
81104bac:	df000017 	ldw	fp,0(sp)
81104bb0:	dec00204 	addi	sp,sp,8
81104bb4:	f800283a 	ret

81104bb8 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104bb8:	defffb04 	addi	sp,sp,-20
81104bbc:	de00012e 	bgeu	sp,et,81104bc4 <bDpktSetPixelDelay+0xc>
81104bc0:	003b68fa 	trap	3
81104bc4:	dfc00415 	stw	ra,16(sp)
81104bc8:	df000315 	stw	fp,12(sp)
81104bcc:	df000304 	addi	fp,sp,12
81104bd0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104bd4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104bd8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bdc:	e0bfff17 	ldw	r2,-4(fp)
81104be0:	10004126 	beq	r2,zero,81104ce8 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104be4:	e0bfff17 	ldw	r2,-4(fp)
81104be8:	10800017 	ldw	r2,0(r2)
81104bec:	01400384 	movi	r5,14
81104bf0:	1009883a 	mov	r4,r2
81104bf4:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104bf8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104bfc:	e0bffe17 	ldw	r2,-8(fp)
81104c00:	10bfffec 	andhi	r2,r2,65535
81104c04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104c08:	e0bfff17 	ldw	r2,-4(fp)
81104c0c:	1080060b 	ldhu	r2,24(r2)
81104c10:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104c14:	e0fffe17 	ldw	r3,-8(fp)
81104c18:	1884b03a 	or	r2,r3,r2
81104c1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104c20:	e0bfff17 	ldw	r2,-4(fp)
81104c24:	10800017 	ldw	r2,0(r2)
81104c28:	e1bffe17 	ldw	r6,-8(fp)
81104c2c:	01400384 	movi	r5,14
81104c30:	1009883a 	mov	r4,r2
81104c34:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c38:	e0bfff17 	ldw	r2,-4(fp)
81104c3c:	10800017 	ldw	r2,0(r2)
81104c40:	014003c4 	movi	r5,15
81104c44:	1009883a 	mov	r4,r2
81104c48:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104c4c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104c50:	e0bffe17 	ldw	r2,-8(fp)
81104c54:	10bfffec 	andhi	r2,r2,65535
81104c58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104c5c:	e0bfff17 	ldw	r2,-4(fp)
81104c60:	1080068b 	ldhu	r2,26(r2)
81104c64:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104c68:	e0fffe17 	ldw	r3,-8(fp)
81104c6c:	1884b03a 	or	r2,r3,r2
81104c70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104c74:	e0bfff17 	ldw	r2,-4(fp)
81104c78:	10800017 	ldw	r2,0(r2)
81104c7c:	e1bffe17 	ldw	r6,-8(fp)
81104c80:	014003c4 	movi	r5,15
81104c84:	1009883a 	mov	r4,r2
81104c88:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c8c:	e0bfff17 	ldw	r2,-4(fp)
81104c90:	10800017 	ldw	r2,0(r2)
81104c94:	01400404 	movi	r5,16
81104c98:	1009883a 	mov	r4,r2
81104c9c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104ca0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104ca4:	e0bffe17 	ldw	r2,-8(fp)
81104ca8:	10bfffec 	andhi	r2,r2,65535
81104cac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104cb0:	e0bfff17 	ldw	r2,-4(fp)
81104cb4:	1080070b 	ldhu	r2,28(r2)
81104cb8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104cbc:	e0fffe17 	ldw	r3,-8(fp)
81104cc0:	1884b03a 	or	r2,r3,r2
81104cc4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104cc8:	e0bfff17 	ldw	r2,-4(fp)
81104ccc:	10800017 	ldw	r2,0(r2)
81104cd0:	e1bffe17 	ldw	r6,-8(fp)
81104cd4:	01400404 	movi	r5,16
81104cd8:	1009883a 	mov	r4,r2
81104cdc:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104ce0:	00800044 	movi	r2,1
81104ce4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ce8:	e0bffd17 	ldw	r2,-12(fp)
}
81104cec:	e037883a 	mov	sp,fp
81104cf0:	dfc00117 	ldw	ra,4(sp)
81104cf4:	df000017 	ldw	fp,0(sp)
81104cf8:	dec00204 	addi	sp,sp,8
81104cfc:	f800283a 	ret

81104d00 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104d00:	defffb04 	addi	sp,sp,-20
81104d04:	de00012e 	bgeu	sp,et,81104d0c <bDpktGetPixelDelay+0xc>
81104d08:	003b68fa 	trap	3
81104d0c:	dfc00415 	stw	ra,16(sp)
81104d10:	df000315 	stw	fp,12(sp)
81104d14:	df000304 	addi	fp,sp,12
81104d18:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d1c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d20:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104d24:	e0bfff17 	ldw	r2,-4(fp)
81104d28:	10002026 	beq	r2,zero,81104dac <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d2c:	e0bfff17 	ldw	r2,-4(fp)
81104d30:	10800017 	ldw	r2,0(r2)
81104d34:	01400384 	movi	r5,14
81104d38:	1009883a 	mov	r4,r2
81104d3c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d40:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104d44:	e0bffe17 	ldw	r2,-8(fp)
81104d48:	1007883a 	mov	r3,r2
81104d4c:	e0bfff17 	ldw	r2,-4(fp)
81104d50:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d54:	e0bfff17 	ldw	r2,-4(fp)
81104d58:	10800017 	ldw	r2,0(r2)
81104d5c:	014003c4 	movi	r5,15
81104d60:	1009883a 	mov	r4,r2
81104d64:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d68:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104d6c:	e0bffe17 	ldw	r2,-8(fp)
81104d70:	1007883a 	mov	r3,r2
81104d74:	e0bfff17 	ldw	r2,-4(fp)
81104d78:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d7c:	e0bfff17 	ldw	r2,-4(fp)
81104d80:	10800017 	ldw	r2,0(r2)
81104d84:	01400404 	movi	r5,16
81104d88:	1009883a 	mov	r4,r2
81104d8c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d90:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104d94:	e0bffe17 	ldw	r2,-8(fp)
81104d98:	1007883a 	mov	r3,r2
81104d9c:	e0bfff17 	ldw	r2,-4(fp)
81104da0:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104da4:	00800044 	movi	r2,1
81104da8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104dac:	e0bffd17 	ldw	r2,-12(fp)
}
81104db0:	e037883a 	mov	sp,fp
81104db4:	dfc00117 	ldw	ra,4(sp)
81104db8:	df000017 	ldw	fp,0(sp)
81104dbc:	dec00204 	addi	sp,sp,8
81104dc0:	f800283a 	ret

81104dc4 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104dc4:	defffb04 	addi	sp,sp,-20
81104dc8:	de00012e 	bgeu	sp,et,81104dd0 <bDpktInitCh+0xc>
81104dcc:	003b68fa 	trap	3
81104dd0:	dfc00415 	stw	ra,16(sp)
81104dd4:	df000315 	stw	fp,12(sp)
81104dd8:	df000304 	addi	fp,sp,12
81104ddc:	e13ffe15 	stw	r4,-8(fp)
81104de0:	2805883a 	mov	r2,r5
81104de4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104de8:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104dec:	e0bffe17 	ldw	r2,-8(fp)
81104df0:	10004b26 	beq	r2,zero,81104f20 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104df4:	00800044 	movi	r2,1
81104df8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104dfc:	e0bfff03 	ldbu	r2,-4(fp)
81104e00:	10c00228 	cmpgeui	r3,r2,8
81104e04:	1800361e 	bne	r3,zero,81104ee0 <bDpktInitCh+0x11c>
81104e08:	100690ba 	slli	r3,r2,2
81104e0c:	00a04434 	movhi	r2,33040
81104e10:	10938804 	addi	r2,r2,20000
81104e14:	1885883a 	add	r2,r3,r2
81104e18:	10800017 	ldw	r2,0(r2)
81104e1c:	1000683a 	jmp	r2
81104e20:	81104e40 	call	881104e4 <__reset+0x20f04e4>
81104e24:	81104e54 	ori	r4,r16,16697
81104e28:	81104e68 	cmpgeui	r4,r16,16697
81104e2c:	81104e7c 	xorhi	r4,r16,16697
81104e30:	81104e90 	cmplti	r4,r16,16698
81104e34:	81104ea4 	muli	r4,r16,16698
81104e38:	81104eb8 	rdprs	r4,r16,16698
81104e3c:	81104ecc 	andi	r4,r16,16699
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104e40:	e0fffe17 	ldw	r3,-8(fp)
81104e44:	00a04834 	movhi	r2,33056
81104e48:	108b0004 	addi	r2,r2,11264
81104e4c:	18800015 	stw	r2,0(r3)
			break;
81104e50:	00002506 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104e54:	e0fffe17 	ldw	r3,-8(fp)
81104e58:	00a04834 	movhi	r2,33056
81104e5c:	108a0004 	addi	r2,r2,10240
81104e60:	18800015 	stw	r2,0(r3)
			break;
81104e64:	00002006 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104e68:	e0fffe17 	ldw	r3,-8(fp)
81104e6c:	00a04834 	movhi	r2,33056
81104e70:	10890004 	addi	r2,r2,9216
81104e74:	18800015 	stw	r2,0(r3)
			break;
81104e78:	00001b06 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104e7c:	e0fffe17 	ldw	r3,-8(fp)
81104e80:	00a04834 	movhi	r2,33056
81104e84:	10880004 	addi	r2,r2,8192
81104e88:	18800015 	stw	r2,0(r3)
			break;
81104e8c:	00001606 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104e90:	e0fffe17 	ldw	r3,-8(fp)
81104e94:	00a04834 	movhi	r2,33056
81104e98:	10870004 	addi	r2,r2,7168
81104e9c:	18800015 	stw	r2,0(r3)
			break;
81104ea0:	00001106 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104ea4:	e0fffe17 	ldw	r3,-8(fp)
81104ea8:	00a04834 	movhi	r2,33056
81104eac:	10860004 	addi	r2,r2,6144
81104eb0:	18800015 	stw	r2,0(r3)
			break;
81104eb4:	00000c06 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104eb8:	e0fffe17 	ldw	r3,-8(fp)
81104ebc:	00a04834 	movhi	r2,33056
81104ec0:	10850004 	addi	r2,r2,5120
81104ec4:	18800015 	stw	r2,0(r3)
			break;
81104ec8:	00000706 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104ecc:	e0fffe17 	ldw	r3,-8(fp)
81104ed0:	00a04834 	movhi	r2,33056
81104ed4:	10840004 	addi	r2,r2,4096
81104ed8:	18800015 	stw	r2,0(r3)
			break;
81104edc:	00000206 	br	81104ee8 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104ee0:	e03ffd15 	stw	zero,-12(fp)
			break;
81104ee4:	0001883a 	nop
		}

		if (bStatus) {
81104ee8:	e0bffd17 	ldw	r2,-12(fp)
81104eec:	10000c26 	beq	r2,zero,81104f20 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104ef0:	e13ffe17 	ldw	r4,-8(fp)
81104ef4:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
81104ef8:	1000011e 	bne	r2,zero,81104f00 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104efc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104f00:	e13ffe17 	ldw	r4,-8(fp)
81104f04:	1104af40 	call	81104af4 <bDpktGetPacketHeader>
81104f08:	1000011e 	bne	r2,zero,81104f10 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104f0c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104f10:	e13ffe17 	ldw	r4,-8(fp)
81104f14:	1104d000 	call	81104d00 <bDpktGetPixelDelay>
81104f18:	1000011e 	bne	r2,zero,81104f20 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104f1c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104f20:	e0bffd17 	ldw	r2,-12(fp)
}
81104f24:	e037883a 	mov	sp,fp
81104f28:	dfc00117 	ldw	ra,4(sp)
81104f2c:	df000017 	ldw	fp,0(sp)
81104f30:	dec00204 	addi	sp,sp,8
81104f34:	f800283a 	ret

81104f38 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104f38:	defffc04 	addi	sp,sp,-16
81104f3c:	de00012e 	bgeu	sp,et,81104f44 <vDpktWriteReg+0xc>
81104f40:	003b68fa 	trap	3
81104f44:	df000315 	stw	fp,12(sp)
81104f48:	df000304 	addi	fp,sp,12
81104f4c:	e13ffd15 	stw	r4,-12(fp)
81104f50:	e17ffe15 	stw	r5,-8(fp)
81104f54:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104f58:	e0bffe17 	ldw	r2,-8(fp)
81104f5c:	1085883a 	add	r2,r2,r2
81104f60:	1085883a 	add	r2,r2,r2
81104f64:	1007883a 	mov	r3,r2
81104f68:	e0bffd17 	ldw	r2,-12(fp)
81104f6c:	10c5883a 	add	r2,r2,r3
81104f70:	e0ffff17 	ldw	r3,-4(fp)
81104f74:	10c00015 	stw	r3,0(r2)
}
81104f78:	0001883a 	nop
81104f7c:	e037883a 	mov	sp,fp
81104f80:	df000017 	ldw	fp,0(sp)
81104f84:	dec00104 	addi	sp,sp,4
81104f88:	f800283a 	ret

81104f8c <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81104f8c:	defffc04 	addi	sp,sp,-16
81104f90:	de00012e 	bgeu	sp,et,81104f98 <uliDpktReadReg+0xc>
81104f94:	003b68fa 	trap	3
81104f98:	df000315 	stw	fp,12(sp)
81104f9c:	df000304 	addi	fp,sp,12
81104fa0:	e13ffe15 	stw	r4,-8(fp)
81104fa4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104fa8:	e0bfff17 	ldw	r2,-4(fp)
81104fac:	1085883a 	add	r2,r2,r2
81104fb0:	1085883a 	add	r2,r2,r2
81104fb4:	1007883a 	mov	r3,r2
81104fb8:	e0bffe17 	ldw	r2,-8(fp)
81104fbc:	10c5883a 	add	r2,r2,r3
81104fc0:	10800017 	ldw	r2,0(r2)
81104fc4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104fc8:	e0bffd17 	ldw	r2,-12(fp)
}
81104fcc:	e037883a 	mov	sp,fp
81104fd0:	df000017 	ldw	fp,0(sp)
81104fd4:	dec00104 	addi	sp,sp,4
81104fd8:	f800283a 	ret

81104fdc <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81104fdc:	defffb04 	addi	sp,sp,-20
81104fe0:	de00012e 	bgeu	sp,et,81104fe8 <vFeebCh1HandleIrq+0xc>
81104fe4:	003b68fa 	trap	3
81104fe8:	dfc00415 	stw	ra,16(sp)
81104fec:	df000315 	stw	fp,12(sp)
81104ff0:	df000304 	addi	fp,sp,12
81104ff4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104ff8:	e0bfff17 	ldw	r2,-4(fp)
81104ffc:	e0bffd15 	stw	r2,-12(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
81105000:	11053300 	call	81105330 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
81105004:	0001883a 	nop
81105008:	e037883a 	mov	sp,fp
8110500c:	dfc00117 	ldw	ra,4(sp)
81105010:	df000017 	ldw	fp,0(sp)
81105014:	dec00204 	addi	sp,sp,8
81105018:	f800283a 	ret

8110501c <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
8110501c:	defffa04 	addi	sp,sp,-24
81105020:	de00012e 	bgeu	sp,et,81105028 <vFeebCh2HandleIrq+0xc>
81105024:	003b68fa 	trap	3
81105028:	dfc00515 	stw	ra,20(sp)
8110502c:	df000415 	stw	fp,16(sp)
81105030:	df000404 	addi	fp,sp,16
81105034:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105038:	e0bfff17 	ldw	r2,-4(fp)
8110503c:	e0bffc15 	stw	r2,-16(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105040:	00800404 	movi	r2,16
81105044:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105048:	00bfe004 	movi	r2,-128
8110504c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105050:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 1;
81105054:	00800044 	movi	r2,1
81105058:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110505c:	d0a05c17 	ldw	r2,-32400(gp)
81105060:	e0fffe17 	ldw	r3,-8(fp)
81105064:	180b883a 	mov	r5,r3
81105068:	1009883a 	mov	r4,r2
8110506c:	113ac000 	call	8113ac00 <OSQPost>
81105070:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105074:	e0bffd03 	ldbu	r2,-12(fp)
81105078:	10000226 	beq	r2,zero,81105084 <vFeebCh2HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 1 );
8110507c:	01000044 	movi	r4,1
81105080:	111a1400 	call	8111a140 <vFailRequestDMAFromIRQ>
	}

	vFeebCh2IrqFlagClrBufferEmpty();
81105084:	11053740 	call	81105374 <vFeebCh2IrqFlagClrBufferEmpty>
}
81105088:	0001883a 	nop
8110508c:	e037883a 	mov	sp,fp
81105090:	dfc00117 	ldw	ra,4(sp)
81105094:	df000017 	ldw	fp,0(sp)
81105098:	dec00204 	addi	sp,sp,8
8110509c:	f800283a 	ret

811050a0 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
811050a0:	defffa04 	addi	sp,sp,-24
811050a4:	de00012e 	bgeu	sp,et,811050ac <vFeebCh3HandleIrq+0xc>
811050a8:	003b68fa 	trap	3
811050ac:	dfc00515 	stw	ra,20(sp)
811050b0:	df000415 	stw	fp,16(sp)
811050b4:	df000404 	addi	fp,sp,16
811050b8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811050bc:	e0bfff17 	ldw	r2,-4(fp)
811050c0:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811050c4:	00800404 	movi	r2,16
811050c8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811050cc:	00bfe004 	movi	r2,-128
811050d0:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811050d4:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
811050d8:	00800084 	movi	r2,2
811050dc:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811050e0:	d0a05c17 	ldw	r2,-32400(gp)
811050e4:	e0fffe17 	ldw	r3,-8(fp)
811050e8:	180b883a 	mov	r5,r3
811050ec:	1009883a 	mov	r4,r2
811050f0:	113ac000 	call	8113ac00 <OSQPost>
811050f4:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811050f8:	e0bffd03 	ldbu	r2,-12(fp)
811050fc:	10000226 	beq	r2,zero,81105108 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
81105100:	01000084 	movi	r4,2
81105104:	111a1400 	call	8111a140 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
81105108:	11053b80 	call	811053b8 <vFeebCh3IrqFlagClrBufferEmpty>
}
8110510c:	0001883a 	nop
81105110:	e037883a 	mov	sp,fp
81105114:	dfc00117 	ldw	ra,4(sp)
81105118:	df000017 	ldw	fp,0(sp)
8110511c:	dec00204 	addi	sp,sp,8
81105120:	f800283a 	ret

81105124 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81105124:	defffa04 	addi	sp,sp,-24
81105128:	de00012e 	bgeu	sp,et,81105130 <vFeebCh4HandleIrq+0xc>
8110512c:	003b68fa 	trap	3
81105130:	dfc00515 	stw	ra,20(sp)
81105134:	df000415 	stw	fp,16(sp)
81105138:	df000404 	addi	fp,sp,16
8110513c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105140:	e0bfff17 	ldw	r2,-4(fp)
81105144:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105148:	00800404 	movi	r2,16
8110514c:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105150:	00bfe004 	movi	r2,-128
81105154:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105158:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
8110515c:	008000c4 	movi	r2,3
81105160:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105164:	d0a05c17 	ldw	r2,-32400(gp)
81105168:	e0fffe17 	ldw	r3,-8(fp)
8110516c:	180b883a 	mov	r5,r3
81105170:	1009883a 	mov	r4,r2
81105174:	113ac000 	call	8113ac00 <OSQPost>
81105178:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110517c:	e0bffd03 	ldbu	r2,-12(fp)
81105180:	10000226 	beq	r2,zero,8110518c <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
81105184:	010000c4 	movi	r4,3
81105188:	111a1400 	call	8111a140 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
8110518c:	11053fc0 	call	811053fc <vFeebCh4IrqFlagClrBufferEmpty>
}
81105190:	0001883a 	nop
81105194:	e037883a 	mov	sp,fp
81105198:	dfc00117 	ldw	ra,4(sp)
8110519c:	df000017 	ldw	fp,0(sp)
811051a0:	dec00204 	addi	sp,sp,8
811051a4:	f800283a 	ret

811051a8 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
811051a8:	defffa04 	addi	sp,sp,-24
811051ac:	de00012e 	bgeu	sp,et,811051b4 <vFeebCh5HandleIrq+0xc>
811051b0:	003b68fa 	trap	3
811051b4:	dfc00515 	stw	ra,20(sp)
811051b8:	df000415 	stw	fp,16(sp)
811051bc:	df000404 	addi	fp,sp,16
811051c0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051c4:	e0bfff17 	ldw	r2,-4(fp)
811051c8:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811051cc:	00800404 	movi	r2,16
811051d0:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811051d4:	00bfe004 	movi	r2,-128
811051d8:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811051dc:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
811051e0:	00800104 	movi	r2,4
811051e4:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811051e8:	d0a05c17 	ldw	r2,-32400(gp)
811051ec:	e0fffe17 	ldw	r3,-8(fp)
811051f0:	180b883a 	mov	r5,r3
811051f4:	1009883a 	mov	r4,r2
811051f8:	113ac000 	call	8113ac00 <OSQPost>
811051fc:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105200:	e0bffd03 	ldbu	r2,-12(fp)
81105204:	10000226 	beq	r2,zero,81105210 <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
81105208:	01000104 	movi	r4,4
8110520c:	111a1400 	call	8111a140 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
81105210:	11054400 	call	81105440 <vFeebCh5IrqFlagClrBufferEmpty>
}
81105214:	0001883a 	nop
81105218:	e037883a 	mov	sp,fp
8110521c:	dfc00117 	ldw	ra,4(sp)
81105220:	df000017 	ldw	fp,0(sp)
81105224:	dec00204 	addi	sp,sp,8
81105228:	f800283a 	ret

8110522c <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
8110522c:	defffa04 	addi	sp,sp,-24
81105230:	de00012e 	bgeu	sp,et,81105238 <vFeebCh6HandleIrq+0xc>
81105234:	003b68fa 	trap	3
81105238:	dfc00515 	stw	ra,20(sp)
8110523c:	df000415 	stw	fp,16(sp)
81105240:	df000404 	addi	fp,sp,16
81105244:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105248:	e0bfff17 	ldw	r2,-4(fp)
8110524c:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105250:	00800404 	movi	r2,16
81105254:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105258:	00bfe004 	movi	r2,-128
8110525c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105260:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
81105264:	00800144 	movi	r2,5
81105268:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110526c:	d0a05c17 	ldw	r2,-32400(gp)
81105270:	e0fffe17 	ldw	r3,-8(fp)
81105274:	180b883a 	mov	r5,r3
81105278:	1009883a 	mov	r4,r2
8110527c:	113ac000 	call	8113ac00 <OSQPost>
81105280:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105284:	e0bffd03 	ldbu	r2,-12(fp)
81105288:	10000226 	beq	r2,zero,81105294 <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
8110528c:	01000144 	movi	r4,5
81105290:	111a1400 	call	8111a140 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
81105294:	11054840 	call	81105484 <vFeebCh6IrqFlagClrBufferEmpty>
}
81105298:	0001883a 	nop
8110529c:	e037883a 	mov	sp,fp
811052a0:	dfc00117 	ldw	ra,4(sp)
811052a4:	df000017 	ldw	fp,0(sp)
811052a8:	dec00204 	addi	sp,sp,8
811052ac:	f800283a 	ret

811052b0 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811052b0:	defffc04 	addi	sp,sp,-16
811052b4:	de00012e 	bgeu	sp,et,811052bc <vFeebCh7HandleIrq+0xc>
811052b8:	003b68fa 	trap	3
811052bc:	dfc00315 	stw	ra,12(sp)
811052c0:	df000215 	stw	fp,8(sp)
811052c4:	df000204 	addi	fp,sp,8
811052c8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811052cc:	e0bfff17 	ldw	r2,-4(fp)
811052d0:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
811052d4:	11054c80 	call	811054c8 <vFeebCh7IrqFlagClrBufferEmpty>
}
811052d8:	0001883a 	nop
811052dc:	e037883a 	mov	sp,fp
811052e0:	dfc00117 	ldw	ra,4(sp)
811052e4:	df000017 	ldw	fp,0(sp)
811052e8:	dec00204 	addi	sp,sp,8
811052ec:	f800283a 	ret

811052f0 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
811052f0:	defffc04 	addi	sp,sp,-16
811052f4:	de00012e 	bgeu	sp,et,811052fc <vFeebCh8HandleIrq+0xc>
811052f8:	003b68fa 	trap	3
811052fc:	dfc00315 	stw	ra,12(sp)
81105300:	df000215 	stw	fp,8(sp)
81105304:	df000204 	addi	fp,sp,8
81105308:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110530c:	e0bfff17 	ldw	r2,-4(fp)
81105310:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
81105314:	110550c0 	call	8110550c <vFeebCh8IrqFlagClrBufferEmpty>
}
81105318:	0001883a 	nop
8110531c:	e037883a 	mov	sp,fp
81105320:	dfc00117 	ldw	ra,4(sp)
81105324:	df000017 	ldw	fp,0(sp)
81105328:	dec00204 	addi	sp,sp,8
8110532c:	f800283a 	ret

81105330 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105330:	defffe04 	addi	sp,sp,-8
81105334:	de00012e 	bgeu	sp,et,8110533c <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105338:	003b68fa 	trap	3
8110533c:	dfc00115 	stw	ra,4(sp)
81105340:	df000015 	stw	fp,0(sp)
81105344:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105348:	01804004 	movi	r6,256
8110534c:	014004c4 	movi	r5,19
81105350:	01204834 	movhi	r4,33056
81105354:	210b0004 	addi	r4,r4,11264
81105358:	110678c0 	call	8110678c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110535c:	0001883a 	nop
81105360:	e037883a 	mov	sp,fp
81105364:	dfc00117 	ldw	ra,4(sp)
81105368:	df000017 	ldw	fp,0(sp)
8110536c:	dec00204 	addi	sp,sp,8
81105370:	f800283a 	ret

81105374 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
81105374:	defffe04 	addi	sp,sp,-8
81105378:	de00012e 	bgeu	sp,et,81105380 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
8110537c:	003b68fa 	trap	3
81105380:	dfc00115 	stw	ra,4(sp)
81105384:	df000015 	stw	fp,0(sp)
81105388:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110538c:	01804004 	movi	r6,256
81105390:	014004c4 	movi	r5,19
81105394:	01204834 	movhi	r4,33056
81105398:	210a0004 	addi	r4,r4,10240
8110539c:	110678c0 	call	8110678c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811053a0:	0001883a 	nop
811053a4:	e037883a 	mov	sp,fp
811053a8:	dfc00117 	ldw	ra,4(sp)
811053ac:	df000017 	ldw	fp,0(sp)
811053b0:	dec00204 	addi	sp,sp,8
811053b4:	f800283a 	ret

811053b8 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
811053b8:	defffe04 	addi	sp,sp,-8
811053bc:	de00012e 	bgeu	sp,et,811053c4 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
811053c0:	003b68fa 	trap	3
811053c4:	dfc00115 	stw	ra,4(sp)
811053c8:	df000015 	stw	fp,0(sp)
811053cc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811053d0:	01804004 	movi	r6,256
811053d4:	014004c4 	movi	r5,19
811053d8:	01204834 	movhi	r4,33056
811053dc:	21090004 	addi	r4,r4,9216
811053e0:	110678c0 	call	8110678c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811053e4:	0001883a 	nop
811053e8:	e037883a 	mov	sp,fp
811053ec:	dfc00117 	ldw	ra,4(sp)
811053f0:	df000017 	ldw	fp,0(sp)
811053f4:	dec00204 	addi	sp,sp,8
811053f8:	f800283a 	ret

811053fc <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
811053fc:	defffe04 	addi	sp,sp,-8
81105400:	de00012e 	bgeu	sp,et,81105408 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
81105404:	003b68fa 	trap	3
81105408:	dfc00115 	stw	ra,4(sp)
8110540c:	df000015 	stw	fp,0(sp)
81105410:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105414:	01804004 	movi	r6,256
81105418:	014004c4 	movi	r5,19
8110541c:	01204834 	movhi	r4,33056
81105420:	21080004 	addi	r4,r4,8192
81105424:	110678c0 	call	8110678c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105428:	0001883a 	nop
8110542c:	e037883a 	mov	sp,fp
81105430:	dfc00117 	ldw	ra,4(sp)
81105434:	df000017 	ldw	fp,0(sp)
81105438:	dec00204 	addi	sp,sp,8
8110543c:	f800283a 	ret

81105440 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105440:	defffe04 	addi	sp,sp,-8
81105444:	de00012e 	bgeu	sp,et,8110544c <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105448:	003b68fa 	trap	3
8110544c:	dfc00115 	stw	ra,4(sp)
81105450:	df000015 	stw	fp,0(sp)
81105454:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105458:	01804004 	movi	r6,256
8110545c:	014004c4 	movi	r5,19
81105460:	01204834 	movhi	r4,33056
81105464:	21070004 	addi	r4,r4,7168
81105468:	110678c0 	call	8110678c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110546c:	0001883a 	nop
81105470:	e037883a 	mov	sp,fp
81105474:	dfc00117 	ldw	ra,4(sp)
81105478:	df000017 	ldw	fp,0(sp)
8110547c:	dec00204 	addi	sp,sp,8
81105480:	f800283a 	ret

81105484 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
81105484:	defffe04 	addi	sp,sp,-8
81105488:	de00012e 	bgeu	sp,et,81105490 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
8110548c:	003b68fa 	trap	3
81105490:	dfc00115 	stw	ra,4(sp)
81105494:	df000015 	stw	fp,0(sp)
81105498:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110549c:	01804004 	movi	r6,256
811054a0:	014004c4 	movi	r5,19
811054a4:	01204834 	movhi	r4,33056
811054a8:	21060004 	addi	r4,r4,6144
811054ac:	110678c0 	call	8110678c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054b0:	0001883a 	nop
811054b4:	e037883a 	mov	sp,fp
811054b8:	dfc00117 	ldw	ra,4(sp)
811054bc:	df000017 	ldw	fp,0(sp)
811054c0:	dec00204 	addi	sp,sp,8
811054c4:	f800283a 	ret

811054c8 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
811054c8:	defffe04 	addi	sp,sp,-8
811054cc:	de00012e 	bgeu	sp,et,811054d4 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
811054d0:	003b68fa 	trap	3
811054d4:	dfc00115 	stw	ra,4(sp)
811054d8:	df000015 	stw	fp,0(sp)
811054dc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811054e0:	01804004 	movi	r6,256
811054e4:	014004c4 	movi	r5,19
811054e8:	01204834 	movhi	r4,33056
811054ec:	21050004 	addi	r4,r4,5120
811054f0:	110678c0 	call	8110678c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054f4:	0001883a 	nop
811054f8:	e037883a 	mov	sp,fp
811054fc:	dfc00117 	ldw	ra,4(sp)
81105500:	df000017 	ldw	fp,0(sp)
81105504:	dec00204 	addi	sp,sp,8
81105508:	f800283a 	ret

8110550c <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
8110550c:	defffe04 	addi	sp,sp,-8
81105510:	de00012e 	bgeu	sp,et,81105518 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
81105514:	003b68fa 	trap	3
81105518:	dfc00115 	stw	ra,4(sp)
8110551c:	df000015 	stw	fp,0(sp)
81105520:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105524:	01804004 	movi	r6,256
81105528:	014004c4 	movi	r5,19
8110552c:	01204834 	movhi	r4,33056
81105530:	21040004 	addi	r4,r4,4096
81105534:	110678c0 	call	8110678c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105538:	0001883a 	nop
8110553c:	e037883a 	mov	sp,fp
81105540:	dfc00117 	ldw	ra,4(sp)
81105544:	df000017 	ldw	fp,0(sp)
81105548:	dec00204 	addi	sp,sp,8
8110554c:	f800283a 	ret

81105550 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105550:	defffd04 	addi	sp,sp,-12
81105554:	de00012e 	bgeu	sp,et,8110555c <bFeebCh1IrqFlagBufferEmpty+0xc>
81105558:	003b68fa 	trap	3
8110555c:	dfc00215 	stw	ra,8(sp)
81105560:	df000115 	stw	fp,4(sp)
81105564:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105568:	01400484 	movi	r5,18
8110556c:	01204834 	movhi	r4,33056
81105570:	210b0004 	addi	r4,r4,11264
81105574:	11067e00 	call	811067e0 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105578:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110557c:	10000326 	beq	r2,zero,8110558c <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105580:	00800044 	movi	r2,1
81105584:	e0bfff15 	stw	r2,-4(fp)
81105588:	00000106 	br	81105590 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110558c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105590:	e0bfff17 	ldw	r2,-4(fp)
}
81105594:	e037883a 	mov	sp,fp
81105598:	dfc00117 	ldw	ra,4(sp)
8110559c:	df000017 	ldw	fp,0(sp)
811055a0:	dec00204 	addi	sp,sp,8
811055a4:	f800283a 	ret

811055a8 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
811055a8:	defffd04 	addi	sp,sp,-12
811055ac:	de00012e 	bgeu	sp,et,811055b4 <bFeebCh2IrqFlagBufferEmpty+0xc>
811055b0:	003b68fa 	trap	3
811055b4:	dfc00215 	stw	ra,8(sp)
811055b8:	df000115 	stw	fp,4(sp)
811055bc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811055c0:	01400484 	movi	r5,18
811055c4:	01204834 	movhi	r4,33056
811055c8:	210a0004 	addi	r4,r4,10240
811055cc:	11067e00 	call	811067e0 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055d0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811055d4:	10000326 	beq	r2,zero,811055e4 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811055d8:	00800044 	movi	r2,1
811055dc:	e0bfff15 	stw	r2,-4(fp)
811055e0:	00000106 	br	811055e8 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811055e4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811055e8:	e0bfff17 	ldw	r2,-4(fp)
}
811055ec:	e037883a 	mov	sp,fp
811055f0:	dfc00117 	ldw	ra,4(sp)
811055f4:	df000017 	ldw	fp,0(sp)
811055f8:	dec00204 	addi	sp,sp,8
811055fc:	f800283a 	ret

81105600 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105600:	defffd04 	addi	sp,sp,-12
81105604:	de00012e 	bgeu	sp,et,8110560c <bFeebCh3IrqFlagBufferEmpty+0xc>
81105608:	003b68fa 	trap	3
8110560c:	dfc00215 	stw	ra,8(sp)
81105610:	df000115 	stw	fp,4(sp)
81105614:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105618:	01400484 	movi	r5,18
8110561c:	01204834 	movhi	r4,33056
81105620:	21090004 	addi	r4,r4,9216
81105624:	11067e00 	call	811067e0 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105628:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110562c:	10000326 	beq	r2,zero,8110563c <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105630:	00800044 	movi	r2,1
81105634:	e0bfff15 	stw	r2,-4(fp)
81105638:	00000106 	br	81105640 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110563c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105640:	e0bfff17 	ldw	r2,-4(fp)
}
81105644:	e037883a 	mov	sp,fp
81105648:	dfc00117 	ldw	ra,4(sp)
8110564c:	df000017 	ldw	fp,0(sp)
81105650:	dec00204 	addi	sp,sp,8
81105654:	f800283a 	ret

81105658 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105658:	defffd04 	addi	sp,sp,-12
8110565c:	de00012e 	bgeu	sp,et,81105664 <bFeebCh4IrqFlagBufferEmpty+0xc>
81105660:	003b68fa 	trap	3
81105664:	dfc00215 	stw	ra,8(sp)
81105668:	df000115 	stw	fp,4(sp)
8110566c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105670:	01400484 	movi	r5,18
81105674:	01204834 	movhi	r4,33056
81105678:	21080004 	addi	r4,r4,8192
8110567c:	11067e00 	call	811067e0 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105680:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105684:	10000326 	beq	r2,zero,81105694 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105688:	00800044 	movi	r2,1
8110568c:	e0bfff15 	stw	r2,-4(fp)
81105690:	00000106 	br	81105698 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105694:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105698:	e0bfff17 	ldw	r2,-4(fp)
}
8110569c:	e037883a 	mov	sp,fp
811056a0:	dfc00117 	ldw	ra,4(sp)
811056a4:	df000017 	ldw	fp,0(sp)
811056a8:	dec00204 	addi	sp,sp,8
811056ac:	f800283a 	ret

811056b0 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
811056b0:	defffd04 	addi	sp,sp,-12
811056b4:	de00012e 	bgeu	sp,et,811056bc <bFeebCh5IrqFlagBufferEmpty+0xc>
811056b8:	003b68fa 	trap	3
811056bc:	dfc00215 	stw	ra,8(sp)
811056c0:	df000115 	stw	fp,4(sp)
811056c4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811056c8:	01400484 	movi	r5,18
811056cc:	01204834 	movhi	r4,33056
811056d0:	21070004 	addi	r4,r4,7168
811056d4:	11067e00 	call	811067e0 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811056d8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811056dc:	10000326 	beq	r2,zero,811056ec <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811056e0:	00800044 	movi	r2,1
811056e4:	e0bfff15 	stw	r2,-4(fp)
811056e8:	00000106 	br	811056f0 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811056ec:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811056f0:	e0bfff17 	ldw	r2,-4(fp)
}
811056f4:	e037883a 	mov	sp,fp
811056f8:	dfc00117 	ldw	ra,4(sp)
811056fc:	df000017 	ldw	fp,0(sp)
81105700:	dec00204 	addi	sp,sp,8
81105704:	f800283a 	ret

81105708 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105708:	defffd04 	addi	sp,sp,-12
8110570c:	de00012e 	bgeu	sp,et,81105714 <bFeebCh6IrqFlagBufferEmpty+0xc>
81105710:	003b68fa 	trap	3
81105714:	dfc00215 	stw	ra,8(sp)
81105718:	df000115 	stw	fp,4(sp)
8110571c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105720:	01400484 	movi	r5,18
81105724:	01204834 	movhi	r4,33056
81105728:	21060004 	addi	r4,r4,6144
8110572c:	11067e00 	call	811067e0 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105730:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105734:	10000326 	beq	r2,zero,81105744 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105738:	00800044 	movi	r2,1
8110573c:	e0bfff15 	stw	r2,-4(fp)
81105740:	00000106 	br	81105748 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105744:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105748:	e0bfff17 	ldw	r2,-4(fp)
}
8110574c:	e037883a 	mov	sp,fp
81105750:	dfc00117 	ldw	ra,4(sp)
81105754:	df000017 	ldw	fp,0(sp)
81105758:	dec00204 	addi	sp,sp,8
8110575c:	f800283a 	ret

81105760 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105760:	defffd04 	addi	sp,sp,-12
81105764:	de00012e 	bgeu	sp,et,8110576c <bFeebCh7IrqFlagBufferEmpty+0xc>
81105768:	003b68fa 	trap	3
8110576c:	dfc00215 	stw	ra,8(sp)
81105770:	df000115 	stw	fp,4(sp)
81105774:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105778:	01400484 	movi	r5,18
8110577c:	01204834 	movhi	r4,33056
81105780:	21050004 	addi	r4,r4,5120
81105784:	11067e00 	call	811067e0 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105788:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110578c:	10000326 	beq	r2,zero,8110579c <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105790:	00800044 	movi	r2,1
81105794:	e0bfff15 	stw	r2,-4(fp)
81105798:	00000106 	br	811057a0 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110579c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057a0:	e0bfff17 	ldw	r2,-4(fp)
}
811057a4:	e037883a 	mov	sp,fp
811057a8:	dfc00117 	ldw	ra,4(sp)
811057ac:	df000017 	ldw	fp,0(sp)
811057b0:	dec00204 	addi	sp,sp,8
811057b4:	f800283a 	ret

811057b8 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
811057b8:	defffd04 	addi	sp,sp,-12
811057bc:	de00012e 	bgeu	sp,et,811057c4 <bFeebCh8IrqFlagBufferEmpty+0xc>
811057c0:	003b68fa 	trap	3
811057c4:	dfc00215 	stw	ra,8(sp)
811057c8:	df000115 	stw	fp,4(sp)
811057cc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811057d0:	01400484 	movi	r5,18
811057d4:	01204834 	movhi	r4,33056
811057d8:	21040004 	addi	r4,r4,4096
811057dc:	11067e00 	call	811067e0 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057e0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811057e4:	10000326 	beq	r2,zero,811057f4 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057e8:	00800044 	movi	r2,1
811057ec:	e0bfff15 	stw	r2,-4(fp)
811057f0:	00000106 	br	811057f8 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057f4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057f8:	e0bfff17 	ldw	r2,-4(fp)
}
811057fc:	e037883a 	mov	sp,fp
81105800:	dfc00117 	ldw	ra,4(sp)
81105804:	df000017 	ldw	fp,0(sp)
81105808:	dec00204 	addi	sp,sp,8
8110580c:	f800283a 	ret

81105810 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105810:	defffa04 	addi	sp,sp,-24
81105814:	de00012e 	bgeu	sp,et,8110581c <bFeebCh1SetBufferSize+0xc>
81105818:	003b68fa 	trap	3
8110581c:	dfc00515 	stw	ra,20(sp)
81105820:	df000415 	stw	fp,16(sp)
81105824:	df000404 	addi	fp,sp,16
81105828:	2007883a 	mov	r3,r4
8110582c:	2805883a 	mov	r2,r5
81105830:	e0fffe05 	stb	r3,-8(fp)
81105834:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105838:	00800044 	movi	r2,1
8110583c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105840:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105844:	e0bffe03 	ldbu	r2,-8(fp)
81105848:	10001f26 	beq	r2,zero,811058c8 <bFeebCh1SetBufferSize+0xb8>
8110584c:	e0bffe03 	ldbu	r2,-8(fp)
81105850:	10800468 	cmpgeui	r2,r2,17
81105854:	10001c1e 	bne	r2,zero,811058c8 <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105858:	e0bfff03 	ldbu	r2,-4(fp)
8110585c:	10000326 	beq	r2,zero,8110586c <bFeebCh1SetBufferSize+0x5c>
81105860:	10800060 	cmpeqi	r2,r2,1
81105864:	10000b1e 	bne	r2,zero,81105894 <bFeebCh1SetBufferSize+0x84>
81105868:	00001406 	br	811058bc <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
8110586c:	e0bffe03 	ldbu	r2,-8(fp)
81105870:	10bfffc4 	addi	r2,r2,-1
81105874:	108003cc 	andi	r2,r2,15
81105878:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110587c:	e1bffd17 	ldw	r6,-12(fp)
81105880:	01400544 	movi	r5,21
81105884:	01204834 	movhi	r4,33056
81105888:	210b0004 	addi	r4,r4,11264
8110588c:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105890:	00000c06 	br	811058c4 <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105894:	e0bffe03 	ldbu	r2,-8(fp)
81105898:	10bfffc4 	addi	r2,r2,-1
8110589c:	108003cc 	andi	r2,r2,15
811058a0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811058a4:	e1bffd17 	ldw	r6,-12(fp)
811058a8:	01400504 	movi	r5,20
811058ac:	01204834 	movhi	r4,33056
811058b0:	210b0004 	addi	r4,r4,11264
811058b4:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811058b8:	00000206 	br	811058c4 <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
811058bc:	e03ffc15 	stw	zero,-16(fp)
			break;
811058c0:	0001883a 	nop
		}
	} else {
811058c4:	00000106 	br	811058cc <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
811058c8:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811058cc:	e0bffc17 	ldw	r2,-16(fp)
}
811058d0:	e037883a 	mov	sp,fp
811058d4:	dfc00117 	ldw	ra,4(sp)
811058d8:	df000017 	ldw	fp,0(sp)
811058dc:	dec00204 	addi	sp,sp,8
811058e0:	f800283a 	ret

811058e4 <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
811058e4:	defffa04 	addi	sp,sp,-24
811058e8:	de00012e 	bgeu	sp,et,811058f0 <bFeebCh2SetBufferSize+0xc>
811058ec:	003b68fa 	trap	3
811058f0:	dfc00515 	stw	ra,20(sp)
811058f4:	df000415 	stw	fp,16(sp)
811058f8:	df000404 	addi	fp,sp,16
811058fc:	2007883a 	mov	r3,r4
81105900:	2805883a 	mov	r2,r5
81105904:	e0fffe05 	stb	r3,-8(fp)
81105908:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
8110590c:	00800044 	movi	r2,1
81105910:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105914:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105918:	e0bffe03 	ldbu	r2,-8(fp)
8110591c:	10001f26 	beq	r2,zero,8110599c <bFeebCh2SetBufferSize+0xb8>
81105920:	e0bffe03 	ldbu	r2,-8(fp)
81105924:	10800468 	cmpgeui	r2,r2,17
81105928:	10001c1e 	bne	r2,zero,8110599c <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
8110592c:	e0bfff03 	ldbu	r2,-4(fp)
81105930:	10000326 	beq	r2,zero,81105940 <bFeebCh2SetBufferSize+0x5c>
81105934:	10800060 	cmpeqi	r2,r2,1
81105938:	10000b1e 	bne	r2,zero,81105968 <bFeebCh2SetBufferSize+0x84>
8110593c:	00001406 	br	81105990 <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105940:	e0bffe03 	ldbu	r2,-8(fp)
81105944:	10bfffc4 	addi	r2,r2,-1
81105948:	108003cc 	andi	r2,r2,15
8110594c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105950:	e1bffd17 	ldw	r6,-12(fp)
81105954:	01400544 	movi	r5,21
81105958:	01204834 	movhi	r4,33056
8110595c:	210a0004 	addi	r4,r4,10240
81105960:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105964:	00000c06 	br	81105998 <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105968:	e0bffe03 	ldbu	r2,-8(fp)
8110596c:	10bfffc4 	addi	r2,r2,-1
81105970:	108003cc 	andi	r2,r2,15
81105974:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105978:	e1bffd17 	ldw	r6,-12(fp)
8110597c:	01400504 	movi	r5,20
81105980:	01204834 	movhi	r4,33056
81105984:	210a0004 	addi	r4,r4,10240
81105988:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110598c:	00000206 	br	81105998 <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105990:	e03ffc15 	stw	zero,-16(fp)
			break;
81105994:	0001883a 	nop
		}
	} else {
81105998:	00000106 	br	811059a0 <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
8110599c:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811059a0:	e0bffc17 	ldw	r2,-16(fp)
}
811059a4:	e037883a 	mov	sp,fp
811059a8:	dfc00117 	ldw	ra,4(sp)
811059ac:	df000017 	ldw	fp,0(sp)
811059b0:	dec00204 	addi	sp,sp,8
811059b4:	f800283a 	ret

811059b8 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
811059b8:	defffa04 	addi	sp,sp,-24
811059bc:	de00012e 	bgeu	sp,et,811059c4 <bFeebCh3SetBufferSize+0xc>
811059c0:	003b68fa 	trap	3
811059c4:	dfc00515 	stw	ra,20(sp)
811059c8:	df000415 	stw	fp,16(sp)
811059cc:	df000404 	addi	fp,sp,16
811059d0:	2007883a 	mov	r3,r4
811059d4:	2805883a 	mov	r2,r5
811059d8:	e0fffe05 	stb	r3,-8(fp)
811059dc:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811059e0:	00800044 	movi	r2,1
811059e4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
811059e8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
811059ec:	e0bffe03 	ldbu	r2,-8(fp)
811059f0:	10001f26 	beq	r2,zero,81105a70 <bFeebCh3SetBufferSize+0xb8>
811059f4:	e0bffe03 	ldbu	r2,-8(fp)
811059f8:	10800468 	cmpgeui	r2,r2,17
811059fc:	10001c1e 	bne	r2,zero,81105a70 <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105a00:	e0bfff03 	ldbu	r2,-4(fp)
81105a04:	10000326 	beq	r2,zero,81105a14 <bFeebCh3SetBufferSize+0x5c>
81105a08:	10800060 	cmpeqi	r2,r2,1
81105a0c:	10000b1e 	bne	r2,zero,81105a3c <bFeebCh3SetBufferSize+0x84>
81105a10:	00001406 	br	81105a64 <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a14:	e0bffe03 	ldbu	r2,-8(fp)
81105a18:	10bfffc4 	addi	r2,r2,-1
81105a1c:	108003cc 	andi	r2,r2,15
81105a20:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105a24:	e1bffd17 	ldw	r6,-12(fp)
81105a28:	01400544 	movi	r5,21
81105a2c:	01204834 	movhi	r4,33056
81105a30:	21090004 	addi	r4,r4,9216
81105a34:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a38:	00000c06 	br	81105a6c <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a3c:	e0bffe03 	ldbu	r2,-8(fp)
81105a40:	10bfffc4 	addi	r2,r2,-1
81105a44:	108003cc 	andi	r2,r2,15
81105a48:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105a4c:	e1bffd17 	ldw	r6,-12(fp)
81105a50:	01400504 	movi	r5,20
81105a54:	01204834 	movhi	r4,33056
81105a58:	21090004 	addi	r4,r4,9216
81105a5c:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a60:	00000206 	br	81105a6c <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105a64:	e03ffc15 	stw	zero,-16(fp)
			break;
81105a68:	0001883a 	nop
		}
	} else {
81105a6c:	00000106 	br	81105a74 <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81105a70:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105a74:	e0bffc17 	ldw	r2,-16(fp)
}
81105a78:	e037883a 	mov	sp,fp
81105a7c:	dfc00117 	ldw	ra,4(sp)
81105a80:	df000017 	ldw	fp,0(sp)
81105a84:	dec00204 	addi	sp,sp,8
81105a88:	f800283a 	ret

81105a8c <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105a8c:	defffa04 	addi	sp,sp,-24
81105a90:	de00012e 	bgeu	sp,et,81105a98 <bFeebCh4SetBufferSize+0xc>
81105a94:	003b68fa 	trap	3
81105a98:	dfc00515 	stw	ra,20(sp)
81105a9c:	df000415 	stw	fp,16(sp)
81105aa0:	df000404 	addi	fp,sp,16
81105aa4:	2007883a 	mov	r3,r4
81105aa8:	2805883a 	mov	r2,r5
81105aac:	e0fffe05 	stb	r3,-8(fp)
81105ab0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105ab4:	00800044 	movi	r2,1
81105ab8:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105abc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ac0:	e0bffe03 	ldbu	r2,-8(fp)
81105ac4:	10001f26 	beq	r2,zero,81105b44 <bFeebCh4SetBufferSize+0xb8>
81105ac8:	e0bffe03 	ldbu	r2,-8(fp)
81105acc:	10800468 	cmpgeui	r2,r2,17
81105ad0:	10001c1e 	bne	r2,zero,81105b44 <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ad4:	e0bfff03 	ldbu	r2,-4(fp)
81105ad8:	10000326 	beq	r2,zero,81105ae8 <bFeebCh4SetBufferSize+0x5c>
81105adc:	10800060 	cmpeqi	r2,r2,1
81105ae0:	10000b1e 	bne	r2,zero,81105b10 <bFeebCh4SetBufferSize+0x84>
81105ae4:	00001406 	br	81105b38 <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ae8:	e0bffe03 	ldbu	r2,-8(fp)
81105aec:	10bfffc4 	addi	r2,r2,-1
81105af0:	108003cc 	andi	r2,r2,15
81105af4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105af8:	e1bffd17 	ldw	r6,-12(fp)
81105afc:	01400544 	movi	r5,21
81105b00:	01204834 	movhi	r4,33056
81105b04:	21080004 	addi	r4,r4,8192
81105b08:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b0c:	00000c06 	br	81105b40 <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b10:	e0bffe03 	ldbu	r2,-8(fp)
81105b14:	10bfffc4 	addi	r2,r2,-1
81105b18:	108003cc 	andi	r2,r2,15
81105b1c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105b20:	e1bffd17 	ldw	r6,-12(fp)
81105b24:	01400504 	movi	r5,20
81105b28:	01204834 	movhi	r4,33056
81105b2c:	21080004 	addi	r4,r4,8192
81105b30:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b34:	00000206 	br	81105b40 <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105b38:	e03ffc15 	stw	zero,-16(fp)
			break;
81105b3c:	0001883a 	nop
		}
	} else {
81105b40:	00000106 	br	81105b48 <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81105b44:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105b48:	e0bffc17 	ldw	r2,-16(fp)
}
81105b4c:	e037883a 	mov	sp,fp
81105b50:	dfc00117 	ldw	ra,4(sp)
81105b54:	df000017 	ldw	fp,0(sp)
81105b58:	dec00204 	addi	sp,sp,8
81105b5c:	f800283a 	ret

81105b60 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105b60:	defffa04 	addi	sp,sp,-24
81105b64:	de00012e 	bgeu	sp,et,81105b6c <bFeebCh5SetBufferSize+0xc>
81105b68:	003b68fa 	trap	3
81105b6c:	dfc00515 	stw	ra,20(sp)
81105b70:	df000415 	stw	fp,16(sp)
81105b74:	df000404 	addi	fp,sp,16
81105b78:	2007883a 	mov	r3,r4
81105b7c:	2805883a 	mov	r2,r5
81105b80:	e0fffe05 	stb	r3,-8(fp)
81105b84:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105b88:	00800044 	movi	r2,1
81105b8c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105b90:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105b94:	e0bffe03 	ldbu	r2,-8(fp)
81105b98:	10001f26 	beq	r2,zero,81105c18 <bFeebCh5SetBufferSize+0xb8>
81105b9c:	e0bffe03 	ldbu	r2,-8(fp)
81105ba0:	10800468 	cmpgeui	r2,r2,17
81105ba4:	10001c1e 	bne	r2,zero,81105c18 <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ba8:	e0bfff03 	ldbu	r2,-4(fp)
81105bac:	10000326 	beq	r2,zero,81105bbc <bFeebCh5SetBufferSize+0x5c>
81105bb0:	10800060 	cmpeqi	r2,r2,1
81105bb4:	10000b1e 	bne	r2,zero,81105be4 <bFeebCh5SetBufferSize+0x84>
81105bb8:	00001406 	br	81105c0c <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105bbc:	e0bffe03 	ldbu	r2,-8(fp)
81105bc0:	10bfffc4 	addi	r2,r2,-1
81105bc4:	108003cc 	andi	r2,r2,15
81105bc8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105bcc:	e1bffd17 	ldw	r6,-12(fp)
81105bd0:	01400544 	movi	r5,21
81105bd4:	01204834 	movhi	r4,33056
81105bd8:	21070004 	addi	r4,r4,7168
81105bdc:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105be0:	00000c06 	br	81105c14 <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105be4:	e0bffe03 	ldbu	r2,-8(fp)
81105be8:	10bfffc4 	addi	r2,r2,-1
81105bec:	108003cc 	andi	r2,r2,15
81105bf0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105bf4:	e1bffd17 	ldw	r6,-12(fp)
81105bf8:	01400504 	movi	r5,20
81105bfc:	01204834 	movhi	r4,33056
81105c00:	21070004 	addi	r4,r4,7168
81105c04:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c08:	00000206 	br	81105c14 <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105c0c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105c10:	0001883a 	nop
		}
	} else {
81105c14:	00000106 	br	81105c1c <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81105c18:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105c1c:	e0bffc17 	ldw	r2,-16(fp)
}
81105c20:	e037883a 	mov	sp,fp
81105c24:	dfc00117 	ldw	ra,4(sp)
81105c28:	df000017 	ldw	fp,0(sp)
81105c2c:	dec00204 	addi	sp,sp,8
81105c30:	f800283a 	ret

81105c34 <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105c34:	defffa04 	addi	sp,sp,-24
81105c38:	de00012e 	bgeu	sp,et,81105c40 <bFeebCh6SetBufferSize+0xc>
81105c3c:	003b68fa 	trap	3
81105c40:	dfc00515 	stw	ra,20(sp)
81105c44:	df000415 	stw	fp,16(sp)
81105c48:	df000404 	addi	fp,sp,16
81105c4c:	2007883a 	mov	r3,r4
81105c50:	2805883a 	mov	r2,r5
81105c54:	e0fffe05 	stb	r3,-8(fp)
81105c58:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105c5c:	00800044 	movi	r2,1
81105c60:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105c64:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c68:	e0bffe03 	ldbu	r2,-8(fp)
81105c6c:	10001f26 	beq	r2,zero,81105cec <bFeebCh6SetBufferSize+0xb8>
81105c70:	e0bffe03 	ldbu	r2,-8(fp)
81105c74:	10800468 	cmpgeui	r2,r2,17
81105c78:	10001c1e 	bne	r2,zero,81105cec <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105c7c:	e0bfff03 	ldbu	r2,-4(fp)
81105c80:	10000326 	beq	r2,zero,81105c90 <bFeebCh6SetBufferSize+0x5c>
81105c84:	10800060 	cmpeqi	r2,r2,1
81105c88:	10000b1e 	bne	r2,zero,81105cb8 <bFeebCh6SetBufferSize+0x84>
81105c8c:	00001406 	br	81105ce0 <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c90:	e0bffe03 	ldbu	r2,-8(fp)
81105c94:	10bfffc4 	addi	r2,r2,-1
81105c98:	108003cc 	andi	r2,r2,15
81105c9c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105ca0:	e1bffd17 	ldw	r6,-12(fp)
81105ca4:	01400544 	movi	r5,21
81105ca8:	01204834 	movhi	r4,33056
81105cac:	21060004 	addi	r4,r4,6144
81105cb0:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105cb4:	00000c06 	br	81105ce8 <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105cb8:	e0bffe03 	ldbu	r2,-8(fp)
81105cbc:	10bfffc4 	addi	r2,r2,-1
81105cc0:	108003cc 	andi	r2,r2,15
81105cc4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105cc8:	e1bffd17 	ldw	r6,-12(fp)
81105ccc:	01400504 	movi	r5,20
81105cd0:	01204834 	movhi	r4,33056
81105cd4:	21060004 	addi	r4,r4,6144
81105cd8:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105cdc:	00000206 	br	81105ce8 <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ce0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105ce4:	0001883a 	nop
		}
	} else {
81105ce8:	00000106 	br	81105cf0 <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81105cec:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105cf0:	e0bffc17 	ldw	r2,-16(fp)
}
81105cf4:	e037883a 	mov	sp,fp
81105cf8:	dfc00117 	ldw	ra,4(sp)
81105cfc:	df000017 	ldw	fp,0(sp)
81105d00:	dec00204 	addi	sp,sp,8
81105d04:	f800283a 	ret

81105d08 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105d08:	defffa04 	addi	sp,sp,-24
81105d0c:	de00012e 	bgeu	sp,et,81105d14 <bFeebCh7SetBufferSize+0xc>
81105d10:	003b68fa 	trap	3
81105d14:	dfc00515 	stw	ra,20(sp)
81105d18:	df000415 	stw	fp,16(sp)
81105d1c:	df000404 	addi	fp,sp,16
81105d20:	2007883a 	mov	r3,r4
81105d24:	2805883a 	mov	r2,r5
81105d28:	e0fffe05 	stb	r3,-8(fp)
81105d2c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105d30:	00800044 	movi	r2,1
81105d34:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105d38:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105d3c:	e0bffe03 	ldbu	r2,-8(fp)
81105d40:	10001f26 	beq	r2,zero,81105dc0 <bFeebCh7SetBufferSize+0xb8>
81105d44:	e0bffe03 	ldbu	r2,-8(fp)
81105d48:	10800468 	cmpgeui	r2,r2,17
81105d4c:	10001c1e 	bne	r2,zero,81105dc0 <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105d50:	e0bfff03 	ldbu	r2,-4(fp)
81105d54:	10000326 	beq	r2,zero,81105d64 <bFeebCh7SetBufferSize+0x5c>
81105d58:	10800060 	cmpeqi	r2,r2,1
81105d5c:	10000b1e 	bne	r2,zero,81105d8c <bFeebCh7SetBufferSize+0x84>
81105d60:	00001406 	br	81105db4 <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d64:	e0bffe03 	ldbu	r2,-8(fp)
81105d68:	10bfffc4 	addi	r2,r2,-1
81105d6c:	108003cc 	andi	r2,r2,15
81105d70:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105d74:	e1bffd17 	ldw	r6,-12(fp)
81105d78:	01400544 	movi	r5,21
81105d7c:	01204834 	movhi	r4,33056
81105d80:	21050004 	addi	r4,r4,5120
81105d84:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d88:	00000c06 	br	81105dbc <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d8c:	e0bffe03 	ldbu	r2,-8(fp)
81105d90:	10bfffc4 	addi	r2,r2,-1
81105d94:	108003cc 	andi	r2,r2,15
81105d98:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105d9c:	e1bffd17 	ldw	r6,-12(fp)
81105da0:	01400504 	movi	r5,20
81105da4:	01204834 	movhi	r4,33056
81105da8:	21050004 	addi	r4,r4,5120
81105dac:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105db0:	00000206 	br	81105dbc <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105db4:	e03ffc15 	stw	zero,-16(fp)
			break;
81105db8:	0001883a 	nop
		}
	} else {
81105dbc:	00000106 	br	81105dc4 <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
81105dc0:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105dc4:	e0bffc17 	ldw	r2,-16(fp)
}
81105dc8:	e037883a 	mov	sp,fp
81105dcc:	dfc00117 	ldw	ra,4(sp)
81105dd0:	df000017 	ldw	fp,0(sp)
81105dd4:	dec00204 	addi	sp,sp,8
81105dd8:	f800283a 	ret

81105ddc <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105ddc:	defffa04 	addi	sp,sp,-24
81105de0:	de00012e 	bgeu	sp,et,81105de8 <bFeebCh8SetBufferSize+0xc>
81105de4:	003b68fa 	trap	3
81105de8:	dfc00515 	stw	ra,20(sp)
81105dec:	df000415 	stw	fp,16(sp)
81105df0:	df000404 	addi	fp,sp,16
81105df4:	2007883a 	mov	r3,r4
81105df8:	2805883a 	mov	r2,r5
81105dfc:	e0fffe05 	stb	r3,-8(fp)
81105e00:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105e04:	00800044 	movi	r2,1
81105e08:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105e0c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105e10:	e0bffe03 	ldbu	r2,-8(fp)
81105e14:	10001f26 	beq	r2,zero,81105e94 <bFeebCh8SetBufferSize+0xb8>
81105e18:	e0bffe03 	ldbu	r2,-8(fp)
81105e1c:	10800468 	cmpgeui	r2,r2,17
81105e20:	10001c1e 	bne	r2,zero,81105e94 <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105e24:	e0bfff03 	ldbu	r2,-4(fp)
81105e28:	10000326 	beq	r2,zero,81105e38 <bFeebCh8SetBufferSize+0x5c>
81105e2c:	10800060 	cmpeqi	r2,r2,1
81105e30:	10000b1e 	bne	r2,zero,81105e60 <bFeebCh8SetBufferSize+0x84>
81105e34:	00001406 	br	81105e88 <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e38:	e0bffe03 	ldbu	r2,-8(fp)
81105e3c:	10bfffc4 	addi	r2,r2,-1
81105e40:	108003cc 	andi	r2,r2,15
81105e44:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105e48:	e1bffd17 	ldw	r6,-12(fp)
81105e4c:	01400544 	movi	r5,21
81105e50:	01204834 	movhi	r4,33056
81105e54:	21040004 	addi	r4,r4,4096
81105e58:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e5c:	00000c06 	br	81105e90 <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e60:	e0bffe03 	ldbu	r2,-8(fp)
81105e64:	10bfffc4 	addi	r2,r2,-1
81105e68:	108003cc 	andi	r2,r2,15
81105e6c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105e70:	e1bffd17 	ldw	r6,-12(fp)
81105e74:	01400504 	movi	r5,20
81105e78:	01204834 	movhi	r4,33056
81105e7c:	21040004 	addi	r4,r4,4096
81105e80:	110678c0 	call	8110678c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e84:	00000206 	br	81105e90 <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105e88:	e03ffc15 	stw	zero,-16(fp)
			break;
81105e8c:	0001883a 	nop
		}
	} else {
81105e90:	00000106 	br	81105e98 <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
81105e94:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105e98:	e0bffc17 	ldw	r2,-16(fp)
}
81105e9c:	e037883a 	mov	sp,fp
81105ea0:	dfc00117 	ldw	ra,4(sp)
81105ea4:	df000017 	ldw	fp,0(sp)
81105ea8:	dec00204 	addi	sp,sp,8
81105eac:	f800283a 	ret

81105eb0 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81105eb0:	defffc04 	addi	sp,sp,-16
81105eb4:	de00012e 	bgeu	sp,et,81105ebc <vFeebInitIrq+0xc>
81105eb8:	003b68fa 	trap	3
81105ebc:	dfc00315 	stw	ra,12(sp)
81105ec0:	df000215 	stw	fp,8(sp)
81105ec4:	df000204 	addi	fp,sp,8
81105ec8:	2005883a 	mov	r2,r4
81105ecc:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81105ed0:	e0bfff03 	ldbu	r2,-4(fp)
81105ed4:	10c00228 	cmpgeui	r3,r2,8
81105ed8:	18004e1e 	bne	r3,zero,81106014 <vFeebInitIrq+0x164>
81105edc:	100690ba 	slli	r3,r2,2
81105ee0:	00a04434 	movhi	r2,33040
81105ee4:	1097bd04 	addi	r2,r2,24308
81105ee8:	1885883a 	add	r2,r3,r2
81105eec:	10800017 	ldw	r2,0(r2)
81105ef0:	1000683a 	jmp	r2
81105ef4:	81105f14 	ori	r4,r16,16764
81105ef8:	81105f34 	orhi	r4,r16,16764
81105efc:	81105f54 	ori	r4,r16,16765
81105f00:	81105f74 	orhi	r4,r16,16765
81105f04:	81105f94 	ori	r4,r16,16766
81105f08:	81105fb4 	orhi	r4,r16,16766
81105f0c:	81105fd4 	ori	r4,r16,16767
81105f10:	81105ff4 	orhi	r4,r16,16767
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81105f14:	d0a04004 	addi	r2,gp,-32512
81105f18:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81105f1c:	01a04434 	movhi	r6,33040
81105f20:	3193f704 	addi	r6,r6,20444
81105f24:	e17ffe17 	ldw	r5,-8(fp)
81105f28:	01000584 	movi	r4,22
81105f2c:	113321c0 	call	8113321c <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81105f30:	00003806 	br	81106014 <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81105f34:	d0a04104 	addi	r2,gp,-32508
81105f38:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
81105f3c:	01a04434 	movhi	r6,33040
81105f40:	31940704 	addi	r6,r6,20508
81105f44:	e17ffe17 	ldw	r5,-8(fp)
81105f48:	01000504 	movi	r4,20
81105f4c:	113321c0 	call	8113321c <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81105f50:	00003006 	br	81106014 <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81105f54:	d0a04204 	addi	r2,gp,-32504
81105f58:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
81105f5c:	01a04434 	movhi	r6,33040
81105f60:	31942804 	addi	r6,r6,20640
81105f64:	e17ffe17 	ldw	r5,-8(fp)
81105f68:	01000484 	movi	r4,18
81105f6c:	113321c0 	call	8113321c <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81105f70:	00002806 	br	81106014 <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81105f74:	d0a04304 	addi	r2,gp,-32500
81105f78:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
81105f7c:	01a04434 	movhi	r6,33040
81105f80:	31944904 	addi	r6,r6,20772
81105f84:	e17ffe17 	ldw	r5,-8(fp)
81105f88:	01000404 	movi	r4,16
81105f8c:	113321c0 	call	8113321c <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81105f90:	00002006 	br	81106014 <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81105f94:	d0a04404 	addi	r2,gp,-32496
81105f98:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81105f9c:	01a04434 	movhi	r6,33040
81105fa0:	31946a04 	addi	r6,r6,20904
81105fa4:	e17ffe17 	ldw	r5,-8(fp)
81105fa8:	01000204 	movi	r4,8
81105fac:	113321c0 	call	8113321c <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81105fb0:	00001806 	br	81106014 <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81105fb4:	d0a04504 	addi	r2,gp,-32492
81105fb8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81105fbc:	01a04434 	movhi	r6,33040
81105fc0:	31948b04 	addi	r6,r6,21036
81105fc4:	e17ffe17 	ldw	r5,-8(fp)
81105fc8:	01000184 	movi	r4,6
81105fcc:	113321c0 	call	8113321c <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81105fd0:	00001006 	br	81106014 <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81105fd4:	d0a04604 	addi	r2,gp,-32488
81105fd8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81105fdc:	01a04434 	movhi	r6,33040
81105fe0:	3194ac04 	addi	r6,r6,21168
81105fe4:	e17ffe17 	ldw	r5,-8(fp)
81105fe8:	01000144 	movi	r4,5
81105fec:	113321c0 	call	8113321c <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81105ff0:	00000806 	br	81106014 <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81105ff4:	d0a04704 	addi	r2,gp,-32484
81105ff8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81105ffc:	01a04434 	movhi	r6,33040
81106000:	3194bc04 	addi	r6,r6,21232
81106004:	e17ffe17 	ldw	r5,-8(fp)
81106008:	01000084 	movi	r4,2
8110600c:	113321c0 	call	8113321c <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81106010:	0001883a 	nop
	}
}
81106014:	0001883a 	nop
81106018:	e037883a 	mov	sp,fp
8110601c:	dfc00117 	ldw	ra,4(sp)
81106020:	df000017 	ldw	fp,0(sp)
81106024:	dec00204 	addi	sp,sp,8
81106028:	f800283a 	ret

8110602c <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
8110602c:	defffb04 	addi	sp,sp,-20
81106030:	de00012e 	bgeu	sp,et,81106038 <bFeebSetIrqControl+0xc>
81106034:	003b68fa 	trap	3
81106038:	dfc00415 	stw	ra,16(sp)
8110603c:	df000315 	stw	fp,12(sp)
81106040:	df000304 	addi	fp,sp,12
81106044:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106048:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110604c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106050:	e0bfff17 	ldw	r2,-4(fp)
81106054:	10002426 	beq	r2,zero,811060e8 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106058:	e0bfff17 	ldw	r2,-4(fp)
8110605c:	10800017 	ldw	r2,0(r2)
81106060:	01400444 	movi	r5,17
81106064:	1009883a 	mov	r4,r2
81106068:	11067e00 	call	811067e0 <uliFeebReadReg>
8110606c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81106070:	e0bfff17 	ldw	r2,-4(fp)
81106074:	10800217 	ldw	r2,8(r2)
81106078:	10000426 	beq	r2,zero,8110608c <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
8110607c:	e0bffe17 	ldw	r2,-8(fp)
81106080:	10808014 	ori	r2,r2,512
81106084:	e0bffe15 	stw	r2,-8(fp)
81106088:	00000406 	br	8110609c <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
8110608c:	e0fffe17 	ldw	r3,-8(fp)
81106090:	00bf7fc4 	movi	r2,-513
81106094:	1884703a 	and	r2,r3,r2
81106098:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
8110609c:	e0bfff17 	ldw	r2,-4(fp)
811060a0:	10800317 	ldw	r2,12(r2)
811060a4:	10000426 	beq	r2,zero,811060b8 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
811060a8:	e0bffe17 	ldw	r2,-8(fp)
811060ac:	10804014 	ori	r2,r2,256
811060b0:	e0bffe15 	stw	r2,-8(fp)
811060b4:	00000406 	br	811060c8 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
811060b8:	e0fffe17 	ldw	r3,-8(fp)
811060bc:	00bfbfc4 	movi	r2,-257
811060c0:	1884703a 	and	r2,r3,r2
811060c4:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
811060c8:	e0bfff17 	ldw	r2,-4(fp)
811060cc:	10800017 	ldw	r2,0(r2)
811060d0:	e1bffe17 	ldw	r6,-8(fp)
811060d4:	01400444 	movi	r5,17
811060d8:	1009883a 	mov	r4,r2
811060dc:	110678c0 	call	8110678c <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
811060e0:	00800044 	movi	r2,1
811060e4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811060e8:	e0bffd17 	ldw	r2,-12(fp)
}
811060ec:	e037883a 	mov	sp,fp
811060f0:	dfc00117 	ldw	ra,4(sp)
811060f4:	df000017 	ldw	fp,0(sp)
811060f8:	dec00204 	addi	sp,sp,8
811060fc:	f800283a 	ret

81106100 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81106100:	defffb04 	addi	sp,sp,-20
81106104:	de00012e 	bgeu	sp,et,8110610c <bFeebGetIrqControl+0xc>
81106108:	003b68fa 	trap	3
8110610c:	dfc00415 	stw	ra,16(sp)
81106110:	df000315 	stw	fp,12(sp)
81106114:	df000304 	addi	fp,sp,12
81106118:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110611c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106120:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106124:	e0bfff17 	ldw	r2,-4(fp)
81106128:	10001a26 	beq	r2,zero,81106194 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110612c:	e0bfff17 	ldw	r2,-4(fp)
81106130:	10800017 	ldw	r2,0(r2)
81106134:	01400444 	movi	r5,17
81106138:	1009883a 	mov	r4,r2
8110613c:	11067e00 	call	811067e0 <uliFeebReadReg>
81106140:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
81106144:	e0bffe17 	ldw	r2,-8(fp)
81106148:	1080800c 	andi	r2,r2,512
8110614c:	10000426 	beq	r2,zero,81106160 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81106150:	e0bfff17 	ldw	r2,-4(fp)
81106154:	00c00044 	movi	r3,1
81106158:	10c00215 	stw	r3,8(r2)
8110615c:	00000206 	br	81106168 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81106160:	e0bfff17 	ldw	r2,-4(fp)
81106164:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81106168:	e0bffe17 	ldw	r2,-8(fp)
8110616c:	1080400c 	andi	r2,r2,256
81106170:	10000426 	beq	r2,zero,81106184 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81106174:	e0bfff17 	ldw	r2,-4(fp)
81106178:	00c00044 	movi	r3,1
8110617c:	10c00315 	stw	r3,12(r2)
81106180:	00000206 	br	8110618c <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81106184:	e0bfff17 	ldw	r2,-4(fp)
81106188:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
8110618c:	00800044 	movi	r2,1
81106190:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106194:	e0bffd17 	ldw	r2,-12(fp)
}
81106198:	e037883a 	mov	sp,fp
8110619c:	dfc00117 	ldw	ra,4(sp)
811061a0:	df000017 	ldw	fp,0(sp)
811061a4:	dec00204 	addi	sp,sp,8
811061a8:	f800283a 	ret

811061ac <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
811061ac:	defffb04 	addi	sp,sp,-20
811061b0:	de00012e 	bgeu	sp,et,811061b8 <bFeebGetIrqFlags+0xc>
811061b4:	003b68fa 	trap	3
811061b8:	dfc00415 	stw	ra,16(sp)
811061bc:	df000315 	stw	fp,12(sp)
811061c0:	df000304 	addi	fp,sp,12
811061c4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811061c8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811061cc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811061d0:	e0bfff17 	ldw	r2,-4(fp)
811061d4:	10001126 	beq	r2,zero,8110621c <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811061d8:	e0bfff17 	ldw	r2,-4(fp)
811061dc:	10800017 	ldw	r2,0(r2)
811061e0:	01400484 	movi	r5,18
811061e4:	1009883a 	mov	r4,r2
811061e8:	11067e00 	call	811067e0 <uliFeebReadReg>
811061ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811061f0:	e0bffe17 	ldw	r2,-8(fp)
811061f4:	1080400c 	andi	r2,r2,256
811061f8:	10000426 	beq	r2,zero,8110620c <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
811061fc:	e0bfff17 	ldw	r2,-4(fp)
81106200:	00c00044 	movi	r3,1
81106204:	10c00415 	stw	r3,16(r2)
81106208:	00000206 	br	81106214 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
8110620c:	e0bfff17 	ldw	r2,-4(fp)
81106210:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81106214:	00800044 	movi	r2,1
81106218:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110621c:	e0bffd17 	ldw	r2,-12(fp)
}
81106220:	e037883a 	mov	sp,fp
81106224:	dfc00117 	ldw	ra,4(sp)
81106228:	df000017 	ldw	fp,0(sp)
8110622c:	dec00204 	addi	sp,sp,8
81106230:	f800283a 	ret

81106234 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
81106234:	defffb04 	addi	sp,sp,-20
81106238:	de00012e 	bgeu	sp,et,81106240 <bFeebGetBuffersStatus+0xc>
8110623c:	003b68fa 	trap	3
81106240:	dfc00415 	stw	ra,16(sp)
81106244:	df000315 	stw	fp,12(sp)
81106248:	df000304 	addi	fp,sp,12
8110624c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106250:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106254:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106258:	e0bfff17 	ldw	r2,-4(fp)
8110625c:	10003226 	beq	r2,zero,81106328 <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106260:	e0bfff17 	ldw	r2,-4(fp)
81106264:	10800017 	ldw	r2,0(r2)
81106268:	014000c4 	movi	r5,3
8110626c:	1009883a 	mov	r4,r2
81106270:	11067e00 	call	811067e0 <uliFeebReadReg>
81106274:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106278:	e0bffe17 	ldw	r2,-8(fp)
8110627c:	1080008c 	andi	r2,r2,2
81106280:	10000426 	beq	r2,zero,81106294 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81106284:	e0bfff17 	ldw	r2,-4(fp)
81106288:	00c00044 	movi	r3,1
8110628c:	10c00515 	stw	r3,20(r2)
81106290:	00000206 	br	8110629c <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81106294:	e0bfff17 	ldw	r2,-4(fp)
81106298:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
8110629c:	e0bffe17 	ldw	r2,-8(fp)
811062a0:	1080004c 	andi	r2,r2,1
811062a4:	10000426 	beq	r2,zero,811062b8 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
811062a8:	e0bfff17 	ldw	r2,-4(fp)
811062ac:	00c00044 	movi	r3,1
811062b0:	10c00615 	stw	r3,24(r2)
811062b4:	00000206 	br	811062c0 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
811062b8:	e0bfff17 	ldw	r2,-4(fp)
811062bc:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811062c0:	e0bfff17 	ldw	r2,-4(fp)
811062c4:	10800017 	ldw	r2,0(r2)
811062c8:	01400504 	movi	r5,20
811062cc:	1009883a 	mov	r4,r2
811062d0:	11067e00 	call	811067e0 <uliFeebReadReg>
811062d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
811062d8:	e0bffe17 	ldw	r2,-8(fp)
811062dc:	108003cc 	andi	r2,r2,15
811062e0:	10800044 	addi	r2,r2,1
811062e4:	1007883a 	mov	r3,r2
811062e8:	e0bfff17 	ldw	r2,-4(fp)
811062ec:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811062f0:	e0bfff17 	ldw	r2,-4(fp)
811062f4:	10800017 	ldw	r2,0(r2)
811062f8:	01400544 	movi	r5,21
811062fc:	1009883a 	mov	r4,r2
81106300:	11067e00 	call	811067e0 <uliFeebReadReg>
81106304:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106308:	e0bffe17 	ldw	r2,-8(fp)
8110630c:	108003cc 	andi	r2,r2,15
81106310:	10800044 	addi	r2,r2,1
81106314:	1007883a 	mov	r3,r2
81106318:	e0bfff17 	ldw	r2,-4(fp)
8110631c:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
81106320:	00800044 	movi	r2,1
81106324:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106328:	e0bffd17 	ldw	r2,-12(fp)
}
8110632c:	e037883a 	mov	sp,fp
81106330:	dfc00117 	ldw	ra,4(sp)
81106334:	df000017 	ldw	fp,0(sp)
81106338:	dec00204 	addi	sp,sp,8
8110633c:	f800283a 	ret

81106340 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81106340:	defffb04 	addi	sp,sp,-20
81106344:	de00012e 	bgeu	sp,et,8110634c <bFeebSetWindowing+0xc>
81106348:	003b68fa 	trap	3
8110634c:	dfc00415 	stw	ra,16(sp)
81106350:	df000315 	stw	fp,12(sp)
81106354:	df000304 	addi	fp,sp,12
81106358:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110635c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106360:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106364:	e0bfff17 	ldw	r2,-4(fp)
81106368:	10001926 	beq	r2,zero,811063d0 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110636c:	e0bfff17 	ldw	r2,-4(fp)
81106370:	10800017 	ldw	r2,0(r2)
81106374:	01400084 	movi	r5,2
81106378:	1009883a 	mov	r4,r2
8110637c:	11067e00 	call	811067e0 <uliFeebReadReg>
81106380:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81106384:	e0bfff17 	ldw	r2,-4(fp)
81106388:	10800117 	ldw	r2,4(r2)
8110638c:	10000426 	beq	r2,zero,811063a0 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81106390:	e0bffe17 	ldw	r2,-8(fp)
81106394:	10800214 	ori	r2,r2,8
81106398:	e0bffe15 	stw	r2,-8(fp)
8110639c:	00000406 	br	811063b0 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
811063a0:	e0fffe17 	ldw	r3,-8(fp)
811063a4:	00bffdc4 	movi	r2,-9
811063a8:	1884703a 	and	r2,r3,r2
811063ac:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811063b0:	e0bfff17 	ldw	r2,-4(fp)
811063b4:	10800017 	ldw	r2,0(r2)
811063b8:	e1bffe17 	ldw	r6,-8(fp)
811063bc:	01400084 	movi	r5,2
811063c0:	1009883a 	mov	r4,r2
811063c4:	110678c0 	call	8110678c <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811063c8:	00800044 	movi	r2,1
811063cc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811063d0:	e0bffd17 	ldw	r2,-12(fp)
}
811063d4:	e037883a 	mov	sp,fp
811063d8:	dfc00117 	ldw	ra,4(sp)
811063dc:	df000017 	ldw	fp,0(sp)
811063e0:	dec00204 	addi	sp,sp,8
811063e4:	f800283a 	ret

811063e8 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
811063e8:	defffb04 	addi	sp,sp,-20
811063ec:	de00012e 	bgeu	sp,et,811063f4 <bFeebGetWindowing+0xc>
811063f0:	003b68fa 	trap	3
811063f4:	dfc00415 	stw	ra,16(sp)
811063f8:	df000315 	stw	fp,12(sp)
811063fc:	df000304 	addi	fp,sp,12
81106400:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106404:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106408:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110640c:	e0bfff17 	ldw	r2,-4(fp)
81106410:	10001126 	beq	r2,zero,81106458 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106414:	e0bfff17 	ldw	r2,-4(fp)
81106418:	10800017 	ldw	r2,0(r2)
8110641c:	01400084 	movi	r5,2
81106420:	1009883a 	mov	r4,r2
81106424:	11067e00 	call	811067e0 <uliFeebReadReg>
81106428:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
8110642c:	e0bffe17 	ldw	r2,-8(fp)
81106430:	1080020c 	andi	r2,r2,8
81106434:	10000426 	beq	r2,zero,81106448 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81106438:	e0bfff17 	ldw	r2,-4(fp)
8110643c:	00c00044 	movi	r3,1
81106440:	10c00115 	stw	r3,4(r2)
81106444:	00000206 	br	81106450 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81106448:	e0bfff17 	ldw	r2,-4(fp)
8110644c:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81106450:	00800044 	movi	r2,1
81106454:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106458:	e0bffd17 	ldw	r2,-12(fp)
}
8110645c:	e037883a 	mov	sp,fp
81106460:	dfc00117 	ldw	ra,4(sp)
81106464:	df000017 	ldw	fp,0(sp)
81106468:	dec00204 	addi	sp,sp,8
8110646c:	f800283a 	ret

81106470 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81106470:	defffb04 	addi	sp,sp,-20
81106474:	de00012e 	bgeu	sp,et,8110647c <bFeebStartCh+0xc>
81106478:	003b68fa 	trap	3
8110647c:	dfc00415 	stw	ra,16(sp)
81106480:	df000315 	stw	fp,12(sp)
81106484:	df000304 	addi	fp,sp,12
81106488:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110648c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106490:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106494:	e0bfff17 	ldw	r2,-4(fp)
81106498:	10001126 	beq	r2,zero,811064e0 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110649c:	e0bfff17 	ldw	r2,-4(fp)
811064a0:	10800017 	ldw	r2,0(r2)
811064a4:	01400084 	movi	r5,2
811064a8:	1009883a 	mov	r4,r2
811064ac:	11067e00 	call	811067e0 <uliFeebReadReg>
811064b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
811064b4:	e0bffe17 	ldw	r2,-8(fp)
811064b8:	10800114 	ori	r2,r2,4
811064bc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811064c0:	e0bfff17 	ldw	r2,-4(fp)
811064c4:	10800017 	ldw	r2,0(r2)
811064c8:	e1bffe17 	ldw	r6,-8(fp)
811064cc:	01400084 	movi	r5,2
811064d0:	1009883a 	mov	r4,r2
811064d4:	110678c0 	call	8110678c <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811064d8:	00800044 	movi	r2,1
811064dc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811064e0:	e0bffd17 	ldw	r2,-12(fp)
}
811064e4:	e037883a 	mov	sp,fp
811064e8:	dfc00117 	ldw	ra,4(sp)
811064ec:	df000017 	ldw	fp,0(sp)
811064f0:	dec00204 	addi	sp,sp,8
811064f4:	f800283a 	ret

811064f8 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
811064f8:	defffb04 	addi	sp,sp,-20
811064fc:	de00012e 	bgeu	sp,et,81106504 <bFeebStopCh+0xc>
81106500:	003b68fa 	trap	3
81106504:	dfc00415 	stw	ra,16(sp)
81106508:	df000315 	stw	fp,12(sp)
8110650c:	df000304 	addi	fp,sp,12
81106510:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106514:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106518:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110651c:	e0bfff17 	ldw	r2,-4(fp)
81106520:	10001126 	beq	r2,zero,81106568 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106524:	e0bfff17 	ldw	r2,-4(fp)
81106528:	10800017 	ldw	r2,0(r2)
8110652c:	01400084 	movi	r5,2
81106530:	1009883a 	mov	r4,r2
81106534:	11067e00 	call	811067e0 <uliFeebReadReg>
81106538:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
8110653c:	e0bffe17 	ldw	r2,-8(fp)
81106540:	10800094 	ori	r2,r2,2
81106544:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106548:	e0bfff17 	ldw	r2,-4(fp)
8110654c:	10800017 	ldw	r2,0(r2)
81106550:	e1bffe17 	ldw	r6,-8(fp)
81106554:	01400084 	movi	r5,2
81106558:	1009883a 	mov	r4,r2
8110655c:	110678c0 	call	8110678c <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106560:	00800044 	movi	r2,1
81106564:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106568:	e0bffd17 	ldw	r2,-12(fp)
}
8110656c:	e037883a 	mov	sp,fp
81106570:	dfc00117 	ldw	ra,4(sp)
81106574:	df000017 	ldw	fp,0(sp)
81106578:	dec00204 	addi	sp,sp,8
8110657c:	f800283a 	ret

81106580 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81106580:	defffb04 	addi	sp,sp,-20
81106584:	de00012e 	bgeu	sp,et,8110658c <bFeebClrCh+0xc>
81106588:	003b68fa 	trap	3
8110658c:	dfc00415 	stw	ra,16(sp)
81106590:	df000315 	stw	fp,12(sp)
81106594:	df000304 	addi	fp,sp,12
81106598:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110659c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811065a0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811065a4:	e0bfff17 	ldw	r2,-4(fp)
811065a8:	10001126 	beq	r2,zero,811065f0 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811065ac:	e0bfff17 	ldw	r2,-4(fp)
811065b0:	10800017 	ldw	r2,0(r2)
811065b4:	01400084 	movi	r5,2
811065b8:	1009883a 	mov	r4,r2
811065bc:	11067e00 	call	811067e0 <uliFeebReadReg>
811065c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
811065c4:	e0bffe17 	ldw	r2,-8(fp)
811065c8:	10800054 	ori	r2,r2,1
811065cc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811065d0:	e0bfff17 	ldw	r2,-4(fp)
811065d4:	10800017 	ldw	r2,0(r2)
811065d8:	e1bffe17 	ldw	r6,-8(fp)
811065dc:	01400084 	movi	r5,2
811065e0:	1009883a 	mov	r4,r2
811065e4:	110678c0 	call	8110678c <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811065e8:	00800044 	movi	r2,1
811065ec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811065f0:	e0bffd17 	ldw	r2,-12(fp)
}
811065f4:	e037883a 	mov	sp,fp
811065f8:	dfc00117 	ldw	ra,4(sp)
811065fc:	df000017 	ldw	fp,0(sp)
81106600:	dec00204 	addi	sp,sp,8
81106604:	f800283a 	ret

81106608 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81106608:	defffb04 	addi	sp,sp,-20
8110660c:	de00012e 	bgeu	sp,et,81106614 <bFeebInitCh+0xc>
81106610:	003b68fa 	trap	3
81106614:	dfc00415 	stw	ra,16(sp)
81106618:	df000315 	stw	fp,12(sp)
8110661c:	df000304 	addi	fp,sp,12
81106620:	e13ffe15 	stw	r4,-8(fp)
81106624:	2805883a 	mov	r2,r5
81106628:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110662c:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81106630:	e0bffe17 	ldw	r2,-8(fp)
81106634:	10004f26 	beq	r2,zero,81106774 <bFeebInitCh+0x16c>
		bStatus = TRUE;
81106638:	00800044 	movi	r2,1
8110663c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81106640:	e0bfff03 	ldbu	r2,-4(fp)
81106644:	10c00228 	cmpgeui	r3,r2,8
81106648:	1800361e 	bne	r3,zero,81106724 <bFeebInitCh+0x11c>
8110664c:	100690ba 	slli	r3,r2,2
81106650:	00a04434 	movhi	r2,33040
81106654:	10999904 	addi	r2,r2,26212
81106658:	1885883a 	add	r2,r3,r2
8110665c:	10800017 	ldw	r2,0(r2)
81106660:	1000683a 	jmp	r2
81106664:	81106684 	addi	r4,r16,16794
81106668:	81106698 	cmpnei	r4,r16,16794
8110666c:	811066ac 	andhi	r4,r16,16794
81106670:	811066c0 	call	8811066c <__reset+0x20f066c>
81106674:	811066d4 	ori	r4,r16,16795
81106678:	811066e8 	cmpgeui	r4,r16,16795
8110667c:	811066fc 	xorhi	r4,r16,16795
81106680:	81106710 	cmplti	r4,r16,16796
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106684:	e0fffe17 	ldw	r3,-8(fp)
81106688:	00a04834 	movhi	r2,33056
8110668c:	108b0004 	addi	r2,r2,11264
81106690:	18800015 	stw	r2,0(r3)
			break;
81106694:	00002506 	br	8110672c <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106698:	e0fffe17 	ldw	r3,-8(fp)
8110669c:	00a04834 	movhi	r2,33056
811066a0:	108a0004 	addi	r2,r2,10240
811066a4:	18800015 	stw	r2,0(r3)
			break;
811066a8:	00002006 	br	8110672c <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811066ac:	e0fffe17 	ldw	r3,-8(fp)
811066b0:	00a04834 	movhi	r2,33056
811066b4:	10890004 	addi	r2,r2,9216
811066b8:	18800015 	stw	r2,0(r3)
			break;
811066bc:	00001b06 	br	8110672c <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811066c0:	e0fffe17 	ldw	r3,-8(fp)
811066c4:	00a04834 	movhi	r2,33056
811066c8:	10880004 	addi	r2,r2,8192
811066cc:	18800015 	stw	r2,0(r3)
			break;
811066d0:	00001606 	br	8110672c <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811066d4:	e0fffe17 	ldw	r3,-8(fp)
811066d8:	00a04834 	movhi	r2,33056
811066dc:	10870004 	addi	r2,r2,7168
811066e0:	18800015 	stw	r2,0(r3)
			break;
811066e4:	00001106 	br	8110672c <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811066e8:	e0fffe17 	ldw	r3,-8(fp)
811066ec:	00a04834 	movhi	r2,33056
811066f0:	10860004 	addi	r2,r2,6144
811066f4:	18800015 	stw	r2,0(r3)
			break;
811066f8:	00000c06 	br	8110672c <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811066fc:	e0fffe17 	ldw	r3,-8(fp)
81106700:	00a04834 	movhi	r2,33056
81106704:	10850004 	addi	r2,r2,5120
81106708:	18800015 	stw	r2,0(r3)
			break;
8110670c:	00000706 	br	8110672c <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106710:	e0fffe17 	ldw	r3,-8(fp)
81106714:	00a04834 	movhi	r2,33056
81106718:	10840004 	addi	r2,r2,4096
8110671c:	18800015 	stw	r2,0(r3)
			break;
81106720:	00000206 	br	8110672c <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106724:	e03ffd15 	stw	zero,-12(fp)
			break;
81106728:	0001883a 	nop
		}

		if (bStatus) {
8110672c:	e0bffd17 	ldw	r2,-12(fp)
81106730:	10001026 	beq	r2,zero,81106774 <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106734:	e13ffe17 	ldw	r4,-8(fp)
81106738:	11061000 	call	81106100 <bFeebGetIrqControl>
8110673c:	1000011e 	bne	r2,zero,81106744 <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106740:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106744:	e13ffe17 	ldw	r4,-8(fp)
81106748:	11061ac0 	call	811061ac <bFeebGetIrqFlags>
8110674c:	1000011e 	bne	r2,zero,81106754 <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106750:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106754:	e13ffe17 	ldw	r4,-8(fp)
81106758:	11062340 	call	81106234 <bFeebGetBuffersStatus>
8110675c:	1000011e 	bne	r2,zero,81106764 <bFeebInitCh+0x15c>
				bStatus = FALSE;
81106760:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106764:	e13ffe17 	ldw	r4,-8(fp)
81106768:	11063e80 	call	811063e8 <bFeebGetWindowing>
8110676c:	1000011e 	bne	r2,zero,81106774 <bFeebInitCh+0x16c>
				bStatus = FALSE;
81106770:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106774:	e0bffd17 	ldw	r2,-12(fp)
}
81106778:	e037883a 	mov	sp,fp
8110677c:	dfc00117 	ldw	ra,4(sp)
81106780:	df000017 	ldw	fp,0(sp)
81106784:	dec00204 	addi	sp,sp,8
81106788:	f800283a 	ret

8110678c <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110678c:	defffc04 	addi	sp,sp,-16
81106790:	de00012e 	bgeu	sp,et,81106798 <vFeebWriteReg+0xc>
81106794:	003b68fa 	trap	3
81106798:	df000315 	stw	fp,12(sp)
8110679c:	df000304 	addi	fp,sp,12
811067a0:	e13ffd15 	stw	r4,-12(fp)
811067a4:	e17ffe15 	stw	r5,-8(fp)
811067a8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811067ac:	e0bffe17 	ldw	r2,-8(fp)
811067b0:	1085883a 	add	r2,r2,r2
811067b4:	1085883a 	add	r2,r2,r2
811067b8:	1007883a 	mov	r3,r2
811067bc:	e0bffd17 	ldw	r2,-12(fp)
811067c0:	10c5883a 	add	r2,r2,r3
811067c4:	e0ffff17 	ldw	r3,-4(fp)
811067c8:	10c00015 	stw	r3,0(r2)
}
811067cc:	0001883a 	nop
811067d0:	e037883a 	mov	sp,fp
811067d4:	df000017 	ldw	fp,0(sp)
811067d8:	dec00104 	addi	sp,sp,4
811067dc:	f800283a 	ret

811067e0 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811067e0:	defffc04 	addi	sp,sp,-16
811067e4:	de00012e 	bgeu	sp,et,811067ec <uliFeebReadReg+0xc>
811067e8:	003b68fa 	trap	3
811067ec:	df000315 	stw	fp,12(sp)
811067f0:	df000304 	addi	fp,sp,12
811067f4:	e13ffe15 	stw	r4,-8(fp)
811067f8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811067fc:	e0bfff17 	ldw	r2,-4(fp)
81106800:	1085883a 	add	r2,r2,r2
81106804:	1085883a 	add	r2,r2,r2
81106808:	1007883a 	mov	r3,r2
8110680c:	e0bffe17 	ldw	r2,-8(fp)
81106810:	10c5883a 	add	r2,r2,r3
81106814:	10800017 	ldw	r2,0(r2)
81106818:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110681c:	e0bffd17 	ldw	r2,-12(fp)
}
81106820:	e037883a 	mov	sp,fp
81106824:	df000017 	ldw	fp,0(sp)
81106828:	dec00104 	addi	sp,sp,4
8110682c:	f800283a 	ret

81106830 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81106830:	defff704 	addi	sp,sp,-36
81106834:	de00012e 	bgeu	sp,et,8110683c <vRmapCh1HandleIrq+0xc>
81106838:	003b68fa 	trap	3
8110683c:	dfc00815 	stw	ra,32(sp)
81106840:	df000715 	stw	fp,28(sp)
81106844:	df000704 	addi	fp,sp,28
81106848:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110684c:	e0bfff17 	ldw	r2,-4(fp)
81106850:	e0bff915 	stw	r2,-28(fp)
	INT32U ucValueMasked;
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106854:	1106ff80 	call	81106ff8 <uliRmapCh1WriteCmdAddress>
81106858:	e0bffa05 	stb	r2,-24(fp)

	/*Need verify if is force trigger*/
	if (0x4D == ucADDRReg) {
8110685c:	e0bffa03 	ldbu	r2,-24(fp)
81106860:	10801358 	cmpnei	r2,r2,77
81106864:	1000241e 	bne	r2,zero,811068f8 <vRmapCh1HandleIrq+0xc8>
		ucValueReg = uliRmapReadReg(xRmap[0].puliRmapChAddr,  ucADDRReg);
81106868:	00a04574 	movhi	r2,33045
8110686c:	10bfaf04 	addi	r2,r2,-324
81106870:	10800017 	ldw	r2,0(r2)
81106874:	e0fffa03 	ldbu	r3,-24(fp)
81106878:	180b883a 	mov	r5,r3
8110687c:	1009883a 	mov	r4,r2
81106880:	11096340 	call	81109634 <uliRmapReadReg>
81106884:	e0bffb15 	stw	r2,-20(fp)
		ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81106888:	e0bffb17 	ldw	r2,-20(fp)
8110688c:	1080010c 	andi	r2,r2,4
81106890:	1004d0ba 	srli	r2,r2,2
81106894:	e0bffc15 	stw	r2,-16(fp)
		if (ucValueMasked){
81106898:	e0bffc17 	ldw	r2,-16(fp)
8110689c:	10002726 	beq	r2,zero,8110693c <vRmapCh1HandleIrq+0x10c>
			//if ( xSimMeb->xFeeControl.xNfee[0].xControl.bWatingSync == TRUE ) {
				uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
811068a0:	00800444 	movi	r2,17
811068a4:	e0bffec5 	stb	r2,-5(fp)
				uiCmdRmap.ucByte[2] = M_SYNC;
811068a8:	00bff844 	movi	r2,-31
811068ac:	e0bffe85 	stb	r2,-6(fp)
				error_codel = OSQPost(xWaitSyncQFee[ 0 ], (void *)uiCmdRmap.ulWord);
811068b0:	d0a05b17 	ldw	r2,-32404(gp)
811068b4:	e0fffe17 	ldw	r3,-8(fp)
811068b8:	180b883a 	mov	r5,r3
811068bc:	1009883a 	mov	r4,r2
811068c0:	113ac000 	call	8113ac00 <OSQPost>
811068c4:	e0bffd05 	stb	r2,-12(fp)
				if ( error_codel != OS_ERR_NONE ) {
811068c8:	e0bffd03 	ldbu	r2,-12(fp)
811068cc:	10000226 	beq	r2,zero,811068d8 <vRmapCh1HandleIrq+0xa8>
					vFailSendMsgSyncRMAPTRIGGER(0);
811068d0:	0009883a 	mov	r4,zero
811068d4:	111a23c0 	call	8111a23c <vFailSendMsgSyncRMAPTRIGGER>
				}

				#ifdef DEBUG_ON
					fprintf(fp," - Mode Forced.\n");
811068d8:	d0a06117 	ldw	r2,-32380(gp)
811068dc:	100f883a 	mov	r7,r2
811068e0:	01800404 	movi	r6,16
811068e4:	01400044 	movi	r5,1
811068e8:	01204574 	movhi	r4,33045
811068ec:	21240b04 	addi	r4,r4,-28628
811068f0:	111dcb00 	call	8111dcb0 <fwrite>
811068f4:	00001106 	br	8110693c <vRmapCh1HandleIrq+0x10c>
			//bRmapGetMemConfigArea(&xSimMeb->xFeeControl.xNfee[0].xChannel.xRmap);
			//xSimMeb->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( xSimMeb->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
			//bRmapSetMemConfigArea(&xSimMeb->xFeeControl.xNfee[0].xChannel.xRmap);
		}
	} else {
		uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
811068f8:	00800444 	movi	r2,17
811068fc:	e0bffec5 	stb	r2,-5(fp)
		uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106900:	00bffc04 	movi	r2,-16
81106904:	e0bffe85 	stb	r2,-6(fp)
		uiCmdRmap.ucByte[1] = ucADDRReg;
81106908:	e0bffa03 	ldbu	r2,-24(fp)
8110690c:	e0bffe45 	stb	r2,-7(fp)
		uiCmdRmap.ucByte[0] = 0;
81106910:	e03ffe05 	stb	zero,-8(fp)

		error_codel = OSQPost(xFeeQ[0], (void *)uiCmdRmap.ulWord);
81106914:	d0a06917 	ldw	r2,-32348(gp)
81106918:	e0fffe17 	ldw	r3,-8(fp)
8110691c:	180b883a 	mov	r5,r3
81106920:	1009883a 	mov	r4,r2
81106924:	113ac000 	call	8113ac00 <OSQPost>
81106928:	e0bffd05 	stb	r2,-12(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110692c:	e0bffd03 	ldbu	r2,-12(fp)
81106930:	10000226 	beq	r2,zero,8110693c <vRmapCh1HandleIrq+0x10c>
			vFailSendRMAPFromIRQ( 0 );
81106934:	0009883a 	mov	r4,zero
81106938:	111a1940 	call	8111a194 <vFailSendRMAPFromIRQ>
		}
	}



	vRmapCh1IrqFlagClrWriteCmd();
8110693c:	1106b180 	call	81106b18 <vRmapCh1IrqFlagClrWriteCmd>
}
81106940:	0001883a 	nop
81106944:	e037883a 	mov	sp,fp
81106948:	dfc00117 	ldw	ra,4(sp)
8110694c:	df000017 	ldw	fp,0(sp)
81106950:	dec00204 	addi	sp,sp,8
81106954:	f800283a 	ret

81106958 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81106958:	defffc04 	addi	sp,sp,-16
8110695c:	de00012e 	bgeu	sp,et,81106964 <vRmapCh2HandleIrq+0xc>
81106960:	003b68fa 	trap	3
81106964:	dfc00315 	stw	ra,12(sp)
81106968:	df000215 	stw	fp,8(sp)
8110696c:	df000204 	addi	fp,sp,8
81106970:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106974:	e0bfff17 	ldw	r2,-4(fp)
81106978:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
8110697c:	1106b5c0 	call	81106b5c <vRmapCh2IrqFlagClrWriteCmd>
}
81106980:	0001883a 	nop
81106984:	e037883a 	mov	sp,fp
81106988:	dfc00117 	ldw	ra,4(sp)
8110698c:	df000017 	ldw	fp,0(sp)
81106990:	dec00204 	addi	sp,sp,8
81106994:	f800283a 	ret

81106998 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81106998:	defffc04 	addi	sp,sp,-16
8110699c:	de00012e 	bgeu	sp,et,811069a4 <vRmapCh3HandleIrq+0xc>
811069a0:	003b68fa 	trap	3
811069a4:	dfc00315 	stw	ra,12(sp)
811069a8:	df000215 	stw	fp,8(sp)
811069ac:	df000204 	addi	fp,sp,8
811069b0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811069b4:	e0bfff17 	ldw	r2,-4(fp)
811069b8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
811069bc:	1106ba00 	call	81106ba0 <vRmapCh3IrqFlagClrWriteCmd>
}
811069c0:	0001883a 	nop
811069c4:	e037883a 	mov	sp,fp
811069c8:	dfc00117 	ldw	ra,4(sp)
811069cc:	df000017 	ldw	fp,0(sp)
811069d0:	dec00204 	addi	sp,sp,8
811069d4:	f800283a 	ret

811069d8 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
811069d8:	defffc04 	addi	sp,sp,-16
811069dc:	de00012e 	bgeu	sp,et,811069e4 <vRmapCh4HandleIrq+0xc>
811069e0:	003b68fa 	trap	3
811069e4:	dfc00315 	stw	ra,12(sp)
811069e8:	df000215 	stw	fp,8(sp)
811069ec:	df000204 	addi	fp,sp,8
811069f0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811069f4:	e0bfff17 	ldw	r2,-4(fp)
811069f8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
811069fc:	1106be40 	call	81106be4 <vRmapCh4IrqFlagClrWriteCmd>
}
81106a00:	0001883a 	nop
81106a04:	e037883a 	mov	sp,fp
81106a08:	dfc00117 	ldw	ra,4(sp)
81106a0c:	df000017 	ldw	fp,0(sp)
81106a10:	dec00204 	addi	sp,sp,8
81106a14:	f800283a 	ret

81106a18 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81106a18:	defffc04 	addi	sp,sp,-16
81106a1c:	de00012e 	bgeu	sp,et,81106a24 <vRmapCh5HandleIrq+0xc>
81106a20:	003b68fa 	trap	3
81106a24:	dfc00315 	stw	ra,12(sp)
81106a28:	df000215 	stw	fp,8(sp)
81106a2c:	df000204 	addi	fp,sp,8
81106a30:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106a34:	e0bfff17 	ldw	r2,-4(fp)
81106a38:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106a3c:	1106c280 	call	81106c28 <vRmapCh5IrqFlagClrWriteCmd>
}
81106a40:	0001883a 	nop
81106a44:	e037883a 	mov	sp,fp
81106a48:	dfc00117 	ldw	ra,4(sp)
81106a4c:	df000017 	ldw	fp,0(sp)
81106a50:	dec00204 	addi	sp,sp,8
81106a54:	f800283a 	ret

81106a58 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81106a58:	defffc04 	addi	sp,sp,-16
81106a5c:	de00012e 	bgeu	sp,et,81106a64 <vRmapCh6HandleIrq+0xc>
81106a60:	003b68fa 	trap	3
81106a64:	dfc00315 	stw	ra,12(sp)
81106a68:	df000215 	stw	fp,8(sp)
81106a6c:	df000204 	addi	fp,sp,8
81106a70:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106a74:	e0bfff17 	ldw	r2,-4(fp)
81106a78:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81106a7c:	1106c6c0 	call	81106c6c <vRmapCh6IrqFlagClrWriteCmd>
}
81106a80:	0001883a 	nop
81106a84:	e037883a 	mov	sp,fp
81106a88:	dfc00117 	ldw	ra,4(sp)
81106a8c:	df000017 	ldw	fp,0(sp)
81106a90:	dec00204 	addi	sp,sp,8
81106a94:	f800283a 	ret

81106a98 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81106a98:	defffc04 	addi	sp,sp,-16
81106a9c:	de00012e 	bgeu	sp,et,81106aa4 <vRmapCh7HandleIrq+0xc>
81106aa0:	003b68fa 	trap	3
81106aa4:	dfc00315 	stw	ra,12(sp)
81106aa8:	df000215 	stw	fp,8(sp)
81106aac:	df000204 	addi	fp,sp,8
81106ab0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106ab4:	e0bfff17 	ldw	r2,-4(fp)
81106ab8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106abc:	1106cb00 	call	81106cb0 <vRmapCh7IrqFlagClrWriteCmd>
}
81106ac0:	0001883a 	nop
81106ac4:	e037883a 	mov	sp,fp
81106ac8:	dfc00117 	ldw	ra,4(sp)
81106acc:	df000017 	ldw	fp,0(sp)
81106ad0:	dec00204 	addi	sp,sp,8
81106ad4:	f800283a 	ret

81106ad8 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81106ad8:	defffc04 	addi	sp,sp,-16
81106adc:	de00012e 	bgeu	sp,et,81106ae4 <vRmapCh8HandleIrq+0xc>
81106ae0:	003b68fa 	trap	3
81106ae4:	dfc00315 	stw	ra,12(sp)
81106ae8:	df000215 	stw	fp,8(sp)
81106aec:	df000204 	addi	fp,sp,8
81106af0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106af4:	e0bfff17 	ldw	r2,-4(fp)
81106af8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106afc:	1106cf40 	call	81106cf4 <vRmapCh8IrqFlagClrWriteCmd>
}
81106b00:	0001883a 	nop
81106b04:	e037883a 	mov	sp,fp
81106b08:	dfc00117 	ldw	ra,4(sp)
81106b0c:	df000017 	ldw	fp,0(sp)
81106b10:	dec00204 	addi	sp,sp,8
81106b14:	f800283a 	ret

81106b18 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81106b18:	defffe04 	addi	sp,sp,-8
81106b1c:	de00012e 	bgeu	sp,et,81106b24 <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106b20:	003b68fa 	trap	3
81106b24:	dfc00115 	stw	ra,4(sp)
81106b28:	df000015 	stw	fp,0(sp)
81106b2c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106b30:	01800044 	movi	r6,1
81106b34:	014004c4 	movi	r5,19
81106b38:	01204834 	movhi	r4,33056
81106b3c:	210b0004 	addi	r4,r4,11264
81106b40:	11095e00 	call	811095e0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106b44:	0001883a 	nop
81106b48:	e037883a 	mov	sp,fp
81106b4c:	dfc00117 	ldw	ra,4(sp)
81106b50:	df000017 	ldw	fp,0(sp)
81106b54:	dec00204 	addi	sp,sp,8
81106b58:	f800283a 	ret

81106b5c <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81106b5c:	defffe04 	addi	sp,sp,-8
81106b60:	de00012e 	bgeu	sp,et,81106b68 <vRmapCh2IrqFlagClrWriteCmd+0xc>
81106b64:	003b68fa 	trap	3
81106b68:	dfc00115 	stw	ra,4(sp)
81106b6c:	df000015 	stw	fp,0(sp)
81106b70:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106b74:	01800044 	movi	r6,1
81106b78:	014004c4 	movi	r5,19
81106b7c:	01204834 	movhi	r4,33056
81106b80:	210a0004 	addi	r4,r4,10240
81106b84:	11095e00 	call	811095e0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106b88:	0001883a 	nop
81106b8c:	e037883a 	mov	sp,fp
81106b90:	dfc00117 	ldw	ra,4(sp)
81106b94:	df000017 	ldw	fp,0(sp)
81106b98:	dec00204 	addi	sp,sp,8
81106b9c:	f800283a 	ret

81106ba0 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81106ba0:	defffe04 	addi	sp,sp,-8
81106ba4:	de00012e 	bgeu	sp,et,81106bac <vRmapCh3IrqFlagClrWriteCmd+0xc>
81106ba8:	003b68fa 	trap	3
81106bac:	dfc00115 	stw	ra,4(sp)
81106bb0:	df000015 	stw	fp,0(sp)
81106bb4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106bb8:	01800044 	movi	r6,1
81106bbc:	014004c4 	movi	r5,19
81106bc0:	01204834 	movhi	r4,33056
81106bc4:	21090004 	addi	r4,r4,9216
81106bc8:	11095e00 	call	811095e0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106bcc:	0001883a 	nop
81106bd0:	e037883a 	mov	sp,fp
81106bd4:	dfc00117 	ldw	ra,4(sp)
81106bd8:	df000017 	ldw	fp,0(sp)
81106bdc:	dec00204 	addi	sp,sp,8
81106be0:	f800283a 	ret

81106be4 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81106be4:	defffe04 	addi	sp,sp,-8
81106be8:	de00012e 	bgeu	sp,et,81106bf0 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81106bec:	003b68fa 	trap	3
81106bf0:	dfc00115 	stw	ra,4(sp)
81106bf4:	df000015 	stw	fp,0(sp)
81106bf8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106bfc:	01800044 	movi	r6,1
81106c00:	014004c4 	movi	r5,19
81106c04:	01204834 	movhi	r4,33056
81106c08:	21080004 	addi	r4,r4,8192
81106c0c:	11095e00 	call	811095e0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106c10:	0001883a 	nop
81106c14:	e037883a 	mov	sp,fp
81106c18:	dfc00117 	ldw	ra,4(sp)
81106c1c:	df000017 	ldw	fp,0(sp)
81106c20:	dec00204 	addi	sp,sp,8
81106c24:	f800283a 	ret

81106c28 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
81106c28:	defffe04 	addi	sp,sp,-8
81106c2c:	de00012e 	bgeu	sp,et,81106c34 <vRmapCh5IrqFlagClrWriteCmd+0xc>
81106c30:	003b68fa 	trap	3
81106c34:	dfc00115 	stw	ra,4(sp)
81106c38:	df000015 	stw	fp,0(sp)
81106c3c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106c40:	01800044 	movi	r6,1
81106c44:	014004c4 	movi	r5,19
81106c48:	01204834 	movhi	r4,33056
81106c4c:	21070004 	addi	r4,r4,7168
81106c50:	11095e00 	call	811095e0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106c54:	0001883a 	nop
81106c58:	e037883a 	mov	sp,fp
81106c5c:	dfc00117 	ldw	ra,4(sp)
81106c60:	df000017 	ldw	fp,0(sp)
81106c64:	dec00204 	addi	sp,sp,8
81106c68:	f800283a 	ret

81106c6c <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81106c6c:	defffe04 	addi	sp,sp,-8
81106c70:	de00012e 	bgeu	sp,et,81106c78 <vRmapCh6IrqFlagClrWriteCmd+0xc>
81106c74:	003b68fa 	trap	3
81106c78:	dfc00115 	stw	ra,4(sp)
81106c7c:	df000015 	stw	fp,0(sp)
81106c80:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106c84:	01800044 	movi	r6,1
81106c88:	014004c4 	movi	r5,19
81106c8c:	01204834 	movhi	r4,33056
81106c90:	21060004 	addi	r4,r4,6144
81106c94:	11095e00 	call	811095e0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106c98:	0001883a 	nop
81106c9c:	e037883a 	mov	sp,fp
81106ca0:	dfc00117 	ldw	ra,4(sp)
81106ca4:	df000017 	ldw	fp,0(sp)
81106ca8:	dec00204 	addi	sp,sp,8
81106cac:	f800283a 	ret

81106cb0 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81106cb0:	defffe04 	addi	sp,sp,-8
81106cb4:	de00012e 	bgeu	sp,et,81106cbc <vRmapCh7IrqFlagClrWriteCmd+0xc>
81106cb8:	003b68fa 	trap	3
81106cbc:	dfc00115 	stw	ra,4(sp)
81106cc0:	df000015 	stw	fp,0(sp)
81106cc4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106cc8:	01800044 	movi	r6,1
81106ccc:	014004c4 	movi	r5,19
81106cd0:	01204834 	movhi	r4,33056
81106cd4:	21050004 	addi	r4,r4,5120
81106cd8:	11095e00 	call	811095e0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106cdc:	0001883a 	nop
81106ce0:	e037883a 	mov	sp,fp
81106ce4:	dfc00117 	ldw	ra,4(sp)
81106ce8:	df000017 	ldw	fp,0(sp)
81106cec:	dec00204 	addi	sp,sp,8
81106cf0:	f800283a 	ret

81106cf4 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
81106cf4:	defffe04 	addi	sp,sp,-8
81106cf8:	de00012e 	bgeu	sp,et,81106d00 <vRmapCh8IrqFlagClrWriteCmd+0xc>
81106cfc:	003b68fa 	trap	3
81106d00:	dfc00115 	stw	ra,4(sp)
81106d04:	df000015 	stw	fp,0(sp)
81106d08:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106d0c:	01800044 	movi	r6,1
81106d10:	014004c4 	movi	r5,19
81106d14:	01204834 	movhi	r4,33056
81106d18:	21040004 	addi	r4,r4,4096
81106d1c:	11095e00 	call	811095e0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106d20:	0001883a 	nop
81106d24:	e037883a 	mov	sp,fp
81106d28:	dfc00117 	ldw	ra,4(sp)
81106d2c:	df000017 	ldw	fp,0(sp)
81106d30:	dec00204 	addi	sp,sp,8
81106d34:	f800283a 	ret

81106d38 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
81106d38:	defffd04 	addi	sp,sp,-12
81106d3c:	de00012e 	bgeu	sp,et,81106d44 <bRmapCh1IrqFlagWriteCmd+0xc>
81106d40:	003b68fa 	trap	3
81106d44:	dfc00215 	stw	ra,8(sp)
81106d48:	df000115 	stw	fp,4(sp)
81106d4c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106d50:	01400484 	movi	r5,18
81106d54:	01204834 	movhi	r4,33056
81106d58:	210b0004 	addi	r4,r4,11264
81106d5c:	11096340 	call	81109634 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106d60:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106d64:	10000326 	beq	r2,zero,81106d74 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106d68:	00800044 	movi	r2,1
81106d6c:	e0bfff15 	stw	r2,-4(fp)
81106d70:	00000106 	br	81106d78 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106d74:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106d78:	e0bfff17 	ldw	r2,-4(fp)
}
81106d7c:	e037883a 	mov	sp,fp
81106d80:	dfc00117 	ldw	ra,4(sp)
81106d84:	df000017 	ldw	fp,0(sp)
81106d88:	dec00204 	addi	sp,sp,8
81106d8c:	f800283a 	ret

81106d90 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81106d90:	defffd04 	addi	sp,sp,-12
81106d94:	de00012e 	bgeu	sp,et,81106d9c <bRmapCh2IrqFlagWriteCmd+0xc>
81106d98:	003b68fa 	trap	3
81106d9c:	dfc00215 	stw	ra,8(sp)
81106da0:	df000115 	stw	fp,4(sp)
81106da4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106da8:	01400484 	movi	r5,18
81106dac:	01204834 	movhi	r4,33056
81106db0:	210a0004 	addi	r4,r4,10240
81106db4:	11096340 	call	81109634 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106db8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106dbc:	10000326 	beq	r2,zero,81106dcc <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106dc0:	00800044 	movi	r2,1
81106dc4:	e0bfff15 	stw	r2,-4(fp)
81106dc8:	00000106 	br	81106dd0 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106dcc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106dd0:	e0bfff17 	ldw	r2,-4(fp)
}
81106dd4:	e037883a 	mov	sp,fp
81106dd8:	dfc00117 	ldw	ra,4(sp)
81106ddc:	df000017 	ldw	fp,0(sp)
81106de0:	dec00204 	addi	sp,sp,8
81106de4:	f800283a 	ret

81106de8 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
81106de8:	defffd04 	addi	sp,sp,-12
81106dec:	de00012e 	bgeu	sp,et,81106df4 <bRmapCh3IrqFlagWriteCmd+0xc>
81106df0:	003b68fa 	trap	3
81106df4:	dfc00215 	stw	ra,8(sp)
81106df8:	df000115 	stw	fp,4(sp)
81106dfc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106e00:	01400484 	movi	r5,18
81106e04:	01204834 	movhi	r4,33056
81106e08:	21090004 	addi	r4,r4,9216
81106e0c:	11096340 	call	81109634 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106e10:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106e14:	10000326 	beq	r2,zero,81106e24 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106e18:	00800044 	movi	r2,1
81106e1c:	e0bfff15 	stw	r2,-4(fp)
81106e20:	00000106 	br	81106e28 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106e24:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106e28:	e0bfff17 	ldw	r2,-4(fp)
}
81106e2c:	e037883a 	mov	sp,fp
81106e30:	dfc00117 	ldw	ra,4(sp)
81106e34:	df000017 	ldw	fp,0(sp)
81106e38:	dec00204 	addi	sp,sp,8
81106e3c:	f800283a 	ret

81106e40 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81106e40:	defffd04 	addi	sp,sp,-12
81106e44:	de00012e 	bgeu	sp,et,81106e4c <bRmapCh4IrqFlagWriteCmd+0xc>
81106e48:	003b68fa 	trap	3
81106e4c:	dfc00215 	stw	ra,8(sp)
81106e50:	df000115 	stw	fp,4(sp)
81106e54:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106e58:	01400484 	movi	r5,18
81106e5c:	01204834 	movhi	r4,33056
81106e60:	21080004 	addi	r4,r4,8192
81106e64:	11096340 	call	81109634 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106e68:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106e6c:	10000326 	beq	r2,zero,81106e7c <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106e70:	00800044 	movi	r2,1
81106e74:	e0bfff15 	stw	r2,-4(fp)
81106e78:	00000106 	br	81106e80 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106e7c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106e80:	e0bfff17 	ldw	r2,-4(fp)
}
81106e84:	e037883a 	mov	sp,fp
81106e88:	dfc00117 	ldw	ra,4(sp)
81106e8c:	df000017 	ldw	fp,0(sp)
81106e90:	dec00204 	addi	sp,sp,8
81106e94:	f800283a 	ret

81106e98 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81106e98:	defffd04 	addi	sp,sp,-12
81106e9c:	de00012e 	bgeu	sp,et,81106ea4 <bRmapCh5IrqFlagWriteCmd+0xc>
81106ea0:	003b68fa 	trap	3
81106ea4:	dfc00215 	stw	ra,8(sp)
81106ea8:	df000115 	stw	fp,4(sp)
81106eac:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106eb0:	01400484 	movi	r5,18
81106eb4:	01204834 	movhi	r4,33056
81106eb8:	21070004 	addi	r4,r4,7168
81106ebc:	11096340 	call	81109634 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106ec0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106ec4:	10000326 	beq	r2,zero,81106ed4 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106ec8:	00800044 	movi	r2,1
81106ecc:	e0bfff15 	stw	r2,-4(fp)
81106ed0:	00000106 	br	81106ed8 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106ed4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106ed8:	e0bfff17 	ldw	r2,-4(fp)
}
81106edc:	e037883a 	mov	sp,fp
81106ee0:	dfc00117 	ldw	ra,4(sp)
81106ee4:	df000017 	ldw	fp,0(sp)
81106ee8:	dec00204 	addi	sp,sp,8
81106eec:	f800283a 	ret

81106ef0 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
81106ef0:	defffd04 	addi	sp,sp,-12
81106ef4:	de00012e 	bgeu	sp,et,81106efc <bRmapCh6IrqFlagWriteCmd+0xc>
81106ef8:	003b68fa 	trap	3
81106efc:	dfc00215 	stw	ra,8(sp)
81106f00:	df000115 	stw	fp,4(sp)
81106f04:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106f08:	01400484 	movi	r5,18
81106f0c:	01204834 	movhi	r4,33056
81106f10:	21060004 	addi	r4,r4,6144
81106f14:	11096340 	call	81109634 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106f18:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106f1c:	10000326 	beq	r2,zero,81106f2c <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106f20:	00800044 	movi	r2,1
81106f24:	e0bfff15 	stw	r2,-4(fp)
81106f28:	00000106 	br	81106f30 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106f2c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106f30:	e0bfff17 	ldw	r2,-4(fp)
}
81106f34:	e037883a 	mov	sp,fp
81106f38:	dfc00117 	ldw	ra,4(sp)
81106f3c:	df000017 	ldw	fp,0(sp)
81106f40:	dec00204 	addi	sp,sp,8
81106f44:	f800283a 	ret

81106f48 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
81106f48:	defffd04 	addi	sp,sp,-12
81106f4c:	de00012e 	bgeu	sp,et,81106f54 <bRmapCh7IrqFlagWriteCmd+0xc>
81106f50:	003b68fa 	trap	3
81106f54:	dfc00215 	stw	ra,8(sp)
81106f58:	df000115 	stw	fp,4(sp)
81106f5c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106f60:	01400484 	movi	r5,18
81106f64:	01204834 	movhi	r4,33056
81106f68:	21050004 	addi	r4,r4,5120
81106f6c:	11096340 	call	81109634 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106f70:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106f74:	10000326 	beq	r2,zero,81106f84 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106f78:	00800044 	movi	r2,1
81106f7c:	e0bfff15 	stw	r2,-4(fp)
81106f80:	00000106 	br	81106f88 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106f84:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106f88:	e0bfff17 	ldw	r2,-4(fp)
}
81106f8c:	e037883a 	mov	sp,fp
81106f90:	dfc00117 	ldw	ra,4(sp)
81106f94:	df000017 	ldw	fp,0(sp)
81106f98:	dec00204 	addi	sp,sp,8
81106f9c:	f800283a 	ret

81106fa0 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81106fa0:	defffd04 	addi	sp,sp,-12
81106fa4:	de00012e 	bgeu	sp,et,81106fac <bRmapCh8IrqFlagWriteCmd+0xc>
81106fa8:	003b68fa 	trap	3
81106fac:	dfc00215 	stw	ra,8(sp)
81106fb0:	df000115 	stw	fp,4(sp)
81106fb4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106fb8:	01400484 	movi	r5,18
81106fbc:	01204834 	movhi	r4,33056
81106fc0:	21040004 	addi	r4,r4,4096
81106fc4:	11096340 	call	81109634 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106fc8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106fcc:	10000326 	beq	r2,zero,81106fdc <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106fd0:	00800044 	movi	r2,1
81106fd4:	e0bfff15 	stw	r2,-4(fp)
81106fd8:	00000106 	br	81106fe0 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106fdc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106fe0:	e0bfff17 	ldw	r2,-4(fp)
}
81106fe4:	e037883a 	mov	sp,fp
81106fe8:	dfc00117 	ldw	ra,4(sp)
81106fec:	df000017 	ldw	fp,0(sp)
81106ff0:	dec00204 	addi	sp,sp,8
81106ff4:	f800283a 	ret

81106ff8 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
81106ff8:	defffd04 	addi	sp,sp,-12
81106ffc:	de00012e 	bgeu	sp,et,81107004 <uliRmapCh1WriteCmdAddress+0xc>
81107000:	003b68fa 	trap	3
81107004:	dfc00215 	stw	ra,8(sp)
81107008:	df000115 	stw	fp,4(sp)
8110700c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107010:	01400184 	movi	r5,6
81107014:	01204834 	movhi	r4,33056
81107018:	210b0004 	addi	r4,r4,11264
8110701c:	11096340 	call	81109634 <uliRmapReadReg>
81107020:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107024:	e13fff17 	ldw	r4,-4(fp)
81107028:	11096840 	call	81109684 <uliConvRmapCfgAddr>
8110702c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107030:	e0bfff17 	ldw	r2,-4(fp)
}
81107034:	e037883a 	mov	sp,fp
81107038:	dfc00117 	ldw	ra,4(sp)
8110703c:	df000017 	ldw	fp,0(sp)
81107040:	dec00204 	addi	sp,sp,8
81107044:	f800283a 	ret

81107048 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
81107048:	defffd04 	addi	sp,sp,-12
8110704c:	de00012e 	bgeu	sp,et,81107054 <uliRmapCh2WriteCmdAddress+0xc>
81107050:	003b68fa 	trap	3
81107054:	dfc00215 	stw	ra,8(sp)
81107058:	df000115 	stw	fp,4(sp)
8110705c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107060:	01400184 	movi	r5,6
81107064:	01204834 	movhi	r4,33056
81107068:	210a0004 	addi	r4,r4,10240
8110706c:	11096340 	call	81109634 <uliRmapReadReg>
81107070:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107074:	e13fff17 	ldw	r4,-4(fp)
81107078:	11096840 	call	81109684 <uliConvRmapCfgAddr>
8110707c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107080:	e0bfff17 	ldw	r2,-4(fp)
}
81107084:	e037883a 	mov	sp,fp
81107088:	dfc00117 	ldw	ra,4(sp)
8110708c:	df000017 	ldw	fp,0(sp)
81107090:	dec00204 	addi	sp,sp,8
81107094:	f800283a 	ret

81107098 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107098:	defffd04 	addi	sp,sp,-12
8110709c:	de00012e 	bgeu	sp,et,811070a4 <uliRmapCh3WriteCmdAddress+0xc>
811070a0:	003b68fa 	trap	3
811070a4:	dfc00215 	stw	ra,8(sp)
811070a8:	df000115 	stw	fp,4(sp)
811070ac:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811070b0:	01400184 	movi	r5,6
811070b4:	01204834 	movhi	r4,33056
811070b8:	21090004 	addi	r4,r4,9216
811070bc:	11096340 	call	81109634 <uliRmapReadReg>
811070c0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811070c4:	e13fff17 	ldw	r4,-4(fp)
811070c8:	11096840 	call	81109684 <uliConvRmapCfgAddr>
811070cc:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811070d0:	e0bfff17 	ldw	r2,-4(fp)
}
811070d4:	e037883a 	mov	sp,fp
811070d8:	dfc00117 	ldw	ra,4(sp)
811070dc:	df000017 	ldw	fp,0(sp)
811070e0:	dec00204 	addi	sp,sp,8
811070e4:	f800283a 	ret

811070e8 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
811070e8:	defffd04 	addi	sp,sp,-12
811070ec:	de00012e 	bgeu	sp,et,811070f4 <uliRmapCh4WriteCmdAddress+0xc>
811070f0:	003b68fa 	trap	3
811070f4:	dfc00215 	stw	ra,8(sp)
811070f8:	df000115 	stw	fp,4(sp)
811070fc:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107100:	01400184 	movi	r5,6
81107104:	01204834 	movhi	r4,33056
81107108:	21080004 	addi	r4,r4,8192
8110710c:	11096340 	call	81109634 <uliRmapReadReg>
81107110:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107114:	e13fff17 	ldw	r4,-4(fp)
81107118:	11096840 	call	81109684 <uliConvRmapCfgAddr>
8110711c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107120:	e0bfff17 	ldw	r2,-4(fp)
}
81107124:	e037883a 	mov	sp,fp
81107128:	dfc00117 	ldw	ra,4(sp)
8110712c:	df000017 	ldw	fp,0(sp)
81107130:	dec00204 	addi	sp,sp,8
81107134:	f800283a 	ret

81107138 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
81107138:	defffd04 	addi	sp,sp,-12
8110713c:	de00012e 	bgeu	sp,et,81107144 <uliRmapCh5WriteCmdAddress+0xc>
81107140:	003b68fa 	trap	3
81107144:	dfc00215 	stw	ra,8(sp)
81107148:	df000115 	stw	fp,4(sp)
8110714c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107150:	01400184 	movi	r5,6
81107154:	01204834 	movhi	r4,33056
81107158:	21070004 	addi	r4,r4,7168
8110715c:	11096340 	call	81109634 <uliRmapReadReg>
81107160:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107164:	e13fff17 	ldw	r4,-4(fp)
81107168:	11096840 	call	81109684 <uliConvRmapCfgAddr>
8110716c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107170:	e0bfff17 	ldw	r2,-4(fp)
}
81107174:	e037883a 	mov	sp,fp
81107178:	dfc00117 	ldw	ra,4(sp)
8110717c:	df000017 	ldw	fp,0(sp)
81107180:	dec00204 	addi	sp,sp,8
81107184:	f800283a 	ret

81107188 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107188:	defffd04 	addi	sp,sp,-12
8110718c:	de00012e 	bgeu	sp,et,81107194 <uliRmapCh6WriteCmdAddress+0xc>
81107190:	003b68fa 	trap	3
81107194:	dfc00215 	stw	ra,8(sp)
81107198:	df000115 	stw	fp,4(sp)
8110719c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811071a0:	01400184 	movi	r5,6
811071a4:	01204834 	movhi	r4,33056
811071a8:	21060004 	addi	r4,r4,6144
811071ac:	11096340 	call	81109634 <uliRmapReadReg>
811071b0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811071b4:	e13fff17 	ldw	r4,-4(fp)
811071b8:	11096840 	call	81109684 <uliConvRmapCfgAddr>
811071bc:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811071c0:	e0bfff17 	ldw	r2,-4(fp)
}
811071c4:	e037883a 	mov	sp,fp
811071c8:	dfc00117 	ldw	ra,4(sp)
811071cc:	df000017 	ldw	fp,0(sp)
811071d0:	dec00204 	addi	sp,sp,8
811071d4:	f800283a 	ret

811071d8 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
811071d8:	defffd04 	addi	sp,sp,-12
811071dc:	de00012e 	bgeu	sp,et,811071e4 <uliRmapCh7WriteCmdAddress+0xc>
811071e0:	003b68fa 	trap	3
811071e4:	dfc00215 	stw	ra,8(sp)
811071e8:	df000115 	stw	fp,4(sp)
811071ec:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811071f0:	01400184 	movi	r5,6
811071f4:	01204834 	movhi	r4,33056
811071f8:	21050004 	addi	r4,r4,5120
811071fc:	11096340 	call	81109634 <uliRmapReadReg>
81107200:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107204:	e13fff17 	ldw	r4,-4(fp)
81107208:	11096840 	call	81109684 <uliConvRmapCfgAddr>
8110720c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107210:	e0bfff17 	ldw	r2,-4(fp)
}
81107214:	e037883a 	mov	sp,fp
81107218:	dfc00117 	ldw	ra,4(sp)
8110721c:	df000017 	ldw	fp,0(sp)
81107220:	dec00204 	addi	sp,sp,8
81107224:	f800283a 	ret

81107228 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81107228:	defffd04 	addi	sp,sp,-12
8110722c:	de00012e 	bgeu	sp,et,81107234 <uliRmapCh8WriteCmdAddress+0xc>
81107230:	003b68fa 	trap	3
81107234:	dfc00215 	stw	ra,8(sp)
81107238:	df000115 	stw	fp,4(sp)
8110723c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107240:	01400184 	movi	r5,6
81107244:	01204834 	movhi	r4,33056
81107248:	21040004 	addi	r4,r4,4096
8110724c:	11096340 	call	81109634 <uliRmapReadReg>
81107250:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107254:	e13fff17 	ldw	r4,-4(fp)
81107258:	11096840 	call	81109684 <uliConvRmapCfgAddr>
8110725c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107260:	e0bfff17 	ldw	r2,-4(fp)
}
81107264:	e037883a 	mov	sp,fp
81107268:	dfc00117 	ldw	ra,4(sp)
8110726c:	df000017 	ldw	fp,0(sp)
81107270:	dec00204 	addi	sp,sp,8
81107274:	f800283a 	ret

81107278 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81107278:	defffc04 	addi	sp,sp,-16
8110727c:	de00012e 	bgeu	sp,et,81107284 <vRmapInitIrq+0xc>
81107280:	003b68fa 	trap	3
81107284:	dfc00315 	stw	ra,12(sp)
81107288:	df000215 	stw	fp,8(sp)
8110728c:	df000204 	addi	fp,sp,8
81107290:	2005883a 	mov	r2,r4
81107294:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107298:	e0bfff03 	ldbu	r2,-4(fp)
8110729c:	10c00228 	cmpgeui	r3,r2,8
811072a0:	18004e1e 	bne	r3,zero,811073dc <vRmapInitIrq+0x164>
811072a4:	100690ba 	slli	r3,r2,2
811072a8:	00a04434 	movhi	r2,33040
811072ac:	109caf04 	addi	r2,r2,29372
811072b0:	1885883a 	add	r2,r3,r2
811072b4:	10800017 	ldw	r2,0(r2)
811072b8:	1000683a 	jmp	r2
811072bc:	811072dc 	xori	r4,r16,16843
811072c0:	811072fc 	xorhi	r4,r16,16843
811072c4:	8110731c 	xori	r4,r16,16844
811072c8:	8110733c 	xorhi	r4,r16,16844
811072cc:	8110735c 	xori	r4,r16,16845
811072d0:	8110737c 	xorhi	r4,r16,16845
811072d4:	8110739c 	xori	r4,r16,16846
811072d8:	811073bc 	xorhi	r4,r16,16846
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811072dc:	d0a04804 	addi	r2,gp,-32480
811072e0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
811072e4:	01a04434 	movhi	r6,33040
811072e8:	319a0c04 	addi	r6,r6,26672
811072ec:	e17ffe17 	ldw	r5,-8(fp)
811072f0:	010005c4 	movi	r4,23
811072f4:	113321c0 	call	8113321c <alt_irq_register>
		break;
811072f8:	00003806 	br	811073dc <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811072fc:	d0a04904 	addi	r2,gp,-32476
81107300:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
81107304:	01a04434 	movhi	r6,33040
81107308:	319a5604 	addi	r6,r6,26968
8110730c:	e17ffe17 	ldw	r5,-8(fp)
81107310:	01000544 	movi	r4,21
81107314:	113321c0 	call	8113321c <alt_irq_register>
		break;
81107318:	00003006 	br	811073dc <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
8110731c:	d0a04a04 	addi	r2,gp,-32472
81107320:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
81107324:	01a04434 	movhi	r6,33040
81107328:	319a6604 	addi	r6,r6,27032
8110732c:	e17ffe17 	ldw	r5,-8(fp)
81107330:	010004c4 	movi	r4,19
81107334:	113321c0 	call	8113321c <alt_irq_register>
		break;
81107338:	00002806 	br	811073dc <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
8110733c:	d0a04b04 	addi	r2,gp,-32468
81107340:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81107344:	01a04434 	movhi	r6,33040
81107348:	319a7604 	addi	r6,r6,27096
8110734c:	e17ffe17 	ldw	r5,-8(fp)
81107350:	01000444 	movi	r4,17
81107354:	113321c0 	call	8113321c <alt_irq_register>
		break;
81107358:	00002006 	br	811073dc <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
8110735c:	d0a04c04 	addi	r2,gp,-32464
81107360:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81107364:	01a04434 	movhi	r6,33040
81107368:	319a8604 	addi	r6,r6,27160
8110736c:	e17ffe17 	ldw	r5,-8(fp)
81107370:	01000244 	movi	r4,9
81107374:	113321c0 	call	8113321c <alt_irq_register>
		break;
81107378:	00001806 	br	811073dc <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
8110737c:	d0a04d04 	addi	r2,gp,-32460
81107380:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81107384:	01a04434 	movhi	r6,33040
81107388:	319a9604 	addi	r6,r6,27224
8110738c:	e17ffe17 	ldw	r5,-8(fp)
81107390:	010001c4 	movi	r4,7
81107394:	113321c0 	call	8113321c <alt_irq_register>
		break;
81107398:	00001006 	br	811073dc <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
8110739c:	d0a04e04 	addi	r2,gp,-32456
811073a0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
811073a4:	01a04434 	movhi	r6,33040
811073a8:	319aa604 	addi	r6,r6,27288
811073ac:	e17ffe17 	ldw	r5,-8(fp)
811073b0:	01000104 	movi	r4,4
811073b4:	113321c0 	call	8113321c <alt_irq_register>
		break;
811073b8:	00000806 	br	811073dc <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
811073bc:	d0a04f04 	addi	r2,gp,-32452
811073c0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
811073c4:	01a04434 	movhi	r6,33040
811073c8:	319ab604 	addi	r6,r6,27352
811073cc:	e17ffe17 	ldw	r5,-8(fp)
811073d0:	010000c4 	movi	r4,3
811073d4:	113321c0 	call	8113321c <alt_irq_register>
		break;
811073d8:	0001883a 	nop
	}
}
811073dc:	0001883a 	nop
811073e0:	e037883a 	mov	sp,fp
811073e4:	dfc00117 	ldw	ra,4(sp)
811073e8:	df000017 	ldw	fp,0(sp)
811073ec:	dec00204 	addi	sp,sp,8
811073f0:	f800283a 	ret

811073f4 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
811073f4:	defffb04 	addi	sp,sp,-20
811073f8:	de00012e 	bgeu	sp,et,81107400 <bRmapSetIrqControl+0xc>
811073fc:	003b68fa 	trap	3
81107400:	dfc00415 	stw	ra,16(sp)
81107404:	df000315 	stw	fp,12(sp)
81107408:	df000304 	addi	fp,sp,12
8110740c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107410:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107414:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107418:	e0bfff17 	ldw	r2,-4(fp)
8110741c:	10001926 	beq	r2,zero,81107484 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107420:	e0bfff17 	ldw	r2,-4(fp)
81107424:	10800017 	ldw	r2,0(r2)
81107428:	01400444 	movi	r5,17
8110742c:	1009883a 	mov	r4,r2
81107430:	11096340 	call	81109634 <uliRmapReadReg>
81107434:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81107438:	e0bfff17 	ldw	r2,-4(fp)
8110743c:	10801017 	ldw	r2,64(r2)
81107440:	10000426 	beq	r2,zero,81107454 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81107444:	e0bffe17 	ldw	r2,-8(fp)
81107448:	10800054 	ori	r2,r2,1
8110744c:	e0bffe15 	stw	r2,-8(fp)
81107450:	00000406 	br	81107464 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81107454:	e0fffe17 	ldw	r3,-8(fp)
81107458:	00bfff84 	movi	r2,-2
8110745c:	1884703a 	and	r2,r3,r2
81107460:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81107464:	e0bfff17 	ldw	r2,-4(fp)
81107468:	10800017 	ldw	r2,0(r2)
8110746c:	e1bffe17 	ldw	r6,-8(fp)
81107470:	01400444 	movi	r5,17
81107474:	1009883a 	mov	r4,r2
81107478:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
8110747c:	00800044 	movi	r2,1
81107480:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107484:	e0bffd17 	ldw	r2,-12(fp)
}
81107488:	e037883a 	mov	sp,fp
8110748c:	dfc00117 	ldw	ra,4(sp)
81107490:	df000017 	ldw	fp,0(sp)
81107494:	dec00204 	addi	sp,sp,8
81107498:	f800283a 	ret

8110749c <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
8110749c:	defffb04 	addi	sp,sp,-20
811074a0:	de00012e 	bgeu	sp,et,811074a8 <bRmapGetIrqControl+0xc>
811074a4:	003b68fa 	trap	3
811074a8:	dfc00415 	stw	ra,16(sp)
811074ac:	df000315 	stw	fp,12(sp)
811074b0:	df000304 	addi	fp,sp,12
811074b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811074b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811074bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811074c0:	e0bfff17 	ldw	r2,-4(fp)
811074c4:	10001126 	beq	r2,zero,8110750c <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811074c8:	e0bfff17 	ldw	r2,-4(fp)
811074cc:	10800017 	ldw	r2,0(r2)
811074d0:	01400444 	movi	r5,17
811074d4:	1009883a 	mov	r4,r2
811074d8:	11096340 	call	81109634 <uliRmapReadReg>
811074dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
811074e0:	e0bffe17 	ldw	r2,-8(fp)
811074e4:	1080004c 	andi	r2,r2,1
811074e8:	10000426 	beq	r2,zero,811074fc <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811074ec:	e0bfff17 	ldw	r2,-4(fp)
811074f0:	00c00044 	movi	r3,1
811074f4:	10c01015 	stw	r3,64(r2)
811074f8:	00000206 	br	81107504 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811074fc:	e0bfff17 	ldw	r2,-4(fp)
81107500:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
81107504:	00800044 	movi	r2,1
81107508:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110750c:	e0bffd17 	ldw	r2,-12(fp)
}
81107510:	e037883a 	mov	sp,fp
81107514:	dfc00117 	ldw	ra,4(sp)
81107518:	df000017 	ldw	fp,0(sp)
8110751c:	dec00204 	addi	sp,sp,8
81107520:	f800283a 	ret

81107524 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81107524:	defffb04 	addi	sp,sp,-20
81107528:	de00012e 	bgeu	sp,et,81107530 <bRmapGetIrqFlags+0xc>
8110752c:	003b68fa 	trap	3
81107530:	dfc00415 	stw	ra,16(sp)
81107534:	df000315 	stw	fp,12(sp)
81107538:	df000304 	addi	fp,sp,12
8110753c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107540:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107544:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107548:	e0bfff17 	ldw	r2,-4(fp)
8110754c:	10001126 	beq	r2,zero,81107594 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107550:	e0bfff17 	ldw	r2,-4(fp)
81107554:	10800017 	ldw	r2,0(r2)
81107558:	01400484 	movi	r5,18
8110755c:	1009883a 	mov	r4,r2
81107560:	11096340 	call	81109634 <uliRmapReadReg>
81107564:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107568:	e0bffe17 	ldw	r2,-8(fp)
8110756c:	1080004c 	andi	r2,r2,1
81107570:	10000426 	beq	r2,zero,81107584 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81107574:	e0bfff17 	ldw	r2,-4(fp)
81107578:	00c00044 	movi	r3,1
8110757c:	10c01115 	stw	r3,68(r2)
81107580:	00000206 	br	8110758c <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81107584:	e0bfff17 	ldw	r2,-4(fp)
81107588:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
8110758c:	00800044 	movi	r2,1
81107590:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107594:	e0bffd17 	ldw	r2,-12(fp)
}
81107598:	e037883a 	mov	sp,fp
8110759c:	dfc00117 	ldw	ra,4(sp)
811075a0:	df000017 	ldw	fp,0(sp)
811075a4:	dec00204 	addi	sp,sp,8
811075a8:	f800283a 	ret

811075ac <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
811075ac:	defffb04 	addi	sp,sp,-20
811075b0:	de00012e 	bgeu	sp,et,811075b8 <bRmapSetCodecConfig+0xc>
811075b4:	003b68fa 	trap	3
811075b8:	dfc00415 	stw	ra,16(sp)
811075bc:	df000315 	stw	fp,12(sp)
811075c0:	df000304 	addi	fp,sp,12
811075c4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811075c8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811075cc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811075d0:	e0bfff17 	ldw	r2,-4(fp)
811075d4:	10002526 	beq	r2,zero,8110766c <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075d8:	e0bfff17 	ldw	r2,-4(fp)
811075dc:	10800017 	ldw	r2,0(r2)
811075e0:	01400104 	movi	r5,4
811075e4:	1009883a 	mov	r4,r2
811075e8:	11096340 	call	81109634 <uliRmapReadReg>
811075ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
811075f0:	e0fffe17 	ldw	r3,-8(fp)
811075f4:	00bfc004 	movi	r2,-256
811075f8:	1884703a 	and	r2,r3,r2
811075fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81107600:	e0bfff17 	ldw	r2,-4(fp)
81107604:	10800143 	ldbu	r2,5(r2)
81107608:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
8110760c:	e0fffe17 	ldw	r3,-8(fp)
81107610:	1884b03a 	or	r2,r3,r2
81107614:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81107618:	e0fffe17 	ldw	r3,-8(fp)
8110761c:	00bffff4 	movhi	r2,65535
81107620:	10803fc4 	addi	r2,r2,255
81107624:	1884703a 	and	r2,r3,r2
81107628:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
8110762c:	e0bfff17 	ldw	r2,-4(fp)
81107630:	10800103 	ldbu	r2,4(r2)
81107634:	10803fcc 	andi	r2,r2,255
81107638:	1004923a 	slli	r2,r2,8
8110763c:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81107640:	e0fffe17 	ldw	r3,-8(fp)
81107644:	1884b03a 	or	r2,r3,r2
81107648:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
8110764c:	e0bfff17 	ldw	r2,-4(fp)
81107650:	10800017 	ldw	r2,0(r2)
81107654:	e1bffe17 	ldw	r6,-8(fp)
81107658:	01400104 	movi	r5,4
8110765c:	1009883a 	mov	r4,r2
81107660:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107664:	00800044 	movi	r2,1
81107668:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110766c:	e0bffd17 	ldw	r2,-12(fp)
}
81107670:	e037883a 	mov	sp,fp
81107674:	dfc00117 	ldw	ra,4(sp)
81107678:	df000017 	ldw	fp,0(sp)
8110767c:	dec00204 	addi	sp,sp,8
81107680:	f800283a 	ret

81107684 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107684:	defffb04 	addi	sp,sp,-20
81107688:	de00012e 	bgeu	sp,et,81107690 <bRmapGetCodecConfig+0xc>
8110768c:	003b68fa 	trap	3
81107690:	dfc00415 	stw	ra,16(sp)
81107694:	df000315 	stw	fp,12(sp)
81107698:	df000304 	addi	fp,sp,12
8110769c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811076a0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811076a4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811076a8:	e0bfff17 	ldw	r2,-4(fp)
811076ac:	10001226 	beq	r2,zero,811076f8 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076b0:	e0bfff17 	ldw	r2,-4(fp)
811076b4:	10800017 	ldw	r2,0(r2)
811076b8:	01400104 	movi	r5,4
811076bc:	1009883a 	mov	r4,r2
811076c0:	11096340 	call	81109634 <uliRmapReadReg>
811076c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
811076c8:	e0bffe17 	ldw	r2,-8(fp)
811076cc:	1007883a 	mov	r3,r2
811076d0:	e0bfff17 	ldw	r2,-4(fp)
811076d4:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
811076d8:	e0bffe17 	ldw	r2,-8(fp)
811076dc:	10bfc00c 	andi	r2,r2,65280
811076e0:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
811076e4:	1007883a 	mov	r3,r2
811076e8:	e0bfff17 	ldw	r2,-4(fp)
811076ec:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
811076f0:	00800044 	movi	r2,1
811076f4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811076f8:	e0bffd17 	ldw	r2,-12(fp)
}
811076fc:	e037883a 	mov	sp,fp
81107700:	dfc00117 	ldw	ra,4(sp)
81107704:	df000017 	ldw	fp,0(sp)
81107708:	dec00204 	addi	sp,sp,8
8110770c:	f800283a 	ret

81107710 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81107710:	defffb04 	addi	sp,sp,-20
81107714:	de00012e 	bgeu	sp,et,8110771c <bRmapGetCodecStatus+0xc>
81107718:	003b68fa 	trap	3
8110771c:	dfc00415 	stw	ra,16(sp)
81107720:	df000315 	stw	fp,12(sp)
81107724:	df000304 	addi	fp,sp,12
81107728:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110772c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107730:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107734:	e0bfff17 	ldw	r2,-4(fp)
81107738:	10004726 	beq	r2,zero,81107858 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110773c:	e0bfff17 	ldw	r2,-4(fp)
81107740:	10800017 	ldw	r2,0(r2)
81107744:	01400144 	movi	r5,5
81107748:	1009883a 	mov	r4,r2
8110774c:	11096340 	call	81109634 <uliRmapReadReg>
81107750:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81107754:	e0bffe17 	ldw	r2,-8(fp)
81107758:	1080004c 	andi	r2,r2,1
8110775c:	10000426 	beq	r2,zero,81107770 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107760:	e0bfff17 	ldw	r2,-4(fp)
81107764:	00c00044 	movi	r3,1
81107768:	10c00215 	stw	r3,8(r2)
8110776c:	00000206 	br	81107778 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107770:	e0bfff17 	ldw	r2,-4(fp)
81107774:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81107778:	e0bffe17 	ldw	r2,-8(fp)
8110777c:	1080008c 	andi	r2,r2,2
81107780:	10000426 	beq	r2,zero,81107794 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107784:	e0bfff17 	ldw	r2,-4(fp)
81107788:	00c00044 	movi	r3,1
8110778c:	10c00315 	stw	r3,12(r2)
81107790:	00000206 	br	8110779c <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107794:	e0bfff17 	ldw	r2,-4(fp)
81107798:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
8110779c:	e0bffe17 	ldw	r2,-8(fp)
811077a0:	1080010c 	andi	r2,r2,4
811077a4:	10000426 	beq	r2,zero,811077b8 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
811077a8:	e0bfff17 	ldw	r2,-4(fp)
811077ac:	00c00044 	movi	r3,1
811077b0:	10c00415 	stw	r3,16(r2)
811077b4:	00000206 	br	811077c0 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
811077b8:	e0bfff17 	ldw	r2,-4(fp)
811077bc:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
811077c0:	e0bffe17 	ldw	r2,-8(fp)
811077c4:	1080020c 	andi	r2,r2,8
811077c8:	10000426 	beq	r2,zero,811077dc <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
811077cc:	e0bfff17 	ldw	r2,-4(fp)
811077d0:	00c00044 	movi	r3,1
811077d4:	10c00515 	stw	r3,20(r2)
811077d8:	00000206 	br	811077e4 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
811077dc:	e0bfff17 	ldw	r2,-4(fp)
811077e0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
811077e4:	e0bffe17 	ldw	r2,-8(fp)
811077e8:	1080040c 	andi	r2,r2,16
811077ec:	10000426 	beq	r2,zero,81107800 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
811077f0:	e0bfff17 	ldw	r2,-4(fp)
811077f4:	00c00044 	movi	r3,1
811077f8:	10c00615 	stw	r3,24(r2)
811077fc:	00000206 	br	81107808 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107800:	e0bfff17 	ldw	r2,-4(fp)
81107804:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81107808:	e0bffe17 	ldw	r2,-8(fp)
8110780c:	1080080c 	andi	r2,r2,32
81107810:	10000426 	beq	r2,zero,81107824 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107814:	e0bfff17 	ldw	r2,-4(fp)
81107818:	00c00044 	movi	r3,1
8110781c:	10c00715 	stw	r3,28(r2)
81107820:	00000206 	br	8110782c <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107824:	e0bfff17 	ldw	r2,-4(fp)
81107828:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
8110782c:	e0bffe17 	ldw	r2,-8(fp)
81107830:	1080100c 	andi	r2,r2,64
81107834:	10000426 	beq	r2,zero,81107848 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81107838:	e0bfff17 	ldw	r2,-4(fp)
8110783c:	00c00044 	movi	r3,1
81107840:	10c00815 	stw	r3,32(r2)
81107844:	00000206 	br	81107850 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107848:	e0bfff17 	ldw	r2,-4(fp)
8110784c:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107850:	00800044 	movi	r2,1
81107854:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107858:	e0bffd17 	ldw	r2,-12(fp)
}
8110785c:	e037883a 	mov	sp,fp
81107860:	dfc00117 	ldw	ra,4(sp)
81107864:	df000017 	ldw	fp,0(sp)
81107868:	dec00204 	addi	sp,sp,8
8110786c:	f800283a 	ret

81107870 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107870:	defffb04 	addi	sp,sp,-20
81107874:	de00012e 	bgeu	sp,et,8110787c <bRmapGetCodecError+0xc>
81107878:	003b68fa 	trap	3
8110787c:	dfc00415 	stw	ra,16(sp)
81107880:	df000315 	stw	fp,12(sp)
81107884:	df000304 	addi	fp,sp,12
81107888:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110788c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107890:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107894:	e0bfff17 	ldw	r2,-4(fp)
81107898:	10004726 	beq	r2,zero,811079b8 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110789c:	e0bfff17 	ldw	r2,-4(fp)
811078a0:	10800017 	ldw	r2,0(r2)
811078a4:	01400144 	movi	r5,5
811078a8:	1009883a 	mov	r4,r2
811078ac:	11096340 	call	81109634 <uliRmapReadReg>
811078b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
811078b4:	e0bffe17 	ldw	r2,-8(fp)
811078b8:	1080006c 	andhi	r2,r2,1
811078bc:	10000426 	beq	r2,zero,811078d0 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
811078c0:	e0bfff17 	ldw	r2,-4(fp)
811078c4:	00c00044 	movi	r3,1
811078c8:	10c00915 	stw	r3,36(r2)
811078cc:	00000206 	br	811078d8 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
811078d0:	e0bfff17 	ldw	r2,-4(fp)
811078d4:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
811078d8:	e0bffe17 	ldw	r2,-8(fp)
811078dc:	108000ac 	andhi	r2,r2,2
811078e0:	10000426 	beq	r2,zero,811078f4 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
811078e4:	e0bfff17 	ldw	r2,-4(fp)
811078e8:	00c00044 	movi	r3,1
811078ec:	10c00a15 	stw	r3,40(r2)
811078f0:	00000206 	br	811078fc <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
811078f4:	e0bfff17 	ldw	r2,-4(fp)
811078f8:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
811078fc:	e0bffe17 	ldw	r2,-8(fp)
81107900:	1080012c 	andhi	r2,r2,4
81107904:	10000426 	beq	r2,zero,81107918 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81107908:	e0bfff17 	ldw	r2,-4(fp)
8110790c:	00c00044 	movi	r3,1
81107910:	10c00b15 	stw	r3,44(r2)
81107914:	00000206 	br	81107920 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81107918:	e0bfff17 	ldw	r2,-4(fp)
8110791c:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107920:	e0bffe17 	ldw	r2,-8(fp)
81107924:	1080022c 	andhi	r2,r2,8
81107928:	10000426 	beq	r2,zero,8110793c <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
8110792c:	e0bfff17 	ldw	r2,-4(fp)
81107930:	00c00044 	movi	r3,1
81107934:	10c00c15 	stw	r3,48(r2)
81107938:	00000206 	br	81107944 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
8110793c:	e0bfff17 	ldw	r2,-4(fp)
81107940:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107944:	e0bffe17 	ldw	r2,-8(fp)
81107948:	1080042c 	andhi	r2,r2,16
8110794c:	10000426 	beq	r2,zero,81107960 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107950:	e0bfff17 	ldw	r2,-4(fp)
81107954:	00c00044 	movi	r3,1
81107958:	10c00d15 	stw	r3,52(r2)
8110795c:	00000206 	br	81107968 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107960:	e0bfff17 	ldw	r2,-4(fp)
81107964:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81107968:	e0bffe17 	ldw	r2,-8(fp)
8110796c:	1080082c 	andhi	r2,r2,32
81107970:	10000426 	beq	r2,zero,81107984 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81107974:	e0bfff17 	ldw	r2,-4(fp)
81107978:	00c00044 	movi	r3,1
8110797c:	10c00e15 	stw	r3,56(r2)
81107980:	00000206 	br	8110798c <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81107984:	e0bfff17 	ldw	r2,-4(fp)
81107988:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
8110798c:	e0bffe17 	ldw	r2,-8(fp)
81107990:	1080102c 	andhi	r2,r2,64
81107994:	10000426 	beq	r2,zero,811079a8 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81107998:	e0bfff17 	ldw	r2,-4(fp)
8110799c:	00c00044 	movi	r3,1
811079a0:	10c00f15 	stw	r3,60(r2)
811079a4:	00000206 	br	811079b0 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
811079a8:	e0bfff17 	ldw	r2,-4(fp)
811079ac:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
811079b0:	00800044 	movi	r2,1
811079b4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811079b8:	e0bffd17 	ldw	r2,-12(fp)
}
811079bc:	e037883a 	mov	sp,fp
811079c0:	dfc00117 	ldw	ra,4(sp)
811079c4:	df000017 	ldw	fp,0(sp)
811079c8:	dec00204 	addi	sp,sp,8
811079cc:	f800283a 	ret

811079d0 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
811079d0:	defffb04 	addi	sp,sp,-20
811079d4:	de00012e 	bgeu	sp,et,811079dc <bRmapSetMemConfigArea+0xc>
811079d8:	003b68fa 	trap	3
811079dc:	dfc00415 	stw	ra,16(sp)
811079e0:	df000315 	stw	fp,12(sp)
811079e4:	df000304 	addi	fp,sp,12
811079e8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811079ec:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811079f0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811079f4:	e0bfff17 	ldw	r2,-4(fp)
811079f8:	1000aa26 	beq	r2,zero,81107ca4 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
811079fc:	e0bfff17 	ldw	r2,-4(fp)
81107a00:	10801217 	ldw	r2,72(r2)
81107a04:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107a08:	e0bfff17 	ldw	r2,-4(fp)
81107a0c:	10800017 	ldw	r2,0(r2)
81107a10:	e1bffe17 	ldw	r6,-8(fp)
81107a14:	01401004 	movi	r5,64
81107a18:	1009883a 	mov	r4,r2
81107a1c:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107a20:	e0bfff17 	ldw	r2,-4(fp)
81107a24:	10801317 	ldw	r2,76(r2)
81107a28:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107a2c:	e0bfff17 	ldw	r2,-4(fp)
81107a30:	10800017 	ldw	r2,0(r2)
81107a34:	e1bffe17 	ldw	r6,-8(fp)
81107a38:	01401044 	movi	r5,65
81107a3c:	1009883a 	mov	r4,r2
81107a40:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81107a44:	e0bfff17 	ldw	r2,-4(fp)
81107a48:	10801417 	ldw	r2,80(r2)
81107a4c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107a50:	e0bfff17 	ldw	r2,-4(fp)
81107a54:	10800017 	ldw	r2,0(r2)
81107a58:	e1bffe17 	ldw	r6,-8(fp)
81107a5c:	01401084 	movi	r5,66
81107a60:	1009883a 	mov	r4,r2
81107a64:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81107a68:	e0bfff17 	ldw	r2,-4(fp)
81107a6c:	10801517 	ldw	r2,84(r2)
81107a70:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107a74:	e0bfff17 	ldw	r2,-4(fp)
81107a78:	10800017 	ldw	r2,0(r2)
81107a7c:	e1bffe17 	ldw	r6,-8(fp)
81107a80:	014010c4 	movi	r5,67
81107a84:	1009883a 	mov	r4,r2
81107a88:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107a8c:	e0bfff17 	ldw	r2,-4(fp)
81107a90:	10802217 	ldw	r2,136(r2)
81107a94:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107a98:	e0bfff17 	ldw	r2,-4(fp)
81107a9c:	10800017 	ldw	r2,0(r2)
81107aa0:	e1bffe17 	ldw	r6,-8(fp)
81107aa4:	01401104 	movi	r5,68
81107aa8:	1009883a 	mov	r4,r2
81107aac:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81107ab0:	e0bfff17 	ldw	r2,-4(fp)
81107ab4:	10801717 	ldw	r2,92(r2)
81107ab8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107abc:	e0bfff17 	ldw	r2,-4(fp)
81107ac0:	10800017 	ldw	r2,0(r2)
81107ac4:	e1bffe17 	ldw	r6,-8(fp)
81107ac8:	01401144 	movi	r5,69
81107acc:	1009883a 	mov	r4,r2
81107ad0:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107ad4:	e0bfff17 	ldw	r2,-4(fp)
81107ad8:	10801817 	ldw	r2,96(r2)
81107adc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107ae0:	e0bfff17 	ldw	r2,-4(fp)
81107ae4:	10800017 	ldw	r2,0(r2)
81107ae8:	e1bffe17 	ldw	r6,-8(fp)
81107aec:	01401184 	movi	r5,70
81107af0:	1009883a 	mov	r4,r2
81107af4:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81107af8:	e0bfff17 	ldw	r2,-4(fp)
81107afc:	10801917 	ldw	r2,100(r2)
81107b00:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107b04:	e0bfff17 	ldw	r2,-4(fp)
81107b08:	10800017 	ldw	r2,0(r2)
81107b0c:	e1bffe17 	ldw	r6,-8(fp)
81107b10:	014011c4 	movi	r5,71
81107b14:	1009883a 	mov	r4,r2
81107b18:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107b1c:	e0bfff17 	ldw	r2,-4(fp)
81107b20:	10801a17 	ldw	r2,104(r2)
81107b24:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107b28:	e0bfff17 	ldw	r2,-4(fp)
81107b2c:	10800017 	ldw	r2,0(r2)
81107b30:	e1bffe17 	ldw	r6,-8(fp)
81107b34:	01401204 	movi	r5,72
81107b38:	1009883a 	mov	r4,r2
81107b3c:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81107b40:	e0bfff17 	ldw	r2,-4(fp)
81107b44:	10801b17 	ldw	r2,108(r2)
81107b48:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107b4c:	e0bfff17 	ldw	r2,-4(fp)
81107b50:	10800017 	ldw	r2,0(r2)
81107b54:	e1bffe17 	ldw	r6,-8(fp)
81107b58:	01401244 	movi	r5,73
81107b5c:	1009883a 	mov	r4,r2
81107b60:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b64:	e0bfff17 	ldw	r2,-4(fp)
81107b68:	10800017 	ldw	r2,0(r2)
81107b6c:	01401284 	movi	r5,74
81107b70:	1009883a 	mov	r4,r2
81107b74:	11096340 	call	81109634 <uliRmapReadReg>
81107b78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81107b7c:	e0bfff17 	ldw	r2,-4(fp)
81107b80:	10801c17 	ldw	r2,112(r2)
81107b84:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107b88:	e0bfff17 	ldw	r2,-4(fp)
81107b8c:	10800017 	ldw	r2,0(r2)
81107b90:	e1bffe17 	ldw	r6,-8(fp)
81107b94:	01401284 	movi	r5,74
81107b98:	1009883a 	mov	r4,r2
81107b9c:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81107ba0:	e0bfff17 	ldw	r2,-4(fp)
81107ba4:	10801d17 	ldw	r2,116(r2)
81107ba8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107bac:	e0bfff17 	ldw	r2,-4(fp)
81107bb0:	10800017 	ldw	r2,0(r2)
81107bb4:	e1bffe17 	ldw	r6,-8(fp)
81107bb8:	014012c4 	movi	r5,75
81107bbc:	1009883a 	mov	r4,r2
81107bc0:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81107bc4:	e0bfff17 	ldw	r2,-4(fp)
81107bc8:	10801e17 	ldw	r2,120(r2)
81107bcc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81107bd0:	e0bfff17 	ldw	r2,-4(fp)
81107bd4:	10800017 	ldw	r2,0(r2)
81107bd8:	e1bffe17 	ldw	r6,-8(fp)
81107bdc:	01401304 	movi	r5,76
81107be0:	1009883a 	mov	r4,r2
81107be4:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81107be8:	e0bfff17 	ldw	r2,-4(fp)
81107bec:	10801f17 	ldw	r2,124(r2)
81107bf0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81107bf4:	e0bfff17 	ldw	r2,-4(fp)
81107bf8:	10800017 	ldw	r2,0(r2)
81107bfc:	e1bffe17 	ldw	r6,-8(fp)
81107c00:	01401344 	movi	r5,77
81107c04:	1009883a 	mov	r4,r2
81107c08:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81107c0c:	e0bfff17 	ldw	r2,-4(fp)
81107c10:	10802017 	ldw	r2,128(r2)
81107c14:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
81107c18:	e0bfff17 	ldw	r2,-4(fp)
81107c1c:	10800017 	ldw	r2,0(r2)
81107c20:	e1bffe17 	ldw	r6,-8(fp)
81107c24:	01401384 	movi	r5,78
81107c28:	1009883a 	mov	r4,r2
81107c2c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107c30:	e0bfff17 	ldw	r2,-4(fp)
81107c34:	10802217 	ldw	r2,136(r2)
81107c38:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107c3c:	e0bfff17 	ldw	r2,-4(fp)
81107c40:	10800017 	ldw	r2,0(r2)
81107c44:	e1bffe17 	ldw	r6,-8(fp)
81107c48:	014013c4 	movi	r5,79
81107c4c:	1009883a 	mov	r4,r2
81107c50:	11095e00 	call	811095e0 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107c54:	e0bfff17 	ldw	r2,-4(fp)
81107c58:	10802217 	ldw	r2,136(r2)
81107c5c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81107c60:	e0bfff17 	ldw	r2,-4(fp)
81107c64:	10800017 	ldw	r2,0(r2)
81107c68:	e1bffe17 	ldw	r6,-8(fp)
81107c6c:	01401404 	movi	r5,80
81107c70:	1009883a 	mov	r4,r2
81107c74:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
81107c78:	e0bfff17 	ldw	r2,-4(fp)
81107c7c:	10802317 	ldw	r2,140(r2)
81107c80:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
81107c84:	e0bfff17 	ldw	r2,-4(fp)
81107c88:	10800017 	ldw	r2,0(r2)
81107c8c:	e1bffe17 	ldw	r6,-8(fp)
81107c90:	01401444 	movi	r5,81
81107c94:	1009883a 	mov	r4,r2
81107c98:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107c9c:	00800044 	movi	r2,1
81107ca0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107ca4:	e0bffd17 	ldw	r2,-12(fp)
}
81107ca8:	e037883a 	mov	sp,fp
81107cac:	dfc00117 	ldw	ra,4(sp)
81107cb0:	df000017 	ldw	fp,0(sp)
81107cb4:	dec00204 	addi	sp,sp,8
81107cb8:	f800283a 	ret

81107cbc <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81107cbc:	defffb04 	addi	sp,sp,-20
81107cc0:	de00012e 	bgeu	sp,et,81107cc8 <bRmapGetMemConfigArea+0xc>
81107cc4:	003b68fa 	trap	3
81107cc8:	dfc00415 	stw	ra,16(sp)
81107ccc:	df000315 	stw	fp,12(sp)
81107cd0:	df000304 	addi	fp,sp,12
81107cd4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107cd8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107cdc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107ce0:	e0bfff17 	ldw	r2,-4(fp)
81107ce4:	1000a426 	beq	r2,zero,81107f78 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ce8:	e0bfff17 	ldw	r2,-4(fp)
81107cec:	10800017 	ldw	r2,0(r2)
81107cf0:	01401004 	movi	r5,64
81107cf4:	1009883a 	mov	r4,r2
81107cf8:	11096340 	call	81109634 <uliRmapReadReg>
81107cfc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
81107d00:	e0bfff17 	ldw	r2,-4(fp)
81107d04:	e0fffe17 	ldw	r3,-8(fp)
81107d08:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d0c:	e0bfff17 	ldw	r2,-4(fp)
81107d10:	10800017 	ldw	r2,0(r2)
81107d14:	01401044 	movi	r5,65
81107d18:	1009883a 	mov	r4,r2
81107d1c:	11096340 	call	81109634 <uliRmapReadReg>
81107d20:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
81107d24:	e0bfff17 	ldw	r2,-4(fp)
81107d28:	e0fffe17 	ldw	r3,-8(fp)
81107d2c:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d30:	e0bfff17 	ldw	r2,-4(fp)
81107d34:	10800017 	ldw	r2,0(r2)
81107d38:	01401084 	movi	r5,66
81107d3c:	1009883a 	mov	r4,r2
81107d40:	11096340 	call	81109634 <uliRmapReadReg>
81107d44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
81107d48:	e0bfff17 	ldw	r2,-4(fp)
81107d4c:	e0fffe17 	ldw	r3,-8(fp)
81107d50:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d54:	e0bfff17 	ldw	r2,-4(fp)
81107d58:	10800017 	ldw	r2,0(r2)
81107d5c:	014010c4 	movi	r5,67
81107d60:	1009883a 	mov	r4,r2
81107d64:	11096340 	call	81109634 <uliRmapReadReg>
81107d68:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
81107d6c:	e0bfff17 	ldw	r2,-4(fp)
81107d70:	e0fffe17 	ldw	r3,-8(fp)
81107d74:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d78:	e0bfff17 	ldw	r2,-4(fp)
81107d7c:	10800017 	ldw	r2,0(r2)
81107d80:	01401104 	movi	r5,68
81107d84:	1009883a 	mov	r4,r2
81107d88:	11096340 	call	81109634 <uliRmapReadReg>
81107d8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107d90:	e0bfff17 	ldw	r2,-4(fp)
81107d94:	e0fffe17 	ldw	r3,-8(fp)
81107d98:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d9c:	e0bfff17 	ldw	r2,-4(fp)
81107da0:	10800017 	ldw	r2,0(r2)
81107da4:	01401144 	movi	r5,69
81107da8:	1009883a 	mov	r4,r2
81107dac:	11096340 	call	81109634 <uliRmapReadReg>
81107db0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81107db4:	e0bfff17 	ldw	r2,-4(fp)
81107db8:	e0fffe17 	ldw	r3,-8(fp)
81107dbc:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107dc0:	e0bfff17 	ldw	r2,-4(fp)
81107dc4:	10800017 	ldw	r2,0(r2)
81107dc8:	01401184 	movi	r5,70
81107dcc:	1009883a 	mov	r4,r2
81107dd0:	11096340 	call	81109634 <uliRmapReadReg>
81107dd4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
81107dd8:	e0bfff17 	ldw	r2,-4(fp)
81107ddc:	e0fffe17 	ldw	r3,-8(fp)
81107de0:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107de4:	e0bfff17 	ldw	r2,-4(fp)
81107de8:	10800017 	ldw	r2,0(r2)
81107dec:	014011c4 	movi	r5,71
81107df0:	1009883a 	mov	r4,r2
81107df4:	11096340 	call	81109634 <uliRmapReadReg>
81107df8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
81107dfc:	e0bfff17 	ldw	r2,-4(fp)
81107e00:	e0fffe17 	ldw	r3,-8(fp)
81107e04:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e08:	e0bfff17 	ldw	r2,-4(fp)
81107e0c:	10800017 	ldw	r2,0(r2)
81107e10:	01401204 	movi	r5,72
81107e14:	1009883a 	mov	r4,r2
81107e18:	11096340 	call	81109634 <uliRmapReadReg>
81107e1c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
81107e20:	e0bfff17 	ldw	r2,-4(fp)
81107e24:	e0fffe17 	ldw	r3,-8(fp)
81107e28:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e2c:	e0bfff17 	ldw	r2,-4(fp)
81107e30:	10800017 	ldw	r2,0(r2)
81107e34:	01401244 	movi	r5,73
81107e38:	1009883a 	mov	r4,r2
81107e3c:	11096340 	call	81109634 <uliRmapReadReg>
81107e40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
81107e44:	e0bfff17 	ldw	r2,-4(fp)
81107e48:	e0fffe17 	ldw	r3,-8(fp)
81107e4c:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e50:	e0bfff17 	ldw	r2,-4(fp)
81107e54:	10800017 	ldw	r2,0(r2)
81107e58:	01401284 	movi	r5,74
81107e5c:	1009883a 	mov	r4,r2
81107e60:	11096340 	call	81109634 <uliRmapReadReg>
81107e64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
81107e68:	e0bfff17 	ldw	r2,-4(fp)
81107e6c:	e0fffe17 	ldw	r3,-8(fp)
81107e70:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e74:	e0bfff17 	ldw	r2,-4(fp)
81107e78:	10800017 	ldw	r2,0(r2)
81107e7c:	014012c4 	movi	r5,75
81107e80:	1009883a 	mov	r4,r2
81107e84:	11096340 	call	81109634 <uliRmapReadReg>
81107e88:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81107e8c:	e0bfff17 	ldw	r2,-4(fp)
81107e90:	e0fffe17 	ldw	r3,-8(fp)
81107e94:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e98:	e0bfff17 	ldw	r2,-4(fp)
81107e9c:	10800017 	ldw	r2,0(r2)
81107ea0:	01401304 	movi	r5,76
81107ea4:	1009883a 	mov	r4,r2
81107ea8:	11096340 	call	81109634 <uliRmapReadReg>
81107eac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81107eb0:	e0bfff17 	ldw	r2,-4(fp)
81107eb4:	e0fffe17 	ldw	r3,-8(fp)
81107eb8:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ebc:	e0bfff17 	ldw	r2,-4(fp)
81107ec0:	10800017 	ldw	r2,0(r2)
81107ec4:	01401344 	movi	r5,77
81107ec8:	1009883a 	mov	r4,r2
81107ecc:	11096340 	call	81109634 <uliRmapReadReg>
81107ed0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81107ed4:	e0bfff17 	ldw	r2,-4(fp)
81107ed8:	e0fffe17 	ldw	r3,-8(fp)
81107edc:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ee0:	e0bfff17 	ldw	r2,-4(fp)
81107ee4:	10800017 	ldw	r2,0(r2)
81107ee8:	01401384 	movi	r5,78
81107eec:	1009883a 	mov	r4,r2
81107ef0:	11096340 	call	81109634 <uliRmapReadReg>
81107ef4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
81107ef8:	e0bfff17 	ldw	r2,-4(fp)
81107efc:	e0fffe17 	ldw	r3,-8(fp)
81107f00:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f04:	e0bfff17 	ldw	r2,-4(fp)
81107f08:	10800017 	ldw	r2,0(r2)
81107f0c:	014013c4 	movi	r5,79
81107f10:	1009883a 	mov	r4,r2
81107f14:	11096340 	call	81109634 <uliRmapReadReg>
81107f18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107f1c:	e0bfff17 	ldw	r2,-4(fp)
81107f20:	e0fffe17 	ldw	r3,-8(fp)
81107f24:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f28:	e0bfff17 	ldw	r2,-4(fp)
81107f2c:	10800017 	ldw	r2,0(r2)
81107f30:	01401404 	movi	r5,80
81107f34:	1009883a 	mov	r4,r2
81107f38:	11096340 	call	81109634 <uliRmapReadReg>
81107f3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107f40:	e0bfff17 	ldw	r2,-4(fp)
81107f44:	e0fffe17 	ldw	r3,-8(fp)
81107f48:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f4c:	e0bfff17 	ldw	r2,-4(fp)
81107f50:	10800017 	ldw	r2,0(r2)
81107f54:	01401444 	movi	r5,81
81107f58:	1009883a 	mov	r4,r2
81107f5c:	11096340 	call	81109634 <uliRmapReadReg>
81107f60:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81107f64:	e0bfff17 	ldw	r2,-4(fp)
81107f68:	e0fffe17 	ldw	r3,-8(fp)
81107f6c:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81107f70:	00800044 	movi	r2,1
81107f74:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107f78:	e0bffd17 	ldw	r2,-12(fp)
}
81107f7c:	e037883a 	mov	sp,fp
81107f80:	dfc00117 	ldw	ra,4(sp)
81107f84:	df000017 	ldw	fp,0(sp)
81107f88:	dec00204 	addi	sp,sp,8
81107f8c:	f800283a 	ret

81107f90 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81107f90:	defffb04 	addi	sp,sp,-20
81107f94:	de00012e 	bgeu	sp,et,81107f9c <bRmapGetMemConfigStat+0xc>
81107f98:	003b68fa 	trap	3
81107f9c:	dfc00415 	stw	ra,16(sp)
81107fa0:	df000315 	stw	fp,12(sp)
81107fa4:	df000304 	addi	fp,sp,12
81107fa8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107fac:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107fb0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107fb4:	e0bfff17 	ldw	r2,-4(fp)
81107fb8:	10001426 	beq	r2,zero,8110800c <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107fbc:	e0bfff17 	ldw	r2,-4(fp)
81107fc0:	10800017 	ldw	r2,0(r2)
81107fc4:	014001c4 	movi	r5,7
81107fc8:	1009883a 	mov	r4,r2
81107fcc:	11096340 	call	81109634 <uliRmapReadReg>
81107fd0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81107fd4:	e0bfff17 	ldw	r2,-4(fp)
81107fd8:	e0fffe17 	ldw	r3,-8(fp)
81107fdc:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107fe0:	e0bfff17 	ldw	r2,-4(fp)
81107fe4:	10800017 	ldw	r2,0(r2)
81107fe8:	01400184 	movi	r5,6
81107fec:	1009883a 	mov	r4,r2
81107ff0:	11096340 	call	81109634 <uliRmapReadReg>
81107ff4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
81107ff8:	e0bfff17 	ldw	r2,-4(fp)
81107ffc:	e0fffe17 	ldw	r3,-8(fp)
81108000:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
81108004:	00800044 	movi	r2,1
81108008:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110800c:	e0bffd17 	ldw	r2,-12(fp)
}
81108010:	e037883a 	mov	sp,fp
81108014:	dfc00117 	ldw	ra,4(sp)
81108018:	df000017 	ldw	fp,0(sp)
8110801c:	dec00204 	addi	sp,sp,8
81108020:	f800283a 	ret

81108024 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81108024:	defffb04 	addi	sp,sp,-20
81108028:	de00012e 	bgeu	sp,et,81108030 <bRmapSetRmapMemHKArea+0xc>
8110802c:	003b68fa 	trap	3
81108030:	dfc00415 	stw	ra,16(sp)
81108034:	df000315 	stw	fp,12(sp)
81108038:	df000304 	addi	fp,sp,12
8110803c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108040:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108044:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108048:	e0bfff17 	ldw	r2,-4(fp)
8110804c:	10030226 	beq	r2,zero,81108c58 <bRmapSetRmapMemHKArea+0xc34>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108050:	e0bfff17 	ldw	r2,-4(fp)
81108054:	10800017 	ldw	r2,0(r2)
81108058:	01402804 	movi	r5,160
8110805c:	1009883a 	mov	r4,r2
81108060:	11096340 	call	81109634 <uliRmapReadReg>
81108064:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
81108068:	e0bffe17 	ldw	r2,-8(fp)
8110806c:	10bfffec 	andhi	r2,r2,65535
81108070:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81108074:	e0bfff17 	ldw	r2,-4(fp)
81108078:	1080260b 	ldhu	r2,152(r2)
8110807c:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81108080:	e0fffe17 	ldw	r3,-8(fp)
81108084:	1884b03a 	or	r2,r3,r2
81108088:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
8110808c:	e0bffe17 	ldw	r2,-8(fp)
81108090:	10bfffcc 	andi	r2,r2,65535
81108094:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108098:	e0bfff17 	ldw	r2,-4(fp)
8110809c:	10800017 	ldw	r2,0(r2)
811080a0:	e1bffe17 	ldw	r6,-8(fp)
811080a4:	01402804 	movi	r5,160
811080a8:	1009883a 	mov	r4,r2
811080ac:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080b0:	e0bfff17 	ldw	r2,-4(fp)
811080b4:	10800017 	ldw	r2,0(r2)
811080b8:	01402844 	movi	r5,161
811080bc:	1009883a 	mov	r4,r2
811080c0:	11096340 	call	81109634 <uliRmapReadReg>
811080c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
811080c8:	e0bffe17 	ldw	r2,-8(fp)
811080cc:	10bfffec 	andhi	r2,r2,65535
811080d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
811080d4:	e0bfff17 	ldw	r2,-4(fp)
811080d8:	1080270b 	ldhu	r2,156(r2)
811080dc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
811080e0:	e0fffe17 	ldw	r3,-8(fp)
811080e4:	1884b03a 	or	r2,r3,r2
811080e8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
811080ec:	e0bffe17 	ldw	r2,-8(fp)
811080f0:	10bfffcc 	andi	r2,r2,65535
811080f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
811080f8:	e0bfff17 	ldw	r2,-4(fp)
811080fc:	10800017 	ldw	r2,0(r2)
81108100:	e1bffe17 	ldw	r6,-8(fp)
81108104:	01402844 	movi	r5,161
81108108:	1009883a 	mov	r4,r2
8110810c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108110:	e0bfff17 	ldw	r2,-4(fp)
81108114:	10800017 	ldw	r2,0(r2)
81108118:	01402884 	movi	r5,162
8110811c:	1009883a 	mov	r4,r2
81108120:	11096340 	call	81109634 <uliRmapReadReg>
81108124:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81108128:	e0bffe17 	ldw	r2,-8(fp)
8110812c:	10bfffec 	andhi	r2,r2,65535
81108130:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81108134:	e0bfff17 	ldw	r2,-4(fp)
81108138:	1080280b 	ldhu	r2,160(r2)
8110813c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81108140:	e0fffe17 	ldw	r3,-8(fp)
81108144:	1884b03a 	or	r2,r3,r2
81108148:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
8110814c:	e0bffe17 	ldw	r2,-8(fp)
81108150:	10bfffcc 	andi	r2,r2,65535
81108154:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81108158:	e0bfff17 	ldw	r2,-4(fp)
8110815c:	10800017 	ldw	r2,0(r2)
81108160:	e1bffe17 	ldw	r6,-8(fp)
81108164:	01402884 	movi	r5,162
81108168:	1009883a 	mov	r4,r2
8110816c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108170:	e0bfff17 	ldw	r2,-4(fp)
81108174:	10800017 	ldw	r2,0(r2)
81108178:	014028c4 	movi	r5,163
8110817c:	1009883a 	mov	r4,r2
81108180:	11096340 	call	81109634 <uliRmapReadReg>
81108184:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81108188:	e0bffe17 	ldw	r2,-8(fp)
8110818c:	10bfffec 	andhi	r2,r2,65535
81108190:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
81108194:	e0bfff17 	ldw	r2,-4(fp)
81108198:	1080290b 	ldhu	r2,164(r2)
8110819c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
811081a0:	e0fffe17 	ldw	r3,-8(fp)
811081a4:	1884b03a 	or	r2,r3,r2
811081a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
811081ac:	e0bffe17 	ldw	r2,-8(fp)
811081b0:	10bfffcc 	andi	r2,r2,65535
811081b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
811081b8:	e0bfff17 	ldw	r2,-4(fp)
811081bc:	10800017 	ldw	r2,0(r2)
811081c0:	e1bffe17 	ldw	r6,-8(fp)
811081c4:	014028c4 	movi	r5,163
811081c8:	1009883a 	mov	r4,r2
811081cc:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081d0:	e0bfff17 	ldw	r2,-4(fp)
811081d4:	10800017 	ldw	r2,0(r2)
811081d8:	01402904 	movi	r5,164
811081dc:	1009883a 	mov	r4,r2
811081e0:	11096340 	call	81109634 <uliRmapReadReg>
811081e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
811081e8:	e0bffe17 	ldw	r2,-8(fp)
811081ec:	10bfffec 	andhi	r2,r2,65535
811081f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
811081f4:	e0bfff17 	ldw	r2,-4(fp)
811081f8:	10802a0b 	ldhu	r2,168(r2)
811081fc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81108200:	e0fffe17 	ldw	r3,-8(fp)
81108204:	1884b03a 	or	r2,r3,r2
81108208:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
8110820c:	e0bffe17 	ldw	r2,-8(fp)
81108210:	10bfffcc 	andi	r2,r2,65535
81108214:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81108218:	e0bfff17 	ldw	r2,-4(fp)
8110821c:	10800017 	ldw	r2,0(r2)
81108220:	e1bffe17 	ldw	r6,-8(fp)
81108224:	01402904 	movi	r5,164
81108228:	1009883a 	mov	r4,r2
8110822c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108230:	e0bfff17 	ldw	r2,-4(fp)
81108234:	10800017 	ldw	r2,0(r2)
81108238:	01402944 	movi	r5,165
8110823c:	1009883a 	mov	r4,r2
81108240:	11096340 	call	81109634 <uliRmapReadReg>
81108244:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81108248:	e0bffe17 	ldw	r2,-8(fp)
8110824c:	10bfffec 	andhi	r2,r2,65535
81108250:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81108254:	e0bfff17 	ldw	r2,-4(fp)
81108258:	10802b0b 	ldhu	r2,172(r2)
8110825c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
81108260:	e0fffe17 	ldw	r3,-8(fp)
81108264:	1884b03a 	or	r2,r3,r2
81108268:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
8110826c:	e0bffe17 	ldw	r2,-8(fp)
81108270:	10bfffcc 	andi	r2,r2,65535
81108274:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81108278:	e0bfff17 	ldw	r2,-4(fp)
8110827c:	10800017 	ldw	r2,0(r2)
81108280:	e1bffe17 	ldw	r6,-8(fp)
81108284:	01402944 	movi	r5,165
81108288:	1009883a 	mov	r4,r2
8110828c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108290:	e0bfff17 	ldw	r2,-4(fp)
81108294:	10800017 	ldw	r2,0(r2)
81108298:	01402984 	movi	r5,166
8110829c:	1009883a 	mov	r4,r2
811082a0:	11096340 	call	81109634 <uliRmapReadReg>
811082a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
811082a8:	e0bffe17 	ldw	r2,-8(fp)
811082ac:	10bfffec 	andhi	r2,r2,65535
811082b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
811082b4:	e0bfff17 	ldw	r2,-4(fp)
811082b8:	10802c0b 	ldhu	r2,176(r2)
811082bc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
811082c0:	e0fffe17 	ldw	r3,-8(fp)
811082c4:	1884b03a 	or	r2,r3,r2
811082c8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
811082cc:	e0bffe17 	ldw	r2,-8(fp)
811082d0:	10bfffcc 	andi	r2,r2,65535
811082d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
811082d8:	e0bfff17 	ldw	r2,-4(fp)
811082dc:	10800017 	ldw	r2,0(r2)
811082e0:	e1bffe17 	ldw	r6,-8(fp)
811082e4:	01402984 	movi	r5,166
811082e8:	1009883a 	mov	r4,r2
811082ec:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082f0:	e0bfff17 	ldw	r2,-4(fp)
811082f4:	10800017 	ldw	r2,0(r2)
811082f8:	014029c4 	movi	r5,167
811082fc:	1009883a 	mov	r4,r2
81108300:	11096340 	call	81109634 <uliRmapReadReg>
81108304:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81108308:	e0bffe17 	ldw	r2,-8(fp)
8110830c:	10bfffec 	andhi	r2,r2,65535
81108310:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
81108314:	e0bfff17 	ldw	r2,-4(fp)
81108318:	10802d0b 	ldhu	r2,180(r2)
8110831c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
81108320:	e0fffe17 	ldw	r3,-8(fp)
81108324:	1884b03a 	or	r2,r3,r2
81108328:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
8110832c:	e0bffe17 	ldw	r2,-8(fp)
81108330:	10bfffcc 	andi	r2,r2,65535
81108334:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81108338:	e0bfff17 	ldw	r2,-4(fp)
8110833c:	10800017 	ldw	r2,0(r2)
81108340:	e1bffe17 	ldw	r6,-8(fp)
81108344:	014029c4 	movi	r5,167
81108348:	1009883a 	mov	r4,r2
8110834c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108350:	e0bfff17 	ldw	r2,-4(fp)
81108354:	10800017 	ldw	r2,0(r2)
81108358:	01402a04 	movi	r5,168
8110835c:	1009883a 	mov	r4,r2
81108360:	11096340 	call	81109634 <uliRmapReadReg>
81108364:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81108368:	e0bffe17 	ldw	r2,-8(fp)
8110836c:	10bfffec 	andhi	r2,r2,65535
81108370:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81108374:	e0bfff17 	ldw	r2,-4(fp)
81108378:	10802e0b 	ldhu	r2,184(r2)
8110837c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81108380:	e0fffe17 	ldw	r3,-8(fp)
81108384:	1884b03a 	or	r2,r3,r2
81108388:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
8110838c:	e0bffe17 	ldw	r2,-8(fp)
81108390:	10bfffcc 	andi	r2,r2,65535
81108394:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81108398:	e0bfff17 	ldw	r2,-4(fp)
8110839c:	10800017 	ldw	r2,0(r2)
811083a0:	e1bffe17 	ldw	r6,-8(fp)
811083a4:	01402a04 	movi	r5,168
811083a8:	1009883a 	mov	r4,r2
811083ac:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083b0:	e0bfff17 	ldw	r2,-4(fp)
811083b4:	10800017 	ldw	r2,0(r2)
811083b8:	01402a44 	movi	r5,169
811083bc:	1009883a 	mov	r4,r2
811083c0:	11096340 	call	81109634 <uliRmapReadReg>
811083c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
811083c8:	e0bffe17 	ldw	r2,-8(fp)
811083cc:	10bfffec 	andhi	r2,r2,65535
811083d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
811083d4:	e0bfff17 	ldw	r2,-4(fp)
811083d8:	10802f0b 	ldhu	r2,188(r2)
811083dc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
811083e0:	e0fffe17 	ldw	r3,-8(fp)
811083e4:	1884b03a 	or	r2,r3,r2
811083e8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
811083ec:	e0bffe17 	ldw	r2,-8(fp)
811083f0:	10bfffcc 	andi	r2,r2,65535
811083f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
811083f8:	e0bfff17 	ldw	r2,-4(fp)
811083fc:	10800017 	ldw	r2,0(r2)
81108400:	e1bffe17 	ldw	r6,-8(fp)
81108404:	01402a44 	movi	r5,169
81108408:	1009883a 	mov	r4,r2
8110840c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108410:	e0bfff17 	ldw	r2,-4(fp)
81108414:	10800017 	ldw	r2,0(r2)
81108418:	01402a84 	movi	r5,170
8110841c:	1009883a 	mov	r4,r2
81108420:	11096340 	call	81109634 <uliRmapReadReg>
81108424:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81108428:	e0bffe17 	ldw	r2,-8(fp)
8110842c:	10bfffec 	andhi	r2,r2,65535
81108430:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81108434:	e0bfff17 	ldw	r2,-4(fp)
81108438:	1080300b 	ldhu	r2,192(r2)
8110843c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81108440:	e0fffe17 	ldw	r3,-8(fp)
81108444:	1884b03a 	or	r2,r3,r2
81108448:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
8110844c:	e0bffe17 	ldw	r2,-8(fp)
81108450:	10bfffcc 	andi	r2,r2,65535
81108454:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81108458:	e0bfff17 	ldw	r2,-4(fp)
8110845c:	10800017 	ldw	r2,0(r2)
81108460:	e1bffe17 	ldw	r6,-8(fp)
81108464:	01402a84 	movi	r5,170
81108468:	1009883a 	mov	r4,r2
8110846c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108470:	e0bfff17 	ldw	r2,-4(fp)
81108474:	10800017 	ldw	r2,0(r2)
81108478:	01402ac4 	movi	r5,171
8110847c:	1009883a 	mov	r4,r2
81108480:	11096340 	call	81109634 <uliRmapReadReg>
81108484:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81108488:	e0bffe17 	ldw	r2,-8(fp)
8110848c:	10bfffec 	andhi	r2,r2,65535
81108490:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81108494:	e0bfff17 	ldw	r2,-4(fp)
81108498:	1080310b 	ldhu	r2,196(r2)
8110849c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
811084a0:	e0fffe17 	ldw	r3,-8(fp)
811084a4:	1884b03a 	or	r2,r3,r2
811084a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
811084ac:	e0bffe17 	ldw	r2,-8(fp)
811084b0:	10bfffcc 	andi	r2,r2,65535
811084b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
811084b8:	e0bfff17 	ldw	r2,-4(fp)
811084bc:	10800017 	ldw	r2,0(r2)
811084c0:	e1bffe17 	ldw	r6,-8(fp)
811084c4:	01402ac4 	movi	r5,171
811084c8:	1009883a 	mov	r4,r2
811084cc:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084d0:	e0bfff17 	ldw	r2,-4(fp)
811084d4:	10800017 	ldw	r2,0(r2)
811084d8:	01402b04 	movi	r5,172
811084dc:	1009883a 	mov	r4,r2
811084e0:	11096340 	call	81109634 <uliRmapReadReg>
811084e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
811084e8:	e0bffe17 	ldw	r2,-8(fp)
811084ec:	10bfffec 	andhi	r2,r2,65535
811084f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
811084f4:	e0bfff17 	ldw	r2,-4(fp)
811084f8:	1080320b 	ldhu	r2,200(r2)
811084fc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81108500:	e0fffe17 	ldw	r3,-8(fp)
81108504:	1884b03a 	or	r2,r3,r2
81108508:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
8110850c:	e0bffe17 	ldw	r2,-8(fp)
81108510:	10bfffcc 	andi	r2,r2,65535
81108514:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81108518:	e0bfff17 	ldw	r2,-4(fp)
8110851c:	10800017 	ldw	r2,0(r2)
81108520:	e1bffe17 	ldw	r6,-8(fp)
81108524:	01402b04 	movi	r5,172
81108528:	1009883a 	mov	r4,r2
8110852c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108530:	e0bfff17 	ldw	r2,-4(fp)
81108534:	10800017 	ldw	r2,0(r2)
81108538:	01402b44 	movi	r5,173
8110853c:	1009883a 	mov	r4,r2
81108540:	11096340 	call	81109634 <uliRmapReadReg>
81108544:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81108548:	e0bffe17 	ldw	r2,-8(fp)
8110854c:	10bfffec 	andhi	r2,r2,65535
81108550:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81108554:	e0bfff17 	ldw	r2,-4(fp)
81108558:	1080330b 	ldhu	r2,204(r2)
8110855c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81108560:	e0fffe17 	ldw	r3,-8(fp)
81108564:	1884b03a 	or	r2,r3,r2
81108568:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
8110856c:	e0bffe17 	ldw	r2,-8(fp)
81108570:	10bfffcc 	andi	r2,r2,65535
81108574:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81108578:	e0bfff17 	ldw	r2,-4(fp)
8110857c:	10800017 	ldw	r2,0(r2)
81108580:	e1bffe17 	ldw	r6,-8(fp)
81108584:	01402b44 	movi	r5,173
81108588:	1009883a 	mov	r4,r2
8110858c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108590:	e0bfff17 	ldw	r2,-4(fp)
81108594:	10800017 	ldw	r2,0(r2)
81108598:	01402b84 	movi	r5,174
8110859c:	1009883a 	mov	r4,r2
811085a0:	11096340 	call	81109634 <uliRmapReadReg>
811085a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
811085a8:	e0bffe17 	ldw	r2,-8(fp)
811085ac:	10bfffec 	andhi	r2,r2,65535
811085b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
811085b4:	e0bfff17 	ldw	r2,-4(fp)
811085b8:	1080340b 	ldhu	r2,208(r2)
811085bc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
811085c0:	e0fffe17 	ldw	r3,-8(fp)
811085c4:	1884b03a 	or	r2,r3,r2
811085c8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
811085cc:	e0bffe17 	ldw	r2,-8(fp)
811085d0:	10bfffcc 	andi	r2,r2,65535
811085d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
811085d8:	e0bfff17 	ldw	r2,-4(fp)
811085dc:	10800017 	ldw	r2,0(r2)
811085e0:	e1bffe17 	ldw	r6,-8(fp)
811085e4:	01402b84 	movi	r5,174
811085e8:	1009883a 	mov	r4,r2
811085ec:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	10800017 	ldw	r2,0(r2)
811085f8:	01402bc4 	movi	r5,175
811085fc:	1009883a 	mov	r4,r2
81108600:	11096340 	call	81109634 <uliRmapReadReg>
81108604:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81108608:	e0bffe17 	ldw	r2,-8(fp)
8110860c:	10bfffec 	andhi	r2,r2,65535
81108610:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81108614:	e0bfff17 	ldw	r2,-4(fp)
81108618:	1080350b 	ldhu	r2,212(r2)
8110861c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81108620:	e0fffe17 	ldw	r3,-8(fp)
81108624:	1884b03a 	or	r2,r3,r2
81108628:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
8110862c:	e0bffe17 	ldw	r2,-8(fp)
81108630:	10bfffcc 	andi	r2,r2,65535
81108634:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81108638:	e0bfff17 	ldw	r2,-4(fp)
8110863c:	10800017 	ldw	r2,0(r2)
81108640:	e1bffe17 	ldw	r6,-8(fp)
81108644:	01402bc4 	movi	r5,175
81108648:	1009883a 	mov	r4,r2
8110864c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108650:	e0bfff17 	ldw	r2,-4(fp)
81108654:	10800017 	ldw	r2,0(r2)
81108658:	01402c04 	movi	r5,176
8110865c:	1009883a 	mov	r4,r2
81108660:	11096340 	call	81109634 <uliRmapReadReg>
81108664:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81108668:	e0bffe17 	ldw	r2,-8(fp)
8110866c:	10bfffec 	andhi	r2,r2,65535
81108670:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81108674:	e0bfff17 	ldw	r2,-4(fp)
81108678:	1080360b 	ldhu	r2,216(r2)
8110867c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81108680:	e0fffe17 	ldw	r3,-8(fp)
81108684:	1884b03a 	or	r2,r3,r2
81108688:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
8110868c:	e0bffe17 	ldw	r2,-8(fp)
81108690:	10bfffcc 	andi	r2,r2,65535
81108694:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81108698:	e0bfff17 	ldw	r2,-4(fp)
8110869c:	10800017 	ldw	r2,0(r2)
811086a0:	e1bffe17 	ldw	r6,-8(fp)
811086a4:	01402c04 	movi	r5,176
811086a8:	1009883a 	mov	r4,r2
811086ac:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086b0:	e0bfff17 	ldw	r2,-4(fp)
811086b4:	10800017 	ldw	r2,0(r2)
811086b8:	01402c44 	movi	r5,177
811086bc:	1009883a 	mov	r4,r2
811086c0:	11096340 	call	81109634 <uliRmapReadReg>
811086c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
811086c8:	e0bffe17 	ldw	r2,-8(fp)
811086cc:	10bfffec 	andhi	r2,r2,65535
811086d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
811086d4:	e0bfff17 	ldw	r2,-4(fp)
811086d8:	1080370b 	ldhu	r2,220(r2)
811086dc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
811086e0:	e0fffe17 	ldw	r3,-8(fp)
811086e4:	1884b03a 	or	r2,r3,r2
811086e8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
811086ec:	e0bffe17 	ldw	r2,-8(fp)
811086f0:	10bfffcc 	andi	r2,r2,65535
811086f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
811086f8:	e0bfff17 	ldw	r2,-4(fp)
811086fc:	10800017 	ldw	r2,0(r2)
81108700:	e1bffe17 	ldw	r6,-8(fp)
81108704:	01402c44 	movi	r5,177
81108708:	1009883a 	mov	r4,r2
8110870c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108710:	e0bfff17 	ldw	r2,-4(fp)
81108714:	10800017 	ldw	r2,0(r2)
81108718:	01402c84 	movi	r5,178
8110871c:	1009883a 	mov	r4,r2
81108720:	11096340 	call	81109634 <uliRmapReadReg>
81108724:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81108728:	e0bffe17 	ldw	r2,-8(fp)
8110872c:	10bfffec 	andhi	r2,r2,65535
81108730:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81108734:	e0bfff17 	ldw	r2,-4(fp)
81108738:	1080380b 	ldhu	r2,224(r2)
8110873c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81108740:	e0fffe17 	ldw	r3,-8(fp)
81108744:	1884b03a 	or	r2,r3,r2
81108748:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
8110874c:	e0bffe17 	ldw	r2,-8(fp)
81108750:	10bfffcc 	andi	r2,r2,65535
81108754:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81108758:	e0bfff17 	ldw	r2,-4(fp)
8110875c:	10800017 	ldw	r2,0(r2)
81108760:	e1bffe17 	ldw	r6,-8(fp)
81108764:	01402c84 	movi	r5,178
81108768:	1009883a 	mov	r4,r2
8110876c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108770:	e0bfff17 	ldw	r2,-4(fp)
81108774:	10800017 	ldw	r2,0(r2)
81108778:	01402cc4 	movi	r5,179
8110877c:	1009883a 	mov	r4,r2
81108780:	11096340 	call	81109634 <uliRmapReadReg>
81108784:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81108788:	e0bffe17 	ldw	r2,-8(fp)
8110878c:	10bfffec 	andhi	r2,r2,65535
81108790:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81108794:	e0bfff17 	ldw	r2,-4(fp)
81108798:	1080390b 	ldhu	r2,228(r2)
8110879c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
811087a0:	e0fffe17 	ldw	r3,-8(fp)
811087a4:	1884b03a 	or	r2,r3,r2
811087a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
811087ac:	e0bffe17 	ldw	r2,-8(fp)
811087b0:	10bfffcc 	andi	r2,r2,65535
811087b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
811087b8:	e0bfff17 	ldw	r2,-4(fp)
811087bc:	10800017 	ldw	r2,0(r2)
811087c0:	e1bffe17 	ldw	r6,-8(fp)
811087c4:	01402cc4 	movi	r5,179
811087c8:	1009883a 	mov	r4,r2
811087cc:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087d0:	e0bfff17 	ldw	r2,-4(fp)
811087d4:	10800017 	ldw	r2,0(r2)
811087d8:	01402d04 	movi	r5,180
811087dc:	1009883a 	mov	r4,r2
811087e0:	11096340 	call	81109634 <uliRmapReadReg>
811087e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
811087e8:	e0bffe17 	ldw	r2,-8(fp)
811087ec:	10bfffec 	andhi	r2,r2,65535
811087f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
811087f4:	e0bfff17 	ldw	r2,-4(fp)
811087f8:	10803a0b 	ldhu	r2,232(r2)
811087fc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81108800:	e0fffe17 	ldw	r3,-8(fp)
81108804:	1884b03a 	or	r2,r3,r2
81108808:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
8110880c:	e0bffe17 	ldw	r2,-8(fp)
81108810:	10bfffcc 	andi	r2,r2,65535
81108814:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81108818:	e0bfff17 	ldw	r2,-4(fp)
8110881c:	10800017 	ldw	r2,0(r2)
81108820:	e1bffe17 	ldw	r6,-8(fp)
81108824:	01402d04 	movi	r5,180
81108828:	1009883a 	mov	r4,r2
8110882c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108830:	e0bfff17 	ldw	r2,-4(fp)
81108834:	10800017 	ldw	r2,0(r2)
81108838:	01402d44 	movi	r5,181
8110883c:	1009883a 	mov	r4,r2
81108840:	11096340 	call	81109634 <uliRmapReadReg>
81108844:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81108848:	e0bffe17 	ldw	r2,-8(fp)
8110884c:	10bfffec 	andhi	r2,r2,65535
81108850:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81108854:	e0bfff17 	ldw	r2,-4(fp)
81108858:	10803b0b 	ldhu	r2,236(r2)
8110885c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108860:	e0fffe17 	ldw	r3,-8(fp)
81108864:	1884b03a 	or	r2,r3,r2
81108868:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
8110886c:	e0bffe17 	ldw	r2,-8(fp)
81108870:	10bfffcc 	andi	r2,r2,65535
81108874:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81108878:	e0bfff17 	ldw	r2,-4(fp)
8110887c:	10800017 	ldw	r2,0(r2)
81108880:	e1bffe17 	ldw	r6,-8(fp)
81108884:	01402d44 	movi	r5,181
81108888:	1009883a 	mov	r4,r2
8110888c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108890:	e0bfff17 	ldw	r2,-4(fp)
81108894:	10800017 	ldw	r2,0(r2)
81108898:	01402d84 	movi	r5,182
8110889c:	1009883a 	mov	r4,r2
811088a0:	11096340 	call	81109634 <uliRmapReadReg>
811088a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
811088a8:	e0bffe17 	ldw	r2,-8(fp)
811088ac:	10bfffec 	andhi	r2,r2,65535
811088b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
811088b4:	e0bfff17 	ldw	r2,-4(fp)
811088b8:	10803c0b 	ldhu	r2,240(r2)
811088bc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
811088c0:	e0fffe17 	ldw	r3,-8(fp)
811088c4:	1884b03a 	or	r2,r3,r2
811088c8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
811088cc:	e0bffe17 	ldw	r2,-8(fp)
811088d0:	10bfffcc 	andi	r2,r2,65535
811088d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
811088d8:	e0bfff17 	ldw	r2,-4(fp)
811088dc:	10800017 	ldw	r2,0(r2)
811088e0:	e1bffe17 	ldw	r6,-8(fp)
811088e4:	01402d84 	movi	r5,182
811088e8:	1009883a 	mov	r4,r2
811088ec:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088f0:	e0bfff17 	ldw	r2,-4(fp)
811088f4:	10800017 	ldw	r2,0(r2)
811088f8:	01402dc4 	movi	r5,183
811088fc:	1009883a 	mov	r4,r2
81108900:	11096340 	call	81109634 <uliRmapReadReg>
81108904:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81108908:	e0bffe17 	ldw	r2,-8(fp)
8110890c:	10bfffec 	andhi	r2,r2,65535
81108910:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81108914:	e0bfff17 	ldw	r2,-4(fp)
81108918:	10803d0b 	ldhu	r2,244(r2)
8110891c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81108920:	e0fffe17 	ldw	r3,-8(fp)
81108924:	1884b03a 	or	r2,r3,r2
81108928:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
8110892c:	e0bffe17 	ldw	r2,-8(fp)
81108930:	10bfffcc 	andi	r2,r2,65535
81108934:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81108938:	e0bfff17 	ldw	r2,-4(fp)
8110893c:	10800017 	ldw	r2,0(r2)
81108940:	e1bffe17 	ldw	r6,-8(fp)
81108944:	01402dc4 	movi	r5,183
81108948:	1009883a 	mov	r4,r2
8110894c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108950:	e0bfff17 	ldw	r2,-4(fp)
81108954:	10800017 	ldw	r2,0(r2)
81108958:	01402e04 	movi	r5,184
8110895c:	1009883a 	mov	r4,r2
81108960:	11096340 	call	81109634 <uliRmapReadReg>
81108964:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81108968:	e0bffe17 	ldw	r2,-8(fp)
8110896c:	10bfffec 	andhi	r2,r2,65535
81108970:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81108974:	e0bfff17 	ldw	r2,-4(fp)
81108978:	10803e0b 	ldhu	r2,248(r2)
8110897c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81108980:	e0fffe17 	ldw	r3,-8(fp)
81108984:	1884b03a 	or	r2,r3,r2
81108988:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
8110898c:	e0bffe17 	ldw	r2,-8(fp)
81108990:	10bfffcc 	andi	r2,r2,65535
81108994:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81108998:	e0bfff17 	ldw	r2,-4(fp)
8110899c:	10800017 	ldw	r2,0(r2)
811089a0:	e1bffe17 	ldw	r6,-8(fp)
811089a4:	01402e04 	movi	r5,184
811089a8:	1009883a 	mov	r4,r2
811089ac:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089b0:	e0bfff17 	ldw	r2,-4(fp)
811089b4:	10800017 	ldw	r2,0(r2)
811089b8:	01402e44 	movi	r5,185
811089bc:	1009883a 	mov	r4,r2
811089c0:	11096340 	call	81109634 <uliRmapReadReg>
811089c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
811089c8:	e0bffe17 	ldw	r2,-8(fp)
811089cc:	10bfffec 	andhi	r2,r2,65535
811089d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
811089d4:	e0bfff17 	ldw	r2,-4(fp)
811089d8:	10803f0b 	ldhu	r2,252(r2)
811089dc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
811089e0:	e0fffe17 	ldw	r3,-8(fp)
811089e4:	1884b03a 	or	r2,r3,r2
811089e8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
811089ec:	e0bffe17 	ldw	r2,-8(fp)
811089f0:	10bfffcc 	andi	r2,r2,65535
811089f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
811089f8:	e0bfff17 	ldw	r2,-4(fp)
811089fc:	10800017 	ldw	r2,0(r2)
81108a00:	e1bffe17 	ldw	r6,-8(fp)
81108a04:	01402e44 	movi	r5,185
81108a08:	1009883a 	mov	r4,r2
81108a0c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a10:	e0bfff17 	ldw	r2,-4(fp)
81108a14:	10800017 	ldw	r2,0(r2)
81108a18:	01402e84 	movi	r5,186
81108a1c:	1009883a 	mov	r4,r2
81108a20:	11096340 	call	81109634 <uliRmapReadReg>
81108a24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81108a28:	e0bffe17 	ldw	r2,-8(fp)
81108a2c:	10bfffec 	andhi	r2,r2,65535
81108a30:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81108a34:	e0bfff17 	ldw	r2,-4(fp)
81108a38:	1080400b 	ldhu	r2,256(r2)
81108a3c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81108a40:	e0fffe17 	ldw	r3,-8(fp)
81108a44:	1884b03a 	or	r2,r3,r2
81108a48:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81108a4c:	e0bffe17 	ldw	r2,-8(fp)
81108a50:	10bfffcc 	andi	r2,r2,65535
81108a54:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81108a58:	e0bfff17 	ldw	r2,-4(fp)
81108a5c:	10800017 	ldw	r2,0(r2)
81108a60:	e1bffe17 	ldw	r6,-8(fp)
81108a64:	01402e84 	movi	r5,186
81108a68:	1009883a 	mov	r4,r2
81108a6c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a70:	e0bfff17 	ldw	r2,-4(fp)
81108a74:	10800017 	ldw	r2,0(r2)
81108a78:	01402ec4 	movi	r5,187
81108a7c:	1009883a 	mov	r4,r2
81108a80:	11096340 	call	81109634 <uliRmapReadReg>
81108a84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
81108a88:	e0bffe17 	ldw	r2,-8(fp)
81108a8c:	10bfffec 	andhi	r2,r2,65535
81108a90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
81108a94:	e0bfff17 	ldw	r2,-4(fp)
81108a98:	1080410b 	ldhu	r2,260(r2)
81108a9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
81108aa0:	e0fffe17 	ldw	r3,-8(fp)
81108aa4:	1884b03a 	or	r2,r3,r2
81108aa8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
81108aac:	e0bffe17 	ldw	r2,-8(fp)
81108ab0:	10bfffcc 	andi	r2,r2,65535
81108ab4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81108ab8:	e0bfff17 	ldw	r2,-4(fp)
81108abc:	10800017 	ldw	r2,0(r2)
81108ac0:	e1bffe17 	ldw	r6,-8(fp)
81108ac4:	01402ec4 	movi	r5,187
81108ac8:	1009883a 	mov	r4,r2
81108acc:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ad0:	e0bfff17 	ldw	r2,-4(fp)
81108ad4:	10800017 	ldw	r2,0(r2)
81108ad8:	01402f04 	movi	r5,188
81108adc:	1009883a 	mov	r4,r2
81108ae0:	11096340 	call	81109634 <uliRmapReadReg>
81108ae4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81108ae8:	e0bffe17 	ldw	r2,-8(fp)
81108aec:	10bfffec 	andhi	r2,r2,65535
81108af0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81108af4:	e0bfff17 	ldw	r2,-4(fp)
81108af8:	1080420b 	ldhu	r2,264(r2)
81108afc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81108b00:	e0fffe17 	ldw	r3,-8(fp)
81108b04:	1884b03a 	or	r2,r3,r2
81108b08:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81108b0c:	e0bffe17 	ldw	r2,-8(fp)
81108b10:	10bfffcc 	andi	r2,r2,65535
81108b14:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81108b18:	e0bfff17 	ldw	r2,-4(fp)
81108b1c:	10800017 	ldw	r2,0(r2)
81108b20:	e1bffe17 	ldw	r6,-8(fp)
81108b24:	01402f04 	movi	r5,188
81108b28:	1009883a 	mov	r4,r2
81108b2c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b30:	e0bfff17 	ldw	r2,-4(fp)
81108b34:	10800017 	ldw	r2,0(r2)
81108b38:	01402f44 	movi	r5,189
81108b3c:	1009883a 	mov	r4,r2
81108b40:	11096340 	call	81109634 <uliRmapReadReg>
81108b44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81108b48:	e0bffe17 	ldw	r2,-8(fp)
81108b4c:	10bfffec 	andhi	r2,r2,65535
81108b50:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
81108b54:	e0bfff17 	ldw	r2,-4(fp)
81108b58:	1080430b 	ldhu	r2,268(r2)
81108b5c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
81108b60:	e0fffe17 	ldw	r3,-8(fp)
81108b64:	1884b03a 	or	r2,r3,r2
81108b68:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
81108b6c:	e0bffe17 	ldw	r2,-8(fp)
81108b70:	10bfffcc 	andi	r2,r2,65535
81108b74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
81108b78:	e0bfff17 	ldw	r2,-4(fp)
81108b7c:	10800017 	ldw	r2,0(r2)
81108b80:	e1bffe17 	ldw	r6,-8(fp)
81108b84:	01402f44 	movi	r5,189
81108b88:	1009883a 	mov	r4,r2
81108b8c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b90:	e0bfff17 	ldw	r2,-4(fp)
81108b94:	10800017 	ldw	r2,0(r2)
81108b98:	01402f84 	movi	r5,190
81108b9c:	1009883a 	mov	r4,r2
81108ba0:	11096340 	call	81109634 <uliRmapReadReg>
81108ba4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
81108ba8:	e0bffe17 	ldw	r2,-8(fp)
81108bac:	10bfffec 	andhi	r2,r2,65535
81108bb0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81108bb4:	e0bfff17 	ldw	r2,-4(fp)
81108bb8:	1080440b 	ldhu	r2,272(r2)
81108bbc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81108bc0:	e0fffe17 	ldw	r3,-8(fp)
81108bc4:	1884b03a 	or	r2,r3,r2
81108bc8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81108bcc:	e0bffe17 	ldw	r2,-8(fp)
81108bd0:	10bfffcc 	andi	r2,r2,65535
81108bd4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81108bd8:	e0bfff17 	ldw	r2,-4(fp)
81108bdc:	10800017 	ldw	r2,0(r2)
81108be0:	e1bffe17 	ldw	r6,-8(fp)
81108be4:	01402f84 	movi	r5,190
81108be8:	1009883a 	mov	r4,r2
81108bec:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bf0:	e0bfff17 	ldw	r2,-4(fp)
81108bf4:	10800017 	ldw	r2,0(r2)
81108bf8:	01402fc4 	movi	r5,191
81108bfc:	1009883a 	mov	r4,r2
81108c00:	11096340 	call	81109634 <uliRmapReadReg>
81108c04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
81108c08:	e0bffe17 	ldw	r2,-8(fp)
81108c0c:	10bfffec 	andhi	r2,r2,65535
81108c10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
81108c14:	e0bfff17 	ldw	r2,-4(fp)
81108c18:	1080450b 	ldhu	r2,276(r2)
81108c1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
81108c20:	e0fffe17 	ldw	r3,-8(fp)
81108c24:	1884b03a 	or	r2,r3,r2
81108c28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
81108c2c:	e0bffe17 	ldw	r2,-8(fp)
81108c30:	10bfffcc 	andi	r2,r2,65535
81108c34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81108c38:	e0bfff17 	ldw	r2,-4(fp)
81108c3c:	10800017 	ldw	r2,0(r2)
81108c40:	e1bffe17 	ldw	r6,-8(fp)
81108c44:	01402fc4 	movi	r5,191
81108c48:	1009883a 	mov	r4,r2
81108c4c:	11095e00 	call	811095e0 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108c50:	00800044 	movi	r2,1
81108c54:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108c58:	e0bffd17 	ldw	r2,-12(fp)
}
81108c5c:	e037883a 	mov	sp,fp
81108c60:	dfc00117 	ldw	ra,4(sp)
81108c64:	df000017 	ldw	fp,0(sp)
81108c68:	dec00204 	addi	sp,sp,8
81108c6c:	f800283a 	ret

81108c70 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81108c70:	defffb04 	addi	sp,sp,-20
81108c74:	de00012e 	bgeu	sp,et,81108c7c <bRmapGetRmapMemHKArea+0xc>
81108c78:	003b68fa 	trap	3
81108c7c:	dfc00415 	stw	ra,16(sp)
81108c80:	df000315 	stw	fp,12(sp)
81108c84:	df000304 	addi	fp,sp,12
81108c88:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108c8c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108c90:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108c94:	e0bfff17 	ldw	r2,-4(fp)
81108c98:	1001e226 	beq	r2,zero,81109424 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c9c:	e0bfff17 	ldw	r2,-4(fp)
81108ca0:	10800017 	ldw	r2,0(r2)
81108ca4:	01402804 	movi	r5,160
81108ca8:	1009883a 	mov	r4,r2
81108cac:	11096340 	call	81109634 <uliRmapReadReg>
81108cb0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81108cb4:	e0bffe17 	ldw	r2,-8(fp)
81108cb8:	1007883a 	mov	r3,r2
81108cbc:	e0bfff17 	ldw	r2,-4(fp)
81108cc0:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
81108cc4:	e0bffe17 	ldw	r2,-8(fp)
81108cc8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81108ccc:	1007883a 	mov	r3,r2
81108cd0:	e0bfff17 	ldw	r2,-4(fp)
81108cd4:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108cd8:	e0bfff17 	ldw	r2,-4(fp)
81108cdc:	10800017 	ldw	r2,0(r2)
81108ce0:	01402844 	movi	r5,161
81108ce4:	1009883a 	mov	r4,r2
81108ce8:	11096340 	call	81109634 <uliRmapReadReg>
81108cec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81108cf0:	e0bffe17 	ldw	r2,-8(fp)
81108cf4:	1007883a 	mov	r3,r2
81108cf8:	e0bfff17 	ldw	r2,-4(fp)
81108cfc:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
81108d00:	e0bffe17 	ldw	r2,-8(fp)
81108d04:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
81108d08:	1007883a 	mov	r3,r2
81108d0c:	e0bfff17 	ldw	r2,-4(fp)
81108d10:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d14:	e0bfff17 	ldw	r2,-4(fp)
81108d18:	10800017 	ldw	r2,0(r2)
81108d1c:	01402884 	movi	r5,162
81108d20:	1009883a 	mov	r4,r2
81108d24:	11096340 	call	81109634 <uliRmapReadReg>
81108d28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
81108d2c:	e0bffe17 	ldw	r2,-8(fp)
81108d30:	1007883a 	mov	r3,r2
81108d34:	e0bfff17 	ldw	r2,-4(fp)
81108d38:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81108d3c:	e0bffe17 	ldw	r2,-8(fp)
81108d40:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
81108d44:	1007883a 	mov	r3,r2
81108d48:	e0bfff17 	ldw	r2,-4(fp)
81108d4c:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d50:	e0bfff17 	ldw	r2,-4(fp)
81108d54:	10800017 	ldw	r2,0(r2)
81108d58:	014028c4 	movi	r5,163
81108d5c:	1009883a 	mov	r4,r2
81108d60:	11096340 	call	81109634 <uliRmapReadReg>
81108d64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
81108d68:	e0bffe17 	ldw	r2,-8(fp)
81108d6c:	1007883a 	mov	r3,r2
81108d70:	e0bfff17 	ldw	r2,-4(fp)
81108d74:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81108d78:	e0bffe17 	ldw	r2,-8(fp)
81108d7c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81108d80:	1007883a 	mov	r3,r2
81108d84:	e0bfff17 	ldw	r2,-4(fp)
81108d88:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d8c:	e0bfff17 	ldw	r2,-4(fp)
81108d90:	10800017 	ldw	r2,0(r2)
81108d94:	01402904 	movi	r5,164
81108d98:	1009883a 	mov	r4,r2
81108d9c:	11096340 	call	81109634 <uliRmapReadReg>
81108da0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81108da4:	e0bffe17 	ldw	r2,-8(fp)
81108da8:	1007883a 	mov	r3,r2
81108dac:	e0bfff17 	ldw	r2,-4(fp)
81108db0:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81108db4:	e0bffe17 	ldw	r2,-8(fp)
81108db8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81108dbc:	1007883a 	mov	r3,r2
81108dc0:	e0bfff17 	ldw	r2,-4(fp)
81108dc4:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108dc8:	e0bfff17 	ldw	r2,-4(fp)
81108dcc:	10800017 	ldw	r2,0(r2)
81108dd0:	01402944 	movi	r5,165
81108dd4:	1009883a 	mov	r4,r2
81108dd8:	11096340 	call	81109634 <uliRmapReadReg>
81108ddc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81108de0:	e0bffe17 	ldw	r2,-8(fp)
81108de4:	1007883a 	mov	r3,r2
81108de8:	e0bfff17 	ldw	r2,-4(fp)
81108dec:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81108df0:	e0bffe17 	ldw	r2,-8(fp)
81108df4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
81108df8:	1007883a 	mov	r3,r2
81108dfc:	e0bfff17 	ldw	r2,-4(fp)
81108e00:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e04:	e0bfff17 	ldw	r2,-4(fp)
81108e08:	10800017 	ldw	r2,0(r2)
81108e0c:	01402984 	movi	r5,166
81108e10:	1009883a 	mov	r4,r2
81108e14:	11096340 	call	81109634 <uliRmapReadReg>
81108e18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
81108e1c:	e0bffe17 	ldw	r2,-8(fp)
81108e20:	1007883a 	mov	r3,r2
81108e24:	e0bfff17 	ldw	r2,-4(fp)
81108e28:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
81108e2c:	e0bffe17 	ldw	r2,-8(fp)
81108e30:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
81108e34:	1007883a 	mov	r3,r2
81108e38:	e0bfff17 	ldw	r2,-4(fp)
81108e3c:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e40:	e0bfff17 	ldw	r2,-4(fp)
81108e44:	10800017 	ldw	r2,0(r2)
81108e48:	014029c4 	movi	r5,167
81108e4c:	1009883a 	mov	r4,r2
81108e50:	11096340 	call	81109634 <uliRmapReadReg>
81108e54:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
81108e58:	e0bffe17 	ldw	r2,-8(fp)
81108e5c:	1007883a 	mov	r3,r2
81108e60:	e0bfff17 	ldw	r2,-4(fp)
81108e64:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
81108e68:	e0bffe17 	ldw	r2,-8(fp)
81108e6c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81108e70:	1007883a 	mov	r3,r2
81108e74:	e0bfff17 	ldw	r2,-4(fp)
81108e78:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e7c:	e0bfff17 	ldw	r2,-4(fp)
81108e80:	10800017 	ldw	r2,0(r2)
81108e84:	01402a04 	movi	r5,168
81108e88:	1009883a 	mov	r4,r2
81108e8c:	11096340 	call	81109634 <uliRmapReadReg>
81108e90:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81108e94:	e0bffe17 	ldw	r2,-8(fp)
81108e98:	1007883a 	mov	r3,r2
81108e9c:	e0bfff17 	ldw	r2,-4(fp)
81108ea0:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81108ea4:	e0bffe17 	ldw	r2,-8(fp)
81108ea8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81108eac:	1007883a 	mov	r3,r2
81108eb0:	e0bfff17 	ldw	r2,-4(fp)
81108eb4:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108eb8:	e0bfff17 	ldw	r2,-4(fp)
81108ebc:	10800017 	ldw	r2,0(r2)
81108ec0:	01402a44 	movi	r5,169
81108ec4:	1009883a 	mov	r4,r2
81108ec8:	11096340 	call	81109634 <uliRmapReadReg>
81108ecc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81108ed0:	e0bffe17 	ldw	r2,-8(fp)
81108ed4:	1007883a 	mov	r3,r2
81108ed8:	e0bfff17 	ldw	r2,-4(fp)
81108edc:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81108ee0:	e0bffe17 	ldw	r2,-8(fp)
81108ee4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
81108ee8:	1007883a 	mov	r3,r2
81108eec:	e0bfff17 	ldw	r2,-4(fp)
81108ef0:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ef4:	e0bfff17 	ldw	r2,-4(fp)
81108ef8:	10800017 	ldw	r2,0(r2)
81108efc:	01402a84 	movi	r5,170
81108f00:	1009883a 	mov	r4,r2
81108f04:	11096340 	call	81109634 <uliRmapReadReg>
81108f08:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
81108f0c:	e0bffe17 	ldw	r2,-8(fp)
81108f10:	1007883a 	mov	r3,r2
81108f14:	e0bfff17 	ldw	r2,-4(fp)
81108f18:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
81108f1c:	e0bffe17 	ldw	r2,-8(fp)
81108f20:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
81108f24:	1007883a 	mov	r3,r2
81108f28:	e0bfff17 	ldw	r2,-4(fp)
81108f2c:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f30:	e0bfff17 	ldw	r2,-4(fp)
81108f34:	10800017 	ldw	r2,0(r2)
81108f38:	01402ac4 	movi	r5,171
81108f3c:	1009883a 	mov	r4,r2
81108f40:	11096340 	call	81109634 <uliRmapReadReg>
81108f44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
81108f48:	e0bffe17 	ldw	r2,-8(fp)
81108f4c:	1007883a 	mov	r3,r2
81108f50:	e0bfff17 	ldw	r2,-4(fp)
81108f54:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
81108f58:	e0bffe17 	ldw	r2,-8(fp)
81108f5c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81108f60:	1007883a 	mov	r3,r2
81108f64:	e0bfff17 	ldw	r2,-4(fp)
81108f68:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f6c:	e0bfff17 	ldw	r2,-4(fp)
81108f70:	10800017 	ldw	r2,0(r2)
81108f74:	01402b04 	movi	r5,172
81108f78:	1009883a 	mov	r4,r2
81108f7c:	11096340 	call	81109634 <uliRmapReadReg>
81108f80:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81108f84:	e0bffe17 	ldw	r2,-8(fp)
81108f88:	1007883a 	mov	r3,r2
81108f8c:	e0bfff17 	ldw	r2,-4(fp)
81108f90:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81108f94:	e0bffe17 	ldw	r2,-8(fp)
81108f98:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81108f9c:	1007883a 	mov	r3,r2
81108fa0:	e0bfff17 	ldw	r2,-4(fp)
81108fa4:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108fa8:	e0bfff17 	ldw	r2,-4(fp)
81108fac:	10800017 	ldw	r2,0(r2)
81108fb0:	01402b44 	movi	r5,173
81108fb4:	1009883a 	mov	r4,r2
81108fb8:	11096340 	call	81109634 <uliRmapReadReg>
81108fbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81108fc0:	e0bffe17 	ldw	r2,-8(fp)
81108fc4:	1007883a 	mov	r3,r2
81108fc8:	e0bfff17 	ldw	r2,-4(fp)
81108fcc:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81108fd0:	e0bffe17 	ldw	r2,-8(fp)
81108fd4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
81108fd8:	1007883a 	mov	r3,r2
81108fdc:	e0bfff17 	ldw	r2,-4(fp)
81108fe0:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108fe4:	e0bfff17 	ldw	r2,-4(fp)
81108fe8:	10800017 	ldw	r2,0(r2)
81108fec:	01402b84 	movi	r5,174
81108ff0:	1009883a 	mov	r4,r2
81108ff4:	11096340 	call	81109634 <uliRmapReadReg>
81108ff8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
81108ffc:	e0bffe17 	ldw	r2,-8(fp)
81109000:	1007883a 	mov	r3,r2
81109004:	e0bfff17 	ldw	r2,-4(fp)
81109008:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
8110900c:	e0bffe17 	ldw	r2,-8(fp)
81109010:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
81109014:	1007883a 	mov	r3,r2
81109018:	e0bfff17 	ldw	r2,-4(fp)
8110901c:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109020:	e0bfff17 	ldw	r2,-4(fp)
81109024:	10800017 	ldw	r2,0(r2)
81109028:	01402bc4 	movi	r5,175
8110902c:	1009883a 	mov	r4,r2
81109030:	11096340 	call	81109634 <uliRmapReadReg>
81109034:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81109038:	e0bffe17 	ldw	r2,-8(fp)
8110903c:	1007883a 	mov	r3,r2
81109040:	e0bfff17 	ldw	r2,-4(fp)
81109044:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81109048:	e0bffe17 	ldw	r2,-8(fp)
8110904c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81109050:	1007883a 	mov	r3,r2
81109054:	e0bfff17 	ldw	r2,-4(fp)
81109058:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110905c:	e0bfff17 	ldw	r2,-4(fp)
81109060:	10800017 	ldw	r2,0(r2)
81109064:	01402c04 	movi	r5,176
81109068:	1009883a 	mov	r4,r2
8110906c:	11096340 	call	81109634 <uliRmapReadReg>
81109070:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81109074:	e0bffe17 	ldw	r2,-8(fp)
81109078:	1007883a 	mov	r3,r2
8110907c:	e0bfff17 	ldw	r2,-4(fp)
81109080:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81109084:	e0bffe17 	ldw	r2,-8(fp)
81109088:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
8110908c:	1007883a 	mov	r3,r2
81109090:	e0bfff17 	ldw	r2,-4(fp)
81109094:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109098:	e0bfff17 	ldw	r2,-4(fp)
8110909c:	10800017 	ldw	r2,0(r2)
811090a0:	01402c44 	movi	r5,177
811090a4:	1009883a 	mov	r4,r2
811090a8:	11096340 	call	81109634 <uliRmapReadReg>
811090ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
811090b0:	e0bffe17 	ldw	r2,-8(fp)
811090b4:	1007883a 	mov	r3,r2
811090b8:	e0bfff17 	ldw	r2,-4(fp)
811090bc:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
811090c0:	e0bffe17 	ldw	r2,-8(fp)
811090c4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
811090c8:	1007883a 	mov	r3,r2
811090cc:	e0bfff17 	ldw	r2,-4(fp)
811090d0:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811090d4:	e0bfff17 	ldw	r2,-4(fp)
811090d8:	10800017 	ldw	r2,0(r2)
811090dc:	01402c84 	movi	r5,178
811090e0:	1009883a 	mov	r4,r2
811090e4:	11096340 	call	81109634 <uliRmapReadReg>
811090e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
811090ec:	e0bffe17 	ldw	r2,-8(fp)
811090f0:	1007883a 	mov	r3,r2
811090f4:	e0bfff17 	ldw	r2,-4(fp)
811090f8:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
811090fc:	e0bffe17 	ldw	r2,-8(fp)
81109100:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
81109104:	1007883a 	mov	r3,r2
81109108:	e0bfff17 	ldw	r2,-4(fp)
8110910c:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109110:	e0bfff17 	ldw	r2,-4(fp)
81109114:	10800017 	ldw	r2,0(r2)
81109118:	01402cc4 	movi	r5,179
8110911c:	1009883a 	mov	r4,r2
81109120:	11096340 	call	81109634 <uliRmapReadReg>
81109124:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81109128:	e0bffe17 	ldw	r2,-8(fp)
8110912c:	1007883a 	mov	r3,r2
81109130:	e0bfff17 	ldw	r2,-4(fp)
81109134:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81109138:	e0bffe17 	ldw	r2,-8(fp)
8110913c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81109140:	1007883a 	mov	r3,r2
81109144:	e0bfff17 	ldw	r2,-4(fp)
81109148:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110914c:	e0bfff17 	ldw	r2,-4(fp)
81109150:	10800017 	ldw	r2,0(r2)
81109154:	01402d04 	movi	r5,180
81109158:	1009883a 	mov	r4,r2
8110915c:	11096340 	call	81109634 <uliRmapReadReg>
81109160:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81109164:	e0bffe17 	ldw	r2,-8(fp)
81109168:	1007883a 	mov	r3,r2
8110916c:	e0bfff17 	ldw	r2,-4(fp)
81109170:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81109174:	e0bffe17 	ldw	r2,-8(fp)
81109178:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
8110917c:	1007883a 	mov	r3,r2
81109180:	e0bfff17 	ldw	r2,-4(fp)
81109184:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109188:	e0bfff17 	ldw	r2,-4(fp)
8110918c:	10800017 	ldw	r2,0(r2)
81109190:	01402d44 	movi	r5,181
81109194:	1009883a 	mov	r4,r2
81109198:	11096340 	call	81109634 <uliRmapReadReg>
8110919c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
811091a0:	e0bffe17 	ldw	r2,-8(fp)
811091a4:	1007883a 	mov	r3,r2
811091a8:	e0bfff17 	ldw	r2,-4(fp)
811091ac:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
811091b0:	e0bffe17 	ldw	r2,-8(fp)
811091b4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
811091b8:	1007883a 	mov	r3,r2
811091bc:	e0bfff17 	ldw	r2,-4(fp)
811091c0:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811091c4:	e0bfff17 	ldw	r2,-4(fp)
811091c8:	10800017 	ldw	r2,0(r2)
811091cc:	01402d84 	movi	r5,182
811091d0:	1009883a 	mov	r4,r2
811091d4:	11096340 	call	81109634 <uliRmapReadReg>
811091d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
811091dc:	e0bffe17 	ldw	r2,-8(fp)
811091e0:	1007883a 	mov	r3,r2
811091e4:	e0bfff17 	ldw	r2,-4(fp)
811091e8:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
811091ec:	e0bffe17 	ldw	r2,-8(fp)
811091f0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
811091f4:	1007883a 	mov	r3,r2
811091f8:	e0bfff17 	ldw	r2,-4(fp)
811091fc:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109200:	e0bfff17 	ldw	r2,-4(fp)
81109204:	10800017 	ldw	r2,0(r2)
81109208:	01402dc4 	movi	r5,183
8110920c:	1009883a 	mov	r4,r2
81109210:	11096340 	call	81109634 <uliRmapReadReg>
81109214:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81109218:	e0bffe17 	ldw	r2,-8(fp)
8110921c:	1007883a 	mov	r3,r2
81109220:	e0bfff17 	ldw	r2,-4(fp)
81109224:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81109228:	e0bffe17 	ldw	r2,-8(fp)
8110922c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81109230:	1007883a 	mov	r3,r2
81109234:	e0bfff17 	ldw	r2,-4(fp)
81109238:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110923c:	e0bfff17 	ldw	r2,-4(fp)
81109240:	10800017 	ldw	r2,0(r2)
81109244:	01402e04 	movi	r5,184
81109248:	1009883a 	mov	r4,r2
8110924c:	11096340 	call	81109634 <uliRmapReadReg>
81109250:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81109254:	e0bffe17 	ldw	r2,-8(fp)
81109258:	1007883a 	mov	r3,r2
8110925c:	e0bfff17 	ldw	r2,-4(fp)
81109260:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81109264:	e0bffe17 	ldw	r2,-8(fp)
81109268:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
8110926c:	1007883a 	mov	r3,r2
81109270:	e0bfff17 	ldw	r2,-4(fp)
81109274:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109278:	e0bfff17 	ldw	r2,-4(fp)
8110927c:	10800017 	ldw	r2,0(r2)
81109280:	01402e44 	movi	r5,185
81109284:	1009883a 	mov	r4,r2
81109288:	11096340 	call	81109634 <uliRmapReadReg>
8110928c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81109290:	e0bffe17 	ldw	r2,-8(fp)
81109294:	1007883a 	mov	r3,r2
81109298:	e0bfff17 	ldw	r2,-4(fp)
8110929c:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
811092a0:	e0bffe17 	ldw	r2,-8(fp)
811092a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
811092a8:	1007883a 	mov	r3,r2
811092ac:	e0bfff17 	ldw	r2,-4(fp)
811092b0:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092b4:	e0bfff17 	ldw	r2,-4(fp)
811092b8:	10800017 	ldw	r2,0(r2)
811092bc:	01402e84 	movi	r5,186
811092c0:	1009883a 	mov	r4,r2
811092c4:	11096340 	call	81109634 <uliRmapReadReg>
811092c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
811092cc:	e0bffe17 	ldw	r2,-8(fp)
811092d0:	1007883a 	mov	r3,r2
811092d4:	e0bfff17 	ldw	r2,-4(fp)
811092d8:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
811092dc:	e0bffe17 	ldw	r2,-8(fp)
811092e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
811092e4:	1007883a 	mov	r3,r2
811092e8:	e0bfff17 	ldw	r2,-4(fp)
811092ec:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092f0:	e0bfff17 	ldw	r2,-4(fp)
811092f4:	10800017 	ldw	r2,0(r2)
811092f8:	01402ec4 	movi	r5,187
811092fc:	1009883a 	mov	r4,r2
81109300:	11096340 	call	81109634 <uliRmapReadReg>
81109304:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81109308:	e0bffe17 	ldw	r2,-8(fp)
8110930c:	1007883a 	mov	r3,r2
81109310:	e0bfff17 	ldw	r2,-4(fp)
81109314:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81109318:	e0bffe17 	ldw	r2,-8(fp)
8110931c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81109320:	1007883a 	mov	r3,r2
81109324:	e0bfff17 	ldw	r2,-4(fp)
81109328:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110932c:	e0bfff17 	ldw	r2,-4(fp)
81109330:	10800017 	ldw	r2,0(r2)
81109334:	01402f04 	movi	r5,188
81109338:	1009883a 	mov	r4,r2
8110933c:	11096340 	call	81109634 <uliRmapReadReg>
81109340:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81109344:	e0bffe17 	ldw	r2,-8(fp)
81109348:	1007883a 	mov	r3,r2
8110934c:	e0bfff17 	ldw	r2,-4(fp)
81109350:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81109354:	e0bffe17 	ldw	r2,-8(fp)
81109358:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
8110935c:	1007883a 	mov	r3,r2
81109360:	e0bfff17 	ldw	r2,-4(fp)
81109364:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109368:	e0bfff17 	ldw	r2,-4(fp)
8110936c:	10800017 	ldw	r2,0(r2)
81109370:	01402f44 	movi	r5,189
81109374:	1009883a 	mov	r4,r2
81109378:	11096340 	call	81109634 <uliRmapReadReg>
8110937c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81109380:	e0bffe17 	ldw	r2,-8(fp)
81109384:	1007883a 	mov	r3,r2
81109388:	e0bfff17 	ldw	r2,-4(fp)
8110938c:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81109390:	e0bffe17 	ldw	r2,-8(fp)
81109394:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81109398:	1007883a 	mov	r3,r2
8110939c:	e0bfff17 	ldw	r2,-4(fp)
811093a0:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093a4:	e0bfff17 	ldw	r2,-4(fp)
811093a8:	10800017 	ldw	r2,0(r2)
811093ac:	01402f84 	movi	r5,190
811093b0:	1009883a 	mov	r4,r2
811093b4:	11096340 	call	81109634 <uliRmapReadReg>
811093b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
811093bc:	e0bffe17 	ldw	r2,-8(fp)
811093c0:	1007883a 	mov	r3,r2
811093c4:	e0bfff17 	ldw	r2,-4(fp)
811093c8:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
811093cc:	e0bffe17 	ldw	r2,-8(fp)
811093d0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
811093d4:	1007883a 	mov	r3,r2
811093d8:	e0bfff17 	ldw	r2,-4(fp)
811093dc:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093e0:	e0bfff17 	ldw	r2,-4(fp)
811093e4:	10800017 	ldw	r2,0(r2)
811093e8:	01402fc4 	movi	r5,191
811093ec:	1009883a 	mov	r4,r2
811093f0:	11096340 	call	81109634 <uliRmapReadReg>
811093f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
811093f8:	e0bffe17 	ldw	r2,-8(fp)
811093fc:	1007883a 	mov	r3,r2
81109400:	e0bfff17 	ldw	r2,-4(fp)
81109404:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81109408:	e0bffe17 	ldw	r2,-8(fp)
8110940c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81109410:	1007883a 	mov	r3,r2
81109414:	e0bfff17 	ldw	r2,-4(fp)
81109418:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
8110941c:	00800044 	movi	r2,1
81109420:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109424:	e0bffd17 	ldw	r2,-12(fp)
}
81109428:	e037883a 	mov	sp,fp
8110942c:	dfc00117 	ldw	ra,4(sp)
81109430:	df000017 	ldw	fp,0(sp)
81109434:	dec00204 	addi	sp,sp,8
81109438:	f800283a 	ret

8110943c <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
8110943c:	defffb04 	addi	sp,sp,-20
81109440:	de00012e 	bgeu	sp,et,81109448 <bRmapInitCh+0xc>
81109444:	003b68fa 	trap	3
81109448:	dfc00415 	stw	ra,16(sp)
8110944c:	df000315 	stw	fp,12(sp)
81109450:	df000304 	addi	fp,sp,12
81109454:	e13ffe15 	stw	r4,-8(fp)
81109458:	2805883a 	mov	r2,r5
8110945c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109460:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81109464:	e0bffe17 	ldw	r2,-8(fp)
81109468:	10005726 	beq	r2,zero,811095c8 <bRmapInitCh+0x18c>
		bStatus = TRUE;
8110946c:	00800044 	movi	r2,1
81109470:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109474:	e0bfff03 	ldbu	r2,-4(fp)
81109478:	10c00228 	cmpgeui	r3,r2,8
8110947c:	1800361e 	bne	r3,zero,81109558 <bRmapInitCh+0x11c>
81109480:	100690ba 	slli	r3,r2,2
81109484:	00a04474 	movhi	r2,33041
81109488:	10a52604 	addi	r2,r2,-27496
8110948c:	1885883a 	add	r2,r3,r2
81109490:	10800017 	ldw	r2,0(r2)
81109494:	1000683a 	jmp	r2
81109498:	811094b8 	rdprs	r4,r16,16978
8110949c:	811094cc 	andi	r4,r16,16979
811094a0:	811094e0 	cmpeqi	r4,r16,16979
811094a4:	811094f4 	orhi	r4,r16,16979
811094a8:	81109508 	cmpgei	r4,r16,16980
811094ac:	8110951c 	xori	r4,r16,16980
811094b0:	81109530 	cmpltui	r4,r16,16980
811094b4:	81109544 	addi	r4,r16,16981
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811094b8:	e0fffe17 	ldw	r3,-8(fp)
811094bc:	00a04834 	movhi	r2,33056
811094c0:	108b0004 	addi	r2,r2,11264
811094c4:	18800015 	stw	r2,0(r3)
			break;
811094c8:	00002506 	br	81109560 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811094cc:	e0fffe17 	ldw	r3,-8(fp)
811094d0:	00a04834 	movhi	r2,33056
811094d4:	108a0004 	addi	r2,r2,10240
811094d8:	18800015 	stw	r2,0(r3)
			break;
811094dc:	00002006 	br	81109560 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811094e0:	e0fffe17 	ldw	r3,-8(fp)
811094e4:	00a04834 	movhi	r2,33056
811094e8:	10890004 	addi	r2,r2,9216
811094ec:	18800015 	stw	r2,0(r3)
			break;
811094f0:	00001b06 	br	81109560 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811094f4:	e0fffe17 	ldw	r3,-8(fp)
811094f8:	00a04834 	movhi	r2,33056
811094fc:	10880004 	addi	r2,r2,8192
81109500:	18800015 	stw	r2,0(r3)
			break;
81109504:	00001606 	br	81109560 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109508:	e0fffe17 	ldw	r3,-8(fp)
8110950c:	00a04834 	movhi	r2,33056
81109510:	10870004 	addi	r2,r2,7168
81109514:	18800015 	stw	r2,0(r3)
			break;
81109518:	00001106 	br	81109560 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110951c:	e0fffe17 	ldw	r3,-8(fp)
81109520:	00a04834 	movhi	r2,33056
81109524:	10860004 	addi	r2,r2,6144
81109528:	18800015 	stw	r2,0(r3)
			break;
8110952c:	00000c06 	br	81109560 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109530:	e0fffe17 	ldw	r3,-8(fp)
81109534:	00a04834 	movhi	r2,33056
81109538:	10850004 	addi	r2,r2,5120
8110953c:	18800015 	stw	r2,0(r3)
			break;
81109540:	00000706 	br	81109560 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109544:	e0fffe17 	ldw	r3,-8(fp)
81109548:	00a04834 	movhi	r2,33056
8110954c:	10840004 	addi	r2,r2,4096
81109550:	18800015 	stw	r2,0(r3)
			break;
81109554:	00000206 	br	81109560 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81109558:	e03ffd15 	stw	zero,-12(fp)
			break;
8110955c:	0001883a 	nop
		}

		if (bStatus) {
81109560:	e0bffd17 	ldw	r2,-12(fp)
81109564:	10001826 	beq	r2,zero,811095c8 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81109568:	e13ffe17 	ldw	r4,-8(fp)
8110956c:	110749c0 	call	8110749c <bRmapGetIrqControl>
81109570:	1000011e 	bne	r2,zero,81109578 <bRmapInitCh+0x13c>
				bStatus = FALSE;
81109574:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81109578:	e13ffe17 	ldw	r4,-8(fp)
8110957c:	11076840 	call	81107684 <bRmapGetCodecConfig>
81109580:	1000011e 	bne	r2,zero,81109588 <bRmapInitCh+0x14c>
				bStatus = FALSE;
81109584:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81109588:	e13ffe17 	ldw	r4,-8(fp)
8110958c:	11077100 	call	81107710 <bRmapGetCodecStatus>
81109590:	1000011e 	bne	r2,zero,81109598 <bRmapInitCh+0x15c>
				bStatus = FALSE;
81109594:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81109598:	e13ffe17 	ldw	r4,-8(fp)
8110959c:	1107cbc0 	call	81107cbc <bRmapGetMemConfigArea>
811095a0:	1000011e 	bne	r2,zero,811095a8 <bRmapInitCh+0x16c>
				bStatus = FALSE;
811095a4:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
811095a8:	e13ffe17 	ldw	r4,-8(fp)
811095ac:	1107f900 	call	81107f90 <bRmapGetMemConfigStat>
811095b0:	1000011e 	bne	r2,zero,811095b8 <bRmapInitCh+0x17c>
				bStatus = FALSE;
811095b4:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
811095b8:	e13ffe17 	ldw	r4,-8(fp)
811095bc:	1108c700 	call	81108c70 <bRmapGetRmapMemHKArea>
811095c0:	1000011e 	bne	r2,zero,811095c8 <bRmapInitCh+0x18c>
				bStatus = FALSE;
811095c4:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
811095c8:	e0bffd17 	ldw	r2,-12(fp)
}
811095cc:	e037883a 	mov	sp,fp
811095d0:	dfc00117 	ldw	ra,4(sp)
811095d4:	df000017 	ldw	fp,0(sp)
811095d8:	dec00204 	addi	sp,sp,8
811095dc:	f800283a 	ret

811095e0 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811095e0:	defffc04 	addi	sp,sp,-16
811095e4:	de00012e 	bgeu	sp,et,811095ec <vRmapWriteReg+0xc>
811095e8:	003b68fa 	trap	3
811095ec:	df000315 	stw	fp,12(sp)
811095f0:	df000304 	addi	fp,sp,12
811095f4:	e13ffd15 	stw	r4,-12(fp)
811095f8:	e17ffe15 	stw	r5,-8(fp)
811095fc:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109600:	e0bffe17 	ldw	r2,-8(fp)
81109604:	1085883a 	add	r2,r2,r2
81109608:	1085883a 	add	r2,r2,r2
8110960c:	1007883a 	mov	r3,r2
81109610:	e0bffd17 	ldw	r2,-12(fp)
81109614:	10c5883a 	add	r2,r2,r3
81109618:	e0ffff17 	ldw	r3,-4(fp)
8110961c:	10c00015 	stw	r3,0(r2)
}
81109620:	0001883a 	nop
81109624:	e037883a 	mov	sp,fp
81109628:	df000017 	ldw	fp,0(sp)
8110962c:	dec00104 	addi	sp,sp,4
81109630:	f800283a 	ret

81109634 <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109634:	defffc04 	addi	sp,sp,-16
81109638:	de00012e 	bgeu	sp,et,81109640 <uliRmapReadReg+0xc>
8110963c:	003b68fa 	trap	3
81109640:	df000315 	stw	fp,12(sp)
81109644:	df000304 	addi	fp,sp,12
81109648:	e13ffe15 	stw	r4,-8(fp)
8110964c:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109650:	e0bfff17 	ldw	r2,-4(fp)
81109654:	1085883a 	add	r2,r2,r2
81109658:	1085883a 	add	r2,r2,r2
8110965c:	1007883a 	mov	r3,r2
81109660:	e0bffe17 	ldw	r2,-8(fp)
81109664:	10c5883a 	add	r2,r2,r3
81109668:	10800017 	ldw	r2,0(r2)
8110966c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109670:	e0bffd17 	ldw	r2,-12(fp)
}
81109674:	e037883a 	mov	sp,fp
81109678:	df000017 	ldw	fp,0(sp)
8110967c:	dec00104 	addi	sp,sp,4
81109680:	f800283a 	ret

81109684 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81109684:	defffd04 	addi	sp,sp,-12
81109688:	de00012e 	bgeu	sp,et,81109690 <uliConvRmapCfgAddr+0xc>
8110968c:	003b68fa 	trap	3
81109690:	df000215 	stw	fp,8(sp)
81109694:	df000204 	addi	fp,sp,8
81109698:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr-3) {
8110969c:	e0bfff17 	ldw	r2,-4(fp)
811096a0:	10bfff44 	addi	r2,r2,-3
811096a4:	10c01368 	cmpgeui	r3,r2,77
811096a8:	1800891e 	bne	r3,zero,811098d0 <uliConvRmapCfgAddr+0x24c>
811096ac:	100690ba 	slli	r3,r2,2
811096b0:	00a04474 	movhi	r2,33041
811096b4:	10a5b104 	addi	r2,r2,-26940
811096b8:	1885883a 	add	r2,r3,r2
811096bc:	10800017 	ldw	r2,0(r2)
811096c0:	1000683a 	jmp	r2
811096c4:	811097f8 	rdprs	r4,r16,16991
811096c8:	811098d0 	cmplti	r4,r16,16995
811096cc:	811098d0 	cmplti	r4,r16,16995
811096d0:	811098d0 	cmplti	r4,r16,16995
811096d4:	81109804 	addi	r4,r16,16992
811096d8:	811098d0 	cmplti	r4,r16,16995
811096dc:	811098d0 	cmplti	r4,r16,16995
811096e0:	811098d0 	cmplti	r4,r16,16995
811096e4:	81109810 	cmplti	r4,r16,16992
811096e8:	811098d0 	cmplti	r4,r16,16995
811096ec:	811098d0 	cmplti	r4,r16,16995
811096f0:	811098d0 	cmplti	r4,r16,16995
811096f4:	8110981c 	xori	r4,r16,16992
811096f8:	811098d0 	cmplti	r4,r16,16995
811096fc:	811098d0 	cmplti	r4,r16,16995
81109700:	811098d0 	cmplti	r4,r16,16995
81109704:	81109828 	cmpgeui	r4,r16,16992
81109708:	811098d0 	cmplti	r4,r16,16995
8110970c:	811098d0 	cmplti	r4,r16,16995
81109710:	811098d0 	cmplti	r4,r16,16995
81109714:	81109834 	orhi	r4,r16,16992
81109718:	811098d0 	cmplti	r4,r16,16995
8110971c:	811098d0 	cmplti	r4,r16,16995
81109720:	811098d0 	cmplti	r4,r16,16995
81109724:	81109840 	call	88110984 <__reset+0x20f0984>
81109728:	811098d0 	cmplti	r4,r16,16995
8110972c:	811098d0 	cmplti	r4,r16,16995
81109730:	811098d0 	cmplti	r4,r16,16995
81109734:	8110984c 	andi	r4,r16,16993
81109738:	811098d0 	cmplti	r4,r16,16995
8110973c:	811098d0 	cmplti	r4,r16,16995
81109740:	811098d0 	cmplti	r4,r16,16995
81109744:	81109858 	cmpnei	r4,r16,16993
81109748:	811098d0 	cmplti	r4,r16,16995
8110974c:	811098d0 	cmplti	r4,r16,16995
81109750:	811098d0 	cmplti	r4,r16,16995
81109754:	81109864 	muli	r4,r16,16993
81109758:	811098d0 	cmplti	r4,r16,16995
8110975c:	811098d0 	cmplti	r4,r16,16995
81109760:	811098d0 	cmplti	r4,r16,16995
81109764:	81109870 	cmpltui	r4,r16,16993
81109768:	811098d0 	cmplti	r4,r16,16995
8110976c:	811098d0 	cmplti	r4,r16,16995
81109770:	811098d0 	cmplti	r4,r16,16995
81109774:	8110987c 	xorhi	r4,r16,16993
81109778:	811098d0 	cmplti	r4,r16,16995
8110977c:	811098d0 	cmplti	r4,r16,16995
81109780:	811098d0 	cmplti	r4,r16,16995
81109784:	811098d0 	cmplti	r4,r16,16995
81109788:	811098d0 	cmplti	r4,r16,16995
8110978c:	811098d0 	cmplti	r4,r16,16995
81109790:	811098d0 	cmplti	r4,r16,16995
81109794:	811098d0 	cmplti	r4,r16,16995
81109798:	811098d0 	cmplti	r4,r16,16995
8110979c:	811098d0 	cmplti	r4,r16,16995
811097a0:	811098d0 	cmplti	r4,r16,16995
811097a4:	81109888 	cmpgei	r4,r16,16994
811097a8:	811098d0 	cmplti	r4,r16,16995
811097ac:	811098d0 	cmplti	r4,r16,16995
811097b0:	811098d0 	cmplti	r4,r16,16995
811097b4:	81109894 	ori	r4,r16,16994
811097b8:	811098d0 	cmplti	r4,r16,16995
811097bc:	811098d0 	cmplti	r4,r16,16995
811097c0:	811098d0 	cmplti	r4,r16,16995
811097c4:	811098a0 	cmpeqi	r4,r16,16994
811097c8:	811098d0 	cmplti	r4,r16,16995
811097cc:	811098d0 	cmplti	r4,r16,16995
811097d0:	811098d0 	cmplti	r4,r16,16995
811097d4:	811098ac 	andhi	r4,r16,16994
811097d8:	811098d0 	cmplti	r4,r16,16995
811097dc:	811098d0 	cmplti	r4,r16,16995
811097e0:	811098d0 	cmplti	r4,r16,16995
811097e4:	811098b8 	rdprs	r4,r16,16994
811097e8:	811098d0 	cmplti	r4,r16,16995
811097ec:	811098d0 	cmplti	r4,r16,16995
811097f0:	811098d0 	cmplti	r4,r16,16995
811097f4:	811098c4 	addi	r4,r16,16995
	case 0x00000000:
		uliValue = 0x00000040;
811097f8:	00801004 	movi	r2,64
811097fc:	e0bffe15 	stw	r2,-8(fp)
		break;
81109800:	00003506 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
81109804:	00801044 	movi	r2,65
81109808:	e0bffe15 	stw	r2,-8(fp)
		break;
8110980c:	00003206 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81109810:	00801084 	movi	r2,66
81109814:	e0bffe15 	stw	r2,-8(fp)
		break;
81109818:	00002f06 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
8110981c:	008010c4 	movi	r2,67
81109820:	e0bffe15 	stw	r2,-8(fp)
		break;
81109824:	00002c06 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
81109828:	00801104 	movi	r2,68
8110982c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109830:	00002906 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
81109834:	00801144 	movi	r2,69
81109838:	e0bffe15 	stw	r2,-8(fp)
		break;
8110983c:	00002606 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
81109840:	00801184 	movi	r2,70
81109844:	e0bffe15 	stw	r2,-8(fp)
		break;
81109848:	00002306 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110984c:	008011c4 	movi	r2,71
81109850:	e0bffe15 	stw	r2,-8(fp)
		break;
81109854:	00002006 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
81109858:	00801204 	movi	r2,72
8110985c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109860:	00001d06 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
81109864:	00801244 	movi	r2,73
81109868:	e0bffe15 	stw	r2,-8(fp)
		break;
8110986c:	00001a06 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
81109870:	00801284 	movi	r2,74
81109874:	e0bffe15 	stw	r2,-8(fp)
		break;
81109878:	00001706 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110987c:	008012c4 	movi	r2,75
81109880:	e0bffe15 	stw	r2,-8(fp)
		break;
81109884:	00001406 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
81109888:	00801304 	movi	r2,76
8110988c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109890:	00001106 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
81109894:	00801344 	movi	r2,77
81109898:	e0bffe15 	stw	r2,-8(fp)
		break;
8110989c:	00000e06 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
811098a0:	00801384 	movi	r2,78
811098a4:	e0bffe15 	stw	r2,-8(fp)
		break;
811098a8:	00000b06 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
811098ac:	008013c4 	movi	r2,79
811098b0:	e0bffe15 	stw	r2,-8(fp)
		break;
811098b4:	00000806 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
811098b8:	00801404 	movi	r2,80
811098bc:	e0bffe15 	stw	r2,-8(fp)
		break;
811098c0:	00000506 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
811098c4:	00801444 	movi	r2,81
811098c8:	e0bffe15 	stw	r2,-8(fp)
		break;
811098cc:	00000206 	br	811098d8 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
811098d0:	e03ffe15 	stw	zero,-8(fp)
		break;
811098d4:	0001883a 	nop
	}

	return uliValue;
811098d8:	e0bffe17 	ldw	r2,-8(fp)
}
811098dc:	e037883a 	mov	sp,fp
811098e0:	df000017 	ldw	fp,0(sp)
811098e4:	dec00104 	addi	sp,sp,4
811098e8:	f800283a 	ret

811098ec <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
811098ec:	defffb04 	addi	sp,sp,-20
811098f0:	de00012e 	bgeu	sp,et,811098f8 <bSpwcSetLink+0xc>
811098f4:	003b68fa 	trap	3
811098f8:	dfc00415 	stw	ra,16(sp)
811098fc:	df000315 	stw	fp,12(sp)
81109900:	df000304 	addi	fp,sp,12
81109904:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109908:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110990c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109910:	e0bfff17 	ldw	r2,-4(fp)
81109914:	10003c26 	beq	r2,zero,81109a08 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109918:	e0bfff17 	ldw	r2,-4(fp)
8110991c:	10800017 	ldw	r2,0(r2)
81109920:	000b883a 	mov	r5,zero
81109924:	1009883a 	mov	r4,r2
81109928:	1109fb80 	call	81109fb8 <uliSpwcReadReg>
8110992c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
81109930:	e0bfff17 	ldw	r2,-4(fp)
81109934:	10800117 	ldw	r2,4(r2)
81109938:	10000426 	beq	r2,zero,8110994c <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110993c:	e0bffe17 	ldw	r2,-8(fp)
81109940:	10800114 	ori	r2,r2,4
81109944:	e0bffe15 	stw	r2,-8(fp)
81109948:	00000406 	br	8110995c <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110994c:	e0fffe17 	ldw	r3,-8(fp)
81109950:	00bffec4 	movi	r2,-5
81109954:	1884703a 	and	r2,r3,r2
81109958:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110995c:	e0bfff17 	ldw	r2,-4(fp)
81109960:	10800217 	ldw	r2,8(r2)
81109964:	10000426 	beq	r2,zero,81109978 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
81109968:	e0bffe17 	ldw	r2,-8(fp)
8110996c:	10800094 	ori	r2,r2,2
81109970:	e0bffe15 	stw	r2,-8(fp)
81109974:	00000406 	br	81109988 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
81109978:	e0fffe17 	ldw	r3,-8(fp)
8110997c:	00bfff44 	movi	r2,-3
81109980:	1884703a 	and	r2,r3,r2
81109984:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81109988:	e0bfff17 	ldw	r2,-4(fp)
8110998c:	10800317 	ldw	r2,12(r2)
81109990:	10000426 	beq	r2,zero,811099a4 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
81109994:	e0bffe17 	ldw	r2,-8(fp)
81109998:	10800054 	ori	r2,r2,1
8110999c:	e0bffe15 	stw	r2,-8(fp)
811099a0:	00000406 	br	811099b4 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
811099a4:	e0fffe17 	ldw	r3,-8(fp)
811099a8:	00bfff84 	movi	r2,-2
811099ac:	1884703a 	and	r2,r3,r2
811099b0:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
811099b4:	e0fffe17 	ldw	r3,-8(fp)
811099b8:	00804034 	movhi	r2,256
811099bc:	10bfffc4 	addi	r2,r2,-1
811099c0:	1884703a 	and	r2,r3,r2
811099c4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
811099c8:	e0bfff17 	ldw	r2,-4(fp)
811099cc:	10800403 	ldbu	r2,16(r2)
811099d0:	10803fcc 	andi	r2,r2,255
811099d4:	1004963a 	slli	r2,r2,24
811099d8:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
811099dc:	e0bffe17 	ldw	r2,-8(fp)
811099e0:	10c4b03a 	or	r2,r2,r3
811099e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
811099e8:	e0bfff17 	ldw	r2,-4(fp)
811099ec:	10800017 	ldw	r2,0(r2)
811099f0:	e1bffe17 	ldw	r6,-8(fp)
811099f4:	000b883a 	mov	r5,zero
811099f8:	1009883a 	mov	r4,r2
811099fc:	1109f640 	call	81109f64 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
81109a00:	00800044 	movi	r2,1
81109a04:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109a08:	e0bffd17 	ldw	r2,-12(fp)
}
81109a0c:	e037883a 	mov	sp,fp
81109a10:	dfc00117 	ldw	ra,4(sp)
81109a14:	df000017 	ldw	fp,0(sp)
81109a18:	dec00204 	addi	sp,sp,8
81109a1c:	f800283a 	ret

81109a20 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
81109a20:	defffb04 	addi	sp,sp,-20
81109a24:	de00012e 	bgeu	sp,et,81109a2c <bSpwcGetLink+0xc>
81109a28:	003b68fa 	trap	3
81109a2c:	dfc00415 	stw	ra,16(sp)
81109a30:	df000315 	stw	fp,12(sp)
81109a34:	df000304 	addi	fp,sp,12
81109a38:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109a3c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109a40:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109a44:	e0bfff17 	ldw	r2,-4(fp)
81109a48:	10002826 	beq	r2,zero,81109aec <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109a4c:	e0bfff17 	ldw	r2,-4(fp)
81109a50:	10800017 	ldw	r2,0(r2)
81109a54:	000b883a 	mov	r5,zero
81109a58:	1009883a 	mov	r4,r2
81109a5c:	1109fb80 	call	81109fb8 <uliSpwcReadReg>
81109a60:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
81109a64:	e0bffe17 	ldw	r2,-8(fp)
81109a68:	1080010c 	andi	r2,r2,4
81109a6c:	10000426 	beq	r2,zero,81109a80 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
81109a70:	e0bfff17 	ldw	r2,-4(fp)
81109a74:	00c00044 	movi	r3,1
81109a78:	10c00115 	stw	r3,4(r2)
81109a7c:	00000206 	br	81109a88 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
81109a80:	e0bfff17 	ldw	r2,-4(fp)
81109a84:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
81109a88:	e0bffe17 	ldw	r2,-8(fp)
81109a8c:	1080008c 	andi	r2,r2,2
81109a90:	10000426 	beq	r2,zero,81109aa4 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
81109a94:	e0bfff17 	ldw	r2,-4(fp)
81109a98:	00c00044 	movi	r3,1
81109a9c:	10c00215 	stw	r3,8(r2)
81109aa0:	00000206 	br	81109aac <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
81109aa4:	e0bfff17 	ldw	r2,-4(fp)
81109aa8:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
81109aac:	e0bffe17 	ldw	r2,-8(fp)
81109ab0:	1080004c 	andi	r2,r2,1
81109ab4:	10000426 	beq	r2,zero,81109ac8 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81109ab8:	e0bfff17 	ldw	r2,-4(fp)
81109abc:	00c00044 	movi	r3,1
81109ac0:	10c00315 	stw	r3,12(r2)
81109ac4:	00000206 	br	81109ad0 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81109ac8:	e0bfff17 	ldw	r2,-4(fp)
81109acc:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
81109ad0:	e0bffe17 	ldw	r2,-8(fp)
81109ad4:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
81109ad8:	1007883a 	mov	r3,r2
81109adc:	e0bfff17 	ldw	r2,-4(fp)
81109ae0:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
81109ae4:	00800044 	movi	r2,1
81109ae8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109aec:	e0bffd17 	ldw	r2,-12(fp)
}
81109af0:	e037883a 	mov	sp,fp
81109af4:	dfc00117 	ldw	ra,4(sp)
81109af8:	df000017 	ldw	fp,0(sp)
81109afc:	dec00204 	addi	sp,sp,8
81109b00:	f800283a 	ret

81109b04 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
81109b04:	defffb04 	addi	sp,sp,-20
81109b08:	de00012e 	bgeu	sp,et,81109b10 <bSpwcGetLinkError+0xc>
81109b0c:	003b68fa 	trap	3
81109b10:	dfc00415 	stw	ra,16(sp)
81109b14:	df000315 	stw	fp,12(sp)
81109b18:	df000304 	addi	fp,sp,12
81109b1c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109b20:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109b24:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109b28:	e0bfff17 	ldw	r2,-4(fp)
81109b2c:	10002c26 	beq	r2,zero,81109be0 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109b30:	e0bfff17 	ldw	r2,-4(fp)
81109b34:	10800017 	ldw	r2,0(r2)
81109b38:	000b883a 	mov	r5,zero
81109b3c:	1009883a 	mov	r4,r2
81109b40:	1109fb80 	call	81109fb8 <uliSpwcReadReg>
81109b44:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
81109b48:	e0bffe17 	ldw	r2,-8(fp)
81109b4c:	1080006c 	andhi	r2,r2,1
81109b50:	10000426 	beq	r2,zero,81109b64 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
81109b54:	e0bfff17 	ldw	r2,-4(fp)
81109b58:	00c00044 	movi	r3,1
81109b5c:	10c00515 	stw	r3,20(r2)
81109b60:	00000206 	br	81109b6c <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
81109b64:	e0bfff17 	ldw	r2,-4(fp)
81109b68:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
81109b6c:	e0bffe17 	ldw	r2,-8(fp)
81109b70:	108000ac 	andhi	r2,r2,2
81109b74:	10000426 	beq	r2,zero,81109b88 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
81109b78:	e0bfff17 	ldw	r2,-4(fp)
81109b7c:	00c00044 	movi	r3,1
81109b80:	10c00615 	stw	r3,24(r2)
81109b84:	00000206 	br	81109b90 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
81109b88:	e0bfff17 	ldw	r2,-4(fp)
81109b8c:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
81109b90:	e0bffe17 	ldw	r2,-8(fp)
81109b94:	1080012c 	andhi	r2,r2,4
81109b98:	10000426 	beq	r2,zero,81109bac <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
81109b9c:	e0bfff17 	ldw	r2,-4(fp)
81109ba0:	00c00044 	movi	r3,1
81109ba4:	10c00715 	stw	r3,28(r2)
81109ba8:	00000206 	br	81109bb4 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
81109bac:	e0bfff17 	ldw	r2,-4(fp)
81109bb0:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
81109bb4:	e0bffe17 	ldw	r2,-8(fp)
81109bb8:	1080022c 	andhi	r2,r2,8
81109bbc:	10000426 	beq	r2,zero,81109bd0 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81109bc0:	e0bfff17 	ldw	r2,-4(fp)
81109bc4:	00c00044 	movi	r3,1
81109bc8:	10c00815 	stw	r3,32(r2)
81109bcc:	00000206 	br	81109bd8 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81109bd0:	e0bfff17 	ldw	r2,-4(fp)
81109bd4:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
81109bd8:	00800044 	movi	r2,1
81109bdc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109be0:	e0bffd17 	ldw	r2,-12(fp)
}
81109be4:	e037883a 	mov	sp,fp
81109be8:	dfc00117 	ldw	ra,4(sp)
81109bec:	df000017 	ldw	fp,0(sp)
81109bf0:	dec00204 	addi	sp,sp,8
81109bf4:	f800283a 	ret

81109bf8 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
81109bf8:	defffb04 	addi	sp,sp,-20
81109bfc:	de00012e 	bgeu	sp,et,81109c04 <bSpwcGetLinkStatus+0xc>
81109c00:	003b68fa 	trap	3
81109c04:	dfc00415 	stw	ra,16(sp)
81109c08:	df000315 	stw	fp,12(sp)
81109c0c:	df000304 	addi	fp,sp,12
81109c10:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109c14:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109c18:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109c1c:	e0bfff17 	ldw	r2,-4(fp)
81109c20:	10002326 	beq	r2,zero,81109cb0 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109c24:	e0bfff17 	ldw	r2,-4(fp)
81109c28:	10800017 	ldw	r2,0(r2)
81109c2c:	000b883a 	mov	r5,zero
81109c30:	1009883a 	mov	r4,r2
81109c34:	1109fb80 	call	81109fb8 <uliSpwcReadReg>
81109c38:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
81109c3c:	e0bffe17 	ldw	r2,-8(fp)
81109c40:	1081000c 	andi	r2,r2,1024
81109c44:	10000426 	beq	r2,zero,81109c58 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
81109c48:	e0bfff17 	ldw	r2,-4(fp)
81109c4c:	00c00044 	movi	r3,1
81109c50:	10c00915 	stw	r3,36(r2)
81109c54:	00000206 	br	81109c60 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
81109c58:	e0bfff17 	ldw	r2,-4(fp)
81109c5c:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
81109c60:	e0bffe17 	ldw	r2,-8(fp)
81109c64:	1080800c 	andi	r2,r2,512
81109c68:	10000426 	beq	r2,zero,81109c7c <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
81109c6c:	e0bfff17 	ldw	r2,-4(fp)
81109c70:	00c00044 	movi	r3,1
81109c74:	10c00a15 	stw	r3,40(r2)
81109c78:	00000206 	br	81109c84 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
81109c7c:	e0bfff17 	ldw	r2,-4(fp)
81109c80:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
81109c84:	e0bffe17 	ldw	r2,-8(fp)
81109c88:	1080400c 	andi	r2,r2,256
81109c8c:	10000426 	beq	r2,zero,81109ca0 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
81109c90:	e0bfff17 	ldw	r2,-4(fp)
81109c94:	00c00044 	movi	r3,1
81109c98:	10c00b15 	stw	r3,44(r2)
81109c9c:	00000206 	br	81109ca8 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
81109ca0:	e0bfff17 	ldw	r2,-4(fp)
81109ca4:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
81109ca8:	00800044 	movi	r2,1
81109cac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109cb0:	e0bffd17 	ldw	r2,-12(fp)
}
81109cb4:	e037883a 	mov	sp,fp
81109cb8:	dfc00117 	ldw	ra,4(sp)
81109cbc:	df000017 	ldw	fp,0(sp)
81109cc0:	dec00204 	addi	sp,sp,8
81109cc4:	f800283a 	ret

81109cc8 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
81109cc8:	defffb04 	addi	sp,sp,-20
81109ccc:	de00012e 	bgeu	sp,et,81109cd4 <bSpwcGetTimecode+0xc>
81109cd0:	003b68fa 	trap	3
81109cd4:	dfc00415 	stw	ra,16(sp)
81109cd8:	df000315 	stw	fp,12(sp)
81109cdc:	df000304 	addi	fp,sp,12
81109ce0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109ce4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109ce8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109cec:	e0bfff17 	ldw	r2,-4(fp)
81109cf0:	10001326 	beq	r2,zero,81109d40 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109cf4:	e0bfff17 	ldw	r2,-4(fp)
81109cf8:	10800017 	ldw	r2,0(r2)
81109cfc:	01400044 	movi	r5,1
81109d00:	1009883a 	mov	r4,r2
81109d04:	1109fb80 	call	81109fb8 <uliSpwcReadReg>
81109d08:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
81109d0c:	e0bffe17 	ldw	r2,-8(fp)
81109d10:	1080300c 	andi	r2,r2,192
81109d14:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
81109d18:	1007883a 	mov	r3,r2
81109d1c:	e0bfff17 	ldw	r2,-4(fp)
81109d20:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
81109d24:	e0bffe17 	ldw	r2,-8(fp)
81109d28:	10800fcc 	andi	r2,r2,63
81109d2c:	1007883a 	mov	r3,r2
81109d30:	e0bfff17 	ldw	r2,-4(fp)
81109d34:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
81109d38:	00800044 	movi	r2,1
81109d3c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109d40:	e0bffd17 	ldw	r2,-12(fp)
}
81109d44:	e037883a 	mov	sp,fp
81109d48:	dfc00117 	ldw	ra,4(sp)
81109d4c:	df000017 	ldw	fp,0(sp)
81109d50:	dec00204 	addi	sp,sp,8
81109d54:	f800283a 	ret

81109d58 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
81109d58:	defffb04 	addi	sp,sp,-20
81109d5c:	de00012e 	bgeu	sp,et,81109d64 <bSpwcClearTimecode+0xc>
81109d60:	003b68fa 	trap	3
81109d64:	dfc00415 	stw	ra,16(sp)
81109d68:	df000315 	stw	fp,12(sp)
81109d6c:	df000304 	addi	fp,sp,12
81109d70:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109d74:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109d78:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109d7c:	e0bfff17 	ldw	r2,-4(fp)
81109d80:	10001126 	beq	r2,zero,81109dc8 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109d84:	e0bfff17 	ldw	r2,-4(fp)
81109d88:	10800017 	ldw	r2,0(r2)
81109d8c:	01400044 	movi	r5,1
81109d90:	1009883a 	mov	r4,r2
81109d94:	1109fb80 	call	81109fb8 <uliSpwcReadReg>
81109d98:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
81109d9c:	e0bffe17 	ldw	r2,-8(fp)
81109da0:	10804014 	ori	r2,r2,256
81109da4:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
81109da8:	e0bfff17 	ldw	r2,-4(fp)
81109dac:	10800017 	ldw	r2,0(r2)
81109db0:	e1bffe17 	ldw	r6,-8(fp)
81109db4:	01400044 	movi	r5,1
81109db8:	1009883a 	mov	r4,r2
81109dbc:	1109f640 	call	81109f64 <vSpwcWriteReg>
		bStatus = TRUE;
81109dc0:	00800044 	movi	r2,1
81109dc4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109dc8:	e0bffd17 	ldw	r2,-12(fp)
}
81109dcc:	e037883a 	mov	sp,fp
81109dd0:	dfc00117 	ldw	ra,4(sp)
81109dd4:	df000017 	ldw	fp,0(sp)
81109dd8:	dec00204 	addi	sp,sp,8
81109ddc:	f800283a 	ret

81109de0 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81109de0:	defffb04 	addi	sp,sp,-20
81109de4:	de00012e 	bgeu	sp,et,81109dec <bSpwcInitCh+0xc>
81109de8:	003b68fa 	trap	3
81109dec:	dfc00415 	stw	ra,16(sp)
81109df0:	df000315 	stw	fp,12(sp)
81109df4:	df000304 	addi	fp,sp,12
81109df8:	e13ffe15 	stw	r4,-8(fp)
81109dfc:	2805883a 	mov	r2,r5
81109e00:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109e04:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
81109e08:	e0bffe17 	ldw	r2,-8(fp)
81109e0c:	10004f26 	beq	r2,zero,81109f4c <bSpwcInitCh+0x16c>
		bStatus = TRUE;
81109e10:	00800044 	movi	r2,1
81109e14:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109e18:	e0bfff03 	ldbu	r2,-4(fp)
81109e1c:	10c00228 	cmpgeui	r3,r2,8
81109e20:	1800361e 	bne	r3,zero,81109efc <bSpwcInitCh+0x11c>
81109e24:	100690ba 	slli	r3,r2,2
81109e28:	00a04474 	movhi	r2,33041
81109e2c:	10a78f04 	addi	r2,r2,-25028
81109e30:	1885883a 	add	r2,r3,r2
81109e34:	10800017 	ldw	r2,0(r2)
81109e38:	1000683a 	jmp	r2
81109e3c:	81109e5c 	xori	r4,r16,17017
81109e40:	81109e70 	cmpltui	r4,r16,17017
81109e44:	81109e84 	addi	r4,r16,17018
81109e48:	81109e98 	cmpnei	r4,r16,17018
81109e4c:	81109eac 	andhi	r4,r16,17018
81109e50:	81109ec0 	call	881109ec <__reset+0x20f09ec>
81109e54:	81109ed4 	ori	r4,r16,17019
81109e58:	81109ee8 	cmpgeui	r4,r16,17019
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109e5c:	e0fffe17 	ldw	r3,-8(fp)
81109e60:	00a04834 	movhi	r2,33056
81109e64:	108b0004 	addi	r2,r2,11264
81109e68:	18800015 	stw	r2,0(r3)
			break;
81109e6c:	00002506 	br	81109f04 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109e70:	e0fffe17 	ldw	r3,-8(fp)
81109e74:	00a04834 	movhi	r2,33056
81109e78:	108a0004 	addi	r2,r2,10240
81109e7c:	18800015 	stw	r2,0(r3)
			break;
81109e80:	00002006 	br	81109f04 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109e84:	e0fffe17 	ldw	r3,-8(fp)
81109e88:	00a04834 	movhi	r2,33056
81109e8c:	10890004 	addi	r2,r2,9216
81109e90:	18800015 	stw	r2,0(r3)
			break;
81109e94:	00001b06 	br	81109f04 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81109e98:	e0fffe17 	ldw	r3,-8(fp)
81109e9c:	00a04834 	movhi	r2,33056
81109ea0:	10880004 	addi	r2,r2,8192
81109ea4:	18800015 	stw	r2,0(r3)
			break;
81109ea8:	00001606 	br	81109f04 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109eac:	e0fffe17 	ldw	r3,-8(fp)
81109eb0:	00a04834 	movhi	r2,33056
81109eb4:	10870004 	addi	r2,r2,7168
81109eb8:	18800015 	stw	r2,0(r3)
			break;
81109ebc:	00001106 	br	81109f04 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109ec0:	e0fffe17 	ldw	r3,-8(fp)
81109ec4:	00a04834 	movhi	r2,33056
81109ec8:	10860004 	addi	r2,r2,6144
81109ecc:	18800015 	stw	r2,0(r3)
			break;
81109ed0:	00000c06 	br	81109f04 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109ed4:	e0fffe17 	ldw	r3,-8(fp)
81109ed8:	00a04834 	movhi	r2,33056
81109edc:	10850004 	addi	r2,r2,5120
81109ee0:	18800015 	stw	r2,0(r3)
			break;
81109ee4:	00000706 	br	81109f04 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109ee8:	e0fffe17 	ldw	r3,-8(fp)
81109eec:	00a04834 	movhi	r2,33056
81109ef0:	10840004 	addi	r2,r2,4096
81109ef4:	18800015 	stw	r2,0(r3)
			break;
81109ef8:	00000206 	br	81109f04 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
81109efc:	e03ffd15 	stw	zero,-12(fp)
			break;
81109f00:	0001883a 	nop
		}

		if (bStatus) {
81109f04:	e0bffd17 	ldw	r2,-12(fp)
81109f08:	10001026 	beq	r2,zero,81109f4c <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
81109f0c:	e13ffe17 	ldw	r4,-8(fp)
81109f10:	1109a200 	call	81109a20 <bSpwcGetLink>
81109f14:	1000011e 	bne	r2,zero,81109f1c <bSpwcInitCh+0x13c>
				bStatus = FALSE;
81109f18:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
81109f1c:	e13ffe17 	ldw	r4,-8(fp)
81109f20:	1109b040 	call	81109b04 <bSpwcGetLinkError>
81109f24:	1000011e 	bne	r2,zero,81109f2c <bSpwcInitCh+0x14c>
				bStatus = FALSE;
81109f28:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
81109f2c:	e13ffe17 	ldw	r4,-8(fp)
81109f30:	1109bf80 	call	81109bf8 <bSpwcGetLinkStatus>
81109f34:	1000011e 	bne	r2,zero,81109f3c <bSpwcInitCh+0x15c>
				bStatus = FALSE;
81109f38:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
81109f3c:	e13ffe17 	ldw	r4,-8(fp)
81109f40:	1109cc80 	call	81109cc8 <bSpwcGetTimecode>
81109f44:	1000011e 	bne	r2,zero,81109f4c <bSpwcInitCh+0x16c>
				bStatus = FALSE;
81109f48:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109f4c:	e0bffd17 	ldw	r2,-12(fp)
}
81109f50:	e037883a 	mov	sp,fp
81109f54:	dfc00117 	ldw	ra,4(sp)
81109f58:	df000017 	ldw	fp,0(sp)
81109f5c:	dec00204 	addi	sp,sp,8
81109f60:	f800283a 	ret

81109f64 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109f64:	defffc04 	addi	sp,sp,-16
81109f68:	de00012e 	bgeu	sp,et,81109f70 <vSpwcWriteReg+0xc>
81109f6c:	003b68fa 	trap	3
81109f70:	df000315 	stw	fp,12(sp)
81109f74:	df000304 	addi	fp,sp,12
81109f78:	e13ffd15 	stw	r4,-12(fp)
81109f7c:	e17ffe15 	stw	r5,-8(fp)
81109f80:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109f84:	e0bffe17 	ldw	r2,-8(fp)
81109f88:	1085883a 	add	r2,r2,r2
81109f8c:	1085883a 	add	r2,r2,r2
81109f90:	1007883a 	mov	r3,r2
81109f94:	e0bffd17 	ldw	r2,-12(fp)
81109f98:	10c5883a 	add	r2,r2,r3
81109f9c:	e0ffff17 	ldw	r3,-4(fp)
81109fa0:	10c00015 	stw	r3,0(r2)
}
81109fa4:	0001883a 	nop
81109fa8:	e037883a 	mov	sp,fp
81109fac:	df000017 	ldw	fp,0(sp)
81109fb0:	dec00104 	addi	sp,sp,4
81109fb4:	f800283a 	ret

81109fb8 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109fb8:	defffc04 	addi	sp,sp,-16
81109fbc:	de00012e 	bgeu	sp,et,81109fc4 <uliSpwcReadReg+0xc>
81109fc0:	003b68fa 	trap	3
81109fc4:	df000315 	stw	fp,12(sp)
81109fc8:	df000304 	addi	fp,sp,12
81109fcc:	e13ffe15 	stw	r4,-8(fp)
81109fd0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109fd4:	e0bfff17 	ldw	r2,-4(fp)
81109fd8:	1085883a 	add	r2,r2,r2
81109fdc:	1085883a 	add	r2,r2,r2
81109fe0:	1007883a 	mov	r3,r2
81109fe4:	e0bffe17 	ldw	r2,-8(fp)
81109fe8:	10c5883a 	add	r2,r2,r3
81109fec:	10800017 	ldw	r2,0(r2)
81109ff0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109ff4:	e0bffd17 	ldw	r2,-12(fp)
}
81109ff8:	e037883a 	mov	sp,fp
81109ffc:	df000017 	ldw	fp,0(sp)
8110a000:	dec00104 	addi	sp,sp,4
8110a004:	f800283a 	ret

8110a008 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110a008:	defffe04 	addi	sp,sp,-8
8110a00c:	de00012e 	bgeu	sp,et,8110a014 <bEnableIsoDrivers+0xc>
8110a010:	003b68fa 	trap	3
8110a014:	dfc00115 	stw	ra,4(sp)
8110a018:	df000015 	stw	fp,0(sp)
8110a01c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110a020:	01400204 	movi	r5,8
8110a024:	01000044 	movi	r4,1
8110a028:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a02c:	00800044 	movi	r2,1
}
8110a030:	e037883a 	mov	sp,fp
8110a034:	dfc00117 	ldw	ra,4(sp)
8110a038:	df000017 	ldw	fp,0(sp)
8110a03c:	dec00204 	addi	sp,sp,8
8110a040:	f800283a 	ret

8110a044 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110a044:	defffe04 	addi	sp,sp,-8
8110a048:	de00012e 	bgeu	sp,et,8110a050 <bDisableIsoDrivers+0xc>
8110a04c:	003b68fa 	trap	3
8110a050:	dfc00115 	stw	ra,4(sp)
8110a054:	df000015 	stw	fp,0(sp)
8110a058:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110a05c:	01400204 	movi	r5,8
8110a060:	0009883a 	mov	r4,zero
8110a064:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a068:	00800044 	movi	r2,1
}
8110a06c:	e037883a 	mov	sp,fp
8110a070:	dfc00117 	ldw	ra,4(sp)
8110a074:	df000017 	ldw	fp,0(sp)
8110a078:	dec00204 	addi	sp,sp,8
8110a07c:	f800283a 	ret

8110a080 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110a080:	defffe04 	addi	sp,sp,-8
8110a084:	de00012e 	bgeu	sp,et,8110a08c <bEnableLvdsBoard+0xc>
8110a088:	003b68fa 	trap	3
8110a08c:	dfc00115 	stw	ra,4(sp)
8110a090:	df000015 	stw	fp,0(sp)
8110a094:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110a098:	01400104 	movi	r5,4
8110a09c:	01000044 	movi	r4,1
8110a0a0:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a0a4:	00800044 	movi	r2,1
}
8110a0a8:	e037883a 	mov	sp,fp
8110a0ac:	dfc00117 	ldw	ra,4(sp)
8110a0b0:	df000017 	ldw	fp,0(sp)
8110a0b4:	dec00204 	addi	sp,sp,8
8110a0b8:	f800283a 	ret

8110a0bc <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110a0bc:	defffe04 	addi	sp,sp,-8
8110a0c0:	de00012e 	bgeu	sp,et,8110a0c8 <bDisableLvdsBoard+0xc>
8110a0c4:	003b68fa 	trap	3
8110a0c8:	dfc00115 	stw	ra,4(sp)
8110a0cc:	df000015 	stw	fp,0(sp)
8110a0d0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110a0d4:	01400104 	movi	r5,4
8110a0d8:	0009883a 	mov	r4,zero
8110a0dc:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a0e0:	00800044 	movi	r2,1
}
8110a0e4:	e037883a 	mov	sp,fp
8110a0e8:	dfc00117 	ldw	ra,4(sp)
8110a0ec:	df000017 	ldw	fp,0(sp)
8110a0f0:	dec00204 	addi	sp,sp,8
8110a0f4:	f800283a 	ret

8110a0f8 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110a0f8:	defffd04 	addi	sp,sp,-12
8110a0fc:	de00012e 	bgeu	sp,et,8110a104 <bSetPreEmphasys+0xc>
8110a100:	003b68fa 	trap	3
8110a104:	dfc00215 	stw	ra,8(sp)
8110a108:	df000115 	stw	fp,4(sp)
8110a10c:	df000104 	addi	fp,sp,4
8110a110:	2005883a 	mov	r2,r4
8110a114:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110a118:	e0bfff03 	ldbu	r2,-4(fp)
8110a11c:	10c00060 	cmpeqi	r3,r2,1
8110a120:	18000d1e 	bne	r3,zero,8110a158 <bSetPreEmphasys+0x60>
8110a124:	10c00088 	cmpgei	r3,r2,2
8110a128:	1800021e 	bne	r3,zero,8110a134 <bSetPreEmphasys+0x3c>
8110a12c:	10000626 	beq	r2,zero,8110a148 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a130:	00001b06 	br	8110a1a0 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110a134:	10c000a0 	cmpeqi	r3,r2,2
8110a138:	18000e1e 	bne	r3,zero,8110a174 <bSetPreEmphasys+0x7c>
8110a13c:	108000e0 	cmpeqi	r2,r2,3
8110a140:	1000131e 	bne	r2,zero,8110a190 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a144:	00001606 	br	8110a1a0 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a148:	014000c4 	movi	r5,3
8110a14c:	0009883a 	mov	r4,zero
8110a150:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
      break;
8110a154:	00001206 	br	8110a1a0 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110a158:	01400084 	movi	r5,2
8110a15c:	0009883a 	mov	r4,zero
8110a160:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110a164:	01400044 	movi	r5,1
8110a168:	01000044 	movi	r4,1
8110a16c:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
      break;
8110a170:	00000b06 	br	8110a1a0 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110a174:	01400044 	movi	r5,1
8110a178:	0009883a 	mov	r4,zero
8110a17c:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110a180:	01400084 	movi	r5,2
8110a184:	01000044 	movi	r4,1
8110a188:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
      break;
8110a18c:	00000406 	br	8110a1a0 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a190:	014000c4 	movi	r5,3
8110a194:	01000044 	movi	r4,1
8110a198:	110a1b80 	call	8110a1b8 <bCtrlIoLvdsDrive>
      break;
8110a19c:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110a1a0:	00800044 	movi	r2,1
}
8110a1a4:	e037883a 	mov	sp,fp
8110a1a8:	dfc00117 	ldw	ra,4(sp)
8110a1ac:	df000017 	ldw	fp,0(sp)
8110a1b0:	dec00204 	addi	sp,sp,8
8110a1b4:	f800283a 	ret

8110a1b8 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110a1b8:	defffd04 	addi	sp,sp,-12
8110a1bc:	de00012e 	bgeu	sp,et,8110a1c4 <bCtrlIoLvdsDrive+0xc>
8110a1c0:	003b68fa 	trap	3
8110a1c4:	df000215 	stw	fp,8(sp)
8110a1c8:	df000204 	addi	fp,sp,8
8110a1cc:	e13ffe15 	stw	r4,-8(fp)
8110a1d0:	2805883a 	mov	r2,r5
8110a1d4:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110a1d8:	e0bffe17 	ldw	r2,-8(fp)
8110a1dc:	1000071e 	bne	r2,zero,8110a1fc <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110a1e0:	e0bfff03 	ldbu	r2,-4(fp)
8110a1e4:	0084303a 	nor	r2,zero,r2
8110a1e8:	1007883a 	mov	r3,r2
8110a1ec:	d0a00103 	ldbu	r2,-32764(gp)
8110a1f0:	1884703a 	and	r2,r3,r2
8110a1f4:	d0a00105 	stb	r2,-32764(gp)
8110a1f8:	00000406 	br	8110a20c <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110a1fc:	d0e00103 	ldbu	r3,-32764(gp)
8110a200:	e0bfff03 	ldbu	r2,-4(fp)
8110a204:	1884b03a 	or	r2,r3,r2
8110a208:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110a20c:	d0a00103 	ldbu	r2,-32764(gp)
8110a210:	10c03fcc 	andi	r3,r2,255
8110a214:	00a00034 	movhi	r2,32768
8110a218:	10822804 	addi	r2,r2,2208
8110a21c:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110a220:	00800044 	movi	r2,1
}
8110a224:	e037883a 	mov	sp,fp
8110a228:	df000017 	ldw	fp,0(sp)
8110a22c:	dec00104 	addi	sp,sp,4
8110a230:	f800283a 	ret

8110a234 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110a234:	defffa04 	addi	sp,sp,-24
8110a238:	de00012e 	bgeu	sp,et,8110a240 <I2C_TestAdress+0xc>
8110a23c:	003b68fa 	trap	3
8110a240:	dfc00515 	stw	ra,20(sp)
8110a244:	df000415 	stw	fp,16(sp)
8110a248:	df000404 	addi	fp,sp,16
8110a24c:	e13ffd15 	stw	r4,-12(fp)
8110a250:	e17ffe15 	stw	r5,-8(fp)
8110a254:	3005883a 	mov	r2,r6
8110a258:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110a25c:	00800044 	movi	r2,1
8110a260:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110a264:	e17ffe17 	ldw	r5,-8(fp)
8110a268:	e13ffd17 	ldw	r4,-12(fp)
8110a26c:	110a6040 	call	8110a604 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110a270:	e0bfff03 	ldbu	r2,-4(fp)
8110a274:	10803fcc 	andi	r2,r2,255
8110a278:	100d883a 	mov	r6,r2
8110a27c:	e17ffe17 	ldw	r5,-8(fp)
8110a280:	e13ffd17 	ldw	r4,-12(fp)
8110a284:	110a7180 	call	8110a718 <i2c_write>
8110a288:	1000011e 	bne	r2,zero,8110a290 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110a28c:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110a290:	e17ffe17 	ldw	r5,-8(fp)
8110a294:	e13ffd17 	ldw	r4,-12(fp)
8110a298:	110a6980 	call	8110a698 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110a29c:	0106d604 	movi	r4,7000
8110a2a0:	11348ec0 	call	811348ec <usleep>
    
    return bSuccess;
8110a2a4:	e0bffc17 	ldw	r2,-16(fp)

}
8110a2a8:	e037883a 	mov	sp,fp
8110a2ac:	dfc00117 	ldw	ra,4(sp)
8110a2b0:	df000017 	ldw	fp,0(sp)
8110a2b4:	dec00204 	addi	sp,sp,8
8110a2b8:	f800283a 	ret

8110a2bc <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110a2bc:	defff804 	addi	sp,sp,-32
8110a2c0:	de00012e 	bgeu	sp,et,8110a2c8 <I2C_Write+0xc>
8110a2c4:	003b68fa 	trap	3
8110a2c8:	dfc00715 	stw	ra,28(sp)
8110a2cc:	df000615 	stw	fp,24(sp)
8110a2d0:	df000604 	addi	fp,sp,24
8110a2d4:	e13ffb15 	stw	r4,-20(fp)
8110a2d8:	e17ffc15 	stw	r5,-16(fp)
8110a2dc:	3009883a 	mov	r4,r6
8110a2e0:	3807883a 	mov	r3,r7
8110a2e4:	e0800217 	ldw	r2,8(fp)
8110a2e8:	e13ffd05 	stb	r4,-12(fp)
8110a2ec:	e0fffe05 	stb	r3,-8(fp)
8110a2f0:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110a2f4:	00800044 	movi	r2,1
8110a2f8:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110a2fc:	e17ffc17 	ldw	r5,-16(fp)
8110a300:	e13ffb17 	ldw	r4,-20(fp)
8110a304:	110a6040 	call	8110a604 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110a308:	e0bffd03 	ldbu	r2,-12(fp)
8110a30c:	10803fcc 	andi	r2,r2,255
8110a310:	100d883a 	mov	r6,r2
8110a314:	e17ffc17 	ldw	r5,-16(fp)
8110a318:	e13ffb17 	ldw	r4,-20(fp)
8110a31c:	110a7180 	call	8110a718 <i2c_write>
8110a320:	1000011e 	bne	r2,zero,8110a328 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110a324:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110a328:	e0bffa17 	ldw	r2,-24(fp)
8110a32c:	10000726 	beq	r2,zero,8110a34c <I2C_Write+0x90>
8110a330:	e0bffe03 	ldbu	r2,-8(fp)
8110a334:	100d883a 	mov	r6,r2
8110a338:	e17ffc17 	ldw	r5,-16(fp)
8110a33c:	e13ffb17 	ldw	r4,-20(fp)
8110a340:	110a7180 	call	8110a718 <i2c_write>
8110a344:	1000011e 	bne	r2,zero,8110a34c <I2C_Write+0x90>
        bSuccess = FALSE;
8110a348:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110a34c:	e0bffa17 	ldw	r2,-24(fp)
8110a350:	10000726 	beq	r2,zero,8110a370 <I2C_Write+0xb4>
8110a354:	e0bfff03 	ldbu	r2,-4(fp)
8110a358:	100d883a 	mov	r6,r2
8110a35c:	e17ffc17 	ldw	r5,-16(fp)
8110a360:	e13ffb17 	ldw	r4,-20(fp)
8110a364:	110a7180 	call	8110a718 <i2c_write>
8110a368:	1000011e 	bne	r2,zero,8110a370 <I2C_Write+0xb4>
        bSuccess = FALSE;
8110a36c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110a370:	e17ffc17 	ldw	r5,-16(fp)
8110a374:	e13ffb17 	ldw	r4,-20(fp)
8110a378:	110a6980 	call	8110a698 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110a37c:	0106d604 	movi	r4,7000
8110a380:	11348ec0 	call	811348ec <usleep>
    
    return bSuccess;
8110a384:	e0bffa17 	ldw	r2,-24(fp)

}
8110a388:	e037883a 	mov	sp,fp
8110a38c:	dfc00117 	ldw	ra,4(sp)
8110a390:	df000017 	ldw	fp,0(sp)
8110a394:	dec00204 	addi	sp,sp,8
8110a398:	f800283a 	ret

8110a39c <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110a39c:	defff904 	addi	sp,sp,-28
8110a3a0:	de00012e 	bgeu	sp,et,8110a3a8 <I2C_Read+0xc>
8110a3a4:	003b68fa 	trap	3
8110a3a8:	dfc00615 	stw	ra,24(sp)
8110a3ac:	df000515 	stw	fp,20(sp)
8110a3b0:	df000504 	addi	fp,sp,20
8110a3b4:	e13ffc15 	stw	r4,-16(fp)
8110a3b8:	e17ffd15 	stw	r5,-12(fp)
8110a3bc:	3007883a 	mov	r3,r6
8110a3c0:	3805883a 	mov	r2,r7
8110a3c4:	e0fffe05 	stb	r3,-8(fp)
8110a3c8:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110a3cc:	00800044 	movi	r2,1
8110a3d0:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110a3d4:	e17ffd17 	ldw	r5,-12(fp)
8110a3d8:	e13ffc17 	ldw	r4,-16(fp)
8110a3dc:	110a6040 	call	8110a604 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110a3e0:	e0bffe03 	ldbu	r2,-8(fp)
8110a3e4:	10803fcc 	andi	r2,r2,255
8110a3e8:	100d883a 	mov	r6,r2
8110a3ec:	e17ffd17 	ldw	r5,-12(fp)
8110a3f0:	e13ffc17 	ldw	r4,-16(fp)
8110a3f4:	110a7180 	call	8110a718 <i2c_write>
8110a3f8:	1000011e 	bne	r2,zero,8110a400 <I2C_Read+0x64>
        bSuccess = FALSE;
8110a3fc:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110a400:	e0bffb17 	ldw	r2,-20(fp)
8110a404:	10000726 	beq	r2,zero,8110a424 <I2C_Read+0x88>
8110a408:	e0bfff03 	ldbu	r2,-4(fp)
8110a40c:	100d883a 	mov	r6,r2
8110a410:	e17ffd17 	ldw	r5,-12(fp)
8110a414:	e13ffc17 	ldw	r4,-16(fp)
8110a418:	110a7180 	call	8110a718 <i2c_write>
8110a41c:	1000011e 	bne	r2,zero,8110a424 <I2C_Read+0x88>
        bSuccess = FALSE;
8110a420:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110a424:	e17ffd17 	ldw	r5,-12(fp)
8110a428:	e13ffc17 	ldw	r4,-16(fp)
8110a42c:	110a6040 	call	8110a604 <i2c_start>
    DeviceAddr |= 1; // Read
8110a430:	e0bffe03 	ldbu	r2,-8(fp)
8110a434:	10800054 	ori	r2,r2,1
8110a438:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110a43c:	e0bffb17 	ldw	r2,-20(fp)
8110a440:	10000826 	beq	r2,zero,8110a464 <I2C_Read+0xc8>
8110a444:	e0bffe03 	ldbu	r2,-8(fp)
8110a448:	10803fcc 	andi	r2,r2,255
8110a44c:	100d883a 	mov	r6,r2
8110a450:	e17ffd17 	ldw	r5,-12(fp)
8110a454:	e13ffc17 	ldw	r4,-16(fp)
8110a458:	110a7180 	call	8110a718 <i2c_write>
8110a45c:	1000011e 	bne	r2,zero,8110a464 <I2C_Read+0xc8>
        bSuccess = FALSE;
8110a460:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110a464:	e0bffb17 	ldw	r2,-20(fp)
8110a468:	10000526 	beq	r2,zero,8110a480 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110a46c:	000f883a 	mov	r7,zero
8110a470:	e1800217 	ldw	r6,8(fp)
8110a474:	e17ffd17 	ldw	r5,-12(fp)
8110a478:	e13ffc17 	ldw	r4,-16(fp)
8110a47c:	110a8500 	call	8110a850 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110a480:	e17ffd17 	ldw	r5,-12(fp)
8110a484:	e13ffc17 	ldw	r4,-16(fp)
8110a488:	110a6980 	call	8110a698 <i2c_stop>
    
    return bSuccess;
8110a48c:	e0bffb17 	ldw	r2,-20(fp)
}
8110a490:	e037883a 	mov	sp,fp
8110a494:	dfc00117 	ldw	ra,4(sp)
8110a498:	df000017 	ldw	fp,0(sp)
8110a49c:	dec00204 	addi	sp,sp,8
8110a4a0:	f800283a 	ret

8110a4a4 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110a4a4:	defff604 	addi	sp,sp,-40
8110a4a8:	de00012e 	bgeu	sp,et,8110a4b0 <I2C_MultipleRead+0xc>
8110a4ac:	003b68fa 	trap	3
8110a4b0:	dfc00915 	stw	ra,36(sp)
8110a4b4:	df000815 	stw	fp,32(sp)
8110a4b8:	df000804 	addi	fp,sp,32
8110a4bc:	e13ffb15 	stw	r4,-20(fp)
8110a4c0:	e17ffc15 	stw	r5,-16(fp)
8110a4c4:	3007883a 	mov	r3,r6
8110a4c8:	e1fffe15 	stw	r7,-8(fp)
8110a4cc:	e0800217 	ldw	r2,8(fp)
8110a4d0:	e0fffd05 	stb	r3,-12(fp)
8110a4d4:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110a4d8:	00800044 	movi	r2,1
8110a4dc:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110a4e0:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110a4e4:	e17ffc17 	ldw	r5,-16(fp)
8110a4e8:	e13ffb17 	ldw	r4,-20(fp)
8110a4ec:	110a6040 	call	8110a604 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110a4f0:	e0bffd03 	ldbu	r2,-12(fp)
8110a4f4:	10803fcc 	andi	r2,r2,255
8110a4f8:	100d883a 	mov	r6,r2
8110a4fc:	e17ffc17 	ldw	r5,-16(fp)
8110a500:	e13ffb17 	ldw	r4,-20(fp)
8110a504:	110a7180 	call	8110a718 <i2c_write>
8110a508:	1000011e 	bne	r2,zero,8110a510 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110a50c:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110a510:	e0bff917 	ldw	r2,-28(fp)
8110a514:	10000726 	beq	r2,zero,8110a534 <I2C_MultipleRead+0x90>
8110a518:	e0bffa03 	ldbu	r2,-24(fp)
8110a51c:	100d883a 	mov	r6,r2
8110a520:	e17ffc17 	ldw	r5,-16(fp)
8110a524:	e13ffb17 	ldw	r4,-20(fp)
8110a528:	110a7180 	call	8110a718 <i2c_write>
8110a52c:	1000011e 	bne	r2,zero,8110a534 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110a530:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110a534:	e0bff917 	ldw	r2,-28(fp)
8110a538:	10000326 	beq	r2,zero,8110a548 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110a53c:	e17ffc17 	ldw	r5,-16(fp)
8110a540:	e13ffb17 	ldw	r4,-20(fp)
8110a544:	110a6040 	call	8110a604 <i2c_start>
    DeviceAddr |= 1; // Read
8110a548:	e0bffd03 	ldbu	r2,-12(fp)
8110a54c:	10800054 	ori	r2,r2,1
8110a550:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110a554:	e0bff917 	ldw	r2,-28(fp)
8110a558:	10000826 	beq	r2,zero,8110a57c <I2C_MultipleRead+0xd8>
8110a55c:	e0bffd03 	ldbu	r2,-12(fp)
8110a560:	10803fcc 	andi	r2,r2,255
8110a564:	100d883a 	mov	r6,r2
8110a568:	e17ffc17 	ldw	r5,-16(fp)
8110a56c:	e13ffb17 	ldw	r4,-20(fp)
8110a570:	110a7180 	call	8110a718 <i2c_write>
8110a574:	1000011e 	bne	r2,zero,8110a57c <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110a578:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110a57c:	e0bff917 	ldw	r2,-28(fp)
8110a580:	10001726 	beq	r2,zero,8110a5e0 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110a584:	e03ff815 	stw	zero,-32(fp)
8110a588:	00001006 	br	8110a5cc <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110a58c:	e0bff817 	ldw	r2,-32(fp)
8110a590:	e0fffe17 	ldw	r3,-8(fp)
8110a594:	1889883a 	add	r4,r3,r2
8110a598:	e0bfff0b 	ldhu	r2,-4(fp)
8110a59c:	10ffffc4 	addi	r3,r2,-1
8110a5a0:	e0bff817 	ldw	r2,-32(fp)
8110a5a4:	1884c03a 	cmpne	r2,r3,r2
8110a5a8:	10803fcc 	andi	r2,r2,255
8110a5ac:	100f883a 	mov	r7,r2
8110a5b0:	200d883a 	mov	r6,r4
8110a5b4:	e17ffc17 	ldw	r5,-16(fp)
8110a5b8:	e13ffb17 	ldw	r4,-20(fp)
8110a5bc:	110a8500 	call	8110a850 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110a5c0:	e0bff817 	ldw	r2,-32(fp)
8110a5c4:	10800044 	addi	r2,r2,1
8110a5c8:	e0bff815 	stw	r2,-32(fp)
8110a5cc:	e0bfff0b 	ldhu	r2,-4(fp)
8110a5d0:	e0fff817 	ldw	r3,-32(fp)
8110a5d4:	1880020e 	bge	r3,r2,8110a5e0 <I2C_MultipleRead+0x13c>
8110a5d8:	e0bff917 	ldw	r2,-28(fp)
8110a5dc:	103feb1e 	bne	r2,zero,8110a58c <__reset+0xfb0ea58c>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110a5e0:	e17ffc17 	ldw	r5,-16(fp)
8110a5e4:	e13ffb17 	ldw	r4,-20(fp)
8110a5e8:	110a6980 	call	8110a698 <i2c_stop>
    
    return bSuccess;    
8110a5ec:	e0bff917 	ldw	r2,-28(fp)
    
}
8110a5f0:	e037883a 	mov	sp,fp
8110a5f4:	dfc00117 	ldw	ra,4(sp)
8110a5f8:	df000017 	ldw	fp,0(sp)
8110a5fc:	dec00204 	addi	sp,sp,8
8110a600:	f800283a 	ret

8110a604 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110a604:	defffc04 	addi	sp,sp,-16
8110a608:	de00012e 	bgeu	sp,et,8110a610 <i2c_start+0xc>
8110a60c:	003b68fa 	trap	3
8110a610:	dfc00315 	stw	ra,12(sp)
8110a614:	df000215 	stw	fp,8(sp)
8110a618:	df000204 	addi	fp,sp,8
8110a61c:	e13ffe15 	stw	r4,-8(fp)
8110a620:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110a624:	e0bfff17 	ldw	r2,-4(fp)
8110a628:	10800104 	addi	r2,r2,4
8110a62c:	1007883a 	mov	r3,r2
8110a630:	00800044 	movi	r2,1
8110a634:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110a638:	e0bfff17 	ldw	r2,-4(fp)
8110a63c:	00c00044 	movi	r3,1
8110a640:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110a644:	e0bffe17 	ldw	r2,-8(fp)
8110a648:	00c00044 	movi	r3,1
8110a64c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110a650:	01000044 	movi	r4,1
8110a654:	11348ec0 	call	811348ec <usleep>
     
    SDA_LOW(data_base); // data low
8110a658:	e0bfff17 	ldw	r2,-4(fp)
8110a65c:	0007883a 	mov	r3,zero
8110a660:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110a664:	01000044 	movi	r4,1
8110a668:	11348ec0 	call	811348ec <usleep>
    SCL_LOW(clk_base); // clock low
8110a66c:	e0bffe17 	ldw	r2,-8(fp)
8110a670:	0007883a 	mov	r3,zero
8110a674:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110a678:	01000044 	movi	r4,1
8110a67c:	11348ec0 	call	811348ec <usleep>
}
8110a680:	0001883a 	nop
8110a684:	e037883a 	mov	sp,fp
8110a688:	dfc00117 	ldw	ra,4(sp)
8110a68c:	df000017 	ldw	fp,0(sp)
8110a690:	dec00204 	addi	sp,sp,8
8110a694:	f800283a 	ret

8110a698 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110a698:	defffc04 	addi	sp,sp,-16
8110a69c:	de00012e 	bgeu	sp,et,8110a6a4 <i2c_stop+0xc>
8110a6a0:	003b68fa 	trap	3
8110a6a4:	dfc00315 	stw	ra,12(sp)
8110a6a8:	df000215 	stw	fp,8(sp)
8110a6ac:	df000204 	addi	fp,sp,8
8110a6b0:	e13ffe15 	stw	r4,-8(fp)
8110a6b4:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110a6b8:	e0bfff17 	ldw	r2,-4(fp)
8110a6bc:	10800104 	addi	r2,r2,4
8110a6c0:	1007883a 	mov	r3,r2
8110a6c4:	00800044 	movi	r2,1
8110a6c8:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110a6cc:	e0bfff17 	ldw	r2,-4(fp)
8110a6d0:	0007883a 	mov	r3,zero
8110a6d4:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110a6d8:	e0bffe17 	ldw	r2,-8(fp)
8110a6dc:	00c00044 	movi	r3,1
8110a6e0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110a6e4:	01000044 	movi	r4,1
8110a6e8:	11348ec0 	call	811348ec <usleep>
    SDA_HIGH(data_base); // data high
8110a6ec:	e0bfff17 	ldw	r2,-4(fp)
8110a6f0:	00c00044 	movi	r3,1
8110a6f4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110a6f8:	01000044 	movi	r4,1
8110a6fc:	11348ec0 	call	811348ec <usleep>
    

    
}
8110a700:	0001883a 	nop
8110a704:	e037883a 	mov	sp,fp
8110a708:	dfc00117 	ldw	ra,4(sp)
8110a70c:	df000017 	ldw	fp,0(sp)
8110a710:	dec00204 	addi	sp,sp,8
8110a714:	f800283a 	ret

8110a718 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110a718:	defff804 	addi	sp,sp,-32
8110a71c:	de00012e 	bgeu	sp,et,8110a724 <i2c_write+0xc>
8110a720:	003b68fa 	trap	3
8110a724:	dfc00715 	stw	ra,28(sp)
8110a728:	df000615 	stw	fp,24(sp)
8110a72c:	df000604 	addi	fp,sp,24
8110a730:	e13ffd15 	stw	r4,-12(fp)
8110a734:	e17ffe15 	stw	r5,-8(fp)
8110a738:	3005883a 	mov	r2,r6
8110a73c:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110a740:	00bfe004 	movi	r2,-128
8110a744:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110a748:	e0bffe17 	ldw	r2,-8(fp)
8110a74c:	10800104 	addi	r2,r2,4
8110a750:	1007883a 	mov	r3,r2
8110a754:	00800044 	movi	r2,1
8110a758:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110a75c:	e03ffb15 	stw	zero,-20(fp)
8110a760:	00001f06 	br	8110a7e0 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110a764:	e0bffd17 	ldw	r2,-12(fp)
8110a768:	0007883a 	mov	r3,zero
8110a76c:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110a770:	e0ffff03 	ldbu	r3,-4(fp)
8110a774:	e0bffa03 	ldbu	r2,-24(fp)
8110a778:	1884703a 	and	r2,r3,r2
8110a77c:	10803fcc 	andi	r2,r2,255
8110a780:	10000426 	beq	r2,zero,8110a794 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110a784:	e0bffe17 	ldw	r2,-8(fp)
8110a788:	00c00044 	movi	r3,1
8110a78c:	10c00035 	stwio	r3,0(r2)
8110a790:	00000306 	br	8110a7a0 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110a794:	e0bffe17 	ldw	r2,-8(fp)
8110a798:	0007883a 	mov	r3,zero
8110a79c:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110a7a0:	e0bffa03 	ldbu	r2,-24(fp)
8110a7a4:	1004d07a 	srli	r2,r2,1
8110a7a8:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110a7ac:	e0bffd17 	ldw	r2,-12(fp)
8110a7b0:	00c00044 	movi	r3,1
8110a7b4:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a7b8:	01000044 	movi	r4,1
8110a7bc:	11348ec0 	call	811348ec <usleep>
        SCL_LOW(clk_base);
8110a7c0:	e0bffd17 	ldw	r2,-12(fp)
8110a7c4:	0007883a 	mov	r3,zero
8110a7c8:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a7cc:	01000044 	movi	r4,1
8110a7d0:	11348ec0 	call	811348ec <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110a7d4:	e0bffb17 	ldw	r2,-20(fp)
8110a7d8:	10800044 	addi	r2,r2,1
8110a7dc:	e0bffb15 	stw	r2,-20(fp)
8110a7e0:	e0bffb17 	ldw	r2,-20(fp)
8110a7e4:	10800210 	cmplti	r2,r2,8
8110a7e8:	103fde1e 	bne	r2,zero,8110a764 <__reset+0xfb0ea764>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110a7ec:	e0bffe17 	ldw	r2,-8(fp)
8110a7f0:	10800104 	addi	r2,r2,4
8110a7f4:	0007883a 	mov	r3,zero
8110a7f8:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110a7fc:	e0bffd17 	ldw	r2,-12(fp)
8110a800:	00c00044 	movi	r3,1
8110a804:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110a808:	01000044 	movi	r4,1
8110a80c:	11348ec0 	call	811348ec <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110a810:	e0bffe17 	ldw	r2,-8(fp)
8110a814:	10800037 	ldwio	r2,0(r2)
8110a818:	1005003a 	cmpeq	r2,r2,zero
8110a81c:	10803fcc 	andi	r2,r2,255
8110a820:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110a824:	e0bffd17 	ldw	r2,-12(fp)
8110a828:	0007883a 	mov	r3,zero
8110a82c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a830:	01000044 	movi	r4,1
8110a834:	11348ec0 	call	811348ec <usleep>
    return bAck;
8110a838:	e0bffc17 	ldw	r2,-16(fp)
}    
8110a83c:	e037883a 	mov	sp,fp
8110a840:	dfc00117 	ldw	ra,4(sp)
8110a844:	df000017 	ldw	fp,0(sp)
8110a848:	dec00204 	addi	sp,sp,8
8110a84c:	f800283a 	ret

8110a850 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110a850:	defff804 	addi	sp,sp,-32
8110a854:	de00012e 	bgeu	sp,et,8110a85c <i2c_read+0xc>
8110a858:	003b68fa 	trap	3
8110a85c:	dfc00715 	stw	ra,28(sp)
8110a860:	df000615 	stw	fp,24(sp)
8110a864:	df000604 	addi	fp,sp,24
8110a868:	e13ffc15 	stw	r4,-16(fp)
8110a86c:	e17ffd15 	stw	r5,-12(fp)
8110a870:	e1bffe15 	stw	r6,-8(fp)
8110a874:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110a878:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110a87c:	e0bffd17 	ldw	r2,-12(fp)
8110a880:	10800104 	addi	r2,r2,4
8110a884:	0007883a 	mov	r3,zero
8110a888:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110a88c:	e0bffc17 	ldw	r2,-16(fp)
8110a890:	0007883a 	mov	r3,zero
8110a894:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a898:	01000044 	movi	r4,1
8110a89c:	11348ec0 	call	811348ec <usleep>

    for(i=0;i<8;i++){
8110a8a0:	e03ffb15 	stw	zero,-20(fp)
8110a8a4:	00001606 	br	8110a900 <i2c_read+0xb0>
        Data <<= 1;
8110a8a8:	e0bffa03 	ldbu	r2,-24(fp)
8110a8ac:	1085883a 	add	r2,r2,r2
8110a8b0:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110a8b4:	e0bffc17 	ldw	r2,-16(fp)
8110a8b8:	00c00044 	movi	r3,1
8110a8bc:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a8c0:	01000044 	movi	r4,1
8110a8c4:	11348ec0 	call	811348ec <usleep>
        if (SDA_READ(data_base))  // read data   
8110a8c8:	e0bffd17 	ldw	r2,-12(fp)
8110a8cc:	10800037 	ldwio	r2,0(r2)
8110a8d0:	10000326 	beq	r2,zero,8110a8e0 <i2c_read+0x90>
            Data |= 0x01;
8110a8d4:	e0bffa03 	ldbu	r2,-24(fp)
8110a8d8:	10800054 	ori	r2,r2,1
8110a8dc:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110a8e0:	e0bffc17 	ldw	r2,-16(fp)
8110a8e4:	0007883a 	mov	r3,zero
8110a8e8:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a8ec:	01000044 	movi	r4,1
8110a8f0:	11348ec0 	call	811348ec <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110a8f4:	e0bffb17 	ldw	r2,-20(fp)
8110a8f8:	10800044 	addi	r2,r2,1
8110a8fc:	e0bffb15 	stw	r2,-20(fp)
8110a900:	e0bffb17 	ldw	r2,-20(fp)
8110a904:	10800210 	cmplti	r2,r2,8
8110a908:	103fe71e 	bne	r2,zero,8110a8a8 <__reset+0xfb0ea8a8>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110a90c:	e0bffc17 	ldw	r2,-16(fp)
8110a910:	0007883a 	mov	r3,zero
8110a914:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110a918:	e0bffd17 	ldw	r2,-12(fp)
8110a91c:	10800104 	addi	r2,r2,4
8110a920:	1007883a 	mov	r3,r2
8110a924:	00800044 	movi	r2,1
8110a928:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110a92c:	e0bfff17 	ldw	r2,-4(fp)
8110a930:	10000426 	beq	r2,zero,8110a944 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110a934:	e0bffd17 	ldw	r2,-12(fp)
8110a938:	0007883a 	mov	r3,zero
8110a93c:	10c00035 	stwio	r3,0(r2)
8110a940:	00000306 	br	8110a950 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110a944:	e0bffd17 	ldw	r2,-12(fp)
8110a948:	00c00044 	movi	r3,1
8110a94c:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110a950:	e0bffc17 	ldw	r2,-16(fp)
8110a954:	00c00044 	movi	r3,1
8110a958:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110a95c:	01000044 	movi	r4,1
8110a960:	11348ec0 	call	811348ec <usleep>
    SCL_LOW(clk_base); // clock low
8110a964:	e0bffc17 	ldw	r2,-16(fp)
8110a968:	0007883a 	mov	r3,zero
8110a96c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a970:	01000044 	movi	r4,1
8110a974:	11348ec0 	call	811348ec <usleep>
    SDA_LOW(data_base);  // data low
8110a978:	e0bffd17 	ldw	r2,-12(fp)
8110a97c:	0007883a 	mov	r3,zero
8110a980:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110a984:	01000044 	movi	r4,1
8110a988:	11348ec0 	call	811348ec <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110a98c:	e0bffe17 	ldw	r2,-8(fp)
8110a990:	e0fffa03 	ldbu	r3,-24(fp)
8110a994:	10c00005 	stb	r3,0(r2)
}
8110a998:	0001883a 	nop
8110a99c:	e037883a 	mov	sp,fp
8110a9a0:	dfc00117 	ldw	ra,4(sp)
8110a9a4:	df000017 	ldw	fp,0(sp)
8110a9a8:	dec00204 	addi	sp,sp,8
8110a9ac:	f800283a 	ret

8110a9b0 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110a9b0:	defffd04 	addi	sp,sp,-12
8110a9b4:	de00012e 	bgeu	sp,et,8110a9bc <bSetBoardLeds+0xc>
8110a9b8:	003b68fa 	trap	3
8110a9bc:	df000215 	stw	fp,8(sp)
8110a9c0:	df000204 	addi	fp,sp,8
8110a9c4:	e13ffe15 	stw	r4,-8(fp)
8110a9c8:	2805883a 	mov	r2,r5
8110a9cc:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110a9d0:	e0bffe17 	ldw	r2,-8(fp)
8110a9d4:	10800058 	cmpnei	r2,r2,1
8110a9d8:	1000071e 	bne	r2,zero,8110a9f8 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110a9dc:	e0bfff03 	ldbu	r2,-4(fp)
8110a9e0:	0084303a 	nor	r2,zero,r2
8110a9e4:	1007883a 	mov	r3,r2
8110a9e8:	d0a05003 	ldbu	r2,-32448(gp)
8110a9ec:	1884703a 	and	r2,r3,r2
8110a9f0:	d0a05005 	stb	r2,-32448(gp)
8110a9f4:	00000406 	br	8110aa08 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110a9f8:	d0e05003 	ldbu	r3,-32448(gp)
8110a9fc:	e0bfff03 	ldbu	r2,-4(fp)
8110aa00:	1884b03a 	or	r2,r3,r2
8110aa04:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110aa08:	d0a05003 	ldbu	r2,-32448(gp)
8110aa0c:	10c03fcc 	andi	r3,r2,255
8110aa10:	00a00034 	movhi	r2,32768
8110aa14:	10827404 	addi	r2,r2,2512
8110aa18:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110aa1c:	00800044 	movi	r2,1
}
8110aa20:	e037883a 	mov	sp,fp
8110aa24:	df000017 	ldw	fp,0(sp)
8110aa28:	dec00104 	addi	sp,sp,4
8110aa2c:	f800283a 	ret

8110aa30 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110aa30:	defffd04 	addi	sp,sp,-12
8110aa34:	de00012e 	bgeu	sp,et,8110aa3c <bSetPainelLeds+0xc>
8110aa38:	003b68fa 	trap	3
8110aa3c:	df000215 	stw	fp,8(sp)
8110aa40:	df000204 	addi	fp,sp,8
8110aa44:	e13ffe15 	stw	r4,-8(fp)
8110aa48:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110aa4c:	e0bffe17 	ldw	r2,-8(fp)
8110aa50:	10800058 	cmpnei	r2,r2,1
8110aa54:	1000051e 	bne	r2,zero,8110aa6c <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110aa58:	d0e00217 	ldw	r3,-32760(gp)
8110aa5c:	e0bfff17 	ldw	r2,-4(fp)
8110aa60:	1884b03a 	or	r2,r3,r2
8110aa64:	d0a00215 	stw	r2,-32760(gp)
8110aa68:	00000506 	br	8110aa80 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110aa6c:	e0bfff17 	ldw	r2,-4(fp)
8110aa70:	0086303a 	nor	r3,zero,r2
8110aa74:	d0a00217 	ldw	r2,-32760(gp)
8110aa78:	1884703a 	and	r2,r3,r2
8110aa7c:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110aa80:	d0a00217 	ldw	r2,-32760(gp)
8110aa84:	1007883a 	mov	r3,r2
8110aa88:	00a00034 	movhi	r2,32768
8110aa8c:	10824004 	addi	r2,r2,2304
8110aa90:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110aa94:	00800044 	movi	r2,1
}
8110aa98:	e037883a 	mov	sp,fp
8110aa9c:	df000017 	ldw	fp,0(sp)
8110aaa0:	dec00104 	addi	sp,sp,4
8110aaa4:	f800283a 	ret

8110aaa8 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110aaa8:	defffc04 	addi	sp,sp,-16
8110aaac:	de00012e 	bgeu	sp,et,8110aab4 <msgdma_write_extended_descriptor+0xc>
8110aab0:	003b68fa 	trap	3
8110aab4:	df000315 	stw	fp,12(sp)
8110aab8:	df000304 	addi	fp,sp,12
8110aabc:	e13ffd15 	stw	r4,-12(fp)
8110aac0:	e17ffe15 	stw	r5,-8(fp)
8110aac4:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110aac8:	e0bffd17 	ldw	r2,-12(fp)
8110aacc:	10800037 	ldwio	r2,0(r2)
8110aad0:	1080010c 	andi	r2,r2,4
8110aad4:	10000226 	beq	r2,zero,8110aae0 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110aad8:	00bff904 	movi	r2,-28
8110aadc:	00003d06 	br	8110abd4 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110aae0:	e0bfff17 	ldw	r2,-4(fp)
8110aae4:	10800017 	ldw	r2,0(r2)
8110aae8:	1007883a 	mov	r3,r2
8110aaec:	e0bffe17 	ldw	r2,-8(fp)
8110aaf0:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110aaf4:	e0bffe17 	ldw	r2,-8(fp)
8110aaf8:	10800104 	addi	r2,r2,4
8110aafc:	e0ffff17 	ldw	r3,-4(fp)
8110ab00:	18c00117 	ldw	r3,4(r3)
8110ab04:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110ab08:	e0bffe17 	ldw	r2,-8(fp)
8110ab0c:	10800204 	addi	r2,r2,8
8110ab10:	e0ffff17 	ldw	r3,-4(fp)
8110ab14:	18c00217 	ldw	r3,8(r3)
8110ab18:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110ab1c:	e0bffe17 	ldw	r2,-8(fp)
8110ab20:	10800304 	addi	r2,r2,12
8110ab24:	e0ffff17 	ldw	r3,-4(fp)
8110ab28:	18c0030b 	ldhu	r3,12(r3)
8110ab2c:	18ffffcc 	andi	r3,r3,65535
8110ab30:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110ab34:	e0bffe17 	ldw	r2,-8(fp)
8110ab38:	10800384 	addi	r2,r2,14
8110ab3c:	e0ffff17 	ldw	r3,-4(fp)
8110ab40:	18c00383 	ldbu	r3,14(r3)
8110ab44:	18c03fcc 	andi	r3,r3,255
8110ab48:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110ab4c:	e0bffe17 	ldw	r2,-8(fp)
8110ab50:	108003c4 	addi	r2,r2,15
8110ab54:	e0ffff17 	ldw	r3,-4(fp)
8110ab58:	18c003c3 	ldbu	r3,15(r3)
8110ab5c:	18c03fcc 	andi	r3,r3,255
8110ab60:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110ab64:	e0bffe17 	ldw	r2,-8(fp)
8110ab68:	10800404 	addi	r2,r2,16
8110ab6c:	e0ffff17 	ldw	r3,-4(fp)
8110ab70:	18c0040b 	ldhu	r3,16(r3)
8110ab74:	18ffffcc 	andi	r3,r3,65535
8110ab78:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110ab7c:	e0bffe17 	ldw	r2,-8(fp)
8110ab80:	10800484 	addi	r2,r2,18
8110ab84:	e0ffff17 	ldw	r3,-4(fp)
8110ab88:	18c0048b 	ldhu	r3,18(r3)
8110ab8c:	18ffffcc 	andi	r3,r3,65535
8110ab90:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110ab94:	e0bffe17 	ldw	r2,-8(fp)
8110ab98:	10800504 	addi	r2,r2,20
8110ab9c:	e0ffff17 	ldw	r3,-4(fp)
8110aba0:	18c00517 	ldw	r3,20(r3)
8110aba4:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110aba8:	e0bffe17 	ldw	r2,-8(fp)
8110abac:	10800604 	addi	r2,r2,24
8110abb0:	e0ffff17 	ldw	r3,-4(fp)
8110abb4:	18c00617 	ldw	r3,24(r3)
8110abb8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110abbc:	e0bffe17 	ldw	r2,-8(fp)
8110abc0:	10800704 	addi	r2,r2,28
8110abc4:	e0ffff17 	ldw	r3,-4(fp)
8110abc8:	18c00717 	ldw	r3,28(r3)
8110abcc:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110abd0:	0005883a 	mov	r2,zero
}
8110abd4:	e037883a 	mov	sp,fp
8110abd8:	df000017 	ldw	fp,0(sp)
8110abdc:	dec00104 	addi	sp,sp,4
8110abe0:	f800283a 	ret

8110abe4 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110abe4:	defff604 	addi	sp,sp,-40
8110abe8:	de00012e 	bgeu	sp,et,8110abf0 <msgdma_construct_extended_descriptor+0xc>
8110abec:	003b68fa 	trap	3
8110abf0:	df000915 	stw	fp,36(sp)
8110abf4:	df000904 	addi	fp,sp,36
8110abf8:	e13ff715 	stw	r4,-36(fp)
8110abfc:	e17ff815 	stw	r5,-32(fp)
8110ac00:	e1bff915 	stw	r6,-28(fp)
8110ac04:	e1fffa15 	stw	r7,-24(fp)
8110ac08:	e1800517 	ldw	r6,20(fp)
8110ac0c:	e1400617 	ldw	r5,24(fp)
8110ac10:	e1000717 	ldw	r4,28(fp)
8110ac14:	e0c00817 	ldw	r3,32(fp)
8110ac18:	e0800917 	ldw	r2,36(fp)
8110ac1c:	e1bffb0d 	sth	r6,-20(fp)
8110ac20:	e17ffc05 	stb	r5,-16(fp)
8110ac24:	e13ffd05 	stb	r4,-12(fp)
8110ac28:	e0fffe0d 	sth	r3,-8(fp)
8110ac2c:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110ac30:	e0bff717 	ldw	r2,-36(fp)
8110ac34:	10c01217 	ldw	r3,72(r2)
8110ac38:	e0800117 	ldw	r2,4(fp)
8110ac3c:	18801936 	bltu	r3,r2,8110aca4 <msgdma_construct_extended_descriptor+0xc0>
8110ac40:	e13ff717 	ldw	r4,-36(fp)
8110ac44:	20801317 	ldw	r2,76(r4)
8110ac48:	20c01417 	ldw	r3,80(r4)
8110ac4c:	e13ffe0b 	ldhu	r4,-8(fp)
8110ac50:	213fffcc 	andi	r4,r4,65535
8110ac54:	2015883a 	mov	r10,r4
8110ac58:	0017883a 	mov	r11,zero
8110ac5c:	1ac01136 	bltu	r3,r11,8110aca4 <msgdma_construct_extended_descriptor+0xc0>
8110ac60:	58c0011e 	bne	r11,r3,8110ac68 <msgdma_construct_extended_descriptor+0x84>
8110ac64:	12800f36 	bltu	r2,r10,8110aca4 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110ac68:	e13ff717 	ldw	r4,-36(fp)
8110ac6c:	20801317 	ldw	r2,76(r4)
8110ac70:	20c01417 	ldw	r3,80(r4)
8110ac74:	e13fff0b 	ldhu	r4,-4(fp)
8110ac78:	213fffcc 	andi	r4,r4,65535
8110ac7c:	2011883a 	mov	r8,r4
8110ac80:	0013883a 	mov	r9,zero
8110ac84:	1a400736 	bltu	r3,r9,8110aca4 <msgdma_construct_extended_descriptor+0xc0>
8110ac88:	48c0011e 	bne	r9,r3,8110ac90 <msgdma_construct_extended_descriptor+0xac>
8110ac8c:	12000536 	bltu	r2,r8,8110aca4 <msgdma_construct_extended_descriptor+0xc0>
8110ac90:	e0bff717 	ldw	r2,-36(fp)
8110ac94:	10801703 	ldbu	r2,92(r2)
8110ac98:	10803fcc 	andi	r2,r2,255
8110ac9c:	10800060 	cmpeqi	r2,r2,1
8110aca0:	1000021e 	bne	r2,zero,8110acac <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110aca4:	00bffa84 	movi	r2,-22
8110aca8:	00002306 	br	8110ad38 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110acac:	e0bff817 	ldw	r2,-32(fp)
8110acb0:	e0fff917 	ldw	r3,-28(fp)
8110acb4:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110acb8:	e0bff817 	ldw	r2,-32(fp)
8110acbc:	e0fffa17 	ldw	r3,-24(fp)
8110acc0:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110acc4:	e0bff817 	ldw	r2,-32(fp)
8110acc8:	e0c00117 	ldw	r3,4(fp)
8110accc:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110acd0:	e0bff817 	ldw	r2,-32(fp)
8110acd4:	e0fffb0b 	ldhu	r3,-20(fp)
8110acd8:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110acdc:	e0bff817 	ldw	r2,-32(fp)
8110ace0:	e0fffc03 	ldbu	r3,-16(fp)
8110ace4:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110ace8:	e0bff817 	ldw	r2,-32(fp)
8110acec:	e0fffd03 	ldbu	r3,-12(fp)
8110acf0:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110acf4:	e0bff817 	ldw	r2,-32(fp)
8110acf8:	e0fffe0b 	ldhu	r3,-8(fp)
8110acfc:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110ad00:	e0bff817 	ldw	r2,-32(fp)
8110ad04:	e0ffff0b 	ldhu	r3,-4(fp)
8110ad08:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110ad0c:	e0bff817 	ldw	r2,-32(fp)
8110ad10:	e0c00317 	ldw	r3,12(fp)
8110ad14:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110ad18:	e0bff817 	ldw	r2,-32(fp)
8110ad1c:	e0c00417 	ldw	r3,16(fp)
8110ad20:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110ad24:	e0800217 	ldw	r2,8(fp)
8110ad28:	10e00034 	orhi	r3,r2,32768
8110ad2c:	e0bff817 	ldw	r2,-32(fp)
8110ad30:	10c00715 	stw	r3,28(r2)

	return 0;
8110ad34:	0005883a 	mov	r2,zero

}
8110ad38:	e037883a 	mov	sp,fp
8110ad3c:	df000017 	ldw	fp,0(sp)
8110ad40:	dec00104 	addi	sp,sp,4
8110ad44:	f800283a 	ret

8110ad48 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110ad48:	deffee04 	addi	sp,sp,-72
8110ad4c:	de00012e 	bgeu	sp,et,8110ad54 <msgdma_descriptor_async_transfer+0xc>
8110ad50:	003b68fa 	trap	3
8110ad54:	dfc01115 	stw	ra,68(sp)
8110ad58:	df001015 	stw	fp,64(sp)
8110ad5c:	df001004 	addi	fp,sp,64
8110ad60:	e13ffd15 	stw	r4,-12(fp)
8110ad64:	e17ffe15 	stw	r5,-8(fp)
8110ad68:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110ad6c:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110ad70:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110ad74:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110ad78:	e0bffd17 	ldw	r2,-12(fp)
8110ad7c:	10800317 	ldw	r2,12(r2)
8110ad80:	10800204 	addi	r2,r2,8
8110ad84:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110ad88:	10bfffcc 	andi	r2,r2,65535
8110ad8c:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110ad90:	e0bffd17 	ldw	r2,-12(fp)
8110ad94:	10800317 	ldw	r2,12(r2)
8110ad98:	10800204 	addi	r2,r2,8
8110ad9c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110ada0:	1004d43a 	srli	r2,r2,16
8110ada4:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110ada8:	e0bffd17 	ldw	r2,-12(fp)
8110adac:	10800917 	ldw	r2,36(r2)
8110adb0:	e0fff417 	ldw	r3,-48(fp)
8110adb4:	1880042e 	bgeu	r3,r2,8110adc8 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110adb8:	e0bffd17 	ldw	r2,-12(fp)
8110adbc:	10800917 	ldw	r2,36(r2)
8110adc0:	e0fff317 	ldw	r3,-52(fp)
8110adc4:	18800236 	bltu	r3,r2,8110add0 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110adc8:	00bff904 	movi	r2,-28
8110adcc:	00009f06 	br	8110b04c <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110add0:	e0bffd17 	ldw	r2,-12(fp)
8110add4:	10801817 	ldw	r2,96(r2)
8110add8:	e0bff615 	stw	r2,-40(fp)
8110addc:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110ade0:	e0bffc0b 	ldhu	r2,-16(fp)
8110ade4:	e0fffc84 	addi	r3,fp,-14
8110ade8:	180d883a 	mov	r6,r3
8110adec:	100b883a 	mov	r5,r2
8110adf0:	e13ff617 	ldw	r4,-40(fp)
8110adf4:	113b6f00 	call	8113b6f0 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110adf8:	00800804 	movi	r2,32
8110adfc:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110ae00:	0005303a 	rdctl	r2,status
8110ae04:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110ae08:	e0fff717 	ldw	r3,-36(fp)
8110ae0c:	00bfff84 	movi	r2,-2
8110ae10:	1884703a 	and	r2,r3,r2
8110ae14:	1001703a 	wrctl	status,r2
  
  return context;
8110ae18:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110ae1c:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110ae20:	e0bffd17 	ldw	r2,-12(fp)
8110ae24:	10800317 	ldw	r2,12(r2)
8110ae28:	10800104 	addi	r2,r2,4
8110ae2c:	e0fff117 	ldw	r3,-60(fp)
8110ae30:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110ae34:	e0bffd17 	ldw	r2,-12(fp)
8110ae38:	10800317 	ldw	r2,12(r2)
8110ae3c:	e0fffd17 	ldw	r3,-12(fp)
8110ae40:	18c00317 	ldw	r3,12(r3)
8110ae44:	18c00037 	ldwio	r3,0(r3)
8110ae48:	10c00035 	stwio	r3,0(r2)
8110ae4c:	e0bff217 	ldw	r2,-56(fp)
8110ae50:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110ae54:	e0bffb17 	ldw	r2,-20(fp)
8110ae58:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110ae5c:	e0bffe17 	ldw	r2,-8(fp)
8110ae60:	10001026 	beq	r2,zero,8110aea4 <msgdma_descriptor_async_transfer+0x15c>
8110ae64:	e0bfff17 	ldw	r2,-4(fp)
8110ae68:	10000e1e 	bne	r2,zero,8110aea4 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110ae6c:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110ae70:	d0a06117 	ldw	r2,-32380(gp)
8110ae74:	100f883a 	mov	r7,r2
8110ae78:	01800784 	movi	r6,30
8110ae7c:	01400044 	movi	r5,1
8110ae80:	01204574 	movhi	r4,33045
8110ae84:	21241004 	addi	r4,r4,-28608
8110ae88:	111dcb00 	call	8111dcb0 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110ae8c:	e0bffd17 	ldw	r2,-12(fp)
8110ae90:	10801817 	ldw	r2,96(r2)
8110ae94:	1009883a 	mov	r4,r2
8110ae98:	113ba780 	call	8113ba78 <OSSemPost>

		return -ETIME;
8110ae9c:	00bff084 	movi	r2,-62
8110aea0:	00006a06 	br	8110b04c <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110aea4:	e0bffe17 	ldw	r2,-8(fp)
8110aea8:	1000231e 	bne	r2,zero,8110af38 <msgdma_descriptor_async_transfer+0x1f0>
8110aeac:	e0bfff17 	ldw	r2,-4(fp)
8110aeb0:	10002126 	beq	r2,zero,8110af38 <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110aeb4:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110aeb8:	00001506 	br	8110af10 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110aebc:	01000044 	movi	r4,1
8110aec0:	1132e780 	call	81132e78 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110aec4:	e0bff00b 	ldhu	r2,-64(fp)
8110aec8:	1084e230 	cmpltui	r2,r2,5000
8110aecc:	10000d1e 	bne	r2,zero,8110af04 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110aed0:	d0a06117 	ldw	r2,-32380(gp)
8110aed4:	100f883a 	mov	r7,r2
8110aed8:	01801544 	movi	r6,85
8110aedc:	01400044 	movi	r5,1
8110aee0:	01204574 	movhi	r4,33045
8110aee4:	21241804 	addi	r4,r4,-28576
8110aee8:	111dcb00 	call	8111dcb0 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110aeec:	e0bffd17 	ldw	r2,-12(fp)
8110aef0:	10801817 	ldw	r2,96(r2)
8110aef4:	1009883a 	mov	r4,r2
8110aef8:	113ba780 	call	8113ba78 <OSSemPost>

				return -ETIME;
8110aefc:	00bff084 	movi	r2,-62
8110af00:	00005206 	br	8110b04c <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110af04:	e0bff00b 	ldhu	r2,-64(fp)
8110af08:	10800044 	addi	r2,r2,1
8110af0c:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110af10:	e0bffd17 	ldw	r2,-12(fp)
8110af14:	10c00317 	ldw	r3,12(r2)
8110af18:	e0bffd17 	ldw	r2,-12(fp)
8110af1c:	10800417 	ldw	r2,16(r2)
8110af20:	e1bfff17 	ldw	r6,-4(fp)
8110af24:	100b883a 	mov	r5,r2
8110af28:	1809883a 	mov	r4,r3
8110af2c:	110aaa80 	call	8110aaa8 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110af30:	103fe21e 	bne	r2,zero,8110aebc <__reset+0xfb0eaebc>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110af34:	00000606 	br	8110af50 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110af38:	e0bffd17 	ldw	r2,-12(fp)
8110af3c:	10801817 	ldw	r2,96(r2)
8110af40:	1009883a 	mov	r4,r2
8110af44:	113ba780 	call	8113ba78 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110af48:	00bfffc4 	movi	r2,-1
8110af4c:	00003f06 	br	8110b04c <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110af50:	e0bffd17 	ldw	r2,-12(fp)
8110af54:	10800b17 	ldw	r2,44(r2)
8110af58:	10001c26 	beq	r2,zero,8110afcc <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110af5c:	e0bffd17 	ldw	r2,-12(fp)
8110af60:	10c00d17 	ldw	r3,52(r2)
8110af64:	e0bff117 	ldw	r2,-60(fp)
8110af68:	1884b03a 	or	r2,r3,r2
8110af6c:	10800514 	ori	r2,r2,20
8110af70:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110af74:	e0fff117 	ldw	r3,-60(fp)
8110af78:	00bff7c4 	movi	r2,-33
8110af7c:	1884703a 	and	r2,r3,r2
8110af80:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110af84:	0005303a 	rdctl	r2,status
8110af88:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110af8c:	e0fff917 	ldw	r3,-28(fp)
8110af90:	00bfff84 	movi	r2,-2
8110af94:	1884703a 	and	r2,r3,r2
8110af98:	1001703a 	wrctl	status,r2
  
  return context;
8110af9c:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110afa0:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110afa4:	e0bffd17 	ldw	r2,-12(fp)
8110afa8:	10800317 	ldw	r2,12(r2)
8110afac:	10800104 	addi	r2,r2,4
8110afb0:	e0fff117 	ldw	r3,-60(fp)
8110afb4:	10c00035 	stwio	r3,0(r2)
8110afb8:	e0bff217 	ldw	r2,-56(fp)
8110afbc:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110afc0:	e0bff517 	ldw	r2,-44(fp)
8110afc4:	1001703a 	wrctl	status,r2
8110afc8:	00001b06 	br	8110b038 <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110afcc:	e0bffd17 	ldw	r2,-12(fp)
8110afd0:	10c00d17 	ldw	r3,52(r2)
8110afd4:	e0bff117 	ldw	r2,-60(fp)
8110afd8:	1884b03a 	or	r2,r3,r2
8110afdc:	10800114 	ori	r2,r2,4
8110afe0:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110afe4:	e0fff117 	ldw	r3,-60(fp)
8110afe8:	00bff3c4 	movi	r2,-49
8110afec:	1884703a 	and	r2,r3,r2
8110aff0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110aff4:	0005303a 	rdctl	r2,status
8110aff8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110affc:	e0fffa17 	ldw	r3,-24(fp)
8110b000:	00bfff84 	movi	r2,-2
8110b004:	1884703a 	and	r2,r3,r2
8110b008:	1001703a 	wrctl	status,r2
  
  return context;
8110b00c:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b010:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b014:	e0bffd17 	ldw	r2,-12(fp)
8110b018:	10800317 	ldw	r2,12(r2)
8110b01c:	10800104 	addi	r2,r2,4
8110b020:	e0fff117 	ldw	r3,-60(fp)
8110b024:	10c00035 	stwio	r3,0(r2)
8110b028:	e0bff217 	ldw	r2,-56(fp)
8110b02c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b030:	e0bff817 	ldw	r2,-32(fp)
8110b034:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110b038:	e0bffd17 	ldw	r2,-12(fp)
8110b03c:	10801817 	ldw	r2,96(r2)
8110b040:	1009883a 	mov	r4,r2
8110b044:	113ba780 	call	8113ba78 <OSSemPost>

	return 0;
8110b048:	0005883a 	mov	r2,zero
}
8110b04c:	e037883a 	mov	sp,fp
8110b050:	dfc00117 	ldw	ra,4(sp)
8110b054:	df000017 	ldw	fp,0(sp)
8110b058:	dec00204 	addi	sp,sp,8
8110b05c:	f800283a 	ret

8110b060 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b060:	deffee04 	addi	sp,sp,-72
8110b064:	de00012e 	bgeu	sp,et,8110b06c <msgdma_descriptor_sync_transfer+0xc>
8110b068:	003b68fa 	trap	3
8110b06c:	dfc01115 	stw	ra,68(sp)
8110b070:	df001015 	stw	fp,64(sp)
8110b074:	df001004 	addi	fp,sp,64
8110b078:	e13ffd15 	stw	r4,-12(fp)
8110b07c:	e17ffe15 	stw	r5,-8(fp)
8110b080:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b084:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110b088:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110b08c:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110b090:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b094:	e0bffd17 	ldw	r2,-12(fp)
8110b098:	10800317 	ldw	r2,12(r2)
8110b09c:	10800204 	addi	r2,r2,8
8110b0a0:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b0a4:	10bfffcc 	andi	r2,r2,65535
8110b0a8:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b0ac:	e0bffd17 	ldw	r2,-12(fp)
8110b0b0:	10800317 	ldw	r2,12(r2)
8110b0b4:	10800204 	addi	r2,r2,8
8110b0b8:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b0bc:	1004d43a 	srli	r2,r2,16
8110b0c0:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110b0c4:	00807804 	movi	r2,480
8110b0c8:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b0cc:	00001d06 	br	8110b144 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110b0d0:	01000044 	movi	r4,1
8110b0d4:	1132e780 	call	81132e78 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b0d8:	e0bff10b 	ldhu	r2,-60(fp)
8110b0dc:	1084e230 	cmpltui	r2,r2,5000
8110b0e0:	1000091e 	bne	r2,zero,8110b108 <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
8110b0e4:	d0a06117 	ldw	r2,-32380(gp)
8110b0e8:	100f883a 	mov	r7,r2
8110b0ec:	01801304 	movi	r6,76
8110b0f0:	01400044 	movi	r5,1
8110b0f4:	01204574 	movhi	r4,33045
8110b0f8:	21242e04 	addi	r4,r4,-28488
8110b0fc:	111dcb00 	call	8111dcb0 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110b100:	00bff084 	movi	r2,-62
8110b104:	0000d006 	br	8110b448 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110b108:	e0bff10b 	ldhu	r2,-60(fp)
8110b10c:	10800044 	addi	r2,r2,1
8110b110:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b114:	e0bffd17 	ldw	r2,-12(fp)
8110b118:	10800317 	ldw	r2,12(r2)
8110b11c:	10800204 	addi	r2,r2,8
8110b120:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110b124:	10bfffcc 	andi	r2,r2,65535
8110b128:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b12c:	e0bffd17 	ldw	r2,-12(fp)
8110b130:	10800317 	ldw	r2,12(r2)
8110b134:	10800204 	addi	r2,r2,8
8110b138:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110b13c:	1004d43a 	srli	r2,r2,16
8110b140:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b144:	e0bffd17 	ldw	r2,-12(fp)
8110b148:	10800917 	ldw	r2,36(r2)
8110b14c:	e0fff317 	ldw	r3,-52(fp)
8110b150:	18bfdf2e 	bgeu	r3,r2,8110b0d0 <__reset+0xfb0eb0d0>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b154:	e0bffd17 	ldw	r2,-12(fp)
8110b158:	10800917 	ldw	r2,36(r2)
8110b15c:	e0fff217 	ldw	r3,-56(fp)
8110b160:	18bfdb2e 	bgeu	r3,r2,8110b0d0 <__reset+0xfb0eb0d0>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b164:	e0bffd17 	ldw	r2,-12(fp)
8110b168:	10801817 	ldw	r2,96(r2)
8110b16c:	e0bff815 	stw	r2,-32(fp)
8110b170:	e03ffc0d 	sth	zero,-16(fp)
8110b174:	e0bffc0b 	ldhu	r2,-16(fp)
8110b178:	e0fffc84 	addi	r3,fp,-14
8110b17c:	180d883a 	mov	r6,r3
8110b180:	100b883a 	mov	r5,r2
8110b184:	e13ff817 	ldw	r4,-32(fp)
8110b188:	113b6f00 	call	8113b6f0 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b18c:	0005303a 	rdctl	r2,status
8110b190:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b194:	e0fffb17 	ldw	r3,-20(fp)
8110b198:	00bfff84 	movi	r2,-2
8110b19c:	1884703a 	and	r2,r3,r2
8110b1a0:	1001703a 	wrctl	status,r2
  
  return context;
8110b1a4:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b1a8:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110b1ac:	e0bffd17 	ldw	r2,-12(fp)
8110b1b0:	10800317 	ldw	r2,12(r2)
8110b1b4:	10800104 	addi	r2,r2,4
8110b1b8:	00c00804 	movi	r3,32
8110b1bc:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b1c0:	e0bffd17 	ldw	r2,-12(fp)
8110b1c4:	10800317 	ldw	r2,12(r2)
8110b1c8:	e0fffd17 	ldw	r3,-12(fp)
8110b1cc:	18c00317 	ldw	r3,12(r3)
8110b1d0:	18c00037 	ldwio	r3,0(r3)
8110b1d4:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110b1d8:	e0bffe17 	ldw	r2,-8(fp)
8110b1dc:	10001026 	beq	r2,zero,8110b220 <msgdma_descriptor_sync_transfer+0x1c0>
8110b1e0:	e0bfff17 	ldw	r2,-4(fp)
8110b1e4:	10000e1e 	bne	r2,zero,8110b220 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110b1e8:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110b1ec:	d0a06117 	ldw	r2,-32380(gp)
8110b1f0:	100f883a 	mov	r7,r2
8110b1f4:	01800784 	movi	r6,30
8110b1f8:	01400044 	movi	r5,1
8110b1fc:	01204574 	movhi	r4,33045
8110b200:	21241004 	addi	r4,r4,-28608
8110b204:	111dcb00 	call	8111dcb0 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b208:	e0bffd17 	ldw	r2,-12(fp)
8110b20c:	10801817 	ldw	r2,96(r2)
8110b210:	1009883a 	mov	r4,r2
8110b214:	113ba780 	call	8113ba78 <OSSemPost>

		return -ETIME;
8110b218:	00bff084 	movi	r2,-62
8110b21c:	00008a06 	br	8110b448 <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b220:	e0bffe17 	ldw	r2,-8(fp)
8110b224:	1000231e 	bne	r2,zero,8110b2b4 <msgdma_descriptor_sync_transfer+0x254>
8110b228:	e0bfff17 	ldw	r2,-4(fp)
8110b22c:	10002126 	beq	r2,zero,8110b2b4 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
8110b230:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b234:	00001506 	br	8110b28c <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b238:	01000044 	movi	r4,1
8110b23c:	1132e780 	call	81132e78 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b240:	e0bff10b 	ldhu	r2,-60(fp)
8110b244:	1084e230 	cmpltui	r2,r2,5000
8110b248:	10000d1e 	bne	r2,zero,8110b280 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
8110b24c:	d0a06117 	ldw	r2,-32380(gp)
8110b250:	100f883a 	mov	r7,r2
8110b254:	01801004 	movi	r6,64
8110b258:	01400044 	movi	r5,1
8110b25c:	01204574 	movhi	r4,33045
8110b260:	21244204 	addi	r4,r4,-28408
8110b264:	111dcb00 	call	8111dcb0 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110b268:	e0bffd17 	ldw	r2,-12(fp)
8110b26c:	10801817 	ldw	r2,96(r2)
8110b270:	1009883a 	mov	r4,r2
8110b274:	113ba780 	call	8113ba78 <OSSemPost>

				return -ETIME;
8110b278:	00bff084 	movi	r2,-62
8110b27c:	00007206 	br	8110b448 <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
8110b280:	e0bff10b 	ldhu	r2,-60(fp)
8110b284:	10800044 	addi	r2,r2,1
8110b288:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b28c:	e0bffd17 	ldw	r2,-12(fp)
8110b290:	10c00317 	ldw	r3,12(r2)
8110b294:	e0bffd17 	ldw	r2,-12(fp)
8110b298:	10800417 	ldw	r2,16(r2)
8110b29c:	e1bfff17 	ldw	r6,-4(fp)
8110b2a0:	100b883a 	mov	r5,r2
8110b2a4:	1809883a 	mov	r4,r3
8110b2a8:	110aaa80 	call	8110aaa8 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b2ac:	103fe21e 	bne	r2,zero,8110b238 <__reset+0xfb0eb238>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b2b0:	00000606 	br	8110b2cc <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b2b4:	e0bffd17 	ldw	r2,-12(fp)
8110b2b8:	10801817 	ldw	r2,96(r2)
8110b2bc:	1009883a 	mov	r4,r2
8110b2c0:	113ba780 	call	8113ba78 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b2c4:	00bfffc4 	movi	r2,-1
8110b2c8:	00005f06 	br	8110b448 <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110b2cc:	e0bffd17 	ldw	r2,-12(fp)
8110b2d0:	10800317 	ldw	r2,12(r2)
8110b2d4:	10800104 	addi	r2,r2,4
8110b2d8:	e0fffd17 	ldw	r3,-12(fp)
8110b2dc:	19000d17 	ldw	r4,52(r3)
8110b2e0:	00fff2c4 	movi	r3,-53
8110b2e4:	20c6703a 	and	r3,r4,r3
8110b2e8:	18c00114 	ori	r3,r3,4
8110b2ec:	10c00035 	stwio	r3,0(r2)
8110b2f0:	e0bff517 	ldw	r2,-44(fp)
8110b2f4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b2f8:	e0bff717 	ldw	r2,-36(fp)
8110b2fc:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110b300:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110b304:	e0bffd17 	ldw	r2,-12(fp)
8110b308:	10800317 	ldw	r2,12(r2)
8110b30c:	10800037 	ldwio	r2,0(r2)
8110b310:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110b314:	00001906 	br	8110b37c <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
8110b318:	01000044 	movi	r4,1
8110b31c:	1132e780 	call	81132e78 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b320:	e0bff10b 	ldhu	r2,-60(fp)
8110b324:	1084e230 	cmpltui	r2,r2,5000
8110b328:	10000d1e 	bne	r2,zero,8110b360 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
8110b32c:	d0a06117 	ldw	r2,-32380(gp)
8110b330:	100f883a 	mov	r7,r2
8110b334:	01801184 	movi	r6,70
8110b338:	01400044 	movi	r5,1
8110b33c:	01204574 	movhi	r4,33045
8110b340:	21245304 	addi	r4,r4,-28340
8110b344:	111dcb00 	call	8111dcb0 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110b348:	e0bffd17 	ldw	r2,-12(fp)
8110b34c:	10801817 	ldw	r2,96(r2)
8110b350:	1009883a 	mov	r4,r2
8110b354:	113ba780 	call	8113ba78 <OSSemPost>

			return -ETIME;
8110b358:	00bff084 	movi	r2,-62
8110b35c:	00003a06 	br	8110b448 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110b360:	e0bff10b 	ldhu	r2,-60(fp)
8110b364:	10800044 	addi	r2,r2,1
8110b368:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110b36c:	e0bffd17 	ldw	r2,-12(fp)
8110b370:	10800317 	ldw	r2,12(r2)
8110b374:	10800037 	ldwio	r2,0(r2)
8110b378:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110b37c:	e0fff017 	ldw	r3,-64(fp)
8110b380:	e0bff617 	ldw	r2,-40(fp)
8110b384:	1884703a 	and	r2,r3,r2
8110b388:	1000031e 	bne	r2,zero,8110b398 <msgdma_descriptor_sync_transfer+0x338>
8110b38c:	e0bff017 	ldw	r2,-64(fp)
8110b390:	1080004c 	andi	r2,r2,1
8110b394:	103fe01e 	bne	r2,zero,8110b318 <__reset+0xfb0eb318>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110b398:	e0fff017 	ldw	r3,-64(fp)
8110b39c:	e0bff617 	ldw	r2,-40(fp)
8110b3a0:	1884703a 	and	r2,r3,r2
8110b3a4:	10000626 	beq	r2,zero,8110b3c0 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b3a8:	e0bffd17 	ldw	r2,-12(fp)
8110b3ac:	10801817 	ldw	r2,96(r2)
8110b3b0:	1009883a 	mov	r4,r2
8110b3b4:	113ba780 	call	8113ba78 <OSSemPost>

		return error;
8110b3b8:	e0bff617 	ldw	r2,-40(fp)
8110b3bc:	00002206 	br	8110b448 <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110b3c0:	e0bffd17 	ldw	r2,-12(fp)
8110b3c4:	10800317 	ldw	r2,12(r2)
8110b3c8:	10800104 	addi	r2,r2,4
8110b3cc:	10800037 	ldwio	r2,0(r2)
8110b3d0:	10800814 	ori	r2,r2,32
8110b3d4:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b3d8:	0005303a 	rdctl	r2,status
8110b3dc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b3e0:	e0fffa17 	ldw	r3,-24(fp)
8110b3e4:	00bfff84 	movi	r2,-2
8110b3e8:	1884703a 	and	r2,r3,r2
8110b3ec:	1001703a 	wrctl	status,r2
  
  return context;
8110b3f0:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b3f4:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b3f8:	e0bffd17 	ldw	r2,-12(fp)
8110b3fc:	10800317 	ldw	r2,12(r2)
8110b400:	10800104 	addi	r2,r2,4
8110b404:	e0fff417 	ldw	r3,-48(fp)
8110b408:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b40c:	e0bffd17 	ldw	r2,-12(fp)
8110b410:	10800317 	ldw	r2,12(r2)
8110b414:	e0fffd17 	ldw	r3,-12(fp)
8110b418:	18c00317 	ldw	r3,12(r3)
8110b41c:	18c00037 	ldwio	r3,0(r3)
8110b420:	10c00035 	stwio	r3,0(r2)
8110b424:	e0bff517 	ldw	r2,-44(fp)
8110b428:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b42c:	e0bff917 	ldw	r2,-28(fp)
8110b430:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110b434:	e0bffd17 	ldw	r2,-12(fp)
8110b438:	10801817 	ldw	r2,96(r2)
8110b43c:	1009883a 	mov	r4,r2
8110b440:	113ba780 	call	8113ba78 <OSSemPost>

	return 0;
8110b444:	0005883a 	mov	r2,zero

}
8110b448:	e037883a 	mov	sp,fp
8110b44c:	dfc00117 	ldw	ra,4(sp)
8110b450:	df000017 	ldw	fp,0(sp)
8110b454:	dec00204 	addi	sp,sp,8
8110b458:	f800283a 	ret

8110b45c <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110b45c:	deffec04 	addi	sp,sp,-80
8110b460:	de00012e 	bgeu	sp,et,8110b468 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110b464:	003b68fa 	trap	3
8110b468:	dfc01315 	stw	ra,76(sp)
8110b46c:	df001215 	stw	fp,72(sp)
8110b470:	df001204 	addi	fp,sp,72
8110b474:	e13ff715 	stw	r4,-36(fp)
8110b478:	e17ff815 	stw	r5,-32(fp)
8110b47c:	e1bff915 	stw	r6,-28(fp)
8110b480:	e1fffa15 	stw	r7,-24(fp)
8110b484:	e1800617 	ldw	r6,24(fp)
8110b488:	e1400717 	ldw	r5,28(fp)
8110b48c:	e1000817 	ldw	r4,32(fp)
8110b490:	e0c00917 	ldw	r3,36(fp)
8110b494:	e0800a17 	ldw	r2,40(fp)
8110b498:	e1bffb0d 	sth	r6,-20(fp)
8110b49c:	e17ffc05 	stb	r5,-16(fp)
8110b4a0:	e13ffd05 	stb	r4,-12(fp)
8110b4a4:	e0fffe0d 	sth	r3,-8(fp)
8110b4a8:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110b4ac:	e0bffb0b 	ldhu	r2,-20(fp)
8110b4b0:	e0fffc03 	ldbu	r3,-16(fp)
8110b4b4:	e13ffd03 	ldbu	r4,-12(fp)
8110b4b8:	e17ffe0b 	ldhu	r5,-8(fp)
8110b4bc:	e1bfff0b 	ldhu	r6,-4(fp)
8110b4c0:	d9800815 	stw	r6,32(sp)
8110b4c4:	d9400715 	stw	r5,28(sp)
8110b4c8:	d9000615 	stw	r4,24(sp)
8110b4cc:	d8c00515 	stw	r3,20(sp)
8110b4d0:	d8800415 	stw	r2,16(sp)
8110b4d4:	e0800517 	ldw	r2,20(fp)
8110b4d8:	d8800315 	stw	r2,12(sp)
8110b4dc:	e0800417 	ldw	r2,16(fp)
8110b4e0:	d8800215 	stw	r2,8(sp)
8110b4e4:	e0800317 	ldw	r2,12(fp)
8110b4e8:	d8800115 	stw	r2,4(sp)
8110b4ec:	e0800217 	ldw	r2,8(fp)
8110b4f0:	d8800015 	stw	r2,0(sp)
8110b4f4:	e1fffa17 	ldw	r7,-24(fp)
8110b4f8:	e1bff917 	ldw	r6,-28(fp)
8110b4fc:	e17ff817 	ldw	r5,-32(fp)
8110b500:	e13ff717 	ldw	r4,-36(fp)
8110b504:	110abe40 	call	8110abe4 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110b508:	e037883a 	mov	sp,fp
8110b50c:	dfc00117 	ldw	ra,4(sp)
8110b510:	df000017 	ldw	fp,0(sp)
8110b514:	dec00204 	addi	sp,sp,8
8110b518:	f800283a 	ret

8110b51c <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110b51c:	defffc04 	addi	sp,sp,-16
8110b520:	de00012e 	bgeu	sp,et,8110b528 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110b524:	003b68fa 	trap	3
8110b528:	dfc00315 	stw	ra,12(sp)
8110b52c:	df000215 	stw	fp,8(sp)
8110b530:	df000204 	addi	fp,sp,8
8110b534:	e13ffe15 	stw	r4,-8(fp)
8110b538:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110b53c:	e1bfff17 	ldw	r6,-4(fp)
8110b540:	000b883a 	mov	r5,zero
8110b544:	e13ffe17 	ldw	r4,-8(fp)
8110b548:	110ad480 	call	8110ad48 <msgdma_descriptor_async_transfer>
}
8110b54c:	e037883a 	mov	sp,fp
8110b550:	dfc00117 	ldw	ra,4(sp)
8110b554:	df000017 	ldw	fp,0(sp)
8110b558:	dec00204 	addi	sp,sp,8
8110b55c:	f800283a 	ret

8110b560 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110b560:	defffc04 	addi	sp,sp,-16
8110b564:	de00012e 	bgeu	sp,et,8110b56c <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110b568:	003b68fa 	trap	3
8110b56c:	dfc00315 	stw	ra,12(sp)
8110b570:	df000215 	stw	fp,8(sp)
8110b574:	df000204 	addi	fp,sp,8
8110b578:	e13ffe15 	stw	r4,-8(fp)
8110b57c:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110b580:	e1bfff17 	ldw	r6,-4(fp)
8110b584:	000b883a 	mov	r5,zero
8110b588:	e13ffe17 	ldw	r4,-8(fp)
8110b58c:	110b0600 	call	8110b060 <msgdma_descriptor_sync_transfer>
}
8110b590:	e037883a 	mov	sp,fp
8110b594:	dfc00117 	ldw	ra,4(sp)
8110b598:	df000017 	ldw	fp,0(sp)
8110b59c:	dec00204 	addi	sp,sp,8
8110b5a0:	f800283a 	ret

8110b5a4 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110b5a4:	defff204 	addi	sp,sp,-56
8110b5a8:	de00012e 	bgeu	sp,et,8110b5b0 <POWER_SPI_RW+0xc>
8110b5ac:	003b68fa 	trap	3
8110b5b0:	dfc00d15 	stw	ra,52(sp)
8110b5b4:	df000c15 	stw	fp,48(sp)
8110b5b8:	df000c04 	addi	fp,sp,48
8110b5bc:	2007883a 	mov	r3,r4
8110b5c0:	2805883a 	mov	r2,r5
8110b5c4:	e1bffe15 	stw	r6,-8(fp)
8110b5c8:	e1ffff15 	stw	r7,-4(fp)
8110b5cc:	e0fffc05 	stb	r3,-16(fp)
8110b5d0:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110b5d4:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110b5d8:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110b5dc:	008003f4 	movhi	r2,15
8110b5e0:	10909004 	addi	r2,r2,16960
8110b5e4:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110b5e8:	00bfe004 	movi	r2,-128
8110b5ec:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110b5f0:	e0bffe17 	ldw	r2,-8(fp)
8110b5f4:	10000226 	beq	r2,zero,8110b600 <POWER_SPI_RW+0x5c>
8110b5f8:	00800804 	movi	r2,32
8110b5fc:	00000106 	br	8110b604 <POWER_SPI_RW+0x60>
8110b600:	0005883a 	mov	r2,zero
8110b604:	e0fff403 	ldbu	r3,-48(fp)
8110b608:	10c4b03a 	or	r2,r2,r3
8110b60c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110b610:	e0800217 	ldw	r2,8(fp)
8110b614:	10000226 	beq	r2,zero,8110b620 <POWER_SPI_RW+0x7c>
8110b618:	00800404 	movi	r2,16
8110b61c:	00000106 	br	8110b624 <POWER_SPI_RW+0x80>
8110b620:	0005883a 	mov	r2,zero
8110b624:	e0fff403 	ldbu	r3,-48(fp)
8110b628:	10c4b03a 	or	r2,r2,r3
8110b62c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110b630:	e0bfff17 	ldw	r2,-4(fp)
8110b634:	10000226 	beq	r2,zero,8110b640 <POWER_SPI_RW+0x9c>
8110b638:	00800204 	movi	r2,8
8110b63c:	00000106 	br	8110b644 <POWER_SPI_RW+0xa0>
8110b640:	0005883a 	mov	r2,zero
8110b644:	e0fff403 	ldbu	r3,-48(fp)
8110b648:	10c4b03a 	or	r2,r2,r3
8110b64c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110b650:	e0bffd03 	ldbu	r2,-12(fp)
8110b654:	108001cc 	andi	r2,r2,7
8110b658:	1007883a 	mov	r3,r2
8110b65c:	e0bff403 	ldbu	r2,-48(fp)
8110b660:	1884b03a 	or	r2,r3,r2
8110b664:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110b668:	0007883a 	mov	r3,zero
8110b66c:	00a00034 	movhi	r2,32768
8110b670:	10824404 	addi	r2,r2,2320
8110b674:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110b678:	0007883a 	mov	r3,zero
8110b67c:	00a00034 	movhi	r2,32768
8110b680:	10824c04 	addi	r2,r2,2352
8110b684:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110b688:	e0bffc03 	ldbu	r2,-16(fp)
8110b68c:	1000021e 	bne	r2,zero,8110b698 <POWER_SPI_RW+0xf4>
8110b690:	00c00084 	movi	r3,2
8110b694:	00000106 	br	8110b69c <POWER_SPI_RW+0xf8>
8110b698:	00c00044 	movi	r3,1
8110b69c:	00a00034 	movhi	r2,32768
8110b6a0:	10824804 	addi	r2,r2,2336
8110b6a4:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110b6a8:	010003c4 	movi	r4,15
8110b6ac:	11348ec0 	call	811348ec <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110b6b0:	00000306 	br	8110b6c0 <POWER_SPI_RW+0x11c>
		nWait++;
8110b6b4:	e0bff817 	ldw	r2,-32(fp)
8110b6b8:	10800044 	addi	r2,r2,1
8110b6bc:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110b6c0:	00a00034 	movhi	r2,32768
8110b6c4:	10825404 	addi	r2,r2,2384
8110b6c8:	10800037 	ldwio	r2,0(r2)
8110b6cc:	1080004c 	andi	r2,r2,1
8110b6d0:	10000326 	beq	r2,zero,8110b6e0 <POWER_SPI_RW+0x13c>
8110b6d4:	e0fff817 	ldw	r3,-32(fp)
8110b6d8:	e0bffa17 	ldw	r2,-24(fp)
8110b6dc:	18bff516 	blt	r3,r2,8110b6b4 <__reset+0xfb0eb6b4>
		nWait++;
	}

	if (SPI_SDO) {
8110b6e0:	00a00034 	movhi	r2,32768
8110b6e4:	10825404 	addi	r2,r2,2384
8110b6e8:	10800037 	ldwio	r2,0(r2)
8110b6ec:	1080004c 	andi	r2,r2,1
8110b6f0:	10000626 	beq	r2,zero,8110b70c <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110b6f4:	00c000c4 	movi	r3,3
8110b6f8:	00a00034 	movhi	r2,32768
8110b6fc:	10824804 	addi	r2,r2,2336
8110b700:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110b704:	0005883a 	mov	r2,zero
8110b708:	0000db06 	br	8110ba78 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110b70c:	e03ff715 	stw	zero,-36(fp)
8110b710:	00002406 	br	8110b7a4 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110b714:	e0bff403 	ldbu	r2,-48(fp)
8110b718:	10803fcc 	andi	r2,r2,255
8110b71c:	1004d1fa 	srli	r2,r2,7
8110b720:	10c03fcc 	andi	r3,r2,255
8110b724:	00a00034 	movhi	r2,32768
8110b728:	10825004 	addi	r2,r2,2368
8110b72c:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110b730:	e0bff403 	ldbu	r2,-48(fp)
8110b734:	1085883a 	add	r2,r2,r2
8110b738:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110b73c:	e0bff517 	ldw	r2,-44(fp)
8110b740:	1085883a 	add	r2,r2,r2
8110b744:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110b748:	00a00034 	movhi	r2,32768
8110b74c:	10825404 	addi	r2,r2,2384
8110b750:	10800037 	ldwio	r2,0(r2)
8110b754:	1080004c 	andi	r2,r2,1
8110b758:	1007883a 	mov	r3,r2
8110b75c:	e0bff517 	ldw	r2,-44(fp)
8110b760:	10c4b03a 	or	r2,r2,r3
8110b764:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b768:	00c00044 	movi	r3,1
8110b76c:	00a00034 	movhi	r2,32768
8110b770:	10824c04 	addi	r2,r2,2352
8110b774:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b778:	010003c4 	movi	r4,15
8110b77c:	11348ec0 	call	811348ec <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b780:	0007883a 	mov	r3,zero
8110b784:	00a00034 	movhi	r2,32768
8110b788:	10824c04 	addi	r2,r2,2352
8110b78c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b790:	010003c4 	movi	r4,15
8110b794:	11348ec0 	call	811348ec <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110b798:	e0bff717 	ldw	r2,-36(fp)
8110b79c:	10800044 	addi	r2,r2,1
8110b7a0:	e0bff715 	stw	r2,-36(fp)
8110b7a4:	e0bff717 	ldw	r2,-36(fp)
8110b7a8:	10800090 	cmplti	r2,r2,2
8110b7ac:	103fd91e 	bne	r2,zero,8110b714 <__reset+0xfb0eb714>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110b7b0:	e03ff715 	stw	zero,-36(fp)
8110b7b4:	00002406 	br	8110b848 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110b7b8:	e0bff403 	ldbu	r2,-48(fp)
8110b7bc:	10803fcc 	andi	r2,r2,255
8110b7c0:	1004d1fa 	srli	r2,r2,7
8110b7c4:	10c03fcc 	andi	r3,r2,255
8110b7c8:	00a00034 	movhi	r2,32768
8110b7cc:	10825004 	addi	r2,r2,2368
8110b7d0:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110b7d4:	e0bff403 	ldbu	r2,-48(fp)
8110b7d8:	1085883a 	add	r2,r2,r2
8110b7dc:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110b7e0:	e0bff517 	ldw	r2,-44(fp)
8110b7e4:	1085883a 	add	r2,r2,r2
8110b7e8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110b7ec:	00a00034 	movhi	r2,32768
8110b7f0:	10825404 	addi	r2,r2,2384
8110b7f4:	10800037 	ldwio	r2,0(r2)
8110b7f8:	1080004c 	andi	r2,r2,1
8110b7fc:	1007883a 	mov	r3,r2
8110b800:	e0bff517 	ldw	r2,-44(fp)
8110b804:	10c4b03a 	or	r2,r2,r3
8110b808:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b80c:	00c00044 	movi	r3,1
8110b810:	00a00034 	movhi	r2,32768
8110b814:	10824c04 	addi	r2,r2,2352
8110b818:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b81c:	010003c4 	movi	r4,15
8110b820:	11348ec0 	call	811348ec <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b824:	0007883a 	mov	r3,zero
8110b828:	00a00034 	movhi	r2,32768
8110b82c:	10824c04 	addi	r2,r2,2352
8110b830:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b834:	010003c4 	movi	r4,15
8110b838:	11348ec0 	call	811348ec <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110b83c:	e0bff717 	ldw	r2,-36(fp)
8110b840:	10800044 	addi	r2,r2,1
8110b844:	e0bff715 	stw	r2,-36(fp)
8110b848:	e0bff717 	ldw	r2,-36(fp)
8110b84c:	10800210 	cmplti	r2,r2,8
8110b850:	103fd91e 	bne	r2,zero,8110b7b8 <__reset+0xfb0eb7b8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110b854:	e03ff715 	stw	zero,-36(fp)
8110b858:	00001a06 	br	8110b8c4 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110b85c:	e0bff517 	ldw	r2,-44(fp)
8110b860:	1085883a 	add	r2,r2,r2
8110b864:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110b868:	00a00034 	movhi	r2,32768
8110b86c:	10825404 	addi	r2,r2,2384
8110b870:	10800037 	ldwio	r2,0(r2)
8110b874:	1080004c 	andi	r2,r2,1
8110b878:	1007883a 	mov	r3,r2
8110b87c:	e0bff517 	ldw	r2,-44(fp)
8110b880:	10c4b03a 	or	r2,r2,r3
8110b884:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b888:	00c00044 	movi	r3,1
8110b88c:	00a00034 	movhi	r2,32768
8110b890:	10824c04 	addi	r2,r2,2352
8110b894:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b898:	010003c4 	movi	r4,15
8110b89c:	11348ec0 	call	811348ec <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b8a0:	0007883a 	mov	r3,zero
8110b8a4:	00a00034 	movhi	r2,32768
8110b8a8:	10824c04 	addi	r2,r2,2352
8110b8ac:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b8b0:	010003c4 	movi	r4,15
8110b8b4:	11348ec0 	call	811348ec <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110b8b8:	e0bff717 	ldw	r2,-36(fp)
8110b8bc:	10800044 	addi	r2,r2,1
8110b8c0:	e0bff715 	stw	r2,-36(fp)
8110b8c4:	e0bff717 	ldw	r2,-36(fp)
8110b8c8:	10800210 	cmplti	r2,r2,8
8110b8cc:	103fe31e 	bne	r2,zero,8110b85c <__reset+0xfb0eb85c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110b8d0:	e03ff715 	stw	zero,-36(fp)
8110b8d4:	00001a06 	br	8110b940 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110b8d8:	e0bff517 	ldw	r2,-44(fp)
8110b8dc:	1085883a 	add	r2,r2,r2
8110b8e0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110b8e4:	00a00034 	movhi	r2,32768
8110b8e8:	10825404 	addi	r2,r2,2384
8110b8ec:	10800037 	ldwio	r2,0(r2)
8110b8f0:	1080004c 	andi	r2,r2,1
8110b8f4:	1007883a 	mov	r3,r2
8110b8f8:	e0bff517 	ldw	r2,-44(fp)
8110b8fc:	10c4b03a 	or	r2,r2,r3
8110b900:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b904:	00c00044 	movi	r3,1
8110b908:	00a00034 	movhi	r2,32768
8110b90c:	10824c04 	addi	r2,r2,2352
8110b910:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b914:	010003c4 	movi	r4,15
8110b918:	11348ec0 	call	811348ec <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b91c:	0007883a 	mov	r3,zero
8110b920:	00a00034 	movhi	r2,32768
8110b924:	10824c04 	addi	r2,r2,2352
8110b928:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b92c:	010003c4 	movi	r4,15
8110b930:	11348ec0 	call	811348ec <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110b934:	e0bff717 	ldw	r2,-36(fp)
8110b938:	10800044 	addi	r2,r2,1
8110b93c:	e0bff715 	stw	r2,-36(fp)
8110b940:	e0bff717 	ldw	r2,-36(fp)
8110b944:	10800210 	cmplti	r2,r2,8
8110b948:	103fe31e 	bne	r2,zero,8110b8d8 <__reset+0xfb0eb8d8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110b94c:	e03ff715 	stw	zero,-36(fp)
8110b950:	00001a06 	br	8110b9bc <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110b954:	e0bff517 	ldw	r2,-44(fp)
8110b958:	1085883a 	add	r2,r2,r2
8110b95c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110b960:	00a00034 	movhi	r2,32768
8110b964:	10825404 	addi	r2,r2,2384
8110b968:	10800037 	ldwio	r2,0(r2)
8110b96c:	1080004c 	andi	r2,r2,1
8110b970:	1007883a 	mov	r3,r2
8110b974:	e0bff517 	ldw	r2,-44(fp)
8110b978:	10c4b03a 	or	r2,r2,r3
8110b97c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b980:	00c00044 	movi	r3,1
8110b984:	00a00034 	movhi	r2,32768
8110b988:	10824c04 	addi	r2,r2,2352
8110b98c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b990:	010003c4 	movi	r4,15
8110b994:	11348ec0 	call	811348ec <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b998:	0007883a 	mov	r3,zero
8110b99c:	00a00034 	movhi	r2,32768
8110b9a0:	10824c04 	addi	r2,r2,2352
8110b9a4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b9a8:	010003c4 	movi	r4,15
8110b9ac:	11348ec0 	call	811348ec <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110b9b0:	e0bff717 	ldw	r2,-36(fp)
8110b9b4:	10800044 	addi	r2,r2,1
8110b9b8:	e0bff715 	stw	r2,-36(fp)
8110b9bc:	e0bff717 	ldw	r2,-36(fp)
8110b9c0:	10800190 	cmplti	r2,r2,6
8110b9c4:	103fe31e 	bne	r2,zero,8110b954 <__reset+0xfb0eb954>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110b9c8:	00c00044 	movi	r3,1
8110b9cc:	00a00034 	movhi	r2,32768
8110b9d0:	10824c04 	addi	r2,r2,2352
8110b9d4:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110b9d8:	010003c4 	movi	r4,15
8110b9dc:	11348ec0 	call	811348ec <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110b9e0:	00c000c4 	movi	r3,3
8110b9e4:	00a00034 	movhi	r2,32768
8110b9e8:	10824804 	addi	r2,r2,2336
8110b9ec:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110b9f0:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110b9f4:	00800044 	movi	r2,1
8110b9f8:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110b9fc:	e03ff715 	stw	zero,-36(fp)
8110ba00:	00000d06 	br	8110ba38 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110ba04:	e0fff517 	ldw	r3,-44(fp)
8110ba08:	e0bff617 	ldw	r2,-40(fp)
8110ba0c:	1884703a 	and	r2,r3,r2
8110ba10:	1000031e 	bne	r2,zero,8110ba20 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110ba14:	e0bff917 	ldw	r2,-28(fp)
8110ba18:	10800044 	addi	r2,r2,1
8110ba1c:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110ba20:	e0bff617 	ldw	r2,-40(fp)
8110ba24:	1085883a 	add	r2,r2,r2
8110ba28:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110ba2c:	e0bff717 	ldw	r2,-36(fp)
8110ba30:	10800044 	addi	r2,r2,1
8110ba34:	e0bff715 	stw	r2,-36(fp)
8110ba38:	e0bff717 	ldw	r2,-36(fp)
8110ba3c:	10800810 	cmplti	r2,r2,32
8110ba40:	103ff01e 	bne	r2,zero,8110ba04 <__reset+0xfb0eba04>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110ba44:	e0bff917 	ldw	r2,-28(fp)
8110ba48:	1080004c 	andi	r2,r2,1
8110ba4c:	1005003a 	cmpeq	r2,r2,zero
8110ba50:	10803fcc 	andi	r2,r2,255
8110ba54:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110ba58:	e0bffb17 	ldw	r2,-20(fp)
8110ba5c:	1000021e 	bne	r2,zero,8110ba68 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110ba60:	0005883a 	mov	r2,zero
8110ba64:	00000406 	br	8110ba78 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110ba68:	e0800317 	ldw	r2,12(fp)
8110ba6c:	e0fff517 	ldw	r3,-44(fp)
8110ba70:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110ba74:	e0bffb17 	ldw	r2,-20(fp)
}
8110ba78:	e037883a 	mov	sp,fp
8110ba7c:	dfc00117 	ldw	ra,4(sp)
8110ba80:	df000017 	ldw	fp,0(sp)
8110ba84:	dec00204 	addi	sp,sp,8
8110ba88:	f800283a 	ret

8110ba8c <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110ba8c:	defffc04 	addi	sp,sp,-16
8110ba90:	de00012e 	bgeu	sp,et,8110ba98 <vRstcSimucamReset+0xc>
8110ba94:	003b68fa 	trap	3
8110ba98:	dfc00315 	stw	ra,12(sp)
8110ba9c:	df000215 	stw	fp,8(sp)
8110baa0:	df000204 	addi	fp,sp,8
8110baa4:	2005883a 	mov	r2,r4
8110baa8:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110baac:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110bab0:	e0bfff0b 	ldhu	r2,-4(fp)
8110bab4:	e0fffe17 	ldw	r3,-8(fp)
8110bab8:	1884b03a 	or	r2,r3,r2
8110babc:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110bac0:	e0bffe17 	ldw	r2,-8(fp)
8110bac4:	10800074 	orhi	r2,r2,1
8110bac8:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bacc:	e1bffe17 	ldw	r6,-8(fp)
8110bad0:	000b883a 	mov	r5,zero
8110bad4:	01200034 	movhi	r4,32768
8110bad8:	21020004 	addi	r4,r4,2048
8110badc:	110bbdc0 	call	8110bbdc <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110bae0:	0001883a 	nop
8110bae4:	e037883a 	mov	sp,fp
8110bae8:	dfc00117 	ldw	ra,4(sp)
8110baec:	df000017 	ldw	fp,0(sp)
8110baf0:	dec00204 	addi	sp,sp,8
8110baf4:	f800283a 	ret

8110baf8 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110baf8:	defffc04 	addi	sp,sp,-16
8110bafc:	de00012e 	bgeu	sp,et,8110bb04 <vRstcReleaseDeviceReset+0xc>
8110bb00:	003b68fa 	trap	3
8110bb04:	dfc00315 	stw	ra,12(sp)
8110bb08:	df000215 	stw	fp,8(sp)
8110bb0c:	df000204 	addi	fp,sp,8
8110bb10:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110bb14:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bb18:	01400044 	movi	r5,1
8110bb1c:	01200034 	movhi	r4,32768
8110bb20:	21020004 	addi	r4,r4,2048
8110bb24:	110bc300 	call	8110bc30 <uliRstReadReg>
8110bb28:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110bb2c:	e0bfff17 	ldw	r2,-4(fp)
8110bb30:	0084303a 	nor	r2,zero,r2
8110bb34:	e0fffe17 	ldw	r3,-8(fp)
8110bb38:	1884703a 	and	r2,r3,r2
8110bb3c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bb40:	e1bffe17 	ldw	r6,-8(fp)
8110bb44:	01400044 	movi	r5,1
8110bb48:	01200034 	movhi	r4,32768
8110bb4c:	21020004 	addi	r4,r4,2048
8110bb50:	110bbdc0 	call	8110bbdc <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110bb54:	0001883a 	nop
8110bb58:	e037883a 	mov	sp,fp
8110bb5c:	dfc00117 	ldw	ra,4(sp)
8110bb60:	df000017 	ldw	fp,0(sp)
8110bb64:	dec00204 	addi	sp,sp,8
8110bb68:	f800283a 	ret

8110bb6c <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110bb6c:	defffc04 	addi	sp,sp,-16
8110bb70:	de00012e 	bgeu	sp,et,8110bb78 <vRstcHoldDeviceReset+0xc>
8110bb74:	003b68fa 	trap	3
8110bb78:	dfc00315 	stw	ra,12(sp)
8110bb7c:	df000215 	stw	fp,8(sp)
8110bb80:	df000204 	addi	fp,sp,8
8110bb84:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110bb88:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bb8c:	01400044 	movi	r5,1
8110bb90:	01200034 	movhi	r4,32768
8110bb94:	21020004 	addi	r4,r4,2048
8110bb98:	110bc300 	call	8110bc30 <uliRstReadReg>
8110bb9c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110bba0:	e0fffe17 	ldw	r3,-8(fp)
8110bba4:	e0bfff17 	ldw	r2,-4(fp)
8110bba8:	1884b03a 	or	r2,r3,r2
8110bbac:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bbb0:	e1bffe17 	ldw	r6,-8(fp)
8110bbb4:	01400044 	movi	r5,1
8110bbb8:	01200034 	movhi	r4,32768
8110bbbc:	21020004 	addi	r4,r4,2048
8110bbc0:	110bbdc0 	call	8110bbdc <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110bbc4:	0001883a 	nop
8110bbc8:	e037883a 	mov	sp,fp
8110bbcc:	dfc00117 	ldw	ra,4(sp)
8110bbd0:	df000017 	ldw	fp,0(sp)
8110bbd4:	dec00204 	addi	sp,sp,8
8110bbd8:	f800283a 	ret

8110bbdc <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110bbdc:	defffc04 	addi	sp,sp,-16
8110bbe0:	de00012e 	bgeu	sp,et,8110bbe8 <vRstcWriteReg+0xc>
8110bbe4:	003b68fa 	trap	3
8110bbe8:	df000315 	stw	fp,12(sp)
8110bbec:	df000304 	addi	fp,sp,12
8110bbf0:	e13ffd15 	stw	r4,-12(fp)
8110bbf4:	e17ffe15 	stw	r5,-8(fp)
8110bbf8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110bbfc:	e0bffe17 	ldw	r2,-8(fp)
8110bc00:	1085883a 	add	r2,r2,r2
8110bc04:	1085883a 	add	r2,r2,r2
8110bc08:	1007883a 	mov	r3,r2
8110bc0c:	e0bffd17 	ldw	r2,-12(fp)
8110bc10:	10c5883a 	add	r2,r2,r3
8110bc14:	e0ffff17 	ldw	r3,-4(fp)
8110bc18:	10c00015 	stw	r3,0(r2)
}
8110bc1c:	0001883a 	nop
8110bc20:	e037883a 	mov	sp,fp
8110bc24:	df000017 	ldw	fp,0(sp)
8110bc28:	dec00104 	addi	sp,sp,4
8110bc2c:	f800283a 	ret

8110bc30 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110bc30:	defffc04 	addi	sp,sp,-16
8110bc34:	de00012e 	bgeu	sp,et,8110bc3c <uliRstReadReg+0xc>
8110bc38:	003b68fa 	trap	3
8110bc3c:	df000315 	stw	fp,12(sp)
8110bc40:	df000304 	addi	fp,sp,12
8110bc44:	e13ffe15 	stw	r4,-8(fp)
8110bc48:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110bc4c:	e0bfff17 	ldw	r2,-4(fp)
8110bc50:	1085883a 	add	r2,r2,r2
8110bc54:	1085883a 	add	r2,r2,r2
8110bc58:	1007883a 	mov	r3,r2
8110bc5c:	e0bffe17 	ldw	r2,-8(fp)
8110bc60:	10c5883a 	add	r2,r2,r3
8110bc64:	10800017 	ldw	r2,0(r2)
8110bc68:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110bc6c:	e0bffd17 	ldw	r2,-12(fp)
}
8110bc70:	e037883a 	mov	sp,fp
8110bc74:	df000017 	ldw	fp,0(sp)
8110bc78:	dec00104 	addi	sp,sp,4
8110bc7c:	f800283a 	ret

8110bc80 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110bc80:	defffe04 	addi	sp,sp,-8
8110bc84:	de00012e 	bgeu	sp,et,8110bc8c <v_spi_start+0xc>
8110bc88:	003b68fa 	trap	3
8110bc8c:	dfc00115 	stw	ra,4(sp)
8110bc90:	df000015 	stw	fp,0(sp)
8110bc94:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110bc98:	0007883a 	mov	r3,zero
8110bc9c:	00a00034 	movhi	r2,32768
8110bca0:	10823004 	addi	r2,r2,2240
8110bca4:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110bca8:	0007883a 	mov	r3,zero
8110bcac:	00a00034 	movhi	r2,32768
8110bcb0:	10822c04 	addi	r2,r2,2224
8110bcb4:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110bcb8:	01002584 	movi	r4,150
8110bcbc:	11348ec0 	call	811348ec <usleep>
}
8110bcc0:	0001883a 	nop
8110bcc4:	e037883a 	mov	sp,fp
8110bcc8:	dfc00117 	ldw	ra,4(sp)
8110bccc:	df000017 	ldw	fp,0(sp)
8110bcd0:	dec00204 	addi	sp,sp,8
8110bcd4:	f800283a 	ret

8110bcd8 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110bcd8:	defffc04 	addi	sp,sp,-16
8110bcdc:	de00012e 	bgeu	sp,et,8110bce4 <v_spi_send_byte+0xc>
8110bce0:	003b68fa 	trap	3
8110bce4:	dfc00315 	stw	ra,12(sp)
8110bce8:	df000215 	stw	fp,8(sp)
8110bcec:	df000204 	addi	fp,sp,8
8110bcf0:	2005883a 	mov	r2,r4
8110bcf4:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110bcf8:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110bcfc:	00bfe004 	movi	r2,-128
8110bd00:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110bd04:	e03ffe05 	stb	zero,-8(fp)
8110bd08:	00001b06 	br	8110bd78 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110bd0c:	e0ffff03 	ldbu	r3,-4(fp)
8110bd10:	e0bffe43 	ldbu	r2,-7(fp)
8110bd14:	1884703a 	and	r2,r3,r2
8110bd18:	10803fcc 	andi	r2,r2,255
8110bd1c:	1004c03a 	cmpne	r2,r2,zero
8110bd20:	10c03fcc 	andi	r3,r2,255
8110bd24:	00a00034 	movhi	r2,32768
8110bd28:	10823404 	addi	r2,r2,2256
8110bd2c:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110bd30:	e0bffe43 	ldbu	r2,-7(fp)
8110bd34:	1004d07a 	srli	r2,r2,1
8110bd38:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110bd3c:	00c00044 	movi	r3,1
8110bd40:	00a00034 	movhi	r2,32768
8110bd44:	10823004 	addi	r2,r2,2240
8110bd48:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110bd4c:	01002584 	movi	r4,150
8110bd50:	11348ec0 	call	811348ec <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110bd54:	0007883a 	mov	r3,zero
8110bd58:	00a00034 	movhi	r2,32768
8110bd5c:	10823004 	addi	r2,r2,2240
8110bd60:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110bd64:	01002584 	movi	r4,150
8110bd68:	11348ec0 	call	811348ec <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110bd6c:	e0bffe03 	ldbu	r2,-8(fp)
8110bd70:	10800044 	addi	r2,r2,1
8110bd74:	e0bffe05 	stb	r2,-8(fp)
8110bd78:	e0bffe03 	ldbu	r2,-8(fp)
8110bd7c:	10800230 	cmpltui	r2,r2,8
8110bd80:	103fe21e 	bne	r2,zero,8110bd0c <__reset+0xfb0ebd0c>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110bd84:	0001883a 	nop
8110bd88:	e037883a 	mov	sp,fp
8110bd8c:	dfc00117 	ldw	ra,4(sp)
8110bd90:	df000017 	ldw	fp,0(sp)
8110bd94:	dec00204 	addi	sp,sp,8
8110bd98:	f800283a 	ret

8110bd9c <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110bd9c:	defffd04 	addi	sp,sp,-12
8110bda0:	de00012e 	bgeu	sp,et,8110bda8 <uc_spi_get_byte+0xc>
8110bda4:	003b68fa 	trap	3
8110bda8:	dfc00215 	stw	ra,8(sp)
8110bdac:	df000115 	stw	fp,4(sp)
8110bdb0:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110bdb4:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110bdb8:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110bdbc:	e03fff05 	stb	zero,-4(fp)
8110bdc0:	00001a06 	br	8110be2c <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110bdc4:	e0bfff43 	ldbu	r2,-3(fp)
8110bdc8:	1085883a 	add	r2,r2,r2
8110bdcc:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110bdd0:	00a00034 	movhi	r2,32768
8110bdd4:	10823804 	addi	r2,r2,2272
8110bdd8:	10800037 	ldwio	r2,0(r2)
8110bddc:	1080004c 	andi	r2,r2,1
8110bde0:	1007883a 	mov	r3,r2
8110bde4:	e0bfff43 	ldbu	r2,-3(fp)
8110bde8:	1884b03a 	or	r2,r3,r2
8110bdec:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110bdf0:	00c00044 	movi	r3,1
8110bdf4:	00a00034 	movhi	r2,32768
8110bdf8:	10823004 	addi	r2,r2,2240
8110bdfc:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110be00:	01002584 	movi	r4,150
8110be04:	11348ec0 	call	811348ec <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110be08:	0007883a 	mov	r3,zero
8110be0c:	00a00034 	movhi	r2,32768
8110be10:	10823004 	addi	r2,r2,2240
8110be14:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110be18:	01002584 	movi	r4,150
8110be1c:	11348ec0 	call	811348ec <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110be20:	e0bfff03 	ldbu	r2,-4(fp)
8110be24:	10800044 	addi	r2,r2,1
8110be28:	e0bfff05 	stb	r2,-4(fp)
8110be2c:	e0bfff03 	ldbu	r2,-4(fp)
8110be30:	10800230 	cmpltui	r2,r2,8
8110be34:	103fe31e 	bne	r2,zero,8110bdc4 <__reset+0xfb0ebdc4>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110be38:	e0bfff43 	ldbu	r2,-3(fp)
}
8110be3c:	e037883a 	mov	sp,fp
8110be40:	dfc00117 	ldw	ra,4(sp)
8110be44:	df000017 	ldw	fp,0(sp)
8110be48:	dec00204 	addi	sp,sp,8
8110be4c:	f800283a 	ret

8110be50 <v_spi_end>:

void v_spi_end(void){
8110be50:	defffe04 	addi	sp,sp,-8
8110be54:	de00012e 	bgeu	sp,et,8110be5c <v_spi_end+0xc>
8110be58:	003b68fa 	trap	3
8110be5c:	dfc00115 	stw	ra,4(sp)
8110be60:	df000015 	stw	fp,0(sp)
8110be64:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110be68:	0007883a 	mov	r3,zero
8110be6c:	00a00034 	movhi	r2,32768
8110be70:	10823004 	addi	r2,r2,2240
8110be74:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110be78:	01002584 	movi	r4,150
8110be7c:	11348ec0 	call	811348ec <usleep>
    SPI_CS_N(1);
8110be80:	00c00044 	movi	r3,1
8110be84:	00a00034 	movhi	r2,32768
8110be88:	10822c04 	addi	r2,r2,2224
8110be8c:	10c00035 	stwio	r3,0(r2)
}
8110be90:	0001883a 	nop
8110be94:	e037883a 	mov	sp,fp
8110be98:	dfc00117 	ldw	ra,4(sp)
8110be9c:	df000017 	ldw	fp,0(sp)
8110bea0:	dec00204 	addi	sp,sp,8
8110bea4:	f800283a 	ret

8110bea8 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110bea8:	defff604 	addi	sp,sp,-40
8110beac:	de00012e 	bgeu	sp,et,8110beb4 <RTCC_SPI_R_MAC+0xc>
8110beb0:	003b68fa 	trap	3
8110beb4:	dfc00915 	stw	ra,36(sp)
8110beb8:	df000815 	stw	fp,32(sp)
8110bebc:	df000804 	addi	fp,sp,32
8110bec0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110bec4:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110bec8:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110becc:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110bed0:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110bed4:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110bed8:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110bedc:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110bee0:	00800084 	movi	r2,2
8110bee4:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110bee8:	00800cc4 	movi	r2,51
8110beec:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110bef0:	110bc800 	call	8110bc80 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110bef4:	e0bffec3 	ldbu	r2,-5(fp)
8110bef8:	1009883a 	mov	r4,r2
8110befc:	110bcd80 	call	8110bcd8 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110bf00:	e0bffe83 	ldbu	r2,-6(fp)
8110bf04:	1009883a 	mov	r4,r2
8110bf08:	110bcd80 	call	8110bcd8 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110bf0c:	110bd9c0 	call	8110bd9c <uc_spi_get_byte>
8110bf10:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110bf14:	110bd9c0 	call	8110bd9c <uc_spi_get_byte>
8110bf18:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110bf1c:	110bd9c0 	call	8110bd9c <uc_spi_get_byte>
8110bf20:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110bf24:	110bd9c0 	call	8110bd9c <uc_spi_get_byte>
8110bf28:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110bf2c:	110bd9c0 	call	8110bd9c <uc_spi_get_byte>
8110bf30:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110bf34:	110bd9c0 	call	8110bd9c <uc_spi_get_byte>
8110bf38:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110bf3c:	110be500 	call	8110be50 <v_spi_end>

    bSuccess = TRUE;
8110bf40:	00800044 	movi	r2,1
8110bf44:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110bf48:	e0bfff17 	ldw	r2,-4(fp)
8110bf4c:	e0fffd03 	ldbu	r3,-12(fp)
8110bf50:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110bf54:	e0bfff17 	ldw	r2,-4(fp)
8110bf58:	10800044 	addi	r2,r2,1
8110bf5c:	e0fffd43 	ldbu	r3,-11(fp)
8110bf60:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110bf64:	e0bfff17 	ldw	r2,-4(fp)
8110bf68:	10800084 	addi	r2,r2,2
8110bf6c:	e0fffd83 	ldbu	r3,-10(fp)
8110bf70:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110bf74:	e0bfff17 	ldw	r2,-4(fp)
8110bf78:	108000c4 	addi	r2,r2,3
8110bf7c:	e0fffdc3 	ldbu	r3,-9(fp)
8110bf80:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110bf84:	e0bfff17 	ldw	r2,-4(fp)
8110bf88:	10800104 	addi	r2,r2,4
8110bf8c:	e0fffe03 	ldbu	r3,-8(fp)
8110bf90:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110bf94:	e0bfff17 	ldw	r2,-4(fp)
8110bf98:	10800144 	addi	r2,r2,5
8110bf9c:	e0fffe43 	ldbu	r3,-7(fp)
8110bfa0:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110bfa4:	e1bffd03 	ldbu	r6,-12(fp)
8110bfa8:	e1fffd43 	ldbu	r7,-11(fp)
8110bfac:	e0bffd83 	ldbu	r2,-10(fp)
8110bfb0:	e0fffdc3 	ldbu	r3,-9(fp)
8110bfb4:	e13ffe03 	ldbu	r4,-8(fp)
8110bfb8:	e17ffe43 	ldbu	r5,-7(fp)
8110bfbc:	d9400315 	stw	r5,12(sp)
8110bfc0:	d9000215 	stw	r4,8(sp)
8110bfc4:	d8c00115 	stw	r3,4(sp)
8110bfc8:	d8800015 	stw	r2,0(sp)
8110bfcc:	01604574 	movhi	r5,33045
8110bfd0:	29646504 	addi	r5,r5,-28268
8110bfd4:	01204574 	movhi	r4,33045
8110bfd8:	213e6f04 	addi	r4,r4,-1604
8110bfdc:	111efa40 	call	8111efa4 <sprintf>
	debug(fp, cDebugBuffer);
8110bfe0:	d0a06117 	ldw	r2,-32380(gp)
8110bfe4:	01604574 	movhi	r5,33045
8110bfe8:	297e6f04 	addi	r5,r5,-1604
8110bfec:	1009883a 	mov	r4,r2
8110bff0:	111d6140 	call	8111d614 <fprintf>
#endif

    return bSuccess;
8110bff4:	e0bffc17 	ldw	r2,-16(fp)
}
8110bff8:	e037883a 	mov	sp,fp
8110bffc:	dfc00117 	ldw	ra,4(sp)
8110c000:	df000017 	ldw	fp,0(sp)
8110c004:	dec00204 	addi	sp,sp,8
8110c008:	f800283a 	ret

8110c00c <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110c00c:	defffd04 	addi	sp,sp,-12
8110c010:	de00012e 	bgeu	sp,et,8110c018 <bSSDisplayConfig+0xc>
8110c014:	003b68fa 	trap	3
8110c018:	df000215 	stw	fp,8(sp)
8110c01c:	df000204 	addi	fp,sp,8
8110c020:	2005883a 	mov	r2,r4
8110c024:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110c028:	e0bfff03 	ldbu	r2,-4(fp)
8110c02c:	10c00168 	cmpgeui	r3,r2,5
8110c030:	18001c1e 	bne	r3,zero,8110c0a4 <bSSDisplayConfig+0x98>
8110c034:	100690ba 	slli	r3,r2,2
8110c038:	00a04474 	movhi	r2,33041
8110c03c:	10b01304 	addi	r2,r2,-16308
8110c040:	1885883a 	add	r2,r3,r2
8110c044:	10800017 	ldw	r2,0(r2)
8110c048:	1000683a 	jmp	r2
8110c04c:	8110c060 	cmpeqi	r4,r16,17153
8110c050:	8110c06c 	andhi	r4,r16,17153
8110c054:	8110c078 	rdprs	r4,r16,17153
8110c058:	8110c08c 	andi	r4,r16,17154
8110c05c:	8110c09c 	xori	r4,r16,17154
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110c060:	00800cc4 	movi	r2,51
8110c064:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c068:	00001006 	br	8110c0ac <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110c06c:	00801544 	movi	r2,85
8110c070:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c074:	00000d06 	br	8110c0ac <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110c078:	d0e05043 	ldbu	r3,-32447(gp)
8110c07c:	00bff744 	movi	r2,-35
8110c080:	1884703a 	and	r2,r3,r2
8110c084:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c088:	00000806 	br	8110c0ac <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110c08c:	d0a05043 	ldbu	r2,-32447(gp)
8110c090:	10800894 	ori	r2,r2,34
8110c094:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c098:	00000406 	br	8110c0ac <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110c09c:	d0205045 	stb	zero,-32447(gp)
	    break;
8110c0a0:	00000206 	br	8110c0ac <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110c0a4:	0005883a 	mov	r2,zero
8110c0a8:	00000806 	br	8110c0cc <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c0ac:	00a00034 	movhi	r2,32768
8110c0b0:	10828404 	addi	r2,r2,2576
8110c0b4:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110c0b8:	d0a05043 	ldbu	r2,-32447(gp)
8110c0bc:	10c03fcc 	andi	r3,r2,255
8110c0c0:	e0bffe17 	ldw	r2,-8(fp)
8110c0c4:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c0c8:	00800044 	movi	r2,1
}
8110c0cc:	e037883a 	mov	sp,fp
8110c0d0:	df000017 	ldw	fp,0(sp)
8110c0d4:	dec00104 	addi	sp,sp,4
8110c0d8:	f800283a 	ret

8110c0dc <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110c0dc:	defffd04 	addi	sp,sp,-12
8110c0e0:	de00012e 	bgeu	sp,et,8110c0e8 <bSSDisplayUpdate+0xc>
8110c0e4:	003b68fa 	trap	3
8110c0e8:	df000215 	stw	fp,8(sp)
8110c0ec:	df000204 	addi	fp,sp,8
8110c0f0:	2005883a 	mov	r2,r4
8110c0f4:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c0f8:	00a00034 	movhi	r2,32768
8110c0fc:	10828404 	addi	r2,r2,2576
8110c100:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110c104:	e0bffe17 	ldw	r2,-8(fp)
8110c108:	10800104 	addi	r2,r2,4
8110c10c:	e0ffff03 	ldbu	r3,-4(fp)
8110c110:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c114:	00800044 	movi	r2,1
}
8110c118:	e037883a 	mov	sp,fp
8110c11c:	df000017 	ldw	fp,0(sp)
8110c120:	dec00104 	addi	sp,sp,4
8110c124:	f800283a 	ret

8110c128 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110c128:	defff904 	addi	sp,sp,-28
8110c12c:	de00012e 	bgeu	sp,et,8110c134 <vSyncHandleIrq+0xc>
8110c130:	003b68fa 	trap	3
8110c134:	dfc00615 	stw	ra,24(sp)
8110c138:	df000515 	stw	fp,20(sp)
8110c13c:	df000504 	addi	fp,sp,20
8110c140:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110c144:	e0bfff17 	ldw	r2,-4(fp)
8110c148:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110c14c:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110c150:	d0a05203 	ldbu	r2,-32440(gp)
8110c154:	108000cc 	andi	r2,r2,3
8110c158:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 ) {
8110c15c:	e0bffd03 	ldbu	r2,-12(fp)
8110c160:	10000e1e 	bne	r2,zero,8110c19c <vSyncHandleIrq+0x74>

		uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110c164:	00800044 	movi	r2,1
8110c168:	e0bffec5 	stb	r2,-5(fp)
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110c16c:	00bff804 	movi	r2,-32
8110c170:	e0bffe85 	stb	r2,-6(fp)

		/* Send Priority message to the Meb Task to indicate the Master Sync */
		error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110c174:	d0a06817 	ldw	r2,-32352(gp)
8110c178:	e0fffe17 	ldw	r3,-8(fp)
8110c17c:	180b883a 	mov	r5,r3
8110c180:	1009883a 	mov	r4,r2
8110c184:	113ad700 	call	8113ad70 <OSQPostFront>
8110c188:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110c18c:	e0bffd43 	ldbu	r2,-11(fp)
8110c190:	10000426 	beq	r2,zero,8110c1a4 <vSyncHandleIrq+0x7c>
			vFailSendMsgMasterSyncMeb( );
8110c194:	111a2900 	call	8111a290 <vFailSendMsgMasterSyncMeb>
8110c198:	00000206 	br	8110c1a4 <vSyncHandleIrq+0x7c>
		}

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110c19c:	00bff844 	movi	r2,-31
8110c1a0:	e0bffe85 	stb	r2,-6(fp)


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110c1a4:	e03ffb05 	stb	zero,-20(fp)
8110c1a8:	00002706 	br	8110c248 <vSyncHandleIrq+0x120>

		if ( xSimMeb.xFeeControl.xNfee[ucIL].xControl.bWatingSync == TRUE ) {
8110c1ac:	e0fffb03 	ldbu	r3,-20(fp)
8110c1b0:	00a04574 	movhi	r2,33045
8110c1b4:	10954904 	addi	r2,r2,21796
8110c1b8:	18c09624 	muli	r3,r3,600
8110c1bc:	10c5883a 	add	r2,r2,r3
8110c1c0:	10803a04 	addi	r2,r2,232
8110c1c4:	10800017 	ldw	r2,0(r2)
8110c1c8:	10800058 	cmpnei	r2,r2,1
8110c1cc:	10001b1e 	bne	r2,zero,8110c23c <vSyncHandleIrq+0x114>
			uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110c1d0:	e0bffb03 	ldbu	r2,-20(fp)
8110c1d4:	10800444 	addi	r2,r2,17
8110c1d8:	e0bffec5 	stb	r2,-5(fp)
			error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110c1dc:	e0bffb03 	ldbu	r2,-20(fp)
8110c1e0:	1085883a 	add	r2,r2,r2
8110c1e4:	1087883a 	add	r3,r2,r2
8110c1e8:	d0a05b04 	addi	r2,gp,-32404
8110c1ec:	1885883a 	add	r2,r3,r2
8110c1f0:	10800017 	ldw	r2,0(r2)
8110c1f4:	e0fffe17 	ldw	r3,-8(fp)
8110c1f8:	180b883a 	mov	r5,r3
8110c1fc:	1009883a 	mov	r4,r2
8110c200:	113ac000 	call	8113ac00 <OSQPost>
8110c204:	e0bffd45 	stb	r2,-11(fp)
			if ( error_codel != OS_ERR_NONE ) {
8110c208:	e0bffd43 	ldbu	r2,-11(fp)
8110c20c:	10000b26 	beq	r2,zero,8110c23c <vSyncHandleIrq+0x114>
				vFailSendMsgSync( ucIL );
8110c210:	e0bffb03 	ldbu	r2,-20(fp)
8110c214:	1009883a 	mov	r4,r2
8110c218:	111a1e80 	call	8111a1e8 <vFailSendMsgSync>
				/*  */
				OSQFlush( xWaitSyncQFee[ ucIL] );
8110c21c:	e0bffb03 	ldbu	r2,-20(fp)
8110c220:	1085883a 	add	r2,r2,r2
8110c224:	1087883a 	add	r3,r2,r2
8110c228:	d0a05b04 	addi	r2,gp,-32404
8110c22c:	1885883a 	add	r2,r3,r2
8110c230:	10800017 	ldw	r2,0(r2)
8110c234:	1009883a 	mov	r4,r2
8110c238:	113a7380 	call	8113a738 <OSQFlush>

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110c23c:	e0bffb03 	ldbu	r2,-20(fp)
8110c240:	10800044 	addi	r2,r2,1
8110c244:	e0bffb05 	stb	r2,-20(fp)
8110c248:	e0bffb03 	ldbu	r2,-20(fp)
8110c24c:	103fd726 	beq	r2,zero,8110c1ac <__reset+0xfb0ec1ac>
				OSQFlush( xWaitSyncQFee[ ucIL] );
			}
		}
	}

	vucN += 1;
8110c250:	d0a05203 	ldbu	r2,-32440(gp)
8110c254:	10800044 	addi	r2,r2,1
8110c258:	d0a05205 	stb	r2,-32440(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110c25c:	d0a06117 	ldw	r2,-32380(gp)
8110c260:	e0fffd03 	ldbu	r3,-12(fp)
8110c264:	180d883a 	mov	r6,r3
8110c268:	01604574 	movhi	r5,33045
8110c26c:	29647404 	addi	r5,r5,-28208
8110c270:	1009883a 	mov	r4,r2
8110c274:	111d6140 	call	8111d614 <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110c278:	110c30c0 	call	8110c30c <vSyncIrqFlagClrSync>
}
8110c27c:	0001883a 	nop
8110c280:	e037883a 	mov	sp,fp
8110c284:	dfc00117 	ldw	ra,4(sp)
8110c288:	df000017 	ldw	fp,0(sp)
8110c28c:	dec00204 	addi	sp,sp,8
8110c290:	f800283a 	ret

8110c294 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110c294:	deffff04 	addi	sp,sp,-4
8110c298:	de00012e 	bgeu	sp,et,8110c2a0 <vSyncClearCounter+0xc>
8110c29c:	003b68fa 	trap	3
8110c2a0:	df000015 	stw	fp,0(sp)
8110c2a4:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110c2a8:	d0205205 	stb	zero,-32440(gp)
}
8110c2ac:	0001883a 	nop
8110c2b0:	e037883a 	mov	sp,fp
8110c2b4:	df000017 	ldw	fp,0(sp)
8110c2b8:	dec00104 	addi	sp,sp,4
8110c2bc:	f800283a 	ret

8110c2c0 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110c2c0:	defffd04 	addi	sp,sp,-12
8110c2c4:	de00012e 	bgeu	sp,et,8110c2cc <vSyncInitIrq+0xc>
8110c2c8:	003b68fa 	trap	3
8110c2cc:	dfc00215 	stw	ra,8(sp)
8110c2d0:	df000115 	stw	fp,4(sp)
8110c2d4:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110c2d8:	d0a05104 	addi	r2,gp,-32444
8110c2dc:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110c2e0:	01a04474 	movhi	r6,33041
8110c2e4:	31b04a04 	addi	r6,r6,-16088
8110c2e8:	e17fff17 	ldw	r5,-4(fp)
8110c2ec:	01000284 	movi	r4,10
8110c2f0:	113321c0 	call	8113321c <alt_irq_register>
}
8110c2f4:	0001883a 	nop
8110c2f8:	e037883a 	mov	sp,fp
8110c2fc:	dfc00117 	ldw	ra,4(sp)
8110c300:	df000017 	ldw	fp,0(sp)
8110c304:	dec00204 	addi	sp,sp,8
8110c308:	f800283a 	ret

8110c30c <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110c30c:	defffe04 	addi	sp,sp,-8
8110c310:	de00012e 	bgeu	sp,et,8110c318 <vSyncIrqFlagClrSync+0xc>
8110c314:	003b68fa 	trap	3
8110c318:	dfc00115 	stw	ra,4(sp)
8110c31c:	df000015 	stw	fp,0(sp)
8110c320:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110c324:	01400044 	movi	r5,1
8110c328:	010002c4 	movi	r4,11
8110c32c:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
}
8110c330:	0001883a 	nop
8110c334:	e037883a 	mov	sp,fp
8110c338:	dfc00117 	ldw	ra,4(sp)
8110c33c:	df000017 	ldw	fp,0(sp)
8110c340:	dec00204 	addi	sp,sp,8
8110c344:	f800283a 	ret

8110c348 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110c348:	defffd04 	addi	sp,sp,-12
8110c34c:	de00012e 	bgeu	sp,et,8110c354 <bSyncIrqFlagSync+0xc>
8110c350:	003b68fa 	trap	3
8110c354:	dfc00215 	stw	ra,8(sp)
8110c358:	df000115 	stw	fp,4(sp)
8110c35c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110c360:	01000304 	movi	r4,12
8110c364:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c368:	1080004c 	andi	r2,r2,1
8110c36c:	10000326 	beq	r2,zero,8110c37c <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110c370:	00800044 	movi	r2,1
8110c374:	e0bfff15 	stw	r2,-4(fp)
8110c378:	00000106 	br	8110c380 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110c37c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110c380:	e0bfff17 	ldw	r2,-4(fp)
}
8110c384:	e037883a 	mov	sp,fp
8110c388:	dfc00117 	ldw	ra,4(sp)
8110c38c:	df000017 	ldw	fp,0(sp)
8110c390:	dec00204 	addi	sp,sp,8
8110c394:	f800283a 	ret

8110c398 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110c398:	defffc04 	addi	sp,sp,-16
8110c39c:	de00012e 	bgeu	sp,et,8110c3a4 <bSyncStatusExtnIrq+0xc>
8110c3a0:	003b68fa 	trap	3
8110c3a4:	dfc00315 	stw	ra,12(sp)
8110c3a8:	df000215 	stw	fp,8(sp)
8110c3ac:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c3b0:	0009883a 	mov	r4,zero
8110c3b4:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c3b8:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110c3bc:	e0bfff17 	ldw	r2,-4(fp)
8110c3c0:	1000030e 	bge	r2,zero,8110c3d0 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110c3c4:	00800044 	movi	r2,1
8110c3c8:	e0bffe15 	stw	r2,-8(fp)
8110c3cc:	00000106 	br	8110c3d4 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110c3d0:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c3d4:	e0bffe17 	ldw	r2,-8(fp)
}
8110c3d8:	e037883a 	mov	sp,fp
8110c3dc:	dfc00117 	ldw	ra,4(sp)
8110c3e0:	df000017 	ldw	fp,0(sp)
8110c3e4:	dec00204 	addi	sp,sp,8
8110c3e8:	f800283a 	ret

8110c3ec <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110c3ec:	defffc04 	addi	sp,sp,-16
8110c3f0:	de00012e 	bgeu	sp,et,8110c3f8 <ucSyncStatusState+0xc>
8110c3f4:	003b68fa 	trap	3
8110c3f8:	dfc00315 	stw	ra,12(sp)
8110c3fc:	df000215 	stw	fp,8(sp)
8110c400:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c404:	0009883a 	mov	r4,zero
8110c408:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c40c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110c410:	e0bffe17 	ldw	r2,-8(fp)
8110c414:	10803fec 	andhi	r2,r2,255
8110c418:	1004d43a 	srli	r2,r2,16
8110c41c:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110c420:	e0bfff03 	ldbu	r2,-4(fp)
}
8110c424:	e037883a 	mov	sp,fp
8110c428:	dfc00117 	ldw	ra,4(sp)
8110c42c:	df000017 	ldw	fp,0(sp)
8110c430:	dec00204 	addi	sp,sp,8
8110c434:	f800283a 	ret

8110c438 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110c438:	defffc04 	addi	sp,sp,-16
8110c43c:	de00012e 	bgeu	sp,et,8110c444 <ucSyncStatusErrorCode+0xc>
8110c440:	003b68fa 	trap	3
8110c444:	dfc00315 	stw	ra,12(sp)
8110c448:	df000215 	stw	fp,8(sp)
8110c44c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c450:	0009883a 	mov	r4,zero
8110c454:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c458:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110c45c:	e0bffe17 	ldw	r2,-8(fp)
8110c460:	10bfc00c 	andi	r2,r2,65280
8110c464:	1004d23a 	srli	r2,r2,8
8110c468:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110c46c:	e0bfff03 	ldbu	r2,-4(fp)
}
8110c470:	e037883a 	mov	sp,fp
8110c474:	dfc00117 	ldw	ra,4(sp)
8110c478:	df000017 	ldw	fp,0(sp)
8110c47c:	dec00204 	addi	sp,sp,8
8110c480:	f800283a 	ret

8110c484 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110c484:	defffc04 	addi	sp,sp,-16
8110c488:	de00012e 	bgeu	sp,et,8110c490 <ucSyncStatusCycleNumber+0xc>
8110c48c:	003b68fa 	trap	3
8110c490:	dfc00315 	stw	ra,12(sp)
8110c494:	df000215 	stw	fp,8(sp)
8110c498:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c49c:	0009883a 	mov	r4,zero
8110c4a0:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c4a4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110c4a8:	e0bffe17 	ldw	r2,-8(fp)
8110c4ac:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110c4b0:	e0bfff03 	ldbu	r2,-4(fp)
}
8110c4b4:	e037883a 	mov	sp,fp
8110c4b8:	dfc00117 	ldw	ra,4(sp)
8110c4bc:	df000017 	ldw	fp,0(sp)
8110c4c0:	dec00204 	addi	sp,sp,8
8110c4c4:	f800283a 	ret

8110c4c8 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110c4c8:	defffd04 	addi	sp,sp,-12
8110c4cc:	de00012e 	bgeu	sp,et,8110c4d4 <bSyncSetMbt+0xc>
8110c4d0:	003b68fa 	trap	3
8110c4d4:	dfc00215 	stw	ra,8(sp)
8110c4d8:	df000115 	stw	fp,4(sp)
8110c4dc:	df000104 	addi	fp,sp,4
8110c4e0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110c4e4:	e17fff17 	ldw	r5,-4(fp)
8110c4e8:	01000104 	movi	r4,4
8110c4ec:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c4f0:	00800044 	movi	r2,1
}
8110c4f4:	e037883a 	mov	sp,fp
8110c4f8:	dfc00117 	ldw	ra,4(sp)
8110c4fc:	df000017 	ldw	fp,0(sp)
8110c500:	dec00204 	addi	sp,sp,8
8110c504:	f800283a 	ret

8110c508 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110c508:	defffd04 	addi	sp,sp,-12
8110c50c:	de00012e 	bgeu	sp,et,8110c514 <bSyncSetBt+0xc>
8110c510:	003b68fa 	trap	3
8110c514:	dfc00215 	stw	ra,8(sp)
8110c518:	df000115 	stw	fp,4(sp)
8110c51c:	df000104 	addi	fp,sp,4
8110c520:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110c524:	e17fff17 	ldw	r5,-4(fp)
8110c528:	01000144 	movi	r4,5
8110c52c:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c530:	00800044 	movi	r2,1
}
8110c534:	e037883a 	mov	sp,fp
8110c538:	dfc00117 	ldw	ra,4(sp)
8110c53c:	df000017 	ldw	fp,0(sp)
8110c540:	dec00204 	addi	sp,sp,8
8110c544:	f800283a 	ret

8110c548 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110c548:	defffd04 	addi	sp,sp,-12
8110c54c:	de00012e 	bgeu	sp,et,8110c554 <bSyncSetPer+0xc>
8110c550:	003b68fa 	trap	3
8110c554:	dfc00215 	stw	ra,8(sp)
8110c558:	df000115 	stw	fp,4(sp)
8110c55c:	df000104 	addi	fp,sp,4
8110c560:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110c564:	e17fff17 	ldw	r5,-4(fp)
8110c568:	01000184 	movi	r4,6
8110c56c:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c570:	00800044 	movi	r2,1
}
8110c574:	e037883a 	mov	sp,fp
8110c578:	dfc00117 	ldw	ra,4(sp)
8110c57c:	df000017 	ldw	fp,0(sp)
8110c580:	dec00204 	addi	sp,sp,8
8110c584:	f800283a 	ret

8110c588 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110c588:	defffd04 	addi	sp,sp,-12
8110c58c:	de00012e 	bgeu	sp,et,8110c594 <bSyncSetOst+0xc>
8110c590:	003b68fa 	trap	3
8110c594:	dfc00215 	stw	ra,8(sp)
8110c598:	df000115 	stw	fp,4(sp)
8110c59c:	df000104 	addi	fp,sp,4
8110c5a0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110c5a4:	e17fff17 	ldw	r5,-4(fp)
8110c5a8:	010001c4 	movi	r4,7
8110c5ac:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c5b0:	00800044 	movi	r2,1
}
8110c5b4:	e037883a 	mov	sp,fp
8110c5b8:	dfc00117 	ldw	ra,4(sp)
8110c5bc:	df000017 	ldw	fp,0(sp)
8110c5c0:	dec00204 	addi	sp,sp,8
8110c5c4:	f800283a 	ret

8110c5c8 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110c5c8:	defffc04 	addi	sp,sp,-16
8110c5cc:	de00012e 	bgeu	sp,et,8110c5d4 <bSyncSetPolarity+0xc>
8110c5d0:	003b68fa 	trap	3
8110c5d4:	dfc00315 	stw	ra,12(sp)
8110c5d8:	df000215 	stw	fp,8(sp)
8110c5dc:	df000204 	addi	fp,sp,8
8110c5e0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110c5e4:	01000204 	movi	r4,8
8110c5e8:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c5ec:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c5f0:	e0bfff17 	ldw	r2,-4(fp)
8110c5f4:	1000051e 	bne	r2,zero,8110c60c <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110c5f8:	e0fffe17 	ldw	r3,-8(fp)
8110c5fc:	00bfbfc4 	movi	r2,-257
8110c600:	1884703a 	and	r2,r3,r2
8110c604:	e0bffe15 	stw	r2,-8(fp)
8110c608:	00000306 	br	8110c618 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110c60c:	e0bffe17 	ldw	r2,-8(fp)
8110c610:	10804014 	ori	r2,r2,256
8110c614:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110c618:	e17ffe17 	ldw	r5,-8(fp)
8110c61c:	01000204 	movi	r4,8
8110c620:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c624:	00800044 	movi	r2,1
}
8110c628:	e037883a 	mov	sp,fp
8110c62c:	dfc00117 	ldw	ra,4(sp)
8110c630:	df000017 	ldw	fp,0(sp)
8110c634:	dec00204 	addi	sp,sp,8
8110c638:	f800283a 	ret

8110c63c <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110c63c:	defffc04 	addi	sp,sp,-16
8110c640:	de00012e 	bgeu	sp,et,8110c648 <bSyncSetNCycles+0xc>
8110c644:	003b68fa 	trap	3
8110c648:	dfc00315 	stw	ra,12(sp)
8110c64c:	df000215 	stw	fp,8(sp)
8110c650:	df000204 	addi	fp,sp,8
8110c654:	2005883a 	mov	r2,r4
8110c658:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110c65c:	01000204 	movi	r4,8
8110c660:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c664:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110c668:	e0fffe17 	ldw	r3,-8(fp)
8110c66c:	00bfc004 	movi	r2,-256
8110c670:	1884703a 	and	r2,r3,r2
8110c674:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110c678:	e0bfff03 	ldbu	r2,-4(fp)
8110c67c:	e0fffe17 	ldw	r3,-8(fp)
8110c680:	1884b03a 	or	r2,r3,r2
8110c684:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110c688:	e17ffe17 	ldw	r5,-8(fp)
8110c68c:	01000204 	movi	r4,8
8110c690:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c694:	00800044 	movi	r2,1
}
8110c698:	e037883a 	mov	sp,fp
8110c69c:	dfc00117 	ldw	ra,4(sp)
8110c6a0:	df000017 	ldw	fp,0(sp)
8110c6a4:	dec00204 	addi	sp,sp,8
8110c6a8:	f800283a 	ret

8110c6ac <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110c6ac:	defffd04 	addi	sp,sp,-12
8110c6b0:	de00012e 	bgeu	sp,et,8110c6b8 <uliSyncGetMbt+0xc>
8110c6b4:	003b68fa 	trap	3
8110c6b8:	dfc00215 	stw	ra,8(sp)
8110c6bc:	df000115 	stw	fp,4(sp)
8110c6c0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110c6c4:	01000104 	movi	r4,4
8110c6c8:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c6cc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c6d0:	e0bfff17 	ldw	r2,-4(fp)
}
8110c6d4:	e037883a 	mov	sp,fp
8110c6d8:	dfc00117 	ldw	ra,4(sp)
8110c6dc:	df000017 	ldw	fp,0(sp)
8110c6e0:	dec00204 	addi	sp,sp,8
8110c6e4:	f800283a 	ret

8110c6e8 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110c6e8:	defffd04 	addi	sp,sp,-12
8110c6ec:	de00012e 	bgeu	sp,et,8110c6f4 <uliSyncGetBt+0xc>
8110c6f0:	003b68fa 	trap	3
8110c6f4:	dfc00215 	stw	ra,8(sp)
8110c6f8:	df000115 	stw	fp,4(sp)
8110c6fc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110c700:	01000144 	movi	r4,5
8110c704:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c708:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c70c:	e0bfff17 	ldw	r2,-4(fp)
}
8110c710:	e037883a 	mov	sp,fp
8110c714:	dfc00117 	ldw	ra,4(sp)
8110c718:	df000017 	ldw	fp,0(sp)
8110c71c:	dec00204 	addi	sp,sp,8
8110c720:	f800283a 	ret

8110c724 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110c724:	defffd04 	addi	sp,sp,-12
8110c728:	de00012e 	bgeu	sp,et,8110c730 <uliSyncGetPer+0xc>
8110c72c:	003b68fa 	trap	3
8110c730:	dfc00215 	stw	ra,8(sp)
8110c734:	df000115 	stw	fp,4(sp)
8110c738:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110c73c:	01000184 	movi	r4,6
8110c740:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c744:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c748:	e0bfff17 	ldw	r2,-4(fp)
}
8110c74c:	e037883a 	mov	sp,fp
8110c750:	dfc00117 	ldw	ra,4(sp)
8110c754:	df000017 	ldw	fp,0(sp)
8110c758:	dec00204 	addi	sp,sp,8
8110c75c:	f800283a 	ret

8110c760 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110c760:	defffd04 	addi	sp,sp,-12
8110c764:	de00012e 	bgeu	sp,et,8110c76c <uliSyncGetOst+0xc>
8110c768:	003b68fa 	trap	3
8110c76c:	dfc00215 	stw	ra,8(sp)
8110c770:	df000115 	stw	fp,4(sp)
8110c774:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110c778:	010001c4 	movi	r4,7
8110c77c:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c780:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c784:	e0bfff17 	ldw	r2,-4(fp)
}
8110c788:	e037883a 	mov	sp,fp
8110c78c:	dfc00117 	ldw	ra,4(sp)
8110c790:	df000017 	ldw	fp,0(sp)
8110c794:	dec00204 	addi	sp,sp,8
8110c798:	f800283a 	ret

8110c79c <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110c79c:	defffd04 	addi	sp,sp,-12
8110c7a0:	de00012e 	bgeu	sp,et,8110c7a8 <uliSyncGetGeneral+0xc>
8110c7a4:	003b68fa 	trap	3
8110c7a8:	dfc00215 	stw	ra,8(sp)
8110c7ac:	df000115 	stw	fp,4(sp)
8110c7b0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110c7b4:	01000204 	movi	r4,8
8110c7b8:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c7bc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c7c0:	e0bfff17 	ldw	r2,-4(fp)
}
8110c7c4:	e037883a 	mov	sp,fp
8110c7c8:	dfc00117 	ldw	ra,4(sp)
8110c7cc:	df000017 	ldw	fp,0(sp)
8110c7d0:	dec00204 	addi	sp,sp,8
8110c7d4:	f800283a 	ret

8110c7d8 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110c7d8:	defffd04 	addi	sp,sp,-12
8110c7dc:	de00012e 	bgeu	sp,et,8110c7e4 <bSyncErrInj+0xc>
8110c7e0:	003b68fa 	trap	3
8110c7e4:	dfc00215 	stw	ra,8(sp)
8110c7e8:	df000115 	stw	fp,4(sp)
8110c7ec:	df000104 	addi	fp,sp,4
8110c7f0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110c7f4:	e17fff17 	ldw	r5,-4(fp)
8110c7f8:	01000244 	movi	r4,9
8110c7fc:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c800:	00800044 	movi	r2,1
}
8110c804:	e037883a 	mov	sp,fp
8110c808:	dfc00117 	ldw	ra,4(sp)
8110c80c:	df000017 	ldw	fp,0(sp)
8110c810:	dec00204 	addi	sp,sp,8
8110c814:	f800283a 	ret

8110c818 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110c818:	defffc04 	addi	sp,sp,-16
8110c81c:	de00012e 	bgeu	sp,et,8110c824 <bSyncCtrExtnIrq+0xc>
8110c820:	003b68fa 	trap	3
8110c824:	dfc00315 	stw	ra,12(sp)
8110c828:	df000215 	stw	fp,8(sp)
8110c82c:	df000204 	addi	fp,sp,8
8110c830:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c834:	01000284 	movi	r4,10
8110c838:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c83c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c840:	e0bfff17 	ldw	r2,-4(fp)
8110c844:	1000061e 	bne	r2,zero,8110c860 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110c848:	e0fffe17 	ldw	r3,-8(fp)
8110c84c:	00a00034 	movhi	r2,32768
8110c850:	10bfffc4 	addi	r2,r2,-1
8110c854:	1884703a 	and	r2,r3,r2
8110c858:	e0bffe15 	stw	r2,-8(fp)
8110c85c:	00000306 	br	8110c86c <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110c860:	e0bffe17 	ldw	r2,-8(fp)
8110c864:	10a00034 	orhi	r2,r2,32768
8110c868:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c86c:	e17ffe17 	ldw	r5,-8(fp)
8110c870:	01000284 	movi	r4,10
8110c874:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c878:	00800044 	movi	r2,1
}
8110c87c:	e037883a 	mov	sp,fp
8110c880:	dfc00117 	ldw	ra,4(sp)
8110c884:	df000017 	ldw	fp,0(sp)
8110c888:	dec00204 	addi	sp,sp,8
8110c88c:	f800283a 	ret

8110c890 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110c890:	defffd04 	addi	sp,sp,-12
8110c894:	de00012e 	bgeu	sp,et,8110c89c <bSyncCtrStart+0xc>
8110c898:	003b68fa 	trap	3
8110c89c:	dfc00215 	stw	ra,8(sp)
8110c8a0:	df000115 	stw	fp,4(sp)
8110c8a4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c8a8:	01000284 	movi	r4,10
8110c8ac:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c8b0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110c8b4:	e0bfff17 	ldw	r2,-4(fp)
8110c8b8:	10800234 	orhi	r2,r2,8
8110c8bc:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c8c0:	e17fff17 	ldw	r5,-4(fp)
8110c8c4:	01000284 	movi	r4,10
8110c8c8:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c8cc:	00800044 	movi	r2,1
}
8110c8d0:	e037883a 	mov	sp,fp
8110c8d4:	dfc00117 	ldw	ra,4(sp)
8110c8d8:	df000017 	ldw	fp,0(sp)
8110c8dc:	dec00204 	addi	sp,sp,8
8110c8e0:	f800283a 	ret

8110c8e4 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110c8e4:	defffd04 	addi	sp,sp,-12
8110c8e8:	de00012e 	bgeu	sp,et,8110c8f0 <bSyncCtrReset+0xc>
8110c8ec:	003b68fa 	trap	3
8110c8f0:	dfc00215 	stw	ra,8(sp)
8110c8f4:	df000115 	stw	fp,4(sp)
8110c8f8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c8fc:	01000284 	movi	r4,10
8110c900:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c904:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110c908:	e0bfff17 	ldw	r2,-4(fp)
8110c90c:	10800134 	orhi	r2,r2,4
8110c910:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c914:	e17fff17 	ldw	r5,-4(fp)
8110c918:	01000284 	movi	r4,10
8110c91c:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c920:	00800044 	movi	r2,1
}
8110c924:	e037883a 	mov	sp,fp
8110c928:	dfc00117 	ldw	ra,4(sp)
8110c92c:	df000017 	ldw	fp,0(sp)
8110c930:	dec00204 	addi	sp,sp,8
8110c934:	f800283a 	ret

8110c938 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110c938:	defffd04 	addi	sp,sp,-12
8110c93c:	de00012e 	bgeu	sp,et,8110c944 <bSyncCtrOneShot+0xc>
8110c940:	003b68fa 	trap	3
8110c944:	dfc00215 	stw	ra,8(sp)
8110c948:	df000115 	stw	fp,4(sp)
8110c94c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c950:	01000284 	movi	r4,10
8110c954:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c958:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110c95c:	e0bfff17 	ldw	r2,-4(fp)
8110c960:	108000b4 	orhi	r2,r2,2
8110c964:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c968:	e17fff17 	ldw	r5,-4(fp)
8110c96c:	01000284 	movi	r4,10
8110c970:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c974:	00800044 	movi	r2,1
}
8110c978:	e037883a 	mov	sp,fp
8110c97c:	dfc00117 	ldw	ra,4(sp)
8110c980:	df000017 	ldw	fp,0(sp)
8110c984:	dec00204 	addi	sp,sp,8
8110c988:	f800283a 	ret

8110c98c <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110c98c:	defffd04 	addi	sp,sp,-12
8110c990:	de00012e 	bgeu	sp,et,8110c998 <bSyncCtrErrInj+0xc>
8110c994:	003b68fa 	trap	3
8110c998:	dfc00215 	stw	ra,8(sp)
8110c99c:	df000115 	stw	fp,4(sp)
8110c9a0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c9a4:	01000284 	movi	r4,10
8110c9a8:	110d1480 	call	8110d148 <uliSyncReadReg>
8110c9ac:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110c9b0:	e0bfff17 	ldw	r2,-4(fp)
8110c9b4:	10800074 	orhi	r2,r2,1
8110c9b8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c9bc:	e17fff17 	ldw	r5,-4(fp)
8110c9c0:	01000284 	movi	r4,10
8110c9c4:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110c9c8:	00800044 	movi	r2,1
}
8110c9cc:	e037883a 	mov	sp,fp
8110c9d0:	dfc00117 	ldw	ra,4(sp)
8110c9d4:	df000017 	ldw	fp,0(sp)
8110c9d8:	dec00204 	addi	sp,sp,8
8110c9dc:	f800283a 	ret

8110c9e0 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110c9e0:	defffc04 	addi	sp,sp,-16
8110c9e4:	de00012e 	bgeu	sp,et,8110c9ec <bSyncCtrSyncOutEnable+0xc>
8110c9e8:	003b68fa 	trap	3
8110c9ec:	dfc00315 	stw	ra,12(sp)
8110c9f0:	df000215 	stw	fp,8(sp)
8110c9f4:	df000204 	addi	fp,sp,8
8110c9f8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c9fc:	01000284 	movi	r4,10
8110ca00:	110d1480 	call	8110d148 <uliSyncReadReg>
8110ca04:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ca08:	e0bfff17 	ldw	r2,-4(fp)
8110ca0c:	1000051e 	bne	r2,zero,8110ca24 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110ca10:	e0fffe17 	ldw	r3,-8(fp)
8110ca14:	00bfbfc4 	movi	r2,-257
8110ca18:	1884703a 	and	r2,r3,r2
8110ca1c:	e0bffe15 	stw	r2,-8(fp)
8110ca20:	00000306 	br	8110ca30 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110ca24:	e0bffe17 	ldw	r2,-8(fp)
8110ca28:	10804014 	ori	r2,r2,256
8110ca2c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110ca30:	e17ffe17 	ldw	r5,-8(fp)
8110ca34:	01000284 	movi	r4,10
8110ca38:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110ca3c:	00800044 	movi	r2,1
}
8110ca40:	e037883a 	mov	sp,fp
8110ca44:	dfc00117 	ldw	ra,4(sp)
8110ca48:	df000017 	ldw	fp,0(sp)
8110ca4c:	dec00204 	addi	sp,sp,8
8110ca50:	f800283a 	ret

8110ca54 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110ca54:	defffc04 	addi	sp,sp,-16
8110ca58:	de00012e 	bgeu	sp,et,8110ca60 <bSyncCtrCh1OutEnable+0xc>
8110ca5c:	003b68fa 	trap	3
8110ca60:	dfc00315 	stw	ra,12(sp)
8110ca64:	df000215 	stw	fp,8(sp)
8110ca68:	df000204 	addi	fp,sp,8
8110ca6c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110ca70:	01000284 	movi	r4,10
8110ca74:	110d1480 	call	8110d148 <uliSyncReadReg>
8110ca78:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ca7c:	e0bfff17 	ldw	r2,-4(fp)
8110ca80:	1000051e 	bne	r2,zero,8110ca98 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110ca84:	e0fffe17 	ldw	r3,-8(fp)
8110ca88:	00bfff84 	movi	r2,-2
8110ca8c:	1884703a 	and	r2,r3,r2
8110ca90:	e0bffe15 	stw	r2,-8(fp)
8110ca94:	00000306 	br	8110caa4 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110ca98:	e0bffe17 	ldw	r2,-8(fp)
8110ca9c:	10800054 	ori	r2,r2,1
8110caa0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110caa4:	e17ffe17 	ldw	r5,-8(fp)
8110caa8:	01000284 	movi	r4,10
8110caac:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cab0:	00800044 	movi	r2,1
}
8110cab4:	e037883a 	mov	sp,fp
8110cab8:	dfc00117 	ldw	ra,4(sp)
8110cabc:	df000017 	ldw	fp,0(sp)
8110cac0:	dec00204 	addi	sp,sp,8
8110cac4:	f800283a 	ret

8110cac8 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110cac8:	defffc04 	addi	sp,sp,-16
8110cacc:	de00012e 	bgeu	sp,et,8110cad4 <bSyncCtrCh2OutEnable+0xc>
8110cad0:	003b68fa 	trap	3
8110cad4:	dfc00315 	stw	ra,12(sp)
8110cad8:	df000215 	stw	fp,8(sp)
8110cadc:	df000204 	addi	fp,sp,8
8110cae0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cae4:	01000284 	movi	r4,10
8110cae8:	110d1480 	call	8110d148 <uliSyncReadReg>
8110caec:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110caf0:	e0bfff17 	ldw	r2,-4(fp)
8110caf4:	1000051e 	bne	r2,zero,8110cb0c <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110caf8:	e0fffe17 	ldw	r3,-8(fp)
8110cafc:	00bfff44 	movi	r2,-3
8110cb00:	1884703a 	and	r2,r3,r2
8110cb04:	e0bffe15 	stw	r2,-8(fp)
8110cb08:	00000306 	br	8110cb18 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110cb0c:	e0bffe17 	ldw	r2,-8(fp)
8110cb10:	10800094 	ori	r2,r2,2
8110cb14:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cb18:	e17ffe17 	ldw	r5,-8(fp)
8110cb1c:	01000284 	movi	r4,10
8110cb20:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cb24:	00800044 	movi	r2,1
}
8110cb28:	e037883a 	mov	sp,fp
8110cb2c:	dfc00117 	ldw	ra,4(sp)
8110cb30:	df000017 	ldw	fp,0(sp)
8110cb34:	dec00204 	addi	sp,sp,8
8110cb38:	f800283a 	ret

8110cb3c <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110cb3c:	defffc04 	addi	sp,sp,-16
8110cb40:	de00012e 	bgeu	sp,et,8110cb48 <bSyncCtrCh3OutEnable+0xc>
8110cb44:	003b68fa 	trap	3
8110cb48:	dfc00315 	stw	ra,12(sp)
8110cb4c:	df000215 	stw	fp,8(sp)
8110cb50:	df000204 	addi	fp,sp,8
8110cb54:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cb58:	01000284 	movi	r4,10
8110cb5c:	110d1480 	call	8110d148 <uliSyncReadReg>
8110cb60:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cb64:	e0bfff17 	ldw	r2,-4(fp)
8110cb68:	1000051e 	bne	r2,zero,8110cb80 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110cb6c:	e0fffe17 	ldw	r3,-8(fp)
8110cb70:	00bffec4 	movi	r2,-5
8110cb74:	1884703a 	and	r2,r3,r2
8110cb78:	e0bffe15 	stw	r2,-8(fp)
8110cb7c:	00000306 	br	8110cb8c <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110cb80:	e0bffe17 	ldw	r2,-8(fp)
8110cb84:	10800114 	ori	r2,r2,4
8110cb88:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cb8c:	e17ffe17 	ldw	r5,-8(fp)
8110cb90:	01000284 	movi	r4,10
8110cb94:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cb98:	00800044 	movi	r2,1
}
8110cb9c:	e037883a 	mov	sp,fp
8110cba0:	dfc00117 	ldw	ra,4(sp)
8110cba4:	df000017 	ldw	fp,0(sp)
8110cba8:	dec00204 	addi	sp,sp,8
8110cbac:	f800283a 	ret

8110cbb0 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110cbb0:	defffc04 	addi	sp,sp,-16
8110cbb4:	de00012e 	bgeu	sp,et,8110cbbc <bSyncCtrCh4OutEnable+0xc>
8110cbb8:	003b68fa 	trap	3
8110cbbc:	dfc00315 	stw	ra,12(sp)
8110cbc0:	df000215 	stw	fp,8(sp)
8110cbc4:	df000204 	addi	fp,sp,8
8110cbc8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cbcc:	01000284 	movi	r4,10
8110cbd0:	110d1480 	call	8110d148 <uliSyncReadReg>
8110cbd4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cbd8:	e0bfff17 	ldw	r2,-4(fp)
8110cbdc:	1000051e 	bne	r2,zero,8110cbf4 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110cbe0:	e0fffe17 	ldw	r3,-8(fp)
8110cbe4:	00bffdc4 	movi	r2,-9
8110cbe8:	1884703a 	and	r2,r3,r2
8110cbec:	e0bffe15 	stw	r2,-8(fp)
8110cbf0:	00000306 	br	8110cc00 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110cbf4:	e0bffe17 	ldw	r2,-8(fp)
8110cbf8:	10800214 	ori	r2,r2,8
8110cbfc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cc00:	e17ffe17 	ldw	r5,-8(fp)
8110cc04:	01000284 	movi	r4,10
8110cc08:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cc0c:	00800044 	movi	r2,1
}
8110cc10:	e037883a 	mov	sp,fp
8110cc14:	dfc00117 	ldw	ra,4(sp)
8110cc18:	df000017 	ldw	fp,0(sp)
8110cc1c:	dec00204 	addi	sp,sp,8
8110cc20:	f800283a 	ret

8110cc24 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110cc24:	defffc04 	addi	sp,sp,-16
8110cc28:	de00012e 	bgeu	sp,et,8110cc30 <bSyncCtrCh5OutEnable+0xc>
8110cc2c:	003b68fa 	trap	3
8110cc30:	dfc00315 	stw	ra,12(sp)
8110cc34:	df000215 	stw	fp,8(sp)
8110cc38:	df000204 	addi	fp,sp,8
8110cc3c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cc40:	01000284 	movi	r4,10
8110cc44:	110d1480 	call	8110d148 <uliSyncReadReg>
8110cc48:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cc4c:	e0bfff17 	ldw	r2,-4(fp)
8110cc50:	1000051e 	bne	r2,zero,8110cc68 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110cc54:	e0fffe17 	ldw	r3,-8(fp)
8110cc58:	00bffbc4 	movi	r2,-17
8110cc5c:	1884703a 	and	r2,r3,r2
8110cc60:	e0bffe15 	stw	r2,-8(fp)
8110cc64:	00000306 	br	8110cc74 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110cc68:	e0bffe17 	ldw	r2,-8(fp)
8110cc6c:	10800414 	ori	r2,r2,16
8110cc70:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cc74:	e17ffe17 	ldw	r5,-8(fp)
8110cc78:	01000284 	movi	r4,10
8110cc7c:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cc80:	00800044 	movi	r2,1
}
8110cc84:	e037883a 	mov	sp,fp
8110cc88:	dfc00117 	ldw	ra,4(sp)
8110cc8c:	df000017 	ldw	fp,0(sp)
8110cc90:	dec00204 	addi	sp,sp,8
8110cc94:	f800283a 	ret

8110cc98 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110cc98:	defffc04 	addi	sp,sp,-16
8110cc9c:	de00012e 	bgeu	sp,et,8110cca4 <bSyncCtrCh6OutEnable+0xc>
8110cca0:	003b68fa 	trap	3
8110cca4:	dfc00315 	stw	ra,12(sp)
8110cca8:	df000215 	stw	fp,8(sp)
8110ccac:	df000204 	addi	fp,sp,8
8110ccb0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110ccb4:	01000284 	movi	r4,10
8110ccb8:	110d1480 	call	8110d148 <uliSyncReadReg>
8110ccbc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ccc0:	e0bfff17 	ldw	r2,-4(fp)
8110ccc4:	1000051e 	bne	r2,zero,8110ccdc <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110ccc8:	e0fffe17 	ldw	r3,-8(fp)
8110cccc:	00bff7c4 	movi	r2,-33
8110ccd0:	1884703a 	and	r2,r3,r2
8110ccd4:	e0bffe15 	stw	r2,-8(fp)
8110ccd8:	00000306 	br	8110cce8 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110ccdc:	e0bffe17 	ldw	r2,-8(fp)
8110cce0:	10800814 	ori	r2,r2,32
8110cce4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cce8:	e17ffe17 	ldw	r5,-8(fp)
8110ccec:	01000284 	movi	r4,10
8110ccf0:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110ccf4:	00800044 	movi	r2,1
}
8110ccf8:	e037883a 	mov	sp,fp
8110ccfc:	dfc00117 	ldw	ra,4(sp)
8110cd00:	df000017 	ldw	fp,0(sp)
8110cd04:	dec00204 	addi	sp,sp,8
8110cd08:	f800283a 	ret

8110cd0c <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110cd0c:	defffc04 	addi	sp,sp,-16
8110cd10:	de00012e 	bgeu	sp,et,8110cd18 <bSyncCtrCh7OutEnable+0xc>
8110cd14:	003b68fa 	trap	3
8110cd18:	dfc00315 	stw	ra,12(sp)
8110cd1c:	df000215 	stw	fp,8(sp)
8110cd20:	df000204 	addi	fp,sp,8
8110cd24:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cd28:	01000284 	movi	r4,10
8110cd2c:	110d1480 	call	8110d148 <uliSyncReadReg>
8110cd30:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cd34:	e0bfff17 	ldw	r2,-4(fp)
8110cd38:	1000051e 	bne	r2,zero,8110cd50 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110cd3c:	e0fffe17 	ldw	r3,-8(fp)
8110cd40:	00bfefc4 	movi	r2,-65
8110cd44:	1884703a 	and	r2,r3,r2
8110cd48:	e0bffe15 	stw	r2,-8(fp)
8110cd4c:	00000306 	br	8110cd5c <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110cd50:	e0bffe17 	ldw	r2,-8(fp)
8110cd54:	10801014 	ori	r2,r2,64
8110cd58:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cd5c:	e17ffe17 	ldw	r5,-8(fp)
8110cd60:	01000284 	movi	r4,10
8110cd64:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cd68:	00800044 	movi	r2,1
}
8110cd6c:	e037883a 	mov	sp,fp
8110cd70:	dfc00117 	ldw	ra,4(sp)
8110cd74:	df000017 	ldw	fp,0(sp)
8110cd78:	dec00204 	addi	sp,sp,8
8110cd7c:	f800283a 	ret

8110cd80 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110cd80:	defffc04 	addi	sp,sp,-16
8110cd84:	de00012e 	bgeu	sp,et,8110cd8c <bSyncCtrCh8OutEnable+0xc>
8110cd88:	003b68fa 	trap	3
8110cd8c:	dfc00315 	stw	ra,12(sp)
8110cd90:	df000215 	stw	fp,8(sp)
8110cd94:	df000204 	addi	fp,sp,8
8110cd98:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cd9c:	01000284 	movi	r4,10
8110cda0:	110d1480 	call	8110d148 <uliSyncReadReg>
8110cda4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cda8:	e0bfff17 	ldw	r2,-4(fp)
8110cdac:	1000051e 	bne	r2,zero,8110cdc4 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110cdb0:	e0fffe17 	ldw	r3,-8(fp)
8110cdb4:	00bfdfc4 	movi	r2,-129
8110cdb8:	1884703a 	and	r2,r3,r2
8110cdbc:	e0bffe15 	stw	r2,-8(fp)
8110cdc0:	00000306 	br	8110cdd0 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110cdc4:	e0bffe17 	ldw	r2,-8(fp)
8110cdc8:	10802014 	ori	r2,r2,128
8110cdcc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cdd0:	e17ffe17 	ldw	r5,-8(fp)
8110cdd4:	01000284 	movi	r4,10
8110cdd8:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cddc:	00800044 	movi	r2,1
}
8110cde0:	e037883a 	mov	sp,fp
8110cde4:	dfc00117 	ldw	ra,4(sp)
8110cde8:	df000017 	ldw	fp,0(sp)
8110cdec:	dec00204 	addi	sp,sp,8
8110cdf0:	f800283a 	ret

8110cdf4 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110cdf4:	defffc04 	addi	sp,sp,-16
8110cdf8:	de00012e 	bgeu	sp,et,8110ce00 <bSyncIrqEnableError+0xc>
8110cdfc:	003b68fa 	trap	3
8110ce00:	dfc00315 	stw	ra,12(sp)
8110ce04:	df000215 	stw	fp,8(sp)
8110ce08:	df000204 	addi	fp,sp,8
8110ce0c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110ce10:	01000044 	movi	r4,1
8110ce14:	110d1480 	call	8110d148 <uliSyncReadReg>
8110ce18:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ce1c:	e0bfff17 	ldw	r2,-4(fp)
8110ce20:	1000051e 	bne	r2,zero,8110ce38 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110ce24:	e0fffe17 	ldw	r3,-8(fp)
8110ce28:	00bfff44 	movi	r2,-3
8110ce2c:	1884703a 	and	r2,r3,r2
8110ce30:	e0bffe15 	stw	r2,-8(fp)
8110ce34:	00000306 	br	8110ce44 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110ce38:	e0bffe17 	ldw	r2,-8(fp)
8110ce3c:	10800094 	ori	r2,r2,2
8110ce40:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110ce44:	e17ffe17 	ldw	r5,-8(fp)
8110ce48:	01000044 	movi	r4,1
8110ce4c:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110ce50:	00800044 	movi	r2,1
}
8110ce54:	e037883a 	mov	sp,fp
8110ce58:	dfc00117 	ldw	ra,4(sp)
8110ce5c:	df000017 	ldw	fp,0(sp)
8110ce60:	dec00204 	addi	sp,sp,8
8110ce64:	f800283a 	ret

8110ce68 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110ce68:	defffc04 	addi	sp,sp,-16
8110ce6c:	de00012e 	bgeu	sp,et,8110ce74 <bSyncIrqEnableBlank+0xc>
8110ce70:	003b68fa 	trap	3
8110ce74:	dfc00315 	stw	ra,12(sp)
8110ce78:	df000215 	stw	fp,8(sp)
8110ce7c:	df000204 	addi	fp,sp,8
8110ce80:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110ce84:	01000044 	movi	r4,1
8110ce88:	110d1480 	call	8110d148 <uliSyncReadReg>
8110ce8c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ce90:	e0bfff17 	ldw	r2,-4(fp)
8110ce94:	1000051e 	bne	r2,zero,8110ceac <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110ce98:	e0fffe17 	ldw	r3,-8(fp)
8110ce9c:	00bfff84 	movi	r2,-2
8110cea0:	1884703a 	and	r2,r3,r2
8110cea4:	e0bffe15 	stw	r2,-8(fp)
8110cea8:	00000306 	br	8110ceb8 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110ceac:	e0bffe17 	ldw	r2,-8(fp)
8110ceb0:	10800054 	ori	r2,r2,1
8110ceb4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110ceb8:	e17ffe17 	ldw	r5,-8(fp)
8110cebc:	01000044 	movi	r4,1
8110cec0:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cec4:	00800044 	movi	r2,1
}
8110cec8:	e037883a 	mov	sp,fp
8110cecc:	dfc00117 	ldw	ra,4(sp)
8110ced0:	df000017 	ldw	fp,0(sp)
8110ced4:	dec00204 	addi	sp,sp,8
8110ced8:	f800283a 	ret

8110cedc <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110cedc:	defffc04 	addi	sp,sp,-16
8110cee0:	de00012e 	bgeu	sp,et,8110cee8 <bSyncIrqFlagClrError+0xc>
8110cee4:	003b68fa 	trap	3
8110cee8:	dfc00315 	stw	ra,12(sp)
8110ceec:	df000215 	stw	fp,8(sp)
8110cef0:	df000204 	addi	fp,sp,8
8110cef4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110cef8:	01000084 	movi	r4,2
8110cefc:	110d1480 	call	8110d148 <uliSyncReadReg>
8110cf00:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cf04:	e0bfff17 	ldw	r2,-4(fp)
8110cf08:	1000051e 	bne	r2,zero,8110cf20 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110cf0c:	e0fffe17 	ldw	r3,-8(fp)
8110cf10:	00bfff44 	movi	r2,-3
8110cf14:	1884703a 	and	r2,r3,r2
8110cf18:	e0bffe15 	stw	r2,-8(fp)
8110cf1c:	00000306 	br	8110cf2c <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110cf20:	e0bffe17 	ldw	r2,-8(fp)
8110cf24:	10800094 	ori	r2,r2,2
8110cf28:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110cf2c:	e17ffe17 	ldw	r5,-8(fp)
8110cf30:	01000084 	movi	r4,2
8110cf34:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cf38:	00800044 	movi	r2,1
}
8110cf3c:	e037883a 	mov	sp,fp
8110cf40:	dfc00117 	ldw	ra,4(sp)
8110cf44:	df000017 	ldw	fp,0(sp)
8110cf48:	dec00204 	addi	sp,sp,8
8110cf4c:	f800283a 	ret

8110cf50 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110cf50:	defffc04 	addi	sp,sp,-16
8110cf54:	de00012e 	bgeu	sp,et,8110cf5c <bSyncIrqFlagClrBlank+0xc>
8110cf58:	003b68fa 	trap	3
8110cf5c:	dfc00315 	stw	ra,12(sp)
8110cf60:	df000215 	stw	fp,8(sp)
8110cf64:	df000204 	addi	fp,sp,8
8110cf68:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110cf6c:	01000084 	movi	r4,2
8110cf70:	110d1480 	call	8110d148 <uliSyncReadReg>
8110cf74:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cf78:	e0bfff17 	ldw	r2,-4(fp)
8110cf7c:	1000051e 	bne	r2,zero,8110cf94 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110cf80:	e0fffe17 	ldw	r3,-8(fp)
8110cf84:	00bfff84 	movi	r2,-2
8110cf88:	1884703a 	and	r2,r3,r2
8110cf8c:	e0bffe15 	stw	r2,-8(fp)
8110cf90:	00000306 	br	8110cfa0 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110cf94:	e0bffe17 	ldw	r2,-8(fp)
8110cf98:	10800054 	ori	r2,r2,1
8110cf9c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110cfa0:	e17ffe17 	ldw	r5,-8(fp)
8110cfa4:	01000084 	movi	r4,2
8110cfa8:	110d0ec0 	call	8110d0ec <bSyncWriteReg>
	return TRUE;
8110cfac:	00800044 	movi	r2,1
}
8110cfb0:	e037883a 	mov	sp,fp
8110cfb4:	dfc00117 	ldw	ra,4(sp)
8110cfb8:	df000017 	ldw	fp,0(sp)
8110cfbc:	dec00204 	addi	sp,sp,8
8110cfc0:	f800283a 	ret

8110cfc4 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110cfc4:	defffc04 	addi	sp,sp,-16
8110cfc8:	de00012e 	bgeu	sp,et,8110cfd0 <bSyncIrqFlagError+0xc>
8110cfcc:	003b68fa 	trap	3
8110cfd0:	dfc00315 	stw	ra,12(sp)
8110cfd4:	df000215 	stw	fp,8(sp)
8110cfd8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110cfdc:	010000c4 	movi	r4,3
8110cfe0:	110d1480 	call	8110d148 <uliSyncReadReg>
8110cfe4:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110cfe8:	e0bfff17 	ldw	r2,-4(fp)
8110cfec:	1080008c 	andi	r2,r2,2
8110cff0:	10000326 	beq	r2,zero,8110d000 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110cff4:	00800044 	movi	r2,1
8110cff8:	e0bffe15 	stw	r2,-8(fp)
8110cffc:	00000106 	br	8110d004 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110d000:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d004:	e0bffe17 	ldw	r2,-8(fp)
}
8110d008:	e037883a 	mov	sp,fp
8110d00c:	dfc00117 	ldw	ra,4(sp)
8110d010:	df000017 	ldw	fp,0(sp)
8110d014:	dec00204 	addi	sp,sp,8
8110d018:	f800283a 	ret

8110d01c <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110d01c:	defffc04 	addi	sp,sp,-16
8110d020:	de00012e 	bgeu	sp,et,8110d028 <bSyncIrqFlagBlank+0xc>
8110d024:	003b68fa 	trap	3
8110d028:	dfc00315 	stw	ra,12(sp)
8110d02c:	df000215 	stw	fp,8(sp)
8110d030:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d034:	010000c4 	movi	r4,3
8110d038:	110d1480 	call	8110d148 <uliSyncReadReg>
8110d03c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110d040:	e0bfff17 	ldw	r2,-4(fp)
8110d044:	1080004c 	andi	r2,r2,1
8110d048:	10000326 	beq	r2,zero,8110d058 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110d04c:	00800044 	movi	r2,1
8110d050:	e0bffe15 	stw	r2,-8(fp)
8110d054:	00000106 	br	8110d05c <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110d058:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d05c:	e0bffe17 	ldw	r2,-8(fp)
}
8110d060:	e037883a 	mov	sp,fp
8110d064:	dfc00117 	ldw	ra,4(sp)
8110d068:	df000017 	ldw	fp,0(sp)
8110d06c:	dec00204 	addi	sp,sp,8
8110d070:	f800283a 	ret

8110d074 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110d074:	defffd04 	addi	sp,sp,-12
8110d078:	de00012e 	bgeu	sp,et,8110d080 <uliSyncGetCtr+0xc>
8110d07c:	003b68fa 	trap	3
8110d080:	dfc00215 	stw	ra,8(sp)
8110d084:	df000115 	stw	fp,4(sp)
8110d088:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d08c:	01000284 	movi	r4,10
8110d090:	110d1480 	call	8110d148 <uliSyncReadReg>
8110d094:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d098:	e0bfff17 	ldw	r2,-4(fp)
}
8110d09c:	e037883a 	mov	sp,fp
8110d0a0:	dfc00117 	ldw	ra,4(sp)
8110d0a4:	df000017 	ldw	fp,0(sp)
8110d0a8:	dec00204 	addi	sp,sp,8
8110d0ac:	f800283a 	ret

8110d0b0 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110d0b0:	defffd04 	addi	sp,sp,-12
8110d0b4:	de00012e 	bgeu	sp,et,8110d0bc <uliSyncReadStatus+0xc>
8110d0b8:	003b68fa 	trap	3
8110d0bc:	dfc00215 	stw	ra,8(sp)
8110d0c0:	df000115 	stw	fp,4(sp)
8110d0c4:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d0c8:	0009883a 	mov	r4,zero
8110d0cc:	110d1480 	call	8110d148 <uliSyncReadReg>
8110d0d0:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110d0d4:	e0bfff17 	ldw	r2,-4(fp)
}
8110d0d8:	e037883a 	mov	sp,fp
8110d0dc:	dfc00117 	ldw	ra,4(sp)
8110d0e0:	df000017 	ldw	fp,0(sp)
8110d0e4:	dec00204 	addi	sp,sp,8
8110d0e8:	f800283a 	ret

8110d0ec <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110d0ec:	defffc04 	addi	sp,sp,-16
8110d0f0:	de00012e 	bgeu	sp,et,8110d0f8 <bSyncWriteReg+0xc>
8110d0f4:	003b68fa 	trap	3
8110d0f8:	df000315 	stw	fp,12(sp)
8110d0fc:	df000304 	addi	fp,sp,12
8110d100:	e13ffe15 	stw	r4,-8(fp)
8110d104:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d108:	00a00034 	movhi	r2,32768
8110d10c:	10810004 	addi	r2,r2,1024
8110d110:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110d114:	e0bffe17 	ldw	r2,-8(fp)
8110d118:	1085883a 	add	r2,r2,r2
8110d11c:	1085883a 	add	r2,r2,r2
8110d120:	1007883a 	mov	r3,r2
8110d124:	e0bffd17 	ldw	r2,-12(fp)
8110d128:	10c5883a 	add	r2,r2,r3
8110d12c:	e0ffff17 	ldw	r3,-4(fp)
8110d130:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110d134:	00800044 	movi	r2,1
}
8110d138:	e037883a 	mov	sp,fp
8110d13c:	df000017 	ldw	fp,0(sp)
8110d140:	dec00104 	addi	sp,sp,4
8110d144:	f800283a 	ret

8110d148 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110d148:	defffc04 	addi	sp,sp,-16
8110d14c:	de00012e 	bgeu	sp,et,8110d154 <uliSyncReadReg+0xc>
8110d150:	003b68fa 	trap	3
8110d154:	df000315 	stw	fp,12(sp)
8110d158:	df000304 	addi	fp,sp,12
8110d15c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d160:	00a00034 	movhi	r2,32768
8110d164:	10810004 	addi	r2,r2,1024
8110d168:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110d16c:	e0bfff17 	ldw	r2,-4(fp)
8110d170:	1085883a 	add	r2,r2,r2
8110d174:	1085883a 	add	r2,r2,r2
8110d178:	1007883a 	mov	r3,r2
8110d17c:	e0bffd17 	ldw	r2,-12(fp)
8110d180:	10c5883a 	add	r2,r2,r3
8110d184:	10800017 	ldw	r2,0(r2)
8110d188:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110d18c:	e0bffe17 	ldw	r2,-8(fp)
}
8110d190:	e037883a 	mov	sp,fp
8110d194:	df000017 	ldw	fp,0(sp)
8110d198:	dec00104 	addi	sp,sp,4
8110d19c:	f800283a 	ret

8110d1a0 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110d1a0:	defff804 	addi	sp,sp,-32
8110d1a4:	de00012e 	bgeu	sp,et,8110d1ac <vDataControlTask+0xc>
8110d1a8:	003b68fa 	trap	3
8110d1ac:	dfc00715 	stw	ra,28(sp)
8110d1b0:	df000615 	stw	fp,24(sp)
8110d1b4:	df000604 	addi	fp,sp,24
8110d1b8:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110d1bc:	e0bffd17 	ldw	r2,-12(fp)
8110d1c0:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110d1c4:	d0a06117 	ldw	r2,-32380(gp)
8110d1c8:	100f883a 	mov	r7,r2
8110d1cc:	01800804 	movi	r6,32
8110d1d0:	01400044 	movi	r5,1
8110d1d4:	01204574 	movhi	r4,33045
8110d1d8:	21247704 	addi	r4,r4,-28196
8110d1dc:	111dcb00 	call	8111dcb0 <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110d1e0:	e0bffa17 	ldw	r2,-24(fp)
8110d1e4:	00c00044 	movi	r3,1
8110d1e8:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110d1ec:	d0a05e17 	ldw	r2,-32392(gp)
8110d1f0:	1009883a 	mov	r4,r2
8110d1f4:	113a7380 	call	8113a738 <OSQFlush>
8110d1f8:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110d1fc:	e0bffc03 	ldbu	r2,-16(fp)
8110d200:	10803fcc 	andi	r2,r2,255
8110d204:	10000126 	beq	r2,zero,8110d20c <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110d208:	111a3c00 	call	8111a3c0 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110d20c:	e0bffc04 	addi	r2,fp,-16
8110d210:	100d883a 	mov	r6,r2
8110d214:	000b883a 	mov	r5,zero
8110d218:	012045b4 	movhi	r4,33046
8110d21c:	21204f04 	addi	r4,r4,-32452
8110d220:	113a7f80 	call	8113a7f8 <OSQPend>
8110d224:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110d228:	000f883a 	mov	r7,zero
8110d22c:	01800144 	movi	r6,5
8110d230:	000b883a 	mov	r5,zero
8110d234:	0009883a 	mov	r4,zero
8110d238:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
	}
8110d23c:	003ff306 	br	8110d20c <__reset+0xfb0ed20c>

8110d240 <vFeeTask>:

#include "fee_task.h"

TRmapChannel RmapConfAreaL;

void vFeeTask(void *task_data) {
8110d240:	defff304 	addi	sp,sp,-52
8110d244:	de00012e 	bgeu	sp,et,8110d24c <vFeeTask+0xc>
8110d248:	003b68fa 	trap	3
8110d24c:	dfc00c15 	stw	ra,48(sp)
8110d250:	df000b15 	stw	fp,44(sp)
8110d254:	df000b04 	addi	fp,sp,44
8110d258:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110d25c:	e03ffb15 	stw	zero,-20(fp)
	alt_u16 usiLengthBlocks;
	bool bDmaReturn;
	bool bFinal;


	pxNFee = ( TNFee * ) task_data;
8110d260:	e0bfff17 	ldw	r2,-4(fp)
8110d264:	d0a05315 	stw	r2,-32436(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110d268:	d0e06117 	ldw	r3,-32380(gp)
8110d26c:	d0a05317 	ldw	r2,-32436(gp)
8110d270:	10800003 	ldbu	r2,0(r2)
8110d274:	10803fcc 	andi	r2,r2,255
8110d278:	100d883a 	mov	r6,r2
8110d27c:	01604574 	movhi	r5,33045
8110d280:	29648004 	addi	r5,r5,-28160
8110d284:	1809883a 	mov	r4,r3
8110d288:	111d6140 	call	8111d614 <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110d28c:	d0a05317 	ldw	r2,-32436(gp)
8110d290:	1009883a 	mov	r4,r2
8110d294:	110f37c0 	call	8110f37c <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110d298:	d0a05317 	ldw	r2,-32436(gp)
8110d29c:	10802c17 	ldw	r2,176(r2)
8110d2a0:	10c00328 	cmpgeui	r3,r2,12
8110d2a4:	1804051e 	bne	r3,zero,8110e2bc <vFeeTask+0x107c>
8110d2a8:	100690ba 	slli	r3,r2,2
8110d2ac:	00a04474 	movhi	r2,33041
8110d2b0:	10b4b004 	addi	r2,r2,-11584
8110d2b4:	1885883a 	add	r2,r3,r2
8110d2b8:	10800017 	ldw	r2,0(r2)
8110d2bc:	1000683a 	jmp	r2
8110d2c0:	8110d2f0 	cmpltui	r4,r16,17227
8110d2c4:	8110d5fc 	xorhi	r4,r16,17239
8110d2c8:	8110d680 	call	88110d68 <__reset+0x20f0d68>
8110d2cc:	8110d7d0 	cmplti	r4,r16,17247
8110d2d0:	8110de6c 	andhi	r4,r16,17273
8110d2d4:	8110d404 	addi	r4,r16,17232
8110d2d8:	8110d690 	cmplti	r4,r16,17242
8110d2dc:	8110ddb0 	cmpltui	r4,r16,17270
8110d2e0:	8110e2bc 	xorhi	r4,r16,17290
8110d2e4:	8110e2f0 	cmpltui	r4,r16,17291
8110d2e8:	8110d854 	ori	r4,r16,17249
8110d2ec:	8110e1fc 	xorhi	r4,r16,17287
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110d2f0:	d0a05317 	ldw	r2,-32436(gp)
8110d2f4:	10800003 	ldbu	r2,0(r2)
8110d2f8:	10803fcc 	andi	r2,r2,255
8110d2fc:	1085883a 	add	r2,r2,r2
8110d300:	1087883a 	add	r3,r2,r2
8110d304:	d0a06904 	addi	r2,gp,-32348
8110d308:	1885883a 	add	r2,r3,r2
8110d30c:	10800017 	ldw	r2,0(r2)
8110d310:	1009883a 	mov	r4,r2
8110d314:	113a7380 	call	8113a738 <OSQFlush>
8110d318:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d31c:	e0bffd03 	ldbu	r2,-12(fp)
8110d320:	10803fcc 	andi	r2,r2,255
8110d324:	10000126 	beq	r2,zero,8110d32c <vFeeTask+0xec>
					vFailFlushNFEEQueue();
8110d328:	111a4580 	call	8111a458 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110d32c:	d0a05317 	ldw	r2,-32436(gp)
8110d330:	10800003 	ldbu	r2,0(r2)
8110d334:	10803fcc 	andi	r2,r2,255
8110d338:	1085883a 	add	r2,r2,r2
8110d33c:	1087883a 	add	r3,r2,r2
8110d340:	d0a05b04 	addi	r2,gp,-32404
8110d344:	1885883a 	add	r2,r3,r2
8110d348:	10800017 	ldw	r2,0(r2)
8110d34c:	1009883a 	mov	r4,r2
8110d350:	113a7380 	call	8113a738 <OSQFlush>
8110d354:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d358:	e0bffd03 	ldbu	r2,-12(fp)
8110d35c:	10803fcc 	andi	r2,r2,255
8110d360:	10000126 	beq	r2,zero,8110d368 <vFeeTask+0x128>
					vFailFlushNFEEQueue();
8110d364:	111a4580 	call	8111a458 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110d368:	d0a05317 	ldw	r2,-32436(gp)
8110d36c:	10803304 	addi	r2,r2,204
8110d370:	1009883a 	mov	r4,r2
8110d374:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth;
8110d378:	d0a05317 	ldw	r2,-32436(gp)
8110d37c:	d0e05317 	ldw	r3,-32436(gp)
8110d380:	18c0308b 	ldhu	r3,194(r3)
8110d384:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight;
8110d388:	d0a05317 	ldw	r2,-32436(gp)
8110d38c:	d0e05317 	ldw	r3,-32436(gp)
8110d390:	18c0310b 	ldhu	r3,196(r3)
8110d394:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight - pxNFee->xCcdInfo.usiOLN;
8110d398:	d0a05317 	ldw	r2,-32436(gp)
8110d39c:	d0e05317 	ldw	r3,-32436(gp)
8110d3a0:	1900310b 	ldhu	r4,196(r3)
8110d3a4:	d0e05317 	ldw	r3,-32436(gp)
8110d3a8:	18c0300b 	ldhu	r3,192(r3)
8110d3ac:	20c7c83a 	sub	r3,r4,r3
8110d3b0:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110d3b4:	d0a05317 	ldw	r2,-32436(gp)
8110d3b8:	d0e05317 	ldw	r3,-32436(gp)
8110d3bc:	18c0300b 	ldhu	r3,192(r3)
8110d3c0:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110d3c4:	d0a05317 	ldw	r2,-32436(gp)
8110d3c8:	00e00004 	movi	r3,-32768
8110d3cc:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110d3d0:	d0a05317 	ldw	r2,-32436(gp)
8110d3d4:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110d3d8:	d0a05317 	ldw	r2,-32436(gp)
8110d3dc:	00c00044 	movi	r3,1
8110d3e0:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110d3e4:	d0a05317 	ldw	r2,-32436(gp)
8110d3e8:	10803304 	addi	r2,r2,204
8110d3ec:	1009883a 	mov	r4,r2
8110d3f0:	110479c0 	call	8110479c <bDpktSetPacketConfig>


				pxNFee->xControl.eMode = sToFeeConfig;
8110d3f4:	d0a05317 	ldw	r2,-32436(gp)
8110d3f8:	00c00144 	movi	r3,5
8110d3fc:	10c02c15 	stw	r3,176(r2)

				break;
8110d400:	0003c206 	br	8110e30c <vFeeTask+0x10cc>
			case sToFeeConfig: /* Transition */

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110d404:	d0a05317 	ldw	r2,-32436(gp)
8110d408:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110d40c:	d0a05317 	ldw	r2,-32436(gp)
8110d410:	10800003 	ldbu	r2,0(r2)
8110d414:	10803fcc 	andi	r2,r2,255
8110d418:	1085883a 	add	r2,r2,r2
8110d41c:	1087883a 	add	r3,r2,r2
8110d420:	d0a05b04 	addi	r2,gp,-32404
8110d424:	1885883a 	add	r2,r3,r2
8110d428:	10800017 	ldw	r2,0(r2)
8110d42c:	1009883a 	mov	r4,r2
8110d430:	113a7380 	call	8113a738 <OSQFlush>
8110d434:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d438:	e0bffd03 	ldbu	r2,-12(fp)
8110d43c:	10803fcc 	andi	r2,r2,255
8110d440:	10000126 	beq	r2,zero,8110d448 <vFeeTask+0x208>
					vFailFlushNFEEQueue();
8110d444:	111a4580 	call	8111a458 <vFailFlushNFEEQueue>
				}


				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d448:	d0a05317 	ldw	r2,-32436(gp)
8110d44c:	10804304 	addi	r2,r2,268
8110d450:	1009883a 	mov	r4,r2
8110d454:	1107cbc0 	call	81107cbc <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110d458:	d0a05317 	ldw	r2,-32436(gp)
8110d45c:	00c00184 	movi	r3,6
8110d460:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d464:	d0a05317 	ldw	r2,-32436(gp)
8110d468:	10804304 	addi	r2,r2,268
8110d46c:	1009883a 	mov	r4,r2
8110d470:	11079d00 	call	811079d0 <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110d474:	d0e06117 	ldw	r3,-32380(gp)
8110d478:	d0a05317 	ldw	r2,-32436(gp)
8110d47c:	10800003 	ldbu	r2,0(r2)
8110d480:	10803fcc 	andi	r2,r2,255
8110d484:	100d883a 	mov	r6,r2
8110d488:	01604574 	movhi	r5,33045
8110d48c:	29648704 	addi	r5,r5,-28132
8110d490:	1809883a 	mov	r4,r3
8110d494:	111d6140 	call	8111d614 <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110d498:	d0a05317 	ldw	r2,-32436(gp)
8110d49c:	10802217 	ldw	r2,136(r2)
8110d4a0:	10800058 	cmpnei	r2,r2,1
8110d4a4:	10000a1e 	bne	r2,zero,8110d4d0 <vFeeTask+0x290>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d4a8:	e0fff603 	ldbu	r3,-40(fp)
8110d4ac:	00a045b4 	movhi	r2,33046
8110d4b0:	10bf9d04 	addi	r2,r2,-396
8110d4b4:	180690fa 	slli	r3,r3,3
8110d4b8:	10c5883a 	add	r2,r2,r3
8110d4bc:	10800017 	ldw	r2,0(r2)
8110d4c0:	1009883a 	mov	r4,r2
8110d4c4:	1139c880 	call	81139c88 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110d4c8:	d0a05317 	ldw	r2,-32436(gp)
8110d4cc:	10002215 	stw	zero,136(r2)
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110d4d0:	d0a05317 	ldw	r2,-32436(gp)
8110d4d4:	10800003 	ldbu	r2,0(r2)
8110d4d8:	10803fcc 	andi	r2,r2,255
8110d4dc:	100d883a 	mov	r6,r2
8110d4e0:	000b883a 	mov	r5,zero
8110d4e4:	01002044 	movi	r4,129
8110d4e8:	110f2d80 	call	8110f2d8 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110d4ec:	d0a05317 	ldw	r2,-32436(gp)
8110d4f0:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110d4f4:	d0a05317 	ldw	r2,-32436(gp)
8110d4f8:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110d4fc:	d0a05317 	ldw	r2,-32436(gp)
8110d500:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110d504:	d0a05317 	ldw	r2,-32436(gp)
8110d508:	00c00044 	movi	r3,1
8110d50c:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110d510:	d0a05317 	ldw	r2,-32436(gp)
8110d514:	1009883a 	mov	r4,r2
8110d518:	111aa240 	call	8111aa24 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110d51c:	d0a05317 	ldw	r2,-32436(gp)
8110d520:	10800003 	ldbu	r2,0(r2)
8110d524:	10803fcc 	andi	r2,r2,255
8110d528:	1085883a 	add	r2,r2,r2
8110d52c:	1087883a 	add	r3,r2,r2
8110d530:	d0a06904 	addi	r2,gp,-32348
8110d534:	1885883a 	add	r2,r3,r2
8110d538:	10800017 	ldw	r2,0(r2)
8110d53c:	1009883a 	mov	r4,r2
8110d540:	113a7380 	call	8113a738 <OSQFlush>
8110d544:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d548:	e0bffd03 	ldbu	r2,-12(fp)
8110d54c:	10803fcc 	andi	r2,r2,255
8110d550:	10000126 	beq	r2,zero,8110d558 <vFeeTask+0x318>
					vFailFlushNFEEQueue();
8110d554:	111a4580 	call	8111a458 <vFailFlushNFEEQueue>
				}

				/* Clear the Queue that indicates when Sync Signals occours */
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110d558:	d0a05317 	ldw	r2,-32436(gp)
8110d55c:	10800003 	ldbu	r2,0(r2)
8110d560:	10803fcc 	andi	r2,r2,255
8110d564:	1085883a 	add	r2,r2,r2
8110d568:	1087883a 	add	r3,r2,r2
8110d56c:	d0a05b04 	addi	r2,gp,-32404
8110d570:	1885883a 	add	r2,r3,r2
8110d574:	10800017 	ldw	r2,0(r2)
8110d578:	1009883a 	mov	r4,r2
8110d57c:	113a7380 	call	8113a738 <OSQFlush>
8110d580:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d584:	e0bffd03 	ldbu	r2,-12(fp)
8110d588:	10803fcc 	andi	r2,r2,255
8110d58c:	10000126 	beq	r2,zero,8110d594 <vFeeTask+0x354>
					vFailFlushNFEEQueue();
8110d590:	111a4580 	call	8111a458 <vFailFlushNFEEQueue>
				}

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110d594:	d0a05317 	ldw	r2,-32436(gp)
8110d598:	10808904 	addi	r2,r2,548
8110d59c:	1009883a 	mov	r4,r2
8110d5a0:	110f08c0 	call	8110f08c <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110d5a4:	d0a05317 	ldw	r2,-32436(gp)
8110d5a8:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110d5ac:	d0a05317 	ldw	r2,-32436(gp)
8110d5b0:	10c04304 	addi	r3,r2,268
8110d5b4:	d0a05317 	ldw	r2,-32436(gp)
8110d5b8:	10800003 	ldbu	r2,0(r2)
8110d5bc:	10803fcc 	andi	r2,r2,255
8110d5c0:	100b883a 	mov	r5,r2
8110d5c4:	1809883a 	mov	r4,r3
8110d5c8:	110efc40 	call	8110efc4 <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110d5cc:	d0a05317 	ldw	r2,-32436(gp)
8110d5d0:	10803b04 	addi	r2,r2,236
8110d5d4:	1009883a 	mov	r4,r2
8110d5d8:	110f1d00 	call	8110f1d0 <bDisAndClrDbBuffer>

				pxNFee->xControl.bWatingSync = TRUE;
8110d5dc:	d0a05317 	ldw	r2,-32436(gp)
8110d5e0:	00c00044 	movi	r3,1
8110d5e4:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110d5e8:	d0a05317 	ldw	r2,-32436(gp)
8110d5ec:	00c00044 	movi	r3,1
8110d5f0:	10c02c15 	stw	r3,176(r2)
				bFinal = FALSE;
8110d5f4:	e03ffa15 	stw	zero,-24(fp)
				break;
8110d5f8:	00034406 	br	8110e30c <vFeeTask+0x10cc>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d5fc:	d0a05317 	ldw	r2,-32436(gp)
8110d600:	10800003 	ldbu	r2,0(r2)
8110d604:	10803fcc 	andi	r2,r2,255
8110d608:	1085883a 	add	r2,r2,r2
8110d60c:	1087883a 	add	r3,r2,r2
8110d610:	d0a06904 	addi	r2,gp,-32348
8110d614:	1885883a 	add	r2,r3,r2
8110d618:	10800017 	ldw	r2,0(r2)
8110d61c:	e0fffd04 	addi	r3,fp,-12
8110d620:	180d883a 	mov	r6,r3
8110d624:	000b883a 	mov	r5,zero
8110d628:	1009883a 	mov	r4,r2
8110d62c:	113a7f80 	call	8113a7f8 <OSQPend>
8110d630:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d634:	e0bffd03 	ldbu	r2,-12(fp)
8110d638:	10803fcc 	andi	r2,r2,255
8110d63c:	1000061e 	bne	r2,zero,8110d658 <vFeeTask+0x418>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110d640:	d0a05317 	ldw	r2,-32436(gp)
8110d644:	e0fffe17 	ldw	r3,-8(fp)
8110d648:	180b883a 	mov	r5,r3
8110d64c:	1009883a 	mov	r4,r2
8110d650:	110e3100 	call	8110e310 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d654:	00032d06 	br	8110e30c <vFeeTask+0x10cc>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110d658:	d0e06117 	ldw	r3,-32380(gp)
8110d65c:	d0a05317 	ldw	r2,-32436(gp)
8110d660:	10800003 	ldbu	r2,0(r2)
8110d664:	10803fcc 	andi	r2,r2,255
8110d668:	100d883a 	mov	r6,r2
8110d66c:	01604574 	movhi	r5,33045
8110d670:	29648e04 	addi	r5,r5,-28104
8110d674:	1809883a 	mov	r4,r3
8110d678:	111d6140 	call	8111d614 <fprintf>
					#endif
				}

				break;
8110d67c:	00032306 	br	8110e30c <vFeeTask+0x10cc>
			case sFeeOn: /* Real mode */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110d680:	d0a05317 	ldw	r2,-32436(gp)
8110d684:	00c00184 	movi	r3,6
8110d688:	10c02c15 	stw	r3,176(r2)
				break;
8110d68c:	00031f06 	br	8110e30c <vFeeTask+0x10cc>

				break;
			case sToFeeStandBy: /* Transition */

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110d690:	d0a05317 	ldw	r2,-32436(gp)
8110d694:	10800003 	ldbu	r2,0(r2)
8110d698:	10803fcc 	andi	r2,r2,255
8110d69c:	100d883a 	mov	r6,r2
8110d6a0:	000b883a 	mov	r5,zero
8110d6a4:	01002044 	movi	r4,129
8110d6a8:	110f2d80 	call	8110f2d8 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110d6ac:	d0a05317 	ldw	r2,-32436(gp)
8110d6b0:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110d6b4:	d0a05317 	ldw	r2,-32436(gp)
8110d6b8:	10800003 	ldbu	r2,0(r2)
8110d6bc:	10803fcc 	andi	r2,r2,255
8110d6c0:	1085883a 	add	r2,r2,r2
8110d6c4:	1087883a 	add	r3,r2,r2
8110d6c8:	d0a05b04 	addi	r2,gp,-32404
8110d6cc:	1885883a 	add	r2,r3,r2
8110d6d0:	10800017 	ldw	r2,0(r2)
8110d6d4:	1009883a 	mov	r4,r2
8110d6d8:	113a7380 	call	8113a738 <OSQFlush>
8110d6dc:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d6e0:	e0bffd03 	ldbu	r2,-12(fp)
8110d6e4:	10803fcc 	andi	r2,r2,255
8110d6e8:	10000126 	beq	r2,zero,8110d6f0 <vFeeTask+0x4b0>
					vFailFlushNFEEQueue();
8110d6ec:	111a4580 	call	8111a458 <vFailFlushNFEEQueue>
				}

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d6f0:	d0a05317 	ldw	r2,-32436(gp)
8110d6f4:	10804304 	addi	r2,r2,268
8110d6f8:	1009883a 	mov	r4,r2
8110d6fc:	1107cbc0 	call	81107cbc <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110d700:	d0a05317 	ldw	r2,-32436(gp)
8110d704:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d708:	d0a05317 	ldw	r2,-32436(gp)
8110d70c:	10804304 	addi	r2,r2,268
8110d710:	1009883a 	mov	r4,r2
8110d714:	11079d00 	call	811079d0 <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110d718:	d0e06117 	ldw	r3,-32380(gp)
8110d71c:	d0a05317 	ldw	r2,-32436(gp)
8110d720:	10800003 	ldbu	r2,0(r2)
8110d724:	10803fcc 	andi	r2,r2,255
8110d728:	100d883a 	mov	r6,r2
8110d72c:	01604574 	movhi	r5,33045
8110d730:	29649a04 	addi	r5,r5,-28056
8110d734:	1809883a 	mov	r4,r3
8110d738:	111d6140 	call	8111d614 <fprintf>
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110d73c:	d0a05317 	ldw	r2,-32436(gp)
8110d740:	1009883a 	mov	r4,r2
8110d744:	111aa240 	call	8111aa24 <vResetMemCCDFEE>

				pxNFee->xControl.bSimulating = TRUE;
8110d748:	d0a05317 	ldw	r2,-32436(gp)
8110d74c:	00c00044 	movi	r3,1
8110d750:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110d754:	d0a05317 	ldw	r2,-32436(gp)
8110d758:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110d75c:	d0a05317 	ldw	r2,-32436(gp)
8110d760:	00c00044 	movi	r3,1
8110d764:	10c02115 	stw	r3,132(r2)

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110d768:	d0a05317 	ldw	r2,-32436(gp)
8110d76c:	10803b04 	addi	r2,r2,236
8110d770:	1009883a 	mov	r4,r2
8110d774:	110f1d00 	call	8110f1d0 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110d778:	d0a05317 	ldw	r2,-32436(gp)
8110d77c:	10c04304 	addi	r3,r2,268
8110d780:	d0a05317 	ldw	r2,-32436(gp)
8110d784:	10800003 	ldbu	r2,0(r2)
8110d788:	10803fcc 	andi	r2,r2,255
8110d78c:	100b883a 	mov	r5,r2
8110d790:	1809883a 	mov	r4,r3
8110d794:	110f0180 	call	8110f018 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110d798:	d0a05317 	ldw	r2,-32436(gp)
8110d79c:	10808904 	addi	r2,r2,548
8110d7a0:	1009883a 	mov	r4,r2
8110d7a4:	110f0ec0 	call	8110f0ec <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110d7a8:	d0a05317 	ldw	r2,-32436(gp)
8110d7ac:	00c00044 	movi	r3,1
8110d7b0:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bWatingSync = TRUE;
8110d7b4:	d0a05317 	ldw	r2,-32436(gp)
8110d7b8:	00c00044 	movi	r3,1
8110d7bc:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110d7c0:	d0a05317 	ldw	r2,-32436(gp)
8110d7c4:	00c000c4 	movi	r3,3
8110d7c8:	10c02c15 	stw	r3,176(r2)
				break;
8110d7cc:	0002cf06 	br	8110e30c <vFeeTask+0x10cc>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d7d0:	d0a05317 	ldw	r2,-32436(gp)
8110d7d4:	10800003 	ldbu	r2,0(r2)
8110d7d8:	10803fcc 	andi	r2,r2,255
8110d7dc:	1085883a 	add	r2,r2,r2
8110d7e0:	1087883a 	add	r3,r2,r2
8110d7e4:	d0a06904 	addi	r2,gp,-32348
8110d7e8:	1885883a 	add	r2,r3,r2
8110d7ec:	10800017 	ldw	r2,0(r2)
8110d7f0:	e0fffd04 	addi	r3,fp,-12
8110d7f4:	180d883a 	mov	r6,r3
8110d7f8:	000b883a 	mov	r5,zero
8110d7fc:	1009883a 	mov	r4,r2
8110d800:	113a7f80 	call	8113a7f8 <OSQPend>
8110d804:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d808:	e0bffd03 	ldbu	r2,-12(fp)
8110d80c:	10803fcc 	andi	r2,r2,255
8110d810:	1000061e 	bne	r2,zero,8110d82c <vFeeTask+0x5ec>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110d814:	d0a05317 	ldw	r2,-32436(gp)
8110d818:	e0fffe17 	ldw	r3,-8(fp)
8110d81c:	180b883a 	mov	r5,r3
8110d820:	1009883a 	mov	r4,r2
8110d824:	110e4c00 	call	8110e4c0 <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d828:	0002b806 	br	8110e30c <vFeeTask+0x10cc>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110d82c:	d0e06117 	ldw	r3,-32380(gp)
8110d830:	d0a05317 	ldw	r2,-32436(gp)
8110d834:	10800003 	ldbu	r2,0(r2)
8110d838:	10803fcc 	andi	r2,r2,255
8110d83c:	100d883a 	mov	r6,r2
8110d840:	01604574 	movhi	r5,33045
8110d844:	29648e04 	addi	r5,r5,-28104
8110d848:	1809883a 	mov	r4,r3
8110d84c:	111d6140 	call	8111d614 <fprintf>
					#endif
				}

				break;
8110d850:	0002ae06 	br	8110e30c <vFeeTask+0x10cc>


			case sSIMTestFullPattern:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110d854:	d0a05317 	ldw	r2,-32436(gp)
8110d858:	10800003 	ldbu	r2,0(r2)
8110d85c:	10803fcc 	andi	r2,r2,255
8110d860:	1085883a 	add	r2,r2,r2
8110d864:	1087883a 	add	r3,r2,r2
8110d868:	d0a05b04 	addi	r2,gp,-32404
8110d86c:	1885883a 	add	r2,r3,r2
8110d870:	10800017 	ldw	r2,0(r2)
8110d874:	1009883a 	mov	r4,r2
8110d878:	113a7380 	call	8113a738 <OSQFlush>
8110d87c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d880:	e0bffd03 	ldbu	r2,-12(fp)
8110d884:	10803fcc 	andi	r2,r2,255
8110d888:	10000126 	beq	r2,zero,8110d890 <vFeeTask+0x650>
					vFailFlushNFEEQueue();
8110d88c:	111a4580 	call	8111a458 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110d890:	d0a05317 	ldw	r2,-32436(gp)
8110d894:	00c00044 	movi	r3,1
8110d898:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110d89c:	d0a05317 	ldw	r2,-32436(gp)
8110d8a0:	00c00044 	movi	r3,1
8110d8a4:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110d8a8:	d0a05317 	ldw	r2,-32436(gp)
8110d8ac:	1009883a 	mov	r4,r2
8110d8b0:	111aa240 	call	8111aa24 <vResetMemCCDFEE>

				bFeebCh1SetBufferSize(SDMA_MAX_BLOCKS,0);
8110d8b4:	000b883a 	mov	r5,zero
8110d8b8:	01000404 	movi	r4,16
8110d8bc:	11058100 	call	81105810 <bFeebCh1SetBufferSize>
				bFeebCh1SetBufferSize(SDMA_MAX_BLOCKS,1);
8110d8c0:	01400044 	movi	r5,1
8110d8c4:	01000404 	movi	r4,16
8110d8c8:	11058100 	call	81105810 <bFeebCh1SetBufferSize>

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110d8cc:	d0a05317 	ldw	r2,-32436(gp)
8110d8d0:	10803b04 	addi	r2,r2,236
8110d8d4:	1009883a 	mov	r4,r2
8110d8d8:	110f14c0 	call	8110f14c <bEnableDbBuffer>


				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110d8dc:	d0a05317 	ldw	r2,-32436(gp)
8110d8e0:	10808904 	addi	r2,r2,548
8110d8e4:	1009883a 	mov	r4,r2
8110d8e8:	1109cc80 	call	81109cc8 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110d8ec:	d0a05317 	ldw	r2,-32436(gp)
8110d8f0:	10809543 	ldbu	r2,597(r2)
8110d8f4:	10803fcc 	andi	r2,r2,255
8110d8f8:	d0a05415 	stw	r2,-32432(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110d8fc:	d0a05417 	ldw	r2,-32432(gp)
8110d900:	10800044 	addi	r2,r2,1
8110d904:	108000cc 	andi	r2,r2,3
8110d908:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110d90c:	e0bffc17 	ldw	r2,-16(fp)
8110d910:	10000f1e 	bne	r2,zero,8110d950 <vFeeTask+0x710>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110d914:	d0a05317 	ldw	r2,-32436(gp)
8110d918:	10802917 	ldw	r2,164(r2)
8110d91c:	10800003 	ldbu	r2,0(r2)
8110d920:	10803fcc 	andi	r2,r2,255
8110d924:	10c00044 	addi	r3,r2,1
8110d928:	00a00034 	movhi	r2,32768
8110d92c:	10800044 	addi	r2,r2,1
8110d930:	1884703a 	and	r2,r3,r2
8110d934:	1000040e 	bge	r2,zero,8110d948 <vFeeTask+0x708>
8110d938:	10bfffc4 	addi	r2,r2,-1
8110d93c:	00ffff84 	movi	r3,-2
8110d940:	10c4b03a 	or	r2,r2,r3
8110d944:	10800044 	addi	r2,r2,1
8110d948:	e0bff605 	stb	r2,-40(fp)
8110d94c:	00000406 	br	8110d960 <vFeeTask+0x720>
				} else {
					ucMemUsing = (unsigned char) *pxNFee->xControl.pActualMem ; /* Select the of the data control (te future)*/
8110d950:	d0a05317 	ldw	r2,-32436(gp)
8110d954:	10802917 	ldw	r2,164(r2)
8110d958:	10800003 	ldbu	r2,0(r2)
8110d95c:	e0bff605 	stb	r2,-40(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110d960:	d0e05317 	ldw	r3,-32436(gp)
8110d964:	e0bffc17 	ldw	r2,-16(fp)
8110d968:	1885883a 	add	r2,r3,r2
8110d96c:	10802a44 	addi	r2,r2,169
8110d970:	10800003 	ldbu	r2,0(r2)
8110d974:	e0bff805 	stb	r2,-32(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110d978:	d0a05317 	ldw	r2,-32436(gp)
8110d97c:	10802e17 	ldw	r2,184(r2)
8110d980:	1000071e 	bne	r2,zero,8110d9a0 <vFeeTask+0x760>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110d984:	d0e05317 	ldw	r3,-32436(gp)
8110d988:	e0bff803 	ldbu	r2,-32(fp)
8110d98c:	10800624 	muli	r2,r2,24
8110d990:	10800904 	addi	r2,r2,36
8110d994:	1885883a 	add	r2,r3,r2
8110d998:	e0bff715 	stw	r2,-36(fp)
8110d99c:	00000606 	br	8110d9b8 <vFeeTask+0x778>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110d9a0:	d0e05317 	ldw	r3,-32436(gp)
8110d9a4:	e0bff803 	ldbu	r2,-32(fp)
8110d9a8:	10800624 	muli	r2,r2,24
8110d9ac:	10800c04 	addi	r2,r2,48
8110d9b0:	1885883a 	add	r2,r3,r2
8110d9b4:	e0bff715 	stw	r2,-36(fp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110d9b8:	d0a05317 	ldw	r2,-32436(gp)
8110d9bc:	10803304 	addi	r2,r2,204
8110d9c0:	1009883a 	mov	r4,r2
8110d9c4:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110d9c8:	d0a05317 	ldw	r2,-32436(gp)
8110d9cc:	e0fff803 	ldbu	r3,-32(fp)
8110d9d0:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110d9d4:	d0a05317 	ldw	r2,-32436(gp)
8110d9d8:	00c00044 	movi	r3,1
8110d9dc:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110d9e0:	d0a05317 	ldw	r2,-32436(gp)
8110d9e4:	10803304 	addi	r2,r2,204
8110d9e8:	1009883a 	mov	r4,r2
8110d9ec:	110479c0 	call	8110479c <bDpktSetPacketConfig>


				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110d9f0:	d0a05317 	ldw	r2,-32436(gp)
8110d9f4:	10800003 	ldbu	r2,0(r2)
8110d9f8:	10803fcc 	andi	r2,r2,255
8110d9fc:	100d883a 	mov	r6,r2
8110da00:	000b883a 	mov	r5,zero
8110da04:	01002004 	movi	r4,128
8110da08:	110f2340 	call	8110f234 <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110da0c:	e03ff915 	stw	zero,-28(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110da10:	d0a05317 	ldw	r2,-32436(gp)
8110da14:	10800003 	ldbu	r2,0(r2)
8110da18:	10803fcc 	andi	r2,r2,255
8110da1c:	1085883a 	add	r2,r2,r2
8110da20:	1087883a 	add	r3,r2,r2
8110da24:	d0a06904 	addi	r2,gp,-32348
8110da28:	1885883a 	add	r2,r3,r2
8110da2c:	10800017 	ldw	r2,0(r2)
8110da30:	e0fffd04 	addi	r3,fp,-12
8110da34:	180d883a 	mov	r6,r3
8110da38:	000b883a 	mov	r5,zero
8110da3c:	1009883a 	mov	r4,r2
8110da40:	113a7f80 	call	8113a7f8 <OSQPend>
8110da44:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110da48:	e0bffd03 	ldbu	r2,-12(fp)
8110da4c:	10803fcc 	andi	r2,r2,255
8110da50:	1000cd1e 	bne	r2,zero,8110dd88 <vFeeTask+0xb48>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110da54:	e0bffe83 	ldbu	r2,-6(fp)
8110da58:	10803fcc 	andi	r2,r2,255
8110da5c:	108023d8 	cmpnei	r2,r2,143
8110da60:	1000c31e 	bne	r2,zero,8110dd70 <vFeeTask+0xb30>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110da64:	e0fff603 	ldbu	r3,-40(fp)
8110da68:	00a045b4 	movhi	r2,33046
8110da6c:	10bf9d04 	addi	r2,r2,-396
8110da70:	180690fa 	slli	r3,r3,3
8110da74:	10c5883a 	add	r2,r2,r3
8110da78:	10800017 	ldw	r2,0(r2)
8110da7c:	e0fffd04 	addi	r3,fp,-12
8110da80:	180d883a 	mov	r6,r3
8110da84:	000b883a 	mov	r5,zero
8110da88:	1009883a 	mov	r4,r2
8110da8c:	11396e40 	call	811396e4 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110da90:	e0bffd03 	ldbu	r2,-12(fp)
8110da94:	10803fcc 	andi	r2,r2,255
8110da98:	1002171e 	bne	r2,zero,8110e2f8 <vFeeTask+0x10b8>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110da9c:	d0a05317 	ldw	r2,-32436(gp)
8110daa0:	00c00044 	movi	r3,1
8110daa4:	10c02215 	stw	r3,136(r2)

							if (  ucMemUsing == 0  ) {
8110daa8:	e0bff603 	ldbu	r2,-40(fp)
8110daac:	1000471e 	bne	r2,zero,8110dbcc <vFeeTask+0x98c>
								/* Initializing the addr */
								xCcdMapLocal->ulBlockI = 0;
8110dab0:	e0bff717 	ldw	r2,-36(fp)
8110dab4:	10000115 	stw	zero,4(r2)
								xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110dab8:	e0bff717 	ldw	r2,-36(fp)
8110dabc:	10c00017 	ldw	r3,0(r2)
8110dac0:	e0bff717 	ldw	r2,-36(fp)
8110dac4:	10c00215 	stw	r3,8(r2)
								bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110dac8:	e0bff717 	ldw	r2,-36(fp)
8110dacc:	10800217 	ldw	r2,8(r2)
8110dad0:	1009883a 	mov	r4,r2
8110dad4:	d0a05317 	ldw	r2,-32436(gp)
8110dad8:	10802e17 	ldw	r2,184(r2)
8110dadc:	10c03fcc 	andi	r3,r2,255
8110dae0:	d0a05317 	ldw	r2,-32436(gp)
8110dae4:	10800003 	ldbu	r2,0(r2)
8110dae8:	10803fcc 	andi	r2,r2,255
8110daec:	100f883a 	mov	r7,r2
8110daf0:	180d883a 	mov	r6,r3
8110daf4:	01400404 	movi	r5,16
8110daf8:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110dafc:	e0bff915 	stw	r2,-28(fp)
								if ( bDmaReturn == TRUE ) {
8110db00:	e0bff917 	ldw	r2,-28(fp)
8110db04:	10800058 	cmpnei	r2,r2,1
8110db08:	1000251e 	bne	r2,zero,8110dba0 <vFeeTask+0x960>
									//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110db0c:	e0bff717 	ldw	r2,-36(fp)
8110db10:	10800217 	ldw	r2,8(r2)
8110db14:	10c22004 	addi	r3,r2,2176
8110db18:	e0bff717 	ldw	r2,-36(fp)
8110db1c:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110db20:	e0bff717 	ldw	r2,-36(fp)
8110db24:	10800117 	ldw	r2,4(r2)
8110db28:	10c00404 	addi	r3,r2,16
8110db2c:	e0bff717 	ldw	r2,-36(fp)
8110db30:	10c00115 	stw	r3,4(r2)
									bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110db34:	e0bff717 	ldw	r2,-36(fp)
8110db38:	10800217 	ldw	r2,8(r2)
8110db3c:	1009883a 	mov	r4,r2
8110db40:	d0a05317 	ldw	r2,-32436(gp)
8110db44:	10802e17 	ldw	r2,184(r2)
8110db48:	10c03fcc 	andi	r3,r2,255
8110db4c:	d0a05317 	ldw	r2,-32436(gp)
8110db50:	10800003 	ldbu	r2,0(r2)
8110db54:	10803fcc 	andi	r2,r2,255
8110db58:	100f883a 	mov	r7,r2
8110db5c:	180d883a 	mov	r6,r3
8110db60:	01400404 	movi	r5,16
8110db64:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110db68:	e0bff915 	stw	r2,-28(fp)
									if ( bDmaReturn == TRUE ) {
8110db6c:	e0bff917 	ldw	r2,-28(fp)
8110db70:	10800058 	cmpnei	r2,r2,1
8110db74:	10000a1e 	bne	r2,zero,8110dba0 <vFeeTask+0x960>
										//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
										xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110db78:	e0bff717 	ldw	r2,-36(fp)
8110db7c:	10800217 	ldw	r2,8(r2)
8110db80:	10c22004 	addi	r3,r2,2176
8110db84:	e0bff717 	ldw	r2,-36(fp)
8110db88:	10c00215 	stw	r3,8(r2)
										xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110db8c:	e0bff717 	ldw	r2,-36(fp)
8110db90:	10800117 	ldw	r2,4(r2)
8110db94:	10c00404 	addi	r3,r2,16
8110db98:	e0bff717 	ldw	r2,-36(fp)
8110db9c:	10c00115 	stw	r3,4(r2)

									}
								}
								OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110dba0:	e0fff603 	ldbu	r3,-40(fp)
8110dba4:	00a045b4 	movhi	r2,33046
8110dba8:	10bf9d04 	addi	r2,r2,-396
8110dbac:	180690fa 	slli	r3,r3,3
8110dbb0:	10c5883a 	add	r2,r2,r3
8110dbb4:	10800017 	ldw	r2,0(r2)
8110dbb8:	1009883a 	mov	r4,r2
8110dbbc:	1139c880 	call	81139c88 <OSMutexPost>
								pxNFee->xControl.bDMALocked = FALSE;
8110dbc0:	d0a05317 	ldw	r2,-32436(gp)
8110dbc4:	10002215 	stw	zero,136(r2)
8110dbc8:	00004606 	br	8110dce4 <vFeeTask+0xaa4>
							} else {
								xCcdMapLocal->ulBlockI = 0;
8110dbcc:	e0bff717 	ldw	r2,-36(fp)
8110dbd0:	10000115 	stw	zero,4(r2)
								xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110dbd4:	e0bff717 	ldw	r2,-36(fp)
8110dbd8:	10c00017 	ldw	r3,0(r2)
8110dbdc:	e0bff717 	ldw	r2,-36(fp)
8110dbe0:	10c00215 	stw	r3,8(r2)
								bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110dbe4:	e0bff717 	ldw	r2,-36(fp)
8110dbe8:	10800217 	ldw	r2,8(r2)
8110dbec:	1009883a 	mov	r4,r2
8110dbf0:	d0a05317 	ldw	r2,-32436(gp)
8110dbf4:	10802e17 	ldw	r2,184(r2)
8110dbf8:	10c03fcc 	andi	r3,r2,255
8110dbfc:	d0a05317 	ldw	r2,-32436(gp)
8110dc00:	10800003 	ldbu	r2,0(r2)
8110dc04:	10803fcc 	andi	r2,r2,255
8110dc08:	100f883a 	mov	r7,r2
8110dc0c:	180d883a 	mov	r6,r3
8110dc10:	01400404 	movi	r5,16
8110dc14:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
8110dc18:	e0bff915 	stw	r2,-28(fp)
								if ( bDmaReturn == TRUE ) {
8110dc1c:	e0bff917 	ldw	r2,-28(fp)
8110dc20:	10800058 	cmpnei	r2,r2,1
8110dc24:	1000251e 	bne	r2,zero,8110dcbc <vFeeTask+0xa7c>
									//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110dc28:	e0bff717 	ldw	r2,-36(fp)
8110dc2c:	10800217 	ldw	r2,8(r2)
8110dc30:	10c22004 	addi	r3,r2,2176
8110dc34:	e0bff717 	ldw	r2,-36(fp)
8110dc38:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110dc3c:	e0bff717 	ldw	r2,-36(fp)
8110dc40:	10800117 	ldw	r2,4(r2)
8110dc44:	10c00404 	addi	r3,r2,16
8110dc48:	e0bff717 	ldw	r2,-36(fp)
8110dc4c:	10c00115 	stw	r3,4(r2)
									bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110dc50:	e0bff717 	ldw	r2,-36(fp)
8110dc54:	10800217 	ldw	r2,8(r2)
8110dc58:	1009883a 	mov	r4,r2
8110dc5c:	d0a05317 	ldw	r2,-32436(gp)
8110dc60:	10802e17 	ldw	r2,184(r2)
8110dc64:	10c03fcc 	andi	r3,r2,255
8110dc68:	d0a05317 	ldw	r2,-32436(gp)
8110dc6c:	10800003 	ldbu	r2,0(r2)
8110dc70:	10803fcc 	andi	r2,r2,255
8110dc74:	100f883a 	mov	r7,r2
8110dc78:	180d883a 	mov	r6,r3
8110dc7c:	01400404 	movi	r5,16
8110dc80:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
8110dc84:	e0bff915 	stw	r2,-28(fp)
									if ( bDmaReturn == TRUE ) {
8110dc88:	e0bff917 	ldw	r2,-28(fp)
8110dc8c:	10800058 	cmpnei	r2,r2,1
8110dc90:	10000a1e 	bne	r2,zero,8110dcbc <vFeeTask+0xa7c>
										//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
										xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110dc94:	e0bff717 	ldw	r2,-36(fp)
8110dc98:	10800217 	ldw	r2,8(r2)
8110dc9c:	10c22004 	addi	r3,r2,2176
8110dca0:	e0bff717 	ldw	r2,-36(fp)
8110dca4:	10c00215 	stw	r3,8(r2)
										xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110dca8:	e0bff717 	ldw	r2,-36(fp)
8110dcac:	10800117 	ldw	r2,4(r2)
8110dcb0:	10c00404 	addi	r3,r2,16
8110dcb4:	e0bff717 	ldw	r2,-36(fp)
8110dcb8:	10c00115 	stw	r3,4(r2)

									}
								}
								OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110dcbc:	e0fff603 	ldbu	r3,-40(fp)
8110dcc0:	00a045b4 	movhi	r2,33046
8110dcc4:	10bf9d04 	addi	r2,r2,-396
8110dcc8:	180690fa 	slli	r3,r3,3
8110dccc:	10c5883a 	add	r2,r2,r3
8110dcd0:	10800017 	ldw	r2,0(r2)
8110dcd4:	1009883a 	mov	r4,r2
8110dcd8:	1139c880 	call	81139c88 <OSMutexPost>
								pxNFee->xControl.bDMALocked = FALSE;
8110dcdc:	d0a05317 	ldw	r2,-32436(gp)
8110dce0:	10002215 	stw	zero,136(r2)
							}
	                        /* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110dce4:	d0a05317 	ldw	r2,-32436(gp)
8110dce8:	10800003 	ldbu	r2,0(r2)
8110dcec:	10803fcc 	andi	r2,r2,255
8110dcf0:	100d883a 	mov	r6,r2
8110dcf4:	000b883a 	mov	r5,zero
8110dcf8:	01002044 	movi	r4,129
8110dcfc:	110f2d80 	call	8110f2d8 <bSendGiveBackNFeeCtrl>

							if ( bDmaReturn == TRUE ) {
8110dd00:	e0bff917 	ldw	r2,-28(fp)
8110dd04:	10800058 	cmpnei	r2,r2,1
8110dd08:	1000111e 	bne	r2,zero,8110dd50 <vFeeTask+0xb10>
								if (pxNFee->xControl.bWatingSync==TRUE) {
8110dd0c:	d0a05317 	ldw	r2,-32436(gp)
8110dd10:	10802817 	ldw	r2,160(r2)
8110dd14:	10800058 	cmpnei	r2,r2,1
8110dd18:	1000071e 	bne	r2,zero,8110dd38 <vFeeTask+0xaf8>
									pxNFee->xControl.eNextMode = sToTestFullPattern;
8110dd1c:	d0a05317 	ldw	r2,-32436(gp)
8110dd20:	00c001c4 	movi	r3,7
8110dd24:	10c02d15 	stw	r3,180(r2)
									pxNFee->xControl.eMode = sFeeWaitingSync;
8110dd28:	d0a05317 	ldw	r2,-32436(gp)
8110dd2c:	00c002c4 	movi	r3,11
8110dd30:	10c02c15 	stw	r3,176(r2)
8110dd34:	00000606 	br	8110dd50 <vFeeTask+0xb10>
								} else {
									pxNFee->xControl.eNextMode = sToTestFullPattern;
8110dd38:	d0a05317 	ldw	r2,-32436(gp)
8110dd3c:	00c001c4 	movi	r3,7
8110dd40:	10c02d15 	stw	r3,180(r2)
									pxNFee->xControl.eMode = sToTestFullPattern;
8110dd44:	d0a05317 	ldw	r2,-32436(gp)
8110dd48:	00c001c4 	movi	r3,7
8110dd4c:	10c02c15 	stw	r3,176(r2)
								}
							}


							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
8110dd50:	d0a06117 	ldw	r2,-32380(gp)
8110dd54:	100f883a 	mov	r7,r2
8110dd58:	01800904 	movi	r6,36
8110dd5c:	01400044 	movi	r5,1
8110dd60:	01204574 	movhi	r4,33045
8110dd64:	2124a204 	addi	r4,r4,-28024
8110dd68:	111dcb00 	call	8111dcb0 <fwrite>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110dd6c:	00016206 	br	8110e2f8 <vFeeTask+0x10b8>
							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
							#endif							
	                    }
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110dd70:	d0a05317 	ldw	r2,-32436(gp)
8110dd74:	e0fffe17 	ldw	r3,-8(fp)
8110dd78:	180b883a 	mov	r5,r3
8110dd7c:	1009883a 	mov	r4,r2
8110dd80:	110e67c0 	call	8110e67c <vQCmdFEEinFullPattern>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110dd84:	00015c06 	br	8110e2f8 <vFeeTask+0x10b8>
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );

					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110dd88:	d0e06117 	ldw	r3,-32380(gp)
8110dd8c:	d0a05317 	ldw	r2,-32436(gp)
8110dd90:	10800003 	ldbu	r2,0(r2)
8110dd94:	10803fcc 	andi	r2,r2,255
8110dd98:	100d883a 	mov	r6,r2
8110dd9c:	01604574 	movhi	r5,33045
8110dda0:	29648e04 	addi	r5,r5,-28104
8110dda4:	1809883a 	mov	r4,r3
8110dda8:	111d6140 	call	8111d614 <fprintf>
					#endif
				}

				break;
8110ddac:	00015206 	br	8110e2f8 <vFeeTask+0x10b8>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110ddb0:	e03ffa15 	stw	zero,-24(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ddb4:	d0a05317 	ldw	r2,-32436(gp)
8110ddb8:	10804304 	addi	r2,r2,268
8110ddbc:	1009883a 	mov	r4,r2
8110ddc0:	1107cbc0 	call	81107cbc <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110ddc4:	d0a05317 	ldw	r2,-32436(gp)
8110ddc8:	00c00084 	movi	r3,2
8110ddcc:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ddd0:	d0a05317 	ldw	r2,-32436(gp)
8110ddd4:	10804304 	addi	r2,r2,268
8110ddd8:	1009883a 	mov	r4,r2
8110dddc:	11079d00 	call	811079d0 <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110dde0:	d0e06117 	ldw	r3,-32380(gp)
8110dde4:	d0a05317 	ldw	r2,-32436(gp)
8110dde8:	10800003 	ldbu	r2,0(r2)
8110ddec:	10803fcc 	andi	r2,r2,255
8110ddf0:	100d883a 	mov	r6,r2
8110ddf4:	01604574 	movhi	r5,33045
8110ddf8:	2964ac04 	addi	r5,r5,-27984
8110ddfc:	1809883a 	mov	r4,r3
8110de00:	111d6140 	call	8111d614 <fprintf>
				#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110de04:	d0a05317 	ldw	r2,-32436(gp)
8110de08:	00c00044 	movi	r3,1
8110de0c:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110de10:	d0a05317 	ldw	r2,-32436(gp)
8110de14:	00c00104 	movi	r3,4
8110de18:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sSIMTestFullPattern;
8110de1c:	d0a05317 	ldw	r2,-32436(gp)
8110de20:	00c00284 	movi	r3,10
8110de24:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110de28:	d0a05317 	ldw	r2,-32436(gp)
8110de2c:	00c00044 	movi	r3,1
8110de30:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110de34:	d0a05317 	ldw	r2,-32436(gp)
8110de38:	00c00044 	movi	r3,1
8110de3c:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110de40:	d0a05317 	ldw	r2,-32436(gp)
8110de44:	00c00044 	movi	r3,1
8110de48:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110de4c:	d0a05317 	ldw	r2,-32436(gp)
8110de50:	10800003 	ldbu	r2,0(r2)
8110de54:	10803fcc 	andi	r2,r2,255
8110de58:	100d883a 	mov	r6,r2
8110de5c:	000b883a 	mov	r5,zero
8110de60:	01002004 	movi	r4,128
8110de64:	110f2340 	call	8110f234 <bSendRequestNFeeCtrl>

				break;
8110de68:	00012806 	br	8110e30c <vFeeTask+0x10cc>


			case sFeeTestFullPattern: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110de6c:	d0a05317 	ldw	r2,-32436(gp)
8110de70:	10800003 	ldbu	r2,0(r2)
8110de74:	10803fcc 	andi	r2,r2,255
8110de78:	1085883a 	add	r2,r2,r2
8110de7c:	1087883a 	add	r3,r2,r2
8110de80:	d0a06904 	addi	r2,gp,-32348
8110de84:	1885883a 	add	r2,r3,r2
8110de88:	10800017 	ldw	r2,0(r2)
8110de8c:	e0fffd04 	addi	r3,fp,-12
8110de90:	180d883a 	mov	r6,r3
8110de94:	000b883a 	mov	r5,zero
8110de98:	1009883a 	mov	r4,r2
8110de9c:	113a7f80 	call	8113a7f8 <OSQPend>
8110dea0:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110dea4:	e0bffd03 	ldbu	r2,-12(fp)
8110dea8:	10803fcc 	andi	r2,r2,255
8110deac:	1000c91e 	bne	r2,zero,8110e1d4 <vFeeTask+0xf94>

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110deb0:	e0bffe83 	ldbu	r2,-6(fp)
8110deb4:	10803fcc 	andi	r2,r2,255
8110deb8:	108023d8 	cmpnei	r2,r2,143
8110debc:	1000b81e 	bne	r2,zero,8110e1a0 <vFeeTask+0xf60>

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110dec0:	e0fff603 	ldbu	r3,-40(fp)
8110dec4:	00a045b4 	movhi	r2,33046
8110dec8:	10bf9d04 	addi	r2,r2,-396
8110decc:	180690fa 	slli	r3,r3,3
8110ded0:	10c5883a 	add	r2,r2,r3
8110ded4:	10800017 	ldw	r2,0(r2)
8110ded8:	e0fffd04 	addi	r3,fp,-12
8110dedc:	180d883a 	mov	r6,r3
8110dee0:	000b883a 	mov	r5,zero
8110dee4:	1009883a 	mov	r4,r2
8110dee8:	11396e40 	call	811396e4 <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110deec:	e0bffd03 	ldbu	r2,-12(fp)
8110def0:	10803fcc 	andi	r2,r2,255
8110def4:	1001021e 	bne	r2,zero,8110e300 <vFeeTask+0x10c0>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110def8:	d0a05317 	ldw	r2,-32436(gp)
8110defc:	00c00044 	movi	r3,1
8110df00:	10c02215 	stw	r3,136(r2)

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI+SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110df04:	e0bff717 	ldw	r2,-36(fp)
8110df08:	10800117 	ldw	r2,4(r2)
8110df0c:	10c00404 	addi	r3,r2,16
8110df10:	d0a05317 	ldw	r2,-32436(gp)
8110df14:	10800417 	ldw	r2,16(r2)
8110df18:	18803336 	bltu	r3,r2,8110dfe8 <vFeeTask+0xda8>

									#ifdef DEBUG_ON
										//fprintf(fp,"\n    i: %u ",incrementador);
										fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu  -> Time Code Ref. used -> %hu  \n", pxNFee->ucId, ucReadout, tCodFeeTask);
8110df1c:	d0e06117 	ldw	r3,-32380(gp)
8110df20:	d0a05317 	ldw	r2,-32436(gp)
8110df24:	10800003 	ldbu	r2,0(r2)
8110df28:	11003fcc 	andi	r4,r2,255
8110df2c:	e17ff803 	ldbu	r5,-32(fp)
8110df30:	d0a05417 	ldw	r2,-32432(gp)
8110df34:	d8800015 	stw	r2,0(sp)
8110df38:	280f883a 	mov	r7,r5
8110df3c:	200d883a 	mov	r6,r4
8110df40:	01604574 	movhi	r5,33045
8110df44:	2964b604 	addi	r5,r5,-27944
8110df48:	1809883a 	mov	r4,r3
8110df4c:	111d6140 	call	8111d614 <fprintf>
										fprintf(fp,"\nTotal blocks transmited: %u ",xCcdMapLocal->ulBlockI);
8110df50:	d0e06117 	ldw	r3,-32380(gp)
8110df54:	e0bff717 	ldw	r2,-36(fp)
8110df58:	10800117 	ldw	r2,4(r2)
8110df5c:	100d883a 	mov	r6,r2
8110df60:	01604574 	movhi	r5,33045
8110df64:	2964ca04 	addi	r5,r5,-27864
8110df68:	1809883a 	mov	r4,r3
8110df6c:	111d6140 	call	8111d614 <fprintf>
									#endif

		                    		/*Define the size of the data in the double buffer (need this to create the interrupt riht)*/
		                    		bFeebCh1SetBufferSize( (pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI), 0 );
8110df70:	d0a05317 	ldw	r2,-32436(gp)
8110df74:	10800417 	ldw	r2,16(r2)
8110df78:	1007883a 	mov	r3,r2
8110df7c:	e0bff717 	ldw	r2,-36(fp)
8110df80:	10800117 	ldw	r2,4(r2)
8110df84:	1885c83a 	sub	r2,r3,r2
8110df88:	10803fcc 	andi	r2,r2,255
8110df8c:	000b883a 	mov	r5,zero
8110df90:	1009883a 	mov	r4,r2
8110df94:	11058100 	call	81105810 <bFeebCh1SetBufferSize>
		                    		bFeebCh1SetBufferSize( (pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI), 1 );
8110df98:	d0a05317 	ldw	r2,-32436(gp)
8110df9c:	10800417 	ldw	r2,16(r2)
8110dfa0:	1007883a 	mov	r3,r2
8110dfa4:	e0bff717 	ldw	r2,-36(fp)
8110dfa8:	10800117 	ldw	r2,4(r2)
8110dfac:	1885c83a 	sub	r2,r3,r2
8110dfb0:	10803fcc 	andi	r2,r2,255
8110dfb4:	01400044 	movi	r5,1
8110dfb8:	1009883a 	mov	r4,r2
8110dfbc:	11058100 	call	81105810 <bFeebCh1SetBufferSize>

		                    		usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110dfc0:	d0a05317 	ldw	r2,-32436(gp)
8110dfc4:	10800417 	ldw	r2,16(r2)
8110dfc8:	1007883a 	mov	r3,r2
8110dfcc:	e0bff717 	ldw	r2,-36(fp)
8110dfd0:	10800117 	ldw	r2,4(r2)
8110dfd4:	1885c83a 	sub	r2,r3,r2
8110dfd8:	e0bff88d 	sth	r2,-30(fp)
		                    		bFinal = TRUE;
8110dfdc:	00800044 	movi	r2,1
8110dfe0:	e0bffa15 	stw	r2,-24(fp)
8110dfe4:	00000306 	br	8110dff4 <vFeeTask+0xdb4>

		                    	} else {

		                    		bFinal = FALSE;
8110dfe8:	e03ffa15 	stw	zero,-24(fp)
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110dfec:	00800404 	movi	r2,16
8110dff0:	e0bff88d 	sth	r2,-30(fp)
		                    	}

		                    	if ( ucMemUsing == 0  ) {
8110dff4:	e0bff603 	ldbu	r2,-40(fp)
8110dff8:	1000111e 	bne	r2,zero,8110e040 <vFeeTask+0xe00>
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI, usiLengthBlocks, pxNFee->xControl.eSide, pxNFee->ucId);
8110dffc:	e0bff717 	ldw	r2,-36(fp)
8110e000:	10800217 	ldw	r2,8(r2)
8110e004:	1011883a 	mov	r8,r2
8110e008:	e0fff88b 	ldhu	r3,-30(fp)
8110e00c:	d0a05317 	ldw	r2,-32436(gp)
8110e010:	10802e17 	ldw	r2,184(r2)
8110e014:	11003fcc 	andi	r4,r2,255
8110e018:	d0a05317 	ldw	r2,-32436(gp)
8110e01c:	10800003 	ldbu	r2,0(r2)
8110e020:	10803fcc 	andi	r2,r2,255
8110e024:	100f883a 	mov	r7,r2
8110e028:	200d883a 	mov	r6,r4
8110e02c:	180b883a 	mov	r5,r3
8110e030:	4009883a 	mov	r4,r8
8110e034:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110e038:	e0bff915 	stw	r2,-28(fp)
8110e03c:	00001006 	br	8110e080 <vFeeTask+0xe40>
		                    	} else {

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI, usiLengthBlocks, pxNFee->xControl.eSide, pxNFee->ucId);
8110e040:	e0bff717 	ldw	r2,-36(fp)
8110e044:	10800217 	ldw	r2,8(r2)
8110e048:	1011883a 	mov	r8,r2
8110e04c:	e0fff88b 	ldhu	r3,-30(fp)
8110e050:	d0a05317 	ldw	r2,-32436(gp)
8110e054:	10802e17 	ldw	r2,184(r2)
8110e058:	11003fcc 	andi	r4,r2,255
8110e05c:	d0a05317 	ldw	r2,-32436(gp)
8110e060:	10800003 	ldbu	r2,0(r2)
8110e064:	10803fcc 	andi	r2,r2,255
8110e068:	100f883a 	mov	r7,r2
8110e06c:	200d883a 	mov	r6,r4
8110e070:	180b883a 	mov	r5,r3
8110e074:	4009883a 	mov	r4,r8
8110e078:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
8110e07c:	e0bff915 	stw	r2,-28(fp)
		                    	}

		                    	if ( bDmaReturn = TRUE ) {
8110e080:	00800044 	movi	r2,1
8110e084:	e0bff915 	stw	r2,-28(fp)
									/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */

									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e088:	e0bff717 	ldw	r2,-36(fp)
8110e08c:	10800217 	ldw	r2,8(r2)
8110e090:	10c22004 	addi	r3,r2,2176
8110e094:	e0bff717 	ldw	r2,-36(fp)
8110e098:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110e09c:	e0bff717 	ldw	r2,-36(fp)
8110e0a0:	10800117 	ldw	r2,4(r2)
8110e0a4:	10c00404 	addi	r3,r2,16
8110e0a8:	e0bff717 	ldw	r2,-36(fp)
8110e0ac:	10c00115 	stw	r3,4(r2)
									OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e0b0:	e0fff603 	ldbu	r3,-40(fp)
8110e0b4:	00a045b4 	movhi	r2,33046
8110e0b8:	10bf9d04 	addi	r2,r2,-396
8110e0bc:	180690fa 	slli	r3,r3,3
8110e0c0:	10c5883a 	add	r2,r2,r3
8110e0c4:	10800017 	ldw	r2,0(r2)
8110e0c8:	1009883a 	mov	r4,r2
8110e0cc:	1139c880 	call	81139c88 <OSMutexPost>
									pxNFee->xControl.bDMALocked = FALSE;
8110e0d0:	d0a05317 	ldw	r2,-32436(gp)
8110e0d4:	10002215 	stw	zero,136(r2)
									#endif
									bFinal = FALSE;
		                    	}

		                        /* Send message telling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e0d8:	d0a05317 	ldw	r2,-32436(gp)
8110e0dc:	10800003 	ldbu	r2,0(r2)
8110e0e0:	10803fcc 	andi	r2,r2,255
8110e0e4:	100d883a 	mov	r6,r2
8110e0e8:	000b883a 	mov	r5,zero
8110e0ec:	01002044 	movi	r4,129
8110e0f0:	110f2d80 	call	8110f2d8 <bSendGiveBackNFeeCtrl>

								if ( ((xCcdMapLocal->ulBlockI) % 5000 == 0) ) {
8110e0f4:	e0bff717 	ldw	r2,-36(fp)
8110e0f8:	10800117 	ldw	r2,4(r2)
8110e0fc:	00c4e204 	movi	r3,5000
8110e100:	10c7203a 	divu	r3,r2,r3
8110e104:	18c4e224 	muli	r3,r3,5000
8110e108:	10c5c83a 	sub	r2,r2,r3
8110e10c:	1000081e 	bne	r2,zero,8110e130 <vFeeTask+0xef0>

									#ifdef DEBUG_ON
										fprintf(fp,"\nblock: %u ", xCcdMapLocal->ulBlockI);
8110e110:	d0e06117 	ldw	r3,-32380(gp)
8110e114:	e0bff717 	ldw	r2,-36(fp)
8110e118:	10800117 	ldw	r2,4(r2)
8110e11c:	100d883a 	mov	r6,r2
8110e120:	01604574 	movhi	r5,33045
8110e124:	2964d204 	addi	r5,r5,-27832
8110e128:	1809883a 	mov	r4,r3
8110e12c:	111d6140 	call	8111d614 <fprintf>
									#endif
								}

								if ( bFinal == TRUE ) {
8110e130:	e0bffa17 	ldw	r2,-24(fp)
8110e134:	10800058 	cmpnei	r2,r2,1
8110e138:	1000111e 	bne	r2,zero,8110e180 <vFeeTask+0xf40>
									pxNFee->xControl.bWatingSync = TRUE;
8110e13c:	d0a05317 	ldw	r2,-32436(gp)
8110e140:	00c00044 	movi	r3,1
8110e144:	10c02815 	stw	r3,160(r2)
									if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110e148:	d0a05317 	ldw	r2,-32436(gp)
8110e14c:	10802d17 	ldw	r2,180(r2)
8110e150:	10800198 	cmpnei	r2,r2,6
8110e154:	1000041e 	bne	r2,zero,8110e168 <vFeeTask+0xf28>
										pxNFee->xControl.eMode =  sSIMTestFullPattern;
8110e158:	d0a05317 	ldw	r2,-32436(gp)
8110e15c:	00c00284 	movi	r3,10
8110e160:	10c02c15 	stw	r3,176(r2)
8110e164:	00000306 	br	8110e174 <vFeeTask+0xf34>
									} else {
										pxNFee->xControl.eMode =  sFeeWaitingSync;
8110e168:	d0a05317 	ldw	r2,-32436(gp)
8110e16c:	00c002c4 	movi	r3,11
8110e170:	10c02c15 	stw	r3,176(r2)
									}
									
									pxNFee->xControl.bUsingDMA = FALSE;
8110e174:	d0a05317 	ldw	r2,-32436(gp)
8110e178:	10002315 	stw	zero,140(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e17c:	00006006 	br	8110e300 <vFeeTask+0x10c0>
										pxNFee->xControl.eMode =  sFeeWaitingSync;
									}
									
									pxNFee->xControl.bUsingDMA = FALSE;
								} else {
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110e180:	d0a05317 	ldw	r2,-32436(gp)
8110e184:	10800003 	ldbu	r2,0(r2)
8110e188:	10803fcc 	andi	r2,r2,255
8110e18c:	100d883a 	mov	r6,r2
8110e190:	000b883a 	mov	r5,zero
8110e194:	01002004 	movi	r4,128
8110e198:	110f2340 	call	8110f234 <bSendRequestNFeeCtrl>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e19c:	00005806 	br	8110e300 <vFeeTask+0x10c0>
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
								}

		                    }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110e1a0:	d0a05317 	ldw	r2,-32436(gp)
8110e1a4:	e0fffe17 	ldw	r3,-8(fp)
8110e1a8:	180b883a 	mov	r5,r3
8110e1ac:	1009883a 	mov	r4,r2
8110e1b0:	110e67c0 	call	8110e67c <vQCmdFEEinFullPattern>

							if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110e1b4:	d0a05317 	ldw	r2,-32436(gp)
8110e1b8:	10802817 	ldw	r2,160(r2)
8110e1bc:	1000501e 	bne	r2,zero,8110e300 <vFeeTask+0x10c0>
								pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110e1c0:	d0a05317 	ldw	r2,-32436(gp)
8110e1c4:	d0e05317 	ldw	r3,-32436(gp)
8110e1c8:	18c02d17 	ldw	r3,180(r3)
8110e1cc:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e1d0:	00004b06 	br	8110e300 <vFeeTask+0x10c0>
							}
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e1d4:	d0e06117 	ldw	r3,-32380(gp)
8110e1d8:	d0a05317 	ldw	r2,-32436(gp)
8110e1dc:	10800003 	ldbu	r2,0(r2)
8110e1e0:	10803fcc 	andi	r2,r2,255
8110e1e4:	100d883a 	mov	r6,r2
8110e1e8:	01604574 	movhi	r5,33045
8110e1ec:	29648e04 	addi	r5,r5,-28104
8110e1f0:	1809883a 	mov	r4,r3
8110e1f4:	111d6140 	call	8111d614 <fprintf>
					#endif
				}

				break;
8110e1f8:	00004106 	br	8110e300 <vFeeTask+0x10c0>

			case sFeeWaitingSync:

				pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110e1fc:	d0a05317 	ldw	r2,-32436(gp)
8110e200:	d0e05317 	ldw	r3,-32436(gp)
8110e204:	18c02d17 	ldw	r3,180(r3)
8110e208:	10c02c15 	stw	r3,176(r2)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xWaitSyncQFee[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e20c:	d0a05317 	ldw	r2,-32436(gp)
8110e210:	10800003 	ldbu	r2,0(r2)
8110e214:	10803fcc 	andi	r2,r2,255
8110e218:	1085883a 	add	r2,r2,r2
8110e21c:	1087883a 	add	r3,r2,r2
8110e220:	d0a05b04 	addi	r2,gp,-32404
8110e224:	1885883a 	add	r2,r3,r2
8110e228:	10800017 	ldw	r2,0(r2)
8110e22c:	e0fffd04 	addi	r3,fp,-12
8110e230:	180d883a 	mov	r6,r3
8110e234:	000b883a 	mov	r5,zero
8110e238:	1009883a 	mov	r4,r2
8110e23c:	113a7f80 	call	8113a7f8 <OSQPend>
8110e240:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110e244:	e0bffd03 	ldbu	r2,-12(fp)
8110e248:	10803fcc 	andi	r2,r2,255
8110e24c:	10000926 	beq	r2,zero,8110e274 <vFeeTask+0x1034>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xWaitSyncQFee\n", pxNFee->ucId);
8110e250:	d0e06117 	ldw	r3,-32380(gp)
8110e254:	d0a05317 	ldw	r2,-32436(gp)
8110e258:	10800003 	ldbu	r2,0(r2)
8110e25c:	10803fcc 	andi	r2,r2,255
8110e260:	100d883a 	mov	r6,r2
8110e264:	01604574 	movhi	r5,33045
8110e268:	2964d504 	addi	r5,r5,-27820
8110e26c:	1809883a 	mov	r4,r3
8110e270:	111d6140 	call	8111d614 <fprintf>
					#endif
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e274:	d0a05317 	ldw	r2,-32436(gp)
8110e278:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e27c:	d0a05317 	ldw	r2,-32436(gp)
8110e280:	10800003 	ldbu	r2,0(r2)
8110e284:	10803fcc 	andi	r2,r2,255
8110e288:	1085883a 	add	r2,r2,r2
8110e28c:	1087883a 	add	r3,r2,r2
8110e290:	d0a05b04 	addi	r2,gp,-32404
8110e294:	1885883a 	add	r2,r3,r2
8110e298:	10800017 	ldw	r2,0(r2)
8110e29c:	1009883a 	mov	r4,r2
8110e2a0:	113a7380 	call	8113a738 <OSQFlush>
8110e2a4:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e2a8:	e0bffd03 	ldbu	r2,-12(fp)
8110e2ac:	10803fcc 	andi	r2,r2,255
8110e2b0:	10001526 	beq	r2,zero,8110e308 <vFeeTask+0x10c8>
					vFailFlushNFEEQueue();
8110e2b4:	111a4580 	call	8111a458 <vFailFlushNFEEQueue>
				}

				break;
8110e2b8:	00001306 	br	8110e308 <vFeeTask+0x10c8>
			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110e2bc:	d0a05317 	ldw	r2,-32436(gp)
8110e2c0:	00c00144 	movi	r3,5
8110e2c4:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110e2c8:	d0e06117 	ldw	r3,-32380(gp)
8110e2cc:	d0a05317 	ldw	r2,-32436(gp)
8110e2d0:	10800003 	ldbu	r2,0(r2)
8110e2d4:	10803fcc 	andi	r2,r2,255
8110e2d8:	100d883a 	mov	r6,r2
8110e2dc:	01604574 	movhi	r5,33045
8110e2e0:	2964e304 	addi	r5,r5,-27764
8110e2e4:	1809883a 	mov	r4,r3
8110e2e8:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e2ec:	00000706 	br	8110e30c <vFeeTask+0x10cc>
				break;
			case sSIMFeeStandBy:

				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
8110e2f0:	0001883a 	nop
8110e2f4:	003be806 	br	8110d298 <__reset+0xfb0ed298>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e2f8:	0001883a 	nop
8110e2fc:	003be606 	br	8110d298 <__reset+0xfb0ed298>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e300:	0001883a 	nop
8110e304:	003be406 	br	8110d298 <__reset+0xfb0ed298>
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}

				break;
8110e308:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110e30c:	003be206 	br	8110d298 <__reset+0xfb0ed298>

8110e310 <vQCmdFEEinConfig>:

}


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110e310:	defffb04 	addi	sp,sp,-20
8110e314:	de00012e 	bgeu	sp,et,8110e31c <vQCmdFEEinConfig+0xc>
8110e318:	003b68fa 	trap	3
8110e31c:	dfc00415 	stw	ra,16(sp)
8110e320:	df000315 	stw	fp,12(sp)
8110e324:	df000304 	addi	fp,sp,12
8110e328:	e13ffe15 	stw	r4,-8(fp)
8110e32c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110e330:	e0bfff17 	ldw	r2,-4(fp)
8110e334:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110e338:	e0bffdc3 	ldbu	r2,-9(fp)
8110e33c:	10c03fcc 	andi	r3,r2,255
8110e340:	e0bffe17 	ldw	r2,-8(fp)
8110e344:	10800003 	ldbu	r2,0(r2)
8110e348:	10803fcc 	andi	r2,r2,255
8110e34c:	10800444 	addi	r2,r2,17
8110e350:	1880551e 	bne	r3,r2,8110e4a8 <vQCmdFEEinConfig+0x198>

		switch (uiCmdFEEL.ucByte[2]) {
8110e354:	e0bffd83 	ldbu	r2,-10(fp)
8110e358:	10803fcc 	andi	r2,r2,255
8110e35c:	10c00220 	cmpeqi	r3,r2,8
8110e360:	1800321e 	bne	r3,zero,8110e42c <vQCmdFEEinConfig+0x11c>
8110e364:	10c00248 	cmpgei	r3,r2,9
8110e368:	1800071e 	bne	r3,zero,8110e388 <vQCmdFEEinConfig+0x78>
8110e36c:	10c000a0 	cmpeqi	r3,r2,2
8110e370:	18004c1e 	bne	r3,zero,8110e4a4 <vQCmdFEEinConfig+0x194>
8110e374:	10c00120 	cmpeqi	r3,r2,4
8110e378:	1800191e 	bne	r3,zero,8110e3e0 <vQCmdFEEinConfig+0xd0>
8110e37c:	10800060 	cmpeqi	r2,r2,1
8110e380:	10000d1e 	bne	r2,zero,8110e3b8 <vQCmdFEEinConfig+0xa8>
8110e384:	00003d06 	br	8110e47c <vQCmdFEEinConfig+0x16c>
8110e388:	10c02920 	cmpeqi	r3,r2,164
8110e38c:	18001e1e 	bne	r3,zero,8110e408 <vQCmdFEEinConfig+0xf8>
8110e390:	10c02948 	cmpgei	r3,r2,165
8110e394:	1800031e 	bne	r3,zero,8110e3a4 <vQCmdFEEinConfig+0x94>
8110e398:	10802860 	cmpeqi	r2,r2,161
8110e39c:	1000061e 	bne	r2,zero,8110e3b8 <vQCmdFEEinConfig+0xa8>
8110e3a0:	00003606 	br	8110e47c <vQCmdFEEinConfig+0x16c>
8110e3a4:	10c02a20 	cmpeqi	r3,r2,168
8110e3a8:	1800201e 	bne	r3,zero,8110e42c <vQCmdFEEinConfig+0x11c>
8110e3ac:	10803c20 	cmpeqi	r2,r2,240
8110e3b0:	1000281e 	bne	r2,zero,8110e454 <vQCmdFEEinConfig+0x144>
8110e3b4:	00003106 	br	8110e47c <vQCmdFEEinConfig+0x16c>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110e3b8:	d0e06117 	ldw	r3,-32380(gp)
8110e3bc:	e0bffe17 	ldw	r2,-8(fp)
8110e3c0:	10800003 	ldbu	r2,0(r2)
8110e3c4:	10803fcc 	andi	r2,r2,255
8110e3c8:	100d883a 	mov	r6,r2
8110e3cc:	01604574 	movhi	r5,33045
8110e3d0:	2964ee04 	addi	r5,r5,-27720
8110e3d4:	1809883a 	mov	r4,r3
8110e3d8:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e3dc:	00003206 	br	8110e4a8 <vQCmdFEEinConfig+0x198>
			case M_FEE_RUN:

				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110e3e0:	e0bffe17 	ldw	r2,-8(fp)
8110e3e4:	00c00044 	movi	r3,1
8110e3e8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110e3ec:	e0bffe17 	ldw	r2,-8(fp)
8110e3f0:	00c002c4 	movi	r3,11
8110e3f4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110e3f8:	e0bffe17 	ldw	r2,-8(fp)
8110e3fc:	00c00184 	movi	r3,6
8110e400:	10c02d15 	stw	r3,180(r2)
				break;
8110e404:	00002806 	br	8110e4a8 <vQCmdFEEinConfig+0x198>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110e408:	e0bffe17 	ldw	r2,-8(fp)
8110e40c:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110e410:	e0bffe17 	ldw	r2,-8(fp)
8110e414:	00c00184 	movi	r3,6
8110e418:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110e41c:	e0bffe17 	ldw	r2,-8(fp)
8110e420:	00c00184 	movi	r3,6
8110e424:	10c02d15 	stw	r3,180(r2)
				break;				
8110e428:	00001f06 	br	8110e4a8 <vQCmdFEEinConfig+0x198>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110e42c:	d0e06117 	ldw	r3,-32380(gp)
8110e430:	e0bffe17 	ldw	r2,-8(fp)
8110e434:	10800003 	ldbu	r2,0(r2)
8110e438:	10803fcc 	andi	r2,r2,255
8110e43c:	100d883a 	mov	r6,r2
8110e440:	01604574 	movhi	r5,33045
8110e444:	2964f904 	addi	r5,r5,-27676
8110e448:	1809883a 	mov	r4,r3
8110e44c:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e450:	00001506 	br	8110e4a8 <vQCmdFEEinConfig+0x198>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
8110e454:	d0e06117 	ldw	r3,-32380(gp)
8110e458:	e0bffe17 	ldw	r2,-8(fp)
8110e45c:	10800003 	ldbu	r2,0(r2)
8110e460:	10803fcc 	andi	r2,r2,255
8110e464:	100d883a 	mov	r6,r2
8110e468:	01604574 	movhi	r5,33045
8110e46c:	29650a04 	addi	r5,r5,-27608
8110e470:	1809883a 	mov	r4,r3
8110e474:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e478:	00000b06 	br	8110e4a8 <vQCmdFEEinConfig+0x198>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110e47c:	d0e06117 	ldw	r3,-32380(gp)
8110e480:	e0bffe17 	ldw	r2,-8(fp)
8110e484:	10800003 	ldbu	r2,0(r2)
8110e488:	10803fcc 	andi	r2,r2,255
8110e48c:	100d883a 	mov	r6,r2
8110e490:	01604574 	movhi	r5,33045
8110e494:	29651d04 	addi	r5,r5,-27532
8110e498:	1809883a 	mov	r4,r3
8110e49c:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e4a0:	00000106 	br	8110e4a8 <vQCmdFEEinConfig+0x198>
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
				#endif
				break;
			case M_FEE_RUN:

				break;
8110e4a4:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110e4a8:	0001883a 	nop
8110e4ac:	e037883a 	mov	sp,fp
8110e4b0:	dfc00117 	ldw	ra,4(sp)
8110e4b4:	df000017 	ldw	fp,0(sp)
8110e4b8:	dec00204 	addi	sp,sp,8
8110e4bc:	f800283a 	ret

8110e4c0 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110e4c0:	defffb04 	addi	sp,sp,-20
8110e4c4:	de00012e 	bgeu	sp,et,8110e4cc <vQCmdFEEinStandBy+0xc>
8110e4c8:	003b68fa 	trap	3
8110e4cc:	dfc00415 	stw	ra,16(sp)
8110e4d0:	df000315 	stw	fp,12(sp)
8110e4d4:	df000304 	addi	fp,sp,12
8110e4d8:	e13ffe15 	stw	r4,-8(fp)
8110e4dc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110e4e0:	e0bfff17 	ldw	r2,-4(fp)
8110e4e4:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110e4e8:	e0bffdc3 	ldbu	r2,-9(fp)
8110e4ec:	10c03fcc 	andi	r3,r2,255
8110e4f0:	e0bffe17 	ldw	r2,-8(fp)
8110e4f4:	10800003 	ldbu	r2,0(r2)
8110e4f8:	10803fcc 	andi	r2,r2,255
8110e4fc:	10800444 	addi	r2,r2,17
8110e500:	1880581e 	bne	r3,r2,8110e664 <vQCmdFEEinStandBy+0x1a4>

		switch (uiCmdFEEL.ucByte[2]) {
8110e504:	e0bffd83 	ldbu	r2,-10(fp)
8110e508:	10803fcc 	andi	r2,r2,255
8110e50c:	10c00220 	cmpeqi	r3,r2,8
8110e510:	1800321e 	bne	r3,zero,8110e5dc <vQCmdFEEinStandBy+0x11c>
8110e514:	10c00248 	cmpgei	r3,r2,9
8110e518:	1800071e 	bne	r3,zero,8110e538 <vQCmdFEEinStandBy+0x78>
8110e51c:	10c000a0 	cmpeqi	r3,r2,2
8110e520:	18004f1e 	bne	r3,zero,8110e660 <vQCmdFEEinStandBy+0x1a0>
8110e524:	10c00120 	cmpeqi	r3,r2,4
8110e528:	1800221e 	bne	r3,zero,8110e5b4 <vQCmdFEEinStandBy+0xf4>
8110e52c:	10800060 	cmpeqi	r2,r2,1
8110e530:	10000d1e 	bne	r2,zero,8110e568 <vQCmdFEEinStandBy+0xa8>
8110e534:	00004006 	br	8110e638 <vQCmdFEEinStandBy+0x178>
8110e538:	10c02920 	cmpeqi	r3,r2,164
8110e53c:	18001d1e 	bne	r3,zero,8110e5b4 <vQCmdFEEinStandBy+0xf4>
8110e540:	10c02948 	cmpgei	r3,r2,165
8110e544:	1800031e 	bne	r3,zero,8110e554 <vQCmdFEEinStandBy+0x94>
8110e548:	10802860 	cmpeqi	r2,r2,161
8110e54c:	1000101e 	bne	r2,zero,8110e590 <vQCmdFEEinStandBy+0xd0>
8110e550:	00003906 	br	8110e638 <vQCmdFEEinStandBy+0x178>
8110e554:	10c02a20 	cmpeqi	r3,r2,168
8110e558:	1800201e 	bne	r3,zero,8110e5dc <vQCmdFEEinStandBy+0x11c>
8110e55c:	10803c20 	cmpeqi	r2,r2,240
8110e560:	1000281e 	bne	r2,zero,8110e604 <vQCmdFEEinStandBy+0x144>
8110e564:	00003406 	br	8110e638 <vQCmdFEEinStandBy+0x178>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110e568:	e0bffe17 	ldw	r2,-8(fp)
8110e56c:	00c00044 	movi	r3,1
8110e570:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110e574:	e0bffe17 	ldw	r2,-8(fp)
8110e578:	00c002c4 	movi	r3,11
8110e57c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110e580:	e0bffe17 	ldw	r2,-8(fp)
8110e584:	00c00144 	movi	r3,5
8110e588:	10c02d15 	stw	r3,180(r2)
				break;
8110e58c:	00003506 	br	8110e664 <vQCmdFEEinStandBy+0x1a4>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110e590:	e0bffe17 	ldw	r2,-8(fp)
8110e594:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110e598:	e0bffe17 	ldw	r2,-8(fp)
8110e59c:	00c00144 	movi	r3,5
8110e5a0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110e5a4:	e0bffe17 	ldw	r2,-8(fp)
8110e5a8:	00c00144 	movi	r3,5
8110e5ac:	10c02d15 	stw	r3,180(r2)
				break;				
8110e5b0:	00002c06 	br	8110e664 <vQCmdFEEinStandBy+0x1a4>
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110e5b4:	d0e06117 	ldw	r3,-32380(gp)
8110e5b8:	e0bffe17 	ldw	r2,-8(fp)
8110e5bc:	10800003 	ldbu	r2,0(r2)
8110e5c0:	10803fcc 	andi	r2,r2,255
8110e5c4:	100d883a 	mov	r6,r2
8110e5c8:	01604574 	movhi	r5,33045
8110e5cc:	29652e04 	addi	r5,r5,-27464
8110e5d0:	1809883a 	mov	r4,r3
8110e5d4:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e5d8:	00002206 	br	8110e664 <vQCmdFEEinStandBy+0x1a4>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110e5dc:	e0bffe17 	ldw	r2,-8(fp)
8110e5e0:	00c00044 	movi	r3,1
8110e5e4:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sSIMTestFullPattern; /*sSIMTestFullPattern*/
8110e5e8:	e0bffe17 	ldw	r2,-8(fp)
8110e5ec:	00c00284 	movi	r3,10
8110e5f0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sSIMTestFullPattern;
8110e5f4:	e0bffe17 	ldw	r2,-8(fp)
8110e5f8:	00c00284 	movi	r3,10
8110e5fc:	10c02d15 	stw	r3,180(r2)
				break;
8110e600:	00001806 	br	8110e664 <vQCmdFEEinStandBy+0x1a4>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110e604:	d0e06117 	ldw	r3,-32380(gp)
8110e608:	e0bffe17 	ldw	r2,-8(fp)
8110e60c:	10800003 	ldbu	r2,0(r2)
8110e610:	10803fcc 	andi	r2,r2,255
8110e614:	100d883a 	mov	r6,r2
8110e618:	01604574 	movhi	r5,33045
8110e61c:	29653904 	addi	r5,r5,-27420
8110e620:	1809883a 	mov	r4,r3
8110e624:	111d6140 	call	8111d614 <fprintf>
				#endif


				/* Perform some actions, check if is a valid command for this mode of opera  */
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110e628:	e17fff17 	ldw	r5,-4(fp)
8110e62c:	e13ffe17 	ldw	r4,-8(fp)
8110e630:	110e85c0 	call	8110e85c <vQCmdFeeRMAPinStandBy>

				break;
8110e634:	00000b06 	br	8110e664 <vQCmdFEEinStandBy+0x1a4>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110e638:	d0e06117 	ldw	r3,-32380(gp)
8110e63c:	e0bffe17 	ldw	r2,-8(fp)
8110e640:	10800003 	ldbu	r2,0(r2)
8110e644:	10803fcc 	andi	r2,r2,255
8110e648:	100d883a 	mov	r6,r2
8110e64c:	01604574 	movhi	r5,33045
8110e650:	29654304 	addi	r5,r5,-27380
8110e654:	1809883a 	mov	r4,r3
8110e658:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e65c:	00000106 	br	8110e664 <vQCmdFEEinStandBy+0x1a4>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110e660:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110e664:	0001883a 	nop
8110e668:	e037883a 	mov	sp,fp
8110e66c:	dfc00117 	ldw	ra,4(sp)
8110e670:	df000017 	ldw	fp,0(sp)
8110e674:	dec00204 	addi	sp,sp,8
8110e678:	f800283a 	ret

8110e67c <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110e67c:	defffb04 	addi	sp,sp,-20
8110e680:	de00012e 	bgeu	sp,et,8110e688 <vQCmdFEEinFullPattern+0xc>
8110e684:	003b68fa 	trap	3
8110e688:	dfc00415 	stw	ra,16(sp)
8110e68c:	df000315 	stw	fp,12(sp)
8110e690:	df000304 	addi	fp,sp,12
8110e694:	e13ffe15 	stw	r4,-8(fp)
8110e698:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110e69c:	e0bfff17 	ldw	r2,-4(fp)
8110e6a0:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110e6a4:	e0bffdc3 	ldbu	r2,-9(fp)
8110e6a8:	10c03fcc 	andi	r3,r2,255
8110e6ac:	e0bffe17 	ldw	r2,-8(fp)
8110e6b0:	10800003 	ldbu	r2,0(r2)
8110e6b4:	10803fcc 	andi	r2,r2,255
8110e6b8:	10800444 	addi	r2,r2,17
8110e6bc:	1880611e 	bne	r3,r2,8110e844 <vQCmdFEEinFullPattern+0x1c8>

		switch (uiCmdFEEL.ucByte[2]) {
8110e6c0:	e0bffd83 	ldbu	r2,-10(fp)
8110e6c4:	10803fcc 	andi	r2,r2,255
8110e6c8:	10c00220 	cmpeqi	r3,r2,8
8110e6cc:	1800391e 	bne	r3,zero,8110e7b4 <vQCmdFEEinFullPattern+0x138>
8110e6d0:	10c00248 	cmpgei	r3,r2,9
8110e6d4:	1800071e 	bne	r3,zero,8110e6f4 <vQCmdFEEinFullPattern+0x78>
8110e6d8:	10c000a0 	cmpeqi	r3,r2,2
8110e6dc:	1800561e 	bne	r3,zero,8110e838 <vQCmdFEEinFullPattern+0x1bc>
8110e6e0:	10c00120 	cmpeqi	r3,r2,4
8110e6e4:	1800121e 	bne	r3,zero,8110e730 <vQCmdFEEinFullPattern+0xb4>
8110e6e8:	10800060 	cmpeqi	r2,r2,1
8110e6ec:	1000541e 	bne	r2,zero,8110e840 <vQCmdFEEinFullPattern+0x1c4>
8110e6f0:	00004706 	br	8110e810 <vQCmdFEEinFullPattern+0x194>
8110e6f4:	10c02920 	cmpeqi	r3,r2,164
8110e6f8:	1800251e 	bne	r3,zero,8110e790 <vQCmdFEEinFullPattern+0x114>
8110e6fc:	10c03c20 	cmpeqi	r3,r2,240
8110e700:	1800361e 	bne	r3,zero,8110e7dc <vQCmdFEEinFullPattern+0x160>
8110e704:	10802860 	cmpeqi	r2,r2,161
8110e708:	10004126 	beq	r2,zero,8110e810 <vQCmdFEEinFullPattern+0x194>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;*/
				break;
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110e70c:	e0bffe17 	ldw	r2,-8(fp)
8110e710:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110e714:	e0bffe17 	ldw	r2,-8(fp)
8110e718:	00c00144 	movi	r3,5
8110e71c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110e720:	e0bffe17 	ldw	r2,-8(fp)
8110e724:	00c00144 	movi	r3,5
8110e728:	10c02d15 	stw	r3,180(r2)
				break;				
8110e72c:	00004506 	br	8110e844 <vQCmdFEEinFullPattern+0x1c8>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sSIMTestFullPattern ) {
8110e730:	e0bffe17 	ldw	r2,-8(fp)
8110e734:	10802c17 	ldw	r2,176(r2)
8110e738:	10800298 	cmpnei	r2,r2,10
8110e73c:	10000a1e 	bne	r2,zero,8110e768 <vQCmdFEEinFullPattern+0xec>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110e740:	e0bffe17 	ldw	r2,-8(fp)
8110e744:	00c00044 	movi	r3,1
8110e748:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110e74c:	e0bffe17 	ldw	r2,-8(fp)
8110e750:	00c002c4 	movi	r3,11
8110e754:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110e758:	e0bffe17 	ldw	r2,-8(fp)
8110e75c:	00c00184 	movi	r3,6
8110e760:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110e764:	00003706 	br	8110e844 <vQCmdFEEinFullPattern+0x1c8>
				if ( pxNFeeP->xControl.eMode == sSIMTestFullPattern ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110e768:	e0bffe17 	ldw	r2,-8(fp)
8110e76c:	00c00044 	movi	r3,1
8110e770:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110e774:	e0bffe17 	ldw	r2,-8(fp)
8110e778:	00c00104 	movi	r3,4
8110e77c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110e780:	e0bffe17 	ldw	r2,-8(fp)
8110e784:	00c00184 	movi	r3,6
8110e788:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110e78c:	00002d06 	br	8110e844 <vQCmdFEEinFullPattern+0x1c8>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110e790:	e0bffe17 	ldw	r2,-8(fp)
8110e794:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110e798:	e0bffe17 	ldw	r2,-8(fp)
8110e79c:	00c00184 	movi	r3,6
8110e7a0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110e7a4:	e0bffe17 	ldw	r2,-8(fp)
8110e7a8:	00c00184 	movi	r3,6
8110e7ac:	10c02d15 	stw	r3,180(r2)
				break;				
8110e7b0:	00002406 	br	8110e844 <vQCmdFEEinFullPattern+0x1c8>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110e7b4:	d0e06117 	ldw	r3,-32380(gp)
8110e7b8:	e0bffe17 	ldw	r2,-8(fp)
8110e7bc:	10800003 	ldbu	r2,0(r2)
8110e7c0:	10803fcc 	andi	r2,r2,255
8110e7c4:	100d883a 	mov	r6,r2
8110e7c8:	01604574 	movhi	r5,33045
8110e7cc:	29655404 	addi	r5,r5,-27312
8110e7d0:	1809883a 	mov	r4,r3
8110e7d4:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e7d8:	00001a06 	br	8110e844 <vQCmdFEEinFullPattern+0x1c8>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110e7dc:	d0e06117 	ldw	r3,-32380(gp)
8110e7e0:	e0bffe17 	ldw	r2,-8(fp)
8110e7e4:	10800003 	ldbu	r2,0(r2)
8110e7e8:	10803fcc 	andi	r2,r2,255
8110e7ec:	100d883a 	mov	r6,r2
8110e7f0:	01604574 	movhi	r5,33045
8110e7f4:	29653904 	addi	r5,r5,-27420
8110e7f8:	1809883a 	mov	r4,r3
8110e7fc:	111d6140 	call	8111d614 <fprintf>
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110e800:	e17fff17 	ldw	r5,-4(fp)
8110e804:	e13ffe17 	ldw	r4,-8(fp)
8110e808:	110ed040 	call	8110ed04 <vQCmdFeeRMAPinFullPattern>

				break;
8110e80c:	00000d06 	br	8110e844 <vQCmdFEEinFullPattern+0x1c8>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110e810:	d0e06117 	ldw	r3,-32380(gp)
8110e814:	e0bffe17 	ldw	r2,-8(fp)
8110e818:	10800003 	ldbu	r2,0(r2)
8110e81c:	10803fcc 	andi	r2,r2,255
8110e820:	100d883a 	mov	r6,r2
8110e824:	01604574 	movhi	r5,33045
8110e828:	29651d04 	addi	r5,r5,-27532
8110e82c:	1809883a 	mov	r4,r3
8110e830:	111d6140 	call	8111d614 <fprintf>
				#endif
				break;
8110e834:	00000306 	br	8110e844 <vQCmdFEEinFullPattern+0x1c8>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110e838:	0001883a 	nop
8110e83c:	00000106 	br	8110e844 <vQCmdFEEinFullPattern+0x1c8>
		switch (uiCmdFEEL.ucByte[2]) {
			case M_FEE_CONFIG:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;*/
				break;
8110e840:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110e844:	0001883a 	nop
8110e848:	e037883a 	mov	sp,fp
8110e84c:	dfc00117 	ldw	ra,4(sp)
8110e850:	df000017 	ldw	fp,0(sp)
8110e854:	dec00204 	addi	sp,sp,8
8110e858:	f800283a 	ret

8110e85c <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110e85c:	defff704 	addi	sp,sp,-36
8110e860:	de00012e 	bgeu	sp,et,8110e868 <vQCmdFeeRMAPinStandBy+0xc>
8110e864:	003b68fa 	trap	3
8110e868:	dfc00815 	stw	ra,32(sp)
8110e86c:	df000715 	stw	fp,28(sp)
8110e870:	df000704 	addi	fp,sp,28
8110e874:	e13ffe15 	stw	r4,-8(fp)
8110e878:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received\n", pxNFeeP->ucId);
8110e87c:	d0e06117 	ldw	r3,-32380(gp)
8110e880:	e0bffe17 	ldw	r2,-8(fp)
8110e884:	10800003 	ldbu	r2,0(r2)
8110e888:	10803fcc 	andi	r2,r2,255
8110e88c:	100d883a 	mov	r6,r2
8110e890:	01604574 	movhi	r5,33045
8110e894:	29656204 	addi	r5,r5,-27256
8110e898:	1809883a 	mov	r4,r3
8110e89c:	111d6140 	call	8111d614 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110e8a0:	e0bfff17 	ldw	r2,-4(fp)
8110e8a4:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110e8a8:	e0bffd43 	ldbu	r2,-11(fp)
8110e8ac:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110e8b0:	e0bffe17 	ldw	r2,-8(fp)
8110e8b4:	10804317 	ldw	r2,268(r2)
8110e8b8:	e0fff903 	ldbu	r3,-28(fp)
8110e8bc:	180b883a 	mov	r5,r3
8110e8c0:	1009883a 	mov	r4,r2
8110e8c4:	11096340 	call	81109634 <uliRmapReadReg>
8110e8c8:	e0bffa15 	stw	r2,-24(fp)


	switch (ucADDRReg) {
8110e8cc:	e0bff903 	ldbu	r2,-28(fp)
8110e8d0:	10bff004 	addi	r2,r2,-64
8110e8d4:	10c003a8 	cmpgeui	r3,r2,14
8110e8d8:	1800f91e 	bne	r3,zero,8110ecc0 <vQCmdFeeRMAPinStandBy+0x464>
8110e8dc:	100690ba 	slli	r3,r2,2
8110e8e0:	00a04474 	movhi	r2,33041
8110e8e4:	10ba3d04 	addi	r2,r2,-5900
8110e8e8:	1885883a 	add	r2,r3,r2
8110e8ec:	10800017 	ldw	r2,0(r2)
8110e8f0:	1000683a 	jmp	r2
8110e8f4:	8110e92c 	andhi	r4,r16,17316
8110e8f8:	8110ece0 	cmpeqi	r4,r16,17331
8110e8fc:	8110e9f8 	rdprs	r4,r16,17319
8110e900:	8110eb60 	cmpeqi	r4,r16,17325
8110e904:	8110eb60 	cmpeqi	r4,r16,17325
8110e908:	8110eb60 	cmpeqi	r4,r16,17325
8110e90c:	8110eb60 	cmpeqi	r4,r16,17325
8110e910:	8110eb60 	cmpeqi	r4,r16,17325
8110e914:	8110eb60 	cmpeqi	r4,r16,17325
8110e918:	8110eb60 	cmpeqi	r4,r16,17325
8110e91c:	8110eb60 	cmpeqi	r4,r16,17325
8110e920:	8110eb60 	cmpeqi	r4,r16,17325
8110e924:	8110eb7c 	xorhi	r4,r16,17325
8110e928:	8110ec50 	cmplti	r4,r16,17329
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110e92c:	e0fffa17 	ldw	r3,-24(fp)
8110e930:	00800434 	movhi	r2,16
8110e934:	10bffc04 	addi	r2,r2,-16
8110e938:	1884703a 	and	r2,r3,r2
8110e93c:	1004d13a 	srli	r2,r2,4
8110e940:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110e944:	e0bffa17 	ldw	r2,-24(fp)
8110e948:	1004d53a 	srli	r2,r2,20
8110e94c:	e0bffc15 	stw	r2,-16(fp)

			/* upsate minha estrutura depois atualizar a do frana */

			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked;
8110e950:	e0bffb17 	ldw	r2,-20(fp)
8110e954:	1007883a 	mov	r3,r2
8110e958:	e0bffe17 	ldw	r2,-8(fp)
8110e95c:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2;
8110e960:	e0bffc17 	ldw	r2,-16(fp)
8110e964:	1007883a 	mov	r3,r2
8110e968:	e0bffe17 	ldw	r2,-8(fp)
8110e96c:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110e970:	e13ffe17 	ldw	r4,-8(fp)
8110e974:	111a6e40 	call	8111a6e4 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110e978:	e0bffe17 	ldw	r2,-8(fp)
8110e97c:	10803304 	addi	r2,r2,204
8110e980:	1009883a 	mov	r4,r2
8110e984:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFeeP->xCcdInfo.usiHalfWidth;
8110e988:	e0bffe17 	ldw	r2,-8(fp)
8110e98c:	10c0308b 	ldhu	r3,194(r2)
8110e990:	e0bffe17 	ldw	r2,-8(fp)
8110e994:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFeeP->xCcdInfo.usiHeight;
8110e998:	e0bffe17 	ldw	r2,-8(fp)
8110e99c:	10c0310b 	ldhu	r3,196(r2)
8110e9a0:	e0bffe17 	ldw	r2,-8(fp)
8110e9a4:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFeeP->xCcdInfo.usiHeight - pxNFeeP->xCcdInfo.usiOLN;
8110e9a8:	e0bffe17 	ldw	r2,-8(fp)
8110e9ac:	10c0310b 	ldhu	r3,196(r2)
8110e9b0:	e0bffe17 	ldw	r2,-8(fp)
8110e9b4:	1080300b 	ldhu	r2,192(r2)
8110e9b8:	1885c83a 	sub	r2,r3,r2
8110e9bc:	1007883a 	mov	r3,r2
8110e9c0:	e0bffe17 	ldw	r2,-8(fp)
8110e9c4:	10c0350d 	sth	r3,212(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110e9c8:	e0bffe17 	ldw	r2,-8(fp)
8110e9cc:	10803304 	addi	r2,r2,204
8110e9d0:	1009883a 	mov	r4,r2
8110e9d4:	110479c0 	call	8110479c <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp," - Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
8110e9d8:	d0a06117 	ldw	r2,-32380(gp)
8110e9dc:	e1fffc17 	ldw	r7,-16(fp)
8110e9e0:	e1bffb17 	ldw	r6,-20(fp)
8110e9e4:	01604574 	movhi	r5,33045
8110e9e8:	29656b04 	addi	r5,r5,-27220
8110e9ec:	1009883a 	mov	r4,r2
8110e9f0:	111d6140 	call	8111d614 <fprintf>
			#endif

			break;
8110e9f4:	0000bd06 	br	8110ecec <vQCmdFeeRMAPinStandBy+0x490>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110e9f8:	e0fffa17 	ldw	r3,-24(fp)
8110e9fc:	00800434 	movhi	r2,16
8110ea00:	10bffc04 	addi	r2,r2,-16
8110ea04:	1884703a 	and	r2,r3,r2
8110ea08:	1004d13a 	srli	r2,r2,4
8110ea0c:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110ea10:	e0bffe17 	ldw	r2,-8(fp)
8110ea14:	10803304 	addi	r2,r2,204
8110ea18:	1009883a 	mov	r4,r2
8110ea1c:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110ea20:	e0bffb17 	ldw	r2,-20(fp)
8110ea24:	1007883a 	mov	r3,r2
8110ea28:	e0bffe17 	ldw	r2,-8(fp)
8110ea2c:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110ea30:	e0bffe17 	ldw	r2,-8(fp)
8110ea34:	10803304 	addi	r2,r2,204
8110ea38:	1009883a 	mov	r4,r2
8110ea3c:	110479c0 	call	8110479c <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp," - Pckt Length: %u\n", ucValueMasked);
8110ea40:	d0a06117 	ldw	r2,-32380(gp)
8110ea44:	e1bffb17 	ldw	r6,-20(fp)
8110ea48:	01604574 	movhi	r5,33045
8110ea4c:	29657204 	addi	r5,r5,-27192
8110ea50:	1009883a 	mov	r4,r2
8110ea54:	111d6140 	call	8111d614 <fprintf>
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110ea58:	e0bffa17 	ldw	r2,-24(fp)
8110ea5c:	1080030c 	andi	r2,r2,12
8110ea60:	1004d0ba 	srli	r2,r2,2
8110ea64:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110ea68:	e0bffc17 	ldw	r2,-16(fp)
8110ea6c:	10c000a0 	cmpeqi	r3,r2,2
8110ea70:	18000e1e 	bne	r3,zero,8110eaac <vQCmdFeeRMAPinStandBy+0x250>
8110ea74:	10c000e0 	cmpeqi	r3,r2,3
8110ea78:	1800171e 	bne	r3,zero,8110ead8 <vQCmdFeeRMAPinStandBy+0x27c>
8110ea7c:	10800060 	cmpeqi	r2,r2,1
8110ea80:	10001e26 	beq	r2,zero,8110eafc <vQCmdFeeRMAPinStandBy+0x2a0>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110ea84:	e0bffe17 	ldw	r2,-8(fp)
8110ea88:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Left side\n");
8110ea8c:	d0a06117 	ldw	r2,-32380(gp)
8110ea90:	100f883a 	mov	r7,r2
8110ea94:	01800344 	movi	r6,13
8110ea98:	01400044 	movi	r5,1
8110ea9c:	01204574 	movhi	r4,33045
8110eaa0:	21257704 	addi	r4,r4,-27172
8110eaa4:	111dcb00 	call	8111dcb0 <fwrite>
					#endif
					break;
8110eaa8:	00002c06 	br	8110eb5c <vQCmdFeeRMAPinStandBy+0x300>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110eaac:	e0bffe17 	ldw	r2,-8(fp)
8110eab0:	00c00044 	movi	r3,1
8110eab4:	10c02e15 	stw	r3,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Right side\n");
8110eab8:	d0a06117 	ldw	r2,-32380(gp)
8110eabc:	100f883a 	mov	r7,r2
8110eac0:	01800384 	movi	r6,14
8110eac4:	01400044 	movi	r5,1
8110eac8:	01204574 	movhi	r4,33045
8110eacc:	21257b04 	addi	r4,r4,-27156
8110ead0:	111dcb00 	call	8111dcb0 <fwrite>
					#endif
					break;
8110ead4:	00002106 	br	8110eb5c <vQCmdFeeRMAPinStandBy+0x300>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110ead8:	e0bffe17 	ldw	r2,-8(fp)
8110eadc:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110eae0:	d0a06117 	ldw	r2,-32380(gp)
8110eae4:	100f883a 	mov	r7,r2
8110eae8:	01800f44 	movi	r6,61
8110eaec:	01400044 	movi	r5,1
8110eaf0:	01204574 	movhi	r4,33045
8110eaf4:	21257f04 	addi	r4,r4,-27140
8110eaf8:	111dcb00 	call	8111dcb0 <fwrite>
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110eafc:	e0bffe17 	ldw	r2,-8(fp)
8110eb00:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110eb04:	e0bffe17 	ldw	r2,-8(fp)
8110eb08:	10804304 	addi	r2,r2,268
8110eb0c:	1009883a 	mov	r4,r2
8110eb10:	1107cbc0 	call	81107cbc <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110eb14:	e0bffe17 	ldw	r2,-8(fp)
8110eb18:	10c05717 	ldw	r3,348(r2)
8110eb1c:	00bffdc4 	movi	r2,-9
8110eb20:	1886703a 	and	r3,r3,r2
8110eb24:	e0bffe17 	ldw	r2,-8(fp)
8110eb28:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110eb2c:	e0bffe17 	ldw	r2,-8(fp)
8110eb30:	10804304 	addi	r2,r2,268
8110eb34:	1009883a 	mov	r4,r2
8110eb38:	11079d00 	call	811079d0 <bRmapSetMemConfigArea>
					#ifdef DEBUG_ON
						fprintf(fp," - Switching to Left side\n");
8110eb3c:	d0a06117 	ldw	r2,-32380(gp)
8110eb40:	100f883a 	mov	r7,r2
8110eb44:	01800684 	movi	r6,26
8110eb48:	01400044 	movi	r5,1
8110eb4c:	01204574 	movhi	r4,33045
8110eb50:	21258f04 	addi	r4,r4,-27076
8110eb54:	111dcb00 	call	8111dcb0 <fwrite>
					#endif
					break;
8110eb58:	0001883a 	nop
			}


			break;
8110eb5c:	00006306 	br	8110ecec <vQCmdFeeRMAPinStandBy+0x490>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucValueMasked);
8110eb60:	d0a06117 	ldw	r2,-32380(gp)
8110eb64:	e1bffb17 	ldw	r6,-20(fp)
8110eb68:	01604574 	movhi	r5,33045
8110eb6c:	29659604 	addi	r5,r5,-27048
8110eb70:	1009883a 	mov	r4,r2
8110eb74:	111d6140 	call	8111d614 <fprintf>
			#endif
				break;
8110eb78:	00005c06 	br	8110ecec <vQCmdFeeRMAPinStandBy+0x490>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110eb7c:	e0bffa17 	ldw	r2,-24(fp)
8110eb80:	10803c0c 	andi	r2,r2,240
8110eb84:	1004d13a 	srli	r2,r2,4
8110eb88:	e0bffb15 	stw	r2,-20(fp)


			switch (ucValueMasked) {
8110eb8c:	e0bffb17 	ldw	r2,-20(fp)
8110eb90:	10c000a0 	cmpeqi	r3,r2,2
8110eb94:	18000d1e 	bne	r3,zero,8110ebcc <vQCmdFeeRMAPinStandBy+0x370>
8110eb98:	10c001a0 	cmpeqi	r3,r2,6
8110eb9c:	18001c1e 	bne	r3,zero,8110ec10 <vQCmdFeeRMAPinStandBy+0x3b4>
8110eba0:	1000231e 	bne	r2,zero,8110ec30 <vQCmdFeeRMAPinStandBy+0x3d4>
				case 0: /* Standby */

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110eba4:	d0e06117 	ldw	r3,-32380(gp)
8110eba8:	e0bffe17 	ldw	r2,-8(fp)
8110ebac:	10800003 	ldbu	r2,0(r2)
8110ebb0:	10803fcc 	andi	r2,r2,255
8110ebb4:	100d883a 	mov	r6,r2
8110ebb8:	01604574 	movhi	r5,33045
8110ebbc:	29652e04 	addi	r5,r5,-27464
8110ebc0:	1809883a 	mov	r4,r3
8110ebc4:	111d6140 	call	8111d614 <fprintf>
				#endif

					break;
8110ebc8:	00002006 	br	8110ec4c <vQCmdFeeRMAPinStandBy+0x3f0>
				case 2: /* PAttern Full image */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
8110ebcc:	d0a06117 	ldw	r2,-32380(gp)
8110ebd0:	100f883a 	mov	r7,r2
8110ebd4:	01800604 	movi	r6,24
8110ebd8:	01400044 	movi	r5,1
8110ebdc:	01204574 	movhi	r4,33045
8110ebe0:	21259f04 	addi	r4,r4,-27012
8110ebe4:	111dcb00 	call	8111dcb0 <fwrite>
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8110ebe8:	e0bffe17 	ldw	r2,-8(fp)
8110ebec:	00c00044 	movi	r3,1
8110ebf0:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sSIMTestFullPattern; /*sSIMTestFullPattern*/
8110ebf4:	e0bffe17 	ldw	r2,-8(fp)
8110ebf8:	00c00284 	movi	r3,10
8110ebfc:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sSIMTestFullPattern;
8110ec00:	e0bffe17 	ldw	r2,-8(fp)
8110ec04:	00c00284 	movi	r3,10
8110ec08:	10c02d15 	stw	r3,180(r2)

					break;
8110ec0c:	00000f06 	br	8110ec4c <vQCmdFeeRMAPinStandBy+0x3f0>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
8110ec10:	d0a06117 	ldw	r2,-32380(gp)
8110ec14:	100f883a 	mov	r7,r2
8110ec18:	018005c4 	movi	r6,23
8110ec1c:	01400044 	movi	r5,1
8110ec20:	01204574 	movhi	r4,33045
8110ec24:	2125a604 	addi	r4,r4,-26984
8110ec28:	111dcb00 	call	8111dcb0 <fwrite>
				#endif
					break;
8110ec2c:	00000706 	br	8110ec4c <vQCmdFeeRMAPinStandBy+0x3f0>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
8110ec30:	d0a06117 	ldw	r2,-32380(gp)
8110ec34:	e1bffb17 	ldw	r6,-20(fp)
8110ec38:	01604574 	movhi	r5,33045
8110ec3c:	2965ac04 	addi	r5,r5,-26960
8110ec40:	1009883a 	mov	r4,r2
8110ec44:	111d6140 	call	8111d614 <fprintf>
					#endif
					break;
8110ec48:	0001883a 	nop
			}

			break;
8110ec4c:	00002706 	br	8110ecec <vQCmdFeeRMAPinStandBy+0x490>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110ec50:	e0bffa17 	ldw	r2,-24(fp)
8110ec54:	1080010c 	andi	r2,r2,4
8110ec58:	1004d0ba 	srli	r2,r2,2
8110ec5c:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110ec60:	e0bffb17 	ldw	r2,-20(fp)
8110ec64:	10002026 	beq	r2,zero,8110ece8 <vQCmdFeeRMAPinStandBy+0x48c>
				#ifdef DEBUG_ON
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
8110ec68:	d0a06117 	ldw	r2,-32380(gp)
8110ec6c:	100f883a 	mov	r7,r2
8110ec70:	01800a04 	movi	r6,40
8110ec74:	01400044 	movi	r5,1
8110ec78:	01204574 	movhi	r4,33045
8110ec7c:	2125b404 	addi	r4,r4,-26928
8110ec80:	111dcb00 	call	8111dcb0 <fwrite>
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110ec84:	e0bffe17 	ldw	r2,-8(fp)
8110ec88:	10804304 	addi	r2,r2,268
8110ec8c:	1009883a 	mov	r4,r2
8110ec90:	1107cbc0 	call	81107cbc <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110ec94:	e0bffe17 	ldw	r2,-8(fp)
8110ec98:	10c06217 	ldw	r3,392(r2)
8110ec9c:	00bffec4 	movi	r2,-5
8110eca0:	1886703a 	and	r3,r3,r2
8110eca4:	e0bffe17 	ldw	r2,-8(fp)
8110eca8:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110ecac:	e0bffe17 	ldw	r2,-8(fp)
8110ecb0:	10804304 	addi	r2,r2,268
8110ecb4:	1009883a 	mov	r4,r2
8110ecb8:	11079d00 	call	811079d0 <bRmapSetMemConfigArea>
			}

			break;
8110ecbc:	00000a06 	br	8110ece8 <vQCmdFeeRMAPinStandBy+0x48c>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110ecc0:	d0a06117 	ldw	r2,-32380(gp)
8110ecc4:	e0fff903 	ldbu	r3,-28(fp)
8110ecc8:	180d883a 	mov	r6,r3
8110eccc:	01604574 	movhi	r5,33045
8110ecd0:	29659604 	addi	r5,r5,-27048
8110ecd4:	1009883a 	mov	r4,r2
8110ecd8:	111d6140 	call	8111d614 <fprintf>
			#endif
			break;
8110ecdc:	00000306 	br	8110ecec <vQCmdFeeRMAPinStandBy+0x490>
				fprintf(fp," - Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8110ece0:	0001883a 	nop
8110ece4:	00000106 	br	8110ecec <vQCmdFeeRMAPinStandBy+0x490>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110ece8:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110ecec:	0001883a 	nop
8110ecf0:	e037883a 	mov	sp,fp
8110ecf4:	dfc00117 	ldw	ra,4(sp)
8110ecf8:	df000017 	ldw	fp,0(sp)
8110ecfc:	dec00204 	addi	sp,sp,8
8110ed00:	f800283a 	ret

8110ed04 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110ed04:	defff804 	addi	sp,sp,-32
8110ed08:	de00012e 	bgeu	sp,et,8110ed10 <vQCmdFeeRMAPinFullPattern+0xc>
8110ed0c:	003b68fa 	trap	3
8110ed10:	dfc00715 	stw	ra,28(sp)
8110ed14:	df000615 	stw	fp,24(sp)
8110ed18:	df000604 	addi	fp,sp,24
8110ed1c:	e13ffe15 	stw	r4,-8(fp)
8110ed20:	e17fff15 	stw	r5,-4(fp)
	INT8U ucADDRReg;
	INT8U ucValueReg;
	INT32U ucValueMasked;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received\n", pxNFeeP->ucId);
8110ed24:	d0e06117 	ldw	r3,-32380(gp)
8110ed28:	e0bffe17 	ldw	r2,-8(fp)
8110ed2c:	10800003 	ldbu	r2,0(r2)
8110ed30:	10803fcc 	andi	r2,r2,255
8110ed34:	100d883a 	mov	r6,r2
8110ed38:	01604574 	movhi	r5,33045
8110ed3c:	29656204 	addi	r5,r5,-27256
8110ed40:	1809883a 	mov	r4,r3
8110ed44:	111d6140 	call	8111d614 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110ed48:	e0bfff17 	ldw	r2,-4(fp)
8110ed4c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110ed50:	e0bffd43 	ldbu	r2,-11(fp)
8110ed54:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110ed58:	e0bffe17 	ldw	r2,-8(fp)
8110ed5c:	10804317 	ldw	r2,268(r2)
8110ed60:	e0fffa03 	ldbu	r3,-24(fp)
8110ed64:	180b883a 	mov	r5,r3
8110ed68:	1009883a 	mov	r4,r2
8110ed6c:	11096340 	call	81109634 <uliRmapReadReg>
8110ed70:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8110ed74:	e0bffa03 	ldbu	r2,-24(fp)
8110ed78:	10c01320 	cmpeqi	r3,r2,76
8110ed7c:	18000f1e 	bne	r3,zero,8110edbc <vQCmdFeeRMAPinFullPattern+0xb8>
8110ed80:	10c01348 	cmpgei	r3,r2,77
8110ed84:	1800031e 	bne	r3,zero,8110ed94 <vQCmdFeeRMAPinFullPattern+0x90>
8110ed88:	10801010 	cmplti	r2,r2,64
8110ed8c:	10007e1e 	bne	r2,zero,8110ef88 <vQCmdFeeRMAPinFullPattern+0x284>
8110ed90:	00000306 	br	8110eda0 <vQCmdFeeRMAPinFullPattern+0x9c>
8110ed94:	10801360 	cmpeqi	r2,r2,77
8110ed98:	10003d1e 	bne	r2,zero,8110ee90 <vQCmdFeeRMAPinFullPattern+0x18c>
8110ed9c:	00007a06 	br	8110ef88 <vQCmdFeeRMAPinFullPattern+0x284>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucValueMasked);
8110eda0:	d0a06117 	ldw	r2,-32380(gp)
8110eda4:	e1bffb17 	ldw	r6,-20(fp)
8110eda8:	01604574 	movhi	r5,33045
8110edac:	29659604 	addi	r5,r5,-27048
8110edb0:	1009883a 	mov	r4,r2
8110edb4:	111d6140 	call	8111d614 <fprintf>
			#endif
				break;
8110edb8:	00007c06 	br	8110efac <vQCmdFeeRMAPinFullPattern+0x2a8>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110edbc:	e0bffa43 	ldbu	r2,-23(fp)
8110edc0:	1004d13a 	srli	r2,r2,4
8110edc4:	10803fcc 	andi	r2,r2,255
8110edc8:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8110edcc:	e0bffb17 	ldw	r2,-20(fp)
8110edd0:	10c000a0 	cmpeqi	r3,r2,2
8110edd4:	1800141e 	bne	r3,zero,8110ee28 <vQCmdFeeRMAPinFullPattern+0x124>
8110edd8:	10c001a0 	cmpeqi	r3,r2,6
8110eddc:	18001c1e 	bne	r3,zero,8110ee50 <vQCmdFeeRMAPinFullPattern+0x14c>
8110ede0:	1000231e 	bne	r2,zero,8110ee70 <vQCmdFeeRMAPinFullPattern+0x16c>
				case 0: /* Standby */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
8110ede4:	d0a06117 	ldw	r2,-32380(gp)
8110ede8:	100f883a 	mov	r7,r2
8110edec:	01800384 	movi	r6,14
8110edf0:	01400044 	movi	r5,1
8110edf4:	01204574 	movhi	r4,33045
8110edf8:	2125bf04 	addi	r4,r4,-26884
8110edfc:	111dcb00 	call	8111dcb0 <fwrite>
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8110ee00:	e0bffe17 	ldw	r2,-8(fp)
8110ee04:	00c00044 	movi	r3,1
8110ee08:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110ee0c:	e0bffe17 	ldw	r2,-8(fp)
8110ee10:	00c002c4 	movi	r3,11
8110ee14:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110ee18:	e0bffe17 	ldw	r2,-8(fp)
8110ee1c:	00c00184 	movi	r3,6
8110ee20:	10c02d15 	stw	r3,180(r2)

					break;
8110ee24:	00001906 	br	8110ee8c <vQCmdFeeRMAPinFullPattern+0x188>
				case 2: /* PAttern Full image */
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110ee28:	d0e06117 	ldw	r3,-32380(gp)
8110ee2c:	e0bffe17 	ldw	r2,-8(fp)
8110ee30:	10800003 	ldbu	r2,0(r2)
8110ee34:	10803fcc 	andi	r2,r2,255
8110ee38:	100d883a 	mov	r6,r2
8110ee3c:	01604574 	movhi	r5,33045
8110ee40:	29655404 	addi	r5,r5,-27312
8110ee44:	1809883a 	mov	r4,r3
8110ee48:	111d6140 	call	8111d614 <fprintf>
					#endif

					break;
8110ee4c:	00000f06 	br	8110ee8c <vQCmdFeeRMAPinFullPattern+0x188>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
8110ee50:	d0a06117 	ldw	r2,-32380(gp)
8110ee54:	100f883a 	mov	r7,r2
8110ee58:	018005c4 	movi	r6,23
8110ee5c:	01400044 	movi	r5,1
8110ee60:	01204574 	movhi	r4,33045
8110ee64:	2125a604 	addi	r4,r4,-26984
8110ee68:	111dcb00 	call	8111dcb0 <fwrite>
				#endif
					break;
8110ee6c:	00000706 	br	8110ee8c <vQCmdFeeRMAPinFullPattern+0x188>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
8110ee70:	d0a06117 	ldw	r2,-32380(gp)
8110ee74:	e1bffb17 	ldw	r6,-20(fp)
8110ee78:	01604574 	movhi	r5,33045
8110ee7c:	2965ac04 	addi	r5,r5,-26960
8110ee80:	1009883a 	mov	r4,r2
8110ee84:	111d6140 	call	8111d614 <fprintf>
					#endif
					break;
8110ee88:	0001883a 	nop
			}

			break;
8110ee8c:	00004706 	br	8110efac <vQCmdFeeRMAPinFullPattern+0x2a8>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110ee90:	e0bffa43 	ldbu	r2,-23(fp)
8110ee94:	1080010c 	andi	r2,r2,4
8110ee98:	10803fcc 	andi	r2,r2,255
8110ee9c:	1004d0ba 	srli	r2,r2,2
8110eea0:	10803fcc 	andi	r2,r2,255
8110eea4:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110eea8:	e0bffb17 	ldw	r2,-20(fp)
8110eeac:	10003e26 	beq	r2,zero,8110efa8 <vQCmdFeeRMAPinFullPattern+0x2a4>

				pxNFeeP->xControl.bWatingSync = FALSE;
8110eeb0:	e0bffe17 	ldw	r2,-8(fp)
8110eeb4:	10002815 	stw	zero,160(r2)


				if ( pxNFeeP->xControl.bWatingSync == TRUE ) {
8110eeb8:	e0bffe17 	ldw	r2,-8(fp)
8110eebc:	10802817 	ldw	r2,160(r2)
8110eec0:	10800058 	cmpnei	r2,r2,1
8110eec4:	1000211e 	bne	r2,zero,8110ef4c <vQCmdFeeRMAPinFullPattern+0x248>
					uiCmdFEEL.ucByte[3] = M_NFEE_BASE_ADDR + pxNFeeP->ucId;
8110eec8:	e0bffe17 	ldw	r2,-8(fp)
8110eecc:	10800003 	ldbu	r2,0(r2)
8110eed0:	10800444 	addi	r2,r2,17
8110eed4:	e0bffdc5 	stb	r2,-9(fp)
					uiCmdFEEL.ucByte[2] = M_SYNC;
8110eed8:	00bff844 	movi	r2,-31
8110eedc:	e0bffd85 	stb	r2,-10(fp)
					error_codel = OSQPost(xWaitSyncQFee[ pxNFeeP->ucId ], (void *)uiCmdFEEL.ulWord);
8110eee0:	e0bffe17 	ldw	r2,-8(fp)
8110eee4:	10800003 	ldbu	r2,0(r2)
8110eee8:	10803fcc 	andi	r2,r2,255
8110eeec:	1085883a 	add	r2,r2,r2
8110eef0:	1087883a 	add	r3,r2,r2
8110eef4:	d0a05b04 	addi	r2,gp,-32404
8110eef8:	1885883a 	add	r2,r3,r2
8110eefc:	10800017 	ldw	r2,0(r2)
8110ef00:	e0fffd17 	ldw	r3,-12(fp)
8110ef04:	180b883a 	mov	r5,r3
8110ef08:	1009883a 	mov	r4,r2
8110ef0c:	113ac000 	call	8113ac00 <OSQPost>
8110ef10:	e0bffc05 	stb	r2,-16(fp)
					if ( error_codel != OS_ERR_NONE ) {
8110ef14:	e0bffc03 	ldbu	r2,-16(fp)
8110ef18:	10000526 	beq	r2,zero,8110ef30 <vQCmdFeeRMAPinFullPattern+0x22c>
						vFailSendMsgSyncRMAPTRIGGER( pxNFeeP->ucId );
8110ef1c:	e0bffe17 	ldw	r2,-8(fp)
8110ef20:	10800003 	ldbu	r2,0(r2)
8110ef24:	10803fcc 	andi	r2,r2,255
8110ef28:	1009883a 	mov	r4,r2
8110ef2c:	111a23c0 	call	8111a23c <vFailSendMsgSyncRMAPTRIGGER>
					}


					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
8110ef30:	d0a06117 	ldw	r2,-32380(gp)
8110ef34:	100f883a 	mov	r7,r2
8110ef38:	01800404 	movi	r6,16
8110ef3c:	01400044 	movi	r5,1
8110ef40:	01204574 	movhi	r4,33045
8110ef44:	2125c304 	addi	r4,r4,-26868
8110ef48:	111dcb00 	call	8111dcb0 <fwrite>
					#endif
				}

				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110ef4c:	e0bffe17 	ldw	r2,-8(fp)
8110ef50:	10804304 	addi	r2,r2,268
8110ef54:	1009883a 	mov	r4,r2
8110ef58:	1107cbc0 	call	81107cbc <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110ef5c:	e0bffe17 	ldw	r2,-8(fp)
8110ef60:	10c06217 	ldw	r3,392(r2)
8110ef64:	00bffec4 	movi	r2,-5
8110ef68:	1886703a 	and	r3,r3,r2
8110ef6c:	e0bffe17 	ldw	r2,-8(fp)
8110ef70:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110ef74:	e0bffe17 	ldw	r2,-8(fp)
8110ef78:	10804304 	addi	r2,r2,268
8110ef7c:	1009883a 	mov	r4,r2
8110ef80:	11079d00 	call	811079d0 <bRmapSetMemConfigArea>
			}

			break;
8110ef84:	00000806 	br	8110efa8 <vQCmdFeeRMAPinFullPattern+0x2a4>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110ef88:	d0a06117 	ldw	r2,-32380(gp)
8110ef8c:	e0fffa03 	ldbu	r3,-24(fp)
8110ef90:	180d883a 	mov	r6,r3
8110ef94:	01604574 	movhi	r5,33045
8110ef98:	29659604 	addi	r5,r5,-27048
8110ef9c:	1009883a 	mov	r4,r2
8110efa0:	111d6140 	call	8111d614 <fprintf>
			#endif
			break;
8110efa4:	00000106 	br	8110efac <vQCmdFeeRMAPinFullPattern+0x2a8>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110efa8:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110efac:	0001883a 	nop
8110efb0:	e037883a 	mov	sp,fp
8110efb4:	dfc00117 	ldw	ra,4(sp)
8110efb8:	df000017 	ldw	fp,0(sp)
8110efbc:	dec00204 	addi	sp,sp,8
8110efc0:	f800283a 	ret

8110efc4 <bDisableRmapIRQ>:



bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
8110efc4:	defffc04 	addi	sp,sp,-16
8110efc8:	de00012e 	bgeu	sp,et,8110efd0 <bDisableRmapIRQ+0xc>
8110efcc:	003b68fa 	trap	3
8110efd0:	dfc00315 	stw	ra,12(sp)
8110efd4:	df000215 	stw	fp,8(sp)
8110efd8:	df000204 	addi	fp,sp,8
8110efdc:	e13ffe15 	stw	r4,-8(fp)
8110efe0:	2805883a 	mov	r2,r5
8110efe4:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
8110efe8:	e13ffe17 	ldw	r4,-8(fp)
8110efec:	110749c0 	call	8110749c <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8110eff0:	e0bffe17 	ldw	r2,-8(fp)
8110eff4:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110eff8:	e13ffe17 	ldw	r4,-8(fp)
8110effc:	11073f40 	call	811073f4 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110f000:	00800044 	movi	r2,1
}
8110f004:	e037883a 	mov	sp,fp
8110f008:	dfc00117 	ldw	ra,4(sp)
8110f00c:	df000017 	ldw	fp,0(sp)
8110f010:	dec00204 	addi	sp,sp,8
8110f014:	f800283a 	ret

8110f018 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
8110f018:	defffc04 	addi	sp,sp,-16
8110f01c:	de00012e 	bgeu	sp,et,8110f024 <bEnableRmapIRQ+0xc>
8110f020:	003b68fa 	trap	3
8110f024:	dfc00315 	stw	ra,12(sp)
8110f028:	df000215 	stw	fp,8(sp)
8110f02c:	df000204 	addi	fp,sp,8
8110f030:	e13ffe15 	stw	r4,-8(fp)
8110f034:	2805883a 	mov	r2,r5
8110f038:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	bRmapGetMemConfigArea(&xRmap[ucId]);
8110f03c:	e0bfff03 	ldbu	r2,-4(fp)
8110f040:	10c04624 	muli	r3,r2,280
8110f044:	00a04574 	movhi	r2,33045
8110f048:	10bfaf04 	addi	r2,r2,-324
8110f04c:	1885883a 	add	r2,r3,r2
8110f050:	1009883a 	mov	r4,r2
8110f054:	1107cbc0 	call	81107cbc <bRmapGetMemConfigArea>

	bRmapGetIrqControl(pxRmapCh);
8110f058:	e13ffe17 	ldw	r4,-8(fp)
8110f05c:	110749c0 	call	8110749c <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8110f060:	e0bffe17 	ldw	r2,-8(fp)
8110f064:	00c00044 	movi	r3,1
8110f068:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110f06c:	e13ffe17 	ldw	r4,-8(fp)
8110f070:	11073f40 	call	811073f4 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110f074:	00800044 	movi	r2,1
}
8110f078:	e037883a 	mov	sp,fp
8110f07c:	dfc00117 	ldw	ra,4(sp)
8110f080:	df000017 	ldw	fp,0(sp)
8110f084:	dec00204 	addi	sp,sp,8
8110f088:	f800283a 	ret

8110f08c <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
8110f08c:	defffd04 	addi	sp,sp,-12
8110f090:	de00012e 	bgeu	sp,et,8110f098 <bDisableSPWChannel+0xc>
8110f094:	003b68fa 	trap	3
8110f098:	dfc00215 	stw	ra,8(sp)
8110f09c:	df000115 	stw	fp,4(sp)
8110f0a0:	df000104 	addi	fp,sp,4
8110f0a4:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
8110f0a8:	e13fff17 	ldw	r4,-4(fp)
8110f0ac:	1109a200 	call	81109a20 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110f0b0:	e0bfff17 	ldw	r2,-4(fp)
8110f0b4:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
8110f0b8:	e0bfff17 	ldw	r2,-4(fp)
8110f0bc:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8110f0c0:	e0bfff17 	ldw	r2,-4(fp)
8110f0c4:	00c00044 	movi	r3,1
8110f0c8:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8110f0cc:	e13fff17 	ldw	r4,-4(fp)
8110f0d0:	11098ec0 	call	811098ec <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110f0d4:	00800044 	movi	r2,1
}
8110f0d8:	e037883a 	mov	sp,fp
8110f0dc:	dfc00117 	ldw	ra,4(sp)
8110f0e0:	df000017 	ldw	fp,0(sp)
8110f0e4:	dec00204 	addi	sp,sp,8
8110f0e8:	f800283a 	ret

8110f0ec <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
8110f0ec:	defffd04 	addi	sp,sp,-12
8110f0f0:	de00012e 	bgeu	sp,et,8110f0f8 <bEnableSPWChannel+0xc>
8110f0f4:	003b68fa 	trap	3
8110f0f8:	dfc00215 	stw	ra,8(sp)
8110f0fc:	df000115 	stw	fp,4(sp)
8110f100:	df000104 	addi	fp,sp,4
8110f104:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
8110f108:	e13fff17 	ldw	r4,-4(fp)
8110f10c:	1109a200 	call	81109a20 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110f110:	e0bfff17 	ldw	r2,-4(fp)
8110f114:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
8110f118:	e0bfff17 	ldw	r2,-4(fp)
8110f11c:	00c00044 	movi	r3,1
8110f120:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
8110f124:	e0bfff17 	ldw	r2,-4(fp)
8110f128:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
8110f12c:	e13fff17 	ldw	r4,-4(fp)
8110f130:	11098ec0 	call	811098ec <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110f134:	00800044 	movi	r2,1
}
8110f138:	e037883a 	mov	sp,fp
8110f13c:	dfc00117 	ldw	ra,4(sp)
8110f140:	df000017 	ldw	fp,0(sp)
8110f144:	dec00204 	addi	sp,sp,8
8110f148:	f800283a 	ret

8110f14c <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
8110f14c:	defffd04 	addi	sp,sp,-12
8110f150:	de00012e 	bgeu	sp,et,8110f158 <bEnableDbBuffer+0xc>
8110f154:	003b68fa 	trap	3
8110f158:	dfc00215 	stw	ra,8(sp)
8110f15c:	df000115 	stw	fp,4(sp)
8110f160:	df000104 	addi	fp,sp,4
8110f164:	e13fff15 	stw	r4,-4(fp)

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110f168:	e13fff17 	ldw	r4,-4(fp)
8110f16c:	11065800 	call	81106580 <bFeebClrCh>

	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
8110f170:	e13fff17 	ldw	r4,-4(fp)
8110f174:	11064700 	call	81106470 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
8110f178:	e13fff17 	ldw	r4,-4(fp)
8110f17c:	11063e80 	call	811063e8 <bFeebGetWindowing>
	pxFeebCh->xWindowingConfig.bMasking = TRANSPARENT;/* True= data packet;    FALSE= Transparent mode */
8110f180:	e0bfff17 	ldw	r2,-4(fp)
8110f184:	10000115 	stw	zero,4(r2)
	bFeebSetWindowing(pxFeebCh);
8110f188:	e13fff17 	ldw	r4,-4(fp)
8110f18c:	11063400 	call	81106340 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110f190:	e13fff17 	ldw	r4,-4(fp)
8110f194:	11061000 	call	81106100 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8110f198:	e0bfff17 	ldw	r2,-4(fp)
8110f19c:	00c00044 	movi	r3,1
8110f1a0:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110f1a4:	e0bfff17 	ldw	r2,-4(fp)
8110f1a8:	00c00044 	movi	r3,1
8110f1ac:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110f1b0:	e13fff17 	ldw	r4,-4(fp)
8110f1b4:	110602c0 	call	8110602c <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110f1b8:	00800044 	movi	r2,1
}
8110f1bc:	e037883a 	mov	sp,fp
8110f1c0:	dfc00117 	ldw	ra,4(sp)
8110f1c4:	df000017 	ldw	fp,0(sp)
8110f1c8:	dec00204 	addi	sp,sp,8
8110f1cc:	f800283a 	ret

8110f1d0 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8110f1d0:	defffd04 	addi	sp,sp,-12
8110f1d4:	de00012e 	bgeu	sp,et,8110f1dc <bDisAndClrDbBuffer+0xc>
8110f1d8:	003b68fa 	trap	3
8110f1dc:	dfc00215 	stw	ra,8(sp)
8110f1e0:	df000115 	stw	fp,4(sp)
8110f1e4:	df000104 	addi	fp,sp,4
8110f1e8:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110f1ec:	e13fff17 	ldw	r4,-4(fp)
8110f1f0:	11061000 	call	81106100 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8110f1f4:	e0bfff17 	ldw	r2,-4(fp)
8110f1f8:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110f1fc:	e0bfff17 	ldw	r2,-4(fp)
8110f200:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110f204:	e13fff17 	ldw	r4,-4(fp)
8110f208:	110602c0 	call	8110602c <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8110f20c:	e13fff17 	ldw	r4,-4(fp)
8110f210:	11064f80 	call	811064f8 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110f214:	e13fff17 	ldw	r4,-4(fp)
8110f218:	11065800 	call	81106580 <bFeebClrCh>

	/*todo: No treatment for now  */
	return TRUE;
8110f21c:	00800044 	movi	r2,1
}
8110f220:	e037883a 	mov	sp,fp
8110f224:	dfc00117 	ldw	ra,4(sp)
8110f228:	df000017 	ldw	fp,0(sp)
8110f22c:	dec00204 	addi	sp,sp,8
8110f230:	f800283a 	ret

8110f234 <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110f234:	defff804 	addi	sp,sp,-32
8110f238:	de00012e 	bgeu	sp,et,8110f240 <bSendRequestNFeeCtrl+0xc>
8110f23c:	003b68fa 	trap	3
8110f240:	dfc00715 	stw	ra,28(sp)
8110f244:	df000615 	stw	fp,24(sp)
8110f248:	df000604 	addi	fp,sp,24
8110f24c:	2807883a 	mov	r3,r5
8110f250:	3005883a 	mov	r2,r6
8110f254:	e13ffd05 	stb	r4,-12(fp)
8110f258:	e0fffe05 	stb	r3,-8(fp)
8110f25c:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110f260:	00800404 	movi	r2,16
8110f264:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110f268:	e0bffd03 	ldbu	r2,-12(fp)
8110f26c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110f270:	e0bffe03 	ldbu	r2,-8(fp)
8110f274:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110f278:	e0bfff03 	ldbu	r2,-4(fp)
8110f27c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110f280:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110f284:	d0a05c17 	ldw	r2,-32400(gp)
8110f288:	e0fffc17 	ldw	r3,-16(fp)
8110f28c:	180b883a 	mov	r5,r3
8110f290:	1009883a 	mov	r4,r2
8110f294:	113ac000 	call	8113ac00 <OSQPost>
8110f298:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110f29c:	e0bffb03 	ldbu	r2,-20(fp)
8110f2a0:	10000526 	beq	r2,zero,8110f2b8 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110f2a4:	e0bfff03 	ldbu	r2,-4(fp)
8110f2a8:	1009883a 	mov	r4,r2
8110f2ac:	111a0ec0 	call	8111a0ec <vFailRequestDMA>
		bSuccesL = FALSE;
8110f2b0:	e03ffa15 	stw	zero,-24(fp)
8110f2b4:	00000206 	br	8110f2c0 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110f2b8:	00800044 	movi	r2,1
8110f2bc:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110f2c0:	e0bffa17 	ldw	r2,-24(fp)
}
8110f2c4:	e037883a 	mov	sp,fp
8110f2c8:	dfc00117 	ldw	ra,4(sp)
8110f2cc:	df000017 	ldw	fp,0(sp)
8110f2d0:	dec00204 	addi	sp,sp,8
8110f2d4:	f800283a 	ret

8110f2d8 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110f2d8:	defff804 	addi	sp,sp,-32
8110f2dc:	de00012e 	bgeu	sp,et,8110f2e4 <bSendGiveBackNFeeCtrl+0xc>
8110f2e0:	003b68fa 	trap	3
8110f2e4:	dfc00715 	stw	ra,28(sp)
8110f2e8:	df000615 	stw	fp,24(sp)
8110f2ec:	df000604 	addi	fp,sp,24
8110f2f0:	2807883a 	mov	r3,r5
8110f2f4:	3005883a 	mov	r2,r6
8110f2f8:	e13ffd05 	stb	r4,-12(fp)
8110f2fc:	e0fffe05 	stb	r3,-8(fp)
8110f300:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110f304:	00800404 	movi	r2,16
8110f308:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110f30c:	e0bffd03 	ldbu	r2,-12(fp)
8110f310:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110f314:	e0bffe03 	ldbu	r2,-8(fp)
8110f318:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110f31c:	e0bfff03 	ldbu	r2,-4(fp)
8110f320:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110f324:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8110f328:	d0a06f17 	ldw	r2,-32324(gp)
8110f32c:	e0fffc17 	ldw	r3,-16(fp)
8110f330:	180b883a 	mov	r5,r3
8110f334:	1009883a 	mov	r4,r2
8110f338:	113ac000 	call	8113ac00 <OSQPost>
8110f33c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110f340:	e0bffb03 	ldbu	r2,-20(fp)
8110f344:	10000526 	beq	r2,zero,8110f35c <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110f348:	e0bfff03 	ldbu	r2,-4(fp)
8110f34c:	1009883a 	mov	r4,r2
8110f350:	111a0ec0 	call	8111a0ec <vFailRequestDMA>
		bSuccesL = FALSE;
8110f354:	e03ffa15 	stw	zero,-24(fp)
8110f358:	00000206 	br	8110f364 <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110f35c:	00800044 	movi	r2,1
8110f360:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110f364:	e0bffa17 	ldw	r2,-24(fp)
}
8110f368:	e037883a 	mov	sp,fp
8110f36c:	dfc00117 	ldw	ra,4(sp)
8110f370:	df000017 	ldw	fp,0(sp)
8110f374:	dec00204 	addi	sp,sp,8
8110f378:	f800283a 	ret

8110f37c <vPrintConsoleNFee>:




#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
8110f37c:	defffa04 	addi	sp,sp,-24
8110f380:	de00012e 	bgeu	sp,et,8110f388 <vPrintConsoleNFee+0xc>
8110f384:	003b68fa 	trap	3
8110f388:	dfc00515 	stw	ra,20(sp)
8110f38c:	df000415 	stw	fp,16(sp)
8110f390:	df000404 	addi	fp,sp,16
8110f394:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
8110f398:	e0bfff17 	ldw	r2,-4(fp)
8110f39c:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
8110f3a0:	d0e06117 	ldw	r3,-32380(gp)
8110f3a4:	e0bffe17 	ldw	r2,-8(fp)
8110f3a8:	10800003 	ldbu	r2,0(r2)
8110f3ac:	10803fcc 	andi	r2,r2,255
8110f3b0:	100d883a 	mov	r6,r2
8110f3b4:	01604574 	movhi	r5,33045
8110f3b8:	2965c804 	addi	r5,r5,-26848
8110f3bc:	1809883a 	mov	r4,r3
8110f3c0:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"\n");
8110f3c4:	d0a06117 	ldw	r2,-32380(gp)
8110f3c8:	100b883a 	mov	r5,r2
8110f3cc:	01000284 	movi	r4,10
8110f3d0:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
8110f3d4:	d0e06117 	ldw	r3,-32380(gp)
8110f3d8:	e0bffe17 	ldw	r2,-8(fp)
8110f3dc:	10800003 	ldbu	r2,0(r2)
8110f3e0:	10803fcc 	andi	r2,r2,255
8110f3e4:	100d883a 	mov	r6,r2
8110f3e8:	01604574 	movhi	r5,33045
8110f3ec:	2965dd04 	addi	r5,r5,-26764
8110f3f0:	1809883a 	mov	r4,r3
8110f3f4:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
8110f3f8:	d0e06117 	ldw	r3,-32380(gp)
8110f3fc:	e0bffe17 	ldw	r2,-8(fp)
8110f400:	10802f0b 	ldhu	r2,188(r2)
8110f404:	10bfffcc 	andi	r2,r2,65535
8110f408:	100d883a 	mov	r6,r2
8110f40c:	01604574 	movhi	r5,33045
8110f410:	2965e304 	addi	r5,r5,-26740
8110f414:	1809883a 	mov	r4,r3
8110f418:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
8110f41c:	d0e06117 	ldw	r3,-32380(gp)
8110f420:	e0bffe17 	ldw	r2,-8(fp)
8110f424:	10802f8b 	ldhu	r2,190(r2)
8110f428:	10bfffcc 	andi	r2,r2,65535
8110f42c:	100d883a 	mov	r6,r2
8110f430:	01604574 	movhi	r5,33045
8110f434:	2965e804 	addi	r5,r5,-26720
8110f438:	1809883a 	mov	r4,r3
8110f43c:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
8110f440:	d0e06117 	ldw	r3,-32380(gp)
8110f444:	e0bffe17 	ldw	r2,-8(fp)
8110f448:	1080300b 	ldhu	r2,192(r2)
8110f44c:	10bfffcc 	andi	r2,r2,65535
8110f450:	100d883a 	mov	r6,r2
8110f454:	01604574 	movhi	r5,33045
8110f458:	2965ee04 	addi	r5,r5,-26696
8110f45c:	1809883a 	mov	r4,r3
8110f460:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8110f464:	d0e06117 	ldw	r3,-32380(gp)
8110f468:	e0bffe17 	ldw	r2,-8(fp)
8110f46c:	1080308b 	ldhu	r2,194(r2)
8110f470:	10bfffcc 	andi	r2,r2,65535
8110f474:	100d883a 	mov	r6,r2
8110f478:	01604574 	movhi	r5,33045
8110f47c:	2965f204 	addi	r5,r5,-26680
8110f480:	1809883a 	mov	r4,r3
8110f484:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
8110f488:	d0e06117 	ldw	r3,-32380(gp)
8110f48c:	e0bffe17 	ldw	r2,-8(fp)
8110f490:	1080310b 	ldhu	r2,196(r2)
8110f494:	10bfffcc 	andi	r2,r2,65535
8110f498:	100d883a 	mov	r6,r2
8110f49c:	01604574 	movhi	r5,33045
8110f4a0:	2965f804 	addi	r5,r5,-26656
8110f4a4:	1809883a 	mov	r4,r3
8110f4a8:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"\n");
8110f4ac:	d0a06117 	ldw	r2,-32380(gp)
8110f4b0:	100b883a 	mov	r5,r2
8110f4b4:	01000284 	movi	r4,10
8110f4b8:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
8110f4bc:	d0e06117 	ldw	r3,-32380(gp)
8110f4c0:	e0bffe17 	ldw	r2,-8(fp)
8110f4c4:	10800003 	ldbu	r2,0(r2)
8110f4c8:	10803fcc 	andi	r2,r2,255
8110f4cc:	100d883a 	mov	r6,r2
8110f4d0:	01604574 	movhi	r5,33045
8110f4d4:	2965fd04 	addi	r5,r5,-26636
8110f4d8:	1809883a 	mov	r4,r3
8110f4dc:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
8110f4e0:	d0e06117 	ldw	r3,-32380(gp)
8110f4e4:	e0bffe17 	ldw	r2,-8(fp)
8110f4e8:	10802c17 	ldw	r2,176(r2)
8110f4ec:	100d883a 	mov	r6,r2
8110f4f0:	01604574 	movhi	r5,33045
8110f4f4:	29660304 	addi	r5,r5,-26612
8110f4f8:	1809883a 	mov	r4,r3
8110f4fc:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
8110f500:	d0e06117 	ldw	r3,-32380(gp)
8110f504:	e0bffe17 	ldw	r2,-8(fp)
8110f508:	10802117 	ldw	r2,132(r2)
8110f50c:	100d883a 	mov	r6,r2
8110f510:	01604574 	movhi	r5,33045
8110f514:	29660904 	addi	r5,r5,-26588
8110f518:	1809883a 	mov	r4,r3
8110f51c:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
8110f520:	d0e06117 	ldw	r3,-32380(gp)
8110f524:	e0bffe17 	ldw	r2,-8(fp)
8110f528:	10802317 	ldw	r2,140(r2)
8110f52c:	100d883a 	mov	r6,r2
8110f530:	01604574 	movhi	r5,33045
8110f534:	29661004 	addi	r5,r5,-26560
8110f538:	1809883a 	mov	r4,r3
8110f53c:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
8110f540:	d0e06117 	ldw	r3,-32380(gp)
8110f544:	e0bffe17 	ldw	r2,-8(fp)
8110f548:	10802417 	ldw	r2,144(r2)
8110f54c:	100d883a 	mov	r6,r2
8110f550:	01604574 	movhi	r5,33045
8110f554:	29661704 	addi	r5,r5,-26532
8110f558:	1809883a 	mov	r4,r3
8110f55c:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
8110f560:	d0e06117 	ldw	r3,-32380(gp)
8110f564:	e0bffe17 	ldw	r2,-8(fp)
8110f568:	10802517 	ldw	r2,148(r2)
8110f56c:	100d883a 	mov	r6,r2
8110f570:	01604574 	movhi	r5,33045
8110f574:	29661e04 	addi	r5,r5,-26504
8110f578:	1809883a 	mov	r4,r3
8110f57c:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
8110f580:	d0e06117 	ldw	r3,-32380(gp)
8110f584:	e0bffe17 	ldw	r2,-8(fp)
8110f588:	10802617 	ldw	r2,152(r2)
8110f58c:	100d883a 	mov	r6,r2
8110f590:	01604574 	movhi	r5,33045
8110f594:	29662504 	addi	r5,r5,-26476
8110f598:	1809883a 	mov	r4,r3
8110f59c:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
8110f5a0:	d1206117 	ldw	r4,-32380(gp)
8110f5a4:	e0bffe17 	ldw	r2,-8(fp)
8110f5a8:	10802a43 	ldbu	r2,169(r2)
8110f5ac:	11403fcc 	andi	r5,r2,255
8110f5b0:	e0bffe17 	ldw	r2,-8(fp)
8110f5b4:	10802a83 	ldbu	r2,170(r2)
8110f5b8:	11803fcc 	andi	r6,r2,255
8110f5bc:	e0bffe17 	ldw	r2,-8(fp)
8110f5c0:	10802ac3 	ldbu	r2,171(r2)
8110f5c4:	10803fcc 	andi	r2,r2,255
8110f5c8:	e0fffe17 	ldw	r3,-8(fp)
8110f5cc:	18c02b03 	ldbu	r3,172(r3)
8110f5d0:	18c03fcc 	andi	r3,r3,255
8110f5d4:	d8c00115 	stw	r3,4(sp)
8110f5d8:	d8800015 	stw	r2,0(sp)
8110f5dc:	300f883a 	mov	r7,r6
8110f5e0:	280d883a 	mov	r6,r5
8110f5e4:	01604574 	movhi	r5,33045
8110f5e8:	29662c04 	addi	r5,r5,-26448
8110f5ec:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
8110f5f0:	d0e06117 	ldw	r3,-32380(gp)
8110f5f4:	e0bffe17 	ldw	r2,-8(fp)
8110f5f8:	10802e17 	ldw	r2,184(r2)
8110f5fc:	100d883a 	mov	r6,r2
8110f600:	01604574 	movhi	r5,33045
8110f604:	29663904 	addi	r5,r5,-26396
8110f608:	1809883a 	mov	r4,r3
8110f60c:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"\n\n");
8110f610:	d0a06117 	ldw	r2,-32380(gp)
8110f614:	100f883a 	mov	r7,r2
8110f618:	01800084 	movi	r6,2
8110f61c:	01400044 	movi	r5,1
8110f620:	01204574 	movhi	r4,33045
8110f624:	21263f04 	addi	r4,r4,-26372
8110f628:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
8110f62c:	d0e06117 	ldw	r3,-32380(gp)
8110f630:	e0bffe17 	ldw	r2,-8(fp)
8110f634:	10800003 	ldbu	r2,0(r2)
8110f638:	10803fcc 	andi	r2,r2,255
8110f63c:	100d883a 	mov	r6,r2
8110f640:	01604574 	movhi	r5,33045
8110f644:	29664004 	addi	r5,r5,-26368
8110f648:	1809883a 	mov	r4,r3
8110f64c:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    General Info: \n");
8110f650:	d0a06117 	ldw	r2,-32380(gp)
8110f654:	100f883a 	mov	r7,r2
8110f658:	018004c4 	movi	r6,19
8110f65c:	01400044 	movi	r5,1
8110f660:	01204574 	movhi	r4,33045
8110f664:	21264604 	addi	r4,r4,-26344
8110f668:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
8110f66c:	d0e06117 	ldw	r3,-32380(gp)
8110f670:	e0bffe17 	ldw	r2,-8(fp)
8110f674:	10800117 	ldw	r2,4(r2)
8110f678:	100d883a 	mov	r6,r2
8110f67c:	01604574 	movhi	r5,33045
8110f680:	29664b04 	addi	r5,r5,-26324
8110f684:	1809883a 	mov	r4,r3
8110f688:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
8110f68c:	d0e06117 	ldw	r3,-32380(gp)
8110f690:	e0bffe17 	ldw	r2,-8(fp)
8110f694:	10800217 	ldw	r2,8(r2)
8110f698:	100d883a 	mov	r6,r2
8110f69c:	01604574 	movhi	r5,33045
8110f6a0:	29665304 	addi	r5,r5,-26292
8110f6a4:	1809883a 	mov	r4,r3
8110f6a8:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
8110f6ac:	d0e06117 	ldw	r3,-32380(gp)
8110f6b0:	e0bffe17 	ldw	r2,-8(fp)
8110f6b4:	10800317 	ldw	r2,12(r2)
8110f6b8:	100d883a 	mov	r6,r2
8110f6bc:	01604574 	movhi	r5,33045
8110f6c0:	29665b04 	addi	r5,r5,-26260
8110f6c4:	1809883a 	mov	r4,r3
8110f6c8:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
8110f6cc:	d0a06117 	ldw	r2,-32380(gp)
8110f6d0:	100f883a 	mov	r7,r2
8110f6d4:	01800644 	movi	r6,25
8110f6d8:	01400044 	movi	r5,1
8110f6dc:	01204574 	movhi	r4,33045
8110f6e0:	21266204 	addi	r4,r4,-26232
8110f6e4:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
8110f6e8:	d0e06117 	ldw	r3,-32380(gp)
8110f6ec:	e0bffe17 	ldw	r2,-8(fp)
8110f6f0:	10800517 	ldw	r2,20(r2)
8110f6f4:	100d883a 	mov	r6,r2
8110f6f8:	01604574 	movhi	r5,33045
8110f6fc:	29666904 	addi	r5,r5,-26204
8110f700:	1809883a 	mov	r4,r3
8110f704:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
8110f708:	d0e06117 	ldw	r3,-32380(gp)
8110f70c:	e0bffe17 	ldw	r2,-8(fp)
8110f710:	10800417 	ldw	r2,16(r2)
8110f714:	100d883a 	mov	r6,r2
8110f718:	01604574 	movhi	r5,33045
8110f71c:	29667104 	addi	r5,r5,-26172
8110f720:	1809883a 	mov	r4,r3
8110f724:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
8110f728:	d0e06117 	ldw	r3,-32380(gp)
8110f72c:	e0bffe17 	ldw	r2,-8(fp)
8110f730:	10800603 	ldbu	r2,24(r2)
8110f734:	10803fcc 	andi	r2,r2,255
8110f738:	100d883a 	mov	r6,r2
8110f73c:	01604574 	movhi	r5,33045
8110f740:	29667904 	addi	r5,r5,-26140
8110f744:	1809883a 	mov	r4,r3
8110f748:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
8110f74c:	d2206117 	ldw	r8,-32380(gp)
8110f750:	e13ffe17 	ldw	r4,-8(fp)
8110f754:	20800717 	ldw	r2,28(r4)
8110f758:	20c00817 	ldw	r3,32(r4)
8110f75c:	100d883a 	mov	r6,r2
8110f760:	180f883a 	mov	r7,r3
8110f764:	01604574 	movhi	r5,33045
8110f768:	29668104 	addi	r5,r5,-26108
8110f76c:	4009883a 	mov	r4,r8
8110f770:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"\n");
8110f774:	d0a06117 	ldw	r2,-32380(gp)
8110f778:	100b883a 	mov	r5,r2
8110f77c:	01000284 	movi	r4,10
8110f780:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8110f784:	d0e06117 	ldw	r3,-32380(gp)
8110f788:	e0bffe17 	ldw	r2,-8(fp)
8110f78c:	10800003 	ldbu	r2,0(r2)
8110f790:	10803fcc 	andi	r2,r2,255
8110f794:	100f883a 	mov	r7,r2
8110f798:	000d883a 	mov	r6,zero
8110f79c:	01604574 	movhi	r5,33045
8110f7a0:	29668904 	addi	r5,r5,-26076
8110f7a4:	1809883a 	mov	r4,r3
8110f7a8:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Left side \n");
8110f7ac:	d0a06117 	ldw	r2,-32380(gp)
8110f7b0:	100f883a 	mov	r7,r2
8110f7b4:	018004c4 	movi	r6,19
8110f7b8:	01400044 	movi	r5,1
8110f7bc:	01204574 	movhi	r4,33045
8110f7c0:	21269304 	addi	r4,r4,-26036
8110f7c4:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
8110f7c8:	d0e06117 	ldw	r3,-32380(gp)
8110f7cc:	e0bffe17 	ldw	r2,-8(fp)
8110f7d0:	10800917 	ldw	r2,36(r2)
8110f7d4:	100d883a 	mov	r6,r2
8110f7d8:	01604574 	movhi	r5,33045
8110f7dc:	29669804 	addi	r5,r5,-26016
8110f7e0:	1809883a 	mov	r4,r3
8110f7e4:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
8110f7e8:	d0e06117 	ldw	r3,-32380(gp)
8110f7ec:	e0bffe17 	ldw	r2,-8(fp)
8110f7f0:	10800a17 	ldw	r2,40(r2)
8110f7f4:	100d883a 	mov	r6,r2
8110f7f8:	01604574 	movhi	r5,33045
8110f7fc:	2966a104 	addi	r5,r5,-25980
8110f800:	1809883a 	mov	r4,r3
8110f804:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
8110f808:	d0e06117 	ldw	r3,-32380(gp)
8110f80c:	e0bffe17 	ldw	r2,-8(fp)
8110f810:	10800b17 	ldw	r2,44(r2)
8110f814:	100d883a 	mov	r6,r2
8110f818:	01604574 	movhi	r5,33045
8110f81c:	2966ac04 	addi	r5,r5,-25936
8110f820:	1809883a 	mov	r4,r3
8110f824:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Right side \n");
8110f828:	d0a06117 	ldw	r2,-32380(gp)
8110f82c:	100f883a 	mov	r7,r2
8110f830:	01800504 	movi	r6,20
8110f834:	01400044 	movi	r5,1
8110f838:	01204574 	movhi	r4,33045
8110f83c:	2126b804 	addi	r4,r4,-25888
8110f840:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8110f844:	d0e06117 	ldw	r3,-32380(gp)
8110f848:	e0bffe17 	ldw	r2,-8(fp)
8110f84c:	10800c17 	ldw	r2,48(r2)
8110f850:	100d883a 	mov	r6,r2
8110f854:	01604574 	movhi	r5,33045
8110f858:	29669804 	addi	r5,r5,-26016
8110f85c:	1809883a 	mov	r4,r3
8110f860:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8110f864:	d0e06117 	ldw	r3,-32380(gp)
8110f868:	e0bffe17 	ldw	r2,-8(fp)
8110f86c:	10800d17 	ldw	r2,52(r2)
8110f870:	100d883a 	mov	r6,r2
8110f874:	01604574 	movhi	r5,33045
8110f878:	2966a104 	addi	r5,r5,-25980
8110f87c:	1809883a 	mov	r4,r3
8110f880:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8110f884:	d0e06117 	ldw	r3,-32380(gp)
8110f888:	e0bffe17 	ldw	r2,-8(fp)
8110f88c:	10800e17 	ldw	r2,56(r2)
8110f890:	100d883a 	mov	r6,r2
8110f894:	01604574 	movhi	r5,33045
8110f898:	2966ac04 	addi	r5,r5,-25936
8110f89c:	1809883a 	mov	r4,r3
8110f8a0:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"\n");
8110f8a4:	d0a06117 	ldw	r2,-32380(gp)
8110f8a8:	100b883a 	mov	r5,r2
8110f8ac:	01000284 	movi	r4,10
8110f8b0:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
8110f8b4:	d0e06117 	ldw	r3,-32380(gp)
8110f8b8:	e0bffe17 	ldw	r2,-8(fp)
8110f8bc:	10800003 	ldbu	r2,0(r2)
8110f8c0:	10803fcc 	andi	r2,r2,255
8110f8c4:	100f883a 	mov	r7,r2
8110f8c8:	01800044 	movi	r6,1
8110f8cc:	01604574 	movhi	r5,33045
8110f8d0:	29668904 	addi	r5,r5,-26076
8110f8d4:	1809883a 	mov	r4,r3
8110f8d8:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Left side \n");
8110f8dc:	d0a06117 	ldw	r2,-32380(gp)
8110f8e0:	100f883a 	mov	r7,r2
8110f8e4:	018004c4 	movi	r6,19
8110f8e8:	01400044 	movi	r5,1
8110f8ec:	01204574 	movhi	r4,33045
8110f8f0:	21269304 	addi	r4,r4,-26036
8110f8f4:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
8110f8f8:	d0e06117 	ldw	r3,-32380(gp)
8110f8fc:	e0bffe17 	ldw	r2,-8(fp)
8110f900:	10800f17 	ldw	r2,60(r2)
8110f904:	100d883a 	mov	r6,r2
8110f908:	01604574 	movhi	r5,33045
8110f90c:	29669804 	addi	r5,r5,-26016
8110f910:	1809883a 	mov	r4,r3
8110f914:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
8110f918:	d0e06117 	ldw	r3,-32380(gp)
8110f91c:	e0bffe17 	ldw	r2,-8(fp)
8110f920:	10801017 	ldw	r2,64(r2)
8110f924:	100d883a 	mov	r6,r2
8110f928:	01604574 	movhi	r5,33045
8110f92c:	2966a104 	addi	r5,r5,-25980
8110f930:	1809883a 	mov	r4,r3
8110f934:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
8110f938:	d0e06117 	ldw	r3,-32380(gp)
8110f93c:	e0bffe17 	ldw	r2,-8(fp)
8110f940:	10801117 	ldw	r2,68(r2)
8110f944:	100d883a 	mov	r6,r2
8110f948:	01604574 	movhi	r5,33045
8110f94c:	2966ac04 	addi	r5,r5,-25936
8110f950:	1809883a 	mov	r4,r3
8110f954:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Right side \n");
8110f958:	d0a06117 	ldw	r2,-32380(gp)
8110f95c:	100f883a 	mov	r7,r2
8110f960:	01800504 	movi	r6,20
8110f964:	01400044 	movi	r5,1
8110f968:	01204574 	movhi	r4,33045
8110f96c:	2126b804 	addi	r4,r4,-25888
8110f970:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8110f974:	d0e06117 	ldw	r3,-32380(gp)
8110f978:	e0bffe17 	ldw	r2,-8(fp)
8110f97c:	10801217 	ldw	r2,72(r2)
8110f980:	100d883a 	mov	r6,r2
8110f984:	01604574 	movhi	r5,33045
8110f988:	29669804 	addi	r5,r5,-26016
8110f98c:	1809883a 	mov	r4,r3
8110f990:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
8110f994:	d0e06117 	ldw	r3,-32380(gp)
8110f998:	e0bffe17 	ldw	r2,-8(fp)
8110f99c:	10801317 	ldw	r2,76(r2)
8110f9a0:	100d883a 	mov	r6,r2
8110f9a4:	01604574 	movhi	r5,33045
8110f9a8:	2966a104 	addi	r5,r5,-25980
8110f9ac:	1809883a 	mov	r4,r3
8110f9b0:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
8110f9b4:	d0e06117 	ldw	r3,-32380(gp)
8110f9b8:	e0bffe17 	ldw	r2,-8(fp)
8110f9bc:	10801417 	ldw	r2,80(r2)
8110f9c0:	100d883a 	mov	r6,r2
8110f9c4:	01604574 	movhi	r5,33045
8110f9c8:	2966ac04 	addi	r5,r5,-25936
8110f9cc:	1809883a 	mov	r4,r3
8110f9d0:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"\n");
8110f9d4:	d0a06117 	ldw	r2,-32380(gp)
8110f9d8:	100b883a 	mov	r5,r2
8110f9dc:	01000284 	movi	r4,10
8110f9e0:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
8110f9e4:	d0e06117 	ldw	r3,-32380(gp)
8110f9e8:	e0bffe17 	ldw	r2,-8(fp)
8110f9ec:	10800003 	ldbu	r2,0(r2)
8110f9f0:	10803fcc 	andi	r2,r2,255
8110f9f4:	100f883a 	mov	r7,r2
8110f9f8:	01800084 	movi	r6,2
8110f9fc:	01604574 	movhi	r5,33045
8110fa00:	29668904 	addi	r5,r5,-26076
8110fa04:	1809883a 	mov	r4,r3
8110fa08:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Left side \n");
8110fa0c:	d0a06117 	ldw	r2,-32380(gp)
8110fa10:	100f883a 	mov	r7,r2
8110fa14:	018004c4 	movi	r6,19
8110fa18:	01400044 	movi	r5,1
8110fa1c:	01204574 	movhi	r4,33045
8110fa20:	21269304 	addi	r4,r4,-26036
8110fa24:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
8110fa28:	d0e06117 	ldw	r3,-32380(gp)
8110fa2c:	e0bffe17 	ldw	r2,-8(fp)
8110fa30:	10801517 	ldw	r2,84(r2)
8110fa34:	100d883a 	mov	r6,r2
8110fa38:	01604574 	movhi	r5,33045
8110fa3c:	29669804 	addi	r5,r5,-26016
8110fa40:	1809883a 	mov	r4,r3
8110fa44:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
8110fa48:	d0e06117 	ldw	r3,-32380(gp)
8110fa4c:	e0bffe17 	ldw	r2,-8(fp)
8110fa50:	10801617 	ldw	r2,88(r2)
8110fa54:	100d883a 	mov	r6,r2
8110fa58:	01604574 	movhi	r5,33045
8110fa5c:	2966a104 	addi	r5,r5,-25980
8110fa60:	1809883a 	mov	r4,r3
8110fa64:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
8110fa68:	d0e06117 	ldw	r3,-32380(gp)
8110fa6c:	e0bffe17 	ldw	r2,-8(fp)
8110fa70:	10801717 	ldw	r2,92(r2)
8110fa74:	100d883a 	mov	r6,r2
8110fa78:	01604574 	movhi	r5,33045
8110fa7c:	2966ac04 	addi	r5,r5,-25936
8110fa80:	1809883a 	mov	r4,r3
8110fa84:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Right side \n");
8110fa88:	d0a06117 	ldw	r2,-32380(gp)
8110fa8c:	100f883a 	mov	r7,r2
8110fa90:	01800504 	movi	r6,20
8110fa94:	01400044 	movi	r5,1
8110fa98:	01204574 	movhi	r4,33045
8110fa9c:	2126b804 	addi	r4,r4,-25888
8110faa0:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
8110faa4:	d0e06117 	ldw	r3,-32380(gp)
8110faa8:	e0bffe17 	ldw	r2,-8(fp)
8110faac:	10801817 	ldw	r2,96(r2)
8110fab0:	100d883a 	mov	r6,r2
8110fab4:	01604574 	movhi	r5,33045
8110fab8:	29669804 	addi	r5,r5,-26016
8110fabc:	1809883a 	mov	r4,r3
8110fac0:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
8110fac4:	d0e06117 	ldw	r3,-32380(gp)
8110fac8:	e0bffe17 	ldw	r2,-8(fp)
8110facc:	10801917 	ldw	r2,100(r2)
8110fad0:	100d883a 	mov	r6,r2
8110fad4:	01604574 	movhi	r5,33045
8110fad8:	2966a104 	addi	r5,r5,-25980
8110fadc:	1809883a 	mov	r4,r3
8110fae0:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
8110fae4:	d0e06117 	ldw	r3,-32380(gp)
8110fae8:	e0bffe17 	ldw	r2,-8(fp)
8110faec:	10801a17 	ldw	r2,104(r2)
8110faf0:	100d883a 	mov	r6,r2
8110faf4:	01604574 	movhi	r5,33045
8110faf8:	2966ac04 	addi	r5,r5,-25936
8110fafc:	1809883a 	mov	r4,r3
8110fb00:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"\n");
8110fb04:	d0a06117 	ldw	r2,-32380(gp)
8110fb08:	100b883a 	mov	r5,r2
8110fb0c:	01000284 	movi	r4,10
8110fb10:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8110fb14:	d0e06117 	ldw	r3,-32380(gp)
8110fb18:	e0bffe17 	ldw	r2,-8(fp)
8110fb1c:	10800003 	ldbu	r2,0(r2)
8110fb20:	10803fcc 	andi	r2,r2,255
8110fb24:	100f883a 	mov	r7,r2
8110fb28:	018000c4 	movi	r6,3
8110fb2c:	01604574 	movhi	r5,33045
8110fb30:	29668904 	addi	r5,r5,-26076
8110fb34:	1809883a 	mov	r4,r3
8110fb38:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Left side \n");
8110fb3c:	d0a06117 	ldw	r2,-32380(gp)
8110fb40:	100f883a 	mov	r7,r2
8110fb44:	018004c4 	movi	r6,19
8110fb48:	01400044 	movi	r5,1
8110fb4c:	01204574 	movhi	r4,33045
8110fb50:	21269304 	addi	r4,r4,-26036
8110fb54:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
8110fb58:	d0e06117 	ldw	r3,-32380(gp)
8110fb5c:	e0bffe17 	ldw	r2,-8(fp)
8110fb60:	10801b17 	ldw	r2,108(r2)
8110fb64:	100d883a 	mov	r6,r2
8110fb68:	01604574 	movhi	r5,33045
8110fb6c:	29669804 	addi	r5,r5,-26016
8110fb70:	1809883a 	mov	r4,r3
8110fb74:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
8110fb78:	d0e06117 	ldw	r3,-32380(gp)
8110fb7c:	e0bffe17 	ldw	r2,-8(fp)
8110fb80:	10801c17 	ldw	r2,112(r2)
8110fb84:	100d883a 	mov	r6,r2
8110fb88:	01604574 	movhi	r5,33045
8110fb8c:	2966a104 	addi	r5,r5,-25980
8110fb90:	1809883a 	mov	r4,r3
8110fb94:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
8110fb98:	d0e06117 	ldw	r3,-32380(gp)
8110fb9c:	e0bffe17 	ldw	r2,-8(fp)
8110fba0:	10801d17 	ldw	r2,116(r2)
8110fba4:	100d883a 	mov	r6,r2
8110fba8:	01604574 	movhi	r5,33045
8110fbac:	2966ac04 	addi	r5,r5,-25936
8110fbb0:	1809883a 	mov	r4,r3
8110fbb4:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"        Right side \n");
8110fbb8:	d0a06117 	ldw	r2,-32380(gp)
8110fbbc:	100f883a 	mov	r7,r2
8110fbc0:	01800504 	movi	r6,20
8110fbc4:	01400044 	movi	r5,1
8110fbc8:	01204574 	movhi	r4,33045
8110fbcc:	2126b804 	addi	r4,r4,-25888
8110fbd0:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
8110fbd4:	d0e06117 	ldw	r3,-32380(gp)
8110fbd8:	e0bffe17 	ldw	r2,-8(fp)
8110fbdc:	10801e17 	ldw	r2,120(r2)
8110fbe0:	100d883a 	mov	r6,r2
8110fbe4:	01604574 	movhi	r5,33045
8110fbe8:	29669804 	addi	r5,r5,-26016
8110fbec:	1809883a 	mov	r4,r3
8110fbf0:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
8110fbf4:	d0e06117 	ldw	r3,-32380(gp)
8110fbf8:	e0bffe17 	ldw	r2,-8(fp)
8110fbfc:	10801f17 	ldw	r2,124(r2)
8110fc00:	100d883a 	mov	r6,r2
8110fc04:	01604574 	movhi	r5,33045
8110fc08:	2966a104 	addi	r5,r5,-25980
8110fc0c:	1809883a 	mov	r4,r3
8110fc10:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
8110fc14:	d0e06117 	ldw	r3,-32380(gp)
8110fc18:	e0bffe17 	ldw	r2,-8(fp)
8110fc1c:	10802017 	ldw	r2,128(r2)
8110fc20:	100d883a 	mov	r6,r2
8110fc24:	01604574 	movhi	r5,33045
8110fc28:	2966ac04 	addi	r5,r5,-25936
8110fc2c:	1809883a 	mov	r4,r3
8110fc30:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"\n");
8110fc34:	d0a06117 	ldw	r2,-32380(gp)
8110fc38:	100b883a 	mov	r5,r2
8110fc3c:	01000284 	movi	r4,10
8110fc40:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"==============================================================================\n");
8110fc44:	d0a06117 	ldw	r2,-32380(gp)
8110fc48:	100f883a 	mov	r7,r2
8110fc4c:	018013c4 	movi	r6,79
8110fc50:	01400044 	movi	r5,1
8110fc54:	01204574 	movhi	r4,33045
8110fc58:	2126be04 	addi	r4,r4,-25864
8110fc5c:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"==============================================================================\n");
8110fc60:	d0a06117 	ldw	r2,-32380(gp)
8110fc64:	100f883a 	mov	r7,r2
8110fc68:	018013c4 	movi	r6,79
8110fc6c:	01400044 	movi	r5,1
8110fc70:	01204574 	movhi	r4,33045
8110fc74:	2126be04 	addi	r4,r4,-25864
8110fc78:	111dcb00 	call	8111dcb0 <fwrite>
		fprintf(fp,"\n");
8110fc7c:	d0a06117 	ldw	r2,-32380(gp)
8110fc80:	100b883a 	mov	r5,r2
8110fc84:	01000284 	movi	r4,10
8110fc88:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"\n");
8110fc8c:	d0a06117 	ldw	r2,-32380(gp)
8110fc90:	100b883a 	mov	r5,r2
8110fc94:	01000284 	movi	r4,10
8110fc98:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"\n");
8110fc9c:	d0a06117 	ldw	r2,-32380(gp)
8110fca0:	100b883a 	mov	r5,r2
8110fca4:	01000284 	movi	r4,10
8110fca8:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"\n");
8110fcac:	d0a06117 	ldw	r2,-32380(gp)
8110fcb0:	100b883a 	mov	r5,r2
8110fcb4:	01000284 	movi	r4,10
8110fcb8:	111d68c0 	call	8111d68c <fputc>
		fprintf(fp,"\n");
8110fcbc:	d0a06117 	ldw	r2,-32380(gp)
8110fcc0:	100b883a 	mov	r5,r2
8110fcc4:	01000284 	movi	r4,10
8110fcc8:	111d68c0 	call	8111d68c <fputc>
	}
8110fccc:	0001883a 	nop
8110fcd0:	e037883a 	mov	sp,fp
8110fcd4:	dfc00117 	ldw	ra,4(sp)
8110fcd8:	df000017 	ldw	fp,0(sp)
8110fcdc:	dec00204 	addi	sp,sp,8
8110fce0:	f800283a 	ret

8110fce4 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
8110fce4:	defff604 	addi	sp,sp,-40
8110fce8:	de00012e 	bgeu	sp,et,8110fcf0 <vInAckHandlerTaskV2+0xc>
8110fcec:	003b68fa 	trap	3
8110fcf0:	dfc00915 	stw	ra,36(sp)
8110fcf4:	df000815 	stw	fp,32(sp)
8110fcf8:	df000804 	addi	fp,sp,32
8110fcfc:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8110fd00:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
8110fd04:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
8110fd08:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
8110fd0c:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8110fd10:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
8110fd14:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
8110fd18:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
8110fd1c:	d0a06117 	ldw	r2,-32380(gp)
8110fd20:	100f883a 	mov	r7,r2
8110fd24:	018007c4 	movi	r6,31
8110fd28:	01400044 	movi	r5,1
8110fd2c:	01204574 	movhi	r4,33045
8110fd30:	2126d204 	addi	r4,r4,-25784
8110fd34:	111dcb00 	call	8111dcb0 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
8110fd38:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
8110fd3c:	e0bff917 	ldw	r2,-28(fp)
8110fd40:	10c00060 	cmpeqi	r3,r2,1
8110fd44:	1800071e 	bne	r3,zero,8110fd64 <vInAckHandlerTaskV2+0x80>
8110fd48:	0080032e 	bgeu	zero,r2,8110fd58 <vInAckHandlerTaskV2+0x74>
8110fd4c:	108000a0 	cmpeqi	r2,r2,2
8110fd50:	10004a1e 	bne	r2,zero,8110fe7c <vInAckHandlerTaskV2+0x198>
8110fd54:	0000ac06 	br	81110008 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8110fd58:	00800044 	movi	r2,1
8110fd5c:	e0bff915 	stw	r2,-28(fp)
				break;
8110fd60:	0000b306 	br	81110030 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
8110fd64:	00800044 	movi	r2,1
8110fd68:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
8110fd6c:	d0a06517 	ldw	r2,-32364(gp)
8110fd70:	e0fffe04 	addi	r3,fp,-8
8110fd74:	180d883a 	mov	r6,r3
8110fd78:	000b883a 	mov	r5,zero
8110fd7c:	1009883a 	mov	r4,r2
8110fd80:	113b6f00 	call	8113b6f0 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110fd84:	e0bffe03 	ldbu	r2,-8(fp)
8110fd88:	10803fcc 	andi	r2,r2,255
8110fd8c:	1000391e 	bne	r2,zero,8110fe74 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
8110fd90:	d0a06417 	ldw	r2,-32368(gp)
8110fd94:	e0fffe04 	addi	r3,fp,-8
8110fd98:	180d883a 	mov	r6,r3
8110fd9c:	000b883a 	mov	r5,zero
8110fda0:	1009883a 	mov	r4,r2
8110fda4:	11396e40 	call	811396e4 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110fda8:	e0bffe03 	ldbu	r2,-8(fp)
8110fdac:	10803fcc 	andi	r2,r2,255
8110fdb0:	10002b1e 	bne	r2,zero,8110fe60 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110fdb4:	e03ffa45 	stb	zero,-23(fp)
8110fdb8:	00002206 	br	8110fe44 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8110fdbc:	e0fffa43 	ldbu	r3,-23(fp)
8110fdc0:	00a045b4 	movhi	r2,33046
8110fdc4:	10b59704 	addi	r2,r2,-10660
8110fdc8:	18c7883a 	add	r3,r3,r3
8110fdcc:	18c7883a 	add	r3,r3,r3
8110fdd0:	10c5883a 	add	r2,r2,r3
8110fdd4:	10800003 	ldbu	r2,0(r2)
8110fdd8:	10803fcc 	andi	r2,r2,255
8110fddc:	1080201c 	xori	r2,r2,128
8110fde0:	10bfe004 	addi	r2,r2,-128
8110fde4:	10001426 	beq	r2,zero,8110fe38 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8110fde8:	e0fffa43 	ldbu	r3,-23(fp)
8110fdec:	00a045b4 	movhi	r2,33046
8110fdf0:	10b59704 	addi	r2,r2,-10660
8110fdf4:	18c7883a 	add	r3,r3,r3
8110fdf8:	18c7883a 	add	r3,r3,r3
8110fdfc:	10c5883a 	add	r2,r2,r3
8110fe00:	10c0000b 	ldhu	r3,0(r2)
8110fe04:	d0e0560d 	sth	r3,-32424(gp)
8110fe08:	1080008b 	ldhu	r2,2(r2)
8110fe0c:	d0a0568d 	sth	r2,-32422(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110fe10:	e0fffa43 	ldbu	r3,-23(fp)
8110fe14:	00a045b4 	movhi	r2,33046
8110fe18:	10b59704 	addi	r2,r2,-10660
8110fe1c:	18c7883a 	add	r3,r3,r3
8110fe20:	18c7883a 	add	r3,r3,r3
8110fe24:	10c5883a 	add	r2,r2,r3
8110fe28:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
8110fe2c:	00800084 	movi	r2,2
8110fe30:	e0bff915 	stw	r2,-28(fp)
                                break;                                
8110fe34:	00000606 	br	8110fe50 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110fe38:	e0bffa43 	ldbu	r2,-23(fp)
8110fe3c:	10800044 	addi	r2,r2,1
8110fe40:	e0bffa45 	stb	r2,-23(fp)
8110fe44:	e0bffa43 	ldbu	r2,-23(fp)
8110fe48:	108001b0 	cmpltui	r2,r2,6
8110fe4c:	103fdb1e 	bne	r2,zero,8110fdbc <__reset+0xfb0efdbc>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
8110fe50:	d0a06417 	ldw	r2,-32368(gp)
8110fe54:	1009883a 	mov	r4,r2
8110fe58:	1139c880 	call	81139c88 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110fe5c:	00007406 	br	81110030 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
8110fe60:	d0a06517 	ldw	r2,-32364(gp)
8110fe64:	1009883a 	mov	r4,r2
8110fe68:	113ba780 	call	8113ba78 <OSSemPost>
                    	vFailGetMutexReceiverTask();
8110fe6c:	111897c0 	call	8111897c <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110fe70:	00006f06 	br	81110030 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
8110fe74:	11189140 	call	81118914 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
8110fe78:	00006d06 	br	81110030 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110fe7c:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110fe80:	d0a06783 	ldbu	r2,-32354(gp)
8110fe84:	10803fcc 	andi	r2,r2,255
8110fe88:	10800218 	cmpnei	r2,r2,8
8110fe8c:	1000021e 	bne	r2,zero,8110fe98 <vInAckHandlerTaskV2+0x1b4>
8110fe90:	00c00104 	movi	r3,4
8110fe94:	00000106 	br	8110fe9c <vInAckHandlerTaskV2+0x1b8>
8110fe98:	0007883a 	mov	r3,zero
8110fe9c:	d0a07403 	ldbu	r2,-32304(gp)
8110fea0:	10803fcc 	andi	r2,r2,255
8110fea4:	10800218 	cmpnei	r2,r2,8
8110fea8:	1000021e 	bne	r2,zero,8110feb4 <vInAckHandlerTaskV2+0x1d0>
8110feac:	00800084 	movi	r2,2
8110feb0:	00000106 	br	8110feb8 <vInAckHandlerTaskV2+0x1d4>
8110feb4:	0005883a 	mov	r2,zero
8110feb8:	1884b03a 	or	r2,r3,r2
8110febc:	1007883a 	mov	r3,r2
8110fec0:	d0a07443 	ldbu	r2,-32303(gp)
8110fec4:	10803fcc 	andi	r2,r2,255
8110fec8:	108001a0 	cmpeqi	r2,r2,6
8110fecc:	1884b03a 	or	r2,r3,r2
8110fed0:	1007883a 	mov	r3,r2
8110fed4:	e0bffa83 	ldbu	r2,-22(fp)
8110fed8:	1884b03a 	or	r2,r3,r2
8110fedc:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
8110fee0:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
8110fee4:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8110fee8:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110feec:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
8110fef0:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
8110fef4:	e0bffa03 	ldbu	r2,-24(fp)
8110fef8:	10800044 	addi	r2,r2,1
8110fefc:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110ff00:	e0bffa83 	ldbu	r2,-22(fp)
8110ff04:	1080004c 	andi	r2,r2,1
8110ff08:	10803fcc 	andi	r2,r2,255
8110ff0c:	1000061e 	bne	r2,zero,8110ff28 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
8110ff10:	e0bffd04 	addi	r2,fp,-12
8110ff14:	100b883a 	mov	r5,r2
8110ff18:	d1205604 	addi	r4,gp,-32424
8110ff1c:	11100340 	call	81110034 <bCheckInAck128>
8110ff20:	e0bff815 	stw	r2,-32(fp)
8110ff24:	00000206 	br	8110ff30 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
8110ff28:	00800044 	movi	r2,1
8110ff2c:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
8110ff30:	e0bffa83 	ldbu	r2,-22(fp)
8110ff34:	1080008c 	andi	r2,r2,2
8110ff38:	10803fcc 	andi	r2,r2,255
8110ff3c:	1000081e 	bne	r2,zero,8110ff60 <vInAckHandlerTaskV2+0x27c>
8110ff40:	e0bff817 	ldw	r2,-32(fp)
8110ff44:	1000061e 	bne	r2,zero,8110ff60 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8110ff48:	e0bffc04 	addi	r2,fp,-16
8110ff4c:	100b883a 	mov	r5,r2
8110ff50:	d1205604 	addi	r4,gp,-32424
8110ff54:	111017c0 	call	8111017c <bCheckInAck64>
8110ff58:	e0bff815 	stw	r2,-32(fp)
8110ff5c:	00000206 	br	8110ff68 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
8110ff60:	00800044 	movi	r2,1
8110ff64:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8110ff68:	e0bffa83 	ldbu	r2,-22(fp)
8110ff6c:	1080010c 	andi	r2,r2,4
8110ff70:	10803fcc 	andi	r2,r2,255
8110ff74:	1000081e 	bne	r2,zero,8110ff98 <vInAckHandlerTaskV2+0x2b4>
8110ff78:	e0bff817 	ldw	r2,-32(fp)
8110ff7c:	1000061e 	bne	r2,zero,8110ff98 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
8110ff80:	e0bffb04 	addi	r2,fp,-20
8110ff84:	100b883a 	mov	r5,r2
8110ff88:	d1205604 	addi	r4,gp,-32424
8110ff8c:	11102c80 	call	811102c8 <bCheckInAck32>
8110ff90:	e0bff815 	stw	r2,-32(fp)
8110ff94:	00000206 	br	8110ffa0 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
8110ff98:	00800044 	movi	r2,1
8110ff9c:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
8110ffa0:	e0bffa03 	ldbu	r2,-24(fp)
8110ffa4:	10c00044 	addi	r3,r2,1
8110ffa8:	e0fffa05 	stb	r3,-24(fp)
8110ffac:	10803fcc 	andi	r2,r2,255
8110ffb0:	10800ca8 	cmpgeui	r2,r2,50
8110ffb4:	10000e1e 	bne	r2,zero,8110fff0 <vInAckHandlerTaskV2+0x30c>
8110ffb8:	e0bff817 	ldw	r2,-32(fp)
8110ffbc:	10000c1e 	bne	r2,zero,8110fff0 <vInAckHandlerTaskV2+0x30c>
8110ffc0:	e0bffb17 	ldw	r2,-20(fp)
8110ffc4:	1005003a 	cmpeq	r2,r2,zero
8110ffc8:	1007883a 	mov	r3,r2
8110ffcc:	e0bffc17 	ldw	r2,-16(fp)
8110ffd0:	1005003a 	cmpeq	r2,r2,zero
8110ffd4:	1884b03a 	or	r2,r3,r2
8110ffd8:	10c03fcc 	andi	r3,r2,255
8110ffdc:	e0bffd17 	ldw	r2,-12(fp)
8110ffe0:	1005003a 	cmpeq	r2,r2,zero
8110ffe4:	10803fcc 	andi	r2,r2,255
8110ffe8:	1884b03a 	or	r2,r3,r2
8110ffec:	103fc11e 	bne	r2,zero,8110fef4 <__reset+0xfb0efef4>
                
                if (bFound == FALSE) {
8110fff0:	e0bff817 	ldw	r2,-32(fp)
8110fff4:	1000011e 	bne	r2,zero,8110fffc <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8110fff8:	1118e380 	call	81118e38 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
8110fffc:	00800044 	movi	r2,1
81110000:	e0bff915 	stw	r2,-28(fp)
				break;
81110004:	00000a06 	br	81110030 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81110008:	d0a06117 	ldw	r2,-32380(gp)
8111000c:	100f883a 	mov	r7,r2
81110010:	01801144 	movi	r6,69
81110014:	01400044 	movi	r5,1
81110018:	01204574 	movhi	r4,33045
8111001c:	2126da04 	addi	r4,r4,-25752
81110020:	111dcb00 	call	8111dcb0 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
81110024:	00800044 	movi	r2,1
81110028:	e0bff915 	stw	r2,-28(fp)
				break;
8111002c:	0001883a 	nop
		}
	}
81110030:	003f4206 	br	8110fd3c <__reset+0xfb0efd3c>

81110034 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81110034:	defffa04 	addi	sp,sp,-24
81110038:	de00012e 	bgeu	sp,et,81110040 <bCheckInAck128+0xc>
8111003c:	003b68fa 	trap	3
81110040:	dfc00515 	stw	ra,20(sp)
81110044:	df000415 	stw	fp,16(sp)
81110048:	df000404 	addi	fp,sp,16
8111004c:	e13ffe15 	stw	r4,-8(fp)
81110050:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81110054:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81110058:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8111005c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81110060:	e0bfff17 	ldw	r2,-4(fp)
81110064:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
81110068:	d0a06d17 	ldw	r2,-32332(gp)
8111006c:	e0fffd44 	addi	r3,fp,-11
81110070:	180d883a 	mov	r6,r3
81110074:	01400144 	movi	r5,5
81110078:	1009883a 	mov	r4,r2
8111007c:	11396e40 	call	811396e4 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81110080:	e0bffd43 	ldbu	r2,-11(fp)
81110084:	10803fcc 	andi	r2,r2,255
81110088:	10000226 	beq	r2,zero,81110094 <bCheckInAck128+0x60>
        return bFound;
8111008c:	e0bffc17 	ldw	r2,-16(fp)
81110090:	00003506 	br	81110168 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81110094:	e03ffd05 	stb	zero,-12(fp)
81110098:	00002706 	br	81110138 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8111009c:	e0fffd03 	ldbu	r3,-12(fp)
811100a0:	00a045b4 	movhi	r2,33046
811100a4:	10ac9504 	addi	r2,r2,-19884
811100a8:	18c02324 	muli	r3,r3,140
811100ac:	10c5883a 	add	r2,r2,r3
811100b0:	10802104 	addi	r2,r2,132
811100b4:	10c0000b 	ldhu	r3,0(r2)
811100b8:	e0bffe17 	ldw	r2,-8(fp)
811100bc:	1080008b 	ldhu	r2,2(r2)
811100c0:	18ffffcc 	andi	r3,r3,65535
811100c4:	10bfffcc 	andi	r2,r2,65535
811100c8:	1880181e 	bne	r3,r2,8111012c <bCheckInAck128+0xf8>
            bFound = TRUE;
811100cc:	00800044 	movi	r2,1
811100d0:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
811100d4:	e0fffd03 	ldbu	r3,-12(fp)
811100d8:	00a045b4 	movhi	r2,33046
811100dc:	10ac7704 	addi	r2,r2,-20004
811100e0:	18c7883a 	add	r3,r3,r3
811100e4:	18c7883a 	add	r3,r3,r3
811100e8:	10c5883a 	add	r2,r2,r3
811100ec:	10000015 	stw	zero,0(r2)
            SemCount128++;
811100f0:	d0a07443 	ldbu	r2,-32303(gp)
811100f4:	10800044 	addi	r2,r2,1
811100f8:	d0a07445 	stb	r2,-32303(gp)
            error_code = OSSemPost(xSemCountBuffer128);
811100fc:	d0a06217 	ldw	r2,-32376(gp)
81110100:	1009883a 	mov	r4,r2
81110104:	113ba780 	call	8113ba78 <OSSemPost>
81110108:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8111010c:	e0bffd43 	ldbu	r2,-11(fp)
81110110:	10803fcc 	andi	r2,r2,255
81110114:	10000c26 	beq	r2,zero,81110148 <bCheckInAck128+0x114>
                SemCount128--;
81110118:	d0a07443 	ldbu	r2,-32303(gp)
8111011c:	10bfffc4 	addi	r2,r2,-1
81110120:	d0a07445 	stb	r2,-32303(gp)
                vFailSetCountSemaphorexBuffer128();
81110124:	1118c980 	call	81118c98 <vFailSetCountSemaphorexBuffer128>
            }
            break;
81110128:	00000706 	br	81110148 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8111012c:	e0bffd03 	ldbu	r2,-12(fp)
81110130:	10800044 	addi	r2,r2,1
81110134:	e0bffd05 	stb	r2,-12(fp)
81110138:	e0bffd03 	ldbu	r2,-12(fp)
8111013c:	108001b0 	cmpltui	r2,r2,6
81110140:	103fd61e 	bne	r2,zero,8111009c <__reset+0xfb0f009c>
81110144:	00000106 	br	8111014c <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
81110148:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8111014c:	d0a06d17 	ldw	r2,-32332(gp)
81110150:	1009883a 	mov	r4,r2
81110154:	1139c880 	call	81139c88 <OSMutexPost>
    (*bFinished) = TRUE;
81110158:	e0bfff17 	ldw	r2,-4(fp)
8111015c:	00c00044 	movi	r3,1
81110160:	10c00015 	stw	r3,0(r2)

    return bFound;
81110164:	e0bffc17 	ldw	r2,-16(fp)
}
81110168:	e037883a 	mov	sp,fp
8111016c:	dfc00117 	ldw	ra,4(sp)
81110170:	df000017 	ldw	fp,0(sp)
81110174:	dec00204 	addi	sp,sp,8
81110178:	f800283a 	ret

8111017c <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8111017c:	defffa04 	addi	sp,sp,-24
81110180:	de00012e 	bgeu	sp,et,81110188 <bCheckInAck64+0xc>
81110184:	003b68fa 	trap	3
81110188:	dfc00515 	stw	ra,20(sp)
8111018c:	df000415 	stw	fp,16(sp)
81110190:	df000404 	addi	fp,sp,16
81110194:	e13ffe15 	stw	r4,-8(fp)
81110198:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8111019c:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811101a0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811101a4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811101a8:	e0bfff17 	ldw	r2,-4(fp)
811101ac:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811101b0:	d0a07017 	ldw	r2,-32320(gp)
811101b4:	e0fffd44 	addi	r3,fp,-11
811101b8:	180d883a 	mov	r6,r3
811101bc:	01400044 	movi	r5,1
811101c0:	1009883a 	mov	r4,r2
811101c4:	11396e40 	call	811396e4 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811101c8:	e0bffd43 	ldbu	r2,-11(fp)
811101cc:	10803fcc 	andi	r2,r2,255
811101d0:	10000226 	beq	r2,zero,811101dc <bCheckInAck64+0x60>
        return bFound;
811101d4:	e0bffc17 	ldw	r2,-16(fp)
811101d8:	00003606 	br	811102b4 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
811101dc:	e03ffd05 	stb	zero,-12(fp)
811101e0:	00002806 	br	81110284 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
811101e4:	e0fffd03 	ldbu	r3,-12(fp)
811101e8:	00a04574 	movhi	r2,33045
811101ec:	10883b04 	addi	r2,r2,8428
811101f0:	18c01324 	muli	r3,r3,76
811101f4:	10c5883a 	add	r2,r2,r3
811101f8:	10801104 	addi	r2,r2,68
811101fc:	10c0000b 	ldhu	r3,0(r2)
81110200:	e0bffe17 	ldw	r2,-8(fp)
81110204:	1080008b 	ldhu	r2,2(r2)
81110208:	18ffffcc 	andi	r3,r3,65535
8111020c:	10bfffcc 	andi	r2,r2,65535
81110210:	1880191e 	bne	r3,r2,81110278 <bCheckInAck64+0xfc>
            bFound = TRUE;
81110214:	00800044 	movi	r2,1
81110218:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8111021c:	e0fffd03 	ldbu	r3,-12(fp)
81110220:	00a045b4 	movhi	r2,33046
81110224:	10ac7704 	addi	r2,r2,-20004
81110228:	18c00184 	addi	r3,r3,6
8111022c:	18c7883a 	add	r3,r3,r3
81110230:	18c7883a 	add	r3,r3,r3
81110234:	10c5883a 	add	r2,r2,r3
81110238:	10000015 	stw	zero,0(r2)
            SemCount64++;
8111023c:	d0a07403 	ldbu	r2,-32304(gp)
81110240:	10800044 	addi	r2,r2,1
81110244:	d0a07405 	stb	r2,-32304(gp)
            error_code = OSSemPost(xSemCountBuffer64);
81110248:	d0a05d17 	ldw	r2,-32396(gp)
8111024c:	1009883a 	mov	r4,r2
81110250:	113ba780 	call	8113ba78 <OSSemPost>
81110254:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81110258:	e0bffd43 	ldbu	r2,-11(fp)
8111025c:	10803fcc 	andi	r2,r2,255
81110260:	10000c26 	beq	r2,zero,81110294 <bCheckInAck64+0x118>
                SemCount64--;
81110264:	d0a07403 	ldbu	r2,-32304(gp)
81110268:	10bfffc4 	addi	r2,r2,-1
8111026c:	d0a07405 	stb	r2,-32304(gp)
                vFailSetCountSemaphorexBuffer64();
81110270:	1118c300 	call	81118c30 <vFailSetCountSemaphorexBuffer64>
            }
            break;
81110274:	00000706 	br	81110294 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81110278:	e0bffd03 	ldbu	r2,-12(fp)
8111027c:	10800044 	addi	r2,r2,1
81110280:	e0bffd05 	stb	r2,-12(fp)
81110284:	e0bffd03 	ldbu	r2,-12(fp)
81110288:	10800230 	cmpltui	r2,r2,8
8111028c:	103fd51e 	bne	r2,zero,811101e4 <__reset+0xfb0f01e4>
81110290:	00000106 	br	81110298 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81110294:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
81110298:	d0a07017 	ldw	r2,-32320(gp)
8111029c:	1009883a 	mov	r4,r2
811102a0:	1139c880 	call	81139c88 <OSMutexPost>
    (*bFinished) = TRUE;
811102a4:	e0bfff17 	ldw	r2,-4(fp)
811102a8:	00c00044 	movi	r3,1
811102ac:	10c00015 	stw	r3,0(r2)

    return bFound;
811102b0:	e0bffc17 	ldw	r2,-16(fp)
}
811102b4:	e037883a 	mov	sp,fp
811102b8:	dfc00117 	ldw	ra,4(sp)
811102bc:	df000017 	ldw	fp,0(sp)
811102c0:	dec00204 	addi	sp,sp,8
811102c4:	f800283a 	ret

811102c8 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
811102c8:	defffa04 	addi	sp,sp,-24
811102cc:	de00012e 	bgeu	sp,et,811102d4 <bCheckInAck32+0xc>
811102d0:	003b68fa 	trap	3
811102d4:	dfc00515 	stw	ra,20(sp)
811102d8:	df000415 	stw	fp,16(sp)
811102dc:	df000404 	addi	fp,sp,16
811102e0:	e13ffe15 	stw	r4,-8(fp)
811102e4:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811102e8:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811102ec:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811102f0:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811102f4:	e0bfff17 	ldw	r2,-4(fp)
811102f8:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811102fc:	d0a06b17 	ldw	r2,-32340(gp)
81110300:	e0fffd44 	addi	r3,fp,-11
81110304:	180d883a 	mov	r6,r3
81110308:	01400044 	movi	r5,1
8111030c:	1009883a 	mov	r4,r2
81110310:	11396e40 	call	811396e4 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81110314:	e0bffd43 	ldbu	r2,-11(fp)
81110318:	10803fcc 	andi	r2,r2,255
8111031c:	10000226 	beq	r2,zero,81110328 <bCheckInAck32+0x60>
        return bFound;
81110320:	e0bffc17 	ldw	r2,-16(fp)
81110324:	00003606 	br	81110400 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81110328:	e03ffd05 	stb	zero,-12(fp)
8111032c:	00002806 	br	811103d0 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
81110330:	e0fffd03 	ldbu	r3,-12(fp)
81110334:	00a04574 	movhi	r2,33045
81110338:	1099f704 	addi	r2,r2,26588
8111033c:	18c00b24 	muli	r3,r3,44
81110340:	10c5883a 	add	r2,r2,r3
81110344:	10800904 	addi	r2,r2,36
81110348:	10c0000b 	ldhu	r3,0(r2)
8111034c:	e0bffe17 	ldw	r2,-8(fp)
81110350:	1080008b 	ldhu	r2,2(r2)
81110354:	18ffffcc 	andi	r3,r3,65535
81110358:	10bfffcc 	andi	r2,r2,65535
8111035c:	1880191e 	bne	r3,r2,811103c4 <bCheckInAck32+0xfc>
            bFound = TRUE;
81110360:	00800044 	movi	r2,1
81110364:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81110368:	e0fffd03 	ldbu	r3,-12(fp)
8111036c:	00a045b4 	movhi	r2,33046
81110370:	10ac7704 	addi	r2,r2,-20004
81110374:	18c00384 	addi	r3,r3,14
81110378:	18c7883a 	add	r3,r3,r3
8111037c:	18c7883a 	add	r3,r3,r3
81110380:	10c5883a 	add	r2,r2,r3
81110384:	10000015 	stw	zero,0(r2)
            SemCount32++;
81110388:	d0a06783 	ldbu	r2,-32354(gp)
8111038c:	10800044 	addi	r2,r2,1
81110390:	d0a06785 	stb	r2,-32354(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81110394:	d0a06e17 	ldw	r2,-32328(gp)
81110398:	1009883a 	mov	r4,r2
8111039c:	113ba780 	call	8113ba78 <OSSemPost>
811103a0:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
811103a4:	e0bffd43 	ldbu	r2,-11(fp)
811103a8:	10803fcc 	andi	r2,r2,255
811103ac:	10000c26 	beq	r2,zero,811103e0 <bCheckInAck32+0x118>
                SemCount32--;
811103b0:	d0a06783 	ldbu	r2,-32354(gp)
811103b4:	10bfffc4 	addi	r2,r2,-1
811103b8:	d0a06785 	stb	r2,-32354(gp)
                vFailSetCountSemaphorexBuffer32();
811103bc:	1118bc80 	call	81118bc8 <vFailSetCountSemaphorexBuffer32>
            }
            break;
811103c0:	00000706 	br	811103e0 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
811103c4:	e0bffd03 	ldbu	r2,-12(fp)
811103c8:	10800044 	addi	r2,r2,1
811103cc:	e0bffd05 	stb	r2,-12(fp)
811103d0:	e0bffd03 	ldbu	r2,-12(fp)
811103d4:	10800230 	cmpltui	r2,r2,8
811103d8:	103fd51e 	bne	r2,zero,81110330 <__reset+0xfb0f0330>
811103dc:	00000106 	br	811103e4 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
811103e0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
811103e4:	d0a06b17 	ldw	r2,-32340(gp)
811103e8:	1009883a 	mov	r4,r2
811103ec:	1139c880 	call	81139c88 <OSMutexPost>
    (*bFinished) = TRUE;
811103f0:	e0bfff17 	ldw	r2,-4(fp)
811103f4:	00c00044 	movi	r3,1
811103f8:	10c00015 	stw	r3,0(r2)

    return bFound;
811103fc:	e0bffc17 	ldw	r2,-16(fp)
}
81110400:	e037883a 	mov	sp,fp
81110404:	dfc00117 	ldw	ra,4(sp)
81110408:	df000017 	ldw	fp,0(sp)
8111040c:	dec00204 	addi	sp,sp,8
81110410:	f800283a 	ret

81110414 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
81110414:	defff704 	addi	sp,sp,-36
81110418:	de00012e 	bgeu	sp,et,81110420 <vInitialTask+0xc>
8111041c:	003b68fa 	trap	3
81110420:	dfc00815 	stw	ra,32(sp)
81110424:	df000715 	stw	fp,28(sp)
81110428:	df000704 	addi	fp,sp,28
8111042c:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
81110430:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81110434:	d8000415 	stw	zero,16(sp)
81110438:	d8000315 	stw	zero,12(sp)
8111043c:	00810004 	movi	r2,1024
81110440:	d8800215 	stw	r2,8(sp)
81110444:	00a04574 	movhi	r2,33045
81110448:	10803b04 	addi	r2,r2,236
8111044c:	d8800115 	stw	r2,4(sp)
81110450:	008002c4 	movi	r2,11
81110454:	d8800015 	stw	r2,0(sp)
81110458:	01c002c4 	movi	r7,11
8111045c:	01a04574 	movhi	r6,33045
81110460:	31843a04 	addi	r6,r6,4328
81110464:	01604574 	movhi	r5,33045
81110468:	29555b04 	addi	r5,r5,21868
8111046c:	01204474 	movhi	r4,33041
81110470:	21349004 	addi	r4,r4,-11712
81110474:	113c45c0 	call	8113c45c <OSTaskCreateExt>
81110478:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8111047c:	e0bffe03 	ldbu	r2,-8(fp)
81110480:	10803fcc 	andi	r2,r2,255
81110484:	10000526 	beq	r2,zero,8111049c <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110488:	e0bffe03 	ldbu	r2,-8(fp)
8111048c:	10803fcc 	andi	r2,r2,255
81110490:	1009883a 	mov	r4,r2
81110494:	11185440 	call	81118544 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
81110498:	11199f00 	call	811199f0 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8111049c:	01c17704 	movi	r7,1500
811104a0:	000d883a 	mov	r6,zero
811104a4:	000b883a 	mov	r5,zero
811104a8:	0009883a 	mov	r4,zero
811104ac:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
811104b0:	d8000415 	stw	zero,16(sp)
811104b4:	d8000315 	stw	zero,12(sp)
811104b8:	00810004 	movi	r2,1024
811104bc:	d8800215 	stw	r2,8(sp)
811104c0:	00a04574 	movhi	r2,33045
811104c4:	10914904 	addi	r2,r2,17700
811104c8:	d8800115 	stw	r2,4(sp)
811104cc:	00800284 	movi	r2,10
811104d0:	d8800015 	stw	r2,0(sp)
811104d4:	01c00284 	movi	r7,10
811104d8:	01a04574 	movhi	r6,33045
811104dc:	31954804 	addi	r6,r6,21792
811104e0:	01604574 	movhi	r5,33045
811104e4:	29555304 	addi	r5,r5,21836
811104e8:	01204474 	movhi	r4,33041
811104ec:	21346804 	addi	r4,r4,-11872
811104f0:	113c45c0 	call	8113c45c <OSTaskCreateExt>
811104f4:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811104f8:	e0bffe03 	ldbu	r2,-8(fp)
811104fc:	10803fcc 	andi	r2,r2,255
81110500:	10000526 	beq	r2,zero,81110518 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110504:	e0bffe03 	ldbu	r2,-8(fp)
81110508:	10803fcc 	andi	r2,r2,255
8111050c:	1009883a 	mov	r4,r2
81110510:	11185440 	call	81118544 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
81110514:	1119cc80 	call	81119cc8 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81110518:	01c17704 	movi	r7,1500
8111051c:	000d883a 	mov	r6,zero
81110520:	000b883a 	mov	r5,zero
81110524:	0009883a 	mov	r4,zero
81110528:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
8111052c:	d8000415 	stw	zero,16(sp)
81110530:	d8000315 	stw	zero,12(sp)
81110534:	00810004 	movi	r2,1024
81110538:	d8800215 	stw	r2,8(sp)
8111053c:	00a045b4 	movhi	r2,33046
81110540:	10ad7f04 	addi	r2,r2,-18948
81110544:	d8800115 	stw	r2,4(sp)
81110548:	00800244 	movi	r2,9
8111054c:	d8800015 	stw	r2,0(sp)
81110550:	01c00244 	movi	r7,9
81110554:	01a045b4 	movhi	r6,33046
81110558:	31b17e04 	addi	r6,r6,-14856
8111055c:	01604574 	movhi	r5,33045
81110560:	29555b04 	addi	r5,r5,21868
81110564:	01204474 	movhi	r4,33041
81110568:	21026604 	addi	r4,r4,2456
8111056c:	113c45c0 	call	8113c45c <OSTaskCreateExt>
81110570:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110574:	e0bffe03 	ldbu	r2,-8(fp)
81110578:	10803fcc 	andi	r2,r2,255
8111057c:	10000526 	beq	r2,zero,81110594 <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110580:	e0bffe03 	ldbu	r2,-8(fp)
81110584:	10803fcc 	andi	r2,r2,255
81110588:	1009883a 	mov	r4,r2
8111058c:	11185440 	call	81118544 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
81110590:	1119c600 	call	81119c60 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81110594:	01c17704 	movi	r7,1500
81110598:	000d883a 	mov	r6,zero
8111059c:	000b883a 	mov	r5,zero
811105a0:	0009883a 	mov	r4,zero
811105a4:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
811105a8:	d8000415 	stw	zero,16(sp)
811105ac:	d8000315 	stw	zero,12(sp)
811105b0:	00810004 	movi	r2,1024
811105b4:	d8800215 	stw	r2,8(sp)
811105b8:	00a045b4 	movhi	r2,33046
811105bc:	10bfa104 	addi	r2,r2,-380
811105c0:	d8800115 	stw	r2,4(sp)
811105c4:	00800204 	movi	r2,8
811105c8:	d8800015 	stw	r2,0(sp)
811105cc:	01c00204 	movi	r7,8
811105d0:	01a045b4 	movhi	r6,33046
811105d4:	3183a004 	addi	r6,r6,3712
811105d8:	01604574 	movhi	r5,33045
811105dc:	29554904 	addi	r5,r5,21796
811105e0:	01204474 	movhi	r4,33041
811105e4:	210bd604 	addi	r4,r4,12120
811105e8:	113c45c0 	call	8113c45c <OSTaskCreateExt>
811105ec:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811105f0:	e0bffe03 	ldbu	r2,-8(fp)
811105f4:	10803fcc 	andi	r2,r2,255
811105f8:	10000526 	beq	r2,zero,81110610 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811105fc:	e0bffe03 	ldbu	r2,-8(fp)
81110600:	10803fcc 	andi	r2,r2,255
81110604:	1009883a 	mov	r4,r2
81110608:	11185440 	call	81118544 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
8111060c:	1119d300 	call	81119d30 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81110610:	01c17704 	movi	r7,1500
81110614:	000d883a 	mov	r6,zero
81110618:	000b883a 	mov	r5,zero
8111061c:	0009883a 	mov	r4,zero
81110620:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81110624:	d8000415 	stw	zero,16(sp)
81110628:	d8000315 	stw	zero,12(sp)
8111062c:	00810004 	movi	r2,1024
81110630:	d8800215 	stw	r2,8(sp)
81110634:	00a04574 	movhi	r2,33045
81110638:	108d4904 	addi	r2,r2,13604
8111063c:	d8800115 	stw	r2,4(sp)
81110640:	00800784 	movi	r2,30
81110644:	d8800015 	stw	r2,0(sp)
81110648:	01c00784 	movi	r7,30
8111064c:	01a04574 	movhi	r6,33045
81110650:	31914804 	addi	r6,r6,17696
81110654:	000b883a 	mov	r5,zero
81110658:	01204474 	movhi	r4,33041
8111065c:	21129a04 	addi	r4,r4,19048
81110660:	113c45c0 	call	8113c45c <OSTaskCreateExt>
81110664:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110668:	e0bffe03 	ldbu	r2,-8(fp)
8111066c:	10803fcc 	andi	r2,r2,255
81110670:	10000526 	beq	r2,zero,81110688 <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110674:	e0bffe03 	ldbu	r2,-8(fp)
81110678:	10803fcc 	andi	r2,r2,255
8111067c:	1009883a 	mov	r4,r2
81110680:	11185440 	call	81118544 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
81110684:	111935c0 	call	8111935c <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81110688:	01c03204 	movi	r7,200
8111068c:	000d883a 	mov	r6,zero
81110690:	000b883a 	mov	r5,zero
81110694:	0009883a 	mov	r4,zero
81110698:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
8111069c:	d8000415 	stw	zero,16(sp)
811106a0:	d8000315 	stw	zero,12(sp)
811106a4:	00810004 	movi	r2,1024
811106a8:	d8800215 	stw	r2,8(sp)
811106ac:	00a045b4 	movhi	r2,33046
811106b0:	10a05f04 	addi	r2,r2,-32388
811106b4:	d8800115 	stw	r2,4(sp)
811106b8:	008006c4 	movi	r2,27
811106bc:	d8800015 	stw	r2,0(sp)
811106c0:	01c006c4 	movi	r7,27
811106c4:	01a045b4 	movhi	r6,33046
811106c8:	31a45e04 	addi	r6,r6,-28296
811106cc:	000b883a 	mov	r5,zero
811106d0:	01204474 	movhi	r4,33041
811106d4:	21041c04 	addi	r4,r4,4208
811106d8:	113c45c0 	call	8113c45c <OSTaskCreateExt>
811106dc:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811106e0:	e0bffe03 	ldbu	r2,-8(fp)
811106e4:	10803fcc 	andi	r2,r2,255
811106e8:	10000526 	beq	r2,zero,81110700 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811106ec:	e0bffe03 	ldbu	r2,-8(fp)
811106f0:	10803fcc 	andi	r2,r2,255
811106f4:	1009883a 	mov	r4,r2
811106f8:	11185440 	call	81118544 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
811106fc:	11192780 	call	81119278 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81110700:	01c03204 	movi	r7,200
81110704:	000d883a 	mov	r6,zero
81110708:	000b883a 	mov	r5,zero
8111070c:	0009883a 	mov	r4,zero
81110710:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81110714:	d8000415 	stw	zero,16(sp)
81110718:	d8000315 	stw	zero,12(sp)
8111071c:	00810004 	movi	r2,1024
81110720:	d8800215 	stw	r2,8(sp)
81110724:	00a04574 	movhi	r2,33045
81110728:	10843b04 	addi	r2,r2,4332
8111072c:	d8800115 	stw	r2,4(sp)
81110730:	00800644 	movi	r2,25
81110734:	d8800015 	stw	r2,0(sp)
81110738:	01c00644 	movi	r7,25
8111073c:	01a04574 	movhi	r6,33045
81110740:	31883a04 	addi	r6,r6,8424
81110744:	000b883a 	mov	r5,zero
81110748:	01204474 	movhi	r4,33041
8111074c:	213f3904 	addi	r4,r4,-796
81110750:	113c45c0 	call	8113c45c <OSTaskCreateExt>
81110754:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110758:	e0bffe03 	ldbu	r2,-8(fp)
8111075c:	10803fcc 	andi	r2,r2,255
81110760:	10000526 	beq	r2,zero,81110778 <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110764:	e0bffe03 	ldbu	r2,-8(fp)
81110768:	10803fcc 	andi	r2,r2,255
8111076c:	1009883a 	mov	r4,r2
81110770:	11185440 	call	81118544 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
81110774:	111922c0 	call	8111922c <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81110778:	01c03204 	movi	r7,200
8111077c:	000d883a 	mov	r6,zero
81110780:	000b883a 	mov	r5,zero
81110784:	0009883a 	mov	r4,zero
81110788:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
8111078c:	d8000415 	stw	zero,16(sp)
81110790:	d8000315 	stw	zero,12(sp)
81110794:	00818004 	movi	r2,1536
81110798:	d8800215 	stw	r2,8(sp)
8111079c:	00a045b4 	movhi	r2,33046
811107a0:	10b99d04 	addi	r2,r2,-6540
811107a4:	d8800115 	stw	r2,4(sp)
811107a8:	00800704 	movi	r2,28
811107ac:	d8800015 	stw	r2,0(sp)
811107b0:	01c00704 	movi	r7,28
811107b4:	01a045b4 	movhi	r6,33046
811107b8:	31bf9c04 	addi	r6,r6,-400
811107bc:	000b883a 	mov	r5,zero
811107c0:	01204474 	movhi	r4,33041
811107c4:	2104da04 	addi	r4,r4,4968
811107c8:	113c45c0 	call	8113c45c <OSTaskCreateExt>
811107cc:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811107d0:	e0bffe03 	ldbu	r2,-8(fp)
811107d4:	10803fcc 	andi	r2,r2,255
811107d8:	10000526 	beq	r2,zero,811107f0 <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811107dc:	e0bffe03 	ldbu	r2,-8(fp)
811107e0:	10803fcc 	andi	r2,r2,255
811107e4:	1009883a 	mov	r4,r2
811107e8:	11185440 	call	81118544 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
811107ec:	11191e00 	call	811191e0 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811107f0:	01c03204 	movi	r7,200
811107f4:	000d883a 	mov	r6,zero
811107f8:	000b883a 	mov	r5,zero
811107fc:	0009883a 	mov	r4,zero
81110800:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
81110804:	d8000415 	stw	zero,16(sp)
81110808:	d8000315 	stw	zero,12(sp)
8111080c:	00818004 	movi	r2,1536
81110810:	d8800215 	stw	r2,8(sp)
81110814:	00a04574 	movhi	r2,33045
81110818:	109a4f04 	addi	r2,r2,26940
8111081c:	d8800115 	stw	r2,4(sp)
81110820:	00800804 	movi	r2,32
81110824:	d8800015 	stw	r2,0(sp)
81110828:	01c00804 	movi	r7,32
8111082c:	01a045b4 	movhi	r6,33046
81110830:	31a04e04 	addi	r6,r6,-32456
81110834:	000b883a 	mov	r5,zero
81110838:	01204474 	movhi	r4,33041
8111083c:	2108f604 	addi	r4,r4,9176
81110840:	113c45c0 	call	8113c45c <OSTaskCreateExt>
81110844:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110848:	e0bffe03 	ldbu	r2,-8(fp)
8111084c:	10803fcc 	andi	r2,r2,255
81110850:	10000526 	beq	r2,zero,81110868 <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81110854:	e0bffe03 	ldbu	r2,-8(fp)
81110858:	10803fcc 	andi	r2,r2,255
8111085c:	1009883a 	mov	r4,r2
81110860:	11185440 	call	81118544 <printErrorTask>
		#endif
		vFailReceiverCreate();
81110864:	1118ae40 	call	81118ae4 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81110868:	01c03204 	movi	r7,200
8111086c:	000d883a 	mov	r6,zero
81110870:	000b883a 	mov	r5,zero
81110874:	0009883a 	mov	r4,zero
81110878:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
8111087c:	d8000415 	stw	zero,16(sp)
81110880:	d8000315 	stw	zero,12(sp)
81110884:	00810004 	movi	r2,1024
81110888:	d8800215 	stw	r2,8(sp)
8111088c:	00a04574 	movhi	r2,33045
81110890:	10893704 	addi	r2,r2,9436
81110894:	d8800115 	stw	r2,4(sp)
81110898:	00800684 	movi	r2,26
8111089c:	d8800015 	stw	r2,0(sp)
811108a0:	01c00684 	movi	r7,26
811108a4:	01a04574 	movhi	r6,33045
811108a8:	318d3604 	addi	r6,r6,13528
811108ac:	000b883a 	mov	r5,zero
811108b0:	01204474 	movhi	r4,33041
811108b4:	210b7804 	addi	r4,r4,11744
811108b8:	113c45c0 	call	8113c45c <OSTaskCreateExt>
811108bc:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
811108c0:	01c03204 	movi	r7,200
811108c4:	000d883a 	mov	r6,zero
811108c8:	000b883a 	mov	r5,zero
811108cc:	0009883a 	mov	r4,zero
811108d0:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
811108d4:	e0bffe03 	ldbu	r2,-8(fp)
811108d8:	10803fcc 	andi	r2,r2,255
811108dc:	10000526 	beq	r2,zero,811108f4 <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
811108e0:	e0bffe03 	ldbu	r2,-8(fp)
811108e4:	10803fcc 	andi	r2,r2,255
811108e8:	1009883a 	mov	r4,r2
811108ec:	11185440 	call	81118544 <printErrorTask>
		#endif
		vFailSenderCreate();
811108f0:	1118b300 	call	81118b30 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
811108f4:	d0a06c17 	ldw	r2,-32336(gp)
811108f8:	e17ffe04 	addi	r5,fp,-8
811108fc:	1009883a 	mov	r4,r2
81110900:	113e17c0 	call	8113e17c <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
81110904:	e0bffe03 	ldbu	r2,-8(fp)
81110908:	10803fcc 	andi	r2,r2,255
8111090c:	10000126 	beq	r2,zero,81110914 <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
81110910:	11196180 	call	81119618 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
81110914:	01c00084 	movi	r7,2
81110918:	01800784 	movi	r6,30
8111091c:	000b883a 	mov	r5,zero
81110920:	0009883a 	mov	r4,zero
81110924:	113d6880 	call	8113d688 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
81110928:	01003fc4 	movi	r4,255
8111092c:	113c6480 	call	8113c648 <OSTaskDel>
81110930:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
81110934:	e0bffe03 	ldbu	r2,-8(fp)
81110938:	10803fcc 	andi	r2,r2,255
8111093c:	10001026 	beq	r2,zero,81110980 <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81110940:	e0bffe03 	ldbu	r2,-8(fp)
81110944:	10803fcc 	andi	r2,r2,255
81110948:	1009883a 	mov	r4,r2
8111094c:	11185440 	call	81118544 <printErrorTask>
		#endif
		vFailDeleteInitialization();
81110950:	1118b7c0 	call	81118b7c <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
81110954:	014009c4 	movi	r5,39
81110958:	01000044 	movi	r4,1
8111095c:	113bdb00 	call	8113bdb0 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
81110960:	01003fc4 	movi	r4,255
81110964:	113c6480 	call	8113c648 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
81110968:	000f883a 	mov	r7,zero
8111096c:	01800284 	movi	r6,10
81110970:	000b883a 	mov	r5,zero
81110974:	0009883a 	mov	r4,zero
81110978:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
		}
8111097c:	003ff806 	br	81110960 <__reset+0xfb0f0960>
	}

}
81110980:	0001883a 	nop
81110984:	e037883a 	mov	sp,fp
81110988:	dfc00117 	ldw	ra,4(sp)
8111098c:	df000017 	ldw	fp,0(sp)
81110990:	dec00204 	addi	sp,sp,8
81110994:	f800283a 	ret

81110998 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
81110998:	defff804 	addi	sp,sp,-32
8111099c:	de00012e 	bgeu	sp,et,811109a4 <vNFeeControlTask+0xc>
811109a0:	003b68fa 	trap	3
811109a4:	dfc00715 	stw	ra,28(sp)
811109a8:	df000615 	stw	fp,24(sp)
811109ac:	df000604 	addi	fp,sp,24
811109b0:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
811109b4:	e0bfff17 	ldw	r2,-4(fp)
811109b8:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
811109bc:	d0a06117 	ldw	r2,-32380(gp)
811109c0:	100f883a 	mov	r7,r2
811109c4:	01800804 	movi	r6,32
811109c8:	01400044 	movi	r5,1
811109cc:	01204574 	movhi	r4,33045
811109d0:	2126ec04 	addi	r4,r4,-25680
811109d4:	111dcb00 	call	8111dcb0 <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
811109d8:	e0bffb17 	ldw	r2,-20(fp)
811109dc:	10809a17 	ldw	r2,616(r2)
811109e0:	10c00168 	cmpgeui	r3,r2,5
811109e4:	1800e71e 	bne	r3,zero,81110d84 <vNFeeControlTask+0x3ec>
811109e8:	100690ba 	slli	r3,r2,2
811109ec:	00a04474 	movhi	r2,33041
811109f0:	10828004 	addi	r2,r2,2560
811109f4:	1885883a 	add	r2,r3,r2
811109f8:	10800017 	ldw	r2,0(r2)
811109fc:	1000683a 	jmp	r2
81110a00:	81110a14 	ori	r4,r16,17448
81110a04:	81110a44 	addi	r4,r16,17449
81110a08:	81110aa4 	muli	r4,r16,17450
81110a0c:	81110b58 	cmpnei	r4,r16,17453
81110a10:	81110bd8 	cmpnei	r4,r16,17455
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
81110a14:	d0a06f17 	ldw	r2,-32324(gp)
81110a18:	1009883a 	mov	r4,r2
81110a1c:	113a7380 	call	8113a738 <OSQFlush>
81110a20:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81110a24:	e0bffe03 	ldbu	r2,-8(fp)
81110a28:	10803fcc 	andi	r2,r2,255
81110a2c:	10000126 	beq	r2,zero,81110a34 <vNFeeControlTask+0x9c>
					vFailFlushQueue();
81110a30:	111a3740 	call	8111a374 <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
81110a34:	e0bffb17 	ldw	r2,-20(fp)
81110a38:	00c00044 	movi	r3,1
81110a3c:	10c09a15 	stw	r3,616(r2)
				break;
81110a40:	0000db06 	br	81110db0 <vNFeeControlTask+0x418>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
81110a44:	d0a06117 	ldw	r2,-32380(gp)
81110a48:	100f883a 	mov	r7,r2
81110a4c:	018008c4 	movi	r6,35
81110a50:	01400044 	movi	r5,1
81110a54:	01204574 	movhi	r4,33045
81110a58:	2126f504 	addi	r4,r4,-25644
81110a5c:	111dcb00 	call	8111dcb0 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81110a60:	d0a05c17 	ldw	r2,-32400(gp)
81110a64:	1009883a 	mov	r4,r2
81110a68:	113a7380 	call	8113a738 <OSQFlush>
81110a6c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81110a70:	e0bffe03 	ldbu	r2,-8(fp)
81110a74:	10803fcc 	andi	r2,r2,255
81110a78:	10000126 	beq	r2,zero,81110a80 <vNFeeControlTask+0xe8>
					vFailFlushQueue();
81110a7c:	111a3740 	call	8111a374 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81110a80:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
81110a84:	00800044 	movi	r2,1
81110a88:	d0a05715 	stw	r2,-32420(gp)
				ucWhoGetDMA = 255;
81110a8c:	00bfffc4 	movi	r2,-1
81110a90:	d0a05805 	stb	r2,-32416(gp)
				pxFeeC->sMode = sMebConfig;
81110a94:	e0bffb17 	ldw	r2,-20(fp)
81110a98:	00c000c4 	movi	r3,3
81110a9c:	10c09a15 	stw	r3,616(r2)
				break;
81110aa0:	0000c306 	br	81110db0 <vNFeeControlTask+0x418>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
81110aa4:	111a4cc0 	call	8111a4cc <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
81110aa8:	d0a06117 	ldw	r2,-32380(gp)
81110aac:	100f883a 	mov	r7,r2
81110ab0:	01800804 	movi	r6,32
81110ab4:	01400044 	movi	r5,1
81110ab8:	01204574 	movhi	r4,33045
81110abc:	2126fe04 	addi	r4,r4,-25608
81110ac0:	111dcb00 	call	8111dcb0 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81110ac4:	d0a05c17 	ldw	r2,-32400(gp)
81110ac8:	1009883a 	mov	r4,r2
81110acc:	113a7380 	call	8113a738 <OSQFlush>
81110ad0:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81110ad4:	e0bffe03 	ldbu	r2,-8(fp)
81110ad8:	10803fcc 	andi	r2,r2,255
81110adc:	10000126 	beq	r2,zero,81110ae4 <vNFeeControlTask+0x14c>
					vFailFlushQueue();
81110ae0:	111a3740 	call	8111a374 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81110ae4:	e03ffa45 	stb	zero,-23(fp)
81110ae8:	00001006 	br	81110b2c <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
81110aec:	e0bffa43 	ldbu	r2,-23(fp)
81110af0:	1085883a 	add	r2,r2,r2
81110af4:	1087883a 	add	r3,r2,r2
81110af8:	d0a06904 	addi	r2,gp,-32348
81110afc:	1885883a 	add	r2,r3,r2
81110b00:	10800017 	ldw	r2,0(r2)
81110b04:	1009883a 	mov	r4,r2
81110b08:	113a7380 	call	8113a738 <OSQFlush>
81110b0c:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
81110b10:	e0bffe03 	ldbu	r2,-8(fp)
81110b14:	10803fcc 	andi	r2,r2,255
81110b18:	10000126 	beq	r2,zero,81110b20 <vNFeeControlTask+0x188>
						vFailFlushQueue();
81110b1c:	111a3740 	call	8111a374 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81110b20:	e0bffa43 	ldbu	r2,-23(fp)
81110b24:	10800044 	addi	r2,r2,1
81110b28:	e0bffa45 	stb	r2,-23(fp)
81110b2c:	e0bffa43 	ldbu	r2,-23(fp)
81110b30:	103fee26 	beq	r2,zero,81110aec <__reset+0xfb0f0aec>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
81110b34:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
81110b38:	00800044 	movi	r2,1
81110b3c:	d0a05715 	stw	r2,-32420(gp)
				ucWhoGetDMA = 255;
81110b40:	00bfffc4 	movi	r2,-1
81110b44:	d0a05805 	stb	r2,-32416(gp)
				pxFeeC->sMode = sMebRun;
81110b48:	e0bffb17 	ldw	r2,-20(fp)
81110b4c:	00c00104 	movi	r3,4
81110b50:	10c09a15 	stw	r3,616(r2)
				break;
81110b54:	00009606 	br	81110db0 <vNFeeControlTask+0x418>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
81110b58:	d0a06f17 	ldw	r2,-32324(gp)
81110b5c:	e0fffe04 	addi	r3,fp,-8
81110b60:	180d883a 	mov	r6,r3
81110b64:	000b883a 	mov	r5,zero
81110b68:	1009883a 	mov	r4,r2
81110b6c:	113a7f80 	call	8113a7f8 <OSQPend>
81110b70:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81110b74:	e0bffe03 	ldbu	r2,-8(fp)
81110b78:	10803fcc 	andi	r2,r2,255
81110b7c:	1000141e 	bne	r2,zero,81110bd0 <vNFeeControlTask+0x238>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81110b80:	e0bffdc3 	ldbu	r2,-9(fp)
81110b84:	10803fcc 	andi	r2,r2,255
81110b88:	10800418 	cmpnei	r2,r2,16
81110b8c:	1000051e 	bne	r2,zero,81110ba4 <vNFeeControlTask+0x20c>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
81110b90:	e0bffd17 	ldw	r2,-12(fp)
81110b94:	e17ffb17 	ldw	r5,-20(fp)
81110b98:	1009883a 	mov	r4,r2
81110b9c:	1110db40 	call	81110db4 <vPerformActionNFCConfig>
81110ba0:	00000706 	br	81110bc0 <vNFeeControlTask+0x228>

					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"Provavel para FEE (Remover)\n");
81110ba4:	d0a06117 	ldw	r2,-32380(gp)
81110ba8:	100f883a 	mov	r7,r2
81110bac:	01800704 	movi	r6,28
81110bb0:	01400044 	movi	r5,1
81110bb4:	01204574 	movhi	r4,33045
81110bb8:	21270704 	addi	r4,r4,-25572
81110bbc:	111dcb00 	call	8111dcb0 <fwrite>
						#endif
					}
					bCmdSent = FALSE;
81110bc0:	e03ffc15 	stw	zero,-16(fp)
					bDmaBack = TRUE;
81110bc4:	00800044 	movi	r2,1
81110bc8:	d0a05715 	stw	r2,-32420(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81110bcc:	00007806 	br	81110db0 <vNFeeControlTask+0x418>
					}
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81110bd0:	1119fc80 	call	81119fc8 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81110bd4:	00007606 	br	81110db0 <vNFeeControlTask+0x418>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81110bd8:	d0a05717 	ldw	r2,-32420(gp)
81110bdc:	10800058 	cmpnei	r2,r2,1
81110be0:	1000221e 	bne	r2,zero,81110c6c <vNFeeControlTask+0x2d4>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81110be4:	d0a05c17 	ldw	r2,-32400(gp)
81110be8:	e0fffe04 	addi	r3,fp,-8
81110bec:	180d883a 	mov	r6,r3
81110bf0:	01400104 	movi	r5,4
81110bf4:	1009883a 	mov	r4,r2
81110bf8:	113a7f80 	call	8113a7f8 <OSQPend>
81110bfc:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
81110c00:	e0bffe03 	ldbu	r2,-8(fp)
81110c04:	10803fcc 	andi	r2,r2,255
81110c08:	1000181e 	bne	r2,zero,81110c6c <vNFeeControlTask+0x2d4>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81110c0c:	e0bffd03 	ldbu	r2,-12(fp)
81110c10:	e0bffa05 	stb	r2,-24(fp)


						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
81110c14:	e0bffa03 	ldbu	r2,-24(fp)
81110c18:	e0fffb17 	ldw	r3,-20(fp)
81110c1c:	10809624 	muli	r2,r2,600
81110c20:	1885883a 	add	r2,r3,r2
81110c24:	10802304 	addi	r2,r2,140
81110c28:	10800017 	ldw	r2,0(r2)
81110c2c:	10800058 	cmpnei	r2,r2,1
81110c30:	10000e1e 	bne	r2,zero,81110c6c <vNFeeControlTask+0x2d4>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
81110c34:	e0bffa03 	ldbu	r2,-24(fp)
81110c38:	e0fffa03 	ldbu	r3,-24(fp)
81110c3c:	180f883a 	mov	r7,r3
81110c40:	000d883a 	mov	r6,zero
81110c44:	014023c4 	movi	r5,143
81110c48:	1009883a 	mov	r4,r2
81110c4c:	1110fa80 	call	81110fa8 <bSendCmdQToNFeeInst>
81110c50:	e0bffc15 	stw	r2,-16(fp)
							if ( bCmdSent == TRUE ) {
81110c54:	e0bffc17 	ldw	r2,-16(fp)
81110c58:	10800058 	cmpnei	r2,r2,1
81110c5c:	1000031e 	bne	r2,zero,81110c6c <vNFeeControlTask+0x2d4>
								bDmaBack = FALSE;
81110c60:	d0205715 	stw	zero,-32420(gp)
								ucWhoGetDMA = ucFeeInstL;
81110c64:	e0bffa03 	ldbu	r2,-24(fp)
81110c68:	d0a05805 	stb	r2,-32416(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
81110c6c:	d0a05717 	ldw	r2,-32420(gp)
81110c70:	1000081e 	bne	r2,zero,81110c94 <vNFeeControlTask+0x2fc>

					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
81110c74:	d0a06f17 	ldw	r2,-32324(gp)
81110c78:	e0fffe04 	addi	r3,fp,-8
81110c7c:	180d883a 	mov	r6,r3
81110c80:	000b883a 	mov	r5,zero
81110c84:	1009883a 	mov	r4,r2
81110c88:	113a7f80 	call	8113a7f8 <OSQPend>
81110c8c:	e0bffd15 	stw	r2,-12(fp)
81110c90:	00000706 	br	81110cb0 <vNFeeControlTask+0x318>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81110c94:	d0a06f17 	ldw	r2,-32324(gp)
81110c98:	e0fffe04 	addi	r3,fp,-8
81110c9c:	180d883a 	mov	r6,r3
81110ca0:	01400104 	movi	r5,4
81110ca4:	1009883a 	mov	r4,r2
81110ca8:	113a7f80 	call	8113a7f8 <OSQPend>
81110cac:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
81110cb0:	e0bffe03 	ldbu	r2,-8(fp)
81110cb4:	10803fcc 	andi	r2,r2,255
81110cb8:	10002c1e 	bne	r2,zero,81110d6c <vNFeeControlTask+0x3d4>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81110cbc:	e0bffd83 	ldbu	r2,-10(fp)
81110cc0:	10803fcc 	andi	r2,r2,255
81110cc4:	10802058 	cmpnei	r2,r2,129
81110cc8:	1000091e 	bne	r2,zero,81110cf0 <vNFeeControlTask+0x358>
						if ( uiCmdNFC.ucByte[0] == ucFeeInstL ){
81110ccc:	e0bffd03 	ldbu	r2,-12(fp)
81110cd0:	10c03fcc 	andi	r3,r2,255
81110cd4:	e0bffa03 	ldbu	r2,-24(fp)
81110cd8:	1880241e 	bne	r3,r2,81110d6c <vNFeeControlTask+0x3d4>
							bDmaBack = TRUE;
81110cdc:	00800044 	movi	r2,1
81110ce0:	d0a05715 	stw	r2,-32420(gp)
							ucFeeInstL = 255;
81110ce4:	00bfffc4 	movi	r2,-1
81110ce8:	e0bffa05 	stb	r2,-24(fp)
81110cec:	00001f06 	br	81110d6c <vNFeeControlTask+0x3d4>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81110cf0:	e0bffdc3 	ldbu	r2,-9(fp)
81110cf4:	10803fcc 	andi	r2,r2,255
81110cf8:	10800418 	cmpnei	r2,r2,16
81110cfc:	1000051e 	bne	r2,zero,81110d14 <vNFeeControlTask+0x37c>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81110d00:	e0bffd17 	ldw	r2,-12(fp)
81110d04:	e17ffb17 	ldw	r5,-20(fp)
81110d08:	1009883a 	mov	r4,r2
81110d0c:	1110e7c0 	call	81110e7c <vPerformActionNFCRunning>
81110d10:	00001606 	br	81110d6c <vNFeeControlTask+0x3d4>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
81110d14:	e0bffdc3 	ldbu	r2,-9(fp)
81110d18:	10803fcc 	andi	r2,r2,255
81110d1c:	10800470 	cmpltui	r2,r2,17
81110d20:	1000121e 	bne	r2,zero,81110d6c <vNFeeControlTask+0x3d4>
81110d24:	e0bffdc3 	ldbu	r2,-9(fp)
81110d28:	10803fcc 	andi	r2,r2,255
81110d2c:	108004e8 	cmpgeui	r2,r2,19
81110d30:	10000e1e 	bne	r2,zero,81110d6c <vNFeeControlTask+0x3d4>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
81110d34:	e0bffdc3 	ldbu	r2,-9(fp)
81110d38:	10bffbc4 	addi	r2,r2,-17
81110d3c:	10803fcc 	andi	r2,r2,255
81110d40:	e0fffd83 	ldbu	r3,-10(fp)
81110d44:	18c03fcc 	andi	r3,r3,255
81110d48:	e13ffd43 	ldbu	r4,-11(fp)
81110d4c:	21003fcc 	andi	r4,r4,255
81110d50:	e17ffd03 	ldbu	r5,-12(fp)
81110d54:	29403fcc 	andi	r5,r5,255
81110d58:	280f883a 	mov	r7,r5
81110d5c:	200d883a 	mov	r6,r4
81110d60:	180b883a 	mov	r5,r3
81110d64:	1009883a 	mov	r4,r2
81110d68:	1110fa80 	call	81110fa8 <bSendCmdQToNFeeInst>

							}
						}
					}
				}
				OSTimeDlyHMSM(0,0,0,20); /*remover!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
81110d6c:	01c00504 	movi	r7,20
81110d70:	000d883a 	mov	r6,zero
81110d74:	000b883a 	mov	r5,zero
81110d78:	0009883a 	mov	r4,zero
81110d7c:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
				break;		
81110d80:	00000b06 	br	81110db0 <vNFeeControlTask+0x418>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81110d84:	d0a06117 	ldw	r2,-32380(gp)
81110d88:	100f883a 	mov	r7,r2
81110d8c:	01800f44 	movi	r6,61
81110d90:	01400044 	movi	r5,1
81110d94:	01204574 	movhi	r4,33045
81110d98:	21270f04 	addi	r4,r4,-25540
81110d9c:	111dcb00 	call	8111dcb0 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
81110da0:	e0bffb17 	ldw	r2,-20(fp)
81110da4:	00c000c4 	movi	r3,3
81110da8:	10c09a15 	stw	r3,616(r2)
				break;
81110dac:	0001883a 	nop
		}
	}
81110db0:	003f0906 	br	811109d8 <__reset+0xfb0f09d8>

81110db4 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81110db4:	defffb04 	addi	sp,sp,-20
81110db8:	de00012e 	bgeu	sp,et,81110dc0 <vPerformActionNFCConfig+0xc>
81110dbc:	003b68fa 	trap	3
81110dc0:	dfc00415 	stw	ra,16(sp)
81110dc4:	df000315 	stw	fp,12(sp)
81110dc8:	df000304 	addi	fp,sp,12
81110dcc:	e13ffe15 	stw	r4,-8(fp)
81110dd0:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81110dd4:	e0bffe17 	ldw	r2,-8(fp)
81110dd8:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81110ddc:	e0bffd83 	ldbu	r2,-10(fp)
81110de0:	10803fcc 	andi	r2,r2,255
81110de4:	10c000a0 	cmpeqi	r3,r2,2
81110de8:	1800121e 	bne	r3,zero,81110e34 <vPerformActionNFCConfig+0x80>
81110dec:	10c000c8 	cmpgei	r3,r2,3
81110df0:	1800031e 	bne	r3,zero,81110e00 <vPerformActionNFCConfig+0x4c>
81110df4:	10800060 	cmpeqi	r2,r2,1
81110df8:	1000061e 	bne	r2,zero,81110e14 <vPerformActionNFCConfig+0x60>
81110dfc:	00001106 	br	81110e44 <vPerformActionNFCConfig+0x90>
81110e00:	10c02860 	cmpeqi	r3,r2,161
81110e04:	1800031e 	bne	r3,zero,81110e14 <vPerformActionNFCConfig+0x60>
81110e08:	108028a0 	cmpeqi	r2,r2,162
81110e0c:	1000091e 	bne	r2,zero,81110e34 <vPerformActionNFCConfig+0x80>
81110e10:	00000c06 	br	81110e44 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
81110e14:	d0a06117 	ldw	r2,-32380(gp)
81110e18:	100f883a 	mov	r7,r2
81110e1c:	01800d44 	movi	r6,53
81110e20:	01400044 	movi	r5,1
81110e24:	01204574 	movhi	r4,33045
81110e28:	21271f04 	addi	r4,r4,-25476
81110e2c:	111dcb00 	call	8111dcb0 <fwrite>
			#endif
			/* Do nothing for now */
			break;
81110e30:	00000c06 	br	81110e64 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
81110e34:	e0bfff17 	ldw	r2,-4(fp)
81110e38:	00c00084 	movi	r3,2
81110e3c:	10c09a15 	stw	r3,616(r2)
			break;
81110e40:	00000806 	br	81110e64 <vPerformActionNFCConfig+0xb0>

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81110e44:	d0a06117 	ldw	r2,-32380(gp)
81110e48:	100f883a 	mov	r7,r2
81110e4c:	018009c4 	movi	r6,39
81110e50:	01400044 	movi	r5,1
81110e54:	01204574 	movhi	r4,33045
81110e58:	21272d04 	addi	r4,r4,-25420
81110e5c:	111dcb00 	call	8111dcb0 <fwrite>
			#endif	
			break;
81110e60:	0001883a 	nop
	}

}
81110e64:	0001883a 	nop
81110e68:	e037883a 	mov	sp,fp
81110e6c:	dfc00117 	ldw	ra,4(sp)
81110e70:	df000017 	ldw	fp,0(sp)
81110e74:	dec00204 	addi	sp,sp,8
81110e78:	f800283a 	ret

81110e7c <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81110e7c:	defffa04 	addi	sp,sp,-24
81110e80:	de00012e 	bgeu	sp,et,81110e88 <vPerformActionNFCRunning+0xc>
81110e84:	003b68fa 	trap	3
81110e88:	dfc00515 	stw	ra,20(sp)
81110e8c:	df000415 	stw	fp,16(sp)
81110e90:	df000404 	addi	fp,sp,16
81110e94:	e13ffe15 	stw	r4,-8(fp)
81110e98:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
81110e9c:	e0bffe17 	ldw	r2,-8(fp)
81110ea0:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81110ea4:	e0bffd83 	ldbu	r2,-10(fp)
81110ea8:	10803fcc 	andi	r2,r2,255
81110eac:	10c000a0 	cmpeqi	r3,r2,2
81110eb0:	1800271e 	bne	r3,zero,81110f50 <vPerformActionNFCRunning+0xd4>
81110eb4:	10c02860 	cmpeqi	r3,r2,161
81110eb8:	1800021e 	bne	r3,zero,81110ec4 <vPerformActionNFCRunning+0x48>
81110ebc:	10800060 	cmpeqi	r2,r2,1
81110ec0:	10002b26 	beq	r2,zero,81110f70 <vPerformActionNFCRunning+0xf4>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to Config Mode\n");
81110ec4:	d0a06117 	ldw	r2,-32380(gp)
81110ec8:	100f883a 	mov	r7,r2
81110ecc:	01800b84 	movi	r6,46
81110ed0:	01400044 	movi	r5,1
81110ed4:	01204574 	movhi	r4,33045
81110ed8:	21273704 	addi	r4,r4,-25380
81110edc:	111dcb00 	call	8111dcb0 <fwrite>
			#endif

			pxFeeCP->sMode = sMebToConfig;
81110ee0:	e0bfff17 	ldw	r2,-4(fp)
81110ee4:	00c00044 	movi	r3,1
81110ee8:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81110eec:	e03ffc05 	stb	zero,-16(fp)
81110ef0:	00001406 	br	81110f44 <vPerformActionNFCRunning+0xc8>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
81110ef4:	e0bffc03 	ldbu	r2,-16(fp)
81110ef8:	e0ffff17 	ldw	r3,-4(fp)
81110efc:	108025c4 	addi	r2,r2,151
81110f00:	1085883a 	add	r2,r2,r2
81110f04:	1085883a 	add	r2,r2,r2
81110f08:	1885883a 	add	r2,r3,r2
81110f0c:	10800017 	ldw	r2,0(r2)
81110f10:	10800017 	ldw	r2,0(r2)
81110f14:	10800058 	cmpnei	r2,r2,1
81110f18:	1000071e 	bne	r2,zero,81110f38 <vPerformActionNFCRunning+0xbc>
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
81110f1c:	e0bffc03 	ldbu	r2,-16(fp)
81110f20:	e0fffc03 	ldbu	r3,-16(fp)
81110f24:	180f883a 	mov	r7,r3
81110f28:	000d883a 	mov	r6,zero
81110f2c:	01402844 	movi	r5,161
81110f30:	1009883a 	mov	r4,r2
81110f34:	1110fa80 	call	81110fa8 <bSendCmdQToNFeeInst>
			#endif

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81110f38:	e0bffc03 	ldbu	r2,-16(fp)
81110f3c:	10800044 	addi	r2,r2,1
81110f40:	e0bffc05 	stb	r2,-16(fp)
81110f44:	e0bffc03 	ldbu	r2,-16(fp)
81110f48:	103fea26 	beq	r2,zero,81110ef4 <__reset+0xfb0f0ef4>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81110f4c:	00001006 	br	81110f90 <vPerformActionNFCRunning+0x114>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81110f50:	d0a06117 	ldw	r2,-32380(gp)
81110f54:	100f883a 	mov	r7,r2
81110f58:	01800d84 	movi	r6,54
81110f5c:	01400044 	movi	r5,1
81110f60:	01204574 	movhi	r4,33045
81110f64:	21274304 	addi	r4,r4,-25332
81110f68:	111dcb00 	call	8111dcb0 <fwrite>
			#endif		
			/* Do nothing for now */

			break;		
81110f6c:	00000806 	br	81110f90 <vPerformActionNFCRunning+0x114>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
81110f70:	d0a06117 	ldw	r2,-32380(gp)
81110f74:	100f883a 	mov	r7,r2
81110f78:	01800984 	movi	r6,38
81110f7c:	01400044 	movi	r5,1
81110f80:	01204574 	movhi	r4,33045
81110f84:	21275104 	addi	r4,r4,-25276
81110f88:	111dcb00 	call	8111dcb0 <fwrite>
			#endif	
			break;
81110f8c:	0001883a 	nop
	}
}
81110f90:	0001883a 	nop
81110f94:	e037883a 	mov	sp,fp
81110f98:	dfc00117 	ldw	ra,4(sp)
81110f9c:	df000017 	ldw	fp,0(sp)
81110fa0:	dec00204 	addi	sp,sp,8
81110fa4:	f800283a 	ret

81110fa8 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81110fa8:	defff704 	addi	sp,sp,-36
81110fac:	de00012e 	bgeu	sp,et,81110fb4 <bSendCmdQToNFeeInst+0xc>
81110fb0:	003b68fa 	trap	3
81110fb4:	dfc00815 	stw	ra,32(sp)
81110fb8:	df000715 	stw	fp,28(sp)
81110fbc:	df000704 	addi	fp,sp,28
81110fc0:	2011883a 	mov	r8,r4
81110fc4:	2809883a 	mov	r4,r5
81110fc8:	3007883a 	mov	r3,r6
81110fcc:	3805883a 	mov	r2,r7
81110fd0:	e23ffc05 	stb	r8,-16(fp)
81110fd4:	e13ffd05 	stb	r4,-12(fp)
81110fd8:	e0fffe05 	stb	r3,-8(fp)
81110fdc:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81110fe0:	e0bffc03 	ldbu	r2,-16(fp)
81110fe4:	10800444 	addi	r2,r2,17
81110fe8:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81110fec:	e0bffd03 	ldbu	r2,-12(fp)
81110ff0:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81110ff4:	e0bffe03 	ldbu	r2,-8(fp)
81110ff8:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81110ffc:	e0bfff03 	ldbu	r2,-4(fp)
81111000:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81111004:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81111008:	e0bffc03 	ldbu	r2,-16(fp)
8111100c:	1085883a 	add	r2,r2,r2
81111010:	1087883a 	add	r3,r2,r2
81111014:	d0a06904 	addi	r2,gp,-32348
81111018:	1885883a 	add	r2,r3,r2
8111101c:	10800017 	ldw	r2,0(r2)
81111020:	e0fffb17 	ldw	r3,-20(fp)
81111024:	180b883a 	mov	r5,r3
81111028:	1009883a 	mov	r4,r2
8111102c:	113ac000 	call	8113ac00 <OSQPost>
81111030:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111034:	e0bffa03 	ldbu	r2,-24(fp)
81111038:	10000526 	beq	r2,zero,81111050 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8111103c:	e0bffc03 	ldbu	r2,-16(fp)
81111040:	1009883a 	mov	r4,r2
81111044:	111a0980 	call	8111a098 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81111048:	e03ff915 	stw	zero,-28(fp)
8111104c:	00000206 	br	81111058 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81111050:	00800044 	movi	r2,1
81111054:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81111058:	e0bff917 	ldw	r2,-28(fp)
}
8111105c:	e037883a 	mov	sp,fp
81111060:	dfc00117 	ldw	ra,4(sp)
81111064:	df000017 	ldw	fp,0(sp)
81111068:	dec00204 	addi	sp,sp,8
8111106c:	f800283a 	ret

81111070 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81111070:	defff704 	addi	sp,sp,-36
81111074:	de00012e 	bgeu	sp,et,8111107c <vOutAckHandlerTask+0xc>
81111078:	003b68fa 	trap	3
8111107c:	dfc00815 	stw	ra,32(sp)
81111080:	df000715 	stw	fp,28(sp)
81111084:	df000704 	addi	fp,sp,28
81111088:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8111108c:	e03ffac5 	stb	zero,-21(fp)
81111090:	e03ffb05 	stb	zero,-20(fp)
81111094:	e03ffb45 	stb	zero,-19(fp)
81111098:	e03ffb85 	stb	zero,-18(fp)
8111109c:	e03ffbc5 	stb	zero,-17(fp)
811110a0:	e03ffc05 	stb	zero,-16(fp)
811110a4:	e03ffc45 	stb	zero,-15(fp)
811110a8:	e03ffc85 	stb	zero,-14(fp)
811110ac:	e03ffcc5 	stb	zero,-13(fp)
811110b0:	e03ffd05 	stb	zero,-12(fp)
811110b4:	e03ffd45 	stb	zero,-11(fp)
811110b8:	e03ffd85 	stb	zero,-10(fp)
811110bc:	e03ffdc5 	stb	zero,-9(fp)
811110c0:	e03ffe05 	stb	zero,-8(fp)
811110c4:	e03ffe45 	stb	zero,-7(fp)
811110c8:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
811110cc:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
811110d0:	d0a06117 	ldw	r2,-32380(gp)
811110d4:	100f883a 	mov	r7,r2
811110d8:	01800804 	movi	r6,32
811110dc:	01400044 	movi	r5,1
811110e0:	01204574 	movhi	r4,33045
811110e4:	21275b04 	addi	r4,r4,-25236
811110e8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
811110ec:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
811110f0:	e0bff917 	ldw	r2,-28(fp)
811110f4:	10c00060 	cmpeqi	r3,r2,1
811110f8:	1800071e 	bne	r3,zero,81111118 <vOutAckHandlerTask+0xa8>
811110fc:	0080032e 	bgeu	zero,r2,8111110c <vOutAckHandlerTask+0x9c>
81111100:	108000a0 	cmpeqi	r2,r2,2
81111104:	1000471e 	bne	r2,zero,81111224 <vOutAckHandlerTask+0x1b4>
81111108:	00008c06 	br	8111133c <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8111110c:	00800044 	movi	r2,1
81111110:	e0bff915 	stw	r2,-28(fp)
				break;
81111114:	00009306 	br	81111364 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
81111118:	00800044 	movi	r2,1
8111111c:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81111120:	d0a06017 	ldw	r2,-32384(gp)
81111124:	e0fffa84 	addi	r3,fp,-22
81111128:	180d883a 	mov	r6,r3
8111112c:	000b883a 	mov	r5,zero
81111130:	1009883a 	mov	r4,r2
81111134:	113b6f00 	call	8113b6f0 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81111138:	e0bffa83 	ldbu	r2,-22(fp)
8111113c:	10803fcc 	andi	r2,r2,255
81111140:	1000361e 	bne	r2,zero,8111121c <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
81111144:	d0a07117 	ldw	r2,-32316(gp)
81111148:	e0fffa84 	addi	r3,fp,-22
8111114c:	180d883a 	mov	r6,r3
81111150:	000b883a 	mov	r5,zero
81111154:	1009883a 	mov	r4,r2
81111158:	11396e40 	call	811396e4 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8111115c:	e0bffa83 	ldbu	r2,-22(fp)
81111160:	10803fcc 	andi	r2,r2,255
81111164:	10002b1e 	bne	r2,zero,81111214 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81111168:	e03ffa05 	stb	zero,-24(fp)
8111116c:	00002206 	br	811111f8 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
81111170:	e0fffa03 	ldbu	r3,-24(fp)
81111174:	00a045b4 	movhi	r2,33046
81111178:	108ba904 	addi	r2,r2,11940
8111117c:	18c7883a 	add	r3,r3,r3
81111180:	18c7883a 	add	r3,r3,r3
81111184:	10c5883a 	add	r2,r2,r3
81111188:	10800003 	ldbu	r2,0(r2)
8111118c:	10803fcc 	andi	r2,r2,255
81111190:	1080201c 	xori	r2,r2,128
81111194:	10bfe004 	addi	r2,r2,-128
81111198:	10001426 	beq	r2,zero,811111ec <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8111119c:	e0fffa03 	ldbu	r3,-24(fp)
811111a0:	00a045b4 	movhi	r2,33046
811111a4:	108ba904 	addi	r2,r2,11940
811111a8:	18c7883a 	add	r3,r3,r3
811111ac:	18c7883a 	add	r3,r3,r3
811111b0:	10c5883a 	add	r2,r2,r3
811111b4:	10c0000b 	ldhu	r3,0(r2)
811111b8:	d0e0588d 	sth	r3,-32414(gp)
811111bc:	1080008b 	ldhu	r2,2(r2)
811111c0:	d0a0590d 	sth	r2,-32412(gp)
                                eSenderAckState = sSASending;
811111c4:	00800084 	movi	r2,2
811111c8:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
811111cc:	e0fffa03 	ldbu	r3,-24(fp)
811111d0:	00a045b4 	movhi	r2,33046
811111d4:	108ba904 	addi	r2,r2,11940
811111d8:	18c7883a 	add	r3,r3,r3
811111dc:	18c7883a 	add	r3,r3,r3
811111e0:	10c5883a 	add	r2,r2,r3
811111e4:	10000005 	stb	zero,0(r2)
                                break;
811111e8:	00000606 	br	81111204 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
811111ec:	e0bffa03 	ldbu	r2,-24(fp)
811111f0:	10800044 	addi	r2,r2,1
811111f4:	e0bffa05 	stb	r2,-24(fp)
811111f8:	e0bffa03 	ldbu	r2,-24(fp)
811111fc:	10800230 	cmpltui	r2,r2,8
81111200:	103fdb1e 	bne	r2,zero,81111170 <__reset+0xfb0f1170>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
81111204:	d0a07117 	ldw	r2,-32316(gp)
81111208:	1009883a 	mov	r4,r2
8111120c:	1139c880 	call	81139c88 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81111210:	00005406 	br	81111364 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
81111214:	11188ac0 	call	811188ac <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81111218:	00005206 	br	81111364 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8111121c:	11188440 	call	81118844 <vFailGetCountSemaphoreSenderTask>
                }

                break;
81111220:	00005006 	br	81111364 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
81111224:	d0a05883 	ldbu	r2,-32414(gp)
81111228:	10803fcc 	andi	r2,r2,255
8111122c:	1080201c 	xori	r2,r2,128
81111230:	10bfe004 	addi	r2,r2,-128
81111234:	108008e0 	cmpeqi	r2,r2,35
81111238:	1000201e 	bne	r2,zero,811112bc <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8111123c:	d0a058c3 	ldbu	r2,-32413(gp)
81111240:	10c03fcc 	andi	r3,r2,255
81111244:	18c0201c 	xori	r3,r3,128
81111248:	18ffe004 	addi	r3,r3,-128
8111124c:	d0a0590b 	ldhu	r2,-32412(gp)
81111250:	113fffcc 	andi	r4,r2,65535
81111254:	e0bffac4 	addi	r2,fp,-21
81111258:	200f883a 	mov	r7,r4
8111125c:	180d883a 	mov	r6,r3
81111260:	01604574 	movhi	r5,33045
81111264:	29676404 	addi	r5,r5,-25200
81111268:	1009883a 	mov	r4,r2
8111126c:	111efa40 	call	8111efa4 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
81111270:	e0bffac4 	addi	r2,fp,-21
81111274:	1009883a 	mov	r4,r2
81111278:	111f1b80 	call	8111f1b8 <strlen>
8111127c:	1007883a 	mov	r3,r2
81111280:	e0bffac4 	addi	r2,fp,-21
81111284:	180b883a 	mov	r5,r3
81111288:	1009883a 	mov	r4,r2
8111128c:	11184080 	call	81118408 <ucCrc8wInit>
81111290:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81111294:	e13ffa43 	ldbu	r4,-23(fp)
81111298:	e0fffac4 	addi	r3,fp,-21
8111129c:	e0bffac4 	addi	r2,fp,-21
811112a0:	200f883a 	mov	r7,r4
811112a4:	180d883a 	mov	r6,r3
811112a8:	01604574 	movhi	r5,33045
811112ac:	29676604 	addi	r5,r5,-25192
811112b0:	1009883a 	mov	r4,r2
811112b4:	111efa40 	call	8111efa4 <sprintf>
811112b8:	00000c06 	br	811112ec <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
811112bc:	e0bffac4 	addi	r2,fp,-21
811112c0:	00c008c4 	movi	r3,35
811112c4:	10c00005 	stb	r3,0(r2)
811112c8:	00c01f04 	movi	r3,124
811112cc:	10c00045 	stb	r3,1(r2)
811112d0:	00c00d44 	movi	r3,53
811112d4:	10c00085 	stb	r3,2(r2)
811112d8:	00c00d04 	movi	r3,52
811112dc:	10c000c5 	stb	r3,3(r2)
811112e0:	00c00ec4 	movi	r3,59
811112e4:	10c00105 	stb	r3,4(r2)
811112e8:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
811112ec:	d0a07317 	ldw	r2,-32308(gp)
811112f0:	e0fffa84 	addi	r3,fp,-22
811112f4:	180d883a 	mov	r6,r3
811112f8:	01401904 	movi	r5,100
811112fc:	1009883a 	mov	r4,r2
81111300:	11396e40 	call	811396e4 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
81111304:	e0bffa83 	ldbu	r2,-22(fp)
81111308:	10803fcc 	andi	r2,r2,255
8111130c:	1000071e 	bne	r2,zero,8111132c <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
81111310:	e0bffac4 	addi	r2,fp,-21
81111314:	1009883a 	mov	r4,r2
81111318:	111ec600 	call	8111ec60 <puts>
                    OSMutexPost(xTxUARTMutex);
8111131c:	d0a07317 	ldw	r2,-32308(gp)
81111320:	1009883a 	mov	r4,r2
81111324:	1139c880 	call	81139c88 <OSMutexPost>
81111328:	00000106 	br	81111330 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8111132c:	11189e40 	call	811189e4 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81111330:	00800044 	movi	r2,1
81111334:	e0bff915 	stw	r2,-28(fp)
                
				break;
81111338:	00000a06 	br	81111364 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
8111133c:	d0a06117 	ldw	r2,-32380(gp)
81111340:	100f883a 	mov	r7,r2
81111344:	01801104 	movi	r6,68
81111348:	01400044 	movi	r5,1
8111134c:	01204574 	movhi	r4,33045
81111350:	21276904 	addi	r4,r4,-25180
81111354:	111dcb00 	call	8111dcb0 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
81111358:	00800044 	movi	r2,1
8111135c:	e0bff915 	stw	r2,-28(fp)
				break;
81111360:	0001883a 	nop
		}
	}
81111364:	003f6206 	br	811110f0 <__reset+0xfb0f10f0>

81111368 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
81111368:	deffd704 	addi	sp,sp,-164
8111136c:	de00012e 	bgeu	sp,et,81111374 <vParserCommTask+0xc>
81111370:	003b68fa 	trap	3
81111374:	dfc02815 	stw	ra,160(sp)
81111378:	df002715 	stw	fp,156(sp)
8111137c:	df002704 	addi	fp,sp,156
81111380:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
81111384:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
81111388:	d0a06117 	ldw	r2,-32380(gp)
8111138c:	100f883a 	mov	r7,r2
81111390:	01800704 	movi	r6,28
81111394:	01400044 	movi	r5,1
81111398:	01204574 	movhi	r4,33045
8111139c:	21277b04 	addi	r4,r4,-25108
811113a0:	111dcb00 	call	8111dcb0 <fwrite>
    #endif

	eParserMode = sConfiguring;
811113a4:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
811113a8:	e0bfdc17 	ldw	r2,-144(fp)
811113ac:	10800168 	cmpgeui	r2,r2,5
811113b0:	1003651e 	bne	r2,zero,81112148 <vParserCommTask+0xde0>
811113b4:	e0bfdc17 	ldw	r2,-144(fp)
811113b8:	100690ba 	slli	r3,r2,2
811113bc:	00a04474 	movhi	r2,33041
811113c0:	1084f404 	addi	r2,r2,5072
811113c4:	1885883a 	add	r2,r3,r2
811113c8:	10800017 	ldw	r2,0(r2)
811113cc:	1000683a 	jmp	r2
811113d0:	811113e4 	muli	r4,r16,17487
811113d4:	811113f0 	cmpltui	r4,r16,17487
811113d8:	81111484 	addi	r4,r16,17490
811113dc:	811115e8 	cmpgeui	r4,r16,17495
811113e0:	8111162c 	andhi	r4,r16,17496
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
811113e4:	00800044 	movi	r2,1
811113e8:	e0bfdc15 	stw	r2,-144(fp)
				break;
811113ec:	00035906 	br	81112154 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
811113f0:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
811113f4:	00800044 	movi	r2,1
811113f8:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
811113fc:	d0a06317 	ldw	r2,-32372(gp)
81111400:	e0ffde84 	addi	r3,fp,-134
81111404:	180d883a 	mov	r6,r3
81111408:	000b883a 	mov	r5,zero
8111140c:	1009883a 	mov	r4,r2
81111410:	113b6f00 	call	8113b6f0 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81111414:	e0bfde83 	ldbu	r2,-134(fp)
81111418:	10803fcc 	andi	r2,r2,255
8111141c:	1000171e 	bne	r2,zero,8111147c <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81111420:	01204574 	movhi	r4,33045
81111424:	213e1504 	addi	r4,r4,-1964
81111428:	11121580 	call	81112158 <getPreParsedPacket>
8111142c:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81111430:	e0bfdd17 	ldw	r2,-140(fp)
81111434:	10800058 	cmpnei	r2,r2,1
81111438:	10000e1e 	bne	r2,zero,81111474 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8111143c:	00a04574 	movhi	r2,33045
81111440:	10be1504 	addi	r2,r2,-1964
81111444:	10800103 	ldbu	r2,4(r2)
81111448:	10803fcc 	andi	r2,r2,255
8111144c:	1080201c 	xori	r2,r2,128
81111450:	10bfe004 	addi	r2,r2,-128
81111454:	10800858 	cmpnei	r2,r2,33
81111458:	1000031e 	bne	r2,zero,81111468 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
8111145c:	008000c4 	movi	r2,3
81111460:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81111464:	00033b06 	br	81112154 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
81111468:	00800084 	movi	r2,2
8111146c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81111470:	00033806 	br	81112154 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
81111474:	1118f700 	call	81118f70 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81111478:	00033606 	br	81112154 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8111147c:	1118ea00 	call	81118ea0 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
81111480:	00033406 	br	81112154 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
81111484:	00a04574 	movhi	r2,33045
81111488:	10be1504 	addi	r2,r2,-1964
8111148c:	10800143 	ldbu	r2,5(r2)
81111490:	10803fcc 	andi	r2,r2,255
81111494:	1080201c 	xori	r2,r2,128
81111498:	10bfe004 	addi	r2,r2,-128
8111149c:	10c010e0 	cmpeqi	r3,r2,67
811114a0:	1800031e 	bne	r3,zero,811114b0 <vParserCommTask+0x148>
811114a4:	10801420 	cmpeqi	r2,r2,80
811114a8:	1000051e 	bne	r2,zero,811114c0 <vParserCommTask+0x158>
811114ac:	00004a06 	br	811115d8 <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
811114b0:	1116bd80 	call	81116bd8 <vSendEthConf>
						eParserMode = sWaitingMessage;
811114b4:	00800044 	movi	r2,1
811114b8:	e0bfdc15 	stw	r2,-144(fp)
						break;
811114bc:	00004906 	br	811115e4 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
811114c0:	e0bfdec4 	addi	r2,fp,-133
811114c4:	01802004 	movi	r6,128
811114c8:	000b883a 	mov	r5,zero
811114cc:	1009883a 	mov	r4,r2
811114d0:	111e8140 	call	8111e814 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
811114d4:	00a04574 	movhi	r2,33045
811114d8:	10be1504 	addi	r2,r2,-1964
811114dc:	1080028b 	ldhu	r2,10(r2)
811114e0:	117fffcc 	andi	r5,r2,65535
811114e4:	00a04574 	movhi	r2,33045
811114e8:	10be1504 	addi	r2,r2,-1964
811114ec:	1080030b 	ldhu	r2,12(r2)
811114f0:	11bfffcc 	andi	r6,r2,65535
811114f4:	00a04574 	movhi	r2,33045
811114f8:	10be1504 	addi	r2,r2,-1964
811114fc:	1080038b 	ldhu	r2,14(r2)
81111500:	10ffffcc 	andi	r3,r2,65535
81111504:	00a04574 	movhi	r2,33045
81111508:	10be1504 	addi	r2,r2,-1964
8111150c:	1080040b 	ldhu	r2,16(r2)
81111510:	113fffcc 	andi	r4,r2,65535
81111514:	00a04574 	movhi	r2,33045
81111518:	10be1504 	addi	r2,r2,-1964
8111151c:	1080048b 	ldhu	r2,18(r2)
81111520:	10bfffcc 	andi	r2,r2,65535
81111524:	e23fdec4 	addi	r8,fp,-133
81111528:	d8800215 	stw	r2,8(sp)
8111152c:	d9000115 	stw	r4,4(sp)
81111530:	d8c00015 	stw	r3,0(sp)
81111534:	300f883a 	mov	r7,r6
81111538:	280d883a 	mov	r6,r5
8111153c:	01604574 	movhi	r5,33045
81111540:	29678304 	addi	r5,r5,-25076
81111544:	4009883a 	mov	r4,r8
81111548:	111efa40 	call	8111efa4 <sprintf>
							debug(fp, cPUSDebug );
8111154c:	d0a06117 	ldw	r2,-32380(gp)
81111550:	e0ffdec4 	addi	r3,fp,-133
81111554:	180b883a 	mov	r5,r3
81111558:	1009883a 	mov	r4,r2
8111155c:	111d6140 	call	8111d614 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81111560:	00a04574 	movhi	r2,33045
81111564:	10be1504 	addi	r2,r2,-1964
81111568:	10c0030b 	ldhu	r3,12(r2)
8111156c:	00a04574 	movhi	r2,33045
81111570:	10be2804 	addi	r2,r2,-1888
81111574:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81111578:	00a04574 	movhi	r2,33045
8111157c:	10be1504 	addi	r2,r2,-1964
81111580:	10c0038b 	ldhu	r3,14(r2)
81111584:	00a04574 	movhi	r2,33045
81111588:	10be2804 	addi	r2,r2,-1888
8111158c:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81111590:	00a04574 	movhi	r2,33045
81111594:	10be1504 	addi	r2,r2,-1964
81111598:	10c0040b 	ldhu	r3,16(r2)
8111159c:	00a04574 	movhi	r2,33045
811115a0:	10be2804 	addi	r2,r2,-1888
811115a4:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
811115a8:	00a04574 	movhi	r2,33045
811115ac:	10be1504 	addi	r2,r2,-1964
811115b0:	10c0048b 	ldhu	r3,18(r2)
811115b4:	00a04574 	movhi	r2,33045
811115b8:	10be2804 	addi	r2,r2,-1888
811115bc:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
811115c0:	00a04574 	movhi	r2,33045
811115c4:	10be2804 	addi	r2,r2,-1888
811115c8:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
811115cc:	00800104 	movi	r2,4
811115d0:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
811115d4:	00000306 	br	811115e4 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
811115d8:	00800044 	movi	r2,1
811115dc:	e0bfdc15 	stw	r2,-144(fp)
						break;
811115e0:	0001883a 	nop
				}
				break;
811115e4:	0002db06 	br	81112154 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
811115e8:	00800044 	movi	r2,1
811115ec:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
811115f0:	00a04574 	movhi	r2,33045
811115f4:	10be2804 	addi	r2,r2,-1888
811115f8:	1080030b 	ldhu	r2,12(r2)
811115fc:	10bfffcc 	andi	r2,r2,65535
81111600:	10c01220 	cmpeqi	r3,r2,72
81111604:	1800051e 	bne	r3,zero,8111161c <vParserCommTask+0x2b4>
81111608:	108014e0 	cmpeqi	r2,r2,83
8111160c:	1000051e 	bne	r2,zero,81111624 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81111610:	00800044 	movi	r2,1
81111614:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81111618:	00000306 	br	81111628 <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
8111161c:	0001883a 	nop
81111620:	0002cc06 	br	81112154 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81111624:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81111628:	0002ca06 	br	81112154 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8111162c:	00800044 	movi	r2,1
81111630:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
81111634:	00a04574 	movhi	r2,33045
81111638:	10be2804 	addi	r2,r2,-1888
8111163c:	1080030b 	ldhu	r2,12(r2)
81111640:	10bfffcc 	andi	r2,r2,65535
81111644:	10c03ea0 	cmpeqi	r3,r2,250
81111648:	1800401e 	bne	r3,zero,8111174c <vParserCommTask+0x3e4>
8111164c:	10c03ec8 	cmpgei	r3,r2,251
81111650:	1800031e 	bne	r3,zero,81111660 <vParserCommTask+0x2f8>
81111654:	10800460 	cmpeqi	r2,r2,17
81111658:	1000061e 	bne	r2,zero,81111674 <vParserCommTask+0x30c>
8111165c:	0002b606 	br	81112138 <vParserCommTask+0xdd0>
81111660:	10c03ee0 	cmpeqi	r3,r2,251
81111664:	18009d1e 	bne	r3,zero,811118dc <vParserCommTask+0x574>
81111668:	10803f20 	cmpeqi	r2,r2,252
8111166c:	1001321e 	bne	r2,zero,81111b38 <vParserCommTask+0x7d0>
81111670:	0002b106 	br	81112138 <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
81111674:	00a04574 	movhi	r2,33045
81111678:	10be2804 	addi	r2,r2,-1888
8111167c:	1080038b 	ldhu	r2,14(r2)
81111680:	10bfffcc 	andi	r2,r2,65535
81111684:	10800060 	cmpeqi	r2,r2,1
81111688:	10000e26 	beq	r2,zero,811116c4 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
8111168c:	d0a06117 	ldw	r2,-32380(gp)
81111690:	100f883a 	mov	r7,r2
81111694:	01800944 	movi	r6,37
81111698:	01400044 	movi	r5,1
8111169c:	01204574 	movhi	r4,33045
811116a0:	21279904 	addi	r4,r4,-24988
811116a4:	111dcb00 	call	8111dcb0 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
811116a8:	00a04574 	movhi	r2,33045
811116ac:	10be2804 	addi	r2,r2,-1888
811116b0:	1080040b 	ldhu	r2,16(r2)
811116b4:	10bfffcc 	andi	r2,r2,65535
811116b8:	1009883a 	mov	r4,r2
811116bc:	11175d80 	call	811175d8 <vTMPusTestConnection>

								break;
811116c0:	00002106 	br	81111748 <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811116c4:	e0bfdec4 	addi	r2,fp,-133
811116c8:	01802004 	movi	r6,128
811116cc:	000b883a 	mov	r5,zero
811116d0:	1009883a 	mov	r4,r2
811116d4:	111e8140 	call	8111e814 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811116d8:	00a04574 	movhi	r2,33045
811116dc:	10be2804 	addi	r2,r2,-1888
811116e0:	1080030b 	ldhu	r2,12(r2)
811116e4:	113fffcc 	andi	r4,r2,65535
811116e8:	00a04574 	movhi	r2,33045
811116ec:	10be2804 	addi	r2,r2,-1888
811116f0:	1080038b 	ldhu	r2,14(r2)
811116f4:	117fffcc 	andi	r5,r2,65535
811116f8:	00a04574 	movhi	r2,33045
811116fc:	10be2804 	addi	r2,r2,-1888
81111700:	1080040b 	ldhu	r2,16(r2)
81111704:	10bfffcc 	andi	r2,r2,65535
81111708:	e0ffdec4 	addi	r3,fp,-133
8111170c:	d8800015 	stw	r2,0(sp)
81111710:	280f883a 	mov	r7,r5
81111714:	200d883a 	mov	r6,r4
81111718:	01604574 	movhi	r5,33045
8111171c:	2967a304 	addi	r5,r5,-24948
81111720:	1809883a 	mov	r4,r3
81111724:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81111728:	d0a06117 	ldw	r2,-32380(gp)
8111172c:	e0ffdec4 	addi	r3,fp,-133
81111730:	180b883a 	mov	r5,r3
81111734:	1009883a 	mov	r4,r2
81111738:	111d6140 	call	8111d614 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
8111173c:	00800044 	movi	r2,1
81111740:	e0bfdc15 	stw	r2,-144(fp)
								break;
81111744:	0001883a 	nop
						}
                        break;
81111748:	00027e06 	br	81112144 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
8111174c:	00a04574 	movhi	r2,33045
81111750:	10be2804 	addi	r2,r2,-1888
81111754:	1080038b 	ldhu	r2,14(r2)
81111758:	10bfffcc 	andi	r2,r2,65535
8111175c:	10c00f20 	cmpeqi	r3,r2,60
81111760:	18001a1e 	bne	r3,zero,811117cc <vParserCommTask+0x464>
81111764:	10c00f48 	cmpgei	r3,r2,61
81111768:	1800031e 	bne	r3,zero,81111778 <vParserCommTask+0x410>
8111176c:	10800ee0 	cmpeqi	r2,r2,59
81111770:	1000061e 	bne	r2,zero,8111178c <vParserCommTask+0x424>
81111774:	00003706 	br	81111854 <vParserCommTask+0x4ec>
81111778:	10c00f60 	cmpeqi	r3,r2,61
8111177c:	18001e1e 	bne	r3,zero,811117f8 <vParserCommTask+0x490>
81111780:	10800fa0 	cmpeqi	r2,r2,62
81111784:	1000271e 	bne	r2,zero,81111824 <vParserCommTask+0x4bc>
81111788:	00003206 	br	81111854 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
8111178c:	d0a06117 	ldw	r2,-32380(gp)
81111790:	100f883a 	mov	r7,r2
81111794:	018006c4 	movi	r6,27
81111798:	01400044 	movi	r5,1
8111179c:	01204574 	movhi	r4,33045
811117a0:	2127b604 	addi	r4,r4,-24872
811117a4:	111dcb00 	call	8111dcb0 <fwrite>
								#endif
								vSendReset();
811117a8:	1116f800 	call	81116f80 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
811117ac:	000f883a 	mov	r7,zero
811117b0:	018000c4 	movi	r6,3
811117b4:	000b883a 	mov	r5,zero
811117b8:	0009883a 	mov	r4,zero
811117bc:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
811117c0:	0104e204 	movi	r4,5000
811117c4:	110ba8c0 	call	8110ba8c <vRstcSimucamReset>

								break;
811117c8:	00004306 	br	811118d8 <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
811117cc:	d0a06117 	ldw	r2,-32380(gp)
811117d0:	100f883a 	mov	r7,r2
811117d4:	01800704 	movi	r6,28
811117d8:	01400044 	movi	r5,1
811117dc:	01204574 	movhi	r4,33045
811117e0:	2127bd04 	addi	r4,r4,-24844
811117e4:	111dcb00 	call	8111dcb0 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811117e8:	01204574 	movhi	r4,33045
811117ec:	213e2804 	addi	r4,r4,-1888
811117f0:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

								break;
811117f4:	00003806 	br	811118d8 <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
811117f8:	d0a06117 	ldw	r2,-32380(gp)
811117fc:	100f883a 	mov	r7,r2
81111800:	01800644 	movi	r6,25
81111804:	01400044 	movi	r5,1
81111808:	01204574 	movhi	r4,33045
8111180c:	2127c504 	addi	r4,r4,-24812
81111810:	111dcb00 	call	8111dcb0 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81111814:	01204574 	movhi	r4,33045
81111818:	213e2804 	addi	r4,r4,-1888
8111181c:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

								break;
81111820:	00002d06 	br	811118d8 <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81111824:	d0a06117 	ldw	r2,-32380(gp)
81111828:	100f883a 	mov	r7,r2
8111182c:	01800744 	movi	r6,29
81111830:	01400044 	movi	r5,1
81111834:	01204574 	movhi	r4,33045
81111838:	2127cc04 	addi	r4,r4,-24784
8111183c:	111dcb00 	call	8111dcb0 <fwrite>
								#endif
								vSendTurnOff();
81111840:	1116e680 	call	81116e68 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
81111844:	01204574 	movhi	r4,33045
81111848:	213e2804 	addi	r4,r4,-1888
8111184c:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

								break;
81111850:	00002106 	br	811118d8 <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81111854:	e0bfdec4 	addi	r2,fp,-133
81111858:	01802004 	movi	r6,128
8111185c:	000b883a 	mov	r5,zero
81111860:	1009883a 	mov	r4,r2
81111864:	111e8140 	call	8111e814 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81111868:	00a04574 	movhi	r2,33045
8111186c:	10be2804 	addi	r2,r2,-1888
81111870:	1080030b 	ldhu	r2,12(r2)
81111874:	113fffcc 	andi	r4,r2,65535
81111878:	00a04574 	movhi	r2,33045
8111187c:	10be2804 	addi	r2,r2,-1888
81111880:	1080038b 	ldhu	r2,14(r2)
81111884:	117fffcc 	andi	r5,r2,65535
81111888:	00a04574 	movhi	r2,33045
8111188c:	10be2804 	addi	r2,r2,-1888
81111890:	1080040b 	ldhu	r2,16(r2)
81111894:	10bfffcc 	andi	r2,r2,65535
81111898:	e0ffdec4 	addi	r3,fp,-133
8111189c:	d8800015 	stw	r2,0(sp)
811118a0:	280f883a 	mov	r7,r5
811118a4:	200d883a 	mov	r6,r4
811118a8:	01604574 	movhi	r5,33045
811118ac:	2967a304 	addi	r5,r5,-24948
811118b0:	1809883a 	mov	r4,r3
811118b4:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
811118b8:	d0a06117 	ldw	r2,-32380(gp)
811118bc:	e0ffdec4 	addi	r3,fp,-133
811118c0:	180b883a 	mov	r5,r3
811118c4:	1009883a 	mov	r4,r2
811118c8:	111d6140 	call	8111d614 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
811118cc:	00800044 	movi	r2,1
811118d0:	e0bfdc15 	stw	r2,-144(fp)
								break;
811118d4:	0001883a 	nop
						}
                        break;
811118d8:	00021a06 	br	81112144 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
811118dc:	00a04574 	movhi	r2,33045
811118e0:	10be1504 	addi	r2,r2,-1964
811118e4:	1080050b 	ldhu	r2,20(r2)
811118e8:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
811118ec:	e0bfde0b 	ldhu	r2,-136(fp)
811118f0:	108000b0 	cmpltui	r2,r2,2
811118f4:	1000121e 	bne	r2,zero,81111940 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
811118f8:	e0bfdec4 	addi	r2,fp,-133
811118fc:	01802004 	movi	r6,128
81111900:	000b883a 	mov	r5,zero
81111904:	1009883a 	mov	r4,r2
81111908:	111e8140 	call	8111e814 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
8111190c:	e0ffde0b 	ldhu	r3,-136(fp)
81111910:	e0bfdec4 	addi	r2,fp,-133
81111914:	180d883a 	mov	r6,r3
81111918:	01604574 	movhi	r5,33045
8111191c:	2967d404 	addi	r5,r5,-24752
81111920:	1009883a 	mov	r4,r2
81111924:	111efa40 	call	8111efa4 <sprintf>
								debug(fp, cPUSDebug );
81111928:	d0a06117 	ldw	r2,-32380(gp)
8111192c:	e0ffdec4 	addi	r3,fp,-133
81111930:	180b883a 	mov	r5,r3
81111934:	1009883a 	mov	r4,r2
81111938:	111d6140 	call	8111d614 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
8111193c:	00020106 	br	81112144 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81111940:	00a04574 	movhi	r2,33045
81111944:	10be2804 	addi	r2,r2,-1888
81111948:	10800483 	ldbu	r2,18(r2)
8111194c:	10c03fcc 	andi	r3,r2,255
81111950:	00a04574 	movhi	r2,33045
81111954:	10be2804 	addi	r2,r2,-1888
81111958:	18c00284 	addi	r3,r3,10
8111195c:	18c7883a 	add	r3,r3,r3
81111960:	10c5883a 	add	r2,r2,r3
81111964:	e0ffde0b 	ldhu	r3,-136(fp)
81111968:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
8111196c:	00a04574 	movhi	r2,33045
81111970:	10be2804 	addi	r2,r2,-1888
81111974:	10800483 	ldbu	r2,18(r2)
81111978:	10800044 	addi	r2,r2,1
8111197c:	1007883a 	mov	r3,r2
81111980:	00a04574 	movhi	r2,33045
81111984:	10be2804 	addi	r2,r2,-1888
81111988:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
8111198c:	00a04574 	movhi	r2,33045
81111990:	10be2804 	addi	r2,r2,-1888
81111994:	1080038b 	ldhu	r2,14(r2)
81111998:	10bfffcc 	andi	r2,r2,65535
8111199c:	10c000a0 	cmpeqi	r3,r2,2
811119a0:	1800191e 	bne	r3,zero,81111a08 <vParserCommTask+0x6a0>
811119a4:	10c00160 	cmpeqi	r3,r2,5
811119a8:	18002c1e 	bne	r3,zero,81111a5c <vParserCommTask+0x6f4>
811119ac:	10800060 	cmpeqi	r2,r2,1
811119b0:	10003f26 	beq	r2,zero,81111ab0 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
811119b4:	e0bfdec4 	addi	r2,fp,-133
811119b8:	01802004 	movi	r6,128
811119bc:	000b883a 	mov	r5,zero
811119c0:	1009883a 	mov	r4,r2
811119c4:	111e8140 	call	8111e814 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811119c8:	e0ffde0b 	ldhu	r3,-136(fp)
811119cc:	e0bfdec4 	addi	r2,fp,-133
811119d0:	180d883a 	mov	r6,r3
811119d4:	01604574 	movhi	r5,33045
811119d8:	2967e304 	addi	r5,r5,-24692
811119dc:	1009883a 	mov	r4,r2
811119e0:	111efa40 	call	8111efa4 <sprintf>
										debug(fp, cPUSDebug );
811119e4:	d0a06117 	ldw	r2,-32380(gp)
811119e8:	e0ffdec4 	addi	r3,fp,-133
811119ec:	180b883a 	mov	r5,r3
811119f0:	1009883a 	mov	r4,r2
811119f4:	111d6140 	call	8111d614 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
811119f8:	01204574 	movhi	r4,33045
811119fc:	213e2804 	addi	r4,r4,-1888
81111a00:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

									break;
81111a04:	00004b06 	br	81111b34 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81111a08:	e0bfdec4 	addi	r2,fp,-133
81111a0c:	01802004 	movi	r6,128
81111a10:	000b883a 	mov	r5,zero
81111a14:	1009883a 	mov	r4,r2
81111a18:	111e8140 	call	8111e814 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81111a1c:	e0ffde0b 	ldhu	r3,-136(fp)
81111a20:	e0bfdec4 	addi	r2,fp,-133
81111a24:	180d883a 	mov	r6,r3
81111a28:	01604574 	movhi	r5,33045
81111a2c:	2967f304 	addi	r5,r5,-24628
81111a30:	1009883a 	mov	r4,r2
81111a34:	111efa40 	call	8111efa4 <sprintf>
										debug(fp, cPUSDebug );
81111a38:	d0a06117 	ldw	r2,-32380(gp)
81111a3c:	e0ffdec4 	addi	r3,fp,-133
81111a40:	180b883a 	mov	r5,r3
81111a44:	1009883a 	mov	r4,r2
81111a48:	111d6140 	call	8111d614 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81111a4c:	01204574 	movhi	r4,33045
81111a50:	213e2804 	addi	r4,r4,-1888
81111a54:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

									break;
81111a58:	00003606 	br	81111b34 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81111a5c:	e0bfdec4 	addi	r2,fp,-133
81111a60:	01802004 	movi	r6,128
81111a64:	000b883a 	mov	r5,zero
81111a68:	1009883a 	mov	r4,r2
81111a6c:	111e8140 	call	8111e814 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81111a70:	e0ffde0b 	ldhu	r3,-136(fp)
81111a74:	e0bfdec4 	addi	r2,fp,-133
81111a78:	180d883a 	mov	r6,r3
81111a7c:	01604574 	movhi	r5,33045
81111a80:	29680304 	addi	r5,r5,-24564
81111a84:	1009883a 	mov	r4,r2
81111a88:	111efa40 	call	8111efa4 <sprintf>
										debug(fp, cPUSDebug );
81111a8c:	d0a06117 	ldw	r2,-32380(gp)
81111a90:	e0ffdec4 	addi	r3,fp,-133
81111a94:	180b883a 	mov	r5,r3
81111a98:	1009883a 	mov	r4,r2
81111a9c:	111d6140 	call	8111d614 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81111aa0:	01204574 	movhi	r4,33045
81111aa4:	213e2804 	addi	r4,r4,-1888
81111aa8:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

									break;
81111aac:	00002106 	br	81111b34 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81111ab0:	e0bfdec4 	addi	r2,fp,-133
81111ab4:	01802004 	movi	r6,128
81111ab8:	000b883a 	mov	r5,zero
81111abc:	1009883a 	mov	r4,r2
81111ac0:	111e8140 	call	8111e814 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81111ac4:	00a04574 	movhi	r2,33045
81111ac8:	10be2804 	addi	r2,r2,-1888
81111acc:	1080030b 	ldhu	r2,12(r2)
81111ad0:	113fffcc 	andi	r4,r2,65535
81111ad4:	00a04574 	movhi	r2,33045
81111ad8:	10be2804 	addi	r2,r2,-1888
81111adc:	1080038b 	ldhu	r2,14(r2)
81111ae0:	117fffcc 	andi	r5,r2,65535
81111ae4:	00a04574 	movhi	r2,33045
81111ae8:	10be2804 	addi	r2,r2,-1888
81111aec:	1080040b 	ldhu	r2,16(r2)
81111af0:	10bfffcc 	andi	r2,r2,65535
81111af4:	e0ffdec4 	addi	r3,fp,-133
81111af8:	d8800015 	stw	r2,0(sp)
81111afc:	280f883a 	mov	r7,r5
81111b00:	200d883a 	mov	r6,r4
81111b04:	01604574 	movhi	r5,33045
81111b08:	2967a304 	addi	r5,r5,-24948
81111b0c:	1809883a 	mov	r4,r3
81111b10:	111efa40 	call	8111efa4 <sprintf>
										debug(fp, cPUSDebug );
81111b14:	d0a06117 	ldw	r2,-32380(gp)
81111b18:	e0ffdec4 	addi	r3,fp,-133
81111b1c:	180b883a 	mov	r5,r3
81111b20:	1009883a 	mov	r4,r2
81111b24:	111d6140 	call	8111d614 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
81111b28:	00800044 	movi	r2,1
81111b2c:	e0bfdc15 	stw	r2,-144(fp)
									break;
81111b30:	0001883a 	nop
							}
						}
                        break;
81111b34:	00018306 	br	81112144 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81111b38:	00a04574 	movhi	r2,33045
81111b3c:	10be1504 	addi	r2,r2,-1964
81111b40:	1080050b 	ldhu	r2,20(r2)
81111b44:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81111b48:	00a04574 	movhi	r2,33045
81111b4c:	10be2804 	addi	r2,r2,-1888
81111b50:	10800483 	ldbu	r2,18(r2)
81111b54:	10c03fcc 	andi	r3,r2,255
81111b58:	00a04574 	movhi	r2,33045
81111b5c:	10be2804 	addi	r2,r2,-1888
81111b60:	18c00284 	addi	r3,r3,10
81111b64:	18c7883a 	add	r3,r3,r3
81111b68:	10c5883a 	add	r2,r2,r3
81111b6c:	e0ffde0b 	ldhu	r3,-136(fp)
81111b70:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
81111b74:	00a04574 	movhi	r2,33045
81111b78:	10be2804 	addi	r2,r2,-1888
81111b7c:	10800483 	ldbu	r2,18(r2)
81111b80:	10800044 	addi	r2,r2,1
81111b84:	1007883a 	mov	r3,r2
81111b88:	00a04574 	movhi	r2,33045
81111b8c:	10be2804 	addi	r2,r2,-1888
81111b90:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
81111b94:	00a04574 	movhi	r2,33045
81111b98:	10be2804 	addi	r2,r2,-1888
81111b9c:	1080038b 	ldhu	r2,14(r2)
81111ba0:	10bfffcc 	andi	r2,r2,65535
81111ba4:	10c000e0 	cmpeqi	r3,r2,3
81111ba8:	18000a1e 	bne	r3,zero,81111bd4 <vParserCommTask+0x86c>
81111bac:	10c00108 	cmpgei	r3,r2,4
81111bb0:	1800031e 	bne	r3,zero,81111bc0 <vParserCommTask+0x858>
81111bb4:	108000a0 	cmpeqi	r2,r2,2
81111bb8:	1000451e 	bne	r2,zero,81111cd0 <vParserCommTask+0x968>
81111bbc:	00013c06 	br	811120b0 <vParserCommTask+0xd48>
81111bc0:	10c00120 	cmpeqi	r3,r2,4
81111bc4:	1800181e 	bne	r3,zero,81111c28 <vParserCommTask+0x8c0>
81111bc8:	10800160 	cmpeqi	r2,r2,5
81111bcc:	10002b1e 	bne	r2,zero,81111c7c <vParserCommTask+0x914>
81111bd0:	00013706 	br	811120b0 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81111bd4:	e0bfdec4 	addi	r2,fp,-133
81111bd8:	01802004 	movi	r6,128
81111bdc:	000b883a 	mov	r5,zero
81111be0:	1009883a 	mov	r4,r2
81111be4:	111e8140 	call	8111e814 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81111be8:	e0ffde0b 	ldhu	r3,-136(fp)
81111bec:	e0bfdec4 	addi	r2,fp,-133
81111bf0:	180d883a 	mov	r6,r3
81111bf4:	01604574 	movhi	r5,33045
81111bf8:	29681504 	addi	r5,r5,-24492
81111bfc:	1009883a 	mov	r4,r2
81111c00:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81111c04:	d0a06117 	ldw	r2,-32380(gp)
81111c08:	e0ffdec4 	addi	r3,fp,-133
81111c0c:	180b883a 	mov	r5,r3
81111c10:	1009883a 	mov	r4,r2
81111c14:	111d6140 	call	8111d614 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81111c18:	01204574 	movhi	r4,33045
81111c1c:	213e2804 	addi	r4,r4,-1888
81111c20:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

								break;
81111c24:	00014306 	br	81112134 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81111c28:	e0bfdec4 	addi	r2,fp,-133
81111c2c:	01802004 	movi	r6,128
81111c30:	000b883a 	mov	r5,zero
81111c34:	1009883a 	mov	r4,r2
81111c38:	111e8140 	call	8111e814 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81111c3c:	e0ffde0b 	ldhu	r3,-136(fp)
81111c40:	e0bfdec4 	addi	r2,fp,-133
81111c44:	180d883a 	mov	r6,r3
81111c48:	01604574 	movhi	r5,33045
81111c4c:	29682504 	addi	r5,r5,-24428
81111c50:	1009883a 	mov	r4,r2
81111c54:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81111c58:	d0a06117 	ldw	r2,-32380(gp)
81111c5c:	e0ffdec4 	addi	r3,fp,-133
81111c60:	180b883a 	mov	r5,r3
81111c64:	1009883a 	mov	r4,r2
81111c68:	111d6140 	call	8111d614 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81111c6c:	01204574 	movhi	r4,33045
81111c70:	213e2804 	addi	r4,r4,-1888
81111c74:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

								break;
81111c78:	00012e06 	br	81112134 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81111c7c:	e0bfdec4 	addi	r2,fp,-133
81111c80:	01802004 	movi	r6,128
81111c84:	000b883a 	mov	r5,zero
81111c88:	1009883a 	mov	r4,r2
81111c8c:	111e8140 	call	8111e814 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81111c90:	e0ffde0b 	ldhu	r3,-136(fp)
81111c94:	e0bfdec4 	addi	r2,fp,-133
81111c98:	180d883a 	mov	r6,r3
81111c9c:	01604574 	movhi	r5,33045
81111ca0:	29683504 	addi	r5,r5,-24364
81111ca4:	1009883a 	mov	r4,r2
81111ca8:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81111cac:	d0a06117 	ldw	r2,-32380(gp)
81111cb0:	e0ffdec4 	addi	r3,fp,-133
81111cb4:	180b883a 	mov	r5,r3
81111cb8:	1009883a 	mov	r4,r2
81111cbc:	111d6140 	call	8111d614 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81111cc0:	01204574 	movhi	r4,33045
81111cc4:	213e2804 	addi	r4,r4,-1888
81111cc8:	11122700 	call	81112270 <bSendMessagePUStoMebTask>

								break;
81111ccc:	00011906 	br	81112134 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81111cd0:	00a04574 	movhi	r2,33045
81111cd4:	10be2804 	addi	r2,r2,-1888
81111cd8:	10800483 	ldbu	r2,18(r2)
81111cdc:	10c03fcc 	andi	r3,r2,255
81111ce0:	00a04574 	movhi	r2,33045
81111ce4:	10be1504 	addi	r2,r2,-1964
81111ce8:	1100058b 	ldhu	r4,22(r2)
81111cec:	00a04574 	movhi	r2,33045
81111cf0:	10be2804 	addi	r2,r2,-1888
81111cf4:	18c00284 	addi	r3,r3,10
81111cf8:	18c7883a 	add	r3,r3,r3
81111cfc:	10c5883a 	add	r2,r2,r3
81111d00:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111d04:	00a04574 	movhi	r2,33045
81111d08:	10be2804 	addi	r2,r2,-1888
81111d0c:	10800483 	ldbu	r2,18(r2)
81111d10:	10800044 	addi	r2,r2,1
81111d14:	1007883a 	mov	r3,r2
81111d18:	00a04574 	movhi	r2,33045
81111d1c:	10be2804 	addi	r2,r2,-1888
81111d20:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
81111d24:	00a04574 	movhi	r2,33045
81111d28:	10be2804 	addi	r2,r2,-1888
81111d2c:	10800483 	ldbu	r2,18(r2)
81111d30:	10c03fcc 	andi	r3,r2,255
81111d34:	00a04574 	movhi	r2,33045
81111d38:	10be1504 	addi	r2,r2,-1964
81111d3c:	1100060b 	ldhu	r4,24(r2)
81111d40:	00a04574 	movhi	r2,33045
81111d44:	10be2804 	addi	r2,r2,-1888
81111d48:	18c00284 	addi	r3,r3,10
81111d4c:	18c7883a 	add	r3,r3,r3
81111d50:	10c5883a 	add	r2,r2,r3
81111d54:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111d58:	00a04574 	movhi	r2,33045
81111d5c:	10be2804 	addi	r2,r2,-1888
81111d60:	10800483 	ldbu	r2,18(r2)
81111d64:	10800044 	addi	r2,r2,1
81111d68:	1007883a 	mov	r3,r2
81111d6c:	00a04574 	movhi	r2,33045
81111d70:	10be2804 	addi	r2,r2,-1888
81111d74:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81111d78:	00a04574 	movhi	r2,33045
81111d7c:	10be2804 	addi	r2,r2,-1888
81111d80:	10800483 	ldbu	r2,18(r2)
81111d84:	10c03fcc 	andi	r3,r2,255
81111d88:	00a04574 	movhi	r2,33045
81111d8c:	10be1504 	addi	r2,r2,-1964
81111d90:	1100068b 	ldhu	r4,26(r2)
81111d94:	00a04574 	movhi	r2,33045
81111d98:	10be2804 	addi	r2,r2,-1888
81111d9c:	18c00284 	addi	r3,r3,10
81111da0:	18c7883a 	add	r3,r3,r3
81111da4:	10c5883a 	add	r2,r2,r3
81111da8:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111dac:	00a04574 	movhi	r2,33045
81111db0:	10be2804 	addi	r2,r2,-1888
81111db4:	10800483 	ldbu	r2,18(r2)
81111db8:	10800044 	addi	r2,r2,1
81111dbc:	1007883a 	mov	r3,r2
81111dc0:	00a04574 	movhi	r2,33045
81111dc4:	10be2804 	addi	r2,r2,-1888
81111dc8:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
81111dcc:	00a04574 	movhi	r2,33045
81111dd0:	10be2804 	addi	r2,r2,-1888
81111dd4:	10800483 	ldbu	r2,18(r2)
81111dd8:	10c03fcc 	andi	r3,r2,255
81111ddc:	00a04574 	movhi	r2,33045
81111de0:	10be1504 	addi	r2,r2,-1964
81111de4:	1100070b 	ldhu	r4,28(r2)
81111de8:	00a04574 	movhi	r2,33045
81111dec:	10be2804 	addi	r2,r2,-1888
81111df0:	18c00284 	addi	r3,r3,10
81111df4:	18c7883a 	add	r3,r3,r3
81111df8:	10c5883a 	add	r2,r2,r3
81111dfc:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111e00:	00a04574 	movhi	r2,33045
81111e04:	10be2804 	addi	r2,r2,-1888
81111e08:	10800483 	ldbu	r2,18(r2)
81111e0c:	10800044 	addi	r2,r2,1
81111e10:	1007883a 	mov	r3,r2
81111e14:	00a04574 	movhi	r2,33045
81111e18:	10be2804 	addi	r2,r2,-1888
81111e1c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81111e20:	00a04574 	movhi	r2,33045
81111e24:	10be2804 	addi	r2,r2,-1888
81111e28:	10800483 	ldbu	r2,18(r2)
81111e2c:	10c03fcc 	andi	r3,r2,255
81111e30:	00a04574 	movhi	r2,33045
81111e34:	10be1504 	addi	r2,r2,-1964
81111e38:	1100078b 	ldhu	r4,30(r2)
81111e3c:	00a04574 	movhi	r2,33045
81111e40:	10be2804 	addi	r2,r2,-1888
81111e44:	18c00284 	addi	r3,r3,10
81111e48:	18c7883a 	add	r3,r3,r3
81111e4c:	10c5883a 	add	r2,r2,r3
81111e50:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111e54:	00a04574 	movhi	r2,33045
81111e58:	10be2804 	addi	r2,r2,-1888
81111e5c:	10800483 	ldbu	r2,18(r2)
81111e60:	10800044 	addi	r2,r2,1
81111e64:	1007883a 	mov	r3,r2
81111e68:	00a04574 	movhi	r2,33045
81111e6c:	10be2804 	addi	r2,r2,-1888
81111e70:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81111e74:	00a04574 	movhi	r2,33045
81111e78:	10be2804 	addi	r2,r2,-1888
81111e7c:	10800483 	ldbu	r2,18(r2)
81111e80:	10c03fcc 	andi	r3,r2,255
81111e84:	00a04574 	movhi	r2,33045
81111e88:	10be1504 	addi	r2,r2,-1964
81111e8c:	1100080b 	ldhu	r4,32(r2)
81111e90:	00a04574 	movhi	r2,33045
81111e94:	10be2804 	addi	r2,r2,-1888
81111e98:	18c00284 	addi	r3,r3,10
81111e9c:	18c7883a 	add	r3,r3,r3
81111ea0:	10c5883a 	add	r2,r2,r3
81111ea4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111ea8:	00a04574 	movhi	r2,33045
81111eac:	10be2804 	addi	r2,r2,-1888
81111eb0:	10800483 	ldbu	r2,18(r2)
81111eb4:	10800044 	addi	r2,r2,1
81111eb8:	1007883a 	mov	r3,r2
81111ebc:	00a04574 	movhi	r2,33045
81111ec0:	10be2804 	addi	r2,r2,-1888
81111ec4:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81111ec8:	e0bfdec4 	addi	r2,fp,-133
81111ecc:	01802004 	movi	r6,128
81111ed0:	000b883a 	mov	r5,zero
81111ed4:	1009883a 	mov	r4,r2
81111ed8:	111e8140 	call	8111e814 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81111edc:	e0ffdec4 	addi	r3,fp,-133
81111ee0:	00a04574 	movhi	r2,33045
81111ee4:	10a84404 	addi	r2,r2,-24304
81111ee8:	1009883a 	mov	r4,r2
81111eec:	00800b84 	movi	r2,46
81111ef0:	100d883a 	mov	r6,r2
81111ef4:	200b883a 	mov	r5,r4
81111ef8:	1809883a 	mov	r4,r3
81111efc:	111e6c40 	call	8111e6c4 <memcpy>
									debug(fp, cPUSDebug );
81111f00:	d0a06117 	ldw	r2,-32380(gp)
81111f04:	e0ffdec4 	addi	r3,fp,-133
81111f08:	180b883a 	mov	r5,r3
81111f0c:	1009883a 	mov	r4,r2
81111f10:	111d6140 	call	8111d614 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81111f14:	e0ffde0b 	ldhu	r3,-136(fp)
81111f18:	e0bfdec4 	addi	r2,fp,-133
81111f1c:	180d883a 	mov	r6,r3
81111f20:	01604574 	movhi	r5,33045
81111f24:	29685004 	addi	r5,r5,-24256
81111f28:	1009883a 	mov	r4,r2
81111f2c:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81111f30:	d0a06117 	ldw	r2,-32380(gp)
81111f34:	e0ffdec4 	addi	r3,fp,-133
81111f38:	180b883a 	mov	r5,r3
81111f3c:	1009883a 	mov	r4,r2
81111f40:	111d6140 	call	8111d614 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81111f44:	00a04574 	movhi	r2,33045
81111f48:	10be1504 	addi	r2,r2,-1964
81111f4c:	1080058b 	ldhu	r2,22(r2)
81111f50:	10ffffcc 	andi	r3,r2,65535
81111f54:	e0bfdec4 	addi	r2,fp,-133
81111f58:	180d883a 	mov	r6,r3
81111f5c:	01604574 	movhi	r5,33045
81111f60:	29685704 	addi	r5,r5,-24228
81111f64:	1009883a 	mov	r4,r2
81111f68:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81111f6c:	d0a06117 	ldw	r2,-32380(gp)
81111f70:	e0ffdec4 	addi	r3,fp,-133
81111f74:	180b883a 	mov	r5,r3
81111f78:	1009883a 	mov	r4,r2
81111f7c:	111d6140 	call	8111d614 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81111f80:	00a04574 	movhi	r2,33045
81111f84:	10be1504 	addi	r2,r2,-1964
81111f88:	1080060b 	ldhu	r2,24(r2)
81111f8c:	10ffffcc 	andi	r3,r2,65535
81111f90:	e0bfdec4 	addi	r2,fp,-133
81111f94:	180d883a 	mov	r6,r3
81111f98:	01604574 	movhi	r5,33045
81111f9c:	29685b04 	addi	r5,r5,-24212
81111fa0:	1009883a 	mov	r4,r2
81111fa4:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81111fa8:	d0a06117 	ldw	r2,-32380(gp)
81111fac:	e0ffdec4 	addi	r3,fp,-133
81111fb0:	180b883a 	mov	r5,r3
81111fb4:	1009883a 	mov	r4,r2
81111fb8:	111d6140 	call	8111d614 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81111fbc:	00a04574 	movhi	r2,33045
81111fc0:	10be1504 	addi	r2,r2,-1964
81111fc4:	1080068b 	ldhu	r2,26(r2)
81111fc8:	10ffffcc 	andi	r3,r2,65535
81111fcc:	e0bfdec4 	addi	r2,fp,-133
81111fd0:	180d883a 	mov	r6,r3
81111fd4:	01604574 	movhi	r5,33045
81111fd8:	29686004 	addi	r5,r5,-24192
81111fdc:	1009883a 	mov	r4,r2
81111fe0:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81111fe4:	d0a06117 	ldw	r2,-32380(gp)
81111fe8:	e0ffdec4 	addi	r3,fp,-133
81111fec:	180b883a 	mov	r5,r3
81111ff0:	1009883a 	mov	r4,r2
81111ff4:	111d6140 	call	8111d614 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81111ff8:	00a04574 	movhi	r2,33045
81111ffc:	10be1504 	addi	r2,r2,-1964
81112000:	1080070b 	ldhu	r2,28(r2)
81112004:	10ffffcc 	andi	r3,r2,65535
81112008:	e0bfdec4 	addi	r2,fp,-133
8111200c:	180d883a 	mov	r6,r3
81112010:	01604574 	movhi	r5,33045
81112014:	29686704 	addi	r5,r5,-24164
81112018:	1009883a 	mov	r4,r2
8111201c:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81112020:	d0a06117 	ldw	r2,-32380(gp)
81112024:	e0ffdec4 	addi	r3,fp,-133
81112028:	180b883a 	mov	r5,r3
8111202c:	1009883a 	mov	r4,r2
81112030:	111d6140 	call	8111d614 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81112034:	00a04574 	movhi	r2,33045
81112038:	10be1504 	addi	r2,r2,-1964
8111203c:	1080078b 	ldhu	r2,30(r2)
81112040:	10ffffcc 	andi	r3,r2,65535
81112044:	e0bfdec4 	addi	r2,fp,-133
81112048:	180d883a 	mov	r6,r3
8111204c:	01604574 	movhi	r5,33045
81112050:	29686e04 	addi	r5,r5,-24136
81112054:	1009883a 	mov	r4,r2
81112058:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
8111205c:	d0a06117 	ldw	r2,-32380(gp)
81112060:	e0ffdec4 	addi	r3,fp,-133
81112064:	180b883a 	mov	r5,r3
81112068:	1009883a 	mov	r4,r2
8111206c:	111d6140 	call	8111d614 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81112070:	00a04574 	movhi	r2,33045
81112074:	10be1504 	addi	r2,r2,-1964
81112078:	1080080b 	ldhu	r2,32(r2)
8111207c:	10ffffcc 	andi	r3,r2,65535
81112080:	e0bfdec4 	addi	r2,fp,-133
81112084:	180d883a 	mov	r6,r3
81112088:	01604574 	movhi	r5,33045
8111208c:	29687404 	addi	r5,r5,-24112
81112090:	1009883a 	mov	r4,r2
81112094:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81112098:	d0a06117 	ldw	r2,-32380(gp)
8111209c:	e0ffdec4 	addi	r3,fp,-133
811120a0:	180b883a 	mov	r5,r3
811120a4:	1009883a 	mov	r4,r2
811120a8:	111d6140 	call	8111d614 <fprintf>
								#endif

								break;
811120ac:	00002106 	br	81112134 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811120b0:	e0bfdec4 	addi	r2,fp,-133
811120b4:	01802004 	movi	r6,128
811120b8:	000b883a 	mov	r5,zero
811120bc:	1009883a 	mov	r4,r2
811120c0:	111e8140 	call	8111e814 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811120c4:	00a04574 	movhi	r2,33045
811120c8:	10be2804 	addi	r2,r2,-1888
811120cc:	1080030b 	ldhu	r2,12(r2)
811120d0:	113fffcc 	andi	r4,r2,65535
811120d4:	00a04574 	movhi	r2,33045
811120d8:	10be2804 	addi	r2,r2,-1888
811120dc:	1080038b 	ldhu	r2,14(r2)
811120e0:	117fffcc 	andi	r5,r2,65535
811120e4:	00a04574 	movhi	r2,33045
811120e8:	10be2804 	addi	r2,r2,-1888
811120ec:	1080040b 	ldhu	r2,16(r2)
811120f0:	10bfffcc 	andi	r2,r2,65535
811120f4:	e0ffdec4 	addi	r3,fp,-133
811120f8:	d8800015 	stw	r2,0(sp)
811120fc:	280f883a 	mov	r7,r5
81112100:	200d883a 	mov	r6,r4
81112104:	01604574 	movhi	r5,33045
81112108:	2967a304 	addi	r5,r5,-24948
8111210c:	1809883a 	mov	r4,r3
81112110:	111efa40 	call	8111efa4 <sprintf>
									debug(fp, cPUSDebug );
81112114:	d0a06117 	ldw	r2,-32380(gp)
81112118:	e0ffdec4 	addi	r3,fp,-133
8111211c:	180b883a 	mov	r5,r3
81112120:	1009883a 	mov	r4,r2
81112124:	111d6140 	call	8111d614 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81112128:	00800044 	movi	r2,1
8111212c:	e0bfdc15 	stw	r2,-144(fp)
								break;
81112130:	0001883a 	nop
						}
                        break;
81112134:	00000306 	br	81112144 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
81112138:	00800044 	movi	r2,1
8111213c:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81112140:	0001883a 	nop
                }
				break;				
81112144:	00000306 	br	81112154 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
81112148:	00800044 	movi	r2,1
8111214c:	e0bfdc15 	stw	r2,-144(fp)
				break;
81112150:	0001883a 	nop
		}
	}
81112154:	003c9406 	br	811113a8 <__reset+0xfb0f13a8>

81112158 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81112158:	defffb04 	addi	sp,sp,-20
8111215c:	de00012e 	bgeu	sp,et,81112164 <getPreParsedPacket+0xc>
81112160:	003b68fa 	trap	3
81112164:	dfc00415 	stw	ra,16(sp)
81112168:	df000315 	stw	fp,12(sp)
8111216c:	df000304 	addi	fp,sp,12
81112170:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81112174:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81112178:	d0a06a17 	ldw	r2,-32344(gp)
8111217c:	e0fffe44 	addi	r3,fp,-7
81112180:	180d883a 	mov	r6,r3
81112184:	000b883a 	mov	r5,zero
81112188:	1009883a 	mov	r4,r2
8111218c:	11396e40 	call	811396e4 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81112190:	e0bffe43 	ldbu	r2,-7(fp)
81112194:	10803fcc 	andi	r2,r2,255
81112198:	10002e1e 	bne	r2,zero,81112254 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8111219c:	e03ffe05 	stb	zero,-8(fp)
811121a0:	00002506 	br	81112238 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
811121a4:	e0fffe03 	ldbu	r3,-8(fp)
811121a8:	00a045b4 	movhi	r2,33046
811121ac:	108bb104 	addi	r2,r2,11972
811121b0:	18c01324 	muli	r3,r3,76
811121b4:	10c5883a 	add	r2,r2,r3
811121b8:	10800104 	addi	r2,r2,4
811121bc:	10800003 	ldbu	r2,0(r2)
811121c0:	10803fcc 	andi	r2,r2,255
811121c4:	1080201c 	xori	r2,r2,128
811121c8:	10bfe004 	addi	r2,r2,-128
811121cc:	10001726 	beq	r2,zero,8111222c <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
811121d0:	e0fffe03 	ldbu	r3,-8(fp)
811121d4:	e13fff17 	ldw	r4,-4(fp)
811121d8:	00a045b4 	movhi	r2,33046
811121dc:	108bb104 	addi	r2,r2,11972
811121e0:	18c01324 	muli	r3,r3,76
811121e4:	10c5883a 	add	r2,r2,r3
811121e8:	2007883a 	mov	r3,r4
811121ec:	1009883a 	mov	r4,r2
811121f0:	00801304 	movi	r2,76
811121f4:	100d883a 	mov	r6,r2
811121f8:	200b883a 	mov	r5,r4
811121fc:	1809883a 	mov	r4,r3
81112200:	111e6c40 	call	8111e6c4 <memcpy>
                bSuccess = TRUE;
81112204:	00800044 	movi	r2,1
81112208:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
8111220c:	e0fffe03 	ldbu	r3,-8(fp)
81112210:	00a045b4 	movhi	r2,33046
81112214:	108bb104 	addi	r2,r2,11972
81112218:	18c01324 	muli	r3,r3,76
8111221c:	10c5883a 	add	r2,r2,r3
81112220:	10800104 	addi	r2,r2,4
81112224:	10000005 	stb	zero,0(r2)
                break;
81112228:	00000606 	br	81112244 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8111222c:	e0bffe03 	ldbu	r2,-8(fp)
81112230:	10800044 	addi	r2,r2,1
81112234:	e0bffe05 	stb	r2,-8(fp)
81112238:	e0bffe03 	ldbu	r2,-8(fp)
8111223c:	10800230 	cmpltui	r2,r2,8
81112240:	103fd81e 	bne	r2,zero,811121a4 <__reset+0xfb0f21a4>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81112244:	d0a06a17 	ldw	r2,-32344(gp)
81112248:	1009883a 	mov	r4,r2
8111224c:	1139c880 	call	81139c88 <OSMutexPost>
81112250:	00000106 	br	81112258 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81112254:	1118f080 	call	81118f08 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81112258:	e0bffd17 	ldw	r2,-12(fp)
}
8111225c:	e037883a 	mov	sp,fp
81112260:	dfc00117 	ldw	ra,4(sp)
81112264:	df000017 	ldw	fp,0(sp)
81112268:	dec00204 	addi	sp,sp,8
8111226c:	f800283a 	ret

81112270 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81112270:	defffa04 	addi	sp,sp,-24
81112274:	de00012e 	bgeu	sp,et,8111227c <bSendMessagePUStoMebTask+0xc>
81112278:	003b68fa 	trap	3
8111227c:	dfc00515 	stw	ra,20(sp)
81112280:	df000415 	stw	fp,16(sp)
81112284:	df000404 	addi	fp,sp,16
81112288:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111228c:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81112290:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
81112294:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
81112298:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
8111229c:	d0a07217 	ldw	r2,-32312(gp)
811122a0:	e0fffd44 	addi	r3,fp,-11
811122a4:	180d883a 	mov	r6,r3
811122a8:	01400284 	movi	r5,10
811122ac:	1009883a 	mov	r4,r2
811122b0:	11396e40 	call	811396e4 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811122b4:	e0bffd43 	ldbu	r2,-11(fp)
811122b8:	10803fcc 	andi	r2,r2,255
811122bc:	1000401e 	bne	r2,zero,811123c0 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
811122c0:	e03ffd05 	stb	zero,-12(fp)
811122c4:	00003806 	br	811123a8 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
811122c8:	e0fffd03 	ldbu	r3,-12(fp)
811122cc:	00a04574 	movhi	r2,33045
811122d0:	1088d304 	addi	r2,r2,9036
811122d4:	18c01524 	muli	r3,r3,84
811122d8:	10c5883a 	add	r2,r2,r3
811122dc:	10800104 	addi	r2,r2,4
811122e0:	10800017 	ldw	r2,0(r2)
811122e4:	10002d1e 	bne	r2,zero,8111239c <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
811122e8:	e0fffd03 	ldbu	r3,-12(fp)
811122ec:	00a04574 	movhi	r2,33045
811122f0:	1088d304 	addi	r2,r2,9036
811122f4:	18c01524 	muli	r3,r3,84
811122f8:	10c7883a 	add	r3,r2,r3
811122fc:	e0bfff17 	ldw	r2,-4(fp)
81112300:	1009883a 	mov	r4,r2
81112304:	00801504 	movi	r2,84
81112308:	100d883a 	mov	r6,r2
8111230c:	200b883a 	mov	r5,r4
81112310:	1809883a 	mov	r4,r3
81112314:	111e6c40 	call	8111e6c4 <memcpy>
            	xPus[i].bInUse = TRUE;
81112318:	e0fffd03 	ldbu	r3,-12(fp)
8111231c:	00a04574 	movhi	r2,33045
81112320:	1088d304 	addi	r2,r2,9036
81112324:	18c01524 	muli	r3,r3,84
81112328:	10c5883a 	add	r2,r2,r3
8111232c:	10800104 	addi	r2,r2,4
81112330:	00c00044 	movi	r3,1
81112334:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81112338:	00800044 	movi	r2,1
8111233c:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81112340:	00800044 	movi	r2,1
81112344:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81112348:	d0a06817 	ldw	r2,-32352(gp)
8111234c:	e0fffe17 	ldw	r3,-8(fp)
81112350:	180b883a 	mov	r5,r3
81112354:	1009883a 	mov	r4,r2
81112358:	113ac000 	call	8113ac00 <OSQPost>
8111235c:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81112360:	e0bffd43 	ldbu	r2,-11(fp)
81112364:	10803fcc 	andi	r2,r2,255
81112368:	10000926 	beq	r2,zero,81112390 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
8111236c:	1119df80 	call	81119df8 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81112370:	e0fffd03 	ldbu	r3,-12(fp)
81112374:	00a04574 	movhi	r2,33045
81112378:	1088d304 	addi	r2,r2,9036
8111237c:	18c01524 	muli	r3,r3,84
81112380:	10c5883a 	add	r2,r2,r3
81112384:	10800104 	addi	r2,r2,4
81112388:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
8111238c:	00000906 	br	811123b4 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81112390:	00800044 	movi	r2,1
81112394:	e0bffc15 	stw	r2,-16(fp)
                break;
81112398:	00000606 	br	811123b4 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
8111239c:	e0bffd03 	ldbu	r2,-12(fp)
811123a0:	10800044 	addi	r2,r2,1
811123a4:	e0bffd05 	stb	r2,-12(fp)
811123a8:	e0bffd03 	ldbu	r2,-12(fp)
811123ac:	10800130 	cmpltui	r2,r2,4
811123b0:	103fc51e 	bne	r2,zero,811122c8 <__reset+0xfb0f22c8>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
811123b4:	d0a07217 	ldw	r2,-32312(gp)
811123b8:	1009883a 	mov	r4,r2
811123bc:	1139c880 	call	81139c88 <OSMutexPost>
    }

    return bSuccess;
811123c0:	e0bffc17 	ldw	r2,-16(fp)
}
811123c4:	e037883a 	mov	sp,fp
811123c8:	dfc00117 	ldw	ra,4(sp)
811123cc:	df000017 	ldw	fp,0(sp)
811123d0:	dec00204 	addi	sp,sp,8
811123d4:	f800283a 	ret

811123d8 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
811123d8:	deffab04 	addi	sp,sp,-340
811123dc:	de00012e 	bgeu	sp,et,811123e4 <vReceiverUartTask+0xc>
811123e0:	003b68fa 	trap	3
811123e4:	dfc05415 	stw	ra,336(sp)
811123e8:	df005315 	stw	fp,332(sp)
811123ec:	df005304 	addi	fp,sp,332
811123f0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811123f4:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
811123f8:	d0a06117 	ldw	r2,-32380(gp)
811123fc:	100f883a 	mov	r7,r2
81112400:	01800784 	movi	r6,30
81112404:	01400044 	movi	r5,1
81112408:	01204574 	movhi	r4,33045
8111240c:	21287a04 	addi	r4,r4,-24088
81112410:	111dcb00 	call	8111dcb0 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
81112414:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81112418:	e0bfad17 	ldw	r2,-332(fp)
8111241c:	10c00060 	cmpeqi	r3,r2,1
81112420:	1800091e 	bne	r3,zero,81112448 <vReceiverUartTask+0x70>
81112424:	0080052e 	bgeu	zero,r2,8111243c <vReceiverUartTask+0x64>
81112428:	10c000a0 	cmpeqi	r3,r2,2
8111242c:	18005d1e 	bne	r3,zero,811125a4 <vReceiverUartTask+0x1cc>
81112430:	108000e0 	cmpeqi	r2,r2,3
81112434:	10006e1e 	bne	r2,zero,811125f0 <vReceiverUartTask+0x218>
81112438:	00007706 	br	81112618 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
8111243c:	00800044 	movi	r2,1
81112440:	e0bfad15 	stw	r2,-332(fp)
                break;
81112444:	00007706 	br	81112624 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81112448:	e0bfaf04 	addi	r2,fp,-324
8111244c:	01802004 	movi	r6,128
81112450:	000b883a 	mov	r5,zero
81112454:	1009883a 	mov	r4,r2
81112458:	111e8140 	call	8111e814 <memset>
                scanf("%s", cReceive);
8111245c:	e0bfcf04 	addi	r2,fp,-196
81112460:	100b883a 	mov	r5,r2
81112464:	01204574 	movhi	r4,33045
81112468:	21288204 	addi	r4,r4,-24056
8111246c:	111eec80 	call	8111eec8 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81112470:	e0ffcf04 	addi	r3,fp,-196
81112474:	e0bfaf04 	addi	r2,fp,-324
81112478:	01801fc4 	movi	r6,127
8111247c:	180b883a 	mov	r5,r3
81112480:	1009883a 	mov	r4,r2
81112484:	111e6c40 	call	8111e6c4 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81112488:	e0bfaf04 	addi	r2,fp,-324
8111248c:	01604574 	movhi	r5,33045
81112490:	297e3d04 	addi	r5,r5,-1804
81112494:	1009883a 	mov	r4,r2
81112498:	1112a7c0 	call	81112a7c <bPreParserV2>
8111249c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
811124a0:	e0bfae17 	ldw	r2,-328(fp)
811124a4:	10800058 	cmpnei	r2,r2,1
811124a8:	1000281e 	bne	r2,zero,8111254c <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
811124ac:	00a04574 	movhi	r2,33045
811124b0:	10be3d04 	addi	r2,r2,-1804
811124b4:	10800103 	ldbu	r2,4(r2)
811124b8:	10803fcc 	andi	r2,r2,255
811124bc:	1080201c 	xori	r2,r2,128
811124c0:	10bfe004 	addi	r2,r2,-128
811124c4:	10800fe0 	cmpeqi	r2,r2,63
811124c8:	1000081e 	bne	r2,zero,811124ec <vReceiverUartTask+0x114>
811124cc:	00a04574 	movhi	r2,33045
811124d0:	10be3d04 	addi	r2,r2,-1804
811124d4:	10800103 	ldbu	r2,4(r2)
811124d8:	10803fcc 	andi	r2,r2,255
811124dc:	1080201c 	xori	r2,r2,128
811124e0:	10bfe004 	addi	r2,r2,-128
811124e4:	10800858 	cmpnei	r2,r2,33
811124e8:	1000031e 	bne	r2,zero,811124f8 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
811124ec:	00800084 	movi	r2,2
811124f0:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811124f4:	00004b06 	br	81112624 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
811124f8:	00a04574 	movhi	r2,33045
811124fc:	10be3d04 	addi	r2,r2,-1804
81112500:	10800103 	ldbu	r2,4(r2)
81112504:	10803fcc 	andi	r2,r2,255
81112508:	1080201c 	xori	r2,r2,128
8111250c:	10bfe004 	addi	r2,r2,-128
81112510:	108008d8 	cmpnei	r2,r2,35
81112514:	10000a1e 	bne	r2,zero,81112540 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
81112518:	00800044 	movi	r2,1
8111251c:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81112520:	d0a06117 	ldw	r2,-32380(gp)
81112524:	100f883a 	mov	r7,r2
81112528:	018006c4 	movi	r6,27
8111252c:	01400044 	movi	r5,1
81112530:	01204574 	movhi	r4,33045
81112534:	21288304 	addi	r4,r4,-24052
81112538:	111dcb00 	call	8111dcb0 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8111253c:	00003906 	br	81112624 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81112540:	008000c4 	movi	r2,3
81112544:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81112548:	00003606 	br	81112624 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
8111254c:	00a04574 	movhi	r2,33045
81112550:	10be3d04 	addi	r2,r2,-1804
81112554:	00c008c4 	movi	r3,35
81112558:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
8111255c:	00a04574 	movhi	r2,33045
81112560:	10be3d04 	addi	r2,r2,-1804
81112564:	00c00b84 	movi	r3,46
81112568:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
8111256c:	00a04574 	movhi	r2,33045
81112570:	10be3d04 	addi	r2,r2,-1804
81112574:	00c00044 	movi	r3,1
81112578:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8111257c:	01204574 	movhi	r4,33045
81112580:	213e3d04 	addi	r4,r4,-1804
81112584:	11127640 	call	81112764 <setPreAckSenderFreePos>
81112588:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8111258c:	e0bfae17 	ldw	r2,-328(fp)
81112590:	1000011e 	bne	r2,zero,81112598 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81112594:	11190400 	call	81119040 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81112598:	00800044 	movi	r2,1
8111259c:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
811125a0:	00002006 	br	81112624 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
811125a4:	01204574 	movhi	r4,33045
811125a8:	213e3d04 	addi	r4,r4,-1804
811125ac:	11127640 	call	81112764 <setPreAckSenderFreePos>
811125b0:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
811125b4:	e0bfae17 	ldw	r2,-328(fp)
811125b8:	10800058 	cmpnei	r2,r2,1
811125bc:	1000081e 	bne	r2,zero,811125e0 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
811125c0:	01204574 	movhi	r4,33045
811125c4:	213e3d04 	addi	r4,r4,-1804
811125c8:	11126280 	call	81112628 <setPreParsedFreePos>
811125cc:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811125d0:	e0bfae17 	ldw	r2,-328(fp)
811125d4:	1000031e 	bne	r2,zero,811125e4 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
811125d8:	11191100 	call	81119110 <vFailSetPreParsedBuffer>
811125dc:	00000106 	br	811125e4 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
811125e0:	11190a80 	call	811190a8 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
811125e4:	00800044 	movi	r2,1
811125e8:	e0bfad15 	stw	r2,-332(fp)
                break;
811125ec:	00000d06 	br	81112624 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
811125f0:	01204574 	movhi	r4,33045
811125f4:	213e3d04 	addi	r4,r4,-1804
811125f8:	11128e00 	call	811128e0 <setPreAckReceiverFreePos>
811125fc:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81112600:	e0bfae17 	ldw	r2,-328(fp)
81112604:	1000011e 	bne	r2,zero,8111260c <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81112608:	11191780 	call	81119178 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
8111260c:	00800044 	movi	r2,1
81112610:	e0bfad15 	stw	r2,-332(fp)
                break;
81112614:	00000306 	br	81112624 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81112618:	00800044 	movi	r2,1
8111261c:	e0bfad15 	stw	r2,-332(fp)
                break;
81112620:	0001883a 	nop
        }

    }
81112624:	003f7c06 	br	81112418 <__reset+0xfb0f2418>

81112628 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81112628:	defffb04 	addi	sp,sp,-20
8111262c:	de00012e 	bgeu	sp,et,81112634 <setPreParsedFreePos+0xc>
81112630:	003b68fa 	trap	3
81112634:	dfc00415 	stw	ra,16(sp)
81112638:	df000315 	stw	fp,12(sp)
8111263c:	df000304 	addi	fp,sp,12
81112640:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81112644:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81112648:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8111264c:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81112650:	d0a06a17 	ldw	r2,-32344(gp)
81112654:	e0fffe44 	addi	r3,fp,-7
81112658:	180d883a 	mov	r6,r3
8111265c:	01400284 	movi	r5,10
81112660:	1009883a 	mov	r4,r2
81112664:	11396e40 	call	811396e4 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81112668:	e0bffe43 	ldbu	r2,-7(fp)
8111266c:	10803fcc 	andi	r2,r2,255
81112670:	1000361e 	bne	r2,zero,8111274c <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81112674:	e03ffe05 	stb	zero,-8(fp)
81112678:	00002e06 	br	81112734 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
8111267c:	e0fffe03 	ldbu	r3,-8(fp)
81112680:	00a045b4 	movhi	r2,33046
81112684:	108bb104 	addi	r2,r2,11972
81112688:	18c01324 	muli	r3,r3,76
8111268c:	10c5883a 	add	r2,r2,r3
81112690:	10800104 	addi	r2,r2,4
81112694:	10800003 	ldbu	r2,0(r2)
81112698:	10803fcc 	andi	r2,r2,255
8111269c:	1080201c 	xori	r2,r2,128
811126a0:	10bfe004 	addi	r2,r2,-128
811126a4:	1000201e 	bne	r2,zero,81112728 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
811126a8:	e0fffe03 	ldbu	r3,-8(fp)
811126ac:	00a045b4 	movhi	r2,33046
811126b0:	108bb104 	addi	r2,r2,11972
811126b4:	18c01324 	muli	r3,r3,76
811126b8:	10c7883a 	add	r3,r2,r3
811126bc:	e0bfff17 	ldw	r2,-4(fp)
811126c0:	1009883a 	mov	r4,r2
811126c4:	00801304 	movi	r2,76
811126c8:	100d883a 	mov	r6,r2
811126cc:	200b883a 	mov	r5,r4
811126d0:	1809883a 	mov	r4,r3
811126d4:	111e6c40 	call	8111e6c4 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
811126d8:	d0a06317 	ldw	r2,-32372(gp)
811126dc:	1009883a 	mov	r4,r2
811126e0:	113ba780 	call	8113ba78 <OSSemPost>
811126e4:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811126e8:	e0bffe43 	ldbu	r2,-7(fp)
811126ec:	10803fcc 	andi	r2,r2,255
811126f0:	1000031e 	bne	r2,zero,81112700 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
811126f4:	00800044 	movi	r2,1
811126f8:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
811126fc:	00001006 	br	81112740 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81112700:	11187600 	call	81118760 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81112704:	e0fffe03 	ldbu	r3,-8(fp)
81112708:	00a045b4 	movhi	r2,33046
8111270c:	108bb104 	addi	r2,r2,11972
81112710:	18c01324 	muli	r3,r3,76
81112714:	10c5883a 	add	r2,r2,r3
81112718:	10800104 	addi	r2,r2,4
8111271c:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81112720:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81112724:	00000606 	br	81112740 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81112728:	e0bffe03 	ldbu	r2,-8(fp)
8111272c:	10800044 	addi	r2,r2,1
81112730:	e0bffe05 	stb	r2,-8(fp)
81112734:	e0bffe03 	ldbu	r2,-8(fp)
81112738:	10800230 	cmpltui	r2,r2,8
8111273c:	103fcf1e 	bne	r2,zero,8111267c <__reset+0xfb0f267c>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81112740:	d0a06a17 	ldw	r2,-32344(gp)
81112744:	1009883a 	mov	r4,r2
81112748:	1139c880 	call	81139c88 <OSMutexPost>
    }
    return bSuccess;
8111274c:	e0bffd17 	ldw	r2,-12(fp)
}
81112750:	e037883a 	mov	sp,fp
81112754:	dfc00117 	ldw	ra,4(sp)
81112758:	df000017 	ldw	fp,0(sp)
8111275c:	dec00204 	addi	sp,sp,8
81112760:	f800283a 	ret

81112764 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81112764:	defffb04 	addi	sp,sp,-20
81112768:	de00012e 	bgeu	sp,et,81112770 <setPreAckSenderFreePos+0xc>
8111276c:	003b68fa 	trap	3
81112770:	dfc00415 	stw	ra,16(sp)
81112774:	df000315 	stw	fp,12(sp)
81112778:	df000304 	addi	fp,sp,12
8111277c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81112780:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81112784:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81112788:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8111278c:	d0a07117 	ldw	r2,-32316(gp)
81112790:	e0fffe44 	addi	r3,fp,-7
81112794:	180d883a 	mov	r6,r3
81112798:	01400284 	movi	r5,10
8111279c:	1009883a 	mov	r4,r2
811127a0:	11396e40 	call	811396e4 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811127a4:	e0bffe43 	ldbu	r2,-7(fp)
811127a8:	10803fcc 	andi	r2,r2,255
811127ac:	1000461e 	bne	r2,zero,811128c8 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811127b0:	e03ffe05 	stb	zero,-8(fp)
811127b4:	00003e06 	br	811128b0 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
811127b8:	e0fffe03 	ldbu	r3,-8(fp)
811127bc:	00a045b4 	movhi	r2,33046
811127c0:	108ba904 	addi	r2,r2,11940
811127c4:	18c7883a 	add	r3,r3,r3
811127c8:	18c7883a 	add	r3,r3,r3
811127cc:	10c5883a 	add	r2,r2,r3
811127d0:	10800003 	ldbu	r2,0(r2)
811127d4:	10803fcc 	andi	r2,r2,255
811127d8:	1080201c 	xori	r2,r2,128
811127dc:	10bfe004 	addi	r2,r2,-128
811127e0:	1000301e 	bne	r2,zero,811128a4 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
811127e4:	e0fffe03 	ldbu	r3,-8(fp)
811127e8:	e0bfff17 	ldw	r2,-4(fp)
811127ec:	11000103 	ldbu	r4,4(r2)
811127f0:	00a045b4 	movhi	r2,33046
811127f4:	108ba904 	addi	r2,r2,11940
811127f8:	18c7883a 	add	r3,r3,r3
811127fc:	18c7883a 	add	r3,r3,r3
81112800:	10c5883a 	add	r2,r2,r3
81112804:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81112808:	e0fffe03 	ldbu	r3,-8(fp)
8111280c:	e0bfff17 	ldw	r2,-4(fp)
81112810:	11000143 	ldbu	r4,5(r2)
81112814:	00a045b4 	movhi	r2,33046
81112818:	108ba904 	addi	r2,r2,11940
8111281c:	18c7883a 	add	r3,r3,r3
81112820:	18c7883a 	add	r3,r3,r3
81112824:	10c5883a 	add	r2,r2,r3
81112828:	10800044 	addi	r2,r2,1
8111282c:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81112830:	e0fffe03 	ldbu	r3,-8(fp)
81112834:	e0bfff17 	ldw	r2,-4(fp)
81112838:	1100020b 	ldhu	r4,8(r2)
8111283c:	00a045b4 	movhi	r2,33046
81112840:	108ba904 	addi	r2,r2,11940
81112844:	18c7883a 	add	r3,r3,r3
81112848:	18c7883a 	add	r3,r3,r3
8111284c:	10c5883a 	add	r2,r2,r3
81112850:	10800084 	addi	r2,r2,2
81112854:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81112858:	d0a06017 	ldw	r2,-32384(gp)
8111285c:	1009883a 	mov	r4,r2
81112860:	113ba780 	call	8113ba78 <OSSemPost>
81112864:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81112868:	e0bffe43 	ldbu	r2,-7(fp)
8111286c:	10803fcc 	andi	r2,r2,255
81112870:	10000926 	beq	r2,zero,81112898 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81112874:	11187f80 	call	811187f8 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81112878:	e0fffe03 	ldbu	r3,-8(fp)
8111287c:	00a045b4 	movhi	r2,33046
81112880:	108ba904 	addi	r2,r2,11940
81112884:	18c7883a 	add	r3,r3,r3
81112888:	18c7883a 	add	r3,r3,r3
8111288c:	10c5883a 	add	r2,r2,r3
81112890:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81112894:	00000906 	br	811128bc <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81112898:	00800044 	movi	r2,1
8111289c:	e0bffd15 	stw	r2,-12(fp)
                break;
811128a0:	00000606 	br	811128bc <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811128a4:	e0bffe03 	ldbu	r2,-8(fp)
811128a8:	10800044 	addi	r2,r2,1
811128ac:	e0bffe05 	stb	r2,-8(fp)
811128b0:	e0bffe03 	ldbu	r2,-8(fp)
811128b4:	10800230 	cmpltui	r2,r2,8
811128b8:	103fbf1e 	bne	r2,zero,811127b8 <__reset+0xfb0f27b8>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
811128bc:	d0a07117 	ldw	r2,-32316(gp)
811128c0:	1009883a 	mov	r4,r2
811128c4:	1139c880 	call	81139c88 <OSMutexPost>
    }

    return bSuccess;
811128c8:	e0bffd17 	ldw	r2,-12(fp)
}
811128cc:	e037883a 	mov	sp,fp
811128d0:	dfc00117 	ldw	ra,4(sp)
811128d4:	df000017 	ldw	fp,0(sp)
811128d8:	dec00204 	addi	sp,sp,8
811128dc:	f800283a 	ret

811128e0 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
811128e0:	defffb04 	addi	sp,sp,-20
811128e4:	de00012e 	bgeu	sp,et,811128ec <setPreAckReceiverFreePos+0xc>
811128e8:	003b68fa 	trap	3
811128ec:	dfc00415 	stw	ra,16(sp)
811128f0:	df000315 	stw	fp,12(sp)
811128f4:	df000304 	addi	fp,sp,12
811128f8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811128fc:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81112900:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81112904:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81112908:	d0a06417 	ldw	r2,-32368(gp)
8111290c:	e0fffe44 	addi	r3,fp,-7
81112910:	180d883a 	mov	r6,r3
81112914:	01400504 	movi	r5,20
81112918:	1009883a 	mov	r4,r2
8111291c:	11396e40 	call	811396e4 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81112920:	e0bffe43 	ldbu	r2,-7(fp)
81112924:	10803fcc 	andi	r2,r2,255
81112928:	1000471e 	bne	r2,zero,81112a48 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8111292c:	e03ffe05 	stb	zero,-8(fp)
81112930:	00003e06 	br	81112a2c <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81112934:	e0fffe03 	ldbu	r3,-8(fp)
81112938:	00a045b4 	movhi	r2,33046
8111293c:	10b59704 	addi	r2,r2,-10660
81112940:	18c7883a 	add	r3,r3,r3
81112944:	18c7883a 	add	r3,r3,r3
81112948:	10c5883a 	add	r2,r2,r3
8111294c:	10800003 	ldbu	r2,0(r2)
81112950:	10803fcc 	andi	r2,r2,255
81112954:	1080201c 	xori	r2,r2,128
81112958:	10bfe004 	addi	r2,r2,-128
8111295c:	1000301e 	bne	r2,zero,81112a20 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81112960:	e0fffe03 	ldbu	r3,-8(fp)
81112964:	e0bfff17 	ldw	r2,-4(fp)
81112968:	11000103 	ldbu	r4,4(r2)
8111296c:	00a045b4 	movhi	r2,33046
81112970:	10b59704 	addi	r2,r2,-10660
81112974:	18c7883a 	add	r3,r3,r3
81112978:	18c7883a 	add	r3,r3,r3
8111297c:	10c5883a 	add	r2,r2,r3
81112980:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81112984:	e0fffe03 	ldbu	r3,-8(fp)
81112988:	e0bfff17 	ldw	r2,-4(fp)
8111298c:	11000143 	ldbu	r4,5(r2)
81112990:	00a045b4 	movhi	r2,33046
81112994:	10b59704 	addi	r2,r2,-10660
81112998:	18c7883a 	add	r3,r3,r3
8111299c:	18c7883a 	add	r3,r3,r3
811129a0:	10c5883a 	add	r2,r2,r3
811129a4:	10800044 	addi	r2,r2,1
811129a8:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
811129ac:	e0fffe03 	ldbu	r3,-8(fp)
811129b0:	e0bfff17 	ldw	r2,-4(fp)
811129b4:	1100020b 	ldhu	r4,8(r2)
811129b8:	00a045b4 	movhi	r2,33046
811129bc:	10b59704 	addi	r2,r2,-10660
811129c0:	18c7883a 	add	r3,r3,r3
811129c4:	18c7883a 	add	r3,r3,r3
811129c8:	10c5883a 	add	r2,r2,r3
811129cc:	10800084 	addi	r2,r2,2
811129d0:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
811129d4:	d0a06517 	ldw	r2,-32364(gp)
811129d8:	1009883a 	mov	r4,r2
811129dc:	113ba780 	call	8113ba78 <OSSemPost>
811129e0:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811129e4:	e0bffe43 	ldbu	r2,-7(fp)
811129e8:	10803fcc 	andi	r2,r2,255
811129ec:	1000031e 	bne	r2,zero,811129fc <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
811129f0:	00800044 	movi	r2,1
811129f4:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
811129f8:	00000f06 	br	81112a38 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
811129fc:	11187ac0 	call	811187ac <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81112a00:	e0fffe03 	ldbu	r3,-8(fp)
81112a04:	00a045b4 	movhi	r2,33046
81112a08:	10b59704 	addi	r2,r2,-10660
81112a0c:	18c7883a 	add	r3,r3,r3
81112a10:	18c7883a 	add	r3,r3,r3
81112a14:	10c5883a 	add	r2,r2,r3
81112a18:	10000005 	stb	zero,0(r2)
                }
                break;
81112a1c:	00000606 	br	81112a38 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81112a20:	e0bffe03 	ldbu	r2,-8(fp)
81112a24:	10800044 	addi	r2,r2,1
81112a28:	e0bffe05 	stb	r2,-8(fp)
81112a2c:	e0bffe03 	ldbu	r2,-8(fp)
81112a30:	108001b0 	cmpltui	r2,r2,6
81112a34:	103fbf1e 	bne	r2,zero,81112934 <__reset+0xfb0f2934>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81112a38:	d0a06417 	ldw	r2,-32368(gp)
81112a3c:	1009883a 	mov	r4,r2
81112a40:	1139c880 	call	81139c88 <OSMutexPost>
81112a44:	00000706 	br	81112a64 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
81112a48:	d0a06117 	ldw	r2,-32380(gp)
81112a4c:	100f883a 	mov	r7,r2
81112a50:	01801404 	movi	r6,80
81112a54:	01400044 	movi	r5,1
81112a58:	01204574 	movhi	r4,33045
81112a5c:	21288a04 	addi	r4,r4,-24024
81112a60:	111dcb00 	call	8111dcb0 <fwrite>
        #endif
    }

    return bSuccess;
81112a64:	e0bffd17 	ldw	r2,-12(fp)
}
81112a68:	e037883a 	mov	sp,fp
81112a6c:	dfc00117 	ldw	ra,4(sp)
81112a70:	df000017 	ldw	fp,0(sp)
81112a74:	dec00204 	addi	sp,sp,8
81112a78:	f800283a 	ret

81112a7c <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
81112a7c:	defff404 	addi	sp,sp,-48
81112a80:	de00012e 	bgeu	sp,et,81112a88 <bPreParserV2+0xc>
81112a84:	003b68fa 	trap	3
81112a88:	dfc00b15 	stw	ra,44(sp)
81112a8c:	df000a15 	stw	fp,40(sp)
81112a90:	dc000915 	stw	r16,36(sp)
81112a94:	df000a04 	addi	fp,sp,40
81112a98:	e13ffd15 	stw	r4,-12(fp)
81112a9c:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81112aa0:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81112aa4:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81112aa8:	01402004 	movi	r5,128
81112aac:	e13ffd17 	ldw	r4,-12(fp)
81112ab0:	111f2500 	call	8111f250 <strnlen>
81112ab4:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81112ab8:	01400ec4 	movi	r5,59
81112abc:	e13ffd17 	ldw	r4,-12(fp)
81112ac0:	11171e80 	call	811171e8 <siPosStr>
81112ac4:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81112ac8:	e0fff98f 	ldh	r3,-26(fp)
81112acc:	e0bff90f 	ldh	r2,-28(fp)
81112ad0:	10bfffc4 	addi	r2,r2,-1
81112ad4:	18800226 	beq	r3,r2,81112ae0 <bPreParserV2+0x64>
        return bSuccess;
81112ad8:	e0bff617 	ldw	r2,-40(fp)
81112adc:	0000ba06 	br	81112dc8 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81112ae0:	01401f04 	movi	r5,124
81112ae4:	e13ffd17 	ldw	r4,-12(fp)
81112ae8:	11171e80 	call	811171e8 <siPosStr>
81112aec:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81112af0:	e0bffa0f 	ldh	r2,-24(fp)
81112af4:	e0fff98f 	ldh	r3,-26(fp)
81112af8:	1880020e 	bge	r3,r2,81112b04 <bPreParserV2+0x88>
        return bSuccess;
81112afc:	e0bff617 	ldw	r2,-40(fp)
81112b00:	0000b106 	br	81112dc8 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81112b04:	01604574 	movhi	r5,33045
81112b08:	29689f04 	addi	r5,r5,-23940
81112b0c:	e13ffd17 	ldw	r4,-12(fp)
81112b10:	111f16c0 	call	8111f16c <strcspn>
81112b14:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81112b18:	e0bffa8f 	ldh	r2,-22(fp)
81112b1c:	e0fffa0f 	ldh	r3,-24(fp)
81112b20:	1880020e 	bge	r3,r2,81112b2c <bPreParserV2+0xb0>
        return bSuccess;
81112b24:	e0bff617 	ldw	r2,-40(fp)
81112b28:	0000a706 	br	81112dc8 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81112b2c:	e0bffa8f 	ldh	r2,-22(fp)
81112b30:	e0fffd17 	ldw	r3,-12(fp)
81112b34:	1885883a 	add	r2,r3,r2
81112b38:	10c00003 	ldbu	r3,0(r2)
81112b3c:	e0bffe17 	ldw	r2,-8(fp)
81112b40:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81112b44:	e0bffe17 	ldw	r2,-8(fp)
81112b48:	10800103 	ldbu	r2,4(r2)
81112b4c:	10803fcc 	andi	r2,r2,255
81112b50:	1080201c 	xori	r2,r2,128
81112b54:	10bfe004 	addi	r2,r2,-128
81112b58:	108008d8 	cmpnei	r2,r2,35
81112b5c:	1000041e 	bne	r2,zero,81112b70 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81112b60:	00800044 	movi	r2,1
81112b64:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81112b68:	e0bff617 	ldw	r2,-40(fp)
81112b6c:	00009606 	br	81112dc8 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81112b70:	e0bffa8f 	ldh	r2,-22(fp)
81112b74:	e0fffd17 	ldw	r3,-12(fp)
81112b78:	1889883a 	add	r4,r3,r2
81112b7c:	e0fffa0f 	ldh	r3,-24(fp)
81112b80:	e0bffa8f 	ldh	r2,-22(fp)
81112b84:	1885c83a 	sub	r2,r3,r2
81112b88:	100b883a 	mov	r5,r2
81112b8c:	11184080 	call	81118408 <ucCrc8wInit>
81112b90:	1007883a 	mov	r3,r2
81112b94:	e0bffe17 	ldw	r2,-8(fp)
81112b98:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
81112b9c:	e0bffa8f 	ldh	r2,-22(fp)
81112ba0:	10800044 	addi	r2,r2,1
81112ba4:	e0fffd17 	ldw	r3,-12(fp)
81112ba8:	1885883a 	add	r2,r3,r2
81112bac:	10c00003 	ldbu	r3,0(r2)
81112bb0:	e0bffe17 	ldw	r2,-8(fp)
81112bb4:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81112bb8:	e0bffe17 	ldw	r2,-8(fp)
81112bbc:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81112bc0:	e0bffe17 	ldw	r2,-8(fp)
81112bc4:	10800204 	addi	r2,r2,8
81112bc8:	01801004 	movi	r6,64
81112bcc:	000b883a 	mov	r5,zero
81112bd0:	1009883a 	mov	r4,r2
81112bd4:	111e8140 	call	8111e814 <memset>

    i = siIni + 3; /* "?C:i..." */
81112bd8:	e0bffa8b 	ldhu	r2,-22(fp)
81112bdc:	108000c4 	addi	r2,r2,3
81112be0:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81112be4:	e0bffb44 	addi	r2,fp,-19
81112be8:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81112bec:	e0bffb44 	addi	r2,fp,-19
81112bf0:	01800184 	movi	r6,6
81112bf4:	000b883a 	mov	r5,zero
81112bf8:	1009883a 	mov	r4,r2
81112bfc:	111e8140 	call	8111e814 <memset>
        do {
            c = buffer[i];
81112c00:	e0bff703 	ldbu	r2,-36(fp)
81112c04:	e0fffd17 	ldw	r3,-12(fp)
81112c08:	1885883a 	add	r2,r3,r2
81112c0c:	10800003 	ldbu	r2,0(r2)
81112c10:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81112c14:	d0e00317 	ldw	r3,-32756(gp)
81112c18:	e0bffb07 	ldb	r2,-20(fp)
81112c1c:	10800044 	addi	r2,r2,1
81112c20:	1885883a 	add	r2,r3,r2
81112c24:	10800003 	ldbu	r2,0(r2)
81112c28:	10803fcc 	andi	r2,r2,255
81112c2c:	1080010c 	andi	r2,r2,4
81112c30:	10000626 	beq	r2,zero,81112c4c <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81112c34:	e0bff817 	ldw	r2,-32(fp)
81112c38:	e0fffb03 	ldbu	r3,-20(fp)
81112c3c:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81112c40:	e0bff817 	ldw	r2,-32(fp)
81112c44:	10800044 	addi	r2,r2,1
81112c48:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81112c4c:	e0bff703 	ldbu	r2,-36(fp)
81112c50:	10800044 	addi	r2,r2,1
81112c54:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81112c58:	e0bff90f 	ldh	r2,-28(fp)
81112c5c:	e0fff703 	ldbu	r3,-36(fp)
81112c60:	1880090e 	bge	r3,r2,81112c88 <bPreParserV2+0x20c>
81112c64:	e0bffb07 	ldb	r2,-20(fp)
81112c68:	10800ea0 	cmpeqi	r2,r2,58
81112c6c:	1000061e 	bne	r2,zero,81112c88 <bPreParserV2+0x20c>
81112c70:	e0bffb07 	ldb	r2,-20(fp)
81112c74:	10800ee0 	cmpeqi	r2,r2,59
81112c78:	1000031e 	bne	r2,zero,81112c88 <bPreParserV2+0x20c>
81112c7c:	e0bffb07 	ldb	r2,-20(fp)
81112c80:	10801f18 	cmpnei	r2,r2,124
81112c84:	103fde1e 	bne	r2,zero,81112c00 <__reset+0xfb0f2c00>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81112c88:	e0bff817 	ldw	r2,-32(fp)
81112c8c:	00c00284 	movi	r3,10
81112c90:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81112c94:	e0bffb07 	ldb	r2,-20(fp)
81112c98:	10800ea0 	cmpeqi	r2,r2,58
81112c9c:	1000031e 	bne	r2,zero,81112cac <bPreParserV2+0x230>
81112ca0:	e0bffb07 	ldb	r2,-20(fp)
81112ca4:	10801f18 	cmpnei	r2,r2,124
81112ca8:	10001a1e 	bne	r2,zero,81112d14 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
81112cac:	e0bffe17 	ldw	r2,-8(fp)
81112cb0:	10800183 	ldbu	r2,6(r2)
81112cb4:	10803fcc 	andi	r2,r2,255
81112cb8:	10800828 	cmpgeui	r2,r2,32
81112cbc:	1000041e 	bne	r2,zero,81112cd0 <bPreParserV2+0x254>
81112cc0:	e0bffe17 	ldw	r2,-8(fp)
81112cc4:	10800183 	ldbu	r2,6(r2)
81112cc8:	14003fcc 	andi	r16,r2,255
81112ccc:	00000106 	br	81112cd4 <bPreParserV2+0x258>
81112cd0:	04000804 	movi	r16,32
81112cd4:	e0bffb44 	addi	r2,fp,-19
81112cd8:	1009883a 	mov	r4,r2
81112cdc:	111d4b80 	call	8111d4b8 <atoi>
81112ce0:	1009883a 	mov	r4,r2
81112ce4:	e0fffe17 	ldw	r3,-8(fp)
81112ce8:	80800104 	addi	r2,r16,4
81112cec:	1085883a 	add	r2,r2,r2
81112cf0:	1885883a 	add	r2,r3,r2
81112cf4:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
81112cf8:	e0bffe17 	ldw	r2,-8(fp)
81112cfc:	10800183 	ldbu	r2,6(r2)
81112d00:	10800044 	addi	r2,r2,1
81112d04:	1007883a 	mov	r3,r2
81112d08:	e0bffe17 	ldw	r2,-8(fp)
81112d0c:	10c00185 	stb	r3,6(r2)
81112d10:	00000906 	br	81112d38 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81112d14:	e0bffb07 	ldb	r2,-20(fp)
81112d18:	10800ed8 	cmpnei	r2,r2,59
81112d1c:	1000061e 	bne	r2,zero,81112d38 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81112d20:	e0bffb44 	addi	r2,fp,-19
81112d24:	1009883a 	mov	r4,r2
81112d28:	111d4b80 	call	8111d4b8 <atoi>
81112d2c:	1007883a 	mov	r3,r2
81112d30:	e0bffe17 	ldw	r2,-8(fp)
81112d34:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
81112d38:	e0bffb07 	ldb	r2,-20(fp)
81112d3c:	10800ee0 	cmpeqi	r2,r2,59
81112d40:	1000031e 	bne	r2,zero,81112d50 <bPreParserV2+0x2d4>
81112d44:	e0bff90f 	ldh	r2,-28(fp)
81112d48:	e0fff703 	ldbu	r3,-36(fp)
81112d4c:	18bfa516 	blt	r3,r2,81112be4 <__reset+0xfb0f2be4>


    if ( c == FINAL_CHAR )
81112d50:	e0bffb07 	ldb	r2,-20(fp)
81112d54:	10800ed8 	cmpnei	r2,r2,59
81112d58:	1000191e 	bne	r2,zero,81112dc0 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81112d5c:	e0bffe17 	ldw	r2,-8(fp)
81112d60:	10c01243 	ldbu	r3,73(r2)
81112d64:	e0bffe17 	ldw	r2,-8(fp)
81112d68:	10801203 	ldbu	r2,72(r2)
81112d6c:	18c03fcc 	andi	r3,r3,255
81112d70:	10803fcc 	andi	r2,r2,255
81112d74:	1880031e 	bne	r3,r2,81112d84 <bPreParserV2+0x308>
            bSuccess = TRUE;
81112d78:	00800044 	movi	r2,1
81112d7c:	e0bff615 	stw	r2,-40(fp)
81112d80:	00001006 	br	81112dc4 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81112d84:	d0e06117 	ldw	r3,-32380(gp)
81112d88:	e0bffe17 	ldw	r2,-8(fp)
81112d8c:	10801203 	ldbu	r2,72(r2)
81112d90:	11003fcc 	andi	r4,r2,255
81112d94:	e0bffe17 	ldw	r2,-8(fp)
81112d98:	10801243 	ldbu	r2,73(r2)
81112d9c:	10803fcc 	andi	r2,r2,255
81112da0:	100f883a 	mov	r7,r2
81112da4:	200d883a 	mov	r6,r4
81112da8:	01604574 	movhi	r5,33045
81112dac:	2968a104 	addi	r5,r5,-23932
81112db0:	1809883a 	mov	r4,r3
81112db4:	111d6140 	call	8111d614 <fprintf>
            #endif
            bSuccess = FALSE;
81112db8:	e03ff615 	stw	zero,-40(fp)
81112dbc:	00000106 	br	81112dc4 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81112dc0:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81112dc4:	e0bff617 	ldw	r2,-40(fp)
}
81112dc8:	e6ffff04 	addi	sp,fp,-4
81112dcc:	dfc00217 	ldw	ra,8(sp)
81112dd0:	df000117 	ldw	fp,4(sp)
81112dd4:	dc000017 	ldw	r16,0(sp)
81112dd8:	dec00304 	addi	sp,sp,12
81112ddc:	f800283a 	ret

81112de0 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81112de0:	defffb04 	addi	sp,sp,-20
81112de4:	de00012e 	bgeu	sp,et,81112dec <vSenderComTask+0xc>
81112de8:	003b68fa 	trap	3
81112dec:	dfc00415 	stw	ra,16(sp)
81112df0:	df000315 	stw	fp,12(sp)
81112df4:	df000304 	addi	fp,sp,12
81112df8:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81112dfc:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81112e00:	d0a06117 	ldw	r2,-32380(gp)
81112e04:	100f883a 	mov	r7,r2
81112e08:	01800704 	movi	r6,28
81112e0c:	01400044 	movi	r5,1
81112e10:	01204574 	movhi	r4,33045
81112e14:	2128ad04 	addi	r4,r4,-23884
81112e18:	111dcb00 	call	8111dcb0 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
81112e1c:	e0bffd17 	ldw	r2,-12(fp)
81112e20:	10c00060 	cmpeqi	r3,r2,1
81112e24:	1800091e 	bne	r3,zero,81112e4c <vSenderComTask+0x6c>
81112e28:	0080052e 	bgeu	zero,r2,81112e40 <vSenderComTask+0x60>
81112e2c:	10c000a0 	cmpeqi	r3,r2,2
81112e30:	1800471e 	bne	r3,zero,81112f50 <vSenderComTask+0x170>
81112e34:	10800160 	cmpeqi	r2,r2,5
81112e38:	10002c1e 	bne	r2,zero,81112eec <vSenderComTask+0x10c>
81112e3c:	00003a06 	br	81112f28 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81112e40:	00800044 	movi	r2,1
81112e44:	e0bffd15 	stw	r2,-12(fp)
                break;
81112e48:	00004206 	br	81112f54 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
81112e4c:	d0a06117 	ldw	r2,-32380(gp)
81112e50:	100f883a 	mov	r7,r2
81112e54:	01800784 	movi	r6,30
81112e58:	01400044 	movi	r5,1
81112e5c:	01204574 	movhi	r4,33045
81112e60:	2128b504 	addi	r4,r4,-23852
81112e64:	111dcb00 	call	8111dcb0 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81112e68:	01400044 	movi	r5,1
81112e6c:	01204574 	movhi	r4,33045
81112e70:	2128bd04 	addi	r4,r4,-23820
81112e74:	11168e00 	call	811168e0 <bSendUART32v2>
81112e78:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81112e7c:	e0bffe17 	ldw	r2,-8(fp)
81112e80:	10800058 	cmpnei	r2,r2,1
81112e84:	10000a1e 	bne	r2,zero,81112eb0 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81112e88:	00800144 	movi	r2,5
81112e8c:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81112e90:	d0a06117 	ldw	r2,-32380(gp)
81112e94:	100f883a 	mov	r7,r2
81112e98:	01800d44 	movi	r6,53
81112e9c:	01400044 	movi	r5,1
81112ea0:	01204574 	movhi	r4,33045
81112ea4:	2128c004 	addi	r4,r4,-23808
81112ea8:	111dcb00 	call	8111dcb0 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81112eac:	00002906 	br	81112f54 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
81112eb0:	d0a06117 	ldw	r2,-32380(gp)
81112eb4:	100f883a 	mov	r7,r2
81112eb8:	01800784 	movi	r6,30
81112ebc:	01400044 	movi	r5,1
81112ec0:	01204574 	movhi	r4,33045
81112ec4:	2128ce04 	addi	r4,r4,-23752
81112ec8:	111dcb00 	call	8111dcb0 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
81112ecc:	00800044 	movi	r2,1
81112ed0:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81112ed4:	000f883a 	mov	r7,zero
81112ed8:	01800144 	movi	r6,5
81112edc:	000b883a 	mov	r5,zero
81112ee0:	0009883a 	mov	r4,zero
81112ee4:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
                }
                break;
81112ee8:	00001a06 	br	81112f54 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81112eec:	00800144 	movi	r2,5
81112ef0:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
81112ef4:	d0a06117 	ldw	r2,-32380(gp)
81112ef8:	100f883a 	mov	r7,r2
81112efc:	018002c4 	movi	r6,11
81112f00:	01400044 	movi	r5,1
81112f04:	01204574 	movhi	r4,33045
81112f08:	2128d604 	addi	r4,r4,-23720
81112f0c:	111dcb00 	call	8111dcb0 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81112f10:	000f883a 	mov	r7,zero
81112f14:	01800644 	movi	r6,25
81112f18:	000b883a 	mov	r5,zero
81112f1c:	0009883a 	mov	r4,zero
81112f20:	113d6880 	call	8113d688 <OSTimeDlyHMSM>

                break;
81112f24:	00000b06 	br	81112f54 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
81112f28:	d0a06117 	ldw	r2,-32380(gp)
81112f2c:	100f883a 	mov	r7,r2
81112f30:	018003c4 	movi	r6,15
81112f34:	01400044 	movi	r5,1
81112f38:	01204574 	movhi	r4,33045
81112f3c:	2128d904 	addi	r4,r4,-23708
81112f40:	111dcb00 	call	8111dcb0 <fwrite>
                #endif
                eSenderMode = sDummySender;
81112f44:	00800144 	movi	r2,5
81112f48:	e0bffd15 	stw	r2,-12(fp)
                break;
81112f4c:	00000106 	br	81112f54 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81112f50:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81112f54:	003fb106 	br	81112e1c <__reset+0xfb0f2e1c>

81112f58 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81112f58:	defff904 	addi	sp,sp,-28
81112f5c:	de00012e 	bgeu	sp,et,81112f64 <vSimMebTask+0xc>
81112f60:	003b68fa 	trap	3
81112f64:	dfc00615 	stw	ra,24(sp)
81112f68:	df000515 	stw	fp,20(sp)
81112f6c:	df000504 	addi	fp,sp,20
81112f70:	e13fff15 	stw	r4,-4(fp)
	TSimucam_MEB *pxMebC;
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
81112f74:	e0bfff17 	ldw	r2,-4(fp)
81112f78:	e0bffc15 	stw	r2,-16(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81112f7c:	d0a06117 	ldw	r2,-32380(gp)
81112f80:	100f883a 	mov	r7,r2
81112f84:	018008c4 	movi	r6,35
81112f88:	01400044 	movi	r5,1
81112f8c:	01204574 	movhi	r4,33045
81112f90:	2128dd04 	addi	r4,r4,-23692
81112f94:	111dcb00 	call	8111dcb0 <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
81112f98:	e0bffc17 	ldw	r2,-16(fp)
81112f9c:	10800117 	ldw	r2,4(r2)
81112fa0:	10c00168 	cmpgeui	r3,r2,5
81112fa4:	1800cb1e 	bne	r3,zero,811132d4 <vSimMebTask+0x37c>
81112fa8:	100690ba 	slli	r3,r2,2
81112fac:	00a04474 	movhi	r2,33041
81112fb0:	108bf004 	addi	r2,r2,12224
81112fb4:	1885883a 	add	r2,r3,r2
81112fb8:	10800017 	ldw	r2,0(r2)
81112fbc:	1000683a 	jmp	r2
81112fc0:	81112fd4 	ori	r4,r16,17599
81112fc4:	81112fec 	andhi	r4,r16,17599
81112fc8:	8111306c 	andhi	r4,r16,17601
81112fcc:	81113138 	rdprs	r4,r16,17604
81112fd0:	81113210 	cmplti	r4,r16,17608
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81112fd4:	e13ffc17 	ldw	r4,-16(fp)
81112fd8:	11140780 	call	81114078 <vMebInit>
				pxMebC->eMode = sMebToConfig;
81112fdc:	e0bffc17 	ldw	r2,-16(fp)
81112fe0:	00c00044 	movi	r3,1
81112fe4:	10c00115 	stw	r3,4(r2)
				break;
81112fe8:	0000c506 	br	81113300 <vSimMebTask+0x3a8>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
81112fec:	d0a06117 	ldw	r2,-32380(gp)
81112ff0:	100f883a 	mov	r7,r2
81112ff4:	01800584 	movi	r6,22
81112ff8:	01400044 	movi	r5,1
81112ffc:	01204574 	movhi	r4,33045
81113000:	2128e604 	addi	r4,r4,-23656
81113004:	111dcb00 	call	8111dcb0 <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81113008:	111babc0 	call	8111babc <bStopSync>
				vSyncClearCounter();
8111300c:	110c2940 	call	8110c294 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81113010:	11141e80 	call	811141e8 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81113014:	01c00284 	movi	r7,10
81113018:	000d883a 	mov	r6,zero
8111301c:	000b883a 	mov	r5,zero
81113020:	0009883a 	mov	r4,zero
81113024:	113d6880 	call	8113d688 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81113028:	000d883a 	mov	r6,zero
8111302c:	000b883a 	mov	r5,zero
81113030:	01002844 	movi	r4,161
81113034:	1113e4c0 	call	81113e4c <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81113038:	000d883a 	mov	r6,zero
8111303c:	000b883a 	mov	r5,zero
81113040:	01002844 	movi	r4,161
81113044:	1113ff00 	call	81113ff0 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81113048:	01c03e84 	movi	r7,250
8111304c:	000d883a 	mov	r6,zero
81113050:	000b883a 	mov	r5,zero
81113054:	0009883a 	mov	r4,zero
81113058:	113d6880 	call	8113d688 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
8111305c:	e0bffc17 	ldw	r2,-16(fp)
81113060:	00c000c4 	movi	r3,3
81113064:	10c00115 	stw	r3,4(r2)
				break;
81113068:	0000a506 	br	81113300 <vSimMebTask+0x3a8>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
8111306c:	d0a06117 	ldw	r2,-32380(gp)
81113070:	100f883a 	mov	r7,r2
81113074:	018004c4 	movi	r6,19
81113078:	01400044 	movi	r5,1
8111307c:	01204574 	movhi	r4,33045
81113080:	2128ec04 	addi	r4,r4,-23632
81113084:	111dcb00 	call	8111dcb0 <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81113088:	000d883a 	mov	r6,zero
8111308c:	000b883a 	mov	r5,zero
81113090:	01002884 	movi	r4,162
81113094:	1113e4c0 	call	81113e4c <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
81113098:	000d883a 	mov	r6,zero
8111309c:	000b883a 	mov	r5,zero
811130a0:	01002884 	movi	r4,162
811130a4:	1113ff00 	call	81113ff0 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
811130a8:	e0bffc17 	ldw	r2,-16(fp)
811130ac:	1080050b 	ldhu	r2,20(r2)
811130b0:	10bfffcc 	andi	r2,r2,65535
811130b4:	100f883a 	mov	r7,r2
811130b8:	000d883a 	mov	r6,zero
811130bc:	000b883a 	mov	r5,zero
811130c0:	0009883a 	mov	r4,zero
811130c4:	113d6880 	call	8113d688 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
811130c8:	e03ffb05 	stb	zero,-20(fp)
811130cc:	00001006 	br	81113110 <vSimMebTask+0x1b8>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
811130d0:	e0bffb03 	ldbu	r2,-20(fp)
811130d4:	10809624 	muli	r2,r2,600
811130d8:	10809b04 	addi	r2,r2,620
811130dc:	e0fffc17 	ldw	r3,-16(fp)
811130e0:	1885883a 	add	r2,r3,r2
811130e4:	1009883a 	mov	r4,r2
811130e8:	1109d580 	call	81109d58 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
811130ec:	e0bffb03 	ldbu	r2,-20(fp)
811130f0:	e0fffc17 	ldw	r3,-16(fp)
811130f4:	10809624 	muli	r2,r2,600
811130f8:	1885883a 	add	r2,r3,r2
811130fc:	10803c04 	addi	r2,r2,240
81113100:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81113104:	e0bffb03 	ldbu	r2,-20(fp)
81113108:	10800044 	addi	r2,r2,1
8111310c:	e0bffb05 	stb	r2,-20(fp)
81113110:	e0bffb03 	ldbu	r2,-20(fp)
81113114:	103fee26 	beq	r2,zero,811130d0 <__reset+0xfb0f30d0>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
81113118:	110c8e40 	call	8110c8e4 <bSyncCtrReset>
				vSyncClearCounter();
8111311c:	110c2940 	call	8110c294 <vSyncClearCounter>
				bStartSync();
81113120:	111ba800 	call	8111ba80 <bStartSync>

				vEvtChangeMebMode();
81113124:	111a4a40 	call	8111a4a4 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81113128:	e0bffc17 	ldw	r2,-16(fp)
8111312c:	00c00104 	movi	r3,4
81113130:	10c00115 	stw	r3,4(r2)
				break;
81113134:	00007206 	br	81113300 <vSimMebTask+0x3a8>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81113138:	d0a06817 	ldw	r2,-32352(gp)
8111313c:	e0fffe04 	addi	r3,fp,-8
81113140:	180d883a 	mov	r6,r3
81113144:	000b883a 	mov	r5,zero
81113148:	1009883a 	mov	r4,r2
8111314c:	113a7f80 	call	8113a7f8 <OSQPend>
81113150:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81113154:	e0bffe03 	ldbu	r2,-8(fp)
81113158:	10803fcc 	andi	r2,r2,255
8111315c:	1000291e 	bne	r2,zero,81113204 <vSimMebTask+0x2ac>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81113160:	e0bffdc3 	ldbu	r2,-9(fp)
81113164:	10803fcc 	andi	r2,r2,255
81113168:	10800058 	cmpnei	r2,r2,1
8111316c:	10001c1e 	bne	r2,zero,811131e0 <vSimMebTask+0x288>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81113170:	e0bffd83 	ldbu	r2,-10(fp)
81113174:	10803fcc 	andi	r2,r2,255
81113178:	10c00060 	cmpeqi	r3,r2,1
8111317c:	1800031e 	bne	r3,zero,8111318c <vSimMebTask+0x234>
81113180:	10803820 	cmpeqi	r2,r2,224
81113184:	1000041e 	bne	r2,zero,81113198 <vSimMebTask+0x240>
81113188:	00000b06 	br	811131b8 <vSimMebTask+0x260>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
8111318c:	e13ffc17 	ldw	r4,-16(fp)
81113190:	11133040 	call	81113304 <vPusMebTask>
								break;
81113194:	00001d06 	br	8111320c <vSimMebTask+0x2b4>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81113198:	d0a06117 	ldw	r2,-32380(gp)
8111319c:	100f883a 	mov	r7,r2
811131a0:	018012c4 	movi	r6,75
811131a4:	01400044 	movi	r5,1
811131a8:	01204574 	movhi	r4,33045
811131ac:	2128f104 	addi	r4,r4,-23612
811131b0:	111dcb00 	call	8111dcb0 <fwrite>
								#endif
								break;
811131b4:	00001506 	br	8111320c <vSimMebTask+0x2b4>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
811131b8:	d0a06117 	ldw	r2,-32380(gp)
811131bc:	e0fffd83 	ldbu	r3,-10(fp)
811131c0:	18c03fcc 	andi	r3,r3,255
811131c4:	180d883a 	mov	r6,r3
811131c8:	01604574 	movhi	r5,33045
811131cc:	29690404 	addi	r5,r5,-23536
811131d0:	1009883a 	mov	r4,r2
811131d4:	111d6140 	call	8111d614 <fprintf>
								#endif
								break;
811131d8:	0001883a 	nop
811131dc:	00000b06 	br	8111320c <vSimMebTask+0x2b4>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
811131e0:	d0a06117 	ldw	r2,-32380(gp)
811131e4:	e0fffdc3 	ldbu	r3,-9(fp)
811131e8:	18c03fcc 	andi	r3,r3,255
811131ec:	180d883a 	mov	r6,r3
811131f0:	01604574 	movhi	r5,33045
811131f4:	29691604 	addi	r5,r5,-23464
811131f8:	1009883a 	mov	r4,r2
811131fc:	111d6140 	call	8111d614 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81113200:	00003f06 	br	81113300 <vSimMebTask+0x3a8>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81113204:	1119e440 	call	81119e44 <vCouldNotGetCmdQueueMeb>
				}

				break;
81113208:	00003d06 	br	81113300 <vSimMebTask+0x3a8>
8111320c:	00003c06 	br	81113300 <vSimMebTask+0x3a8>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81113210:	d0a06817 	ldw	r2,-32352(gp)
81113214:	e0fffe04 	addi	r3,fp,-8
81113218:	180d883a 	mov	r6,r3
8111321c:	000b883a 	mov	r5,zero
81113220:	1009883a 	mov	r4,r2
81113224:	113a7f80 	call	8113a7f8 <OSQPend>
81113228:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8111322c:	e0bffe03 	ldbu	r2,-8(fp)
81113230:	10803fcc 	andi	r2,r2,255
81113234:	1000241e 	bne	r2,zero,811132c8 <vSimMebTask+0x370>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81113238:	e0bffdc3 	ldbu	r2,-9(fp)
8111323c:	10803fcc 	andi	r2,r2,255
81113240:	10800058 	cmpnei	r2,r2,1
81113244:	1000171e 	bne	r2,zero,811132a4 <vSimMebTask+0x34c>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81113248:	e0bffd83 	ldbu	r2,-10(fp)
8111324c:	10803fcc 	andi	r2,r2,255
81113250:	10c00060 	cmpeqi	r3,r2,1
81113254:	1800031e 	bne	r3,zero,81113264 <vSimMebTask+0x30c>
81113258:	10803820 	cmpeqi	r2,r2,224
8111325c:	1000041e 	bne	r2,zero,81113270 <vSimMebTask+0x318>
81113260:	00000606 	br	8111327c <vSimMebTask+0x324>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81113264:	e13ffc17 	ldw	r4,-16(fp)
81113268:	11133040 	call	81113304 <vPusMebTask>
								break;
8111326c:	00001806 	br	811132d0 <vSimMebTask+0x378>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81113270:	e13ffc17 	ldw	r4,-16(fp)
81113274:	11140dc0 	call	811140dc <vSwapMemmory>

								break;
81113278:	00001506 	br	811132d0 <vSimMebTask+0x378>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
8111327c:	d0a06117 	ldw	r2,-32380(gp)
81113280:	e0fffd83 	ldbu	r3,-10(fp)
81113284:	18c03fcc 	andi	r3,r3,255
81113288:	180d883a 	mov	r6,r3
8111328c:	01604574 	movhi	r5,33045
81113290:	29692404 	addi	r5,r5,-23408
81113294:	1009883a 	mov	r4,r2
81113298:	111d6140 	call	8111d614 <fprintf>
								#endif
								break;
8111329c:	0001883a 	nop
811132a0:	00000b06 	br	811132d0 <vSimMebTask+0x378>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
811132a4:	d0a06117 	ldw	r2,-32380(gp)
811132a8:	e0fffdc3 	ldbu	r3,-9(fp)
811132ac:	18c03fcc 	andi	r3,r3,255
811132b0:	180d883a 	mov	r6,r3
811132b4:	01604574 	movhi	r5,33045
811132b8:	29691604 	addi	r5,r5,-23464
811132bc:	1009883a 	mov	r4,r2
811132c0:	111d6140 	call	8111d614 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
811132c4:	00000e06 	br	81113300 <vSimMebTask+0x3a8>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811132c8:	1119e440 	call	81119e44 <vCouldNotGetCmdQueueMeb>
				}			
				break;
811132cc:	00000c06 	br	81113300 <vSimMebTask+0x3a8>
811132d0:	00000b06 	br	81113300 <vSimMebTask+0x3a8>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
811132d4:	d0a06117 	ldw	r2,-32380(gp)
811132d8:	100f883a 	mov	r7,r2
811132dc:	01800bc4 	movi	r6,47
811132e0:	01400044 	movi	r5,1
811132e4:	01204574 	movhi	r4,33045
811132e8:	21292d04 	addi	r4,r4,-23372
811132ec:	111dcb00 	call	8111dcb0 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
811132f0:	e0bffc17 	ldw	r2,-16(fp)
811132f4:	00c00044 	movi	r3,1
811132f8:	10c00115 	stw	r3,4(r2)
				break;
811132fc:	0001883a 	nop
		}
	}
81113300:	003f2506 	br	81112f98 <__reset+0xfb0f2f98>

81113304 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81113304:	defffb04 	addi	sp,sp,-20
81113308:	de00012e 	bgeu	sp,et,81113310 <vPusMebTask+0xc>
8111330c:	003b68fa 	trap	3
81113310:	dfc00415 	stw	ra,16(sp)
81113314:	df000315 	stw	fp,12(sp)
81113318:	df000304 	addi	fp,sp,12
8111331c:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
81113320:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
81113324:	d0a07217 	ldw	r2,-32312(gp)
81113328:	e0fffe44 	addi	r3,fp,-7
8111332c:	180d883a 	mov	r6,r3
81113330:	01400084 	movi	r5,2
81113334:	1009883a 	mov	r4,r2
81113338:	11396e40 	call	811396e4 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
8111333c:	e0bffe43 	ldbu	r2,-7(fp)
81113340:	10803fcc 	andi	r2,r2,255
81113344:	10002c1e 	bne	r2,zero,811133f8 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81113348:	e03ffe05 	stb	zero,-8(fp)
8111334c:	00002306 	br	811133dc <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81113350:	e0fffe03 	ldbu	r3,-8(fp)
81113354:	00a04574 	movhi	r2,33045
81113358:	1088d304 	addi	r2,r2,9036
8111335c:	18c01524 	muli	r3,r3,84
81113360:	10c5883a 	add	r2,r2,r3
81113364:	10800104 	addi	r2,r2,4
81113368:	10800017 	ldw	r2,0(r2)
8111336c:	10800058 	cmpnei	r2,r2,1
81113370:	1000171e 	bne	r2,zero,811133d0 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81113374:	e13ffe03 	ldbu	r4,-8(fp)
81113378:	00e04574 	movhi	r3,33045
8111337c:	18fe5004 	addi	r3,r3,-1728
81113380:	00a04574 	movhi	r2,33045
81113384:	1088d304 	addi	r2,r2,9036
81113388:	21001524 	muli	r4,r4,84
8111338c:	1105883a 	add	r2,r2,r4
81113390:	1009883a 	mov	r4,r2
81113394:	00801504 	movi	r2,84
81113398:	100d883a 	mov	r6,r2
8111339c:	200b883a 	mov	r5,r4
811133a0:	1809883a 	mov	r4,r3
811133a4:	111e6c40 	call	8111e6c4 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
811133a8:	e0fffe03 	ldbu	r3,-8(fp)
811133ac:	00a04574 	movhi	r2,33045
811133b0:	1088d304 	addi	r2,r2,9036
811133b4:	18c01524 	muli	r3,r3,84
811133b8:	10c5883a 	add	r2,r2,r3
811133bc:	10800104 	addi	r2,r2,4
811133c0:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
811133c4:	00800044 	movi	r2,1
811133c8:	e0bffd15 	stw	r2,-12(fp)
                break;
811133cc:	00000606 	br	811133e8 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811133d0:	e0bffe03 	ldbu	r2,-8(fp)
811133d4:	10800044 	addi	r2,r2,1
811133d8:	e0bffe05 	stb	r2,-8(fp)
811133dc:	e0bffe03 	ldbu	r2,-8(fp)
811133e0:	10800130 	cmpltui	r2,r2,4
811133e4:	103fda1e 	bne	r2,zero,81113350 <__reset+0xfb0f3350>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
811133e8:	d0a07217 	ldw	r2,-32312(gp)
811133ec:	1009883a 	mov	r4,r2
811133f0:	1139c880 	call	81139c88 <OSMutexPost>
811133f4:	00000106 	br	811133fc <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
811133f8:	1119eac0 	call	81119eac <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
811133fc:	e0bffd17 	ldw	r2,-12(fp)
81113400:	10001126 	beq	r2,zero,81113448 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81113404:	e0bfff17 	ldw	r2,-4(fp)
81113408:	10800117 	ldw	r2,4(r2)
8111340c:	10c000e0 	cmpeqi	r3,r2,3
81113410:	1800031e 	bne	r3,zero,81113420 <vPusMebTask+0x11c>
81113414:	10800120 	cmpeqi	r2,r2,4
81113418:	1000061e 	bne	r2,zero,81113434 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
8111341c:	00000a06 	br	81113448 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81113420:	01604574 	movhi	r5,33045
81113424:	297e5004 	addi	r5,r5,-1728
81113428:	e13fff17 	ldw	r4,-4(fp)
8111342c:	11134600 	call	81113460 <vPusMebInTaskConfigMode>
				break;
81113430:	00000506 	br	81113448 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81113434:	01604574 	movhi	r5,33045
81113438:	297e5004 	addi	r5,r5,-1728
8111343c:	e13fff17 	ldw	r4,-4(fp)
81113440:	11137f00 	call	811137f0 <vPusMebInTaskRunningMode>
				break;
81113444:	0001883a 	nop
			default:
				break;
		}
	}
}
81113448:	0001883a 	nop
8111344c:	e037883a 	mov	sp,fp
81113450:	dfc00117 	ldw	ra,4(sp)
81113454:	df000017 	ldw	fp,0(sp)
81113458:	dec00204 	addi	sp,sp,8
8111345c:	f800283a 	ret

81113460 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81113460:	defffc04 	addi	sp,sp,-16
81113464:	de00012e 	bgeu	sp,et,8111346c <vPusMebInTaskConfigMode+0xc>
81113468:	003b68fa 	trap	3
8111346c:	dfc00315 	stw	ra,12(sp)
81113470:	df000215 	stw	fp,8(sp)
81113474:	df000204 	addi	fp,sp,8
81113478:	e13ffe15 	stw	r4,-8(fp)
8111347c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81113480:	e0bfff17 	ldw	r2,-4(fp)
81113484:	1080030b 	ldhu	r2,12(r2)
81113488:	10bfffcc 	andi	r2,r2,65535
8111348c:	10c03ee0 	cmpeqi	r3,r2,251
81113490:	1800081e 	bne	r3,zero,811134b4 <vPusMebInTaskConfigMode+0x54>
81113494:	10c03f20 	cmpeqi	r3,r2,252
81113498:	18000a1e 	bne	r3,zero,811134c4 <vPusMebInTaskConfigMode+0x64>
8111349c:	10803ea0 	cmpeqi	r2,r2,250
811134a0:	10000c26 	beq	r2,zero,811134d4 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
811134a4:	e17fff17 	ldw	r5,-4(fp)
811134a8:	e13ffe17 	ldw	r4,-8(fp)
811134ac:	111350c0 	call	8111350c <vPusType250conf>
			break;
811134b0:	00001006 	br	811134f4 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
811134b4:	e17fff17 	ldw	r5,-4(fp)
811134b8:	e13ffe17 	ldw	r4,-8(fp)
811134bc:	11135980 	call	81113598 <vPusType251conf>
			break;
811134c0:	00000c06 	br	811134f4 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
811134c4:	e17fff17 	ldw	r5,-4(fp)
811134c8:	e13ffe17 	ldw	r4,-8(fp)
811134cc:	11135ec0 	call	811135ec <vPusType252conf>
			break;
811134d0:	00000806 	br	811134f4 <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
811134d4:	d0a06117 	ldw	r2,-32380(gp)
811134d8:	100f883a 	mov	r7,r2
811134dc:	01800d84 	movi	r6,54
811134e0:	01400044 	movi	r5,1
811134e4:	01204574 	movhi	r4,33045
811134e8:	21293904 	addi	r4,r4,-23324
811134ec:	111dcb00 	call	8111dcb0 <fwrite>
			#endif
			break;
811134f0:	0001883a 	nop
	}
}
811134f4:	0001883a 	nop
811134f8:	e037883a 	mov	sp,fp
811134fc:	dfc00117 	ldw	ra,4(sp)
81113500:	df000017 	ldw	fp,0(sp)
81113504:	dec00204 	addi	sp,sp,8
81113508:	f800283a 	ret

8111350c <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111350c:	defffc04 	addi	sp,sp,-16
81113510:	de00012e 	bgeu	sp,et,81113518 <vPusType250conf+0xc>
81113514:	003b68fa 	trap	3
81113518:	dfc00315 	stw	ra,12(sp)
8111351c:	df000215 	stw	fp,8(sp)
81113520:	df000204 	addi	fp,sp,8
81113524:	e13ffe15 	stw	r4,-8(fp)
81113528:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
8111352c:	e0bfff17 	ldw	r2,-4(fp)
81113530:	1080038b 	ldhu	r2,14(r2)
81113534:	10bfffcc 	andi	r2,r2,65535
81113538:	10c00f60 	cmpeqi	r3,r2,61
8111353c:	1800031e 	bne	r3,zero,8111354c <vPusType250conf+0x40>
81113540:	10800fa0 	cmpeqi	r2,r2,62
81113544:	10000d1e 	bne	r2,zero,8111357c <vPusType250conf+0x70>
81113548:	00000406 	br	8111355c <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
8111354c:	e0bffe17 	ldw	r2,-8(fp)
81113550:	00c00084 	movi	r3,2
81113554:	10c00115 	stw	r3,4(r2)
			break;
81113558:	00000906 	br	81113580 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
8111355c:	d0a06117 	ldw	r2,-32380(gp)
81113560:	100f883a 	mov	r7,r2
81113564:	01800b04 	movi	r6,44
81113568:	01400044 	movi	r5,1
8111356c:	01204574 	movhi	r4,33045
81113570:	21294704 	addi	r4,r4,-23268
81113574:	111dcb00 	call	8111dcb0 <fwrite>
			#endif
			break;
81113578:	00000106 	br	81113580 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
8111357c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81113580:	0001883a 	nop
81113584:	e037883a 	mov	sp,fp
81113588:	dfc00117 	ldw	ra,4(sp)
8111358c:	df000017 	ldw	fp,0(sp)
81113590:	dec00204 	addi	sp,sp,8
81113594:	f800283a 	ret

81113598 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81113598:	defffc04 	addi	sp,sp,-16
8111359c:	de00012e 	bgeu	sp,et,811135a4 <vPusType251conf+0xc>
811135a0:	003b68fa 	trap	3
811135a4:	dfc00315 	stw	ra,12(sp)
811135a8:	df000215 	stw	fp,8(sp)
811135ac:	df000204 	addi	fp,sp,8
811135b0:	e13ffe15 	stw	r4,-8(fp)
811135b4:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
811135b8:	d0a06117 	ldw	r2,-32380(gp)
811135bc:	100f883a 	mov	r7,r2
811135c0:	01801184 	movi	r6,70
811135c4:	01400044 	movi	r5,1
811135c8:	01204574 	movhi	r4,33045
811135cc:	21295304 	addi	r4,r4,-23220
811135d0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
}
811135d4:	0001883a 	nop
811135d8:	e037883a 	mov	sp,fp
811135dc:	dfc00117 	ldw	ra,4(sp)
811135e0:	df000017 	ldw	fp,0(sp)
811135e4:	dec00204 	addi	sp,sp,8
811135e8:	f800283a 	ret

811135ec <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811135ec:	defffb04 	addi	sp,sp,-20
811135f0:	de00012e 	bgeu	sp,et,811135f8 <vPusType252conf+0xc>
811135f4:	003b68fa 	trap	3
811135f8:	dfc00415 	stw	ra,16(sp)
811135fc:	df000315 	stw	fp,12(sp)
81113600:	df000304 	addi	fp,sp,12
81113604:	e13ffe15 	stw	r4,-8(fp)
81113608:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
8111360c:	e0bfff17 	ldw	r2,-4(fp)
81113610:	1080050b 	ldhu	r2,20(r2)
81113614:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81113618:	e0bfff17 	ldw	r2,-4(fp)
8111361c:	1080038b 	ldhu	r2,14(r2)
81113620:	10bfffcc 	andi	r2,r2,65535
81113624:	10c000a0 	cmpeqi	r3,r2,2
81113628:	18000c1e 	bne	r3,zero,8111365c <vPusType252conf+0x70>
8111362c:	10c00090 	cmplti	r3,r2,2
81113630:	1800611e 	bne	r3,zero,811137b8 <vPusType252conf+0x1cc>
81113634:	10800188 	cmpgei	r2,r2,6
81113638:	10005f1e 	bne	r2,zero,811137b8 <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
8111363c:	d0a06117 	ldw	r2,-32380(gp)
81113640:	100f883a 	mov	r7,r2
81113644:	01801384 	movi	r6,78
81113648:	01400044 	movi	r5,1
8111364c:	01204574 	movhi	r4,33045
81113650:	21296504 	addi	r4,r4,-23148
81113654:	111dcb00 	call	8111dcb0 <fwrite>
			#endif
			break;
81113658:	00005f06 	br	811137d8 <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111365c:	e0bffd0b 	ldhu	r2,-12(fp)
81113660:	10809624 	muli	r2,r2,600
81113664:	10805504 	addi	r2,r2,340
81113668:	e0fffe17 	ldw	r3,-8(fp)
8111366c:	1885883a 	add	r2,r3,r2
81113670:	1009883a 	mov	r4,r2
81113674:	110749c0 	call	8110749c <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81113678:	e0bffd0b 	ldhu	r2,-12(fp)
8111367c:	e0fffe17 	ldw	r3,-8(fp)
81113680:	10809624 	muli	r2,r2,600
81113684:	1885883a 	add	r2,r3,r2
81113688:	10806504 	addi	r2,r2,404
8111368c:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81113690:	e0bffd0b 	ldhu	r2,-12(fp)
81113694:	10809624 	muli	r2,r2,600
81113698:	10805504 	addi	r2,r2,340
8111369c:	e0fffe17 	ldw	r3,-8(fp)
811136a0:	1885883a 	add	r2,r3,r2
811136a4:	1009883a 	mov	r4,r2
811136a8:	11073f40 	call	811073f4 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811136ac:	e0bffd0b 	ldhu	r2,-12(fp)
811136b0:	10809624 	muli	r2,r2,600
811136b4:	10805504 	addi	r2,r2,340
811136b8:	e0fffe17 	ldw	r3,-8(fp)
811136bc:	1885883a 	add	r2,r3,r2
811136c0:	1009883a 	mov	r4,r2
811136c4:	11076840 	call	81107684 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811136c8:	e0bffd0b 	ldhu	r2,-12(fp)
811136cc:	e0ffff17 	ldw	r3,-4(fp)
811136d0:	18c00b0b 	ldhu	r3,44(r3)
811136d4:	1809883a 	mov	r4,r3
811136d8:	e0fffe17 	ldw	r3,-8(fp)
811136dc:	10809624 	muli	r2,r2,600
811136e0:	1885883a 	add	r2,r3,r2
811136e4:	10805604 	addi	r2,r2,344
811136e8:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
811136ec:	e0bffd0b 	ldhu	r2,-12(fp)
811136f0:	e0ffff17 	ldw	r3,-4(fp)
811136f4:	18c0098b 	ldhu	r3,38(r3)
811136f8:	1809883a 	mov	r4,r3
811136fc:	e0fffe17 	ldw	r3,-8(fp)
81113700:	10809624 	muli	r2,r2,600
81113704:	1885883a 	add	r2,r3,r2
81113708:	10805644 	addi	r2,r2,345
8111370c:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81113710:	e0bffd0b 	ldhu	r2,-12(fp)
81113714:	10809624 	muli	r2,r2,600
81113718:	10805504 	addi	r2,r2,340
8111371c:	e0fffe17 	ldw	r3,-8(fp)
81113720:	1885883a 	add	r2,r3,r2
81113724:	1009883a 	mov	r4,r2
81113728:	11075ac0 	call	811075ac <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111372c:	e0bffd0b 	ldhu	r2,-12(fp)
81113730:	10809624 	muli	r2,r2,600
81113734:	10805504 	addi	r2,r2,340
81113738:	e0fffe17 	ldw	r3,-8(fp)
8111373c:	1885883a 	add	r2,r3,r2
81113740:	1009883a 	mov	r4,r2
81113744:	110749c0 	call	8110749c <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81113748:	e0bffd0b 	ldhu	r2,-12(fp)
8111374c:	e0fffe17 	ldw	r3,-8(fp)
81113750:	10809624 	muli	r2,r2,600
81113754:	1885883a 	add	r2,r3,r2
81113758:	10806504 	addi	r2,r2,404
8111375c:	00c00044 	movi	r3,1
81113760:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81113764:	e0bffd0b 	ldhu	r2,-12(fp)
81113768:	10809624 	muli	r2,r2,600
8111376c:	10805504 	addi	r2,r2,340
81113770:	e0fffe17 	ldw	r3,-8(fp)
81113774:	1885883a 	add	r2,r3,r2
81113778:	1009883a 	mov	r4,r2
8111377c:	11073f40 	call	811073f4 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81113780:	d0e06117 	ldw	r3,-32380(gp)
81113784:	e0bfff17 	ldw	r2,-4(fp)
81113788:	10800b0b 	ldhu	r2,44(r2)
8111378c:	113fffcc 	andi	r4,r2,65535
81113790:	e0bfff17 	ldw	r2,-4(fp)
81113794:	1080098b 	ldhu	r2,38(r2)
81113798:	10bfffcc 	andi	r2,r2,65535
8111379c:	100f883a 	mov	r7,r2
811137a0:	200d883a 	mov	r6,r4
811137a4:	01604574 	movhi	r5,33045
811137a8:	29697904 	addi	r5,r5,-23068
811137ac:	1809883a 	mov	r4,r3
811137b0:	111d6140 	call	8111d614 <fprintf>
			#endif

			break;
811137b4:	00000806 	br	811137d8 <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
811137b8:	d0a06117 	ldw	r2,-32380(gp)
811137bc:	100f883a 	mov	r7,r2
811137c0:	01800b04 	movi	r6,44
811137c4:	01400044 	movi	r5,1
811137c8:	01204574 	movhi	r4,33045
811137cc:	21294704 	addi	r4,r4,-23268
811137d0:	111dcb00 	call	8111dcb0 <fwrite>
			#endif
			break;
811137d4:	0001883a 	nop
	}
}
811137d8:	0001883a 	nop
811137dc:	e037883a 	mov	sp,fp
811137e0:	dfc00117 	ldw	ra,4(sp)
811137e4:	df000017 	ldw	fp,0(sp)
811137e8:	dec00204 	addi	sp,sp,8
811137ec:	f800283a 	ret

811137f0 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811137f0:	defffc04 	addi	sp,sp,-16
811137f4:	de00012e 	bgeu	sp,et,811137fc <vPusMebInTaskRunningMode+0xc>
811137f8:	003b68fa 	trap	3
811137fc:	dfc00315 	stw	ra,12(sp)
81113800:	df000215 	stw	fp,8(sp)
81113804:	df000204 	addi	fp,sp,8
81113808:	e13ffe15 	stw	r4,-8(fp)
8111380c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81113810:	e0bfff17 	ldw	r2,-4(fp)
81113814:	1080030b 	ldhu	r2,12(r2)
81113818:	10bfffcc 	andi	r2,r2,65535
8111381c:	10c03ee0 	cmpeqi	r3,r2,251
81113820:	1800081e 	bne	r3,zero,81113844 <vPusMebInTaskRunningMode+0x54>
81113824:	10c03f20 	cmpeqi	r3,r2,252
81113828:	18000a1e 	bne	r3,zero,81113854 <vPusMebInTaskRunningMode+0x64>
8111382c:	10803ea0 	cmpeqi	r2,r2,250
81113830:	10000c26 	beq	r2,zero,81113864 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81113834:	e17fff17 	ldw	r5,-4(fp)
81113838:	e13ffe17 	ldw	r4,-8(fp)
8111383c:	111389c0 	call	8111389c <vPusType250run>
			break;
81113840:	00001006 	br	81113884 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81113844:	e17fff17 	ldw	r5,-4(fp)
81113848:	e13ffe17 	ldw	r4,-8(fp)
8111384c:	11139280 	call	81113928 <vPusType251run>
			break;
81113850:	00000c06 	br	81113884 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
81113854:	e17fff17 	ldw	r5,-4(fp)
81113858:	e13ffe17 	ldw	r4,-8(fp)
8111385c:	1113a3c0 	call	81113a3c <vPusType252run>
			break;
81113860:	00000806 	br	81113884 <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
81113864:	d0a06117 	ldw	r2,-32380(gp)
81113868:	100f883a 	mov	r7,r2
8111386c:	01800cc4 	movi	r6,51
81113870:	01400044 	movi	r5,1
81113874:	01204574 	movhi	r4,33045
81113878:	21298904 	addi	r4,r4,-23004
8111387c:	111dcb00 	call	8111dcb0 <fwrite>
			#endif
			break;
81113880:	0001883a 	nop
	}
}
81113884:	0001883a 	nop
81113888:	e037883a 	mov	sp,fp
8111388c:	dfc00117 	ldw	ra,4(sp)
81113890:	df000017 	ldw	fp,0(sp)
81113894:	dec00204 	addi	sp,sp,8
81113898:	f800283a 	ret

8111389c <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111389c:	defffc04 	addi	sp,sp,-16
811138a0:	de00012e 	bgeu	sp,et,811138a8 <vPusType250run+0xc>
811138a4:	003b68fa 	trap	3
811138a8:	dfc00315 	stw	ra,12(sp)
811138ac:	df000215 	stw	fp,8(sp)
811138b0:	df000204 	addi	fp,sp,8
811138b4:	e13ffe15 	stw	r4,-8(fp)
811138b8:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811138bc:	e0bfff17 	ldw	r2,-4(fp)
811138c0:	1080038b 	ldhu	r2,14(r2)
811138c4:	10bfffcc 	andi	r2,r2,65535
811138c8:	10c00f20 	cmpeqi	r3,r2,60
811138cc:	1800031e 	bne	r3,zero,811138dc <vPusType250run+0x40>
811138d0:	10800fa0 	cmpeqi	r2,r2,62
811138d4:	10000d1e 	bne	r2,zero,8111390c <vPusType250run+0x70>
811138d8:	00000406 	br	811138ec <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
811138dc:	e0bffe17 	ldw	r2,-8(fp)
811138e0:	00c00044 	movi	r3,1
811138e4:	10c00115 	stw	r3,4(r2)
			break;
811138e8:	00000906 	br	81113910 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
811138ec:	d0a06117 	ldw	r2,-32380(gp)
811138f0:	100f883a 	mov	r7,r2
811138f4:	01800c84 	movi	r6,50
811138f8:	01400044 	movi	r5,1
811138fc:	01204574 	movhi	r4,33045
81113900:	21299604 	addi	r4,r4,-22952
81113904:	111dcb00 	call	8111dcb0 <fwrite>
			#endif
			break;
81113908:	00000106 	br	81113910 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
8111390c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81113910:	0001883a 	nop
81113914:	e037883a 	mov	sp,fp
81113918:	dfc00117 	ldw	ra,4(sp)
8111391c:	df000017 	ldw	fp,0(sp)
81113920:	dec00204 	addi	sp,sp,8
81113924:	f800283a 	ret

81113928 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81113928:	defffb04 	addi	sp,sp,-20
8111392c:	de00012e 	bgeu	sp,et,81113934 <vPusType251run+0xc>
81113930:	003b68fa 	trap	3
81113934:	dfc00415 	stw	ra,16(sp)
81113938:	df000315 	stw	fp,12(sp)
8111393c:	df000304 	addi	fp,sp,12
81113940:	e13ffe15 	stw	r4,-8(fp)
81113944:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81113948:	e0bfff17 	ldw	r2,-4(fp)
8111394c:	1080050b 	ldhu	r2,20(r2)
81113950:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81113954:	e0bfff17 	ldw	r2,-4(fp)
81113958:	1080038b 	ldhu	r2,14(r2)
8111395c:	10bfffcc 	andi	r2,r2,65535
81113960:	10c000a0 	cmpeqi	r3,r2,2
81113964:	18000f1e 	bne	r3,zero,811139a4 <vPusType251run+0x7c>
81113968:	10c00160 	cmpeqi	r3,r2,5
8111396c:	1800181e 	bne	r3,zero,811139d0 <vPusType251run+0xa8>
81113970:	10800060 	cmpeqi	r2,r2,1
81113974:	10002126 	beq	r2,zero,811139fc <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81113978:	e0bffd0b 	ldhu	r2,-12(fp)
8111397c:	10800444 	addi	r2,r2,17
81113980:	10803fcc 	andi	r2,r2,255
81113984:	e0fffd0b 	ldhu	r3,-12(fp)
81113988:	18c03fcc 	andi	r3,r3,255
8111398c:	180f883a 	mov	r7,r3
81113990:	000d883a 	mov	r6,zero
81113994:	01400044 	movi	r5,1
81113998:	1009883a 	mov	r4,r2
8111399c:	1113ed40 	call	81113ed4 <vSendCmdQToNFeeCTRL_GEN>
			break;
811139a0:	00002006 	br	81113a24 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
811139a4:	e0bffd0b 	ldhu	r2,-12(fp)
811139a8:	10800444 	addi	r2,r2,17
811139ac:	10803fcc 	andi	r2,r2,255
811139b0:	e0fffd0b 	ldhu	r3,-12(fp)
811139b4:	18c03fcc 	andi	r3,r3,255
811139b8:	180f883a 	mov	r7,r3
811139bc:	000d883a 	mov	r6,zero
811139c0:	01400104 	movi	r5,4
811139c4:	1009883a 	mov	r4,r2
811139c8:	1113ed40 	call	81113ed4 <vSendCmdQToNFeeCTRL_GEN>
			break;
811139cc:	00001506 	br	81113a24 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
811139d0:	e0bffd0b 	ldhu	r2,-12(fp)
811139d4:	10800444 	addi	r2,r2,17
811139d8:	10803fcc 	andi	r2,r2,255
811139dc:	e0fffd0b 	ldhu	r3,-12(fp)
811139e0:	18c03fcc 	andi	r3,r3,255
811139e4:	180f883a 	mov	r7,r3
811139e8:	000d883a 	mov	r6,zero
811139ec:	01400204 	movi	r5,8
811139f0:	1009883a 	mov	r4,r2
811139f4:	1113ed40 	call	81113ed4 <vSendCmdQToNFeeCTRL_GEN>
			break;
811139f8:	00000a06 	br	81113a24 <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
811139fc:	d0e06117 	ldw	r3,-32380(gp)
81113a00:	e0bfff17 	ldw	r2,-4(fp)
81113a04:	1080038b 	ldhu	r2,14(r2)
81113a08:	10bfffcc 	andi	r2,r2,65535
81113a0c:	100d883a 	mov	r6,r2
81113a10:	01604574 	movhi	r5,33045
81113a14:	2969a304 	addi	r5,r5,-22900
81113a18:	1809883a 	mov	r4,r3
81113a1c:	111d6140 	call	8111d614 <fprintf>
			#endif
			break;
81113a20:	0001883a 	nop
	}
}
81113a24:	0001883a 	nop
81113a28:	e037883a 	mov	sp,fp
81113a2c:	dfc00117 	ldw	ra,4(sp)
81113a30:	df000017 	ldw	fp,0(sp)
81113a34:	dec00204 	addi	sp,sp,8
81113a38:	f800283a 	ret

81113a3c <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81113a3c:	defffb04 	addi	sp,sp,-20
81113a40:	de00012e 	bgeu	sp,et,81113a48 <vPusType252run+0xc>
81113a44:	003b68fa 	trap	3
81113a48:	dfc00415 	stw	ra,16(sp)
81113a4c:	df000315 	stw	fp,12(sp)
81113a50:	df000304 	addi	fp,sp,12
81113a54:	e13ffe15 	stw	r4,-8(fp)
81113a58:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81113a5c:	e0bfff17 	ldw	r2,-4(fp)
81113a60:	1080050b 	ldhu	r2,20(r2)
81113a64:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81113a68:	e0bfff17 	ldw	r2,-4(fp)
81113a6c:	1080038b 	ldhu	r2,14(r2)
81113a70:	10bfffcc 	andi	r2,r2,65535
81113a74:	10c000e0 	cmpeqi	r3,r2,3
81113a78:	18000a1e 	bne	r3,zero,81113aa4 <vPusType252run+0x68>
81113a7c:	10c00108 	cmpgei	r3,r2,4
81113a80:	1800031e 	bne	r3,zero,81113a90 <vPusType252run+0x54>
81113a84:	108000a0 	cmpeqi	r2,r2,2
81113a88:	1000581e 	bne	r2,zero,81113bec <vPusType252run+0x1b0>
81113a8c:	0000be06 	br	81113d88 <vPusType252run+0x34c>
81113a90:	10c00120 	cmpeqi	r3,r2,4
81113a94:	18002c1e 	bne	r3,zero,81113b48 <vPusType252run+0x10c>
81113a98:	10800160 	cmpeqi	r2,r2,5
81113a9c:	1000c21e 	bne	r2,zero,81113da8 <vPusType252run+0x36c>
81113aa0:	0000b906 	br	81113d88 <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81113aa4:	e0bffd0b 	ldhu	r2,-12(fp)
81113aa8:	10809624 	muli	r2,r2,600
81113aac:	10809b04 	addi	r2,r2,620
81113ab0:	e0fffe17 	ldw	r3,-8(fp)
81113ab4:	1885883a 	add	r2,r3,r2
81113ab8:	1009883a 	mov	r4,r2
81113abc:	1109a200 	call	81109a20 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81113ac0:	e0bffd0b 	ldhu	r2,-12(fp)
81113ac4:	e0fffe17 	ldw	r3,-8(fp)
81113ac8:	10809624 	muli	r2,r2,600
81113acc:	1885883a 	add	r2,r3,r2
81113ad0:	10809d04 	addi	r2,r2,628
81113ad4:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81113ad8:	e0bffd0b 	ldhu	r2,-12(fp)
81113adc:	e0fffe17 	ldw	r3,-8(fp)
81113ae0:	10809624 	muli	r2,r2,600
81113ae4:	1885883a 	add	r2,r3,r2
81113ae8:	10809c04 	addi	r2,r2,624
81113aec:	00c00044 	movi	r3,1
81113af0:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81113af4:	e0bffd0b 	ldhu	r2,-12(fp)
81113af8:	e0fffe17 	ldw	r3,-8(fp)
81113afc:	10809624 	muli	r2,r2,600
81113b00:	1885883a 	add	r2,r3,r2
81113b04:	10809e04 	addi	r2,r2,632
81113b08:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81113b0c:	e0bffd0b 	ldhu	r2,-12(fp)
81113b10:	10809624 	muli	r2,r2,600
81113b14:	10809b04 	addi	r2,r2,620
81113b18:	e0fffe17 	ldw	r3,-8(fp)
81113b1c:	1885883a 	add	r2,r3,r2
81113b20:	1009883a 	mov	r4,r2
81113b24:	11098ec0 	call	811098ec <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81113b28:	d0a06117 	ldw	r2,-32380(gp)
81113b2c:	e0fffd0b 	ldhu	r3,-12(fp)
81113b30:	180d883a 	mov	r6,r3
81113b34:	01604574 	movhi	r5,33045
81113b38:	2969b104 	addi	r5,r5,-22844
81113b3c:	1009883a 	mov	r4,r2
81113b40:	111d6140 	call	8111d614 <fprintf>
			#endif

			break;
81113b44:	00009906 	br	81113dac <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81113b48:	e0bffd0b 	ldhu	r2,-12(fp)
81113b4c:	10809624 	muli	r2,r2,600
81113b50:	10809b04 	addi	r2,r2,620
81113b54:	e0fffe17 	ldw	r3,-8(fp)
81113b58:	1885883a 	add	r2,r3,r2
81113b5c:	1009883a 	mov	r4,r2
81113b60:	1109a200 	call	81109a20 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81113b64:	e0bffd0b 	ldhu	r2,-12(fp)
81113b68:	e0fffe17 	ldw	r3,-8(fp)
81113b6c:	10809624 	muli	r2,r2,600
81113b70:	1885883a 	add	r2,r3,r2
81113b74:	10809d04 	addi	r2,r2,628
81113b78:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81113b7c:	e0bffd0b 	ldhu	r2,-12(fp)
81113b80:	e0fffe17 	ldw	r3,-8(fp)
81113b84:	10809624 	muli	r2,r2,600
81113b88:	1885883a 	add	r2,r3,r2
81113b8c:	10809c04 	addi	r2,r2,624
81113b90:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81113b94:	e0bffd0b 	ldhu	r2,-12(fp)
81113b98:	e0fffe17 	ldw	r3,-8(fp)
81113b9c:	10809624 	muli	r2,r2,600
81113ba0:	1885883a 	add	r2,r3,r2
81113ba4:	10809e04 	addi	r2,r2,632
81113ba8:	00c00044 	movi	r3,1
81113bac:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81113bb0:	e0bffd0b 	ldhu	r2,-12(fp)
81113bb4:	10809624 	muli	r2,r2,600
81113bb8:	10809b04 	addi	r2,r2,620
81113bbc:	e0fffe17 	ldw	r3,-8(fp)
81113bc0:	1885883a 	add	r2,r3,r2
81113bc4:	1009883a 	mov	r4,r2
81113bc8:	11098ec0 	call	811098ec <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81113bcc:	d0a06117 	ldw	r2,-32380(gp)
81113bd0:	e0fffd0b 	ldhu	r3,-12(fp)
81113bd4:	180d883a 	mov	r6,r3
81113bd8:	01604574 	movhi	r5,33045
81113bdc:	2969ba04 	addi	r5,r5,-22808
81113be0:	1009883a 	mov	r4,r2
81113be4:	111d6140 	call	8111d614 <fprintf>
			#endif

			break;
81113be8:	00007006 	br	81113dac <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81113bec:	e0bffd0b 	ldhu	r2,-12(fp)
81113bf0:	e0fffe17 	ldw	r3,-8(fp)
81113bf4:	10809624 	muli	r2,r2,600
81113bf8:	1885883a 	add	r2,r3,r2
81113bfc:	10803e04 	addi	r2,r2,248
81113c00:	10800017 	ldw	r2,0(r2)
81113c04:	10800058 	cmpnei	r2,r2,1
81113c08:	10004a1e 	bne	r2,zero,81113d34 <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81113c0c:	e0bffd0b 	ldhu	r2,-12(fp)
81113c10:	10809624 	muli	r2,r2,600
81113c14:	10805504 	addi	r2,r2,340
81113c18:	e0fffe17 	ldw	r3,-8(fp)
81113c1c:	1885883a 	add	r2,r3,r2
81113c20:	1009883a 	mov	r4,r2
81113c24:	110749c0 	call	8110749c <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81113c28:	e0bffd0b 	ldhu	r2,-12(fp)
81113c2c:	e0fffe17 	ldw	r3,-8(fp)
81113c30:	10809624 	muli	r2,r2,600
81113c34:	1885883a 	add	r2,r3,r2
81113c38:	10806504 	addi	r2,r2,404
81113c3c:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81113c40:	e0bffd0b 	ldhu	r2,-12(fp)
81113c44:	10809624 	muli	r2,r2,600
81113c48:	10805504 	addi	r2,r2,340
81113c4c:	e0fffe17 	ldw	r3,-8(fp)
81113c50:	1885883a 	add	r2,r3,r2
81113c54:	1009883a 	mov	r4,r2
81113c58:	11073f40 	call	811073f4 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81113c5c:	e0bffd0b 	ldhu	r2,-12(fp)
81113c60:	10809624 	muli	r2,r2,600
81113c64:	10805504 	addi	r2,r2,340
81113c68:	e0fffe17 	ldw	r3,-8(fp)
81113c6c:	1885883a 	add	r2,r3,r2
81113c70:	1009883a 	mov	r4,r2
81113c74:	11076840 	call	81107684 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81113c78:	e0bffd0b 	ldhu	r2,-12(fp)
81113c7c:	e0ffff17 	ldw	r3,-4(fp)
81113c80:	18c00b0b 	ldhu	r3,44(r3)
81113c84:	1809883a 	mov	r4,r3
81113c88:	e0fffe17 	ldw	r3,-8(fp)
81113c8c:	10809624 	muli	r2,r2,600
81113c90:	1885883a 	add	r2,r3,r2
81113c94:	10805604 	addi	r2,r2,344
81113c98:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81113c9c:	e0bffd0b 	ldhu	r2,-12(fp)
81113ca0:	e0ffff17 	ldw	r3,-4(fp)
81113ca4:	18c0098b 	ldhu	r3,38(r3)
81113ca8:	1809883a 	mov	r4,r3
81113cac:	e0fffe17 	ldw	r3,-8(fp)
81113cb0:	10809624 	muli	r2,r2,600
81113cb4:	1885883a 	add	r2,r3,r2
81113cb8:	10805644 	addi	r2,r2,345
81113cbc:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81113cc0:	e0bffd0b 	ldhu	r2,-12(fp)
81113cc4:	10809624 	muli	r2,r2,600
81113cc8:	10805504 	addi	r2,r2,340
81113ccc:	e0fffe17 	ldw	r3,-8(fp)
81113cd0:	1885883a 	add	r2,r3,r2
81113cd4:	1009883a 	mov	r4,r2
81113cd8:	11075ac0 	call	811075ac <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81113cdc:	e0bffd0b 	ldhu	r2,-12(fp)
81113ce0:	10809624 	muli	r2,r2,600
81113ce4:	10805504 	addi	r2,r2,340
81113ce8:	e0fffe17 	ldw	r3,-8(fp)
81113cec:	1885883a 	add	r2,r3,r2
81113cf0:	1009883a 	mov	r4,r2
81113cf4:	110749c0 	call	8110749c <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81113cf8:	e0bffd0b 	ldhu	r2,-12(fp)
81113cfc:	e0fffe17 	ldw	r3,-8(fp)
81113d00:	10809624 	muli	r2,r2,600
81113d04:	1885883a 	add	r2,r3,r2
81113d08:	10806504 	addi	r2,r2,404
81113d0c:	00c00044 	movi	r3,1
81113d10:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81113d14:	e0bffd0b 	ldhu	r2,-12(fp)
81113d18:	10809624 	muli	r2,r2,600
81113d1c:	10805504 	addi	r2,r2,340
81113d20:	e0fffe17 	ldw	r3,-8(fp)
81113d24:	1885883a 	add	r2,r3,r2
81113d28:	1009883a 	mov	r4,r2
81113d2c:	11073f40 	call	811073f4 <bRmapSetIrqControl>
81113d30:	00000706 	br	81113d50 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81113d34:	d0a06117 	ldw	r2,-32380(gp)
81113d38:	e0fffd0b 	ldhu	r3,-12(fp)
81113d3c:	180d883a 	mov	r6,r3
81113d40:	01604574 	movhi	r5,33045
81113d44:	2969c304 	addi	r5,r5,-22772
81113d48:	1009883a 	mov	r4,r2
81113d4c:	111d6140 	call	8111d614 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81113d50:	d0e06117 	ldw	r3,-32380(gp)
81113d54:	e0bfff17 	ldw	r2,-4(fp)
81113d58:	10800b0b 	ldhu	r2,44(r2)
81113d5c:	113fffcc 	andi	r4,r2,65535
81113d60:	e0bfff17 	ldw	r2,-4(fp)
81113d64:	1080098b 	ldhu	r2,38(r2)
81113d68:	10bfffcc 	andi	r2,r2,65535
81113d6c:	100f883a 	mov	r7,r2
81113d70:	200d883a 	mov	r6,r4
81113d74:	01604574 	movhi	r5,33045
81113d78:	29697904 	addi	r5,r5,-23068
81113d7c:	1809883a 	mov	r4,r3
81113d80:	111d6140 	call	8111d614 <fprintf>
			#endif
			break;
81113d84:	00000906 	br	81113dac <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81113d88:	d0a06117 	ldw	r2,-32380(gp)
81113d8c:	100f883a 	mov	r7,r2
81113d90:	01800c84 	movi	r6,50
81113d94:	01400044 	movi	r5,1
81113d98:	01204574 	movhi	r4,33045
81113d9c:	21299604 	addi	r4,r4,-22952
81113da0:	111dcb00 	call	8111dcb0 <fwrite>
			#endif
			break;
81113da4:	00000106 	br	81113dac <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81113da8:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81113dac:	0001883a 	nop
81113db0:	e037883a 	mov	sp,fp
81113db4:	dfc00117 	ldw	ra,4(sp)
81113db8:	df000017 	ldw	fp,0(sp)
81113dbc:	dec00204 	addi	sp,sp,8
81113dc0:	f800283a 	ret

81113dc4 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113dc4:	defff904 	addi	sp,sp,-28
81113dc8:	de00012e 	bgeu	sp,et,81113dd0 <vSendCmdQToNFeeCTRL+0xc>
81113dcc:	003b68fa 	trap	3
81113dd0:	dfc00615 	stw	ra,24(sp)
81113dd4:	df000515 	stw	fp,20(sp)
81113dd8:	df000504 	addi	fp,sp,20
81113ddc:	2807883a 	mov	r3,r5
81113de0:	3005883a 	mov	r2,r6
81113de4:	e13ffd05 	stb	r4,-12(fp)
81113de8:	e0fffe05 	stb	r3,-8(fp)
81113dec:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81113df0:	00800404 	movi	r2,16
81113df4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81113df8:	e0bffd03 	ldbu	r2,-12(fp)
81113dfc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81113e00:	e0bffe03 	ldbu	r2,-8(fp)
81113e04:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81113e08:	e0bfff03 	ldbu	r2,-4(fp)
81113e0c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81113e10:	d0a06f17 	ldw	r2,-32324(gp)
81113e14:	e0fffc17 	ldw	r3,-16(fp)
81113e18:	180b883a 	mov	r5,r3
81113e1c:	1009883a 	mov	r4,r2
81113e20:	113ac000 	call	8113ac00 <OSQPost>
81113e24:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113e28:	e0bffb03 	ldbu	r2,-20(fp)
81113e2c:	10000126 	beq	r2,zero,81113e34 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81113e30:	111a2dc0 	call	8111a2dc <vFailSendMsgFeeCTRL>
	}
}
81113e34:	0001883a 	nop
81113e38:	e037883a 	mov	sp,fp
81113e3c:	dfc00117 	ldw	ra,4(sp)
81113e40:	df000017 	ldw	fp,0(sp)
81113e44:	dec00204 	addi	sp,sp,8
81113e48:	f800283a 	ret

81113e4c <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113e4c:	defff904 	addi	sp,sp,-28
81113e50:	de00012e 	bgeu	sp,et,81113e58 <vSendCmdQToNFeeCTRL_PRIO+0xc>
81113e54:	003b68fa 	trap	3
81113e58:	dfc00615 	stw	ra,24(sp)
81113e5c:	df000515 	stw	fp,20(sp)
81113e60:	df000504 	addi	fp,sp,20
81113e64:	2807883a 	mov	r3,r5
81113e68:	3005883a 	mov	r2,r6
81113e6c:	e13ffd05 	stb	r4,-12(fp)
81113e70:	e0fffe05 	stb	r3,-8(fp)
81113e74:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81113e78:	00800404 	movi	r2,16
81113e7c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81113e80:	e0bffd03 	ldbu	r2,-12(fp)
81113e84:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81113e88:	e0bffe03 	ldbu	r2,-8(fp)
81113e8c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81113e90:	e0bfff03 	ldbu	r2,-4(fp)
81113e94:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81113e98:	d0a06f17 	ldw	r2,-32324(gp)
81113e9c:	e0fffc17 	ldw	r3,-16(fp)
81113ea0:	180b883a 	mov	r5,r3
81113ea4:	1009883a 	mov	r4,r2
81113ea8:	113ac000 	call	8113ac00 <OSQPost>
81113eac:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113eb0:	e0bffb03 	ldbu	r2,-20(fp)
81113eb4:	10000126 	beq	r2,zero,81113ebc <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81113eb8:	111a2dc0 	call	8111a2dc <vFailSendMsgFeeCTRL>
	}
}
81113ebc:	0001883a 	nop
81113ec0:	e037883a 	mov	sp,fp
81113ec4:	dfc00117 	ldw	ra,4(sp)
81113ec8:	df000017 	ldw	fp,0(sp)
81113ecc:	dec00204 	addi	sp,sp,8
81113ed0:	f800283a 	ret

81113ed4 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113ed4:	defff804 	addi	sp,sp,-32
81113ed8:	de00012e 	bgeu	sp,et,81113ee0 <vSendCmdQToNFeeCTRL_GEN+0xc>
81113edc:	003b68fa 	trap	3
81113ee0:	dfc00715 	stw	ra,28(sp)
81113ee4:	df000615 	stw	fp,24(sp)
81113ee8:	df000604 	addi	fp,sp,24
81113eec:	2011883a 	mov	r8,r4
81113ef0:	2809883a 	mov	r4,r5
81113ef4:	3007883a 	mov	r3,r6
81113ef8:	3805883a 	mov	r2,r7
81113efc:	e23ffc05 	stb	r8,-16(fp)
81113f00:	e13ffd05 	stb	r4,-12(fp)
81113f04:	e0fffe05 	stb	r3,-8(fp)
81113f08:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81113f0c:	e0bffc03 	ldbu	r2,-16(fp)
81113f10:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81113f14:	e0bffd03 	ldbu	r2,-12(fp)
81113f18:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81113f1c:	e0bffe03 	ldbu	r2,-8(fp)
81113f20:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81113f24:	e0bfff03 	ldbu	r2,-4(fp)
81113f28:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81113f2c:	d0a06f17 	ldw	r2,-32324(gp)
81113f30:	e0fffb17 	ldw	r3,-20(fp)
81113f34:	180b883a 	mov	r5,r3
81113f38:	1009883a 	mov	r4,r2
81113f3c:	113ac000 	call	8113ac00 <OSQPost>
81113f40:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113f44:	e0bffa03 	ldbu	r2,-24(fp)
81113f48:	10000126 	beq	r2,zero,81113f50 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81113f4c:	111a2dc0 	call	8111a2dc <vFailSendMsgFeeCTRL>
	}
}
81113f50:	0001883a 	nop
81113f54:	e037883a 	mov	sp,fp
81113f58:	dfc00117 	ldw	ra,4(sp)
81113f5c:	df000017 	ldw	fp,0(sp)
81113f60:	dec00204 	addi	sp,sp,8
81113f64:	f800283a 	ret

81113f68 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113f68:	defff904 	addi	sp,sp,-28
81113f6c:	de00012e 	bgeu	sp,et,81113f74 <vSendCmdQToDataCTRL+0xc>
81113f70:	003b68fa 	trap	3
81113f74:	dfc00615 	stw	ra,24(sp)
81113f78:	df000515 	stw	fp,20(sp)
81113f7c:	df000504 	addi	fp,sp,20
81113f80:	2807883a 	mov	r3,r5
81113f84:	3005883a 	mov	r2,r6
81113f88:	e13ffd05 	stb	r4,-12(fp)
81113f8c:	e0fffe05 	stb	r3,-8(fp)
81113f90:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81113f94:	00800804 	movi	r2,32
81113f98:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81113f9c:	e0bffd03 	ldbu	r2,-12(fp)
81113fa0:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81113fa4:	e0bffe03 	ldbu	r2,-8(fp)
81113fa8:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81113fac:	e0bfff03 	ldbu	r2,-4(fp)
81113fb0:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81113fb4:	d0a05e17 	ldw	r2,-32392(gp)
81113fb8:	e0fffc17 	ldw	r3,-16(fp)
81113fbc:	180b883a 	mov	r5,r3
81113fc0:	1009883a 	mov	r4,r2
81113fc4:	113ac000 	call	8113ac00 <OSQPost>
81113fc8:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113fcc:	e0bffb03 	ldbu	r2,-20(fp)
81113fd0:	10000126 	beq	r2,zero,81113fd8 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81113fd4:	111a3280 	call	8111a328 <vFailSendMsgDataCTRL>
	}
}
81113fd8:	0001883a 	nop
81113fdc:	e037883a 	mov	sp,fp
81113fe0:	dfc00117 	ldw	ra,4(sp)
81113fe4:	df000017 	ldw	fp,0(sp)
81113fe8:	dec00204 	addi	sp,sp,8
81113fec:	f800283a 	ret

81113ff0 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113ff0:	defff904 	addi	sp,sp,-28
81113ff4:	de00012e 	bgeu	sp,et,81113ffc <vSendCmdQToDataCTRL_PRIO+0xc>
81113ff8:	003b68fa 	trap	3
81113ffc:	dfc00615 	stw	ra,24(sp)
81114000:	df000515 	stw	fp,20(sp)
81114004:	df000504 	addi	fp,sp,20
81114008:	2807883a 	mov	r3,r5
8111400c:	3005883a 	mov	r2,r6
81114010:	e13ffd05 	stb	r4,-12(fp)
81114014:	e0fffe05 	stb	r3,-8(fp)
81114018:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8111401c:	00800404 	movi	r2,16
81114020:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81114024:	e0bffd03 	ldbu	r2,-12(fp)
81114028:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111402c:	e0bffe03 	ldbu	r2,-8(fp)
81114030:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81114034:	e0bfff03 	ldbu	r2,-4(fp)
81114038:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
8111403c:	d0a05e17 	ldw	r2,-32392(gp)
81114040:	e0fffc17 	ldw	r3,-16(fp)
81114044:	180b883a 	mov	r5,r3
81114048:	1009883a 	mov	r4,r2
8111404c:	113ac000 	call	8113ac00 <OSQPost>
81114050:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81114054:	e0bffb03 	ldbu	r2,-20(fp)
81114058:	10000126 	beq	r2,zero,81114060 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
8111405c:	111a2dc0 	call	8111a2dc <vFailSendMsgFeeCTRL>
	}
}
81114060:	0001883a 	nop
81114064:	e037883a 	mov	sp,fp
81114068:	dfc00117 	ldw	ra,4(sp)
8111406c:	df000017 	ldw	fp,0(sp)
81114070:	dec00204 	addi	sp,sp,8
81114074:	f800283a 	ret

81114078 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81114078:	defffc04 	addi	sp,sp,-16
8111407c:	de00012e 	bgeu	sp,et,81114084 <vMebInit+0xc>
81114080:	003b68fa 	trap	3
81114084:	dfc00315 	stw	ra,12(sp)
81114088:	df000215 	stw	fp,8(sp)
8111408c:	df000204 	addi	fp,sp,8
81114090:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81114094:	e0bfff17 	ldw	r2,-4(fp)
81114098:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
8111409c:	e0bfff17 	ldw	r2,-4(fp)
811140a0:	00c00044 	movi	r3,1
811140a4:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
811140a8:	d0a06817 	ldw	r2,-32352(gp)
811140ac:	1009883a 	mov	r4,r2
811140b0:	113a7380 	call	8113a738 <OSQFlush>
811140b4:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
811140b8:	e0bffe03 	ldbu	r2,-8(fp)
811140bc:	10000126 	beq	r2,zero,811140c4 <vMebInit+0x4c>
		vFailFlushMEBQueue();
811140c0:	111a40c0 	call	8111a40c <vFailFlushMEBQueue>
	}
}
811140c4:	0001883a 	nop
811140c8:	e037883a 	mov	sp,fp
811140cc:	dfc00117 	ldw	ra,4(sp)
811140d0:	df000017 	ldw	fp,0(sp)
811140d4:	dec00204 	addi	sp,sp,8
811140d8:	f800283a 	ret

811140dc <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
811140dc:	defffc04 	addi	sp,sp,-16
811140e0:	de00012e 	bgeu	sp,et,811140e8 <vSwapMemmory+0xc>
811140e4:	003b68fa 	trap	3
811140e8:	dfc00315 	stw	ra,12(sp)
811140ec:	df000215 	stw	fp,8(sp)
811140f0:	df000204 	addi	fp,sp,8
811140f4:	e13fff15 	stw	r4,-4(fp)
	/*todo: Apenas para teste !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/



	/* Configurar o tamanho normal do double buffer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  */
	bSpwcGetTimecode(&pxMebCLocal->xFeeControl.xNfee[0].xChannel.xSpacewire);
811140f8:	e0bfff17 	ldw	r2,-4(fp)
811140fc:	10809b04 	addi	r2,r2,620
81114100:	1009883a 	mov	r4,r2
81114104:	1109cc80 	call	81109cc8 <bSpwcGetTimecode>
	tCode = ( pxMebCLocal->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81114108:	e0bfff17 	ldw	r2,-4(fp)
8111410c:	1080a743 	ldbu	r2,669(r2)
81114110:	e0bffe05 	stb	r2,-8(fp)
	tCodeNext = ( tCode ) % 4;
81114114:	e0bffe03 	ldbu	r2,-8(fp)
81114118:	108000cc 	andi	r2,r2,3
8111411c:	e0bffe45 	stb	r2,-7(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"\n\nMEB TASK:  TIME CODE: %hhu \n ", tCode);
81114120:	d0a06117 	ldw	r2,-32380(gp)
81114124:	e0fffe03 	ldbu	r3,-8(fp)
81114128:	180d883a 	mov	r6,r3
8111412c:	01604574 	movhi	r5,33045
81114130:	2969d604 	addi	r5,r5,-22696
81114134:	1009883a 	mov	r4,r2
81114138:	111d6140 	call	8111d614 <fprintf>
		fprintf(fp,"MEB TASK:  MODULUS: %hhu \n\n ", tCodeNext);
8111413c:	d0a06117 	ldw	r2,-32380(gp)
81114140:	e0fffe43 	ldbu	r3,-7(fp)
81114144:	180d883a 	mov	r6,r3
81114148:	01604574 	movhi	r5,33045
8111414c:	2969de04 	addi	r5,r5,-22664
81114150:	1009883a 	mov	r4,r2
81114154:	111d6140 	call	8111d614 <fprintf>
	#endif


	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81114158:	e0bfff17 	ldw	r2,-4(fp)
8111415c:	10800203 	ldbu	r2,8(r2)
81114160:	10803fcc 	andi	r2,r2,255
81114164:	10c00044 	addi	r3,r2,1
81114168:	00a00034 	movhi	r2,32768
8111416c:	10800044 	addi	r2,r2,1
81114170:	1884703a 	and	r2,r3,r2
81114174:	1000040e 	bge	r2,zero,81114188 <vSwapMemmory+0xac>
81114178:	10bfffc4 	addi	r2,r2,-1
8111417c:	00ffff84 	movi	r3,-2
81114180:	10c4b03a 	or	r2,r2,r3
81114184:	10800044 	addi	r2,r2,1
81114188:	1007883a 	mov	r3,r2
8111418c:	e0bfff17 	ldw	r2,-4(fp)
81114190:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81114194:	e0bfff17 	ldw	r2,-4(fp)
81114198:	10800243 	ldbu	r2,9(r2)
8111419c:	10803fcc 	andi	r2,r2,255
811141a0:	10c00044 	addi	r3,r2,1
811141a4:	00a00034 	movhi	r2,32768
811141a8:	10800044 	addi	r2,r2,1
811141ac:	1884703a 	and	r2,r3,r2
811141b0:	1000040e 	bge	r2,zero,811141c4 <vSwapMemmory+0xe8>
811141b4:	10bfffc4 	addi	r2,r2,-1
811141b8:	00ffff84 	movi	r3,-2
811141bc:	10c4b03a 	or	r2,r2,r3
811141c0:	10800044 	addi	r2,r2,1
811141c4:	1007883a 	mov	r3,r2
811141c8:	e0bfff17 	ldw	r2,-4(fp)
811141cc:	10c00245 	stb	r3,9(r2)

}
811141d0:	0001883a 	nop
811141d4:	e037883a 	mov	sp,fp
811141d8:	dfc00117 	ldw	ra,4(sp)
811141dc:	df000017 	ldw	fp,0(sp)
811141e0:	dec00204 	addi	sp,sp,8
811141e4:	f800283a 	ret

811141e8 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
811141e8:	defffc04 	addi	sp,sp,-16
811141ec:	de00012e 	bgeu	sp,et,811141f4 <vReleaseSyncMessages+0xc>
811141f0:	003b68fa 	trap	3
811141f4:	dfc00315 	stw	ra,12(sp)
811141f8:	df000215 	stw	fp,8(sp)
811141fc:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81114200:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
81114204:	00bff844 	movi	r2,-31
81114208:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8111420c:	e03ffe05 	stb	zero,-8(fp)
81114210:	00001606 	br	8111426c <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
81114214:	e0bffe03 	ldbu	r2,-8(fp)
81114218:	10800444 	addi	r2,r2,17
8111421c:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
81114220:	e0bffe03 	ldbu	r2,-8(fp)
81114224:	1085883a 	add	r2,r2,r2
81114228:	1087883a 	add	r3,r2,r2
8111422c:	d0a05b04 	addi	r2,gp,-32404
81114230:	1885883a 	add	r2,r3,r2
81114234:	10800017 	ldw	r2,0(r2)
81114238:	e0ffff17 	ldw	r3,-4(fp)
8111423c:	180b883a 	mov	r5,r3
81114240:	1009883a 	mov	r4,r2
81114244:	113ac000 	call	8113ac00 <OSQPost>
81114248:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
8111424c:	e0bffe43 	ldbu	r2,-7(fp)
81114250:	10000326 	beq	r2,zero,81114260 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
81114254:	e0bffe03 	ldbu	r2,-8(fp)
81114258:	1009883a 	mov	r4,r2
8111425c:	111a1e80 	call	8111a1e8 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81114260:	e0bffe03 	ldbu	r2,-8(fp)
81114264:	10800044 	addi	r2,r2,1
81114268:	e0bffe05 	stb	r2,-8(fp)
8111426c:	e0bffe03 	ldbu	r2,-8(fp)
81114270:	103fe826 	beq	r2,zero,81114214 <__reset+0xfb0f4214>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81114274:	0001883a 	nop
81114278:	e037883a 	mov	sp,fp
8111427c:	dfc00117 	ldw	ra,4(sp)
81114280:	df000017 	ldw	fp,0(sp)
81114284:	dec00204 	addi	sp,sp,8
81114288:	f800283a 	ret

8111428c <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
8111428c:	defff804 	addi	sp,sp,-32
81114290:	de00012e 	bgeu	sp,et,81114298 <vStackMonitor+0xc>
81114294:	003b68fa 	trap	3
81114298:	dfc00715 	stw	ra,28(sp)
8111429c:	df000615 	stw	fp,24(sp)
811142a0:	df000604 	addi	fp,sp,24
811142a4:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811142a8:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
811142ac:	d0a06117 	ldw	r2,-32380(gp)
811142b0:	100f883a 	mov	r7,r2
811142b4:	018006c4 	movi	r6,27
811142b8:	01400044 	movi	r5,1
811142bc:	01204574 	movhi	r4,33045
811142c0:	2129e604 	addi	r4,r4,-22632
811142c4:	111dcb00 	call	8111dcb0 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
811142c8:	d0a06117 	ldw	r2,-32380(gp)
811142cc:	100f883a 	mov	r7,r2
811142d0:	01800b04 	movi	r6,44
811142d4:	01400044 	movi	r5,1
811142d8:	01204574 	movhi	r4,33045
811142dc:	2129ed04 	addi	r4,r4,-22604
811142e0:	111dcb00 	call	8111dcb0 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
811142e4:	d0a06117 	ldw	r2,-32380(gp)
811142e8:	100f883a 	mov	r7,r2
811142ec:	01800f84 	movi	r6,62
811142f0:	01400044 	movi	r5,1
811142f4:	01204574 	movhi	r4,33045
811142f8:	2129f904 	addi	r4,r4,-22556
811142fc:	111dcb00 	call	8111dcb0 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81114300:	e0bffd04 	addi	r2,fp,-12
81114304:	100b883a 	mov	r5,r2
81114308:	01000804 	movi	r4,32
8111430c:	113d0240 	call	8113d024 <OSTaskStkChk>
81114310:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
81114314:	e0bffc03 	ldbu	r2,-16(fp)
81114318:	10000f1e 	bne	r2,zero,81114358 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111431c:	d1206117 	ldw	r4,-32380(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81114320:	e0fffd17 	ldw	r3,-12(fp)
81114324:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114328:	188b883a 	add	r5,r3,r2
8111432c:	e0bffd17 	ldw	r2,-12(fp)
81114330:	e0fffe17 	ldw	r3,-8(fp)
81114334:	d8c00115 	stw	r3,4(sp)
81114338:	d8800015 	stw	r2,0(sp)
8111433c:	280f883a 	mov	r7,r5
81114340:	01a04574 	movhi	r6,33045
81114344:	31aa0904 	addi	r6,r6,-22492
81114348:	01604574 	movhi	r5,33045
8111434c:	296a0d04 	addi	r5,r5,-22476
81114350:	111d6140 	call	8111d614 <fprintf>
81114354:	00000706 	br	81114374 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81114358:	d0a06117 	ldw	r2,-32380(gp)
8111435c:	100f883a 	mov	r7,r2
81114360:	01800904 	movi	r6,36
81114364:	01400044 	movi	r5,1
81114368:	01204574 	movhi	r4,33045
8111436c:	212a1c04 	addi	r4,r4,-22416
81114370:	111dcb00 	call	8111dcb0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81114374:	e0bffd04 	addi	r2,fp,-12
81114378:	100b883a 	mov	r5,r2
8111437c:	01000784 	movi	r4,30
81114380:	113d0240 	call	8113d024 <OSTaskStkChk>
81114384:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114388:	e0bffc03 	ldbu	r2,-16(fp)
8111438c:	10000f1e 	bne	r2,zero,811143cc <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114390:	d1206117 	ldw	r4,-32380(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81114394:	e0fffd17 	ldw	r3,-12(fp)
81114398:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111439c:	188b883a 	add	r5,r3,r2
811143a0:	e0bffd17 	ldw	r2,-12(fp)
811143a4:	e0fffe17 	ldw	r3,-8(fp)
811143a8:	d8c00115 	stw	r3,4(sp)
811143ac:	d8800015 	stw	r2,0(sp)
811143b0:	280f883a 	mov	r7,r5
811143b4:	01a04574 	movhi	r6,33045
811143b8:	31aa2604 	addi	r6,r6,-22376
811143bc:	01604574 	movhi	r5,33045
811143c0:	296a0d04 	addi	r5,r5,-22476
811143c4:	111d6140 	call	8111d614 <fprintf>
811143c8:	00000706 	br	811143e8 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
811143cc:	d0a06117 	ldw	r2,-32380(gp)
811143d0:	100f883a 	mov	r7,r2
811143d4:	01800984 	movi	r6,38
811143d8:	01400044 	movi	r5,1
811143dc:	01204574 	movhi	r4,33045
811143e0:	212a2a04 	addi	r4,r4,-22360
811143e4:	111dcb00 	call	8111dcb0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
811143e8:	e0bffd04 	addi	r2,fp,-12
811143ec:	100b883a 	mov	r5,r2
811143f0:	01000704 	movi	r4,28
811143f4:	113d0240 	call	8113d024 <OSTaskStkChk>
811143f8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811143fc:	e0bffc03 	ldbu	r2,-16(fp)
81114400:	10000f1e 	bne	r2,zero,81114440 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114404:	d1206117 	ldw	r4,-32380(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81114408:	e0fffd17 	ldw	r3,-12(fp)
8111440c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114410:	188b883a 	add	r5,r3,r2
81114414:	e0bffd17 	ldw	r2,-12(fp)
81114418:	e0fffe17 	ldw	r3,-8(fp)
8111441c:	d8c00115 	stw	r3,4(sp)
81114420:	d8800015 	stw	r2,0(sp)
81114424:	280f883a 	mov	r7,r5
81114428:	01a04574 	movhi	r6,33045
8111442c:	31aa3404 	addi	r6,r6,-22320
81114430:	01604574 	movhi	r5,33045
81114434:	296a0d04 	addi	r5,r5,-22476
81114438:	111d6140 	call	8111d614 <fprintf>
8111443c:	00000706 	br	8111445c <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81114440:	d0a06117 	ldw	r2,-32380(gp)
81114444:	100f883a 	mov	r7,r2
81114448:	01800884 	movi	r6,34
8111444c:	01400044 	movi	r5,1
81114450:	01204574 	movhi	r4,33045
81114454:	212a3704 	addi	r4,r4,-22308
81114458:	111dcb00 	call	8111dcb0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
8111445c:	e0bffd04 	addi	r2,fp,-12
81114460:	100b883a 	mov	r5,r2
81114464:	010006c4 	movi	r4,27
81114468:	113d0240 	call	8113d024 <OSTaskStkChk>
8111446c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114470:	e0bffc03 	ldbu	r2,-16(fp)
81114474:	10000f1e 	bne	r2,zero,811144b4 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114478:	d1206117 	ldw	r4,-32380(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
8111447c:	e0fffd17 	ldw	r3,-12(fp)
81114480:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114484:	188b883a 	add	r5,r3,r2
81114488:	e0bffd17 	ldw	r2,-12(fp)
8111448c:	e0fffe17 	ldw	r3,-8(fp)
81114490:	d8c00115 	stw	r3,4(sp)
81114494:	d8800015 	stw	r2,0(sp)
81114498:	280f883a 	mov	r7,r5
8111449c:	01a04574 	movhi	r6,33045
811144a0:	31aa4004 	addi	r6,r6,-22272
811144a4:	01604574 	movhi	r5,33045
811144a8:	296a0d04 	addi	r5,r5,-22476
811144ac:	111d6140 	call	8111d614 <fprintf>
811144b0:	00000706 	br	811144d0 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
811144b4:	d0a06117 	ldw	r2,-32380(gp)
811144b8:	100f883a 	mov	r7,r2
811144bc:	018008c4 	movi	r6,35
811144c0:	01400044 	movi	r5,1
811144c4:	01204574 	movhi	r4,33045
811144c8:	212a4404 	addi	r4,r4,-22256
811144cc:	111dcb00 	call	8111dcb0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
811144d0:	e0bffd04 	addi	r2,fp,-12
811144d4:	100b883a 	mov	r5,r2
811144d8:	01000684 	movi	r4,26
811144dc:	113d0240 	call	8113d024 <OSTaskStkChk>
811144e0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811144e4:	e0bffc03 	ldbu	r2,-16(fp)
811144e8:	10000f1e 	bne	r2,zero,81114528 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811144ec:	d1206117 	ldw	r4,-32380(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
811144f0:	e0fffd17 	ldw	r3,-12(fp)
811144f4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811144f8:	188b883a 	add	r5,r3,r2
811144fc:	e0bffd17 	ldw	r2,-12(fp)
81114500:	e0fffe17 	ldw	r3,-8(fp)
81114504:	d8c00115 	stw	r3,4(sp)
81114508:	d8800015 	stw	r2,0(sp)
8111450c:	280f883a 	mov	r7,r5
81114510:	01a04574 	movhi	r6,33045
81114514:	31aa4d04 	addi	r6,r6,-22220
81114518:	01604574 	movhi	r5,33045
8111451c:	296a0d04 	addi	r5,r5,-22476
81114520:	111d6140 	call	8111d614 <fprintf>
81114524:	00000706 	br	81114544 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81114528:	d0a06117 	ldw	r2,-32380(gp)
8111452c:	100f883a 	mov	r7,r2
81114530:	01800884 	movi	r6,34
81114534:	01400044 	movi	r5,1
81114538:	01204574 	movhi	r4,33045
8111453c:	212a5004 	addi	r4,r4,-22208
81114540:	111dcb00 	call	8111dcb0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81114544:	e0bffd04 	addi	r2,fp,-12
81114548:	100b883a 	mov	r5,r2
8111454c:	01000644 	movi	r4,25
81114550:	113d0240 	call	8113d024 <OSTaskStkChk>
81114554:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114558:	e0bffc03 	ldbu	r2,-16(fp)
8111455c:	10000f1e 	bne	r2,zero,8111459c <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114560:	d1206117 	ldw	r4,-32380(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81114564:	e0fffd17 	ldw	r3,-12(fp)
81114568:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111456c:	188b883a 	add	r5,r3,r2
81114570:	e0bffd17 	ldw	r2,-12(fp)
81114574:	e0fffe17 	ldw	r3,-8(fp)
81114578:	d8c00115 	stw	r3,4(sp)
8111457c:	d8800015 	stw	r2,0(sp)
81114580:	280f883a 	mov	r7,r5
81114584:	01a04574 	movhi	r6,33045
81114588:	31aa5904 	addi	r6,r6,-22172
8111458c:	01604574 	movhi	r5,33045
81114590:	296a0d04 	addi	r5,r5,-22476
81114594:	111d6140 	call	8111d614 <fprintf>
81114598:	00000706 	br	811145b8 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
8111459c:	d0a06117 	ldw	r2,-32380(gp)
811145a0:	100f883a 	mov	r7,r2
811145a4:	01800884 	movi	r6,34
811145a8:	01400044 	movi	r5,1
811145ac:	01204574 	movhi	r4,33045
811145b0:	212a5c04 	addi	r4,r4,-22160
811145b4:	111dcb00 	call	8111dcb0 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
811145b8:	e0bffd04 	addi	r2,fp,-12
811145bc:	100b883a 	mov	r5,r2
811145c0:	01000044 	movi	r4,1
811145c4:	113d0240 	call	8113d024 <OSTaskStkChk>
811145c8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811145cc:	e0bffc03 	ldbu	r2,-16(fp)
811145d0:	10000f1e 	bne	r2,zero,81114610 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811145d4:	d1206117 	ldw	r4,-32380(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
811145d8:	e0fffd17 	ldw	r3,-12(fp)
811145dc:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811145e0:	188b883a 	add	r5,r3,r2
811145e4:	e0bffd17 	ldw	r2,-12(fp)
811145e8:	e0fffe17 	ldw	r3,-8(fp)
811145ec:	d8c00115 	stw	r3,4(sp)
811145f0:	d8800015 	stw	r2,0(sp)
811145f4:	280f883a 	mov	r7,r5
811145f8:	01a04574 	movhi	r6,33045
811145fc:	31aa6504 	addi	r6,r6,-22124
81114600:	01604574 	movhi	r5,33045
81114604:	296a0d04 	addi	r5,r5,-22476
81114608:	111d6140 	call	8111d614 <fprintf>
8111460c:	00000706 	br	8111462c <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81114610:	d0a06117 	ldw	r2,-32380(gp)
81114614:	100f883a 	mov	r7,r2
81114618:	01800804 	movi	r6,32
8111461c:	01400044 	movi	r5,1
81114620:	01204574 	movhi	r4,33045
81114624:	212a6804 	addi	r4,r4,-22112
81114628:	111dcb00 	call	8111dcb0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
8111462c:	e0bffd04 	addi	r2,fp,-12
81114630:	100b883a 	mov	r5,r2
81114634:	010002c4 	movi	r4,11
81114638:	113d0240 	call	8113d024 <OSTaskStkChk>
8111463c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114640:	e0bffc03 	ldbu	r2,-16(fp)
81114644:	10000f1e 	bne	r2,zero,81114684 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114648:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
8111464c:	e0fffd17 	ldw	r3,-12(fp)
81114650:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114654:	188b883a 	add	r5,r3,r2
81114658:	e0bffd17 	ldw	r2,-12(fp)
8111465c:	e0fffe17 	ldw	r3,-8(fp)
81114660:	d8c00115 	stw	r3,4(sp)
81114664:	d8800015 	stw	r2,0(sp)
81114668:	280f883a 	mov	r7,r5
8111466c:	01a04574 	movhi	r6,33045
81114670:	31aa7104 	addi	r6,r6,-22076
81114674:	01604574 	movhi	r5,33045
81114678:	296a0d04 	addi	r5,r5,-22476
8111467c:	111d6140 	call	8111d614 <fprintf>
81114680:	00000706 	br	811146a0 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81114684:	d0a06117 	ldw	r2,-32380(gp)
81114688:	100f883a 	mov	r7,r2
8111468c:	018008c4 	movi	r6,35
81114690:	01400044 	movi	r5,1
81114694:	01204574 	movhi	r4,33045
81114698:	212a7404 	addi	r4,r4,-22064
8111469c:	111dcb00 	call	8111dcb0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
811146a0:	e0bffd04 	addi	r2,fp,-12
811146a4:	100b883a 	mov	r5,r2
811146a8:	01000304 	movi	r4,12
811146ac:	113d0240 	call	8113d024 <OSTaskStkChk>
811146b0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811146b4:	e0bffc03 	ldbu	r2,-16(fp)
811146b8:	10000f1e 	bne	r2,zero,811146f8 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811146bc:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
811146c0:	e0fffd17 	ldw	r3,-12(fp)
811146c4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811146c8:	188b883a 	add	r5,r3,r2
811146cc:	e0bffd17 	ldw	r2,-12(fp)
811146d0:	e0fffe17 	ldw	r3,-8(fp)
811146d4:	d8c00115 	stw	r3,4(sp)
811146d8:	d8800015 	stw	r2,0(sp)
811146dc:	280f883a 	mov	r7,r5
811146e0:	01a04574 	movhi	r6,33045
811146e4:	31aa7d04 	addi	r6,r6,-22028
811146e8:	01604574 	movhi	r5,33045
811146ec:	296a0d04 	addi	r5,r5,-22476
811146f0:	111d6140 	call	8111d614 <fprintf>
811146f4:	00000706 	br	81114714 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
811146f8:	d0a06117 	ldw	r2,-32380(gp)
811146fc:	100f883a 	mov	r7,r2
81114700:	018008c4 	movi	r6,35
81114704:	01400044 	movi	r5,1
81114708:	01204574 	movhi	r4,33045
8111470c:	212a8004 	addi	r4,r4,-22016
81114710:	111dcb00 	call	8111dcb0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
81114714:	e0bffd04 	addi	r2,fp,-12
81114718:	100b883a 	mov	r5,r2
8111471c:	01000344 	movi	r4,13
81114720:	113d0240 	call	8113d024 <OSTaskStkChk>
81114724:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114728:	e0bffc03 	ldbu	r2,-16(fp)
8111472c:	10000f1e 	bne	r2,zero,8111476c <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114730:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81114734:	e0fffd17 	ldw	r3,-12(fp)
81114738:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111473c:	188b883a 	add	r5,r3,r2
81114740:	e0bffd17 	ldw	r2,-12(fp)
81114744:	e0fffe17 	ldw	r3,-8(fp)
81114748:	d8c00115 	stw	r3,4(sp)
8111474c:	d8800015 	stw	r2,0(sp)
81114750:	280f883a 	mov	r7,r5
81114754:	01a04574 	movhi	r6,33045
81114758:	31aa8904 	addi	r6,r6,-21980
8111475c:	01604574 	movhi	r5,33045
81114760:	296a0d04 	addi	r5,r5,-22476
81114764:	111d6140 	call	8111d614 <fprintf>
81114768:	00000706 	br	81114788 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
8111476c:	d0a06117 	ldw	r2,-32380(gp)
81114770:	100f883a 	mov	r7,r2
81114774:	018008c4 	movi	r6,35
81114778:	01400044 	movi	r5,1
8111477c:	01204574 	movhi	r4,33045
81114780:	212a8c04 	addi	r4,r4,-21968
81114784:	111dcb00 	call	8111dcb0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81114788:	e0bffd04 	addi	r2,fp,-12
8111478c:	100b883a 	mov	r5,r2
81114790:	01000384 	movi	r4,14
81114794:	113d0240 	call	8113d024 <OSTaskStkChk>
81114798:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111479c:	e0bffc03 	ldbu	r2,-16(fp)
811147a0:	10000f1e 	bne	r2,zero,811147e0 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811147a4:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
811147a8:	e0fffd17 	ldw	r3,-12(fp)
811147ac:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811147b0:	188b883a 	add	r5,r3,r2
811147b4:	e0bffd17 	ldw	r2,-12(fp)
811147b8:	e0fffe17 	ldw	r3,-8(fp)
811147bc:	d8c00115 	stw	r3,4(sp)
811147c0:	d8800015 	stw	r2,0(sp)
811147c4:	280f883a 	mov	r7,r5
811147c8:	01a04574 	movhi	r6,33045
811147cc:	31aa9504 	addi	r6,r6,-21932
811147d0:	01604574 	movhi	r5,33045
811147d4:	296a0d04 	addi	r5,r5,-22476
811147d8:	111d6140 	call	8111d614 <fprintf>
811147dc:	00000706 	br	811147fc <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
811147e0:	d0a06117 	ldw	r2,-32380(gp)
811147e4:	100f883a 	mov	r7,r2
811147e8:	018008c4 	movi	r6,35
811147ec:	01400044 	movi	r5,1
811147f0:	01204574 	movhi	r4,33045
811147f4:	212a9804 	addi	r4,r4,-21920
811147f8:	111dcb00 	call	8111dcb0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
811147fc:	e0bffd04 	addi	r2,fp,-12
81114800:	100b883a 	mov	r5,r2
81114804:	010003c4 	movi	r4,15
81114808:	113d0240 	call	8113d024 <OSTaskStkChk>
8111480c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114810:	e0bffc03 	ldbu	r2,-16(fp)
81114814:	10000f1e 	bne	r2,zero,81114854 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114818:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
8111481c:	e0fffd17 	ldw	r3,-12(fp)
81114820:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114824:	188b883a 	add	r5,r3,r2
81114828:	e0bffd17 	ldw	r2,-12(fp)
8111482c:	e0fffe17 	ldw	r3,-8(fp)
81114830:	d8c00115 	stw	r3,4(sp)
81114834:	d8800015 	stw	r2,0(sp)
81114838:	280f883a 	mov	r7,r5
8111483c:	01a04574 	movhi	r6,33045
81114840:	31aaa104 	addi	r6,r6,-21884
81114844:	01604574 	movhi	r5,33045
81114848:	296a0d04 	addi	r5,r5,-22476
8111484c:	111d6140 	call	8111d614 <fprintf>
81114850:	00000706 	br	81114870 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81114854:	d0a06117 	ldw	r2,-32380(gp)
81114858:	100f883a 	mov	r7,r2
8111485c:	018008c4 	movi	r6,35
81114860:	01400044 	movi	r5,1
81114864:	01204574 	movhi	r4,33045
81114868:	212aa404 	addi	r4,r4,-21872
8111486c:	111dcb00 	call	8111dcb0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81114870:	e0bffd04 	addi	r2,fp,-12
81114874:	100b883a 	mov	r5,r2
81114878:	01000404 	movi	r4,16
8111487c:	113d0240 	call	8113d024 <OSTaskStkChk>
81114880:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114884:	e0bffc03 	ldbu	r2,-16(fp)
81114888:	10000f1e 	bne	r2,zero,811148c8 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111488c:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81114890:	e0fffd17 	ldw	r3,-12(fp)
81114894:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114898:	188b883a 	add	r5,r3,r2
8111489c:	e0bffd17 	ldw	r2,-12(fp)
811148a0:	e0fffe17 	ldw	r3,-8(fp)
811148a4:	d8c00115 	stw	r3,4(sp)
811148a8:	d8800015 	stw	r2,0(sp)
811148ac:	280f883a 	mov	r7,r5
811148b0:	01a04574 	movhi	r6,33045
811148b4:	31aaad04 	addi	r6,r6,-21836
811148b8:	01604574 	movhi	r5,33045
811148bc:	296a0d04 	addi	r5,r5,-22476
811148c0:	111d6140 	call	8111d614 <fprintf>
811148c4:	00000706 	br	811148e4 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
811148c8:	d0a06117 	ldw	r2,-32380(gp)
811148cc:	100f883a 	mov	r7,r2
811148d0:	018008c4 	movi	r6,35
811148d4:	01400044 	movi	r5,1
811148d8:	01204574 	movhi	r4,33045
811148dc:	212ab004 	addi	r4,r4,-21824
811148e0:	111dcb00 	call	8111dcb0 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
811148e4:	e0bffd04 	addi	r2,fp,-12
811148e8:	100b883a 	mov	r5,r2
811148ec:	01000284 	movi	r4,10
811148f0:	113d0240 	call	8113d024 <OSTaskStkChk>
811148f4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811148f8:	e0bffc03 	ldbu	r2,-16(fp)
811148fc:	10000f1e 	bne	r2,zero,8111493c <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114900:	d1206117 	ldw	r4,-32380(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
81114904:	e0fffd17 	ldw	r3,-12(fp)
81114908:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111490c:	188b883a 	add	r5,r3,r2
81114910:	e0bffd17 	ldw	r2,-12(fp)
81114914:	e0fffe17 	ldw	r3,-8(fp)
81114918:	d8c00115 	stw	r3,4(sp)
8111491c:	d8800015 	stw	r2,0(sp)
81114920:	280f883a 	mov	r7,r5
81114924:	01a04574 	movhi	r6,33045
81114928:	31aab904 	addi	r6,r6,-21788
8111492c:	01604574 	movhi	r5,33045
81114930:	296a0d04 	addi	r5,r5,-22476
81114934:	111d6140 	call	8111d614 <fprintf>
81114938:	00000706 	br	81114958 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
8111493c:	d0a06117 	ldw	r2,-32380(gp)
81114940:	100f883a 	mov	r7,r2
81114944:	01800884 	movi	r6,34
81114948:	01400044 	movi	r5,1
8111494c:	01204574 	movhi	r4,33045
81114950:	212abc04 	addi	r4,r4,-21776
81114954:	111dcb00 	call	8111dcb0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81114958:	e0bffd04 	addi	r2,fp,-12
8111495c:	100b883a 	mov	r5,r2
81114960:	01000244 	movi	r4,9
81114964:	113d0240 	call	8113d024 <OSTaskStkChk>
81114968:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111496c:	e0bffc03 	ldbu	r2,-16(fp)
81114970:	10000f1e 	bne	r2,zero,811149b0 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114974:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81114978:	e0fffd17 	ldw	r3,-12(fp)
8111497c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114980:	188b883a 	add	r5,r3,r2
81114984:	e0bffd17 	ldw	r2,-12(fp)
81114988:	e0fffe17 	ldw	r3,-8(fp)
8111498c:	d8c00115 	stw	r3,4(sp)
81114990:	d8800015 	stw	r2,0(sp)
81114994:	280f883a 	mov	r7,r5
81114998:	01a04574 	movhi	r6,33045
8111499c:	31aac504 	addi	r6,r6,-21740
811149a0:	01604574 	movhi	r5,33045
811149a4:	296a0d04 	addi	r5,r5,-22476
811149a8:	111d6140 	call	8111d614 <fprintf>
811149ac:	00000706 	br	811149cc <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
811149b0:	d0a06117 	ldw	r2,-32380(gp)
811149b4:	100f883a 	mov	r7,r2
811149b8:	01800844 	movi	r6,33
811149bc:	01400044 	movi	r5,1
811149c0:	01204574 	movhi	r4,33045
811149c4:	212ac804 	addi	r4,r4,-21728
811149c8:	111dcb00 	call	8111dcb0 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
811149cc:	e0bffd04 	addi	r2,fp,-12
811149d0:	100b883a 	mov	r5,r2
811149d4:	01000204 	movi	r4,8
811149d8:	113d0240 	call	8113d024 <OSTaskStkChk>
811149dc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811149e0:	e0bffc03 	ldbu	r2,-16(fp)
811149e4:	10000f1e 	bne	r2,zero,81114a24 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811149e8:	d1206117 	ldw	r4,-32380(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
811149ec:	e0fffd17 	ldw	r3,-12(fp)
811149f0:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811149f4:	188b883a 	add	r5,r3,r2
811149f8:	e0bffd17 	ldw	r2,-12(fp)
811149fc:	e0fffe17 	ldw	r3,-8(fp)
81114a00:	d8c00115 	stw	r3,4(sp)
81114a04:	d8800015 	stw	r2,0(sp)
81114a08:	280f883a 	mov	r7,r5
81114a0c:	01a04574 	movhi	r6,33045
81114a10:	31aad104 	addi	r6,r6,-21692
81114a14:	01604574 	movhi	r5,33045
81114a18:	296a0d04 	addi	r5,r5,-22476
81114a1c:	111d6140 	call	8111d614 <fprintf>
81114a20:	00000706 	br	81114a40 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
81114a24:	d0a06117 	ldw	r2,-32380(gp)
81114a28:	100f883a 	mov	r7,r2
81114a2c:	018007c4 	movi	r6,31
81114a30:	01400044 	movi	r5,1
81114a34:	01204574 	movhi	r4,33045
81114a38:	212ad404 	addi	r4,r4,-21680
81114a3c:	111dcb00 	call	8111dcb0 <fwrite>
    	}		


    	fprintf(fp, "\n" );
81114a40:	d0a06117 	ldw	r2,-32380(gp)
81114a44:	100b883a 	mov	r5,r2
81114a48:	01000284 	movi	r4,10
81114a4c:	111d68c0 	call	8111d68c <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81114a50:	000f883a 	mov	r7,zero
81114a54:	01800284 	movi	r6,10
81114a58:	000b883a 	mov	r5,zero
81114a5c:	0009883a 	mov	r4,zero
81114a60:	113d6880 	call	8113d688 <OSTimeDlyHMSM>
    }
81114a64:	003e1806 	br	811142c8 <__reset+0xfb0f42c8>

81114a68 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81114a68:	defffc04 	addi	sp,sp,-16
81114a6c:	de00012e 	bgeu	sp,et,81114a74 <vTimeoutCheckerTaskv2+0xc>
81114a70:	003b68fa 	trap	3
81114a74:	dfc00315 	stw	ra,12(sp)
81114a78:	df000215 	stw	fp,8(sp)
81114a7c:	df000204 	addi	fp,sp,8
81114a80:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81114a84:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81114a88:	d0a06117 	ldw	r2,-32380(gp)
81114a8c:	100f883a 	mov	r7,r2
81114a90:	01800844 	movi	r6,33
81114a94:	01400044 	movi	r5,1
81114a98:	01204574 	movhi	r4,33045
81114a9c:	212adc04 	addi	r4,r4,-21648
81114aa0:	111dcb00 	call	8111dcb0 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81114aa4:	d0a06617 	ldw	r2,-32360(gp)
81114aa8:	e1bffe04 	addi	r6,fp,-8
81114aac:	000b883a 	mov	r5,zero
81114ab0:	1009883a 	mov	r4,r2
81114ab4:	113b6f00 	call	8113b6f0 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81114ab8:	e0bffe03 	ldbu	r2,-8(fp)
81114abc:	10803fcc 	andi	r2,r2,255
81114ac0:	1000021e 	bne	r2,zero,81114acc <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81114ac4:	1114ad40 	call	81114ad4 <vCheck>
81114ac8:	003ff606 	br	81114aa4 <__reset+0xfb0f4aa4>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81114acc:	11193a80 	call	811193a8 <vFailGetBlockingSemTimeoutTask>
        }
    }
81114ad0:	003ff406 	br	81114aa4 <__reset+0xfb0f4aa4>

81114ad4 <vCheck>:
}


void vCheck( void ) {
81114ad4:	defffd04 	addi	sp,sp,-12
81114ad8:	de00012e 	bgeu	sp,et,81114ae0 <vCheck+0xc>
81114adc:	003b68fa 	trap	3
81114ae0:	dfc00215 	stw	ra,8(sp)
81114ae4:	df000115 	stw	fp,4(sp)
81114ae8:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81114aec:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81114af0:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81114af4:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81114af8:	d0a06783 	ldbu	r2,-32354(gp)
81114afc:	10803fcc 	andi	r2,r2,255
81114b00:	10800218 	cmpnei	r2,r2,8
81114b04:	1000021e 	bne	r2,zero,81114b10 <vCheck+0x3c>
81114b08:	00c00104 	movi	r3,4
81114b0c:	00000106 	br	81114b14 <vCheck+0x40>
81114b10:	0007883a 	mov	r3,zero
81114b14:	d0a07403 	ldbu	r2,-32304(gp)
81114b18:	10803fcc 	andi	r2,r2,255
81114b1c:	10800218 	cmpnei	r2,r2,8
81114b20:	1000021e 	bne	r2,zero,81114b2c <vCheck+0x58>
81114b24:	00800084 	movi	r2,2
81114b28:	00000106 	br	81114b30 <vCheck+0x5c>
81114b2c:	0005883a 	mov	r2,zero
81114b30:	1884b03a 	or	r2,r3,r2
81114b34:	1007883a 	mov	r3,r2
81114b38:	d0a07443 	ldbu	r2,-32303(gp)
81114b3c:	10803fcc 	andi	r2,r2,255
81114b40:	108001a0 	cmpeqi	r2,r2,6
81114b44:	1884b03a 	or	r2,r3,r2
81114b48:	1007883a 	mov	r3,r2
81114b4c:	e0bfff03 	ldbu	r2,-4(fp)
81114b50:	1884b03a 	or	r2,r3,r2
81114b54:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81114b58:	e0bfff03 	ldbu	r2,-4(fp)
81114b5c:	108001d8 	cmpnei	r2,r2,7
81114b60:	10003726 	beq	r2,zero,81114c40 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81114b64:	d0a07317 	ldw	r2,-32308(gp)
81114b68:	e0ffff44 	addi	r3,fp,-3
81114b6c:	180d883a 	mov	r6,r3
81114b70:	000b883a 	mov	r5,zero
81114b74:	1009883a 	mov	r4,r2
81114b78:	11396e40 	call	811396e4 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81114b7c:	e0bfff43 	ldbu	r2,-3(fp)
81114b80:	10803fcc 	andi	r2,r2,255
81114b84:	10000826 	beq	r2,zero,81114ba8 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81114b88:	d0a06117 	ldw	r2,-32380(gp)
81114b8c:	100f883a 	mov	r7,r2
81114b90:	01800f04 	movi	r6,60
81114b94:	01400044 	movi	r5,1
81114b98:	01204574 	movhi	r4,33045
81114b9c:	212ae504 	addi	r4,r4,-21612
81114ba0:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
        return;
81114ba4:	00002706 	br	81114c44 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81114ba8:	e0bfff03 	ldbu	r2,-4(fp)
81114bac:	1080004c 	andi	r2,r2,1
81114bb0:	10803fcc 	andi	r2,r2,255
81114bb4:	1000021e 	bne	r2,zero,81114bc0 <vCheck+0xec>
        vCheckRetransmission128();
81114bb8:	1114c580 	call	81114c58 <vCheckRetransmission128>
81114bbc:	00000506 	br	81114bd4 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81114bc0:	01800604 	movi	r6,24
81114bc4:	000b883a 	mov	r5,zero
81114bc8:	012045b4 	movhi	r4,33046
81114bcc:	212c7704 	addi	r4,r4,-20004
81114bd0:	111e8140 	call	8111e814 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81114bd4:	e0bfff03 	ldbu	r2,-4(fp)
81114bd8:	1080008c 	andi	r2,r2,2
81114bdc:	10803fcc 	andi	r2,r2,255
81114be0:	1000021e 	bne	r2,zero,81114bec <vCheck+0x118>
        vCheckRetransmission64();
81114be4:	1114edc0 	call	81114edc <vCheckRetransmission64>
81114be8:	00000506 	br	81114c00 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81114bec:	01800804 	movi	r6,32
81114bf0:	000b883a 	mov	r5,zero
81114bf4:	012045b4 	movhi	r4,33046
81114bf8:	212c7d04 	addi	r4,r4,-19980
81114bfc:	111e8140 	call	8111e814 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81114c00:	e0bfff03 	ldbu	r2,-4(fp)
81114c04:	1080010c 	andi	r2,r2,4
81114c08:	10803fcc 	andi	r2,r2,255
81114c0c:	1000021e 	bne	r2,zero,81114c18 <vCheck+0x144>
        vCheckRetransmission32();
81114c10:	11151680 	call	81115168 <vCheckRetransmission32>
81114c14:	00000506 	br	81114c2c <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81114c18:	01800804 	movi	r6,32
81114c1c:	000b883a 	mov	r5,zero
81114c20:	012045b4 	movhi	r4,33046
81114c24:	212c8504 	addi	r4,r4,-19948
81114c28:	111e8140 	call	8111e814 <memset>


    OSMutexPost(xTxUARTMutex);
81114c2c:	d0a07317 	ldw	r2,-32308(gp)
81114c30:	1009883a 	mov	r4,r2
81114c34:	1139c880 	call	81139c88 <OSMutexPost>

    return;
81114c38:	0001883a 	nop
81114c3c:	00000106 	br	81114c44 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81114c40:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81114c44:	e037883a 	mov	sp,fp
81114c48:	dfc00117 	ldw	ra,4(sp)
81114c4c:	df000017 	ldw	fp,0(sp)
81114c50:	dec00204 	addi	sp,sp,8
81114c54:	f800283a 	ret

81114c58 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81114c58:	defffd04 	addi	sp,sp,-12
81114c5c:	de00012e 	bgeu	sp,et,81114c64 <vCheckRetransmission128+0xc>
81114c60:	003b68fa 	trap	3
81114c64:	dfc00215 	stw	ra,8(sp)
81114c68:	df000115 	stw	fp,4(sp)
81114c6c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81114c70:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81114c74:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81114c78:	d0a06d17 	ldw	r2,-32332(gp)
81114c7c:	e0ffff44 	addi	r3,fp,-3
81114c80:	180b883a 	mov	r5,r3
81114c84:	1009883a 	mov	r4,r2
81114c88:	11390640 	call	81139064 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81114c8c:	e0bfff43 	ldbu	r2,-3(fp)
81114c90:	10803fcc 	andi	r2,r2,255
81114c94:	10008b1e 	bne	r2,zero,81114ec4 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81114c98:	e03fff05 	stb	zero,-4(fp)
81114c9c:	00008106 	br	81114ea4 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81114ca0:	e0ffff03 	ldbu	r3,-4(fp)
81114ca4:	00a045b4 	movhi	r2,33046
81114ca8:	10ac7704 	addi	r2,r2,-20004
81114cac:	18c7883a 	add	r3,r3,r3
81114cb0:	18c7883a 	add	r3,r3,r3
81114cb4:	10c5883a 	add	r2,r2,r3
81114cb8:	10800017 	ldw	r2,0(r2)
81114cbc:	10800058 	cmpnei	r2,r2,1
81114cc0:	1000751e 	bne	r2,zero,81114e98 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81114cc4:	e0ffff03 	ldbu	r3,-4(fp)
81114cc8:	00a045b4 	movhi	r2,33046
81114ccc:	10ac9504 	addi	r2,r2,-19884
81114cd0:	18c02324 	muli	r3,r3,140
81114cd4:	10c5883a 	add	r2,r2,r3
81114cd8:	10802004 	addi	r2,r2,128
81114cdc:	10800017 	ldw	r2,0(r2)
81114ce0:	10800058 	cmpnei	r2,r2,1
81114ce4:	1000211e 	bne	r2,zero,81114d6c <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81114ce8:	e0ffff03 	ldbu	r3,-4(fp)
81114cec:	00a045b4 	movhi	r2,33046
81114cf0:	10ac9504 	addi	r2,r2,-19884
81114cf4:	19002324 	muli	r4,r3,140
81114cf8:	1105883a 	add	r2,r2,r4
81114cfc:	10802184 	addi	r2,r2,134
81114d00:	1080000b 	ldhu	r2,0(r2)
81114d04:	10800044 	addi	r2,r2,1
81114d08:	100b883a 	mov	r5,r2
81114d0c:	00a045b4 	movhi	r2,33046
81114d10:	10ac9504 	addi	r2,r2,-19884
81114d14:	19002324 	muli	r4,r3,140
81114d18:	1105883a 	add	r2,r2,r4
81114d1c:	10802184 	addi	r2,r2,134
81114d20:	1140000d 	sth	r5,0(r2)
81114d24:	00a045b4 	movhi	r2,33046
81114d28:	10ac9504 	addi	r2,r2,-19884
81114d2c:	18c02324 	muli	r3,r3,140
81114d30:	10c5883a 	add	r2,r2,r3
81114d34:	10802184 	addi	r2,r2,134
81114d38:	1080000b 	ldhu	r2,0(r2)
81114d3c:	10bfffcc 	andi	r2,r2,65535
81114d40:	10a0001c 	xori	r2,r2,32768
81114d44:	10a00004 	addi	r2,r2,-32768
81114d48:	10800090 	cmplti	r2,r2,2
81114d4c:	1000071e 	bne	r2,zero,81114d6c <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81114d50:	e0ffff03 	ldbu	r3,-4(fp)
81114d54:	00a045b4 	movhi	r2,33046
81114d58:	10ac9504 	addi	r2,r2,-19884
81114d5c:	18c02324 	muli	r3,r3,140
81114d60:	10c5883a 	add	r2,r2,r3
81114d64:	10802004 	addi	r2,r2,128
81114d68:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81114d6c:	e0ffff03 	ldbu	r3,-4(fp)
81114d70:	00a045b4 	movhi	r2,33046
81114d74:	10ac9504 	addi	r2,r2,-19884
81114d78:	18c02324 	muli	r3,r3,140
81114d7c:	10c5883a 	add	r2,r2,r3
81114d80:	10802004 	addi	r2,r2,128
81114d84:	10800017 	ldw	r2,0(r2)
81114d88:	1000431e 	bne	r2,zero,81114e98 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81114d8c:	e0bfff03 	ldbu	r2,-4(fp)
81114d90:	10c02324 	muli	r3,r2,140
81114d94:	00a045b4 	movhi	r2,33046
81114d98:	10ac9504 	addi	r2,r2,-19884
81114d9c:	1885883a 	add	r2,r3,r2
81114da0:	1009883a 	mov	r4,r2
81114da4:	111ec600 	call	8111ec60 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81114da8:	e0ffff03 	ldbu	r3,-4(fp)
81114dac:	00a045b4 	movhi	r2,33046
81114db0:	10ac9504 	addi	r2,r2,-19884
81114db4:	18c02324 	muli	r3,r3,140
81114db8:	10c5883a 	add	r2,r2,r3
81114dbc:	10802004 	addi	r2,r2,128
81114dc0:	00c00044 	movi	r3,1
81114dc4:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81114dc8:	e0ffff03 	ldbu	r3,-4(fp)
81114dcc:	00a045b4 	movhi	r2,33046
81114dd0:	10ac9504 	addi	r2,r2,-19884
81114dd4:	18c02324 	muli	r3,r3,140
81114dd8:	10c5883a 	add	r2,r2,r3
81114ddc:	10802184 	addi	r2,r2,134
81114de0:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81114de4:	e0ffff03 	ldbu	r3,-4(fp)
81114de8:	00a045b4 	movhi	r2,33046
81114dec:	10ac9504 	addi	r2,r2,-19884
81114df0:	19002324 	muli	r4,r3,140
81114df4:	1105883a 	add	r2,r2,r4
81114df8:	10802204 	addi	r2,r2,136
81114dfc:	10800003 	ldbu	r2,0(r2)
81114e00:	10800044 	addi	r2,r2,1
81114e04:	100b883a 	mov	r5,r2
81114e08:	00a045b4 	movhi	r2,33046
81114e0c:	10ac9504 	addi	r2,r2,-19884
81114e10:	19002324 	muli	r4,r3,140
81114e14:	1105883a 	add	r2,r2,r4
81114e18:	10802204 	addi	r2,r2,136
81114e1c:	11400005 	stb	r5,0(r2)
81114e20:	00a045b4 	movhi	r2,33046
81114e24:	10ac9504 	addi	r2,r2,-19884
81114e28:	18c02324 	muli	r3,r3,140
81114e2c:	10c5883a 	add	r2,r2,r3
81114e30:	10802204 	addi	r2,r2,136
81114e34:	10800003 	ldbu	r2,0(r2)
81114e38:	10803fcc 	andi	r2,r2,255
81114e3c:	108000b0 	cmpltui	r2,r2,2
81114e40:	1000151e 	bne	r2,zero,81114e98 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81114e44:	e0ffff03 	ldbu	r3,-4(fp)
81114e48:	00a045b4 	movhi	r2,33046
81114e4c:	10ac7704 	addi	r2,r2,-20004
81114e50:	18c7883a 	add	r3,r3,r3
81114e54:	18c7883a 	add	r3,r3,r3
81114e58:	10c5883a 	add	r2,r2,r3
81114e5c:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81114e60:	d0a07443 	ldbu	r2,-32303(gp)
81114e64:	10800044 	addi	r2,r2,1
81114e68:	d0a07445 	stb	r2,-32303(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81114e6c:	d0a06217 	ldw	r2,-32376(gp)
81114e70:	1009883a 	mov	r4,r2
81114e74:	113ba780 	call	8113ba78 <OSSemPost>
81114e78:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81114e7c:	e0bfff43 	ldbu	r2,-3(fp)
81114e80:	10803fcc 	andi	r2,r2,255
81114e84:	10000426 	beq	r2,zero,81114e98 <vCheckRetransmission128+0x240>
                        SemCount128--;
81114e88:	d0a07443 	ldbu	r2,-32303(gp)
81114e8c:	10bfffc4 	addi	r2,r2,-1
81114e90:	d0a07445 	stb	r2,-32303(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81114e94:	1118c980 	call	81118c98 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81114e98:	e0bfff03 	ldbu	r2,-4(fp)
81114e9c:	10800044 	addi	r2,r2,1
81114ea0:	e0bfff05 	stb	r2,-4(fp)
81114ea4:	e0bfff03 	ldbu	r2,-4(fp)
81114ea8:	108001b0 	cmpltui	r2,r2,6
81114eac:	103f7c1e 	bne	r2,zero,81114ca0 <__reset+0xfb0f4ca0>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81114eb0:	d0a06d17 	ldw	r2,-32332(gp)
81114eb4:	1009883a 	mov	r4,r2
81114eb8:	1139c880 	call	81139c88 <OSMutexPost>

    return;
81114ebc:	0001883a 	nop
81114ec0:	00000106 	br	81114ec8 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81114ec4:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81114ec8:	e037883a 	mov	sp,fp
81114ecc:	dfc00117 	ldw	ra,4(sp)
81114ed0:	df000017 	ldw	fp,0(sp)
81114ed4:	dec00204 	addi	sp,sp,8
81114ed8:	f800283a 	ret

81114edc <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81114edc:	defffd04 	addi	sp,sp,-12
81114ee0:	de00012e 	bgeu	sp,et,81114ee8 <vCheckRetransmission64+0xc>
81114ee4:	003b68fa 	trap	3
81114ee8:	dfc00215 	stw	ra,8(sp)
81114eec:	df000115 	stw	fp,4(sp)
81114ef0:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81114ef4:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81114ef8:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81114efc:	d0a07017 	ldw	r2,-32320(gp)
81114f00:	e0ffff44 	addi	r3,fp,-3
81114f04:	180b883a 	mov	r5,r3
81114f08:	1009883a 	mov	r4,r2
81114f0c:	11390640 	call	81139064 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81114f10:	e0bfff43 	ldbu	r2,-3(fp)
81114f14:	10803fcc 	andi	r2,r2,255
81114f18:	10008d1e 	bne	r2,zero,81115150 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81114f1c:	e03fff05 	stb	zero,-4(fp)
81114f20:	00008306 	br	81115130 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81114f24:	e0ffff03 	ldbu	r3,-4(fp)
81114f28:	00a045b4 	movhi	r2,33046
81114f2c:	10ac7704 	addi	r2,r2,-20004
81114f30:	18c00184 	addi	r3,r3,6
81114f34:	18c7883a 	add	r3,r3,r3
81114f38:	18c7883a 	add	r3,r3,r3
81114f3c:	10c5883a 	add	r2,r2,r3
81114f40:	10800017 	ldw	r2,0(r2)
81114f44:	10800058 	cmpnei	r2,r2,1
81114f48:	1000761e 	bne	r2,zero,81115124 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81114f4c:	e0ffff03 	ldbu	r3,-4(fp)
81114f50:	00a04574 	movhi	r2,33045
81114f54:	10883b04 	addi	r2,r2,8428
81114f58:	18c01324 	muli	r3,r3,76
81114f5c:	10c5883a 	add	r2,r2,r3
81114f60:	10801004 	addi	r2,r2,64
81114f64:	10800017 	ldw	r2,0(r2)
81114f68:	10800058 	cmpnei	r2,r2,1
81114f6c:	1000211e 	bne	r2,zero,81114ff4 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81114f70:	e0ffff03 	ldbu	r3,-4(fp)
81114f74:	00a04574 	movhi	r2,33045
81114f78:	10883b04 	addi	r2,r2,8428
81114f7c:	19001324 	muli	r4,r3,76
81114f80:	1105883a 	add	r2,r2,r4
81114f84:	10801184 	addi	r2,r2,70
81114f88:	1080000b 	ldhu	r2,0(r2)
81114f8c:	10800044 	addi	r2,r2,1
81114f90:	100b883a 	mov	r5,r2
81114f94:	00a04574 	movhi	r2,33045
81114f98:	10883b04 	addi	r2,r2,8428
81114f9c:	19001324 	muli	r4,r3,76
81114fa0:	1105883a 	add	r2,r2,r4
81114fa4:	10801184 	addi	r2,r2,70
81114fa8:	1140000d 	sth	r5,0(r2)
81114fac:	00a04574 	movhi	r2,33045
81114fb0:	10883b04 	addi	r2,r2,8428
81114fb4:	18c01324 	muli	r3,r3,76
81114fb8:	10c5883a 	add	r2,r2,r3
81114fbc:	10801184 	addi	r2,r2,70
81114fc0:	1080000b 	ldhu	r2,0(r2)
81114fc4:	10bfffcc 	andi	r2,r2,65535
81114fc8:	10a0001c 	xori	r2,r2,32768
81114fcc:	10a00004 	addi	r2,r2,-32768
81114fd0:	10800090 	cmplti	r2,r2,2
81114fd4:	1000071e 	bne	r2,zero,81114ff4 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81114fd8:	e0ffff03 	ldbu	r3,-4(fp)
81114fdc:	00a04574 	movhi	r2,33045
81114fe0:	10883b04 	addi	r2,r2,8428
81114fe4:	18c01324 	muli	r3,r3,76
81114fe8:	10c5883a 	add	r2,r2,r3
81114fec:	10801004 	addi	r2,r2,64
81114ff0:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81114ff4:	e0ffff03 	ldbu	r3,-4(fp)
81114ff8:	00a04574 	movhi	r2,33045
81114ffc:	10883b04 	addi	r2,r2,8428
81115000:	18c01324 	muli	r3,r3,76
81115004:	10c5883a 	add	r2,r2,r3
81115008:	10801004 	addi	r2,r2,64
8111500c:	10800017 	ldw	r2,0(r2)
81115010:	1000441e 	bne	r2,zero,81115124 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
81115014:	e0bfff03 	ldbu	r2,-4(fp)
81115018:	10c01324 	muli	r3,r2,76
8111501c:	00a04574 	movhi	r2,33045
81115020:	10883b04 	addi	r2,r2,8428
81115024:	1885883a 	add	r2,r3,r2
81115028:	1009883a 	mov	r4,r2
8111502c:	111ec600 	call	8111ec60 <puts>
                xBuffer64[ucIL].bSent = TRUE;
81115030:	e0ffff03 	ldbu	r3,-4(fp)
81115034:	00a04574 	movhi	r2,33045
81115038:	10883b04 	addi	r2,r2,8428
8111503c:	18c01324 	muli	r3,r3,76
81115040:	10c5883a 	add	r2,r2,r3
81115044:	10801004 	addi	r2,r2,64
81115048:	00c00044 	movi	r3,1
8111504c:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81115050:	e0ffff03 	ldbu	r3,-4(fp)
81115054:	00a04574 	movhi	r2,33045
81115058:	10883b04 	addi	r2,r2,8428
8111505c:	18c01324 	muli	r3,r3,76
81115060:	10c5883a 	add	r2,r2,r3
81115064:	10801184 	addi	r2,r2,70
81115068:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8111506c:	e0ffff03 	ldbu	r3,-4(fp)
81115070:	00a04574 	movhi	r2,33045
81115074:	10883b04 	addi	r2,r2,8428
81115078:	19001324 	muli	r4,r3,76
8111507c:	1105883a 	add	r2,r2,r4
81115080:	10801204 	addi	r2,r2,72
81115084:	10800003 	ldbu	r2,0(r2)
81115088:	10800044 	addi	r2,r2,1
8111508c:	100b883a 	mov	r5,r2
81115090:	00a04574 	movhi	r2,33045
81115094:	10883b04 	addi	r2,r2,8428
81115098:	19001324 	muli	r4,r3,76
8111509c:	1105883a 	add	r2,r2,r4
811150a0:	10801204 	addi	r2,r2,72
811150a4:	11400005 	stb	r5,0(r2)
811150a8:	00a04574 	movhi	r2,33045
811150ac:	10883b04 	addi	r2,r2,8428
811150b0:	18c01324 	muli	r3,r3,76
811150b4:	10c5883a 	add	r2,r2,r3
811150b8:	10801204 	addi	r2,r2,72
811150bc:	10800003 	ldbu	r2,0(r2)
811150c0:	10803fcc 	andi	r2,r2,255
811150c4:	108000b0 	cmpltui	r2,r2,2
811150c8:	1000161e 	bne	r2,zero,81115124 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
811150cc:	e0ffff03 	ldbu	r3,-4(fp)
811150d0:	00a045b4 	movhi	r2,33046
811150d4:	10ac7704 	addi	r2,r2,-20004
811150d8:	18c00184 	addi	r3,r3,6
811150dc:	18c7883a 	add	r3,r3,r3
811150e0:	18c7883a 	add	r3,r3,r3
811150e4:	10c5883a 	add	r2,r2,r3
811150e8:	10000015 	stw	zero,0(r2)
                    SemCount64++;
811150ec:	d0a07403 	ldbu	r2,-32304(gp)
811150f0:	10800044 	addi	r2,r2,1
811150f4:	d0a07405 	stb	r2,-32304(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
811150f8:	d0a05d17 	ldw	r2,-32396(gp)
811150fc:	1009883a 	mov	r4,r2
81115100:	113ba780 	call	8113ba78 <OSSemPost>
81115104:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81115108:	e0bfff43 	ldbu	r2,-3(fp)
8111510c:	10803fcc 	andi	r2,r2,255
81115110:	10000426 	beq	r2,zero,81115124 <vCheckRetransmission64+0x248>
                        SemCount64--;
81115114:	d0a07403 	ldbu	r2,-32304(gp)
81115118:	10bfffc4 	addi	r2,r2,-1
8111511c:	d0a07405 	stb	r2,-32304(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81115120:	1118c300 	call	81118c30 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81115124:	e0bfff03 	ldbu	r2,-4(fp)
81115128:	10800044 	addi	r2,r2,1
8111512c:	e0bfff05 	stb	r2,-4(fp)
81115130:	e0bfff03 	ldbu	r2,-4(fp)
81115134:	10800230 	cmpltui	r2,r2,8
81115138:	103f7a1e 	bne	r2,zero,81114f24 <__reset+0xfb0f4f24>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
8111513c:	d0a07017 	ldw	r2,-32320(gp)
81115140:	1009883a 	mov	r4,r2
81115144:	1139c880 	call	81139c88 <OSMutexPost>

    return;
81115148:	0001883a 	nop
8111514c:	00000106 	br	81115154 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81115150:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
81115154:	e037883a 	mov	sp,fp
81115158:	dfc00117 	ldw	ra,4(sp)
8111515c:	df000017 	ldw	fp,0(sp)
81115160:	dec00204 	addi	sp,sp,8
81115164:	f800283a 	ret

81115168 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81115168:	defffd04 	addi	sp,sp,-12
8111516c:	de00012e 	bgeu	sp,et,81115174 <vCheckRetransmission32+0xc>
81115170:	003b68fa 	trap	3
81115174:	dfc00215 	stw	ra,8(sp)
81115178:	df000115 	stw	fp,4(sp)
8111517c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81115180:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
81115184:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81115188:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8111518c:	d0a06b17 	ldw	r2,-32340(gp)
81115190:	e0ffff84 	addi	r3,fp,-2
81115194:	180b883a 	mov	r5,r3
81115198:	1009883a 	mov	r4,r2
8111519c:	11390640 	call	81139064 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811151a0:	e0bfff83 	ldbu	r2,-2(fp)
811151a4:	10803fcc 	andi	r2,r2,255
811151a8:	10009b1e 	bne	r2,zero,81115418 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811151ac:	e03fff05 	stb	zero,-4(fp)
811151b0:	00009106 	br	811153f8 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
811151b4:	e0ffff03 	ldbu	r3,-4(fp)
811151b8:	00a045b4 	movhi	r2,33046
811151bc:	10ac7704 	addi	r2,r2,-20004
811151c0:	18c00384 	addi	r3,r3,14
811151c4:	18c7883a 	add	r3,r3,r3
811151c8:	18c7883a 	add	r3,r3,r3
811151cc:	10c5883a 	add	r2,r2,r3
811151d0:	10800017 	ldw	r2,0(r2)
811151d4:	10800058 	cmpnei	r2,r2,1
811151d8:	1000841e 	bne	r2,zero,811153ec <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
811151dc:	e0ffff03 	ldbu	r3,-4(fp)
811151e0:	00a04574 	movhi	r2,33045
811151e4:	1099f704 	addi	r2,r2,26588
811151e8:	18c00b24 	muli	r3,r3,44
811151ec:	10c5883a 	add	r2,r2,r3
811151f0:	10800804 	addi	r2,r2,32
811151f4:	10800017 	ldw	r2,0(r2)
811151f8:	10800058 	cmpnei	r2,r2,1
811151fc:	1000211e 	bne	r2,zero,81115284 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81115200:	e0ffff03 	ldbu	r3,-4(fp)
81115204:	00a04574 	movhi	r2,33045
81115208:	1099f704 	addi	r2,r2,26588
8111520c:	19000b24 	muli	r4,r3,44
81115210:	1105883a 	add	r2,r2,r4
81115214:	10800984 	addi	r2,r2,38
81115218:	1080000b 	ldhu	r2,0(r2)
8111521c:	10800044 	addi	r2,r2,1
81115220:	100b883a 	mov	r5,r2
81115224:	00a04574 	movhi	r2,33045
81115228:	1099f704 	addi	r2,r2,26588
8111522c:	19000b24 	muli	r4,r3,44
81115230:	1105883a 	add	r2,r2,r4
81115234:	10800984 	addi	r2,r2,38
81115238:	1140000d 	sth	r5,0(r2)
8111523c:	00a04574 	movhi	r2,33045
81115240:	1099f704 	addi	r2,r2,26588
81115244:	18c00b24 	muli	r3,r3,44
81115248:	10c5883a 	add	r2,r2,r3
8111524c:	10800984 	addi	r2,r2,38
81115250:	1080000b 	ldhu	r2,0(r2)
81115254:	10bfffcc 	andi	r2,r2,65535
81115258:	10a0001c 	xori	r2,r2,32768
8111525c:	10a00004 	addi	r2,r2,-32768
81115260:	10800090 	cmplti	r2,r2,2
81115264:	1000071e 	bne	r2,zero,81115284 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81115268:	e0ffff03 	ldbu	r3,-4(fp)
8111526c:	00a04574 	movhi	r2,33045
81115270:	1099f704 	addi	r2,r2,26588
81115274:	18c00b24 	muli	r3,r3,44
81115278:	10c5883a 	add	r2,r2,r3
8111527c:	10800804 	addi	r2,r2,32
81115280:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81115284:	e0ffff03 	ldbu	r3,-4(fp)
81115288:	00a04574 	movhi	r2,33045
8111528c:	1099f704 	addi	r2,r2,26588
81115290:	18c00b24 	muli	r3,r3,44
81115294:	10c5883a 	add	r2,r2,r3
81115298:	10800804 	addi	r2,r2,32
8111529c:	10800017 	ldw	r2,0(r2)
811152a0:	1000521e 	bne	r2,zero,811153ec <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
811152a4:	e0bfff03 	ldbu	r2,-4(fp)
811152a8:	10c00b24 	muli	r3,r2,44
811152ac:	00a04574 	movhi	r2,33045
811152b0:	1099f704 	addi	r2,r2,26588
811152b4:	1885883a 	add	r2,r3,r2
811152b8:	1009883a 	mov	r4,r2
811152bc:	111ec600 	call	8111ec60 <puts>
                xBuffer32[ucIL].bSent = TRUE;
811152c0:	e0ffff03 	ldbu	r3,-4(fp)
811152c4:	00a04574 	movhi	r2,33045
811152c8:	1099f704 	addi	r2,r2,26588
811152cc:	18c00b24 	muli	r3,r3,44
811152d0:	10c5883a 	add	r2,r2,r3
811152d4:	10800804 	addi	r2,r2,32
811152d8:	00c00044 	movi	r3,1
811152dc:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
811152e0:	e0ffff03 	ldbu	r3,-4(fp)
811152e4:	00a04574 	movhi	r2,33045
811152e8:	1099f704 	addi	r2,r2,26588
811152ec:	18c00b24 	muli	r3,r3,44
811152f0:	10c5883a 	add	r2,r2,r3
811152f4:	10800984 	addi	r2,r2,38
811152f8:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
811152fc:	e0ffff03 	ldbu	r3,-4(fp)
81115300:	00a04574 	movhi	r2,33045
81115304:	1099f704 	addi	r2,r2,26588
81115308:	18c00b24 	muli	r3,r3,44
8111530c:	10c5883a 	add	r2,r2,r3
81115310:	10800904 	addi	r2,r2,36
81115314:	1080000b 	ldhu	r2,0(r2)
81115318:	10bfffcc 	andi	r2,r2,65535
8111531c:	10800058 	cmpnei	r2,r2,1
81115320:	1000021e 	bne	r2,zero,8111532c <vCheckRetransmission32+0x1c4>
81115324:	00bffe84 	movi	r2,-6
81115328:	00000106 	br	81115330 <vCheckRetransmission32+0x1c8>
8111532c:	00800044 	movi	r2,1
81115330:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81115334:	e0ffff03 	ldbu	r3,-4(fp)
81115338:	00a04574 	movhi	r2,33045
8111533c:	1099f704 	addi	r2,r2,26588
81115340:	19000b24 	muli	r4,r3,44
81115344:	1105883a 	add	r2,r2,r4
81115348:	10800a04 	addi	r2,r2,40
8111534c:	10800003 	ldbu	r2,0(r2)
81115350:	10800044 	addi	r2,r2,1
81115354:	100b883a 	mov	r5,r2
81115358:	00a04574 	movhi	r2,33045
8111535c:	1099f704 	addi	r2,r2,26588
81115360:	19000b24 	muli	r4,r3,44
81115364:	1105883a 	add	r2,r2,r4
81115368:	10800a04 	addi	r2,r2,40
8111536c:	11400005 	stb	r5,0(r2)
81115370:	00a04574 	movhi	r2,33045
81115374:	1099f704 	addi	r2,r2,26588
81115378:	18c00b24 	muli	r3,r3,44
8111537c:	10c5883a 	add	r2,r2,r3
81115380:	10800a04 	addi	r2,r2,40
81115384:	10800003 	ldbu	r2,0(r2)
81115388:	10803fcc 	andi	r2,r2,255
8111538c:	e0ffff43 	ldbu	r3,-3(fp)
81115390:	1880162e 	bgeu	r3,r2,811153ec <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81115394:	e0ffff03 	ldbu	r3,-4(fp)
81115398:	00a045b4 	movhi	r2,33046
8111539c:	10ac7704 	addi	r2,r2,-20004
811153a0:	18c00384 	addi	r3,r3,14
811153a4:	18c7883a 	add	r3,r3,r3
811153a8:	18c7883a 	add	r3,r3,r3
811153ac:	10c5883a 	add	r2,r2,r3
811153b0:	10000015 	stw	zero,0(r2)
                    SemCount32++;
811153b4:	d0a06783 	ldbu	r2,-32354(gp)
811153b8:	10800044 	addi	r2,r2,1
811153bc:	d0a06785 	stb	r2,-32354(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
811153c0:	d0a06e17 	ldw	r2,-32328(gp)
811153c4:	1009883a 	mov	r4,r2
811153c8:	113ba780 	call	8113ba78 <OSSemPost>
811153cc:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811153d0:	e0bfff83 	ldbu	r2,-2(fp)
811153d4:	10803fcc 	andi	r2,r2,255
811153d8:	10000426 	beq	r2,zero,811153ec <vCheckRetransmission32+0x284>
                        SemCount32--;
811153dc:	d0a06783 	ldbu	r2,-32354(gp)
811153e0:	10bfffc4 	addi	r2,r2,-1
811153e4:	d0a06785 	stb	r2,-32354(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811153e8:	1118bc80 	call	81118bc8 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811153ec:	e0bfff03 	ldbu	r2,-4(fp)
811153f0:	10800044 	addi	r2,r2,1
811153f4:	e0bfff05 	stb	r2,-4(fp)
811153f8:	e0bfff03 	ldbu	r2,-4(fp)
811153fc:	10800230 	cmpltui	r2,r2,8
81115400:	103f6c1e 	bne	r2,zero,811151b4 <__reset+0xfb0f51b4>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81115404:	d0a06b17 	ldw	r2,-32340(gp)
81115408:	1009883a 	mov	r4,r2
8111540c:	1139c880 	call	81139c88 <OSMutexPost>

    return;
81115410:	0001883a 	nop
81115414:	00000106 	br	8111541c <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81115418:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
8111541c:	e037883a 	mov	sp,fp
81115420:	dfc00117 	ldw	ra,4(sp)
81115424:	df000017 	ldw	fp,0(sp)
81115428:	dec00204 	addi	sp,sp,8
8111542c:	f800283a 	ret

81115430 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81115430:	defff904 	addi	sp,sp,-28
81115434:	de00012e 	bgeu	sp,et,8111543c <bResourcesInitRTOS+0xc>
81115438:	003b68fa 	trap	3
8111543c:	dfc00615 	stw	ra,24(sp)
81115440:	df000515 	stw	fp,20(sp)
81115444:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81115448:	00800044 	movi	r2,1
8111544c:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81115450:	0009883a 	mov	r4,zero
81115454:	113b3c80 	call	8113b3c8 <OSSemCreate>
81115458:	d0a05f15 	stw	r2,-32388(gp)
	if (!xSemCommInit) {
8111545c:	d0a05f17 	ldw	r2,-32388(gp)
81115460:	1000021e 	bne	r2,zero,8111546c <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
81115464:	11186600 	call	81118660 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115468:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
8111546c:	e0bfff04 	addi	r2,fp,-4
81115470:	100b883a 	mov	r5,r2
81115474:	01000444 	movi	r4,17
81115478:	11392100 	call	81139210 <OSMutexCreate>
8111547c:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
81115480:	e0bfff03 	ldbu	r2,-4(fp)
81115484:	10803fcc 	andi	r2,r2,255
81115488:	10000526 	beq	r2,zero,811154a0 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
8111548c:	e0bfff03 	ldbu	r2,-4(fp)
81115490:	10803fcc 	andi	r2,r2,255
81115494:	1009883a 	mov	r4,r2
81115498:	11185b40 	call	811185b4 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111549c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
811154a0:	e0bfff04 	addi	r2,fp,-4
811154a4:	100b883a 	mov	r5,r2
811154a8:	01000504 	movi	r4,20
811154ac:	11392100 	call	81139210 <OSMutexCreate>
811154b0:	d0a06d15 	stw	r2,-32332(gp)
	if ( err != OS_ERR_NONE ) {
811154b4:	e0bfff03 	ldbu	r2,-4(fp)
811154b8:	10803fcc 	andi	r2,r2,255
811154bc:	10000526 	beq	r2,zero,811154d4 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
811154c0:	e0bfff03 	ldbu	r2,-4(fp)
811154c4:	10803fcc 	andi	r2,r2,255
811154c8:	1009883a 	mov	r4,r2
811154cc:	11185b40 	call	811185b4 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811154d0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
811154d4:	e0bfff04 	addi	r2,fp,-4
811154d8:	100b883a 	mov	r5,r2
811154dc:	01000544 	movi	r4,21
811154e0:	11392100 	call	81139210 <OSMutexCreate>
811154e4:	d0a07015 	stw	r2,-32320(gp)
	if ( err != OS_ERR_NONE ) {
811154e8:	e0bfff03 	ldbu	r2,-4(fp)
811154ec:	10803fcc 	andi	r2,r2,255
811154f0:	10000526 	beq	r2,zero,81115508 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
811154f4:	e0bfff03 	ldbu	r2,-4(fp)
811154f8:	10803fcc 	andi	r2,r2,255
811154fc:	1009883a 	mov	r4,r2
81115500:	11185b40 	call	811185b4 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115504:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81115508:	e0bfff04 	addi	r2,fp,-4
8111550c:	100b883a 	mov	r5,r2
81115510:	01000584 	movi	r4,22
81115514:	11392100 	call	81139210 <OSMutexCreate>
81115518:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
8111551c:	e0bfff03 	ldbu	r2,-4(fp)
81115520:	10803fcc 	andi	r2,r2,255
81115524:	10000526 	beq	r2,zero,8111553c <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81115528:	e0bfff03 	ldbu	r2,-4(fp)
8111552c:	10803fcc 	andi	r2,r2,255
81115530:	1009883a 	mov	r4,r2
81115534:	11185b40 	call	811185b4 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115538:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
8111553c:	00800184 	movi	r2,6
81115540:	d0a07445 	stb	r2,-32303(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
81115544:	01000184 	movi	r4,6
81115548:	113b3c80 	call	8113b3c8 <OSSemCreate>
8111554c:	d0a06215 	stw	r2,-32376(gp)
	if (!xSemCountBuffer128) {
81115550:	d0a06217 	ldw	r2,-32376(gp)
81115554:	1000031e 	bne	r2,zero,81115564 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81115558:	d0207445 	stb	zero,-32303(gp)
		vFailCreateSemaphoreResources();
8111555c:	11186600 	call	81118660 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115560:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
81115564:	00800204 	movi	r2,8
81115568:	d0a07405 	stb	r2,-32304(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
8111556c:	01000204 	movi	r4,8
81115570:	113b3c80 	call	8113b3c8 <OSSemCreate>
81115574:	d0a05d15 	stw	r2,-32396(gp)
	if (!xSemCountBuffer64) {
81115578:	d0a05d17 	ldw	r2,-32396(gp)
8111557c:	1000031e 	bne	r2,zero,8111558c <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81115580:	d0207405 	stb	zero,-32304(gp)
		vFailCreateSemaphoreResources();
81115584:	11186600 	call	81118660 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115588:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
8111558c:	00800204 	movi	r2,8
81115590:	d0a06785 	stb	r2,-32354(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81115594:	01000204 	movi	r4,8
81115598:	113b3c80 	call	8113b3c8 <OSSemCreate>
8111559c:	d0a06e15 	stw	r2,-32328(gp)
	if (!xSemCountBuffer32) {
811155a0:	d0a06e17 	ldw	r2,-32328(gp)
811155a4:	1000031e 	bne	r2,zero,811155b4 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
811155a8:	d0206785 	stb	zero,-32354(gp)
		vFailCreateSemaphoreResources();
811155ac:	11186600 	call	81118660 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811155b0:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
811155b4:	e0bfff04 	addi	r2,fp,-4
811155b8:	100b883a 	mov	r5,r2
811155bc:	010004c4 	movi	r4,19
811155c0:	11392100 	call	81139210 <OSMutexCreate>
811155c4:	d0a06415 	stw	r2,-32368(gp)
	if ( err != OS_ERR_NONE ) {
811155c8:	e0bfff03 	ldbu	r2,-4(fp)
811155cc:	10803fcc 	andi	r2,r2,255
811155d0:	10000526 	beq	r2,zero,811155e8 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
811155d4:	e0bfff03 	ldbu	r2,-4(fp)
811155d8:	10803fcc 	andi	r2,r2,255
811155dc:	1009883a 	mov	r4,r2
811155e0:	11185b40 	call	811185b4 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811155e4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
811155e8:	e0bfff04 	addi	r2,fp,-4
811155ec:	100b883a 	mov	r5,r2
811155f0:	010005c4 	movi	r4,23
811155f4:	11392100 	call	81139210 <OSMutexCreate>
811155f8:	d0a06a15 	stw	r2,-32344(gp)
	if ( err != OS_ERR_NONE ) {
811155fc:	e0bfff03 	ldbu	r2,-4(fp)
81115600:	10803fcc 	andi	r2,r2,255
81115604:	10000526 	beq	r2,zero,8111561c <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81115608:	e0bfff03 	ldbu	r2,-4(fp)
8111560c:	10803fcc 	andi	r2,r2,255
81115610:	1009883a 	mov	r4,r2
81115614:	11185b40 	call	811185b4 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115618:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
8111561c:	0009883a 	mov	r4,zero
81115620:	113b3c80 	call	8113b3c8 <OSSemCreate>
81115624:	d0a06515 	stw	r2,-32364(gp)
	if (!xSemCountReceivedACK) {
81115628:	d0a06517 	ldw	r2,-32364(gp)
8111562c:	1000021e 	bne	r2,zero,81115638 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81115630:	11186600 	call	81118660 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115634:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81115638:	0009883a 	mov	r4,zero
8111563c:	113b3c80 	call	8113b3c8 <OSSemCreate>
81115640:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountPreParsed) {
81115644:	d0a06317 	ldw	r2,-32372(gp)
81115648:	1000021e 	bne	r2,zero,81115654 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
8111564c:	11186600 	call	81118660 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115650:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
81115654:	0009883a 	mov	r4,zero
81115658:	113b3c80 	call	8113b3c8 <OSSemCreate>
8111565c:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCountSenderACK) {
81115660:	d0a06017 	ldw	r2,-32384(gp)
81115664:	1000021e 	bne	r2,zero,81115670 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81115668:	11186600 	call	81118660 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8111566c:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81115670:	e0bfff04 	addi	r2,fp,-4
81115674:	100b883a 	mov	r5,r2
81115678:	01000484 	movi	r4,18
8111567c:	11392100 	call	81139210 <OSMutexCreate>
81115680:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81115684:	e0bfff03 	ldbu	r2,-4(fp)
81115688:	10803fcc 	andi	r2,r2,255
8111568c:	10000526 	beq	r2,zero,811156a4 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81115690:	e0bfff03 	ldbu	r2,-4(fp)
81115694:	10803fcc 	andi	r2,r2,255
81115698:	1009883a 	mov	r4,r2
8111569c:	11185b40 	call	811185b4 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811156a0:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
811156a4:	0009883a 	mov	r4,zero
811156a8:	113b3c80 	call	8113b3c8 <OSSemCreate>
811156ac:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemTimeoutChecker) {
811156b0:	d0a06617 	ldw	r2,-32360(gp)
811156b4:	1000021e 	bne	r2,zero,811156c0 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
811156b8:	11186600 	call	81118660 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811156bc:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
811156c0:	e0bfff04 	addi	r2,fp,-4
811156c4:	d8800215 	stw	r2,8(sp)
811156c8:	00a04574 	movhi	r2,33045
811156cc:	10aaf504 	addi	r2,r2,-21548
811156d0:	d8800115 	stw	r2,4(sp)
811156d4:	d8000015 	stw	zero,0(sp)
811156d8:	01e04474 	movhi	r7,33041
811156dc:	39dc8e04 	addi	r7,r7,29240
811156e0:	01800084 	movi	r6,2
811156e4:	01400104 	movi	r5,4
811156e8:	01000284 	movi	r4,10
811156ec:	113da940 	call	8113da94 <OSTmrCreate>
811156f0:	d0a06c15 	stw	r2,-32336(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
811156f4:	e0bfff03 	ldbu	r2,-4(fp)
811156f8:	10803fcc 	andi	r2,r2,255
811156fc:	10000226 	beq	r2,zero,81115708 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81115700:	11192c40 	call	811192c4 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81115704:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81115708:	01400484 	movi	r5,18
8111570c:	01204574 	movhi	r4,33045
81115710:	210d3704 	addi	r4,r4,13532
81115714:	113a2fc0 	call	8113a2fc <OSQCreate>
81115718:	d0a05c15 	stw	r2,-32400(gp)
	if ( xNfeeSchedule == NULL ) {
8111571c:	d0a05c17 	ldw	r2,-32400(gp)
81115720:	1000021e 	bne	r2,zero,8111572c <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81115724:	11198a80 	call	811198a8 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81115728:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
8111572c:	01400204 	movi	r5,8
81115730:	012045b4 	movhi	r4,33046
81115734:	210c4904 	addi	r4,r4,12580
81115738:	113a2fc0 	call	8113a2fc <OSQCreate>
8111573c:	d0a06915 	stw	r2,-32348(gp)
	if ( xFeeQ[0] == NULL ) {
81115740:	d0a06917 	ldw	r2,-32348(gp)
81115744:	1000031e 	bne	r2,zero,81115754 <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81115748:	0009883a 	mov	r4,zero
8111574c:	11199100 	call	81119910 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81115750:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
81115754:	01400204 	movi	r5,8
81115758:	012045b4 	movhi	r4,33046
8111575c:	21318f04 	addi	r4,r4,-14788
81115760:	113a2fc0 	call	8113a2fc <OSQCreate>
81115764:	d0a05b15 	stw	r2,-32404(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81115768:	d0a05b17 	ldw	r2,-32404(gp)
8111576c:	1000031e 	bne	r2,zero,8111577c <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81115770:	0009883a 	mov	r4,zero
81115774:	11199800 	call	81119980 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81115778:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
8111577c:	01400204 	movi	r5,8
81115780:	012045b4 	movhi	r4,33046
81115784:	212c8d04 	addi	r4,r4,-19916
81115788:	113a2fc0 	call	8113a2fc <OSQCreate>
8111578c:	d0a06815 	stw	r2,-32352(gp)
	if ( xMebQ == NULL ) {
81115790:	d0a06817 	ldw	r2,-32352(gp)
81115794:	1000031e 	bne	r2,zero,811157a4 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
81115798:	01000144 	movi	r4,5
8111579c:	11199100 	call	81119910 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811157a0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
811157a4:	e0bfff04 	addi	r2,fp,-4
811157a8:	100b883a 	mov	r5,r2
811157ac:	010001c4 	movi	r4,7
811157b0:	11392100 	call	81139210 <OSMutexCreate>
811157b4:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
811157b8:	e0bfff03 	ldbu	r2,-4(fp)
811157bc:	10803fcc 	andi	r2,r2,255
811157c0:	10000526 	beq	r2,zero,811157d8 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
811157c4:	e0bfff03 	ldbu	r2,-4(fp)
811157c8:	10803fcc 	andi	r2,r2,255
811157cc:	1009883a 	mov	r4,r2
811157d0:	1119d980 	call	81119d98 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
811157d4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
811157d8:	01400404 	movi	r5,16
811157dc:	012045b4 	movhi	r4,33046
811157e0:	212d6704 	addi	r4,r4,-19044
811157e4:	113a2fc0 	call	8113a2fc <OSQCreate>
811157e8:	d0a06f15 	stw	r2,-32324(gp)
	if ( xQMaskFeeCtrl == NULL ) {
811157ec:	d0a06f17 	ldw	r2,-32324(gp)
811157f0:	1000021e 	bne	r2,zero,811157fc <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
811157f4:	1119ef80 	call	81119ef8 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
811157f8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
811157fc:	01400404 	movi	r5,16
81115800:	012045b4 	movhi	r4,33046
81115804:	21204f04 	addi	r4,r4,-32452
81115808:	113a2fc0 	call	8113a2fc <OSQCreate>
8111580c:	d0a05e15 	stw	r2,-32392(gp)
	if ( xQMaskDataCtrl == NULL ) {
81115810:	d0a05e17 	ldw	r2,-32392(gp)
81115814:	1000021e 	bne	r2,zero,81115820 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81115818:	1119f600 	call	81119f60 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
8111581c:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81115820:	e0bfff04 	addi	r2,fp,-4
81115824:	100b883a 	mov	r5,r2
81115828:	01000104 	movi	r4,4
8111582c:	11392100 	call	81139210 <OSMutexCreate>
81115830:	1007883a 	mov	r3,r2
81115834:	00a045b4 	movhi	r2,33046
81115838:	10bf9d04 	addi	r2,r2,-396
8111583c:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81115840:	e0bfff03 	ldbu	r2,-4(fp)
81115844:	10803fcc 	andi	r2,r2,255
81115848:	10000226 	beq	r2,zero,81115854 <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
8111584c:	11186140 	call	81118614 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81115850:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
81115854:	e0bfff04 	addi	r2,fp,-4
81115858:	100b883a 	mov	r5,r2
8111585c:	01000184 	movi	r4,6
81115860:	11392100 	call	81139210 <OSMutexCreate>
81115864:	1007883a 	mov	r3,r2
81115868:	00a045b4 	movhi	r2,33046
8111586c:	10bf9d04 	addi	r2,r2,-396
81115870:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81115874:	e0bfff03 	ldbu	r2,-4(fp)
81115878:	10803fcc 	andi	r2,r2,255
8111587c:	10000226 	beq	r2,zero,81115888 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81115880:	11186140 	call	81118614 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81115884:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81115888:	e0bffe17 	ldw	r2,-8(fp)
}
8111588c:	e037883a 	mov	sp,fp
81115890:	dfc00117 	ldw	ra,4(sp)
81115894:	df000017 	ldw	fp,0(sp)
81115898:	dec00204 	addi	sp,sp,8
8111589c:	f800283a 	ret

811158a0 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
811158a0:	defffd04 	addi	sp,sp,-12
811158a4:	de00012e 	bgeu	sp,et,811158ac <vVariablesInitialization+0xc>
811158a8:	003b68fa 	trap	3
811158ac:	dfc00215 	stw	ra,8(sp)
811158b0:	df000115 	stw	fp,4(sp)
811158b4:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
811158b8:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
811158bc:	00800084 	movi	r2,2
811158c0:	d0a0670d 	sth	r2,-32356(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
811158c4:	01800604 	movi	r6,24
811158c8:	000b883a 	mov	r5,zero
811158cc:	012045b4 	movhi	r4,33046
811158d0:	212c7704 	addi	r4,r4,-20004
811158d4:	111e8140 	call	8111e814 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
811158d8:	01800804 	movi	r6,32
811158dc:	000b883a 	mov	r5,zero
811158e0:	012045b4 	movhi	r4,33046
811158e4:	212c7d04 	addi	r4,r4,-19980
811158e8:	111e8140 	call	8111e814 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
811158ec:	01800804 	movi	r6,32
811158f0:	000b883a 	mov	r5,zero
811158f4:	012045b4 	movhi	r4,33046
811158f8:	212c8504 	addi	r4,r4,-19948
811158fc:	111e8140 	call	8111e814 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81115900:	e03fff05 	stb	zero,-4(fp)
81115904:	00002806 	br	811159a8 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81115908:	e0bfff03 	ldbu	r2,-4(fp)
8111590c:	10c02324 	muli	r3,r2,140
81115910:	00a045b4 	movhi	r2,33046
81115914:	10ac9504 	addi	r2,r2,-19884
81115918:	1885883a 	add	r2,r3,r2
8111591c:	01802004 	movi	r6,128
81115920:	000b883a 	mov	r5,zero
81115924:	1009883a 	mov	r4,r2
81115928:	111e8140 	call	8111e814 <memset>
		xBuffer128[ucIL].bSent = FALSE;
8111592c:	e0ffff03 	ldbu	r3,-4(fp)
81115930:	00a045b4 	movhi	r2,33046
81115934:	10ac9504 	addi	r2,r2,-19884
81115938:	18c02324 	muli	r3,r3,140
8111593c:	10c5883a 	add	r2,r2,r3
81115940:	10802004 	addi	r2,r2,128
81115944:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81115948:	e0ffff03 	ldbu	r3,-4(fp)
8111594c:	00a045b4 	movhi	r2,33046
81115950:	10ac9504 	addi	r2,r2,-19884
81115954:	18c02324 	muli	r3,r3,140
81115958:	10c5883a 	add	r2,r2,r3
8111595c:	10802104 	addi	r2,r2,132
81115960:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
81115964:	e0ffff03 	ldbu	r3,-4(fp)
81115968:	00a045b4 	movhi	r2,33046
8111596c:	10ac9504 	addi	r2,r2,-19884
81115970:	18c02324 	muli	r3,r3,140
81115974:	10c5883a 	add	r2,r2,r3
81115978:	10802184 	addi	r2,r2,134
8111597c:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81115980:	e0ffff03 	ldbu	r3,-4(fp)
81115984:	00a045b4 	movhi	r2,33046
81115988:	10ac9504 	addi	r2,r2,-19884
8111598c:	18c02324 	muli	r3,r3,140
81115990:	10c5883a 	add	r2,r2,r3
81115994:	10802204 	addi	r2,r2,136
81115998:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111599c:	e0bfff03 	ldbu	r2,-4(fp)
811159a0:	10800044 	addi	r2,r2,1
811159a4:	e0bfff05 	stb	r2,-4(fp)
811159a8:	e0bfff03 	ldbu	r2,-4(fp)
811159ac:	108001b0 	cmpltui	r2,r2,6
811159b0:	103fd51e 	bne	r2,zero,81115908 <__reset+0xfb0f5908>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811159b4:	e03fff05 	stb	zero,-4(fp)
811159b8:	00002806 	br	81115a5c <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
811159bc:	e0bfff03 	ldbu	r2,-4(fp)
811159c0:	10c01324 	muli	r3,r2,76
811159c4:	00a04574 	movhi	r2,33045
811159c8:	10883b04 	addi	r2,r2,8428
811159cc:	1885883a 	add	r2,r3,r2
811159d0:	01801004 	movi	r6,64
811159d4:	000b883a 	mov	r5,zero
811159d8:	1009883a 	mov	r4,r2
811159dc:	111e8140 	call	8111e814 <memset>
		xBuffer64[ucIL].bSent = FALSE;
811159e0:	e0ffff03 	ldbu	r3,-4(fp)
811159e4:	00a04574 	movhi	r2,33045
811159e8:	10883b04 	addi	r2,r2,8428
811159ec:	18c01324 	muli	r3,r3,76
811159f0:	10c5883a 	add	r2,r2,r3
811159f4:	10801004 	addi	r2,r2,64
811159f8:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
811159fc:	e0ffff03 	ldbu	r3,-4(fp)
81115a00:	00a04574 	movhi	r2,33045
81115a04:	10883b04 	addi	r2,r2,8428
81115a08:	18c01324 	muli	r3,r3,76
81115a0c:	10c5883a 	add	r2,r2,r3
81115a10:	10801104 	addi	r2,r2,68
81115a14:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81115a18:	e0ffff03 	ldbu	r3,-4(fp)
81115a1c:	00a04574 	movhi	r2,33045
81115a20:	10883b04 	addi	r2,r2,8428
81115a24:	18c01324 	muli	r3,r3,76
81115a28:	10c5883a 	add	r2,r2,r3
81115a2c:	10801184 	addi	r2,r2,70
81115a30:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81115a34:	e0ffff03 	ldbu	r3,-4(fp)
81115a38:	00a04574 	movhi	r2,33045
81115a3c:	10883b04 	addi	r2,r2,8428
81115a40:	18c01324 	muli	r3,r3,76
81115a44:	10c5883a 	add	r2,r2,r3
81115a48:	10801204 	addi	r2,r2,72
81115a4c:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81115a50:	e0bfff03 	ldbu	r2,-4(fp)
81115a54:	10800044 	addi	r2,r2,1
81115a58:	e0bfff05 	stb	r2,-4(fp)
81115a5c:	e0bfff03 	ldbu	r2,-4(fp)
81115a60:	10800230 	cmpltui	r2,r2,8
81115a64:	103fd51e 	bne	r2,zero,811159bc <__reset+0xfb0f59bc>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81115a68:	e03fff05 	stb	zero,-4(fp)
81115a6c:	00002806 	br	81115b10 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81115a70:	e0bfff03 	ldbu	r2,-4(fp)
81115a74:	10c00b24 	muli	r3,r2,44
81115a78:	00a04574 	movhi	r2,33045
81115a7c:	1099f704 	addi	r2,r2,26588
81115a80:	1885883a 	add	r2,r3,r2
81115a84:	01800804 	movi	r6,32
81115a88:	000b883a 	mov	r5,zero
81115a8c:	1009883a 	mov	r4,r2
81115a90:	111e8140 	call	8111e814 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81115a94:	e0ffff03 	ldbu	r3,-4(fp)
81115a98:	00a04574 	movhi	r2,33045
81115a9c:	1099f704 	addi	r2,r2,26588
81115aa0:	18c00b24 	muli	r3,r3,44
81115aa4:	10c5883a 	add	r2,r2,r3
81115aa8:	10800804 	addi	r2,r2,32
81115aac:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81115ab0:	e0ffff03 	ldbu	r3,-4(fp)
81115ab4:	00a04574 	movhi	r2,33045
81115ab8:	1099f704 	addi	r2,r2,26588
81115abc:	18c00b24 	muli	r3,r3,44
81115ac0:	10c5883a 	add	r2,r2,r3
81115ac4:	10800904 	addi	r2,r2,36
81115ac8:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81115acc:	e0ffff03 	ldbu	r3,-4(fp)
81115ad0:	00a04574 	movhi	r2,33045
81115ad4:	1099f704 	addi	r2,r2,26588
81115ad8:	18c00b24 	muli	r3,r3,44
81115adc:	10c5883a 	add	r2,r2,r3
81115ae0:	10800984 	addi	r2,r2,38
81115ae4:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81115ae8:	e0ffff03 	ldbu	r3,-4(fp)
81115aec:	00a04574 	movhi	r2,33045
81115af0:	1099f704 	addi	r2,r2,26588
81115af4:	18c00b24 	muli	r3,r3,44
81115af8:	10c5883a 	add	r2,r2,r3
81115afc:	10800a04 	addi	r2,r2,40
81115b00:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81115b04:	e0bfff03 	ldbu	r2,-4(fp)
81115b08:	10800044 	addi	r2,r2,1
81115b0c:	e0bfff05 	stb	r2,-4(fp)
81115b10:	e0bfff03 	ldbu	r2,-4(fp)
81115b14:	10800230 	cmpltui	r2,r2,8
81115b18:	103fd51e 	bne	r2,zero,81115a70 <__reset+0xfb0f5a70>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81115b1c:	e03fff05 	stb	zero,-4(fp)
81115b20:	00001b06 	br	81115b90 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81115b24:	e0ffff03 	ldbu	r3,-4(fp)
81115b28:	00a04574 	movhi	r2,33045
81115b2c:	1088d304 	addi	r2,r2,9036
81115b30:	18c01524 	muli	r3,r3,84
81115b34:	10c5883a 	add	r2,r2,r3
81115b38:	10800104 	addi	r2,r2,4
81115b3c:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81115b40:	e0ffff03 	ldbu	r3,-4(fp)
81115b44:	00a04574 	movhi	r2,33045
81115b48:	1088d304 	addi	r2,r2,9036
81115b4c:	18c01524 	muli	r3,r3,84
81115b50:	10c5883a 	add	r2,r2,r3
81115b54:	10800484 	addi	r2,r2,18
81115b58:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81115b5c:	e0bfff03 	ldbu	r2,-4(fp)
81115b60:	10801524 	muli	r2,r2,84
81115b64:	10c00504 	addi	r3,r2,20
81115b68:	00a04574 	movhi	r2,33045
81115b6c:	1088d304 	addi	r2,r2,9036
81115b70:	1885883a 	add	r2,r3,r2
81115b74:	01801004 	movi	r6,64
81115b78:	000b883a 	mov	r5,zero
81115b7c:	1009883a 	mov	r4,r2
81115b80:	111e8140 	call	8111e814 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81115b84:	e0bfff03 	ldbu	r2,-4(fp)
81115b88:	10800044 	addi	r2,r2,1
81115b8c:	e0bfff05 	stb	r2,-4(fp)
81115b90:	e0bfff03 	ldbu	r2,-4(fp)
81115b94:	10800130 	cmpltui	r2,r2,4
81115b98:	103fe21e 	bne	r2,zero,81115b24 <__reset+0xfb0f5b24>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81115b9c:	0001883a 	nop
81115ba0:	e037883a 	mov	sp,fp
81115ba4:	dfc00117 	ldw	ra,4(sp)
81115ba8:	df000017 	ldw	fp,0(sp)
81115bac:	dec00204 	addi	sp,sp,8
81115bb0:	f800283a 	ret

81115bb4 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81115bb4:	defff704 	addi	sp,sp,-36
81115bb8:	de00012e 	bgeu	sp,et,81115bc0 <main+0xc>
81115bbc:	003b68fa 	trap	3
81115bc0:	dfc00815 	stw	ra,32(sp)
81115bc4:	df000715 	stw	fp,28(sp)
81115bc8:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81115bcc:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81115bd0:	11356ac0 	call	811356ac <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81115bd4:	01604574 	movhi	r5,33045
81115bd8:	296af904 	addi	r5,r5,-21532
81115bdc:	01204574 	movhi	r4,33045
81115be0:	212afa04 	addi	r4,r4,-21528
81115be4:	111d5cc0 	call	8111d5cc <fopen>
81115be8:	d0a06115 	stw	r2,-32380(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
81115bec:	d0a06117 	ldw	r2,-32380(gp)
81115bf0:	100f883a 	mov	r7,r2
81115bf4:	01800484 	movi	r6,18
81115bf8:	01400044 	movi	r5,1
81115bfc:	01204574 	movhi	r4,33045
81115c00:	212aff04 	addi	r4,r4,-21508
81115c04:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81115c08:	111aedc0 	call	8111aedc <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81115c0c:	111bb200 	call	8111bb20 <bTestSimucamCriticalHW>
81115c10:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81115c14:	e0bffe17 	ldw	r2,-8(fp)
81115c18:	1000031e 	bne	r2,zero,81115c28 <main+0x74>
		vFailTestCriticasParts();
81115c1c:	11186ac0 	call	811186ac <vFailTestCriticasParts>
		return -1;
81115c20:	00bfffc4 	movi	r2,-1
81115c24:	00004106 	br	81115d2c <main+0x178>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81115c28:	111b65c0 	call	8111b65c <bInitializeSDCard>
81115c2c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81115c30:	e0bffe17 	ldw	r2,-8(fp)
81115c34:	1000031e 	bne	r2,zero,81115c44 <main+0x90>
		vFailTestCriticasParts();
81115c38:	11186ac0 	call	811186ac <vFailTestCriticasParts>
		return -1;
81115c3c:	00bfffc4 	movi	r2,-1
81115c40:	00003a06 	br	81115d2c <main+0x178>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81115c44:	11176600 	call	81117660 <vLoadDefaultETHConf>
81115c48:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81115c4c:	e0bffe17 	ldw	r2,-8(fp)
81115c50:	1000091e 	bne	r2,zero,81115c78 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
81115c54:	d0a06117 	ldw	r2,-32380(gp)
81115c58:	100f883a 	mov	r7,r2
81115c5c:	01801644 	movi	r6,89
81115c60:	01400044 	movi	r5,1
81115c64:	01204574 	movhi	r4,33045
81115c68:	212b0404 	addi	r4,r4,-21488
81115c6c:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return -1;
81115c70:	00bfffc4 	movi	r2,-1
81115c74:	00002d06 	br	81115d2c <main+0x178>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
81115c78:	11180340 	call	81118034 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81115c7c:	11154300 	call	81115430 <bResourcesInitRTOS>
81115c80:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81115c84:	e0bffe17 	ldw	r2,-8(fp)
81115c88:	1000091e 	bne	r2,zero,81115cb0 <main+0xfc>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81115c8c:	d0a06117 	ldw	r2,-32380(gp)
81115c90:	100f883a 	mov	r7,r2
81115c94:	01800ac4 	movi	r6,43
81115c98:	01400044 	movi	r5,1
81115c9c:	01204574 	movhi	r4,33045
81115ca0:	212b1b04 	addi	r4,r4,-21396
81115ca4:	111dcb00 	call	8111dcb0 <fwrite>
		return -1;
81115ca8:	00bfffc4 	movi	r2,-1
81115cac:	00001f06 	br	81115d2c <main+0x178>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81115cb0:	01204574 	movhi	r4,33045
81115cb4:	21154904 	addi	r4,r4,21796
81115cb8:	111b01c0 	call	8111b01c <vSimucamStructureInit>

	vVariablesInitialization();
81115cbc:	11158a00 	call	811158a0 <vVariablesInitialization>

	bInitSync();
81115cc0:	111b8100 	call	8111b810 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81115cc4:	01204574 	movhi	r4,33045
81115cc8:	21154904 	addi	r4,r4,21796
81115ccc:	1115d400 	call	81115d40 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81115cd0:	d8000415 	stw	zero,16(sp)
81115cd4:	d8000315 	stw	zero,12(sp)
81115cd8:	00810004 	movi	r2,1024
81115cdc:	d8800215 	stw	r2,8(sp)
81115ce0:	00a045b4 	movhi	r2,33046
81115ce4:	10a46f04 	addi	r2,r2,-28228
81115ce8:	d8800115 	stw	r2,4(sp)
81115cec:	00800044 	movi	r2,1
81115cf0:	d8800015 	stw	r2,0(sp)
81115cf4:	01c00044 	movi	r7,1
81115cf8:	01a045b4 	movhi	r6,33046
81115cfc:	31a86e04 	addi	r6,r6,-24136
81115d00:	000b883a 	mov	r5,zero
81115d04:	01204474 	movhi	r4,33041
81115d08:	21010504 	addi	r4,r4,1044
81115d0c:	113c45c0 	call	8113c45c <OSTaskCreateExt>
81115d10:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81115d14:	e0bfff03 	ldbu	r2,-4(fp)
81115d18:	1000021e 	bne	r2,zero,81115d24 <main+0x170>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81115d1c:	11359dc0 	call	811359dc <OSStart>
81115d20:	00000106 	br	81115d28 <main+0x174>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81115d24:	1118a980 	call	81118a98 <vFailInitialization>
	}
  
	return 0;
81115d28:	0005883a 	mov	r2,zero
}
81115d2c:	e037883a 	mov	sp,fp
81115d30:	dfc00117 	ldw	ra,4(sp)
81115d34:	df000017 	ldw	fp,0(sp)
81115d38:	dec00204 	addi	sp,sp,8
81115d3c:	f800283a 	ret

81115d40 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81115d40:	defff604 	addi	sp,sp,-40
81115d44:	de00012e 	bgeu	sp,et,81115d4c <vFillMemmoryPattern+0xc>
81115d48:	003b68fa 	trap	3
81115d4c:	dfc00915 	stw	ra,36(sp)
81115d50:	df000815 	stw	fp,32(sp)
81115d54:	df000804 	addi	fp,sp,32
81115d58:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81115d5c:	00800044 	movi	r2,1
81115d60:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81115d64:	d0a06117 	ldw	r2,-32380(gp)
81115d68:	100f883a 	mov	r7,r2
81115d6c:	018009c4 	movi	r6,39
81115d70:	01400044 	movi	r5,1
81115d74:	01204574 	movhi	r4,33045
81115d78:	212b2604 	addi	r4,r4,-21352
81115d7c:	111dcb00 	call	8111dcb0 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81115d80:	e03ffa05 	stb	zero,-24(fp)
81115d84:	00007606 	br	81115f60 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81115d88:	e03ffc85 	stb	zero,-14(fp)
81115d8c:	00006706 	br	81115f2c <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81115d90:	e0bffc83 	ldbu	r2,-14(fp)
81115d94:	e0ffff17 	ldw	r3,-4(fp)
81115d98:	10809624 	muli	r2,r2,600
81115d9c:	1885883a 	add	r2,r3,r2
81115da0:	10804304 	addi	r2,r2,268
81115da4:	1080000b 	ldhu	r2,0(r2)
81115da8:	10ffffcc 	andi	r3,r2,65535
81115dac:	e0bffc83 	ldbu	r2,-14(fp)
81115db0:	e13fff17 	ldw	r4,-4(fp)
81115db4:	10809624 	muli	r2,r2,600
81115db8:	2085883a 	add	r2,r4,r2
81115dbc:	10804204 	addi	r2,r2,264
81115dc0:	1080000b 	ldhu	r2,0(r2)
81115dc4:	10bfffcc 	andi	r2,r2,65535
81115dc8:	1885883a 	add	r2,r3,r2
81115dcc:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81115dd0:	e0bffc83 	ldbu	r2,-14(fp)
81115dd4:	e0ffff17 	ldw	r3,-4(fp)
81115dd8:	10809624 	muli	r2,r2,600
81115ddc:	1885883a 	add	r2,r3,r2
81115de0:	10804284 	addi	r2,r2,266
81115de4:	1080000b 	ldhu	r2,0(r2)
81115de8:	10ffffcc 	andi	r3,r2,65535
81115dec:	e0bffc83 	ldbu	r2,-14(fp)
81115df0:	e13fff17 	ldw	r4,-4(fp)
81115df4:	10809624 	muli	r2,r2,600
81115df8:	2085883a 	add	r2,r4,r2
81115dfc:	10804184 	addi	r2,r2,262
81115e00:	1080000b 	ldhu	r2,0(r2)
81115e04:	10bfffcc 	andi	r2,r2,65535
81115e08:	1887883a 	add	r3,r3,r2
81115e0c:	e0bffc83 	ldbu	r2,-14(fp)
81115e10:	e13fff17 	ldw	r4,-4(fp)
81115e14:	10809624 	muli	r2,r2,600
81115e18:	2085883a 	add	r2,r4,r2
81115e1c:	10804104 	addi	r2,r2,260
81115e20:	1080000b 	ldhu	r2,0(r2)
81115e24:	10bfffcc 	andi	r2,r2,65535
81115e28:	1885883a 	add	r2,r3,r2
81115e2c:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81115e30:	e03ffc05 	stb	zero,-16(fp)
81115e34:	00003706 	br	81115f14 <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81115e38:	e03ffc45 	stb	zero,-15(fp)
81115e3c:	00002606 	br	81115ed8 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
81115e40:	e0bffc43 	ldbu	r2,-15(fp)
81115e44:	10000b1e 	bne	r2,zero,81115e74 <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81115e48:	e0bffc83 	ldbu	r2,-14(fp)
81115e4c:	e13ffc03 	ldbu	r4,-16(fp)
81115e50:	e0ffff17 	ldw	r3,-4(fp)
81115e54:	21000624 	muli	r4,r4,24
81115e58:	10809624 	muli	r2,r2,600
81115e5c:	2085883a 	add	r2,r4,r2
81115e60:	1885883a 	add	r2,r3,r2
81115e64:	10801b04 	addi	r2,r2,108
81115e68:	10800017 	ldw	r2,0(r2)
81115e6c:	e0bffb15 	stw	r2,-20(fp)
81115e70:	00000a06 	br	81115e9c <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81115e74:	e0bffc83 	ldbu	r2,-14(fp)
81115e78:	e13ffc03 	ldbu	r4,-16(fp)
81115e7c:	e0ffff17 	ldw	r3,-4(fp)
81115e80:	21000624 	muli	r4,r4,24
81115e84:	10809624 	muli	r2,r2,600
81115e88:	2085883a 	add	r2,r4,r2
81115e8c:	1885883a 	add	r2,r3,r2
81115e90:	10801e04 	addi	r2,r2,120
81115e94:	10800017 	ldw	r2,0(r2)
81115e98:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81115e9c:	e0fffa03 	ldbu	r3,-24(fp)
81115ea0:	e13ffc03 	ldbu	r4,-16(fp)
81115ea4:	e17ffc43 	ldbu	r5,-15(fp)
81115ea8:	e0bffd17 	ldw	r2,-12(fp)
81115eac:	d8800115 	stw	r2,4(sp)
81115eb0:	e0bffe17 	ldw	r2,-8(fp)
81115eb4:	d8800015 	stw	r2,0(sp)
81115eb8:	280f883a 	mov	r7,r5
81115ebc:	200d883a 	mov	r6,r4
81115ec0:	e17ffb17 	ldw	r5,-20(fp)
81115ec4:	1809883a 	mov	r4,r3
81115ec8:	111b3e00 	call	8111b3e0 <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81115ecc:	e0bffc43 	ldbu	r2,-15(fp)
81115ed0:	10800044 	addi	r2,r2,1
81115ed4:	e0bffc45 	stb	r2,-15(fp)
81115ed8:	e0bffc43 	ldbu	r2,-15(fp)
81115edc:	108000b0 	cmpltui	r2,r2,2
81115ee0:	103fd71e 	bne	r2,zero,81115e40 <__reset+0xfb0f5e40>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81115ee4:	d0a06117 	ldw	r2,-32380(gp)
81115ee8:	e0fffc83 	ldbu	r3,-14(fp)
81115eec:	e13ffc03 	ldbu	r4,-16(fp)
81115ef0:	200f883a 	mov	r7,r4
81115ef4:	180d883a 	mov	r6,r3
81115ef8:	01604574 	movhi	r5,33045
81115efc:	296b3004 	addi	r5,r5,-21312
81115f00:	1009883a 	mov	r4,r2
81115f04:	111d6140 	call	8111d614 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81115f08:	e0bffc03 	ldbu	r2,-16(fp)
81115f0c:	10800044 	addi	r2,r2,1
81115f10:	e0bffc05 	stb	r2,-16(fp)
81115f14:	e0bffc03 	ldbu	r2,-16(fp)
81115f18:	10800130 	cmpltui	r2,r2,4
81115f1c:	103fc61e 	bne	r2,zero,81115e38 <__reset+0xfb0f5e38>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81115f20:	e0bffc83 	ldbu	r2,-14(fp)
81115f24:	10800044 	addi	r2,r2,1
81115f28:	e0bffc85 	stb	r2,-14(fp)
81115f2c:	e0fffc83 	ldbu	r3,-14(fp)
81115f30:	e0bffcc3 	ldbu	r2,-13(fp)
81115f34:	18bf9636 	bltu	r3,r2,81115d90 <__reset+0xfb0f5d90>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81115f38:	d0a06117 	ldw	r2,-32380(gp)
81115f3c:	e0fffa03 	ldbu	r3,-24(fp)
81115f40:	180d883a 	mov	r6,r3
81115f44:	01604574 	movhi	r5,33045
81115f48:	296b3504 	addi	r5,r5,-21292
81115f4c:	1009883a 	mov	r4,r2
81115f50:	111d6140 	call	8111d614 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81115f54:	e0bffa03 	ldbu	r2,-24(fp)
81115f58:	10800044 	addi	r2,r2,1
81115f5c:	e0bffa05 	stb	r2,-24(fp)
81115f60:	e0bffa03 	ldbu	r2,-24(fp)
81115f64:	108000b0 	cmpltui	r2,r2,2
81115f68:	103f871e 	bne	r2,zero,81115d88 <__reset+0xfb0f5d88>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81115f6c:	d0a06117 	ldw	r2,-32380(gp)
81115f70:	100f883a 	mov	r7,r2
81115f74:	01800404 	movi	r6,16
81115f78:	01400044 	movi	r5,1
81115f7c:	01204574 	movhi	r4,33045
81115f80:	212b3904 	addi	r4,r4,-21276
81115f84:	111dcb00 	call	8111dcb0 <fwrite>
#endif


}
81115f88:	0001883a 	nop
81115f8c:	e037883a 	mov	sp,fp
81115f90:	dfc00117 	ldw	ra,4(sp)
81115f94:	df000017 	ldw	fp,0(sp)
81115f98:	dec00204 	addi	sp,sp,8
81115f9c:	f800283a 	ret

81115fa0 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81115fa0:	defff604 	addi	sp,sp,-40
81115fa4:	de00012e 	bgeu	sp,et,81115fac <vPrintMemmoryPattern+0xc>
81115fa8:	003b68fa 	trap	3
81115fac:	dfc00915 	stw	ra,36(sp)
81115fb0:	df000815 	stw	fp,32(sp)
81115fb4:	df000804 	addi	fp,sp,32
81115fb8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81115fbc:	00800044 	movi	r2,1
81115fc0:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81115fc4:	d0a06117 	ldw	r2,-32380(gp)
81115fc8:	100f883a 	mov	r7,r2
81115fcc:	018009c4 	movi	r6,39
81115fd0:	01400044 	movi	r5,1
81115fd4:	01204574 	movhi	r4,33045
81115fd8:	212b2604 	addi	r4,r4,-21352
81115fdc:	111dcb00 	call	8111dcb0 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81115fe0:	e03ffa05 	stb	zero,-24(fp)
81115fe4:	00007606 	br	811161c0 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81115fe8:	e03ffc85 	stb	zero,-14(fp)
81115fec:	00006706 	br	8111618c <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81115ff0:	e0bffc83 	ldbu	r2,-14(fp)
81115ff4:	e0ffff17 	ldw	r3,-4(fp)
81115ff8:	10809624 	muli	r2,r2,600
81115ffc:	1885883a 	add	r2,r3,r2
81116000:	10804304 	addi	r2,r2,268
81116004:	1080000b 	ldhu	r2,0(r2)
81116008:	10ffffcc 	andi	r3,r2,65535
8111600c:	e0bffc83 	ldbu	r2,-14(fp)
81116010:	e13fff17 	ldw	r4,-4(fp)
81116014:	10809624 	muli	r2,r2,600
81116018:	2085883a 	add	r2,r4,r2
8111601c:	10804204 	addi	r2,r2,264
81116020:	1080000b 	ldhu	r2,0(r2)
81116024:	10bfffcc 	andi	r2,r2,65535
81116028:	1885883a 	add	r2,r3,r2
8111602c:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81116030:	e0bffc83 	ldbu	r2,-14(fp)
81116034:	e0ffff17 	ldw	r3,-4(fp)
81116038:	10809624 	muli	r2,r2,600
8111603c:	1885883a 	add	r2,r3,r2
81116040:	10804284 	addi	r2,r2,266
81116044:	1080000b 	ldhu	r2,0(r2)
81116048:	10ffffcc 	andi	r3,r2,65535
8111604c:	e0bffc83 	ldbu	r2,-14(fp)
81116050:	e13fff17 	ldw	r4,-4(fp)
81116054:	10809624 	muli	r2,r2,600
81116058:	2085883a 	add	r2,r4,r2
8111605c:	10804184 	addi	r2,r2,262
81116060:	1080000b 	ldhu	r2,0(r2)
81116064:	10bfffcc 	andi	r2,r2,65535
81116068:	1887883a 	add	r3,r3,r2
8111606c:	e0bffc83 	ldbu	r2,-14(fp)
81116070:	e13fff17 	ldw	r4,-4(fp)
81116074:	10809624 	muli	r2,r2,600
81116078:	2085883a 	add	r2,r4,r2
8111607c:	10804104 	addi	r2,r2,260
81116080:	1080000b 	ldhu	r2,0(r2)
81116084:	10bfffcc 	andi	r2,r2,65535
81116088:	1885883a 	add	r2,r3,r2
8111608c:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81116090:	e03ffc05 	stb	zero,-16(fp)
81116094:	00003706 	br	81116174 <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81116098:	e03ffc45 	stb	zero,-15(fp)
8111609c:	00002606 	br	81116138 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
811160a0:	e0bffc43 	ldbu	r2,-15(fp)
811160a4:	10000b1e 	bne	r2,zero,811160d4 <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
811160a8:	e0bffc83 	ldbu	r2,-14(fp)
811160ac:	e13ffc03 	ldbu	r4,-16(fp)
811160b0:	e0ffff17 	ldw	r3,-4(fp)
811160b4:	21000624 	muli	r4,r4,24
811160b8:	10809624 	muli	r2,r2,600
811160bc:	2085883a 	add	r2,r4,r2
811160c0:	1885883a 	add	r2,r3,r2
811160c4:	10801b04 	addi	r2,r2,108
811160c8:	10800017 	ldw	r2,0(r2)
811160cc:	e0bffb15 	stw	r2,-20(fp)
811160d0:	00000a06 	br	811160fc <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
811160d4:	e0bffc83 	ldbu	r2,-14(fp)
811160d8:	e13ffc03 	ldbu	r4,-16(fp)
811160dc:	e0ffff17 	ldw	r3,-4(fp)
811160e0:	21000624 	muli	r4,r4,24
811160e4:	10809624 	muli	r2,r2,600
811160e8:	2085883a 	add	r2,r4,r2
811160ec:	1885883a 	add	r2,r3,r2
811160f0:	10801e04 	addi	r2,r2,120
811160f4:	10800017 	ldw	r2,0(r2)
811160f8:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811160fc:	e0fffa03 	ldbu	r3,-24(fp)
81116100:	e13ffc03 	ldbu	r4,-16(fp)
81116104:	e17ffc43 	ldbu	r5,-15(fp)
81116108:	e0bffe17 	ldw	r2,-8(fp)
8111610c:	d8800115 	stw	r2,4(sp)
81116110:	e0bffd17 	ldw	r2,-12(fp)
81116114:	d8800015 	stw	r2,0(sp)
81116118:	280f883a 	mov	r7,r5
8111611c:	200d883a 	mov	r6,r4
81116120:	e17ffb17 	ldw	r5,-20(fp)
81116124:	1809883a 	mov	r4,r3
81116128:	111b3e00 	call	8111b3e0 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111612c:	e0bffc43 	ldbu	r2,-15(fp)
81116130:	10800044 	addi	r2,r2,1
81116134:	e0bffc45 	stb	r2,-15(fp)
81116138:	e0bffc43 	ldbu	r2,-15(fp)
8111613c:	108000b0 	cmpltui	r2,r2,2
81116140:	103fd71e 	bne	r2,zero,811160a0 <__reset+0xfb0f60a0>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81116144:	d0a06117 	ldw	r2,-32380(gp)
81116148:	e0fffc83 	ldbu	r3,-14(fp)
8111614c:	e13ffc03 	ldbu	r4,-16(fp)
81116150:	200f883a 	mov	r7,r4
81116154:	180d883a 	mov	r6,r3
81116158:	01604574 	movhi	r5,33045
8111615c:	296b3004 	addi	r5,r5,-21312
81116160:	1009883a 	mov	r4,r2
81116164:	111d6140 	call	8111d614 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81116168:	e0bffc03 	ldbu	r2,-16(fp)
8111616c:	10800044 	addi	r2,r2,1
81116170:	e0bffc05 	stb	r2,-16(fp)
81116174:	e0bffc03 	ldbu	r2,-16(fp)
81116178:	10800130 	cmpltui	r2,r2,4
8111617c:	103fc61e 	bne	r2,zero,81116098 <__reset+0xfb0f6098>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81116180:	e0bffc83 	ldbu	r2,-14(fp)
81116184:	10800044 	addi	r2,r2,1
81116188:	e0bffc85 	stb	r2,-14(fp)
8111618c:	e0fffc83 	ldbu	r3,-14(fp)
81116190:	e0bffcc3 	ldbu	r2,-13(fp)
81116194:	18bf9636 	bltu	r3,r2,81115ff0 <__reset+0xfb0f5ff0>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81116198:	d0a06117 	ldw	r2,-32380(gp)
8111619c:	e0fffa03 	ldbu	r3,-24(fp)
811161a0:	180d883a 	mov	r6,r3
811161a4:	01604574 	movhi	r5,33045
811161a8:	296b3504 	addi	r5,r5,-21292
811161ac:	1009883a 	mov	r4,r2
811161b0:	111d6140 	call	8111d614 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811161b4:	e0bffa03 	ldbu	r2,-24(fp)
811161b8:	10800044 	addi	r2,r2,1
811161bc:	e0bffa05 	stb	r2,-24(fp)
811161c0:	e0bffa03 	ldbu	r2,-24(fp)
811161c4:	108000b0 	cmpltui	r2,r2,2
811161c8:	103f871e 	bne	r2,zero,81115fe8 <__reset+0xfb0f5fe8>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
811161cc:	d0a06117 	ldw	r2,-32380(gp)
811161d0:	100f883a 	mov	r7,r2
811161d4:	01800404 	movi	r6,16
811161d8:	01400044 	movi	r5,1
811161dc:	01204574 	movhi	r4,33045
811161e0:	212b3904 	addi	r4,r4,-21276
811161e4:	111dcb00 	call	8111dcb0 <fwrite>
#endif


}
811161e8:	0001883a 	nop
811161ec:	e037883a 	mov	sp,fp
811161f0:	dfc00117 	ldw	ra,4(sp)
811161f4:	df000017 	ldw	fp,0(sp)
811161f8:	dec00204 	addi	sp,sp,8
811161fc:	f800283a 	ret

81116200 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81116200:	defffe04 	addi	sp,sp,-8
81116204:	de00012e 	bgeu	sp,et,8111620c <vCCDLoadDefaultValues+0xc>
81116208:	003b68fa 	trap	3
8111620c:	df000115 	stw	fp,4(sp)
81116210:	df000104 	addi	fp,sp,4
81116214:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
81116218:	e0bfff17 	ldw	r2,-4(fp)
8111621c:	00c46784 	movi	r3,4510
81116220:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
81116224:	e0bfff17 	ldw	r2,-4(fp)
81116228:	00c00784 	movi	r3,30
8111622c:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
81116230:	e0bfff17 	ldw	r2,-4(fp)
81116234:	00c233c4 	movi	r3,2255
81116238:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
8111623c:	e0bfff17 	ldw	r2,-4(fp)
81116240:	00c003c4 	movi	r3,15
81116244:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
81116248:	e0bfff17 	ldw	r2,-4(fp)
8111624c:	00c00644 	movi	r3,25
81116250:	10c0000d 	sth	r3,0(r2)
}
81116254:	0001883a 	nop
81116258:	e037883a 	mov	sp,fp
8111625c:	df000017 	ldw	fp,0(sp)
81116260:	dec00104 	addi	sp,sp,4
81116264:	f800283a 	ret

81116268 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81116268:	defff904 	addi	sp,sp,-28
8111626c:	de00012e 	bgeu	sp,et,81116274 <vCCDChangeValues+0xc>
81116270:	003b68fa 	trap	3
81116274:	df000615 	stw	fp,24(sp)
81116278:	df000604 	addi	fp,sp,24
8111627c:	e13ffa15 	stw	r4,-24(fp)
81116280:	2811883a 	mov	r8,r5
81116284:	300b883a 	mov	r5,r6
81116288:	3809883a 	mov	r4,r7
8111628c:	e0c00117 	ldw	r3,4(fp)
81116290:	e0800217 	ldw	r2,8(fp)
81116294:	e23ffb0d 	sth	r8,-20(fp)
81116298:	e17ffc0d 	sth	r5,-16(fp)
8111629c:	e13ffd0d 	sth	r4,-12(fp)
811162a0:	e0fffe0d 	sth	r3,-8(fp)
811162a4:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
811162a8:	e0bffa17 	ldw	r2,-24(fp)
811162ac:	e0fffb0b 	ldhu	r3,-20(fp)
811162b0:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
811162b4:	e0bffa17 	ldw	r2,-24(fp)
811162b8:	e0fffc0b 	ldhu	r3,-16(fp)
811162bc:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
811162c0:	e0bffa17 	ldw	r2,-24(fp)
811162c4:	e0fffd0b 	ldhu	r3,-12(fp)
811162c8:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
811162cc:	e0bffa17 	ldw	r2,-24(fp)
811162d0:	e0fffe0b 	ldhu	r3,-8(fp)
811162d4:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
811162d8:	e0bffa17 	ldw	r2,-24(fp)
811162dc:	e0ffff0b 	ldhu	r3,-4(fp)
811162e0:	10c0000d 	sth	r3,0(r2)
}
811162e4:	0001883a 	nop
811162e8:	e037883a 	mov	sp,fp
811162ec:	df000017 	ldw	fp,0(sp)
811162f0:	dec00104 	addi	sp,sp,4
811162f4:	f800283a 	ret

811162f8 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
811162f8:	defff904 	addi	sp,sp,-28
811162fc:	de00012e 	bgeu	sp,et,81116304 <bSendUART128v2+0xc>
81116300:	003b68fa 	trap	3
81116304:	dfc00615 	stw	ra,24(sp)
81116308:	df000515 	stw	fp,20(sp)
8111630c:	df000504 	addi	fp,sp,20
81116310:	e13ffe15 	stw	r4,-8(fp)
81116314:	2805883a 	mov	r2,r5
81116318:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
8111631c:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81116320:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81116324:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81116328:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8111632c:	d0a06217 	ldw	r2,-32376(gp)
81116330:	e0fffd04 	addi	r3,fp,-12
81116334:	180d883a 	mov	r6,r3
81116338:	01400504 	movi	r5,20
8111633c:	1009883a 	mov	r4,r2
81116340:	113b6f00 	call	8113b6f0 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81116344:	e0bffd03 	ldbu	r2,-12(fp)
81116348:	10803fcc 	andi	r2,r2,255
8111634c:	10000326 	beq	r2,zero,8111635c <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81116350:	1118d000 	call	81118d00 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81116354:	e0bffc17 	ldw	r2,-16(fp)
81116358:	00009e06 	br	811165d4 <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8111635c:	d0a06d17 	ldw	r2,-32332(gp)
81116360:	e0fffd04 	addi	r3,fp,-12
81116364:	180d883a 	mov	r6,r3
81116368:	01400104 	movi	r5,4
8111636c:	1009883a 	mov	r4,r2
81116370:	11396e40 	call	811396e4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81116374:	e0bffd03 	ldbu	r2,-12(fp)
81116378:	10803fcc 	andi	r2,r2,255
8111637c:	10001126 	beq	r2,zero,811163c4 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81116380:	d0a06117 	ldw	r2,-32380(gp)
81116384:	100f883a 	mov	r7,r2
81116388:	01801484 	movi	r6,82
8111638c:	01400044 	movi	r5,1
81116390:	01204574 	movhi	r4,33045
81116394:	212b3e04 	addi	r4,r4,-21256
81116398:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
8111639c:	d0a06217 	ldw	r2,-32376(gp)
811163a0:	1009883a 	mov	r4,r2
811163a4:	113ba780 	call	8113ba78 <OSSemPost>
811163a8:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811163ac:	e0bffd03 	ldbu	r2,-12(fp)
811163b0:	10803fcc 	andi	r2,r2,255
811163b4:	10000126 	beq	r2,zero,811163bc <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811163b8:	1118c980 	call	81118c98 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
811163bc:	e0bffc17 	ldw	r2,-16(fp)
811163c0:	00008406 	br	811165d4 <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
811163c4:	e03ffb05 	stb	zero,-20(fp)
811163c8:	00004306 	br	811164d8 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
811163cc:	e0fffb03 	ldbu	r3,-20(fp)
811163d0:	00a045b4 	movhi	r2,33046
811163d4:	10ac7704 	addi	r2,r2,-20004
811163d8:	18c7883a 	add	r3,r3,r3
811163dc:	18c7883a 	add	r3,r3,r3
811163e0:	10c5883a 	add	r2,r2,r3
811163e4:	10800017 	ldw	r2,0(r2)
811163e8:	1000381e 	bne	r2,zero,811164cc <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
811163ec:	e0bffb03 	ldbu	r2,-20(fp)
811163f0:	10c02324 	muli	r3,r2,140
811163f4:	00a045b4 	movhi	r2,33046
811163f8:	10ac9504 	addi	r2,r2,-19884
811163fc:	1885883a 	add	r2,r3,r2
81116400:	01802004 	movi	r6,128
81116404:	000b883a 	mov	r5,zero
81116408:	1009883a 	mov	r4,r2
8111640c:	111e8140 	call	8111e814 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81116410:	e0bffb03 	ldbu	r2,-20(fp)
81116414:	10c02324 	muli	r3,r2,140
81116418:	00a045b4 	movhi	r2,33046
8111641c:	10ac9504 	addi	r2,r2,-19884
81116420:	1885883a 	add	r2,r3,r2
81116424:	01801fc4 	movi	r6,127
81116428:	e17ffe17 	ldw	r5,-8(fp)
8111642c:	1009883a 	mov	r4,r2
81116430:	111e6c40 	call	8111e6c4 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81116434:	e13ffb03 	ldbu	r4,-20(fp)
81116438:	e0ffff0b 	ldhu	r3,-4(fp)
8111643c:	00a045b4 	movhi	r2,33046
81116440:	10ac9504 	addi	r2,r2,-19884
81116444:	21002324 	muli	r4,r4,140
81116448:	1105883a 	add	r2,r2,r4
8111644c:	10802104 	addi	r2,r2,132
81116450:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81116454:	e0fffb03 	ldbu	r3,-20(fp)
81116458:	00a045b4 	movhi	r2,33046
8111645c:	10ac9504 	addi	r2,r2,-19884
81116460:	18c02324 	muli	r3,r3,140
81116464:	10c5883a 	add	r2,r2,r3
81116468:	10802204 	addi	r2,r2,136
8111646c:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81116470:	e0fffb03 	ldbu	r3,-20(fp)
81116474:	00a045b4 	movhi	r2,33046
81116478:	10ac9504 	addi	r2,r2,-19884
8111647c:	18c02324 	muli	r3,r3,140
81116480:	10c5883a 	add	r2,r2,r3
81116484:	10802184 	addi	r2,r2,134
81116488:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
8111648c:	e0fffb03 	ldbu	r3,-20(fp)
81116490:	00a045b4 	movhi	r2,33046
81116494:	10ac9504 	addi	r2,r2,-19884
81116498:	18c02324 	muli	r3,r3,140
8111649c:	10c5883a 	add	r2,r2,r3
811164a0:	10802004 	addi	r2,r2,128
811164a4:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
811164a8:	e0fffb03 	ldbu	r3,-20(fp)
811164ac:	00a045b4 	movhi	r2,33046
811164b0:	10ac7704 	addi	r2,r2,-20004
811164b4:	18c7883a 	add	r3,r3,r3
811164b8:	18c7883a 	add	r3,r3,r3
811164bc:	10c5883a 	add	r2,r2,r3
811164c0:	00c00044 	movi	r3,1
811164c4:	10c00015 	stw	r3,0(r2)
			break;
811164c8:	00000606 	br	811164e4 <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
811164cc:	e0bffb03 	ldbu	r2,-20(fp)
811164d0:	10800044 	addi	r2,r2,1
811164d4:	e0bffb05 	stb	r2,-20(fp)
811164d8:	e0bffb03 	ldbu	r2,-20(fp)
811164dc:	108001b0 	cmpltui	r2,r2,6
811164e0:	103fba1e 	bne	r2,zero,811163cc <__reset+0xfb0f63cc>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
811164e4:	e0bffb03 	ldbu	r2,-20(fp)
811164e8:	108001b0 	cmpltui	r2,r2,6
811164ec:	1000091e 	bne	r2,zero,81116514 <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811164f0:	d0a06217 	ldw	r2,-32376(gp)
811164f4:	1009883a 	mov	r4,r2
811164f8:	113ba780 	call	8113ba78 <OSSemPost>
811164fc:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81116500:	d0a06d17 	ldw	r2,-32332(gp)
81116504:	1009883a 	mov	r4,r2
81116508:	1139c880 	call	81139c88 <OSMutexPost>
		return bSuccessL;
8111650c:	e0bffc17 	ldw	r2,-16(fp)
81116510:	00003006 	br	811165d4 <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
81116514:	00800044 	movi	r2,1
81116518:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
8111651c:	d0a07443 	ldbu	r2,-32303(gp)
81116520:	10bfffc4 	addi	r2,r2,-1
81116524:	d0a07445 	stb	r2,-32303(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81116528:	d0a07317 	ldw	r2,-32308(gp)
8111652c:	e0fffd04 	addi	r3,fp,-12
81116530:	180d883a 	mov	r6,r3
81116534:	01400084 	movi	r5,2
81116538:	1009883a 	mov	r4,r2
8111653c:	11396e40 	call	811396e4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81116540:	e0bffd03 	ldbu	r2,-12(fp)
81116544:	10803fcc 	andi	r2,r2,255
81116548:	10000c26 	beq	r2,zero,8111657c <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
8111654c:	d0a06117 	ldw	r2,-32380(gp)
81116550:	100f883a 	mov	r7,r2
81116554:	01801c04 	movi	r6,112
81116558:	01400044 	movi	r5,1
8111655c:	01204574 	movhi	r4,33045
81116560:	212b5304 	addi	r4,r4,-21172
81116564:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81116568:	d0a06d17 	ldw	r2,-32332(gp)
8111656c:	1009883a 	mov	r4,r2
81116570:	1139c880 	call	81139c88 <OSMutexPost>
		return bSuccessL;
81116574:	e0bffc17 	ldw	r2,-16(fp)
81116578:	00001606 	br	811165d4 <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
8111657c:	e0bffb03 	ldbu	r2,-20(fp)
81116580:	10c02324 	muli	r3,r2,140
81116584:	00a045b4 	movhi	r2,33046
81116588:	10ac9504 	addi	r2,r2,-19884
8111658c:	1885883a 	add	r2,r3,r2
81116590:	1009883a 	mov	r4,r2
81116594:	111ec600 	call	8111ec60 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81116598:	e0fffb03 	ldbu	r3,-20(fp)
8111659c:	00a045b4 	movhi	r2,33046
811165a0:	10ac9504 	addi	r2,r2,-19884
811165a4:	18c02324 	muli	r3,r3,140
811165a8:	10c5883a 	add	r2,r2,r3
811165ac:	10802004 	addi	r2,r2,128
811165b0:	00c00044 	movi	r3,1
811165b4:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
811165b8:	d0a07317 	ldw	r2,-32308(gp)
811165bc:	1009883a 	mov	r4,r2
811165c0:	1139c880 	call	81139c88 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
811165c4:	d0a06d17 	ldw	r2,-32332(gp)
811165c8:	1009883a 	mov	r4,r2
811165cc:	1139c880 	call	81139c88 <OSMutexPost>

	return bSuccessL;
811165d0:	e0bffc17 	ldw	r2,-16(fp)
}
811165d4:	e037883a 	mov	sp,fp
811165d8:	dfc00117 	ldw	ra,4(sp)
811165dc:	df000017 	ldw	fp,0(sp)
811165e0:	dec00204 	addi	sp,sp,8
811165e4:	f800283a 	ret

811165e8 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
811165e8:	defff904 	addi	sp,sp,-28
811165ec:	de00012e 	bgeu	sp,et,811165f4 <bSendUART64v2+0xc>
811165f0:	003b68fa 	trap	3
811165f4:	dfc00615 	stw	ra,24(sp)
811165f8:	df000515 	stw	fp,20(sp)
811165fc:	df000504 	addi	fp,sp,20
81116600:	e13ffe15 	stw	r4,-8(fp)
81116604:	2805883a 	mov	r2,r5
81116608:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8111660c:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81116610:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81116614:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81116618:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8111661c:	d0a05d17 	ldw	r2,-32396(gp)
81116620:	e0fffd04 	addi	r3,fp,-12
81116624:	180d883a 	mov	r6,r3
81116628:	01400504 	movi	r5,20
8111662c:	1009883a 	mov	r4,r2
81116630:	113b6f00 	call	8113b6f0 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81116634:	e0bffd03 	ldbu	r2,-12(fp)
81116638:	10803fcc 	andi	r2,r2,255
8111663c:	10000326 	beq	r2,zero,8111664c <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81116640:	1118d680 	call	81118d68 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81116644:	e0bffc17 	ldw	r2,-16(fp)
81116648:	0000a006 	br	811168cc <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8111664c:	d0a07017 	ldw	r2,-32320(gp)
81116650:	e0fffd04 	addi	r3,fp,-12
81116654:	180d883a 	mov	r6,r3
81116658:	01400104 	movi	r5,4
8111665c:	1009883a 	mov	r4,r2
81116660:	11396e40 	call	811396e4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81116664:	e0bffd03 	ldbu	r2,-12(fp)
81116668:	10803fcc 	andi	r2,r2,255
8111666c:	10001126 	beq	r2,zero,811166b4 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81116670:	d0a06117 	ldw	r2,-32380(gp)
81116674:	100f883a 	mov	r7,r2
81116678:	018013c4 	movi	r6,79
8111667c:	01400044 	movi	r5,1
81116680:	01204574 	movhi	r4,33045
81116684:	212b7004 	addi	r4,r4,-21056
81116688:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8111668c:	d0a05d17 	ldw	r2,-32396(gp)
81116690:	1009883a 	mov	r4,r2
81116694:	113ba780 	call	8113ba78 <OSSemPost>
81116698:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8111669c:	e0bffd03 	ldbu	r2,-12(fp)
811166a0:	10803fcc 	andi	r2,r2,255
811166a4:	10000126 	beq	r2,zero,811166ac <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811166a8:	1118c300 	call	81118c30 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
811166ac:	e0bffc17 	ldw	r2,-16(fp)
811166b0:	00008606 	br	811168cc <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
811166b4:	e03ffb05 	stb	zero,-20(fp)
811166b8:	00004506 	br	811167d0 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
811166bc:	e0fffb03 	ldbu	r3,-20(fp)
811166c0:	00a045b4 	movhi	r2,33046
811166c4:	10ac7704 	addi	r2,r2,-20004
811166c8:	18c00184 	addi	r3,r3,6
811166cc:	18c7883a 	add	r3,r3,r3
811166d0:	18c7883a 	add	r3,r3,r3
811166d4:	10c5883a 	add	r2,r2,r3
811166d8:	10800017 	ldw	r2,0(r2)
811166dc:	1000391e 	bne	r2,zero,811167c4 <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
811166e0:	e0bffb03 	ldbu	r2,-20(fp)
811166e4:	10c01324 	muli	r3,r2,76
811166e8:	00a04574 	movhi	r2,33045
811166ec:	10883b04 	addi	r2,r2,8428
811166f0:	1885883a 	add	r2,r3,r2
811166f4:	01801004 	movi	r6,64
811166f8:	000b883a 	mov	r5,zero
811166fc:	1009883a 	mov	r4,r2
81116700:	111e8140 	call	8111e814 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81116704:	e0bffb03 	ldbu	r2,-20(fp)
81116708:	10c01324 	muli	r3,r2,76
8111670c:	00a04574 	movhi	r2,33045
81116710:	10883b04 	addi	r2,r2,8428
81116714:	1885883a 	add	r2,r3,r2
81116718:	01800fc4 	movi	r6,63
8111671c:	e17ffe17 	ldw	r5,-8(fp)
81116720:	1009883a 	mov	r4,r2
81116724:	111e6c40 	call	8111e6c4 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81116728:	e13ffb03 	ldbu	r4,-20(fp)
8111672c:	e0ffff0b 	ldhu	r3,-4(fp)
81116730:	00a04574 	movhi	r2,33045
81116734:	10883b04 	addi	r2,r2,8428
81116738:	21001324 	muli	r4,r4,76
8111673c:	1105883a 	add	r2,r2,r4
81116740:	10801104 	addi	r2,r2,68
81116744:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81116748:	e0fffb03 	ldbu	r3,-20(fp)
8111674c:	00a04574 	movhi	r2,33045
81116750:	10883b04 	addi	r2,r2,8428
81116754:	18c01324 	muli	r3,r3,76
81116758:	10c5883a 	add	r2,r2,r3
8111675c:	10801204 	addi	r2,r2,72
81116760:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81116764:	e0fffb03 	ldbu	r3,-20(fp)
81116768:	00a04574 	movhi	r2,33045
8111676c:	10883b04 	addi	r2,r2,8428
81116770:	18c01324 	muli	r3,r3,76
81116774:	10c5883a 	add	r2,r2,r3
81116778:	10801184 	addi	r2,r2,70
8111677c:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81116780:	e0fffb03 	ldbu	r3,-20(fp)
81116784:	00a04574 	movhi	r2,33045
81116788:	10883b04 	addi	r2,r2,8428
8111678c:	18c01324 	muli	r3,r3,76
81116790:	10c5883a 	add	r2,r2,r3
81116794:	10801004 	addi	r2,r2,64
81116798:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
8111679c:	e0fffb03 	ldbu	r3,-20(fp)
811167a0:	00a045b4 	movhi	r2,33046
811167a4:	10ac7704 	addi	r2,r2,-20004
811167a8:	18c00184 	addi	r3,r3,6
811167ac:	18c7883a 	add	r3,r3,r3
811167b0:	18c7883a 	add	r3,r3,r3
811167b4:	10c5883a 	add	r2,r2,r3
811167b8:	00c00044 	movi	r3,1
811167bc:	10c00015 	stw	r3,0(r2)
			break;
811167c0:	00000606 	br	811167dc <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
811167c4:	e0bffb03 	ldbu	r2,-20(fp)
811167c8:	10800044 	addi	r2,r2,1
811167cc:	e0bffb05 	stb	r2,-20(fp)
811167d0:	e0bffb03 	ldbu	r2,-20(fp)
811167d4:	10800230 	cmpltui	r2,r2,8
811167d8:	103fb81e 	bne	r2,zero,811166bc <__reset+0xfb0f66bc>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
811167dc:	e0bffb03 	ldbu	r2,-20(fp)
811167e0:	10800230 	cmpltui	r2,r2,8
811167e4:	1000091e 	bne	r2,zero,8111680c <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
811167e8:	d0a05d17 	ldw	r2,-32396(gp)
811167ec:	1009883a 	mov	r4,r2
811167f0:	113ba780 	call	8113ba78 <OSSemPost>
811167f4:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
811167f8:	d0a07017 	ldw	r2,-32320(gp)
811167fc:	1009883a 	mov	r4,r2
81116800:	1139c880 	call	81139c88 <OSMutexPost>
		return bSuccessL;
81116804:	e0bffc17 	ldw	r2,-16(fp)
81116808:	00003006 	br	811168cc <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
8111680c:	00800044 	movi	r2,1
81116810:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81116814:	d0a07403 	ldbu	r2,-32304(gp)
81116818:	10bfffc4 	addi	r2,r2,-1
8111681c:	d0a07405 	stb	r2,-32304(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81116820:	d0a07317 	ldw	r2,-32308(gp)
81116824:	e0fffd04 	addi	r3,fp,-12
81116828:	180d883a 	mov	r6,r3
8111682c:	01400084 	movi	r5,2
81116830:	1009883a 	mov	r4,r2
81116834:	11396e40 	call	811396e4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81116838:	e0bffd03 	ldbu	r2,-12(fp)
8111683c:	10803fcc 	andi	r2,r2,255
81116840:	10000c26 	beq	r2,zero,81116874 <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
81116844:	d0a06117 	ldw	r2,-32380(gp)
81116848:	100f883a 	mov	r7,r2
8111684c:	01801bc4 	movi	r6,111
81116850:	01400044 	movi	r5,1
81116854:	01204574 	movhi	r4,33045
81116858:	212b8404 	addi	r4,r4,-20976
8111685c:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81116860:	d0a07017 	ldw	r2,-32320(gp)
81116864:	1009883a 	mov	r4,r2
81116868:	1139c880 	call	81139c88 <OSMutexPost>
		return bSuccessL;
8111686c:	e0bffc17 	ldw	r2,-16(fp)
81116870:	00001606 	br	811168cc <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81116874:	e0bffb03 	ldbu	r2,-20(fp)
81116878:	10c01324 	muli	r3,r2,76
8111687c:	00a04574 	movhi	r2,33045
81116880:	10883b04 	addi	r2,r2,8428
81116884:	1885883a 	add	r2,r3,r2
81116888:	1009883a 	mov	r4,r2
8111688c:	111ec600 	call	8111ec60 <puts>
	xBuffer64[ucIL].bSent = TRUE;
81116890:	e0fffb03 	ldbu	r3,-20(fp)
81116894:	00a04574 	movhi	r2,33045
81116898:	10883b04 	addi	r2,r2,8428
8111689c:	18c01324 	muli	r3,r3,76
811168a0:	10c5883a 	add	r2,r2,r3
811168a4:	10801004 	addi	r2,r2,64
811168a8:	00c00044 	movi	r3,1
811168ac:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
811168b0:	d0a07317 	ldw	r2,-32308(gp)
811168b4:	1009883a 	mov	r4,r2
811168b8:	1139c880 	call	81139c88 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
811168bc:	d0a07017 	ldw	r2,-32320(gp)
811168c0:	1009883a 	mov	r4,r2
811168c4:	1139c880 	call	81139c88 <OSMutexPost>

	return bSuccessL;
811168c8:	e0bffc17 	ldw	r2,-16(fp)
}
811168cc:	e037883a 	mov	sp,fp
811168d0:	dfc00117 	ldw	ra,4(sp)
811168d4:	df000017 	ldw	fp,0(sp)
811168d8:	dec00204 	addi	sp,sp,8
811168dc:	f800283a 	ret

811168e0 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
811168e0:	defff904 	addi	sp,sp,-28
811168e4:	de00012e 	bgeu	sp,et,811168ec <bSendUART32v2+0xc>
811168e8:	003b68fa 	trap	3
811168ec:	dfc00615 	stw	ra,24(sp)
811168f0:	df000515 	stw	fp,20(sp)
811168f4:	df000504 	addi	fp,sp,20
811168f8:	e13ffe15 	stw	r4,-8(fp)
811168fc:	2805883a 	mov	r2,r5
81116900:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81116904:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81116908:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8111690c:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81116910:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81116914:	d0a06e17 	ldw	r2,-32328(gp)
81116918:	e0fffd04 	addi	r3,fp,-12
8111691c:	180d883a 	mov	r6,r3
81116920:	01400504 	movi	r5,20
81116924:	1009883a 	mov	r4,r2
81116928:	113b6f00 	call	8113b6f0 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8111692c:	e0bffd03 	ldbu	r2,-12(fp)
81116930:	10803fcc 	andi	r2,r2,255
81116934:	10000326 	beq	r2,zero,81116944 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81116938:	1118dd00 	call	81118dd0 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
8111693c:	e0bffc17 	ldw	r2,-16(fp)
81116940:	0000a006 	br	81116bc4 <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81116944:	d0a06b17 	ldw	r2,-32340(gp)
81116948:	e0fffd04 	addi	r3,fp,-12
8111694c:	180d883a 	mov	r6,r3
81116950:	01400104 	movi	r5,4
81116954:	1009883a 	mov	r4,r2
81116958:	11396e40 	call	811396e4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111695c:	e0bffd03 	ldbu	r2,-12(fp)
81116960:	10803fcc 	andi	r2,r2,255
81116964:	10001126 	beq	r2,zero,811169ac <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81116968:	d0a06117 	ldw	r2,-32380(gp)
8111696c:	100f883a 	mov	r7,r2
81116970:	018013c4 	movi	r6,79
81116974:	01400044 	movi	r5,1
81116978:	01204574 	movhi	r4,33045
8111697c:	212ba004 	addi	r4,r4,-20864
81116980:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81116984:	d0a06e17 	ldw	r2,-32328(gp)
81116988:	1009883a 	mov	r4,r2
8111698c:	113ba780 	call	8113ba78 <OSSemPost>
81116990:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81116994:	e0bffd03 	ldbu	r2,-12(fp)
81116998:	10803fcc 	andi	r2,r2,255
8111699c:	10000126 	beq	r2,zero,811169a4 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811169a0:	1118bc80 	call	81118bc8 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
811169a4:	e0bffc17 	ldw	r2,-16(fp)
811169a8:	00008606 	br	81116bc4 <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
811169ac:	e03ffb05 	stb	zero,-20(fp)
811169b0:	00004506 	br	81116ac8 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
811169b4:	e0fffb03 	ldbu	r3,-20(fp)
811169b8:	00a045b4 	movhi	r2,33046
811169bc:	10ac7704 	addi	r2,r2,-20004
811169c0:	18c00384 	addi	r3,r3,14
811169c4:	18c7883a 	add	r3,r3,r3
811169c8:	18c7883a 	add	r3,r3,r3
811169cc:	10c5883a 	add	r2,r2,r3
811169d0:	10800017 	ldw	r2,0(r2)
811169d4:	1000391e 	bne	r2,zero,81116abc <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
811169d8:	e0bffb03 	ldbu	r2,-20(fp)
811169dc:	10c00b24 	muli	r3,r2,44
811169e0:	00a04574 	movhi	r2,33045
811169e4:	1099f704 	addi	r2,r2,26588
811169e8:	1885883a 	add	r2,r3,r2
811169ec:	01800804 	movi	r6,32
811169f0:	000b883a 	mov	r5,zero
811169f4:	1009883a 	mov	r4,r2
811169f8:	111e8140 	call	8111e814 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
811169fc:	e0bffb03 	ldbu	r2,-20(fp)
81116a00:	10c00b24 	muli	r3,r2,44
81116a04:	00a04574 	movhi	r2,33045
81116a08:	1099f704 	addi	r2,r2,26588
81116a0c:	1885883a 	add	r2,r3,r2
81116a10:	018007c4 	movi	r6,31
81116a14:	e17ffe17 	ldw	r5,-8(fp)
81116a18:	1009883a 	mov	r4,r2
81116a1c:	111e6c40 	call	8111e6c4 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81116a20:	e13ffb03 	ldbu	r4,-20(fp)
81116a24:	e0ffff0b 	ldhu	r3,-4(fp)
81116a28:	00a04574 	movhi	r2,33045
81116a2c:	1099f704 	addi	r2,r2,26588
81116a30:	21000b24 	muli	r4,r4,44
81116a34:	1105883a 	add	r2,r2,r4
81116a38:	10800904 	addi	r2,r2,36
81116a3c:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81116a40:	e0fffb03 	ldbu	r3,-20(fp)
81116a44:	00a04574 	movhi	r2,33045
81116a48:	1099f704 	addi	r2,r2,26588
81116a4c:	18c00b24 	muli	r3,r3,44
81116a50:	10c5883a 	add	r2,r2,r3
81116a54:	10800a04 	addi	r2,r2,40
81116a58:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81116a5c:	e0fffb03 	ldbu	r3,-20(fp)
81116a60:	00a04574 	movhi	r2,33045
81116a64:	1099f704 	addi	r2,r2,26588
81116a68:	18c00b24 	muli	r3,r3,44
81116a6c:	10c5883a 	add	r2,r2,r3
81116a70:	10800984 	addi	r2,r2,38
81116a74:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81116a78:	e0fffb03 	ldbu	r3,-20(fp)
81116a7c:	00a04574 	movhi	r2,33045
81116a80:	1099f704 	addi	r2,r2,26588
81116a84:	18c00b24 	muli	r3,r3,44
81116a88:	10c5883a 	add	r2,r2,r3
81116a8c:	10800804 	addi	r2,r2,32
81116a90:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81116a94:	e0fffb03 	ldbu	r3,-20(fp)
81116a98:	00a045b4 	movhi	r2,33046
81116a9c:	10ac7704 	addi	r2,r2,-20004
81116aa0:	18c00384 	addi	r3,r3,14
81116aa4:	18c7883a 	add	r3,r3,r3
81116aa8:	18c7883a 	add	r3,r3,r3
81116aac:	10c5883a 	add	r2,r2,r3
81116ab0:	00c00044 	movi	r3,1
81116ab4:	10c00015 	stw	r3,0(r2)
			break;
81116ab8:	00000606 	br	81116ad4 <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81116abc:	e0bffb03 	ldbu	r2,-20(fp)
81116ac0:	10800044 	addi	r2,r2,1
81116ac4:	e0bffb05 	stb	r2,-20(fp)
81116ac8:	e0bffb03 	ldbu	r2,-20(fp)
81116acc:	10800230 	cmpltui	r2,r2,8
81116ad0:	103fb81e 	bne	r2,zero,811169b4 <__reset+0xfb0f69b4>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81116ad4:	e0bffb03 	ldbu	r2,-20(fp)
81116ad8:	10800230 	cmpltui	r2,r2,8
81116adc:	1000091e 	bne	r2,zero,81116b04 <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81116ae0:	d0a06e17 	ldw	r2,-32328(gp)
81116ae4:	1009883a 	mov	r4,r2
81116ae8:	113ba780 	call	8113ba78 <OSSemPost>
81116aec:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81116af0:	d0a06b17 	ldw	r2,-32340(gp)
81116af4:	1009883a 	mov	r4,r2
81116af8:	1139c880 	call	81139c88 <OSMutexPost>
		return bSuccessL;
81116afc:	e0bffc17 	ldw	r2,-16(fp)
81116b00:	00003006 	br	81116bc4 <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81116b04:	00800044 	movi	r2,1
81116b08:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81116b0c:	d0a06783 	ldbu	r2,-32354(gp)
81116b10:	10bfffc4 	addi	r2,r2,-1
81116b14:	d0a06785 	stb	r2,-32354(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81116b18:	d0a07317 	ldw	r2,-32308(gp)
81116b1c:	e0fffd04 	addi	r3,fp,-12
81116b20:	180d883a 	mov	r6,r3
81116b24:	01400084 	movi	r5,2
81116b28:	1009883a 	mov	r4,r2
81116b2c:	11396e40 	call	811396e4 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81116b30:	e0bffd03 	ldbu	r2,-12(fp)
81116b34:	10803fcc 	andi	r2,r2,255
81116b38:	10000c26 	beq	r2,zero,81116b6c <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81116b3c:	d0a06117 	ldw	r2,-32380(gp)
81116b40:	100f883a 	mov	r7,r2
81116b44:	01801bc4 	movi	r6,111
81116b48:	01400044 	movi	r5,1
81116b4c:	01204574 	movhi	r4,33045
81116b50:	212bb404 	addi	r4,r4,-20784
81116b54:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81116b58:	d0a06b17 	ldw	r2,-32340(gp)
81116b5c:	1009883a 	mov	r4,r2
81116b60:	1139c880 	call	81139c88 <OSMutexPost>
		return bSuccessL;
81116b64:	e0bffc17 	ldw	r2,-16(fp)
81116b68:	00001606 	br	81116bc4 <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81116b6c:	e0bffb03 	ldbu	r2,-20(fp)
81116b70:	10c00b24 	muli	r3,r2,44
81116b74:	00a04574 	movhi	r2,33045
81116b78:	1099f704 	addi	r2,r2,26588
81116b7c:	1885883a 	add	r2,r3,r2
81116b80:	1009883a 	mov	r4,r2
81116b84:	111ec600 	call	8111ec60 <puts>
	xBuffer32[ucIL].bSent = TRUE;
81116b88:	e0fffb03 	ldbu	r3,-20(fp)
81116b8c:	00a04574 	movhi	r2,33045
81116b90:	1099f704 	addi	r2,r2,26588
81116b94:	18c00b24 	muli	r3,r3,44
81116b98:	10c5883a 	add	r2,r2,r3
81116b9c:	10800804 	addi	r2,r2,32
81116ba0:	00c00044 	movi	r3,1
81116ba4:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81116ba8:	d0a07317 	ldw	r2,-32308(gp)
81116bac:	1009883a 	mov	r4,r2
81116bb0:	1139c880 	call	81139c88 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81116bb4:	d0a06b17 	ldw	r2,-32340(gp)
81116bb8:	1009883a 	mov	r4,r2
81116bbc:	1139c880 	call	81139c88 <OSMutexPost>

	return bSuccessL;
81116bc0:	e0bffc17 	ldw	r2,-16(fp)
}
81116bc4:	e037883a 	mov	sp,fp
81116bc8:	dfc00117 	ldw	ra,4(sp)
81116bcc:	df000017 	ldw	fp,0(sp)
81116bd0:	dec00204 	addi	sp,sp,8
81116bd4:	f800283a 	ret

81116bd8 <vSendEthConf>:


void vSendEthConf ( void ) {
81116bd8:	deffc304 	addi	sp,sp,-244
81116bdc:	de00012e 	bgeu	sp,et,81116be4 <vSendEthConf+0xc>
81116be0:	003b68fa 	trap	3
81116be4:	dfc03c15 	stw	ra,240(sp)
81116be8:	df003b15 	stw	fp,236(sp)
81116bec:	dd403a15 	stw	r21,232(sp)
81116bf0:	dd003915 	stw	r20,228(sp)
81116bf4:	dcc03815 	stw	r19,224(sp)
81116bf8:	dc803715 	stw	r18,220(sp)
81116bfc:	dc403615 	stw	r17,216(sp)
81116c00:	dc003515 	stw	r16,212(sp)
81116c04:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
81116c08:	e03fd98d 	sth	zero,-154(fp)
81116c0c:	e03fda0d 	sth	zero,-152(fp)
81116c10:	e0bfda84 	addi	r2,fp,-150
81116c14:	00c01f04 	movi	r3,124
81116c18:	180d883a 	mov	r6,r3
81116c1c:	000b883a 	mov	r5,zero
81116c20:	1009883a 	mov	r4,r2
81116c24:	111e8140 	call	8111e814 <memset>
    unsigned char crc = 0;
81116c28:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81116c2c:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81116c30:	11171980 	call	81117198 <usiGetIdCMD>
81116c34:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116c38:	e57fd90b 	ldhu	r21,-156(fp)
81116c3c:	00a045b4 	movhi	r2,33046
81116c40:	108c5904 	addi	r2,r2,12644
81116c44:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81116c48:	00a045b4 	movhi	r2,33046
81116c4c:	108c5904 	addi	r2,r2,12644
81116c50:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116c54:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81116c58:	00a045b4 	movhi	r2,33046
81116c5c:	108c5904 	addi	r2,r2,12644
81116c60:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116c64:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81116c68:	00a045b4 	movhi	r2,33046
81116c6c:	108c5904 	addi	r2,r2,12644
81116c70:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116c74:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81116c78:	00a045b4 	movhi	r2,33046
81116c7c:	108c5904 	addi	r2,r2,12644
81116c80:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116c84:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81116c88:	00a045b4 	movhi	r2,33046
81116c8c:	108c5904 	addi	r2,r2,12644
81116c90:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116c94:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81116c98:	00a045b4 	movhi	r2,33046
81116c9c:	108c5904 	addi	r2,r2,12644
81116ca0:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116ca4:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81116ca8:	00a045b4 	movhi	r2,33046
81116cac:	108c5904 	addi	r2,r2,12644
81116cb0:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116cb4:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81116cb8:	00a045b4 	movhi	r2,33046
81116cbc:	108c5904 	addi	r2,r2,12644
81116cc0:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116cc4:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81116cc8:	00a045b4 	movhi	r2,33046
81116ccc:	108c5904 	addi	r2,r2,12644
81116cd0:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116cd4:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81116cd8:	00a045b4 	movhi	r2,33046
81116cdc:	108c5904 	addi	r2,r2,12644
81116ce0:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116ce4:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81116ce8:	00a045b4 	movhi	r2,33046
81116cec:	108c5904 	addi	r2,r2,12644
81116cf0:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116cf4:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81116cf8:	00a045b4 	movhi	r2,33046
81116cfc:	108c5904 	addi	r2,r2,12644
81116d00:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116d04:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81116d08:	00a045b4 	movhi	r2,33046
81116d0c:	108c5904 	addi	r2,r2,12644
81116d10:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116d14:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81116d18:	00a045b4 	movhi	r2,33046
81116d1c:	108c5904 	addi	r2,r2,12644
81116d20:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116d24:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81116d28:	00a045b4 	movhi	r2,33046
81116d2c:	108c5904 	addi	r2,r2,12644
81116d30:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116d34:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81116d38:	00a045b4 	movhi	r2,33046
81116d3c:	108c5904 	addi	r2,r2,12644
81116d40:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116d44:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81116d48:	00a045b4 	movhi	r2,33046
81116d4c:	108c5904 	addi	r2,r2,12644
81116d50:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81116d54:	10bfffcc 	andi	r2,r2,65535
81116d58:	e53fd984 	addi	r20,fp,-154
81116d5c:	d8801115 	stw	r2,68(sp)
81116d60:	dcc01015 	stw	r19,64(sp)
81116d64:	dc800f15 	stw	r18,60(sp)
81116d68:	dc400e15 	stw	r17,56(sp)
81116d6c:	dc000d15 	stw	r16,52(sp)
81116d70:	dbc00c15 	stw	r15,48(sp)
81116d74:	db800b15 	stw	r14,44(sp)
81116d78:	db400a15 	stw	r13,40(sp)
81116d7c:	db000915 	stw	r12,36(sp)
81116d80:	dac00815 	stw	r11,32(sp)
81116d84:	da800715 	stw	r10,28(sp)
81116d88:	da400615 	stw	r9,24(sp)
81116d8c:	da000515 	stw	r8,20(sp)
81116d90:	d9c00415 	stw	r7,16(sp)
81116d94:	d9800315 	stw	r6,12(sp)
81116d98:	d9400215 	stw	r5,8(sp)
81116d9c:	d9000115 	stw	r4,4(sp)
81116da0:	d8c00015 	stw	r3,0(sp)
81116da4:	a80f883a 	mov	r7,r21
81116da8:	018010c4 	movi	r6,67
81116dac:	01604574 	movhi	r5,33045
81116db0:	296bd004 	addi	r5,r5,-20672
81116db4:	a009883a 	mov	r4,r20
81116db8:	111efa40 	call	8111efa4 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81116dbc:	e0bfd984 	addi	r2,fp,-154
81116dc0:	1009883a 	mov	r4,r2
81116dc4:	111f1b80 	call	8111f1b8 <strlen>
81116dc8:	1007883a 	mov	r3,r2
81116dcc:	e0bfd984 	addi	r2,fp,-154
81116dd0:	180b883a 	mov	r5,r3
81116dd4:	1009883a 	mov	r4,r2
81116dd8:	11184080 	call	81118408 <ucCrc8wInit>
81116ddc:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81116de0:	e13fd703 	ldbu	r4,-164(fp)
81116de4:	e0ffd984 	addi	r3,fp,-154
81116de8:	e0bfd984 	addi	r2,fp,-154
81116dec:	200f883a 	mov	r7,r4
81116df0:	180d883a 	mov	r6,r3
81116df4:	01604574 	movhi	r5,33045
81116df8:	296be804 	addi	r5,r5,-20576
81116dfc:	1009883a 	mov	r4,r2
81116e00:	111efa40 	call	8111efa4 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81116e04:	e0bfd90b 	ldhu	r2,-156(fp)
81116e08:	10ffffcc 	andi	r3,r2,65535
81116e0c:	18e0001c 	xori	r3,r3,32768
81116e10:	18e00004 	addi	r3,r3,-32768
81116e14:	e0bfd984 	addi	r2,fp,-154
81116e18:	180b883a 	mov	r5,r3
81116e1c:	1009883a 	mov	r4,r2
81116e20:	11162f80 	call	811162f8 <bSendUART128v2>
81116e24:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81116e28:	e0bfd817 	ldw	r2,-160(fp)
81116e2c:	10800060 	cmpeqi	r2,r2,1
81116e30:	1000011e 	bne	r2,zero,81116e38 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81116e34:	1118fd80 	call	81118fd8 <vCouldNotSendEthConfUART>
	}
}
81116e38:	0001883a 	nop
81116e3c:	e6fffa04 	addi	sp,fp,-24
81116e40:	dfc00717 	ldw	ra,28(sp)
81116e44:	df000617 	ldw	fp,24(sp)
81116e48:	dd400517 	ldw	r21,20(sp)
81116e4c:	dd000417 	ldw	r20,16(sp)
81116e50:	dcc00317 	ldw	r19,12(sp)
81116e54:	dc800217 	ldw	r18,8(sp)
81116e58:	dc400117 	ldw	r17,4(sp)
81116e5c:	dc000017 	ldw	r16,0(sp)
81116e60:	dec00804 	addi	sp,sp,32
81116e64:	f800283a 	ret

81116e68 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81116e68:	defff304 	addi	sp,sp,-52
81116e6c:	de00012e 	bgeu	sp,et,81116e74 <vSendTurnOff+0xc>
81116e70:	003b68fa 	trap	3
81116e74:	dfc00c15 	stw	ra,48(sp)
81116e78:	df000b15 	stw	fp,44(sp)
81116e7c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81116e80:	e03ff78d 	sth	zero,-34(fp)
81116e84:	e03ff80d 	sth	zero,-32(fp)
81116e88:	e03ff88d 	sth	zero,-30(fp)
81116e8c:	e03ff90d 	sth	zero,-28(fp)
81116e90:	e03ff98d 	sth	zero,-26(fp)
81116e94:	e03ffa0d 	sth	zero,-24(fp)
81116e98:	e03ffa8d 	sth	zero,-22(fp)
81116e9c:	e03ffb0d 	sth	zero,-20(fp)
81116ea0:	e03ffb8d 	sth	zero,-18(fp)
81116ea4:	e03ffc0d 	sth	zero,-16(fp)
81116ea8:	e03ffc8d 	sth	zero,-14(fp)
81116eac:	e03ffd0d 	sth	zero,-12(fp)
81116eb0:	e03ffd8d 	sth	zero,-10(fp)
81116eb4:	e03ffe0d 	sth	zero,-8(fp)
81116eb8:	e03ffe8d 	sth	zero,-6(fp)
81116ebc:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81116ec0:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81116ec4:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81116ec8:	11171980 	call	81117198 <usiGetIdCMD>
81116ecc:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81116ed0:	e0fff70b 	ldhu	r3,-36(fp)
81116ed4:	e0bff784 	addi	r2,fp,-34
81116ed8:	180d883a 	mov	r6,r3
81116edc:	01604574 	movhi	r5,33045
81116ee0:	296beb04 	addi	r5,r5,-20564
81116ee4:	1009883a 	mov	r4,r2
81116ee8:	111efa40 	call	8111efa4 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81116eec:	e0bff784 	addi	r2,fp,-34
81116ef0:	1009883a 	mov	r4,r2
81116ef4:	111f1b80 	call	8111f1b8 <strlen>
81116ef8:	1007883a 	mov	r3,r2
81116efc:	e0bff784 	addi	r2,fp,-34
81116f00:	180b883a 	mov	r5,r3
81116f04:	1009883a 	mov	r4,r2
81116f08:	11184080 	call	81118408 <ucCrc8wInit>
81116f0c:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81116f10:	e13ff503 	ldbu	r4,-44(fp)
81116f14:	e0fff784 	addi	r3,fp,-34
81116f18:	e0bff784 	addi	r2,fp,-34
81116f1c:	200f883a 	mov	r7,r4
81116f20:	180d883a 	mov	r6,r3
81116f24:	01604574 	movhi	r5,33045
81116f28:	296be804 	addi	r5,r5,-20576
81116f2c:	1009883a 	mov	r4,r2
81116f30:	111efa40 	call	8111efa4 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81116f34:	e0bff70b 	ldhu	r2,-36(fp)
81116f38:	10ffffcc 	andi	r3,r2,65535
81116f3c:	18e0001c 	xori	r3,r3,32768
81116f40:	18e00004 	addi	r3,r3,-32768
81116f44:	e0bff784 	addi	r2,fp,-34
81116f48:	180b883a 	mov	r5,r3
81116f4c:	1009883a 	mov	r4,r2
81116f50:	11168e00 	call	811168e0 <bSendUART32v2>
81116f54:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81116f58:	e0bff617 	ldw	r2,-40(fp)
81116f5c:	10800060 	cmpeqi	r2,r2,1
81116f60:	1000011e 	bne	r2,zero,81116f68 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81116f64:	11196800 	call	81119680 <vCouldNotSendTurnOff>
	}
}
81116f68:	0001883a 	nop
81116f6c:	e037883a 	mov	sp,fp
81116f70:	dfc00117 	ldw	ra,4(sp)
81116f74:	df000017 	ldw	fp,0(sp)
81116f78:	dec00204 	addi	sp,sp,8
81116f7c:	f800283a 	ret

81116f80 <vSendReset>:

void vSendReset ( void ) {
81116f80:	defff304 	addi	sp,sp,-52
81116f84:	de00012e 	bgeu	sp,et,81116f8c <vSendReset+0xc>
81116f88:	003b68fa 	trap	3
81116f8c:	dfc00c15 	stw	ra,48(sp)
81116f90:	df000b15 	stw	fp,44(sp)
81116f94:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81116f98:	e03ff78d 	sth	zero,-34(fp)
81116f9c:	e03ff80d 	sth	zero,-32(fp)
81116fa0:	e03ff88d 	sth	zero,-30(fp)
81116fa4:	e03ff90d 	sth	zero,-28(fp)
81116fa8:	e03ff98d 	sth	zero,-26(fp)
81116fac:	e03ffa0d 	sth	zero,-24(fp)
81116fb0:	e03ffa8d 	sth	zero,-22(fp)
81116fb4:	e03ffb0d 	sth	zero,-20(fp)
81116fb8:	e03ffb8d 	sth	zero,-18(fp)
81116fbc:	e03ffc0d 	sth	zero,-16(fp)
81116fc0:	e03ffc8d 	sth	zero,-14(fp)
81116fc4:	e03ffd0d 	sth	zero,-12(fp)
81116fc8:	e03ffd8d 	sth	zero,-10(fp)
81116fcc:	e03ffe0d 	sth	zero,-8(fp)
81116fd0:	e03ffe8d 	sth	zero,-6(fp)
81116fd4:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81116fd8:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81116fdc:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81116fe0:	11171980 	call	81117198 <usiGetIdCMD>
81116fe4:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81116fe8:	e0fff70b 	ldhu	r3,-36(fp)
81116fec:	e0bff784 	addi	r2,fp,-34
81116ff0:	180d883a 	mov	r6,r3
81116ff4:	01604574 	movhi	r5,33045
81116ff8:	296bed04 	addi	r5,r5,-20556
81116ffc:	1009883a 	mov	r4,r2
81117000:	111efa40 	call	8111efa4 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81117004:	e0bff784 	addi	r2,fp,-34
81117008:	1009883a 	mov	r4,r2
8111700c:	111f1b80 	call	8111f1b8 <strlen>
81117010:	1007883a 	mov	r3,r2
81117014:	e0bff784 	addi	r2,fp,-34
81117018:	180b883a 	mov	r5,r3
8111701c:	1009883a 	mov	r4,r2
81117020:	11184080 	call	81118408 <ucCrc8wInit>
81117024:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81117028:	e13ff503 	ldbu	r4,-44(fp)
8111702c:	e0fff784 	addi	r3,fp,-34
81117030:	e0bff784 	addi	r2,fp,-34
81117034:	200f883a 	mov	r7,r4
81117038:	180d883a 	mov	r6,r3
8111703c:	01604574 	movhi	r5,33045
81117040:	296be804 	addi	r5,r5,-20576
81117044:	1009883a 	mov	r4,r2
81117048:	111efa40 	call	8111efa4 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111704c:	e0bff70b 	ldhu	r2,-36(fp)
81117050:	10ffffcc 	andi	r3,r2,65535
81117054:	18e0001c 	xori	r3,r3,32768
81117058:	18e00004 	addi	r3,r3,-32768
8111705c:	e0bff784 	addi	r2,fp,-34
81117060:	180b883a 	mov	r5,r3
81117064:	1009883a 	mov	r4,r2
81117068:	11168e00 	call	811168e0 <bSendUART32v2>
8111706c:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81117070:	e0bff617 	ldw	r2,-40(fp)
81117074:	10800060 	cmpeqi	r2,r2,1
81117078:	1000011e 	bne	r2,zero,81117080 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111707c:	11196800 	call	81119680 <vCouldNotSendTurnOff>
	}
}
81117080:	0001883a 	nop
81117084:	e037883a 	mov	sp,fp
81117088:	dfc00117 	ldw	ra,4(sp)
8111708c:	df000017 	ldw	fp,0(sp)
81117090:	dec00204 	addi	sp,sp,8
81117094:	f800283a 	ret

81117098 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81117098:	deffda04 	addi	sp,sp,-152
8111709c:	de00012e 	bgeu	sp,et,811170a4 <vSendLog+0xc>
811170a0:	003b68fa 	trap	3
811170a4:	dfc02515 	stw	ra,148(sp)
811170a8:	df002415 	stw	fp,144(sp)
811170ac:	df002404 	addi	fp,sp,144
811170b0:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
811170b4:	e03fde8d 	sth	zero,-134(fp)
811170b8:	e03fdf0d 	sth	zero,-132(fp)
811170bc:	e0bfdf84 	addi	r2,fp,-130
811170c0:	00c01f04 	movi	r3,124
811170c4:	180d883a 	mov	r6,r3
811170c8:	000b883a 	mov	r5,zero
811170cc:	1009883a 	mov	r4,r2
811170d0:	111e8140 	call	8111e814 <memset>
    unsigned char crc = 0;
811170d4:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811170d8:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
811170dc:	11171980 	call	81117198 <usiGetIdCMD>
811170e0:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
811170e4:	e0ffde0b 	ldhu	r3,-136(fp)
811170e8:	e0bfde84 	addi	r2,fp,-134
811170ec:	e1ffff17 	ldw	r7,-4(fp)
811170f0:	180d883a 	mov	r6,r3
811170f4:	01604574 	movhi	r5,33045
811170f8:	296bef04 	addi	r5,r5,-20548
811170fc:	1009883a 	mov	r4,r2
81117100:	111efa40 	call	8111efa4 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
81117104:	e0bfde84 	addi	r2,fp,-134
81117108:	1009883a 	mov	r4,r2
8111710c:	111f1b80 	call	8111f1b8 <strlen>
81117110:	1007883a 	mov	r3,r2
81117114:	e0bfde84 	addi	r2,fp,-134
81117118:	180b883a 	mov	r5,r3
8111711c:	1009883a 	mov	r4,r2
81117120:	11184080 	call	81118408 <ucCrc8wInit>
81117124:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
81117128:	e13fdc03 	ldbu	r4,-144(fp)
8111712c:	e0ffde84 	addi	r3,fp,-134
81117130:	e0bfde84 	addi	r2,fp,-134
81117134:	200f883a 	mov	r7,r4
81117138:	180d883a 	mov	r6,r3
8111713c:	01604574 	movhi	r5,33045
81117140:	296be804 	addi	r5,r5,-20576
81117144:	1009883a 	mov	r4,r2
81117148:	111efa40 	call	8111efa4 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8111714c:	e0bfde0b 	ldhu	r2,-136(fp)
81117150:	10ffffcc 	andi	r3,r2,65535
81117154:	18e0001c 	xori	r3,r3,32768
81117158:	18e00004 	addi	r3,r3,-32768
8111715c:	e0bfde84 	addi	r2,fp,-134
81117160:	180b883a 	mov	r5,r3
81117164:	1009883a 	mov	r4,r2
81117168:	11162f80 	call	811162f8 <bSendUART128v2>
8111716c:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81117170:	e0bfdd17 	ldw	r2,-140(fp)
81117174:	10800060 	cmpeqi	r2,r2,1
81117178:	1000011e 	bne	r2,zero,81117180 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8111717c:	11197500 	call	81119750 <vCouldNotSendLog>
	}
}
81117180:	0001883a 	nop
81117184:	e037883a 	mov	sp,fp
81117188:	dfc00117 	ldw	ra,4(sp)
8111718c:	df000017 	ldw	fp,0(sp)
81117190:	dec00204 	addi	sp,sp,8
81117194:	f800283a 	ret

81117198 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81117198:	deffff04 	addi	sp,sp,-4
8111719c:	de00012e 	bgeu	sp,et,811171a4 <usiGetIdCMD+0xc>
811171a0:	003b68fa 	trap	3
811171a4:	df000015 	stw	fp,0(sp)
811171a8:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
811171ac:	d0a0670b 	ldhu	r2,-32356(gp)
811171b0:	10ffffcc 	andi	r3,r2,65535
811171b4:	00bfffd4 	movui	r2,65535
811171b8:	1880031e 	bne	r3,r2,811171c8 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
811171bc:	00800084 	movi	r2,2
811171c0:	d0a0670d 	sth	r2,-32356(gp)
811171c4:	00000306 	br	811171d4 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
811171c8:	d0a0670b 	ldhu	r2,-32356(gp)
811171cc:	10800044 	addi	r2,r2,1
811171d0:	d0a0670d 	sth	r2,-32356(gp)

    return usiIdCMD;
811171d4:	d0a0670b 	ldhu	r2,-32356(gp)
}
811171d8:	e037883a 	mov	sp,fp
811171dc:	df000017 	ldw	fp,0(sp)
811171e0:	dec00104 	addi	sp,sp,4
811171e4:	f800283a 	ret

811171e8 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
811171e8:	defffb04 	addi	sp,sp,-20
811171ec:	de00012e 	bgeu	sp,et,811171f4 <siPosStr+0xc>
811171f0:	003b68fa 	trap	3
811171f4:	dfc00415 	stw	ra,16(sp)
811171f8:	df000315 	stw	fp,12(sp)
811171fc:	df000304 	addi	fp,sp,12
81117200:	e13ffe15 	stw	r4,-8(fp)
81117204:	2805883a 	mov	r2,r5
81117208:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8111720c:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
81117210:	e0bfff03 	ldbu	r2,-4(fp)
81117214:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
81117218:	e17ffd04 	addi	r5,fp,-12
8111721c:	e13ffe17 	ldw	r4,-8(fp)
81117220:	111f16c0 	call	8111f16c <strcspn>
}
81117224:	e037883a 	mov	sp,fp
81117228:	dfc00117 	ldw	ra,4(sp)
8111722c:	df000017 	ldw	fp,0(sp)
81117230:	dec00204 	addi	sp,sp,8
81117234:	f800283a 	ret

81117238 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
81117238:	defffc04 	addi	sp,sp,-16
8111723c:	de00012e 	bgeu	sp,et,81117244 <vTimeoutCheck+0xc>
81117240:	003b68fa 	trap	3
81117244:	dfc00315 	stw	ra,12(sp)
81117248:	df000215 	stw	fp,8(sp)
8111724c:	df000204 	addi	fp,sp,8
81117250:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
81117254:	d0a06617 	ldw	r2,-32360(gp)
81117258:	1009883a 	mov	r4,r2
8111725c:	113ba780 	call	8113ba78 <OSSemPost>
81117260:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
81117264:	e0bffe03 	ldbu	r2,-8(fp)
81117268:	10000126 	beq	r2,zero,81117270 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8111726c:	11194100 	call	81119410 <vFailPostBlockingSemTimeoutTask>
	}
}
81117270:	0001883a 	nop
81117274:	e037883a 	mov	sp,fp
81117278:	dfc00117 	ldw	ra,4(sp)
8111727c:	df000017 	ldw	fp,0(sp)
81117280:	dec00204 	addi	sp,sp,8
81117284:	f800283a 	ret

81117288 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81117288:	deffe304 	addi	sp,sp,-116
8111728c:	de00012e 	bgeu	sp,et,81117294 <vSendPusTM64+0xc>
81117290:	003b68fa 	trap	3
81117294:	dfc01815 	stw	ra,96(sp)
81117298:	df001715 	stw	fp,92(sp)
8111729c:	df001704 	addi	fp,sp,92
811172a0:	e1000215 	stw	r4,8(fp)
811172a4:	e1400315 	stw	r5,12(fp)
811172a8:	e1800415 	stw	r6,16(fp)
811172ac:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
811172b0:	e03fef8d 	sth	zero,-66(fp)
811172b4:	e03ff00d 	sth	zero,-64(fp)
811172b8:	e0bff084 	addi	r2,fp,-62
811172bc:	00c00f04 	movi	r3,60
811172c0:	180d883a 	mov	r6,r3
811172c4:	000b883a 	mov	r5,zero
811172c8:	1009883a 	mov	r4,r2
811172cc:	111e8140 	call	8111e814 <memset>
    unsigned char crc = 0;
811172d0:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
811172d4:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811172d8:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
811172dc:	11171980 	call	81117198 <usiGetIdCMD>
811172e0:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
811172e4:	e1bfef0b 	ldhu	r6,-68(fp)
811172e8:	e080040b 	ldhu	r2,16(fp)
811172ec:	11ffffcc 	andi	r7,r2,65535
811172f0:	e080048b 	ldhu	r2,18(fp)
811172f4:	10bfffcc 	andi	r2,r2,65535
811172f8:	e0c0050b 	ldhu	r3,20(fp)
811172fc:	18ffffcc 	andi	r3,r3,65535
81117300:	e100058b 	ldhu	r4,22(fp)
81117304:	213fffcc 	andi	r4,r4,65535
81117308:	e140060b 	ldhu	r5,24(fp)
8111730c:	297fffcc 	andi	r5,r5,65535
81117310:	e23fef84 	addi	r8,fp,-66
81117314:	d9400315 	stw	r5,12(sp)
81117318:	d9000215 	stw	r4,8(sp)
8111731c:	d8c00115 	stw	r3,4(sp)
81117320:	d8800015 	stw	r2,0(sp)
81117324:	01604574 	movhi	r5,33045
81117328:	296bf204 	addi	r5,r5,-20536
8111732c:	4009883a 	mov	r4,r8
81117330:	111efa40 	call	8111efa4 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81117334:	e03fed05 	stb	zero,-76(fp)
81117338:	00001206 	br	81117384 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111733c:	e0bfed03 	ldbu	r2,-76(fp)
81117340:	10800284 	addi	r2,r2,10
81117344:	1085883a 	add	r2,r2,r2
81117348:	e0c00204 	addi	r3,fp,8
8111734c:	1885883a 	add	r2,r3,r2
81117350:	1080000b 	ldhu	r2,0(r2)
81117354:	113fffcc 	andi	r4,r2,65535
81117358:	e0ffef84 	addi	r3,fp,-66
8111735c:	e0bfef84 	addi	r2,fp,-66
81117360:	200f883a 	mov	r7,r4
81117364:	180d883a 	mov	r6,r3
81117368:	01604574 	movhi	r5,33045
8111736c:	296bf904 	addi	r5,r5,-20508
81117370:	1009883a 	mov	r4,r2
81117374:	111efa40 	call	8111efa4 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81117378:	e0bfed03 	ldbu	r2,-76(fp)
8111737c:	10800044 	addi	r2,r2,1
81117380:	e0bfed05 	stb	r2,-76(fp)
81117384:	e0800683 	ldbu	r2,26(fp)
81117388:	10803fcc 	andi	r2,r2,255
8111738c:	e0ffed03 	ldbu	r3,-76(fp)
81117390:	18bfea36 	bltu	r3,r2,8111733c <__reset+0xfb0f733c>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81117394:	e0bfef84 	addi	r2,fp,-66
81117398:	1009883a 	mov	r4,r2
8111739c:	111f1b80 	call	8111f1b8 <strlen>
811173a0:	1007883a 	mov	r3,r2
811173a4:	e0bfef84 	addi	r2,fp,-66
811173a8:	180b883a 	mov	r5,r3
811173ac:	1009883a 	mov	r4,r2
811173b0:	11184080 	call	81118408 <ucCrc8wInit>
811173b4:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
811173b8:	e13fed43 	ldbu	r4,-75(fp)
811173bc:	e0ffef84 	addi	r3,fp,-66
811173c0:	e0bfef84 	addi	r2,fp,-66
811173c4:	200f883a 	mov	r7,r4
811173c8:	180d883a 	mov	r6,r3
811173cc:	01604574 	movhi	r5,33045
811173d0:	296be804 	addi	r5,r5,-20576
811173d4:	1009883a 	mov	r4,r2
811173d8:	111efa40 	call	8111efa4 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
811173dc:	e0bfef0b 	ldhu	r2,-68(fp)
811173e0:	10ffffcc 	andi	r3,r2,65535
811173e4:	18e0001c 	xori	r3,r3,32768
811173e8:	18e00004 	addi	r3,r3,-32768
811173ec:	e0bfef84 	addi	r2,fp,-66
811173f0:	180b883a 	mov	r5,r3
811173f4:	1009883a 	mov	r4,r2
811173f8:	11165e80 	call	811165e8 <bSendUART64v2>
811173fc:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
81117400:	e0bfee17 	ldw	r2,-72(fp)
81117404:	10800060 	cmpeqi	r2,r2,1
81117408:	1000031e 	bne	r2,zero,81117418 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111740c:	e0bfef84 	addi	r2,fp,-66
81117410:	1009883a 	mov	r4,r2
81117414:	11197b80 	call	811197b8 <vCouldNotSendTMPusCommand>
	}
}
81117418:	0001883a 	nop
8111741c:	e037883a 	mov	sp,fp
81117420:	dfc00117 	ldw	ra,4(sp)
81117424:	df000017 	ldw	fp,0(sp)
81117428:	dec00604 	addi	sp,sp,24
8111742c:	f800283a 	ret

81117430 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
81117430:	deffd304 	addi	sp,sp,-180
81117434:	de00012e 	bgeu	sp,et,8111743c <vSendPusTM128+0xc>
81117438:	003b68fa 	trap	3
8111743c:	dfc02815 	stw	ra,160(sp)
81117440:	df002715 	stw	fp,156(sp)
81117444:	df002704 	addi	fp,sp,156
81117448:	e1000215 	stw	r4,8(fp)
8111744c:	e1400315 	stw	r5,12(fp)
81117450:	e1800415 	stw	r6,16(fp)
81117454:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81117458:	e03fdf8d 	sth	zero,-130(fp)
8111745c:	e03fe00d 	sth	zero,-128(fp)
81117460:	e0bfe084 	addi	r2,fp,-126
81117464:	00c01f04 	movi	r3,124
81117468:	180d883a 	mov	r6,r3
8111746c:	000b883a 	mov	r5,zero
81117470:	1009883a 	mov	r4,r2
81117474:	111e8140 	call	8111e814 <memset>
    unsigned char crc = 0;
81117478:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
8111747c:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81117480:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
81117484:	11171980 	call	81117198 <usiGetIdCMD>
81117488:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111748c:	e1bfdf0b 	ldhu	r6,-132(fp)
81117490:	e080040b 	ldhu	r2,16(fp)
81117494:	11ffffcc 	andi	r7,r2,65535
81117498:	e080048b 	ldhu	r2,18(fp)
8111749c:	10bfffcc 	andi	r2,r2,65535
811174a0:	e0c0050b 	ldhu	r3,20(fp)
811174a4:	18ffffcc 	andi	r3,r3,65535
811174a8:	e100058b 	ldhu	r4,22(fp)
811174ac:	213fffcc 	andi	r4,r4,65535
811174b0:	e140060b 	ldhu	r5,24(fp)
811174b4:	297fffcc 	andi	r5,r5,65535
811174b8:	e23fdf84 	addi	r8,fp,-130
811174bc:	d9400315 	stw	r5,12(sp)
811174c0:	d9000215 	stw	r4,8(sp)
811174c4:	d8c00115 	stw	r3,4(sp)
811174c8:	d8800015 	stw	r2,0(sp)
811174cc:	01604574 	movhi	r5,33045
811174d0:	296bf204 	addi	r5,r5,-20536
811174d4:	4009883a 	mov	r4,r8
811174d8:	111efa40 	call	8111efa4 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811174dc:	e03fdd05 	stb	zero,-140(fp)
811174e0:	00001206 	br	8111752c <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
811174e4:	e0bfdd03 	ldbu	r2,-140(fp)
811174e8:	10800284 	addi	r2,r2,10
811174ec:	1085883a 	add	r2,r2,r2
811174f0:	e0c00204 	addi	r3,fp,8
811174f4:	1885883a 	add	r2,r3,r2
811174f8:	1080000b 	ldhu	r2,0(r2)
811174fc:	113fffcc 	andi	r4,r2,65535
81117500:	e0ffdf84 	addi	r3,fp,-130
81117504:	e0bfdf84 	addi	r2,fp,-130
81117508:	200f883a 	mov	r7,r4
8111750c:	180d883a 	mov	r6,r3
81117510:	01604574 	movhi	r5,33045
81117514:	296bf904 	addi	r5,r5,-20508
81117518:	1009883a 	mov	r4,r2
8111751c:	111efa40 	call	8111efa4 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81117520:	e0bfdd03 	ldbu	r2,-140(fp)
81117524:	10800044 	addi	r2,r2,1
81117528:	e0bfdd05 	stb	r2,-140(fp)
8111752c:	e0800683 	ldbu	r2,26(fp)
81117530:	10803fcc 	andi	r2,r2,255
81117534:	e0ffdd03 	ldbu	r3,-140(fp)
81117538:	18bfea36 	bltu	r3,r2,811174e4 <__reset+0xfb0f74e4>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111753c:	e0bfdf84 	addi	r2,fp,-130
81117540:	1009883a 	mov	r4,r2
81117544:	111f1b80 	call	8111f1b8 <strlen>
81117548:	1007883a 	mov	r3,r2
8111754c:	e0bfdf84 	addi	r2,fp,-130
81117550:	180b883a 	mov	r5,r3
81117554:	1009883a 	mov	r4,r2
81117558:	11184080 	call	81118408 <ucCrc8wInit>
8111755c:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81117560:	e13fdd43 	ldbu	r4,-139(fp)
81117564:	e0ffdf84 	addi	r3,fp,-130
81117568:	e0bfdf84 	addi	r2,fp,-130
8111756c:	200f883a 	mov	r7,r4
81117570:	180d883a 	mov	r6,r3
81117574:	01604574 	movhi	r5,33045
81117578:	296be804 	addi	r5,r5,-20576
8111757c:	1009883a 	mov	r4,r2
81117580:	111efa40 	call	8111efa4 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
81117584:	e0bfdf0b 	ldhu	r2,-132(fp)
81117588:	10ffffcc 	andi	r3,r2,65535
8111758c:	18e0001c 	xori	r3,r3,32768
81117590:	18e00004 	addi	r3,r3,-32768
81117594:	e0bfdf84 	addi	r2,fp,-130
81117598:	180b883a 	mov	r5,r3
8111759c:	1009883a 	mov	r4,r2
811175a0:	11162f80 	call	811162f8 <bSendUART128v2>
811175a4:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
811175a8:	e0bfde17 	ldw	r2,-136(fp)
811175ac:	10800060 	cmpeqi	r2,r2,1
811175b0:	1000031e 	bne	r2,zero,811175c0 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
811175b4:	e0bfdf84 	addi	r2,fp,-130
811175b8:	1009883a 	mov	r4,r2
811175bc:	11197b80 	call	811197b8 <vCouldNotSendTMPusCommand>
	}
}
811175c0:	0001883a 	nop
811175c4:	e037883a 	mov	sp,fp
811175c8:	dfc00117 	ldw	ra,4(sp)
811175cc:	df000017 	ldw	fp,0(sp)
811175d0:	dec00604 	addi	sp,sp,24
811175d4:	f800283a 	ret

811175d8 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
811175d8:	deffd704 	addi	sp,sp,-164
811175dc:	de00012e 	bgeu	sp,et,811175e4 <vTMPusTestConnection+0xc>
811175e0:	003b68fa 	trap	3
811175e4:	dfc02815 	stw	ra,160(sp)
811175e8:	df002715 	stw	fp,156(sp)
811175ec:	df002704 	addi	fp,sp,156
811175f0:	2005883a 	mov	r2,r4
811175f4:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
811175f8:	e0bfff0b 	ldhu	r2,-4(fp)
811175fc:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81117600:	00801c04 	movi	r2,112
81117604:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
81117608:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
8111760c:	00800444 	movi	r2,17
81117610:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81117614:	00800084 	movi	r2,2
81117618:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
8111761c:	d809883a 	mov	r4,sp
81117620:	e0bfee04 	addi	r2,fp,-72
81117624:	00c01104 	movi	r3,68
81117628:	180d883a 	mov	r6,r3
8111762c:	100b883a 	mov	r5,r2
81117630:	111e6c40 	call	8111e6c4 <memcpy>
81117634:	e13fea17 	ldw	r4,-88(fp)
81117638:	e17feb17 	ldw	r5,-84(fp)
8111763c:	e1bfec17 	ldw	r6,-80(fp)
81117640:	e1ffed17 	ldw	r7,-76(fp)
81117644:	11172880 	call	81117288 <vSendPusTM64>
}
81117648:	0001883a 	nop
8111764c:	e037883a 	mov	sp,fp
81117650:	dfc00117 	ldw	ra,4(sp)
81117654:	df000017 	ldw	fp,0(sp)
81117658:	dec00204 	addi	sp,sp,8
8111765c:	f800283a 	ret

81117660 <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
81117660:	defff504 	addi	sp,sp,-44
81117664:	de00012e 	bgeu	sp,et,8111766c <vLoadDefaultETHConf+0xc>
81117668:	003b68fa 	trap	3
8111766c:	dfc00a15 	stw	ra,40(sp)
81117670:	df000915 	stw	fp,36(sp)
81117674:	dc000815 	stw	r16,32(sp)
81117678:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111767c:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81117680:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81117684:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81117688:	d0a07517 	ldw	r2,-32300(gp)
8111768c:	10800058 	cmpnei	r2,r2,1
81117690:	1002041e 	bne	r2,zero,81117ea4 <vLoadDefaultETHConf+0x844>
81117694:	111b5fc0 	call	8111b5fc <bSDcardIsPresent>
81117698:	10020226 	beq	r2,zero,81117ea4 <vLoadDefaultETHConf+0x844>
8111769c:	111b62c0 	call	8111b62c <bSDcardFAT16Check>
811176a0:	10020026 	beq	r2,zero,81117ea4 <vLoadDefaultETHConf+0x844>

		siFile = siOpenFile( ETH_FILE_NAME );
811176a4:	01204574 	movhi	r4,33045
811176a8:	212bfb04 	addi	r4,r4,-20500
811176ac:	111b7540 	call	8111b754 <siOpenFile>
811176b0:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
811176b4:	e0bffc0f 	ldh	r2,-16(fp)
811176b8:	1001f216 	blt	r2,zero,81117e84 <vLoadDefaultETHConf+0x824>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
811176bc:	e0bffd04 	addi	r2,fp,-12
811176c0:	01800204 	movi	r6,8
811176c4:	01400284 	movi	r5,10
811176c8:	1009883a 	mov	r4,r2
811176cc:	111e8140 	call	8111e814 <memset>
			p_inteiro = inteiro;
811176d0:	e0bffd04 	addi	r2,fp,-12
811176d4:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
811176d8:	e0bffc0f 	ldh	r2,-16(fp)
811176dc:	1009883a 	mov	r4,r2
811176e0:	111b7d00 	call	8111b7d0 <cGetNextChar>
811176e4:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
811176e8:	e0bff947 	ldb	r2,-27(fp)
811176ec:	10800084 	addi	r2,r2,2
811176f0:	10c015a8 	cmpgeui	r3,r2,86
811176f4:	1801d71e 	bne	r3,zero,81117e54 <vLoadDefaultETHConf+0x7f4>
811176f8:	100690ba 	slli	r3,r2,2
811176fc:	00a04474 	movhi	r2,33041
81117700:	109dc404 	addi	r2,r2,30480
81117704:	1885883a 	add	r2,r3,r2
81117708:	10800017 	ldw	r2,0(r2)
8111770c:	1000683a 	jmp	r2
81117710:	811178a8 	cmpgeui	r4,r16,17890
81117714:	8111789c 	xori	r4,r16,17890
81117718:	81117e54 	ori	r4,r16,17913
8111771c:	81117e54 	ori	r4,r16,17913
81117720:	81117e54 	ori	r4,r16,17913
81117724:	81117e54 	ori	r4,r16,17913
81117728:	81117e54 	ori	r4,r16,17913
8111772c:	81117e54 	ori	r4,r16,17913
81117730:	81117e54 	ori	r4,r16,17913
81117734:	81117e54 	ori	r4,r16,17913
81117738:	81117e54 	ori	r4,r16,17913
8111773c:	81117e54 	ori	r4,r16,17913
81117740:	81117e74 	orhi	r4,r16,17913
81117744:	81117e54 	ori	r4,r16,17913
81117748:	81117e54 	ori	r4,r16,17913
8111774c:	81117e74 	orhi	r4,r16,17913
81117750:	81117e54 	ori	r4,r16,17913
81117754:	81117e54 	ori	r4,r16,17913
81117758:	81117e54 	ori	r4,r16,17913
8111775c:	81117e54 	ori	r4,r16,17913
81117760:	81117e54 	ori	r4,r16,17913
81117764:	81117e54 	ori	r4,r16,17913
81117768:	81117e54 	ori	r4,r16,17913
8111776c:	81117e54 	ori	r4,r16,17913
81117770:	81117e54 	ori	r4,r16,17913
81117774:	81117e54 	ori	r4,r16,17913
81117778:	81117e54 	ori	r4,r16,17913
8111777c:	81117e54 	ori	r4,r16,17913
81117780:	81117e54 	ori	r4,r16,17913
81117784:	81117e54 	ori	r4,r16,17913
81117788:	81117e54 	ori	r4,r16,17913
8111778c:	81117e54 	ori	r4,r16,17913
81117790:	81117e54 	ori	r4,r16,17913
81117794:	81117e54 	ori	r4,r16,17913
81117798:	81117e74 	orhi	r4,r16,17913
8111779c:	81117e54 	ori	r4,r16,17913
811177a0:	81117e54 	ori	r4,r16,17913
811177a4:	81117e54 	ori	r4,r16,17913
811177a8:	81117e54 	ori	r4,r16,17913
811177ac:	81117e54 	ori	r4,r16,17913
811177b0:	81117e54 	ori	r4,r16,17913
811177b4:	81117868 	cmpgeui	r4,r16,17889
811177b8:	81117e54 	ori	r4,r16,17913
811177bc:	81117e54 	ori	r4,r16,17913
811177c0:	81117e54 	ori	r4,r16,17913
811177c4:	81117e54 	ori	r4,r16,17913
811177c8:	81117e54 	ori	r4,r16,17913
811177cc:	81117e54 	ori	r4,r16,17913
811177d0:	81117e54 	ori	r4,r16,17913
811177d4:	81117e54 	ori	r4,r16,17913
811177d8:	81117e54 	ori	r4,r16,17913
811177dc:	81117e54 	ori	r4,r16,17913
811177e0:	81117e54 	ori	r4,r16,17913
811177e4:	81117e54 	ori	r4,r16,17913
811177e8:	81117e54 	ori	r4,r16,17913
811177ec:	81117e54 	ori	r4,r16,17913
811177f0:	81117e54 	ori	r4,r16,17913
811177f4:	81117e54 	ori	r4,r16,17913
811177f8:	81117e54 	ori	r4,r16,17913
811177fc:	81117e54 	ori	r4,r16,17913
81117800:	81117e54 	ori	r4,r16,17913
81117804:	81117e54 	ori	r4,r16,17913
81117808:	81117e0c 	andi	r4,r16,17912
8111780c:	81117e54 	ori	r4,r16,17913
81117810:	81117e54 	ori	r4,r16,17913
81117814:	81117e54 	ori	r4,r16,17913
81117818:	81117e54 	ori	r4,r16,17913
8111781c:	81117e54 	ori	r4,r16,17913
81117820:	81117e54 	ori	r4,r16,17913
81117824:	81117e54 	ori	r4,r16,17913
81117828:	81117c0c 	andi	r4,r16,17904
8111782c:	81117e54 	ori	r4,r16,17913
81117830:	81117e54 	ori	r4,r16,17913
81117834:	81117a6c 	andhi	r4,r16,17897
81117838:	81117d64 	muli	r4,r16,17909
8111783c:	811179a0 	cmpeqi	r4,r16,17894
81117840:	81117e54 	ori	r4,r16,17913
81117844:	81117e54 	ori	r4,r16,17913
81117848:	81117e54 	ori	r4,r16,17913
8111784c:	811178d0 	cmplti	r4,r16,17891
81117850:	81117e54 	ori	r4,r16,17913
81117854:	81117e54 	ori	r4,r16,17913
81117858:	81117cdc 	xori	r4,r16,17907
8111785c:	81117e54 	ori	r4,r16,17913
81117860:	81117e54 	ori	r4,r16,17913
81117864:	81117b3c 	xorhi	r4,r16,17900
					case 39:// single quote '
						c = cGetNextChar(siFile);
81117868:	e0bffc0f 	ldh	r2,-16(fp)
8111786c:	1009883a 	mov	r4,r2
81117870:	111b7d00 	call	8111b7d0 <cGetNextChar>
81117874:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81117878:	00000406 	br	8111788c <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8111787c:	e0bffc0f 	ldh	r2,-16(fp)
81117880:	1009883a 	mov	r4,r2
81117884:	111b7d00 	call	8111b7d0 <cGetNextChar>
81117888:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111788c:	e0bff947 	ldb	r2,-27(fp)
81117890:	108009d8 	cmpnei	r2,r2,39
81117894:	103ff91e 	bne	r2,zero,8111787c <__reset+0xfb0f787c>
							c = cGetNextChar(siFile);
						}
						break;
81117898:	00017706 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case -1: 	//EOF
						bEOF = TRUE;
8111789c:	00800044 	movi	r2,1
811178a0:	e0bff815 	stw	r2,-32(fp)
						break;
811178a4:	00017406 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
811178a8:	d0a06117 	ldw	r2,-32380(gp)
811178ac:	100f883a 	mov	r7,r2
811178b0:	018006c4 	movi	r6,27
811178b4:	01400044 	movi	r5,1
811178b8:	01204574 	movhi	r4,33045
811178bc:	212bfd04 	addi	r4,r4,-20492
811178c0:	111dcb00 	call	8111dcb0 <fwrite>
						#endif
						bEOF = TRUE;
811178c4:	00800044 	movi	r2,1
811178c8:	e0bff815 	stw	r2,-32(fp)
						break;
811178cc:	00016a06 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
811178d0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811178d4:	e0bffc0f 	ldh	r2,-16(fp)
811178d8:	1009883a 	mov	r4,r2
811178dc:	111b7d00 	call	8111b7d0 <cGetNextChar>
811178e0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811178e4:	d0e00317 	ldw	r3,-32756(gp)
811178e8:	e0bff947 	ldb	r2,-27(fp)
811178ec:	10800044 	addi	r2,r2,1
811178f0:	1885883a 	add	r2,r3,r2
811178f4:	10800003 	ldbu	r2,0(r2)
811178f8:	10803fcc 	andi	r2,r2,255
811178fc:	1080010c 	andi	r2,r2,4
81117900:	10000626 	beq	r2,zero,8111791c <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
81117904:	e0bffa17 	ldw	r2,-24(fp)
81117908:	e0fff943 	ldbu	r3,-27(fp)
8111790c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81117910:	e0bffa17 	ldw	r2,-24(fp)
81117914:	10800044 	addi	r2,r2,1
81117918:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8111791c:	e0bff947 	ldb	r2,-27(fp)
81117920:	10800ea0 	cmpeqi	r2,r2,58
81117924:	1000031e 	bne	r2,zero,81117934 <vLoadDefaultETHConf+0x2d4>
81117928:	e0bff947 	ldb	r2,-27(fp)
8111792c:	10800ed8 	cmpnei	r2,r2,59
81117930:	103fe81e 	bne	r2,zero,811178d4 <__reset+0xfb0f78d4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117934:	e0bffa17 	ldw	r2,-24(fp)
81117938:	00c00284 	movi	r3,10
8111793c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81117940:	e0bff903 	ldbu	r2,-28(fp)
81117944:	10800168 	cmpgeui	r2,r2,5
81117948:	1000021e 	bne	r2,zero,81117954 <vLoadDefaultETHConf+0x2f4>
8111794c:	e43ff903 	ldbu	r16,-28(fp)
81117950:	00000106 	br	81117958 <vLoadDefaultETHConf+0x2f8>
81117954:	04000144 	movi	r16,5
81117958:	e0bffd04 	addi	r2,fp,-12
8111795c:	1009883a 	mov	r4,r2
81117960:	111d4b80 	call	8111d4b8 <atoi>
81117964:	1007883a 	mov	r3,r2
81117968:	00a045b4 	movhi	r2,33046
8111796c:	108c5904 	addi	r2,r2,12644
81117970:	1405883a 	add	r2,r2,r16
81117974:	10800404 	addi	r2,r2,16
81117978:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111797c:	e0bffd04 	addi	r2,fp,-12
81117980:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81117984:	e0bff903 	ldbu	r2,-28(fp)
81117988:	10800044 	addi	r2,r2,1
8111798c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81117990:	e0bff947 	ldb	r2,-27(fp)
81117994:	10800ed8 	cmpnei	r2,r2,59
81117998:	103fce1e 	bne	r2,zero,811178d4 <__reset+0xfb0f78d4>

						break;
8111799c:	00013606 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case 'I':

						ucParser = 0;
811179a0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811179a4:	e0bffc0f 	ldh	r2,-16(fp)
811179a8:	1009883a 	mov	r4,r2
811179ac:	111b7d00 	call	8111b7d0 <cGetNextChar>
811179b0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811179b4:	d0e00317 	ldw	r3,-32756(gp)
811179b8:	e0bff947 	ldb	r2,-27(fp)
811179bc:	10800044 	addi	r2,r2,1
811179c0:	1885883a 	add	r2,r3,r2
811179c4:	10800003 	ldbu	r2,0(r2)
811179c8:	10803fcc 	andi	r2,r2,255
811179cc:	1080010c 	andi	r2,r2,4
811179d0:	10000626 	beq	r2,zero,811179ec <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
811179d4:	e0bffa17 	ldw	r2,-24(fp)
811179d8:	e0fff943 	ldbu	r3,-27(fp)
811179dc:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811179e0:	e0bffa17 	ldw	r2,-24(fp)
811179e4:	10800044 	addi	r2,r2,1
811179e8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811179ec:	e0bff947 	ldb	r2,-27(fp)
811179f0:	10800ba0 	cmpeqi	r2,r2,46
811179f4:	1000031e 	bne	r2,zero,81117a04 <vLoadDefaultETHConf+0x3a4>
811179f8:	e0bff947 	ldb	r2,-27(fp)
811179fc:	10800ed8 	cmpnei	r2,r2,59
81117a00:	103fe81e 	bne	r2,zero,811179a4 <__reset+0xfb0f79a4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117a04:	e0bffa17 	ldw	r2,-24(fp)
81117a08:	00c00284 	movi	r3,10
81117a0c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81117a10:	e0bff903 	ldbu	r2,-28(fp)
81117a14:	108000e8 	cmpgeui	r2,r2,3
81117a18:	1000021e 	bne	r2,zero,81117a24 <vLoadDefaultETHConf+0x3c4>
81117a1c:	e43ff903 	ldbu	r16,-28(fp)
81117a20:	00000106 	br	81117a28 <vLoadDefaultETHConf+0x3c8>
81117a24:	040000c4 	movi	r16,3
81117a28:	e0bffd04 	addi	r2,fp,-12
81117a2c:	1009883a 	mov	r4,r2
81117a30:	111d4b80 	call	8111d4b8 <atoi>
81117a34:	1007883a 	mov	r3,r2
81117a38:	00a045b4 	movhi	r2,33046
81117a3c:	108c5904 	addi	r2,r2,12644
81117a40:	1405883a 	add	r2,r2,r16
81117a44:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81117a48:	e0bffd04 	addi	r2,fp,-12
81117a4c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81117a50:	e0bff903 	ldbu	r2,-28(fp)
81117a54:	10800044 	addi	r2,r2,1
81117a58:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81117a5c:	e0bff947 	ldb	r2,-27(fp)
81117a60:	10800ed8 	cmpnei	r2,r2,59
81117a64:	103fcf1e 	bne	r2,zero,811179a4 <__reset+0xfb0f79a4>

						break;
81117a68:	00010306 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case 'G':

						ucParser = 0;
81117a6c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81117a70:	e0bffc0f 	ldh	r2,-16(fp)
81117a74:	1009883a 	mov	r4,r2
81117a78:	111b7d00 	call	8111b7d0 <cGetNextChar>
81117a7c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81117a80:	d0e00317 	ldw	r3,-32756(gp)
81117a84:	e0bff947 	ldb	r2,-27(fp)
81117a88:	10800044 	addi	r2,r2,1
81117a8c:	1885883a 	add	r2,r3,r2
81117a90:	10800003 	ldbu	r2,0(r2)
81117a94:	10803fcc 	andi	r2,r2,255
81117a98:	1080010c 	andi	r2,r2,4
81117a9c:	10000626 	beq	r2,zero,81117ab8 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81117aa0:	e0bffa17 	ldw	r2,-24(fp)
81117aa4:	e0fff943 	ldbu	r3,-27(fp)
81117aa8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81117aac:	e0bffa17 	ldw	r2,-24(fp)
81117ab0:	10800044 	addi	r2,r2,1
81117ab4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81117ab8:	e0bff947 	ldb	r2,-27(fp)
81117abc:	10800ba0 	cmpeqi	r2,r2,46
81117ac0:	1000031e 	bne	r2,zero,81117ad0 <vLoadDefaultETHConf+0x470>
81117ac4:	e0bff947 	ldb	r2,-27(fp)
81117ac8:	10800ed8 	cmpnei	r2,r2,59
81117acc:	103fe81e 	bne	r2,zero,81117a70 <__reset+0xfb0f7a70>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117ad0:	e0bffa17 	ldw	r2,-24(fp)
81117ad4:	00c00284 	movi	r3,10
81117ad8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81117adc:	e0bff903 	ldbu	r2,-28(fp)
81117ae0:	108000e8 	cmpgeui	r2,r2,3
81117ae4:	1000021e 	bne	r2,zero,81117af0 <vLoadDefaultETHConf+0x490>
81117ae8:	e43ff903 	ldbu	r16,-28(fp)
81117aec:	00000106 	br	81117af4 <vLoadDefaultETHConf+0x494>
81117af0:	040000c4 	movi	r16,3
81117af4:	e0bffd04 	addi	r2,fp,-12
81117af8:	1009883a 	mov	r4,r2
81117afc:	111d4b80 	call	8111d4b8 <atoi>
81117b00:	1007883a 	mov	r3,r2
81117b04:	00a045b4 	movhi	r2,33046
81117b08:	108c5904 	addi	r2,r2,12644
81117b0c:	1405883a 	add	r2,r2,r16
81117b10:	10800104 	addi	r2,r2,4
81117b14:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81117b18:	e0bffd04 	addi	r2,fp,-12
81117b1c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81117b20:	e0bff903 	ldbu	r2,-28(fp)
81117b24:	10800044 	addi	r2,r2,1
81117b28:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81117b2c:	e0bff947 	ldb	r2,-27(fp)
81117b30:	10800ed8 	cmpnei	r2,r2,59
81117b34:	103fce1e 	bne	r2,zero,81117a70 <__reset+0xfb0f7a70>

						break;
81117b38:	0000cf06 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case 'S':

						ucParser = 0;
81117b3c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81117b40:	e0bffc0f 	ldh	r2,-16(fp)
81117b44:	1009883a 	mov	r4,r2
81117b48:	111b7d00 	call	8111b7d0 <cGetNextChar>
81117b4c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81117b50:	d0e00317 	ldw	r3,-32756(gp)
81117b54:	e0bff947 	ldb	r2,-27(fp)
81117b58:	10800044 	addi	r2,r2,1
81117b5c:	1885883a 	add	r2,r3,r2
81117b60:	10800003 	ldbu	r2,0(r2)
81117b64:	10803fcc 	andi	r2,r2,255
81117b68:	1080010c 	andi	r2,r2,4
81117b6c:	10000626 	beq	r2,zero,81117b88 <vLoadDefaultETHConf+0x528>
									(*p_inteiro) = c;
81117b70:	e0bffa17 	ldw	r2,-24(fp)
81117b74:	e0fff943 	ldbu	r3,-27(fp)
81117b78:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81117b7c:	e0bffa17 	ldw	r2,-24(fp)
81117b80:	10800044 	addi	r2,r2,1
81117b84:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81117b88:	e0bff947 	ldb	r2,-27(fp)
81117b8c:	10800ba0 	cmpeqi	r2,r2,46
81117b90:	1000031e 	bne	r2,zero,81117ba0 <vLoadDefaultETHConf+0x540>
81117b94:	e0bff947 	ldb	r2,-27(fp)
81117b98:	10800ed8 	cmpnei	r2,r2,59
81117b9c:	103fe81e 	bne	r2,zero,81117b40 <__reset+0xfb0f7b40>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117ba0:	e0bffa17 	ldw	r2,-24(fp)
81117ba4:	00c00284 	movi	r3,10
81117ba8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81117bac:	e0bff903 	ldbu	r2,-28(fp)
81117bb0:	108000e8 	cmpgeui	r2,r2,3
81117bb4:	1000021e 	bne	r2,zero,81117bc0 <vLoadDefaultETHConf+0x560>
81117bb8:	e43ff903 	ldbu	r16,-28(fp)
81117bbc:	00000106 	br	81117bc4 <vLoadDefaultETHConf+0x564>
81117bc0:	040000c4 	movi	r16,3
81117bc4:	e0bffd04 	addi	r2,fp,-12
81117bc8:	1009883a 	mov	r4,r2
81117bcc:	111d4b80 	call	8111d4b8 <atoi>
81117bd0:	1007883a 	mov	r3,r2
81117bd4:	00a045b4 	movhi	r2,33046
81117bd8:	108c5904 	addi	r2,r2,12644
81117bdc:	1405883a 	add	r2,r2,r16
81117be0:	10800204 	addi	r2,r2,8
81117be4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81117be8:	e0bffd04 	addi	r2,fp,-12
81117bec:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81117bf0:	e0bff903 	ldbu	r2,-28(fp)
81117bf4:	10800044 	addi	r2,r2,1
81117bf8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81117bfc:	e0bff947 	ldb	r2,-27(fp)
81117c00:	10800ed8 	cmpnei	r2,r2,59
81117c04:	103fce1e 	bne	r2,zero,81117b40 <__reset+0xfb0f7b40>

						break;
81117c08:	00009b06 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case 'D':

						ucParser = 0;
81117c0c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81117c10:	e0bffc0f 	ldh	r2,-16(fp)
81117c14:	1009883a 	mov	r4,r2
81117c18:	111b7d00 	call	8111b7d0 <cGetNextChar>
81117c1c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81117c20:	d0e00317 	ldw	r3,-32756(gp)
81117c24:	e0bff947 	ldb	r2,-27(fp)
81117c28:	10800044 	addi	r2,r2,1
81117c2c:	1885883a 	add	r2,r3,r2
81117c30:	10800003 	ldbu	r2,0(r2)
81117c34:	10803fcc 	andi	r2,r2,255
81117c38:	1080010c 	andi	r2,r2,4
81117c3c:	10000626 	beq	r2,zero,81117c58 <vLoadDefaultETHConf+0x5f8>
									(*p_inteiro) = c;
81117c40:	e0bffa17 	ldw	r2,-24(fp)
81117c44:	e0fff943 	ldbu	r3,-27(fp)
81117c48:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81117c4c:	e0bffa17 	ldw	r2,-24(fp)
81117c50:	10800044 	addi	r2,r2,1
81117c54:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81117c58:	e0bff947 	ldb	r2,-27(fp)
81117c5c:	10800ba0 	cmpeqi	r2,r2,46
81117c60:	1000031e 	bne	r2,zero,81117c70 <vLoadDefaultETHConf+0x610>
81117c64:	e0bff947 	ldb	r2,-27(fp)
81117c68:	10800ed8 	cmpnei	r2,r2,59
81117c6c:	103fe81e 	bne	r2,zero,81117c10 <__reset+0xfb0f7c10>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117c70:	e0bffa17 	ldw	r2,-24(fp)
81117c74:	00c00284 	movi	r3,10
81117c78:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
81117c7c:	e0bff903 	ldbu	r2,-28(fp)
81117c80:	108000e8 	cmpgeui	r2,r2,3
81117c84:	1000021e 	bne	r2,zero,81117c90 <vLoadDefaultETHConf+0x630>
81117c88:	e43ff903 	ldbu	r16,-28(fp)
81117c8c:	00000106 	br	81117c94 <vLoadDefaultETHConf+0x634>
81117c90:	040000c4 	movi	r16,3
81117c94:	e0bffd04 	addi	r2,fp,-12
81117c98:	1009883a 	mov	r4,r2
81117c9c:	111d4b80 	call	8111d4b8 <atoi>
81117ca0:	1007883a 	mov	r3,r2
81117ca4:	00a045b4 	movhi	r2,33046
81117ca8:	108c5904 	addi	r2,r2,12644
81117cac:	1405883a 	add	r2,r2,r16
81117cb0:	10800304 	addi	r2,r2,12
81117cb4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81117cb8:	e0bffd04 	addi	r2,fp,-12
81117cbc:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81117cc0:	e0bff903 	ldbu	r2,-28(fp)
81117cc4:	10800044 	addi	r2,r2,1
81117cc8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81117ccc:	e0bff947 	ldb	r2,-27(fp)
81117cd0:	10800ed8 	cmpnei	r2,r2,59
81117cd4:	103fce1e 	bne	r2,zero,81117c10 <__reset+0xfb0f7c10>

						break;						
81117cd8:	00006706 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case 'P':

						do {
							c = cGetNextChar(siFile);
81117cdc:	e0bffc0f 	ldh	r2,-16(fp)
81117ce0:	1009883a 	mov	r4,r2
81117ce4:	111b7d00 	call	8111b7d0 <cGetNextChar>
81117ce8:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81117cec:	d0e00317 	ldw	r3,-32756(gp)
81117cf0:	e0bff947 	ldb	r2,-27(fp)
81117cf4:	10800044 	addi	r2,r2,1
81117cf8:	1885883a 	add	r2,r3,r2
81117cfc:	10800003 	ldbu	r2,0(r2)
81117d00:	10803fcc 	andi	r2,r2,255
81117d04:	1080010c 	andi	r2,r2,4
81117d08:	10000626 	beq	r2,zero,81117d24 <vLoadDefaultETHConf+0x6c4>
								(*p_inteiro) = c;
81117d0c:	e0bffa17 	ldw	r2,-24(fp)
81117d10:	e0fff943 	ldbu	r3,-27(fp)
81117d14:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81117d18:	e0bffa17 	ldw	r2,-24(fp)
81117d1c:	10800044 	addi	r2,r2,1
81117d20:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81117d24:	e0bff947 	ldb	r2,-27(fp)
81117d28:	10800ed8 	cmpnei	r2,r2,59
81117d2c:	103feb1e 	bne	r2,zero,81117cdc <__reset+0xfb0f7cdc>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117d30:	e0bffa17 	ldw	r2,-24(fp)
81117d34:	00c00284 	movi	r3,10
81117d38:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81117d3c:	e0bffd04 	addi	r2,fp,-12
81117d40:	1009883a 	mov	r4,r2
81117d44:	111d4b80 	call	8111d4b8 <atoi>
81117d48:	1007883a 	mov	r3,r2
81117d4c:	00a045b4 	movhi	r2,33046
81117d50:	108c5904 	addi	r2,r2,12644
81117d54:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81117d58:	e0bffd04 	addi	r2,fp,-12
81117d5c:	e0bffa15 	stw	r2,-24(fp)

						break;
81117d60:	00004506 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case 'H':

						do {
							c = cGetNextChar(siFile);
81117d64:	e0bffc0f 	ldh	r2,-16(fp)
81117d68:	1009883a 	mov	r4,r2
81117d6c:	111b7d00 	call	8111b7d0 <cGetNextChar>
81117d70:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81117d74:	d0e00317 	ldw	r3,-32756(gp)
81117d78:	e0bff947 	ldb	r2,-27(fp)
81117d7c:	10800044 	addi	r2,r2,1
81117d80:	1885883a 	add	r2,r3,r2
81117d84:	10800003 	ldbu	r2,0(r2)
81117d88:	10803fcc 	andi	r2,r2,255
81117d8c:	1080010c 	andi	r2,r2,4
81117d90:	10000626 	beq	r2,zero,81117dac <vLoadDefaultETHConf+0x74c>
								(*p_inteiro) = c;
81117d94:	e0bffa17 	ldw	r2,-24(fp)
81117d98:	e0fff943 	ldbu	r3,-27(fp)
81117d9c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81117da0:	e0bffa17 	ldw	r2,-24(fp)
81117da4:	10800044 	addi	r2,r2,1
81117da8:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81117dac:	e0bff947 	ldb	r2,-27(fp)
81117db0:	10800ed8 	cmpnei	r2,r2,59
81117db4:	103feb1e 	bne	r2,zero,81117d64 <__reset+0xfb0f7d64>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117db8:	e0bffa17 	ldw	r2,-24(fp)
81117dbc:	00c00284 	movi	r3,10
81117dc0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81117dc4:	e0bffd04 	addi	r2,fp,-12
81117dc8:	1009883a 	mov	r4,r2
81117dcc:	111d4b80 	call	8111d4b8 <atoi>
81117dd0:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81117dd4:	e0bffc8f 	ldh	r2,-14(fp)
81117dd8:	10800058 	cmpnei	r2,r2,1
81117ddc:	1000051e 	bne	r2,zero,81117df4 <vLoadDefaultETHConf+0x794>
							xConfEth.bDHCP = TRUE;
81117de0:	00a045b4 	movhi	r2,33046
81117de4:	108c5904 	addi	r2,r2,12644
81117de8:	00c00044 	movi	r3,1
81117dec:	10c00615 	stw	r3,24(r2)
81117df0:	00000306 	br	81117e00 <vLoadDefaultETHConf+0x7a0>
						else
							xConfEth.bDHCP = FALSE;
81117df4:	00a045b4 	movhi	r2,33046
81117df8:	108c5904 	addi	r2,r2,12644
81117dfc:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81117e00:	e0bffd04 	addi	r2,fp,-12
81117e04:	e0bffa15 	stw	r2,-24(fp)

						break;
81117e08:	00001b06 	br	81117e78 <vLoadDefaultETHConf+0x818>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81117e0c:	e0bffc0f 	ldh	r2,-16(fp)
81117e10:	1009883a 	mov	r4,r2
81117e14:	111b7900 	call	8111b790 <siCloseFile>
81117e18:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81117e1c:	e0bffb17 	ldw	r2,-20(fp)
81117e20:	1000071e 	bne	r2,zero,81117e40 <vLoadDefaultETHConf+0x7e0>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81117e24:	d0a06117 	ldw	r2,-32380(gp)
81117e28:	100f883a 	mov	r7,r2
81117e2c:	01800784 	movi	r6,30
81117e30:	01400044 	movi	r5,1
81117e34:	01204574 	movhi	r4,33045
81117e38:	212c0404 	addi	r4,r4,-20464
81117e3c:	111dcb00 	call	8111dcb0 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81117e40:	00800044 	movi	r2,1
81117e44:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81117e48:	00800044 	movi	r2,1
81117e4c:	e0bff715 	stw	r2,-36(fp)
						break;
81117e50:	00000906 	br	81117e78 <vLoadDefaultETHConf+0x818>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
81117e54:	d0a06117 	ldw	r2,-32380(gp)
81117e58:	100f883a 	mov	r7,r2
81117e5c:	01800844 	movi	r6,33
81117e60:	01400044 	movi	r5,1
81117e64:	01204574 	movhi	r4,33045
81117e68:	212c0c04 	addi	r4,r4,-20432
81117e6c:	111dcb00 	call	8111dcb0 <fwrite>
						#endif
						break;
81117e70:	00000106 	br	81117e78 <vLoadDefaultETHConf+0x818>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81117e74:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81117e78:	e0bff817 	ldw	r2,-32(fp)
81117e7c:	103e1626 	beq	r2,zero,811176d8 <__reset+0xfb0f76d8>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81117e80:	00000f06 	br	81117ec0 <vLoadDefaultETHConf+0x860>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
81117e84:	d0a06117 	ldw	r2,-32380(gp)
81117e88:	100f883a 	mov	r7,r2
81117e8c:	01800604 	movi	r6,24
81117e90:	01400044 	movi	r5,1
81117e94:	01204574 	movhi	r4,33045
81117e98:	212c1504 	addi	r4,r4,-20396
81117e9c:	111dcb00 	call	8111dcb0 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81117ea0:	00000706 	br	81117ec0 <vLoadDefaultETHConf+0x860>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
81117ea4:	d0a06117 	ldw	r2,-32380(gp)
81117ea8:	100f883a 	mov	r7,r2
81117eac:	018004c4 	movi	r6,19
81117eb0:	01400044 	movi	r5,1
81117eb4:	01204574 	movhi	r4,33045
81117eb8:	212c1c04 	addi	r4,r4,-20368
81117ebc:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81117ec0:	e0bff717 	ldw	r2,-36(fp)
81117ec4:	1000541e 	bne	r2,zero,81118018 <vLoadDefaultETHConf+0x9b8>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81117ec8:	01204574 	movhi	r4,33045
81117ecc:	212c2104 	addi	r4,r4,-20348
81117ed0:	111ec600 	call	8111ec60 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81117ed4:	01604574 	movhi	r5,33045
81117ed8:	296bfb04 	addi	r5,r5,-20500
81117edc:	01204574 	movhi	r4,33045
81117ee0:	212c3504 	addi	r4,r4,-20268
81117ee4:	111e9dc0 	call	8111e9dc <printf>


		xConfEth.siPortPUS = 17000;
81117ee8:	00a045b4 	movhi	r2,33046
81117eec:	108c5904 	addi	r2,r2,12644
81117ef0:	00d09a04 	movi	r3,17000
81117ef4:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
81117ef8:	00a045b4 	movhi	r2,33046
81117efc:	108c5904 	addi	r2,r2,12644
81117f00:	00fff004 	movi	r3,-64
81117f04:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
81117f08:	00a045b4 	movhi	r2,33046
81117f0c:	108c5904 	addi	r2,r2,12644
81117f10:	00ffea04 	movi	r3,-88
81117f14:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
81117f18:	00a045b4 	movhi	r2,33046
81117f1c:	108c5904 	addi	r2,r2,12644
81117f20:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81117f24:	00a045b4 	movhi	r2,33046
81117f28:	108c5904 	addi	r2,r2,12644
81117f2c:	00c00144 	movi	r3,5
81117f30:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81117f34:	00a045b4 	movhi	r2,33046
81117f38:	108c5904 	addi	r2,r2,12644
81117f3c:	00fff004 	movi	r3,-64
81117f40:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81117f44:	00a045b4 	movhi	r2,33046
81117f48:	108c5904 	addi	r2,r2,12644
81117f4c:	00ffea04 	movi	r3,-88
81117f50:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
81117f54:	00a045b4 	movhi	r2,33046
81117f58:	108c5904 	addi	r2,r2,12644
81117f5c:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81117f60:	00a045b4 	movhi	r2,33046
81117f64:	108c5904 	addi	r2,r2,12644
81117f68:	00c00044 	movi	r3,1
81117f6c:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81117f70:	00a045b4 	movhi	r2,33046
81117f74:	108c5904 	addi	r2,r2,12644
81117f78:	00ffffc4 	movi	r3,-1
81117f7c:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
81117f80:	00a045b4 	movhi	r2,33046
81117f84:	108c5904 	addi	r2,r2,12644
81117f88:	00ffffc4 	movi	r3,-1
81117f8c:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
81117f90:	00a045b4 	movhi	r2,33046
81117f94:	108c5904 	addi	r2,r2,12644
81117f98:	00ffffc4 	movi	r3,-1
81117f9c:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
81117fa0:	00a045b4 	movhi	r2,33046
81117fa4:	108c5904 	addi	r2,r2,12644
81117fa8:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
81117fac:	00a045b4 	movhi	r2,33046
81117fb0:	108c5904 	addi	r2,r2,12644
81117fb4:	00ffff04 	movi	r3,-4
81117fb8:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
81117fbc:	00a045b4 	movhi	r2,33046
81117fc0:	108c5904 	addi	r2,r2,12644
81117fc4:	00fffdc4 	movi	r3,-9
81117fc8:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
81117fcc:	00a045b4 	movhi	r2,33046
81117fd0:	108c5904 	addi	r2,r2,12644
81117fd4:	00c018c4 	movi	r3,99
81117fd8:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
81117fdc:	00a045b4 	movhi	r2,33046
81117fe0:	108c5904 	addi	r2,r2,12644
81117fe4:	00c01344 	movi	r3,77
81117fe8:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
81117fec:	00a045b4 	movhi	r2,33046
81117ff0:	108c5904 	addi	r2,r2,12644
81117ff4:	00c007c4 	movi	r3,31
81117ff8:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
81117ffc:	00a045b4 	movhi	r2,33046
81118000:	108c5904 	addi	r2,r2,12644
81118004:	00c01084 	movi	r3,66
81118008:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111800c:	00a045b4 	movhi	r2,33046
81118010:	108c5904 	addi	r2,r2,12644
81118014:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
81118018:	e0bff717 	ldw	r2,-36(fp)
}
8111801c:	e6ffff04 	addi	sp,fp,-4
81118020:	dfc00217 	ldw	ra,8(sp)
81118024:	df000117 	ldw	fp,4(sp)
81118028:	dc000017 	ldw	r16,0(sp)
8111802c:	dec00304 	addi	sp,sp,12
81118030:	f800283a 	ret

81118034 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
81118034:	defff004 	addi	sp,sp,-64
81118038:	de00012e 	bgeu	sp,et,81118040 <vShowEthConfig+0xc>
8111803c:	003b68fa 	trap	3
81118040:	dfc00f15 	stw	ra,60(sp)
81118044:	df000e15 	stw	fp,56(sp)
81118048:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111804c:	d0a06117 	ldw	r2,-32380(gp)
81118050:	100f883a 	mov	r7,r2
81118054:	018007c4 	movi	r6,31
81118058:	01400044 	movi	r5,1
8111805c:	01204574 	movhi	r4,33045
81118060:	212c3b04 	addi	r4,r4,-20244
81118064:	111dcb00 	call	8111dcb0 <fwrite>

		memset(buffer,0,40);
81118068:	01800a04 	movi	r6,40
8111806c:	000b883a 	mov	r5,zero
81118070:	e13ff604 	addi	r4,fp,-40
81118074:	111e8140 	call	8111e814 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
81118078:	00a045b4 	movhi	r2,33046
8111807c:	108c5904 	addi	r2,r2,12644
81118080:	10800403 	ldbu	r2,16(r2)
81118084:	11803fcc 	andi	r6,r2,255
81118088:	00a045b4 	movhi	r2,33046
8111808c:	108c5904 	addi	r2,r2,12644
81118090:	10800443 	ldbu	r2,17(r2)
81118094:	11c03fcc 	andi	r7,r2,255
81118098:	00a045b4 	movhi	r2,33046
8111809c:	108c5904 	addi	r2,r2,12644
811180a0:	10800483 	ldbu	r2,18(r2)
811180a4:	10c03fcc 	andi	r3,r2,255
811180a8:	00a045b4 	movhi	r2,33046
811180ac:	108c5904 	addi	r2,r2,12644
811180b0:	108004c3 	ldbu	r2,19(r2)
811180b4:	11003fcc 	andi	r4,r2,255
811180b8:	00a045b4 	movhi	r2,33046
811180bc:	108c5904 	addi	r2,r2,12644
811180c0:	10800503 	ldbu	r2,20(r2)
811180c4:	11403fcc 	andi	r5,r2,255
811180c8:	00a045b4 	movhi	r2,33046
811180cc:	108c5904 	addi	r2,r2,12644
811180d0:	10800543 	ldbu	r2,21(r2)
811180d4:	10803fcc 	andi	r2,r2,255
811180d8:	d8800315 	stw	r2,12(sp)
811180dc:	d9400215 	stw	r5,8(sp)
811180e0:	d9000115 	stw	r4,4(sp)
811180e4:	d8c00015 	stw	r3,0(sp)
811180e8:	01604574 	movhi	r5,33045
811180ec:	296c4304 	addi	r5,r5,-20212
811180f0:	e13ff604 	addi	r4,fp,-40
811180f4:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, buffer );
811180f8:	d0a06117 	ldw	r2,-32380(gp)
811180fc:	e17ff604 	addi	r5,fp,-40
81118100:	1009883a 	mov	r4,r2
81118104:	111d6140 	call	8111d614 <fprintf>

		memset(buffer,0,40);
81118108:	01800a04 	movi	r6,40
8111810c:	000b883a 	mov	r5,zero
81118110:	e13ff604 	addi	r4,fp,-40
81118114:	111e8140 	call	8111e814 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
81118118:	00a045b4 	movhi	r2,33046
8111811c:	108c5904 	addi	r2,r2,12644
81118120:	10800003 	ldbu	r2,0(r2)
81118124:	11003fcc 	andi	r4,r2,255
81118128:	00a045b4 	movhi	r2,33046
8111812c:	108c5904 	addi	r2,r2,12644
81118130:	10800043 	ldbu	r2,1(r2)
81118134:	11403fcc 	andi	r5,r2,255
81118138:	00a045b4 	movhi	r2,33046
8111813c:	108c5904 	addi	r2,r2,12644
81118140:	10800083 	ldbu	r2,2(r2)
81118144:	10c03fcc 	andi	r3,r2,255
81118148:	00a045b4 	movhi	r2,33046
8111814c:	108c5904 	addi	r2,r2,12644
81118150:	108000c3 	ldbu	r2,3(r2)
81118154:	10803fcc 	andi	r2,r2,255
81118158:	d8800115 	stw	r2,4(sp)
8111815c:	d8c00015 	stw	r3,0(sp)
81118160:	280f883a 	mov	r7,r5
81118164:	200d883a 	mov	r6,r4
81118168:	01604574 	movhi	r5,33045
8111816c:	296c4c04 	addi	r5,r5,-20176
81118170:	e13ff604 	addi	r4,fp,-40
81118174:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, buffer );
81118178:	d0a06117 	ldw	r2,-32380(gp)
8111817c:	e17ff604 	addi	r5,fp,-40
81118180:	1009883a 	mov	r4,r2
81118184:	111d6140 	call	8111d614 <fprintf>

		memset(buffer,0,40);
81118188:	01800a04 	movi	r6,40
8111818c:	000b883a 	mov	r5,zero
81118190:	e13ff604 	addi	r4,fp,-40
81118194:	111e8140 	call	8111e814 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
81118198:	00a045b4 	movhi	r2,33046
8111819c:	108c5904 	addi	r2,r2,12644
811181a0:	10800103 	ldbu	r2,4(r2)
811181a4:	11003fcc 	andi	r4,r2,255
811181a8:	00a045b4 	movhi	r2,33046
811181ac:	108c5904 	addi	r2,r2,12644
811181b0:	10800143 	ldbu	r2,5(r2)
811181b4:	11403fcc 	andi	r5,r2,255
811181b8:	00a045b4 	movhi	r2,33046
811181bc:	108c5904 	addi	r2,r2,12644
811181c0:	10800183 	ldbu	r2,6(r2)
811181c4:	10c03fcc 	andi	r3,r2,255
811181c8:	00a045b4 	movhi	r2,33046
811181cc:	108c5904 	addi	r2,r2,12644
811181d0:	108001c3 	ldbu	r2,7(r2)
811181d4:	10803fcc 	andi	r2,r2,255
811181d8:	d8800115 	stw	r2,4(sp)
811181dc:	d8c00015 	stw	r3,0(sp)
811181e0:	280f883a 	mov	r7,r5
811181e4:	200d883a 	mov	r6,r4
811181e8:	01604574 	movhi	r5,33045
811181ec:	296c5204 	addi	r5,r5,-20152
811181f0:	e13ff604 	addi	r4,fp,-40
811181f4:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, buffer );
811181f8:	d0a06117 	ldw	r2,-32380(gp)
811181fc:	e17ff604 	addi	r5,fp,-40
81118200:	1009883a 	mov	r4,r2
81118204:	111d6140 	call	8111d614 <fprintf>

		memset(buffer,0,40);
81118208:	01800a04 	movi	r6,40
8111820c:	000b883a 	mov	r5,zero
81118210:	e13ff604 	addi	r4,fp,-40
81118214:	111e8140 	call	8111e814 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
81118218:	00a045b4 	movhi	r2,33046
8111821c:	108c5904 	addi	r2,r2,12644
81118220:	10800203 	ldbu	r2,8(r2)
81118224:	11003fcc 	andi	r4,r2,255
81118228:	00a045b4 	movhi	r2,33046
8111822c:	108c5904 	addi	r2,r2,12644
81118230:	10800243 	ldbu	r2,9(r2)
81118234:	11403fcc 	andi	r5,r2,255
81118238:	00a045b4 	movhi	r2,33046
8111823c:	108c5904 	addi	r2,r2,12644
81118240:	10800283 	ldbu	r2,10(r2)
81118244:	10c03fcc 	andi	r3,r2,255
81118248:	00a045b4 	movhi	r2,33046
8111824c:	108c5904 	addi	r2,r2,12644
81118250:	108002c3 	ldbu	r2,11(r2)
81118254:	10803fcc 	andi	r2,r2,255
81118258:	d8800115 	stw	r2,4(sp)
8111825c:	d8c00015 	stw	r3,0(sp)
81118260:	280f883a 	mov	r7,r5
81118264:	200d883a 	mov	r6,r4
81118268:	01604574 	movhi	r5,33045
8111826c:	296c5904 	addi	r5,r5,-20124
81118270:	e13ff604 	addi	r4,fp,-40
81118274:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, buffer );
81118278:	d0a06117 	ldw	r2,-32380(gp)
8111827c:	e17ff604 	addi	r5,fp,-40
81118280:	1009883a 	mov	r4,r2
81118284:	111d6140 	call	8111d614 <fprintf>

		memset(buffer,0,40);
81118288:	01800a04 	movi	r6,40
8111828c:	000b883a 	mov	r5,zero
81118290:	e13ff604 	addi	r4,fp,-40
81118294:	111e8140 	call	8111e814 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
81118298:	00a045b4 	movhi	r2,33046
8111829c:	108c5904 	addi	r2,r2,12644
811182a0:	10800303 	ldbu	r2,12(r2)
811182a4:	11003fcc 	andi	r4,r2,255
811182a8:	00a045b4 	movhi	r2,33046
811182ac:	108c5904 	addi	r2,r2,12644
811182b0:	10800343 	ldbu	r2,13(r2)
811182b4:	11403fcc 	andi	r5,r2,255
811182b8:	00a045b4 	movhi	r2,33046
811182bc:	108c5904 	addi	r2,r2,12644
811182c0:	10800383 	ldbu	r2,14(r2)
811182c4:	10c03fcc 	andi	r3,r2,255
811182c8:	00a045b4 	movhi	r2,33046
811182cc:	108c5904 	addi	r2,r2,12644
811182d0:	108003c3 	ldbu	r2,15(r2)
811182d4:	10803fcc 	andi	r2,r2,255
811182d8:	d8800115 	stw	r2,4(sp)
811182dc:	d8c00015 	stw	r3,0(sp)
811182e0:	280f883a 	mov	r7,r5
811182e4:	200d883a 	mov	r6,r4
811182e8:	01604574 	movhi	r5,33045
811182ec:	296c6004 	addi	r5,r5,-20096
811182f0:	e13ff604 	addi	r4,fp,-40
811182f4:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, buffer );
811182f8:	d0a06117 	ldw	r2,-32380(gp)
811182fc:	e17ff604 	addi	r5,fp,-40
81118300:	1009883a 	mov	r4,r2
81118304:	111d6140 	call	8111d614 <fprintf>

		memset(buffer,0,40);
81118308:	01800a04 	movi	r6,40
8111830c:	000b883a 	mov	r5,zero
81118310:	e13ff604 	addi	r4,fp,-40
81118314:	111e8140 	call	8111e814 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
81118318:	00a045b4 	movhi	r2,33046
8111831c:	108c5904 	addi	r2,r2,12644
81118320:	1080058b 	ldhu	r2,22(r2)
81118324:	10bfffcc 	andi	r2,r2,65535
81118328:	100d883a 	mov	r6,r2
8111832c:	01604574 	movhi	r5,33045
81118330:	296c6704 	addi	r5,r5,-20068
81118334:	e13ff604 	addi	r4,fp,-40
81118338:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, buffer );
8111833c:	d0a06117 	ldw	r2,-32380(gp)
81118340:	e17ff604 	addi	r5,fp,-40
81118344:	1009883a 	mov	r4,r2
81118348:	111d6140 	call	8111d614 <fprintf>

	}
8111834c:	0001883a 	nop
81118350:	e037883a 	mov	sp,fp
81118354:	dfc00117 	ldw	ra,4(sp)
81118358:	df000017 	ldw	fp,0(sp)
8111835c:	dec00204 	addi	sp,sp,8
81118360:	f800283a 	ret

81118364 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
81118364:	defffb04 	addi	sp,sp,-20
81118368:	de00012e 	bgeu	sp,et,81118370 <ucCrc8+0xc>
8111836c:	003b68fa 	trap	3
81118370:	df000415 	stw	fp,16(sp)
81118374:	df000404 	addi	fp,sp,16
81118378:	e13ffd15 	stw	r4,-12(fp)
8111837c:	e17ffe15 	stw	r5,-8(fp)
81118380:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
81118384:	e0bffe17 	ldw	r2,-8(fp)
81118388:	1000021e 	bne	r2,zero,81118394 <ucCrc8+0x30>
        return 0;
8111838c:	0005883a 	mov	r2,zero
81118390:	00001906 	br	811183f8 <ucCrc8+0x94>
    crc &= 0xff;
81118394:	e0bffd17 	ldw	r2,-12(fp)
81118398:	10803fcc 	andi	r2,r2,255
8111839c:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
811183a0:	e0fffe17 	ldw	r3,-8(fp)
811183a4:	e0bfff17 	ldw	r2,-4(fp)
811183a8:	1885883a 	add	r2,r3,r2
811183ac:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
811183b0:	00000d06 	br	811183e8 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
811183b4:	e0bffe17 	ldw	r2,-8(fp)
811183b8:	10c00044 	addi	r3,r2,1
811183bc:	e0fffe15 	stw	r3,-8(fp)
811183c0:	10800003 	ldbu	r2,0(r2)
811183c4:	10c03fcc 	andi	r3,r2,255
811183c8:	e0bffd17 	ldw	r2,-12(fp)
811183cc:	1886f03a 	xor	r3,r3,r2
811183d0:	00a04574 	movhi	r2,33045
811183d4:	10ac6ac4 	addi	r2,r2,-20053
811183d8:	10c5883a 	add	r2,r2,r3
811183dc:	10800003 	ldbu	r2,0(r2)
811183e0:	10803fcc 	andi	r2,r2,255
811183e4:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
811183e8:	e0fffe17 	ldw	r3,-8(fp)
811183ec:	e0bffc17 	ldw	r2,-16(fp)
811183f0:	18bff036 	bltu	r3,r2,811183b4 <__reset+0xfb0f83b4>
        crc = crc8_table[crc ^ *data++];
    return crc;
811183f4:	e0bffd17 	ldw	r2,-12(fp)
}
811183f8:	e037883a 	mov	sp,fp
811183fc:	df000017 	ldw	fp,0(sp)
81118400:	dec00104 	addi	sp,sp,4
81118404:	f800283a 	ret

81118408 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
81118408:	defffb04 	addi	sp,sp,-20
8111840c:	de00012e 	bgeu	sp,et,81118414 <ucCrc8wInit+0xc>
81118410:	003b68fa 	trap	3
81118414:	dfc00415 	stw	ra,16(sp)
81118418:	df000315 	stw	fp,12(sp)
8111841c:	df000304 	addi	fp,sp,12
81118420:	e13ffe15 	stw	r4,-8(fp)
81118424:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
81118428:	000d883a 	mov	r6,zero
8111842c:	000b883a 	mov	r5,zero
81118430:	0009883a 	mov	r4,zero
81118434:	11183640 	call	81118364 <ucCrc8>
81118438:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111843c:	e0bffd03 	ldbu	r2,-12(fp)
81118440:	e1bfff17 	ldw	r6,-4(fp)
81118444:	e17ffe17 	ldw	r5,-8(fp)
81118448:	1009883a 	mov	r4,r2
8111844c:	11183640 	call	81118364 <ucCrc8>
}
81118450:	e037883a 	mov	sp,fp
81118454:	dfc00117 	ldw	ra,4(sp)
81118458:	df000017 	ldw	fp,0(sp)
8111845c:	dec00204 	addi	sp,sp,8
81118460:	f800283a 	ret

81118464 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
81118464:	defffc04 	addi	sp,sp,-16
81118468:	de00012e 	bgeu	sp,et,81118470 <vDataControllerInit+0xc>
8111846c:	003b68fa 	trap	3
81118470:	df000315 	stw	fp,12(sp)
81118474:	df000304 	addi	fp,sp,12
81118478:	e13ffe15 	stw	r4,-8(fp)
8111847c:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
81118480:	e0bffe17 	ldw	r2,-8(fp)
81118484:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81118488:	e03ffd05 	stb	zero,-12(fp)
8111848c:	00001c06 	br	81118500 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
81118490:	e0bffd03 	ldbu	r2,-12(fp)
81118494:	e0fffd03 	ldbu	r3,-12(fp)
81118498:	18c09624 	muli	r3,r3,600
8111849c:	e13fff17 	ldw	r4,-4(fp)
811184a0:	20c7883a 	add	r3,r4,r3
811184a4:	e13ffe17 	ldw	r4,-8(fp)
811184a8:	10800084 	addi	r2,r2,2
811184ac:	1085883a 	add	r2,r2,r2
811184b0:	1085883a 	add	r2,r2,r2
811184b4:	2085883a 	add	r2,r4,r2
811184b8:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
811184bc:	e17ffd03 	ldbu	r5,-12(fp)
811184c0:	e0bffd03 	ldbu	r2,-12(fp)
811184c4:	e0ffff17 	ldw	r3,-4(fp)
811184c8:	108025c4 	addi	r2,r2,151
811184cc:	1085883a 	add	r2,r2,r2
811184d0:	1085883a 	add	r2,r2,r2
811184d4:	1885883a 	add	r2,r3,r2
811184d8:	10c00017 	ldw	r3,0(r2)
811184dc:	e13ffe17 	ldw	r4,-8(fp)
811184e0:	288000c4 	addi	r2,r5,3
811184e4:	1085883a 	add	r2,r2,r2
811184e8:	1085883a 	add	r2,r2,r2
811184ec:	2085883a 	add	r2,r4,r2
811184f0:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
811184f4:	e0bffd03 	ldbu	r2,-12(fp)
811184f8:	10800044 	addi	r2,r2,1
811184fc:	e0bffd05 	stb	r2,-12(fp)
81118500:	e0bffd03 	ldbu	r2,-12(fp)
81118504:	103fe226 	beq	r2,zero,81118490 <__reset+0xfb0f8490>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
81118508:	e0bfff17 	ldw	r2,-4(fp)
8111850c:	10c09904 	addi	r3,r2,612
81118510:	e0bffe17 	ldw	r2,-8(fp)
81118514:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
81118518:	e0bffe17 	ldw	r2,-8(fp)
8111851c:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
81118520:	e0bffe17 	ldw	r2,-8(fp)
81118524:	10c00504 	addi	r3,r2,20
81118528:	e0bfff17 	ldw	r2,-4(fp)
8111852c:	10c09b15 	stw	r3,620(r2)
}
81118530:	0001883a 	nop
81118534:	e037883a 	mov	sp,fp
81118538:	df000017 	ldw	fp,0(sp)
8111853c:	dec00104 	addi	sp,sp,4
81118540:	f800283a 	ret

81118544 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
81118544:	defff904 	addi	sp,sp,-28
81118548:	de00012e 	bgeu	sp,et,81118550 <printErrorTask+0xc>
8111854c:	003b68fa 	trap	3
81118550:	dfc00615 	stw	ra,24(sp)
81118554:	df000515 	stw	fp,20(sp)
81118558:	df000504 	addi	fp,sp,20
8111855c:	2005883a 	mov	r2,r4
81118560:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
81118564:	e03ffb15 	stw	zero,-20(fp)
81118568:	e03ffc15 	stw	zero,-16(fp)
8111856c:	e03ffd15 	stw	zero,-12(fp)
81118570:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
81118574:	e0bfff03 	ldbu	r2,-4(fp)
81118578:	100d883a 	mov	r6,r2
8111857c:	01604574 	movhi	r5,33045
81118580:	296cab04 	addi	r5,r5,-19796
81118584:	e13ffb04 	addi	r4,fp,-20
81118588:	111efa40 	call	8111efa4 <sprintf>
		debug(fp, buffer);
8111858c:	d0a06117 	ldw	r2,-32380(gp)
81118590:	e17ffb04 	addi	r5,fp,-20
81118594:	1009883a 	mov	r4,r2
81118598:	111d6140 	call	8111d614 <fprintf>
	}
8111859c:	0001883a 	nop
811185a0:	e037883a 	mov	sp,fp
811185a4:	dfc00117 	ldw	ra,4(sp)
811185a8:	df000017 	ldw	fp,0(sp)
811185ac:	dec00204 	addi	sp,sp,8
811185b0:	f800283a 	ret

811185b4 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
811185b4:	defffd04 	addi	sp,sp,-12
811185b8:	de00012e 	bgeu	sp,et,811185c0 <vFailCreateMutexSResources+0xc>
811185bc:	003b68fa 	trap	3
811185c0:	dfc00215 	stw	ra,8(sp)
811185c4:	df000115 	stw	fp,4(sp)
811185c8:	df000104 	addi	fp,sp,4
811185cc:	2005883a 	mov	r2,r4
811185d0:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
811185d4:	d0a06117 	ldw	r2,-32380(gp)
811185d8:	100f883a 	mov	r7,r2
811185dc:	018008c4 	movi	r6,35
811185e0:	01400044 	movi	r5,1
811185e4:	01204574 	movhi	r4,33045
811185e8:	212cae04 	addi	r4,r4,-19784
811185ec:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
811185f0:	e0bfff03 	ldbu	r2,-4(fp)
811185f4:	1009883a 	mov	r4,r2
811185f8:	11185440 	call	81118544 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811185fc:	0001883a 	nop
81118600:	e037883a 	mov	sp,fp
81118604:	dfc00117 	ldw	ra,4(sp)
81118608:	df000017 	ldw	fp,0(sp)
8111860c:	dec00204 	addi	sp,sp,8
81118610:	f800283a 	ret

81118614 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
81118614:	defffe04 	addi	sp,sp,-8
81118618:	de00012e 	bgeu	sp,et,81118620 <vFailCreateMutexDMA+0xc>
8111861c:	003b68fa 	trap	3
81118620:	dfc00115 	stw	ra,4(sp)
81118624:	df000015 	stw	fp,0(sp)
81118628:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111862c:	d0a06117 	ldw	r2,-32380(gp)
81118630:	100f883a 	mov	r7,r2
81118634:	018009c4 	movi	r6,39
81118638:	01400044 	movi	r5,1
8111863c:	01204574 	movhi	r4,33045
81118640:	212cb704 	addi	r4,r4,-19748
81118644:	111dcb00 	call	8111dcb0 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118648:	0001883a 	nop
8111864c:	e037883a 	mov	sp,fp
81118650:	dfc00117 	ldw	ra,4(sp)
81118654:	df000017 	ldw	fp,0(sp)
81118658:	dec00204 	addi	sp,sp,8
8111865c:	f800283a 	ret

81118660 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
81118660:	defffe04 	addi	sp,sp,-8
81118664:	de00012e 	bgeu	sp,et,8111866c <vFailCreateSemaphoreResources+0xc>
81118668:	003b68fa 	trap	3
8111866c:	dfc00115 	stw	ra,4(sp)
81118670:	df000015 	stw	fp,0(sp)
81118674:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
81118678:	d0a06117 	ldw	r2,-32380(gp)
8111867c:	100f883a 	mov	r7,r2
81118680:	01800984 	movi	r6,38
81118684:	01400044 	movi	r5,1
81118688:	01204574 	movhi	r4,33045
8111868c:	212cc104 	addi	r4,r4,-19708
81118690:	111dcb00 	call	8111dcb0 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118694:	0001883a 	nop
81118698:	e037883a 	mov	sp,fp
8111869c:	dfc00117 	ldw	ra,4(sp)
811186a0:	df000017 	ldw	fp,0(sp)
811186a4:	dec00204 	addi	sp,sp,8
811186a8:	f800283a 	ret

811186ac <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
811186ac:	defffe04 	addi	sp,sp,-8
811186b0:	de00012e 	bgeu	sp,et,811186b8 <vFailTestCriticasParts+0xc>
811186b4:	003b68fa 	trap	3
811186b8:	dfc00115 	stw	ra,4(sp)
811186bc:	df000015 	stw	fp,0(sp)
811186c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
811186c4:	d0a06117 	ldw	r2,-32380(gp)
811186c8:	100f883a 	mov	r7,r2
811186cc:	018007c4 	movi	r6,31
811186d0:	01400044 	movi	r5,1
811186d4:	01204574 	movhi	r4,33045
811186d8:	212ccb04 	addi	r4,r4,-19668
811186dc:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811186e0:	0001883a 	nop
811186e4:	e037883a 	mov	sp,fp
811186e8:	dfc00117 	ldw	ra,4(sp)
811186ec:	df000017 	ldw	fp,0(sp)
811186f0:	dec00204 	addi	sp,sp,8
811186f4:	f800283a 	ret

811186f8 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
811186f8:	defffe04 	addi	sp,sp,-8
811186fc:	de00012e 	bgeu	sp,et,81118704 <vFailSendxSemCommInit+0xc>
81118700:	003b68fa 	trap	3
81118704:	dfc00115 	stw	ra,4(sp)
81118708:	df000015 	stw	fp,0(sp)
8111870c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
81118710:	d0a06117 	ldw	r2,-32380(gp)
81118714:	100f883a 	mov	r7,r2
81118718:	01800744 	movi	r6,29
8111871c:	01400044 	movi	r5,1
81118720:	01204574 	movhi	r4,33045
81118724:	212cd304 	addi	r4,r4,-19636
81118728:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111872c:	d0a06117 	ldw	r2,-32380(gp)
81118730:	100f883a 	mov	r7,r2
81118734:	01800a44 	movi	r6,41
81118738:	01400044 	movi	r5,1
8111873c:	01204574 	movhi	r4,33045
81118740:	212cdb04 	addi	r4,r4,-19604
81118744:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118748:	0001883a 	nop
8111874c:	e037883a 	mov	sp,fp
81118750:	dfc00117 	ldw	ra,4(sp)
81118754:	df000017 	ldw	fp,0(sp)
81118758:	dec00204 	addi	sp,sp,8
8111875c:	f800283a 	ret

81118760 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
81118760:	defffe04 	addi	sp,sp,-8
81118764:	de00012e 	bgeu	sp,et,8111876c <vFailSendPreParsedSemaphore+0xc>
81118768:	003b68fa 	trap	3
8111876c:	dfc00115 	stw	ra,4(sp)
81118770:	df000015 	stw	fp,0(sp)
81118774:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
81118778:	d0a06117 	ldw	r2,-32380(gp)
8111877c:	100f883a 	mov	r7,r2
81118780:	01800904 	movi	r6,36
81118784:	01400044 	movi	r5,1
81118788:	01204574 	movhi	r4,33045
8111878c:	212ce604 	addi	r4,r4,-19560
81118790:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118794:	0001883a 	nop
81118798:	e037883a 	mov	sp,fp
8111879c:	dfc00117 	ldw	ra,4(sp)
811187a0:	df000017 	ldw	fp,0(sp)
811187a4:	dec00204 	addi	sp,sp,8
811187a8:	f800283a 	ret

811187ac <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
811187ac:	defffe04 	addi	sp,sp,-8
811187b0:	de00012e 	bgeu	sp,et,811187b8 <vFailSendPreAckReceiverSemaphore+0xc>
811187b4:	003b68fa 	trap	3
811187b8:	dfc00115 	stw	ra,4(sp)
811187bc:	df000015 	stw	fp,0(sp)
811187c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
811187c4:	d0a06117 	ldw	r2,-32380(gp)
811187c8:	100f883a 	mov	r7,r2
811187cc:	01800a44 	movi	r6,41
811187d0:	01400044 	movi	r5,1
811187d4:	01204574 	movhi	r4,33045
811187d8:	212cf004 	addi	r4,r4,-19520
811187dc:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811187e0:	0001883a 	nop
811187e4:	e037883a 	mov	sp,fp
811187e8:	dfc00117 	ldw	ra,4(sp)
811187ec:	df000017 	ldw	fp,0(sp)
811187f0:	dec00204 	addi	sp,sp,8
811187f4:	f800283a 	ret

811187f8 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
811187f8:	defffe04 	addi	sp,sp,-8
811187fc:	de00012e 	bgeu	sp,et,81118804 <vFailSendPreAckSenderSemaphore+0xc>
81118800:	003b68fa 	trap	3
81118804:	dfc00115 	stw	ra,4(sp)
81118808:	df000015 	stw	fp,0(sp)
8111880c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
81118810:	d0a06117 	ldw	r2,-32380(gp)
81118814:	100f883a 	mov	r7,r2
81118818:	018009c4 	movi	r6,39
8111881c:	01400044 	movi	r5,1
81118820:	01204574 	movhi	r4,33045
81118824:	212cfb04 	addi	r4,r4,-19476
81118828:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111882c:	0001883a 	nop
81118830:	e037883a 	mov	sp,fp
81118834:	dfc00117 	ldw	ra,4(sp)
81118838:	df000017 	ldw	fp,0(sp)
8111883c:	dec00204 	addi	sp,sp,8
81118840:	f800283a 	ret

81118844 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
81118844:	defffe04 	addi	sp,sp,-8
81118848:	de00012e 	bgeu	sp,et,81118850 <vFailGetCountSemaphoreSenderTask+0xc>
8111884c:	003b68fa 	trap	3
81118850:	dfc00115 	stw	ra,4(sp)
81118854:	df000015 	stw	fp,0(sp)
81118858:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111885c:	d0a06117 	ldw	r2,-32380(gp)
81118860:	100f883a 	mov	r7,r2
81118864:	01800a44 	movi	r6,41
81118868:	01400044 	movi	r5,1
8111886c:	01204574 	movhi	r4,33045
81118870:	212d0504 	addi	r4,r4,-19436
81118874:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
81118878:	d0a06117 	ldw	r2,-32380(gp)
8111887c:	100f883a 	mov	r7,r2
81118880:	01801104 	movi	r6,68
81118884:	01400044 	movi	r5,1
81118888:	01204574 	movhi	r4,33045
8111888c:	212d1004 	addi	r4,r4,-19392
81118890:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118894:	0001883a 	nop
81118898:	e037883a 	mov	sp,fp
8111889c:	dfc00117 	ldw	ra,4(sp)
811188a0:	df000017 	ldw	fp,0(sp)
811188a4:	dec00204 	addi	sp,sp,8
811188a8:	f800283a 	ret

811188ac <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
811188ac:	defffe04 	addi	sp,sp,-8
811188b0:	de00012e 	bgeu	sp,et,811188b8 <vFailGetMutexSenderTask+0xc>
811188b4:	003b68fa 	trap	3
811188b8:	dfc00115 	stw	ra,4(sp)
811188bc:	df000015 	stw	fp,0(sp)
811188c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
811188c4:	d0a06117 	ldw	r2,-32380(gp)
811188c8:	100f883a 	mov	r7,r2
811188cc:	01800804 	movi	r6,32
811188d0:	01400044 	movi	r5,1
811188d4:	01204574 	movhi	r4,33045
811188d8:	212d2204 	addi	r4,r4,-19320
811188dc:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
811188e0:	d0a06117 	ldw	r2,-32380(gp)
811188e4:	100f883a 	mov	r7,r2
811188e8:	01801084 	movi	r6,66
811188ec:	01400044 	movi	r5,1
811188f0:	01204574 	movhi	r4,33045
811188f4:	212d2b04 	addi	r4,r4,-19284
811188f8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811188fc:	0001883a 	nop
81118900:	e037883a 	mov	sp,fp
81118904:	dfc00117 	ldw	ra,4(sp)
81118908:	df000017 	ldw	fp,0(sp)
8111890c:	dec00204 	addi	sp,sp,8
81118910:	f800283a 	ret

81118914 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
81118914:	defffe04 	addi	sp,sp,-8
81118918:	de00012e 	bgeu	sp,et,81118920 <vFailGetCountSemaphoreReceiverTask+0xc>
8111891c:	003b68fa 	trap	3
81118920:	dfc00115 	stw	ra,4(sp)
81118924:	df000015 	stw	fp,0(sp)
81118928:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111892c:	d0a06117 	ldw	r2,-32380(gp)
81118930:	100f883a 	mov	r7,r2
81118934:	01800ac4 	movi	r6,43
81118938:	01400044 	movi	r5,1
8111893c:	01204574 	movhi	r4,33045
81118940:	212d3c04 	addi	r4,r4,-19216
81118944:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
81118948:	d0a06117 	ldw	r2,-32380(gp)
8111894c:	100f883a 	mov	r7,r2
81118950:	01801184 	movi	r6,70
81118954:	01400044 	movi	r5,1
81118958:	01204574 	movhi	r4,33045
8111895c:	212d4704 	addi	r4,r4,-19172
81118960:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118964:	0001883a 	nop
81118968:	e037883a 	mov	sp,fp
8111896c:	dfc00117 	ldw	ra,4(sp)
81118970:	df000017 	ldw	fp,0(sp)
81118974:	dec00204 	addi	sp,sp,8
81118978:	f800283a 	ret

8111897c <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111897c:	defffe04 	addi	sp,sp,-8
81118980:	de00012e 	bgeu	sp,et,81118988 <vFailGetMutexReceiverTask+0xc>
81118984:	003b68fa 	trap	3
81118988:	dfc00115 	stw	ra,4(sp)
8111898c:	df000015 	stw	fp,0(sp)
81118990:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
81118994:	d0a06117 	ldw	r2,-32380(gp)
81118998:	100f883a 	mov	r7,r2
8111899c:	01800884 	movi	r6,34
811189a0:	01400044 	movi	r5,1
811189a4:	01204574 	movhi	r4,33045
811189a8:	212d5904 	addi	r4,r4,-19100
811189ac:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
811189b0:	d0a06117 	ldw	r2,-32380(gp)
811189b4:	100f883a 	mov	r7,r2
811189b8:	01801104 	movi	r6,68
811189bc:	01400044 	movi	r5,1
811189c0:	01204574 	movhi	r4,33045
811189c4:	212d6204 	addi	r4,r4,-19064
811189c8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811189cc:	0001883a 	nop
811189d0:	e037883a 	mov	sp,fp
811189d4:	dfc00117 	ldw	ra,4(sp)
811189d8:	df000017 	ldw	fp,0(sp)
811189dc:	dec00204 	addi	sp,sp,8
811189e0:	f800283a 	ret

811189e4 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
811189e4:	defffe04 	addi	sp,sp,-8
811189e8:	de00012e 	bgeu	sp,et,811189f0 <vFailGetMutexTxUARTSenderTask+0xc>
811189ec:	003b68fa 	trap	3
811189f0:	dfc00115 	stw	ra,4(sp)
811189f4:	df000015 	stw	fp,0(sp)
811189f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
811189fc:	d0a06117 	ldw	r2,-32380(gp)
81118a00:	100f883a 	mov	r7,r2
81118a04:	01800984 	movi	r6,38
81118a08:	01400044 	movi	r5,1
81118a0c:	01204574 	movhi	r4,33045
81118a10:	212d7404 	addi	r4,r4,-18992
81118a14:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
81118a18:	d0a06117 	ldw	r2,-32380(gp)
81118a1c:	100f883a 	mov	r7,r2
81118a20:	01801044 	movi	r6,65
81118a24:	01400044 	movi	r5,1
81118a28:	01204574 	movhi	r4,33045
81118a2c:	212d7e04 	addi	r4,r4,-18952
81118a30:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118a34:	0001883a 	nop
81118a38:	e037883a 	mov	sp,fp
81118a3c:	dfc00117 	ldw	ra,4(sp)
81118a40:	df000017 	ldw	fp,0(sp)
81118a44:	dec00204 	addi	sp,sp,8
81118a48:	f800283a 	ret

81118a4c <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
81118a4c:	defffe04 	addi	sp,sp,-8
81118a50:	de00012e 	bgeu	sp,et,81118a58 <vFailGetMacRTC+0xc>
81118a54:	003b68fa 	trap	3
81118a58:	dfc00115 	stw	ra,4(sp)
81118a5c:	df000015 	stw	fp,0(sp)
81118a60:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
81118a64:	d0a06117 	ldw	r2,-32380(gp)
81118a68:	100f883a 	mov	r7,r2
81118a6c:	018003c4 	movi	r6,15
81118a70:	01400044 	movi	r5,1
81118a74:	01204574 	movhi	r4,33045
81118a78:	212d8f04 	addi	r4,r4,-18884
81118a7c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118a80:	0001883a 	nop
81118a84:	e037883a 	mov	sp,fp
81118a88:	dfc00117 	ldw	ra,4(sp)
81118a8c:	df000017 	ldw	fp,0(sp)
81118a90:	dec00204 	addi	sp,sp,8
81118a94:	f800283a 	ret

81118a98 <vFailInitialization>:


void vFailInitialization( void )
{
81118a98:	defffe04 	addi	sp,sp,-8
81118a9c:	de00012e 	bgeu	sp,et,81118aa4 <vFailInitialization+0xc>
81118aa0:	003b68fa 	trap	3
81118aa4:	dfc00115 	stw	ra,4(sp)
81118aa8:	df000015 	stw	fp,0(sp)
81118aac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
81118ab0:	d0a06117 	ldw	r2,-32380(gp)
81118ab4:	100f883a 	mov	r7,r2
81118ab8:	01800504 	movi	r6,20
81118abc:	01400044 	movi	r5,1
81118ac0:	01204574 	movhi	r4,33045
81118ac4:	212d9304 	addi	r4,r4,-18868
81118ac8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118acc:	0001883a 	nop
81118ad0:	e037883a 	mov	sp,fp
81118ad4:	dfc00117 	ldw	ra,4(sp)
81118ad8:	df000017 	ldw	fp,0(sp)
81118adc:	dec00204 	addi	sp,sp,8
81118ae0:	f800283a 	ret

81118ae4 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
81118ae4:	defffe04 	addi	sp,sp,-8
81118ae8:	de00012e 	bgeu	sp,et,81118af0 <vFailReceiverCreate+0xc>
81118aec:	003b68fa 	trap	3
81118af0:	dfc00115 	stw	ra,4(sp)
81118af4:	df000015 	stw	fp,0(sp)
81118af8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81118afc:	d0a06117 	ldw	r2,-32380(gp)
81118b00:	100f883a 	mov	r7,r2
81118b04:	01800484 	movi	r6,18
81118b08:	01400044 	movi	r5,1
81118b0c:	01204574 	movhi	r4,33045
81118b10:	212d9904 	addi	r4,r4,-18844
81118b14:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118b18:	0001883a 	nop
81118b1c:	e037883a 	mov	sp,fp
81118b20:	dfc00117 	ldw	ra,4(sp)
81118b24:	df000017 	ldw	fp,0(sp)
81118b28:	dec00204 	addi	sp,sp,8
81118b2c:	f800283a 	ret

81118b30 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
81118b30:	defffe04 	addi	sp,sp,-8
81118b34:	de00012e 	bgeu	sp,et,81118b3c <vFailSenderCreate+0xc>
81118b38:	003b68fa 	trap	3
81118b3c:	dfc00115 	stw	ra,4(sp)
81118b40:	df000015 	stw	fp,0(sp)
81118b44:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
81118b48:	d0a06117 	ldw	r2,-32380(gp)
81118b4c:	100f883a 	mov	r7,r2
81118b50:	01800484 	movi	r6,18
81118b54:	01400044 	movi	r5,1
81118b58:	01204574 	movhi	r4,33045
81118b5c:	212d9e04 	addi	r4,r4,-18824
81118b60:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118b64:	0001883a 	nop
81118b68:	e037883a 	mov	sp,fp
81118b6c:	dfc00117 	ldw	ra,4(sp)
81118b70:	df000017 	ldw	fp,0(sp)
81118b74:	dec00204 	addi	sp,sp,8
81118b78:	f800283a 	ret

81118b7c <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
81118b7c:	defffe04 	addi	sp,sp,-8
81118b80:	de00012e 	bgeu	sp,et,81118b88 <vFailDeleteInitialization+0xc>
81118b84:	003b68fa 	trap	3
81118b88:	dfc00115 	stw	ra,4(sp)
81118b8c:	df000015 	stw	fp,0(sp)
81118b90:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
81118b94:	d0a06117 	ldw	r2,-32380(gp)
81118b98:	100f883a 	mov	r7,r2
81118b9c:	01800684 	movi	r6,26
81118ba0:	01400044 	movi	r5,1
81118ba4:	01204574 	movhi	r4,33045
81118ba8:	212da304 	addi	r4,r4,-18804
81118bac:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118bb0:	0001883a 	nop
81118bb4:	e037883a 	mov	sp,fp
81118bb8:	dfc00117 	ldw	ra,4(sp)
81118bbc:	df000017 	ldw	fp,0(sp)
81118bc0:	dec00204 	addi	sp,sp,8
81118bc4:	f800283a 	ret

81118bc8 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
81118bc8:	defffe04 	addi	sp,sp,-8
81118bcc:	de00012e 	bgeu	sp,et,81118bd4 <vFailSetCountSemaphorexBuffer32+0xc>
81118bd0:	003b68fa 	trap	3
81118bd4:	dfc00115 	stw	ra,4(sp)
81118bd8:	df000015 	stw	fp,0(sp)
81118bdc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
81118be0:	d0a06117 	ldw	r2,-32380(gp)
81118be4:	100f883a 	mov	r7,r2
81118be8:	01800a04 	movi	r6,40
81118bec:	01400044 	movi	r5,1
81118bf0:	01204574 	movhi	r4,33045
81118bf4:	212daa04 	addi	r4,r4,-18776
81118bf8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81118bfc:	d0a06117 	ldw	r2,-32380(gp)
81118c00:	100f883a 	mov	r7,r2
81118c04:	018008c4 	movi	r6,35
81118c08:	01400044 	movi	r5,1
81118c0c:	01204574 	movhi	r4,33045
81118c10:	212db504 	addi	r4,r4,-18732
81118c14:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118c18:	0001883a 	nop
81118c1c:	e037883a 	mov	sp,fp
81118c20:	dfc00117 	ldw	ra,4(sp)
81118c24:	df000017 	ldw	fp,0(sp)
81118c28:	dec00204 	addi	sp,sp,8
81118c2c:	f800283a 	ret

81118c30 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
81118c30:	defffe04 	addi	sp,sp,-8
81118c34:	de00012e 	bgeu	sp,et,81118c3c <vFailSetCountSemaphorexBuffer64+0xc>
81118c38:	003b68fa 	trap	3
81118c3c:	dfc00115 	stw	ra,4(sp)
81118c40:	df000015 	stw	fp,0(sp)
81118c44:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
81118c48:	d0a06117 	ldw	r2,-32380(gp)
81118c4c:	100f883a 	mov	r7,r2
81118c50:	01800a04 	movi	r6,40
81118c54:	01400044 	movi	r5,1
81118c58:	01204574 	movhi	r4,33045
81118c5c:	212dbe04 	addi	r4,r4,-18696
81118c60:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81118c64:	d0a06117 	ldw	r2,-32380(gp)
81118c68:	100f883a 	mov	r7,r2
81118c6c:	018008c4 	movi	r6,35
81118c70:	01400044 	movi	r5,1
81118c74:	01204574 	movhi	r4,33045
81118c78:	212db504 	addi	r4,r4,-18732
81118c7c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118c80:	0001883a 	nop
81118c84:	e037883a 	mov	sp,fp
81118c88:	dfc00117 	ldw	ra,4(sp)
81118c8c:	df000017 	ldw	fp,0(sp)
81118c90:	dec00204 	addi	sp,sp,8
81118c94:	f800283a 	ret

81118c98 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
81118c98:	defffe04 	addi	sp,sp,-8
81118c9c:	de00012e 	bgeu	sp,et,81118ca4 <vFailSetCountSemaphorexBuffer128+0xc>
81118ca0:	003b68fa 	trap	3
81118ca4:	dfc00115 	stw	ra,4(sp)
81118ca8:	df000015 	stw	fp,0(sp)
81118cac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
81118cb0:	d0a06117 	ldw	r2,-32380(gp)
81118cb4:	100f883a 	mov	r7,r2
81118cb8:	01800a44 	movi	r6,41
81118cbc:	01400044 	movi	r5,1
81118cc0:	01204574 	movhi	r4,33045
81118cc4:	212dc904 	addi	r4,r4,-18652
81118cc8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81118ccc:	d0a06117 	ldw	r2,-32380(gp)
81118cd0:	100f883a 	mov	r7,r2
81118cd4:	018008c4 	movi	r6,35
81118cd8:	01400044 	movi	r5,1
81118cdc:	01204574 	movhi	r4,33045
81118ce0:	212db504 	addi	r4,r4,-18732
81118ce4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118ce8:	0001883a 	nop
81118cec:	e037883a 	mov	sp,fp
81118cf0:	dfc00117 	ldw	ra,4(sp)
81118cf4:	df000017 	ldw	fp,0(sp)
81118cf8:	dec00204 	addi	sp,sp,8
81118cfc:	f800283a 	ret

81118d00 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
81118d00:	defffe04 	addi	sp,sp,-8
81118d04:	de00012e 	bgeu	sp,et,81118d0c <vFailGetCountSemaphorexBuffer128+0xc>
81118d08:	003b68fa 	trap	3
81118d0c:	dfc00115 	stw	ra,4(sp)
81118d10:	df000015 	stw	fp,0(sp)
81118d14:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
81118d18:	d0a06117 	ldw	r2,-32380(gp)
81118d1c:	100f883a 	mov	r7,r2
81118d20:	01800a44 	movi	r6,41
81118d24:	01400044 	movi	r5,1
81118d28:	01204574 	movhi	r4,33045
81118d2c:	212dd404 	addi	r4,r4,-18608
81118d30:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81118d34:	d0a06117 	ldw	r2,-32380(gp)
81118d38:	100f883a 	mov	r7,r2
81118d3c:	01800884 	movi	r6,34
81118d40:	01400044 	movi	r5,1
81118d44:	01204574 	movhi	r4,33045
81118d48:	212ddf04 	addi	r4,r4,-18564
81118d4c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118d50:	0001883a 	nop
81118d54:	e037883a 	mov	sp,fp
81118d58:	dfc00117 	ldw	ra,4(sp)
81118d5c:	df000017 	ldw	fp,0(sp)
81118d60:	dec00204 	addi	sp,sp,8
81118d64:	f800283a 	ret

81118d68 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
81118d68:	defffe04 	addi	sp,sp,-8
81118d6c:	de00012e 	bgeu	sp,et,81118d74 <vFailGetCountSemaphorexBuffer64+0xc>
81118d70:	003b68fa 	trap	3
81118d74:	dfc00115 	stw	ra,4(sp)
81118d78:	df000015 	stw	fp,0(sp)
81118d7c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
81118d80:	d0a06117 	ldw	r2,-32380(gp)
81118d84:	100f883a 	mov	r7,r2
81118d88:	01800a04 	movi	r6,40
81118d8c:	01400044 	movi	r5,1
81118d90:	01204574 	movhi	r4,33045
81118d94:	212de804 	addi	r4,r4,-18528
81118d98:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81118d9c:	d0a06117 	ldw	r2,-32380(gp)
81118da0:	100f883a 	mov	r7,r2
81118da4:	01800884 	movi	r6,34
81118da8:	01400044 	movi	r5,1
81118dac:	01204574 	movhi	r4,33045
81118db0:	212ddf04 	addi	r4,r4,-18564
81118db4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118db8:	0001883a 	nop
81118dbc:	e037883a 	mov	sp,fp
81118dc0:	dfc00117 	ldw	ra,4(sp)
81118dc4:	df000017 	ldw	fp,0(sp)
81118dc8:	dec00204 	addi	sp,sp,8
81118dcc:	f800283a 	ret

81118dd0 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
81118dd0:	defffe04 	addi	sp,sp,-8
81118dd4:	de00012e 	bgeu	sp,et,81118ddc <vFailGetCountSemaphorexBuffer32+0xc>
81118dd8:	003b68fa 	trap	3
81118ddc:	dfc00115 	stw	ra,4(sp)
81118de0:	df000015 	stw	fp,0(sp)
81118de4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
81118de8:	d0a06117 	ldw	r2,-32380(gp)
81118dec:	100f883a 	mov	r7,r2
81118df0:	01800a04 	movi	r6,40
81118df4:	01400044 	movi	r5,1
81118df8:	01204574 	movhi	r4,33045
81118dfc:	212df304 	addi	r4,r4,-18484
81118e00:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81118e04:	d0a06117 	ldw	r2,-32380(gp)
81118e08:	100f883a 	mov	r7,r2
81118e0c:	01800884 	movi	r6,34
81118e10:	01400044 	movi	r5,1
81118e14:	01204574 	movhi	r4,33045
81118e18:	212ddf04 	addi	r4,r4,-18564
81118e1c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118e20:	0001883a 	nop
81118e24:	e037883a 	mov	sp,fp
81118e28:	dfc00117 	ldw	ra,4(sp)
81118e2c:	df000017 	ldw	fp,0(sp)
81118e30:	dec00204 	addi	sp,sp,8
81118e34:	f800283a 	ret

81118e38 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
81118e38:	defffe04 	addi	sp,sp,-8
81118e3c:	de00012e 	bgeu	sp,et,81118e44 <vFailFoundBufferRetransmission+0xc>
81118e40:	003b68fa 	trap	3
81118e44:	dfc00115 	stw	ra,4(sp)
81118e48:	df000015 	stw	fp,0(sp)
81118e4c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
81118e50:	d0a06117 	ldw	r2,-32380(gp)
81118e54:	100f883a 	mov	r7,r2
81118e58:	01800a84 	movi	r6,42
81118e5c:	01400044 	movi	r5,1
81118e60:	01204574 	movhi	r4,33045
81118e64:	212dfe04 	addi	r4,r4,-18440
81118e68:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
81118e6c:	d0a06117 	ldw	r2,-32380(gp)
81118e70:	100f883a 	mov	r7,r2
81118e74:	01801204 	movi	r6,72
81118e78:	01400044 	movi	r5,1
81118e7c:	01204574 	movhi	r4,33045
81118e80:	212e0904 	addi	r4,r4,-18396
81118e84:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118e88:	0001883a 	nop
81118e8c:	e037883a 	mov	sp,fp
81118e90:	dfc00117 	ldw	ra,4(sp)
81118e94:	df000017 	ldw	fp,0(sp)
81118e98:	dec00204 	addi	sp,sp,8
81118e9c:	f800283a 	ret

81118ea0 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
81118ea0:	defffe04 	addi	sp,sp,-8
81118ea4:	de00012e 	bgeu	sp,et,81118eac <vFailGetCountSemaphorePreParsedBuffer+0xc>
81118ea8:	003b68fa 	trap	3
81118eac:	dfc00115 	stw	ra,4(sp)
81118eb0:	df000015 	stw	fp,0(sp)
81118eb4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
81118eb8:	d0a06117 	ldw	r2,-32380(gp)
81118ebc:	100f883a 	mov	r7,r2
81118ec0:	01800b84 	movi	r6,46
81118ec4:	01400044 	movi	r5,1
81118ec8:	01204574 	movhi	r4,33045
81118ecc:	212e1c04 	addi	r4,r4,-18320
81118ed0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
81118ed4:	d0a06117 	ldw	r2,-32380(gp)
81118ed8:	100f883a 	mov	r7,r2
81118edc:	018010c4 	movi	r6,67
81118ee0:	01400044 	movi	r5,1
81118ee4:	01204574 	movhi	r4,33045
81118ee8:	212e2804 	addi	r4,r4,-18272
81118eec:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118ef0:	0001883a 	nop
81118ef4:	e037883a 	mov	sp,fp
81118ef8:	dfc00117 	ldw	ra,4(sp)
81118efc:	df000017 	ldw	fp,0(sp)
81118f00:	dec00204 	addi	sp,sp,8
81118f04:	f800283a 	ret

81118f08 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
81118f08:	defffe04 	addi	sp,sp,-8
81118f0c:	de00012e 	bgeu	sp,et,81118f14 <vFailGetxMutexPreParsedParserRxTask+0xc>
81118f10:	003b68fa 	trap	3
81118f14:	dfc00115 	stw	ra,4(sp)
81118f18:	df000015 	stw	fp,0(sp)
81118f1c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
81118f20:	d0a06117 	ldw	r2,-32380(gp)
81118f24:	100f883a 	mov	r7,r2
81118f28:	01800b04 	movi	r6,44
81118f2c:	01400044 	movi	r5,1
81118f30:	01204574 	movhi	r4,33045
81118f34:	212e3904 	addi	r4,r4,-18204
81118f38:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
81118f3c:	d0a06117 	ldw	r2,-32380(gp)
81118f40:	100f883a 	mov	r7,r2
81118f44:	01800fc4 	movi	r6,63
81118f48:	01400044 	movi	r5,1
81118f4c:	01204574 	movhi	r4,33045
81118f50:	212e4504 	addi	r4,r4,-18156
81118f54:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118f58:	0001883a 	nop
81118f5c:	e037883a 	mov	sp,fp
81118f60:	dfc00117 	ldw	ra,4(sp)
81118f64:	df000017 	ldw	fp,0(sp)
81118f68:	dec00204 	addi	sp,sp,8
81118f6c:	f800283a 	ret

81118f70 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
81118f70:	defffe04 	addi	sp,sp,-8
81118f74:	de00012e 	bgeu	sp,et,81118f7c <vNoContentInPreParsedBuffer+0xc>
81118f78:	003b68fa 	trap	3
81118f7c:	dfc00115 	stw	ra,4(sp)
81118f80:	df000015 	stw	fp,0(sp)
81118f84:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
81118f88:	d0a06117 	ldw	r2,-32380(gp)
81118f8c:	100f883a 	mov	r7,r2
81118f90:	01800904 	movi	r6,36
81118f94:	01400044 	movi	r5,1
81118f98:	01204574 	movhi	r4,33045
81118f9c:	212e5504 	addi	r4,r4,-18092
81118fa0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
81118fa4:	d0a06117 	ldw	r2,-32380(gp)
81118fa8:	100f883a 	mov	r7,r2
81118fac:	01801684 	movi	r6,90
81118fb0:	01400044 	movi	r5,1
81118fb4:	01204574 	movhi	r4,33045
81118fb8:	212e5f04 	addi	r4,r4,-18052
81118fbc:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118fc0:	0001883a 	nop
81118fc4:	e037883a 	mov	sp,fp
81118fc8:	dfc00117 	ldw	ra,4(sp)
81118fcc:	df000017 	ldw	fp,0(sp)
81118fd0:	dec00204 	addi	sp,sp,8
81118fd4:	f800283a 	ret

81118fd8 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
81118fd8:	defffe04 	addi	sp,sp,-8
81118fdc:	de00012e 	bgeu	sp,et,81118fe4 <vCouldNotSendEthConfUART+0xc>
81118fe0:	003b68fa 	trap	3
81118fe4:	dfc00115 	stw	ra,4(sp)
81118fe8:	df000015 	stw	fp,0(sp)
81118fec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
81118ff0:	d0a06117 	ldw	r2,-32380(gp)
81118ff4:	100f883a 	mov	r7,r2
81118ff8:	01800844 	movi	r6,33
81118ffc:	01400044 	movi	r5,1
81119000:	01204574 	movhi	r4,33045
81119004:	212e7604 	addi	r4,r4,-17960
81119008:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111900c:	d0a06117 	ldw	r2,-32380(gp)
81119010:	100f883a 	mov	r7,r2
81119014:	01801784 	movi	r6,94
81119018:	01400044 	movi	r5,1
8111901c:	01204574 	movhi	r4,33045
81119020:	212e7f04 	addi	r4,r4,-17924
81119024:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119028:	0001883a 	nop
8111902c:	e037883a 	mov	sp,fp
81119030:	dfc00117 	ldw	ra,4(sp)
81119034:	df000017 	ldw	fp,0(sp)
81119038:	dec00204 	addi	sp,sp,8
8111903c:	f800283a 	ret

81119040 <vFailSendNack>:

void vFailSendNack( void )
{
81119040:	defffe04 	addi	sp,sp,-8
81119044:	de00012e 	bgeu	sp,et,8111904c <vFailSendNack+0xc>
81119048:	003b68fa 	trap	3
8111904c:	dfc00115 	stw	ra,4(sp)
81119050:	df000015 	stw	fp,0(sp)
81119054:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
81119058:	d0a06117 	ldw	r2,-32380(gp)
8111905c:	100f883a 	mov	r7,r2
81119060:	01800584 	movi	r6,22
81119064:	01400044 	movi	r5,1
81119068:	01204574 	movhi	r4,33045
8111906c:	212e9704 	addi	r4,r4,-17828
81119070:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
81119074:	d0a06117 	ldw	r2,-32380(gp)
81119078:	100f883a 	mov	r7,r2
8111907c:	01800a84 	movi	r6,42
81119080:	01400044 	movi	r5,1
81119084:	01204574 	movhi	r4,33045
81119088:	212e9d04 	addi	r4,r4,-17804
8111908c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119090:	0001883a 	nop
81119094:	e037883a 	mov	sp,fp
81119098:	dfc00117 	ldw	ra,4(sp)
8111909c:	df000017 	ldw	fp,0(sp)
811190a0:	dec00204 	addi	sp,sp,8
811190a4:	f800283a 	ret

811190a8 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
811190a8:	defffe04 	addi	sp,sp,-8
811190ac:	de00012e 	bgeu	sp,et,811190b4 <vFailSetPreAckSenderBuffer+0xc>
811190b0:	003b68fa 	trap	3
811190b4:	dfc00115 	stw	ra,4(sp)
811190b8:	df000015 	stw	fp,0(sp)
811190bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
811190c0:	d0a06117 	ldw	r2,-32380(gp)
811190c4:	100f883a 	mov	r7,r2
811190c8:	018008c4 	movi	r6,35
811190cc:	01400044 	movi	r5,1
811190d0:	01204574 	movhi	r4,33045
811190d4:	212ea804 	addi	r4,r4,-17760
811190d8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
811190dc:	d0a06117 	ldw	r2,-32380(gp)
811190e0:	100f883a 	mov	r7,r2
811190e4:	01801584 	movi	r6,86
811190e8:	01400044 	movi	r5,1
811190ec:	01204574 	movhi	r4,33045
811190f0:	212eb104 	addi	r4,r4,-17724
811190f4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811190f8:	0001883a 	nop
811190fc:	e037883a 	mov	sp,fp
81119100:	dfc00117 	ldw	ra,4(sp)
81119104:	df000017 	ldw	fp,0(sp)
81119108:	dec00204 	addi	sp,sp,8
8111910c:	f800283a 	ret

81119110 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
81119110:	defffe04 	addi	sp,sp,-8
81119114:	de00012e 	bgeu	sp,et,8111911c <vFailSetPreParsedBuffer+0xc>
81119118:	003b68fa 	trap	3
8111911c:	dfc00115 	stw	ra,4(sp)
81119120:	df000015 	stw	fp,0(sp)
81119124:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
81119128:	d0a06117 	ldw	r2,-32380(gp)
8111912c:	100f883a 	mov	r7,r2
81119130:	01800804 	movi	r6,32
81119134:	01400044 	movi	r5,1
81119138:	01204574 	movhi	r4,33045
8111913c:	212ec704 	addi	r4,r4,-17636
81119140:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
81119144:	d0a06117 	ldw	r2,-32380(gp)
81119148:	100f883a 	mov	r7,r2
8111914c:	018013c4 	movi	r6,79
81119150:	01400044 	movi	r5,1
81119154:	01204574 	movhi	r4,33045
81119158:	212ed004 	addi	r4,r4,-17600
8111915c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119160:	0001883a 	nop
81119164:	e037883a 	mov	sp,fp
81119168:	dfc00117 	ldw	ra,4(sp)
8111916c:	df000017 	ldw	fp,0(sp)
81119170:	dec00204 	addi	sp,sp,8
81119174:	f800283a 	ret

81119178 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
81119178:	defffe04 	addi	sp,sp,-8
8111917c:	de00012e 	bgeu	sp,et,81119184 <vFailSetPreAckReceiverBuffer+0xc>
81119180:	003b68fa 	trap	3
81119184:	dfc00115 	stw	ra,4(sp)
81119188:	df000015 	stw	fp,0(sp)
8111918c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
81119190:	d0a06117 	ldw	r2,-32380(gp)
81119194:	100f883a 	mov	r7,r2
81119198:	01800944 	movi	r6,37
8111919c:	01400044 	movi	r5,1
811191a0:	01204574 	movhi	r4,33045
811191a4:	212ee404 	addi	r4,r4,-17520
811191a8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
811191ac:	d0a06117 	ldw	r2,-32380(gp)
811191b0:	100f883a 	mov	r7,r2
811191b4:	018015c4 	movi	r6,87
811191b8:	01400044 	movi	r5,1
811191bc:	01204574 	movhi	r4,33045
811191c0:	212eee04 	addi	r4,r4,-17480
811191c4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811191c8:	0001883a 	nop
811191cc:	e037883a 	mov	sp,fp
811191d0:	dfc00117 	ldw	ra,4(sp)
811191d4:	df000017 	ldw	fp,0(sp)
811191d8:	dec00204 	addi	sp,sp,8
811191dc:	f800283a 	ret

811191e0 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
811191e0:	defffe04 	addi	sp,sp,-8
811191e4:	de00012e 	bgeu	sp,et,811191ec <vFailParserCommTaskCreate+0xc>
811191e8:	003b68fa 	trap	3
811191ec:	dfc00115 	stw	ra,4(sp)
811191f0:	df000015 	stw	fp,0(sp)
811191f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
811191f8:	d0a06117 	ldw	r2,-32380(gp)
811191fc:	100f883a 	mov	r7,r2
81119200:	01800684 	movi	r6,26
81119204:	01400044 	movi	r5,1
81119208:	01204574 	movhi	r4,33045
8111920c:	212f0404 	addi	r4,r4,-17392
81119210:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119214:	0001883a 	nop
81119218:	e037883a 	mov	sp,fp
8111921c:	dfc00117 	ldw	ra,4(sp)
81119220:	df000017 	ldw	fp,0(sp)
81119224:	dec00204 	addi	sp,sp,8
81119228:	f800283a 	ret

8111922c <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111922c:	defffe04 	addi	sp,sp,-8
81119230:	de00012e 	bgeu	sp,et,81119238 <vFailInAckHandlerTaskCreate+0xc>
81119234:	003b68fa 	trap	3
81119238:	dfc00115 	stw	ra,4(sp)
8111923c:	df000015 	stw	fp,0(sp)
81119240:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81119244:	d0a06117 	ldw	r2,-32380(gp)
81119248:	100f883a 	mov	r7,r2
8111924c:	01800704 	movi	r6,28
81119250:	01400044 	movi	r5,1
81119254:	01204574 	movhi	r4,33045
81119258:	212f0b04 	addi	r4,r4,-17364
8111925c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119260:	0001883a 	nop
81119264:	e037883a 	mov	sp,fp
81119268:	dfc00117 	ldw	ra,4(sp)
8111926c:	df000017 	ldw	fp,0(sp)
81119270:	dec00204 	addi	sp,sp,8
81119274:	f800283a 	ret

81119278 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
81119278:	defffe04 	addi	sp,sp,-8
8111927c:	de00012e 	bgeu	sp,et,81119284 <vFailOutAckHandlerTaskCreate+0xc>
81119280:	003b68fa 	trap	3
81119284:	dfc00115 	stw	ra,4(sp)
81119288:	df000015 	stw	fp,0(sp)
8111928c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81119290:	d0a06117 	ldw	r2,-32380(gp)
81119294:	100f883a 	mov	r7,r2
81119298:	01800704 	movi	r6,28
8111929c:	01400044 	movi	r5,1
811192a0:	01204574 	movhi	r4,33045
811192a4:	212f0b04 	addi	r4,r4,-17364
811192a8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811192ac:	0001883a 	nop
811192b0:	e037883a 	mov	sp,fp
811192b4:	dfc00117 	ldw	ra,4(sp)
811192b8:	df000017 	ldw	fp,0(sp)
811192bc:	dec00204 	addi	sp,sp,8
811192c0:	f800283a 	ret

811192c4 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
811192c4:	defffe04 	addi	sp,sp,-8
811192c8:	de00012e 	bgeu	sp,et,811192d0 <vFailCreateTimerRetransmisison+0xc>
811192cc:	003b68fa 	trap	3
811192d0:	dfc00115 	stw	ra,4(sp)
811192d4:	df000015 	stw	fp,0(sp)
811192d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
811192dc:	d0a06117 	ldw	r2,-32380(gp)
811192e0:	100f883a 	mov	r7,r2
811192e4:	018007c4 	movi	r6,31
811192e8:	01400044 	movi	r5,1
811192ec:	01204574 	movhi	r4,33045
811192f0:	212f1304 	addi	r4,r4,-17332
811192f4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811192f8:	0001883a 	nop
811192fc:	e037883a 	mov	sp,fp
81119300:	dfc00117 	ldw	ra,4(sp)
81119304:	df000017 	ldw	fp,0(sp)
81119308:	dec00204 	addi	sp,sp,8
8111930c:	f800283a 	ret

81119310 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
81119310:	defffe04 	addi	sp,sp,-8
81119314:	de00012e 	bgeu	sp,et,8111931c <vCouldNotCheckBufferTimeOutFunction+0xc>
81119318:	003b68fa 	trap	3
8111931c:	dfc00115 	stw	ra,4(sp)
81119320:	df000015 	stw	fp,0(sp)
81119324:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
81119328:	d0a06117 	ldw	r2,-32380(gp)
8111932c:	100f883a 	mov	r7,r2
81119330:	01800904 	movi	r6,36
81119334:	01400044 	movi	r5,1
81119338:	01204574 	movhi	r4,33045
8111933c:	212f1b04 	addi	r4,r4,-17300
81119340:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119344:	0001883a 	nop
81119348:	e037883a 	mov	sp,fp
8111934c:	dfc00117 	ldw	ra,4(sp)
81119350:	df000017 	ldw	fp,0(sp)
81119354:	dec00204 	addi	sp,sp,8
81119358:	f800283a 	ret

8111935c <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111935c:	defffe04 	addi	sp,sp,-8
81119360:	de00012e 	bgeu	sp,et,81119368 <vFailTimeoutCheckerTaskCreate+0xc>
81119364:	003b68fa 	trap	3
81119368:	dfc00115 	stw	ra,4(sp)
8111936c:	df000015 	stw	fp,0(sp)
81119370:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
81119374:	d0a06117 	ldw	r2,-32380(gp)
81119378:	100f883a 	mov	r7,r2
8111937c:	01800a04 	movi	r6,40
81119380:	01400044 	movi	r5,1
81119384:	01204574 	movhi	r4,33045
81119388:	212f2504 	addi	r4,r4,-17260
8111938c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119390:	0001883a 	nop
81119394:	e037883a 	mov	sp,fp
81119398:	dfc00117 	ldw	ra,4(sp)
8111939c:	df000017 	ldw	fp,0(sp)
811193a0:	dec00204 	addi	sp,sp,8
811193a4:	f800283a 	ret

811193a8 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
811193a8:	defffe04 	addi	sp,sp,-8
811193ac:	de00012e 	bgeu	sp,et,811193b4 <vFailGetBlockingSemTimeoutTask+0xc>
811193b0:	003b68fa 	trap	3
811193b4:	dfc00115 	stw	ra,4(sp)
811193b8:	df000015 	stw	fp,0(sp)
811193bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
811193c0:	d0a06117 	ldw	r2,-32380(gp)
811193c4:	100f883a 	mov	r7,r2
811193c8:	018009c4 	movi	r6,39
811193cc:	01400044 	movi	r5,1
811193d0:	01204574 	movhi	r4,33045
811193d4:	212f3004 	addi	r4,r4,-17216
811193d8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
811193dc:	d0a06117 	ldw	r2,-32380(gp)
811193e0:	100f883a 	mov	r7,r2
811193e4:	01800cc4 	movi	r6,51
811193e8:	01400044 	movi	r5,1
811193ec:	01204574 	movhi	r4,33045
811193f0:	212f3a04 	addi	r4,r4,-17176
811193f4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811193f8:	0001883a 	nop
811193fc:	e037883a 	mov	sp,fp
81119400:	dfc00117 	ldw	ra,4(sp)
81119404:	df000017 	ldw	fp,0(sp)
81119408:	dec00204 	addi	sp,sp,8
8111940c:	f800283a 	ret

81119410 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
81119410:	defffe04 	addi	sp,sp,-8
81119414:	de00012e 	bgeu	sp,et,8111941c <vFailPostBlockingSemTimeoutTask+0xc>
81119418:	003b68fa 	trap	3
8111941c:	dfc00115 	stw	ra,4(sp)
81119420:	df000015 	stw	fp,0(sp)
81119424:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
81119428:	d0a06117 	ldw	r2,-32380(gp)
8111942c:	100f883a 	mov	r7,r2
81119430:	01800a04 	movi	r6,40
81119434:	01400044 	movi	r5,1
81119438:	01204574 	movhi	r4,33045
8111943c:	212f4704 	addi	r4,r4,-17124
81119440:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
81119444:	d0a06117 	ldw	r2,-32380(gp)
81119448:	100f883a 	mov	r7,r2
8111944c:	01800c84 	movi	r6,50
81119450:	01400044 	movi	r5,1
81119454:	01204574 	movhi	r4,33045
81119458:	212f5204 	addi	r4,r4,-17080
8111945c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119460:	0001883a 	nop
81119464:	e037883a 	mov	sp,fp
81119468:	dfc00117 	ldw	ra,4(sp)
8111946c:	df000017 	ldw	fp,0(sp)
81119470:	dec00204 	addi	sp,sp,8
81119474:	f800283a 	ret

81119478 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
81119478:	defffe04 	addi	sp,sp,-8
8111947c:	de00012e 	bgeu	sp,et,81119484 <vFailCouldNotRetransmitTimeoutTask+0xc>
81119480:	003b68fa 	trap	3
81119484:	dfc00115 	stw	ra,4(sp)
81119488:	df000015 	stw	fp,0(sp)
8111948c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
81119490:	d0a06117 	ldw	r2,-32380(gp)
81119494:	100f883a 	mov	r7,r2
81119498:	01800ac4 	movi	r6,43
8111949c:	01400044 	movi	r5,1
811194a0:	01204574 	movhi	r4,33045
811194a4:	212f5f04 	addi	r4,r4,-17028
811194a8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
811194ac:	d0a06117 	ldw	r2,-32380(gp)
811194b0:	100f883a 	mov	r7,r2
811194b4:	01801644 	movi	r6,89
811194b8:	01400044 	movi	r5,1
811194bc:	01204574 	movhi	r4,33045
811194c0:	212f6a04 	addi	r4,r4,-16984
811194c4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811194c8:	0001883a 	nop
811194cc:	e037883a 	mov	sp,fp
811194d0:	dfc00117 	ldw	ra,4(sp)
811194d4:	df000017 	ldw	fp,0(sp)
811194d8:	dec00204 	addi	sp,sp,8
811194dc:	f800283a 	ret

811194e0 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
811194e0:	defffe04 	addi	sp,sp,-8
811194e4:	de00012e 	bgeu	sp,et,811194ec <vCouldNotRetransmitB32TimeoutTask+0xc>
811194e8:	003b68fa 	trap	3
811194ec:	dfc00115 	stw	ra,4(sp)
811194f0:	df000015 	stw	fp,0(sp)
811194f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
811194f8:	d0a06117 	ldw	r2,-32380(gp)
811194fc:	100f883a 	mov	r7,r2
81119500:	01800a84 	movi	r6,42
81119504:	01400044 	movi	r5,1
81119508:	01204574 	movhi	r4,33045
8111950c:	212f8104 	addi	r4,r4,-16892
81119510:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
81119514:	d0a06117 	ldw	r2,-32380(gp)
81119518:	100f883a 	mov	r7,r2
8111951c:	01801444 	movi	r6,81
81119520:	01400044 	movi	r5,1
81119524:	01204574 	movhi	r4,33045
81119528:	212f8c04 	addi	r4,r4,-16848
8111952c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119530:	0001883a 	nop
81119534:	e037883a 	mov	sp,fp
81119538:	dfc00117 	ldw	ra,4(sp)
8111953c:	df000017 	ldw	fp,0(sp)
81119540:	dec00204 	addi	sp,sp,8
81119544:	f800283a 	ret

81119548 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
81119548:	defffe04 	addi	sp,sp,-8
8111954c:	de00012e 	bgeu	sp,et,81119554 <vCouldNotRetransmitB64TimeoutTask+0xc>
81119550:	003b68fa 	trap	3
81119554:	dfc00115 	stw	ra,4(sp)
81119558:	df000015 	stw	fp,0(sp)
8111955c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
81119560:	d0a06117 	ldw	r2,-32380(gp)
81119564:	100f883a 	mov	r7,r2
81119568:	01800a84 	movi	r6,42
8111956c:	01400044 	movi	r5,1
81119570:	01204574 	movhi	r4,33045
81119574:	212fa104 	addi	r4,r4,-16764
81119578:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111957c:	d0a06117 	ldw	r2,-32380(gp)
81119580:	100f883a 	mov	r7,r2
81119584:	01801444 	movi	r6,81
81119588:	01400044 	movi	r5,1
8111958c:	01204574 	movhi	r4,33045
81119590:	212fac04 	addi	r4,r4,-16720
81119594:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119598:	0001883a 	nop
8111959c:	e037883a 	mov	sp,fp
811195a0:	dfc00117 	ldw	ra,4(sp)
811195a4:	df000017 	ldw	fp,0(sp)
811195a8:	dec00204 	addi	sp,sp,8
811195ac:	f800283a 	ret

811195b0 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
811195b0:	defffe04 	addi	sp,sp,-8
811195b4:	de00012e 	bgeu	sp,et,811195bc <vCouldNotRetransmitB128TimeoutTask+0xc>
811195b8:	003b68fa 	trap	3
811195bc:	dfc00115 	stw	ra,4(sp)
811195c0:	df000015 	stw	fp,0(sp)
811195c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
811195c8:	d0a06117 	ldw	r2,-32380(gp)
811195cc:	100f883a 	mov	r7,r2
811195d0:	01800ac4 	movi	r6,43
811195d4:	01400044 	movi	r5,1
811195d8:	01204574 	movhi	r4,33045
811195dc:	212fc104 	addi	r4,r4,-16636
811195e0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
811195e4:	d0a06117 	ldw	r2,-32380(gp)
811195e8:	100f883a 	mov	r7,r2
811195ec:	01801484 	movi	r6,82
811195f0:	01400044 	movi	r5,1
811195f4:	01204574 	movhi	r4,33045
811195f8:	212fcc04 	addi	r4,r4,-16592
811195fc:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119600:	0001883a 	nop
81119604:	e037883a 	mov	sp,fp
81119608:	dfc00117 	ldw	ra,4(sp)
8111960c:	df000017 	ldw	fp,0(sp)
81119610:	dec00204 	addi	sp,sp,8
81119614:	f800283a 	ret

81119618 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
81119618:	defffe04 	addi	sp,sp,-8
8111961c:	de00012e 	bgeu	sp,et,81119624 <vFailStartTimerRetransmission+0xc>
81119620:	003b68fa 	trap	3
81119624:	dfc00115 	stw	ra,4(sp)
81119628:	df000015 	stw	fp,0(sp)
8111962c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
81119630:	d0a06117 	ldw	r2,-32380(gp)
81119634:	100f883a 	mov	r7,r2
81119638:	01800984 	movi	r6,38
8111963c:	01400044 	movi	r5,1
81119640:	01204574 	movhi	r4,33045
81119644:	212fe104 	addi	r4,r4,-16508
81119648:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111964c:	d0a06117 	ldw	r2,-32380(gp)
81119650:	100f883a 	mov	r7,r2
81119654:	01800d44 	movi	r6,53
81119658:	01400044 	movi	r5,1
8111965c:	01204574 	movhi	r4,33045
81119660:	212feb04 	addi	r4,r4,-16468
81119664:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119668:	0001883a 	nop
8111966c:	e037883a 	mov	sp,fp
81119670:	dfc00117 	ldw	ra,4(sp)
81119674:	df000017 	ldw	fp,0(sp)
81119678:	dec00204 	addi	sp,sp,8
8111967c:	f800283a 	ret

81119680 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
81119680:	defffe04 	addi	sp,sp,-8
81119684:	de00012e 	bgeu	sp,et,8111968c <vCouldNotSendTurnOff+0xc>
81119688:	003b68fa 	trap	3
8111968c:	dfc00115 	stw	ra,4(sp)
81119690:	df000015 	stw	fp,0(sp)
81119694:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
81119698:	d0a06117 	ldw	r2,-32380(gp)
8111969c:	100f883a 	mov	r7,r2
811196a0:	01800744 	movi	r6,29
811196a4:	01400044 	movi	r5,1
811196a8:	01204574 	movhi	r4,33045
811196ac:	212ff904 	addi	r4,r4,-16412
811196b0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
811196b4:	d0a06117 	ldw	r2,-32380(gp)
811196b8:	100f883a 	mov	r7,r2
811196bc:	01800984 	movi	r6,38
811196c0:	01400044 	movi	r5,1
811196c4:	01204574 	movhi	r4,33045
811196c8:	21300104 	addi	r4,r4,-16380
811196cc:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811196d0:	0001883a 	nop
811196d4:	e037883a 	mov	sp,fp
811196d8:	dfc00117 	ldw	ra,4(sp)
811196dc:	df000017 	ldw	fp,0(sp)
811196e0:	dec00204 	addi	sp,sp,8
811196e4:	f800283a 	ret

811196e8 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
811196e8:	defffe04 	addi	sp,sp,-8
811196ec:	de00012e 	bgeu	sp,et,811196f4 <vCouldNotSendReset+0xc>
811196f0:	003b68fa 	trap	3
811196f4:	dfc00115 	stw	ra,4(sp)
811196f8:	df000015 	stw	fp,0(sp)
811196fc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
81119700:	d0a06117 	ldw	r2,-32380(gp)
81119704:	100f883a 	mov	r7,r2
81119708:	018006c4 	movi	r6,27
8111970c:	01400044 	movi	r5,1
81119710:	01204574 	movhi	r4,33045
81119714:	21300b04 	addi	r4,r4,-16340
81119718:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
8111971c:	d0a06117 	ldw	r2,-32380(gp)
81119720:	100f883a 	mov	r7,r2
81119724:	018008c4 	movi	r6,35
81119728:	01400044 	movi	r5,1
8111972c:	01204574 	movhi	r4,33045
81119730:	21301204 	addi	r4,r4,-16312
81119734:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119738:	0001883a 	nop
8111973c:	e037883a 	mov	sp,fp
81119740:	dfc00117 	ldw	ra,4(sp)
81119744:	df000017 	ldw	fp,0(sp)
81119748:	dec00204 	addi	sp,sp,8
8111974c:	f800283a 	ret

81119750 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
81119750:	defffe04 	addi	sp,sp,-8
81119754:	de00012e 	bgeu	sp,et,8111975c <vCouldNotSendLog+0xc>
81119758:	003b68fa 	trap	3
8111975c:	dfc00115 	stw	ra,4(sp)
81119760:	df000015 	stw	fp,0(sp)
81119764:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
81119768:	d0a06117 	ldw	r2,-32380(gp)
8111976c:	100f883a 	mov	r7,r2
81119770:	01800644 	movi	r6,25
81119774:	01400044 	movi	r5,1
81119778:	01204574 	movhi	r4,33045
8111977c:	21301b04 	addi	r4,r4,-16276
81119780:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
81119784:	d0a06117 	ldw	r2,-32380(gp)
81119788:	100f883a 	mov	r7,r2
8111978c:	018008c4 	movi	r6,35
81119790:	01400044 	movi	r5,1
81119794:	01204574 	movhi	r4,33045
81119798:	21302204 	addi	r4,r4,-16248
8111979c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811197a0:	0001883a 	nop
811197a4:	e037883a 	mov	sp,fp
811197a8:	dfc00117 	ldw	ra,4(sp)
811197ac:	df000017 	ldw	fp,0(sp)
811197b0:	dec00204 	addi	sp,sp,8
811197b4:	f800283a 	ret

811197b8 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
811197b8:	defffd04 	addi	sp,sp,-12
811197bc:	de00012e 	bgeu	sp,et,811197c4 <vCouldNotSendTMPusCommand+0xc>
811197c0:	003b68fa 	trap	3
811197c4:	dfc00215 	stw	ra,8(sp)
811197c8:	df000115 	stw	fp,4(sp)
811197cc:	df000104 	addi	fp,sp,4
811197d0:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
811197d4:	d0a06117 	ldw	r2,-32380(gp)
811197d8:	100f883a 	mov	r7,r2
811197dc:	01800884 	movi	r6,34
811197e0:	01400044 	movi	r5,1
811197e4:	01204574 	movhi	r4,33045
811197e8:	21302b04 	addi	r4,r4,-16212
811197ec:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
811197f0:	d0a06117 	ldw	r2,-32380(gp)
811197f4:	100f883a 	mov	r7,r2
811197f8:	01800ac4 	movi	r6,43
811197fc:	01400044 	movi	r5,1
81119800:	01204574 	movhi	r4,33045
81119804:	21303404 	addi	r4,r4,-16176
81119808:	111dcb00 	call	8111dcb0 <fwrite>
		debug(fp,"cData");
8111980c:	d0a06117 	ldw	r2,-32380(gp)
81119810:	100f883a 	mov	r7,r2
81119814:	01800144 	movi	r6,5
81119818:	01400044 	movi	r5,1
8111981c:	01204574 	movhi	r4,33045
81119820:	21303f04 	addi	r4,r4,-16132
81119824:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119828:	0001883a 	nop
8111982c:	e037883a 	mov	sp,fp
81119830:	dfc00117 	ldw	ra,4(sp)
81119834:	df000017 	ldw	fp,0(sp)
81119838:	dec00204 	addi	sp,sp,8
8111983c:	f800283a 	ret

81119840 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
81119840:	defffe04 	addi	sp,sp,-8
81119844:	de00012e 	bgeu	sp,et,8111984c <vWarnCouldNotgetMutexRetrans128+0xc>
81119848:	003b68fa 	trap	3
8111984c:	dfc00115 	stw	ra,4(sp)
81119850:	df000015 	stw	fp,0(sp)
81119854:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
81119858:	d0a06117 	ldw	r2,-32380(gp)
8111985c:	100f883a 	mov	r7,r2
81119860:	01800a04 	movi	r6,40
81119864:	01400044 	movi	r5,1
81119868:	01204574 	movhi	r4,33045
8111986c:	21304104 	addi	r4,r4,-16124
81119870:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
81119874:	d0a06117 	ldw	r2,-32380(gp)
81119878:	100f883a 	mov	r7,r2
8111987c:	018014c4 	movi	r6,83
81119880:	01400044 	movi	r5,1
81119884:	01204574 	movhi	r4,33045
81119888:	21304c04 	addi	r4,r4,-16080
8111988c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119890:	0001883a 	nop
81119894:	e037883a 	mov	sp,fp
81119898:	dfc00117 	ldw	ra,4(sp)
8111989c:	df000017 	ldw	fp,0(sp)
811198a0:	dec00204 	addi	sp,sp,8
811198a4:	f800283a 	ret

811198a8 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
811198a8:	defffe04 	addi	sp,sp,-8
811198ac:	de00012e 	bgeu	sp,et,811198b4 <vFailCreateScheduleQueue+0xc>
811198b0:	003b68fa 	trap	3
811198b4:	dfc00115 	stw	ra,4(sp)
811198b8:	df000015 	stw	fp,0(sp)
811198bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
811198c0:	d0a06117 	ldw	r2,-32380(gp)
811198c4:	100f883a 	mov	r7,r2
811198c8:	01800844 	movi	r6,33
811198cc:	01400044 	movi	r5,1
811198d0:	01204574 	movhi	r4,33045
811198d4:	21306104 	addi	r4,r4,-15996
811198d8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
811198dc:	d0a06117 	ldw	r2,-32380(gp)
811198e0:	100f883a 	mov	r7,r2
811198e4:	01801204 	movi	r6,72
811198e8:	01400044 	movi	r5,1
811198ec:	01204574 	movhi	r4,33045
811198f0:	21306a04 	addi	r4,r4,-15960
811198f4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811198f8:	0001883a 	nop
811198fc:	e037883a 	mov	sp,fp
81119900:	dfc00117 	ldw	ra,4(sp)
81119904:	df000017 	ldw	fp,0(sp)
81119908:	dec00204 	addi	sp,sp,8
8111990c:	f800283a 	ret

81119910 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
81119910:	defffd04 	addi	sp,sp,-12
81119914:	de00012e 	bgeu	sp,et,8111991c <vFailCreateNFEEQueue+0xc>
81119918:	003b68fa 	trap	3
8111991c:	dfc00215 	stw	ra,8(sp)
81119920:	df000115 	stw	fp,4(sp)
81119924:	df000104 	addi	fp,sp,4
81119928:	2005883a 	mov	r2,r4
8111992c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
81119930:	d0a06117 	ldw	r2,-32380(gp)
81119934:	100f883a 	mov	r7,r2
81119938:	01800744 	movi	r6,29
8111993c:	01400044 	movi	r5,1
81119940:	01204574 	movhi	r4,33045
81119944:	21307d04 	addi	r4,r4,-15884
81119948:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111994c:	d0a06117 	ldw	r2,-32380(gp)
81119950:	e0ffff03 	ldbu	r3,-4(fp)
81119954:	180d883a 	mov	r6,r3
81119958:	01604574 	movhi	r5,33045
8111995c:	29708504 	addi	r5,r5,-15852
81119960:	1009883a 	mov	r4,r2
81119964:	111e9dc0 	call	8111e9dc <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119968:	0001883a 	nop
8111996c:	e037883a 	mov	sp,fp
81119970:	dfc00117 	ldw	ra,4(sp)
81119974:	df000017 	ldw	fp,0(sp)
81119978:	dec00204 	addi	sp,sp,8
8111997c:	f800283a 	ret

81119980 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
81119980:	defffd04 	addi	sp,sp,-12
81119984:	de00012e 	bgeu	sp,et,8111998c <vFailCreateNFEESyncQueue+0xc>
81119988:	003b68fa 	trap	3
8111998c:	dfc00215 	stw	ra,8(sp)
81119990:	df000115 	stw	fp,4(sp)
81119994:	df000104 	addi	fp,sp,4
81119998:	2005883a 	mov	r2,r4
8111999c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
811199a0:	d0a06117 	ldw	r2,-32380(gp)
811199a4:	100f883a 	mov	r7,r2
811199a8:	01800844 	movi	r6,33
811199ac:	01400044 	movi	r5,1
811199b0:	01204574 	movhi	r4,33045
811199b4:	21309304 	addi	r4,r4,-15796
811199b8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
811199bc:	d0a06117 	ldw	r2,-32380(gp)
811199c0:	e0ffff03 	ldbu	r3,-4(fp)
811199c4:	180d883a 	mov	r6,r3
811199c8:	01604574 	movhi	r5,33045
811199cc:	29709c04 	addi	r5,r5,-15760
811199d0:	1009883a 	mov	r4,r2
811199d4:	111e9dc0 	call	8111e9dc <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811199d8:	0001883a 	nop
811199dc:	e037883a 	mov	sp,fp
811199e0:	dfc00117 	ldw	ra,4(sp)
811199e4:	df000017 	ldw	fp,0(sp)
811199e8:	dec00204 	addi	sp,sp,8
811199ec:	f800283a 	ret

811199f0 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
811199f0:	defffe04 	addi	sp,sp,-8
811199f4:	de00012e 	bgeu	sp,et,811199fc <vCoudlNotCreateNFee0Task+0xc>
811199f8:	003b68fa 	trap	3
811199fc:	dfc00115 	stw	ra,4(sp)
81119a00:	df000015 	stw	fp,0(sp)
81119a04:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
81119a08:	d0a06117 	ldw	r2,-32380(gp)
81119a0c:	100f883a 	mov	r7,r2
81119a10:	01800844 	movi	r6,33
81119a14:	01400044 	movi	r5,1
81119a18:	01204574 	movhi	r4,33045
81119a1c:	2130aa04 	addi	r4,r4,-15704
81119a20:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
81119a24:	d0a06117 	ldw	r2,-32380(gp)
81119a28:	100f883a 	mov	r7,r2
81119a2c:	01800784 	movi	r6,30
81119a30:	01400044 	movi	r5,1
81119a34:	01204574 	movhi	r4,33045
81119a38:	2130b304 	addi	r4,r4,-15668
81119a3c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119a40:	0001883a 	nop
81119a44:	e037883a 	mov	sp,fp
81119a48:	dfc00117 	ldw	ra,4(sp)
81119a4c:	df000017 	ldw	fp,0(sp)
81119a50:	dec00204 	addi	sp,sp,8
81119a54:	f800283a 	ret

81119a58 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
81119a58:	defffe04 	addi	sp,sp,-8
81119a5c:	de00012e 	bgeu	sp,et,81119a64 <vCoudlNotCreateNFee1Task+0xc>
81119a60:	003b68fa 	trap	3
81119a64:	dfc00115 	stw	ra,4(sp)
81119a68:	df000015 	stw	fp,0(sp)
81119a6c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
81119a70:	d0a06117 	ldw	r2,-32380(gp)
81119a74:	100f883a 	mov	r7,r2
81119a78:	01800844 	movi	r6,33
81119a7c:	01400044 	movi	r5,1
81119a80:	01204574 	movhi	r4,33045
81119a84:	2130bb04 	addi	r4,r4,-15636
81119a88:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
81119a8c:	d0a06117 	ldw	r2,-32380(gp)
81119a90:	100f883a 	mov	r7,r2
81119a94:	01800784 	movi	r6,30
81119a98:	01400044 	movi	r5,1
81119a9c:	01204574 	movhi	r4,33045
81119aa0:	2130c404 	addi	r4,r4,-15600
81119aa4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119aa8:	0001883a 	nop
81119aac:	e037883a 	mov	sp,fp
81119ab0:	dfc00117 	ldw	ra,4(sp)
81119ab4:	df000017 	ldw	fp,0(sp)
81119ab8:	dec00204 	addi	sp,sp,8
81119abc:	f800283a 	ret

81119ac0 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
81119ac0:	defffe04 	addi	sp,sp,-8
81119ac4:	de00012e 	bgeu	sp,et,81119acc <vCoudlNotCreateNFee2Task+0xc>
81119ac8:	003b68fa 	trap	3
81119acc:	dfc00115 	stw	ra,4(sp)
81119ad0:	df000015 	stw	fp,0(sp)
81119ad4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
81119ad8:	d0a06117 	ldw	r2,-32380(gp)
81119adc:	100f883a 	mov	r7,r2
81119ae0:	01800844 	movi	r6,33
81119ae4:	01400044 	movi	r5,1
81119ae8:	01204574 	movhi	r4,33045
81119aec:	2130cc04 	addi	r4,r4,-15568
81119af0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
81119af4:	d0a06117 	ldw	r2,-32380(gp)
81119af8:	100f883a 	mov	r7,r2
81119afc:	01800784 	movi	r6,30
81119b00:	01400044 	movi	r5,1
81119b04:	01204574 	movhi	r4,33045
81119b08:	2130d504 	addi	r4,r4,-15532
81119b0c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119b10:	0001883a 	nop
81119b14:	e037883a 	mov	sp,fp
81119b18:	dfc00117 	ldw	ra,4(sp)
81119b1c:	df000017 	ldw	fp,0(sp)
81119b20:	dec00204 	addi	sp,sp,8
81119b24:	f800283a 	ret

81119b28 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
81119b28:	defffe04 	addi	sp,sp,-8
81119b2c:	de00012e 	bgeu	sp,et,81119b34 <vCoudlNotCreateNFee3Task+0xc>
81119b30:	003b68fa 	trap	3
81119b34:	dfc00115 	stw	ra,4(sp)
81119b38:	df000015 	stw	fp,0(sp)
81119b3c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
81119b40:	d0a06117 	ldw	r2,-32380(gp)
81119b44:	100f883a 	mov	r7,r2
81119b48:	01800844 	movi	r6,33
81119b4c:	01400044 	movi	r5,1
81119b50:	01204574 	movhi	r4,33045
81119b54:	2130dd04 	addi	r4,r4,-15500
81119b58:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
81119b5c:	d0a06117 	ldw	r2,-32380(gp)
81119b60:	100f883a 	mov	r7,r2
81119b64:	01800784 	movi	r6,30
81119b68:	01400044 	movi	r5,1
81119b6c:	01204574 	movhi	r4,33045
81119b70:	2130e604 	addi	r4,r4,-15464
81119b74:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119b78:	0001883a 	nop
81119b7c:	e037883a 	mov	sp,fp
81119b80:	dfc00117 	ldw	ra,4(sp)
81119b84:	df000017 	ldw	fp,0(sp)
81119b88:	dec00204 	addi	sp,sp,8
81119b8c:	f800283a 	ret

81119b90 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
81119b90:	defffe04 	addi	sp,sp,-8
81119b94:	de00012e 	bgeu	sp,et,81119b9c <vCoudlNotCreateNFee4Task+0xc>
81119b98:	003b68fa 	trap	3
81119b9c:	dfc00115 	stw	ra,4(sp)
81119ba0:	df000015 	stw	fp,0(sp)
81119ba4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
81119ba8:	d0a06117 	ldw	r2,-32380(gp)
81119bac:	100f883a 	mov	r7,r2
81119bb0:	01800844 	movi	r6,33
81119bb4:	01400044 	movi	r5,1
81119bb8:	01204574 	movhi	r4,33045
81119bbc:	2130ee04 	addi	r4,r4,-15432
81119bc0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
81119bc4:	d0a06117 	ldw	r2,-32380(gp)
81119bc8:	100f883a 	mov	r7,r2
81119bcc:	01800784 	movi	r6,30
81119bd0:	01400044 	movi	r5,1
81119bd4:	01204574 	movhi	r4,33045
81119bd8:	2130f704 	addi	r4,r4,-15396
81119bdc:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119be0:	0001883a 	nop
81119be4:	e037883a 	mov	sp,fp
81119be8:	dfc00117 	ldw	ra,4(sp)
81119bec:	df000017 	ldw	fp,0(sp)
81119bf0:	dec00204 	addi	sp,sp,8
81119bf4:	f800283a 	ret

81119bf8 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
81119bf8:	defffe04 	addi	sp,sp,-8
81119bfc:	de00012e 	bgeu	sp,et,81119c04 <vCoudlNotCreateNFee5Task+0xc>
81119c00:	003b68fa 	trap	3
81119c04:	dfc00115 	stw	ra,4(sp)
81119c08:	df000015 	stw	fp,0(sp)
81119c0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
81119c10:	d0a06117 	ldw	r2,-32380(gp)
81119c14:	100f883a 	mov	r7,r2
81119c18:	01800844 	movi	r6,33
81119c1c:	01400044 	movi	r5,1
81119c20:	01204574 	movhi	r4,33045
81119c24:	2130ff04 	addi	r4,r4,-15364
81119c28:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
81119c2c:	d0a06117 	ldw	r2,-32380(gp)
81119c30:	100f883a 	mov	r7,r2
81119c34:	01800784 	movi	r6,30
81119c38:	01400044 	movi	r5,1
81119c3c:	01204574 	movhi	r4,33045
81119c40:	21310804 	addi	r4,r4,-15328
81119c44:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119c48:	0001883a 	nop
81119c4c:	e037883a 	mov	sp,fp
81119c50:	dfc00117 	ldw	ra,4(sp)
81119c54:	df000017 	ldw	fp,0(sp)
81119c58:	dec00204 	addi	sp,sp,8
81119c5c:	f800283a 	ret

81119c60 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
81119c60:	defffe04 	addi	sp,sp,-8
81119c64:	de00012e 	bgeu	sp,et,81119c6c <vCoudlNotCreateNFeeControllerTask+0xc>
81119c68:	003b68fa 	trap	3
81119c6c:	dfc00115 	stw	ra,4(sp)
81119c70:	df000015 	stw	fp,0(sp)
81119c74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
81119c78:	d0a06117 	ldw	r2,-32380(gp)
81119c7c:	100f883a 	mov	r7,r2
81119c80:	01800a84 	movi	r6,42
81119c84:	01400044 	movi	r5,1
81119c88:	01204574 	movhi	r4,33045
81119c8c:	21311004 	addi	r4,r4,-15296
81119c90:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
81119c94:	d0a06117 	ldw	r2,-32380(gp)
81119c98:	100f883a 	mov	r7,r2
81119c9c:	018009c4 	movi	r6,39
81119ca0:	01400044 	movi	r5,1
81119ca4:	01204574 	movhi	r4,33045
81119ca8:	21311b04 	addi	r4,r4,-15252
81119cac:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119cb0:	0001883a 	nop
81119cb4:	e037883a 	mov	sp,fp
81119cb8:	dfc00117 	ldw	ra,4(sp)
81119cbc:	df000017 	ldw	fp,0(sp)
81119cc0:	dec00204 	addi	sp,sp,8
81119cc4:	f800283a 	ret

81119cc8 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
81119cc8:	defffe04 	addi	sp,sp,-8
81119ccc:	de00012e 	bgeu	sp,et,81119cd4 <vCoudlNotCreateDataControllerTask+0xc>
81119cd0:	003b68fa 	trap	3
81119cd4:	dfc00115 	stw	ra,4(sp)
81119cd8:	df000015 	stw	fp,0(sp)
81119cdc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
81119ce0:	d0a06117 	ldw	r2,-32380(gp)
81119ce4:	100f883a 	mov	r7,r2
81119ce8:	01800a84 	movi	r6,42
81119cec:	01400044 	movi	r5,1
81119cf0:	01204574 	movhi	r4,33045
81119cf4:	21312504 	addi	r4,r4,-15212
81119cf8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
81119cfc:	d0a06117 	ldw	r2,-32380(gp)
81119d00:	100f883a 	mov	r7,r2
81119d04:	018009c4 	movi	r6,39
81119d08:	01400044 	movi	r5,1
81119d0c:	01204574 	movhi	r4,33045
81119d10:	21313004 	addi	r4,r4,-15168
81119d14:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119d18:	0001883a 	nop
81119d1c:	e037883a 	mov	sp,fp
81119d20:	dfc00117 	ldw	ra,4(sp)
81119d24:	df000017 	ldw	fp,0(sp)
81119d28:	dec00204 	addi	sp,sp,8
81119d2c:	f800283a 	ret

81119d30 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
81119d30:	defffe04 	addi	sp,sp,-8
81119d34:	de00012e 	bgeu	sp,et,81119d3c <vCoudlNotCreateMebTask+0xc>
81119d38:	003b68fa 	trap	3
81119d3c:	dfc00115 	stw	ra,4(sp)
81119d40:	df000015 	stw	fp,0(sp)
81119d44:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
81119d48:	d0a06117 	ldw	r2,-32380(gp)
81119d4c:	100f883a 	mov	r7,r2
81119d50:	018007c4 	movi	r6,31
81119d54:	01400044 	movi	r5,1
81119d58:	01204574 	movhi	r4,33045
81119d5c:	21313a04 	addi	r4,r4,-15128
81119d60:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
81119d64:	d0a06117 	ldw	r2,-32380(gp)
81119d68:	100f883a 	mov	r7,r2
81119d6c:	018006c4 	movi	r6,27
81119d70:	01400044 	movi	r5,1
81119d74:	01204574 	movhi	r4,33045
81119d78:	21314204 	addi	r4,r4,-15096
81119d7c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119d80:	0001883a 	nop
81119d84:	e037883a 	mov	sp,fp
81119d88:	dfc00117 	ldw	ra,4(sp)
81119d8c:	df000017 	ldw	fp,0(sp)
81119d90:	dec00204 	addi	sp,sp,8
81119d94:	f800283a 	ret

81119d98 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
81119d98:	defffd04 	addi	sp,sp,-12
81119d9c:	de00012e 	bgeu	sp,et,81119da4 <vFailCreateMutexSPUSQueueMeb+0xc>
81119da0:	003b68fa 	trap	3
81119da4:	dfc00215 	stw	ra,8(sp)
81119da8:	df000115 	stw	fp,4(sp)
81119dac:	df000104 	addi	fp,sp,4
81119db0:	2005883a 	mov	r2,r4
81119db4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
81119db8:	d0a06117 	ldw	r2,-32380(gp)
81119dbc:	100f883a 	mov	r7,r2
81119dc0:	01800944 	movi	r6,37
81119dc4:	01400044 	movi	r5,1
81119dc8:	01204574 	movhi	r4,33045
81119dcc:	21314904 	addi	r4,r4,-15068
81119dd0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81119dd4:	e0bfff03 	ldbu	r2,-4(fp)
81119dd8:	1009883a 	mov	r4,r2
81119ddc:	11185440 	call	81118544 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119de0:	0001883a 	nop
81119de4:	e037883a 	mov	sp,fp
81119de8:	dfc00117 	ldw	ra,4(sp)
81119dec:	df000017 	ldw	fp,0(sp)
81119df0:	dec00204 	addi	sp,sp,8
81119df4:	f800283a 	ret

81119df8 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
81119df8:	defffe04 	addi	sp,sp,-8
81119dfc:	de00012e 	bgeu	sp,et,81119e04 <vFailSendPUStoMebTask+0xc>
81119e00:	003b68fa 	trap	3
81119e04:	dfc00115 	stw	ra,4(sp)
81119e08:	df000015 	stw	fp,0(sp)
81119e0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
81119e10:	d0a06117 	ldw	r2,-32380(gp)
81119e14:	100f883a 	mov	r7,r2
81119e18:	01800784 	movi	r6,30
81119e1c:	01400044 	movi	r5,1
81119e20:	01204574 	movhi	r4,33045
81119e24:	21315304 	addi	r4,r4,-15028
81119e28:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119e2c:	0001883a 	nop
81119e30:	e037883a 	mov	sp,fp
81119e34:	dfc00117 	ldw	ra,4(sp)
81119e38:	df000017 	ldw	fp,0(sp)
81119e3c:	dec00204 	addi	sp,sp,8
81119e40:	f800283a 	ret

81119e44 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
81119e44:	defffe04 	addi	sp,sp,-8
81119e48:	de00012e 	bgeu	sp,et,81119e50 <vCouldNotGetCmdQueueMeb+0xc>
81119e4c:	003b68fa 	trap	3
81119e50:	dfc00115 	stw	ra,4(sp)
81119e54:	df000015 	stw	fp,0(sp)
81119e58:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
81119e5c:	d0a06117 	ldw	r2,-32380(gp)
81119e60:	100f883a 	mov	r7,r2
81119e64:	01800a84 	movi	r6,42
81119e68:	01400044 	movi	r5,1
81119e6c:	01204574 	movhi	r4,33045
81119e70:	21315b04 	addi	r4,r4,-14996
81119e74:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
81119e78:	d0a06117 	ldw	r2,-32380(gp)
81119e7c:	100f883a 	mov	r7,r2
81119e80:	01800cc4 	movi	r6,51
81119e84:	01400044 	movi	r5,1
81119e88:	01204574 	movhi	r4,33045
81119e8c:	21316604 	addi	r4,r4,-14952
81119e90:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119e94:	0001883a 	nop
81119e98:	e037883a 	mov	sp,fp
81119e9c:	dfc00117 	ldw	ra,4(sp)
81119ea0:	df000017 	ldw	fp,0(sp)
81119ea4:	dec00204 	addi	sp,sp,8
81119ea8:	f800283a 	ret

81119eac <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
81119eac:	defffe04 	addi	sp,sp,-8
81119eb0:	de00012e 	bgeu	sp,et,81119eb8 <vCouldNotGetMutexMebPus+0xc>
81119eb4:	003b68fa 	trap	3
81119eb8:	dfc00115 	stw	ra,4(sp)
81119ebc:	df000015 	stw	fp,0(sp)
81119ec0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
81119ec4:	d0a06117 	ldw	r2,-32380(gp)
81119ec8:	100f883a 	mov	r7,r2
81119ecc:	01800804 	movi	r6,32
81119ed0:	01400044 	movi	r5,1
81119ed4:	01204574 	movhi	r4,33045
81119ed8:	21317304 	addi	r4,r4,-14900
81119edc:	111dcb00 	call	8111dcb0 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119ee0:	0001883a 	nop
81119ee4:	e037883a 	mov	sp,fp
81119ee8:	dfc00117 	ldw	ra,4(sp)
81119eec:	df000017 	ldw	fp,0(sp)
81119ef0:	dec00204 	addi	sp,sp,8
81119ef4:	f800283a 	ret

81119ef8 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
81119ef8:	defffe04 	addi	sp,sp,-8
81119efc:	de00012e 	bgeu	sp,et,81119f04 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
81119f00:	003b68fa 	trap	3
81119f04:	dfc00115 	stw	ra,4(sp)
81119f08:	df000015 	stw	fp,0(sp)
81119f0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
81119f10:	d0a06117 	ldw	r2,-32380(gp)
81119f14:	100f883a 	mov	r7,r2
81119f18:	01800a44 	movi	r6,41
81119f1c:	01400044 	movi	r5,1
81119f20:	01204574 	movhi	r4,33045
81119f24:	21317c04 	addi	r4,r4,-14864
81119f28:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
81119f2c:	d0a06117 	ldw	r2,-32380(gp)
81119f30:	100f883a 	mov	r7,r2
81119f34:	01800c84 	movi	r6,50
81119f38:	01400044 	movi	r5,1
81119f3c:	01204574 	movhi	r4,33045
81119f40:	21318704 	addi	r4,r4,-14820
81119f44:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119f48:	0001883a 	nop
81119f4c:	e037883a 	mov	sp,fp
81119f50:	dfc00117 	ldw	ra,4(sp)
81119f54:	df000017 	ldw	fp,0(sp)
81119f58:	dec00204 	addi	sp,sp,8
81119f5c:	f800283a 	ret

81119f60 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
81119f60:	defffe04 	addi	sp,sp,-8
81119f64:	de00012e 	bgeu	sp,et,81119f6c <vCouldNotCreateQueueMaskDataCtrl+0xc>
81119f68:	003b68fa 	trap	3
81119f6c:	dfc00115 	stw	ra,4(sp)
81119f70:	df000015 	stw	fp,0(sp)
81119f74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
81119f78:	d0a06117 	ldw	r2,-32380(gp)
81119f7c:	100f883a 	mov	r7,r2
81119f80:	01800a44 	movi	r6,41
81119f84:	01400044 	movi	r5,1
81119f88:	01204574 	movhi	r4,33045
81119f8c:	21319404 	addi	r4,r4,-14768
81119f90:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
81119f94:	d0a06117 	ldw	r2,-32380(gp)
81119f98:	100f883a 	mov	r7,r2
81119f9c:	01800c84 	movi	r6,50
81119fa0:	01400044 	movi	r5,1
81119fa4:	01204574 	movhi	r4,33045
81119fa8:	21319f04 	addi	r4,r4,-14724
81119fac:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119fb0:	0001883a 	nop
81119fb4:	e037883a 	mov	sp,fp
81119fb8:	dfc00117 	ldw	ra,4(sp)
81119fbc:	df000017 	ldw	fp,0(sp)
81119fc0:	dec00204 	addi	sp,sp,8
81119fc4:	f800283a 	ret

81119fc8 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
81119fc8:	defffe04 	addi	sp,sp,-8
81119fcc:	de00012e 	bgeu	sp,et,81119fd4 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
81119fd0:	003b68fa 	trap	3
81119fd4:	dfc00115 	stw	ra,4(sp)
81119fd8:	df000015 	stw	fp,0(sp)
81119fdc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
81119fe0:	d0a06117 	ldw	r2,-32380(gp)
81119fe4:	100f883a 	mov	r7,r2
81119fe8:	01800984 	movi	r6,38
81119fec:	01400044 	movi	r5,1
81119ff0:	01204574 	movhi	r4,33045
81119ff4:	2131ac04 	addi	r4,r4,-14672
81119ff8:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
81119ffc:	d0a06117 	ldw	r2,-32380(gp)
8111a000:	100f883a 	mov	r7,r2
8111a004:	01800bc4 	movi	r6,47
8111a008:	01400044 	movi	r5,1
8111a00c:	01204574 	movhi	r4,33045
8111a010:	2131b604 	addi	r4,r4,-14632
8111a014:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a018:	0001883a 	nop
8111a01c:	e037883a 	mov	sp,fp
8111a020:	dfc00117 	ldw	ra,4(sp)
8111a024:	df000017 	ldw	fp,0(sp)
8111a028:	dec00204 	addi	sp,sp,8
8111a02c:	f800283a 	ret

8111a030 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111a030:	defffe04 	addi	sp,sp,-8
8111a034:	de00012e 	bgeu	sp,et,8111a03c <vCouldNotGetQueueMaskDataCtrl+0xc>
8111a038:	003b68fa 	trap	3
8111a03c:	dfc00115 	stw	ra,4(sp)
8111a040:	df000015 	stw	fp,0(sp)
8111a044:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111a048:	d0a06117 	ldw	r2,-32380(gp)
8111a04c:	100f883a 	mov	r7,r2
8111a050:	01800984 	movi	r6,38
8111a054:	01400044 	movi	r5,1
8111a058:	01204574 	movhi	r4,33045
8111a05c:	2131c204 	addi	r4,r4,-14584
8111a060:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111a064:	d0a06117 	ldw	r2,-32380(gp)
8111a068:	100f883a 	mov	r7,r2
8111a06c:	01800bc4 	movi	r6,47
8111a070:	01400044 	movi	r5,1
8111a074:	01204574 	movhi	r4,33045
8111a078:	2131cc04 	addi	r4,r4,-14544
8111a07c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a080:	0001883a 	nop
8111a084:	e037883a 	mov	sp,fp
8111a088:	dfc00117 	ldw	ra,4(sp)
8111a08c:	df000017 	ldw	fp,0(sp)
8111a090:	dec00204 	addi	sp,sp,8
8111a094:	f800283a 	ret

8111a098 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111a098:	defffd04 	addi	sp,sp,-12
8111a09c:	de00012e 	bgeu	sp,et,8111a0a4 <vFailSendMsgAccessDMA+0xc>
8111a0a0:	003b68fa 	trap	3
8111a0a4:	dfc00215 	stw	ra,8(sp)
8111a0a8:	df000115 	stw	fp,4(sp)
8111a0ac:	df000104 	addi	fp,sp,4
8111a0b0:	2005883a 	mov	r2,r4
8111a0b4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
8111a0b8:	d0a06117 	ldw	r2,-32380(gp)
8111a0bc:	e0ffff03 	ldbu	r3,-4(fp)
8111a0c0:	180d883a 	mov	r6,r3
8111a0c4:	01604574 	movhi	r5,33045
8111a0c8:	2971d804 	addi	r5,r5,-14496
8111a0cc:	1009883a 	mov	r4,r2
8111a0d0:	111d6140 	call	8111d614 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a0d4:	0001883a 	nop
8111a0d8:	e037883a 	mov	sp,fp
8111a0dc:	dfc00117 	ldw	ra,4(sp)
8111a0e0:	df000017 	ldw	fp,0(sp)
8111a0e4:	dec00204 	addi	sp,sp,8
8111a0e8:	f800283a 	ret

8111a0ec <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111a0ec:	defffd04 	addi	sp,sp,-12
8111a0f0:	de00012e 	bgeu	sp,et,8111a0f8 <vFailRequestDMA+0xc>
8111a0f4:	003b68fa 	trap	3
8111a0f8:	dfc00215 	stw	ra,8(sp)
8111a0fc:	df000115 	stw	fp,4(sp)
8111a100:	df000104 	addi	fp,sp,4
8111a104:	2005883a 	mov	r2,r4
8111a108:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111a10c:	d0a06117 	ldw	r2,-32380(gp)
8111a110:	e0ffff03 	ldbu	r3,-4(fp)
8111a114:	180d883a 	mov	r6,r3
8111a118:	01604574 	movhi	r5,33045
8111a11c:	2971e004 	addi	r5,r5,-14464
8111a120:	1009883a 	mov	r4,r2
8111a124:	111d6140 	call	8111d614 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a128:	0001883a 	nop
8111a12c:	e037883a 	mov	sp,fp
8111a130:	dfc00117 	ldw	ra,4(sp)
8111a134:	df000017 	ldw	fp,0(sp)
8111a138:	dec00204 	addi	sp,sp,8
8111a13c:	f800283a 	ret

8111a140 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111a140:	defffd04 	addi	sp,sp,-12
8111a144:	de00012e 	bgeu	sp,et,8111a14c <vFailRequestDMAFromIRQ+0xc>
8111a148:	003b68fa 	trap	3
8111a14c:	dfc00215 	stw	ra,8(sp)
8111a150:	df000115 	stw	fp,4(sp)
8111a154:	df000104 	addi	fp,sp,4
8111a158:	2005883a 	mov	r2,r4
8111a15c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111a160:	d0a06117 	ldw	r2,-32380(gp)
8111a164:	e0ffff03 	ldbu	r3,-4(fp)
8111a168:	180d883a 	mov	r6,r3
8111a16c:	01604574 	movhi	r5,33045
8111a170:	2971e004 	addi	r5,r5,-14464
8111a174:	1009883a 	mov	r4,r2
8111a178:	111d6140 	call	8111d614 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a17c:	0001883a 	nop
8111a180:	e037883a 	mov	sp,fp
8111a184:	dfc00117 	ldw	ra,4(sp)
8111a188:	df000017 	ldw	fp,0(sp)
8111a18c:	dec00204 	addi	sp,sp,8
8111a190:	f800283a 	ret

8111a194 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111a194:	defffd04 	addi	sp,sp,-12
8111a198:	de00012e 	bgeu	sp,et,8111a1a0 <vFailSendRMAPFromIRQ+0xc>
8111a19c:	003b68fa 	trap	3
8111a1a0:	dfc00215 	stw	ra,8(sp)
8111a1a4:	df000115 	stw	fp,4(sp)
8111a1a8:	df000104 	addi	fp,sp,4
8111a1ac:	2005883a 	mov	r2,r4
8111a1b0:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n: \n", ucTemp);
8111a1b4:	d0a06117 	ldw	r2,-32380(gp)
8111a1b8:	e0ffff03 	ldbu	r3,-4(fp)
8111a1bc:	180d883a 	mov	r6,r3
8111a1c0:	01604574 	movhi	r5,33045
8111a1c4:	2971e704 	addi	r5,r5,-14436
8111a1c8:	1009883a 	mov	r4,r2
8111a1cc:	111d6140 	call	8111d614 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a1d0:	0001883a 	nop
8111a1d4:	e037883a 	mov	sp,fp
8111a1d8:	dfc00117 	ldw	ra,4(sp)
8111a1dc:	df000017 	ldw	fp,0(sp)
8111a1e0:	dec00204 	addi	sp,sp,8
8111a1e4:	f800283a 	ret

8111a1e8 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111a1e8:	defffd04 	addi	sp,sp,-12
8111a1ec:	de00012e 	bgeu	sp,et,8111a1f4 <vFailSendMsgSync+0xc>
8111a1f0:	003b68fa 	trap	3
8111a1f4:	dfc00215 	stw	ra,8(sp)
8111a1f8:	df000115 	stw	fp,4(sp)
8111a1fc:	df000104 	addi	fp,sp,4
8111a200:	2005883a 	mov	r2,r4
8111a204:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
8111a208:	d0a06117 	ldw	r2,-32380(gp)
8111a20c:	e0ffff03 	ldbu	r3,-4(fp)
8111a210:	180d883a 	mov	r6,r3
8111a214:	01604574 	movhi	r5,33045
8111a218:	2971ef04 	addi	r5,r5,-14404
8111a21c:	1009883a 	mov	r4,r2
8111a220:	111d6140 	call	8111d614 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a224:	0001883a 	nop
8111a228:	e037883a 	mov	sp,fp
8111a22c:	dfc00117 	ldw	ra,4(sp)
8111a230:	df000017 	ldw	fp,0(sp)
8111a234:	dec00204 	addi	sp,sp,8
8111a238:	f800283a 	ret

8111a23c <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111a23c:	defffd04 	addi	sp,sp,-12
8111a240:	de00012e 	bgeu	sp,et,8111a248 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111a244:	003b68fa 	trap	3
8111a248:	dfc00215 	stw	ra,8(sp)
8111a24c:	df000115 	stw	fp,4(sp)
8111a250:	df000104 	addi	fp,sp,4
8111a254:	2005883a 	mov	r2,r4
8111a258:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n: \n", ucTemp);
8111a25c:	d0a06117 	ldw	r2,-32380(gp)
8111a260:	e0ffff03 	ldbu	r3,-4(fp)
8111a264:	180d883a 	mov	r6,r3
8111a268:	01604574 	movhi	r5,33045
8111a26c:	2971f604 	addi	r5,r5,-14376
8111a270:	1009883a 	mov	r4,r2
8111a274:	111d6140 	call	8111d614 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a278:	0001883a 	nop
8111a27c:	e037883a 	mov	sp,fp
8111a280:	dfc00117 	ldw	ra,4(sp)
8111a284:	df000017 	ldw	fp,0(sp)
8111a288:	dec00204 	addi	sp,sp,8
8111a28c:	f800283a 	ret

8111a290 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111a290:	defffe04 	addi	sp,sp,-8
8111a294:	de00012e 	bgeu	sp,et,8111a29c <vFailSendMsgMasterSyncMeb+0xc>
8111a298:	003b68fa 	trap	3
8111a29c:	dfc00115 	stw	ra,4(sp)
8111a2a0:	df000015 	stw	fp,0(sp)
8111a2a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111a2a8:	d0a06117 	ldw	r2,-32380(gp)
8111a2ac:	100f883a 	mov	r7,r2
8111a2b0:	018006c4 	movi	r6,27
8111a2b4:	01400044 	movi	r5,1
8111a2b8:	01204574 	movhi	r4,33045
8111a2bc:	21320304 	addi	r4,r4,-14324
8111a2c0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a2c4:	0001883a 	nop
8111a2c8:	e037883a 	mov	sp,fp
8111a2cc:	dfc00117 	ldw	ra,4(sp)
8111a2d0:	df000017 	ldw	fp,0(sp)
8111a2d4:	dec00204 	addi	sp,sp,8
8111a2d8:	f800283a 	ret

8111a2dc <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111a2dc:	defffe04 	addi	sp,sp,-8
8111a2e0:	de00012e 	bgeu	sp,et,8111a2e8 <vFailSendMsgFeeCTRL+0xc>
8111a2e4:	003b68fa 	trap	3
8111a2e8:	dfc00115 	stw	ra,4(sp)
8111a2ec:	df000015 	stw	fp,0(sp)
8111a2f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111a2f4:	d0a06117 	ldw	r2,-32380(gp)
8111a2f8:	100f883a 	mov	r7,r2
8111a2fc:	018005c4 	movi	r6,23
8111a300:	01400044 	movi	r5,1
8111a304:	01204574 	movhi	r4,33045
8111a308:	21320a04 	addi	r4,r4,-14296
8111a30c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a310:	0001883a 	nop
8111a314:	e037883a 	mov	sp,fp
8111a318:	dfc00117 	ldw	ra,4(sp)
8111a31c:	df000017 	ldw	fp,0(sp)
8111a320:	dec00204 	addi	sp,sp,8
8111a324:	f800283a 	ret

8111a328 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111a328:	defffe04 	addi	sp,sp,-8
8111a32c:	de00012e 	bgeu	sp,et,8111a334 <vFailSendMsgDataCTRL+0xc>
8111a330:	003b68fa 	trap	3
8111a334:	dfc00115 	stw	ra,4(sp)
8111a338:	df000015 	stw	fp,0(sp)
8111a33c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111a340:	d0a06117 	ldw	r2,-32380(gp)
8111a344:	100f883a 	mov	r7,r2
8111a348:	01800604 	movi	r6,24
8111a34c:	01400044 	movi	r5,1
8111a350:	01204574 	movhi	r4,33045
8111a354:	21321004 	addi	r4,r4,-14272
8111a358:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a35c:	0001883a 	nop
8111a360:	e037883a 	mov	sp,fp
8111a364:	dfc00117 	ldw	ra,4(sp)
8111a368:	df000017 	ldw	fp,0(sp)
8111a36c:	dec00204 	addi	sp,sp,8
8111a370:	f800283a 	ret

8111a374 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111a374:	defffe04 	addi	sp,sp,-8
8111a378:	de00012e 	bgeu	sp,et,8111a380 <vFailFlushQueue+0xc>
8111a37c:	003b68fa 	trap	3
8111a380:	dfc00115 	stw	ra,4(sp)
8111a384:	df000015 	stw	fp,0(sp)
8111a388:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111a38c:	d0a06117 	ldw	r2,-32380(gp)
8111a390:	100f883a 	mov	r7,r2
8111a394:	01800744 	movi	r6,29
8111a398:	01400044 	movi	r5,1
8111a39c:	01204574 	movhi	r4,33045
8111a3a0:	21321704 	addi	r4,r4,-14244
8111a3a4:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a3a8:	0001883a 	nop
8111a3ac:	e037883a 	mov	sp,fp
8111a3b0:	dfc00117 	ldw	ra,4(sp)
8111a3b4:	df000017 	ldw	fp,0(sp)
8111a3b8:	dec00204 	addi	sp,sp,8
8111a3bc:	f800283a 	ret

8111a3c0 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111a3c0:	defffe04 	addi	sp,sp,-8
8111a3c4:	de00012e 	bgeu	sp,et,8111a3cc <vFailFlushQueueData+0xc>
8111a3c8:	003b68fa 	trap	3
8111a3cc:	dfc00115 	stw	ra,4(sp)
8111a3d0:	df000015 	stw	fp,0(sp)
8111a3d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111a3d8:	d0a06117 	ldw	r2,-32380(gp)
8111a3dc:	100f883a 	mov	r7,r2
8111a3e0:	01800844 	movi	r6,33
8111a3e4:	01400044 	movi	r5,1
8111a3e8:	01204574 	movhi	r4,33045
8111a3ec:	21321f04 	addi	r4,r4,-14212
8111a3f0:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a3f4:	0001883a 	nop
8111a3f8:	e037883a 	mov	sp,fp
8111a3fc:	dfc00117 	ldw	ra,4(sp)
8111a400:	df000017 	ldw	fp,0(sp)
8111a404:	dec00204 	addi	sp,sp,8
8111a408:	f800283a 	ret

8111a40c <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111a40c:	defffe04 	addi	sp,sp,-8
8111a410:	de00012e 	bgeu	sp,et,8111a418 <vFailFlushMEBQueue+0xc>
8111a414:	003b68fa 	trap	3
8111a418:	dfc00115 	stw	ra,4(sp)
8111a41c:	df000015 	stw	fp,0(sp)
8111a420:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111a424:	d0a06117 	ldw	r2,-32380(gp)
8111a428:	100f883a 	mov	r7,r2
8111a42c:	01800804 	movi	r6,32
8111a430:	01400044 	movi	r5,1
8111a434:	01204574 	movhi	r4,33045
8111a438:	21322804 	addi	r4,r4,-14176
8111a43c:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a440:	0001883a 	nop
8111a444:	e037883a 	mov	sp,fp
8111a448:	dfc00117 	ldw	ra,4(sp)
8111a44c:	df000017 	ldw	fp,0(sp)
8111a450:	dec00204 	addi	sp,sp,8
8111a454:	f800283a 	ret

8111a458 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111a458:	defffe04 	addi	sp,sp,-8
8111a45c:	de00012e 	bgeu	sp,et,8111a464 <vFailFlushNFEEQueue+0xc>
8111a460:	003b68fa 	trap	3
8111a464:	dfc00115 	stw	ra,4(sp)
8111a468:	df000015 	stw	fp,0(sp)
8111a46c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111a470:	d0a06117 	ldw	r2,-32380(gp)
8111a474:	100f883a 	mov	r7,r2
8111a478:	01800844 	movi	r6,33
8111a47c:	01400044 	movi	r5,1
8111a480:	01204574 	movhi	r4,33045
8111a484:	21323104 	addi	r4,r4,-14140
8111a488:	111dcb00 	call	8111dcb0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a48c:	0001883a 	nop
8111a490:	e037883a 	mov	sp,fp
8111a494:	dfc00117 	ldw	ra,4(sp)
8111a498:	df000017 	ldw	fp,0(sp)
8111a49c:	dec00204 	addi	sp,sp,8
8111a4a0:	f800283a 	ret

8111a4a4 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111a4a4:	deffff04 	addi	sp,sp,-4
8111a4a8:	de00012e 	bgeu	sp,et,8111a4b0 <vEvtChangeMebMode+0xc>
8111a4ac:	003b68fa 	trap	3
8111a4b0:	df000015 	stw	fp,0(sp)
8111a4b4:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111a4b8:	0001883a 	nop
8111a4bc:	e037883a 	mov	sp,fp
8111a4c0:	df000017 	ldw	fp,0(sp)
8111a4c4:	dec00104 	addi	sp,sp,4
8111a4c8:	f800283a 	ret

8111a4cc <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111a4cc:	deffff04 	addi	sp,sp,-4
8111a4d0:	de00012e 	bgeu	sp,et,8111a4d8 <vEvtChangeFeeControllerMode+0xc>
8111a4d4:	003b68fa 	trap	3
8111a4d8:	df000015 	stw	fp,0(sp)
8111a4dc:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111a4e0:	0001883a 	nop
8111a4e4:	e037883a 	mov	sp,fp
8111a4e8:	df000017 	ldw	fp,0(sp)
8111a4ec:	dec00104 	addi	sp,sp,4
8111a4f0:	f800283a 	ret

8111a4f4 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111a4f4:	deffff04 	addi	sp,sp,-4
8111a4f8:	de00012e 	bgeu	sp,et,8111a500 <vEvtChangeDataControllerMode+0xc>
8111a4fc:	003b68fa 	trap	3
8111a500:	df000015 	stw	fp,0(sp)
8111a504:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111a508:	0001883a 	nop
8111a50c:	e037883a 	mov	sp,fp
8111a510:	df000017 	ldw	fp,0(sp)
8111a514:	dec00104 	addi	sp,sp,4
8111a518:	f800283a 	ret

8111a51c <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111a51c:	defffd04 	addi	sp,sp,-12
8111a520:	de00012e 	bgeu	sp,et,8111a528 <vNFeeNotInUse+0xc>
8111a524:	003b68fa 	trap	3
8111a528:	df000215 	stw	fp,8(sp)
8111a52c:	df000204 	addi	fp,sp,8
8111a530:	e13ffe15 	stw	r4,-8(fp)
8111a534:	2805883a 	mov	r2,r5
8111a538:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111a53c:	e0bffe17 	ldw	r2,-8(fp)
8111a540:	e0ffff03 	ldbu	r3,-4(fp)
8111a544:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111a548:	e0bffe17 	ldw	r2,-8(fp)
8111a54c:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111a550:	e0bffe17 	ldw	r2,-8(fp)
8111a554:	10002315 	stw	zero,140(r2)
}
8111a558:	0001883a 	nop
8111a55c:	e037883a 	mov	sp,fp
8111a560:	df000017 	ldw	fp,0(sp)
8111a564:	dec00104 	addi	sp,sp,4
8111a568:	f800283a 	ret

8111a56c <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111a56c:	defffb04 	addi	sp,sp,-20
8111a570:	de00012e 	bgeu	sp,et,8111a578 <vNFeeStructureInit+0xc>
8111a574:	003b68fa 	trap	3
8111a578:	dfc00415 	stw	ra,16(sp)
8111a57c:	df000315 	stw	fp,12(sp)
8111a580:	df000304 	addi	fp,sp,12
8111a584:	e13ffe15 	stw	r4,-8(fp)
8111a588:	2805883a 	mov	r2,r5
8111a58c:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111a590:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111a594:	e0bffe17 	ldw	r2,-8(fp)
8111a598:	e0ffff03 	ldbu	r3,-4(fp)
8111a59c:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111a5a0:	e0bffe17 	ldw	r2,-8(fp)
8111a5a4:	10802f04 	addi	r2,r2,188
8111a5a8:	1009883a 	mov	r4,r2
8111a5ac:	11162000 	call	81116200 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111a5b0:	e13ffe17 	ldw	r4,-8(fp)
8111a5b4:	111a6e40 	call	8111a6e4 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111a5b8:	e0bffe17 	ldw	r2,-8(fp)
8111a5bc:	00c00044 	movi	r3,1
8111a5c0:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111a5c4:	e0bffe17 	ldw	r2,-8(fp)
8111a5c8:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111a5cc:	e0bffe17 	ldw	r2,-8(fp)
8111a5d0:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111a5d4:	e0bffe17 	ldw	r2,-8(fp)
8111a5d8:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111a5dc:	e0bffe17 	ldw	r2,-8(fp)
8111a5e0:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111a5e4:	e0bffe17 	ldw	r2,-8(fp)
8111a5e8:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111a5ec:	e0bffe17 	ldw	r2,-8(fp)
8111a5f0:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111a5f4:	e0bffe17 	ldw	r2,-8(fp)
8111a5f8:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111a5fc:	e0bffe17 	ldw	r2,-8(fp)
8111a600:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111a604:	e0bffe17 	ldw	r2,-8(fp)
8111a608:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111a60c:	e0bffe17 	ldw	r2,-8(fp)
8111a610:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111a614:	e0bffe17 	ldw	r2,-8(fp)
8111a618:	10002d15 	stw	zero,180(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111a61c:	e03ffd05 	stb	zero,-12(fp)
8111a620:	00000906 	br	8111a648 <vNFeeStructureInit+0xdc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111a624:	e0bffd03 	ldbu	r2,-12(fp)
8111a628:	e0fffe17 	ldw	r3,-8(fp)
8111a62c:	1885883a 	add	r2,r3,r2
8111a630:	10802a44 	addi	r2,r2,169
8111a634:	e0fffd03 	ldbu	r3,-12(fp)
8111a638:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111a63c:	e0bffd03 	ldbu	r2,-12(fp)
8111a640:	10800044 	addi	r2,r2,1
8111a644:	e0bffd05 	stb	r2,-12(fp)
8111a648:	e0bffd03 	ldbu	r2,-12(fp)
8111a64c:	10800130 	cmpltui	r2,r2,4
8111a650:	103ff41e 	bne	r2,zero,8111a624 <__reset+0xfb0fa624>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, ucIdNFEE ) == FALSE ) {
8111a654:	e0bffe17 	ldw	r2,-8(fp)
8111a658:	10803204 	addi	r2,r2,200
8111a65c:	e0ffff03 	ldbu	r3,-4(fp)
8111a660:	180b883a 	mov	r5,r3
8111a664:	1009883a 	mov	r4,r2
8111a668:	110461c0 	call	8110461c <bCommInitCh>
8111a66c:	1000091e 	bne	r2,zero,8111a694 <vNFeeStructureInit+0x128>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111a670:	d0e06117 	ldw	r3,-32380(gp)
8111a674:	e0bffe17 	ldw	r2,-8(fp)
8111a678:	10800003 	ldbu	r2,0(r2)
8111a67c:	10803fcc 	andi	r2,r2,255
8111a680:	100d883a 	mov	r6,r2
8111a684:	01604574 	movhi	r5,33045
8111a688:	29723a04 	addi	r5,r5,-14104
8111a68c:	1809883a 	mov	r4,r3
8111a690:	111d6140 	call	8111d614 <fprintf>
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, ucIdNFEE ) == FALSE ) {
8111a694:	e0bfff03 	ldbu	r2,-4(fp)
8111a698:	100b883a 	mov	r5,r2
8111a69c:	01000044 	movi	r4,1
8111a6a0:	11044b00 	call	811044b0 <bCommSetGlobalIrqEn>
8111a6a4:	1000091e 	bne	r2,zero,8111a6cc <vNFeeStructureInit+0x160>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111a6a8:	d0e06117 	ldw	r3,-32380(gp)
8111a6ac:	e0bffe17 	ldw	r2,-8(fp)
8111a6b0:	10800003 	ldbu	r2,0(r2)
8111a6b4:	10803fcc 	andi	r2,r2,255
8111a6b8:	100d883a 	mov	r6,r2
8111a6bc:	01604574 	movhi	r5,33045
8111a6c0:	29724604 	addi	r5,r5,-14056
8111a6c4:	1809883a 	mov	r4,r3
8111a6c8:	111d6140 	call	8111d614 <fprintf>
		#endif
    }

}
8111a6cc:	0001883a 	nop
8111a6d0:	e037883a 	mov	sp,fp
8111a6d4:	dfc00117 	ldw	ra,4(sp)
8111a6d8:	df000017 	ldw	fp,0(sp)
8111a6dc:	dec00204 	addi	sp,sp,8
8111a6e0:	f800283a 	ret

8111a6e4 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111a6e4:	defff404 	addi	sp,sp,-48
8111a6e8:	de00012e 	bgeu	sp,et,8111a6f0 <vUpdateMemMapFEE+0xc>
8111a6ec:	003b68fa 	trap	3
8111a6f0:	df000b15 	stw	fp,44(sp)
8111a6f4:	df000b04 	addi	fp,sp,44
8111a6f8:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111a6fc:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111a700:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111a704:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111a708:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111a70c:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111a710:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111a714:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111a718:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111a71c:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111a720:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111a724:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111a728:	e17fff17 	ldw	r5,-4(fp)
8111a72c:	01035a34 	movhi	r4,3432
8111a730:	21348c04 	addi	r4,r4,-11728
8111a734:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111a738:	e13fff17 	ldw	r4,-4(fp)
8111a73c:	21000003 	ldbu	r4,0(r4)
8111a740:	21403fcc 	andi	r5,r4,255
8111a744:	01035a34 	movhi	r4,3432
8111a748:	21348c04 	addi	r4,r4,-11728
8111a74c:	2909383a 	mul	r4,r5,r4
8111a750:	200b883a 	mov	r5,r4
8111a754:	e13fff17 	ldw	r4,-4(fp)
8111a758:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111a75c:	e13fff17 	ldw	r4,-4(fp)
8111a760:	21400117 	ldw	r5,4(r4)
8111a764:	01033234 	movhi	r4,3272
8111a768:	21348c04 	addi	r4,r4,-11728
8111a76c:	290b883a 	add	r5,r5,r4
8111a770:	e13fff17 	ldw	r4,-4(fp)
8111a774:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111a778:	e13fff17 	ldw	r4,-4(fp)
8111a77c:	2100310b 	ldhu	r4,196(r4)
8111a780:	217fffcc 	andi	r5,r4,65535
8111a784:	e13fff17 	ldw	r4,-4(fp)
8111a788:	2100300b 	ldhu	r4,192(r4)
8111a78c:	213fffcc 	andi	r4,r4,65535
8111a790:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111a794:	e13fff17 	ldw	r4,-4(fp)
8111a798:	2100308b 	ldhu	r4,194(r4)
8111a79c:	21bfffcc 	andi	r6,r4,65535
8111a7a0:	e13fff17 	ldw	r4,-4(fp)
8111a7a4:	21002f8b 	ldhu	r4,190(r4)
8111a7a8:	213fffcc 	andi	r4,r4,65535
8111a7ac:	310d883a 	add	r6,r6,r4
8111a7b0:	e13fff17 	ldw	r4,-4(fp)
8111a7b4:	21002f0b 	ldhu	r4,188(r4)
8111a7b8:	213fffcc 	andi	r4,r4,65535
8111a7bc:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111a7c0:	2909383a 	mul	r4,r5,r4
8111a7c4:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111a7c8:	e13ffa17 	ldw	r4,-24(fp)
8111a7cc:	2109883a 	add	r4,r4,r4
8111a7d0:	200b883a 	mov	r5,r4
8111a7d4:	e13fff17 	ldw	r4,-4(fp)
8111a7d8:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111a7dc:	e13fff17 	ldw	r4,-4(fp)
8111a7e0:	21000517 	ldw	r4,20(r4)
8111a7e4:	2008d0fa 	srli	r4,r4,3
8111a7e8:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111a7ec:	e13fff17 	ldw	r4,-4(fp)
8111a7f0:	21000517 	ldw	r4,20(r4)
8111a7f4:	210001cc 	andi	r4,r4,7
8111a7f8:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111a7fc:	e13ffb17 	ldw	r4,-20(fp)
8111a800:	20001226 	beq	r4,zero,8111a84c <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111a804:	e13ff517 	ldw	r4,-44(fp)
8111a808:	21000044 	addi	r4,r4,1
8111a80c:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111a810:	e13fff17 	ldw	r4,-4(fp)
8111a814:	21400517 	ldw	r5,20(r4)
8111a818:	e13ffb17 	ldw	r4,-20(fp)
8111a81c:	2909c83a 	sub	r4,r5,r4
8111a820:	21400204 	addi	r5,r4,8
8111a824:	e13fff17 	ldw	r4,-4(fp)
8111a828:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111a82c:	e13ffb17 	ldw	r4,-20(fp)
8111a830:	200b883a 	mov	r5,r4
8111a834:	01000204 	movi	r4,8
8111a838:	2149c83a 	sub	r4,r4,r5
8111a83c:	200b883a 	mov	r5,r4
8111a840:	e13fff17 	ldw	r4,-4(fp)
8111a844:	21400605 	stb	r5,24(r4)
8111a848:	00000206 	br	8111a854 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111a84c:	e13fff17 	ldw	r4,-4(fp)
8111a850:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111a854:	e13ff517 	ldw	r4,-44(fp)
8111a858:	2008d13a 	srli	r4,r4,4
8111a85c:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111a860:	e13ff517 	ldw	r4,-44(fp)
8111a864:	210003cc 	andi	r4,r4,15
8111a868:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111a86c:	e13ffc17 	ldw	r4,-16(fp)
8111a870:	20000b26 	beq	r4,zero,8111a8a0 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111a874:	e13ff717 	ldw	r4,-36(fp)
8111a878:	21000044 	addi	r4,r4,1
8111a87c:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111a880:	e17ff517 	ldw	r5,-44(fp)
8111a884:	e13ffc17 	ldw	r4,-16(fp)
8111a888:	290bc83a 	sub	r5,r5,r4
8111a88c:	e13ff717 	ldw	r4,-36(fp)
8111a890:	2909883a 	add	r4,r5,r4
8111a894:	21000404 	addi	r4,r4,16
8111a898:	e13ff615 	stw	r4,-40(fp)
8111a89c:	00000406 	br	8111a8b0 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111a8a0:	e17ff517 	ldw	r5,-44(fp)
8111a8a4:	e13ff717 	ldw	r4,-36(fp)
8111a8a8:	2909883a 	add	r4,r5,r4
8111a8ac:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111a8b0:	e13ff617 	ldw	r4,-40(fp)
8111a8b4:	200a90fa 	slli	r5,r4,3
8111a8b8:	e13fff17 	ldw	r4,-4(fp)
8111a8bc:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111a8c0:	e13ffb17 	ldw	r4,-20(fp)
8111a8c4:	20000926 	beq	r4,zero,8111a8ec <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111a8c8:	e13ffc17 	ldw	r4,-16(fp)
8111a8cc:	2109883a 	add	r4,r4,r4
8111a8d0:	2109883a 	add	r4,r4,r4
8111a8d4:	200b883a 	mov	r5,r4
8111a8d8:	e13ffb17 	ldw	r4,-20(fp)
8111a8dc:	2008d07a 	srli	r4,r4,1
8111a8e0:	2909883a 	add	r4,r5,r4
8111a8e4:	e13ff805 	stb	r4,-32(fp)
8111a8e8:	00000406 	br	8111a8fc <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111a8ec:	e13ffc17 	ldw	r4,-16(fp)
8111a8f0:	2109883a 	add	r4,r4,r4
8111a8f4:	2109883a 	add	r4,r4,r4
8111a8f8:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111a8fc:	e13ff803 	ldbu	r4,-32(fp)
8111a900:	01401004 	movi	r5,64
8111a904:	2909c83a 	sub	r4,r5,r4
8111a908:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
8111a90c:	e13ffd03 	ldbu	r4,-12(fp)
8111a910:	217ff804 	addi	r5,r4,-32
8111a914:	28000416 	blt	r5,zero,8111a928 <vUpdateMemMapFEE+0x244>
8111a918:	013fffc4 	movi	r4,-1
8111a91c:	2144d83a 	srl	r2,r4,r5
8111a920:	0007883a 	mov	r3,zero
8111a924:	00000a06 	br	8111a950 <vUpdateMemMapFEE+0x26c>
8111a928:	017fffc4 	movi	r5,-1
8111a92c:	280c907a 	slli	r6,r5,1
8111a930:	014007c4 	movi	r5,31
8111a934:	290bc83a 	sub	r5,r5,r4
8111a938:	314a983a 	sll	r5,r6,r5
8111a93c:	01bfffc4 	movi	r6,-1
8111a940:	3104d83a 	srl	r2,r6,r4
8111a944:	2884b03a 	or	r2,r5,r2
8111a948:	017fffc4 	movi	r5,-1
8111a94c:	2906d83a 	srl	r3,r5,r4
8111a950:	e13fff17 	ldw	r4,-4(fp)
8111a954:	20800715 	stw	r2,28(r4)
8111a958:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111a95c:	e0bfff17 	ldw	r2,-4(fp)
8111a960:	e0fff717 	ldw	r3,-36(fp)
8111a964:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111a968:	e0bfff17 	ldw	r2,-4(fp)
8111a96c:	10c00117 	ldw	r3,4(r2)
8111a970:	008004b4 	movhi	r2,18
8111a974:	10a40004 	addi	r2,r2,-28672
8111a978:	1885883a 	add	r2,r3,r2
8111a97c:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111a980:	e0bfff17 	ldw	r2,-4(fp)
8111a984:	10c00517 	ldw	r3,20(r2)
8111a988:	008000b4 	movhi	r2,2
8111a98c:	10a40004 	addi	r2,r2,-28672
8111a990:	1885883a 	add	r2,r3,r2
8111a994:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111a998:	e03ff845 	stb	zero,-31(fp)
8111a99c:	00001906 	br	8111aa04 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111a9a0:	e0bff843 	ldbu	r2,-31(fp)
8111a9a4:	e0ffff17 	ldw	r3,-4(fp)
8111a9a8:	10800624 	muli	r2,r2,24
8111a9ac:	1885883a 	add	r2,r3,r2
8111a9b0:	10800904 	addi	r2,r2,36
8111a9b4:	e0fff917 	ldw	r3,-28(fp)
8111a9b8:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111a9bc:	e0fff917 	ldw	r3,-28(fp)
8111a9c0:	e0bffe17 	ldw	r2,-8(fp)
8111a9c4:	1885883a 	add	r2,r3,r2
8111a9c8:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111a9cc:	e0bff843 	ldbu	r2,-31(fp)
8111a9d0:	e0ffff17 	ldw	r3,-4(fp)
8111a9d4:	10800624 	muli	r2,r2,24
8111a9d8:	1885883a 	add	r2,r3,r2
8111a9dc:	10800c04 	addi	r2,r2,48
8111a9e0:	e0fff917 	ldw	r3,-28(fp)
8111a9e4:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111a9e8:	e0fff917 	ldw	r3,-28(fp)
8111a9ec:	e0bffe17 	ldw	r2,-8(fp)
8111a9f0:	1885883a 	add	r2,r3,r2
8111a9f4:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111a9f8:	e0bff843 	ldbu	r2,-31(fp)
8111a9fc:	10800044 	addi	r2,r2,1
8111aa00:	e0bff845 	stb	r2,-31(fp)
8111aa04:	e0bff843 	ldbu	r2,-31(fp)
8111aa08:	10800130 	cmpltui	r2,r2,4
8111aa0c:	103fe41e 	bne	r2,zero,8111a9a0 <__reset+0xfb0fa9a0>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
8111aa10:	0001883a 	nop
8111aa14:	e037883a 	mov	sp,fp
8111aa18:	df000017 	ldw	fp,0(sp)
8111aa1c:	dec00104 	addi	sp,sp,4
8111aa20:	f800283a 	ret

8111aa24 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111aa24:	defffd04 	addi	sp,sp,-12
8111aa28:	de00012e 	bgeu	sp,et,8111aa30 <vResetMemCCDFEE+0xc>
8111aa2c:	003b68fa 	trap	3
8111aa30:	df000215 	stw	fp,8(sp)
8111aa34:	df000204 	addi	fp,sp,8
8111aa38:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111aa3c:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111aa40:	e03ffe05 	stb	zero,-8(fp)
8111aa44:	00001b06 	br	8111aab4 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111aa48:	e0bffe03 	ldbu	r2,-8(fp)
8111aa4c:	e0ffff17 	ldw	r3,-4(fp)
8111aa50:	10800624 	muli	r2,r2,24
8111aa54:	1885883a 	add	r2,r3,r2
8111aa58:	10800b04 	addi	r2,r2,44
8111aa5c:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111aa60:	e0bffe03 	ldbu	r2,-8(fp)
8111aa64:	e0ffff17 	ldw	r3,-4(fp)
8111aa68:	10800624 	muli	r2,r2,24
8111aa6c:	1885883a 	add	r2,r3,r2
8111aa70:	10800a04 	addi	r2,r2,40
8111aa74:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111aa78:	e0bffe03 	ldbu	r2,-8(fp)
8111aa7c:	e0ffff17 	ldw	r3,-4(fp)
8111aa80:	10800624 	muli	r2,r2,24
8111aa84:	1885883a 	add	r2,r3,r2
8111aa88:	10800e04 	addi	r2,r2,56
8111aa8c:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111aa90:	e0bffe03 	ldbu	r2,-8(fp)
8111aa94:	e0ffff17 	ldw	r3,-4(fp)
8111aa98:	10800624 	muli	r2,r2,24
8111aa9c:	1885883a 	add	r2,r3,r2
8111aaa0:	10800d04 	addi	r2,r2,52
8111aaa4:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111aaa8:	e0bffe03 	ldbu	r2,-8(fp)
8111aaac:	10800044 	addi	r2,r2,1
8111aab0:	e0bffe05 	stb	r2,-8(fp)
8111aab4:	e0bffe03 	ldbu	r2,-8(fp)
8111aab8:	10800130 	cmpltui	r2,r2,4
8111aabc:	103fe21e 	bne	r2,zero,8111aa48 <__reset+0xfb0faa48>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111aac0:	0001883a 	nop
8111aac4:	e037883a 	mov	sp,fp
8111aac8:	df000017 	ldw	fp,0(sp)
8111aacc:	dec00104 	addi	sp,sp,4
8111aad0:	f800283a 	ret

8111aad4 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111aad4:	defffe04 	addi	sp,sp,-8
8111aad8:	de00012e 	bgeu	sp,et,8111aae0 <vFeeSpwRMAPLoadDefault+0xc>
8111aadc:	003b68fa 	trap	3
8111aae0:	df000115 	stw	fp,4(sp)
8111aae4:	df000104 	addi	fp,sp,4
8111aae8:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111aaec:	0001883a 	nop
8111aaf0:	e037883a 	mov	sp,fp
8111aaf4:	df000017 	ldw	fp,0(sp)
8111aaf8:	dec00104 	addi	sp,sp,4
8111aafc:	f800283a 	ret

8111ab00 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111ab00:	defffe04 	addi	sp,sp,-8
8111ab04:	de00012e 	bgeu	sp,et,8111ab0c <vFeeSpwRMAPChangeConfig+0xc>
8111ab08:	003b68fa 	trap	3
8111ab0c:	df000115 	stw	fp,4(sp)
8111ab10:	df000104 	addi	fp,sp,4
8111ab14:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111ab18:	0001883a 	nop
8111ab1c:	e037883a 	mov	sp,fp
8111ab20:	df000017 	ldw	fp,0(sp)
8111ab24:	dec00104 	addi	sp,sp,4
8111ab28:	f800283a 	ret

8111ab2c <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111ab2c:	defffe04 	addi	sp,sp,-8
8111ab30:	de00012e 	bgeu	sp,et,8111ab38 <vFeeSpwRMAPChangeDefault+0xc>
8111ab34:	003b68fa 	trap	3
8111ab38:	df000115 	stw	fp,4(sp)
8111ab3c:	df000104 	addi	fp,sp,4
8111ab40:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111ab44:	0001883a 	nop
8111ab48:	e037883a 	mov	sp,fp
8111ab4c:	df000017 	ldw	fp,0(sp)
8111ab50:	dec00104 	addi	sp,sp,4
8111ab54:	f800283a 	ret

8111ab58 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111ab58:	defffe04 	addi	sp,sp,-8
8111ab5c:	de00012e 	bgeu	sp,et,8111ab64 <cFeeSpwChannelEnable+0xc>
8111ab60:	003b68fa 	trap	3
8111ab64:	df000115 	stw	fp,4(sp)
8111ab68:	df000104 	addi	fp,sp,4
8111ab6c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111ab70:	0001883a 	nop
8111ab74:	e037883a 	mov	sp,fp
8111ab78:	df000017 	ldw	fp,0(sp)
8111ab7c:	dec00104 	addi	sp,sp,4
8111ab80:	f800283a 	ret

8111ab84 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111ab84:	defffe04 	addi	sp,sp,-8
8111ab88:	de00012e 	bgeu	sp,et,8111ab90 <cFeeSpwChannelDisable+0xc>
8111ab8c:	003b68fa 	trap	3
8111ab90:	df000115 	stw	fp,4(sp)
8111ab94:	df000104 	addi	fp,sp,4
8111ab98:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111ab9c:	0001883a 	nop
8111aba0:	e037883a 	mov	sp,fp
8111aba4:	df000017 	ldw	fp,0(sp)
8111aba8:	dec00104 	addi	sp,sp,4
8111abac:	f800283a 	ret

8111abb0 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111abb0:	defffe04 	addi	sp,sp,-8
8111abb4:	de00012e 	bgeu	sp,et,8111abbc <cFeeRMAPDump+0xc>
8111abb8:	003b68fa 	trap	3
8111abbc:	df000115 	stw	fp,4(sp)
8111abc0:	df000104 	addi	fp,sp,4
8111abc4:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111abc8:	0001883a 	nop
8111abcc:	e037883a 	mov	sp,fp
8111abd0:	df000017 	ldw	fp,0(sp)
8111abd4:	dec00104 	addi	sp,sp,4
8111abd8:	f800283a 	ret

8111abdc <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111abdc:	defffe04 	addi	sp,sp,-8
8111abe0:	de00012e 	bgeu	sp,et,8111abe8 <cFeeRMAPEchoingEnable+0xc>
8111abe4:	003b68fa 	trap	3
8111abe8:	df000115 	stw	fp,4(sp)
8111abec:	df000104 	addi	fp,sp,4
8111abf0:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111abf4:	e0bfff17 	ldw	r2,-4(fp)
8111abf8:	00c00044 	movi	r3,1
8111abfc:	10c02515 	stw	r3,148(r2)
}
8111ac00:	0001883a 	nop
8111ac04:	e037883a 	mov	sp,fp
8111ac08:	df000017 	ldw	fp,0(sp)
8111ac0c:	dec00104 	addi	sp,sp,4
8111ac10:	f800283a 	ret

8111ac14 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111ac14:	defffe04 	addi	sp,sp,-8
8111ac18:	de00012e 	bgeu	sp,et,8111ac20 <cFeeRMAPEchoingDisable+0xc>
8111ac1c:	003b68fa 	trap	3
8111ac20:	df000115 	stw	fp,4(sp)
8111ac24:	df000104 	addi	fp,sp,4
8111ac28:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111ac2c:	e0bfff17 	ldw	r2,-4(fp)
8111ac30:	10002515 	stw	zero,148(r2)
}
8111ac34:	0001883a 	nop
8111ac38:	e037883a 	mov	sp,fp
8111ac3c:	df000017 	ldw	fp,0(sp)
8111ac40:	dec00104 	addi	sp,sp,4
8111ac44:	f800283a 	ret

8111ac48 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111ac48:	defffe04 	addi	sp,sp,-8
8111ac4c:	de00012e 	bgeu	sp,et,8111ac54 <cFeeRMAPLogEnable+0xc>
8111ac50:	003b68fa 	trap	3
8111ac54:	df000115 	stw	fp,4(sp)
8111ac58:	df000104 	addi	fp,sp,4
8111ac5c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111ac60:	e0bfff17 	ldw	r2,-4(fp)
8111ac64:	00c00044 	movi	r3,1
8111ac68:	10c02415 	stw	r3,144(r2)
}
8111ac6c:	0001883a 	nop
8111ac70:	e037883a 	mov	sp,fp
8111ac74:	df000017 	ldw	fp,0(sp)
8111ac78:	dec00104 	addi	sp,sp,4
8111ac7c:	f800283a 	ret

8111ac80 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111ac80:	defffe04 	addi	sp,sp,-8
8111ac84:	de00012e 	bgeu	sp,et,8111ac8c <cFeeRMAPLogDisable+0xc>
8111ac88:	003b68fa 	trap	3
8111ac8c:	df000115 	stw	fp,4(sp)
8111ac90:	df000104 	addi	fp,sp,4
8111ac94:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111ac98:	e0bfff17 	ldw	r2,-4(fp)
8111ac9c:	10002415 	stw	zero,144(r2)
}
8111aca0:	0001883a 	nop
8111aca4:	e037883a 	mov	sp,fp
8111aca8:	df000017 	ldw	fp,0(sp)
8111acac:	dec00104 	addi	sp,sp,4
8111acb0:	f800283a 	ret

8111acb4 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111acb4:	defffc04 	addi	sp,sp,-16
8111acb8:	de00012e 	bgeu	sp,et,8111acc0 <vNFeeControlInit+0xc>
8111acbc:	003b68fa 	trap	3
8111acc0:	dfc00315 	stw	ra,12(sp)
8111acc4:	df000215 	stw	fp,8(sp)
8111acc8:	df000204 	addi	fp,sp,8
8111accc:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111acd0:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111acd4:	e13fff17 	ldw	r4,-4(fp)
8111acd8:	111ae000 	call	8111ae00 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111acdc:	e13fff17 	ldw	r4,-4(fp)
8111ace0:	111ae340 	call	8111ae34 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111ace4:	e0bfff17 	ldw	r2,-4(fp)
8111ace8:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111acec:	e03ffe05 	stb	zero,-8(fp)
8111acf0:	00002b06 	br	8111ada0 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111acf4:	e0bffe03 	ldbu	r2,-8(fp)
8111acf8:	10809624 	muli	r2,r2,600
8111acfc:	e0ffff17 	ldw	r3,-4(fp)
8111ad00:	1885883a 	add	r2,r3,r2
8111ad04:	e0fffe03 	ldbu	r3,-8(fp)
8111ad08:	180b883a 	mov	r5,r3
8111ad0c:	1009883a 	mov	r4,r2
8111ad10:	111a56c0 	call	8111a56c <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111ad14:	e0bffe03 	ldbu	r2,-8(fp)
8111ad18:	e0fffe03 	ldbu	r3,-8(fp)
8111ad1c:	18c09624 	muli	r3,r3,600
8111ad20:	18c02104 	addi	r3,r3,132
8111ad24:	e13fff17 	ldw	r4,-4(fp)
8111ad28:	20c7883a 	add	r3,r4,r3
8111ad2c:	e13fff17 	ldw	r4,-4(fp)
8111ad30:	108025c4 	addi	r2,r2,151
8111ad34:	1085883a 	add	r2,r2,r2
8111ad38:	1085883a 	add	r2,r2,r2
8111ad3c:	2085883a 	add	r2,r4,r2
8111ad40:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111ad44:	e0bffe03 	ldbu	r2,-8(fp)
8111ad48:	e0fffe03 	ldbu	r3,-8(fp)
8111ad4c:	18c09624 	muli	r3,r3,600
8111ad50:	18c02704 	addi	r3,r3,156
8111ad54:	e13fff17 	ldw	r4,-4(fp)
8111ad58:	20c7883a 	add	r3,r4,r3
8111ad5c:	e13fff17 	ldw	r4,-4(fp)
8111ad60:	10802604 	addi	r2,r2,152
8111ad64:	1085883a 	add	r2,r2,r2
8111ad68:	1085883a 	add	r2,r2,r2
8111ad6c:	2085883a 	add	r2,r4,r2
8111ad70:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111ad74:	e0bffe03 	ldbu	r2,-8(fp)
8111ad78:	e0ffff17 	ldw	r3,-4(fp)
8111ad7c:	18c09617 	ldw	r3,600(r3)
8111ad80:	e13fff17 	ldw	r4,-4(fp)
8111ad84:	10809624 	muli	r2,r2,600
8111ad88:	2085883a 	add	r2,r4,r2
8111ad8c:	10802904 	addi	r2,r2,164
8111ad90:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111ad94:	e0bffe03 	ldbu	r2,-8(fp)
8111ad98:	10800044 	addi	r2,r2,1
8111ad9c:	e0bffe05 	stb	r2,-8(fp)
8111ada0:	e0bffe03 	ldbu	r2,-8(fp)
8111ada4:	103fd326 	beq	r2,zero,8111acf4 <__reset+0xfb0facf4>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111ada8:	0001883a 	nop
8111adac:	e037883a 	mov	sp,fp
8111adb0:	dfc00117 	ldw	ra,4(sp)
8111adb4:	df000017 	ldw	fp,0(sp)
8111adb8:	dec00204 	addi	sp,sp,8
8111adbc:	f800283a 	ret

8111adc0 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111adc0:	defffd04 	addi	sp,sp,-12
8111adc4:	de00012e 	bgeu	sp,et,8111adcc <vSetTimeCode+0xc>
8111adc8:	003b68fa 	trap	3
8111adcc:	df000215 	stw	fp,8(sp)
8111add0:	df000204 	addi	fp,sp,8
8111add4:	e13ffe15 	stw	r4,-8(fp)
8111add8:	2805883a 	mov	r2,r5
8111addc:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111ade0:	e0bffe17 	ldw	r2,-8(fp)
8111ade4:	e0ffff03 	ldbu	r3,-4(fp)
8111ade8:	10c09905 	stb	r3,612(r2)
}
8111adec:	0001883a 	nop
8111adf0:	e037883a 	mov	sp,fp
8111adf4:	df000017 	ldw	fp,0(sp)
8111adf8:	dec00104 	addi	sp,sp,4
8111adfc:	f800283a 	ret

8111ae00 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111ae00:	defffe04 	addi	sp,sp,-8
8111ae04:	de00012e 	bgeu	sp,et,8111ae0c <vResetTimeCode+0xc>
8111ae08:	003b68fa 	trap	3
8111ae0c:	df000115 	stw	fp,4(sp)
8111ae10:	df000104 	addi	fp,sp,4
8111ae14:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111ae18:	e0bfff17 	ldw	r2,-4(fp)
8111ae1c:	10009905 	stb	zero,612(r2)
}
8111ae20:	0001883a 	nop
8111ae24:	e037883a 	mov	sp,fp
8111ae28:	df000017 	ldw	fp,0(sp)
8111ae2c:	dec00104 	addi	sp,sp,4
8111ae30:	f800283a 	ret

8111ae34 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111ae34:	defffe04 	addi	sp,sp,-8
8111ae38:	de00012e 	bgeu	sp,et,8111ae40 <vLoadDefaultIdNFEEMaster+0xc>
8111ae3c:	003b68fa 	trap	3
8111ae40:	df000115 	stw	fp,4(sp)
8111ae44:	df000104 	addi	fp,sp,4
8111ae48:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111ae4c:	e0bfff17 	ldw	r2,-4(fp)
8111ae50:	10009945 	stb	zero,613(r2)
}
8111ae54:	0001883a 	nop
8111ae58:	e037883a 	mov	sp,fp
8111ae5c:	df000017 	ldw	fp,0(sp)
8111ae60:	dec00104 	addi	sp,sp,4
8111ae64:	f800283a 	ret

8111ae68 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111ae68:	defffd04 	addi	sp,sp,-12
8111ae6c:	de00012e 	bgeu	sp,et,8111ae74 <vChangeIdNFEEMaster+0xc>
8111ae70:	003b68fa 	trap	3
8111ae74:	df000215 	stw	fp,8(sp)
8111ae78:	df000204 	addi	fp,sp,8
8111ae7c:	e13ffe15 	stw	r4,-8(fp)
8111ae80:	2805883a 	mov	r2,r5
8111ae84:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111ae88:	e0bffe17 	ldw	r2,-8(fp)
8111ae8c:	e0ffff03 	ldbu	r3,-4(fp)
8111ae90:	10c09945 	stb	r3,613(r2)
}
8111ae94:	0001883a 	nop
8111ae98:	e037883a 	mov	sp,fp
8111ae9c:	df000017 	ldw	fp,0(sp)
8111aea0:	dec00104 	addi	sp,sp,4
8111aea4:	f800283a 	ret

8111aea8 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111aea8:	defffd04 	addi	sp,sp,-12
8111aeac:	de00012e 	bgeu	sp,et,8111aeb4 <vChangeDefaultIdNFEEMaster+0xc>
8111aeb0:	003b68fa 	trap	3
8111aeb4:	df000215 	stw	fp,8(sp)
8111aeb8:	df000204 	addi	fp,sp,8
8111aebc:	e13ffe15 	stw	r4,-8(fp)
8111aec0:	2805883a 	mov	r2,r5
8111aec4:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111aec8:	0001883a 	nop
8111aecc:	e037883a 	mov	sp,fp
8111aed0:	df000017 	ldw	fp,0(sp)
8111aed4:	dec00104 	addi	sp,sp,4
8111aed8:	f800283a 	ret

8111aedc <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111aedc:	defffe04 	addi	sp,sp,-8
8111aee0:	de00012e 	bgeu	sp,et,8111aee8 <vInitSimucamBasicHW+0xc>
8111aee4:	003b68fa 	trap	3
8111aee8:	dfc00115 	stw	ra,4(sp)
8111aeec:	df000015 	stw	fp,0(sp)
8111aef0:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111aef4:	01403fc4 	movi	r5,255
8111aef8:	0009883a 	mov	r4,zero
8111aefc:	110a9b00 	call	8110a9b0 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111af00:	01400834 	movhi	r5,32
8111af04:	297fffc4 	addi	r5,r5,-1
8111af08:	0009883a 	mov	r4,zero
8111af0c:	110aa300 	call	8110aa30 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111af10:	01400074 	movhi	r5,1
8111af14:	01000044 	movi	r4,1
8111af18:	110aa300 	call	8110aa30 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111af1c:	0009883a 	mov	r4,zero
8111af20:	110c00c0 	call	8110c00c <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111af24:	0009883a 	mov	r4,zero
8111af28:	110c0dc0 	call	8110c0dc <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111af2c:	01008004 	movi	r4,512
8111af30:	110bb6c0 	call	8110bb6c <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111af34:	01008004 	movi	r4,512
8111af38:	110baf80 	call	8110baf8 <vRstcReleaseDeviceReset>

}
8111af3c:	0001883a 	nop
8111af40:	e037883a 	mov	sp,fp
8111af44:	dfc00117 	ldw	ra,4(sp)
8111af48:	df000017 	ldw	fp,0(sp)
8111af4c:	dec00204 	addi	sp,sp,8
8111af50:	f800283a 	ret

8111af54 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111af54:	defffd04 	addi	sp,sp,-12
8111af58:	de00012e 	bgeu	sp,et,8111af60 <bLogWriteSDCard+0xc>
8111af5c:	003b68fa 	trap	3
8111af60:	df000215 	stw	fp,8(sp)
8111af64:	df000204 	addi	fp,sp,8
8111af68:	e13ffe15 	stw	r4,-8(fp)
8111af6c:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111af70:	00800044 	movi	r2,1
}
8111af74:	e037883a 	mov	sp,fp
8111af78:	df000017 	ldw	fp,0(sp)
8111af7c:	dec00104 	addi	sp,sp,4
8111af80:	f800283a 	ret

8111af84 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111af84:	deffe004 	addi	sp,sp,-128
8111af88:	de00012e 	bgeu	sp,et,8111af90 <vLogWriteNUC+0xc>
8111af8c:	003b68fa 	trap	3
8111af90:	dfc01f15 	stw	ra,124(sp)
8111af94:	df001e15 	stw	fp,120(sp)
8111af98:	df001e04 	addi	fp,sp,120
8111af9c:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111afa0:	e03fe215 	stw	zero,-120(fp)
8111afa4:	e0bfe304 	addi	r2,fp,-116
8111afa8:	00c01b84 	movi	r3,110
8111afac:	180d883a 	mov	r6,r3
8111afb0:	000b883a 	mov	r5,zero
8111afb4:	1009883a 	mov	r4,r2
8111afb8:	111e8140 	call	8111e814 <memset>
	memset(cTemp,0,114);
8111afbc:	01801c84 	movi	r6,114
8111afc0:	000b883a 	mov	r5,zero
8111afc4:	e13fe204 	addi	r4,fp,-120
8111afc8:	111e8140 	call	8111e814 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111afcc:	e13fff17 	ldw	r4,-4(fp)
8111afd0:	111f1b80 	call	8111f1b8 <strlen>
8111afd4:	10801c68 	cmpgeui	r2,r2,113
8111afd8:	1000031e 	bne	r2,zero,8111afe8 <vLogWriteNUC+0x64>
8111afdc:	e13fff17 	ldw	r4,-4(fp)
8111afe0:	111f1b80 	call	8111f1b8 <strlen>
8111afe4:	00000106 	br	8111afec <vLogWriteNUC+0x68>
8111afe8:	00801c44 	movi	r2,113
8111afec:	100d883a 	mov	r6,r2
8111aff0:	e17fff17 	ldw	r5,-4(fp)
8111aff4:	e13fe204 	addi	r4,fp,-120
8111aff8:	111e6c40 	call	8111e6c4 <memcpy>
	vSendLog ( cDataIn );
8111affc:	e13fff17 	ldw	r4,-4(fp)
8111b000:	11170980 	call	81117098 <vSendLog>
}
8111b004:	0001883a 	nop
8111b008:	e037883a 	mov	sp,fp
8111b00c:	dfc00117 	ldw	ra,4(sp)
8111b010:	df000017 	ldw	fp,0(sp)
8111b014:	dec00204 	addi	sp,sp,8
8111b018:	f800283a 	ret

8111b01c <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111b01c:	defffd04 	addi	sp,sp,-12
8111b020:	de00012e 	bgeu	sp,et,8111b028 <vSimucamStructureInit+0xc>
8111b024:	003b68fa 	trap	3
8111b028:	dfc00215 	stw	ra,8(sp)
8111b02c:	df000115 	stw	fp,4(sp)
8111b030:	df000104 	addi	fp,sp,4
8111b034:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111b038:	e0bfff17 	ldw	r2,-4(fp)
8111b03c:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111b040:	e0bfff17 	ldw	r2,-4(fp)
8111b044:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111b048:	e13fff17 	ldw	r4,-4(fp)
8111b04c:	111b1080 	call	8111b108 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111b050:	e13fff17 	ldw	r4,-4(fp)
8111b054:	111b1ac0 	call	8111b1ac <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111b058:	e13fff17 	ldw	r4,-4(fp)
8111b05c:	111b2540 	call	8111b254 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111b060:	e13fff17 	ldw	r4,-4(fp)
8111b064:	111b2f40 	call	8111b2f4 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111b068:	e0bfff17 	ldw	r2,-4(fp)
8111b06c:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111b070:	e0bfff17 	ldw	r2,-4(fp)
8111b074:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111b078:	e0bfff17 	ldw	r2,-4(fp)
8111b07c:	00c07d04 	movi	r3,500
8111b080:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111b084:	e0bfff17 	ldw	r2,-4(fp)
8111b088:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111b08c:	e0bfff17 	ldw	r2,-4(fp)
8111b090:	00c00044 	movi	r3,1
8111b094:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111b098:	e0bfff17 	ldw	r2,-4(fp)
8111b09c:	10c00204 	addi	r3,r2,8
8111b0a0:	e0bfff17 	ldw	r2,-4(fp)
8111b0a4:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111b0a8:	e0bfff17 	ldw	r2,-4(fp)
8111b0ac:	10c00244 	addi	r3,r2,9
8111b0b0:	e0bfff17 	ldw	r2,-4(fp)
8111b0b4:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111b0b8:	e0bfff17 	ldw	r2,-4(fp)
8111b0bc:	10800017 	ldw	r2,0(r2)
8111b0c0:	10000b1e 	bne	r2,zero,8111b0f0 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111b0c4:	e0bfff17 	ldw	r2,-4(fp)
8111b0c8:	10801204 	addi	r2,r2,72
8111b0cc:	1009883a 	mov	r4,r2
8111b0d0:	111acb40 	call	8111acb4 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111b0d4:	e0bfff17 	ldw	r2,-4(fp)
8111b0d8:	10c00a04 	addi	r3,r2,40
8111b0dc:	e0bfff17 	ldw	r2,-4(fp)
8111b0e0:	10801204 	addi	r2,r2,72
8111b0e4:	100b883a 	mov	r5,r2
8111b0e8:	1809883a 	mov	r4,r3
8111b0ec:	11184640 	call	81118464 <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
8111b0f0:	0001883a 	nop
8111b0f4:	e037883a 	mov	sp,fp
8111b0f8:	dfc00117 	ldw	ra,4(sp)
8111b0fc:	df000017 	ldw	fp,0(sp)
8111b100:	dec00204 	addi	sp,sp,8
8111b104:	f800283a 	ret

8111b108 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111b108:	defffe04 	addi	sp,sp,-8
8111b10c:	de00012e 	bgeu	sp,et,8111b114 <vLoadDefaultEPValue+0xc>
8111b110:	003b68fa 	trap	3
8111b114:	df000115 	stw	fp,4(sp)
8111b118:	df000104 	addi	fp,sp,4
8111b11c:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111b120:	e0bfff17 	ldw	r2,-4(fp)
8111b124:	00d07234 	movhi	r3,16840
8111b128:	10c00315 	stw	r3,12(r2)
}
8111b12c:	0001883a 	nop
8111b130:	e037883a 	mov	sp,fp
8111b134:	df000017 	ldw	fp,0(sp)
8111b138:	dec00104 	addi	sp,sp,4
8111b13c:	f800283a 	ret

8111b140 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111b140:	defffd04 	addi	sp,sp,-12
8111b144:	de00012e 	bgeu	sp,et,8111b14c <vChangeEPValue+0xc>
8111b148:	003b68fa 	trap	3
8111b14c:	df000215 	stw	fp,8(sp)
8111b150:	df000204 	addi	fp,sp,8
8111b154:	e13ffe15 	stw	r4,-8(fp)
8111b158:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111b15c:	e0bffe17 	ldw	r2,-8(fp)
8111b160:	e0ffff17 	ldw	r3,-4(fp)
8111b164:	10c00315 	stw	r3,12(r2)
}
8111b168:	0001883a 	nop
8111b16c:	e037883a 	mov	sp,fp
8111b170:	df000017 	ldw	fp,0(sp)
8111b174:	dec00104 	addi	sp,sp,4
8111b178:	f800283a 	ret

8111b17c <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111b17c:	defffd04 	addi	sp,sp,-12
8111b180:	de00012e 	bgeu	sp,et,8111b188 <vChangeDefaultEPValue+0xc>
8111b184:	003b68fa 	trap	3
8111b188:	df000215 	stw	fp,8(sp)
8111b18c:	df000204 	addi	fp,sp,8
8111b190:	e13ffe15 	stw	r4,-8(fp)
8111b194:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111b198:	0001883a 	nop
8111b19c:	e037883a 	mov	sp,fp
8111b1a0:	df000017 	ldw	fp,0(sp)
8111b1a4:	dec00104 	addi	sp,sp,4
8111b1a8:	f800283a 	ret

8111b1ac <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111b1ac:	defffe04 	addi	sp,sp,-8
8111b1b0:	de00012e 	bgeu	sp,et,8111b1b8 <vLoadDefaultRTValue+0xc>
8111b1b4:	003b68fa 	trap	3
8111b1b8:	df000115 	stw	fp,4(sp)
8111b1bc:	df000104 	addi	fp,sp,4
8111b1c0:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111b1c4:	e0ffff17 	ldw	r3,-4(fp)
8111b1c8:	00901eb4 	movhi	r2,16506
8111b1cc:	10a66684 	addi	r2,r2,-26214
8111b1d0:	18800415 	stw	r2,16(r3)
}
8111b1d4:	0001883a 	nop
8111b1d8:	e037883a 	mov	sp,fp
8111b1dc:	df000017 	ldw	fp,0(sp)
8111b1e0:	dec00104 	addi	sp,sp,4
8111b1e4:	f800283a 	ret

8111b1e8 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111b1e8:	defffd04 	addi	sp,sp,-12
8111b1ec:	de00012e 	bgeu	sp,et,8111b1f4 <vChangeRTValue+0xc>
8111b1f0:	003b68fa 	trap	3
8111b1f4:	df000215 	stw	fp,8(sp)
8111b1f8:	df000204 	addi	fp,sp,8
8111b1fc:	e13ffe15 	stw	r4,-8(fp)
8111b200:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111b204:	e0bffe17 	ldw	r2,-8(fp)
8111b208:	e0ffff17 	ldw	r3,-4(fp)
8111b20c:	10c00415 	stw	r3,16(r2)
}
8111b210:	0001883a 	nop
8111b214:	e037883a 	mov	sp,fp
8111b218:	df000017 	ldw	fp,0(sp)
8111b21c:	dec00104 	addi	sp,sp,4
8111b220:	f800283a 	ret

8111b224 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111b224:	defffd04 	addi	sp,sp,-12
8111b228:	de00012e 	bgeu	sp,et,8111b230 <vChangeDefaultRTValue+0xc>
8111b22c:	003b68fa 	trap	3
8111b230:	df000215 	stw	fp,8(sp)
8111b234:	df000204 	addi	fp,sp,8
8111b238:	e13ffe15 	stw	r4,-8(fp)
8111b23c:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111b240:	0001883a 	nop
8111b244:	e037883a 	mov	sp,fp
8111b248:	df000017 	ldw	fp,0(sp)
8111b24c:	dec00104 	addi	sp,sp,4
8111b250:	f800283a 	ret

8111b254 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111b254:	defffe04 	addi	sp,sp,-8
8111b258:	de00012e 	bgeu	sp,et,8111b260 <vLoadDefaultSyncSource+0xc>
8111b25c:	003b68fa 	trap	3
8111b260:	df000115 	stw	fp,4(sp)
8111b264:	df000104 	addi	fp,sp,4
8111b268:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111b26c:	e0bfff17 	ldw	r2,-4(fp)
8111b270:	10000815 	stw	zero,32(r2)
}
8111b274:	0001883a 	nop
8111b278:	e037883a 	mov	sp,fp
8111b27c:	df000017 	ldw	fp,0(sp)
8111b280:	dec00104 	addi	sp,sp,4
8111b284:	f800283a 	ret

8111b288 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111b288:	defffd04 	addi	sp,sp,-12
8111b28c:	de00012e 	bgeu	sp,et,8111b294 <vChangeSyncSource+0xc>
8111b290:	003b68fa 	trap	3
8111b294:	df000215 	stw	fp,8(sp)
8111b298:	df000204 	addi	fp,sp,8
8111b29c:	e13ffe15 	stw	r4,-8(fp)
8111b2a0:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111b2a4:	e0bffe17 	ldw	r2,-8(fp)
8111b2a8:	e0ffff17 	ldw	r3,-4(fp)
8111b2ac:	10c00815 	stw	r3,32(r2)
}
8111b2b0:	0001883a 	nop
8111b2b4:	e037883a 	mov	sp,fp
8111b2b8:	df000017 	ldw	fp,0(sp)
8111b2bc:	dec00104 	addi	sp,sp,4
8111b2c0:	f800283a 	ret

8111b2c4 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111b2c4:	defffd04 	addi	sp,sp,-12
8111b2c8:	de00012e 	bgeu	sp,et,8111b2d0 <vChangeDefaultSyncSource+0xc>
8111b2cc:	003b68fa 	trap	3
8111b2d0:	df000215 	stw	fp,8(sp)
8111b2d4:	df000204 	addi	fp,sp,8
8111b2d8:	e13ffe15 	stw	r4,-8(fp)
8111b2dc:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111b2e0:	0001883a 	nop
8111b2e4:	e037883a 	mov	sp,fp
8111b2e8:	df000017 	ldw	fp,0(sp)
8111b2ec:	dec00104 	addi	sp,sp,4
8111b2f0:	f800283a 	ret

8111b2f4 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111b2f4:	defffe04 	addi	sp,sp,-8
8111b2f8:	de00012e 	bgeu	sp,et,8111b300 <vLoadDefaultAutoResetSync+0xc>
8111b2fc:	003b68fa 	trap	3
8111b300:	df000115 	stw	fp,4(sp)
8111b304:	df000104 	addi	fp,sp,4
8111b308:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111b30c:	e0bfff17 	ldw	r2,-4(fp)
8111b310:	00c00044 	movi	r3,1
8111b314:	10c00915 	stw	r3,36(r2)
}
8111b318:	0001883a 	nop
8111b31c:	e037883a 	mov	sp,fp
8111b320:	df000017 	ldw	fp,0(sp)
8111b324:	dec00104 	addi	sp,sp,4
8111b328:	f800283a 	ret

8111b32c <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111b32c:	defffd04 	addi	sp,sp,-12
8111b330:	de00012e 	bgeu	sp,et,8111b338 <vChangeAutoResetSync+0xc>
8111b334:	003b68fa 	trap	3
8111b338:	df000215 	stw	fp,8(sp)
8111b33c:	df000204 	addi	fp,sp,8
8111b340:	e13ffe15 	stw	r4,-8(fp)
8111b344:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111b348:	e0bffe17 	ldw	r2,-8(fp)
8111b34c:	e0ffff17 	ldw	r3,-4(fp)
8111b350:	10c00915 	stw	r3,36(r2)
}
8111b354:	0001883a 	nop
8111b358:	e037883a 	mov	sp,fp
8111b35c:	df000017 	ldw	fp,0(sp)
8111b360:	dec00104 	addi	sp,sp,4
8111b364:	f800283a 	ret

8111b368 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111b368:	defffd04 	addi	sp,sp,-12
8111b36c:	de00012e 	bgeu	sp,et,8111b374 <vChangeDefaultAutoResetSync+0xc>
8111b370:	003b68fa 	trap	3
8111b374:	df000215 	stw	fp,8(sp)
8111b378:	df000204 	addi	fp,sp,8
8111b37c:	e13ffe15 	stw	r4,-8(fp)
8111b380:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111b384:	0001883a 	nop
8111b388:	e037883a 	mov	sp,fp
8111b38c:	df000017 	ldw	fp,0(sp)
8111b390:	dec00104 	addi	sp,sp,4
8111b394:	f800283a 	ret

8111b398 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111b398:	defffc04 	addi	sp,sp,-16
8111b39c:	de00012e 	bgeu	sp,et,8111b3a4 <vSyncReset+0xc>
8111b3a0:	003b68fa 	trap	3
8111b3a4:	dfc00315 	stw	ra,12(sp)
8111b3a8:	df000215 	stw	fp,8(sp)
8111b3ac:	df000204 	addi	fp,sp,8
8111b3b0:	e13ffe15 	stw	r4,-8(fp)
8111b3b4:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111b3b8:	e0bffe17 	ldw	r2,-8(fp)
8111b3bc:	10801204 	addi	r2,r2,72
8111b3c0:	1009883a 	mov	r4,r2
8111b3c4:	111ae000 	call	8111ae00 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111b3c8:	0001883a 	nop
8111b3cc:	e037883a 	mov	sp,fp
8111b3d0:	dfc00117 	ldw	ra,4(sp)
8111b3d4:	df000017 	ldw	fp,0(sp)
8111b3d8:	dec00204 	addi	sp,sp,8
8111b3dc:	f800283a 	ret

8111b3e0 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111b3e0:	defff004 	addi	sp,sp,-64
8111b3e4:	de00012e 	bgeu	sp,et,8111b3ec <pattern_createPattern+0xc>
8111b3e8:	003b68fa 	trap	3
8111b3ec:	dfc00f15 	stw	ra,60(sp)
8111b3f0:	df000e15 	stw	fp,56(sp)
8111b3f4:	dcc00d15 	stw	r19,52(sp)
8111b3f8:	dc800c15 	stw	r18,48(sp)
8111b3fc:	dc400b15 	stw	r17,44(sp)
8111b400:	dc000a15 	stw	r16,40(sp)
8111b404:	df000e04 	addi	fp,sp,56
8111b408:	e17ff915 	stw	r5,-28(fp)
8111b40c:	3007883a 	mov	r3,r6
8111b410:	3805883a 	mov	r2,r7
8111b414:	e13ff805 	stb	r4,-32(fp)
8111b418:	e0fffa05 	stb	r3,-24(fp)
8111b41c:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111b420:	e0bff803 	ldbu	r2,-32(fp)
8111b424:	1009883a 	mov	r4,r2
8111b428:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111b42c:	e0bff917 	ldw	r2,-28(fp)
8111b430:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111b434:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111b438:	e0bff217 	ldw	r2,-56(fp)
8111b43c:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111b440:	e03ff515 	stw	zero,-44(fp)
8111b444:	00003606 	br	8111b520 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111b448:	e03ff615 	stw	zero,-40(fp)
8111b44c:	00002e06 	br	8111b508 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111b450:	e0bff303 	ldbu	r2,-52(fp)
8111b454:	10801018 	cmpnei	r2,r2,64
8111b458:	10000b1e 	bne	r2,zero,8111b488 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111b45c:	e0bff417 	ldw	r2,-48(fp)
8111b460:	00ffffc4 	movi	r3,-1
8111b464:	10c02015 	stw	r3,128(r2)
8111b468:	00ffffc4 	movi	r3,-1
8111b46c:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111b470:	e0bff217 	ldw	r2,-56(fp)
8111b474:	10802204 	addi	r2,r2,136
8111b478:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111b47c:	e0bff217 	ldw	r2,-56(fp)
8111b480:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111b484:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111b488:	e0bff303 	ldbu	r2,-52(fp)
8111b48c:	10c00044 	addi	r3,r2,1
8111b490:	e0fff305 	stb	r3,-52(fp)
8111b494:	10803fcc 	andi	r2,r2,255
8111b498:	e0fffa03 	ldbu	r3,-24(fp)
8111b49c:	18c000cc 	andi	r3,r3,3
8111b4a0:	180692fa 	slli	r3,r3,11
8111b4a4:	1809883a 	mov	r4,r3
8111b4a8:	00f80004 	movi	r3,-8192
8111b4ac:	20c6b03a 	or	r3,r4,r3
8111b4b0:	1809883a 	mov	r4,r3
8111b4b4:	e0fffb03 	ldbu	r3,-20(fp)
8111b4b8:	18c0004c 	andi	r3,r3,1
8111b4bc:	180692ba 	slli	r3,r3,10
8111b4c0:	20c6b03a 	or	r3,r4,r3
8111b4c4:	1809883a 	mov	r4,r3
8111b4c8:	e0fff517 	ldw	r3,-44(fp)
8111b4cc:	18c007cc 	andi	r3,r3,31
8111b4d0:	1806917a 	slli	r3,r3,5
8111b4d4:	20c6b03a 	or	r3,r4,r3
8111b4d8:	1809883a 	mov	r4,r3
8111b4dc:	e0fff617 	ldw	r3,-40(fp)
8111b4e0:	18c007cc 	andi	r3,r3,31
8111b4e4:	20c6b03a 	or	r3,r4,r3
8111b4e8:	1809883a 	mov	r4,r3
8111b4ec:	e0fff417 	ldw	r3,-48(fp)
8111b4f0:	1085883a 	add	r2,r2,r2
8111b4f4:	1885883a 	add	r2,r3,r2
8111b4f8:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111b4fc:	e0bff617 	ldw	r2,-40(fp)
8111b500:	10800044 	addi	r2,r2,1
8111b504:	e0bff615 	stw	r2,-40(fp)
8111b508:	e0fff617 	ldw	r3,-40(fp)
8111b50c:	e0800217 	ldw	r2,8(fp)
8111b510:	18bfcf36 	bltu	r3,r2,8111b450 <__reset+0xfb0fb450>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111b514:	e0bff517 	ldw	r2,-44(fp)
8111b518:	10800044 	addi	r2,r2,1
8111b51c:	e0bff515 	stw	r2,-44(fp)
8111b520:	e0fff517 	ldw	r3,-44(fp)
8111b524:	e0800317 	ldw	r2,12(fp)
8111b528:	18bfc736 	bltu	r3,r2,8111b448 <__reset+0xfb0fb448>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111b52c:	e0bff303 	ldbu	r2,-52(fp)
8111b530:	e0bff705 	stb	r2,-36(fp)
8111b534:	00000806 	br	8111b558 <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
8111b538:	e0bff703 	ldbu	r2,-36(fp)
8111b53c:	e0fff417 	ldw	r3,-48(fp)
8111b540:	1085883a 	add	r2,r2,r2
8111b544:	1885883a 	add	r2,r3,r2
8111b548:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111b54c:	e0bff703 	ldbu	r2,-36(fp)
8111b550:	10800044 	addi	r2,r2,1
8111b554:	e0bff705 	stb	r2,-36(fp)
8111b558:	e0bff703 	ldbu	r2,-36(fp)
8111b55c:	10801030 	cmpltui	r2,r2,64
8111b560:	103ff51e 	bne	r2,zero,8111b538 <__reset+0xfb0fb538>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
8111b564:	e0bff417 	ldw	r2,-48(fp)
8111b568:	10002015 	stw	zero,128(r2)
8111b56c:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111b570:	e03ff745 	stb	zero,-35(fp)
8111b574:	00001106 	br	8111b5bc <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
8111b578:	e13ff417 	ldw	r4,-48(fp)
8111b57c:	20802017 	ldw	r2,128(r4)
8111b580:	20c02117 	ldw	r3,132(r4)
8111b584:	e13ff743 	ldbu	r4,-35(fp)
8111b588:	01400044 	movi	r5,1
8111b58c:	2908983a 	sll	r4,r5,r4
8111b590:	2025883a 	mov	r18,r4
8111b594:	2009d7fa 	srai	r4,r4,31
8111b598:	2027883a 	mov	r19,r4
8111b59c:	14a0b03a 	or	r16,r2,r18
8111b5a0:	1ce2b03a 	or	r17,r3,r19
8111b5a4:	e0bff417 	ldw	r2,-48(fp)
8111b5a8:	14002015 	stw	r16,128(r2)
8111b5ac:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111b5b0:	e0bff743 	ldbu	r2,-35(fp)
8111b5b4:	10800044 	addi	r2,r2,1
8111b5b8:	e0bff745 	stb	r2,-35(fp)
8111b5bc:	e0fff743 	ldbu	r3,-35(fp)
8111b5c0:	e0bff303 	ldbu	r2,-52(fp)
8111b5c4:	18bfec36 	bltu	r3,r2,8111b578 <__reset+0xfb0fb578>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111b5c8:	e0bff217 	ldw	r2,-56(fp)
8111b5cc:	10802204 	addi	r2,r2,136
8111b5d0:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111b5d4:	e0bff217 	ldw	r2,-56(fp)
}
8111b5d8:	e6fffc04 	addi	sp,fp,-16
8111b5dc:	dfc00517 	ldw	ra,20(sp)
8111b5e0:	df000417 	ldw	fp,16(sp)
8111b5e4:	dcc00317 	ldw	r19,12(sp)
8111b5e8:	dc800217 	ldw	r18,8(sp)
8111b5ec:	dc400117 	ldw	r17,4(sp)
8111b5f0:	dc000017 	ldw	r16,0(sp)
8111b5f4:	dec00604 	addi	sp,sp,24
8111b5f8:	f800283a 	ret

8111b5fc <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111b5fc:	defffe04 	addi	sp,sp,-8
8111b600:	de00012e 	bgeu	sp,et,8111b608 <bSDcardIsPresent+0xc>
8111b604:	003b68fa 	trap	3
8111b608:	dfc00115 	stw	ra,4(sp)
8111b60c:	df000015 	stw	fp,0(sp)
8111b610:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111b614:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
}
8111b618:	e037883a 	mov	sp,fp
8111b61c:	dfc00117 	ldw	ra,4(sp)
8111b620:	df000017 	ldw	fp,0(sp)
8111b624:	dec00204 	addi	sp,sp,8
8111b628:	f800283a 	ret

8111b62c <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111b62c:	defffe04 	addi	sp,sp,-8
8111b630:	de00012e 	bgeu	sp,et,8111b638 <bSDcardFAT16Check+0xc>
8111b634:	003b68fa 	trap	3
8111b638:	dfc00115 	stw	ra,4(sp)
8111b63c:	df000015 	stw	fp,0(sp)
8111b640:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111b644:	1141bfc0 	call	81141bfc <alt_up_sd_card_is_FAT16>
}
8111b648:	e037883a 	mov	sp,fp
8111b64c:	dfc00117 	ldw	ra,4(sp)
8111b650:	df000017 	ldw	fp,0(sp)
8111b654:	dec00204 	addi	sp,sp,8
8111b658:	f800283a 	ret

8111b65c <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111b65c:	defffd04 	addi	sp,sp,-12
8111b660:	de00012e 	bgeu	sp,et,8111b668 <bInitializeSDCard+0xc>
8111b664:	003b68fa 	trap	3
8111b668:	dfc00215 	stw	ra,8(sp)
8111b66c:	df000115 	stw	fp,4(sp)
8111b670:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111b674:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111b678:	d0207615 	stw	zero,-32296(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111b67c:	01204574 	movhi	r4,33045
8111b680:	21325604 	addi	r4,r4,-13992
8111b684:	1141a6c0 	call	81141a6c <alt_up_sd_card_open_dev>
8111b688:	d0a07615 	stw	r2,-32296(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111b68c:	d0a07617 	ldw	r2,-32296(gp)
8111b690:	10002226 	beq	r2,zero,8111b71c <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111b694:	111b5fc0 	call	8111b5fc <bSDcardIsPresent>
8111b698:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111b69c:	e0bfff17 	ldw	r2,-4(fp)
8111b6a0:	10001626 	beq	r2,zero,8111b6fc <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111b6a4:	111b62c0 	call	8111b62c <bSDcardFAT16Check>
8111b6a8:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111b6ac:	e0bfff17 	ldw	r2,-4(fp)
8111b6b0:	10000a26 	beq	r2,zero,8111b6dc <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111b6b4:	00800044 	movi	r2,1
8111b6b8:	d0a07515 	stw	r2,-32300(gp)
				debug(fp, "SD is up.\r\n");
8111b6bc:	d0a06117 	ldw	r2,-32380(gp)
8111b6c0:	100f883a 	mov	r7,r2
8111b6c4:	018002c4 	movi	r6,11
8111b6c8:	01400044 	movi	r5,1
8111b6cc:	01204574 	movhi	r4,33045
8111b6d0:	21326104 	addi	r4,r4,-13948
8111b6d4:	111dcb00 	call	8111dcb0 <fwrite>
8111b6d8:	00001806 	br	8111b73c <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
8111b6dc:	d0a06117 	ldw	r2,-32380(gp)
8111b6e0:	100f883a 	mov	r7,r2
8111b6e4:	01800984 	movi	r6,38
8111b6e8:	01400044 	movi	r5,1
8111b6ec:	01204574 	movhi	r4,33045
8111b6f0:	21326404 	addi	r4,r4,-13936
8111b6f4:	111dcb00 	call	8111dcb0 <fwrite>
8111b6f8:	00001006 	br	8111b73c <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
8111b6fc:	d0a06117 	ldw	r2,-32380(gp)
8111b700:	100f883a 	mov	r7,r2
8111b704:	01800744 	movi	r6,29
8111b708:	01400044 	movi	r5,1
8111b70c:	01204574 	movhi	r4,33045
8111b710:	21326e04 	addi	r4,r4,-13896
8111b714:	111dcb00 	call	8111dcb0 <fwrite>
8111b718:	00000806 	br	8111b73c <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111b71c:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
8111b720:	d0a06117 	ldw	r2,-32380(gp)
8111b724:	100f883a 	mov	r7,r2
8111b728:	018008c4 	movi	r6,35
8111b72c:	01400044 	movi	r5,1
8111b730:	01204574 	movhi	r4,33045
8111b734:	21327604 	addi	r4,r4,-13864
8111b738:	111dcb00 	call	8111dcb0 <fwrite>
	}

	return bSucess;
8111b73c:	e0bfff17 	ldw	r2,-4(fp)
}
8111b740:	e037883a 	mov	sp,fp
8111b744:	dfc00117 	ldw	ra,4(sp)
8111b748:	df000017 	ldw	fp,0(sp)
8111b74c:	dec00204 	addi	sp,sp,8
8111b750:	f800283a 	ret

8111b754 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111b754:	defffd04 	addi	sp,sp,-12
8111b758:	de00012e 	bgeu	sp,et,8111b760 <siOpenFile+0xc>
8111b75c:	003b68fa 	trap	3
8111b760:	dfc00215 	stw	ra,8(sp)
8111b764:	df000115 	stw	fp,4(sp)
8111b768:	df000104 	addi	fp,sp,4
8111b76c:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111b770:	000b883a 	mov	r5,zero
8111b774:	e13fff17 	ldw	r4,-4(fp)
8111b778:	11421080 	call	81142108 <alt_up_sd_card_fopen>
}
8111b77c:	e037883a 	mov	sp,fp
8111b780:	dfc00117 	ldw	ra,4(sp)
8111b784:	df000017 	ldw	fp,0(sp)
8111b788:	dec00204 	addi	sp,sp,8
8111b78c:	f800283a 	ret

8111b790 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111b790:	defffd04 	addi	sp,sp,-12
8111b794:	de00012e 	bgeu	sp,et,8111b79c <siCloseFile+0xc>
8111b798:	003b68fa 	trap	3
8111b79c:	dfc00215 	stw	ra,8(sp)
8111b7a0:	df000115 	stw	fp,4(sp)
8111b7a4:	df000104 	addi	fp,sp,4
8111b7a8:	2005883a 	mov	r2,r4
8111b7ac:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111b7b0:	e0bfff0f 	ldh	r2,-4(fp)
8111b7b4:	1009883a 	mov	r4,r2
8111b7b8:	1142f540 	call	81142f54 <alt_up_sd_card_fclose>
}
8111b7bc:	e037883a 	mov	sp,fp
8111b7c0:	dfc00117 	ldw	ra,4(sp)
8111b7c4:	df000017 	ldw	fp,0(sp)
8111b7c8:	dec00204 	addi	sp,sp,8
8111b7cc:	f800283a 	ret

8111b7d0 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111b7d0:	defffd04 	addi	sp,sp,-12
8111b7d4:	de00012e 	bgeu	sp,et,8111b7dc <cGetNextChar+0xc>
8111b7d8:	003b68fa 	trap	3
8111b7dc:	dfc00215 	stw	ra,8(sp)
8111b7e0:	df000115 	stw	fp,4(sp)
8111b7e4:	df000104 	addi	fp,sp,4
8111b7e8:	2005883a 	mov	r2,r4
8111b7ec:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111b7f0:	e0bfff0f 	ldh	r2,-4(fp)
8111b7f4:	1009883a 	mov	r4,r2
8111b7f8:	11425ac0 	call	811425ac <alt_up_sd_card_read>
}
8111b7fc:	e037883a 	mov	sp,fp
8111b800:	dfc00117 	ldw	ra,4(sp)
8111b804:	df000017 	ldw	fp,0(sp)
8111b808:	dec00204 	addi	sp,sp,8
8111b80c:	f800283a 	ret

8111b810 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8111b810:	defffc04 	addi	sp,sp,-16
8111b814:	de00012e 	bgeu	sp,et,8111b81c <bInitSync+0xc>
8111b818:	003b68fa 	trap	3
8111b81c:	dfc00315 	stw	ra,12(sp)
8111b820:	df000215 	stw	fp,8(sp)
8111b824:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111b828:	110c2c00 	call	8110c2c0 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
8111b82c:	d0a06117 	ldw	r2,-32380(gp)
8111b830:	100f883a 	mov	r7,r2
8111b834:	01800684 	movi	r6,26
8111b838:	01400044 	movi	r5,1
8111b83c:	01204574 	movhi	r4,33045
8111b840:	21327f04 	addi	r4,r4,-13828
8111b844:	111dcb00 	call	8111dcb0 <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8111b848:	01004c74 	movhi	r4,305
8111b84c:	210b4004 	addi	r4,r4,11520
8111b850:	110c4c80 	call	8110c4c8 <bSyncSetMbt>
8111b854:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111b858:	e0bffe17 	ldw	r2,-8(fp)
8111b85c:	1000091e 	bne	r2,zero,8111b884 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111b860:	d0a06117 	ldw	r2,-32380(gp)
8111b864:	100f883a 	mov	r7,r2
8111b868:	018005c4 	movi	r6,23
8111b86c:	01400044 	movi	r5,1
8111b870:	01204574 	movhi	r4,33045
8111b874:	21328604 	addi	r4,r4,-13800
8111b878:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111b87c:	e0bffe17 	ldw	r2,-8(fp)
8111b880:	00007a06 	br	8111ba6c <bInitSync+0x25c>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111b884:	01002674 	movhi	r4,153
8111b888:	2125a004 	addi	r4,r4,-27008
8111b88c:	110c5080 	call	8110c508 <bSyncSetBt>
8111b890:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111b894:	e0bffe17 	ldw	r2,-8(fp)
8111b898:	1000091e 	bne	r2,zero,8111b8c0 <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111b89c:	d0a06117 	ldw	r2,-32380(gp)
8111b8a0:	100f883a 	mov	r7,r2
8111b8a4:	018005c4 	movi	r6,23
8111b8a8:	01400044 	movi	r5,1
8111b8ac:	01204574 	movhi	r4,33045
8111b8b0:	21328604 	addi	r4,r4,-13800
8111b8b4:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111b8b8:	e0bffe17 	ldw	r2,-8(fp)
8111b8bc:	00006b06 	br	8111ba6c <bInitSync+0x25c>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer((alt_u32)PER);
8111b8c0:	0112a074 	movhi	r4,19073
8111b8c4:	211f2004 	addi	r4,r4,31872
8111b8c8:	110c5480 	call	8110c548 <bSyncSetPer>
8111b8cc:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111b8d0:	e0bffe17 	ldw	r2,-8(fp)
8111b8d4:	1000091e 	bne	r2,zero,8111b8fc <bInitSync+0xec>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111b8d8:	d0a06117 	ldw	r2,-32380(gp)
8111b8dc:	100f883a 	mov	r7,r2
8111b8e0:	018005c4 	movi	r6,23
8111b8e4:	01400044 	movi	r5,1
8111b8e8:	01204574 	movhi	r4,33045
8111b8ec:	21328604 	addi	r4,r4,-13800
8111b8f0:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111b8f4:	e0bffe17 	ldw	r2,-8(fp)
8111b8f8:	00005c06 	br	8111ba6c <bInitSync+0x25c>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8111b8fc:	01005f74 	movhi	r4,381
8111b900:	211e1004 	addi	r4,r4,30784
8111b904:	110c5880 	call	8110c588 <bSyncSetOst>
8111b908:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111b90c:	e0bffe17 	ldw	r2,-8(fp)
8111b910:	1000091e 	bne	r2,zero,8111b938 <bInitSync+0x128>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111b914:	d0a06117 	ldw	r2,-32380(gp)
8111b918:	100f883a 	mov	r7,r2
8111b91c:	018005c4 	movi	r6,23
8111b920:	01400044 	movi	r5,1
8111b924:	01204574 	movhi	r4,33045
8111b928:	21328604 	addi	r4,r4,-13800
8111b92c:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111b930:	e0bffe17 	ldw	r2,-8(fp)
8111b934:	00004d06 	br	8111ba6c <bInitSync+0x25c>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8111b938:	0009883a 	mov	r4,zero
8111b93c:	110c5c80 	call	8110c5c8 <bSyncSetPolarity>
8111b940:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111b944:	e0bffe17 	ldw	r2,-8(fp)
8111b948:	1000091e 	bne	r2,zero,8111b970 <bInitSync+0x160>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111b94c:	d0a06117 	ldw	r2,-32380(gp)
8111b950:	100f883a 	mov	r7,r2
8111b954:	018005c4 	movi	r6,23
8111b958:	01400044 	movi	r5,1
8111b95c:	01204574 	movhi	r4,33045
8111b960:	21328604 	addi	r4,r4,-13800
8111b964:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111b968:	e0bffe17 	ldw	r2,-8(fp)
8111b96c:	00003f06 	br	8111ba6c <bInitSync+0x25c>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8111b970:	01000104 	movi	r4,4
8111b974:	110c63c0 	call	8110c63c <bSyncSetNCycles>
8111b978:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111b97c:	e0bffe17 	ldw	r2,-8(fp)
8111b980:	1000091e 	bne	r2,zero,8111b9a8 <bInitSync+0x198>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111b984:	d0a06117 	ldw	r2,-32380(gp)
8111b988:	100f883a 	mov	r7,r2
8111b98c:	018005c4 	movi	r6,23
8111b990:	01400044 	movi	r5,1
8111b994:	01204574 	movhi	r4,33045
8111b998:	21328604 	addi	r4,r4,-13800
8111b99c:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111b9a0:	e0bffe17 	ldw	r2,-8(fp)
8111b9a4:	00003106 	br	8111ba6c <bInitSync+0x25c>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8111b9a8:	01000044 	movi	r4,1
8111b9ac:	110c8180 	call	8110c818 <bSyncCtrExtnIrq>
8111b9b0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111b9b4:	e0bffe17 	ldw	r2,-8(fp)
8111b9b8:	1000091e 	bne	r2,zero,8111b9e0 <bInitSync+0x1d0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111b9bc:	d0a06117 	ldw	r2,-32380(gp)
8111b9c0:	100f883a 	mov	r7,r2
8111b9c4:	018005c4 	movi	r6,23
8111b9c8:	01400044 	movi	r5,1
8111b9cc:	01204574 	movhi	r4,33045
8111b9d0:	21328604 	addi	r4,r4,-13800
8111b9d4:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111b9d8:	e0bffe17 	ldw	r2,-8(fp)
8111b9dc:	00002306 	br	8111ba6c <bInitSync+0x25c>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8111b9e0:	01000044 	movi	r4,1
8111b9e4:	110c9e00 	call	8110c9e0 <bSyncCtrSyncOutEnable>
8111b9e8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111b9ec:	e0bffe17 	ldw	r2,-8(fp)
8111b9f0:	1000091e 	bne	r2,zero,8111ba18 <bInitSync+0x208>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111b9f4:	d0a06117 	ldw	r2,-32380(gp)
8111b9f8:	100f883a 	mov	r7,r2
8111b9fc:	018005c4 	movi	r6,23
8111ba00:	01400044 	movi	r5,1
8111ba04:	01204574 	movhi	r4,33045
8111ba08:	21328604 	addi	r4,r4,-13800
8111ba0c:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111ba10:	e0bffe17 	ldw	r2,-8(fp)
8111ba14:	00001506 	br	8111ba6c <bInitSync+0x25c>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8111ba18:	01000044 	movi	r4,1
8111ba1c:	110ca540 	call	8110ca54 <bSyncCtrCh1OutEnable>
8111ba20:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ba24:	e0bffe17 	ldw	r2,-8(fp)
8111ba28:	1000091e 	bne	r2,zero,8111ba50 <bInitSync+0x240>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ba2c:	d0a06117 	ldw	r2,-32380(gp)
8111ba30:	100f883a 	mov	r7,r2
8111ba34:	018005c4 	movi	r6,23
8111ba38:	01400044 	movi	r5,1
8111ba3c:	01204574 	movhi	r4,33045
8111ba40:	21328604 	addi	r4,r4,-13800
8111ba44:	111dcb00 	call	8111dcb0 <fwrite>
		#endif
		return bSuccess;
8111ba48:	e0bffe17 	ldw	r2,-8(fp)
8111ba4c:	00000706 	br	8111ba6c <bInitSync+0x25c>
	}

	bSuccess = bSyncCtrStart();
8111ba50:	110c8900 	call	8110c890 <bSyncCtrStart>
8111ba54:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
8111ba58:	110c8e40 	call	8110c8e4 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111ba5c:	01000044 	movi	r4,1
8111ba60:	110ce680 	call	8110ce68 <bSyncIrqEnableBlank>
8111ba64:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
8111ba68:	e0bffe17 	ldw	r2,-8(fp)
}
8111ba6c:	e037883a 	mov	sp,fp
8111ba70:	dfc00117 	ldw	ra,4(sp)
8111ba74:	df000017 	ldw	fp,0(sp)
8111ba78:	dec00204 	addi	sp,sp,8
8111ba7c:	f800283a 	ret

8111ba80 <bStartSync>:


bool bStartSync(void) {
8111ba80:	defffd04 	addi	sp,sp,-12
8111ba84:	de00012e 	bgeu	sp,et,8111ba8c <bStartSync+0xc>
8111ba88:	003b68fa 	trap	3
8111ba8c:	dfc00215 	stw	ra,8(sp)
8111ba90:	df000115 	stw	fp,4(sp)
8111ba94:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
8111ba98:	110c8e40 	call	8110c8e4 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
8111ba9c:	110c8900 	call	8110c890 <bSyncCtrStart>
8111baa0:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8111baa4:	e0bfff17 	ldw	r2,-4(fp)
}
8111baa8:	e037883a 	mov	sp,fp
8111baac:	dfc00117 	ldw	ra,4(sp)
8111bab0:	df000017 	ldw	fp,0(sp)
8111bab4:	dec00204 	addi	sp,sp,8
8111bab8:	f800283a 	ret

8111babc <bStopSync>:

bool bStopSync(void) {
8111babc:	defffe04 	addi	sp,sp,-8
8111bac0:	de00012e 	bgeu	sp,et,8111bac8 <bStopSync+0xc>
8111bac4:	003b68fa 	trap	3
8111bac8:	dfc00115 	stw	ra,4(sp)
8111bacc:	df000015 	stw	fp,0(sp)
8111bad0:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8111bad4:	110c8e40 	call	8110c8e4 <bSyncCtrReset>
}
8111bad8:	e037883a 	mov	sp,fp
8111badc:	dfc00117 	ldw	ra,4(sp)
8111bae0:	df000017 	ldw	fp,0(sp)
8111bae4:	dec00204 	addi	sp,sp,8
8111bae8:	f800283a 	ret

8111baec <bClearCounterSync>:

void bClearCounterSync(void) {
8111baec:	defffe04 	addi	sp,sp,-8
8111baf0:	de00012e 	bgeu	sp,et,8111baf8 <bClearCounterSync+0xc>
8111baf4:	003b68fa 	trap	3
8111baf8:	dfc00115 	stw	ra,4(sp)
8111bafc:	df000015 	stw	fp,0(sp)
8111bb00:	d839883a 	mov	fp,sp

	vSyncClearCounter();
8111bb04:	110c2940 	call	8110c294 <vSyncClearCounter>
}
8111bb08:	0001883a 	nop
8111bb0c:	e037883a 	mov	sp,fp
8111bb10:	dfc00117 	ldw	ra,4(sp)
8111bb14:	df000017 	ldw	fp,0(sp)
8111bb18:	dec00204 	addi	sp,sp,8
8111bb1c:	f800283a 	ret

8111bb20 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111bb20:	defffd04 	addi	sp,sp,-12
8111bb24:	de00012e 	bgeu	sp,et,8111bb2c <bTestSimucamCriticalHW+0xc>
8111bb28:	003b68fa 	trap	3
8111bb2c:	dfc00215 	stw	ra,8(sp)
8111bb30:	df000115 	stw	fp,4(sp)
8111bb34:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8111bb38:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8111bb3c:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111bb40:	e0bfff17 	ldw	r2,-4(fp)
8111bb44:	1000021e 	bne	r2,zero,8111bb50 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8111bb48:	e0bfff17 	ldw	r2,-4(fp)
8111bb4c:	00001106 	br	8111bb94 <bTestSimucamCriticalHW+0x74>
	}

	bSuccess = bSdmaInitM2Dma();
8111bb50:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
8111bb54:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111bb58:	e0bfff17 	ldw	r2,-4(fp)
8111bb5c:	1000021e 	bne	r2,zero,8111bb68 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111bb60:	e0bfff17 	ldw	r2,-4(fp)
8111bb64:	00000b06 	br	8111bb94 <bTestSimucamCriticalHW+0x74>
	}

	xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
8111bb68:	00a045b4 	movhi	r2,33046
8111bb6c:	10bf9d04 	addi	r2,r2,-396
8111bb70:	00e04434 	movhi	r3,33040
8111bb74:	18cf2404 	addi	r3,r3,15504
8111bb78:	10c00115 	stw	r3,4(r2)
	xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;
8111bb7c:	00a045b4 	movhi	r2,33046
8111bb80:	10bf9d04 	addi	r2,r2,-396
8111bb84:	00e04434 	movhi	r3,33040
8111bb88:	18d02704 	addi	r3,r3,16540
8111bb8c:	10c00115 	stw	r3,4(r2)


	return TRUE;
8111bb90:	00800044 	movi	r2,1
}
8111bb94:	e037883a 	mov	sp,fp
8111bb98:	dfc00117 	ldw	ra,4(sp)
8111bb9c:	df000017 	ldw	fp,0(sp)
8111bba0:	dec00204 	addi	sp,sp,8
8111bba4:	f800283a 	ret

8111bba8 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111bba8:	defffc04 	addi	sp,sp,-16
8111bbac:	de00012e 	bgeu	sp,et,8111bbb4 <_reg_write+0xc>
8111bbb0:	003b68fa 	trap	3
8111bbb4:	df000315 	stw	fp,12(sp)
8111bbb8:	df000304 	addi	fp,sp,12
8111bbbc:	e13ffd15 	stw	r4,-12(fp)
8111bbc0:	e17ffe15 	stw	r5,-8(fp)
8111bbc4:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111bbc8:	e0bffe17 	ldw	r2,-8(fp)
8111bbcc:	1085883a 	add	r2,r2,r2
8111bbd0:	1085883a 	add	r2,r2,r2
8111bbd4:	1007883a 	mov	r3,r2
8111bbd8:	e0bffd17 	ldw	r2,-12(fp)
8111bbdc:	1885883a 	add	r2,r3,r2
8111bbe0:	1007883a 	mov	r3,r2
8111bbe4:	e0bfff17 	ldw	r2,-4(fp)
8111bbe8:	18800035 	stwio	r2,0(r3)
	return 1;
8111bbec:	00800044 	movi	r2,1

}
8111bbf0:	e037883a 	mov	sp,fp
8111bbf4:	df000017 	ldw	fp,0(sp)
8111bbf8:	dec00104 	addi	sp,sp,4
8111bbfc:	f800283a 	ret

8111bc00 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111bc00:	defffc04 	addi	sp,sp,-16
8111bc04:	de00012e 	bgeu	sp,et,8111bc0c <_reg_read+0xc>
8111bc08:	003b68fa 	trap	3
8111bc0c:	df000315 	stw	fp,12(sp)
8111bc10:	df000304 	addi	fp,sp,12
8111bc14:	e13ffd15 	stw	r4,-12(fp)
8111bc18:	e17ffe15 	stw	r5,-8(fp)
8111bc1c:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111bc20:	e0bffe17 	ldw	r2,-8(fp)
8111bc24:	1085883a 	add	r2,r2,r2
8111bc28:	1085883a 	add	r2,r2,r2
8111bc2c:	1007883a 	mov	r3,r2
8111bc30:	e0bffd17 	ldw	r2,-12(fp)
8111bc34:	1885883a 	add	r2,r3,r2
8111bc38:	10c00037 	ldwio	r3,0(r2)
8111bc3c:	e0bfff17 	ldw	r2,-4(fp)
8111bc40:	10c00015 	stw	r3,0(r2)
	return 1;
8111bc44:	00800044 	movi	r2,1

}
8111bc48:	e037883a 	mov	sp,fp
8111bc4c:	df000017 	ldw	fp,0(sp)
8111bc50:	dec00104 	addi	sp,sp,4
8111bc54:	f800283a 	ret

8111bc58 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111bc58:	defffa04 	addi	sp,sp,-24
8111bc5c:	de00012e 	bgeu	sp,et,8111bc64 <_print_codec_status+0xc>
8111bc60:	003b68fa 	trap	3
8111bc64:	dfc00515 	stw	ra,20(sp)
8111bc68:	df000415 	stw	fp,16(sp)
8111bc6c:	df000404 	addi	fp,sp,16
8111bc70:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111bc74:	e0bfff17 	ldw	r2,-4(fp)
8111bc78:	1005d1ba 	srai	r2,r2,6
8111bc7c:	1080004c 	andi	r2,r2,1
8111bc80:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111bc84:	e0bfff17 	ldw	r2,-4(fp)
8111bc88:	1005d17a 	srai	r2,r2,5
8111bc8c:	1080004c 	andi	r2,r2,1
8111bc90:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111bc94:	e0bfff17 	ldw	r2,-4(fp)
8111bc98:	1005d13a 	srai	r2,r2,4
8111bc9c:	1080004c 	andi	r2,r2,1
8111bca0:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111bca4:	00e04574 	movhi	r3,33045
8111bca8:	18fe6f04 	addi	r3,r3,-1604
8111bcac:	00a04574 	movhi	r2,33045
8111bcb0:	10b28c04 	addi	r2,r2,-13776
8111bcb4:	1009883a 	mov	r4,r2
8111bcb8:	008005c4 	movi	r2,23
8111bcbc:	100d883a 	mov	r6,r2
8111bcc0:	200b883a 	mov	r5,r4
8111bcc4:	1809883a 	mov	r4,r3
8111bcc8:	111e6c40 	call	8111e6c4 <memcpy>
	debug(fp, cDebugBuffer);
8111bccc:	d0a06117 	ldw	r2,-32380(gp)
8111bcd0:	01604574 	movhi	r5,33045
8111bcd4:	297e6f04 	addi	r5,r5,-1604
8111bcd8:	1009883a 	mov	r4,r2
8111bcdc:	111d6140 	call	8111d614 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111bce0:	e0bffc17 	ldw	r2,-16(fp)
8111bce4:	10800058 	cmpnei	r2,r2,1
8111bce8:	1000031e 	bne	r2,zero,8111bcf8 <_print_codec_status+0xa0>
8111bcec:	00a04574 	movhi	r2,33045
8111bcf0:	10b29204 	addi	r2,r2,-13752
8111bcf4:	00000206 	br	8111bd00 <_print_codec_status+0xa8>
8111bcf8:	00a04574 	movhi	r2,33045
8111bcfc:	10b29304 	addi	r2,r2,-13748
8111bd00:	100d883a 	mov	r6,r2
8111bd04:	01604574 	movhi	r5,33045
8111bd08:	29729404 	addi	r5,r5,-13744
8111bd0c:	01204574 	movhi	r4,33045
8111bd10:	213e6f04 	addi	r4,r4,-1604
8111bd14:	111efa40 	call	8111efa4 <sprintf>
	debug(fp, cDebugBuffer);
8111bd18:	d0a06117 	ldw	r2,-32380(gp)
8111bd1c:	01604574 	movhi	r5,33045
8111bd20:	297e6f04 	addi	r5,r5,-1604
8111bd24:	1009883a 	mov	r4,r2
8111bd28:	111d6140 	call	8111d614 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111bd2c:	e0bffd17 	ldw	r2,-12(fp)
8111bd30:	10800058 	cmpnei	r2,r2,1
8111bd34:	1000031e 	bne	r2,zero,8111bd44 <_print_codec_status+0xec>
8111bd38:	00a04574 	movhi	r2,33045
8111bd3c:	10b29204 	addi	r2,r2,-13752
8111bd40:	00000206 	br	8111bd4c <_print_codec_status+0xf4>
8111bd44:	00a04574 	movhi	r2,33045
8111bd48:	10b29304 	addi	r2,r2,-13748
8111bd4c:	100d883a 	mov	r6,r2
8111bd50:	01604574 	movhi	r5,33045
8111bd54:	29729a04 	addi	r5,r5,-13720
8111bd58:	01204574 	movhi	r4,33045
8111bd5c:	213e6f04 	addi	r4,r4,-1604
8111bd60:	111efa40 	call	8111efa4 <sprintf>
	debug(fp, cDebugBuffer);
8111bd64:	d0a06117 	ldw	r2,-32380(gp)
8111bd68:	01604574 	movhi	r5,33045
8111bd6c:	297e6f04 	addi	r5,r5,-1604
8111bd70:	1009883a 	mov	r4,r2
8111bd74:	111d6140 	call	8111d614 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111bd78:	e0bffe17 	ldw	r2,-8(fp)
8111bd7c:	10800058 	cmpnei	r2,r2,1
8111bd80:	1000031e 	bne	r2,zero,8111bd90 <_print_codec_status+0x138>
8111bd84:	00a04574 	movhi	r2,33045
8111bd88:	10b29204 	addi	r2,r2,-13752
8111bd8c:	00000206 	br	8111bd98 <_print_codec_status+0x140>
8111bd90:	00a04574 	movhi	r2,33045
8111bd94:	10b29304 	addi	r2,r2,-13748
8111bd98:	100d883a 	mov	r6,r2
8111bd9c:	01604574 	movhi	r5,33045
8111bda0:	2972a004 	addi	r5,r5,-13696
8111bda4:	01204574 	movhi	r4,33045
8111bda8:	213e6f04 	addi	r4,r4,-1604
8111bdac:	111efa40 	call	8111efa4 <sprintf>
	debug(fp, cDebugBuffer);
8111bdb0:	d0a06117 	ldw	r2,-32380(gp)
8111bdb4:	01604574 	movhi	r5,33045
8111bdb8:	297e6f04 	addi	r5,r5,-1604
8111bdbc:	1009883a 	mov	r4,r2
8111bdc0:	111d6140 	call	8111d614 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111bdc4:	00a04574 	movhi	r2,33045
8111bdc8:	10be6f04 	addi	r2,r2,-1604
8111bdcc:	00c00b44 	movi	r3,45
8111bdd0:	10c00005 	stb	r3,0(r2)
8111bdd4:	00c00b44 	movi	r3,45
8111bdd8:	10c00045 	stb	r3,1(r2)
8111bddc:	00c00b44 	movi	r3,45
8111bde0:	10c00085 	stb	r3,2(r2)
8111bde4:	00c00b44 	movi	r3,45
8111bde8:	10c000c5 	stb	r3,3(r2)
8111bdec:	00c00b44 	movi	r3,45
8111bdf0:	10c00105 	stb	r3,4(r2)
8111bdf4:	00c00b44 	movi	r3,45
8111bdf8:	10c00145 	stb	r3,5(r2)
8111bdfc:	00c00b44 	movi	r3,45
8111be00:	10c00185 	stb	r3,6(r2)
8111be04:	00c00b44 	movi	r3,45
8111be08:	10c001c5 	stb	r3,7(r2)
8111be0c:	00c00804 	movi	r3,32
8111be10:	10c00205 	stb	r3,8(r2)
8111be14:	00c00804 	movi	r3,32
8111be18:	10c00245 	stb	r3,9(r2)
8111be1c:	00c00284 	movi	r3,10
8111be20:	10c00285 	stb	r3,10(r2)
8111be24:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111be28:	d0a06117 	ldw	r2,-32380(gp)
8111be2c:	01604574 	movhi	r5,33045
8111be30:	297e6f04 	addi	r5,r5,-1604
8111be34:	1009883a 	mov	r4,r2
8111be38:	111d6140 	call	8111d614 <fprintf>
#endif
}
8111be3c:	0001883a 	nop
8111be40:	e037883a 	mov	sp,fp
8111be44:	dfc00117 	ldw	ra,4(sp)
8111be48:	df000017 	ldw	fp,0(sp)
8111be4c:	dec00204 	addi	sp,sp,8
8111be50:	f800283a 	ret

8111be54 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111be54:	defffb04 	addi	sp,sp,-20
8111be58:	de00012e 	bgeu	sp,et,8111be60 <_split_codec_status+0xc>
8111be5c:	003b68fa 	trap	3
8111be60:	df000415 	stw	fp,16(sp)
8111be64:	df000404 	addi	fp,sp,16
8111be68:	e13ffc15 	stw	r4,-16(fp)
8111be6c:	e17ffd15 	stw	r5,-12(fp)
8111be70:	e1bffe15 	stw	r6,-8(fp)
8111be74:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111be78:	e0bffc17 	ldw	r2,-16(fp)
8111be7c:	1005d1ba 	srai	r2,r2,6
8111be80:	10c0004c 	andi	r3,r2,1
8111be84:	e0bffd17 	ldw	r2,-12(fp)
8111be88:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111be8c:	e0bffc17 	ldw	r2,-16(fp)
8111be90:	1005d17a 	srai	r2,r2,5
8111be94:	10c0004c 	andi	r3,r2,1
8111be98:	e0bffe17 	ldw	r2,-8(fp)
8111be9c:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111bea0:	e0bffc17 	ldw	r2,-16(fp)
8111bea4:	1005d13a 	srai	r2,r2,4
8111bea8:	10c0004c 	andi	r3,r2,1
8111beac:	e0bfff17 	ldw	r2,-4(fp)
8111beb0:	10c00015 	stw	r3,0(r2)
}
8111beb4:	0001883a 	nop
8111beb8:	e037883a 	mov	sp,fp
8111bebc:	df000017 	ldw	fp,0(sp)
8111bec0:	dec00104 	addi	sp,sp,4
8111bec4:	f800283a 	ret

8111bec8 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111bec8:	defffc04 	addi	sp,sp,-16
8111becc:	de00012e 	bgeu	sp,et,8111bed4 <aatoh+0xc>
8111bed0:	003b68fa 	trap	3
8111bed4:	df000315 	stw	fp,12(sp)
8111bed8:	df000304 	addi	fp,sp,12
8111bedc:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111bee0:	e0bfff17 	ldw	r2,-4(fp)
8111bee4:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111bee8:	e0bffd17 	ldw	r2,-12(fp)
8111beec:	10c00003 	ldbu	r3,0(r2)
8111bef0:	e0bffd17 	ldw	r2,-12(fp)
8111bef4:	10800003 	ldbu	r2,0(r2)
8111bef8:	10803fcc 	andi	r2,r2,255
8111befc:	10800eb0 	cmpltui	r2,r2,58
8111bf00:	1000021e 	bne	r2,zero,8111bf0c <aatoh+0x44>
8111bf04:	00800dc4 	movi	r2,55
8111bf08:	00000106 	br	8111bf10 <aatoh+0x48>
8111bf0c:	00800c04 	movi	r2,48
8111bf10:	1885c83a 	sub	r2,r3,r2
8111bf14:	1004913a 	slli	r2,r2,4
8111bf18:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111bf1c:	e0bffd17 	ldw	r2,-12(fp)
8111bf20:	10800044 	addi	r2,r2,1
8111bf24:	10c00003 	ldbu	r3,0(r2)
8111bf28:	e0bffd17 	ldw	r2,-12(fp)
8111bf2c:	10800044 	addi	r2,r2,1
8111bf30:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111bf34:	10803fcc 	andi	r2,r2,255
8111bf38:	10800eb0 	cmpltui	r2,r2,58
8111bf3c:	1000021e 	bne	r2,zero,8111bf48 <aatoh+0x80>
8111bf40:	00800dc4 	movi	r2,55
8111bf44:	00000106 	br	8111bf4c <aatoh+0x84>
8111bf48:	00800c04 	movi	r2,48
8111bf4c:	1885c83a 	sub	r2,r3,r2
8111bf50:	2085883a 	add	r2,r4,r2
8111bf54:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111bf58:	e0bffe03 	ldbu	r2,-8(fp)
}
8111bf5c:	e037883a 	mov	sp,fp
8111bf60:	df000017 	ldw	fp,0(sp)
8111bf64:	dec00104 	addi	sp,sp,4
8111bf68:	f800283a 	ret

8111bf6c <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111bf6c:	defffd04 	addi	sp,sp,-12
8111bf70:	de00012e 	bgeu	sp,et,8111bf78 <Verif_Error+0xc>
8111bf74:	003b68fa 	trap	3
8111bf78:	dfc00215 	stw	ra,8(sp)
8111bf7c:	df000115 	stw	fp,4(sp)
8111bf80:	df000104 	addi	fp,sp,4
8111bf84:	2005883a 	mov	r2,r4
8111bf88:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111bf8c:	e0bfff03 	ldbu	r2,-4(fp)
8111bf90:	1000091e 	bne	r2,zero,8111bfb8 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111bf94:	d0a06117 	ldw	r2,-32380(gp)
8111bf98:	100f883a 	mov	r7,r2
8111bf9c:	018001c4 	movi	r6,7
8111bfa0:	01400044 	movi	r5,1
8111bfa4:	01204574 	movhi	r4,33045
8111bfa8:	2132a604 	addi	r4,r4,-13672
8111bfac:	111dcb00 	call	8111dcb0 <fwrite>
#endif
		return 0;
8111bfb0:	0005883a 	mov	r2,zero
8111bfb4:	00000106 	br	8111bfbc <Verif_Error+0x50>
	} else
		return 1;
8111bfb8:	00800044 	movi	r2,1
}
8111bfbc:	e037883a 	mov	sp,fp
8111bfc0:	dfc00117 	ldw	ra,4(sp)
8111bfc4:	df000017 	ldw	fp,0(sp)
8111bfc8:	dec00204 	addi	sp,sp,8
8111bfcc:	f800283a 	ret

8111bfd0 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111bfd0:	defffe04 	addi	sp,sp,-8
8111bfd4:	de00012e 	bgeu	sp,et,8111bfdc <toInt+0xc>
8111bfd8:	003b68fa 	trap	3
8111bfdc:	df000115 	stw	fp,4(sp)
8111bfe0:	df000104 	addi	fp,sp,4
8111bfe4:	2005883a 	mov	r2,r4
8111bfe8:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111bfec:	e0bfff03 	ldbu	r2,-4(fp)
8111bff0:	10bff404 	addi	r2,r2,-48
}
8111bff4:	e037883a 	mov	sp,fp
8111bff8:	df000017 	ldw	fp,0(sp)
8111bffc:	dec00104 	addi	sp,sp,4
8111c000:	f800283a 	ret

8111c004 <__divsf3>:
8111c004:	defff504 	addi	sp,sp,-44
8111c008:	200cd5fa 	srli	r6,r4,23
8111c00c:	de00012e 	bgeu	sp,et,8111c014 <__divsf3+0x10>
8111c010:	003b68fa 	trap	3
8111c014:	dcc00415 	stw	r19,16(sp)
8111c018:	2026d7fa 	srli	r19,r4,31
8111c01c:	00c02034 	movhi	r3,128
8111c020:	dd800715 	stw	r22,28(sp)
8111c024:	dd000515 	stw	r20,20(sp)
8111c028:	dc800315 	stw	r18,12(sp)
8111c02c:	18ffffc4 	addi	r3,r3,-1
8111c030:	dfc00a15 	stw	ra,40(sp)
8111c034:	df000915 	stw	fp,36(sp)
8111c038:	ddc00815 	stw	r23,32(sp)
8111c03c:	dd400615 	stw	r21,24(sp)
8111c040:	dc400215 	stw	r17,8(sp)
8111c044:	dc000115 	stw	r16,4(sp)
8111c048:	35003fcc 	andi	r20,r6,255
8111c04c:	1924703a 	and	r18,r3,r4
8111c050:	9d803fcc 	andi	r22,r19,255
8111c054:	a0005226 	beq	r20,zero,8111c1a0 <__divsf3+0x19c>
8111c058:	00803fc4 	movi	r2,255
8111c05c:	a0802e26 	beq	r20,r2,8111c118 <__divsf3+0x114>
8111c060:	91002034 	orhi	r4,r18,128
8111c064:	202490fa 	slli	r18,r4,3
8111c068:	a53fe044 	addi	r20,r20,-127
8111c06c:	0021883a 	mov	r16,zero
8111c070:	002f883a 	mov	r23,zero
8111c074:	280cd5fa 	srli	r6,r5,23
8111c078:	282ad7fa 	srli	r21,r5,31
8111c07c:	00c02034 	movhi	r3,128
8111c080:	18ffffc4 	addi	r3,r3,-1
8111c084:	31803fcc 	andi	r6,r6,255
8111c088:	1962703a 	and	r17,r3,r5
8111c08c:	af003fcc 	andi	fp,r21,255
8111c090:	30004a26 	beq	r6,zero,8111c1bc <__divsf3+0x1b8>
8111c094:	00803fc4 	movi	r2,255
8111c098:	30804526 	beq	r6,r2,8111c1b0 <__divsf3+0x1ac>
8111c09c:	89402034 	orhi	r5,r17,128
8111c0a0:	282290fa 	slli	r17,r5,3
8111c0a4:	31bfe044 	addi	r6,r6,-127
8111c0a8:	000b883a 	mov	r5,zero
8111c0ac:	2c20b03a 	or	r16,r5,r16
8111c0b0:	802090ba 	slli	r16,r16,2
8111c0b4:	00a044b4 	movhi	r2,33042
8111c0b8:	10b03604 	addi	r2,r2,-16168
8111c0bc:	80a1883a 	add	r16,r16,r2
8111c0c0:	81000017 	ldw	r4,0(r16)
8111c0c4:	9d46f03a 	xor	r3,r19,r21
8111c0c8:	180f883a 	mov	r7,r3
8111c0cc:	18803fcc 	andi	r2,r3,255
8111c0d0:	a18dc83a 	sub	r6,r20,r6
8111c0d4:	2000683a 	jmp	r4
8111c0d8:	8111c2bc 	xorhi	r4,r16,18186
8111c0dc:	8111c140 	call	88111c14 <__reset+0x20f1c14>
8111c0e0:	8111c2b0 	cmpltui	r4,r16,18186
8111c0e4:	8111c12c 	andhi	r4,r16,18180
8111c0e8:	8111c2b0 	cmpltui	r4,r16,18186
8111c0ec:	8111c288 	cmpgei	r4,r16,18186
8111c0f0:	8111c2b0 	cmpltui	r4,r16,18186
8111c0f4:	8111c12c 	andhi	r4,r16,18180
8111c0f8:	8111c140 	call	88111c14 <__reset+0x20f1c14>
8111c0fc:	8111c140 	call	88111c14 <__reset+0x20f1c14>
8111c100:	8111c288 	cmpgei	r4,r16,18186
8111c104:	8111c12c 	andhi	r4,r16,18180
8111c108:	8111c39c 	xori	r4,r16,18190
8111c10c:	8111c39c 	xori	r4,r16,18190
8111c110:	8111c39c 	xori	r4,r16,18190
8111c114:	8111c350 	cmplti	r4,r16,18189
8111c118:	9000581e 	bne	r18,zero,8111c27c <__divsf3+0x278>
8111c11c:	04000204 	movi	r16,8
8111c120:	05c00084 	movi	r23,2
8111c124:	003fd306 	br	8111c074 <__reset+0xfb0fc074>
8111c128:	0023883a 	mov	r17,zero
8111c12c:	e02d883a 	mov	r22,fp
8111c130:	282f883a 	mov	r23,r5
8111c134:	00800084 	movi	r2,2
8111c138:	b8808f1e 	bne	r23,r2,8111c378 <__divsf3+0x374>
8111c13c:	b005883a 	mov	r2,r22
8111c140:	11c0004c 	andi	r7,r2,1
8111c144:	013fffc4 	movi	r4,-1
8111c148:	000d883a 	mov	r6,zero
8111c14c:	21003fcc 	andi	r4,r4,255
8111c150:	200895fa 	slli	r4,r4,23
8111c154:	38803fcc 	andi	r2,r7,255
8111c158:	00c02034 	movhi	r3,128
8111c15c:	100497fa 	slli	r2,r2,31
8111c160:	18ffffc4 	addi	r3,r3,-1
8111c164:	30c6703a 	and	r3,r6,r3
8111c168:	1906b03a 	or	r3,r3,r4
8111c16c:	1884b03a 	or	r2,r3,r2
8111c170:	dfc00a17 	ldw	ra,40(sp)
8111c174:	df000917 	ldw	fp,36(sp)
8111c178:	ddc00817 	ldw	r23,32(sp)
8111c17c:	dd800717 	ldw	r22,28(sp)
8111c180:	dd400617 	ldw	r21,24(sp)
8111c184:	dd000517 	ldw	r20,20(sp)
8111c188:	dcc00417 	ldw	r19,16(sp)
8111c18c:	dc800317 	ldw	r18,12(sp)
8111c190:	dc400217 	ldw	r17,8(sp)
8111c194:	dc000117 	ldw	r16,4(sp)
8111c198:	dec00b04 	addi	sp,sp,44
8111c19c:	f800283a 	ret
8111c1a0:	90002b1e 	bne	r18,zero,8111c250 <__divsf3+0x24c>
8111c1a4:	04000104 	movi	r16,4
8111c1a8:	05c00044 	movi	r23,1
8111c1ac:	003fb106 	br	8111c074 <__reset+0xfb0fc074>
8111c1b0:	8800251e 	bne	r17,zero,8111c248 <__divsf3+0x244>
8111c1b4:	01400084 	movi	r5,2
8111c1b8:	00000206 	br	8111c1c4 <__divsf3+0x1c0>
8111c1bc:	88001a1e 	bne	r17,zero,8111c228 <__divsf3+0x224>
8111c1c0:	01400044 	movi	r5,1
8111c1c4:	8160b03a 	or	r16,r16,r5
8111c1c8:	802090ba 	slli	r16,r16,2
8111c1cc:	00e044b4 	movhi	r3,33042
8111c1d0:	18f07a04 	addi	r3,r3,-15896
8111c1d4:	80e1883a 	add	r16,r16,r3
8111c1d8:	80c00017 	ldw	r3,0(r16)
8111c1dc:	9d44f03a 	xor	r2,r19,r21
8111c1e0:	a18dc83a 	sub	r6,r20,r6
8111c1e4:	1800683a 	jmp	r3
8111c1e8:	8111c140 	call	88111c14 <__reset+0x20f1c14>
8111c1ec:	8111c140 	call	88111c14 <__reset+0x20f1c14>
8111c1f0:	8111c38c 	andi	r4,r16,18190
8111c1f4:	8111c128 	cmpgeui	r4,r16,18180
8111c1f8:	8111c38c 	andi	r4,r16,18190
8111c1fc:	8111c288 	cmpgei	r4,r16,18186
8111c200:	8111c38c 	andi	r4,r16,18190
8111c204:	8111c128 	cmpgeui	r4,r16,18180
8111c208:	8111c140 	call	88111c14 <__reset+0x20f1c14>
8111c20c:	8111c140 	call	88111c14 <__reset+0x20f1c14>
8111c210:	8111c288 	cmpgei	r4,r16,18186
8111c214:	8111c128 	cmpgeui	r4,r16,18180
8111c218:	8111c39c 	xori	r4,r16,18190
8111c21c:	8111c39c 	xori	r4,r16,18190
8111c220:	8111c39c 	xori	r4,r16,18190
8111c224:	8111c3b4 	orhi	r4,r16,18190
8111c228:	8809883a 	mov	r4,r17
8111c22c:	111d4540 	call	8111d454 <__clzsi2>
8111c230:	10fffec4 	addi	r3,r2,-5
8111c234:	10801d84 	addi	r2,r2,118
8111c238:	88e2983a 	sll	r17,r17,r3
8111c23c:	008dc83a 	sub	r6,zero,r2
8111c240:	000b883a 	mov	r5,zero
8111c244:	003f9906 	br	8111c0ac <__reset+0xfb0fc0ac>
8111c248:	014000c4 	movi	r5,3
8111c24c:	003f9706 	br	8111c0ac <__reset+0xfb0fc0ac>
8111c250:	9009883a 	mov	r4,r18
8111c254:	d9400015 	stw	r5,0(sp)
8111c258:	111d4540 	call	8111d454 <__clzsi2>
8111c25c:	10fffec4 	addi	r3,r2,-5
8111c260:	11801d84 	addi	r6,r2,118
8111c264:	90e4983a 	sll	r18,r18,r3
8111c268:	01a9c83a 	sub	r20,zero,r6
8111c26c:	0021883a 	mov	r16,zero
8111c270:	002f883a 	mov	r23,zero
8111c274:	d9400017 	ldw	r5,0(sp)
8111c278:	003f7e06 	br	8111c074 <__reset+0xfb0fc074>
8111c27c:	04000304 	movi	r16,12
8111c280:	05c000c4 	movi	r23,3
8111c284:	003f7b06 	br	8111c074 <__reset+0xfb0fc074>
8111c288:	01802034 	movhi	r6,128
8111c28c:	000f883a 	mov	r7,zero
8111c290:	31bfffc4 	addi	r6,r6,-1
8111c294:	013fffc4 	movi	r4,-1
8111c298:	003fac06 	br	8111c14c <__reset+0xfb0fc14c>
8111c29c:	01400044 	movi	r5,1
8111c2a0:	2909c83a 	sub	r4,r5,r4
8111c2a4:	00c006c4 	movi	r3,27
8111c2a8:	19004b0e 	bge	r3,r4,8111c3d8 <__divsf3+0x3d4>
8111c2ac:	114e703a 	and	r7,r2,r5
8111c2b0:	0009883a 	mov	r4,zero
8111c2b4:	000d883a 	mov	r6,zero
8111c2b8:	003fa406 	br	8111c14c <__reset+0xfb0fc14c>
8111c2bc:	9006917a 	slli	r3,r18,5
8111c2c0:	8822917a 	slli	r17,r17,5
8111c2c4:	1c40372e 	bgeu	r3,r17,8111c3a4 <__divsf3+0x3a0>
8111c2c8:	31bfffc4 	addi	r6,r6,-1
8111c2cc:	010006c4 	movi	r4,27
8111c2d0:	000b883a 	mov	r5,zero
8111c2d4:	180f883a 	mov	r7,r3
8111c2d8:	294b883a 	add	r5,r5,r5
8111c2dc:	18c7883a 	add	r3,r3,r3
8111c2e0:	38000116 	blt	r7,zero,8111c2e8 <__divsf3+0x2e4>
8111c2e4:	1c400236 	bltu	r3,r17,8111c2f0 <__divsf3+0x2ec>
8111c2e8:	1c47c83a 	sub	r3,r3,r17
8111c2ec:	29400054 	ori	r5,r5,1
8111c2f0:	213fffc4 	addi	r4,r4,-1
8111c2f4:	203ff71e 	bne	r4,zero,8111c2d4 <__reset+0xfb0fc2d4>
8111c2f8:	1806c03a 	cmpne	r3,r3,zero
8111c2fc:	1962b03a 	or	r17,r3,r5
8111c300:	31001fc4 	addi	r4,r6,127
8111c304:	013fe50e 	bge	zero,r4,8111c29c <__reset+0xfb0fc29c>
8111c308:	88c001cc 	andi	r3,r17,7
8111c30c:	18000426 	beq	r3,zero,8111c320 <__divsf3+0x31c>
8111c310:	88c003cc 	andi	r3,r17,15
8111c314:	01400104 	movi	r5,4
8111c318:	19400126 	beq	r3,r5,8111c320 <__divsf3+0x31c>
8111c31c:	8963883a 	add	r17,r17,r5
8111c320:	88c2002c 	andhi	r3,r17,2048
8111c324:	18000426 	beq	r3,zero,8111c338 <__divsf3+0x334>
8111c328:	00fe0034 	movhi	r3,63488
8111c32c:	18ffffc4 	addi	r3,r3,-1
8111c330:	31002004 	addi	r4,r6,128
8111c334:	88e2703a 	and	r17,r17,r3
8111c338:	00c03f84 	movi	r3,254
8111c33c:	193f8016 	blt	r3,r4,8111c140 <__reset+0xfb0fc140>
8111c340:	880c91ba 	slli	r6,r17,6
8111c344:	11c0004c 	andi	r7,r2,1
8111c348:	300cd27a 	srli	r6,r6,9
8111c34c:	003f7f06 	br	8111c14c <__reset+0xfb0fc14c>
8111c350:	9080102c 	andhi	r2,r18,64
8111c354:	10000226 	beq	r2,zero,8111c360 <__divsf3+0x35c>
8111c358:	8880102c 	andhi	r2,r17,64
8111c35c:	10001826 	beq	r2,zero,8111c3c0 <__divsf3+0x3bc>
8111c360:	00802034 	movhi	r2,128
8111c364:	91801034 	orhi	r6,r18,64
8111c368:	10bfffc4 	addi	r2,r2,-1
8111c36c:	980f883a 	mov	r7,r19
8111c370:	308c703a 	and	r6,r6,r2
8111c374:	003fc706 	br	8111c294 <__reset+0xfb0fc294>
8111c378:	008000c4 	movi	r2,3
8111c37c:	b8802d26 	beq	r23,r2,8111c434 <__divsf3+0x430>
8111c380:	00c00044 	movi	r3,1
8111c384:	b005883a 	mov	r2,r22
8111c388:	b8ffdd1e 	bne	r23,r3,8111c300 <__reset+0xfb0fc300>
8111c38c:	11c0004c 	andi	r7,r2,1
8111c390:	0009883a 	mov	r4,zero
8111c394:	000d883a 	mov	r6,zero
8111c398:	003f6c06 	br	8111c14c <__reset+0xfb0fc14c>
8111c39c:	9023883a 	mov	r17,r18
8111c3a0:	003f6406 	br	8111c134 <__reset+0xfb0fc134>
8111c3a4:	1c47c83a 	sub	r3,r3,r17
8111c3a8:	01000684 	movi	r4,26
8111c3ac:	01400044 	movi	r5,1
8111c3b0:	003fc806 	br	8111c2d4 <__reset+0xfb0fc2d4>
8111c3b4:	9080102c 	andhi	r2,r18,64
8111c3b8:	103fe926 	beq	r2,zero,8111c360 <__reset+0xfb0fc360>
8111c3bc:	0023883a 	mov	r17,zero
8111c3c0:	00802034 	movhi	r2,128
8111c3c4:	89801034 	orhi	r6,r17,64
8111c3c8:	10bfffc4 	addi	r2,r2,-1
8111c3cc:	a80f883a 	mov	r7,r21
8111c3d0:	308c703a 	and	r6,r6,r2
8111c3d4:	003faf06 	br	8111c294 <__reset+0xfb0fc294>
8111c3d8:	01c00804 	movi	r7,32
8111c3dc:	390fc83a 	sub	r7,r7,r4
8111c3e0:	89ce983a 	sll	r7,r17,r7
8111c3e4:	890ad83a 	srl	r5,r17,r4
8111c3e8:	380ec03a 	cmpne	r7,r7,zero
8111c3ec:	29cab03a 	or	r5,r5,r7
8111c3f0:	28c001cc 	andi	r3,r5,7
8111c3f4:	18000426 	beq	r3,zero,8111c408 <__divsf3+0x404>
8111c3f8:	28c003cc 	andi	r3,r5,15
8111c3fc:	01000104 	movi	r4,4
8111c400:	19000126 	beq	r3,r4,8111c408 <__divsf3+0x404>
8111c404:	290b883a 	add	r5,r5,r4
8111c408:	28c1002c 	andhi	r3,r5,1024
8111c40c:	18000426 	beq	r3,zero,8111c420 <__divsf3+0x41c>
8111c410:	11c0004c 	andi	r7,r2,1
8111c414:	01000044 	movi	r4,1
8111c418:	000d883a 	mov	r6,zero
8111c41c:	003f4b06 	br	8111c14c <__reset+0xfb0fc14c>
8111c420:	280a91ba 	slli	r5,r5,6
8111c424:	11c0004c 	andi	r7,r2,1
8111c428:	0009883a 	mov	r4,zero
8111c42c:	280cd27a 	srli	r6,r5,9
8111c430:	003f4606 	br	8111c14c <__reset+0xfb0fc14c>
8111c434:	00802034 	movhi	r2,128
8111c438:	89801034 	orhi	r6,r17,64
8111c43c:	10bfffc4 	addi	r2,r2,-1
8111c440:	b00f883a 	mov	r7,r22
8111c444:	308c703a 	and	r6,r6,r2
8111c448:	003f9206 	br	8111c294 <__reset+0xfb0fc294>

8111c44c <__mulsf3>:
8111c44c:	defff504 	addi	sp,sp,-44
8111c450:	de00012e 	bgeu	sp,et,8111c458 <__mulsf3+0xc>
8111c454:	003b68fa 	trap	3
8111c458:	dc000115 	stw	r16,4(sp)
8111c45c:	2020d5fa 	srli	r16,r4,23
8111c460:	dd400615 	stw	r21,24(sp)
8111c464:	202ad7fa 	srli	r21,r4,31
8111c468:	dc800315 	stw	r18,12(sp)
8111c46c:	04802034 	movhi	r18,128
8111c470:	df000915 	stw	fp,36(sp)
8111c474:	dd000515 	stw	r20,20(sp)
8111c478:	94bfffc4 	addi	r18,r18,-1
8111c47c:	dfc00a15 	stw	ra,40(sp)
8111c480:	ddc00815 	stw	r23,32(sp)
8111c484:	dd800715 	stw	r22,28(sp)
8111c488:	dcc00415 	stw	r19,16(sp)
8111c48c:	dc400215 	stw	r17,8(sp)
8111c490:	84003fcc 	andi	r16,r16,255
8111c494:	9124703a 	and	r18,r18,r4
8111c498:	a829883a 	mov	r20,r21
8111c49c:	af003fcc 	andi	fp,r21,255
8111c4a0:	80005426 	beq	r16,zero,8111c5f4 <__mulsf3+0x1a8>
8111c4a4:	00803fc4 	movi	r2,255
8111c4a8:	80802f26 	beq	r16,r2,8111c568 <__mulsf3+0x11c>
8111c4ac:	91002034 	orhi	r4,r18,128
8111c4b0:	202490fa 	slli	r18,r4,3
8111c4b4:	843fe044 	addi	r16,r16,-127
8111c4b8:	0023883a 	mov	r17,zero
8111c4bc:	002f883a 	mov	r23,zero
8111c4c0:	2804d5fa 	srli	r2,r5,23
8111c4c4:	282cd7fa 	srli	r22,r5,31
8111c4c8:	01002034 	movhi	r4,128
8111c4cc:	213fffc4 	addi	r4,r4,-1
8111c4d0:	10803fcc 	andi	r2,r2,255
8111c4d4:	2166703a 	and	r19,r4,r5
8111c4d8:	b1803fcc 	andi	r6,r22,255
8111c4dc:	10004c26 	beq	r2,zero,8111c610 <__mulsf3+0x1c4>
8111c4e0:	00c03fc4 	movi	r3,255
8111c4e4:	10c04726 	beq	r2,r3,8111c604 <__mulsf3+0x1b8>
8111c4e8:	99002034 	orhi	r4,r19,128
8111c4ec:	202690fa 	slli	r19,r4,3
8111c4f0:	10bfe044 	addi	r2,r2,-127
8111c4f4:	0007883a 	mov	r3,zero
8111c4f8:	80a1883a 	add	r16,r16,r2
8111c4fc:	010003c4 	movi	r4,15
8111c500:	1c44b03a 	or	r2,r3,r17
8111c504:	b56af03a 	xor	r21,r22,r21
8111c508:	81c00044 	addi	r7,r16,1
8111c50c:	20806b36 	bltu	r4,r2,8111c6bc <__mulsf3+0x270>
8111c510:	100490ba 	slli	r2,r2,2
8111c514:	012044b4 	movhi	r4,33042
8111c518:	21314a04 	addi	r4,r4,-15064
8111c51c:	1105883a 	add	r2,r2,r4
8111c520:	10800017 	ldw	r2,0(r2)
8111c524:	1000683a 	jmp	r2
8111c528:	8111c6bc 	xorhi	r4,r16,18202
8111c52c:	8111c57c 	xorhi	r4,r16,18197
8111c530:	8111c57c 	xorhi	r4,r16,18197
8111c534:	8111c578 	rdprs	r4,r16,18197
8111c538:	8111c6a0 	cmpeqi	r4,r16,18202
8111c53c:	8111c6a0 	cmpeqi	r4,r16,18202
8111c540:	8111c68c 	andi	r4,r16,18202
8111c544:	8111c578 	rdprs	r4,r16,18197
8111c548:	8111c6a0 	cmpeqi	r4,r16,18202
8111c54c:	8111c68c 	andi	r4,r16,18202
8111c550:	8111c6a0 	cmpeqi	r4,r16,18202
8111c554:	8111c578 	rdprs	r4,r16,18197
8111c558:	8111c6ac 	andhi	r4,r16,18202
8111c55c:	8111c6ac 	andhi	r4,r16,18202
8111c560:	8111c6ac 	andhi	r4,r16,18202
8111c564:	8111c788 	cmpgei	r4,r16,18206
8111c568:	90003b1e 	bne	r18,zero,8111c658 <__mulsf3+0x20c>
8111c56c:	04400204 	movi	r17,8
8111c570:	05c00084 	movi	r23,2
8111c574:	003fd206 	br	8111c4c0 <__reset+0xfb0fc4c0>
8111c578:	302b883a 	mov	r21,r6
8111c57c:	00800084 	movi	r2,2
8111c580:	18802626 	beq	r3,r2,8111c61c <__mulsf3+0x1d0>
8111c584:	008000c4 	movi	r2,3
8111c588:	1880ab26 	beq	r3,r2,8111c838 <__mulsf3+0x3ec>
8111c58c:	00800044 	movi	r2,1
8111c590:	1880a21e 	bne	r3,r2,8111c81c <__mulsf3+0x3d0>
8111c594:	a829883a 	mov	r20,r21
8111c598:	0007883a 	mov	r3,zero
8111c59c:	0009883a 	mov	r4,zero
8111c5a0:	18803fcc 	andi	r2,r3,255
8111c5a4:	100695fa 	slli	r3,r2,23
8111c5a8:	a0803fcc 	andi	r2,r20,255
8111c5ac:	100a97fa 	slli	r5,r2,31
8111c5b0:	00802034 	movhi	r2,128
8111c5b4:	10bfffc4 	addi	r2,r2,-1
8111c5b8:	2084703a 	and	r2,r4,r2
8111c5bc:	10c4b03a 	or	r2,r2,r3
8111c5c0:	1144b03a 	or	r2,r2,r5
8111c5c4:	dfc00a17 	ldw	ra,40(sp)
8111c5c8:	df000917 	ldw	fp,36(sp)
8111c5cc:	ddc00817 	ldw	r23,32(sp)
8111c5d0:	dd800717 	ldw	r22,28(sp)
8111c5d4:	dd400617 	ldw	r21,24(sp)
8111c5d8:	dd000517 	ldw	r20,20(sp)
8111c5dc:	dcc00417 	ldw	r19,16(sp)
8111c5e0:	dc800317 	ldw	r18,12(sp)
8111c5e4:	dc400217 	ldw	r17,8(sp)
8111c5e8:	dc000117 	ldw	r16,4(sp)
8111c5ec:	dec00b04 	addi	sp,sp,44
8111c5f0:	f800283a 	ret
8111c5f4:	90000d1e 	bne	r18,zero,8111c62c <__mulsf3+0x1e0>
8111c5f8:	04400104 	movi	r17,4
8111c5fc:	05c00044 	movi	r23,1
8111c600:	003faf06 	br	8111c4c0 <__reset+0xfb0fc4c0>
8111c604:	9806c03a 	cmpne	r3,r19,zero
8111c608:	18c00084 	addi	r3,r3,2
8111c60c:	003fba06 	br	8111c4f8 <__reset+0xfb0fc4f8>
8111c610:	9800141e 	bne	r19,zero,8111c664 <__mulsf3+0x218>
8111c614:	00c00044 	movi	r3,1
8111c618:	003fb706 	br	8111c4f8 <__reset+0xfb0fc4f8>
8111c61c:	a829883a 	mov	r20,r21
8111c620:	00ffffc4 	movi	r3,-1
8111c624:	0009883a 	mov	r4,zero
8111c628:	003fdd06 	br	8111c5a0 <__reset+0xfb0fc5a0>
8111c62c:	9009883a 	mov	r4,r18
8111c630:	d9400015 	stw	r5,0(sp)
8111c634:	111d4540 	call	8111d454 <__clzsi2>
8111c638:	10fffec4 	addi	r3,r2,-5
8111c63c:	10801d84 	addi	r2,r2,118
8111c640:	90e4983a 	sll	r18,r18,r3
8111c644:	00a1c83a 	sub	r16,zero,r2
8111c648:	0023883a 	mov	r17,zero
8111c64c:	002f883a 	mov	r23,zero
8111c650:	d9400017 	ldw	r5,0(sp)
8111c654:	003f9a06 	br	8111c4c0 <__reset+0xfb0fc4c0>
8111c658:	04400304 	movi	r17,12
8111c65c:	05c000c4 	movi	r23,3
8111c660:	003f9706 	br	8111c4c0 <__reset+0xfb0fc4c0>
8111c664:	9809883a 	mov	r4,r19
8111c668:	d9800015 	stw	r6,0(sp)
8111c66c:	111d4540 	call	8111d454 <__clzsi2>
8111c670:	10fffec4 	addi	r3,r2,-5
8111c674:	10801d84 	addi	r2,r2,118
8111c678:	98e6983a 	sll	r19,r19,r3
8111c67c:	0085c83a 	sub	r2,zero,r2
8111c680:	0007883a 	mov	r3,zero
8111c684:	d9800017 	ldw	r6,0(sp)
8111c688:	003f9b06 	br	8111c4f8 <__reset+0xfb0fc4f8>
8111c68c:	01002034 	movhi	r4,128
8111c690:	0029883a 	mov	r20,zero
8111c694:	213fffc4 	addi	r4,r4,-1
8111c698:	00ffffc4 	movi	r3,-1
8111c69c:	003fc006 	br	8111c5a0 <__reset+0xfb0fc5a0>
8111c6a0:	9027883a 	mov	r19,r18
8111c6a4:	b807883a 	mov	r3,r23
8111c6a8:	003fb406 	br	8111c57c <__reset+0xfb0fc57c>
8111c6ac:	9027883a 	mov	r19,r18
8111c6b0:	e02b883a 	mov	r21,fp
8111c6b4:	b807883a 	mov	r3,r23
8111c6b8:	003fb006 	br	8111c57c <__reset+0xfb0fc57c>
8111c6bc:	9004d43a 	srli	r2,r18,16
8111c6c0:	9810d43a 	srli	r8,r19,16
8111c6c4:	94bfffcc 	andi	r18,r18,65535
8111c6c8:	993fffcc 	andi	r4,r19,65535
8111c6cc:	910d383a 	mul	r6,r18,r4
8111c6d0:	20a7383a 	mul	r19,r4,r2
8111c6d4:	9225383a 	mul	r18,r18,r8
8111c6d8:	3006d43a 	srli	r3,r6,16
8111c6dc:	1211383a 	mul	r8,r2,r8
8111c6e0:	94e5883a 	add	r18,r18,r19
8111c6e4:	1c87883a 	add	r3,r3,r18
8111c6e8:	1cc0022e 	bgeu	r3,r19,8111c6f4 <__mulsf3+0x2a8>
8111c6ec:	00800074 	movhi	r2,1
8111c6f0:	4091883a 	add	r8,r8,r2
8111c6f4:	1804943a 	slli	r2,r3,16
8111c6f8:	31bfffcc 	andi	r6,r6,65535
8111c6fc:	1806d43a 	srli	r3,r3,16
8111c700:	1185883a 	add	r2,r2,r6
8111c704:	102691ba 	slli	r19,r2,6
8111c708:	1a07883a 	add	r3,r3,r8
8111c70c:	1004d6ba 	srli	r2,r2,26
8111c710:	180891ba 	slli	r4,r3,6
8111c714:	9826c03a 	cmpne	r19,r19,zero
8111c718:	9884b03a 	or	r2,r19,r2
8111c71c:	1126b03a 	or	r19,r2,r4
8111c720:	9882002c 	andhi	r2,r19,2048
8111c724:	10000426 	beq	r2,zero,8111c738 <__mulsf3+0x2ec>
8111c728:	9804d07a 	srli	r2,r19,1
8111c72c:	9900004c 	andi	r4,r19,1
8111c730:	3821883a 	mov	r16,r7
8111c734:	1126b03a 	or	r19,r2,r4
8111c738:	80c01fc4 	addi	r3,r16,127
8111c73c:	00c0210e 	bge	zero,r3,8111c7c4 <__mulsf3+0x378>
8111c740:	988001cc 	andi	r2,r19,7
8111c744:	10000426 	beq	r2,zero,8111c758 <__mulsf3+0x30c>
8111c748:	988003cc 	andi	r2,r19,15
8111c74c:	01000104 	movi	r4,4
8111c750:	11000126 	beq	r2,r4,8111c758 <__mulsf3+0x30c>
8111c754:	9927883a 	add	r19,r19,r4
8111c758:	9882002c 	andhi	r2,r19,2048
8111c75c:	10000426 	beq	r2,zero,8111c770 <__mulsf3+0x324>
8111c760:	00be0034 	movhi	r2,63488
8111c764:	10bfffc4 	addi	r2,r2,-1
8111c768:	80c02004 	addi	r3,r16,128
8111c76c:	98a6703a 	and	r19,r19,r2
8111c770:	00803f84 	movi	r2,254
8111c774:	10ffa916 	blt	r2,r3,8111c61c <__reset+0xfb0fc61c>
8111c778:	980891ba 	slli	r4,r19,6
8111c77c:	a829883a 	mov	r20,r21
8111c780:	2008d27a 	srli	r4,r4,9
8111c784:	003f8606 	br	8111c5a0 <__reset+0xfb0fc5a0>
8111c788:	9080102c 	andhi	r2,r18,64
8111c78c:	10000826 	beq	r2,zero,8111c7b0 <__mulsf3+0x364>
8111c790:	9880102c 	andhi	r2,r19,64
8111c794:	1000061e 	bne	r2,zero,8111c7b0 <__mulsf3+0x364>
8111c798:	00802034 	movhi	r2,128
8111c79c:	99001034 	orhi	r4,r19,64
8111c7a0:	10bfffc4 	addi	r2,r2,-1
8111c7a4:	b029883a 	mov	r20,r22
8111c7a8:	2088703a 	and	r4,r4,r2
8111c7ac:	003fba06 	br	8111c698 <__reset+0xfb0fc698>
8111c7b0:	00802034 	movhi	r2,128
8111c7b4:	91001034 	orhi	r4,r18,64
8111c7b8:	10bfffc4 	addi	r2,r2,-1
8111c7bc:	2088703a 	and	r4,r4,r2
8111c7c0:	003fb506 	br	8111c698 <__reset+0xfb0fc698>
8111c7c4:	00800044 	movi	r2,1
8111c7c8:	10c7c83a 	sub	r3,r2,r3
8111c7cc:	008006c4 	movi	r2,27
8111c7d0:	10ff7016 	blt	r2,r3,8111c594 <__reset+0xfb0fc594>
8111c7d4:	00800804 	movi	r2,32
8111c7d8:	10c5c83a 	sub	r2,r2,r3
8111c7dc:	9884983a 	sll	r2,r19,r2
8111c7e0:	98c6d83a 	srl	r3,r19,r3
8111c7e4:	1004c03a 	cmpne	r2,r2,zero
8111c7e8:	1884b03a 	or	r2,r3,r2
8111c7ec:	10c001cc 	andi	r3,r2,7
8111c7f0:	18000426 	beq	r3,zero,8111c804 <__mulsf3+0x3b8>
8111c7f4:	10c003cc 	andi	r3,r2,15
8111c7f8:	01000104 	movi	r4,4
8111c7fc:	19000126 	beq	r3,r4,8111c804 <__mulsf3+0x3b8>
8111c800:	1105883a 	add	r2,r2,r4
8111c804:	10c1002c 	andhi	r3,r2,1024
8111c808:	18000626 	beq	r3,zero,8111c824 <__mulsf3+0x3d8>
8111c80c:	a829883a 	mov	r20,r21
8111c810:	00c00044 	movi	r3,1
8111c814:	0009883a 	mov	r4,zero
8111c818:	003f6106 	br	8111c5a0 <__reset+0xfb0fc5a0>
8111c81c:	3821883a 	mov	r16,r7
8111c820:	003fc506 	br	8111c738 <__reset+0xfb0fc738>
8111c824:	100491ba 	slli	r2,r2,6
8111c828:	a829883a 	mov	r20,r21
8111c82c:	0007883a 	mov	r3,zero
8111c830:	1008d27a 	srli	r4,r2,9
8111c834:	003f5a06 	br	8111c5a0 <__reset+0xfb0fc5a0>
8111c838:	00802034 	movhi	r2,128
8111c83c:	99001034 	orhi	r4,r19,64
8111c840:	10bfffc4 	addi	r2,r2,-1
8111c844:	a829883a 	mov	r20,r21
8111c848:	2088703a 	and	r4,r4,r2
8111c84c:	003f9206 	br	8111c698 <__reset+0xfb0fc698>

8111c850 <__floatsisf>:
8111c850:	defffd04 	addi	sp,sp,-12
8111c854:	de00012e 	bgeu	sp,et,8111c85c <__floatsisf+0xc>
8111c858:	003b68fa 	trap	3
8111c85c:	dfc00215 	stw	ra,8(sp)
8111c860:	dc400115 	stw	r17,4(sp)
8111c864:	dc000015 	stw	r16,0(sp)
8111c868:	20003526 	beq	r4,zero,8111c940 <__floatsisf+0xf0>
8111c86c:	2021883a 	mov	r16,r4
8111c870:	2022d7fa 	srli	r17,r4,31
8111c874:	20003616 	blt	r4,zero,8111c950 <__floatsisf+0x100>
8111c878:	8009883a 	mov	r4,r16
8111c87c:	111d4540 	call	8111d454 <__clzsi2>
8111c880:	00c02784 	movi	r3,158
8111c884:	1887c83a 	sub	r3,r3,r2
8111c888:	01002584 	movi	r4,150
8111c88c:	20c01416 	blt	r4,r3,8111c8e0 <__floatsisf+0x90>
8111c890:	20c9c83a 	sub	r4,r4,r3
8111c894:	8120983a 	sll	r16,r16,r4
8111c898:	00802034 	movhi	r2,128
8111c89c:	10bfffc4 	addi	r2,r2,-1
8111c8a0:	8809883a 	mov	r4,r17
8111c8a4:	80a0703a 	and	r16,r16,r2
8111c8a8:	18803fcc 	andi	r2,r3,255
8111c8ac:	100695fa 	slli	r3,r2,23
8111c8b0:	20803fcc 	andi	r2,r4,255
8111c8b4:	100897fa 	slli	r4,r2,31
8111c8b8:	00802034 	movhi	r2,128
8111c8bc:	10bfffc4 	addi	r2,r2,-1
8111c8c0:	8084703a 	and	r2,r16,r2
8111c8c4:	10c4b03a 	or	r2,r2,r3
8111c8c8:	1104b03a 	or	r2,r2,r4
8111c8cc:	dfc00217 	ldw	ra,8(sp)
8111c8d0:	dc400117 	ldw	r17,4(sp)
8111c8d4:	dc000017 	ldw	r16,0(sp)
8111c8d8:	dec00304 	addi	sp,sp,12
8111c8dc:	f800283a 	ret
8111c8e0:	01002644 	movi	r4,153
8111c8e4:	20c01c16 	blt	r4,r3,8111c958 <__floatsisf+0x108>
8111c8e8:	20c9c83a 	sub	r4,r4,r3
8111c8ec:	8120983a 	sll	r16,r16,r4
8111c8f0:	013f0034 	movhi	r4,64512
8111c8f4:	213fffc4 	addi	r4,r4,-1
8111c8f8:	814001cc 	andi	r5,r16,7
8111c8fc:	8108703a 	and	r4,r16,r4
8111c900:	28000426 	beq	r5,zero,8111c914 <__floatsisf+0xc4>
8111c904:	840003cc 	andi	r16,r16,15
8111c908:	01400104 	movi	r5,4
8111c90c:	81400126 	beq	r16,r5,8111c914 <__floatsisf+0xc4>
8111c910:	2149883a 	add	r4,r4,r5
8111c914:	2141002c 	andhi	r5,r4,1024
8111c918:	28000526 	beq	r5,zero,8111c930 <__floatsisf+0xe0>
8111c91c:	00c027c4 	movi	r3,159
8111c920:	1887c83a 	sub	r3,r3,r2
8111c924:	00bf0034 	movhi	r2,64512
8111c928:	10bfffc4 	addi	r2,r2,-1
8111c92c:	2088703a 	and	r4,r4,r2
8111c930:	202091ba 	slli	r16,r4,6
8111c934:	8809883a 	mov	r4,r17
8111c938:	8020d27a 	srli	r16,r16,9
8111c93c:	003fda06 	br	8111c8a8 <__reset+0xfb0fc8a8>
8111c940:	0009883a 	mov	r4,zero
8111c944:	0007883a 	mov	r3,zero
8111c948:	0021883a 	mov	r16,zero
8111c94c:	003fd606 	br	8111c8a8 <__reset+0xfb0fc8a8>
8111c950:	0121c83a 	sub	r16,zero,r4
8111c954:	003fc806 	br	8111c878 <__reset+0xfb0fc878>
8111c958:	01002e44 	movi	r4,185
8111c95c:	20c9c83a 	sub	r4,r4,r3
8111c960:	01400144 	movi	r5,5
8111c964:	8108983a 	sll	r4,r16,r4
8111c968:	288bc83a 	sub	r5,r5,r2
8111c96c:	8160d83a 	srl	r16,r16,r5
8111c970:	2008c03a 	cmpne	r4,r4,zero
8111c974:	8120b03a 	or	r16,r16,r4
8111c978:	003fdd06 	br	8111c8f0 <__reset+0xfb0fc8f0>

8111c97c <__floatunsisf>:
8111c97c:	defffe04 	addi	sp,sp,-8
8111c980:	de00012e 	bgeu	sp,et,8111c988 <__floatunsisf+0xc>
8111c984:	003b68fa 	trap	3
8111c988:	dfc00115 	stw	ra,4(sp)
8111c98c:	dc000015 	stw	r16,0(sp)
8111c990:	20002c26 	beq	r4,zero,8111ca44 <__floatunsisf+0xc8>
8111c994:	2021883a 	mov	r16,r4
8111c998:	111d4540 	call	8111d454 <__clzsi2>
8111c99c:	00c02784 	movi	r3,158
8111c9a0:	1887c83a 	sub	r3,r3,r2
8111c9a4:	01002584 	movi	r4,150
8111c9a8:	20c00f16 	blt	r4,r3,8111c9e8 <__floatunsisf+0x6c>
8111c9ac:	20c9c83a 	sub	r4,r4,r3
8111c9b0:	8108983a 	sll	r4,r16,r4
8111c9b4:	00802034 	movhi	r2,128
8111c9b8:	10bfffc4 	addi	r2,r2,-1
8111c9bc:	2088703a 	and	r4,r4,r2
8111c9c0:	18803fcc 	andi	r2,r3,255
8111c9c4:	100695fa 	slli	r3,r2,23
8111c9c8:	00802034 	movhi	r2,128
8111c9cc:	10bfffc4 	addi	r2,r2,-1
8111c9d0:	2084703a 	and	r2,r4,r2
8111c9d4:	10c4b03a 	or	r2,r2,r3
8111c9d8:	dfc00117 	ldw	ra,4(sp)
8111c9dc:	dc000017 	ldw	r16,0(sp)
8111c9e0:	dec00204 	addi	sp,sp,8
8111c9e4:	f800283a 	ret
8111c9e8:	01002644 	movi	r4,153
8111c9ec:	20c01816 	blt	r4,r3,8111ca50 <__floatunsisf+0xd4>
8111c9f0:	20c9c83a 	sub	r4,r4,r3
8111c9f4:	8108983a 	sll	r4,r16,r4
8111c9f8:	017f0034 	movhi	r5,64512
8111c9fc:	297fffc4 	addi	r5,r5,-1
8111ca00:	218001cc 	andi	r6,r4,7
8111ca04:	214a703a 	and	r5,r4,r5
8111ca08:	30000426 	beq	r6,zero,8111ca1c <__floatunsisf+0xa0>
8111ca0c:	210003cc 	andi	r4,r4,15
8111ca10:	01800104 	movi	r6,4
8111ca14:	21800126 	beq	r4,r6,8111ca1c <__floatunsisf+0xa0>
8111ca18:	298b883a 	add	r5,r5,r6
8111ca1c:	2901002c 	andhi	r4,r5,1024
8111ca20:	20000526 	beq	r4,zero,8111ca38 <__floatunsisf+0xbc>
8111ca24:	00c027c4 	movi	r3,159
8111ca28:	1887c83a 	sub	r3,r3,r2
8111ca2c:	00bf0034 	movhi	r2,64512
8111ca30:	10bfffc4 	addi	r2,r2,-1
8111ca34:	288a703a 	and	r5,r5,r2
8111ca38:	280891ba 	slli	r4,r5,6
8111ca3c:	2008d27a 	srli	r4,r4,9
8111ca40:	003fdf06 	br	8111c9c0 <__reset+0xfb0fc9c0>
8111ca44:	0007883a 	mov	r3,zero
8111ca48:	0009883a 	mov	r4,zero
8111ca4c:	003fdc06 	br	8111c9c0 <__reset+0xfb0fc9c0>
8111ca50:	01402e44 	movi	r5,185
8111ca54:	28cbc83a 	sub	r5,r5,r3
8111ca58:	01000144 	movi	r4,5
8111ca5c:	2089c83a 	sub	r4,r4,r2
8111ca60:	814a983a 	sll	r5,r16,r5
8111ca64:	8108d83a 	srl	r4,r16,r4
8111ca68:	2820c03a 	cmpne	r16,r5,zero
8111ca6c:	2408b03a 	or	r4,r4,r16
8111ca70:	003fe106 	br	8111c9f8 <__reset+0xfb0fc9f8>

8111ca74 <__muldf3>:
8111ca74:	defff304 	addi	sp,sp,-52
8111ca78:	2804d53a 	srli	r2,r5,20
8111ca7c:	de00012e 	bgeu	sp,et,8111ca84 <__muldf3+0x10>
8111ca80:	003b68fa 	trap	3
8111ca84:	dd800915 	stw	r22,36(sp)
8111ca88:	282cd7fa 	srli	r22,r5,31
8111ca8c:	dc000315 	stw	r16,12(sp)
8111ca90:	04000434 	movhi	r16,16
8111ca94:	dd400815 	stw	r21,32(sp)
8111ca98:	dc800515 	stw	r18,20(sp)
8111ca9c:	843fffc4 	addi	r16,r16,-1
8111caa0:	dfc00c15 	stw	ra,48(sp)
8111caa4:	df000b15 	stw	fp,44(sp)
8111caa8:	ddc00a15 	stw	r23,40(sp)
8111caac:	dd000715 	stw	r20,28(sp)
8111cab0:	dcc00615 	stw	r19,24(sp)
8111cab4:	dc400415 	stw	r17,16(sp)
8111cab8:	1481ffcc 	andi	r18,r2,2047
8111cabc:	2c20703a 	and	r16,r5,r16
8111cac0:	b02b883a 	mov	r21,r22
8111cac4:	b2403fcc 	andi	r9,r22,255
8111cac8:	90006026 	beq	r18,zero,8111cc4c <__muldf3+0x1d8>
8111cacc:	0081ffc4 	movi	r2,2047
8111cad0:	2029883a 	mov	r20,r4
8111cad4:	90803626 	beq	r18,r2,8111cbb0 <__muldf3+0x13c>
8111cad8:	80800434 	orhi	r2,r16,16
8111cadc:	100490fa 	slli	r2,r2,3
8111cae0:	2020d77a 	srli	r16,r4,29
8111cae4:	202890fa 	slli	r20,r4,3
8111cae8:	94bf0044 	addi	r18,r18,-1023
8111caec:	80a0b03a 	or	r16,r16,r2
8111caf0:	0027883a 	mov	r19,zero
8111caf4:	0039883a 	mov	fp,zero
8111caf8:	3804d53a 	srli	r2,r7,20
8111cafc:	382ed7fa 	srli	r23,r7,31
8111cb00:	04400434 	movhi	r17,16
8111cb04:	8c7fffc4 	addi	r17,r17,-1
8111cb08:	1081ffcc 	andi	r2,r2,2047
8111cb0c:	3011883a 	mov	r8,r6
8111cb10:	3c62703a 	and	r17,r7,r17
8111cb14:	ba803fcc 	andi	r10,r23,255
8111cb18:	10006d26 	beq	r2,zero,8111ccd0 <__muldf3+0x25c>
8111cb1c:	00c1ffc4 	movi	r3,2047
8111cb20:	10c06526 	beq	r2,r3,8111ccb8 <__muldf3+0x244>
8111cb24:	88c00434 	orhi	r3,r17,16
8111cb28:	180690fa 	slli	r3,r3,3
8111cb2c:	3022d77a 	srli	r17,r6,29
8111cb30:	301090fa 	slli	r8,r6,3
8111cb34:	10bf0044 	addi	r2,r2,-1023
8111cb38:	88e2b03a 	or	r17,r17,r3
8111cb3c:	000b883a 	mov	r5,zero
8111cb40:	9085883a 	add	r2,r18,r2
8111cb44:	2cc8b03a 	or	r4,r5,r19
8111cb48:	00c003c4 	movi	r3,15
8111cb4c:	bdacf03a 	xor	r22,r23,r22
8111cb50:	12c00044 	addi	r11,r2,1
8111cb54:	19009936 	bltu	r3,r4,8111cdbc <__muldf3+0x348>
8111cb58:	200890ba 	slli	r4,r4,2
8111cb5c:	00e044b4 	movhi	r3,33042
8111cb60:	18f2dc04 	addi	r3,r3,-13456
8111cb64:	20c9883a 	add	r4,r4,r3
8111cb68:	20c00017 	ldw	r3,0(r4)
8111cb6c:	1800683a 	jmp	r3
8111cb70:	8111cdbc 	xorhi	r4,r16,18230
8111cb74:	8111cbd0 	cmplti	r4,r16,18223
8111cb78:	8111cbd0 	cmplti	r4,r16,18223
8111cb7c:	8111cbcc 	andi	r4,r16,18223
8111cb80:	8111cd98 	cmpnei	r4,r16,18230
8111cb84:	8111cd98 	cmpnei	r4,r16,18230
8111cb88:	8111cd80 	call	88111cd8 <__reset+0x20f1cd8>
8111cb8c:	8111cbcc 	andi	r4,r16,18223
8111cb90:	8111cd98 	cmpnei	r4,r16,18230
8111cb94:	8111cd80 	call	88111cd8 <__reset+0x20f1cd8>
8111cb98:	8111cd98 	cmpnei	r4,r16,18230
8111cb9c:	8111cbcc 	andi	r4,r16,18223
8111cba0:	8111cda8 	cmpgeui	r4,r16,18230
8111cba4:	8111cda8 	cmpgeui	r4,r16,18230
8111cba8:	8111cda8 	cmpgeui	r4,r16,18230
8111cbac:	8111cfc4 	addi	r4,r16,18239
8111cbb0:	2404b03a 	or	r2,r4,r16
8111cbb4:	10006f1e 	bne	r2,zero,8111cd74 <__muldf3+0x300>
8111cbb8:	04c00204 	movi	r19,8
8111cbbc:	0021883a 	mov	r16,zero
8111cbc0:	0029883a 	mov	r20,zero
8111cbc4:	07000084 	movi	fp,2
8111cbc8:	003fcb06 	br	8111caf8 <__reset+0xfb0fcaf8>
8111cbcc:	502d883a 	mov	r22,r10
8111cbd0:	00800084 	movi	r2,2
8111cbd4:	28805726 	beq	r5,r2,8111cd34 <__muldf3+0x2c0>
8111cbd8:	008000c4 	movi	r2,3
8111cbdc:	28816626 	beq	r5,r2,8111d178 <__muldf3+0x704>
8111cbe0:	00800044 	movi	r2,1
8111cbe4:	2881411e 	bne	r5,r2,8111d0ec <__muldf3+0x678>
8111cbe8:	b02b883a 	mov	r21,r22
8111cbec:	0005883a 	mov	r2,zero
8111cbf0:	000b883a 	mov	r5,zero
8111cbf4:	0029883a 	mov	r20,zero
8111cbf8:	1004953a 	slli	r2,r2,20
8111cbfc:	a8c03fcc 	andi	r3,r21,255
8111cc00:	04400434 	movhi	r17,16
8111cc04:	8c7fffc4 	addi	r17,r17,-1
8111cc08:	180697fa 	slli	r3,r3,31
8111cc0c:	2c4a703a 	and	r5,r5,r17
8111cc10:	288ab03a 	or	r5,r5,r2
8111cc14:	28c6b03a 	or	r3,r5,r3
8111cc18:	a005883a 	mov	r2,r20
8111cc1c:	dfc00c17 	ldw	ra,48(sp)
8111cc20:	df000b17 	ldw	fp,44(sp)
8111cc24:	ddc00a17 	ldw	r23,40(sp)
8111cc28:	dd800917 	ldw	r22,36(sp)
8111cc2c:	dd400817 	ldw	r21,32(sp)
8111cc30:	dd000717 	ldw	r20,28(sp)
8111cc34:	dcc00617 	ldw	r19,24(sp)
8111cc38:	dc800517 	ldw	r18,20(sp)
8111cc3c:	dc400417 	ldw	r17,16(sp)
8111cc40:	dc000317 	ldw	r16,12(sp)
8111cc44:	dec00d04 	addi	sp,sp,52
8111cc48:	f800283a 	ret
8111cc4c:	2404b03a 	or	r2,r4,r16
8111cc50:	2027883a 	mov	r19,r4
8111cc54:	10004226 	beq	r2,zero,8111cd60 <__muldf3+0x2ec>
8111cc58:	8000fc26 	beq	r16,zero,8111d04c <__muldf3+0x5d8>
8111cc5c:	8009883a 	mov	r4,r16
8111cc60:	d9800215 	stw	r6,8(sp)
8111cc64:	d9c00015 	stw	r7,0(sp)
8111cc68:	da400115 	stw	r9,4(sp)
8111cc6c:	111d4540 	call	8111d454 <__clzsi2>
8111cc70:	d9800217 	ldw	r6,8(sp)
8111cc74:	d9c00017 	ldw	r7,0(sp)
8111cc78:	da400117 	ldw	r9,4(sp)
8111cc7c:	113ffd44 	addi	r4,r2,-11
8111cc80:	00c00704 	movi	r3,28
8111cc84:	1900ed16 	blt	r3,r4,8111d03c <__muldf3+0x5c8>
8111cc88:	00c00744 	movi	r3,29
8111cc8c:	147ffe04 	addi	r17,r2,-8
8111cc90:	1907c83a 	sub	r3,r3,r4
8111cc94:	8460983a 	sll	r16,r16,r17
8111cc98:	98c6d83a 	srl	r3,r19,r3
8111cc9c:	9c68983a 	sll	r20,r19,r17
8111cca0:	1c20b03a 	or	r16,r3,r16
8111cca4:	1080fcc4 	addi	r2,r2,1011
8111cca8:	00a5c83a 	sub	r18,zero,r2
8111ccac:	0027883a 	mov	r19,zero
8111ccb0:	0039883a 	mov	fp,zero
8111ccb4:	003f9006 	br	8111caf8 <__reset+0xfb0fcaf8>
8111ccb8:	3446b03a 	or	r3,r6,r17
8111ccbc:	1800261e 	bne	r3,zero,8111cd58 <__muldf3+0x2e4>
8111ccc0:	0023883a 	mov	r17,zero
8111ccc4:	0011883a 	mov	r8,zero
8111ccc8:	01400084 	movi	r5,2
8111cccc:	003f9c06 	br	8111cb40 <__reset+0xfb0fcb40>
8111ccd0:	3446b03a 	or	r3,r6,r17
8111ccd4:	18001c26 	beq	r3,zero,8111cd48 <__muldf3+0x2d4>
8111ccd8:	8800ce26 	beq	r17,zero,8111d014 <__muldf3+0x5a0>
8111ccdc:	8809883a 	mov	r4,r17
8111cce0:	d9800215 	stw	r6,8(sp)
8111cce4:	da400115 	stw	r9,4(sp)
8111cce8:	da800015 	stw	r10,0(sp)
8111ccec:	111d4540 	call	8111d454 <__clzsi2>
8111ccf0:	d9800217 	ldw	r6,8(sp)
8111ccf4:	da400117 	ldw	r9,4(sp)
8111ccf8:	da800017 	ldw	r10,0(sp)
8111ccfc:	113ffd44 	addi	r4,r2,-11
8111cd00:	00c00704 	movi	r3,28
8111cd04:	1900bf16 	blt	r3,r4,8111d004 <__muldf3+0x590>
8111cd08:	00c00744 	movi	r3,29
8111cd0c:	123ffe04 	addi	r8,r2,-8
8111cd10:	1907c83a 	sub	r3,r3,r4
8111cd14:	8a22983a 	sll	r17,r17,r8
8111cd18:	30c6d83a 	srl	r3,r6,r3
8111cd1c:	3210983a 	sll	r8,r6,r8
8111cd20:	1c62b03a 	or	r17,r3,r17
8111cd24:	1080fcc4 	addi	r2,r2,1011
8111cd28:	0085c83a 	sub	r2,zero,r2
8111cd2c:	000b883a 	mov	r5,zero
8111cd30:	003f8306 	br	8111cb40 <__reset+0xfb0fcb40>
8111cd34:	b02b883a 	mov	r21,r22
8111cd38:	0081ffc4 	movi	r2,2047
8111cd3c:	000b883a 	mov	r5,zero
8111cd40:	0029883a 	mov	r20,zero
8111cd44:	003fac06 	br	8111cbf8 <__reset+0xfb0fcbf8>
8111cd48:	0023883a 	mov	r17,zero
8111cd4c:	0011883a 	mov	r8,zero
8111cd50:	01400044 	movi	r5,1
8111cd54:	003f7a06 	br	8111cb40 <__reset+0xfb0fcb40>
8111cd58:	014000c4 	movi	r5,3
8111cd5c:	003f7806 	br	8111cb40 <__reset+0xfb0fcb40>
8111cd60:	04c00104 	movi	r19,4
8111cd64:	0021883a 	mov	r16,zero
8111cd68:	0029883a 	mov	r20,zero
8111cd6c:	07000044 	movi	fp,1
8111cd70:	003f6106 	br	8111caf8 <__reset+0xfb0fcaf8>
8111cd74:	04c00304 	movi	r19,12
8111cd78:	070000c4 	movi	fp,3
8111cd7c:	003f5e06 	br	8111caf8 <__reset+0xfb0fcaf8>
8111cd80:	01400434 	movhi	r5,16
8111cd84:	002b883a 	mov	r21,zero
8111cd88:	297fffc4 	addi	r5,r5,-1
8111cd8c:	053fffc4 	movi	r20,-1
8111cd90:	0081ffc4 	movi	r2,2047
8111cd94:	003f9806 	br	8111cbf8 <__reset+0xfb0fcbf8>
8111cd98:	8023883a 	mov	r17,r16
8111cd9c:	a011883a 	mov	r8,r20
8111cda0:	e00b883a 	mov	r5,fp
8111cda4:	003f8a06 	br	8111cbd0 <__reset+0xfb0fcbd0>
8111cda8:	8023883a 	mov	r17,r16
8111cdac:	a011883a 	mov	r8,r20
8111cdb0:	482d883a 	mov	r22,r9
8111cdb4:	e00b883a 	mov	r5,fp
8111cdb8:	003f8506 	br	8111cbd0 <__reset+0xfb0fcbd0>
8111cdbc:	a00ad43a 	srli	r5,r20,16
8111cdc0:	401ad43a 	srli	r13,r8,16
8111cdc4:	a53fffcc 	andi	r20,r20,65535
8111cdc8:	423fffcc 	andi	r8,r8,65535
8111cdcc:	4519383a 	mul	r12,r8,r20
8111cdd0:	4147383a 	mul	r3,r8,r5
8111cdd4:	6d09383a 	mul	r4,r13,r20
8111cdd8:	600cd43a 	srli	r6,r12,16
8111cddc:	2b5d383a 	mul	r14,r5,r13
8111cde0:	20c9883a 	add	r4,r4,r3
8111cde4:	310d883a 	add	r6,r6,r4
8111cde8:	30c0022e 	bgeu	r6,r3,8111cdf4 <__muldf3+0x380>
8111cdec:	00c00074 	movhi	r3,1
8111cdf0:	70dd883a 	add	r14,r14,r3
8111cdf4:	8826d43a 	srli	r19,r17,16
8111cdf8:	8bffffcc 	andi	r15,r17,65535
8111cdfc:	7d23383a 	mul	r17,r15,r20
8111ce00:	7949383a 	mul	r4,r15,r5
8111ce04:	9d29383a 	mul	r20,r19,r20
8111ce08:	8814d43a 	srli	r10,r17,16
8111ce0c:	3012943a 	slli	r9,r6,16
8111ce10:	a129883a 	add	r20,r20,r4
8111ce14:	633fffcc 	andi	r12,r12,65535
8111ce18:	5515883a 	add	r10,r10,r20
8111ce1c:	3006d43a 	srli	r3,r6,16
8111ce20:	4b13883a 	add	r9,r9,r12
8111ce24:	2ccb383a 	mul	r5,r5,r19
8111ce28:	5100022e 	bgeu	r10,r4,8111ce34 <__muldf3+0x3c0>
8111ce2c:	01000074 	movhi	r4,1
8111ce30:	290b883a 	add	r5,r5,r4
8111ce34:	802ad43a 	srli	r21,r16,16
8111ce38:	843fffcc 	andi	r16,r16,65535
8111ce3c:	440d383a 	mul	r6,r8,r16
8111ce40:	4565383a 	mul	r18,r8,r21
8111ce44:	8349383a 	mul	r4,r16,r13
8111ce48:	500e943a 	slli	r7,r10,16
8111ce4c:	3010d43a 	srli	r8,r6,16
8111ce50:	5028d43a 	srli	r20,r10,16
8111ce54:	2489883a 	add	r4,r4,r18
8111ce58:	8abfffcc 	andi	r10,r17,65535
8111ce5c:	3a95883a 	add	r10,r7,r10
8111ce60:	4119883a 	add	r12,r8,r4
8111ce64:	a169883a 	add	r20,r20,r5
8111ce68:	1a87883a 	add	r3,r3,r10
8111ce6c:	6d5b383a 	mul	r13,r13,r21
8111ce70:	6480022e 	bgeu	r12,r18,8111ce7c <__muldf3+0x408>
8111ce74:	01000074 	movhi	r4,1
8111ce78:	691b883a 	add	r13,r13,r4
8111ce7c:	7c25383a 	mul	r18,r15,r16
8111ce80:	7d4b383a 	mul	r5,r15,r21
8111ce84:	84cf383a 	mul	r7,r16,r19
8111ce88:	901ed43a 	srli	r15,r18,16
8111ce8c:	6008d43a 	srli	r4,r12,16
8111ce90:	6010943a 	slli	r8,r12,16
8111ce94:	394f883a 	add	r7,r7,r5
8111ce98:	333fffcc 	andi	r12,r6,65535
8111ce9c:	79df883a 	add	r15,r15,r7
8111cea0:	235b883a 	add	r13,r4,r13
8111cea4:	9d63383a 	mul	r17,r19,r21
8111cea8:	4309883a 	add	r4,r8,r12
8111ceac:	7940022e 	bgeu	r15,r5,8111ceb8 <__muldf3+0x444>
8111ceb0:	01400074 	movhi	r5,1
8111ceb4:	8963883a 	add	r17,r17,r5
8111ceb8:	780a943a 	slli	r5,r15,16
8111cebc:	91bfffcc 	andi	r6,r18,65535
8111cec0:	70c7883a 	add	r3,r14,r3
8111cec4:	298d883a 	add	r6,r5,r6
8111cec8:	1a8f803a 	cmpltu	r7,r3,r10
8111cecc:	350b883a 	add	r5,r6,r20
8111ced0:	20c7883a 	add	r3,r4,r3
8111ced4:	3955883a 	add	r10,r7,r5
8111ced8:	1909803a 	cmpltu	r4,r3,r4
8111cedc:	6a91883a 	add	r8,r13,r10
8111cee0:	780cd43a 	srli	r6,r15,16
8111cee4:	2219883a 	add	r12,r4,r8
8111cee8:	2d0b803a 	cmpltu	r5,r5,r20
8111ceec:	51cf803a 	cmpltu	r7,r10,r7
8111cef0:	29ceb03a 	or	r7,r5,r7
8111cef4:	4351803a 	cmpltu	r8,r8,r13
8111cef8:	610b803a 	cmpltu	r5,r12,r4
8111cefc:	4148b03a 	or	r4,r8,r5
8111cf00:	398f883a 	add	r7,r7,r6
8111cf04:	3909883a 	add	r4,r7,r4
8111cf08:	1810927a 	slli	r8,r3,9
8111cf0c:	2449883a 	add	r4,r4,r17
8111cf10:	2008927a 	slli	r4,r4,9
8111cf14:	6022d5fa 	srli	r17,r12,23
8111cf18:	1806d5fa 	srli	r3,r3,23
8111cf1c:	4252b03a 	or	r9,r8,r9
8111cf20:	600a927a 	slli	r5,r12,9
8111cf24:	4810c03a 	cmpne	r8,r9,zero
8111cf28:	2462b03a 	or	r17,r4,r17
8111cf2c:	40c6b03a 	or	r3,r8,r3
8111cf30:	8900402c 	andhi	r4,r17,256
8111cf34:	1950b03a 	or	r8,r3,r5
8111cf38:	20000726 	beq	r4,zero,8111cf58 <__muldf3+0x4e4>
8111cf3c:	4006d07a 	srli	r3,r8,1
8111cf40:	880497fa 	slli	r2,r17,31
8111cf44:	4200004c 	andi	r8,r8,1
8111cf48:	8822d07a 	srli	r17,r17,1
8111cf4c:	1a10b03a 	or	r8,r3,r8
8111cf50:	1210b03a 	or	r8,r2,r8
8111cf54:	5805883a 	mov	r2,r11
8111cf58:	1140ffc4 	addi	r5,r2,1023
8111cf5c:	0140440e 	bge	zero,r5,8111d070 <__muldf3+0x5fc>
8111cf60:	40c001cc 	andi	r3,r8,7
8111cf64:	18000726 	beq	r3,zero,8111cf84 <__muldf3+0x510>
8111cf68:	40c003cc 	andi	r3,r8,15
8111cf6c:	01000104 	movi	r4,4
8111cf70:	19000426 	beq	r3,r4,8111cf84 <__muldf3+0x510>
8111cf74:	4107883a 	add	r3,r8,r4
8111cf78:	1a11803a 	cmpltu	r8,r3,r8
8111cf7c:	8a23883a 	add	r17,r17,r8
8111cf80:	1811883a 	mov	r8,r3
8111cf84:	88c0402c 	andhi	r3,r17,256
8111cf88:	18000426 	beq	r3,zero,8111cf9c <__muldf3+0x528>
8111cf8c:	11410004 	addi	r5,r2,1024
8111cf90:	00bfc034 	movhi	r2,65280
8111cf94:	10bfffc4 	addi	r2,r2,-1
8111cf98:	88a2703a 	and	r17,r17,r2
8111cf9c:	0081ff84 	movi	r2,2046
8111cfa0:	117f6416 	blt	r2,r5,8111cd34 <__reset+0xfb0fcd34>
8111cfa4:	8828977a 	slli	r20,r17,29
8111cfa8:	4010d0fa 	srli	r8,r8,3
8111cfac:	8822927a 	slli	r17,r17,9
8111cfb0:	2881ffcc 	andi	r2,r5,2047
8111cfb4:	a228b03a 	or	r20,r20,r8
8111cfb8:	880ad33a 	srli	r5,r17,12
8111cfbc:	b02b883a 	mov	r21,r22
8111cfc0:	003f0d06 	br	8111cbf8 <__reset+0xfb0fcbf8>
8111cfc4:	8080022c 	andhi	r2,r16,8
8111cfc8:	10000926 	beq	r2,zero,8111cff0 <__muldf3+0x57c>
8111cfcc:	8880022c 	andhi	r2,r17,8
8111cfd0:	1000071e 	bne	r2,zero,8111cff0 <__muldf3+0x57c>
8111cfd4:	00800434 	movhi	r2,16
8111cfd8:	89400234 	orhi	r5,r17,8
8111cfdc:	10bfffc4 	addi	r2,r2,-1
8111cfe0:	b82b883a 	mov	r21,r23
8111cfe4:	288a703a 	and	r5,r5,r2
8111cfe8:	4029883a 	mov	r20,r8
8111cfec:	003f6806 	br	8111cd90 <__reset+0xfb0fcd90>
8111cff0:	00800434 	movhi	r2,16
8111cff4:	81400234 	orhi	r5,r16,8
8111cff8:	10bfffc4 	addi	r2,r2,-1
8111cffc:	288a703a 	and	r5,r5,r2
8111d000:	003f6306 	br	8111cd90 <__reset+0xfb0fcd90>
8111d004:	147ff604 	addi	r17,r2,-40
8111d008:	3462983a 	sll	r17,r6,r17
8111d00c:	0011883a 	mov	r8,zero
8111d010:	003f4406 	br	8111cd24 <__reset+0xfb0fcd24>
8111d014:	3009883a 	mov	r4,r6
8111d018:	d9800215 	stw	r6,8(sp)
8111d01c:	da400115 	stw	r9,4(sp)
8111d020:	da800015 	stw	r10,0(sp)
8111d024:	111d4540 	call	8111d454 <__clzsi2>
8111d028:	10800804 	addi	r2,r2,32
8111d02c:	da800017 	ldw	r10,0(sp)
8111d030:	da400117 	ldw	r9,4(sp)
8111d034:	d9800217 	ldw	r6,8(sp)
8111d038:	003f3006 	br	8111ccfc <__reset+0xfb0fccfc>
8111d03c:	143ff604 	addi	r16,r2,-40
8111d040:	9c20983a 	sll	r16,r19,r16
8111d044:	0029883a 	mov	r20,zero
8111d048:	003f1606 	br	8111cca4 <__reset+0xfb0fcca4>
8111d04c:	d9800215 	stw	r6,8(sp)
8111d050:	d9c00015 	stw	r7,0(sp)
8111d054:	da400115 	stw	r9,4(sp)
8111d058:	111d4540 	call	8111d454 <__clzsi2>
8111d05c:	10800804 	addi	r2,r2,32
8111d060:	da400117 	ldw	r9,4(sp)
8111d064:	d9c00017 	ldw	r7,0(sp)
8111d068:	d9800217 	ldw	r6,8(sp)
8111d06c:	003f0306 	br	8111cc7c <__reset+0xfb0fcc7c>
8111d070:	00c00044 	movi	r3,1
8111d074:	1947c83a 	sub	r3,r3,r5
8111d078:	00800e04 	movi	r2,56
8111d07c:	10feda16 	blt	r2,r3,8111cbe8 <__reset+0xfb0fcbe8>
8111d080:	008007c4 	movi	r2,31
8111d084:	10c01b16 	blt	r2,r3,8111d0f4 <__muldf3+0x680>
8111d088:	00800804 	movi	r2,32
8111d08c:	10c5c83a 	sub	r2,r2,r3
8111d090:	888a983a 	sll	r5,r17,r2
8111d094:	40c8d83a 	srl	r4,r8,r3
8111d098:	4084983a 	sll	r2,r8,r2
8111d09c:	88e2d83a 	srl	r17,r17,r3
8111d0a0:	2906b03a 	or	r3,r5,r4
8111d0a4:	1004c03a 	cmpne	r2,r2,zero
8111d0a8:	1886b03a 	or	r3,r3,r2
8111d0ac:	188001cc 	andi	r2,r3,7
8111d0b0:	10000726 	beq	r2,zero,8111d0d0 <__muldf3+0x65c>
8111d0b4:	188003cc 	andi	r2,r3,15
8111d0b8:	01000104 	movi	r4,4
8111d0bc:	11000426 	beq	r2,r4,8111d0d0 <__muldf3+0x65c>
8111d0c0:	1805883a 	mov	r2,r3
8111d0c4:	10c00104 	addi	r3,r2,4
8111d0c8:	1885803a 	cmpltu	r2,r3,r2
8111d0cc:	88a3883a 	add	r17,r17,r2
8111d0d0:	8880202c 	andhi	r2,r17,128
8111d0d4:	10001c26 	beq	r2,zero,8111d148 <__muldf3+0x6d4>
8111d0d8:	b02b883a 	mov	r21,r22
8111d0dc:	00800044 	movi	r2,1
8111d0e0:	000b883a 	mov	r5,zero
8111d0e4:	0029883a 	mov	r20,zero
8111d0e8:	003ec306 	br	8111cbf8 <__reset+0xfb0fcbf8>
8111d0ec:	5805883a 	mov	r2,r11
8111d0f0:	003f9906 	br	8111cf58 <__reset+0xfb0fcf58>
8111d0f4:	00bff844 	movi	r2,-31
8111d0f8:	1145c83a 	sub	r2,r2,r5
8111d0fc:	8888d83a 	srl	r4,r17,r2
8111d100:	00800804 	movi	r2,32
8111d104:	18801a26 	beq	r3,r2,8111d170 <__muldf3+0x6fc>
8111d108:	00801004 	movi	r2,64
8111d10c:	10c5c83a 	sub	r2,r2,r3
8111d110:	8884983a 	sll	r2,r17,r2
8111d114:	1204b03a 	or	r2,r2,r8
8111d118:	1004c03a 	cmpne	r2,r2,zero
8111d11c:	2084b03a 	or	r2,r4,r2
8111d120:	144001cc 	andi	r17,r2,7
8111d124:	88000d1e 	bne	r17,zero,8111d15c <__muldf3+0x6e8>
8111d128:	000b883a 	mov	r5,zero
8111d12c:	1028d0fa 	srli	r20,r2,3
8111d130:	b02b883a 	mov	r21,r22
8111d134:	0005883a 	mov	r2,zero
8111d138:	a468b03a 	or	r20,r20,r17
8111d13c:	003eae06 	br	8111cbf8 <__reset+0xfb0fcbf8>
8111d140:	1007883a 	mov	r3,r2
8111d144:	0023883a 	mov	r17,zero
8111d148:	880a927a 	slli	r5,r17,9
8111d14c:	1805883a 	mov	r2,r3
8111d150:	8822977a 	slli	r17,r17,29
8111d154:	280ad33a 	srli	r5,r5,12
8111d158:	003ff406 	br	8111d12c <__reset+0xfb0fd12c>
8111d15c:	10c003cc 	andi	r3,r2,15
8111d160:	01000104 	movi	r4,4
8111d164:	193ff626 	beq	r3,r4,8111d140 <__reset+0xfb0fd140>
8111d168:	0023883a 	mov	r17,zero
8111d16c:	003fd506 	br	8111d0c4 <__reset+0xfb0fd0c4>
8111d170:	0005883a 	mov	r2,zero
8111d174:	003fe706 	br	8111d114 <__reset+0xfb0fd114>
8111d178:	00800434 	movhi	r2,16
8111d17c:	89400234 	orhi	r5,r17,8
8111d180:	10bfffc4 	addi	r2,r2,-1
8111d184:	b02b883a 	mov	r21,r22
8111d188:	288a703a 	and	r5,r5,r2
8111d18c:	4029883a 	mov	r20,r8
8111d190:	003eff06 	br	8111cd90 <__reset+0xfb0fcd90>

8111d194 <__extendsfdf2>:
8111d194:	200ad5fa 	srli	r5,r4,23
8111d198:	defffd04 	addi	sp,sp,-12
8111d19c:	de00012e 	bgeu	sp,et,8111d1a4 <__extendsfdf2+0x10>
8111d1a0:	003b68fa 	trap	3
8111d1a4:	29403fcc 	andi	r5,r5,255
8111d1a8:	dc400115 	stw	r17,4(sp)
8111d1ac:	29800044 	addi	r6,r5,1
8111d1b0:	04402034 	movhi	r17,128
8111d1b4:	dc000015 	stw	r16,0(sp)
8111d1b8:	8c7fffc4 	addi	r17,r17,-1
8111d1bc:	dfc00215 	stw	ra,8(sp)
8111d1c0:	31803fcc 	andi	r6,r6,255
8111d1c4:	00800044 	movi	r2,1
8111d1c8:	8922703a 	and	r17,r17,r4
8111d1cc:	2020d7fa 	srli	r16,r4,31
8111d1d0:	1180110e 	bge	r2,r6,8111d218 <__extendsfdf2+0x84>
8111d1d4:	880cd0fa 	srli	r6,r17,3
8111d1d8:	8822977a 	slli	r17,r17,29
8111d1dc:	2940e004 	addi	r5,r5,896
8111d1e0:	2941ffcc 	andi	r5,r5,2047
8111d1e4:	2804953a 	slli	r2,r5,20
8111d1e8:	01400434 	movhi	r5,16
8111d1ec:	800697fa 	slli	r3,r16,31
8111d1f0:	297fffc4 	addi	r5,r5,-1
8111d1f4:	314a703a 	and	r5,r6,r5
8111d1f8:	288ab03a 	or	r5,r5,r2
8111d1fc:	28c6b03a 	or	r3,r5,r3
8111d200:	8805883a 	mov	r2,r17
8111d204:	dfc00217 	ldw	ra,8(sp)
8111d208:	dc400117 	ldw	r17,4(sp)
8111d20c:	dc000017 	ldw	r16,0(sp)
8111d210:	dec00304 	addi	sp,sp,12
8111d214:	f800283a 	ret
8111d218:	2800111e 	bne	r5,zero,8111d260 <__extendsfdf2+0xcc>
8111d21c:	88001c26 	beq	r17,zero,8111d290 <__extendsfdf2+0xfc>
8111d220:	8809883a 	mov	r4,r17
8111d224:	111d4540 	call	8111d454 <__clzsi2>
8111d228:	00c00284 	movi	r3,10
8111d22c:	18801b16 	blt	r3,r2,8111d29c <__extendsfdf2+0x108>
8111d230:	018002c4 	movi	r6,11
8111d234:	308dc83a 	sub	r6,r6,r2
8111d238:	11000544 	addi	r4,r2,21
8111d23c:	8986d83a 	srl	r3,r17,r6
8111d240:	8922983a 	sll	r17,r17,r4
8111d244:	0180e244 	movi	r6,905
8111d248:	01400434 	movhi	r5,16
8111d24c:	3085c83a 	sub	r2,r6,r2
8111d250:	297fffc4 	addi	r5,r5,-1
8111d254:	194c703a 	and	r6,r3,r5
8111d258:	1141ffcc 	andi	r5,r2,2047
8111d25c:	003fe006 	br	8111d1e0 <__reset+0xfb0fd1e0>
8111d260:	88000826 	beq	r17,zero,8111d284 <__extendsfdf2+0xf0>
8111d264:	880cd0fa 	srli	r6,r17,3
8111d268:	00800434 	movhi	r2,16
8111d26c:	10bfffc4 	addi	r2,r2,-1
8111d270:	31800234 	orhi	r6,r6,8
8111d274:	8822977a 	slli	r17,r17,29
8111d278:	308c703a 	and	r6,r6,r2
8111d27c:	0141ffc4 	movi	r5,2047
8111d280:	003fd706 	br	8111d1e0 <__reset+0xfb0fd1e0>
8111d284:	0141ffc4 	movi	r5,2047
8111d288:	000d883a 	mov	r6,zero
8111d28c:	003fd406 	br	8111d1e0 <__reset+0xfb0fd1e0>
8111d290:	000b883a 	mov	r5,zero
8111d294:	000d883a 	mov	r6,zero
8111d298:	003fd106 	br	8111d1e0 <__reset+0xfb0fd1e0>
8111d29c:	11bffd44 	addi	r6,r2,-11
8111d2a0:	8986983a 	sll	r3,r17,r6
8111d2a4:	0023883a 	mov	r17,zero
8111d2a8:	003fe606 	br	8111d244 <__reset+0xfb0fd244>

8111d2ac <__truncdfsf2>:
8111d2ac:	2810d53a 	srli	r8,r5,20
8111d2b0:	01c00434 	movhi	r7,16
8111d2b4:	39ffffc4 	addi	r7,r7,-1
8111d2b8:	29ce703a 	and	r7,r5,r7
8111d2bc:	4201ffcc 	andi	r8,r8,2047
8111d2c0:	380e90fa 	slli	r7,r7,3
8111d2c4:	200cd77a 	srli	r6,r4,29
8111d2c8:	42400044 	addi	r9,r8,1
8111d2cc:	4a41ffcc 	andi	r9,r9,2047
8111d2d0:	00c00044 	movi	r3,1
8111d2d4:	280ad7fa 	srli	r5,r5,31
8111d2d8:	31ceb03a 	or	r7,r6,r7
8111d2dc:	200490fa 	slli	r2,r4,3
8111d2e0:	1a40230e 	bge	r3,r9,8111d370 <__truncdfsf2+0xc4>
8111d2e4:	40ff2004 	addi	r3,r8,-896
8111d2e8:	01803f84 	movi	r6,254
8111d2ec:	30c01516 	blt	r6,r3,8111d344 <__truncdfsf2+0x98>
8111d2f0:	00c0380e 	bge	zero,r3,8111d3d4 <__truncdfsf2+0x128>
8111d2f4:	200c91ba 	slli	r6,r4,6
8111d2f8:	380e90fa 	slli	r7,r7,3
8111d2fc:	1004d77a 	srli	r2,r2,29
8111d300:	300cc03a 	cmpne	r6,r6,zero
8111d304:	31ccb03a 	or	r6,r6,r7
8111d308:	308cb03a 	or	r6,r6,r2
8111d30c:	308001cc 	andi	r2,r6,7
8111d310:	10000426 	beq	r2,zero,8111d324 <__truncdfsf2+0x78>
8111d314:	308003cc 	andi	r2,r6,15
8111d318:	01000104 	movi	r4,4
8111d31c:	11000126 	beq	r2,r4,8111d324 <__truncdfsf2+0x78>
8111d320:	31800104 	addi	r6,r6,4
8111d324:	3081002c 	andhi	r2,r6,1024
8111d328:	10001626 	beq	r2,zero,8111d384 <__truncdfsf2+0xd8>
8111d32c:	18c00044 	addi	r3,r3,1
8111d330:	00803fc4 	movi	r2,255
8111d334:	18800326 	beq	r3,r2,8111d344 <__truncdfsf2+0x98>
8111d338:	300c91ba 	slli	r6,r6,6
8111d33c:	300cd27a 	srli	r6,r6,9
8111d340:	00000206 	br	8111d34c <__truncdfsf2+0xa0>
8111d344:	00ffffc4 	movi	r3,-1
8111d348:	000d883a 	mov	r6,zero
8111d34c:	18c03fcc 	andi	r3,r3,255
8111d350:	180895fa 	slli	r4,r3,23
8111d354:	00c02034 	movhi	r3,128
8111d358:	280a97fa 	slli	r5,r5,31
8111d35c:	18ffffc4 	addi	r3,r3,-1
8111d360:	30c6703a 	and	r3,r6,r3
8111d364:	1906b03a 	or	r3,r3,r4
8111d368:	1944b03a 	or	r2,r3,r5
8111d36c:	f800283a 	ret
8111d370:	40000b1e 	bne	r8,zero,8111d3a0 <__truncdfsf2+0xf4>
8111d374:	388cb03a 	or	r6,r7,r2
8111d378:	0007883a 	mov	r3,zero
8111d37c:	30000426 	beq	r6,zero,8111d390 <__truncdfsf2+0xe4>
8111d380:	01800144 	movi	r6,5
8111d384:	00803fc4 	movi	r2,255
8111d388:	300cd0fa 	srli	r6,r6,3
8111d38c:	18800a26 	beq	r3,r2,8111d3b8 <__truncdfsf2+0x10c>
8111d390:	00802034 	movhi	r2,128
8111d394:	10bfffc4 	addi	r2,r2,-1
8111d398:	308c703a 	and	r6,r6,r2
8111d39c:	003feb06 	br	8111d34c <__reset+0xfb0fd34c>
8111d3a0:	3888b03a 	or	r4,r7,r2
8111d3a4:	203fe726 	beq	r4,zero,8111d344 <__reset+0xfb0fd344>
8111d3a8:	380c90fa 	slli	r6,r7,3
8111d3ac:	00c03fc4 	movi	r3,255
8111d3b0:	31808034 	orhi	r6,r6,512
8111d3b4:	003fd506 	br	8111d30c <__reset+0xfb0fd30c>
8111d3b8:	303fe226 	beq	r6,zero,8111d344 <__reset+0xfb0fd344>
8111d3bc:	00802034 	movhi	r2,128
8111d3c0:	31801034 	orhi	r6,r6,64
8111d3c4:	10bfffc4 	addi	r2,r2,-1
8111d3c8:	00ffffc4 	movi	r3,-1
8111d3cc:	308c703a 	and	r6,r6,r2
8111d3d0:	003fde06 	br	8111d34c <__reset+0xfb0fd34c>
8111d3d4:	013ffa44 	movi	r4,-23
8111d3d8:	19000e16 	blt	r3,r4,8111d414 <__truncdfsf2+0x168>
8111d3dc:	01000784 	movi	r4,30
8111d3e0:	20c9c83a 	sub	r4,r4,r3
8111d3e4:	018007c4 	movi	r6,31
8111d3e8:	39c02034 	orhi	r7,r7,128
8111d3ec:	31000b16 	blt	r6,r4,8111d41c <__truncdfsf2+0x170>
8111d3f0:	423f2084 	addi	r8,r8,-894
8111d3f4:	120c983a 	sll	r6,r2,r8
8111d3f8:	3a0e983a 	sll	r7,r7,r8
8111d3fc:	1104d83a 	srl	r2,r2,r4
8111d400:	300cc03a 	cmpne	r6,r6,zero
8111d404:	31ceb03a 	or	r7,r6,r7
8111d408:	388cb03a 	or	r6,r7,r2
8111d40c:	0007883a 	mov	r3,zero
8111d410:	003fbe06 	br	8111d30c <__reset+0xfb0fd30c>
8111d414:	0007883a 	mov	r3,zero
8111d418:	003fd906 	br	8111d380 <__reset+0xfb0fd380>
8111d41c:	01bfff84 	movi	r6,-2
8111d420:	30cdc83a 	sub	r6,r6,r3
8111d424:	00c00804 	movi	r3,32
8111d428:	398cd83a 	srl	r6,r7,r6
8111d42c:	20c00726 	beq	r4,r3,8111d44c <__truncdfsf2+0x1a0>
8111d430:	423f2884 	addi	r8,r8,-862
8111d434:	3a0e983a 	sll	r7,r7,r8
8111d438:	3884b03a 	or	r2,r7,r2
8111d43c:	1004c03a 	cmpne	r2,r2,zero
8111d440:	118cb03a 	or	r6,r2,r6
8111d444:	0007883a 	mov	r3,zero
8111d448:	003fb006 	br	8111d30c <__reset+0xfb0fd30c>
8111d44c:	000f883a 	mov	r7,zero
8111d450:	003ff906 	br	8111d438 <__reset+0xfb0fd438>

8111d454 <__clzsi2>:
8111d454:	00bfffd4 	movui	r2,65535
8111d458:	11000536 	bltu	r2,r4,8111d470 <__clzsi2+0x1c>
8111d45c:	00803fc4 	movi	r2,255
8111d460:	11000f36 	bltu	r2,r4,8111d4a0 <__clzsi2+0x4c>
8111d464:	00800804 	movi	r2,32
8111d468:	0007883a 	mov	r3,zero
8111d46c:	00000506 	br	8111d484 <__clzsi2+0x30>
8111d470:	00804034 	movhi	r2,256
8111d474:	10bfffc4 	addi	r2,r2,-1
8111d478:	11000c2e 	bgeu	r2,r4,8111d4ac <__clzsi2+0x58>
8111d47c:	00800204 	movi	r2,8
8111d480:	00c00604 	movi	r3,24
8111d484:	20c8d83a 	srl	r4,r4,r3
8111d488:	00e04574 	movhi	r3,33045
8111d48c:	18f2a804 	addi	r3,r3,-13664
8111d490:	1909883a 	add	r4,r3,r4
8111d494:	20c00003 	ldbu	r3,0(r4)
8111d498:	10c5c83a 	sub	r2,r2,r3
8111d49c:	f800283a 	ret
8111d4a0:	00800604 	movi	r2,24
8111d4a4:	00c00204 	movi	r3,8
8111d4a8:	003ff606 	br	8111d484 <__reset+0xfb0fd484>
8111d4ac:	00800404 	movi	r2,16
8111d4b0:	1007883a 	mov	r3,r2
8111d4b4:	003ff306 	br	8111d484 <__reset+0xfb0fd484>

8111d4b8 <atoi>:
8111d4b8:	01800284 	movi	r6,10
8111d4bc:	000b883a 	mov	r5,zero
8111d4c0:	111f4d41 	jmpi	8111f4d4 <strtol>

8111d4c4 <_atoi_r>:
8111d4c4:	01c00284 	movi	r7,10
8111d4c8:	000d883a 	mov	r6,zero
8111d4cc:	111f2941 	jmpi	8111f294 <_strtol_r>

8111d4d0 <_fopen_r>:
8111d4d0:	defffa04 	addi	sp,sp,-24
8111d4d4:	3005883a 	mov	r2,r6
8111d4d8:	de00012e 	bgeu	sp,et,8111d4e0 <_fopen_r+0x10>
8111d4dc:	003b68fa 	trap	3
8111d4e0:	d80d883a 	mov	r6,sp
8111d4e4:	dcc00415 	stw	r19,16(sp)
8111d4e8:	2827883a 	mov	r19,r5
8111d4ec:	100b883a 	mov	r5,r2
8111d4f0:	dc800315 	stw	r18,12(sp)
8111d4f4:	dfc00515 	stw	ra,20(sp)
8111d4f8:	dc400215 	stw	r17,8(sp)
8111d4fc:	dc000115 	stw	r16,4(sp)
8111d500:	2025883a 	mov	r18,r4
8111d504:	11274dc0 	call	811274dc <__sflags>
8111d508:	10002726 	beq	r2,zero,8111d5a8 <_fopen_r+0xd8>
8111d50c:	9009883a 	mov	r4,r18
8111d510:	1023883a 	mov	r17,r2
8111d514:	11273540 	call	81127354 <__sfp>
8111d518:	1021883a 	mov	r16,r2
8111d51c:	10002226 	beq	r2,zero,8111d5a8 <_fopen_r+0xd8>
8111d520:	d9800017 	ldw	r6,0(sp)
8111d524:	01c06d84 	movi	r7,438
8111d528:	980b883a 	mov	r5,r19
8111d52c:	9009883a 	mov	r4,r18
8111d530:	111e93c0 	call	8111e93c <_open_r>
8111d534:	10001916 	blt	r2,zero,8111d59c <_fopen_r+0xcc>
8111d538:	8080038d 	sth	r2,14(r16)
8111d53c:	00a044b4 	movhi	r2,33042
8111d540:	10bc0604 	addi	r2,r2,-4072
8111d544:	80800815 	stw	r2,32(r16)
8111d548:	00a044b4 	movhi	r2,33042
8111d54c:	10bc1f04 	addi	r2,r2,-3972
8111d550:	80800915 	stw	r2,36(r16)
8111d554:	00a044b4 	movhi	r2,33042
8111d558:	10bc4004 	addi	r2,r2,-3840
8111d55c:	80800a15 	stw	r2,40(r16)
8111d560:	00a044b4 	movhi	r2,33042
8111d564:	10bc5904 	addi	r2,r2,-3740
8111d568:	8440030d 	sth	r17,12(r16)
8111d56c:	84000715 	stw	r16,28(r16)
8111d570:	80800b15 	stw	r2,44(r16)
8111d574:	8c40400c 	andi	r17,r17,256
8111d578:	88000d1e 	bne	r17,zero,8111d5b0 <_fopen_r+0xe0>
8111d57c:	8005883a 	mov	r2,r16
8111d580:	dfc00517 	ldw	ra,20(sp)
8111d584:	dcc00417 	ldw	r19,16(sp)
8111d588:	dc800317 	ldw	r18,12(sp)
8111d58c:	dc400217 	ldw	r17,8(sp)
8111d590:	dc000117 	ldw	r16,4(sp)
8111d594:	dec00604 	addi	sp,sp,24
8111d598:	f800283a 	ret
8111d59c:	112749c0 	call	8112749c <__sfp_lock_acquire>
8111d5a0:	8000030d 	sth	zero,12(r16)
8111d5a4:	11274a00 	call	811274a0 <__sfp_lock_release>
8111d5a8:	0005883a 	mov	r2,zero
8111d5ac:	003ff406 	br	8111d580 <__reset+0xfb0fd580>
8111d5b0:	01c00084 	movi	r7,2
8111d5b4:	000d883a 	mov	r6,zero
8111d5b8:	800b883a 	mov	r5,r16
8111d5bc:	9009883a 	mov	r4,r18
8111d5c0:	111d6f00 	call	8111d6f0 <_fseek_r>
8111d5c4:	8005883a 	mov	r2,r16
8111d5c8:	003fed06 	br	8111d580 <__reset+0xfb0fd580>

8111d5cc <fopen>:
8111d5cc:	00a04574 	movhi	r2,33045
8111d5d0:	10bd6304 	addi	r2,r2,-2676
8111d5d4:	280d883a 	mov	r6,r5
8111d5d8:	200b883a 	mov	r5,r4
8111d5dc:	11000017 	ldw	r4,0(r2)
8111d5e0:	111d4d01 	jmpi	8111d4d0 <_fopen_r>

8111d5e4 <_fprintf_r>:
8111d5e4:	defffe04 	addi	sp,sp,-8
8111d5e8:	2809883a 	mov	r4,r5
8111d5ec:	300b883a 	mov	r5,r6
8111d5f0:	de00012e 	bgeu	sp,et,8111d5f8 <_fprintf_r+0x14>
8111d5f4:	003b68fa 	trap	3
8111d5f8:	dfc00015 	stw	ra,0(sp)
8111d5fc:	d9c00115 	stw	r7,4(sp)
8111d600:	d9800104 	addi	r6,sp,4
8111d604:	11238d00 	call	811238d0 <__vfprintf_internal>
8111d608:	dfc00017 	ldw	ra,0(sp)
8111d60c:	dec00204 	addi	sp,sp,8
8111d610:	f800283a 	ret

8111d614 <fprintf>:
8111d614:	defffd04 	addi	sp,sp,-12
8111d618:	de00012e 	bgeu	sp,et,8111d620 <fprintf+0xc>
8111d61c:	003b68fa 	trap	3
8111d620:	dfc00015 	stw	ra,0(sp)
8111d624:	d9800115 	stw	r6,4(sp)
8111d628:	d9c00215 	stw	r7,8(sp)
8111d62c:	d9800104 	addi	r6,sp,4
8111d630:	11238d00 	call	811238d0 <__vfprintf_internal>
8111d634:	dfc00017 	ldw	ra,0(sp)
8111d638:	dec00304 	addi	sp,sp,12
8111d63c:	f800283a 	ret

8111d640 <_fputc_r>:
8111d640:	defffc04 	addi	sp,sp,-16
8111d644:	de00012e 	bgeu	sp,et,8111d64c <_fputc_r+0xc>
8111d648:	003b68fa 	trap	3
8111d64c:	dc000215 	stw	r16,8(sp)
8111d650:	dfc00315 	stw	ra,12(sp)
8111d654:	2021883a 	mov	r16,r4
8111d658:	20000726 	beq	r4,zero,8111d678 <_fputc_r+0x38>
8111d65c:	20800e17 	ldw	r2,56(r4)
8111d660:	1000051e 	bne	r2,zero,8111d678 <_fputc_r+0x38>
8111d664:	d9400015 	stw	r5,0(sp)
8111d668:	d9800115 	stw	r6,4(sp)
8111d66c:	112748c0 	call	8112748c <__sinit>
8111d670:	d9800117 	ldw	r6,4(sp)
8111d674:	d9400017 	ldw	r5,0(sp)
8111d678:	8009883a 	mov	r4,r16
8111d67c:	dfc00317 	ldw	ra,12(sp)
8111d680:	dc000217 	ldw	r16,8(sp)
8111d684:	dec00404 	addi	sp,sp,16
8111d688:	111ea201 	jmpi	8111ea20 <_putc_r>

8111d68c <fputc>:
8111d68c:	00a04574 	movhi	r2,33045
8111d690:	defffc04 	addi	sp,sp,-16
8111d694:	10bd6304 	addi	r2,r2,-2676
8111d698:	de00012e 	bgeu	sp,et,8111d6a0 <fputc+0x14>
8111d69c:	003b68fa 	trap	3
8111d6a0:	dc000115 	stw	r16,4(sp)
8111d6a4:	14000017 	ldw	r16,0(r2)
8111d6a8:	dc400215 	stw	r17,8(sp)
8111d6ac:	dfc00315 	stw	ra,12(sp)
8111d6b0:	2023883a 	mov	r17,r4
8111d6b4:	80000626 	beq	r16,zero,8111d6d0 <fputc+0x44>
8111d6b8:	80800e17 	ldw	r2,56(r16)
8111d6bc:	1000041e 	bne	r2,zero,8111d6d0 <fputc+0x44>
8111d6c0:	8009883a 	mov	r4,r16
8111d6c4:	d9400015 	stw	r5,0(sp)
8111d6c8:	112748c0 	call	8112748c <__sinit>
8111d6cc:	d9400017 	ldw	r5,0(sp)
8111d6d0:	280d883a 	mov	r6,r5
8111d6d4:	8009883a 	mov	r4,r16
8111d6d8:	880b883a 	mov	r5,r17
8111d6dc:	dfc00317 	ldw	ra,12(sp)
8111d6e0:	dc400217 	ldw	r17,8(sp)
8111d6e4:	dc000117 	ldw	r16,4(sp)
8111d6e8:	dec00404 	addi	sp,sp,16
8111d6ec:	111ea201 	jmpi	8111ea20 <_putc_r>

8111d6f0 <_fseek_r>:
8111d6f0:	111d7101 	jmpi	8111d710 <_fseeko_r>

8111d6f4 <fseek>:
8111d6f4:	00a04574 	movhi	r2,33045
8111d6f8:	10bd6304 	addi	r2,r2,-2676
8111d6fc:	300f883a 	mov	r7,r6
8111d700:	280d883a 	mov	r6,r5
8111d704:	200b883a 	mov	r5,r4
8111d708:	11000017 	ldw	r4,0(r2)
8111d70c:	111d7101 	jmpi	8111d710 <_fseeko_r>

8111d710 <_fseeko_r>:
8111d710:	deffe804 	addi	sp,sp,-96
8111d714:	de00012e 	bgeu	sp,et,8111d71c <_fseeko_r+0xc>
8111d718:	003b68fa 	trap	3
8111d71c:	dd401415 	stw	r21,80(sp)
8111d720:	dc801115 	stw	r18,68(sp)
8111d724:	dc401015 	stw	r17,64(sp)
8111d728:	dc000f15 	stw	r16,60(sp)
8111d72c:	dfc01715 	stw	ra,92(sp)
8111d730:	ddc01615 	stw	r23,88(sp)
8111d734:	dd801515 	stw	r22,84(sp)
8111d738:	dd001315 	stw	r20,76(sp)
8111d73c:	dcc01215 	stw	r19,72(sp)
8111d740:	2023883a 	mov	r17,r4
8111d744:	2821883a 	mov	r16,r5
8111d748:	302b883a 	mov	r21,r6
8111d74c:	3825883a 	mov	r18,r7
8111d750:	20000226 	beq	r4,zero,8111d75c <_fseeko_r+0x4c>
8111d754:	20800e17 	ldw	r2,56(r4)
8111d758:	10005a26 	beq	r2,zero,8111d8c4 <_fseeko_r+0x1b4>
8111d75c:	8080030b 	ldhu	r2,12(r16)
8111d760:	00c04204 	movi	r3,264
8111d764:	1080420c 	andi	r2,r2,264
8111d768:	10c05b26 	beq	r2,r3,8111d8d8 <_fseeko_r+0x1c8>
8111d76c:	85000a17 	ldw	r20,40(r16)
8111d770:	a000f626 	beq	r20,zero,8111db4c <_fseeko_r+0x43c>
8111d774:	00800044 	movi	r2,1
8111d778:	90803e26 	beq	r18,r2,8111d874 <_fseeko_r+0x164>
8111d77c:	00800084 	movi	r2,2
8111d780:	90801026 	beq	r18,r2,8111d7c4 <_fseeko_r+0xb4>
8111d784:	90000f26 	beq	r18,zero,8111d7c4 <_fseeko_r+0xb4>
8111d788:	00800584 	movi	r2,22
8111d78c:	88800015 	stw	r2,0(r17)
8111d790:	04ffffc4 	movi	r19,-1
8111d794:	9805883a 	mov	r2,r19
8111d798:	dfc01717 	ldw	ra,92(sp)
8111d79c:	ddc01617 	ldw	r23,88(sp)
8111d7a0:	dd801517 	ldw	r22,84(sp)
8111d7a4:	dd401417 	ldw	r21,80(sp)
8111d7a8:	dd001317 	ldw	r20,76(sp)
8111d7ac:	dcc01217 	ldw	r19,72(sp)
8111d7b0:	dc801117 	ldw	r18,68(sp)
8111d7b4:	dc401017 	ldw	r17,64(sp)
8111d7b8:	dc000f17 	ldw	r16,60(sp)
8111d7bc:	dec01804 	addi	sp,sp,96
8111d7c0:	f800283a 	ret
8111d7c4:	80800417 	ldw	r2,16(r16)
8111d7c8:	002f883a 	mov	r23,zero
8111d7cc:	0027883a 	mov	r19,zero
8111d7d0:	1000cb26 	beq	r2,zero,8111db00 <_fseeko_r+0x3f0>
8111d7d4:	8080030b 	ldhu	r2,12(r16)
8111d7d8:	10c2068c 	andi	r3,r2,2074
8111d7dc:	1800071e 	bne	r3,zero,8111d7fc <_fseeko_r+0xec>
8111d7e0:	10c1000c 	andi	r3,r2,1024
8111d7e4:	1800451e 	bne	r3,zero,8111d8fc <_fseeko_r+0x1ec>
8111d7e8:	00e044b4 	movhi	r3,33042
8111d7ec:	18fc4004 	addi	r3,r3,-3840
8111d7f0:	a0c0b726 	beq	r20,r3,8111dad0 <_fseeko_r+0x3c0>
8111d7f4:	10820014 	ori	r2,r2,2048
8111d7f8:	8080030d 	sth	r2,12(r16)
8111d7fc:	800b883a 	mov	r5,r16
8111d800:	8809883a 	mov	r4,r17
8111d804:	11270900 	call	81127090 <_fflush_r>
8111d808:	1027883a 	mov	r19,r2
8111d80c:	103fe01e 	bne	r2,zero,8111d790 <__reset+0xfb0fd790>
8111d810:	81400717 	ldw	r5,28(r16)
8111d814:	900f883a 	mov	r7,r18
8111d818:	a80d883a 	mov	r6,r21
8111d81c:	8809883a 	mov	r4,r17
8111d820:	a03ee83a 	callr	r20
8111d824:	00ffffc4 	movi	r3,-1
8111d828:	10ffd926 	beq	r2,r3,8111d790 <__reset+0xfb0fd790>
8111d82c:	81400c17 	ldw	r5,48(r16)
8111d830:	28000526 	beq	r5,zero,8111d848 <_fseeko_r+0x138>
8111d834:	80801004 	addi	r2,r16,64
8111d838:	28800226 	beq	r5,r2,8111d844 <_fseeko_r+0x134>
8111d83c:	8809883a 	mov	r4,r17
8111d840:	11279240 	call	81127924 <_free_r>
8111d844:	80000c15 	stw	zero,48(r16)
8111d848:	8080030b 	ldhu	r2,12(r16)
8111d84c:	80c00417 	ldw	r3,16(r16)
8111d850:	80000115 	stw	zero,4(r16)
8111d854:	10bdf7cc 	andi	r2,r2,63455
8111d858:	80c00015 	stw	r3,0(r16)
8111d85c:	8080030d 	sth	r2,12(r16)
8111d860:	01800204 	movi	r6,8
8111d864:	000b883a 	mov	r5,zero
8111d868:	81001704 	addi	r4,r16,92
8111d86c:	111e8140 	call	8111e814 <memset>
8111d870:	003fc806 	br	8111d794 <__reset+0xfb0fd794>
8111d874:	800b883a 	mov	r5,r16
8111d878:	8809883a 	mov	r4,r17
8111d87c:	11270900 	call	81127090 <_fflush_r>
8111d880:	8080030b 	ldhu	r2,12(r16)
8111d884:	10c4000c 	andi	r3,r2,4096
8111d888:	18008726 	beq	r3,zero,8111daa8 <_fseeko_r+0x398>
8111d88c:	84c01417 	ldw	r19,80(r16)
8111d890:	10c0010c 	andi	r3,r2,4
8111d894:	1800431e 	bne	r3,zero,8111d9a4 <_fseeko_r+0x294>
8111d898:	1080020c 	andi	r2,r2,8
8111d89c:	10008026 	beq	r2,zero,8111daa0 <_fseeko_r+0x390>
8111d8a0:	80c00017 	ldw	r3,0(r16)
8111d8a4:	80800417 	ldw	r2,16(r16)
8111d8a8:	18000226 	beq	r3,zero,8111d8b4 <_fseeko_r+0x1a4>
8111d8ac:	1887c83a 	sub	r3,r3,r2
8111d8b0:	98e7883a 	add	r19,r19,r3
8111d8b4:	aceb883a 	add	r21,r21,r19
8111d8b8:	05c00044 	movi	r23,1
8111d8bc:	0025883a 	mov	r18,zero
8111d8c0:	003fc306 	br	8111d7d0 <__reset+0xfb0fd7d0>
8111d8c4:	112748c0 	call	8112748c <__sinit>
8111d8c8:	8080030b 	ldhu	r2,12(r16)
8111d8cc:	00c04204 	movi	r3,264
8111d8d0:	1080420c 	andi	r2,r2,264
8111d8d4:	10ffa51e 	bne	r2,r3,8111d76c <__reset+0xfb0fd76c>
8111d8d8:	800b883a 	mov	r5,r16
8111d8dc:	8809883a 	mov	r4,r17
8111d8e0:	11270900 	call	81127090 <_fflush_r>
8111d8e4:	003fa106 	br	8111d76c <__reset+0xfb0fd76c>
8111d8e8:	8080030b 	ldhu	r2,12(r16)
8111d8ec:	00c10004 	movi	r3,1024
8111d8f0:	80c01315 	stw	r3,76(r16)
8111d8f4:	10c4b03a 	or	r2,r2,r3
8111d8f8:	8080030d 	sth	r2,12(r16)
8111d8fc:	9000311e 	bne	r18,zero,8111d9c4 <_fseeko_r+0x2b4>
8111d900:	a82d883a 	mov	r22,r21
8111d904:	b800371e 	bne	r23,zero,8111d9e4 <_fseeko_r+0x2d4>
8111d908:	8080030b 	ldhu	r2,12(r16)
8111d90c:	1084000c 	andi	r2,r2,4096
8111d910:	10007f26 	beq	r2,zero,8111db10 <_fseeko_r+0x400>
8111d914:	80801417 	ldw	r2,80(r16)
8111d918:	81800117 	ldw	r6,4(r16)
8111d91c:	81400c17 	ldw	r5,48(r16)
8111d920:	11a7c83a 	sub	r19,r2,r6
8111d924:	28008226 	beq	r5,zero,8111db30 <_fseeko_r+0x420>
8111d928:	81c00f17 	ldw	r7,60(r16)
8111d92c:	99e7c83a 	sub	r19,r19,r7
8111d930:	81000e17 	ldw	r4,56(r16)
8111d934:	80800417 	ldw	r2,16(r16)
8111d938:	99a7883a 	add	r19,r19,r6
8111d93c:	2087c83a 	sub	r3,r4,r2
8111d940:	98e7c83a 	sub	r19,r19,r3
8111d944:	38c7883a 	add	r3,r7,r3
8111d948:	b4c02b16 	blt	r22,r19,8111d9f8 <_fseeko_r+0x2e8>
8111d94c:	98c9883a 	add	r4,r19,r3
8111d950:	b100292e 	bgeu	r22,r4,8111d9f8 <_fseeko_r+0x2e8>
8111d954:	b4e7c83a 	sub	r19,r22,r19
8111d958:	14c5883a 	add	r2,r2,r19
8111d95c:	1ce7c83a 	sub	r19,r3,r19
8111d960:	80800015 	stw	r2,0(r16)
8111d964:	84c00115 	stw	r19,4(r16)
8111d968:	28000526 	beq	r5,zero,8111d980 <_fseeko_r+0x270>
8111d96c:	80801004 	addi	r2,r16,64
8111d970:	28800226 	beq	r5,r2,8111d97c <_fseeko_r+0x26c>
8111d974:	8809883a 	mov	r4,r17
8111d978:	11279240 	call	81127924 <_free_r>
8111d97c:	80000c15 	stw	zero,48(r16)
8111d980:	8080030b 	ldhu	r2,12(r16)
8111d984:	01800204 	movi	r6,8
8111d988:	000b883a 	mov	r5,zero
8111d98c:	10bff7cc 	andi	r2,r2,65503
8111d990:	8080030d 	sth	r2,12(r16)
8111d994:	81001704 	addi	r4,r16,92
8111d998:	111e8140 	call	8111e814 <memset>
8111d99c:	0027883a 	mov	r19,zero
8111d9a0:	003f7c06 	br	8111d794 <__reset+0xfb0fd794>
8111d9a4:	80c00117 	ldw	r3,4(r16)
8111d9a8:	80800c17 	ldw	r2,48(r16)
8111d9ac:	98e7c83a 	sub	r19,r19,r3
8111d9b0:	10003b26 	beq	r2,zero,8111daa0 <_fseeko_r+0x390>
8111d9b4:	80c00f17 	ldw	r3,60(r16)
8111d9b8:	80800417 	ldw	r2,16(r16)
8111d9bc:	98e7c83a 	sub	r19,r19,r3
8111d9c0:	003fbc06 	br	8111d8b4 <__reset+0xfb0fd8b4>
8111d9c4:	8140038f 	ldh	r5,14(r16)
8111d9c8:	d80d883a 	mov	r6,sp
8111d9cc:	8809883a 	mov	r4,r17
8111d9d0:	111db780 	call	8111db78 <_fstat_r>
8111d9d4:	103f891e 	bne	r2,zero,8111d7fc <__reset+0xfb0fd7fc>
8111d9d8:	dd800417 	ldw	r22,16(sp)
8111d9dc:	adad883a 	add	r22,r21,r22
8111d9e0:	b83fc926 	beq	r23,zero,8111d908 <__reset+0xfb0fd908>
8111d9e4:	81400c17 	ldw	r5,48(r16)
8111d9e8:	81800117 	ldw	r6,4(r16)
8111d9ec:	28005026 	beq	r5,zero,8111db30 <_fseeko_r+0x420>
8111d9f0:	81c00f17 	ldw	r7,60(r16)
8111d9f4:	003fce06 	br	8111d930 <__reset+0xfb0fd930>
8111d9f8:	84c01317 	ldw	r19,76(r16)
8111d9fc:	81400717 	ldw	r5,28(r16)
8111da00:	000f883a 	mov	r7,zero
8111da04:	04e7c83a 	sub	r19,zero,r19
8111da08:	9da6703a 	and	r19,r19,r22
8111da0c:	980d883a 	mov	r6,r19
8111da10:	8809883a 	mov	r4,r17
8111da14:	a03ee83a 	callr	r20
8111da18:	00ffffc4 	movi	r3,-1
8111da1c:	10ff7726 	beq	r2,r3,8111d7fc <__reset+0xfb0fd7fc>
8111da20:	80800417 	ldw	r2,16(r16)
8111da24:	81400c17 	ldw	r5,48(r16)
8111da28:	80000115 	stw	zero,4(r16)
8111da2c:	80800015 	stw	r2,0(r16)
8111da30:	28000526 	beq	r5,zero,8111da48 <_fseeko_r+0x338>
8111da34:	80801004 	addi	r2,r16,64
8111da38:	28800226 	beq	r5,r2,8111da44 <_fseeko_r+0x334>
8111da3c:	8809883a 	mov	r4,r17
8111da40:	11279240 	call	81127924 <_free_r>
8111da44:	80000c15 	stw	zero,48(r16)
8111da48:	8080030b 	ldhu	r2,12(r16)
8111da4c:	b4e7c83a 	sub	r19,r22,r19
8111da50:	10bff7cc 	andi	r2,r2,65503
8111da54:	8080030d 	sth	r2,12(r16)
8111da58:	98000b26 	beq	r19,zero,8111da88 <_fseeko_r+0x378>
8111da5c:	800b883a 	mov	r5,r16
8111da60:	8809883a 	mov	r4,r17
8111da64:	111ec900 	call	8111ec90 <__srefill_r>
8111da68:	103f641e 	bne	r2,zero,8111d7fc <__reset+0xfb0fd7fc>
8111da6c:	80800117 	ldw	r2,4(r16)
8111da70:	14ff6236 	bltu	r2,r19,8111d7fc <__reset+0xfb0fd7fc>
8111da74:	80c00017 	ldw	r3,0(r16)
8111da78:	14c5c83a 	sub	r2,r2,r19
8111da7c:	80800115 	stw	r2,4(r16)
8111da80:	1ce7883a 	add	r19,r3,r19
8111da84:	84c00015 	stw	r19,0(r16)
8111da88:	01800204 	movi	r6,8
8111da8c:	000b883a 	mov	r5,zero
8111da90:	81001704 	addi	r4,r16,92
8111da94:	111e8140 	call	8111e814 <memset>
8111da98:	0027883a 	mov	r19,zero
8111da9c:	003f3d06 	br	8111d794 <__reset+0xfb0fd794>
8111daa0:	80800417 	ldw	r2,16(r16)
8111daa4:	003f8306 	br	8111d8b4 <__reset+0xfb0fd8b4>
8111daa8:	81400717 	ldw	r5,28(r16)
8111daac:	900f883a 	mov	r7,r18
8111dab0:	000d883a 	mov	r6,zero
8111dab4:	8809883a 	mov	r4,r17
8111dab8:	a03ee83a 	callr	r20
8111dabc:	1027883a 	mov	r19,r2
8111dac0:	00bfffc4 	movi	r2,-1
8111dac4:	98bf3226 	beq	r19,r2,8111d790 <__reset+0xfb0fd790>
8111dac8:	8080030b 	ldhu	r2,12(r16)
8111dacc:	003f7006 	br	8111d890 <__reset+0xfb0fd890>
8111dad0:	8140038f 	ldh	r5,14(r16)
8111dad4:	283f4716 	blt	r5,zero,8111d7f4 <__reset+0xfb0fd7f4>
8111dad8:	d80d883a 	mov	r6,sp
8111dadc:	8809883a 	mov	r4,r17
8111dae0:	111db780 	call	8111db78 <_fstat_r>
8111dae4:	1000041e 	bne	r2,zero,8111daf8 <_fseeko_r+0x3e8>
8111dae8:	d8800117 	ldw	r2,4(sp)
8111daec:	00e00014 	movui	r3,32768
8111daf0:	10bc000c 	andi	r2,r2,61440
8111daf4:	10ff7c26 	beq	r2,r3,8111d8e8 <__reset+0xfb0fd8e8>
8111daf8:	8080030b 	ldhu	r2,12(r16)
8111dafc:	003f3d06 	br	8111d7f4 <__reset+0xfb0fd7f4>
8111db00:	800b883a 	mov	r5,r16
8111db04:	8809883a 	mov	r4,r17
8111db08:	111dcec0 	call	8111dcec <__smakebuf_r>
8111db0c:	003f3106 	br	8111d7d4 <__reset+0xfb0fd7d4>
8111db10:	81400717 	ldw	r5,28(r16)
8111db14:	01c00044 	movi	r7,1
8111db18:	000d883a 	mov	r6,zero
8111db1c:	8809883a 	mov	r4,r17
8111db20:	a03ee83a 	callr	r20
8111db24:	00ffffc4 	movi	r3,-1
8111db28:	10ff7b1e 	bne	r2,r3,8111d918 <__reset+0xfb0fd918>
8111db2c:	003f3306 	br	8111d7fc <__reset+0xfb0fd7fc>
8111db30:	80c00017 	ldw	r3,0(r16)
8111db34:	80800417 	ldw	r2,16(r16)
8111db38:	000b883a 	mov	r5,zero
8111db3c:	1887c83a 	sub	r3,r3,r2
8111db40:	98e7c83a 	sub	r19,r19,r3
8111db44:	30c7883a 	add	r3,r6,r3
8111db48:	003f7f06 	br	8111d948 <__reset+0xfb0fd948>
8111db4c:	00800744 	movi	r2,29
8111db50:	88800015 	stw	r2,0(r17)
8111db54:	04ffffc4 	movi	r19,-1
8111db58:	003f0e06 	br	8111d794 <__reset+0xfb0fd794>

8111db5c <fseeko>:
8111db5c:	00a04574 	movhi	r2,33045
8111db60:	10bd6304 	addi	r2,r2,-2676
8111db64:	300f883a 	mov	r7,r6
8111db68:	280d883a 	mov	r6,r5
8111db6c:	200b883a 	mov	r5,r4
8111db70:	11000017 	ldw	r4,0(r2)
8111db74:	111d7101 	jmpi	8111d710 <_fseeko_r>

8111db78 <_fstat_r>:
8111db78:	defffd04 	addi	sp,sp,-12
8111db7c:	de00012e 	bgeu	sp,et,8111db84 <_fstat_r+0xc>
8111db80:	003b68fa 	trap	3
8111db84:	2805883a 	mov	r2,r5
8111db88:	dc000015 	stw	r16,0(sp)
8111db8c:	04204574 	movhi	r16,33045
8111db90:	dc400115 	stw	r17,4(sp)
8111db94:	843dd504 	addi	r16,r16,-2220
8111db98:	2023883a 	mov	r17,r4
8111db9c:	300b883a 	mov	r5,r6
8111dba0:	1009883a 	mov	r4,r2
8111dba4:	dfc00215 	stw	ra,8(sp)
8111dba8:	80000015 	stw	zero,0(r16)
8111dbac:	11331640 	call	81133164 <fstat>
8111dbb0:	00ffffc4 	movi	r3,-1
8111dbb4:	10c00526 	beq	r2,r3,8111dbcc <_fstat_r+0x54>
8111dbb8:	dfc00217 	ldw	ra,8(sp)
8111dbbc:	dc400117 	ldw	r17,4(sp)
8111dbc0:	dc000017 	ldw	r16,0(sp)
8111dbc4:	dec00304 	addi	sp,sp,12
8111dbc8:	f800283a 	ret
8111dbcc:	80c00017 	ldw	r3,0(r16)
8111dbd0:	183ff926 	beq	r3,zero,8111dbb8 <__reset+0xfb0fdbb8>
8111dbd4:	88c00015 	stw	r3,0(r17)
8111dbd8:	003ff706 	br	8111dbb8 <__reset+0xfb0fdbb8>

8111dbdc <_fwrite_r>:
8111dbdc:	defff504 	addi	sp,sp,-44
8111dbe0:	de00012e 	bgeu	sp,et,8111dbe8 <_fwrite_r+0xc>
8111dbe4:	003b68fa 	trap	3
8111dbe8:	dc800815 	stw	r18,32(sp)
8111dbec:	39a5383a 	mul	r18,r7,r6
8111dbf0:	d8800304 	addi	r2,sp,12
8111dbf4:	d8800015 	stw	r2,0(sp)
8111dbf8:	00800044 	movi	r2,1
8111dbfc:	dcc00915 	stw	r19,36(sp)
8111dc00:	dc400715 	stw	r17,28(sp)
8111dc04:	dc000615 	stw	r16,24(sp)
8111dc08:	d9400315 	stw	r5,12(sp)
8111dc0c:	dfc00a15 	stw	ra,40(sp)
8111dc10:	dc800415 	stw	r18,16(sp)
8111dc14:	dc800215 	stw	r18,8(sp)
8111dc18:	d8800115 	stw	r2,4(sp)
8111dc1c:	3027883a 	mov	r19,r6
8111dc20:	3821883a 	mov	r16,r7
8111dc24:	2023883a 	mov	r17,r4
8111dc28:	d9400b17 	ldw	r5,44(sp)
8111dc2c:	20000226 	beq	r4,zero,8111dc38 <_fwrite_r+0x5c>
8111dc30:	20800e17 	ldw	r2,56(r4)
8111dc34:	10001a26 	beq	r2,zero,8111dca0 <_fwrite_r+0xc4>
8111dc38:	2880030b 	ldhu	r2,12(r5)
8111dc3c:	10c8000c 	andi	r3,r2,8192
8111dc40:	1800061e 	bne	r3,zero,8111dc5c <_fwrite_r+0x80>
8111dc44:	29001917 	ldw	r4,100(r5)
8111dc48:	00f7ffc4 	movi	r3,-8193
8111dc4c:	10880014 	ori	r2,r2,8192
8111dc50:	20c6703a 	and	r3,r4,r3
8111dc54:	2880030d 	sth	r2,12(r5)
8111dc58:	28c01915 	stw	r3,100(r5)
8111dc5c:	d80d883a 	mov	r6,sp
8111dc60:	8809883a 	mov	r4,r17
8111dc64:	1127c3c0 	call	81127c3c <__sfvwrite_r>
8111dc68:	10000b26 	beq	r2,zero,8111dc98 <_fwrite_r+0xbc>
8111dc6c:	d9000217 	ldw	r4,8(sp)
8111dc70:	980b883a 	mov	r5,r19
8111dc74:	9109c83a 	sub	r4,r18,r4
8111dc78:	1130cac0 	call	81130cac <__udivsi3>
8111dc7c:	dfc00a17 	ldw	ra,40(sp)
8111dc80:	dcc00917 	ldw	r19,36(sp)
8111dc84:	dc800817 	ldw	r18,32(sp)
8111dc88:	dc400717 	ldw	r17,28(sp)
8111dc8c:	dc000617 	ldw	r16,24(sp)
8111dc90:	dec00b04 	addi	sp,sp,44
8111dc94:	f800283a 	ret
8111dc98:	8005883a 	mov	r2,r16
8111dc9c:	003ff706 	br	8111dc7c <__reset+0xfb0fdc7c>
8111dca0:	d9400515 	stw	r5,20(sp)
8111dca4:	112748c0 	call	8112748c <__sinit>
8111dca8:	d9400517 	ldw	r5,20(sp)
8111dcac:	003fe206 	br	8111dc38 <__reset+0xfb0fdc38>

8111dcb0 <fwrite>:
8111dcb0:	defffe04 	addi	sp,sp,-8
8111dcb4:	00a04574 	movhi	r2,33045
8111dcb8:	de00012e 	bgeu	sp,et,8111dcc0 <fwrite+0x10>
8111dcbc:	003b68fa 	trap	3
8111dcc0:	10bd6304 	addi	r2,r2,-2676
8111dcc4:	d9c00015 	stw	r7,0(sp)
8111dcc8:	300f883a 	mov	r7,r6
8111dccc:	280d883a 	mov	r6,r5
8111dcd0:	200b883a 	mov	r5,r4
8111dcd4:	11000017 	ldw	r4,0(r2)
8111dcd8:	dfc00115 	stw	ra,4(sp)
8111dcdc:	111dbdc0 	call	8111dbdc <_fwrite_r>
8111dce0:	dfc00117 	ldw	ra,4(sp)
8111dce4:	dec00204 	addi	sp,sp,8
8111dce8:	f800283a 	ret

8111dcec <__smakebuf_r>:
8111dcec:	2880030b 	ldhu	r2,12(r5)
8111dcf0:	10c0008c 	andi	r3,r2,2
8111dcf4:	1800431e 	bne	r3,zero,8111de04 <__smakebuf_r+0x118>
8111dcf8:	deffec04 	addi	sp,sp,-80
8111dcfc:	de00012e 	bgeu	sp,et,8111dd04 <__smakebuf_r+0x18>
8111dd00:	003b68fa 	trap	3
8111dd04:	dc000f15 	stw	r16,60(sp)
8111dd08:	2821883a 	mov	r16,r5
8111dd0c:	2940038f 	ldh	r5,14(r5)
8111dd10:	dc401015 	stw	r17,64(sp)
8111dd14:	dfc01315 	stw	ra,76(sp)
8111dd18:	dcc01215 	stw	r19,72(sp)
8111dd1c:	dc801115 	stw	r18,68(sp)
8111dd20:	2023883a 	mov	r17,r4
8111dd24:	28001c16 	blt	r5,zero,8111dd98 <__smakebuf_r+0xac>
8111dd28:	d80d883a 	mov	r6,sp
8111dd2c:	111db780 	call	8111db78 <_fstat_r>
8111dd30:	10001816 	blt	r2,zero,8111dd94 <__smakebuf_r+0xa8>
8111dd34:	d8800117 	ldw	r2,4(sp)
8111dd38:	00e00014 	movui	r3,32768
8111dd3c:	10bc000c 	andi	r2,r2,61440
8111dd40:	14c80020 	cmpeqi	r19,r2,8192
8111dd44:	10c03726 	beq	r2,r3,8111de24 <__smakebuf_r+0x138>
8111dd48:	80c0030b 	ldhu	r3,12(r16)
8111dd4c:	18c20014 	ori	r3,r3,2048
8111dd50:	80c0030d 	sth	r3,12(r16)
8111dd54:	00c80004 	movi	r3,8192
8111dd58:	10c0521e 	bne	r2,r3,8111dea4 <__smakebuf_r+0x1b8>
8111dd5c:	8140038f 	ldh	r5,14(r16)
8111dd60:	8809883a 	mov	r4,r17
8111dd64:	11282980 	call	81128298 <_isatty_r>
8111dd68:	10004c26 	beq	r2,zero,8111de9c <__smakebuf_r+0x1b0>
8111dd6c:	8080030b 	ldhu	r2,12(r16)
8111dd70:	80c010c4 	addi	r3,r16,67
8111dd74:	80c00015 	stw	r3,0(r16)
8111dd78:	10800054 	ori	r2,r2,1
8111dd7c:	8080030d 	sth	r2,12(r16)
8111dd80:	00800044 	movi	r2,1
8111dd84:	80c00415 	stw	r3,16(r16)
8111dd88:	80800515 	stw	r2,20(r16)
8111dd8c:	04810004 	movi	r18,1024
8111dd90:	00000706 	br	8111ddb0 <__smakebuf_r+0xc4>
8111dd94:	8080030b 	ldhu	r2,12(r16)
8111dd98:	10c0200c 	andi	r3,r2,128
8111dd9c:	18001f1e 	bne	r3,zero,8111de1c <__smakebuf_r+0x130>
8111dda0:	04810004 	movi	r18,1024
8111dda4:	10820014 	ori	r2,r2,2048
8111dda8:	8080030d 	sth	r2,12(r16)
8111ddac:	0027883a 	mov	r19,zero
8111ddb0:	900b883a 	mov	r5,r18
8111ddb4:	8809883a 	mov	r4,r17
8111ddb8:	111deb00 	call	8111deb0 <_malloc_r>
8111ddbc:	10002c26 	beq	r2,zero,8111de70 <__smakebuf_r+0x184>
8111ddc0:	80c0030b 	ldhu	r3,12(r16)
8111ddc4:	012044b4 	movhi	r4,33042
8111ddc8:	211c4b04 	addi	r4,r4,28972
8111ddcc:	89000f15 	stw	r4,60(r17)
8111ddd0:	18c02014 	ori	r3,r3,128
8111ddd4:	80c0030d 	sth	r3,12(r16)
8111ddd8:	80800015 	stw	r2,0(r16)
8111dddc:	80800415 	stw	r2,16(r16)
8111dde0:	84800515 	stw	r18,20(r16)
8111dde4:	98001a1e 	bne	r19,zero,8111de50 <__smakebuf_r+0x164>
8111dde8:	dfc01317 	ldw	ra,76(sp)
8111ddec:	dcc01217 	ldw	r19,72(sp)
8111ddf0:	dc801117 	ldw	r18,68(sp)
8111ddf4:	dc401017 	ldw	r17,64(sp)
8111ddf8:	dc000f17 	ldw	r16,60(sp)
8111ddfc:	dec01404 	addi	sp,sp,80
8111de00:	f800283a 	ret
8111de04:	288010c4 	addi	r2,r5,67
8111de08:	28800015 	stw	r2,0(r5)
8111de0c:	28800415 	stw	r2,16(r5)
8111de10:	00800044 	movi	r2,1
8111de14:	28800515 	stw	r2,20(r5)
8111de18:	f800283a 	ret
8111de1c:	04801004 	movi	r18,64
8111de20:	003fe006 	br	8111dda4 <__reset+0xfb0fdda4>
8111de24:	81000a17 	ldw	r4,40(r16)
8111de28:	00e044b4 	movhi	r3,33042
8111de2c:	18fc4004 	addi	r3,r3,-3840
8111de30:	20ffc51e 	bne	r4,r3,8111dd48 <__reset+0xfb0fdd48>
8111de34:	8080030b 	ldhu	r2,12(r16)
8111de38:	04810004 	movi	r18,1024
8111de3c:	84801315 	stw	r18,76(r16)
8111de40:	1484b03a 	or	r2,r2,r18
8111de44:	8080030d 	sth	r2,12(r16)
8111de48:	0027883a 	mov	r19,zero
8111de4c:	003fd806 	br	8111ddb0 <__reset+0xfb0fddb0>
8111de50:	8140038f 	ldh	r5,14(r16)
8111de54:	8809883a 	mov	r4,r17
8111de58:	11282980 	call	81128298 <_isatty_r>
8111de5c:	103fe226 	beq	r2,zero,8111dde8 <__reset+0xfb0fdde8>
8111de60:	8080030b 	ldhu	r2,12(r16)
8111de64:	10800054 	ori	r2,r2,1
8111de68:	8080030d 	sth	r2,12(r16)
8111de6c:	003fde06 	br	8111dde8 <__reset+0xfb0fdde8>
8111de70:	8080030b 	ldhu	r2,12(r16)
8111de74:	10c0800c 	andi	r3,r2,512
8111de78:	183fdb1e 	bne	r3,zero,8111dde8 <__reset+0xfb0fdde8>
8111de7c:	10800094 	ori	r2,r2,2
8111de80:	80c010c4 	addi	r3,r16,67
8111de84:	8080030d 	sth	r2,12(r16)
8111de88:	00800044 	movi	r2,1
8111de8c:	80c00015 	stw	r3,0(r16)
8111de90:	80c00415 	stw	r3,16(r16)
8111de94:	80800515 	stw	r2,20(r16)
8111de98:	003fd306 	br	8111dde8 <__reset+0xfb0fdde8>
8111de9c:	04810004 	movi	r18,1024
8111dea0:	003fc306 	br	8111ddb0 <__reset+0xfb0fddb0>
8111dea4:	0027883a 	mov	r19,zero
8111dea8:	04810004 	movi	r18,1024
8111deac:	003fc006 	br	8111ddb0 <__reset+0xfb0fddb0>

8111deb0 <_malloc_r>:
8111deb0:	defff504 	addi	sp,sp,-44
8111deb4:	de00012e 	bgeu	sp,et,8111debc <_malloc_r+0xc>
8111deb8:	003b68fa 	trap	3
8111debc:	288002c4 	addi	r2,r5,11
8111dec0:	dc800315 	stw	r18,12(sp)
8111dec4:	dfc00a15 	stw	ra,40(sp)
8111dec8:	df000915 	stw	fp,36(sp)
8111decc:	ddc00815 	stw	r23,32(sp)
8111ded0:	dd800715 	stw	r22,28(sp)
8111ded4:	dd400615 	stw	r21,24(sp)
8111ded8:	dd000515 	stw	r20,20(sp)
8111dedc:	dcc00415 	stw	r19,16(sp)
8111dee0:	dc400215 	stw	r17,8(sp)
8111dee4:	dc000115 	stw	r16,4(sp)
8111dee8:	00c00584 	movi	r3,22
8111deec:	2025883a 	mov	r18,r4
8111def0:	18807f2e 	bgeu	r3,r2,8111e0f0 <_malloc_r+0x240>
8111def4:	047ffe04 	movi	r17,-8
8111def8:	1462703a 	and	r17,r2,r17
8111defc:	8800a316 	blt	r17,zero,8111e18c <_malloc_r+0x2dc>
8111df00:	8940a236 	bltu	r17,r5,8111e18c <_malloc_r+0x2dc>
8111df04:	1134cac0 	call	81134cac <__malloc_lock>
8111df08:	00807dc4 	movi	r2,503
8111df0c:	1441e92e 	bgeu	r2,r17,8111e6b4 <_malloc_r+0x804>
8111df10:	8804d27a 	srli	r2,r17,9
8111df14:	1000a126 	beq	r2,zero,8111e19c <_malloc_r+0x2ec>
8111df18:	00c00104 	movi	r3,4
8111df1c:	18811e36 	bltu	r3,r2,8111e398 <_malloc_r+0x4e8>
8111df20:	8804d1ba 	srli	r2,r17,6
8111df24:	12000e44 	addi	r8,r2,57
8111df28:	11c00e04 	addi	r7,r2,56
8111df2c:	4209883a 	add	r4,r8,r8
8111df30:	04e04574 	movhi	r19,33045
8111df34:	2109883a 	add	r4,r4,r4
8111df38:	9cf72104 	addi	r19,r19,-9084
8111df3c:	2109883a 	add	r4,r4,r4
8111df40:	9909883a 	add	r4,r19,r4
8111df44:	24000117 	ldw	r16,4(r4)
8111df48:	213ffe04 	addi	r4,r4,-8
8111df4c:	24009726 	beq	r4,r16,8111e1ac <_malloc_r+0x2fc>
8111df50:	80800117 	ldw	r2,4(r16)
8111df54:	01bfff04 	movi	r6,-4
8111df58:	014003c4 	movi	r5,15
8111df5c:	1184703a 	and	r2,r2,r6
8111df60:	1447c83a 	sub	r3,r2,r17
8111df64:	28c00716 	blt	r5,r3,8111df84 <_malloc_r+0xd4>
8111df68:	1800920e 	bge	r3,zero,8111e1b4 <_malloc_r+0x304>
8111df6c:	84000317 	ldw	r16,12(r16)
8111df70:	24008e26 	beq	r4,r16,8111e1ac <_malloc_r+0x2fc>
8111df74:	80800117 	ldw	r2,4(r16)
8111df78:	1184703a 	and	r2,r2,r6
8111df7c:	1447c83a 	sub	r3,r2,r17
8111df80:	28fff90e 	bge	r5,r3,8111df68 <__reset+0xfb0fdf68>
8111df84:	3809883a 	mov	r4,r7
8111df88:	01a04574 	movhi	r6,33045
8111df8c:	9c000417 	ldw	r16,16(r19)
8111df90:	31b72104 	addi	r6,r6,-9084
8111df94:	32000204 	addi	r8,r6,8
8111df98:	82013426 	beq	r16,r8,8111e46c <_malloc_r+0x5bc>
8111df9c:	80c00117 	ldw	r3,4(r16)
8111dfa0:	00bfff04 	movi	r2,-4
8111dfa4:	188e703a 	and	r7,r3,r2
8111dfa8:	3c45c83a 	sub	r2,r7,r17
8111dfac:	00c003c4 	movi	r3,15
8111dfb0:	18811f16 	blt	r3,r2,8111e430 <_malloc_r+0x580>
8111dfb4:	32000515 	stw	r8,20(r6)
8111dfb8:	32000415 	stw	r8,16(r6)
8111dfbc:	10007f0e 	bge	r2,zero,8111e1bc <_malloc_r+0x30c>
8111dfc0:	00807fc4 	movi	r2,511
8111dfc4:	11c0fd36 	bltu	r2,r7,8111e3bc <_malloc_r+0x50c>
8111dfc8:	3806d0fa 	srli	r3,r7,3
8111dfcc:	01c00044 	movi	r7,1
8111dfd0:	30800117 	ldw	r2,4(r6)
8111dfd4:	19400044 	addi	r5,r3,1
8111dfd8:	294b883a 	add	r5,r5,r5
8111dfdc:	1807d0ba 	srai	r3,r3,2
8111dfe0:	294b883a 	add	r5,r5,r5
8111dfe4:	294b883a 	add	r5,r5,r5
8111dfe8:	298b883a 	add	r5,r5,r6
8111dfec:	38c6983a 	sll	r3,r7,r3
8111dff0:	29c00017 	ldw	r7,0(r5)
8111dff4:	2a7ffe04 	addi	r9,r5,-8
8111dff8:	1886b03a 	or	r3,r3,r2
8111dffc:	82400315 	stw	r9,12(r16)
8111e000:	81c00215 	stw	r7,8(r16)
8111e004:	30c00115 	stw	r3,4(r6)
8111e008:	2c000015 	stw	r16,0(r5)
8111e00c:	3c000315 	stw	r16,12(r7)
8111e010:	2005d0ba 	srai	r2,r4,2
8111e014:	01400044 	movi	r5,1
8111e018:	288a983a 	sll	r5,r5,r2
8111e01c:	19406f36 	bltu	r3,r5,8111e1dc <_malloc_r+0x32c>
8111e020:	28c4703a 	and	r2,r5,r3
8111e024:	10000a1e 	bne	r2,zero,8111e050 <_malloc_r+0x1a0>
8111e028:	00bfff04 	movi	r2,-4
8111e02c:	294b883a 	add	r5,r5,r5
8111e030:	2088703a 	and	r4,r4,r2
8111e034:	28c4703a 	and	r2,r5,r3
8111e038:	21000104 	addi	r4,r4,4
8111e03c:	1000041e 	bne	r2,zero,8111e050 <_malloc_r+0x1a0>
8111e040:	294b883a 	add	r5,r5,r5
8111e044:	28c4703a 	and	r2,r5,r3
8111e048:	21000104 	addi	r4,r4,4
8111e04c:	103ffc26 	beq	r2,zero,8111e040 <__reset+0xfb0fe040>
8111e050:	02bfff04 	movi	r10,-4
8111e054:	024003c4 	movi	r9,15
8111e058:	21800044 	addi	r6,r4,1
8111e05c:	318d883a 	add	r6,r6,r6
8111e060:	318d883a 	add	r6,r6,r6
8111e064:	318d883a 	add	r6,r6,r6
8111e068:	998d883a 	add	r6,r19,r6
8111e06c:	333ffe04 	addi	r12,r6,-8
8111e070:	2017883a 	mov	r11,r4
8111e074:	31800104 	addi	r6,r6,4
8111e078:	34000017 	ldw	r16,0(r6)
8111e07c:	31fffd04 	addi	r7,r6,-12
8111e080:	81c0041e 	bne	r16,r7,8111e094 <_malloc_r+0x1e4>
8111e084:	0000fb06 	br	8111e474 <_malloc_r+0x5c4>
8111e088:	1801030e 	bge	r3,zero,8111e498 <_malloc_r+0x5e8>
8111e08c:	84000317 	ldw	r16,12(r16)
8111e090:	81c0f826 	beq	r16,r7,8111e474 <_malloc_r+0x5c4>
8111e094:	80800117 	ldw	r2,4(r16)
8111e098:	1284703a 	and	r2,r2,r10
8111e09c:	1447c83a 	sub	r3,r2,r17
8111e0a0:	48fff90e 	bge	r9,r3,8111e088 <__reset+0xfb0fe088>
8111e0a4:	80800317 	ldw	r2,12(r16)
8111e0a8:	81000217 	ldw	r4,8(r16)
8111e0ac:	89400054 	ori	r5,r17,1
8111e0b0:	81400115 	stw	r5,4(r16)
8111e0b4:	20800315 	stw	r2,12(r4)
8111e0b8:	11000215 	stw	r4,8(r2)
8111e0bc:	8463883a 	add	r17,r16,r17
8111e0c0:	9c400515 	stw	r17,20(r19)
8111e0c4:	9c400415 	stw	r17,16(r19)
8111e0c8:	18800054 	ori	r2,r3,1
8111e0cc:	88800115 	stw	r2,4(r17)
8111e0d0:	8a000315 	stw	r8,12(r17)
8111e0d4:	8a000215 	stw	r8,8(r17)
8111e0d8:	88e3883a 	add	r17,r17,r3
8111e0dc:	88c00015 	stw	r3,0(r17)
8111e0e0:	9009883a 	mov	r4,r18
8111e0e4:	1134dd40 	call	81134dd4 <__malloc_unlock>
8111e0e8:	80800204 	addi	r2,r16,8
8111e0ec:	00001b06 	br	8111e15c <_malloc_r+0x2ac>
8111e0f0:	04400404 	movi	r17,16
8111e0f4:	89402536 	bltu	r17,r5,8111e18c <_malloc_r+0x2dc>
8111e0f8:	1134cac0 	call	81134cac <__malloc_lock>
8111e0fc:	00800184 	movi	r2,6
8111e100:	01000084 	movi	r4,2
8111e104:	04e04574 	movhi	r19,33045
8111e108:	1085883a 	add	r2,r2,r2
8111e10c:	9cf72104 	addi	r19,r19,-9084
8111e110:	1085883a 	add	r2,r2,r2
8111e114:	9885883a 	add	r2,r19,r2
8111e118:	14000117 	ldw	r16,4(r2)
8111e11c:	10fffe04 	addi	r3,r2,-8
8111e120:	80c0d926 	beq	r16,r3,8111e488 <_malloc_r+0x5d8>
8111e124:	80c00117 	ldw	r3,4(r16)
8111e128:	81000317 	ldw	r4,12(r16)
8111e12c:	00bfff04 	movi	r2,-4
8111e130:	1884703a 	and	r2,r3,r2
8111e134:	81400217 	ldw	r5,8(r16)
8111e138:	8085883a 	add	r2,r16,r2
8111e13c:	10c00117 	ldw	r3,4(r2)
8111e140:	29000315 	stw	r4,12(r5)
8111e144:	21400215 	stw	r5,8(r4)
8111e148:	18c00054 	ori	r3,r3,1
8111e14c:	10c00115 	stw	r3,4(r2)
8111e150:	9009883a 	mov	r4,r18
8111e154:	1134dd40 	call	81134dd4 <__malloc_unlock>
8111e158:	80800204 	addi	r2,r16,8
8111e15c:	dfc00a17 	ldw	ra,40(sp)
8111e160:	df000917 	ldw	fp,36(sp)
8111e164:	ddc00817 	ldw	r23,32(sp)
8111e168:	dd800717 	ldw	r22,28(sp)
8111e16c:	dd400617 	ldw	r21,24(sp)
8111e170:	dd000517 	ldw	r20,20(sp)
8111e174:	dcc00417 	ldw	r19,16(sp)
8111e178:	dc800317 	ldw	r18,12(sp)
8111e17c:	dc400217 	ldw	r17,8(sp)
8111e180:	dc000117 	ldw	r16,4(sp)
8111e184:	dec00b04 	addi	sp,sp,44
8111e188:	f800283a 	ret
8111e18c:	00800304 	movi	r2,12
8111e190:	90800015 	stw	r2,0(r18)
8111e194:	0005883a 	mov	r2,zero
8111e198:	003ff006 	br	8111e15c <__reset+0xfb0fe15c>
8111e19c:	01002004 	movi	r4,128
8111e1a0:	02001004 	movi	r8,64
8111e1a4:	01c00fc4 	movi	r7,63
8111e1a8:	003f6106 	br	8111df30 <__reset+0xfb0fdf30>
8111e1ac:	4009883a 	mov	r4,r8
8111e1b0:	003f7506 	br	8111df88 <__reset+0xfb0fdf88>
8111e1b4:	81000317 	ldw	r4,12(r16)
8111e1b8:	003fde06 	br	8111e134 <__reset+0xfb0fe134>
8111e1bc:	81c5883a 	add	r2,r16,r7
8111e1c0:	11400117 	ldw	r5,4(r2)
8111e1c4:	9009883a 	mov	r4,r18
8111e1c8:	29400054 	ori	r5,r5,1
8111e1cc:	11400115 	stw	r5,4(r2)
8111e1d0:	1134dd40 	call	81134dd4 <__malloc_unlock>
8111e1d4:	80800204 	addi	r2,r16,8
8111e1d8:	003fe006 	br	8111e15c <__reset+0xfb0fe15c>
8111e1dc:	9c000217 	ldw	r16,8(r19)
8111e1e0:	00bfff04 	movi	r2,-4
8111e1e4:	85800117 	ldw	r22,4(r16)
8111e1e8:	b0ac703a 	and	r22,r22,r2
8111e1ec:	b4400336 	bltu	r22,r17,8111e1fc <_malloc_r+0x34c>
8111e1f0:	b445c83a 	sub	r2,r22,r17
8111e1f4:	00c003c4 	movi	r3,15
8111e1f8:	18805d16 	blt	r3,r2,8111e370 <_malloc_r+0x4c0>
8111e1fc:	05e04574 	movhi	r23,33045
8111e200:	00a04574 	movhi	r2,33045
8111e204:	10bdd804 	addi	r2,r2,-2208
8111e208:	bdfd6404 	addi	r23,r23,-2672
8111e20c:	15400017 	ldw	r21,0(r2)
8111e210:	b8c00017 	ldw	r3,0(r23)
8111e214:	00bfffc4 	movi	r2,-1
8111e218:	858d883a 	add	r6,r16,r22
8111e21c:	8d6b883a 	add	r21,r17,r21
8111e220:	1880ea26 	beq	r3,r2,8111e5cc <_malloc_r+0x71c>
8111e224:	ad4403c4 	addi	r21,r21,4111
8111e228:	00bc0004 	movi	r2,-4096
8111e22c:	a8aa703a 	and	r21,r21,r2
8111e230:	a80b883a 	mov	r5,r21
8111e234:	9009883a 	mov	r4,r18
8111e238:	d9800015 	stw	r6,0(sp)
8111e23c:	111ee6c0 	call	8111ee6c <_sbrk_r>
8111e240:	1029883a 	mov	r20,r2
8111e244:	00bfffc4 	movi	r2,-1
8111e248:	d9800017 	ldw	r6,0(sp)
8111e24c:	a080e826 	beq	r20,r2,8111e5f0 <_malloc_r+0x740>
8111e250:	a180a636 	bltu	r20,r6,8111e4ec <_malloc_r+0x63c>
8111e254:	07204574 	movhi	fp,33045
8111e258:	e73e6504 	addi	fp,fp,-1644
8111e25c:	e0800017 	ldw	r2,0(fp)
8111e260:	a887883a 	add	r3,r21,r2
8111e264:	e0c00015 	stw	r3,0(fp)
8111e268:	3500e626 	beq	r6,r20,8111e604 <_malloc_r+0x754>
8111e26c:	b9000017 	ldw	r4,0(r23)
8111e270:	00bfffc4 	movi	r2,-1
8111e274:	2080ee26 	beq	r4,r2,8111e630 <_malloc_r+0x780>
8111e278:	a185c83a 	sub	r2,r20,r6
8111e27c:	10c5883a 	add	r2,r2,r3
8111e280:	e0800015 	stw	r2,0(fp)
8111e284:	a0c001cc 	andi	r3,r20,7
8111e288:	1800bc26 	beq	r3,zero,8111e57c <_malloc_r+0x6cc>
8111e28c:	a0e9c83a 	sub	r20,r20,r3
8111e290:	00840204 	movi	r2,4104
8111e294:	a5000204 	addi	r20,r20,8
8111e298:	10c7c83a 	sub	r3,r2,r3
8111e29c:	a545883a 	add	r2,r20,r21
8111e2a0:	1083ffcc 	andi	r2,r2,4095
8111e2a4:	18abc83a 	sub	r21,r3,r2
8111e2a8:	a80b883a 	mov	r5,r21
8111e2ac:	9009883a 	mov	r4,r18
8111e2b0:	111ee6c0 	call	8111ee6c <_sbrk_r>
8111e2b4:	00ffffc4 	movi	r3,-1
8111e2b8:	10c0e126 	beq	r2,r3,8111e640 <_malloc_r+0x790>
8111e2bc:	1505c83a 	sub	r2,r2,r20
8111e2c0:	1545883a 	add	r2,r2,r21
8111e2c4:	10800054 	ori	r2,r2,1
8111e2c8:	e0c00017 	ldw	r3,0(fp)
8111e2cc:	9d000215 	stw	r20,8(r19)
8111e2d0:	a0800115 	stw	r2,4(r20)
8111e2d4:	a8c7883a 	add	r3,r21,r3
8111e2d8:	e0c00015 	stw	r3,0(fp)
8111e2dc:	84c00e26 	beq	r16,r19,8111e318 <_malloc_r+0x468>
8111e2e0:	018003c4 	movi	r6,15
8111e2e4:	3580a72e 	bgeu	r6,r22,8111e584 <_malloc_r+0x6d4>
8111e2e8:	81400117 	ldw	r5,4(r16)
8111e2ec:	013ffe04 	movi	r4,-8
8111e2f0:	b0bffd04 	addi	r2,r22,-12
8111e2f4:	1104703a 	and	r2,r2,r4
8111e2f8:	2900004c 	andi	r4,r5,1
8111e2fc:	2088b03a 	or	r4,r4,r2
8111e300:	81000115 	stw	r4,4(r16)
8111e304:	01400144 	movi	r5,5
8111e308:	8089883a 	add	r4,r16,r2
8111e30c:	21400115 	stw	r5,4(r4)
8111e310:	21400215 	stw	r5,8(r4)
8111e314:	3080cd36 	bltu	r6,r2,8111e64c <_malloc_r+0x79c>
8111e318:	00a04574 	movhi	r2,33045
8111e31c:	10bdd704 	addi	r2,r2,-2212
8111e320:	11000017 	ldw	r4,0(r2)
8111e324:	20c0012e 	bgeu	r4,r3,8111e32c <_malloc_r+0x47c>
8111e328:	10c00015 	stw	r3,0(r2)
8111e32c:	00a04574 	movhi	r2,33045
8111e330:	10bdd604 	addi	r2,r2,-2216
8111e334:	11000017 	ldw	r4,0(r2)
8111e338:	9c000217 	ldw	r16,8(r19)
8111e33c:	20c0012e 	bgeu	r4,r3,8111e344 <_malloc_r+0x494>
8111e340:	10c00015 	stw	r3,0(r2)
8111e344:	80c00117 	ldw	r3,4(r16)
8111e348:	00bfff04 	movi	r2,-4
8111e34c:	1886703a 	and	r3,r3,r2
8111e350:	1c45c83a 	sub	r2,r3,r17
8111e354:	1c400236 	bltu	r3,r17,8111e360 <_malloc_r+0x4b0>
8111e358:	00c003c4 	movi	r3,15
8111e35c:	18800416 	blt	r3,r2,8111e370 <_malloc_r+0x4c0>
8111e360:	9009883a 	mov	r4,r18
8111e364:	1134dd40 	call	81134dd4 <__malloc_unlock>
8111e368:	0005883a 	mov	r2,zero
8111e36c:	003f7b06 	br	8111e15c <__reset+0xfb0fe15c>
8111e370:	88c00054 	ori	r3,r17,1
8111e374:	80c00115 	stw	r3,4(r16)
8111e378:	8463883a 	add	r17,r16,r17
8111e37c:	10800054 	ori	r2,r2,1
8111e380:	9c400215 	stw	r17,8(r19)
8111e384:	88800115 	stw	r2,4(r17)
8111e388:	9009883a 	mov	r4,r18
8111e38c:	1134dd40 	call	81134dd4 <__malloc_unlock>
8111e390:	80800204 	addi	r2,r16,8
8111e394:	003f7106 	br	8111e15c <__reset+0xfb0fe15c>
8111e398:	00c00504 	movi	r3,20
8111e39c:	18804a2e 	bgeu	r3,r2,8111e4c8 <_malloc_r+0x618>
8111e3a0:	00c01504 	movi	r3,84
8111e3a4:	18806e36 	bltu	r3,r2,8111e560 <_malloc_r+0x6b0>
8111e3a8:	8804d33a 	srli	r2,r17,12
8111e3ac:	12001bc4 	addi	r8,r2,111
8111e3b0:	11c01b84 	addi	r7,r2,110
8111e3b4:	4209883a 	add	r4,r8,r8
8111e3b8:	003edd06 	br	8111df30 <__reset+0xfb0fdf30>
8111e3bc:	3804d27a 	srli	r2,r7,9
8111e3c0:	00c00104 	movi	r3,4
8111e3c4:	1880442e 	bgeu	r3,r2,8111e4d8 <_malloc_r+0x628>
8111e3c8:	00c00504 	movi	r3,20
8111e3cc:	18808136 	bltu	r3,r2,8111e5d4 <_malloc_r+0x724>
8111e3d0:	11401704 	addi	r5,r2,92
8111e3d4:	10c016c4 	addi	r3,r2,91
8111e3d8:	294b883a 	add	r5,r5,r5
8111e3dc:	294b883a 	add	r5,r5,r5
8111e3e0:	294b883a 	add	r5,r5,r5
8111e3e4:	994b883a 	add	r5,r19,r5
8111e3e8:	28800017 	ldw	r2,0(r5)
8111e3ec:	01a04574 	movhi	r6,33045
8111e3f0:	297ffe04 	addi	r5,r5,-8
8111e3f4:	31b72104 	addi	r6,r6,-9084
8111e3f8:	28806526 	beq	r5,r2,8111e590 <_malloc_r+0x6e0>
8111e3fc:	01bfff04 	movi	r6,-4
8111e400:	10c00117 	ldw	r3,4(r2)
8111e404:	1986703a 	and	r3,r3,r6
8111e408:	38c0022e 	bgeu	r7,r3,8111e414 <_malloc_r+0x564>
8111e40c:	10800217 	ldw	r2,8(r2)
8111e410:	28bffb1e 	bne	r5,r2,8111e400 <__reset+0xfb0fe400>
8111e414:	11400317 	ldw	r5,12(r2)
8111e418:	98c00117 	ldw	r3,4(r19)
8111e41c:	81400315 	stw	r5,12(r16)
8111e420:	80800215 	stw	r2,8(r16)
8111e424:	2c000215 	stw	r16,8(r5)
8111e428:	14000315 	stw	r16,12(r2)
8111e42c:	003ef806 	br	8111e010 <__reset+0xfb0fe010>
8111e430:	88c00054 	ori	r3,r17,1
8111e434:	80c00115 	stw	r3,4(r16)
8111e438:	8463883a 	add	r17,r16,r17
8111e43c:	34400515 	stw	r17,20(r6)
8111e440:	34400415 	stw	r17,16(r6)
8111e444:	10c00054 	ori	r3,r2,1
8111e448:	8a000315 	stw	r8,12(r17)
8111e44c:	8a000215 	stw	r8,8(r17)
8111e450:	88c00115 	stw	r3,4(r17)
8111e454:	88a3883a 	add	r17,r17,r2
8111e458:	88800015 	stw	r2,0(r17)
8111e45c:	9009883a 	mov	r4,r18
8111e460:	1134dd40 	call	81134dd4 <__malloc_unlock>
8111e464:	80800204 	addi	r2,r16,8
8111e468:	003f3c06 	br	8111e15c <__reset+0xfb0fe15c>
8111e46c:	30c00117 	ldw	r3,4(r6)
8111e470:	003ee706 	br	8111e010 <__reset+0xfb0fe010>
8111e474:	5ac00044 	addi	r11,r11,1
8111e478:	588000cc 	andi	r2,r11,3
8111e47c:	31800204 	addi	r6,r6,8
8111e480:	103efd1e 	bne	r2,zero,8111e078 <__reset+0xfb0fe078>
8111e484:	00002406 	br	8111e518 <_malloc_r+0x668>
8111e488:	14000317 	ldw	r16,12(r2)
8111e48c:	143f251e 	bne	r2,r16,8111e124 <__reset+0xfb0fe124>
8111e490:	21000084 	addi	r4,r4,2
8111e494:	003ebc06 	br	8111df88 <__reset+0xfb0fdf88>
8111e498:	8085883a 	add	r2,r16,r2
8111e49c:	10c00117 	ldw	r3,4(r2)
8111e4a0:	81000317 	ldw	r4,12(r16)
8111e4a4:	81400217 	ldw	r5,8(r16)
8111e4a8:	18c00054 	ori	r3,r3,1
8111e4ac:	10c00115 	stw	r3,4(r2)
8111e4b0:	29000315 	stw	r4,12(r5)
8111e4b4:	21400215 	stw	r5,8(r4)
8111e4b8:	9009883a 	mov	r4,r18
8111e4bc:	1134dd40 	call	81134dd4 <__malloc_unlock>
8111e4c0:	80800204 	addi	r2,r16,8
8111e4c4:	003f2506 	br	8111e15c <__reset+0xfb0fe15c>
8111e4c8:	12001704 	addi	r8,r2,92
8111e4cc:	11c016c4 	addi	r7,r2,91
8111e4d0:	4209883a 	add	r4,r8,r8
8111e4d4:	003e9606 	br	8111df30 <__reset+0xfb0fdf30>
8111e4d8:	3804d1ba 	srli	r2,r7,6
8111e4dc:	11400e44 	addi	r5,r2,57
8111e4e0:	10c00e04 	addi	r3,r2,56
8111e4e4:	294b883a 	add	r5,r5,r5
8111e4e8:	003fbc06 	br	8111e3dc <__reset+0xfb0fe3dc>
8111e4ec:	84ff5926 	beq	r16,r19,8111e254 <__reset+0xfb0fe254>
8111e4f0:	00a04574 	movhi	r2,33045
8111e4f4:	10b72104 	addi	r2,r2,-9084
8111e4f8:	14000217 	ldw	r16,8(r2)
8111e4fc:	00bfff04 	movi	r2,-4
8111e500:	80c00117 	ldw	r3,4(r16)
8111e504:	1886703a 	and	r3,r3,r2
8111e508:	003f9106 	br	8111e350 <__reset+0xfb0fe350>
8111e50c:	60800217 	ldw	r2,8(r12)
8111e510:	213fffc4 	addi	r4,r4,-1
8111e514:	1300651e 	bne	r2,r12,8111e6ac <_malloc_r+0x7fc>
8111e518:	208000cc 	andi	r2,r4,3
8111e51c:	633ffe04 	addi	r12,r12,-8
8111e520:	103ffa1e 	bne	r2,zero,8111e50c <__reset+0xfb0fe50c>
8111e524:	98800117 	ldw	r2,4(r19)
8111e528:	0146303a 	nor	r3,zero,r5
8111e52c:	1884703a 	and	r2,r3,r2
8111e530:	98800115 	stw	r2,4(r19)
8111e534:	294b883a 	add	r5,r5,r5
8111e538:	117f2836 	bltu	r2,r5,8111e1dc <__reset+0xfb0fe1dc>
8111e53c:	283f2726 	beq	r5,zero,8111e1dc <__reset+0xfb0fe1dc>
8111e540:	2886703a 	and	r3,r5,r2
8111e544:	5809883a 	mov	r4,r11
8111e548:	183ec31e 	bne	r3,zero,8111e058 <__reset+0xfb0fe058>
8111e54c:	294b883a 	add	r5,r5,r5
8111e550:	2886703a 	and	r3,r5,r2
8111e554:	21000104 	addi	r4,r4,4
8111e558:	183ffc26 	beq	r3,zero,8111e54c <__reset+0xfb0fe54c>
8111e55c:	003ebe06 	br	8111e058 <__reset+0xfb0fe058>
8111e560:	00c05504 	movi	r3,340
8111e564:	18801236 	bltu	r3,r2,8111e5b0 <_malloc_r+0x700>
8111e568:	8804d3fa 	srli	r2,r17,15
8111e56c:	12001e04 	addi	r8,r2,120
8111e570:	11c01dc4 	addi	r7,r2,119
8111e574:	4209883a 	add	r4,r8,r8
8111e578:	003e6d06 	br	8111df30 <__reset+0xfb0fdf30>
8111e57c:	00c40004 	movi	r3,4096
8111e580:	003f4606 	br	8111e29c <__reset+0xfb0fe29c>
8111e584:	00800044 	movi	r2,1
8111e588:	a0800115 	stw	r2,4(r20)
8111e58c:	003f7406 	br	8111e360 <__reset+0xfb0fe360>
8111e590:	1805d0ba 	srai	r2,r3,2
8111e594:	01c00044 	movi	r7,1
8111e598:	30c00117 	ldw	r3,4(r6)
8111e59c:	388e983a 	sll	r7,r7,r2
8111e5a0:	2805883a 	mov	r2,r5
8111e5a4:	38c6b03a 	or	r3,r7,r3
8111e5a8:	30c00115 	stw	r3,4(r6)
8111e5ac:	003f9b06 	br	8111e41c <__reset+0xfb0fe41c>
8111e5b0:	00c15504 	movi	r3,1364
8111e5b4:	18801a36 	bltu	r3,r2,8111e620 <_malloc_r+0x770>
8111e5b8:	8804d4ba 	srli	r2,r17,18
8111e5bc:	12001f44 	addi	r8,r2,125
8111e5c0:	11c01f04 	addi	r7,r2,124
8111e5c4:	4209883a 	add	r4,r8,r8
8111e5c8:	003e5906 	br	8111df30 <__reset+0xfb0fdf30>
8111e5cc:	ad400404 	addi	r21,r21,16
8111e5d0:	003f1706 	br	8111e230 <__reset+0xfb0fe230>
8111e5d4:	00c01504 	movi	r3,84
8111e5d8:	18802336 	bltu	r3,r2,8111e668 <_malloc_r+0x7b8>
8111e5dc:	3804d33a 	srli	r2,r7,12
8111e5e0:	11401bc4 	addi	r5,r2,111
8111e5e4:	10c01b84 	addi	r3,r2,110
8111e5e8:	294b883a 	add	r5,r5,r5
8111e5ec:	003f7b06 	br	8111e3dc <__reset+0xfb0fe3dc>
8111e5f0:	9c000217 	ldw	r16,8(r19)
8111e5f4:	00bfff04 	movi	r2,-4
8111e5f8:	80c00117 	ldw	r3,4(r16)
8111e5fc:	1886703a 	and	r3,r3,r2
8111e600:	003f5306 	br	8111e350 <__reset+0xfb0fe350>
8111e604:	3083ffcc 	andi	r2,r6,4095
8111e608:	103f181e 	bne	r2,zero,8111e26c <__reset+0xfb0fe26c>
8111e60c:	99000217 	ldw	r4,8(r19)
8111e610:	b545883a 	add	r2,r22,r21
8111e614:	10800054 	ori	r2,r2,1
8111e618:	20800115 	stw	r2,4(r4)
8111e61c:	003f3e06 	br	8111e318 <__reset+0xfb0fe318>
8111e620:	01003f84 	movi	r4,254
8111e624:	02001fc4 	movi	r8,127
8111e628:	01c01f84 	movi	r7,126
8111e62c:	003e4006 	br	8111df30 <__reset+0xfb0fdf30>
8111e630:	00a04574 	movhi	r2,33045
8111e634:	10bd6404 	addi	r2,r2,-2672
8111e638:	15000015 	stw	r20,0(r2)
8111e63c:	003f1106 	br	8111e284 <__reset+0xfb0fe284>
8111e640:	00800044 	movi	r2,1
8111e644:	002b883a 	mov	r21,zero
8111e648:	003f1f06 	br	8111e2c8 <__reset+0xfb0fe2c8>
8111e64c:	81400204 	addi	r5,r16,8
8111e650:	9009883a 	mov	r4,r18
8111e654:	11279240 	call	81127924 <_free_r>
8111e658:	00a04574 	movhi	r2,33045
8111e65c:	10be6504 	addi	r2,r2,-1644
8111e660:	10c00017 	ldw	r3,0(r2)
8111e664:	003f2c06 	br	8111e318 <__reset+0xfb0fe318>
8111e668:	00c05504 	movi	r3,340
8111e66c:	18800536 	bltu	r3,r2,8111e684 <_malloc_r+0x7d4>
8111e670:	3804d3fa 	srli	r2,r7,15
8111e674:	11401e04 	addi	r5,r2,120
8111e678:	10c01dc4 	addi	r3,r2,119
8111e67c:	294b883a 	add	r5,r5,r5
8111e680:	003f5606 	br	8111e3dc <__reset+0xfb0fe3dc>
8111e684:	00c15504 	movi	r3,1364
8111e688:	18800536 	bltu	r3,r2,8111e6a0 <_malloc_r+0x7f0>
8111e68c:	3804d4ba 	srli	r2,r7,18
8111e690:	11401f44 	addi	r5,r2,125
8111e694:	10c01f04 	addi	r3,r2,124
8111e698:	294b883a 	add	r5,r5,r5
8111e69c:	003f4f06 	br	8111e3dc <__reset+0xfb0fe3dc>
8111e6a0:	01403f84 	movi	r5,254
8111e6a4:	00c01f84 	movi	r3,126
8111e6a8:	003f4c06 	br	8111e3dc <__reset+0xfb0fe3dc>
8111e6ac:	98800117 	ldw	r2,4(r19)
8111e6b0:	003fa006 	br	8111e534 <__reset+0xfb0fe534>
8111e6b4:	8808d0fa 	srli	r4,r17,3
8111e6b8:	20800044 	addi	r2,r4,1
8111e6bc:	1085883a 	add	r2,r2,r2
8111e6c0:	003e9006 	br	8111e104 <__reset+0xfb0fe104>

8111e6c4 <memcpy>:
8111e6c4:	defffd04 	addi	sp,sp,-12
8111e6c8:	de00012e 	bgeu	sp,et,8111e6d0 <memcpy+0xc>
8111e6cc:	003b68fa 	trap	3
8111e6d0:	00c003c4 	movi	r3,15
8111e6d4:	dfc00215 	stw	ra,8(sp)
8111e6d8:	dc400115 	stw	r17,4(sp)
8111e6dc:	dc000015 	stw	r16,0(sp)
8111e6e0:	2005883a 	mov	r2,r4
8111e6e4:	1980452e 	bgeu	r3,r6,8111e7fc <memcpy+0x138>
8111e6e8:	2906b03a 	or	r3,r5,r4
8111e6ec:	18c000cc 	andi	r3,r3,3
8111e6f0:	1800441e 	bne	r3,zero,8111e804 <memcpy+0x140>
8111e6f4:	347ffc04 	addi	r17,r6,-16
8111e6f8:	8822d13a 	srli	r17,r17,4
8111e6fc:	28c00104 	addi	r3,r5,4
8111e700:	23400104 	addi	r13,r4,4
8111e704:	8820913a 	slli	r16,r17,4
8111e708:	2b000204 	addi	r12,r5,8
8111e70c:	22c00204 	addi	r11,r4,8
8111e710:	84000504 	addi	r16,r16,20
8111e714:	2a800304 	addi	r10,r5,12
8111e718:	22400304 	addi	r9,r4,12
8111e71c:	2c21883a 	add	r16,r5,r16
8111e720:	2811883a 	mov	r8,r5
8111e724:	200f883a 	mov	r7,r4
8111e728:	41000017 	ldw	r4,0(r8)
8111e72c:	1fc00017 	ldw	ra,0(r3)
8111e730:	63c00017 	ldw	r15,0(r12)
8111e734:	39000015 	stw	r4,0(r7)
8111e738:	53800017 	ldw	r14,0(r10)
8111e73c:	6fc00015 	stw	ra,0(r13)
8111e740:	5bc00015 	stw	r15,0(r11)
8111e744:	4b800015 	stw	r14,0(r9)
8111e748:	18c00404 	addi	r3,r3,16
8111e74c:	39c00404 	addi	r7,r7,16
8111e750:	42000404 	addi	r8,r8,16
8111e754:	6b400404 	addi	r13,r13,16
8111e758:	63000404 	addi	r12,r12,16
8111e75c:	5ac00404 	addi	r11,r11,16
8111e760:	52800404 	addi	r10,r10,16
8111e764:	4a400404 	addi	r9,r9,16
8111e768:	1c3fef1e 	bne	r3,r16,8111e728 <__reset+0xfb0fe728>
8111e76c:	89c00044 	addi	r7,r17,1
8111e770:	380e913a 	slli	r7,r7,4
8111e774:	310003cc 	andi	r4,r6,15
8111e778:	02c000c4 	movi	r11,3
8111e77c:	11c7883a 	add	r3,r2,r7
8111e780:	29cb883a 	add	r5,r5,r7
8111e784:	5900212e 	bgeu	r11,r4,8111e80c <memcpy+0x148>
8111e788:	1813883a 	mov	r9,r3
8111e78c:	2811883a 	mov	r8,r5
8111e790:	200f883a 	mov	r7,r4
8111e794:	42800017 	ldw	r10,0(r8)
8111e798:	4a400104 	addi	r9,r9,4
8111e79c:	39ffff04 	addi	r7,r7,-4
8111e7a0:	4abfff15 	stw	r10,-4(r9)
8111e7a4:	42000104 	addi	r8,r8,4
8111e7a8:	59fffa36 	bltu	r11,r7,8111e794 <__reset+0xfb0fe794>
8111e7ac:	213fff04 	addi	r4,r4,-4
8111e7b0:	2008d0ba 	srli	r4,r4,2
8111e7b4:	318000cc 	andi	r6,r6,3
8111e7b8:	21000044 	addi	r4,r4,1
8111e7bc:	2109883a 	add	r4,r4,r4
8111e7c0:	2109883a 	add	r4,r4,r4
8111e7c4:	1907883a 	add	r3,r3,r4
8111e7c8:	290b883a 	add	r5,r5,r4
8111e7cc:	30000626 	beq	r6,zero,8111e7e8 <memcpy+0x124>
8111e7d0:	198d883a 	add	r6,r3,r6
8111e7d4:	29c00003 	ldbu	r7,0(r5)
8111e7d8:	18c00044 	addi	r3,r3,1
8111e7dc:	29400044 	addi	r5,r5,1
8111e7e0:	19ffffc5 	stb	r7,-1(r3)
8111e7e4:	19bffb1e 	bne	r3,r6,8111e7d4 <__reset+0xfb0fe7d4>
8111e7e8:	dfc00217 	ldw	ra,8(sp)
8111e7ec:	dc400117 	ldw	r17,4(sp)
8111e7f0:	dc000017 	ldw	r16,0(sp)
8111e7f4:	dec00304 	addi	sp,sp,12
8111e7f8:	f800283a 	ret
8111e7fc:	2007883a 	mov	r3,r4
8111e800:	003ff206 	br	8111e7cc <__reset+0xfb0fe7cc>
8111e804:	2007883a 	mov	r3,r4
8111e808:	003ff106 	br	8111e7d0 <__reset+0xfb0fe7d0>
8111e80c:	200d883a 	mov	r6,r4
8111e810:	003fee06 	br	8111e7cc <__reset+0xfb0fe7cc>

8111e814 <memset>:
8111e814:	20c000cc 	andi	r3,r4,3
8111e818:	2005883a 	mov	r2,r4
8111e81c:	18004426 	beq	r3,zero,8111e930 <memset+0x11c>
8111e820:	31ffffc4 	addi	r7,r6,-1
8111e824:	30004026 	beq	r6,zero,8111e928 <memset+0x114>
8111e828:	2813883a 	mov	r9,r5
8111e82c:	200d883a 	mov	r6,r4
8111e830:	2007883a 	mov	r3,r4
8111e834:	00000406 	br	8111e848 <memset+0x34>
8111e838:	3a3fffc4 	addi	r8,r7,-1
8111e83c:	31800044 	addi	r6,r6,1
8111e840:	38003926 	beq	r7,zero,8111e928 <memset+0x114>
8111e844:	400f883a 	mov	r7,r8
8111e848:	18c00044 	addi	r3,r3,1
8111e84c:	32400005 	stb	r9,0(r6)
8111e850:	1a0000cc 	andi	r8,r3,3
8111e854:	403ff81e 	bne	r8,zero,8111e838 <__reset+0xfb0fe838>
8111e858:	010000c4 	movi	r4,3
8111e85c:	21c02d2e 	bgeu	r4,r7,8111e914 <memset+0x100>
8111e860:	29003fcc 	andi	r4,r5,255
8111e864:	200c923a 	slli	r6,r4,8
8111e868:	3108b03a 	or	r4,r6,r4
8111e86c:	200c943a 	slli	r6,r4,16
8111e870:	218cb03a 	or	r6,r4,r6
8111e874:	010003c4 	movi	r4,15
8111e878:	21c0182e 	bgeu	r4,r7,8111e8dc <memset+0xc8>
8111e87c:	3b3ffc04 	addi	r12,r7,-16
8111e880:	6018d13a 	srli	r12,r12,4
8111e884:	1a000104 	addi	r8,r3,4
8111e888:	1ac00204 	addi	r11,r3,8
8111e88c:	6008913a 	slli	r4,r12,4
8111e890:	1a800304 	addi	r10,r3,12
8111e894:	1813883a 	mov	r9,r3
8111e898:	21000504 	addi	r4,r4,20
8111e89c:	1909883a 	add	r4,r3,r4
8111e8a0:	49800015 	stw	r6,0(r9)
8111e8a4:	41800015 	stw	r6,0(r8)
8111e8a8:	59800015 	stw	r6,0(r11)
8111e8ac:	51800015 	stw	r6,0(r10)
8111e8b0:	42000404 	addi	r8,r8,16
8111e8b4:	4a400404 	addi	r9,r9,16
8111e8b8:	5ac00404 	addi	r11,r11,16
8111e8bc:	52800404 	addi	r10,r10,16
8111e8c0:	413ff71e 	bne	r8,r4,8111e8a0 <__reset+0xfb0fe8a0>
8111e8c4:	63000044 	addi	r12,r12,1
8111e8c8:	6018913a 	slli	r12,r12,4
8111e8cc:	39c003cc 	andi	r7,r7,15
8111e8d0:	010000c4 	movi	r4,3
8111e8d4:	1b07883a 	add	r3,r3,r12
8111e8d8:	21c00e2e 	bgeu	r4,r7,8111e914 <memset+0x100>
8111e8dc:	1813883a 	mov	r9,r3
8111e8e0:	3811883a 	mov	r8,r7
8111e8e4:	010000c4 	movi	r4,3
8111e8e8:	49800015 	stw	r6,0(r9)
8111e8ec:	423fff04 	addi	r8,r8,-4
8111e8f0:	4a400104 	addi	r9,r9,4
8111e8f4:	223ffc36 	bltu	r4,r8,8111e8e8 <__reset+0xfb0fe8e8>
8111e8f8:	393fff04 	addi	r4,r7,-4
8111e8fc:	2008d0ba 	srli	r4,r4,2
8111e900:	39c000cc 	andi	r7,r7,3
8111e904:	21000044 	addi	r4,r4,1
8111e908:	2109883a 	add	r4,r4,r4
8111e90c:	2109883a 	add	r4,r4,r4
8111e910:	1907883a 	add	r3,r3,r4
8111e914:	38000526 	beq	r7,zero,8111e92c <memset+0x118>
8111e918:	19cf883a 	add	r7,r3,r7
8111e91c:	19400005 	stb	r5,0(r3)
8111e920:	18c00044 	addi	r3,r3,1
8111e924:	38fffd1e 	bne	r7,r3,8111e91c <__reset+0xfb0fe91c>
8111e928:	f800283a 	ret
8111e92c:	f800283a 	ret
8111e930:	2007883a 	mov	r3,r4
8111e934:	300f883a 	mov	r7,r6
8111e938:	003fc706 	br	8111e858 <__reset+0xfb0fe858>

8111e93c <_open_r>:
8111e93c:	defffd04 	addi	sp,sp,-12
8111e940:	de00012e 	bgeu	sp,et,8111e948 <_open_r+0xc>
8111e944:	003b68fa 	trap	3
8111e948:	2805883a 	mov	r2,r5
8111e94c:	dc000015 	stw	r16,0(sp)
8111e950:	04204574 	movhi	r16,33045
8111e954:	dc400115 	stw	r17,4(sp)
8111e958:	300b883a 	mov	r5,r6
8111e95c:	843dd504 	addi	r16,r16,-2220
8111e960:	2023883a 	mov	r17,r4
8111e964:	380d883a 	mov	r6,r7
8111e968:	1009883a 	mov	r4,r2
8111e96c:	dfc00215 	stw	ra,8(sp)
8111e970:	80000015 	stw	zero,0(r16)
8111e974:	113432c0 	call	8113432c <open>
8111e978:	00ffffc4 	movi	r3,-1
8111e97c:	10c00526 	beq	r2,r3,8111e994 <_open_r+0x58>
8111e980:	dfc00217 	ldw	ra,8(sp)
8111e984:	dc400117 	ldw	r17,4(sp)
8111e988:	dc000017 	ldw	r16,0(sp)
8111e98c:	dec00304 	addi	sp,sp,12
8111e990:	f800283a 	ret
8111e994:	80c00017 	ldw	r3,0(r16)
8111e998:	183ff926 	beq	r3,zero,8111e980 <__reset+0xfb0fe980>
8111e99c:	88c00015 	stw	r3,0(r17)
8111e9a0:	003ff706 	br	8111e980 <__reset+0xfb0fe980>

8111e9a4 <_printf_r>:
8111e9a4:	defffd04 	addi	sp,sp,-12
8111e9a8:	2805883a 	mov	r2,r5
8111e9ac:	de00012e 	bgeu	sp,et,8111e9b4 <_printf_r+0x10>
8111e9b0:	003b68fa 	trap	3
8111e9b4:	dfc00015 	stw	ra,0(sp)
8111e9b8:	d9800115 	stw	r6,4(sp)
8111e9bc:	d9c00215 	stw	r7,8(sp)
8111e9c0:	21400217 	ldw	r5,8(r4)
8111e9c4:	d9c00104 	addi	r7,sp,4
8111e9c8:	100d883a 	mov	r6,r2
8111e9cc:	11216d00 	call	811216d0 <___vfprintf_internal_r>
8111e9d0:	dfc00017 	ldw	ra,0(sp)
8111e9d4:	dec00304 	addi	sp,sp,12
8111e9d8:	f800283a 	ret

8111e9dc <printf>:
8111e9dc:	defffc04 	addi	sp,sp,-16
8111e9e0:	de00012e 	bgeu	sp,et,8111e9e8 <printf+0xc>
8111e9e4:	003b68fa 	trap	3
8111e9e8:	dfc00015 	stw	ra,0(sp)
8111e9ec:	d9400115 	stw	r5,4(sp)
8111e9f0:	d9800215 	stw	r6,8(sp)
8111e9f4:	d9c00315 	stw	r7,12(sp)
8111e9f8:	00a04574 	movhi	r2,33045
8111e9fc:	10bd6304 	addi	r2,r2,-2676
8111ea00:	10800017 	ldw	r2,0(r2)
8111ea04:	200b883a 	mov	r5,r4
8111ea08:	d9800104 	addi	r6,sp,4
8111ea0c:	11000217 	ldw	r4,8(r2)
8111ea10:	11238d00 	call	811238d0 <__vfprintf_internal>
8111ea14:	dfc00017 	ldw	ra,0(sp)
8111ea18:	dec00404 	addi	sp,sp,16
8111ea1c:	f800283a 	ret

8111ea20 <_putc_r>:
8111ea20:	defffc04 	addi	sp,sp,-16
8111ea24:	de00012e 	bgeu	sp,et,8111ea2c <_putc_r+0xc>
8111ea28:	003b68fa 	trap	3
8111ea2c:	dc000215 	stw	r16,8(sp)
8111ea30:	dfc00315 	stw	ra,12(sp)
8111ea34:	2021883a 	mov	r16,r4
8111ea38:	20000226 	beq	r4,zero,8111ea44 <_putc_r+0x24>
8111ea3c:	20800e17 	ldw	r2,56(r4)
8111ea40:	10001b26 	beq	r2,zero,8111eab0 <_putc_r+0x90>
8111ea44:	30800217 	ldw	r2,8(r6)
8111ea48:	10bfffc4 	addi	r2,r2,-1
8111ea4c:	30800215 	stw	r2,8(r6)
8111ea50:	10000a16 	blt	r2,zero,8111ea7c <_putc_r+0x5c>
8111ea54:	30800017 	ldw	r2,0(r6)
8111ea58:	11400005 	stb	r5,0(r2)
8111ea5c:	30800017 	ldw	r2,0(r6)
8111ea60:	10c00044 	addi	r3,r2,1
8111ea64:	30c00015 	stw	r3,0(r6)
8111ea68:	10800003 	ldbu	r2,0(r2)
8111ea6c:	dfc00317 	ldw	ra,12(sp)
8111ea70:	dc000217 	ldw	r16,8(sp)
8111ea74:	dec00404 	addi	sp,sp,16
8111ea78:	f800283a 	ret
8111ea7c:	30c00617 	ldw	r3,24(r6)
8111ea80:	10c00616 	blt	r2,r3,8111ea9c <_putc_r+0x7c>
8111ea84:	30800017 	ldw	r2,0(r6)
8111ea88:	00c00284 	movi	r3,10
8111ea8c:	11400005 	stb	r5,0(r2)
8111ea90:	30800017 	ldw	r2,0(r6)
8111ea94:	11400003 	ldbu	r5,0(r2)
8111ea98:	28fff11e 	bne	r5,r3,8111ea60 <__reset+0xfb0fea60>
8111ea9c:	8009883a 	mov	r4,r16
8111eaa0:	dfc00317 	ldw	ra,12(sp)
8111eaa4:	dc000217 	ldw	r16,8(sp)
8111eaa8:	dec00404 	addi	sp,sp,16
8111eaac:	11252541 	jmpi	81125254 <__swbuf_r>
8111eab0:	d9400015 	stw	r5,0(sp)
8111eab4:	d9800115 	stw	r6,4(sp)
8111eab8:	112748c0 	call	8112748c <__sinit>
8111eabc:	d9800117 	ldw	r6,4(sp)
8111eac0:	d9400017 	ldw	r5,0(sp)
8111eac4:	003fdf06 	br	8111ea44 <__reset+0xfb0fea44>

8111eac8 <putc>:
8111eac8:	00a04574 	movhi	r2,33045
8111eacc:	defffc04 	addi	sp,sp,-16
8111ead0:	10bd6304 	addi	r2,r2,-2676
8111ead4:	de00012e 	bgeu	sp,et,8111eadc <putc+0x14>
8111ead8:	003b68fa 	trap	3
8111eadc:	dc000115 	stw	r16,4(sp)
8111eae0:	14000017 	ldw	r16,0(r2)
8111eae4:	dc400215 	stw	r17,8(sp)
8111eae8:	dfc00315 	stw	ra,12(sp)
8111eaec:	2023883a 	mov	r17,r4
8111eaf0:	80000226 	beq	r16,zero,8111eafc <putc+0x34>
8111eaf4:	80800e17 	ldw	r2,56(r16)
8111eaf8:	10001a26 	beq	r2,zero,8111eb64 <putc+0x9c>
8111eafc:	28800217 	ldw	r2,8(r5)
8111eb00:	10bfffc4 	addi	r2,r2,-1
8111eb04:	28800215 	stw	r2,8(r5)
8111eb08:	10000b16 	blt	r2,zero,8111eb38 <putc+0x70>
8111eb0c:	28800017 	ldw	r2,0(r5)
8111eb10:	14400005 	stb	r17,0(r2)
8111eb14:	28800017 	ldw	r2,0(r5)
8111eb18:	10c00044 	addi	r3,r2,1
8111eb1c:	28c00015 	stw	r3,0(r5)
8111eb20:	10800003 	ldbu	r2,0(r2)
8111eb24:	dfc00317 	ldw	ra,12(sp)
8111eb28:	dc400217 	ldw	r17,8(sp)
8111eb2c:	dc000117 	ldw	r16,4(sp)
8111eb30:	dec00404 	addi	sp,sp,16
8111eb34:	f800283a 	ret
8111eb38:	28c00617 	ldw	r3,24(r5)
8111eb3c:	10c00e16 	blt	r2,r3,8111eb78 <putc+0xb0>
8111eb40:	28800017 	ldw	r2,0(r5)
8111eb44:	01000284 	movi	r4,10
8111eb48:	14400005 	stb	r17,0(r2)
8111eb4c:	28800017 	ldw	r2,0(r5)
8111eb50:	10c00003 	ldbu	r3,0(r2)
8111eb54:	193ff01e 	bne	r3,r4,8111eb18 <__reset+0xfb0feb18>
8111eb58:	280d883a 	mov	r6,r5
8111eb5c:	180b883a 	mov	r5,r3
8111eb60:	00000706 	br	8111eb80 <putc+0xb8>
8111eb64:	8009883a 	mov	r4,r16
8111eb68:	d9400015 	stw	r5,0(sp)
8111eb6c:	112748c0 	call	8112748c <__sinit>
8111eb70:	d9400017 	ldw	r5,0(sp)
8111eb74:	003fe106 	br	8111eafc <__reset+0xfb0feafc>
8111eb78:	280d883a 	mov	r6,r5
8111eb7c:	880b883a 	mov	r5,r17
8111eb80:	8009883a 	mov	r4,r16
8111eb84:	dfc00317 	ldw	ra,12(sp)
8111eb88:	dc400217 	ldw	r17,8(sp)
8111eb8c:	dc000117 	ldw	r16,4(sp)
8111eb90:	dec00404 	addi	sp,sp,16
8111eb94:	11252541 	jmpi	81125254 <__swbuf_r>

8111eb98 <_puts_r>:
8111eb98:	defff604 	addi	sp,sp,-40
8111eb9c:	de00012e 	bgeu	sp,et,8111eba4 <_puts_r+0xc>
8111eba0:	003b68fa 	trap	3
8111eba4:	dc000715 	stw	r16,28(sp)
8111eba8:	2021883a 	mov	r16,r4
8111ebac:	2809883a 	mov	r4,r5
8111ebb0:	dc400815 	stw	r17,32(sp)
8111ebb4:	dfc00915 	stw	ra,36(sp)
8111ebb8:	2823883a 	mov	r17,r5
8111ebbc:	111f1b80 	call	8111f1b8 <strlen>
8111ebc0:	10c00044 	addi	r3,r2,1
8111ebc4:	d8800115 	stw	r2,4(sp)
8111ebc8:	00a04574 	movhi	r2,33045
8111ebcc:	10b38a04 	addi	r2,r2,-12760
8111ebd0:	d8800215 	stw	r2,8(sp)
8111ebd4:	00800044 	movi	r2,1
8111ebd8:	d8800315 	stw	r2,12(sp)
8111ebdc:	00800084 	movi	r2,2
8111ebe0:	dc400015 	stw	r17,0(sp)
8111ebe4:	d8c00615 	stw	r3,24(sp)
8111ebe8:	dec00415 	stw	sp,16(sp)
8111ebec:	d8800515 	stw	r2,20(sp)
8111ebf0:	80000226 	beq	r16,zero,8111ebfc <_puts_r+0x64>
8111ebf4:	80800e17 	ldw	r2,56(r16)
8111ebf8:	10001426 	beq	r2,zero,8111ec4c <_puts_r+0xb4>
8111ebfc:	81400217 	ldw	r5,8(r16)
8111ec00:	2880030b 	ldhu	r2,12(r5)
8111ec04:	10c8000c 	andi	r3,r2,8192
8111ec08:	1800061e 	bne	r3,zero,8111ec24 <_puts_r+0x8c>
8111ec0c:	29001917 	ldw	r4,100(r5)
8111ec10:	00f7ffc4 	movi	r3,-8193
8111ec14:	10880014 	ori	r2,r2,8192
8111ec18:	20c6703a 	and	r3,r4,r3
8111ec1c:	2880030d 	sth	r2,12(r5)
8111ec20:	28c01915 	stw	r3,100(r5)
8111ec24:	d9800404 	addi	r6,sp,16
8111ec28:	8009883a 	mov	r4,r16
8111ec2c:	1127c3c0 	call	81127c3c <__sfvwrite_r>
8111ec30:	1000091e 	bne	r2,zero,8111ec58 <_puts_r+0xc0>
8111ec34:	00800284 	movi	r2,10
8111ec38:	dfc00917 	ldw	ra,36(sp)
8111ec3c:	dc400817 	ldw	r17,32(sp)
8111ec40:	dc000717 	ldw	r16,28(sp)
8111ec44:	dec00a04 	addi	sp,sp,40
8111ec48:	f800283a 	ret
8111ec4c:	8009883a 	mov	r4,r16
8111ec50:	112748c0 	call	8112748c <__sinit>
8111ec54:	003fe906 	br	8111ebfc <__reset+0xfb0febfc>
8111ec58:	00bfffc4 	movi	r2,-1
8111ec5c:	003ff606 	br	8111ec38 <__reset+0xfb0fec38>

8111ec60 <puts>:
8111ec60:	00a04574 	movhi	r2,33045
8111ec64:	10bd6304 	addi	r2,r2,-2676
8111ec68:	200b883a 	mov	r5,r4
8111ec6c:	11000017 	ldw	r4,0(r2)
8111ec70:	111eb981 	jmpi	8111eb98 <_puts_r>

8111ec74 <lflush>:
8111ec74:	2080030b 	ldhu	r2,12(r4)
8111ec78:	00c00244 	movi	r3,9
8111ec7c:	1080024c 	andi	r2,r2,9
8111ec80:	10c00226 	beq	r2,r3,8111ec8c <lflush+0x18>
8111ec84:	0005883a 	mov	r2,zero
8111ec88:	f800283a 	ret
8111ec8c:	11270f41 	jmpi	811270f4 <fflush>

8111ec90 <__srefill_r>:
8111ec90:	defffc04 	addi	sp,sp,-16
8111ec94:	de00012e 	bgeu	sp,et,8111ec9c <__srefill_r+0xc>
8111ec98:	003b68fa 	trap	3
8111ec9c:	dc400115 	stw	r17,4(sp)
8111eca0:	dc000015 	stw	r16,0(sp)
8111eca4:	dfc00315 	stw	ra,12(sp)
8111eca8:	dc800215 	stw	r18,8(sp)
8111ecac:	2023883a 	mov	r17,r4
8111ecb0:	2821883a 	mov	r16,r5
8111ecb4:	20000226 	beq	r4,zero,8111ecc0 <__srefill_r+0x30>
8111ecb8:	20800e17 	ldw	r2,56(r4)
8111ecbc:	10003c26 	beq	r2,zero,8111edb0 <__srefill_r+0x120>
8111ecc0:	80c0030b 	ldhu	r3,12(r16)
8111ecc4:	1908000c 	andi	r4,r3,8192
8111ecc8:	1805883a 	mov	r2,r3
8111eccc:	2000071e 	bne	r4,zero,8111ecec <__srefill_r+0x5c>
8111ecd0:	81001917 	ldw	r4,100(r16)
8111ecd4:	18880014 	ori	r2,r3,8192
8111ecd8:	00f7ffc4 	movi	r3,-8193
8111ecdc:	20c8703a 	and	r4,r4,r3
8111ece0:	8080030d 	sth	r2,12(r16)
8111ece4:	1007883a 	mov	r3,r2
8111ece8:	81001915 	stw	r4,100(r16)
8111ecec:	80000115 	stw	zero,4(r16)
8111ecf0:	1100080c 	andi	r4,r2,32
8111ecf4:	2000571e 	bne	r4,zero,8111ee54 <__srefill_r+0x1c4>
8111ecf8:	1100010c 	andi	r4,r2,4
8111ecfc:	20001f26 	beq	r4,zero,8111ed7c <__srefill_r+0xec>
8111ed00:	81400c17 	ldw	r5,48(r16)
8111ed04:	28000826 	beq	r5,zero,8111ed28 <__srefill_r+0x98>
8111ed08:	80801004 	addi	r2,r16,64
8111ed0c:	28800226 	beq	r5,r2,8111ed18 <__srefill_r+0x88>
8111ed10:	8809883a 	mov	r4,r17
8111ed14:	11279240 	call	81127924 <_free_r>
8111ed18:	80800f17 	ldw	r2,60(r16)
8111ed1c:	80000c15 	stw	zero,48(r16)
8111ed20:	80800115 	stw	r2,4(r16)
8111ed24:	1000391e 	bne	r2,zero,8111ee0c <__srefill_r+0x17c>
8111ed28:	80800417 	ldw	r2,16(r16)
8111ed2c:	10004b26 	beq	r2,zero,8111ee5c <__srefill_r+0x1cc>
8111ed30:	8480030b 	ldhu	r18,12(r16)
8111ed34:	908000cc 	andi	r2,r18,3
8111ed38:	10001f1e 	bne	r2,zero,8111edb8 <__srefill_r+0x128>
8111ed3c:	81800417 	ldw	r6,16(r16)
8111ed40:	80800817 	ldw	r2,32(r16)
8111ed44:	81c00517 	ldw	r7,20(r16)
8111ed48:	81400717 	ldw	r5,28(r16)
8111ed4c:	81800015 	stw	r6,0(r16)
8111ed50:	8809883a 	mov	r4,r17
8111ed54:	103ee83a 	callr	r2
8111ed58:	80800115 	stw	r2,4(r16)
8111ed5c:	00800e0e 	bge	zero,r2,8111ed98 <__srefill_r+0x108>
8111ed60:	0005883a 	mov	r2,zero
8111ed64:	dfc00317 	ldw	ra,12(sp)
8111ed68:	dc800217 	ldw	r18,8(sp)
8111ed6c:	dc400117 	ldw	r17,4(sp)
8111ed70:	dc000017 	ldw	r16,0(sp)
8111ed74:	dec00404 	addi	sp,sp,16
8111ed78:	f800283a 	ret
8111ed7c:	1100040c 	andi	r4,r2,16
8111ed80:	20003026 	beq	r4,zero,8111ee44 <__srefill_r+0x1b4>
8111ed84:	1080020c 	andi	r2,r2,8
8111ed88:	1000241e 	bne	r2,zero,8111ee1c <__srefill_r+0x18c>
8111ed8c:	18c00114 	ori	r3,r3,4
8111ed90:	80c0030d 	sth	r3,12(r16)
8111ed94:	003fe406 	br	8111ed28 <__reset+0xfb0fed28>
8111ed98:	80c0030b 	ldhu	r3,12(r16)
8111ed9c:	1000161e 	bne	r2,zero,8111edf8 <__srefill_r+0x168>
8111eda0:	18c00814 	ori	r3,r3,32
8111eda4:	00bfffc4 	movi	r2,-1
8111eda8:	80c0030d 	sth	r3,12(r16)
8111edac:	003fed06 	br	8111ed64 <__reset+0xfb0fed64>
8111edb0:	112748c0 	call	8112748c <__sinit>
8111edb4:	003fc206 	br	8111ecc0 <__reset+0xfb0fecc0>
8111edb8:	00a04574 	movhi	r2,33045
8111edbc:	10bd6204 	addi	r2,r2,-2680
8111edc0:	11000017 	ldw	r4,0(r2)
8111edc4:	016044b4 	movhi	r5,33042
8111edc8:	00800044 	movi	r2,1
8111edcc:	297b1d04 	addi	r5,r5,-5004
8111edd0:	8080030d 	sth	r2,12(r16)
8111edd4:	11281000 	call	81128100 <_fwalk>
8111edd8:	00800244 	movi	r2,9
8111eddc:	8480030d 	sth	r18,12(r16)
8111ede0:	9480024c 	andi	r18,r18,9
8111ede4:	90bfd51e 	bne	r18,r2,8111ed3c <__reset+0xfb0fed3c>
8111ede8:	800b883a 	mov	r5,r16
8111edec:	8809883a 	mov	r4,r17
8111edf0:	1126e6c0 	call	81126e6c <__sflush_r>
8111edf4:	003fd106 	br	8111ed3c <__reset+0xfb0fed3c>
8111edf8:	18c01014 	ori	r3,r3,64
8111edfc:	80000115 	stw	zero,4(r16)
8111ee00:	00bfffc4 	movi	r2,-1
8111ee04:	80c0030d 	sth	r3,12(r16)
8111ee08:	003fd606 	br	8111ed64 <__reset+0xfb0fed64>
8111ee0c:	80c00e17 	ldw	r3,56(r16)
8111ee10:	0005883a 	mov	r2,zero
8111ee14:	80c00015 	stw	r3,0(r16)
8111ee18:	003fd206 	br	8111ed64 <__reset+0xfb0fed64>
8111ee1c:	800b883a 	mov	r5,r16
8111ee20:	8809883a 	mov	r4,r17
8111ee24:	11270900 	call	81127090 <_fflush_r>
8111ee28:	10000a1e 	bne	r2,zero,8111ee54 <__srefill_r+0x1c4>
8111ee2c:	8080030b 	ldhu	r2,12(r16)
8111ee30:	00fffdc4 	movi	r3,-9
8111ee34:	80000215 	stw	zero,8(r16)
8111ee38:	1886703a 	and	r3,r3,r2
8111ee3c:	80000615 	stw	zero,24(r16)
8111ee40:	003fd206 	br	8111ed8c <__reset+0xfb0fed8c>
8111ee44:	00800244 	movi	r2,9
8111ee48:	88800015 	stw	r2,0(r17)
8111ee4c:	18c01014 	ori	r3,r3,64
8111ee50:	80c0030d 	sth	r3,12(r16)
8111ee54:	00bfffc4 	movi	r2,-1
8111ee58:	003fc206 	br	8111ed64 <__reset+0xfb0fed64>
8111ee5c:	800b883a 	mov	r5,r16
8111ee60:	8809883a 	mov	r4,r17
8111ee64:	111dcec0 	call	8111dcec <__smakebuf_r>
8111ee68:	003fb106 	br	8111ed30 <__reset+0xfb0fed30>

8111ee6c <_sbrk_r>:
8111ee6c:	defffd04 	addi	sp,sp,-12
8111ee70:	de00012e 	bgeu	sp,et,8111ee78 <_sbrk_r+0xc>
8111ee74:	003b68fa 	trap	3
8111ee78:	dc000015 	stw	r16,0(sp)
8111ee7c:	04204574 	movhi	r16,33045
8111ee80:	dc400115 	stw	r17,4(sp)
8111ee84:	843dd504 	addi	r16,r16,-2220
8111ee88:	2023883a 	mov	r17,r4
8111ee8c:	2809883a 	mov	r4,r5
8111ee90:	dfc00215 	stw	ra,8(sp)
8111ee94:	80000015 	stw	zero,0(r16)
8111ee98:	113463c0 	call	8113463c <sbrk>
8111ee9c:	00ffffc4 	movi	r3,-1
8111eea0:	10c00526 	beq	r2,r3,8111eeb8 <_sbrk_r+0x4c>
8111eea4:	dfc00217 	ldw	ra,8(sp)
8111eea8:	dc400117 	ldw	r17,4(sp)
8111eeac:	dc000017 	ldw	r16,0(sp)
8111eeb0:	dec00304 	addi	sp,sp,12
8111eeb4:	f800283a 	ret
8111eeb8:	80c00017 	ldw	r3,0(r16)
8111eebc:	183ff926 	beq	r3,zero,8111eea4 <__reset+0xfb0feea4>
8111eec0:	88c00015 	stw	r3,0(r17)
8111eec4:	003ff706 	br	8111eea4 <__reset+0xfb0feea4>

8111eec8 <scanf>:
8111eec8:	defffc04 	addi	sp,sp,-16
8111eecc:	de00012e 	bgeu	sp,et,8111eed4 <scanf+0xc>
8111eed0:	003b68fa 	trap	3
8111eed4:	dfc00015 	stw	ra,0(sp)
8111eed8:	d9400115 	stw	r5,4(sp)
8111eedc:	d9800215 	stw	r6,8(sp)
8111eee0:	d9c00315 	stw	r7,12(sp)
8111eee4:	00a04574 	movhi	r2,33045
8111eee8:	10bd6304 	addi	r2,r2,-2676
8111eeec:	200d883a 	mov	r6,r4
8111eef0:	11000017 	ldw	r4,0(r2)
8111eef4:	d9c00104 	addi	r7,sp,4
8111eef8:	21400117 	ldw	r5,4(r4)
8111eefc:	11252000 	call	81125200 <_vfscanf_r>
8111ef00:	dfc00017 	ldw	ra,0(sp)
8111ef04:	dec00404 	addi	sp,sp,16
8111ef08:	f800283a 	ret

8111ef0c <_scanf_r>:
8111ef0c:	defffd04 	addi	sp,sp,-12
8111ef10:	2805883a 	mov	r2,r5
8111ef14:	de00012e 	bgeu	sp,et,8111ef1c <_scanf_r+0x10>
8111ef18:	003b68fa 	trap	3
8111ef1c:	dfc00015 	stw	ra,0(sp)
8111ef20:	d9800115 	stw	r6,4(sp)
8111ef24:	d9c00215 	stw	r7,8(sp)
8111ef28:	21400117 	ldw	r5,4(r4)
8111ef2c:	d9c00104 	addi	r7,sp,4
8111ef30:	100d883a 	mov	r6,r2
8111ef34:	11252000 	call	81125200 <_vfscanf_r>
8111ef38:	dfc00017 	ldw	ra,0(sp)
8111ef3c:	dec00304 	addi	sp,sp,12
8111ef40:	f800283a 	ret

8111ef44 <_sprintf_r>:
8111ef44:	deffe404 	addi	sp,sp,-112
8111ef48:	2807883a 	mov	r3,r5
8111ef4c:	de00012e 	bgeu	sp,et,8111ef54 <_sprintf_r+0x10>
8111ef50:	003b68fa 	trap	3
8111ef54:	dfc01a15 	stw	ra,104(sp)
8111ef58:	d9c01b15 	stw	r7,108(sp)
8111ef5c:	00a00034 	movhi	r2,32768
8111ef60:	10bfffc4 	addi	r2,r2,-1
8111ef64:	02008204 	movi	r8,520
8111ef68:	d8800215 	stw	r2,8(sp)
8111ef6c:	d8800515 	stw	r2,20(sp)
8111ef70:	d9c01b04 	addi	r7,sp,108
8111ef74:	d80b883a 	mov	r5,sp
8111ef78:	00bfffc4 	movi	r2,-1
8111ef7c:	d8c00015 	stw	r3,0(sp)
8111ef80:	d8c00415 	stw	r3,16(sp)
8111ef84:	da00030d 	sth	r8,12(sp)
8111ef88:	d880038d 	sth	r2,14(sp)
8111ef8c:	111f4f00 	call	8111f4f0 <___svfprintf_internal_r>
8111ef90:	d8c00017 	ldw	r3,0(sp)
8111ef94:	18000005 	stb	zero,0(r3)
8111ef98:	dfc01a17 	ldw	ra,104(sp)
8111ef9c:	dec01c04 	addi	sp,sp,112
8111efa0:	f800283a 	ret

8111efa4 <sprintf>:
8111efa4:	deffe304 	addi	sp,sp,-116
8111efa8:	2007883a 	mov	r3,r4
8111efac:	de00012e 	bgeu	sp,et,8111efb4 <sprintf+0x10>
8111efb0:	003b68fa 	trap	3
8111efb4:	dfc01a15 	stw	ra,104(sp)
8111efb8:	d9801b15 	stw	r6,108(sp)
8111efbc:	d9c01c15 	stw	r7,112(sp)
8111efc0:	01204574 	movhi	r4,33045
8111efc4:	213d6304 	addi	r4,r4,-2676
8111efc8:	21000017 	ldw	r4,0(r4)
8111efcc:	00a00034 	movhi	r2,32768
8111efd0:	10bfffc4 	addi	r2,r2,-1
8111efd4:	280d883a 	mov	r6,r5
8111efd8:	02008204 	movi	r8,520
8111efdc:	d8800215 	stw	r2,8(sp)
8111efe0:	d8800515 	stw	r2,20(sp)
8111efe4:	d9c01b04 	addi	r7,sp,108
8111efe8:	d80b883a 	mov	r5,sp
8111efec:	00bfffc4 	movi	r2,-1
8111eff0:	d8c00015 	stw	r3,0(sp)
8111eff4:	d8c00415 	stw	r3,16(sp)
8111eff8:	da00030d 	sth	r8,12(sp)
8111effc:	d880038d 	sth	r2,14(sp)
8111f000:	111f4f00 	call	8111f4f0 <___svfprintf_internal_r>
8111f004:	d8c00017 	ldw	r3,0(sp)
8111f008:	18000005 	stb	zero,0(r3)
8111f00c:	dfc01a17 	ldw	ra,104(sp)
8111f010:	dec01d04 	addi	sp,sp,116
8111f014:	f800283a 	ret

8111f018 <__sread>:
8111f018:	defffe04 	addi	sp,sp,-8
8111f01c:	de00012e 	bgeu	sp,et,8111f024 <__sread+0xc>
8111f020:	003b68fa 	trap	3
8111f024:	dc000015 	stw	r16,0(sp)
8111f028:	2821883a 	mov	r16,r5
8111f02c:	2940038f 	ldh	r5,14(r5)
8111f030:	dfc00115 	stw	ra,4(sp)
8111f034:	11299500 	call	81129950 <_read_r>
8111f038:	10000716 	blt	r2,zero,8111f058 <__sread+0x40>
8111f03c:	80c01417 	ldw	r3,80(r16)
8111f040:	1887883a 	add	r3,r3,r2
8111f044:	80c01415 	stw	r3,80(r16)
8111f048:	dfc00117 	ldw	ra,4(sp)
8111f04c:	dc000017 	ldw	r16,0(sp)
8111f050:	dec00204 	addi	sp,sp,8
8111f054:	f800283a 	ret
8111f058:	80c0030b 	ldhu	r3,12(r16)
8111f05c:	18fbffcc 	andi	r3,r3,61439
8111f060:	80c0030d 	sth	r3,12(r16)
8111f064:	dfc00117 	ldw	ra,4(sp)
8111f068:	dc000017 	ldw	r16,0(sp)
8111f06c:	dec00204 	addi	sp,sp,8
8111f070:	f800283a 	ret

8111f074 <__seofread>:
8111f074:	0005883a 	mov	r2,zero
8111f078:	f800283a 	ret

8111f07c <__swrite>:
8111f07c:	defffb04 	addi	sp,sp,-20
8111f080:	de00012e 	bgeu	sp,et,8111f088 <__swrite+0xc>
8111f084:	003b68fa 	trap	3
8111f088:	2880030b 	ldhu	r2,12(r5)
8111f08c:	dcc00315 	stw	r19,12(sp)
8111f090:	dc800215 	stw	r18,8(sp)
8111f094:	dc400115 	stw	r17,4(sp)
8111f098:	dc000015 	stw	r16,0(sp)
8111f09c:	dfc00415 	stw	ra,16(sp)
8111f0a0:	10c0400c 	andi	r3,r2,256
8111f0a4:	2821883a 	mov	r16,r5
8111f0a8:	2023883a 	mov	r17,r4
8111f0ac:	3025883a 	mov	r18,r6
8111f0b0:	3827883a 	mov	r19,r7
8111f0b4:	18000526 	beq	r3,zero,8111f0cc <__swrite+0x50>
8111f0b8:	2940038f 	ldh	r5,14(r5)
8111f0bc:	01c00084 	movi	r7,2
8111f0c0:	000d883a 	mov	r6,zero
8111f0c4:	11284080 	call	81128408 <_lseek_r>
8111f0c8:	8080030b 	ldhu	r2,12(r16)
8111f0cc:	8140038f 	ldh	r5,14(r16)
8111f0d0:	10bbffcc 	andi	r2,r2,61439
8111f0d4:	980f883a 	mov	r7,r19
8111f0d8:	900d883a 	mov	r6,r18
8111f0dc:	8809883a 	mov	r4,r17
8111f0e0:	8080030d 	sth	r2,12(r16)
8111f0e4:	dfc00417 	ldw	ra,16(sp)
8111f0e8:	dcc00317 	ldw	r19,12(sp)
8111f0ec:	dc800217 	ldw	r18,8(sp)
8111f0f0:	dc400117 	ldw	r17,4(sp)
8111f0f4:	dc000017 	ldw	r16,0(sp)
8111f0f8:	dec00504 	addi	sp,sp,20
8111f0fc:	11253b41 	jmpi	811253b4 <_write_r>

8111f100 <__sseek>:
8111f100:	defffe04 	addi	sp,sp,-8
8111f104:	de00012e 	bgeu	sp,et,8111f10c <__sseek+0xc>
8111f108:	003b68fa 	trap	3
8111f10c:	dc000015 	stw	r16,0(sp)
8111f110:	2821883a 	mov	r16,r5
8111f114:	2940038f 	ldh	r5,14(r5)
8111f118:	dfc00115 	stw	ra,4(sp)
8111f11c:	11284080 	call	81128408 <_lseek_r>
8111f120:	00ffffc4 	movi	r3,-1
8111f124:	10c00826 	beq	r2,r3,8111f148 <__sseek+0x48>
8111f128:	80c0030b 	ldhu	r3,12(r16)
8111f12c:	80801415 	stw	r2,80(r16)
8111f130:	18c40014 	ori	r3,r3,4096
8111f134:	80c0030d 	sth	r3,12(r16)
8111f138:	dfc00117 	ldw	ra,4(sp)
8111f13c:	dc000017 	ldw	r16,0(sp)
8111f140:	dec00204 	addi	sp,sp,8
8111f144:	f800283a 	ret
8111f148:	80c0030b 	ldhu	r3,12(r16)
8111f14c:	18fbffcc 	andi	r3,r3,61439
8111f150:	80c0030d 	sth	r3,12(r16)
8111f154:	dfc00117 	ldw	ra,4(sp)
8111f158:	dc000017 	ldw	r16,0(sp)
8111f15c:	dec00204 	addi	sp,sp,8
8111f160:	f800283a 	ret

8111f164 <__sclose>:
8111f164:	2940038f 	ldh	r5,14(r5)
8111f168:	11255781 	jmpi	81125578 <_close_r>

8111f16c <strcspn>:
8111f16c:	21c00007 	ldb	r7,0(r4)
8111f170:	38000f26 	beq	r7,zero,8111f1b0 <strcspn+0x44>
8111f174:	2a000007 	ldb	r8,0(r5)
8111f178:	2005883a 	mov	r2,r4
8111f17c:	40000726 	beq	r8,zero,8111f19c <strcspn+0x30>
8111f180:	3a000926 	beq	r7,r8,8111f1a8 <strcspn+0x3c>
8111f184:	2807883a 	mov	r3,r5
8111f188:	00000106 	br	8111f190 <strcspn+0x24>
8111f18c:	31c00626 	beq	r6,r7,8111f1a8 <strcspn+0x3c>
8111f190:	18c00044 	addi	r3,r3,1
8111f194:	19800007 	ldb	r6,0(r3)
8111f198:	303ffc1e 	bne	r6,zero,8111f18c <__reset+0xfb0ff18c>
8111f19c:	10800044 	addi	r2,r2,1
8111f1a0:	11c00007 	ldb	r7,0(r2)
8111f1a4:	383ff51e 	bne	r7,zero,8111f17c <__reset+0xfb0ff17c>
8111f1a8:	1105c83a 	sub	r2,r2,r4
8111f1ac:	f800283a 	ret
8111f1b0:	0005883a 	mov	r2,zero
8111f1b4:	f800283a 	ret

8111f1b8 <strlen>:
8111f1b8:	208000cc 	andi	r2,r4,3
8111f1bc:	10002026 	beq	r2,zero,8111f240 <strlen+0x88>
8111f1c0:	20800007 	ldb	r2,0(r4)
8111f1c4:	10002026 	beq	r2,zero,8111f248 <strlen+0x90>
8111f1c8:	2005883a 	mov	r2,r4
8111f1cc:	00000206 	br	8111f1d8 <strlen+0x20>
8111f1d0:	10c00007 	ldb	r3,0(r2)
8111f1d4:	18001826 	beq	r3,zero,8111f238 <strlen+0x80>
8111f1d8:	10800044 	addi	r2,r2,1
8111f1dc:	10c000cc 	andi	r3,r2,3
8111f1e0:	183ffb1e 	bne	r3,zero,8111f1d0 <__reset+0xfb0ff1d0>
8111f1e4:	10c00017 	ldw	r3,0(r2)
8111f1e8:	01ffbff4 	movhi	r7,65279
8111f1ec:	39ffbfc4 	addi	r7,r7,-257
8111f1f0:	00ca303a 	nor	r5,zero,r3
8111f1f4:	01a02074 	movhi	r6,32897
8111f1f8:	19c7883a 	add	r3,r3,r7
8111f1fc:	31a02004 	addi	r6,r6,-32640
8111f200:	1946703a 	and	r3,r3,r5
8111f204:	1986703a 	and	r3,r3,r6
8111f208:	1800091e 	bne	r3,zero,8111f230 <strlen+0x78>
8111f20c:	10800104 	addi	r2,r2,4
8111f210:	10c00017 	ldw	r3,0(r2)
8111f214:	19cb883a 	add	r5,r3,r7
8111f218:	00c6303a 	nor	r3,zero,r3
8111f21c:	28c6703a 	and	r3,r5,r3
8111f220:	1986703a 	and	r3,r3,r6
8111f224:	183ff926 	beq	r3,zero,8111f20c <__reset+0xfb0ff20c>
8111f228:	00000106 	br	8111f230 <strlen+0x78>
8111f22c:	10800044 	addi	r2,r2,1
8111f230:	10c00007 	ldb	r3,0(r2)
8111f234:	183ffd1e 	bne	r3,zero,8111f22c <__reset+0xfb0ff22c>
8111f238:	1105c83a 	sub	r2,r2,r4
8111f23c:	f800283a 	ret
8111f240:	2005883a 	mov	r2,r4
8111f244:	003fe706 	br	8111f1e4 <__reset+0xfb0ff1e4>
8111f248:	0005883a 	mov	r2,zero
8111f24c:	f800283a 	ret

8111f250 <strnlen>:
8111f250:	28000e26 	beq	r5,zero,8111f28c <strnlen+0x3c>
8111f254:	20800007 	ldb	r2,0(r4)
8111f258:	10000c26 	beq	r2,zero,8111f28c <strnlen+0x3c>
8111f25c:	20c00044 	addi	r3,r4,1
8111f260:	214b883a 	add	r5,r4,r5
8111f264:	28c00526 	beq	r5,r3,8111f27c <strnlen+0x2c>
8111f268:	19800007 	ldb	r6,0(r3)
8111f26c:	19c00044 	addi	r7,r3,1
8111f270:	30000426 	beq	r6,zero,8111f284 <strnlen+0x34>
8111f274:	3807883a 	mov	r3,r7
8111f278:	28fffb1e 	bne	r5,r3,8111f268 <__reset+0xfb0ff268>
8111f27c:	2905c83a 	sub	r2,r5,r4
8111f280:	f800283a 	ret
8111f284:	1905c83a 	sub	r2,r3,r4
8111f288:	f800283a 	ret
8111f28c:	0005883a 	mov	r2,zero
8111f290:	f800283a 	ret

8111f294 <_strtol_r>:
8111f294:	00a04574 	movhi	r2,33045
8111f298:	defff404 	addi	sp,sp,-48
8111f29c:	10bd6104 	addi	r2,r2,-2684
8111f2a0:	de00012e 	bgeu	sp,et,8111f2a8 <_strtol_r+0x14>
8111f2a4:	003b68fa 	trap	3
8111f2a8:	dd400715 	stw	r21,28(sp)
8111f2ac:	15400017 	ldw	r21,0(r2)
8111f2b0:	dd800815 	stw	r22,32(sp)
8111f2b4:	dd000615 	stw	r20,24(sp)
8111f2b8:	dcc00515 	stw	r19,20(sp)
8111f2bc:	d9000015 	stw	r4,0(sp)
8111f2c0:	dfc00b15 	stw	ra,44(sp)
8111f2c4:	df000a15 	stw	fp,40(sp)
8111f2c8:	ddc00915 	stw	r23,36(sp)
8111f2cc:	dc800415 	stw	r18,16(sp)
8111f2d0:	dc400315 	stw	r17,12(sp)
8111f2d4:	dc000215 	stw	r16,8(sp)
8111f2d8:	2829883a 	mov	r20,r5
8111f2dc:	3027883a 	mov	r19,r6
8111f2e0:	382d883a 	mov	r22,r7
8111f2e4:	2809883a 	mov	r4,r5
8111f2e8:	24000003 	ldbu	r16,0(r4)
8111f2ec:	24400044 	addi	r17,r4,1
8111f2f0:	2007883a 	mov	r3,r4
8111f2f4:	ac05883a 	add	r2,r21,r16
8111f2f8:	10800043 	ldbu	r2,1(r2)
8111f2fc:	8809883a 	mov	r4,r17
8111f300:	1080020c 	andi	r2,r2,8
8111f304:	103ff81e 	bne	r2,zero,8111f2e8 <__reset+0xfb0ff2e8>
8111f308:	00800b44 	movi	r2,45
8111f30c:	80805826 	beq	r16,r2,8111f470 <_strtol_r+0x1dc>
8111f310:	00800ac4 	movi	r2,43
8111f314:	80805a26 	beq	r16,r2,8111f480 <_strtol_r+0x1ec>
8111f318:	0039883a 	mov	fp,zero
8111f31c:	b0004426 	beq	r22,zero,8111f430 <_strtol_r+0x19c>
8111f320:	00800404 	movi	r2,16
8111f324:	b0806026 	beq	r22,r2,8111f4a8 <_strtol_r+0x214>
8111f328:	b02f883a 	mov	r23,r22
8111f32c:	00a00034 	movhi	r2,32768
8111f330:	e025003a 	cmpeq	r18,fp,zero
8111f334:	14a5c83a 	sub	r18,r2,r18
8111f338:	b80b883a 	mov	r5,r23
8111f33c:	9009883a 	mov	r4,r18
8111f340:	1130d100 	call	81130d10 <__umodsi3>
8111f344:	b80b883a 	mov	r5,r23
8111f348:	9009883a 	mov	r4,r18
8111f34c:	d8800115 	stw	r2,4(sp)
8111f350:	1130cac0 	call	81130cac <__udivsi3>
8111f354:	ac07883a 	add	r3,r21,r16
8111f358:	18c00043 	ldbu	r3,1(r3)
8111f35c:	880b883a 	mov	r5,r17
8111f360:	000d883a 	mov	r6,zero
8111f364:	1a00010c 	andi	r8,r3,4
8111f368:	0009883a 	mov	r4,zero
8111f36c:	02800044 	movi	r10,1
8111f370:	027fffc4 	movi	r9,-1
8111f374:	d9c00117 	ldw	r7,4(sp)
8111f378:	40000e26 	beq	r8,zero,8111f3b4 <_strtol_r+0x120>
8111f37c:	843ff404 	addi	r16,r16,-48
8111f380:	8580120e 	bge	r16,r22,8111f3cc <_strtol_r+0x138>
8111f384:	32400526 	beq	r6,r9,8111f39c <_strtol_r+0x108>
8111f388:	11002536 	bltu	r2,r4,8111f420 <_strtol_r+0x18c>
8111f38c:	20802326 	beq	r4,r2,8111f41c <_strtol_r+0x188>
8111f390:	25c9383a 	mul	r4,r4,r23
8111f394:	01800044 	movi	r6,1
8111f398:	8109883a 	add	r4,r16,r4
8111f39c:	2c000003 	ldbu	r16,0(r5)
8111f3a0:	29400044 	addi	r5,r5,1
8111f3a4:	ac07883a 	add	r3,r21,r16
8111f3a8:	18c00043 	ldbu	r3,1(r3)
8111f3ac:	1a00010c 	andi	r8,r3,4
8111f3b0:	403ff21e 	bne	r8,zero,8111f37c <__reset+0xfb0ff37c>
8111f3b4:	18c000cc 	andi	r3,r3,3
8111f3b8:	18000426 	beq	r3,zero,8111f3cc <_strtol_r+0x138>
8111f3bc:	1a801a26 	beq	r3,r10,8111f428 <_strtol_r+0x194>
8111f3c0:	00c015c4 	movi	r3,87
8111f3c4:	80e1c83a 	sub	r16,r16,r3
8111f3c8:	85bfee16 	blt	r16,r22,8111f384 <__reset+0xfb0ff384>
8111f3cc:	00bfffc4 	movi	r2,-1
8111f3d0:	30801e26 	beq	r6,r2,8111f44c <_strtol_r+0x1b8>
8111f3d4:	e0001b1e 	bne	fp,zero,8111f444 <_strtol_r+0x1b0>
8111f3d8:	2005883a 	mov	r2,r4
8111f3dc:	98000326 	beq	r19,zero,8111f3ec <_strtol_r+0x158>
8111f3e0:	3000211e 	bne	r6,zero,8111f468 <_strtol_r+0x1d4>
8111f3e4:	a00b883a 	mov	r5,r20
8111f3e8:	99400015 	stw	r5,0(r19)
8111f3ec:	dfc00b17 	ldw	ra,44(sp)
8111f3f0:	df000a17 	ldw	fp,40(sp)
8111f3f4:	ddc00917 	ldw	r23,36(sp)
8111f3f8:	dd800817 	ldw	r22,32(sp)
8111f3fc:	dd400717 	ldw	r21,28(sp)
8111f400:	dd000617 	ldw	r20,24(sp)
8111f404:	dcc00517 	ldw	r19,20(sp)
8111f408:	dc800417 	ldw	r18,16(sp)
8111f40c:	dc400317 	ldw	r17,12(sp)
8111f410:	dc000217 	ldw	r16,8(sp)
8111f414:	dec00c04 	addi	sp,sp,48
8111f418:	f800283a 	ret
8111f41c:	3c3fdc0e 	bge	r7,r16,8111f390 <__reset+0xfb0ff390>
8111f420:	01bfffc4 	movi	r6,-1
8111f424:	003fdd06 	br	8111f39c <__reset+0xfb0ff39c>
8111f428:	00c00dc4 	movi	r3,55
8111f42c:	003fe506 	br	8111f3c4 <__reset+0xfb0ff3c4>
8111f430:	00800c04 	movi	r2,48
8111f434:	80801626 	beq	r16,r2,8111f490 <_strtol_r+0x1fc>
8111f438:	05800284 	movi	r22,10
8111f43c:	b02f883a 	mov	r23,r22
8111f440:	003fba06 	br	8111f32c <__reset+0xfb0ff32c>
8111f444:	0109c83a 	sub	r4,zero,r4
8111f448:	003fe306 	br	8111f3d8 <__reset+0xfb0ff3d8>
8111f44c:	d9000017 	ldw	r4,0(sp)
8111f450:	00c00884 	movi	r3,34
8111f454:	e005003a 	cmpeq	r2,fp,zero
8111f458:	20c00015 	stw	r3,0(r4)
8111f45c:	00e00034 	movhi	r3,32768
8111f460:	1885c83a 	sub	r2,r3,r2
8111f464:	983fe126 	beq	r19,zero,8111f3ec <__reset+0xfb0ff3ec>
8111f468:	297fffc4 	addi	r5,r5,-1
8111f46c:	003fde06 	br	8111f3e8 <__reset+0xfb0ff3e8>
8111f470:	1c400084 	addi	r17,r3,2
8111f474:	1c000043 	ldbu	r16,1(r3)
8111f478:	07000044 	movi	fp,1
8111f47c:	003fa706 	br	8111f31c <__reset+0xfb0ff31c>
8111f480:	1c400084 	addi	r17,r3,2
8111f484:	1c000043 	ldbu	r16,1(r3)
8111f488:	0039883a 	mov	fp,zero
8111f48c:	003fa306 	br	8111f31c <__reset+0xfb0ff31c>
8111f490:	88800003 	ldbu	r2,0(r17)
8111f494:	00c01604 	movi	r3,88
8111f498:	108037cc 	andi	r2,r2,223
8111f49c:	10c00826 	beq	r2,r3,8111f4c0 <_strtol_r+0x22c>
8111f4a0:	05800204 	movi	r22,8
8111f4a4:	003fa006 	br	8111f328 <__reset+0xfb0ff328>
8111f4a8:	00800c04 	movi	r2,48
8111f4ac:	80bf9e1e 	bne	r16,r2,8111f328 <__reset+0xfb0ff328>
8111f4b0:	88800003 	ldbu	r2,0(r17)
8111f4b4:	00c01604 	movi	r3,88
8111f4b8:	108037cc 	andi	r2,r2,223
8111f4bc:	10ff9a1e 	bne	r2,r3,8111f328 <__reset+0xfb0ff328>
8111f4c0:	05c00404 	movi	r23,16
8111f4c4:	8c000043 	ldbu	r16,1(r17)
8111f4c8:	b82d883a 	mov	r22,r23
8111f4cc:	8c400084 	addi	r17,r17,2
8111f4d0:	003f9606 	br	8111f32c <__reset+0xfb0ff32c>

8111f4d4 <strtol>:
8111f4d4:	00a04574 	movhi	r2,33045
8111f4d8:	10bd6304 	addi	r2,r2,-2676
8111f4dc:	300f883a 	mov	r7,r6
8111f4e0:	280d883a 	mov	r6,r5
8111f4e4:	200b883a 	mov	r5,r4
8111f4e8:	11000017 	ldw	r4,0(r2)
8111f4ec:	111f2941 	jmpi	8111f294 <_strtol_r>

8111f4f0 <___svfprintf_internal_r>:
8111f4f0:	deffb704 	addi	sp,sp,-292
8111f4f4:	de00012e 	bgeu	sp,et,8111f4fc <___svfprintf_internal_r+0xc>
8111f4f8:	003b68fa 	trap	3
8111f4fc:	dfc04815 	stw	ra,288(sp)
8111f500:	ddc04615 	stw	r23,280(sp)
8111f504:	d9402c15 	stw	r5,176(sp)
8111f508:	d9003915 	stw	r4,228(sp)
8111f50c:	302f883a 	mov	r23,r6
8111f510:	d9c02d15 	stw	r7,180(sp)
8111f514:	df004715 	stw	fp,284(sp)
8111f518:	dd804515 	stw	r22,276(sp)
8111f51c:	dd404415 	stw	r21,272(sp)
8111f520:	dd004315 	stw	r20,268(sp)
8111f524:	dcc04215 	stw	r19,264(sp)
8111f528:	dc804115 	stw	r18,260(sp)
8111f52c:	dc404015 	stw	r17,256(sp)
8111f530:	dc003f15 	stw	r16,252(sp)
8111f534:	11283d80 	call	811283d8 <_localeconv_r>
8111f538:	10800017 	ldw	r2,0(r2)
8111f53c:	1009883a 	mov	r4,r2
8111f540:	d8803415 	stw	r2,208(sp)
8111f544:	111f1b80 	call	8111f1b8 <strlen>
8111f548:	d8c02c17 	ldw	r3,176(sp)
8111f54c:	d8803815 	stw	r2,224(sp)
8111f550:	1880030b 	ldhu	r2,12(r3)
8111f554:	1080200c 	andi	r2,r2,128
8111f558:	10000226 	beq	r2,zero,8111f564 <___svfprintf_internal_r+0x74>
8111f55c:	18800417 	ldw	r2,16(r3)
8111f560:	10067f26 	beq	r2,zero,81120f60 <___svfprintf_internal_r+0x1a70>
8111f564:	dcc03917 	ldw	r19,228(sp)
8111f568:	d8c00404 	addi	r3,sp,16
8111f56c:	05604574 	movhi	r21,33045
8111f570:	d9001e04 	addi	r4,sp,120
8111f574:	ad739b84 	addi	r21,r21,-12690
8111f578:	d8c01e15 	stw	r3,120(sp)
8111f57c:	d8002015 	stw	zero,128(sp)
8111f580:	d8001f15 	stw	zero,124(sp)
8111f584:	d8003315 	stw	zero,204(sp)
8111f588:	d8003615 	stw	zero,216(sp)
8111f58c:	d8003715 	stw	zero,220(sp)
8111f590:	1811883a 	mov	r8,r3
8111f594:	d8003a15 	stw	zero,232(sp)
8111f598:	d8003b15 	stw	zero,236(sp)
8111f59c:	d8002f15 	stw	zero,188(sp)
8111f5a0:	d9002815 	stw	r4,160(sp)
8111f5a4:	b8800007 	ldb	r2,0(r23)
8111f5a8:	10026726 	beq	r2,zero,8111ff48 <___svfprintf_internal_r+0xa58>
8111f5ac:	00c00944 	movi	r3,37
8111f5b0:	b821883a 	mov	r16,r23
8111f5b4:	10c0021e 	bne	r2,r3,8111f5c0 <___svfprintf_internal_r+0xd0>
8111f5b8:	00001406 	br	8111f60c <___svfprintf_internal_r+0x11c>
8111f5bc:	10c00326 	beq	r2,r3,8111f5cc <___svfprintf_internal_r+0xdc>
8111f5c0:	84000044 	addi	r16,r16,1
8111f5c4:	80800007 	ldb	r2,0(r16)
8111f5c8:	103ffc1e 	bne	r2,zero,8111f5bc <__reset+0xfb0ff5bc>
8111f5cc:	85e3c83a 	sub	r17,r16,r23
8111f5d0:	88000e26 	beq	r17,zero,8111f60c <___svfprintf_internal_r+0x11c>
8111f5d4:	d8c02017 	ldw	r3,128(sp)
8111f5d8:	d8801f17 	ldw	r2,124(sp)
8111f5dc:	45c00015 	stw	r23,0(r8)
8111f5e0:	1c47883a 	add	r3,r3,r17
8111f5e4:	10800044 	addi	r2,r2,1
8111f5e8:	d8c02015 	stw	r3,128(sp)
8111f5ec:	44400115 	stw	r17,4(r8)
8111f5f0:	d8801f15 	stw	r2,124(sp)
8111f5f4:	00c001c4 	movi	r3,7
8111f5f8:	18809716 	blt	r3,r2,8111f858 <___svfprintf_internal_r+0x368>
8111f5fc:	42000204 	addi	r8,r8,8
8111f600:	d9402f17 	ldw	r5,188(sp)
8111f604:	2c4b883a 	add	r5,r5,r17
8111f608:	d9402f15 	stw	r5,188(sp)
8111f60c:	80800007 	ldb	r2,0(r16)
8111f610:	10009826 	beq	r2,zero,8111f874 <___svfprintf_internal_r+0x384>
8111f614:	84400047 	ldb	r17,1(r16)
8111f618:	00bfffc4 	movi	r2,-1
8111f61c:	85c00044 	addi	r23,r16,1
8111f620:	d8002785 	stb	zero,158(sp)
8111f624:	0007883a 	mov	r3,zero
8111f628:	000f883a 	mov	r7,zero
8111f62c:	d8802915 	stw	r2,164(sp)
8111f630:	d8003115 	stw	zero,196(sp)
8111f634:	0025883a 	mov	r18,zero
8111f638:	01401604 	movi	r5,88
8111f63c:	01800244 	movi	r6,9
8111f640:	02800a84 	movi	r10,42
8111f644:	02401b04 	movi	r9,108
8111f648:	bdc00044 	addi	r23,r23,1
8111f64c:	88bff804 	addi	r2,r17,-32
8111f650:	2882f036 	bltu	r5,r2,81120214 <___svfprintf_internal_r+0xd24>
8111f654:	100490ba 	slli	r2,r2,2
8111f658:	012044b4 	movhi	r4,33042
8111f65c:	213d9b04 	addi	r4,r4,-2452
8111f660:	1105883a 	add	r2,r2,r4
8111f664:	10800017 	ldw	r2,0(r2)
8111f668:	1000683a 	jmp	r2
8111f66c:	8112017c 	xorhi	r4,r16,18437
8111f670:	81120214 	ori	r4,r16,18440
8111f674:	81120214 	ori	r4,r16,18440
8111f678:	81120170 	cmpltui	r4,r16,18437
8111f67c:	81120214 	ori	r4,r16,18440
8111f680:	81120214 	ori	r4,r16,18440
8111f684:	81120214 	ori	r4,r16,18440
8111f688:	81120214 	ori	r4,r16,18440
8111f68c:	81120214 	ori	r4,r16,18440
8111f690:	81120214 	ori	r4,r16,18440
8111f694:	8111f8d0 	cmplti	r4,r16,18403
8111f698:	811200ac 	andhi	r4,r16,18434
8111f69c:	81120214 	ori	r4,r16,18440
8111f6a0:	8111f7e0 	cmpeqi	r4,r16,18399
8111f6a4:	8111f8f8 	rdprs	r4,r16,18403
8111f6a8:	81120214 	ori	r4,r16,18440
8111f6ac:	8111f96c 	andhi	r4,r16,18405
8111f6b0:	8111f938 	rdprs	r4,r16,18404
8111f6b4:	8111f938 	rdprs	r4,r16,18404
8111f6b8:	8111f938 	rdprs	r4,r16,18404
8111f6bc:	8111f938 	rdprs	r4,r16,18404
8111f6c0:	8111f938 	rdprs	r4,r16,18404
8111f6c4:	8111f938 	rdprs	r4,r16,18404
8111f6c8:	8111f938 	rdprs	r4,r16,18404
8111f6cc:	8111f938 	rdprs	r4,r16,18404
8111f6d0:	8111f938 	rdprs	r4,r16,18404
8111f6d4:	81120214 	ori	r4,r16,18440
8111f6d8:	81120214 	ori	r4,r16,18440
8111f6dc:	81120214 	ori	r4,r16,18440
8111f6e0:	81120214 	ori	r4,r16,18440
8111f6e4:	81120214 	ori	r4,r16,18440
8111f6e8:	81120214 	ori	r4,r16,18440
8111f6ec:	81120214 	ori	r4,r16,18440
8111f6f0:	81120214 	ori	r4,r16,18440
8111f6f4:	81120214 	ori	r4,r16,18440
8111f6f8:	81120214 	ori	r4,r16,18440
8111f6fc:	8111fa24 	muli	r4,r16,18408
8111f700:	8111f978 	rdprs	r4,r16,18405
8111f704:	81120214 	ori	r4,r16,18440
8111f708:	8111f978 	rdprs	r4,r16,18405
8111f70c:	81120214 	ori	r4,r16,18440
8111f710:	81120214 	ori	r4,r16,18440
8111f714:	81120214 	ori	r4,r16,18440
8111f718:	81120214 	ori	r4,r16,18440
8111f71c:	8111fa18 	cmpnei	r4,r16,18408
8111f720:	81120214 	ori	r4,r16,18440
8111f724:	81120214 	ori	r4,r16,18440
8111f728:	8111fae0 	cmpeqi	r4,r16,18411
8111f72c:	81120214 	ori	r4,r16,18440
8111f730:	81120214 	ori	r4,r16,18440
8111f734:	81120214 	ori	r4,r16,18440
8111f738:	81120214 	ori	r4,r16,18440
8111f73c:	81120214 	ori	r4,r16,18440
8111f740:	8111ff50 	cmplti	r4,r16,18429
8111f744:	81120214 	ori	r4,r16,18440
8111f748:	81120214 	ori	r4,r16,18440
8111f74c:	8111ffb0 	cmpltui	r4,r16,18430
8111f750:	81120214 	ori	r4,r16,18440
8111f754:	81120214 	ori	r4,r16,18440
8111f758:	81120214 	ori	r4,r16,18440
8111f75c:	81120214 	ori	r4,r16,18440
8111f760:	81120214 	ori	r4,r16,18440
8111f764:	81120214 	ori	r4,r16,18440
8111f768:	81120214 	ori	r4,r16,18440
8111f76c:	81120214 	ori	r4,r16,18440
8111f770:	81120214 	ori	r4,r16,18440
8111f774:	81120214 	ori	r4,r16,18440
8111f778:	81120060 	cmpeqi	r4,r16,18433
8111f77c:	8112019c 	xori	r4,r16,18438
8111f780:	8111f978 	rdprs	r4,r16,18405
8111f784:	8111f978 	rdprs	r4,r16,18405
8111f788:	8111f978 	rdprs	r4,r16,18405
8111f78c:	811201f0 	cmpltui	r4,r16,18439
8111f790:	8112019c 	xori	r4,r16,18438
8111f794:	81120214 	ori	r4,r16,18440
8111f798:	81120214 	ori	r4,r16,18440
8111f79c:	811201ac 	andhi	r4,r16,18438
8111f7a0:	81120214 	ori	r4,r16,18440
8111f7a4:	811201bc 	xorhi	r4,r16,18438
8111f7a8:	8112009c 	xori	r4,r16,18434
8111f7ac:	8111f7ec 	andhi	r4,r16,18399
8111f7b0:	811200bc 	xorhi	r4,r16,18434
8111f7b4:	81120214 	ori	r4,r16,18440
8111f7b8:	811200c8 	cmpgei	r4,r16,18435
8111f7bc:	81120214 	ori	r4,r16,18440
8111f7c0:	81120124 	muli	r4,r16,18436
8111f7c4:	81120214 	ori	r4,r16,18440
8111f7c8:	81120214 	ori	r4,r16,18440
8111f7cc:	81120134 	orhi	r4,r16,18436
8111f7d0:	d9003117 	ldw	r4,196(sp)
8111f7d4:	d8802d15 	stw	r2,180(sp)
8111f7d8:	0109c83a 	sub	r4,zero,r4
8111f7dc:	d9003115 	stw	r4,196(sp)
8111f7e0:	94800114 	ori	r18,r18,4
8111f7e4:	bc400007 	ldb	r17,0(r23)
8111f7e8:	003f9706 	br	8111f648 <__reset+0xfb0ff648>
8111f7ec:	00800c04 	movi	r2,48
8111f7f0:	d9002d17 	ldw	r4,180(sp)
8111f7f4:	d9402917 	ldw	r5,164(sp)
8111f7f8:	d8802705 	stb	r2,156(sp)
8111f7fc:	00801e04 	movi	r2,120
8111f800:	d8802745 	stb	r2,157(sp)
8111f804:	d8002785 	stb	zero,158(sp)
8111f808:	20c00104 	addi	r3,r4,4
8111f80c:	25000017 	ldw	r20,0(r4)
8111f810:	002d883a 	mov	r22,zero
8111f814:	90800094 	ori	r2,r18,2
8111f818:	28028616 	blt	r5,zero,81120234 <___svfprintf_internal_r+0xd44>
8111f81c:	00bfdfc4 	movi	r2,-129
8111f820:	90a4703a 	and	r18,r18,r2
8111f824:	d8c02d15 	stw	r3,180(sp)
8111f828:	94800094 	ori	r18,r18,2
8111f82c:	a002731e 	bne	r20,zero,811201fc <___svfprintf_internal_r+0xd0c>
8111f830:	00a04574 	movhi	r2,33045
8111f834:	10b39404 	addi	r2,r2,-12720
8111f838:	d8803a15 	stw	r2,232(sp)
8111f83c:	04401e04 	movi	r17,120
8111f840:	d8c02917 	ldw	r3,164(sp)
8111f844:	0039883a 	mov	fp,zero
8111f848:	1801d526 	beq	r3,zero,8111ffa0 <___svfprintf_internal_r+0xab0>
8111f84c:	0029883a 	mov	r20,zero
8111f850:	002d883a 	mov	r22,zero
8111f854:	0001f106 	br	8112001c <___svfprintf_internal_r+0xb2c>
8111f858:	d9402c17 	ldw	r5,176(sp)
8111f85c:	d9801e04 	addi	r6,sp,120
8111f860:	9809883a 	mov	r4,r19
8111f864:	112c1100 	call	8112c110 <__ssprint_r>
8111f868:	1000081e 	bne	r2,zero,8111f88c <___svfprintf_internal_r+0x39c>
8111f86c:	da000404 	addi	r8,sp,16
8111f870:	003f6306 	br	8111f600 <__reset+0xfb0ff600>
8111f874:	d8802017 	ldw	r2,128(sp)
8111f878:	10000426 	beq	r2,zero,8111f88c <___svfprintf_internal_r+0x39c>
8111f87c:	d9402c17 	ldw	r5,176(sp)
8111f880:	d9003917 	ldw	r4,228(sp)
8111f884:	d9801e04 	addi	r6,sp,120
8111f888:	112c1100 	call	8112c110 <__ssprint_r>
8111f88c:	d8802c17 	ldw	r2,176(sp)
8111f890:	10c0030b 	ldhu	r3,12(r2)
8111f894:	d8802f17 	ldw	r2,188(sp)
8111f898:	18c0100c 	andi	r3,r3,64
8111f89c:	1805f51e 	bne	r3,zero,81121074 <___svfprintf_internal_r+0x1b84>
8111f8a0:	dfc04817 	ldw	ra,288(sp)
8111f8a4:	df004717 	ldw	fp,284(sp)
8111f8a8:	ddc04617 	ldw	r23,280(sp)
8111f8ac:	dd804517 	ldw	r22,276(sp)
8111f8b0:	dd404417 	ldw	r21,272(sp)
8111f8b4:	dd004317 	ldw	r20,268(sp)
8111f8b8:	dcc04217 	ldw	r19,264(sp)
8111f8bc:	dc804117 	ldw	r18,260(sp)
8111f8c0:	dc404017 	ldw	r17,256(sp)
8111f8c4:	dc003f17 	ldw	r16,252(sp)
8111f8c8:	dec04904 	addi	sp,sp,292
8111f8cc:	f800283a 	ret
8111f8d0:	d8802d17 	ldw	r2,180(sp)
8111f8d4:	d9002d17 	ldw	r4,180(sp)
8111f8d8:	10800017 	ldw	r2,0(r2)
8111f8dc:	d8803115 	stw	r2,196(sp)
8111f8e0:	20800104 	addi	r2,r4,4
8111f8e4:	d9003117 	ldw	r4,196(sp)
8111f8e8:	203fb916 	blt	r4,zero,8111f7d0 <__reset+0xfb0ff7d0>
8111f8ec:	d8802d15 	stw	r2,180(sp)
8111f8f0:	bc400007 	ldb	r17,0(r23)
8111f8f4:	003f5406 	br	8111f648 <__reset+0xfb0ff648>
8111f8f8:	bc400007 	ldb	r17,0(r23)
8111f8fc:	bac00044 	addi	r11,r23,1
8111f900:	8a873926 	beq	r17,r10,811215e8 <___svfprintf_internal_r+0x20f8>
8111f904:	88bff404 	addi	r2,r17,-48
8111f908:	0009883a 	mov	r4,zero
8111f90c:	30868836 	bltu	r6,r2,81121330 <___svfprintf_internal_r+0x1e40>
8111f910:	5c400007 	ldb	r17,0(r11)
8111f914:	210002a4 	muli	r4,r4,10
8111f918:	5dc00044 	addi	r23,r11,1
8111f91c:	b817883a 	mov	r11,r23
8111f920:	2089883a 	add	r4,r4,r2
8111f924:	88bff404 	addi	r2,r17,-48
8111f928:	30bff92e 	bgeu	r6,r2,8111f910 <__reset+0xfb0ff910>
8111f92c:	2005d716 	blt	r4,zero,8112108c <___svfprintf_internal_r+0x1b9c>
8111f930:	d9002915 	stw	r4,164(sp)
8111f934:	003f4506 	br	8111f64c <__reset+0xfb0ff64c>
8111f938:	b809883a 	mov	r4,r23
8111f93c:	d8003115 	stw	zero,196(sp)
8111f940:	88bff404 	addi	r2,r17,-48
8111f944:	0017883a 	mov	r11,zero
8111f948:	24400007 	ldb	r17,0(r4)
8111f94c:	5ac002a4 	muli	r11,r11,10
8111f950:	bdc00044 	addi	r23,r23,1
8111f954:	b809883a 	mov	r4,r23
8111f958:	12d7883a 	add	r11,r2,r11
8111f95c:	88bff404 	addi	r2,r17,-48
8111f960:	30bff92e 	bgeu	r6,r2,8111f948 <__reset+0xfb0ff948>
8111f964:	dac03115 	stw	r11,196(sp)
8111f968:	003f3806 	br	8111f64c <__reset+0xfb0ff64c>
8111f96c:	94802014 	ori	r18,r18,128
8111f970:	bc400007 	ldb	r17,0(r23)
8111f974:	003f3406 	br	8111f648 <__reset+0xfb0ff648>
8111f978:	18c03fcc 	andi	r3,r3,255
8111f97c:	1807471e 	bne	r3,zero,8112169c <___svfprintf_internal_r+0x21ac>
8111f980:	9080020c 	andi	r2,r18,8
8111f984:	10047d26 	beq	r2,zero,81120b7c <___svfprintf_internal_r+0x168c>
8111f988:	d8c02d17 	ldw	r3,180(sp)
8111f98c:	d9002d17 	ldw	r4,180(sp)
8111f990:	d9402d17 	ldw	r5,180(sp)
8111f994:	18c00017 	ldw	r3,0(r3)
8111f998:	21000117 	ldw	r4,4(r4)
8111f99c:	29400204 	addi	r5,r5,8
8111f9a0:	d8c03615 	stw	r3,216(sp)
8111f9a4:	d9003715 	stw	r4,220(sp)
8111f9a8:	d9402d15 	stw	r5,180(sp)
8111f9ac:	d9003617 	ldw	r4,216(sp)
8111f9b0:	d9403717 	ldw	r5,220(sp)
8111f9b4:	da003e15 	stw	r8,248(sp)
8111f9b8:	04000044 	movi	r16,1
8111f9bc:	1129f240 	call	81129f24 <__fpclassifyd>
8111f9c0:	da003e17 	ldw	r8,248(sp)
8111f9c4:	14044b1e 	bne	r2,r16,81120af4 <___svfprintf_internal_r+0x1604>
8111f9c8:	d9003617 	ldw	r4,216(sp)
8111f9cc:	d9403717 	ldw	r5,220(sp)
8111f9d0:	000d883a 	mov	r6,zero
8111f9d4:	000f883a 	mov	r7,zero
8111f9d8:	113226c0 	call	8113226c <__ledf2>
8111f9dc:	da003e17 	ldw	r8,248(sp)
8111f9e0:	1005f316 	blt	r2,zero,811211b0 <___svfprintf_internal_r+0x1cc0>
8111f9e4:	df002783 	ldbu	fp,158(sp)
8111f9e8:	008011c4 	movi	r2,71
8111f9ec:	1445590e 	bge	r2,r17,81120f54 <___svfprintf_internal_r+0x1a64>
8111f9f0:	04204574 	movhi	r16,33045
8111f9f4:	84338c04 	addi	r16,r16,-12752
8111f9f8:	00c000c4 	movi	r3,3
8111f9fc:	00bfdfc4 	movi	r2,-129
8111fa00:	d8c02a15 	stw	r3,168(sp)
8111fa04:	90a4703a 	and	r18,r18,r2
8111fa08:	d8c02e15 	stw	r3,184(sp)
8111fa0c:	d8002915 	stw	zero,164(sp)
8111fa10:	d8003215 	stw	zero,200(sp)
8111fa14:	00006606 	br	8111fbb0 <___svfprintf_internal_r+0x6c0>
8111fa18:	94800214 	ori	r18,r18,8
8111fa1c:	bc400007 	ldb	r17,0(r23)
8111fa20:	003f0906 	br	8111f648 <__reset+0xfb0ff648>
8111fa24:	18c03fcc 	andi	r3,r3,255
8111fa28:	1807181e 	bne	r3,zero,8112168c <___svfprintf_internal_r+0x219c>
8111fa2c:	94800414 	ori	r18,r18,16
8111fa30:	9080080c 	andi	r2,r18,32
8111fa34:	10039626 	beq	r2,zero,81120890 <___svfprintf_internal_r+0x13a0>
8111fa38:	d9402d17 	ldw	r5,180(sp)
8111fa3c:	28800117 	ldw	r2,4(r5)
8111fa40:	2d000017 	ldw	r20,0(r5)
8111fa44:	29400204 	addi	r5,r5,8
8111fa48:	d9402d15 	stw	r5,180(sp)
8111fa4c:	102d883a 	mov	r22,r2
8111fa50:	10039816 	blt	r2,zero,811208b4 <___svfprintf_internal_r+0x13c4>
8111fa54:	d9402917 	ldw	r5,164(sp)
8111fa58:	df002783 	ldbu	fp,158(sp)
8111fa5c:	2803ab16 	blt	r5,zero,8112090c <___svfprintf_internal_r+0x141c>
8111fa60:	00ffdfc4 	movi	r3,-129
8111fa64:	a584b03a 	or	r2,r20,r22
8111fa68:	90e4703a 	and	r18,r18,r3
8111fa6c:	10014a26 	beq	r2,zero,8111ff98 <___svfprintf_internal_r+0xaa8>
8111fa70:	b0034b26 	beq	r22,zero,811207a0 <___svfprintf_internal_r+0x12b0>
8111fa74:	dc402a15 	stw	r17,168(sp)
8111fa78:	dc001e04 	addi	r16,sp,120
8111fa7c:	b023883a 	mov	r17,r22
8111fa80:	402d883a 	mov	r22,r8
8111fa84:	a009883a 	mov	r4,r20
8111fa88:	880b883a 	mov	r5,r17
8111fa8c:	01800284 	movi	r6,10
8111fa90:	000f883a 	mov	r7,zero
8111fa94:	11306740 	call	81130674 <__umoddi3>
8111fa98:	10800c04 	addi	r2,r2,48
8111fa9c:	843fffc4 	addi	r16,r16,-1
8111faa0:	a009883a 	mov	r4,r20
8111faa4:	880b883a 	mov	r5,r17
8111faa8:	80800005 	stb	r2,0(r16)
8111faac:	01800284 	movi	r6,10
8111fab0:	000f883a 	mov	r7,zero
8111fab4:	11300f40 	call	811300f4 <__udivdi3>
8111fab8:	1029883a 	mov	r20,r2
8111fabc:	10c4b03a 	or	r2,r2,r3
8111fac0:	1823883a 	mov	r17,r3
8111fac4:	103fef1e 	bne	r2,zero,8111fa84 <__reset+0xfb0ffa84>
8111fac8:	d8c02817 	ldw	r3,160(sp)
8111facc:	dc402a17 	ldw	r17,168(sp)
8111fad0:	b011883a 	mov	r8,r22
8111fad4:	1c07c83a 	sub	r3,r3,r16
8111fad8:	d8c02e15 	stw	r3,184(sp)
8111fadc:	00002e06 	br	8111fb98 <___svfprintf_internal_r+0x6a8>
8111fae0:	18c03fcc 	andi	r3,r3,255
8111fae4:	1806e71e 	bne	r3,zero,81121684 <___svfprintf_internal_r+0x2194>
8111fae8:	94800414 	ori	r18,r18,16
8111faec:	9080080c 	andi	r2,r18,32
8111faf0:	1002d426 	beq	r2,zero,81120644 <___svfprintf_internal_r+0x1154>
8111faf4:	d9402d17 	ldw	r5,180(sp)
8111faf8:	d8c02917 	ldw	r3,164(sp)
8111fafc:	d8002785 	stb	zero,158(sp)
8111fb00:	28800204 	addi	r2,r5,8
8111fb04:	2d000017 	ldw	r20,0(r5)
8111fb08:	2d800117 	ldw	r22,4(r5)
8111fb0c:	18041516 	blt	r3,zero,81120b64 <___svfprintf_internal_r+0x1674>
8111fb10:	013fdfc4 	movi	r4,-129
8111fb14:	a586b03a 	or	r3,r20,r22
8111fb18:	d8802d15 	stw	r2,180(sp)
8111fb1c:	9124703a 	and	r18,r18,r4
8111fb20:	1802d51e 	bne	r3,zero,81120678 <___svfprintf_internal_r+0x1188>
8111fb24:	d9402917 	ldw	r5,164(sp)
8111fb28:	0039883a 	mov	fp,zero
8111fb2c:	2806be26 	beq	r5,zero,81121628 <___svfprintf_internal_r+0x2138>
8111fb30:	0029883a 	mov	r20,zero
8111fb34:	002d883a 	mov	r22,zero
8111fb38:	dc001e04 	addi	r16,sp,120
8111fb3c:	a006d0fa 	srli	r3,r20,3
8111fb40:	b008977a 	slli	r4,r22,29
8111fb44:	b02cd0fa 	srli	r22,r22,3
8111fb48:	a50001cc 	andi	r20,r20,7
8111fb4c:	a0800c04 	addi	r2,r20,48
8111fb50:	843fffc4 	addi	r16,r16,-1
8111fb54:	20e8b03a 	or	r20,r4,r3
8111fb58:	80800005 	stb	r2,0(r16)
8111fb5c:	a586b03a 	or	r3,r20,r22
8111fb60:	183ff61e 	bne	r3,zero,8111fb3c <__reset+0xfb0ffb3c>
8111fb64:	90c0004c 	andi	r3,r18,1
8111fb68:	18013926 	beq	r3,zero,81120050 <___svfprintf_internal_r+0xb60>
8111fb6c:	10803fcc 	andi	r2,r2,255
8111fb70:	1080201c 	xori	r2,r2,128
8111fb74:	10bfe004 	addi	r2,r2,-128
8111fb78:	00c00c04 	movi	r3,48
8111fb7c:	10c13426 	beq	r2,r3,81120050 <___svfprintf_internal_r+0xb60>
8111fb80:	80ffffc5 	stb	r3,-1(r16)
8111fb84:	d8c02817 	ldw	r3,160(sp)
8111fb88:	80bfffc4 	addi	r2,r16,-1
8111fb8c:	1021883a 	mov	r16,r2
8111fb90:	1887c83a 	sub	r3,r3,r2
8111fb94:	d8c02e15 	stw	r3,184(sp)
8111fb98:	d8802e17 	ldw	r2,184(sp)
8111fb9c:	d9002917 	ldw	r4,164(sp)
8111fba0:	1100010e 	bge	r2,r4,8111fba8 <___svfprintf_internal_r+0x6b8>
8111fba4:	2005883a 	mov	r2,r4
8111fba8:	d8802a15 	stw	r2,168(sp)
8111fbac:	d8003215 	stw	zero,200(sp)
8111fbb0:	e7003fcc 	andi	fp,fp,255
8111fbb4:	e700201c 	xori	fp,fp,128
8111fbb8:	e73fe004 	addi	fp,fp,-128
8111fbbc:	e0000326 	beq	fp,zero,8111fbcc <___svfprintf_internal_r+0x6dc>
8111fbc0:	d8c02a17 	ldw	r3,168(sp)
8111fbc4:	18c00044 	addi	r3,r3,1
8111fbc8:	d8c02a15 	stw	r3,168(sp)
8111fbcc:	90c0008c 	andi	r3,r18,2
8111fbd0:	d8c02b15 	stw	r3,172(sp)
8111fbd4:	18000326 	beq	r3,zero,8111fbe4 <___svfprintf_internal_r+0x6f4>
8111fbd8:	d8c02a17 	ldw	r3,168(sp)
8111fbdc:	18c00084 	addi	r3,r3,2
8111fbe0:	d8c02a15 	stw	r3,168(sp)
8111fbe4:	90c0210c 	andi	r3,r18,132
8111fbe8:	d8c03015 	stw	r3,192(sp)
8111fbec:	1801a11e 	bne	r3,zero,81120274 <___svfprintf_internal_r+0xd84>
8111fbf0:	d9003117 	ldw	r4,196(sp)
8111fbf4:	d8c02a17 	ldw	r3,168(sp)
8111fbf8:	20e9c83a 	sub	r20,r4,r3
8111fbfc:	05019d0e 	bge	zero,r20,81120274 <___svfprintf_internal_r+0xd84>
8111fc00:	02400404 	movi	r9,16
8111fc04:	d8c02017 	ldw	r3,128(sp)
8111fc08:	d8801f17 	ldw	r2,124(sp)
8111fc0c:	4d051b0e 	bge	r9,r20,8112107c <___svfprintf_internal_r+0x1b8c>
8111fc10:	01604574 	movhi	r5,33045
8111fc14:	29739f84 	addi	r5,r5,-12674
8111fc18:	dc403c15 	stw	r17,240(sp)
8111fc1c:	d9403515 	stw	r5,212(sp)
8111fc20:	a023883a 	mov	r17,r20
8111fc24:	482d883a 	mov	r22,r9
8111fc28:	9029883a 	mov	r20,r18
8111fc2c:	070001c4 	movi	fp,7
8111fc30:	8025883a 	mov	r18,r16
8111fc34:	dc002c17 	ldw	r16,176(sp)
8111fc38:	00000306 	br	8111fc48 <___svfprintf_internal_r+0x758>
8111fc3c:	8c7ffc04 	addi	r17,r17,-16
8111fc40:	42000204 	addi	r8,r8,8
8111fc44:	b440130e 	bge	r22,r17,8111fc94 <___svfprintf_internal_r+0x7a4>
8111fc48:	01204574 	movhi	r4,33045
8111fc4c:	18c00404 	addi	r3,r3,16
8111fc50:	10800044 	addi	r2,r2,1
8111fc54:	21339f84 	addi	r4,r4,-12674
8111fc58:	41000015 	stw	r4,0(r8)
8111fc5c:	45800115 	stw	r22,4(r8)
8111fc60:	d8c02015 	stw	r3,128(sp)
8111fc64:	d8801f15 	stw	r2,124(sp)
8111fc68:	e0bff40e 	bge	fp,r2,8111fc3c <__reset+0xfb0ffc3c>
8111fc6c:	d9801e04 	addi	r6,sp,120
8111fc70:	800b883a 	mov	r5,r16
8111fc74:	9809883a 	mov	r4,r19
8111fc78:	112c1100 	call	8112c110 <__ssprint_r>
8111fc7c:	103f031e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
8111fc80:	8c7ffc04 	addi	r17,r17,-16
8111fc84:	d8c02017 	ldw	r3,128(sp)
8111fc88:	d8801f17 	ldw	r2,124(sp)
8111fc8c:	da000404 	addi	r8,sp,16
8111fc90:	b47fed16 	blt	r22,r17,8111fc48 <__reset+0xfb0ffc48>
8111fc94:	9021883a 	mov	r16,r18
8111fc98:	a025883a 	mov	r18,r20
8111fc9c:	8829883a 	mov	r20,r17
8111fca0:	dc403c17 	ldw	r17,240(sp)
8111fca4:	d9403517 	ldw	r5,212(sp)
8111fca8:	a0c7883a 	add	r3,r20,r3
8111fcac:	10800044 	addi	r2,r2,1
8111fcb0:	41400015 	stw	r5,0(r8)
8111fcb4:	45000115 	stw	r20,4(r8)
8111fcb8:	d8c02015 	stw	r3,128(sp)
8111fcbc:	d8801f15 	stw	r2,124(sp)
8111fcc0:	010001c4 	movi	r4,7
8111fcc4:	20829f16 	blt	r4,r2,81120744 <___svfprintf_internal_r+0x1254>
8111fcc8:	df002787 	ldb	fp,158(sp)
8111fccc:	42000204 	addi	r8,r8,8
8111fcd0:	e0000c26 	beq	fp,zero,8111fd04 <___svfprintf_internal_r+0x814>
8111fcd4:	d8801f17 	ldw	r2,124(sp)
8111fcd8:	d9002784 	addi	r4,sp,158
8111fcdc:	18c00044 	addi	r3,r3,1
8111fce0:	10800044 	addi	r2,r2,1
8111fce4:	41000015 	stw	r4,0(r8)
8111fce8:	01000044 	movi	r4,1
8111fcec:	41000115 	stw	r4,4(r8)
8111fcf0:	d8c02015 	stw	r3,128(sp)
8111fcf4:	d8801f15 	stw	r2,124(sp)
8111fcf8:	010001c4 	movi	r4,7
8111fcfc:	20823816 	blt	r4,r2,811205e0 <___svfprintf_internal_r+0x10f0>
8111fd00:	42000204 	addi	r8,r8,8
8111fd04:	d8802b17 	ldw	r2,172(sp)
8111fd08:	10000c26 	beq	r2,zero,8111fd3c <___svfprintf_internal_r+0x84c>
8111fd0c:	d8801f17 	ldw	r2,124(sp)
8111fd10:	d9002704 	addi	r4,sp,156
8111fd14:	18c00084 	addi	r3,r3,2
8111fd18:	10800044 	addi	r2,r2,1
8111fd1c:	41000015 	stw	r4,0(r8)
8111fd20:	01000084 	movi	r4,2
8111fd24:	41000115 	stw	r4,4(r8)
8111fd28:	d8c02015 	stw	r3,128(sp)
8111fd2c:	d8801f15 	stw	r2,124(sp)
8111fd30:	010001c4 	movi	r4,7
8111fd34:	20823216 	blt	r4,r2,81120600 <___svfprintf_internal_r+0x1110>
8111fd38:	42000204 	addi	r8,r8,8
8111fd3c:	d9003017 	ldw	r4,192(sp)
8111fd40:	00802004 	movi	r2,128
8111fd44:	20819726 	beq	r4,r2,811203a4 <___svfprintf_internal_r+0xeb4>
8111fd48:	d9402917 	ldw	r5,164(sp)
8111fd4c:	d8802e17 	ldw	r2,184(sp)
8111fd50:	28adc83a 	sub	r22,r5,r2
8111fd54:	05802f0e 	bge	zero,r22,8111fe14 <___svfprintf_internal_r+0x924>
8111fd58:	07000404 	movi	fp,16
8111fd5c:	d8801f17 	ldw	r2,124(sp)
8111fd60:	e583c00e 	bge	fp,r22,81120c64 <___svfprintf_internal_r+0x1774>
8111fd64:	01604574 	movhi	r5,33045
8111fd68:	29739b84 	addi	r5,r5,-12690
8111fd6c:	dc402915 	stw	r17,164(sp)
8111fd70:	d9402b15 	stw	r5,172(sp)
8111fd74:	b023883a 	mov	r17,r22
8111fd78:	050001c4 	movi	r20,7
8111fd7c:	902d883a 	mov	r22,r18
8111fd80:	8025883a 	mov	r18,r16
8111fd84:	dc002c17 	ldw	r16,176(sp)
8111fd88:	00000306 	br	8111fd98 <___svfprintf_internal_r+0x8a8>
8111fd8c:	8c7ffc04 	addi	r17,r17,-16
8111fd90:	42000204 	addi	r8,r8,8
8111fd94:	e440110e 	bge	fp,r17,8111fddc <___svfprintf_internal_r+0x8ec>
8111fd98:	18c00404 	addi	r3,r3,16
8111fd9c:	10800044 	addi	r2,r2,1
8111fda0:	45400015 	stw	r21,0(r8)
8111fda4:	47000115 	stw	fp,4(r8)
8111fda8:	d8c02015 	stw	r3,128(sp)
8111fdac:	d8801f15 	stw	r2,124(sp)
8111fdb0:	a0bff60e 	bge	r20,r2,8111fd8c <__reset+0xfb0ffd8c>
8111fdb4:	d9801e04 	addi	r6,sp,120
8111fdb8:	800b883a 	mov	r5,r16
8111fdbc:	9809883a 	mov	r4,r19
8111fdc0:	112c1100 	call	8112c110 <__ssprint_r>
8111fdc4:	103eb11e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
8111fdc8:	8c7ffc04 	addi	r17,r17,-16
8111fdcc:	d8c02017 	ldw	r3,128(sp)
8111fdd0:	d8801f17 	ldw	r2,124(sp)
8111fdd4:	da000404 	addi	r8,sp,16
8111fdd8:	e47fef16 	blt	fp,r17,8111fd98 <__reset+0xfb0ffd98>
8111fddc:	9021883a 	mov	r16,r18
8111fde0:	b025883a 	mov	r18,r22
8111fde4:	882d883a 	mov	r22,r17
8111fde8:	dc402917 	ldw	r17,164(sp)
8111fdec:	d9002b17 	ldw	r4,172(sp)
8111fdf0:	1d87883a 	add	r3,r3,r22
8111fdf4:	10800044 	addi	r2,r2,1
8111fdf8:	41000015 	stw	r4,0(r8)
8111fdfc:	45800115 	stw	r22,4(r8)
8111fe00:	d8c02015 	stw	r3,128(sp)
8111fe04:	d8801f15 	stw	r2,124(sp)
8111fe08:	010001c4 	movi	r4,7
8111fe0c:	2081ec16 	blt	r4,r2,811205c0 <___svfprintf_internal_r+0x10d0>
8111fe10:	42000204 	addi	r8,r8,8
8111fe14:	9080400c 	andi	r2,r18,256
8111fe18:	1001181e 	bne	r2,zero,8112027c <___svfprintf_internal_r+0xd8c>
8111fe1c:	d9402e17 	ldw	r5,184(sp)
8111fe20:	d8801f17 	ldw	r2,124(sp)
8111fe24:	44000015 	stw	r16,0(r8)
8111fe28:	1947883a 	add	r3,r3,r5
8111fe2c:	10800044 	addi	r2,r2,1
8111fe30:	41400115 	stw	r5,4(r8)
8111fe34:	d8c02015 	stw	r3,128(sp)
8111fe38:	d8801f15 	stw	r2,124(sp)
8111fe3c:	010001c4 	movi	r4,7
8111fe40:	2081d116 	blt	r4,r2,81120588 <___svfprintf_internal_r+0x1098>
8111fe44:	42000204 	addi	r8,r8,8
8111fe48:	9480010c 	andi	r18,r18,4
8111fe4c:	90003226 	beq	r18,zero,8111ff18 <___svfprintf_internal_r+0xa28>
8111fe50:	d9403117 	ldw	r5,196(sp)
8111fe54:	d8802a17 	ldw	r2,168(sp)
8111fe58:	28a1c83a 	sub	r16,r5,r2
8111fe5c:	04002e0e 	bge	zero,r16,8111ff18 <___svfprintf_internal_r+0xa28>
8111fe60:	04400404 	movi	r17,16
8111fe64:	d8801f17 	ldw	r2,124(sp)
8111fe68:	8c04b90e 	bge	r17,r16,81121150 <___svfprintf_internal_r+0x1c60>
8111fe6c:	01604574 	movhi	r5,33045
8111fe70:	29739f84 	addi	r5,r5,-12674
8111fe74:	d9403515 	stw	r5,212(sp)
8111fe78:	048001c4 	movi	r18,7
8111fe7c:	dd002c17 	ldw	r20,176(sp)
8111fe80:	00000306 	br	8111fe90 <___svfprintf_internal_r+0x9a0>
8111fe84:	843ffc04 	addi	r16,r16,-16
8111fe88:	42000204 	addi	r8,r8,8
8111fe8c:	8c00130e 	bge	r17,r16,8111fedc <___svfprintf_internal_r+0x9ec>
8111fe90:	01204574 	movhi	r4,33045
8111fe94:	18c00404 	addi	r3,r3,16
8111fe98:	10800044 	addi	r2,r2,1
8111fe9c:	21339f84 	addi	r4,r4,-12674
8111fea0:	41000015 	stw	r4,0(r8)
8111fea4:	44400115 	stw	r17,4(r8)
8111fea8:	d8c02015 	stw	r3,128(sp)
8111feac:	d8801f15 	stw	r2,124(sp)
8111feb0:	90bff40e 	bge	r18,r2,8111fe84 <__reset+0xfb0ffe84>
8111feb4:	d9801e04 	addi	r6,sp,120
8111feb8:	a00b883a 	mov	r5,r20
8111febc:	9809883a 	mov	r4,r19
8111fec0:	112c1100 	call	8112c110 <__ssprint_r>
8111fec4:	103e711e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
8111fec8:	843ffc04 	addi	r16,r16,-16
8111fecc:	d8c02017 	ldw	r3,128(sp)
8111fed0:	d8801f17 	ldw	r2,124(sp)
8111fed4:	da000404 	addi	r8,sp,16
8111fed8:	8c3fed16 	blt	r17,r16,8111fe90 <__reset+0xfb0ffe90>
8111fedc:	d9403517 	ldw	r5,212(sp)
8111fee0:	1c07883a 	add	r3,r3,r16
8111fee4:	10800044 	addi	r2,r2,1
8111fee8:	41400015 	stw	r5,0(r8)
8111feec:	44000115 	stw	r16,4(r8)
8111fef0:	d8c02015 	stw	r3,128(sp)
8111fef4:	d8801f15 	stw	r2,124(sp)
8111fef8:	010001c4 	movi	r4,7
8111fefc:	2080060e 	bge	r4,r2,8111ff18 <___svfprintf_internal_r+0xa28>
8111ff00:	d9402c17 	ldw	r5,176(sp)
8111ff04:	d9801e04 	addi	r6,sp,120
8111ff08:	9809883a 	mov	r4,r19
8111ff0c:	112c1100 	call	8112c110 <__ssprint_r>
8111ff10:	103e5e1e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
8111ff14:	d8c02017 	ldw	r3,128(sp)
8111ff18:	d8803117 	ldw	r2,196(sp)
8111ff1c:	d9002a17 	ldw	r4,168(sp)
8111ff20:	1100010e 	bge	r2,r4,8111ff28 <___svfprintf_internal_r+0xa38>
8111ff24:	2005883a 	mov	r2,r4
8111ff28:	d9402f17 	ldw	r5,188(sp)
8111ff2c:	288b883a 	add	r5,r5,r2
8111ff30:	d9402f15 	stw	r5,188(sp)
8111ff34:	18019c1e 	bne	r3,zero,811205a8 <___svfprintf_internal_r+0x10b8>
8111ff38:	b8800007 	ldb	r2,0(r23)
8111ff3c:	d8001f15 	stw	zero,124(sp)
8111ff40:	da000404 	addi	r8,sp,16
8111ff44:	103d991e 	bne	r2,zero,8111f5ac <__reset+0xfb0ff5ac>
8111ff48:	b821883a 	mov	r16,r23
8111ff4c:	003daf06 	br	8111f60c <__reset+0xfb0ff60c>
8111ff50:	18c03fcc 	andi	r3,r3,255
8111ff54:	1805c71e 	bne	r3,zero,81121674 <___svfprintf_internal_r+0x2184>
8111ff58:	94800414 	ori	r18,r18,16
8111ff5c:	9080080c 	andi	r2,r18,32
8111ff60:	10020126 	beq	r2,zero,81120768 <___svfprintf_internal_r+0x1278>
8111ff64:	d8802d17 	ldw	r2,180(sp)
8111ff68:	d9002917 	ldw	r4,164(sp)
8111ff6c:	d8002785 	stb	zero,158(sp)
8111ff70:	10c00204 	addi	r3,r2,8
8111ff74:	15000017 	ldw	r20,0(r2)
8111ff78:	15800117 	ldw	r22,4(r2)
8111ff7c:	20038e16 	blt	r4,zero,81120db8 <___svfprintf_internal_r+0x18c8>
8111ff80:	013fdfc4 	movi	r4,-129
8111ff84:	a584b03a 	or	r2,r20,r22
8111ff88:	d8c02d15 	stw	r3,180(sp)
8111ff8c:	9124703a 	and	r18,r18,r4
8111ff90:	0039883a 	mov	fp,zero
8111ff94:	103eb61e 	bne	r2,zero,8111fa70 <__reset+0xfb0ffa70>
8111ff98:	d8802917 	ldw	r2,164(sp)
8111ff9c:	1002c81e 	bne	r2,zero,81120ac0 <___svfprintf_internal_r+0x15d0>
8111ffa0:	d8002915 	stw	zero,164(sp)
8111ffa4:	d8002e15 	stw	zero,184(sp)
8111ffa8:	dc001e04 	addi	r16,sp,120
8111ffac:	003efa06 	br	8111fb98 <__reset+0xfb0ffb98>
8111ffb0:	18c03fcc 	andi	r3,r3,255
8111ffb4:	1805ad1e 	bne	r3,zero,8112166c <___svfprintf_internal_r+0x217c>
8111ffb8:	01604574 	movhi	r5,33045
8111ffbc:	29738f04 	addi	r5,r5,-12740
8111ffc0:	d9403a15 	stw	r5,232(sp)
8111ffc4:	9080080c 	andi	r2,r18,32
8111ffc8:	10006126 	beq	r2,zero,81120150 <___svfprintf_internal_r+0xc60>
8111ffcc:	d8802d17 	ldw	r2,180(sp)
8111ffd0:	15000017 	ldw	r20,0(r2)
8111ffd4:	15800117 	ldw	r22,4(r2)
8111ffd8:	10800204 	addi	r2,r2,8
8111ffdc:	d8802d15 	stw	r2,180(sp)
8111ffe0:	9080004c 	andi	r2,r18,1
8111ffe4:	10018e26 	beq	r2,zero,81120620 <___svfprintf_internal_r+0x1130>
8111ffe8:	a584b03a 	or	r2,r20,r22
8111ffec:	10030926 	beq	r2,zero,81120c14 <___svfprintf_internal_r+0x1724>
8111fff0:	d8c02917 	ldw	r3,164(sp)
8111fff4:	00800c04 	movi	r2,48
8111fff8:	d8802705 	stb	r2,156(sp)
8111fffc:	dc402745 	stb	r17,157(sp)
81120000:	d8002785 	stb	zero,158(sp)
81120004:	90800094 	ori	r2,r18,2
81120008:	18048716 	blt	r3,zero,81121228 <___svfprintf_internal_r+0x1d38>
8112000c:	00bfdfc4 	movi	r2,-129
81120010:	90a4703a 	and	r18,r18,r2
81120014:	94800094 	ori	r18,r18,2
81120018:	0039883a 	mov	fp,zero
8112001c:	d9003a17 	ldw	r4,232(sp)
81120020:	dc001e04 	addi	r16,sp,120
81120024:	a08003cc 	andi	r2,r20,15
81120028:	b006973a 	slli	r3,r22,28
8112002c:	2085883a 	add	r2,r4,r2
81120030:	a028d13a 	srli	r20,r20,4
81120034:	10800003 	ldbu	r2,0(r2)
81120038:	b02cd13a 	srli	r22,r22,4
8112003c:	843fffc4 	addi	r16,r16,-1
81120040:	1d28b03a 	or	r20,r3,r20
81120044:	80800005 	stb	r2,0(r16)
81120048:	a584b03a 	or	r2,r20,r22
8112004c:	103ff51e 	bne	r2,zero,81120024 <__reset+0xfb100024>
81120050:	d8c02817 	ldw	r3,160(sp)
81120054:	1c07c83a 	sub	r3,r3,r16
81120058:	d8c02e15 	stw	r3,184(sp)
8112005c:	003ece06 	br	8111fb98 <__reset+0xfb0ffb98>
81120060:	d8c02d17 	ldw	r3,180(sp)
81120064:	d9002d17 	ldw	r4,180(sp)
81120068:	d8002785 	stb	zero,158(sp)
8112006c:	18800017 	ldw	r2,0(r3)
81120070:	21000104 	addi	r4,r4,4
81120074:	00c00044 	movi	r3,1
81120078:	d8c02a15 	stw	r3,168(sp)
8112007c:	d8801405 	stb	r2,80(sp)
81120080:	d9002d15 	stw	r4,180(sp)
81120084:	d8c02e15 	stw	r3,184(sp)
81120088:	d8002915 	stw	zero,164(sp)
8112008c:	d8003215 	stw	zero,200(sp)
81120090:	dc001404 	addi	r16,sp,80
81120094:	0039883a 	mov	fp,zero
81120098:	003ecc06 	br	8111fbcc <__reset+0xfb0ffbcc>
8112009c:	18c03fcc 	andi	r3,r3,255
811200a0:	183e9226 	beq	r3,zero,8111faec <__reset+0xfb0ffaec>
811200a4:	d9c02785 	stb	r7,158(sp)
811200a8:	003e9006 	br	8111faec <__reset+0xfb0ffaec>
811200ac:	00c00044 	movi	r3,1
811200b0:	01c00ac4 	movi	r7,43
811200b4:	bc400007 	ldb	r17,0(r23)
811200b8:	003d6306 	br	8111f648 <__reset+0xfb0ff648>
811200bc:	94800814 	ori	r18,r18,32
811200c0:	bc400007 	ldb	r17,0(r23)
811200c4:	003d6006 	br	8111f648 <__reset+0xfb0ff648>
811200c8:	d8c02d17 	ldw	r3,180(sp)
811200cc:	d8002785 	stb	zero,158(sp)
811200d0:	1c000017 	ldw	r16,0(r3)
811200d4:	1d000104 	addi	r20,r3,4
811200d8:	80040f26 	beq	r16,zero,81121118 <___svfprintf_internal_r+0x1c28>
811200dc:	d9002917 	ldw	r4,164(sp)
811200e0:	2003dc16 	blt	r4,zero,81121054 <___svfprintf_internal_r+0x1b64>
811200e4:	200d883a 	mov	r6,r4
811200e8:	000b883a 	mov	r5,zero
811200ec:	8009883a 	mov	r4,r16
811200f0:	da003e15 	stw	r8,248(sp)
811200f4:	11286b40 	call	811286b4 <memchr>
811200f8:	da003e17 	ldw	r8,248(sp)
811200fc:	10045826 	beq	r2,zero,81121260 <___svfprintf_internal_r+0x1d70>
81120100:	1405c83a 	sub	r2,r2,r16
81120104:	d8802e15 	stw	r2,184(sp)
81120108:	1003d816 	blt	r2,zero,8112106c <___svfprintf_internal_r+0x1b7c>
8112010c:	df002783 	ldbu	fp,158(sp)
81120110:	d8802a15 	stw	r2,168(sp)
81120114:	dd002d15 	stw	r20,180(sp)
81120118:	d8002915 	stw	zero,164(sp)
8112011c:	d8003215 	stw	zero,200(sp)
81120120:	003ea306 	br	8111fbb0 <__reset+0xfb0ffbb0>
81120124:	18c03fcc 	andi	r3,r3,255
81120128:	183f8c26 	beq	r3,zero,8111ff5c <__reset+0xfb0fff5c>
8112012c:	d9c02785 	stb	r7,158(sp)
81120130:	003f8a06 	br	8111ff5c <__reset+0xfb0fff5c>
81120134:	18c03fcc 	andi	r3,r3,255
81120138:	1805631e 	bne	r3,zero,811216c8 <___svfprintf_internal_r+0x21d8>
8112013c:	01604574 	movhi	r5,33045
81120140:	29739404 	addi	r5,r5,-12720
81120144:	d9403a15 	stw	r5,232(sp)
81120148:	9080080c 	andi	r2,r18,32
8112014c:	103f9f1e 	bne	r2,zero,8111ffcc <__reset+0xfb0fffcc>
81120150:	9080040c 	andi	r2,r18,16
81120154:	10029c26 	beq	r2,zero,81120bc8 <___svfprintf_internal_r+0x16d8>
81120158:	d8c02d17 	ldw	r3,180(sp)
8112015c:	002d883a 	mov	r22,zero
81120160:	1d000017 	ldw	r20,0(r3)
81120164:	18c00104 	addi	r3,r3,4
81120168:	d8c02d15 	stw	r3,180(sp)
8112016c:	003f9c06 	br	8111ffe0 <__reset+0xfb0fffe0>
81120170:	94800054 	ori	r18,r18,1
81120174:	bc400007 	ldb	r17,0(r23)
81120178:	003d3306 	br	8111f648 <__reset+0xfb0ff648>
8112017c:	38803fcc 	andi	r2,r7,255
81120180:	1080201c 	xori	r2,r2,128
81120184:	10bfe004 	addi	r2,r2,-128
81120188:	1002971e 	bne	r2,zero,81120be8 <___svfprintf_internal_r+0x16f8>
8112018c:	00c00044 	movi	r3,1
81120190:	01c00804 	movi	r7,32
81120194:	bc400007 	ldb	r17,0(r23)
81120198:	003d2b06 	br	8111f648 <__reset+0xfb0ff648>
8112019c:	18c03fcc 	andi	r3,r3,255
811201a0:	183e2326 	beq	r3,zero,8111fa30 <__reset+0xfb0ffa30>
811201a4:	d9c02785 	stb	r7,158(sp)
811201a8:	003e2106 	br	8111fa30 <__reset+0xfb0ffa30>
811201ac:	bc400007 	ldb	r17,0(r23)
811201b0:	8a430426 	beq	r17,r9,81120dc4 <___svfprintf_internal_r+0x18d4>
811201b4:	94800414 	ori	r18,r18,16
811201b8:	003d2306 	br	8111f648 <__reset+0xfb0ff648>
811201bc:	18c03fcc 	andi	r3,r3,255
811201c0:	18053f1e 	bne	r3,zero,811216c0 <___svfprintf_internal_r+0x21d0>
811201c4:	9080080c 	andi	r2,r18,32
811201c8:	10028926 	beq	r2,zero,81120bf0 <___svfprintf_internal_r+0x1700>
811201cc:	d9402d17 	ldw	r5,180(sp)
811201d0:	d9002f17 	ldw	r4,188(sp)
811201d4:	28800017 	ldw	r2,0(r5)
811201d8:	2007d7fa 	srai	r3,r4,31
811201dc:	29400104 	addi	r5,r5,4
811201e0:	d9402d15 	stw	r5,180(sp)
811201e4:	11000015 	stw	r4,0(r2)
811201e8:	10c00115 	stw	r3,4(r2)
811201ec:	003ced06 	br	8111f5a4 <__reset+0xfb0ff5a4>
811201f0:	94801014 	ori	r18,r18,64
811201f4:	bc400007 	ldb	r17,0(r23)
811201f8:	003d1306 	br	8111f648 <__reset+0xfb0ff648>
811201fc:	01204574 	movhi	r4,33045
81120200:	21339404 	addi	r4,r4,-12720
81120204:	0039883a 	mov	fp,zero
81120208:	d9003a15 	stw	r4,232(sp)
8112020c:	04401e04 	movi	r17,120
81120210:	003f8206 	br	8112001c <__reset+0xfb10001c>
81120214:	18c03fcc 	andi	r3,r3,255
81120218:	1805221e 	bne	r3,zero,811216a4 <___svfprintf_internal_r+0x21b4>
8112021c:	883d9526 	beq	r17,zero,8111f874 <__reset+0xfb0ff874>
81120220:	00c00044 	movi	r3,1
81120224:	d8c02a15 	stw	r3,168(sp)
81120228:	dc401405 	stb	r17,80(sp)
8112022c:	d8002785 	stb	zero,158(sp)
81120230:	003f9406 	br	81120084 <__reset+0xfb100084>
81120234:	01204574 	movhi	r4,33045
81120238:	21339404 	addi	r4,r4,-12720
8112023c:	d9003a15 	stw	r4,232(sp)
81120240:	d8c02d15 	stw	r3,180(sp)
81120244:	1025883a 	mov	r18,r2
81120248:	04401e04 	movi	r17,120
8112024c:	a584b03a 	or	r2,r20,r22
81120250:	1000fa1e 	bne	r2,zero,8112063c <___svfprintf_internal_r+0x114c>
81120254:	0039883a 	mov	fp,zero
81120258:	00800084 	movi	r2,2
8112025c:	10803fcc 	andi	r2,r2,255
81120260:	00c00044 	movi	r3,1
81120264:	10c21626 	beq	r2,r3,81120ac0 <___svfprintf_internal_r+0x15d0>
81120268:	00c00084 	movi	r3,2
8112026c:	10fe301e 	bne	r2,r3,8111fb30 <__reset+0xfb0ffb30>
81120270:	003d7606 	br	8111f84c <__reset+0xfb0ff84c>
81120274:	d8c02017 	ldw	r3,128(sp)
81120278:	003e9506 	br	8111fcd0 <__reset+0xfb0ffcd0>
8112027c:	00801944 	movi	r2,101
81120280:	14407c0e 	bge	r2,r17,81120474 <___svfprintf_internal_r+0xf84>
81120284:	d9003617 	ldw	r4,216(sp)
81120288:	d9403717 	ldw	r5,220(sp)
8112028c:	000d883a 	mov	r6,zero
81120290:	000f883a 	mov	r7,zero
81120294:	d8c03d15 	stw	r3,244(sp)
81120298:	da003e15 	stw	r8,248(sp)
8112029c:	11321080 	call	81132108 <__eqdf2>
811202a0:	d8c03d17 	ldw	r3,244(sp)
811202a4:	da003e17 	ldw	r8,248(sp)
811202a8:	1000f51e 	bne	r2,zero,81120680 <___svfprintf_internal_r+0x1190>
811202ac:	d8801f17 	ldw	r2,124(sp)
811202b0:	01204574 	movhi	r4,33045
811202b4:	21339b04 	addi	r4,r4,-12692
811202b8:	18c00044 	addi	r3,r3,1
811202bc:	10800044 	addi	r2,r2,1
811202c0:	41000015 	stw	r4,0(r8)
811202c4:	01000044 	movi	r4,1
811202c8:	41000115 	stw	r4,4(r8)
811202cc:	d8c02015 	stw	r3,128(sp)
811202d0:	d8801f15 	stw	r2,124(sp)
811202d4:	010001c4 	movi	r4,7
811202d8:	20826616 	blt	r4,r2,81120c74 <___svfprintf_internal_r+0x1784>
811202dc:	42000204 	addi	r8,r8,8
811202e0:	d8802617 	ldw	r2,152(sp)
811202e4:	d9403317 	ldw	r5,204(sp)
811202e8:	11400216 	blt	r2,r5,811202f4 <___svfprintf_internal_r+0xe04>
811202ec:	9080004c 	andi	r2,r18,1
811202f0:	103ed526 	beq	r2,zero,8111fe48 <__reset+0xfb0ffe48>
811202f4:	d8803817 	ldw	r2,224(sp)
811202f8:	d9003417 	ldw	r4,208(sp)
811202fc:	d9403817 	ldw	r5,224(sp)
81120300:	1887883a 	add	r3,r3,r2
81120304:	d8801f17 	ldw	r2,124(sp)
81120308:	41000015 	stw	r4,0(r8)
8112030c:	41400115 	stw	r5,4(r8)
81120310:	10800044 	addi	r2,r2,1
81120314:	d8c02015 	stw	r3,128(sp)
81120318:	d8801f15 	stw	r2,124(sp)
8112031c:	010001c4 	movi	r4,7
81120320:	2082af16 	blt	r4,r2,81120de0 <___svfprintf_internal_r+0x18f0>
81120324:	42000204 	addi	r8,r8,8
81120328:	d8803317 	ldw	r2,204(sp)
8112032c:	143fffc4 	addi	r16,r2,-1
81120330:	043ec50e 	bge	zero,r16,8111fe48 <__reset+0xfb0ffe48>
81120334:	04400404 	movi	r17,16
81120338:	d8801f17 	ldw	r2,124(sp)
8112033c:	8c00860e 	bge	r17,r16,81120558 <___svfprintf_internal_r+0x1068>
81120340:	01604574 	movhi	r5,33045
81120344:	29739b84 	addi	r5,r5,-12690
81120348:	d9402b15 	stw	r5,172(sp)
8112034c:	058001c4 	movi	r22,7
81120350:	dd002c17 	ldw	r20,176(sp)
81120354:	00000306 	br	81120364 <___svfprintf_internal_r+0xe74>
81120358:	42000204 	addi	r8,r8,8
8112035c:	843ffc04 	addi	r16,r16,-16
81120360:	8c00800e 	bge	r17,r16,81120564 <___svfprintf_internal_r+0x1074>
81120364:	18c00404 	addi	r3,r3,16
81120368:	10800044 	addi	r2,r2,1
8112036c:	45400015 	stw	r21,0(r8)
81120370:	44400115 	stw	r17,4(r8)
81120374:	d8c02015 	stw	r3,128(sp)
81120378:	d8801f15 	stw	r2,124(sp)
8112037c:	b0bff60e 	bge	r22,r2,81120358 <__reset+0xfb100358>
81120380:	d9801e04 	addi	r6,sp,120
81120384:	a00b883a 	mov	r5,r20
81120388:	9809883a 	mov	r4,r19
8112038c:	112c1100 	call	8112c110 <__ssprint_r>
81120390:	103d3e1e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120394:	d8c02017 	ldw	r3,128(sp)
81120398:	d8801f17 	ldw	r2,124(sp)
8112039c:	da000404 	addi	r8,sp,16
811203a0:	003fee06 	br	8112035c <__reset+0xfb10035c>
811203a4:	d9403117 	ldw	r5,196(sp)
811203a8:	d8802a17 	ldw	r2,168(sp)
811203ac:	28adc83a 	sub	r22,r5,r2
811203b0:	05be650e 	bge	zero,r22,8111fd48 <__reset+0xfb0ffd48>
811203b4:	07000404 	movi	fp,16
811203b8:	d8801f17 	ldw	r2,124(sp)
811203bc:	e583a20e 	bge	fp,r22,81121248 <___svfprintf_internal_r+0x1d58>
811203c0:	01604574 	movhi	r5,33045
811203c4:	29739b84 	addi	r5,r5,-12690
811203c8:	dc403015 	stw	r17,192(sp)
811203cc:	d9402b15 	stw	r5,172(sp)
811203d0:	b023883a 	mov	r17,r22
811203d4:	050001c4 	movi	r20,7
811203d8:	902d883a 	mov	r22,r18
811203dc:	8025883a 	mov	r18,r16
811203e0:	dc002c17 	ldw	r16,176(sp)
811203e4:	00000306 	br	811203f4 <___svfprintf_internal_r+0xf04>
811203e8:	8c7ffc04 	addi	r17,r17,-16
811203ec:	42000204 	addi	r8,r8,8
811203f0:	e440110e 	bge	fp,r17,81120438 <___svfprintf_internal_r+0xf48>
811203f4:	18c00404 	addi	r3,r3,16
811203f8:	10800044 	addi	r2,r2,1
811203fc:	45400015 	stw	r21,0(r8)
81120400:	47000115 	stw	fp,4(r8)
81120404:	d8c02015 	stw	r3,128(sp)
81120408:	d8801f15 	stw	r2,124(sp)
8112040c:	a0bff60e 	bge	r20,r2,811203e8 <__reset+0xfb1003e8>
81120410:	d9801e04 	addi	r6,sp,120
81120414:	800b883a 	mov	r5,r16
81120418:	9809883a 	mov	r4,r19
8112041c:	112c1100 	call	8112c110 <__ssprint_r>
81120420:	103d1a1e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120424:	8c7ffc04 	addi	r17,r17,-16
81120428:	d8c02017 	ldw	r3,128(sp)
8112042c:	d8801f17 	ldw	r2,124(sp)
81120430:	da000404 	addi	r8,sp,16
81120434:	e47fef16 	blt	fp,r17,811203f4 <__reset+0xfb1003f4>
81120438:	9021883a 	mov	r16,r18
8112043c:	b025883a 	mov	r18,r22
81120440:	882d883a 	mov	r22,r17
81120444:	dc403017 	ldw	r17,192(sp)
81120448:	d9002b17 	ldw	r4,172(sp)
8112044c:	1d87883a 	add	r3,r3,r22
81120450:	10800044 	addi	r2,r2,1
81120454:	41000015 	stw	r4,0(r8)
81120458:	45800115 	stw	r22,4(r8)
8112045c:	d8c02015 	stw	r3,128(sp)
81120460:	d8801f15 	stw	r2,124(sp)
81120464:	010001c4 	movi	r4,7
81120468:	20819a16 	blt	r4,r2,81120ad4 <___svfprintf_internal_r+0x15e4>
8112046c:	42000204 	addi	r8,r8,8
81120470:	003e3506 	br	8111fd48 <__reset+0xfb0ffd48>
81120474:	d9403317 	ldw	r5,204(sp)
81120478:	00800044 	movi	r2,1
8112047c:	18c00044 	addi	r3,r3,1
81120480:	1141710e 	bge	r2,r5,81120a48 <___svfprintf_internal_r+0x1558>
81120484:	dc401f17 	ldw	r17,124(sp)
81120488:	00800044 	movi	r2,1
8112048c:	40800115 	stw	r2,4(r8)
81120490:	8c400044 	addi	r17,r17,1
81120494:	44000015 	stw	r16,0(r8)
81120498:	d8c02015 	stw	r3,128(sp)
8112049c:	dc401f15 	stw	r17,124(sp)
811204a0:	008001c4 	movi	r2,7
811204a4:	14417416 	blt	r2,r17,81120a78 <___svfprintf_internal_r+0x1588>
811204a8:	42000204 	addi	r8,r8,8
811204ac:	d8803817 	ldw	r2,224(sp)
811204b0:	d9003417 	ldw	r4,208(sp)
811204b4:	8c400044 	addi	r17,r17,1
811204b8:	10c7883a 	add	r3,r2,r3
811204bc:	40800115 	stw	r2,4(r8)
811204c0:	41000015 	stw	r4,0(r8)
811204c4:	d8c02015 	stw	r3,128(sp)
811204c8:	dc401f15 	stw	r17,124(sp)
811204cc:	008001c4 	movi	r2,7
811204d0:	14417216 	blt	r2,r17,81120a9c <___svfprintf_internal_r+0x15ac>
811204d4:	45800204 	addi	r22,r8,8
811204d8:	d9003617 	ldw	r4,216(sp)
811204dc:	d9403717 	ldw	r5,220(sp)
811204e0:	000d883a 	mov	r6,zero
811204e4:	000f883a 	mov	r7,zero
811204e8:	d8c03d15 	stw	r3,244(sp)
811204ec:	11321080 	call	81132108 <__eqdf2>
811204f0:	d8c03d17 	ldw	r3,244(sp)
811204f4:	1000b326 	beq	r2,zero,811207c4 <___svfprintf_internal_r+0x12d4>
811204f8:	d9403317 	ldw	r5,204(sp)
811204fc:	84000044 	addi	r16,r16,1
81120500:	8c400044 	addi	r17,r17,1
81120504:	28bfffc4 	addi	r2,r5,-1
81120508:	1887883a 	add	r3,r3,r2
8112050c:	b0800115 	stw	r2,4(r22)
81120510:	b4000015 	stw	r16,0(r22)
81120514:	d8c02015 	stw	r3,128(sp)
81120518:	dc401f15 	stw	r17,124(sp)
8112051c:	008001c4 	movi	r2,7
81120520:	1440d216 	blt	r2,r17,8112086c <___svfprintf_internal_r+0x137c>
81120524:	b5800204 	addi	r22,r22,8
81120528:	d9003b17 	ldw	r4,236(sp)
8112052c:	df0022c4 	addi	fp,sp,139
81120530:	8c400044 	addi	r17,r17,1
81120534:	20c7883a 	add	r3,r4,r3
81120538:	b7000015 	stw	fp,0(r22)
8112053c:	b1000115 	stw	r4,4(r22)
81120540:	d8c02015 	stw	r3,128(sp)
81120544:	dc401f15 	stw	r17,124(sp)
81120548:	008001c4 	movi	r2,7
8112054c:	14400e16 	blt	r2,r17,81120588 <___svfprintf_internal_r+0x1098>
81120550:	b2000204 	addi	r8,r22,8
81120554:	003e3c06 	br	8111fe48 <__reset+0xfb0ffe48>
81120558:	01204574 	movhi	r4,33045
8112055c:	21339b84 	addi	r4,r4,-12690
81120560:	d9002b15 	stw	r4,172(sp)
81120564:	d9002b17 	ldw	r4,172(sp)
81120568:	1c07883a 	add	r3,r3,r16
8112056c:	44000115 	stw	r16,4(r8)
81120570:	41000015 	stw	r4,0(r8)
81120574:	10800044 	addi	r2,r2,1
81120578:	d8c02015 	stw	r3,128(sp)
8112057c:	d8801f15 	stw	r2,124(sp)
81120580:	010001c4 	movi	r4,7
81120584:	20be2f0e 	bge	r4,r2,8111fe44 <__reset+0xfb0ffe44>
81120588:	d9402c17 	ldw	r5,176(sp)
8112058c:	d9801e04 	addi	r6,sp,120
81120590:	9809883a 	mov	r4,r19
81120594:	112c1100 	call	8112c110 <__ssprint_r>
81120598:	103cbc1e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
8112059c:	d8c02017 	ldw	r3,128(sp)
811205a0:	da000404 	addi	r8,sp,16
811205a4:	003e2806 	br	8111fe48 <__reset+0xfb0ffe48>
811205a8:	d9402c17 	ldw	r5,176(sp)
811205ac:	d9801e04 	addi	r6,sp,120
811205b0:	9809883a 	mov	r4,r19
811205b4:	112c1100 	call	8112c110 <__ssprint_r>
811205b8:	103e5f26 	beq	r2,zero,8111ff38 <__reset+0xfb0fff38>
811205bc:	003cb306 	br	8111f88c <__reset+0xfb0ff88c>
811205c0:	d9402c17 	ldw	r5,176(sp)
811205c4:	d9801e04 	addi	r6,sp,120
811205c8:	9809883a 	mov	r4,r19
811205cc:	112c1100 	call	8112c110 <__ssprint_r>
811205d0:	103cae1e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
811205d4:	d8c02017 	ldw	r3,128(sp)
811205d8:	da000404 	addi	r8,sp,16
811205dc:	003e0d06 	br	8111fe14 <__reset+0xfb0ffe14>
811205e0:	d9402c17 	ldw	r5,176(sp)
811205e4:	d9801e04 	addi	r6,sp,120
811205e8:	9809883a 	mov	r4,r19
811205ec:	112c1100 	call	8112c110 <__ssprint_r>
811205f0:	103ca61e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
811205f4:	d8c02017 	ldw	r3,128(sp)
811205f8:	da000404 	addi	r8,sp,16
811205fc:	003dc106 	br	8111fd04 <__reset+0xfb0ffd04>
81120600:	d9402c17 	ldw	r5,176(sp)
81120604:	d9801e04 	addi	r6,sp,120
81120608:	9809883a 	mov	r4,r19
8112060c:	112c1100 	call	8112c110 <__ssprint_r>
81120610:	103c9e1e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120614:	d8c02017 	ldw	r3,128(sp)
81120618:	da000404 	addi	r8,sp,16
8112061c:	003dc706 	br	8111fd3c <__reset+0xfb0ffd3c>
81120620:	d8802917 	ldw	r2,164(sp)
81120624:	d8002785 	stb	zero,158(sp)
81120628:	103f0816 	blt	r2,zero,8112024c <__reset+0xfb10024c>
8112062c:	00ffdfc4 	movi	r3,-129
81120630:	a584b03a 	or	r2,r20,r22
81120634:	90e4703a 	and	r18,r18,r3
81120638:	103c8126 	beq	r2,zero,8111f840 <__reset+0xfb0ff840>
8112063c:	0039883a 	mov	fp,zero
81120640:	003e7606 	br	8112001c <__reset+0xfb10001c>
81120644:	9080040c 	andi	r2,r18,16
81120648:	10013d26 	beq	r2,zero,81120b40 <___svfprintf_internal_r+0x1650>
8112064c:	d9002d17 	ldw	r4,180(sp)
81120650:	d9402917 	ldw	r5,164(sp)
81120654:	d8002785 	stb	zero,158(sp)
81120658:	20800104 	addi	r2,r4,4
8112065c:	25000017 	ldw	r20,0(r4)
81120660:	002d883a 	mov	r22,zero
81120664:	28013f16 	blt	r5,zero,81120b64 <___svfprintf_internal_r+0x1674>
81120668:	00ffdfc4 	movi	r3,-129
8112066c:	d8802d15 	stw	r2,180(sp)
81120670:	90e4703a 	and	r18,r18,r3
81120674:	a03d2b26 	beq	r20,zero,8111fb24 <__reset+0xfb0ffb24>
81120678:	0039883a 	mov	fp,zero
8112067c:	003d2e06 	br	8111fb38 <__reset+0xfb0ffb38>
81120680:	dc402617 	ldw	r17,152(sp)
81120684:	0441830e 	bge	zero,r17,81120c94 <___svfprintf_internal_r+0x17a4>
81120688:	dc403217 	ldw	r17,200(sp)
8112068c:	d8803317 	ldw	r2,204(sp)
81120690:	1440010e 	bge	r2,r17,81120698 <___svfprintf_internal_r+0x11a8>
81120694:	1023883a 	mov	r17,r2
81120698:	04400a0e 	bge	zero,r17,811206c4 <___svfprintf_internal_r+0x11d4>
8112069c:	d8801f17 	ldw	r2,124(sp)
811206a0:	1c47883a 	add	r3,r3,r17
811206a4:	44000015 	stw	r16,0(r8)
811206a8:	10800044 	addi	r2,r2,1
811206ac:	44400115 	stw	r17,4(r8)
811206b0:	d8c02015 	stw	r3,128(sp)
811206b4:	d8801f15 	stw	r2,124(sp)
811206b8:	010001c4 	movi	r4,7
811206bc:	20827516 	blt	r4,r2,81121094 <___svfprintf_internal_r+0x1ba4>
811206c0:	42000204 	addi	r8,r8,8
811206c4:	88027b16 	blt	r17,zero,811210b4 <___svfprintf_internal_r+0x1bc4>
811206c8:	d9003217 	ldw	r4,200(sp)
811206cc:	2463c83a 	sub	r17,r4,r17
811206d0:	0440990e 	bge	zero,r17,81120938 <___svfprintf_internal_r+0x1448>
811206d4:	05800404 	movi	r22,16
811206d8:	d8801f17 	ldw	r2,124(sp)
811206dc:	b441530e 	bge	r22,r17,81120c2c <___svfprintf_internal_r+0x173c>
811206e0:	01204574 	movhi	r4,33045
811206e4:	21339b84 	addi	r4,r4,-12690
811206e8:	d9002b15 	stw	r4,172(sp)
811206ec:	070001c4 	movi	fp,7
811206f0:	dd002c17 	ldw	r20,176(sp)
811206f4:	00000306 	br	81120704 <___svfprintf_internal_r+0x1214>
811206f8:	42000204 	addi	r8,r8,8
811206fc:	8c7ffc04 	addi	r17,r17,-16
81120700:	b4414d0e 	bge	r22,r17,81120c38 <___svfprintf_internal_r+0x1748>
81120704:	18c00404 	addi	r3,r3,16
81120708:	10800044 	addi	r2,r2,1
8112070c:	45400015 	stw	r21,0(r8)
81120710:	45800115 	stw	r22,4(r8)
81120714:	d8c02015 	stw	r3,128(sp)
81120718:	d8801f15 	stw	r2,124(sp)
8112071c:	e0bff60e 	bge	fp,r2,811206f8 <__reset+0xfb1006f8>
81120720:	d9801e04 	addi	r6,sp,120
81120724:	a00b883a 	mov	r5,r20
81120728:	9809883a 	mov	r4,r19
8112072c:	112c1100 	call	8112c110 <__ssprint_r>
81120730:	103c561e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120734:	d8c02017 	ldw	r3,128(sp)
81120738:	d8801f17 	ldw	r2,124(sp)
8112073c:	da000404 	addi	r8,sp,16
81120740:	003fee06 	br	811206fc <__reset+0xfb1006fc>
81120744:	d9402c17 	ldw	r5,176(sp)
81120748:	d9801e04 	addi	r6,sp,120
8112074c:	9809883a 	mov	r4,r19
81120750:	112c1100 	call	8112c110 <__ssprint_r>
81120754:	103c4d1e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120758:	d8c02017 	ldw	r3,128(sp)
8112075c:	df002787 	ldb	fp,158(sp)
81120760:	da000404 	addi	r8,sp,16
81120764:	003d5a06 	br	8111fcd0 <__reset+0xfb0ffcd0>
81120768:	9080040c 	andi	r2,r18,16
8112076c:	10005c26 	beq	r2,zero,811208e0 <___svfprintf_internal_r+0x13f0>
81120770:	d9402d17 	ldw	r5,180(sp)
81120774:	d8c02917 	ldw	r3,164(sp)
81120778:	d8002785 	stb	zero,158(sp)
8112077c:	28800104 	addi	r2,r5,4
81120780:	2d000017 	ldw	r20,0(r5)
81120784:	002d883a 	mov	r22,zero
81120788:	18005e16 	blt	r3,zero,81120904 <___svfprintf_internal_r+0x1414>
8112078c:	00ffdfc4 	movi	r3,-129
81120790:	d8802d15 	stw	r2,180(sp)
81120794:	90e4703a 	and	r18,r18,r3
81120798:	0039883a 	mov	fp,zero
8112079c:	a03dfe26 	beq	r20,zero,8111ff98 <__reset+0xfb0fff98>
811207a0:	00800244 	movi	r2,9
811207a4:	153cb336 	bltu	r2,r20,8111fa74 <__reset+0xfb0ffa74>
811207a8:	a5000c04 	addi	r20,r20,48
811207ac:	dc001dc4 	addi	r16,sp,119
811207b0:	dd001dc5 	stb	r20,119(sp)
811207b4:	d8c02817 	ldw	r3,160(sp)
811207b8:	1c07c83a 	sub	r3,r3,r16
811207bc:	d8c02e15 	stw	r3,184(sp)
811207c0:	003cf506 	br	8111fb98 <__reset+0xfb0ffb98>
811207c4:	d8803317 	ldw	r2,204(sp)
811207c8:	143fffc4 	addi	r16,r2,-1
811207cc:	043f560e 	bge	zero,r16,81120528 <__reset+0xfb100528>
811207d0:	07000404 	movi	fp,16
811207d4:	e403530e 	bge	fp,r16,81121524 <___svfprintf_internal_r+0x2034>
811207d8:	01604574 	movhi	r5,33045
811207dc:	29739b84 	addi	r5,r5,-12690
811207e0:	d9402b15 	stw	r5,172(sp)
811207e4:	01c001c4 	movi	r7,7
811207e8:	dd002c17 	ldw	r20,176(sp)
811207ec:	00000306 	br	811207fc <___svfprintf_internal_r+0x130c>
811207f0:	843ffc04 	addi	r16,r16,-16
811207f4:	b5800204 	addi	r22,r22,8
811207f8:	e400130e 	bge	fp,r16,81120848 <___svfprintf_internal_r+0x1358>
811207fc:	18c00404 	addi	r3,r3,16
81120800:	8c400044 	addi	r17,r17,1
81120804:	b5400015 	stw	r21,0(r22)
81120808:	b7000115 	stw	fp,4(r22)
8112080c:	d8c02015 	stw	r3,128(sp)
81120810:	dc401f15 	stw	r17,124(sp)
81120814:	3c7ff60e 	bge	r7,r17,811207f0 <__reset+0xfb1007f0>
81120818:	d9801e04 	addi	r6,sp,120
8112081c:	a00b883a 	mov	r5,r20
81120820:	9809883a 	mov	r4,r19
81120824:	d9c03d15 	stw	r7,244(sp)
81120828:	112c1100 	call	8112c110 <__ssprint_r>
8112082c:	d9c03d17 	ldw	r7,244(sp)
81120830:	103c161e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120834:	843ffc04 	addi	r16,r16,-16
81120838:	d8c02017 	ldw	r3,128(sp)
8112083c:	dc401f17 	ldw	r17,124(sp)
81120840:	dd800404 	addi	r22,sp,16
81120844:	e43fed16 	blt	fp,r16,811207fc <__reset+0xfb1007fc>
81120848:	d8802b17 	ldw	r2,172(sp)
8112084c:	1c07883a 	add	r3,r3,r16
81120850:	8c400044 	addi	r17,r17,1
81120854:	b0800015 	stw	r2,0(r22)
81120858:	b4000115 	stw	r16,4(r22)
8112085c:	d8c02015 	stw	r3,128(sp)
81120860:	dc401f15 	stw	r17,124(sp)
81120864:	008001c4 	movi	r2,7
81120868:	147f2e0e 	bge	r2,r17,81120524 <__reset+0xfb100524>
8112086c:	d9402c17 	ldw	r5,176(sp)
81120870:	d9801e04 	addi	r6,sp,120
81120874:	9809883a 	mov	r4,r19
81120878:	112c1100 	call	8112c110 <__ssprint_r>
8112087c:	103c031e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120880:	d8c02017 	ldw	r3,128(sp)
81120884:	dc401f17 	ldw	r17,124(sp)
81120888:	dd800404 	addi	r22,sp,16
8112088c:	003f2606 	br	81120528 <__reset+0xfb100528>
81120890:	9080040c 	andi	r2,r18,16
81120894:	1000c326 	beq	r2,zero,81120ba4 <___svfprintf_internal_r+0x16b4>
81120898:	d8802d17 	ldw	r2,180(sp)
8112089c:	15000017 	ldw	r20,0(r2)
811208a0:	10800104 	addi	r2,r2,4
811208a4:	d8802d15 	stw	r2,180(sp)
811208a8:	a02dd7fa 	srai	r22,r20,31
811208ac:	b005883a 	mov	r2,r22
811208b0:	103c680e 	bge	r2,zero,8111fa54 <__reset+0xfb0ffa54>
811208b4:	0529c83a 	sub	r20,zero,r20
811208b8:	a004c03a 	cmpne	r2,r20,zero
811208bc:	05adc83a 	sub	r22,zero,r22
811208c0:	b0adc83a 	sub	r22,r22,r2
811208c4:	d8802917 	ldw	r2,164(sp)
811208c8:	07000b44 	movi	fp,45
811208cc:	df002785 	stb	fp,158(sp)
811208d0:	10022e16 	blt	r2,zero,8112118c <___svfprintf_internal_r+0x1c9c>
811208d4:	00bfdfc4 	movi	r2,-129
811208d8:	90a4703a 	and	r18,r18,r2
811208dc:	003c6406 	br	8111fa70 <__reset+0xfb0ffa70>
811208e0:	9080100c 	andi	r2,r18,64
811208e4:	d8002785 	stb	zero,158(sp)
811208e8:	10012526 	beq	r2,zero,81120d80 <___svfprintf_internal_r+0x1890>
811208ec:	d9002d17 	ldw	r4,180(sp)
811208f0:	d9402917 	ldw	r5,164(sp)
811208f4:	002d883a 	mov	r22,zero
811208f8:	20800104 	addi	r2,r4,4
811208fc:	2500000b 	ldhu	r20,0(r4)
81120900:	283fa20e 	bge	r5,zero,8112078c <__reset+0xfb10078c>
81120904:	d8802d15 	stw	r2,180(sp)
81120908:	0039883a 	mov	fp,zero
8112090c:	a584b03a 	or	r2,r20,r22
81120910:	103c571e 	bne	r2,zero,8111fa70 <__reset+0xfb0ffa70>
81120914:	00800044 	movi	r2,1
81120918:	003e5006 	br	8112025c <__reset+0xfb10025c>
8112091c:	d9402c17 	ldw	r5,176(sp)
81120920:	d9801e04 	addi	r6,sp,120
81120924:	9809883a 	mov	r4,r19
81120928:	112c1100 	call	8112c110 <__ssprint_r>
8112092c:	103bd71e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120930:	d8c02017 	ldw	r3,128(sp)
81120934:	da000404 	addi	r8,sp,16
81120938:	d9003217 	ldw	r4,200(sp)
8112093c:	d8802617 	ldw	r2,152(sp)
81120940:	d9403317 	ldw	r5,204(sp)
81120944:	8123883a 	add	r17,r16,r4
81120948:	11400216 	blt	r2,r5,81120954 <___svfprintf_internal_r+0x1464>
8112094c:	9100004c 	andi	r4,r18,1
81120950:	20000d26 	beq	r4,zero,81120988 <___svfprintf_internal_r+0x1498>
81120954:	d9003817 	ldw	r4,224(sp)
81120958:	d9403417 	ldw	r5,208(sp)
8112095c:	1907883a 	add	r3,r3,r4
81120960:	d9001f17 	ldw	r4,124(sp)
81120964:	41400015 	stw	r5,0(r8)
81120968:	d9403817 	ldw	r5,224(sp)
8112096c:	21000044 	addi	r4,r4,1
81120970:	d8c02015 	stw	r3,128(sp)
81120974:	41400115 	stw	r5,4(r8)
81120978:	d9001f15 	stw	r4,124(sp)
8112097c:	014001c4 	movi	r5,7
81120980:	2901dc16 	blt	r5,r4,811210f4 <___svfprintf_internal_r+0x1c04>
81120984:	42000204 	addi	r8,r8,8
81120988:	d9003317 	ldw	r4,204(sp)
8112098c:	8121883a 	add	r16,r16,r4
81120990:	2085c83a 	sub	r2,r4,r2
81120994:	8461c83a 	sub	r16,r16,r17
81120998:	1400010e 	bge	r2,r16,811209a0 <___svfprintf_internal_r+0x14b0>
8112099c:	1021883a 	mov	r16,r2
811209a0:	04000a0e 	bge	zero,r16,811209cc <___svfprintf_internal_r+0x14dc>
811209a4:	d9001f17 	ldw	r4,124(sp)
811209a8:	1c07883a 	add	r3,r3,r16
811209ac:	44400015 	stw	r17,0(r8)
811209b0:	21000044 	addi	r4,r4,1
811209b4:	44000115 	stw	r16,4(r8)
811209b8:	d8c02015 	stw	r3,128(sp)
811209bc:	d9001f15 	stw	r4,124(sp)
811209c0:	014001c4 	movi	r5,7
811209c4:	2901e616 	blt	r5,r4,81121160 <___svfprintf_internal_r+0x1c70>
811209c8:	42000204 	addi	r8,r8,8
811209cc:	8001f616 	blt	r16,zero,811211a8 <___svfprintf_internal_r+0x1cb8>
811209d0:	1421c83a 	sub	r16,r2,r16
811209d4:	043d1c0e 	bge	zero,r16,8111fe48 <__reset+0xfb0ffe48>
811209d8:	04400404 	movi	r17,16
811209dc:	d8801f17 	ldw	r2,124(sp)
811209e0:	8c3edd0e 	bge	r17,r16,81120558 <__reset+0xfb100558>
811209e4:	01604574 	movhi	r5,33045
811209e8:	29739b84 	addi	r5,r5,-12690
811209ec:	d9402b15 	stw	r5,172(sp)
811209f0:	058001c4 	movi	r22,7
811209f4:	dd002c17 	ldw	r20,176(sp)
811209f8:	00000306 	br	81120a08 <___svfprintf_internal_r+0x1518>
811209fc:	42000204 	addi	r8,r8,8
81120a00:	843ffc04 	addi	r16,r16,-16
81120a04:	8c3ed70e 	bge	r17,r16,81120564 <__reset+0xfb100564>
81120a08:	18c00404 	addi	r3,r3,16
81120a0c:	10800044 	addi	r2,r2,1
81120a10:	45400015 	stw	r21,0(r8)
81120a14:	44400115 	stw	r17,4(r8)
81120a18:	d8c02015 	stw	r3,128(sp)
81120a1c:	d8801f15 	stw	r2,124(sp)
81120a20:	b0bff60e 	bge	r22,r2,811209fc <__reset+0xfb1009fc>
81120a24:	d9801e04 	addi	r6,sp,120
81120a28:	a00b883a 	mov	r5,r20
81120a2c:	9809883a 	mov	r4,r19
81120a30:	112c1100 	call	8112c110 <__ssprint_r>
81120a34:	103b951e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120a38:	d8c02017 	ldw	r3,128(sp)
81120a3c:	d8801f17 	ldw	r2,124(sp)
81120a40:	da000404 	addi	r8,sp,16
81120a44:	003fee06 	br	81120a00 <__reset+0xfb100a00>
81120a48:	9088703a 	and	r4,r18,r2
81120a4c:	203e8d1e 	bne	r4,zero,81120484 <__reset+0xfb100484>
81120a50:	dc401f17 	ldw	r17,124(sp)
81120a54:	40800115 	stw	r2,4(r8)
81120a58:	44000015 	stw	r16,0(r8)
81120a5c:	8c400044 	addi	r17,r17,1
81120a60:	d8c02015 	stw	r3,128(sp)
81120a64:	dc401f15 	stw	r17,124(sp)
81120a68:	008001c4 	movi	r2,7
81120a6c:	147f7f16 	blt	r2,r17,8112086c <__reset+0xfb10086c>
81120a70:	45800204 	addi	r22,r8,8
81120a74:	003eac06 	br	81120528 <__reset+0xfb100528>
81120a78:	d9402c17 	ldw	r5,176(sp)
81120a7c:	d9801e04 	addi	r6,sp,120
81120a80:	9809883a 	mov	r4,r19
81120a84:	112c1100 	call	8112c110 <__ssprint_r>
81120a88:	103b801e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120a8c:	d8c02017 	ldw	r3,128(sp)
81120a90:	dc401f17 	ldw	r17,124(sp)
81120a94:	da000404 	addi	r8,sp,16
81120a98:	003e8406 	br	811204ac <__reset+0xfb1004ac>
81120a9c:	d9402c17 	ldw	r5,176(sp)
81120aa0:	d9801e04 	addi	r6,sp,120
81120aa4:	9809883a 	mov	r4,r19
81120aa8:	112c1100 	call	8112c110 <__ssprint_r>
81120aac:	103b771e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120ab0:	d8c02017 	ldw	r3,128(sp)
81120ab4:	dc401f17 	ldw	r17,124(sp)
81120ab8:	dd800404 	addi	r22,sp,16
81120abc:	003e8606 	br	811204d8 <__reset+0xfb1004d8>
81120ac0:	0029883a 	mov	r20,zero
81120ac4:	a5000c04 	addi	r20,r20,48
81120ac8:	dc001dc4 	addi	r16,sp,119
81120acc:	dd001dc5 	stb	r20,119(sp)
81120ad0:	003f3806 	br	811207b4 <__reset+0xfb1007b4>
81120ad4:	d9402c17 	ldw	r5,176(sp)
81120ad8:	d9801e04 	addi	r6,sp,120
81120adc:	9809883a 	mov	r4,r19
81120ae0:	112c1100 	call	8112c110 <__ssprint_r>
81120ae4:	103b691e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120ae8:	d8c02017 	ldw	r3,128(sp)
81120aec:	da000404 	addi	r8,sp,16
81120af0:	003c9506 	br	8111fd48 <__reset+0xfb0ffd48>
81120af4:	d9003617 	ldw	r4,216(sp)
81120af8:	d9403717 	ldw	r5,220(sp)
81120afc:	da003e15 	stw	r8,248(sp)
81120b00:	1129f240 	call	81129f24 <__fpclassifyd>
81120b04:	da003e17 	ldw	r8,248(sp)
81120b08:	1000bd1e 	bne	r2,zero,81120e00 <___svfprintf_internal_r+0x1910>
81120b0c:	008011c4 	movi	r2,71
81120b10:	14411e0e 	bge	r2,r17,81120f8c <___svfprintf_internal_r+0x1a9c>
81120b14:	04204574 	movhi	r16,33045
81120b18:	84338e04 	addi	r16,r16,-12744
81120b1c:	00c000c4 	movi	r3,3
81120b20:	00bfdfc4 	movi	r2,-129
81120b24:	d8c02a15 	stw	r3,168(sp)
81120b28:	90a4703a 	and	r18,r18,r2
81120b2c:	df002783 	ldbu	fp,158(sp)
81120b30:	d8c02e15 	stw	r3,184(sp)
81120b34:	d8002915 	stw	zero,164(sp)
81120b38:	d8003215 	stw	zero,200(sp)
81120b3c:	003c1c06 	br	8111fbb0 <__reset+0xfb0ffbb0>
81120b40:	9080100c 	andi	r2,r18,64
81120b44:	d8002785 	stb	zero,158(sp)
81120b48:	10009426 	beq	r2,zero,81120d9c <___svfprintf_internal_r+0x18ac>
81120b4c:	d8c02d17 	ldw	r3,180(sp)
81120b50:	d9002917 	ldw	r4,164(sp)
81120b54:	002d883a 	mov	r22,zero
81120b58:	18800104 	addi	r2,r3,4
81120b5c:	1d00000b 	ldhu	r20,0(r3)
81120b60:	203ec10e 	bge	r4,zero,81120668 <__reset+0xfb100668>
81120b64:	a586b03a 	or	r3,r20,r22
81120b68:	d8802d15 	stw	r2,180(sp)
81120b6c:	183ec21e 	bne	r3,zero,81120678 <__reset+0xfb100678>
81120b70:	0039883a 	mov	fp,zero
81120b74:	0005883a 	mov	r2,zero
81120b78:	003db806 	br	8112025c <__reset+0xfb10025c>
81120b7c:	d8802d17 	ldw	r2,180(sp)
81120b80:	d8c02d17 	ldw	r3,180(sp)
81120b84:	d9002d17 	ldw	r4,180(sp)
81120b88:	10800017 	ldw	r2,0(r2)
81120b8c:	18c00117 	ldw	r3,4(r3)
81120b90:	21000204 	addi	r4,r4,8
81120b94:	d8803615 	stw	r2,216(sp)
81120b98:	d8c03715 	stw	r3,220(sp)
81120b9c:	d9002d15 	stw	r4,180(sp)
81120ba0:	003b8206 	br	8111f9ac <__reset+0xfb0ff9ac>
81120ba4:	9080100c 	andi	r2,r18,64
81120ba8:	10010726 	beq	r2,zero,81120fc8 <___svfprintf_internal_r+0x1ad8>
81120bac:	d8c02d17 	ldw	r3,180(sp)
81120bb0:	1d00000f 	ldh	r20,0(r3)
81120bb4:	18c00104 	addi	r3,r3,4
81120bb8:	d8c02d15 	stw	r3,180(sp)
81120bbc:	a02dd7fa 	srai	r22,r20,31
81120bc0:	b005883a 	mov	r2,r22
81120bc4:	003ba206 	br	8111fa50 <__reset+0xfb0ffa50>
81120bc8:	9080100c 	andi	r2,r18,64
81120bcc:	10010526 	beq	r2,zero,81120fe4 <___svfprintf_internal_r+0x1af4>
81120bd0:	d9002d17 	ldw	r4,180(sp)
81120bd4:	002d883a 	mov	r22,zero
81120bd8:	2500000b 	ldhu	r20,0(r4)
81120bdc:	21000104 	addi	r4,r4,4
81120be0:	d9002d15 	stw	r4,180(sp)
81120be4:	003cfe06 	br	8111ffe0 <__reset+0xfb0fffe0>
81120be8:	bc400007 	ldb	r17,0(r23)
81120bec:	003a9606 	br	8111f648 <__reset+0xfb0ff648>
81120bf0:	9080040c 	andi	r2,r18,16
81120bf4:	10010126 	beq	r2,zero,81120ffc <___svfprintf_internal_r+0x1b0c>
81120bf8:	d9402d17 	ldw	r5,180(sp)
81120bfc:	d8c02f17 	ldw	r3,188(sp)
81120c00:	28800017 	ldw	r2,0(r5)
81120c04:	29400104 	addi	r5,r5,4
81120c08:	d9402d15 	stw	r5,180(sp)
81120c0c:	10c00015 	stw	r3,0(r2)
81120c10:	003a6406 	br	8111f5a4 <__reset+0xfb0ff5a4>
81120c14:	d9002917 	ldw	r4,164(sp)
81120c18:	d8002785 	stb	zero,158(sp)
81120c1c:	203d8d16 	blt	r4,zero,81120254 <__reset+0xfb100254>
81120c20:	00bfdfc4 	movi	r2,-129
81120c24:	90a4703a 	and	r18,r18,r2
81120c28:	003b0506 	br	8111f840 <__reset+0xfb0ff840>
81120c2c:	01604574 	movhi	r5,33045
81120c30:	29739b84 	addi	r5,r5,-12690
81120c34:	d9402b15 	stw	r5,172(sp)
81120c38:	d9402b17 	ldw	r5,172(sp)
81120c3c:	1c47883a 	add	r3,r3,r17
81120c40:	10800044 	addi	r2,r2,1
81120c44:	41400015 	stw	r5,0(r8)
81120c48:	44400115 	stw	r17,4(r8)
81120c4c:	d8c02015 	stw	r3,128(sp)
81120c50:	d8801f15 	stw	r2,124(sp)
81120c54:	010001c4 	movi	r4,7
81120c58:	20bf3016 	blt	r4,r2,8112091c <__reset+0xfb10091c>
81120c5c:	42000204 	addi	r8,r8,8
81120c60:	003f3506 	br	81120938 <__reset+0xfb100938>
81120c64:	01204574 	movhi	r4,33045
81120c68:	21339b84 	addi	r4,r4,-12690
81120c6c:	d9002b15 	stw	r4,172(sp)
81120c70:	003c5e06 	br	8111fdec <__reset+0xfb0ffdec>
81120c74:	d9402c17 	ldw	r5,176(sp)
81120c78:	d9801e04 	addi	r6,sp,120
81120c7c:	9809883a 	mov	r4,r19
81120c80:	112c1100 	call	8112c110 <__ssprint_r>
81120c84:	103b011e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120c88:	d8c02017 	ldw	r3,128(sp)
81120c8c:	da000404 	addi	r8,sp,16
81120c90:	003d9306 	br	811202e0 <__reset+0xfb1002e0>
81120c94:	d8801f17 	ldw	r2,124(sp)
81120c98:	01604574 	movhi	r5,33045
81120c9c:	01000044 	movi	r4,1
81120ca0:	18c00044 	addi	r3,r3,1
81120ca4:	10800044 	addi	r2,r2,1
81120ca8:	29739b04 	addi	r5,r5,-12692
81120cac:	41000115 	stw	r4,4(r8)
81120cb0:	41400015 	stw	r5,0(r8)
81120cb4:	d8c02015 	stw	r3,128(sp)
81120cb8:	d8801f15 	stw	r2,124(sp)
81120cbc:	010001c4 	movi	r4,7
81120cc0:	2080b516 	blt	r4,r2,81120f98 <___svfprintf_internal_r+0x1aa8>
81120cc4:	42000204 	addi	r8,r8,8
81120cc8:	8800041e 	bne	r17,zero,81120cdc <___svfprintf_internal_r+0x17ec>
81120ccc:	d8803317 	ldw	r2,204(sp)
81120cd0:	1000021e 	bne	r2,zero,81120cdc <___svfprintf_internal_r+0x17ec>
81120cd4:	9080004c 	andi	r2,r18,1
81120cd8:	103c5b26 	beq	r2,zero,8111fe48 <__reset+0xfb0ffe48>
81120cdc:	d9003817 	ldw	r4,224(sp)
81120ce0:	d8801f17 	ldw	r2,124(sp)
81120ce4:	d9403417 	ldw	r5,208(sp)
81120ce8:	20c7883a 	add	r3,r4,r3
81120cec:	10800044 	addi	r2,r2,1
81120cf0:	41000115 	stw	r4,4(r8)
81120cf4:	41400015 	stw	r5,0(r8)
81120cf8:	d8c02015 	stw	r3,128(sp)
81120cfc:	d8801f15 	stw	r2,124(sp)
81120d00:	010001c4 	movi	r4,7
81120d04:	20818016 	blt	r4,r2,81121308 <___svfprintf_internal_r+0x1e18>
81120d08:	42000204 	addi	r8,r8,8
81120d0c:	0463c83a 	sub	r17,zero,r17
81120d10:	0440cb0e 	bge	zero,r17,81121040 <___svfprintf_internal_r+0x1b50>
81120d14:	05800404 	movi	r22,16
81120d18:	b440e80e 	bge	r22,r17,811210bc <___svfprintf_internal_r+0x1bcc>
81120d1c:	01604574 	movhi	r5,33045
81120d20:	29739b84 	addi	r5,r5,-12690
81120d24:	d9402b15 	stw	r5,172(sp)
81120d28:	070001c4 	movi	fp,7
81120d2c:	dd002c17 	ldw	r20,176(sp)
81120d30:	00000306 	br	81120d40 <___svfprintf_internal_r+0x1850>
81120d34:	42000204 	addi	r8,r8,8
81120d38:	8c7ffc04 	addi	r17,r17,-16
81120d3c:	b440e20e 	bge	r22,r17,811210c8 <___svfprintf_internal_r+0x1bd8>
81120d40:	18c00404 	addi	r3,r3,16
81120d44:	10800044 	addi	r2,r2,1
81120d48:	45400015 	stw	r21,0(r8)
81120d4c:	45800115 	stw	r22,4(r8)
81120d50:	d8c02015 	stw	r3,128(sp)
81120d54:	d8801f15 	stw	r2,124(sp)
81120d58:	e0bff60e 	bge	fp,r2,81120d34 <__reset+0xfb100d34>
81120d5c:	d9801e04 	addi	r6,sp,120
81120d60:	a00b883a 	mov	r5,r20
81120d64:	9809883a 	mov	r4,r19
81120d68:	112c1100 	call	8112c110 <__ssprint_r>
81120d6c:	103ac71e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120d70:	d8c02017 	ldw	r3,128(sp)
81120d74:	d8801f17 	ldw	r2,124(sp)
81120d78:	da000404 	addi	r8,sp,16
81120d7c:	003fee06 	br	81120d38 <__reset+0xfb100d38>
81120d80:	d8c02d17 	ldw	r3,180(sp)
81120d84:	d9002917 	ldw	r4,164(sp)
81120d88:	002d883a 	mov	r22,zero
81120d8c:	18800104 	addi	r2,r3,4
81120d90:	1d000017 	ldw	r20,0(r3)
81120d94:	203e7d0e 	bge	r4,zero,8112078c <__reset+0xfb10078c>
81120d98:	003eda06 	br	81120904 <__reset+0xfb100904>
81120d9c:	d9402d17 	ldw	r5,180(sp)
81120da0:	d8c02917 	ldw	r3,164(sp)
81120da4:	002d883a 	mov	r22,zero
81120da8:	28800104 	addi	r2,r5,4
81120dac:	2d000017 	ldw	r20,0(r5)
81120db0:	183e2d0e 	bge	r3,zero,81120668 <__reset+0xfb100668>
81120db4:	003f6b06 	br	81120b64 <__reset+0xfb100b64>
81120db8:	d8c02d15 	stw	r3,180(sp)
81120dbc:	0039883a 	mov	fp,zero
81120dc0:	003ed206 	br	8112090c <__reset+0xfb10090c>
81120dc4:	bc400043 	ldbu	r17,1(r23)
81120dc8:	94800814 	ori	r18,r18,32
81120dcc:	bdc00044 	addi	r23,r23,1
81120dd0:	8c403fcc 	andi	r17,r17,255
81120dd4:	8c40201c 	xori	r17,r17,128
81120dd8:	8c7fe004 	addi	r17,r17,-128
81120ddc:	003a1a06 	br	8111f648 <__reset+0xfb0ff648>
81120de0:	d9402c17 	ldw	r5,176(sp)
81120de4:	d9801e04 	addi	r6,sp,120
81120de8:	9809883a 	mov	r4,r19
81120dec:	112c1100 	call	8112c110 <__ssprint_r>
81120df0:	103aa61e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120df4:	d8c02017 	ldw	r3,128(sp)
81120df8:	da000404 	addi	r8,sp,16
81120dfc:	003d4a06 	br	81120328 <__reset+0xfb100328>
81120e00:	d9002917 	ldw	r4,164(sp)
81120e04:	05bff7c4 	movi	r22,-33
81120e08:	00bfffc4 	movi	r2,-1
81120e0c:	8dac703a 	and	r22,r17,r22
81120e10:	20806a26 	beq	r4,r2,81120fbc <___svfprintf_internal_r+0x1acc>
81120e14:	008011c4 	movi	r2,71
81120e18:	b0813726 	beq	r22,r2,811212f8 <___svfprintf_internal_r+0x1e08>
81120e1c:	d9003717 	ldw	r4,220(sp)
81120e20:	90c04014 	ori	r3,r18,256
81120e24:	d8c02b15 	stw	r3,172(sp)
81120e28:	20015d16 	blt	r4,zero,811213a0 <___svfprintf_internal_r+0x1eb0>
81120e2c:	dd003717 	ldw	r20,220(sp)
81120e30:	d8002a05 	stb	zero,168(sp)
81120e34:	00801984 	movi	r2,102
81120e38:	88814026 	beq	r17,r2,8112133c <___svfprintf_internal_r+0x1e4c>
81120e3c:	00801184 	movi	r2,70
81120e40:	88817126 	beq	r17,r2,81121408 <___svfprintf_internal_r+0x1f18>
81120e44:	00801144 	movi	r2,69
81120e48:	b0816226 	beq	r22,r2,811213d4 <___svfprintf_internal_r+0x1ee4>
81120e4c:	d8c02917 	ldw	r3,164(sp)
81120e50:	d8802104 	addi	r2,sp,132
81120e54:	d8800315 	stw	r2,12(sp)
81120e58:	d9403617 	ldw	r5,216(sp)
81120e5c:	d8802504 	addi	r2,sp,148
81120e60:	d8800215 	stw	r2,8(sp)
81120e64:	d8802604 	addi	r2,sp,152
81120e68:	d8c00015 	stw	r3,0(sp)
81120e6c:	d8800115 	stw	r2,4(sp)
81120e70:	01c00084 	movi	r7,2
81120e74:	a00d883a 	mov	r6,r20
81120e78:	9809883a 	mov	r4,r19
81120e7c:	d8c03d15 	stw	r3,244(sp)
81120e80:	da003e15 	stw	r8,248(sp)
81120e84:	11257dc0 	call	811257dc <_dtoa_r>
81120e88:	1021883a 	mov	r16,r2
81120e8c:	008019c4 	movi	r2,103
81120e90:	d8c03d17 	ldw	r3,244(sp)
81120e94:	da003e17 	ldw	r8,248(sp)
81120e98:	8880e726 	beq	r17,r2,81121238 <___svfprintf_internal_r+0x1d48>
81120e9c:	008011c4 	movi	r2,71
81120ea0:	8880d426 	beq	r17,r2,811211f4 <___svfprintf_internal_r+0x1d04>
81120ea4:	80f9883a 	add	fp,r16,r3
81120ea8:	d9003617 	ldw	r4,216(sp)
81120eac:	000d883a 	mov	r6,zero
81120eb0:	000f883a 	mov	r7,zero
81120eb4:	a00b883a 	mov	r5,r20
81120eb8:	da003e15 	stw	r8,248(sp)
81120ebc:	11321080 	call	81132108 <__eqdf2>
81120ec0:	da003e17 	ldw	r8,248(sp)
81120ec4:	1000e426 	beq	r2,zero,81121258 <___svfprintf_internal_r+0x1d68>
81120ec8:	d8802117 	ldw	r2,132(sp)
81120ecc:	1700062e 	bgeu	r2,fp,81120ee8 <___svfprintf_internal_r+0x19f8>
81120ed0:	01000c04 	movi	r4,48
81120ed4:	10c00044 	addi	r3,r2,1
81120ed8:	d8c02115 	stw	r3,132(sp)
81120edc:	11000005 	stb	r4,0(r2)
81120ee0:	d8802117 	ldw	r2,132(sp)
81120ee4:	173ffb36 	bltu	r2,fp,81120ed4 <__reset+0xfb100ed4>
81120ee8:	1405c83a 	sub	r2,r2,r16
81120eec:	d8803315 	stw	r2,204(sp)
81120ef0:	008011c4 	movi	r2,71
81120ef4:	b080c526 	beq	r22,r2,8112120c <___svfprintf_internal_r+0x1d1c>
81120ef8:	00801944 	movi	r2,101
81120efc:	1441d90e 	bge	r2,r17,81121664 <___svfprintf_internal_r+0x2174>
81120f00:	d8c02617 	ldw	r3,152(sp)
81120f04:	00801984 	movi	r2,102
81120f08:	d8c03215 	stw	r3,200(sp)
81120f0c:	88813426 	beq	r17,r2,811213e0 <___svfprintf_internal_r+0x1ef0>
81120f10:	d8c03217 	ldw	r3,200(sp)
81120f14:	d9003317 	ldw	r4,204(sp)
81120f18:	19012516 	blt	r3,r4,811213b0 <___svfprintf_internal_r+0x1ec0>
81120f1c:	9480004c 	andi	r18,r18,1
81120f20:	9001841e 	bne	r18,zero,81121534 <___svfprintf_internal_r+0x2044>
81120f24:	1805883a 	mov	r2,r3
81120f28:	1801cc16 	blt	r3,zero,8112165c <___svfprintf_internal_r+0x216c>
81120f2c:	d8c03217 	ldw	r3,200(sp)
81120f30:	044019c4 	movi	r17,103
81120f34:	d8c02e15 	stw	r3,184(sp)
81120f38:	df002a07 	ldb	fp,168(sp)
81120f3c:	e000a61e 	bne	fp,zero,811211d8 <___svfprintf_internal_r+0x1ce8>
81120f40:	df002783 	ldbu	fp,158(sp)
81120f44:	d8802a15 	stw	r2,168(sp)
81120f48:	dc802b17 	ldw	r18,172(sp)
81120f4c:	d8002915 	stw	zero,164(sp)
81120f50:	003b1706 	br	8111fbb0 <__reset+0xfb0ffbb0>
81120f54:	04204574 	movhi	r16,33045
81120f58:	84338b04 	addi	r16,r16,-12756
81120f5c:	003aa606 	br	8111f9f8 <__reset+0xfb0ff9f8>
81120f60:	d9003917 	ldw	r4,228(sp)
81120f64:	04001004 	movi	r16,64
81120f68:	800b883a 	mov	r5,r16
81120f6c:	111deb00 	call	8111deb0 <_malloc_r>
81120f70:	d9002c17 	ldw	r4,176(sp)
81120f74:	20800015 	stw	r2,0(r4)
81120f78:	20800415 	stw	r2,16(r4)
81120f7c:	1001cb26 	beq	r2,zero,811216ac <___svfprintf_internal_r+0x21bc>
81120f80:	d8802c17 	ldw	r2,176(sp)
81120f84:	14000515 	stw	r16,20(r2)
81120f88:	00397606 	br	8111f564 <__reset+0xfb0ff564>
81120f8c:	04204574 	movhi	r16,33045
81120f90:	84338d04 	addi	r16,r16,-12748
81120f94:	003ee106 	br	81120b1c <__reset+0xfb100b1c>
81120f98:	d9402c17 	ldw	r5,176(sp)
81120f9c:	d9801e04 	addi	r6,sp,120
81120fa0:	9809883a 	mov	r4,r19
81120fa4:	112c1100 	call	8112c110 <__ssprint_r>
81120fa8:	103a381e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81120fac:	dc402617 	ldw	r17,152(sp)
81120fb0:	d8c02017 	ldw	r3,128(sp)
81120fb4:	da000404 	addi	r8,sp,16
81120fb8:	003f4306 	br	81120cc8 <__reset+0xfb100cc8>
81120fbc:	01400184 	movi	r5,6
81120fc0:	d9402915 	stw	r5,164(sp)
81120fc4:	003f9506 	br	81120e1c <__reset+0xfb100e1c>
81120fc8:	d9002d17 	ldw	r4,180(sp)
81120fcc:	25000017 	ldw	r20,0(r4)
81120fd0:	21000104 	addi	r4,r4,4
81120fd4:	d9002d15 	stw	r4,180(sp)
81120fd8:	a02dd7fa 	srai	r22,r20,31
81120fdc:	b005883a 	mov	r2,r22
81120fe0:	003a9b06 	br	8111fa50 <__reset+0xfb0ffa50>
81120fe4:	d9402d17 	ldw	r5,180(sp)
81120fe8:	002d883a 	mov	r22,zero
81120fec:	2d000017 	ldw	r20,0(r5)
81120ff0:	29400104 	addi	r5,r5,4
81120ff4:	d9402d15 	stw	r5,180(sp)
81120ff8:	003bf906 	br	8111ffe0 <__reset+0xfb0fffe0>
81120ffc:	9480100c 	andi	r18,r18,64
81121000:	90006e26 	beq	r18,zero,811211bc <___svfprintf_internal_r+0x1ccc>
81121004:	d9002d17 	ldw	r4,180(sp)
81121008:	d9402f17 	ldw	r5,188(sp)
8112100c:	20800017 	ldw	r2,0(r4)
81121010:	21000104 	addi	r4,r4,4
81121014:	d9002d15 	stw	r4,180(sp)
81121018:	1140000d 	sth	r5,0(r2)
8112101c:	00396106 	br	8111f5a4 <__reset+0xfb0ff5a4>
81121020:	d9402c17 	ldw	r5,176(sp)
81121024:	d9801e04 	addi	r6,sp,120
81121028:	9809883a 	mov	r4,r19
8112102c:	112c1100 	call	8112c110 <__ssprint_r>
81121030:	103a161e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81121034:	d8c02017 	ldw	r3,128(sp)
81121038:	d8801f17 	ldw	r2,124(sp)
8112103c:	da000404 	addi	r8,sp,16
81121040:	d9403317 	ldw	r5,204(sp)
81121044:	10800044 	addi	r2,r2,1
81121048:	44000015 	stw	r16,0(r8)
8112104c:	28c7883a 	add	r3,r5,r3
81121050:	003b7706 	br	8111fe30 <__reset+0xfb0ffe30>
81121054:	8009883a 	mov	r4,r16
81121058:	da003e15 	stw	r8,248(sp)
8112105c:	111f1b80 	call	8111f1b8 <strlen>
81121060:	d8802e15 	stw	r2,184(sp)
81121064:	da003e17 	ldw	r8,248(sp)
81121068:	103c280e 	bge	r2,zero,8112010c <__reset+0xfb10010c>
8112106c:	0005883a 	mov	r2,zero
81121070:	003c2606 	br	8112010c <__reset+0xfb10010c>
81121074:	00bfffc4 	movi	r2,-1
81121078:	003a0906 	br	8111f8a0 <__reset+0xfb0ff8a0>
8112107c:	01204574 	movhi	r4,33045
81121080:	21339f84 	addi	r4,r4,-12674
81121084:	d9003515 	stw	r4,212(sp)
81121088:	003b0606 	br	8111fca4 <__reset+0xfb0ffca4>
8112108c:	013fffc4 	movi	r4,-1
81121090:	003a2706 	br	8111f930 <__reset+0xfb0ff930>
81121094:	d9402c17 	ldw	r5,176(sp)
81121098:	d9801e04 	addi	r6,sp,120
8112109c:	9809883a 	mov	r4,r19
811210a0:	112c1100 	call	8112c110 <__ssprint_r>
811210a4:	1039f91e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
811210a8:	d8c02017 	ldw	r3,128(sp)
811210ac:	da000404 	addi	r8,sp,16
811210b0:	003d8406 	br	811206c4 <__reset+0xfb1006c4>
811210b4:	0023883a 	mov	r17,zero
811210b8:	003d8306 	br	811206c8 <__reset+0xfb1006c8>
811210bc:	01204574 	movhi	r4,33045
811210c0:	21339b84 	addi	r4,r4,-12690
811210c4:	d9002b15 	stw	r4,172(sp)
811210c8:	d9002b17 	ldw	r4,172(sp)
811210cc:	1c47883a 	add	r3,r3,r17
811210d0:	10800044 	addi	r2,r2,1
811210d4:	41000015 	stw	r4,0(r8)
811210d8:	44400115 	stw	r17,4(r8)
811210dc:	d8c02015 	stw	r3,128(sp)
811210e0:	d8801f15 	stw	r2,124(sp)
811210e4:	010001c4 	movi	r4,7
811210e8:	20bfcd16 	blt	r4,r2,81121020 <__reset+0xfb101020>
811210ec:	42000204 	addi	r8,r8,8
811210f0:	003fd306 	br	81121040 <__reset+0xfb101040>
811210f4:	d9402c17 	ldw	r5,176(sp)
811210f8:	d9801e04 	addi	r6,sp,120
811210fc:	9809883a 	mov	r4,r19
81121100:	112c1100 	call	8112c110 <__ssprint_r>
81121104:	1039e11e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81121108:	d8802617 	ldw	r2,152(sp)
8112110c:	d8c02017 	ldw	r3,128(sp)
81121110:	da000404 	addi	r8,sp,16
81121114:	003e1c06 	br	81120988 <__reset+0xfb100988>
81121118:	d8802917 	ldw	r2,164(sp)
8112111c:	00c00184 	movi	r3,6
81121120:	1880012e 	bgeu	r3,r2,81121128 <___svfprintf_internal_r+0x1c38>
81121124:	1805883a 	mov	r2,r3
81121128:	d8802e15 	stw	r2,184(sp)
8112112c:	1000f316 	blt	r2,zero,811214fc <___svfprintf_internal_r+0x200c>
81121130:	04204574 	movhi	r16,33045
81121134:	d8802a15 	stw	r2,168(sp)
81121138:	dd002d15 	stw	r20,180(sp)
8112113c:	d8002915 	stw	zero,164(sp)
81121140:	d8003215 	stw	zero,200(sp)
81121144:	84339904 	addi	r16,r16,-12700
81121148:	0039883a 	mov	fp,zero
8112114c:	003a9f06 	br	8111fbcc <__reset+0xfb0ffbcc>
81121150:	01204574 	movhi	r4,33045
81121154:	21339f84 	addi	r4,r4,-12674
81121158:	d9003515 	stw	r4,212(sp)
8112115c:	003b5f06 	br	8111fedc <__reset+0xfb0ffedc>
81121160:	d9402c17 	ldw	r5,176(sp)
81121164:	d9801e04 	addi	r6,sp,120
81121168:	9809883a 	mov	r4,r19
8112116c:	112c1100 	call	8112c110 <__ssprint_r>
81121170:	1039c61e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
81121174:	d8802617 	ldw	r2,152(sp)
81121178:	d9403317 	ldw	r5,204(sp)
8112117c:	d8c02017 	ldw	r3,128(sp)
81121180:	da000404 	addi	r8,sp,16
81121184:	2885c83a 	sub	r2,r5,r2
81121188:	003e1006 	br	811209cc <__reset+0xfb1009cc>
8112118c:	00800044 	movi	r2,1
81121190:	10803fcc 	andi	r2,r2,255
81121194:	00c00044 	movi	r3,1
81121198:	10fa3526 	beq	r2,r3,8111fa70 <__reset+0xfb0ffa70>
8112119c:	00c00084 	movi	r3,2
811211a0:	10fb9e26 	beq	r2,r3,8112001c <__reset+0xfb10001c>
811211a4:	003a6406 	br	8111fb38 <__reset+0xfb0ffb38>
811211a8:	0021883a 	mov	r16,zero
811211ac:	003e0806 	br	811209d0 <__reset+0xfb1009d0>
811211b0:	07000b44 	movi	fp,45
811211b4:	df002785 	stb	fp,158(sp)
811211b8:	003a0b06 	br	8111f9e8 <__reset+0xfb0ff9e8>
811211bc:	d8c02d17 	ldw	r3,180(sp)
811211c0:	d9002f17 	ldw	r4,188(sp)
811211c4:	18800017 	ldw	r2,0(r3)
811211c8:	18c00104 	addi	r3,r3,4
811211cc:	d8c02d15 	stw	r3,180(sp)
811211d0:	11000015 	stw	r4,0(r2)
811211d4:	0038f306 	br	8111f5a4 <__reset+0xfb0ff5a4>
811211d8:	00c00b44 	movi	r3,45
811211dc:	d8c02785 	stb	r3,158(sp)
811211e0:	d8802a15 	stw	r2,168(sp)
811211e4:	dc802b17 	ldw	r18,172(sp)
811211e8:	d8002915 	stw	zero,164(sp)
811211ec:	07000b44 	movi	fp,45
811211f0:	003a7306 	br	8111fbc0 <__reset+0xfb0ffbc0>
811211f4:	9080004c 	andi	r2,r18,1
811211f8:	1000941e 	bne	r2,zero,8112144c <___svfprintf_internal_r+0x1f5c>
811211fc:	d8802117 	ldw	r2,132(sp)
81121200:	1405c83a 	sub	r2,r2,r16
81121204:	d8803315 	stw	r2,204(sp)
81121208:	b441161e 	bne	r22,r17,81121664 <___svfprintf_internal_r+0x2174>
8112120c:	dd802617 	ldw	r22,152(sp)
81121210:	00bfff44 	movi	r2,-3
81121214:	b0801a16 	blt	r22,r2,81121280 <___svfprintf_internal_r+0x1d90>
81121218:	d9402917 	ldw	r5,164(sp)
8112121c:	2d801816 	blt	r5,r22,81121280 <___svfprintf_internal_r+0x1d90>
81121220:	dd803215 	stw	r22,200(sp)
81121224:	003f3a06 	br	81120f10 <__reset+0xfb100f10>
81121228:	1025883a 	mov	r18,r2
8112122c:	0039883a 	mov	fp,zero
81121230:	00800084 	movi	r2,2
81121234:	003fd606 	br	81121190 <__reset+0xfb101190>
81121238:	9080004c 	andi	r2,r18,1
8112123c:	103f191e 	bne	r2,zero,81120ea4 <__reset+0xfb100ea4>
81121240:	d8802117 	ldw	r2,132(sp)
81121244:	003f2806 	br	81120ee8 <__reset+0xfb100ee8>
81121248:	01204574 	movhi	r4,33045
8112124c:	21339b84 	addi	r4,r4,-12690
81121250:	d9002b15 	stw	r4,172(sp)
81121254:	003c7c06 	br	81120448 <__reset+0xfb100448>
81121258:	e005883a 	mov	r2,fp
8112125c:	003f2206 	br	81120ee8 <__reset+0xfb100ee8>
81121260:	d9402917 	ldw	r5,164(sp)
81121264:	df002783 	ldbu	fp,158(sp)
81121268:	dd002d15 	stw	r20,180(sp)
8112126c:	d9402a15 	stw	r5,168(sp)
81121270:	d9402e15 	stw	r5,184(sp)
81121274:	d8002915 	stw	zero,164(sp)
81121278:	d8003215 	stw	zero,200(sp)
8112127c:	003a4c06 	br	8111fbb0 <__reset+0xfb0ffbb0>
81121280:	8c7fff84 	addi	r17,r17,-2
81121284:	b5bfffc4 	addi	r22,r22,-1
81121288:	dd802615 	stw	r22,152(sp)
8112128c:	dc4022c5 	stb	r17,139(sp)
81121290:	b000c316 	blt	r22,zero,811215a0 <___svfprintf_internal_r+0x20b0>
81121294:	00800ac4 	movi	r2,43
81121298:	d8802305 	stb	r2,140(sp)
8112129c:	00800244 	movi	r2,9
811212a0:	15806e16 	blt	r2,r22,8112145c <___svfprintf_internal_r+0x1f6c>
811212a4:	00800c04 	movi	r2,48
811212a8:	b5800c04 	addi	r22,r22,48
811212ac:	d8802345 	stb	r2,141(sp)
811212b0:	dd802385 	stb	r22,142(sp)
811212b4:	d88023c4 	addi	r2,sp,143
811212b8:	df0022c4 	addi	fp,sp,139
811212bc:	d8c03317 	ldw	r3,204(sp)
811212c0:	1739c83a 	sub	fp,r2,fp
811212c4:	d9003317 	ldw	r4,204(sp)
811212c8:	e0c7883a 	add	r3,fp,r3
811212cc:	df003b15 	stw	fp,236(sp)
811212d0:	d8c02e15 	stw	r3,184(sp)
811212d4:	00800044 	movi	r2,1
811212d8:	1100b70e 	bge	r2,r4,811215b8 <___svfprintf_internal_r+0x20c8>
811212dc:	d8c02e17 	ldw	r3,184(sp)
811212e0:	18c00044 	addi	r3,r3,1
811212e4:	d8c02e15 	stw	r3,184(sp)
811212e8:	1805883a 	mov	r2,r3
811212ec:	1800b016 	blt	r3,zero,811215b0 <___svfprintf_internal_r+0x20c0>
811212f0:	d8003215 	stw	zero,200(sp)
811212f4:	003f1006 	br	81120f38 <__reset+0xfb100f38>
811212f8:	d8802917 	ldw	r2,164(sp)
811212fc:	103ec71e 	bne	r2,zero,81120e1c <__reset+0xfb100e1c>
81121300:	dc002915 	stw	r16,164(sp)
81121304:	003ec506 	br	81120e1c <__reset+0xfb100e1c>
81121308:	d9402c17 	ldw	r5,176(sp)
8112130c:	d9801e04 	addi	r6,sp,120
81121310:	9809883a 	mov	r4,r19
81121314:	112c1100 	call	8112c110 <__ssprint_r>
81121318:	10395c1e 	bne	r2,zero,8111f88c <__reset+0xfb0ff88c>
8112131c:	dc402617 	ldw	r17,152(sp)
81121320:	d8c02017 	ldw	r3,128(sp)
81121324:	d8801f17 	ldw	r2,124(sp)
81121328:	da000404 	addi	r8,sp,16
8112132c:	003e7706 	br	81120d0c <__reset+0xfb100d0c>
81121330:	582f883a 	mov	r23,r11
81121334:	d8002915 	stw	zero,164(sp)
81121338:	0038c406 	br	8111f64c <__reset+0xfb0ff64c>
8112133c:	d8c02917 	ldw	r3,164(sp)
81121340:	d8802104 	addi	r2,sp,132
81121344:	d8800315 	stw	r2,12(sp)
81121348:	d9403617 	ldw	r5,216(sp)
8112134c:	d8802504 	addi	r2,sp,148
81121350:	d8800215 	stw	r2,8(sp)
81121354:	d8802604 	addi	r2,sp,152
81121358:	d8c00015 	stw	r3,0(sp)
8112135c:	9809883a 	mov	r4,r19
81121360:	d8800115 	stw	r2,4(sp)
81121364:	01c000c4 	movi	r7,3
81121368:	a00d883a 	mov	r6,r20
8112136c:	da003e15 	stw	r8,248(sp)
81121370:	11257dc0 	call	811257dc <_dtoa_r>
81121374:	d9002917 	ldw	r4,164(sp)
81121378:	da003e17 	ldw	r8,248(sp)
8112137c:	1021883a 	mov	r16,r2
81121380:	1139883a 	add	fp,r2,r4
81121384:	2007883a 	mov	r3,r4
81121388:	81000007 	ldb	r4,0(r16)
8112138c:	00800c04 	movi	r2,48
81121390:	20806f26 	beq	r4,r2,81121550 <___svfprintf_internal_r+0x2060>
81121394:	d8c02617 	ldw	r3,152(sp)
81121398:	e0f9883a 	add	fp,fp,r3
8112139c:	003ec206 	br	81120ea8 <__reset+0xfb100ea8>
811213a0:	00c00b44 	movi	r3,45
811213a4:	2520003c 	xorhi	r20,r4,32768
811213a8:	d8c02a05 	stb	r3,168(sp)
811213ac:	003ea106 	br	81120e34 <__reset+0xfb100e34>
811213b0:	d8c03217 	ldw	r3,200(sp)
811213b4:	00c0890e 	bge	zero,r3,811215dc <___svfprintf_internal_r+0x20ec>
811213b8:	00800044 	movi	r2,1
811213bc:	d9003317 	ldw	r4,204(sp)
811213c0:	1105883a 	add	r2,r2,r4
811213c4:	d8802e15 	stw	r2,184(sp)
811213c8:	10005f16 	blt	r2,zero,81121548 <___svfprintf_internal_r+0x2058>
811213cc:	044019c4 	movi	r17,103
811213d0:	003ed906 	br	81120f38 <__reset+0xfb100f38>
811213d4:	d9002917 	ldw	r4,164(sp)
811213d8:	20c00044 	addi	r3,r4,1
811213dc:	003e9c06 	br	81120e50 <__reset+0xfb100e50>
811213e0:	d9002917 	ldw	r4,164(sp)
811213e4:	00c0680e 	bge	zero,r3,81121588 <___svfprintf_internal_r+0x2098>
811213e8:	2000461e 	bne	r4,zero,81121504 <___svfprintf_internal_r+0x2014>
811213ec:	9480004c 	andi	r18,r18,1
811213f0:	9000441e 	bne	r18,zero,81121504 <___svfprintf_internal_r+0x2014>
811213f4:	1805883a 	mov	r2,r3
811213f8:	1800a016 	blt	r3,zero,8112167c <___svfprintf_internal_r+0x218c>
811213fc:	d8c03217 	ldw	r3,200(sp)
81121400:	d8c02e15 	stw	r3,184(sp)
81121404:	003ecc06 	br	81120f38 <__reset+0xfb100f38>
81121408:	d9402917 	ldw	r5,164(sp)
8112140c:	d8802104 	addi	r2,sp,132
81121410:	d8800315 	stw	r2,12(sp)
81121414:	d9400015 	stw	r5,0(sp)
81121418:	d8802504 	addi	r2,sp,148
8112141c:	d9403617 	ldw	r5,216(sp)
81121420:	d8800215 	stw	r2,8(sp)
81121424:	d8802604 	addi	r2,sp,152
81121428:	d8800115 	stw	r2,4(sp)
8112142c:	01c000c4 	movi	r7,3
81121430:	a00d883a 	mov	r6,r20
81121434:	9809883a 	mov	r4,r19
81121438:	da003e15 	stw	r8,248(sp)
8112143c:	11257dc0 	call	811257dc <_dtoa_r>
81121440:	d8c02917 	ldw	r3,164(sp)
81121444:	da003e17 	ldw	r8,248(sp)
81121448:	1021883a 	mov	r16,r2
8112144c:	00801184 	movi	r2,70
81121450:	80f9883a 	add	fp,r16,r3
81121454:	88bfcc26 	beq	r17,r2,81121388 <__reset+0xfb101388>
81121458:	003e9306 	br	81120ea8 <__reset+0xfb100ea8>
8112145c:	df0022c4 	addi	fp,sp,139
81121460:	dc002915 	stw	r16,164(sp)
81121464:	9829883a 	mov	r20,r19
81121468:	e021883a 	mov	r16,fp
8112146c:	4027883a 	mov	r19,r8
81121470:	b009883a 	mov	r4,r22
81121474:	01400284 	movi	r5,10
81121478:	1130c380 	call	81130c38 <__modsi3>
8112147c:	10800c04 	addi	r2,r2,48
81121480:	843fffc4 	addi	r16,r16,-1
81121484:	b009883a 	mov	r4,r22
81121488:	01400284 	movi	r5,10
8112148c:	80800005 	stb	r2,0(r16)
81121490:	1130bb40 	call	81130bb4 <__divsi3>
81121494:	102d883a 	mov	r22,r2
81121498:	00800244 	movi	r2,9
8112149c:	15bff416 	blt	r2,r22,81121470 <__reset+0xfb101470>
811214a0:	9811883a 	mov	r8,r19
811214a4:	b0800c04 	addi	r2,r22,48
811214a8:	a027883a 	mov	r19,r20
811214ac:	8029883a 	mov	r20,r16
811214b0:	a17fffc4 	addi	r5,r20,-1
811214b4:	a0bfffc5 	stb	r2,-1(r20)
811214b8:	dc002917 	ldw	r16,164(sp)
811214bc:	2f00752e 	bgeu	r5,fp,81121694 <___svfprintf_internal_r+0x21a4>
811214c0:	d9c02384 	addi	r7,sp,142
811214c4:	3d0fc83a 	sub	r7,r7,r20
811214c8:	d9002344 	addi	r4,sp,141
811214cc:	e1cf883a 	add	r7,fp,r7
811214d0:	00000106 	br	811214d8 <___svfprintf_internal_r+0x1fe8>
811214d4:	28800003 	ldbu	r2,0(r5)
811214d8:	20800005 	stb	r2,0(r4)
811214dc:	21000044 	addi	r4,r4,1
811214e0:	29400044 	addi	r5,r5,1
811214e4:	21fffb1e 	bne	r4,r7,811214d4 <__reset+0xfb1014d4>
811214e8:	d8802304 	addi	r2,sp,140
811214ec:	1505c83a 	sub	r2,r2,r20
811214f0:	d8c02344 	addi	r3,sp,141
811214f4:	1885883a 	add	r2,r3,r2
811214f8:	003f7006 	br	811212bc <__reset+0xfb1012bc>
811214fc:	0005883a 	mov	r2,zero
81121500:	003f0b06 	br	81121130 <__reset+0xfb101130>
81121504:	d9002917 	ldw	r4,164(sp)
81121508:	d8c03217 	ldw	r3,200(sp)
8112150c:	20800044 	addi	r2,r4,1
81121510:	1885883a 	add	r2,r3,r2
81121514:	d8802e15 	stw	r2,184(sp)
81121518:	103e870e 	bge	r2,zero,81120f38 <__reset+0xfb100f38>
8112151c:	0005883a 	mov	r2,zero
81121520:	003e8506 	br	81120f38 <__reset+0xfb100f38>
81121524:	01204574 	movhi	r4,33045
81121528:	21339b84 	addi	r4,r4,-12690
8112152c:	d9002b15 	stw	r4,172(sp)
81121530:	003cc506 	br	81120848 <__reset+0xfb100848>
81121534:	d8c03217 	ldw	r3,200(sp)
81121538:	18c00044 	addi	r3,r3,1
8112153c:	d8c02e15 	stw	r3,184(sp)
81121540:	1805883a 	mov	r2,r3
81121544:	183fa10e 	bge	r3,zero,811213cc <__reset+0xfb1013cc>
81121548:	0005883a 	mov	r2,zero
8112154c:	003f9f06 	br	811213cc <__reset+0xfb1013cc>
81121550:	d9003617 	ldw	r4,216(sp)
81121554:	000d883a 	mov	r6,zero
81121558:	000f883a 	mov	r7,zero
8112155c:	a00b883a 	mov	r5,r20
81121560:	d8c03d15 	stw	r3,244(sp)
81121564:	da003e15 	stw	r8,248(sp)
81121568:	11321080 	call	81132108 <__eqdf2>
8112156c:	d8c03d17 	ldw	r3,244(sp)
81121570:	da003e17 	ldw	r8,248(sp)
81121574:	103f8726 	beq	r2,zero,81121394 <__reset+0xfb101394>
81121578:	00800044 	movi	r2,1
8112157c:	10c7c83a 	sub	r3,r2,r3
81121580:	d8c02615 	stw	r3,152(sp)
81121584:	003f8406 	br	81121398 <__reset+0xfb101398>
81121588:	20000e1e 	bne	r4,zero,811215c4 <___svfprintf_internal_r+0x20d4>
8112158c:	9480004c 	andi	r18,r18,1
81121590:	90000c1e 	bne	r18,zero,811215c4 <___svfprintf_internal_r+0x20d4>
81121594:	00800044 	movi	r2,1
81121598:	d8802e15 	stw	r2,184(sp)
8112159c:	003e6606 	br	81120f38 <__reset+0xfb100f38>
811215a0:	00800b44 	movi	r2,45
811215a4:	05adc83a 	sub	r22,zero,r22
811215a8:	d8802305 	stb	r2,140(sp)
811215ac:	003f3b06 	br	8112129c <__reset+0xfb10129c>
811215b0:	0005883a 	mov	r2,zero
811215b4:	003f4e06 	br	811212f0 <__reset+0xfb1012f0>
811215b8:	90a4703a 	and	r18,r18,r2
811215bc:	903f4a26 	beq	r18,zero,811212e8 <__reset+0xfb1012e8>
811215c0:	003f4606 	br	811212dc <__reset+0xfb1012dc>
811215c4:	d8c02917 	ldw	r3,164(sp)
811215c8:	18c00084 	addi	r3,r3,2
811215cc:	d8c02e15 	stw	r3,184(sp)
811215d0:	1805883a 	mov	r2,r3
811215d4:	183e580e 	bge	r3,zero,81120f38 <__reset+0xfb100f38>
811215d8:	003fd006 	br	8112151c <__reset+0xfb10151c>
811215dc:	00800084 	movi	r2,2
811215e0:	10c5c83a 	sub	r2,r2,r3
811215e4:	003f7506 	br	811213bc <__reset+0xfb1013bc>
811215e8:	d8802d17 	ldw	r2,180(sp)
811215ec:	d9002d17 	ldw	r4,180(sp)
811215f0:	bc400043 	ldbu	r17,1(r23)
811215f4:	10800017 	ldw	r2,0(r2)
811215f8:	582f883a 	mov	r23,r11
811215fc:	d8802915 	stw	r2,164(sp)
81121600:	20800104 	addi	r2,r4,4
81121604:	d9002917 	ldw	r4,164(sp)
81121608:	d8802d15 	stw	r2,180(sp)
8112160c:	203df00e 	bge	r4,zero,81120dd0 <__reset+0xfb100dd0>
81121610:	8c403fcc 	andi	r17,r17,255
81121614:	00bfffc4 	movi	r2,-1
81121618:	8c40201c 	xori	r17,r17,128
8112161c:	d8802915 	stw	r2,164(sp)
81121620:	8c7fe004 	addi	r17,r17,-128
81121624:	00380806 	br	8111f648 <__reset+0xfb0ff648>
81121628:	9080004c 	andi	r2,r18,1
8112162c:	0039883a 	mov	fp,zero
81121630:	10000726 	beq	r2,zero,81121650 <___svfprintf_internal_r+0x2160>
81121634:	d8c02817 	ldw	r3,160(sp)
81121638:	dc001dc4 	addi	r16,sp,119
8112163c:	00800c04 	movi	r2,48
81121640:	1c07c83a 	sub	r3,r3,r16
81121644:	d8801dc5 	stb	r2,119(sp)
81121648:	d8c02e15 	stw	r3,184(sp)
8112164c:	00395206 	br	8111fb98 <__reset+0xfb0ffb98>
81121650:	d8002e15 	stw	zero,184(sp)
81121654:	dc001e04 	addi	r16,sp,120
81121658:	00394f06 	br	8111fb98 <__reset+0xfb0ffb98>
8112165c:	0005883a 	mov	r2,zero
81121660:	003e3206 	br	81120f2c <__reset+0xfb100f2c>
81121664:	dd802617 	ldw	r22,152(sp)
81121668:	003f0606 	br	81121284 <__reset+0xfb101284>
8112166c:	d9c02785 	stb	r7,158(sp)
81121670:	003a5106 	br	8111ffb8 <__reset+0xfb0fffb8>
81121674:	d9c02785 	stb	r7,158(sp)
81121678:	003a3706 	br	8111ff58 <__reset+0xfb0fff58>
8112167c:	0005883a 	mov	r2,zero
81121680:	003f5e06 	br	811213fc <__reset+0xfb1013fc>
81121684:	d9c02785 	stb	r7,158(sp)
81121688:	00391706 	br	8111fae8 <__reset+0xfb0ffae8>
8112168c:	d9c02785 	stb	r7,158(sp)
81121690:	0038e606 	br	8111fa2c <__reset+0xfb0ffa2c>
81121694:	d8802344 	addi	r2,sp,141
81121698:	003f0806 	br	811212bc <__reset+0xfb1012bc>
8112169c:	d9c02785 	stb	r7,158(sp)
811216a0:	0038b706 	br	8111f980 <__reset+0xfb0ff980>
811216a4:	d9c02785 	stb	r7,158(sp)
811216a8:	003adc06 	br	8112021c <__reset+0xfb10021c>
811216ac:	d9403917 	ldw	r5,228(sp)
811216b0:	00800304 	movi	r2,12
811216b4:	28800015 	stw	r2,0(r5)
811216b8:	00bfffc4 	movi	r2,-1
811216bc:	00387806 	br	8111f8a0 <__reset+0xfb0ff8a0>
811216c0:	d9c02785 	stb	r7,158(sp)
811216c4:	003abf06 	br	811201c4 <__reset+0xfb1001c4>
811216c8:	d9c02785 	stb	r7,158(sp)
811216cc:	003a9b06 	br	8112013c <__reset+0xfb10013c>

811216d0 <___vfprintf_internal_r>:
811216d0:	deffb804 	addi	sp,sp,-288
811216d4:	de00012e 	bgeu	sp,et,811216dc <___vfprintf_internal_r+0xc>
811216d8:	003b68fa 	trap	3
811216dc:	dfc04715 	stw	ra,284(sp)
811216e0:	ddc04515 	stw	r23,276(sp)
811216e4:	dd404315 	stw	r21,268(sp)
811216e8:	d9002c15 	stw	r4,176(sp)
811216ec:	282f883a 	mov	r23,r5
811216f0:	302b883a 	mov	r21,r6
811216f4:	d9c02d15 	stw	r7,180(sp)
811216f8:	df004615 	stw	fp,280(sp)
811216fc:	dd804415 	stw	r22,272(sp)
81121700:	dd004215 	stw	r20,264(sp)
81121704:	dcc04115 	stw	r19,260(sp)
81121708:	dc804015 	stw	r18,256(sp)
8112170c:	dc403f15 	stw	r17,252(sp)
81121710:	dc003e15 	stw	r16,248(sp)
81121714:	11283d80 	call	811283d8 <_localeconv_r>
81121718:	10800017 	ldw	r2,0(r2)
8112171c:	1009883a 	mov	r4,r2
81121720:	d8803415 	stw	r2,208(sp)
81121724:	111f1b80 	call	8111f1b8 <strlen>
81121728:	d8803715 	stw	r2,220(sp)
8112172c:	d8802c17 	ldw	r2,176(sp)
81121730:	10000226 	beq	r2,zero,8112173c <___vfprintf_internal_r+0x6c>
81121734:	10800e17 	ldw	r2,56(r2)
81121738:	1000f926 	beq	r2,zero,81121b20 <___vfprintf_internal_r+0x450>
8112173c:	b880030b 	ldhu	r2,12(r23)
81121740:	10c8000c 	andi	r3,r2,8192
81121744:	1800061e 	bne	r3,zero,81121760 <___vfprintf_internal_r+0x90>
81121748:	b9001917 	ldw	r4,100(r23)
8112174c:	00f7ffc4 	movi	r3,-8193
81121750:	10880014 	ori	r2,r2,8192
81121754:	20c6703a 	and	r3,r4,r3
81121758:	b880030d 	sth	r2,12(r23)
8112175c:	b8c01915 	stw	r3,100(r23)
81121760:	10c0020c 	andi	r3,r2,8
81121764:	1800c126 	beq	r3,zero,81121a6c <___vfprintf_internal_r+0x39c>
81121768:	b8c00417 	ldw	r3,16(r23)
8112176c:	1800bf26 	beq	r3,zero,81121a6c <___vfprintf_internal_r+0x39c>
81121770:	1080068c 	andi	r2,r2,26
81121774:	00c00284 	movi	r3,10
81121778:	10c0c426 	beq	r2,r3,81121a8c <___vfprintf_internal_r+0x3bc>
8112177c:	d8c00404 	addi	r3,sp,16
81121780:	05204574 	movhi	r20,33045
81121784:	d9001e04 	addi	r4,sp,120
81121788:	a533a384 	addi	r20,r20,-12658
8112178c:	d8c01e15 	stw	r3,120(sp)
81121790:	d8002015 	stw	zero,128(sp)
81121794:	d8001f15 	stw	zero,124(sp)
81121798:	d8003315 	stw	zero,204(sp)
8112179c:	d8003615 	stw	zero,216(sp)
811217a0:	d8003815 	stw	zero,224(sp)
811217a4:	1811883a 	mov	r8,r3
811217a8:	d8003915 	stw	zero,228(sp)
811217ac:	d8003a15 	stw	zero,232(sp)
811217b0:	d8002f15 	stw	zero,188(sp)
811217b4:	d9002815 	stw	r4,160(sp)
811217b8:	a8800007 	ldb	r2,0(r21)
811217bc:	10027b26 	beq	r2,zero,811221ac <___vfprintf_internal_r+0xadc>
811217c0:	00c00944 	movi	r3,37
811217c4:	a821883a 	mov	r16,r21
811217c8:	10c0021e 	bne	r2,r3,811217d4 <___vfprintf_internal_r+0x104>
811217cc:	00001406 	br	81121820 <___vfprintf_internal_r+0x150>
811217d0:	10c00326 	beq	r2,r3,811217e0 <___vfprintf_internal_r+0x110>
811217d4:	84000044 	addi	r16,r16,1
811217d8:	80800007 	ldb	r2,0(r16)
811217dc:	103ffc1e 	bne	r2,zero,811217d0 <__reset+0xfb1017d0>
811217e0:	8563c83a 	sub	r17,r16,r21
811217e4:	88000e26 	beq	r17,zero,81121820 <___vfprintf_internal_r+0x150>
811217e8:	d8c02017 	ldw	r3,128(sp)
811217ec:	d8801f17 	ldw	r2,124(sp)
811217f0:	45400015 	stw	r21,0(r8)
811217f4:	1c47883a 	add	r3,r3,r17
811217f8:	10800044 	addi	r2,r2,1
811217fc:	d8c02015 	stw	r3,128(sp)
81121800:	44400115 	stw	r17,4(r8)
81121804:	d8801f15 	stw	r2,124(sp)
81121808:	00c001c4 	movi	r3,7
8112180c:	1880a716 	blt	r3,r2,81121aac <___vfprintf_internal_r+0x3dc>
81121810:	42000204 	addi	r8,r8,8
81121814:	d9402f17 	ldw	r5,188(sp)
81121818:	2c4b883a 	add	r5,r5,r17
8112181c:	d9402f15 	stw	r5,188(sp)
81121820:	80800007 	ldb	r2,0(r16)
81121824:	1000a826 	beq	r2,zero,81121ac8 <___vfprintf_internal_r+0x3f8>
81121828:	84400047 	ldb	r17,1(r16)
8112182c:	00bfffc4 	movi	r2,-1
81121830:	85400044 	addi	r21,r16,1
81121834:	d8002785 	stb	zero,158(sp)
81121838:	0007883a 	mov	r3,zero
8112183c:	000f883a 	mov	r7,zero
81121840:	d8802915 	stw	r2,164(sp)
81121844:	d8003115 	stw	zero,196(sp)
81121848:	0025883a 	mov	r18,zero
8112184c:	01401604 	movi	r5,88
81121850:	01800244 	movi	r6,9
81121854:	02800a84 	movi	r10,42
81121858:	02401b04 	movi	r9,108
8112185c:	ad400044 	addi	r21,r21,1
81121860:	88bff804 	addi	r2,r17,-32
81121864:	28830436 	bltu	r5,r2,81122478 <___vfprintf_internal_r+0xda8>
81121868:	100490ba 	slli	r2,r2,2
8112186c:	012044b4 	movhi	r4,33042
81121870:	21062004 	addi	r4,r4,6272
81121874:	1105883a 	add	r2,r2,r4
81121878:	10800017 	ldw	r2,0(r2)
8112187c:	1000683a 	jmp	r2
81121880:	81122398 	cmpnei	r4,r16,18574
81121884:	81122478 	rdprs	r4,r16,18577
81121888:	81122478 	rdprs	r4,r16,18577
8112188c:	811223b8 	rdprs	r4,r16,18574
81121890:	81122478 	rdprs	r4,r16,18577
81121894:	81122478 	rdprs	r4,r16,18577
81121898:	81122478 	rdprs	r4,r16,18577
8112189c:	81122478 	rdprs	r4,r16,18577
811218a0:	81122478 	rdprs	r4,r16,18577
811218a4:	81122478 	rdprs	r4,r16,18577
811218a8:	81121b2c 	andhi	r4,r16,18540
811218ac:	811222d4 	ori	r4,r16,18571
811218b0:	81122478 	rdprs	r4,r16,18577
811218b4:	811219f4 	orhi	r4,r16,18535
811218b8:	81121b54 	ori	r4,r16,18541
811218bc:	81122478 	rdprs	r4,r16,18577
811218c0:	81121b94 	ori	r4,r16,18542
811218c4:	81121ba0 	cmpeqi	r4,r16,18542
811218c8:	81121ba0 	cmpeqi	r4,r16,18542
811218cc:	81121ba0 	cmpeqi	r4,r16,18542
811218d0:	81121ba0 	cmpeqi	r4,r16,18542
811218d4:	81121ba0 	cmpeqi	r4,r16,18542
811218d8:	81121ba0 	cmpeqi	r4,r16,18542
811218dc:	81121ba0 	cmpeqi	r4,r16,18542
811218e0:	81121ba0 	cmpeqi	r4,r16,18542
811218e4:	81121ba0 	cmpeqi	r4,r16,18542
811218e8:	81122478 	rdprs	r4,r16,18577
811218ec:	81122478 	rdprs	r4,r16,18577
811218f0:	81122478 	rdprs	r4,r16,18577
811218f4:	81122478 	rdprs	r4,r16,18577
811218f8:	81122478 	rdprs	r4,r16,18577
811218fc:	81122478 	rdprs	r4,r16,18577
81121900:	81122478 	rdprs	r4,r16,18577
81121904:	81122478 	rdprs	r4,r16,18577
81121908:	81122478 	rdprs	r4,r16,18577
8112190c:	81122478 	rdprs	r4,r16,18577
81121910:	81121bd4 	ori	r4,r16,18543
81121914:	81121c90 	cmplti	r4,r16,18546
81121918:	81122478 	rdprs	r4,r16,18577
8112191c:	81121c90 	cmplti	r4,r16,18546
81121920:	81122478 	rdprs	r4,r16,18577
81121924:	81122478 	rdprs	r4,r16,18577
81121928:	81122478 	rdprs	r4,r16,18577
8112192c:	81122478 	rdprs	r4,r16,18577
81121930:	81121d30 	cmpltui	r4,r16,18548
81121934:	81122478 	rdprs	r4,r16,18577
81121938:	81122478 	rdprs	r4,r16,18577
8112193c:	81121d3c 	xorhi	r4,r16,18548
81121940:	81122478 	rdprs	r4,r16,18577
81121944:	81122478 	rdprs	r4,r16,18577
81121948:	81122478 	rdprs	r4,r16,18577
8112194c:	81122478 	rdprs	r4,r16,18577
81121950:	81122478 	rdprs	r4,r16,18577
81121954:	811221b4 	orhi	r4,r16,18566
81121958:	81122478 	rdprs	r4,r16,18577
8112195c:	81122478 	rdprs	r4,r16,18577
81121960:	81122214 	ori	r4,r16,18568
81121964:	81122478 	rdprs	r4,r16,18577
81121968:	81122478 	rdprs	r4,r16,18577
8112196c:	81122478 	rdprs	r4,r16,18577
81121970:	81122478 	rdprs	r4,r16,18577
81121974:	81122478 	rdprs	r4,r16,18577
81121978:	81122478 	rdprs	r4,r16,18577
8112197c:	81122478 	rdprs	r4,r16,18577
81121980:	81122478 	rdprs	r4,r16,18577
81121984:	81122478 	rdprs	r4,r16,18577
81121988:	81122478 	rdprs	r4,r16,18577
8112198c:	81122424 	muli	r4,r16,18576
81121990:	811223c4 	addi	r4,r16,18575
81121994:	81121c90 	cmplti	r4,r16,18546
81121998:	81121c90 	cmplti	r4,r16,18546
8112199c:	81121c90 	cmplti	r4,r16,18546
811219a0:	811223d4 	ori	r4,r16,18575
811219a4:	811223c4 	addi	r4,r16,18575
811219a8:	81122478 	rdprs	r4,r16,18577
811219ac:	81122478 	rdprs	r4,r16,18577
811219b0:	811223e0 	cmpeqi	r4,r16,18575
811219b4:	81122478 	rdprs	r4,r16,18577
811219b8:	811223f0 	cmpltui	r4,r16,18575
811219bc:	811222c4 	addi	r4,r16,18571
811219c0:	81121a00 	call	881121a0 <__reset+0x20f21a0>
811219c4:	811222e4 	muli	r4,r16,18571
811219c8:	81122478 	rdprs	r4,r16,18577
811219cc:	811222f0 	cmpltui	r4,r16,18571
811219d0:	81122478 	rdprs	r4,r16,18577
811219d4:	8112234c 	andi	r4,r16,18573
811219d8:	81122478 	rdprs	r4,r16,18577
811219dc:	81122478 	rdprs	r4,r16,18577
811219e0:	8112235c 	xori	r4,r16,18573
811219e4:	d9003117 	ldw	r4,196(sp)
811219e8:	d8802d15 	stw	r2,180(sp)
811219ec:	0109c83a 	sub	r4,zero,r4
811219f0:	d9003115 	stw	r4,196(sp)
811219f4:	94800114 	ori	r18,r18,4
811219f8:	ac400007 	ldb	r17,0(r21)
811219fc:	003f9706 	br	8112185c <__reset+0xfb10185c>
81121a00:	00800c04 	movi	r2,48
81121a04:	d9002d17 	ldw	r4,180(sp)
81121a08:	d9402917 	ldw	r5,164(sp)
81121a0c:	d8802705 	stb	r2,156(sp)
81121a10:	00801e04 	movi	r2,120
81121a14:	d8802745 	stb	r2,157(sp)
81121a18:	d8002785 	stb	zero,158(sp)
81121a1c:	20c00104 	addi	r3,r4,4
81121a20:	24c00017 	ldw	r19,0(r4)
81121a24:	002d883a 	mov	r22,zero
81121a28:	90800094 	ori	r2,r18,2
81121a2c:	28029a16 	blt	r5,zero,81122498 <___vfprintf_internal_r+0xdc8>
81121a30:	00bfdfc4 	movi	r2,-129
81121a34:	90a4703a 	and	r18,r18,r2
81121a38:	d8c02d15 	stw	r3,180(sp)
81121a3c:	94800094 	ori	r18,r18,2
81121a40:	9802871e 	bne	r19,zero,81122460 <___vfprintf_internal_r+0xd90>
81121a44:	00a04574 	movhi	r2,33045
81121a48:	10b39404 	addi	r2,r2,-12720
81121a4c:	d8803915 	stw	r2,228(sp)
81121a50:	04401e04 	movi	r17,120
81121a54:	d8802917 	ldw	r2,164(sp)
81121a58:	0039883a 	mov	fp,zero
81121a5c:	1001e926 	beq	r2,zero,81122204 <___vfprintf_internal_r+0xb34>
81121a60:	0027883a 	mov	r19,zero
81121a64:	002d883a 	mov	r22,zero
81121a68:	00020506 	br	81122280 <___vfprintf_internal_r+0xbb0>
81121a6c:	d9002c17 	ldw	r4,176(sp)
81121a70:	b80b883a 	mov	r5,r23
81121a74:	112541c0 	call	8112541c <__swsetup_r>
81121a78:	1005ac1e 	bne	r2,zero,8112312c <___vfprintf_internal_r+0x1a5c>
81121a7c:	b880030b 	ldhu	r2,12(r23)
81121a80:	00c00284 	movi	r3,10
81121a84:	1080068c 	andi	r2,r2,26
81121a88:	10ff3c1e 	bne	r2,r3,8112177c <__reset+0xfb10177c>
81121a8c:	b880038f 	ldh	r2,14(r23)
81121a90:	103f3a16 	blt	r2,zero,8112177c <__reset+0xfb10177c>
81121a94:	d9c02d17 	ldw	r7,180(sp)
81121a98:	d9002c17 	ldw	r4,176(sp)
81121a9c:	a80d883a 	mov	r6,r21
81121aa0:	b80b883a 	mov	r5,r23
81121aa4:	11238ec0 	call	811238ec <__sbprintf>
81121aa8:	00001106 	br	81121af0 <___vfprintf_internal_r+0x420>
81121aac:	d9002c17 	ldw	r4,176(sp)
81121ab0:	d9801e04 	addi	r6,sp,120
81121ab4:	b80b883a 	mov	r5,r23
81121ab8:	112d8c00 	call	8112d8c0 <__sprint_r>
81121abc:	1000081e 	bne	r2,zero,81121ae0 <___vfprintf_internal_r+0x410>
81121ac0:	da000404 	addi	r8,sp,16
81121ac4:	003f5306 	br	81121814 <__reset+0xfb101814>
81121ac8:	d8802017 	ldw	r2,128(sp)
81121acc:	10000426 	beq	r2,zero,81121ae0 <___vfprintf_internal_r+0x410>
81121ad0:	d9002c17 	ldw	r4,176(sp)
81121ad4:	d9801e04 	addi	r6,sp,120
81121ad8:	b80b883a 	mov	r5,r23
81121adc:	112d8c00 	call	8112d8c0 <__sprint_r>
81121ae0:	b880030b 	ldhu	r2,12(r23)
81121ae4:	1080100c 	andi	r2,r2,64
81121ae8:	1005901e 	bne	r2,zero,8112312c <___vfprintf_internal_r+0x1a5c>
81121aec:	d8802f17 	ldw	r2,188(sp)
81121af0:	dfc04717 	ldw	ra,284(sp)
81121af4:	df004617 	ldw	fp,280(sp)
81121af8:	ddc04517 	ldw	r23,276(sp)
81121afc:	dd804417 	ldw	r22,272(sp)
81121b00:	dd404317 	ldw	r21,268(sp)
81121b04:	dd004217 	ldw	r20,264(sp)
81121b08:	dcc04117 	ldw	r19,260(sp)
81121b0c:	dc804017 	ldw	r18,256(sp)
81121b10:	dc403f17 	ldw	r17,252(sp)
81121b14:	dc003e17 	ldw	r16,248(sp)
81121b18:	dec04804 	addi	sp,sp,288
81121b1c:	f800283a 	ret
81121b20:	d9002c17 	ldw	r4,176(sp)
81121b24:	112748c0 	call	8112748c <__sinit>
81121b28:	003f0406 	br	8112173c <__reset+0xfb10173c>
81121b2c:	d8802d17 	ldw	r2,180(sp)
81121b30:	d9002d17 	ldw	r4,180(sp)
81121b34:	10800017 	ldw	r2,0(r2)
81121b38:	d8803115 	stw	r2,196(sp)
81121b3c:	20800104 	addi	r2,r4,4
81121b40:	d9003117 	ldw	r4,196(sp)
81121b44:	203fa716 	blt	r4,zero,811219e4 <__reset+0xfb1019e4>
81121b48:	d8802d15 	stw	r2,180(sp)
81121b4c:	ac400007 	ldb	r17,0(r21)
81121b50:	003f4206 	br	8112185c <__reset+0xfb10185c>
81121b54:	ac400007 	ldb	r17,0(r21)
81121b58:	aac00044 	addi	r11,r21,1
81121b5c:	8a872826 	beq	r17,r10,81123800 <___vfprintf_internal_r+0x2130>
81121b60:	88bff404 	addi	r2,r17,-48
81121b64:	0009883a 	mov	r4,zero
81121b68:	30867d36 	bltu	r6,r2,81123560 <___vfprintf_internal_r+0x1e90>
81121b6c:	5c400007 	ldb	r17,0(r11)
81121b70:	210002a4 	muli	r4,r4,10
81121b74:	5d400044 	addi	r21,r11,1
81121b78:	a817883a 	mov	r11,r21
81121b7c:	2089883a 	add	r4,r4,r2
81121b80:	88bff404 	addi	r2,r17,-48
81121b84:	30bff92e 	bgeu	r6,r2,81121b6c <__reset+0xfb101b6c>
81121b88:	2005c916 	blt	r4,zero,811232b0 <___vfprintf_internal_r+0x1be0>
81121b8c:	d9002915 	stw	r4,164(sp)
81121b90:	003f3306 	br	81121860 <__reset+0xfb101860>
81121b94:	94802014 	ori	r18,r18,128
81121b98:	ac400007 	ldb	r17,0(r21)
81121b9c:	003f2f06 	br	8112185c <__reset+0xfb10185c>
81121ba0:	a809883a 	mov	r4,r21
81121ba4:	d8003115 	stw	zero,196(sp)
81121ba8:	88bff404 	addi	r2,r17,-48
81121bac:	0017883a 	mov	r11,zero
81121bb0:	24400007 	ldb	r17,0(r4)
81121bb4:	5ac002a4 	muli	r11,r11,10
81121bb8:	ad400044 	addi	r21,r21,1
81121bbc:	a809883a 	mov	r4,r21
81121bc0:	12d7883a 	add	r11,r2,r11
81121bc4:	88bff404 	addi	r2,r17,-48
81121bc8:	30bff92e 	bgeu	r6,r2,81121bb0 <__reset+0xfb101bb0>
81121bcc:	dac03115 	stw	r11,196(sp)
81121bd0:	003f2306 	br	81121860 <__reset+0xfb101860>
81121bd4:	18c03fcc 	andi	r3,r3,255
81121bd8:	18072b1e 	bne	r3,zero,81123888 <___vfprintf_internal_r+0x21b8>
81121bdc:	94800414 	ori	r18,r18,16
81121be0:	9080080c 	andi	r2,r18,32
81121be4:	10037b26 	beq	r2,zero,811229d4 <___vfprintf_internal_r+0x1304>
81121be8:	d9402d17 	ldw	r5,180(sp)
81121bec:	28800117 	ldw	r2,4(r5)
81121bf0:	2cc00017 	ldw	r19,0(r5)
81121bf4:	29400204 	addi	r5,r5,8
81121bf8:	d9402d15 	stw	r5,180(sp)
81121bfc:	102d883a 	mov	r22,r2
81121c00:	10044b16 	blt	r2,zero,81122d30 <___vfprintf_internal_r+0x1660>
81121c04:	d9402917 	ldw	r5,164(sp)
81121c08:	df002783 	ldbu	fp,158(sp)
81121c0c:	2803bc16 	blt	r5,zero,81122b00 <___vfprintf_internal_r+0x1430>
81121c10:	00ffdfc4 	movi	r3,-129
81121c14:	9d84b03a 	or	r2,r19,r22
81121c18:	90e4703a 	and	r18,r18,r3
81121c1c:	10017726 	beq	r2,zero,811221fc <___vfprintf_internal_r+0xb2c>
81121c20:	b0038326 	beq	r22,zero,81122a30 <___vfprintf_internal_r+0x1360>
81121c24:	dc402a15 	stw	r17,168(sp)
81121c28:	dc001e04 	addi	r16,sp,120
81121c2c:	b023883a 	mov	r17,r22
81121c30:	402d883a 	mov	r22,r8
81121c34:	9809883a 	mov	r4,r19
81121c38:	880b883a 	mov	r5,r17
81121c3c:	01800284 	movi	r6,10
81121c40:	000f883a 	mov	r7,zero
81121c44:	11306740 	call	81130674 <__umoddi3>
81121c48:	10800c04 	addi	r2,r2,48
81121c4c:	843fffc4 	addi	r16,r16,-1
81121c50:	9809883a 	mov	r4,r19
81121c54:	880b883a 	mov	r5,r17
81121c58:	80800005 	stb	r2,0(r16)
81121c5c:	01800284 	movi	r6,10
81121c60:	000f883a 	mov	r7,zero
81121c64:	11300f40 	call	811300f4 <__udivdi3>
81121c68:	1027883a 	mov	r19,r2
81121c6c:	10c4b03a 	or	r2,r2,r3
81121c70:	1823883a 	mov	r17,r3
81121c74:	103fef1e 	bne	r2,zero,81121c34 <__reset+0xfb101c34>
81121c78:	d8c02817 	ldw	r3,160(sp)
81121c7c:	dc402a17 	ldw	r17,168(sp)
81121c80:	b011883a 	mov	r8,r22
81121c84:	1c07c83a 	sub	r3,r3,r16
81121c88:	d8c02e15 	stw	r3,184(sp)
81121c8c:	00005906 	br	81121df4 <___vfprintf_internal_r+0x724>
81121c90:	18c03fcc 	andi	r3,r3,255
81121c94:	1806fa1e 	bne	r3,zero,81123880 <___vfprintf_internal_r+0x21b0>
81121c98:	9080020c 	andi	r2,r18,8
81121c9c:	10048a26 	beq	r2,zero,81122ec8 <___vfprintf_internal_r+0x17f8>
81121ca0:	d8c02d17 	ldw	r3,180(sp)
81121ca4:	d9002d17 	ldw	r4,180(sp)
81121ca8:	d9402d17 	ldw	r5,180(sp)
81121cac:	18c00017 	ldw	r3,0(r3)
81121cb0:	21000117 	ldw	r4,4(r4)
81121cb4:	29400204 	addi	r5,r5,8
81121cb8:	d8c03615 	stw	r3,216(sp)
81121cbc:	d9003815 	stw	r4,224(sp)
81121cc0:	d9402d15 	stw	r5,180(sp)
81121cc4:	d9003617 	ldw	r4,216(sp)
81121cc8:	d9403817 	ldw	r5,224(sp)
81121ccc:	da003d15 	stw	r8,244(sp)
81121cd0:	04000044 	movi	r16,1
81121cd4:	1129f240 	call	81129f24 <__fpclassifyd>
81121cd8:	da003d17 	ldw	r8,244(sp)
81121cdc:	14041f1e 	bne	r2,r16,81122d5c <___vfprintf_internal_r+0x168c>
81121ce0:	d9003617 	ldw	r4,216(sp)
81121ce4:	d9403817 	ldw	r5,224(sp)
81121ce8:	000d883a 	mov	r6,zero
81121cec:	000f883a 	mov	r7,zero
81121cf0:	113226c0 	call	8113226c <__ledf2>
81121cf4:	da003d17 	ldw	r8,244(sp)
81121cf8:	1005be16 	blt	r2,zero,811233f4 <___vfprintf_internal_r+0x1d24>
81121cfc:	df002783 	ldbu	fp,158(sp)
81121d00:	008011c4 	movi	r2,71
81121d04:	1445330e 	bge	r2,r17,811231d4 <___vfprintf_internal_r+0x1b04>
81121d08:	04204574 	movhi	r16,33045
81121d0c:	84338c04 	addi	r16,r16,-12752
81121d10:	00c000c4 	movi	r3,3
81121d14:	00bfdfc4 	movi	r2,-129
81121d18:	d8c02a15 	stw	r3,168(sp)
81121d1c:	90a4703a 	and	r18,r18,r2
81121d20:	d8c02e15 	stw	r3,184(sp)
81121d24:	d8002915 	stw	zero,164(sp)
81121d28:	d8003215 	stw	zero,200(sp)
81121d2c:	00003706 	br	81121e0c <___vfprintf_internal_r+0x73c>
81121d30:	94800214 	ori	r18,r18,8
81121d34:	ac400007 	ldb	r17,0(r21)
81121d38:	003ec806 	br	8112185c <__reset+0xfb10185c>
81121d3c:	18c03fcc 	andi	r3,r3,255
81121d40:	1806db1e 	bne	r3,zero,811238b0 <___vfprintf_internal_r+0x21e0>
81121d44:	94800414 	ori	r18,r18,16
81121d48:	9080080c 	andi	r2,r18,32
81121d4c:	1002d826 	beq	r2,zero,811228b0 <___vfprintf_internal_r+0x11e0>
81121d50:	d9402d17 	ldw	r5,180(sp)
81121d54:	d8c02917 	ldw	r3,164(sp)
81121d58:	d8002785 	stb	zero,158(sp)
81121d5c:	28800204 	addi	r2,r5,8
81121d60:	2cc00017 	ldw	r19,0(r5)
81121d64:	2d800117 	ldw	r22,4(r5)
81121d68:	18048f16 	blt	r3,zero,81122fa8 <___vfprintf_internal_r+0x18d8>
81121d6c:	013fdfc4 	movi	r4,-129
81121d70:	9d86b03a 	or	r3,r19,r22
81121d74:	d8802d15 	stw	r2,180(sp)
81121d78:	9124703a 	and	r18,r18,r4
81121d7c:	1802d91e 	bne	r3,zero,811228e4 <___vfprintf_internal_r+0x1214>
81121d80:	d8c02917 	ldw	r3,164(sp)
81121d84:	0039883a 	mov	fp,zero
81121d88:	1805c326 	beq	r3,zero,81123498 <___vfprintf_internal_r+0x1dc8>
81121d8c:	0027883a 	mov	r19,zero
81121d90:	002d883a 	mov	r22,zero
81121d94:	dc001e04 	addi	r16,sp,120
81121d98:	9806d0fa 	srli	r3,r19,3
81121d9c:	b008977a 	slli	r4,r22,29
81121da0:	b02cd0fa 	srli	r22,r22,3
81121da4:	9cc001cc 	andi	r19,r19,7
81121da8:	98800c04 	addi	r2,r19,48
81121dac:	843fffc4 	addi	r16,r16,-1
81121db0:	20e6b03a 	or	r19,r4,r3
81121db4:	80800005 	stb	r2,0(r16)
81121db8:	9d86b03a 	or	r3,r19,r22
81121dbc:	183ff61e 	bne	r3,zero,81121d98 <__reset+0xfb101d98>
81121dc0:	90c0004c 	andi	r3,r18,1
81121dc4:	18013b26 	beq	r3,zero,811222b4 <___vfprintf_internal_r+0xbe4>
81121dc8:	10803fcc 	andi	r2,r2,255
81121dcc:	1080201c 	xori	r2,r2,128
81121dd0:	10bfe004 	addi	r2,r2,-128
81121dd4:	00c00c04 	movi	r3,48
81121dd8:	10c13626 	beq	r2,r3,811222b4 <___vfprintf_internal_r+0xbe4>
81121ddc:	80ffffc5 	stb	r3,-1(r16)
81121de0:	d8c02817 	ldw	r3,160(sp)
81121de4:	80bfffc4 	addi	r2,r16,-1
81121de8:	1021883a 	mov	r16,r2
81121dec:	1887c83a 	sub	r3,r3,r2
81121df0:	d8c02e15 	stw	r3,184(sp)
81121df4:	d8802e17 	ldw	r2,184(sp)
81121df8:	d9002917 	ldw	r4,164(sp)
81121dfc:	1100010e 	bge	r2,r4,81121e04 <___vfprintf_internal_r+0x734>
81121e00:	2005883a 	mov	r2,r4
81121e04:	d8802a15 	stw	r2,168(sp)
81121e08:	d8003215 	stw	zero,200(sp)
81121e0c:	e7003fcc 	andi	fp,fp,255
81121e10:	e700201c 	xori	fp,fp,128
81121e14:	e73fe004 	addi	fp,fp,-128
81121e18:	e0000326 	beq	fp,zero,81121e28 <___vfprintf_internal_r+0x758>
81121e1c:	d8c02a17 	ldw	r3,168(sp)
81121e20:	18c00044 	addi	r3,r3,1
81121e24:	d8c02a15 	stw	r3,168(sp)
81121e28:	90c0008c 	andi	r3,r18,2
81121e2c:	d8c02b15 	stw	r3,172(sp)
81121e30:	18000326 	beq	r3,zero,81121e40 <___vfprintf_internal_r+0x770>
81121e34:	d8c02a17 	ldw	r3,168(sp)
81121e38:	18c00084 	addi	r3,r3,2
81121e3c:	d8c02a15 	stw	r3,168(sp)
81121e40:	90c0210c 	andi	r3,r18,132
81121e44:	d8c03015 	stw	r3,192(sp)
81121e48:	1801a31e 	bne	r3,zero,811224d8 <___vfprintf_internal_r+0xe08>
81121e4c:	d9003117 	ldw	r4,196(sp)
81121e50:	d8c02a17 	ldw	r3,168(sp)
81121e54:	20e7c83a 	sub	r19,r4,r3
81121e58:	04c19f0e 	bge	zero,r19,811224d8 <___vfprintf_internal_r+0xe08>
81121e5c:	02400404 	movi	r9,16
81121e60:	d8c02017 	ldw	r3,128(sp)
81121e64:	d8801f17 	ldw	r2,124(sp)
81121e68:	4cc50d0e 	bge	r9,r19,811232a0 <___vfprintf_internal_r+0x1bd0>
81121e6c:	01604574 	movhi	r5,33045
81121e70:	2973a784 	addi	r5,r5,-12642
81121e74:	dc403b15 	stw	r17,236(sp)
81121e78:	d9403515 	stw	r5,212(sp)
81121e7c:	9823883a 	mov	r17,r19
81121e80:	482d883a 	mov	r22,r9
81121e84:	9027883a 	mov	r19,r18
81121e88:	070001c4 	movi	fp,7
81121e8c:	8025883a 	mov	r18,r16
81121e90:	dc002c17 	ldw	r16,176(sp)
81121e94:	00000306 	br	81121ea4 <___vfprintf_internal_r+0x7d4>
81121e98:	8c7ffc04 	addi	r17,r17,-16
81121e9c:	42000204 	addi	r8,r8,8
81121ea0:	b440130e 	bge	r22,r17,81121ef0 <___vfprintf_internal_r+0x820>
81121ea4:	01204574 	movhi	r4,33045
81121ea8:	18c00404 	addi	r3,r3,16
81121eac:	10800044 	addi	r2,r2,1
81121eb0:	2133a784 	addi	r4,r4,-12642
81121eb4:	41000015 	stw	r4,0(r8)
81121eb8:	45800115 	stw	r22,4(r8)
81121ebc:	d8c02015 	stw	r3,128(sp)
81121ec0:	d8801f15 	stw	r2,124(sp)
81121ec4:	e0bff40e 	bge	fp,r2,81121e98 <__reset+0xfb101e98>
81121ec8:	d9801e04 	addi	r6,sp,120
81121ecc:	b80b883a 	mov	r5,r23
81121ed0:	8009883a 	mov	r4,r16
81121ed4:	112d8c00 	call	8112d8c0 <__sprint_r>
81121ed8:	103f011e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81121edc:	8c7ffc04 	addi	r17,r17,-16
81121ee0:	d8c02017 	ldw	r3,128(sp)
81121ee4:	d8801f17 	ldw	r2,124(sp)
81121ee8:	da000404 	addi	r8,sp,16
81121eec:	b47fed16 	blt	r22,r17,81121ea4 <__reset+0xfb101ea4>
81121ef0:	9021883a 	mov	r16,r18
81121ef4:	9825883a 	mov	r18,r19
81121ef8:	8827883a 	mov	r19,r17
81121efc:	dc403b17 	ldw	r17,236(sp)
81121f00:	d9403517 	ldw	r5,212(sp)
81121f04:	98c7883a 	add	r3,r19,r3
81121f08:	10800044 	addi	r2,r2,1
81121f0c:	41400015 	stw	r5,0(r8)
81121f10:	44c00115 	stw	r19,4(r8)
81121f14:	d8c02015 	stw	r3,128(sp)
81121f18:	d8801f15 	stw	r2,124(sp)
81121f1c:	010001c4 	movi	r4,7
81121f20:	2082a316 	blt	r4,r2,811229b0 <___vfprintf_internal_r+0x12e0>
81121f24:	df002787 	ldb	fp,158(sp)
81121f28:	42000204 	addi	r8,r8,8
81121f2c:	e0000c26 	beq	fp,zero,81121f60 <___vfprintf_internal_r+0x890>
81121f30:	d8801f17 	ldw	r2,124(sp)
81121f34:	d9002784 	addi	r4,sp,158
81121f38:	18c00044 	addi	r3,r3,1
81121f3c:	10800044 	addi	r2,r2,1
81121f40:	41000015 	stw	r4,0(r8)
81121f44:	01000044 	movi	r4,1
81121f48:	41000115 	stw	r4,4(r8)
81121f4c:	d8c02015 	stw	r3,128(sp)
81121f50:	d8801f15 	stw	r2,124(sp)
81121f54:	010001c4 	movi	r4,7
81121f58:	20823c16 	blt	r4,r2,8112284c <___vfprintf_internal_r+0x117c>
81121f5c:	42000204 	addi	r8,r8,8
81121f60:	d8802b17 	ldw	r2,172(sp)
81121f64:	10000c26 	beq	r2,zero,81121f98 <___vfprintf_internal_r+0x8c8>
81121f68:	d8801f17 	ldw	r2,124(sp)
81121f6c:	d9002704 	addi	r4,sp,156
81121f70:	18c00084 	addi	r3,r3,2
81121f74:	10800044 	addi	r2,r2,1
81121f78:	41000015 	stw	r4,0(r8)
81121f7c:	01000084 	movi	r4,2
81121f80:	41000115 	stw	r4,4(r8)
81121f84:	d8c02015 	stw	r3,128(sp)
81121f88:	d8801f15 	stw	r2,124(sp)
81121f8c:	010001c4 	movi	r4,7
81121f90:	20823616 	blt	r4,r2,8112286c <___vfprintf_internal_r+0x119c>
81121f94:	42000204 	addi	r8,r8,8
81121f98:	d9003017 	ldw	r4,192(sp)
81121f9c:	00802004 	movi	r2,128
81121fa0:	20819926 	beq	r4,r2,81122608 <___vfprintf_internal_r+0xf38>
81121fa4:	d9402917 	ldw	r5,164(sp)
81121fa8:	d8802e17 	ldw	r2,184(sp)
81121fac:	28adc83a 	sub	r22,r5,r2
81121fb0:	0580310e 	bge	zero,r22,81122078 <___vfprintf_internal_r+0x9a8>
81121fb4:	07000404 	movi	fp,16
81121fb8:	d8801f17 	ldw	r2,124(sp)
81121fbc:	e584140e 	bge	fp,r22,81123010 <___vfprintf_internal_r+0x1940>
81121fc0:	01604574 	movhi	r5,33045
81121fc4:	2973a384 	addi	r5,r5,-12658
81121fc8:	dc402915 	stw	r17,164(sp)
81121fcc:	d9402b15 	stw	r5,172(sp)
81121fd0:	b023883a 	mov	r17,r22
81121fd4:	04c001c4 	movi	r19,7
81121fd8:	a82d883a 	mov	r22,r21
81121fdc:	902b883a 	mov	r21,r18
81121fe0:	8025883a 	mov	r18,r16
81121fe4:	dc002c17 	ldw	r16,176(sp)
81121fe8:	00000306 	br	81121ff8 <___vfprintf_internal_r+0x928>
81121fec:	8c7ffc04 	addi	r17,r17,-16
81121ff0:	42000204 	addi	r8,r8,8
81121ff4:	e440110e 	bge	fp,r17,8112203c <___vfprintf_internal_r+0x96c>
81121ff8:	18c00404 	addi	r3,r3,16
81121ffc:	10800044 	addi	r2,r2,1
81122000:	45000015 	stw	r20,0(r8)
81122004:	47000115 	stw	fp,4(r8)
81122008:	d8c02015 	stw	r3,128(sp)
8112200c:	d8801f15 	stw	r2,124(sp)
81122010:	98bff60e 	bge	r19,r2,81121fec <__reset+0xfb101fec>
81122014:	d9801e04 	addi	r6,sp,120
81122018:	b80b883a 	mov	r5,r23
8112201c:	8009883a 	mov	r4,r16
81122020:	112d8c00 	call	8112d8c0 <__sprint_r>
81122024:	103eae1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122028:	8c7ffc04 	addi	r17,r17,-16
8112202c:	d8c02017 	ldw	r3,128(sp)
81122030:	d8801f17 	ldw	r2,124(sp)
81122034:	da000404 	addi	r8,sp,16
81122038:	e47fef16 	blt	fp,r17,81121ff8 <__reset+0xfb101ff8>
8112203c:	9021883a 	mov	r16,r18
81122040:	a825883a 	mov	r18,r21
81122044:	b02b883a 	mov	r21,r22
81122048:	882d883a 	mov	r22,r17
8112204c:	dc402917 	ldw	r17,164(sp)
81122050:	d9002b17 	ldw	r4,172(sp)
81122054:	1d87883a 	add	r3,r3,r22
81122058:	10800044 	addi	r2,r2,1
8112205c:	41000015 	stw	r4,0(r8)
81122060:	45800115 	stw	r22,4(r8)
81122064:	d8c02015 	stw	r3,128(sp)
81122068:	d8801f15 	stw	r2,124(sp)
8112206c:	010001c4 	movi	r4,7
81122070:	2081ee16 	blt	r4,r2,8112282c <___vfprintf_internal_r+0x115c>
81122074:	42000204 	addi	r8,r8,8
81122078:	9080400c 	andi	r2,r18,256
8112207c:	1001181e 	bne	r2,zero,811224e0 <___vfprintf_internal_r+0xe10>
81122080:	d9402e17 	ldw	r5,184(sp)
81122084:	d8801f17 	ldw	r2,124(sp)
81122088:	44000015 	stw	r16,0(r8)
8112208c:	1947883a 	add	r3,r3,r5
81122090:	10800044 	addi	r2,r2,1
81122094:	41400115 	stw	r5,4(r8)
81122098:	d8c02015 	stw	r3,128(sp)
8112209c:	d8801f15 	stw	r2,124(sp)
811220a0:	010001c4 	movi	r4,7
811220a4:	2081d316 	blt	r4,r2,811227f4 <___vfprintf_internal_r+0x1124>
811220a8:	42000204 	addi	r8,r8,8
811220ac:	9480010c 	andi	r18,r18,4
811220b0:	90003226 	beq	r18,zero,8112217c <___vfprintf_internal_r+0xaac>
811220b4:	d9403117 	ldw	r5,196(sp)
811220b8:	d8802a17 	ldw	r2,168(sp)
811220bc:	28a1c83a 	sub	r16,r5,r2
811220c0:	04002e0e 	bge	zero,r16,8112217c <___vfprintf_internal_r+0xaac>
811220c4:	04400404 	movi	r17,16
811220c8:	d8801f17 	ldw	r2,124(sp)
811220cc:	8c04a20e 	bge	r17,r16,81123358 <___vfprintf_internal_r+0x1c88>
811220d0:	01604574 	movhi	r5,33045
811220d4:	2973a784 	addi	r5,r5,-12642
811220d8:	d9403515 	stw	r5,212(sp)
811220dc:	048001c4 	movi	r18,7
811220e0:	dcc02c17 	ldw	r19,176(sp)
811220e4:	00000306 	br	811220f4 <___vfprintf_internal_r+0xa24>
811220e8:	843ffc04 	addi	r16,r16,-16
811220ec:	42000204 	addi	r8,r8,8
811220f0:	8c00130e 	bge	r17,r16,81122140 <___vfprintf_internal_r+0xa70>
811220f4:	01204574 	movhi	r4,33045
811220f8:	18c00404 	addi	r3,r3,16
811220fc:	10800044 	addi	r2,r2,1
81122100:	2133a784 	addi	r4,r4,-12642
81122104:	41000015 	stw	r4,0(r8)
81122108:	44400115 	stw	r17,4(r8)
8112210c:	d8c02015 	stw	r3,128(sp)
81122110:	d8801f15 	stw	r2,124(sp)
81122114:	90bff40e 	bge	r18,r2,811220e8 <__reset+0xfb1020e8>
81122118:	d9801e04 	addi	r6,sp,120
8112211c:	b80b883a 	mov	r5,r23
81122120:	9809883a 	mov	r4,r19
81122124:	112d8c00 	call	8112d8c0 <__sprint_r>
81122128:	103e6d1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
8112212c:	843ffc04 	addi	r16,r16,-16
81122130:	d8c02017 	ldw	r3,128(sp)
81122134:	d8801f17 	ldw	r2,124(sp)
81122138:	da000404 	addi	r8,sp,16
8112213c:	8c3fed16 	blt	r17,r16,811220f4 <__reset+0xfb1020f4>
81122140:	d9403517 	ldw	r5,212(sp)
81122144:	1c07883a 	add	r3,r3,r16
81122148:	10800044 	addi	r2,r2,1
8112214c:	41400015 	stw	r5,0(r8)
81122150:	44000115 	stw	r16,4(r8)
81122154:	d8c02015 	stw	r3,128(sp)
81122158:	d8801f15 	stw	r2,124(sp)
8112215c:	010001c4 	movi	r4,7
81122160:	2080060e 	bge	r4,r2,8112217c <___vfprintf_internal_r+0xaac>
81122164:	d9002c17 	ldw	r4,176(sp)
81122168:	d9801e04 	addi	r6,sp,120
8112216c:	b80b883a 	mov	r5,r23
81122170:	112d8c00 	call	8112d8c0 <__sprint_r>
81122174:	103e5a1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122178:	d8c02017 	ldw	r3,128(sp)
8112217c:	d8803117 	ldw	r2,196(sp)
81122180:	d9002a17 	ldw	r4,168(sp)
81122184:	1100010e 	bge	r2,r4,8112218c <___vfprintf_internal_r+0xabc>
81122188:	2005883a 	mov	r2,r4
8112218c:	d9402f17 	ldw	r5,188(sp)
81122190:	288b883a 	add	r5,r5,r2
81122194:	d9402f15 	stw	r5,188(sp)
81122198:	18019e1e 	bne	r3,zero,81122814 <___vfprintf_internal_r+0x1144>
8112219c:	a8800007 	ldb	r2,0(r21)
811221a0:	d8001f15 	stw	zero,124(sp)
811221a4:	da000404 	addi	r8,sp,16
811221a8:	103d851e 	bne	r2,zero,811217c0 <__reset+0xfb1017c0>
811221ac:	a821883a 	mov	r16,r21
811221b0:	003d9b06 	br	81121820 <__reset+0xfb101820>
811221b4:	18c03fcc 	andi	r3,r3,255
811221b8:	1805c11e 	bne	r3,zero,811238c0 <___vfprintf_internal_r+0x21f0>
811221bc:	94800414 	ori	r18,r18,16
811221c0:	9080080c 	andi	r2,r18,32
811221c4:	10020c26 	beq	r2,zero,811229f8 <___vfprintf_internal_r+0x1328>
811221c8:	d8802d17 	ldw	r2,180(sp)
811221cc:	d9002917 	ldw	r4,164(sp)
811221d0:	d8002785 	stb	zero,158(sp)
811221d4:	10c00204 	addi	r3,r2,8
811221d8:	14c00017 	ldw	r19,0(r2)
811221dc:	15800117 	ldw	r22,4(r2)
811221e0:	20040f16 	blt	r4,zero,81123220 <___vfprintf_internal_r+0x1b50>
811221e4:	013fdfc4 	movi	r4,-129
811221e8:	9d84b03a 	or	r2,r19,r22
811221ec:	d8c02d15 	stw	r3,180(sp)
811221f0:	9124703a 	and	r18,r18,r4
811221f4:	0039883a 	mov	fp,zero
811221f8:	103e891e 	bne	r2,zero,81121c20 <__reset+0xfb101c20>
811221fc:	d9002917 	ldw	r4,164(sp)
81122200:	2002c11e 	bne	r4,zero,81122d08 <___vfprintf_internal_r+0x1638>
81122204:	d8002915 	stw	zero,164(sp)
81122208:	d8002e15 	stw	zero,184(sp)
8112220c:	dc001e04 	addi	r16,sp,120
81122210:	003ef806 	br	81121df4 <__reset+0xfb101df4>
81122214:	18c03fcc 	andi	r3,r3,255
81122218:	18059d1e 	bne	r3,zero,81123890 <___vfprintf_internal_r+0x21c0>
8112221c:	01604574 	movhi	r5,33045
81122220:	29738f04 	addi	r5,r5,-12740
81122224:	d9403915 	stw	r5,228(sp)
81122228:	9080080c 	andi	r2,r18,32
8112222c:	10005226 	beq	r2,zero,81122378 <___vfprintf_internal_r+0xca8>
81122230:	d8802d17 	ldw	r2,180(sp)
81122234:	14c00017 	ldw	r19,0(r2)
81122238:	15800117 	ldw	r22,4(r2)
8112223c:	10800204 	addi	r2,r2,8
81122240:	d8802d15 	stw	r2,180(sp)
81122244:	9080004c 	andi	r2,r18,1
81122248:	10019026 	beq	r2,zero,8112288c <___vfprintf_internal_r+0x11bc>
8112224c:	9d84b03a 	or	r2,r19,r22
81122250:	10036926 	beq	r2,zero,81122ff8 <___vfprintf_internal_r+0x1928>
81122254:	d8c02917 	ldw	r3,164(sp)
81122258:	00800c04 	movi	r2,48
8112225c:	d8802705 	stb	r2,156(sp)
81122260:	dc402745 	stb	r17,157(sp)
81122264:	d8002785 	stb	zero,158(sp)
81122268:	90800094 	ori	r2,r18,2
8112226c:	18045d16 	blt	r3,zero,811233e4 <___vfprintf_internal_r+0x1d14>
81122270:	00bfdfc4 	movi	r2,-129
81122274:	90a4703a 	and	r18,r18,r2
81122278:	94800094 	ori	r18,r18,2
8112227c:	0039883a 	mov	fp,zero
81122280:	d9003917 	ldw	r4,228(sp)
81122284:	dc001e04 	addi	r16,sp,120
81122288:	988003cc 	andi	r2,r19,15
8112228c:	b006973a 	slli	r3,r22,28
81122290:	2085883a 	add	r2,r4,r2
81122294:	9826d13a 	srli	r19,r19,4
81122298:	10800003 	ldbu	r2,0(r2)
8112229c:	b02cd13a 	srli	r22,r22,4
811222a0:	843fffc4 	addi	r16,r16,-1
811222a4:	1ce6b03a 	or	r19,r3,r19
811222a8:	80800005 	stb	r2,0(r16)
811222ac:	9d84b03a 	or	r2,r19,r22
811222b0:	103ff51e 	bne	r2,zero,81122288 <__reset+0xfb102288>
811222b4:	d8c02817 	ldw	r3,160(sp)
811222b8:	1c07c83a 	sub	r3,r3,r16
811222bc:	d8c02e15 	stw	r3,184(sp)
811222c0:	003ecc06 	br	81121df4 <__reset+0xfb101df4>
811222c4:	18c03fcc 	andi	r3,r3,255
811222c8:	183e9f26 	beq	r3,zero,81121d48 <__reset+0xfb101d48>
811222cc:	d9c02785 	stb	r7,158(sp)
811222d0:	003e9d06 	br	81121d48 <__reset+0xfb101d48>
811222d4:	00c00044 	movi	r3,1
811222d8:	01c00ac4 	movi	r7,43
811222dc:	ac400007 	ldb	r17,0(r21)
811222e0:	003d5e06 	br	8112185c <__reset+0xfb10185c>
811222e4:	94800814 	ori	r18,r18,32
811222e8:	ac400007 	ldb	r17,0(r21)
811222ec:	003d5b06 	br	8112185c <__reset+0xfb10185c>
811222f0:	d8c02d17 	ldw	r3,180(sp)
811222f4:	d8002785 	stb	zero,158(sp)
811222f8:	1c000017 	ldw	r16,0(r3)
811222fc:	1cc00104 	addi	r19,r3,4
81122300:	80041926 	beq	r16,zero,81123368 <___vfprintf_internal_r+0x1c98>
81122304:	d9002917 	ldw	r4,164(sp)
81122308:	2003d016 	blt	r4,zero,8112324c <___vfprintf_internal_r+0x1b7c>
8112230c:	200d883a 	mov	r6,r4
81122310:	000b883a 	mov	r5,zero
81122314:	8009883a 	mov	r4,r16
81122318:	da003d15 	stw	r8,244(sp)
8112231c:	11286b40 	call	811286b4 <memchr>
81122320:	da003d17 	ldw	r8,244(sp)
81122324:	10045426 	beq	r2,zero,81123478 <___vfprintf_internal_r+0x1da8>
81122328:	1405c83a 	sub	r2,r2,r16
8112232c:	d8802e15 	stw	r2,184(sp)
81122330:	1003cc16 	blt	r2,zero,81123264 <___vfprintf_internal_r+0x1b94>
81122334:	df002783 	ldbu	fp,158(sp)
81122338:	d8802a15 	stw	r2,168(sp)
8112233c:	dcc02d15 	stw	r19,180(sp)
81122340:	d8002915 	stw	zero,164(sp)
81122344:	d8003215 	stw	zero,200(sp)
81122348:	003eb006 	br	81121e0c <__reset+0xfb101e0c>
8112234c:	18c03fcc 	andi	r3,r3,255
81122350:	183f9b26 	beq	r3,zero,811221c0 <__reset+0xfb1021c0>
81122354:	d9c02785 	stb	r7,158(sp)
81122358:	003f9906 	br	811221c0 <__reset+0xfb1021c0>
8112235c:	18c03fcc 	andi	r3,r3,255
81122360:	1805551e 	bne	r3,zero,811238b8 <___vfprintf_internal_r+0x21e8>
81122364:	01604574 	movhi	r5,33045
81122368:	29739404 	addi	r5,r5,-12720
8112236c:	d9403915 	stw	r5,228(sp)
81122370:	9080080c 	andi	r2,r18,32
81122374:	103fae1e 	bne	r2,zero,81122230 <__reset+0xfb102230>
81122378:	9080040c 	andi	r2,r18,16
8112237c:	1002de26 	beq	r2,zero,81122ef8 <___vfprintf_internal_r+0x1828>
81122380:	d8c02d17 	ldw	r3,180(sp)
81122384:	002d883a 	mov	r22,zero
81122388:	1cc00017 	ldw	r19,0(r3)
8112238c:	18c00104 	addi	r3,r3,4
81122390:	d8c02d15 	stw	r3,180(sp)
81122394:	003fab06 	br	81122244 <__reset+0xfb102244>
81122398:	38803fcc 	andi	r2,r7,255
8112239c:	1080201c 	xori	r2,r2,128
811223a0:	10bfe004 	addi	r2,r2,-128
811223a4:	1002d21e 	bne	r2,zero,81122ef0 <___vfprintf_internal_r+0x1820>
811223a8:	00c00044 	movi	r3,1
811223ac:	01c00804 	movi	r7,32
811223b0:	ac400007 	ldb	r17,0(r21)
811223b4:	003d2906 	br	8112185c <__reset+0xfb10185c>
811223b8:	94800054 	ori	r18,r18,1
811223bc:	ac400007 	ldb	r17,0(r21)
811223c0:	003d2606 	br	8112185c <__reset+0xfb10185c>
811223c4:	18c03fcc 	andi	r3,r3,255
811223c8:	183e0526 	beq	r3,zero,81121be0 <__reset+0xfb101be0>
811223cc:	d9c02785 	stb	r7,158(sp)
811223d0:	003e0306 	br	81121be0 <__reset+0xfb101be0>
811223d4:	94801014 	ori	r18,r18,64
811223d8:	ac400007 	ldb	r17,0(r21)
811223dc:	003d1f06 	br	8112185c <__reset+0xfb10185c>
811223e0:	ac400007 	ldb	r17,0(r21)
811223e4:	8a438726 	beq	r17,r9,81123204 <___vfprintf_internal_r+0x1b34>
811223e8:	94800414 	ori	r18,r18,16
811223ec:	003d1b06 	br	8112185c <__reset+0xfb10185c>
811223f0:	18c03fcc 	andi	r3,r3,255
811223f4:	1805341e 	bne	r3,zero,811238c8 <___vfprintf_internal_r+0x21f8>
811223f8:	9080080c 	andi	r2,r18,32
811223fc:	1002cd26 	beq	r2,zero,81122f34 <___vfprintf_internal_r+0x1864>
81122400:	d9402d17 	ldw	r5,180(sp)
81122404:	d9002f17 	ldw	r4,188(sp)
81122408:	28800017 	ldw	r2,0(r5)
8112240c:	2007d7fa 	srai	r3,r4,31
81122410:	29400104 	addi	r5,r5,4
81122414:	d9402d15 	stw	r5,180(sp)
81122418:	11000015 	stw	r4,0(r2)
8112241c:	10c00115 	stw	r3,4(r2)
81122420:	003ce506 	br	811217b8 <__reset+0xfb1017b8>
81122424:	d8c02d17 	ldw	r3,180(sp)
81122428:	d9002d17 	ldw	r4,180(sp)
8112242c:	d8002785 	stb	zero,158(sp)
81122430:	18800017 	ldw	r2,0(r3)
81122434:	21000104 	addi	r4,r4,4
81122438:	00c00044 	movi	r3,1
8112243c:	d8c02a15 	stw	r3,168(sp)
81122440:	d8801405 	stb	r2,80(sp)
81122444:	d9002d15 	stw	r4,180(sp)
81122448:	d8c02e15 	stw	r3,184(sp)
8112244c:	d8002915 	stw	zero,164(sp)
81122450:	d8003215 	stw	zero,200(sp)
81122454:	dc001404 	addi	r16,sp,80
81122458:	0039883a 	mov	fp,zero
8112245c:	003e7206 	br	81121e28 <__reset+0xfb101e28>
81122460:	01204574 	movhi	r4,33045
81122464:	21339404 	addi	r4,r4,-12720
81122468:	0039883a 	mov	fp,zero
8112246c:	d9003915 	stw	r4,228(sp)
81122470:	04401e04 	movi	r17,120
81122474:	003f8206 	br	81122280 <__reset+0xfb102280>
81122478:	18c03fcc 	andi	r3,r3,255
8112247c:	1805061e 	bne	r3,zero,81123898 <___vfprintf_internal_r+0x21c8>
81122480:	883d9126 	beq	r17,zero,81121ac8 <__reset+0xfb101ac8>
81122484:	00c00044 	movi	r3,1
81122488:	d8c02a15 	stw	r3,168(sp)
8112248c:	dc401405 	stb	r17,80(sp)
81122490:	d8002785 	stb	zero,158(sp)
81122494:	003fec06 	br	81122448 <__reset+0xfb102448>
81122498:	01604574 	movhi	r5,33045
8112249c:	29739404 	addi	r5,r5,-12720
811224a0:	d9403915 	stw	r5,228(sp)
811224a4:	d8c02d15 	stw	r3,180(sp)
811224a8:	1025883a 	mov	r18,r2
811224ac:	04401e04 	movi	r17,120
811224b0:	9d84b03a 	or	r2,r19,r22
811224b4:	1000fc1e 	bne	r2,zero,811228a8 <___vfprintf_internal_r+0x11d8>
811224b8:	0039883a 	mov	fp,zero
811224bc:	00800084 	movi	r2,2
811224c0:	10803fcc 	andi	r2,r2,255
811224c4:	00c00044 	movi	r3,1
811224c8:	10c20f26 	beq	r2,r3,81122d08 <___vfprintf_internal_r+0x1638>
811224cc:	00c00084 	movi	r3,2
811224d0:	10fd6326 	beq	r2,r3,81121a60 <__reset+0xfb101a60>
811224d4:	003e2d06 	br	81121d8c <__reset+0xfb101d8c>
811224d8:	d8c02017 	ldw	r3,128(sp)
811224dc:	003e9306 	br	81121f2c <__reset+0xfb101f2c>
811224e0:	00801944 	movi	r2,101
811224e4:	14407e0e 	bge	r2,r17,811226e0 <___vfprintf_internal_r+0x1010>
811224e8:	d9003617 	ldw	r4,216(sp)
811224ec:	d9403817 	ldw	r5,224(sp)
811224f0:	000d883a 	mov	r6,zero
811224f4:	000f883a 	mov	r7,zero
811224f8:	d8c03c15 	stw	r3,240(sp)
811224fc:	da003d15 	stw	r8,244(sp)
81122500:	11321080 	call	81132108 <__eqdf2>
81122504:	d8c03c17 	ldw	r3,240(sp)
81122508:	da003d17 	ldw	r8,244(sp)
8112250c:	1000f71e 	bne	r2,zero,811228ec <___vfprintf_internal_r+0x121c>
81122510:	d8801f17 	ldw	r2,124(sp)
81122514:	01204574 	movhi	r4,33045
81122518:	21339b04 	addi	r4,r4,-12692
8112251c:	18c00044 	addi	r3,r3,1
81122520:	10800044 	addi	r2,r2,1
81122524:	41000015 	stw	r4,0(r8)
81122528:	01000044 	movi	r4,1
8112252c:	41000115 	stw	r4,4(r8)
81122530:	d8c02015 	stw	r3,128(sp)
81122534:	d8801f15 	stw	r2,124(sp)
81122538:	010001c4 	movi	r4,7
8112253c:	2082b816 	blt	r4,r2,81123020 <___vfprintf_internal_r+0x1950>
81122540:	42000204 	addi	r8,r8,8
81122544:	d8802617 	ldw	r2,152(sp)
81122548:	d9403317 	ldw	r5,204(sp)
8112254c:	11400216 	blt	r2,r5,81122558 <___vfprintf_internal_r+0xe88>
81122550:	9080004c 	andi	r2,r18,1
81122554:	103ed526 	beq	r2,zero,811220ac <__reset+0xfb1020ac>
81122558:	d8803717 	ldw	r2,220(sp)
8112255c:	d9003417 	ldw	r4,208(sp)
81122560:	d9403717 	ldw	r5,220(sp)
81122564:	1887883a 	add	r3,r3,r2
81122568:	d8801f17 	ldw	r2,124(sp)
8112256c:	41000015 	stw	r4,0(r8)
81122570:	41400115 	stw	r5,4(r8)
81122574:	10800044 	addi	r2,r2,1
81122578:	d8c02015 	stw	r3,128(sp)
8112257c:	d8801f15 	stw	r2,124(sp)
81122580:	010001c4 	movi	r4,7
81122584:	20832916 	blt	r4,r2,8112322c <___vfprintf_internal_r+0x1b5c>
81122588:	42000204 	addi	r8,r8,8
8112258c:	d8803317 	ldw	r2,204(sp)
81122590:	143fffc4 	addi	r16,r2,-1
81122594:	043ec50e 	bge	zero,r16,811220ac <__reset+0xfb1020ac>
81122598:	04400404 	movi	r17,16
8112259c:	d8801f17 	ldw	r2,124(sp)
811225a0:	8c00880e 	bge	r17,r16,811227c4 <___vfprintf_internal_r+0x10f4>
811225a4:	01604574 	movhi	r5,33045
811225a8:	2973a384 	addi	r5,r5,-12658
811225ac:	d9402b15 	stw	r5,172(sp)
811225b0:	058001c4 	movi	r22,7
811225b4:	dcc02c17 	ldw	r19,176(sp)
811225b8:	00000306 	br	811225c8 <___vfprintf_internal_r+0xef8>
811225bc:	42000204 	addi	r8,r8,8
811225c0:	843ffc04 	addi	r16,r16,-16
811225c4:	8c00820e 	bge	r17,r16,811227d0 <___vfprintf_internal_r+0x1100>
811225c8:	18c00404 	addi	r3,r3,16
811225cc:	10800044 	addi	r2,r2,1
811225d0:	45000015 	stw	r20,0(r8)
811225d4:	44400115 	stw	r17,4(r8)
811225d8:	d8c02015 	stw	r3,128(sp)
811225dc:	d8801f15 	stw	r2,124(sp)
811225e0:	b0bff60e 	bge	r22,r2,811225bc <__reset+0xfb1025bc>
811225e4:	d9801e04 	addi	r6,sp,120
811225e8:	b80b883a 	mov	r5,r23
811225ec:	9809883a 	mov	r4,r19
811225f0:	112d8c00 	call	8112d8c0 <__sprint_r>
811225f4:	103d3a1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
811225f8:	d8c02017 	ldw	r3,128(sp)
811225fc:	d8801f17 	ldw	r2,124(sp)
81122600:	da000404 	addi	r8,sp,16
81122604:	003fee06 	br	811225c0 <__reset+0xfb1025c0>
81122608:	d9403117 	ldw	r5,196(sp)
8112260c:	d8802a17 	ldw	r2,168(sp)
81122610:	28adc83a 	sub	r22,r5,r2
81122614:	05be630e 	bge	zero,r22,81121fa4 <__reset+0xfb101fa4>
81122618:	07000404 	movi	fp,16
8112261c:	d8801f17 	ldw	r2,124(sp)
81122620:	e5838f0e 	bge	fp,r22,81123460 <___vfprintf_internal_r+0x1d90>
81122624:	01604574 	movhi	r5,33045
81122628:	2973a384 	addi	r5,r5,-12658
8112262c:	dc403015 	stw	r17,192(sp)
81122630:	d9402b15 	stw	r5,172(sp)
81122634:	b023883a 	mov	r17,r22
81122638:	04c001c4 	movi	r19,7
8112263c:	a82d883a 	mov	r22,r21
81122640:	902b883a 	mov	r21,r18
81122644:	8025883a 	mov	r18,r16
81122648:	dc002c17 	ldw	r16,176(sp)
8112264c:	00000306 	br	8112265c <___vfprintf_internal_r+0xf8c>
81122650:	8c7ffc04 	addi	r17,r17,-16
81122654:	42000204 	addi	r8,r8,8
81122658:	e440110e 	bge	fp,r17,811226a0 <___vfprintf_internal_r+0xfd0>
8112265c:	18c00404 	addi	r3,r3,16
81122660:	10800044 	addi	r2,r2,1
81122664:	45000015 	stw	r20,0(r8)
81122668:	47000115 	stw	fp,4(r8)
8112266c:	d8c02015 	stw	r3,128(sp)
81122670:	d8801f15 	stw	r2,124(sp)
81122674:	98bff60e 	bge	r19,r2,81122650 <__reset+0xfb102650>
81122678:	d9801e04 	addi	r6,sp,120
8112267c:	b80b883a 	mov	r5,r23
81122680:	8009883a 	mov	r4,r16
81122684:	112d8c00 	call	8112d8c0 <__sprint_r>
81122688:	103d151e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
8112268c:	8c7ffc04 	addi	r17,r17,-16
81122690:	d8c02017 	ldw	r3,128(sp)
81122694:	d8801f17 	ldw	r2,124(sp)
81122698:	da000404 	addi	r8,sp,16
8112269c:	e47fef16 	blt	fp,r17,8112265c <__reset+0xfb10265c>
811226a0:	9021883a 	mov	r16,r18
811226a4:	a825883a 	mov	r18,r21
811226a8:	b02b883a 	mov	r21,r22
811226ac:	882d883a 	mov	r22,r17
811226b0:	dc403017 	ldw	r17,192(sp)
811226b4:	d9002b17 	ldw	r4,172(sp)
811226b8:	1d87883a 	add	r3,r3,r22
811226bc:	10800044 	addi	r2,r2,1
811226c0:	41000015 	stw	r4,0(r8)
811226c4:	45800115 	stw	r22,4(r8)
811226c8:	d8c02015 	stw	r3,128(sp)
811226cc:	d8801f15 	stw	r2,124(sp)
811226d0:	010001c4 	movi	r4,7
811226d4:	20818e16 	blt	r4,r2,81122d10 <___vfprintf_internal_r+0x1640>
811226d8:	42000204 	addi	r8,r8,8
811226dc:	003e3106 	br	81121fa4 <__reset+0xfb101fa4>
811226e0:	d9403317 	ldw	r5,204(sp)
811226e4:	00800044 	movi	r2,1
811226e8:	18c00044 	addi	r3,r3,1
811226ec:	1141530e 	bge	r2,r5,81122c3c <___vfprintf_internal_r+0x156c>
811226f0:	dc401f17 	ldw	r17,124(sp)
811226f4:	00800044 	movi	r2,1
811226f8:	40800115 	stw	r2,4(r8)
811226fc:	8c400044 	addi	r17,r17,1
81122700:	44000015 	stw	r16,0(r8)
81122704:	d8c02015 	stw	r3,128(sp)
81122708:	dc401f15 	stw	r17,124(sp)
8112270c:	008001c4 	movi	r2,7
81122710:	14416b16 	blt	r2,r17,81122cc0 <___vfprintf_internal_r+0x15f0>
81122714:	42000204 	addi	r8,r8,8
81122718:	d8803717 	ldw	r2,220(sp)
8112271c:	d9003417 	ldw	r4,208(sp)
81122720:	8c400044 	addi	r17,r17,1
81122724:	10c7883a 	add	r3,r2,r3
81122728:	40800115 	stw	r2,4(r8)
8112272c:	41000015 	stw	r4,0(r8)
81122730:	d8c02015 	stw	r3,128(sp)
81122734:	dc401f15 	stw	r17,124(sp)
81122738:	008001c4 	movi	r2,7
8112273c:	14416916 	blt	r2,r17,81122ce4 <___vfprintf_internal_r+0x1614>
81122740:	45800204 	addi	r22,r8,8
81122744:	d9003617 	ldw	r4,216(sp)
81122748:	d9403817 	ldw	r5,224(sp)
8112274c:	000d883a 	mov	r6,zero
81122750:	000f883a 	mov	r7,zero
81122754:	d8c03c15 	stw	r3,240(sp)
81122758:	11321080 	call	81132108 <__eqdf2>
8112275c:	d8c03c17 	ldw	r3,240(sp)
81122760:	1000bc26 	beq	r2,zero,81122a54 <___vfprintf_internal_r+0x1384>
81122764:	d9403317 	ldw	r5,204(sp)
81122768:	84000044 	addi	r16,r16,1
8112276c:	8c400044 	addi	r17,r17,1
81122770:	28bfffc4 	addi	r2,r5,-1
81122774:	1887883a 	add	r3,r3,r2
81122778:	b0800115 	stw	r2,4(r22)
8112277c:	b4000015 	stw	r16,0(r22)
81122780:	d8c02015 	stw	r3,128(sp)
81122784:	dc401f15 	stw	r17,124(sp)
81122788:	008001c4 	movi	r2,7
8112278c:	14414316 	blt	r2,r17,81122c9c <___vfprintf_internal_r+0x15cc>
81122790:	b5800204 	addi	r22,r22,8
81122794:	d9003a17 	ldw	r4,232(sp)
81122798:	df0022c4 	addi	fp,sp,139
8112279c:	8c400044 	addi	r17,r17,1
811227a0:	20c7883a 	add	r3,r4,r3
811227a4:	b7000015 	stw	fp,0(r22)
811227a8:	b1000115 	stw	r4,4(r22)
811227ac:	d8c02015 	stw	r3,128(sp)
811227b0:	dc401f15 	stw	r17,124(sp)
811227b4:	008001c4 	movi	r2,7
811227b8:	14400e16 	blt	r2,r17,811227f4 <___vfprintf_internal_r+0x1124>
811227bc:	b2000204 	addi	r8,r22,8
811227c0:	003e3a06 	br	811220ac <__reset+0xfb1020ac>
811227c4:	01204574 	movhi	r4,33045
811227c8:	2133a384 	addi	r4,r4,-12658
811227cc:	d9002b15 	stw	r4,172(sp)
811227d0:	d9002b17 	ldw	r4,172(sp)
811227d4:	1c07883a 	add	r3,r3,r16
811227d8:	44000115 	stw	r16,4(r8)
811227dc:	41000015 	stw	r4,0(r8)
811227e0:	10800044 	addi	r2,r2,1
811227e4:	d8c02015 	stw	r3,128(sp)
811227e8:	d8801f15 	stw	r2,124(sp)
811227ec:	010001c4 	movi	r4,7
811227f0:	20be2d0e 	bge	r4,r2,811220a8 <__reset+0xfb1020a8>
811227f4:	d9002c17 	ldw	r4,176(sp)
811227f8:	d9801e04 	addi	r6,sp,120
811227fc:	b80b883a 	mov	r5,r23
81122800:	112d8c00 	call	8112d8c0 <__sprint_r>
81122804:	103cb61e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122808:	d8c02017 	ldw	r3,128(sp)
8112280c:	da000404 	addi	r8,sp,16
81122810:	003e2606 	br	811220ac <__reset+0xfb1020ac>
81122814:	d9002c17 	ldw	r4,176(sp)
81122818:	d9801e04 	addi	r6,sp,120
8112281c:	b80b883a 	mov	r5,r23
81122820:	112d8c00 	call	8112d8c0 <__sprint_r>
81122824:	103e5d26 	beq	r2,zero,8112219c <__reset+0xfb10219c>
81122828:	003cad06 	br	81121ae0 <__reset+0xfb101ae0>
8112282c:	d9002c17 	ldw	r4,176(sp)
81122830:	d9801e04 	addi	r6,sp,120
81122834:	b80b883a 	mov	r5,r23
81122838:	112d8c00 	call	8112d8c0 <__sprint_r>
8112283c:	103ca81e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122840:	d8c02017 	ldw	r3,128(sp)
81122844:	da000404 	addi	r8,sp,16
81122848:	003e0b06 	br	81122078 <__reset+0xfb102078>
8112284c:	d9002c17 	ldw	r4,176(sp)
81122850:	d9801e04 	addi	r6,sp,120
81122854:	b80b883a 	mov	r5,r23
81122858:	112d8c00 	call	8112d8c0 <__sprint_r>
8112285c:	103ca01e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122860:	d8c02017 	ldw	r3,128(sp)
81122864:	da000404 	addi	r8,sp,16
81122868:	003dbd06 	br	81121f60 <__reset+0xfb101f60>
8112286c:	d9002c17 	ldw	r4,176(sp)
81122870:	d9801e04 	addi	r6,sp,120
81122874:	b80b883a 	mov	r5,r23
81122878:	112d8c00 	call	8112d8c0 <__sprint_r>
8112287c:	103c981e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122880:	d8c02017 	ldw	r3,128(sp)
81122884:	da000404 	addi	r8,sp,16
81122888:	003dc306 	br	81121f98 <__reset+0xfb101f98>
8112288c:	d8802917 	ldw	r2,164(sp)
81122890:	d8002785 	stb	zero,158(sp)
81122894:	103f0616 	blt	r2,zero,811224b0 <__reset+0xfb1024b0>
81122898:	00ffdfc4 	movi	r3,-129
8112289c:	9d84b03a 	or	r2,r19,r22
811228a0:	90e4703a 	and	r18,r18,r3
811228a4:	103c6b26 	beq	r2,zero,81121a54 <__reset+0xfb101a54>
811228a8:	0039883a 	mov	fp,zero
811228ac:	003e7406 	br	81122280 <__reset+0xfb102280>
811228b0:	9080040c 	andi	r2,r18,16
811228b4:	1001b326 	beq	r2,zero,81122f84 <___vfprintf_internal_r+0x18b4>
811228b8:	d9002d17 	ldw	r4,180(sp)
811228bc:	d9402917 	ldw	r5,164(sp)
811228c0:	d8002785 	stb	zero,158(sp)
811228c4:	20800104 	addi	r2,r4,4
811228c8:	24c00017 	ldw	r19,0(r4)
811228cc:	002d883a 	mov	r22,zero
811228d0:	2801b516 	blt	r5,zero,81122fa8 <___vfprintf_internal_r+0x18d8>
811228d4:	00ffdfc4 	movi	r3,-129
811228d8:	d8802d15 	stw	r2,180(sp)
811228dc:	90e4703a 	and	r18,r18,r3
811228e0:	983d2726 	beq	r19,zero,81121d80 <__reset+0xfb101d80>
811228e4:	0039883a 	mov	fp,zero
811228e8:	003d2a06 	br	81121d94 <__reset+0xfb101d94>
811228ec:	dc402617 	ldw	r17,152(sp)
811228f0:	0441d30e 	bge	zero,r17,81123040 <___vfprintf_internal_r+0x1970>
811228f4:	dc403217 	ldw	r17,200(sp)
811228f8:	d8803317 	ldw	r2,204(sp)
811228fc:	1440010e 	bge	r2,r17,81122904 <___vfprintf_internal_r+0x1234>
81122900:	1023883a 	mov	r17,r2
81122904:	04400a0e 	bge	zero,r17,81122930 <___vfprintf_internal_r+0x1260>
81122908:	d8801f17 	ldw	r2,124(sp)
8112290c:	1c47883a 	add	r3,r3,r17
81122910:	44000015 	stw	r16,0(r8)
81122914:	10800044 	addi	r2,r2,1
81122918:	44400115 	stw	r17,4(r8)
8112291c:	d8c02015 	stw	r3,128(sp)
81122920:	d8801f15 	stw	r2,124(sp)
81122924:	010001c4 	movi	r4,7
81122928:	20826516 	blt	r4,r2,811232c0 <___vfprintf_internal_r+0x1bf0>
8112292c:	42000204 	addi	r8,r8,8
81122930:	88026116 	blt	r17,zero,811232b8 <___vfprintf_internal_r+0x1be8>
81122934:	d9003217 	ldw	r4,200(sp)
81122938:	2463c83a 	sub	r17,r4,r17
8112293c:	04407b0e 	bge	zero,r17,81122b2c <___vfprintf_internal_r+0x145c>
81122940:	05800404 	movi	r22,16
81122944:	d8801f17 	ldw	r2,124(sp)
81122948:	b4419d0e 	bge	r22,r17,81122fc0 <___vfprintf_internal_r+0x18f0>
8112294c:	01204574 	movhi	r4,33045
81122950:	2133a384 	addi	r4,r4,-12658
81122954:	d9002b15 	stw	r4,172(sp)
81122958:	070001c4 	movi	fp,7
8112295c:	dcc02c17 	ldw	r19,176(sp)
81122960:	00000306 	br	81122970 <___vfprintf_internal_r+0x12a0>
81122964:	42000204 	addi	r8,r8,8
81122968:	8c7ffc04 	addi	r17,r17,-16
8112296c:	b441970e 	bge	r22,r17,81122fcc <___vfprintf_internal_r+0x18fc>
81122970:	18c00404 	addi	r3,r3,16
81122974:	10800044 	addi	r2,r2,1
81122978:	45000015 	stw	r20,0(r8)
8112297c:	45800115 	stw	r22,4(r8)
81122980:	d8c02015 	stw	r3,128(sp)
81122984:	d8801f15 	stw	r2,124(sp)
81122988:	e0bff60e 	bge	fp,r2,81122964 <__reset+0xfb102964>
8112298c:	d9801e04 	addi	r6,sp,120
81122990:	b80b883a 	mov	r5,r23
81122994:	9809883a 	mov	r4,r19
81122998:	112d8c00 	call	8112d8c0 <__sprint_r>
8112299c:	103c501e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
811229a0:	d8c02017 	ldw	r3,128(sp)
811229a4:	d8801f17 	ldw	r2,124(sp)
811229a8:	da000404 	addi	r8,sp,16
811229ac:	003fee06 	br	81122968 <__reset+0xfb102968>
811229b0:	d9002c17 	ldw	r4,176(sp)
811229b4:	d9801e04 	addi	r6,sp,120
811229b8:	b80b883a 	mov	r5,r23
811229bc:	112d8c00 	call	8112d8c0 <__sprint_r>
811229c0:	103c471e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
811229c4:	d8c02017 	ldw	r3,128(sp)
811229c8:	df002787 	ldb	fp,158(sp)
811229cc:	da000404 	addi	r8,sp,16
811229d0:	003d5606 	br	81121f2c <__reset+0xfb101f2c>
811229d4:	9080040c 	andi	r2,r18,16
811229d8:	10016126 	beq	r2,zero,81122f60 <___vfprintf_internal_r+0x1890>
811229dc:	d8802d17 	ldw	r2,180(sp)
811229e0:	14c00017 	ldw	r19,0(r2)
811229e4:	10800104 	addi	r2,r2,4
811229e8:	d8802d15 	stw	r2,180(sp)
811229ec:	982dd7fa 	srai	r22,r19,31
811229f0:	b005883a 	mov	r2,r22
811229f4:	003c8206 	br	81121c00 <__reset+0xfb101c00>
811229f8:	9080040c 	andi	r2,r18,16
811229fc:	10003526 	beq	r2,zero,81122ad4 <___vfprintf_internal_r+0x1404>
81122a00:	d9402d17 	ldw	r5,180(sp)
81122a04:	d8c02917 	ldw	r3,164(sp)
81122a08:	d8002785 	stb	zero,158(sp)
81122a0c:	28800104 	addi	r2,r5,4
81122a10:	2cc00017 	ldw	r19,0(r5)
81122a14:	002d883a 	mov	r22,zero
81122a18:	18003716 	blt	r3,zero,81122af8 <___vfprintf_internal_r+0x1428>
81122a1c:	00ffdfc4 	movi	r3,-129
81122a20:	d8802d15 	stw	r2,180(sp)
81122a24:	90e4703a 	and	r18,r18,r3
81122a28:	0039883a 	mov	fp,zero
81122a2c:	983df326 	beq	r19,zero,811221fc <__reset+0xfb1021fc>
81122a30:	00800244 	movi	r2,9
81122a34:	14fc7b36 	bltu	r2,r19,81121c24 <__reset+0xfb101c24>
81122a38:	d8c02817 	ldw	r3,160(sp)
81122a3c:	dc001dc4 	addi	r16,sp,119
81122a40:	9cc00c04 	addi	r19,r19,48
81122a44:	1c07c83a 	sub	r3,r3,r16
81122a48:	dcc01dc5 	stb	r19,119(sp)
81122a4c:	d8c02e15 	stw	r3,184(sp)
81122a50:	003ce806 	br	81121df4 <__reset+0xfb101df4>
81122a54:	d8803317 	ldw	r2,204(sp)
81122a58:	143fffc4 	addi	r16,r2,-1
81122a5c:	043f4d0e 	bge	zero,r16,81122794 <__reset+0xfb102794>
81122a60:	07000404 	movi	fp,16
81122a64:	e400810e 	bge	fp,r16,81122c6c <___vfprintf_internal_r+0x159c>
81122a68:	01604574 	movhi	r5,33045
81122a6c:	2973a384 	addi	r5,r5,-12658
81122a70:	d9402b15 	stw	r5,172(sp)
81122a74:	01c001c4 	movi	r7,7
81122a78:	dcc02c17 	ldw	r19,176(sp)
81122a7c:	00000306 	br	81122a8c <___vfprintf_internal_r+0x13bc>
81122a80:	b5800204 	addi	r22,r22,8
81122a84:	843ffc04 	addi	r16,r16,-16
81122a88:	e4007b0e 	bge	fp,r16,81122c78 <___vfprintf_internal_r+0x15a8>
81122a8c:	18c00404 	addi	r3,r3,16
81122a90:	8c400044 	addi	r17,r17,1
81122a94:	b5000015 	stw	r20,0(r22)
81122a98:	b7000115 	stw	fp,4(r22)
81122a9c:	d8c02015 	stw	r3,128(sp)
81122aa0:	dc401f15 	stw	r17,124(sp)
81122aa4:	3c7ff60e 	bge	r7,r17,81122a80 <__reset+0xfb102a80>
81122aa8:	d9801e04 	addi	r6,sp,120
81122aac:	b80b883a 	mov	r5,r23
81122ab0:	9809883a 	mov	r4,r19
81122ab4:	d9c03c15 	stw	r7,240(sp)
81122ab8:	112d8c00 	call	8112d8c0 <__sprint_r>
81122abc:	d9c03c17 	ldw	r7,240(sp)
81122ac0:	103c071e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122ac4:	d8c02017 	ldw	r3,128(sp)
81122ac8:	dc401f17 	ldw	r17,124(sp)
81122acc:	dd800404 	addi	r22,sp,16
81122ad0:	003fec06 	br	81122a84 <__reset+0xfb102a84>
81122ad4:	9080100c 	andi	r2,r18,64
81122ad8:	d8002785 	stb	zero,158(sp)
81122adc:	10010e26 	beq	r2,zero,81122f18 <___vfprintf_internal_r+0x1848>
81122ae0:	d9002d17 	ldw	r4,180(sp)
81122ae4:	d9402917 	ldw	r5,164(sp)
81122ae8:	002d883a 	mov	r22,zero
81122aec:	20800104 	addi	r2,r4,4
81122af0:	24c0000b 	ldhu	r19,0(r4)
81122af4:	283fc90e 	bge	r5,zero,81122a1c <__reset+0xfb102a1c>
81122af8:	d8802d15 	stw	r2,180(sp)
81122afc:	0039883a 	mov	fp,zero
81122b00:	9d84b03a 	or	r2,r19,r22
81122b04:	103c461e 	bne	r2,zero,81121c20 <__reset+0xfb101c20>
81122b08:	00800044 	movi	r2,1
81122b0c:	003e6c06 	br	811224c0 <__reset+0xfb1024c0>
81122b10:	d9002c17 	ldw	r4,176(sp)
81122b14:	d9801e04 	addi	r6,sp,120
81122b18:	b80b883a 	mov	r5,r23
81122b1c:	112d8c00 	call	8112d8c0 <__sprint_r>
81122b20:	103bef1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122b24:	d8c02017 	ldw	r3,128(sp)
81122b28:	da000404 	addi	r8,sp,16
81122b2c:	d9003217 	ldw	r4,200(sp)
81122b30:	d8802617 	ldw	r2,152(sp)
81122b34:	d9403317 	ldw	r5,204(sp)
81122b38:	8123883a 	add	r17,r16,r4
81122b3c:	11400216 	blt	r2,r5,81122b48 <___vfprintf_internal_r+0x1478>
81122b40:	9100004c 	andi	r4,r18,1
81122b44:	20000d26 	beq	r4,zero,81122b7c <___vfprintf_internal_r+0x14ac>
81122b48:	d9003717 	ldw	r4,220(sp)
81122b4c:	d9403417 	ldw	r5,208(sp)
81122b50:	1907883a 	add	r3,r3,r4
81122b54:	d9001f17 	ldw	r4,124(sp)
81122b58:	41400015 	stw	r5,0(r8)
81122b5c:	d9403717 	ldw	r5,220(sp)
81122b60:	21000044 	addi	r4,r4,1
81122b64:	d8c02015 	stw	r3,128(sp)
81122b68:	41400115 	stw	r5,4(r8)
81122b6c:	d9001f15 	stw	r4,124(sp)
81122b70:	014001c4 	movi	r5,7
81122b74:	2901e816 	blt	r5,r4,81123318 <___vfprintf_internal_r+0x1c48>
81122b78:	42000204 	addi	r8,r8,8
81122b7c:	d9003317 	ldw	r4,204(sp)
81122b80:	8121883a 	add	r16,r16,r4
81122b84:	2085c83a 	sub	r2,r4,r2
81122b88:	8461c83a 	sub	r16,r16,r17
81122b8c:	1400010e 	bge	r2,r16,81122b94 <___vfprintf_internal_r+0x14c4>
81122b90:	1021883a 	mov	r16,r2
81122b94:	04000a0e 	bge	zero,r16,81122bc0 <___vfprintf_internal_r+0x14f0>
81122b98:	d9001f17 	ldw	r4,124(sp)
81122b9c:	1c07883a 	add	r3,r3,r16
81122ba0:	44400015 	stw	r17,0(r8)
81122ba4:	21000044 	addi	r4,r4,1
81122ba8:	44000115 	stw	r16,4(r8)
81122bac:	d8c02015 	stw	r3,128(sp)
81122bb0:	d9001f15 	stw	r4,124(sp)
81122bb4:	014001c4 	movi	r5,7
81122bb8:	2901fb16 	blt	r5,r4,811233a8 <___vfprintf_internal_r+0x1cd8>
81122bbc:	42000204 	addi	r8,r8,8
81122bc0:	8001f716 	blt	r16,zero,811233a0 <___vfprintf_internal_r+0x1cd0>
81122bc4:	1421c83a 	sub	r16,r2,r16
81122bc8:	043d380e 	bge	zero,r16,811220ac <__reset+0xfb1020ac>
81122bcc:	04400404 	movi	r17,16
81122bd0:	d8801f17 	ldw	r2,124(sp)
81122bd4:	8c3efb0e 	bge	r17,r16,811227c4 <__reset+0xfb1027c4>
81122bd8:	01604574 	movhi	r5,33045
81122bdc:	2973a384 	addi	r5,r5,-12658
81122be0:	d9402b15 	stw	r5,172(sp)
81122be4:	058001c4 	movi	r22,7
81122be8:	dcc02c17 	ldw	r19,176(sp)
81122bec:	00000306 	br	81122bfc <___vfprintf_internal_r+0x152c>
81122bf0:	42000204 	addi	r8,r8,8
81122bf4:	843ffc04 	addi	r16,r16,-16
81122bf8:	8c3ef50e 	bge	r17,r16,811227d0 <__reset+0xfb1027d0>
81122bfc:	18c00404 	addi	r3,r3,16
81122c00:	10800044 	addi	r2,r2,1
81122c04:	45000015 	stw	r20,0(r8)
81122c08:	44400115 	stw	r17,4(r8)
81122c0c:	d8c02015 	stw	r3,128(sp)
81122c10:	d8801f15 	stw	r2,124(sp)
81122c14:	b0bff60e 	bge	r22,r2,81122bf0 <__reset+0xfb102bf0>
81122c18:	d9801e04 	addi	r6,sp,120
81122c1c:	b80b883a 	mov	r5,r23
81122c20:	9809883a 	mov	r4,r19
81122c24:	112d8c00 	call	8112d8c0 <__sprint_r>
81122c28:	103bad1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122c2c:	d8c02017 	ldw	r3,128(sp)
81122c30:	d8801f17 	ldw	r2,124(sp)
81122c34:	da000404 	addi	r8,sp,16
81122c38:	003fee06 	br	81122bf4 <__reset+0xfb102bf4>
81122c3c:	9088703a 	and	r4,r18,r2
81122c40:	203eab1e 	bne	r4,zero,811226f0 <__reset+0xfb1026f0>
81122c44:	dc401f17 	ldw	r17,124(sp)
81122c48:	40800115 	stw	r2,4(r8)
81122c4c:	44000015 	stw	r16,0(r8)
81122c50:	8c400044 	addi	r17,r17,1
81122c54:	d8c02015 	stw	r3,128(sp)
81122c58:	dc401f15 	stw	r17,124(sp)
81122c5c:	008001c4 	movi	r2,7
81122c60:	14400e16 	blt	r2,r17,81122c9c <___vfprintf_internal_r+0x15cc>
81122c64:	45800204 	addi	r22,r8,8
81122c68:	003eca06 	br	81122794 <__reset+0xfb102794>
81122c6c:	01204574 	movhi	r4,33045
81122c70:	2133a384 	addi	r4,r4,-12658
81122c74:	d9002b15 	stw	r4,172(sp)
81122c78:	d8802b17 	ldw	r2,172(sp)
81122c7c:	1c07883a 	add	r3,r3,r16
81122c80:	8c400044 	addi	r17,r17,1
81122c84:	b0800015 	stw	r2,0(r22)
81122c88:	b4000115 	stw	r16,4(r22)
81122c8c:	d8c02015 	stw	r3,128(sp)
81122c90:	dc401f15 	stw	r17,124(sp)
81122c94:	008001c4 	movi	r2,7
81122c98:	147ebd0e 	bge	r2,r17,81122790 <__reset+0xfb102790>
81122c9c:	d9002c17 	ldw	r4,176(sp)
81122ca0:	d9801e04 	addi	r6,sp,120
81122ca4:	b80b883a 	mov	r5,r23
81122ca8:	112d8c00 	call	8112d8c0 <__sprint_r>
81122cac:	103b8c1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122cb0:	d8c02017 	ldw	r3,128(sp)
81122cb4:	dc401f17 	ldw	r17,124(sp)
81122cb8:	dd800404 	addi	r22,sp,16
81122cbc:	003eb506 	br	81122794 <__reset+0xfb102794>
81122cc0:	d9002c17 	ldw	r4,176(sp)
81122cc4:	d9801e04 	addi	r6,sp,120
81122cc8:	b80b883a 	mov	r5,r23
81122ccc:	112d8c00 	call	8112d8c0 <__sprint_r>
81122cd0:	103b831e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122cd4:	d8c02017 	ldw	r3,128(sp)
81122cd8:	dc401f17 	ldw	r17,124(sp)
81122cdc:	da000404 	addi	r8,sp,16
81122ce0:	003e8d06 	br	81122718 <__reset+0xfb102718>
81122ce4:	d9002c17 	ldw	r4,176(sp)
81122ce8:	d9801e04 	addi	r6,sp,120
81122cec:	b80b883a 	mov	r5,r23
81122cf0:	112d8c00 	call	8112d8c0 <__sprint_r>
81122cf4:	103b7a1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122cf8:	d8c02017 	ldw	r3,128(sp)
81122cfc:	dc401f17 	ldw	r17,124(sp)
81122d00:	dd800404 	addi	r22,sp,16
81122d04:	003e8f06 	br	81122744 <__reset+0xfb102744>
81122d08:	0027883a 	mov	r19,zero
81122d0c:	003f4a06 	br	81122a38 <__reset+0xfb102a38>
81122d10:	d9002c17 	ldw	r4,176(sp)
81122d14:	d9801e04 	addi	r6,sp,120
81122d18:	b80b883a 	mov	r5,r23
81122d1c:	112d8c00 	call	8112d8c0 <__sprint_r>
81122d20:	103b6f1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81122d24:	d8c02017 	ldw	r3,128(sp)
81122d28:	da000404 	addi	r8,sp,16
81122d2c:	003c9d06 	br	81121fa4 <__reset+0xfb101fa4>
81122d30:	04e7c83a 	sub	r19,zero,r19
81122d34:	9804c03a 	cmpne	r2,r19,zero
81122d38:	05adc83a 	sub	r22,zero,r22
81122d3c:	b0adc83a 	sub	r22,r22,r2
81122d40:	d8802917 	ldw	r2,164(sp)
81122d44:	07000b44 	movi	fp,45
81122d48:	df002785 	stb	fp,158(sp)
81122d4c:	10017b16 	blt	r2,zero,8112333c <___vfprintf_internal_r+0x1c6c>
81122d50:	00bfdfc4 	movi	r2,-129
81122d54:	90a4703a 	and	r18,r18,r2
81122d58:	003bb106 	br	81121c20 <__reset+0xfb101c20>
81122d5c:	d9003617 	ldw	r4,216(sp)
81122d60:	d9403817 	ldw	r5,224(sp)
81122d64:	da003d15 	stw	r8,244(sp)
81122d68:	1129f240 	call	81129f24 <__fpclassifyd>
81122d6c:	da003d17 	ldw	r8,244(sp)
81122d70:	1000f026 	beq	r2,zero,81123134 <___vfprintf_internal_r+0x1a64>
81122d74:	d9002917 	ldw	r4,164(sp)
81122d78:	05bff7c4 	movi	r22,-33
81122d7c:	00bfffc4 	movi	r2,-1
81122d80:	8dac703a 	and	r22,r17,r22
81122d84:	20820026 	beq	r4,r2,81123588 <___vfprintf_internal_r+0x1eb8>
81122d88:	008011c4 	movi	r2,71
81122d8c:	b081f726 	beq	r22,r2,8112356c <___vfprintf_internal_r+0x1e9c>
81122d90:	d9003817 	ldw	r4,224(sp)
81122d94:	90c04014 	ori	r3,r18,256
81122d98:	d8c02b15 	stw	r3,172(sp)
81122d9c:	20021516 	blt	r4,zero,811235f4 <___vfprintf_internal_r+0x1f24>
81122da0:	dcc03817 	ldw	r19,224(sp)
81122da4:	d8002a05 	stb	zero,168(sp)
81122da8:	00801984 	movi	r2,102
81122dac:	8881f926 	beq	r17,r2,81123594 <___vfprintf_internal_r+0x1ec4>
81122db0:	00801184 	movi	r2,70
81122db4:	88821c26 	beq	r17,r2,81123628 <___vfprintf_internal_r+0x1f58>
81122db8:	00801144 	movi	r2,69
81122dbc:	b081ef26 	beq	r22,r2,8112357c <___vfprintf_internal_r+0x1eac>
81122dc0:	d8c02917 	ldw	r3,164(sp)
81122dc4:	d8802104 	addi	r2,sp,132
81122dc8:	d8800315 	stw	r2,12(sp)
81122dcc:	d9403617 	ldw	r5,216(sp)
81122dd0:	d8802504 	addi	r2,sp,148
81122dd4:	d9002c17 	ldw	r4,176(sp)
81122dd8:	d8800215 	stw	r2,8(sp)
81122ddc:	d8802604 	addi	r2,sp,152
81122de0:	d8c00015 	stw	r3,0(sp)
81122de4:	d8800115 	stw	r2,4(sp)
81122de8:	01c00084 	movi	r7,2
81122dec:	980d883a 	mov	r6,r19
81122df0:	d8c03c15 	stw	r3,240(sp)
81122df4:	da003d15 	stw	r8,244(sp)
81122df8:	11257dc0 	call	811257dc <_dtoa_r>
81122dfc:	1021883a 	mov	r16,r2
81122e00:	008019c4 	movi	r2,103
81122e04:	d8c03c17 	ldw	r3,240(sp)
81122e08:	da003d17 	ldw	r8,244(sp)
81122e0c:	88817126 	beq	r17,r2,811233d4 <___vfprintf_internal_r+0x1d04>
81122e10:	008011c4 	movi	r2,71
81122e14:	88829226 	beq	r17,r2,81123860 <___vfprintf_internal_r+0x2190>
81122e18:	80f9883a 	add	fp,r16,r3
81122e1c:	d9003617 	ldw	r4,216(sp)
81122e20:	000d883a 	mov	r6,zero
81122e24:	000f883a 	mov	r7,zero
81122e28:	980b883a 	mov	r5,r19
81122e2c:	da003d15 	stw	r8,244(sp)
81122e30:	11321080 	call	81132108 <__eqdf2>
81122e34:	da003d17 	ldw	r8,244(sp)
81122e38:	10018d26 	beq	r2,zero,81123470 <___vfprintf_internal_r+0x1da0>
81122e3c:	d8802117 	ldw	r2,132(sp)
81122e40:	1700062e 	bgeu	r2,fp,81122e5c <___vfprintf_internal_r+0x178c>
81122e44:	01000c04 	movi	r4,48
81122e48:	10c00044 	addi	r3,r2,1
81122e4c:	d8c02115 	stw	r3,132(sp)
81122e50:	11000005 	stb	r4,0(r2)
81122e54:	d8802117 	ldw	r2,132(sp)
81122e58:	173ffb36 	bltu	r2,fp,81122e48 <__reset+0xfb102e48>
81122e5c:	1405c83a 	sub	r2,r2,r16
81122e60:	d8803315 	stw	r2,204(sp)
81122e64:	008011c4 	movi	r2,71
81122e68:	b0817626 	beq	r22,r2,81123444 <___vfprintf_internal_r+0x1d74>
81122e6c:	00801944 	movi	r2,101
81122e70:	1442810e 	bge	r2,r17,81123878 <___vfprintf_internal_r+0x21a8>
81122e74:	d8c02617 	ldw	r3,152(sp)
81122e78:	00801984 	movi	r2,102
81122e7c:	d8c03215 	stw	r3,200(sp)
81122e80:	8881fe26 	beq	r17,r2,8112367c <___vfprintf_internal_r+0x1fac>
81122e84:	d8c03217 	ldw	r3,200(sp)
81122e88:	d9003317 	ldw	r4,204(sp)
81122e8c:	1901dd16 	blt	r3,r4,81123604 <___vfprintf_internal_r+0x1f34>
81122e90:	9480004c 	andi	r18,r18,1
81122e94:	90022b1e 	bne	r18,zero,81123744 <___vfprintf_internal_r+0x2074>
81122e98:	1805883a 	mov	r2,r3
81122e9c:	18028016 	blt	r3,zero,811238a0 <___vfprintf_internal_r+0x21d0>
81122ea0:	d8c03217 	ldw	r3,200(sp)
81122ea4:	044019c4 	movi	r17,103
81122ea8:	d8c02e15 	stw	r3,184(sp)
81122eac:	df002a07 	ldb	fp,168(sp)
81122eb0:	e001531e 	bne	fp,zero,81123400 <___vfprintf_internal_r+0x1d30>
81122eb4:	df002783 	ldbu	fp,158(sp)
81122eb8:	d8802a15 	stw	r2,168(sp)
81122ebc:	dc802b17 	ldw	r18,172(sp)
81122ec0:	d8002915 	stw	zero,164(sp)
81122ec4:	003bd106 	br	81121e0c <__reset+0xfb101e0c>
81122ec8:	d8802d17 	ldw	r2,180(sp)
81122ecc:	d8c02d17 	ldw	r3,180(sp)
81122ed0:	d9002d17 	ldw	r4,180(sp)
81122ed4:	10800017 	ldw	r2,0(r2)
81122ed8:	18c00117 	ldw	r3,4(r3)
81122edc:	21000204 	addi	r4,r4,8
81122ee0:	d8803615 	stw	r2,216(sp)
81122ee4:	d8c03815 	stw	r3,224(sp)
81122ee8:	d9002d15 	stw	r4,180(sp)
81122eec:	003b7506 	br	81121cc4 <__reset+0xfb101cc4>
81122ef0:	ac400007 	ldb	r17,0(r21)
81122ef4:	003a5906 	br	8112185c <__reset+0xfb10185c>
81122ef8:	9080100c 	andi	r2,r18,64
81122efc:	1000a826 	beq	r2,zero,811231a0 <___vfprintf_internal_r+0x1ad0>
81122f00:	d9002d17 	ldw	r4,180(sp)
81122f04:	002d883a 	mov	r22,zero
81122f08:	24c0000b 	ldhu	r19,0(r4)
81122f0c:	21000104 	addi	r4,r4,4
81122f10:	d9002d15 	stw	r4,180(sp)
81122f14:	003ccb06 	br	81122244 <__reset+0xfb102244>
81122f18:	d8c02d17 	ldw	r3,180(sp)
81122f1c:	d9002917 	ldw	r4,164(sp)
81122f20:	002d883a 	mov	r22,zero
81122f24:	18800104 	addi	r2,r3,4
81122f28:	1cc00017 	ldw	r19,0(r3)
81122f2c:	203ebb0e 	bge	r4,zero,81122a1c <__reset+0xfb102a1c>
81122f30:	003ef106 	br	81122af8 <__reset+0xfb102af8>
81122f34:	9080040c 	andi	r2,r18,16
81122f38:	1000921e 	bne	r2,zero,81123184 <___vfprintf_internal_r+0x1ab4>
81122f3c:	9480100c 	andi	r18,r18,64
81122f40:	90013926 	beq	r18,zero,81123428 <___vfprintf_internal_r+0x1d58>
81122f44:	d9002d17 	ldw	r4,180(sp)
81122f48:	d9402f17 	ldw	r5,188(sp)
81122f4c:	20800017 	ldw	r2,0(r4)
81122f50:	21000104 	addi	r4,r4,4
81122f54:	d9002d15 	stw	r4,180(sp)
81122f58:	1140000d 	sth	r5,0(r2)
81122f5c:	003a1606 	br	811217b8 <__reset+0xfb1017b8>
81122f60:	9080100c 	andi	r2,r18,64
81122f64:	10008026 	beq	r2,zero,81123168 <___vfprintf_internal_r+0x1a98>
81122f68:	d8c02d17 	ldw	r3,180(sp)
81122f6c:	1cc0000f 	ldh	r19,0(r3)
81122f70:	18c00104 	addi	r3,r3,4
81122f74:	d8c02d15 	stw	r3,180(sp)
81122f78:	982dd7fa 	srai	r22,r19,31
81122f7c:	b005883a 	mov	r2,r22
81122f80:	003b1f06 	br	81121c00 <__reset+0xfb101c00>
81122f84:	9080100c 	andi	r2,r18,64
81122f88:	d8002785 	stb	zero,158(sp)
81122f8c:	10008a1e 	bne	r2,zero,811231b8 <___vfprintf_internal_r+0x1ae8>
81122f90:	d9402d17 	ldw	r5,180(sp)
81122f94:	d8c02917 	ldw	r3,164(sp)
81122f98:	002d883a 	mov	r22,zero
81122f9c:	28800104 	addi	r2,r5,4
81122fa0:	2cc00017 	ldw	r19,0(r5)
81122fa4:	183e4b0e 	bge	r3,zero,811228d4 <__reset+0xfb1028d4>
81122fa8:	9d86b03a 	or	r3,r19,r22
81122fac:	d8802d15 	stw	r2,180(sp)
81122fb0:	183e4c1e 	bne	r3,zero,811228e4 <__reset+0xfb1028e4>
81122fb4:	0039883a 	mov	fp,zero
81122fb8:	0005883a 	mov	r2,zero
81122fbc:	003d4006 	br	811224c0 <__reset+0xfb1024c0>
81122fc0:	01604574 	movhi	r5,33045
81122fc4:	2973a384 	addi	r5,r5,-12658
81122fc8:	d9402b15 	stw	r5,172(sp)
81122fcc:	d9402b17 	ldw	r5,172(sp)
81122fd0:	1c47883a 	add	r3,r3,r17
81122fd4:	10800044 	addi	r2,r2,1
81122fd8:	41400015 	stw	r5,0(r8)
81122fdc:	44400115 	stw	r17,4(r8)
81122fe0:	d8c02015 	stw	r3,128(sp)
81122fe4:	d8801f15 	stw	r2,124(sp)
81122fe8:	010001c4 	movi	r4,7
81122fec:	20bec816 	blt	r4,r2,81122b10 <__reset+0xfb102b10>
81122ff0:	42000204 	addi	r8,r8,8
81122ff4:	003ecd06 	br	81122b2c <__reset+0xfb102b2c>
81122ff8:	d9002917 	ldw	r4,164(sp)
81122ffc:	d8002785 	stb	zero,158(sp)
81123000:	203d2d16 	blt	r4,zero,811224b8 <__reset+0xfb1024b8>
81123004:	00bfdfc4 	movi	r2,-129
81123008:	90a4703a 	and	r18,r18,r2
8112300c:	003a9106 	br	81121a54 <__reset+0xfb101a54>
81123010:	01204574 	movhi	r4,33045
81123014:	2133a384 	addi	r4,r4,-12658
81123018:	d9002b15 	stw	r4,172(sp)
8112301c:	003c0c06 	br	81122050 <__reset+0xfb102050>
81123020:	d9002c17 	ldw	r4,176(sp)
81123024:	d9801e04 	addi	r6,sp,120
81123028:	b80b883a 	mov	r5,r23
8112302c:	112d8c00 	call	8112d8c0 <__sprint_r>
81123030:	103aab1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81123034:	d8c02017 	ldw	r3,128(sp)
81123038:	da000404 	addi	r8,sp,16
8112303c:	003d4106 	br	81122544 <__reset+0xfb102544>
81123040:	d8801f17 	ldw	r2,124(sp)
81123044:	01604574 	movhi	r5,33045
81123048:	01000044 	movi	r4,1
8112304c:	18c00044 	addi	r3,r3,1
81123050:	10800044 	addi	r2,r2,1
81123054:	29739b04 	addi	r5,r5,-12692
81123058:	41000115 	stw	r4,4(r8)
8112305c:	41400015 	stw	r5,0(r8)
81123060:	d8c02015 	stw	r3,128(sp)
81123064:	d8801f15 	stw	r2,124(sp)
81123068:	010001c4 	movi	r4,7
8112306c:	20805c16 	blt	r4,r2,811231e0 <___vfprintf_internal_r+0x1b10>
81123070:	42000204 	addi	r8,r8,8
81123074:	8800041e 	bne	r17,zero,81123088 <___vfprintf_internal_r+0x19b8>
81123078:	d8803317 	ldw	r2,204(sp)
8112307c:	1000021e 	bne	r2,zero,81123088 <___vfprintf_internal_r+0x19b8>
81123080:	9080004c 	andi	r2,r18,1
81123084:	103c0926 	beq	r2,zero,811220ac <__reset+0xfb1020ac>
81123088:	d9003717 	ldw	r4,220(sp)
8112308c:	d8801f17 	ldw	r2,124(sp)
81123090:	d9403417 	ldw	r5,208(sp)
81123094:	20c7883a 	add	r3,r4,r3
81123098:	10800044 	addi	r2,r2,1
8112309c:	41000115 	stw	r4,4(r8)
811230a0:	41400015 	stw	r5,0(r8)
811230a4:	d8c02015 	stw	r3,128(sp)
811230a8:	d8801f15 	stw	r2,124(sp)
811230ac:	010001c4 	movi	r4,7
811230b0:	20812116 	blt	r4,r2,81123538 <___vfprintf_internal_r+0x1e68>
811230b4:	42000204 	addi	r8,r8,8
811230b8:	0463c83a 	sub	r17,zero,r17
811230bc:	0440730e 	bge	zero,r17,8112328c <___vfprintf_internal_r+0x1bbc>
811230c0:	05800404 	movi	r22,16
811230c4:	b440860e 	bge	r22,r17,811232e0 <___vfprintf_internal_r+0x1c10>
811230c8:	01604574 	movhi	r5,33045
811230cc:	2973a384 	addi	r5,r5,-12658
811230d0:	d9402b15 	stw	r5,172(sp)
811230d4:	070001c4 	movi	fp,7
811230d8:	dcc02c17 	ldw	r19,176(sp)
811230dc:	00000306 	br	811230ec <___vfprintf_internal_r+0x1a1c>
811230e0:	42000204 	addi	r8,r8,8
811230e4:	8c7ffc04 	addi	r17,r17,-16
811230e8:	b440800e 	bge	r22,r17,811232ec <___vfprintf_internal_r+0x1c1c>
811230ec:	18c00404 	addi	r3,r3,16
811230f0:	10800044 	addi	r2,r2,1
811230f4:	45000015 	stw	r20,0(r8)
811230f8:	45800115 	stw	r22,4(r8)
811230fc:	d8c02015 	stw	r3,128(sp)
81123100:	d8801f15 	stw	r2,124(sp)
81123104:	e0bff60e 	bge	fp,r2,811230e0 <__reset+0xfb1030e0>
81123108:	d9801e04 	addi	r6,sp,120
8112310c:	b80b883a 	mov	r5,r23
81123110:	9809883a 	mov	r4,r19
81123114:	112d8c00 	call	8112d8c0 <__sprint_r>
81123118:	103a711e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
8112311c:	d8c02017 	ldw	r3,128(sp)
81123120:	d8801f17 	ldw	r2,124(sp)
81123124:	da000404 	addi	r8,sp,16
81123128:	003fee06 	br	811230e4 <__reset+0xfb1030e4>
8112312c:	00bfffc4 	movi	r2,-1
81123130:	003a6f06 	br	81121af0 <__reset+0xfb101af0>
81123134:	008011c4 	movi	r2,71
81123138:	1440b816 	blt	r2,r17,8112341c <___vfprintf_internal_r+0x1d4c>
8112313c:	04204574 	movhi	r16,33045
81123140:	84338d04 	addi	r16,r16,-12748
81123144:	00c000c4 	movi	r3,3
81123148:	00bfdfc4 	movi	r2,-129
8112314c:	d8c02a15 	stw	r3,168(sp)
81123150:	90a4703a 	and	r18,r18,r2
81123154:	df002783 	ldbu	fp,158(sp)
81123158:	d8c02e15 	stw	r3,184(sp)
8112315c:	d8002915 	stw	zero,164(sp)
81123160:	d8003215 	stw	zero,200(sp)
81123164:	003b2906 	br	81121e0c <__reset+0xfb101e0c>
81123168:	d9002d17 	ldw	r4,180(sp)
8112316c:	24c00017 	ldw	r19,0(r4)
81123170:	21000104 	addi	r4,r4,4
81123174:	d9002d15 	stw	r4,180(sp)
81123178:	982dd7fa 	srai	r22,r19,31
8112317c:	b005883a 	mov	r2,r22
81123180:	003a9f06 	br	81121c00 <__reset+0xfb101c00>
81123184:	d9402d17 	ldw	r5,180(sp)
81123188:	d8c02f17 	ldw	r3,188(sp)
8112318c:	28800017 	ldw	r2,0(r5)
81123190:	29400104 	addi	r5,r5,4
81123194:	d9402d15 	stw	r5,180(sp)
81123198:	10c00015 	stw	r3,0(r2)
8112319c:	00398606 	br	811217b8 <__reset+0xfb1017b8>
811231a0:	d9402d17 	ldw	r5,180(sp)
811231a4:	002d883a 	mov	r22,zero
811231a8:	2cc00017 	ldw	r19,0(r5)
811231ac:	29400104 	addi	r5,r5,4
811231b0:	d9402d15 	stw	r5,180(sp)
811231b4:	003c2306 	br	81122244 <__reset+0xfb102244>
811231b8:	d8c02d17 	ldw	r3,180(sp)
811231bc:	d9002917 	ldw	r4,164(sp)
811231c0:	002d883a 	mov	r22,zero
811231c4:	18800104 	addi	r2,r3,4
811231c8:	1cc0000b 	ldhu	r19,0(r3)
811231cc:	203dc10e 	bge	r4,zero,811228d4 <__reset+0xfb1028d4>
811231d0:	003f7506 	br	81122fa8 <__reset+0xfb102fa8>
811231d4:	04204574 	movhi	r16,33045
811231d8:	84338b04 	addi	r16,r16,-12756
811231dc:	003acc06 	br	81121d10 <__reset+0xfb101d10>
811231e0:	d9002c17 	ldw	r4,176(sp)
811231e4:	d9801e04 	addi	r6,sp,120
811231e8:	b80b883a 	mov	r5,r23
811231ec:	112d8c00 	call	8112d8c0 <__sprint_r>
811231f0:	103a3b1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
811231f4:	dc402617 	ldw	r17,152(sp)
811231f8:	d8c02017 	ldw	r3,128(sp)
811231fc:	da000404 	addi	r8,sp,16
81123200:	003f9c06 	br	81123074 <__reset+0xfb103074>
81123204:	ac400043 	ldbu	r17,1(r21)
81123208:	94800814 	ori	r18,r18,32
8112320c:	ad400044 	addi	r21,r21,1
81123210:	8c403fcc 	andi	r17,r17,255
81123214:	8c40201c 	xori	r17,r17,128
81123218:	8c7fe004 	addi	r17,r17,-128
8112321c:	00398f06 	br	8112185c <__reset+0xfb10185c>
81123220:	d8c02d15 	stw	r3,180(sp)
81123224:	0039883a 	mov	fp,zero
81123228:	003e3506 	br	81122b00 <__reset+0xfb102b00>
8112322c:	d9002c17 	ldw	r4,176(sp)
81123230:	d9801e04 	addi	r6,sp,120
81123234:	b80b883a 	mov	r5,r23
81123238:	112d8c00 	call	8112d8c0 <__sprint_r>
8112323c:	103a281e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81123240:	d8c02017 	ldw	r3,128(sp)
81123244:	da000404 	addi	r8,sp,16
81123248:	003cd006 	br	8112258c <__reset+0xfb10258c>
8112324c:	8009883a 	mov	r4,r16
81123250:	da003d15 	stw	r8,244(sp)
81123254:	111f1b80 	call	8111f1b8 <strlen>
81123258:	d8802e15 	stw	r2,184(sp)
8112325c:	da003d17 	ldw	r8,244(sp)
81123260:	103c340e 	bge	r2,zero,81122334 <__reset+0xfb102334>
81123264:	0005883a 	mov	r2,zero
81123268:	003c3206 	br	81122334 <__reset+0xfb102334>
8112326c:	d9002c17 	ldw	r4,176(sp)
81123270:	d9801e04 	addi	r6,sp,120
81123274:	b80b883a 	mov	r5,r23
81123278:	112d8c00 	call	8112d8c0 <__sprint_r>
8112327c:	103a181e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
81123280:	d8c02017 	ldw	r3,128(sp)
81123284:	d8801f17 	ldw	r2,124(sp)
81123288:	da000404 	addi	r8,sp,16
8112328c:	d9403317 	ldw	r5,204(sp)
81123290:	10800044 	addi	r2,r2,1
81123294:	44000015 	stw	r16,0(r8)
81123298:	28c7883a 	add	r3,r5,r3
8112329c:	003b7d06 	br	81122094 <__reset+0xfb102094>
811232a0:	01204574 	movhi	r4,33045
811232a4:	2133a784 	addi	r4,r4,-12642
811232a8:	d9003515 	stw	r4,212(sp)
811232ac:	003b1406 	br	81121f00 <__reset+0xfb101f00>
811232b0:	013fffc4 	movi	r4,-1
811232b4:	003a3506 	br	81121b8c <__reset+0xfb101b8c>
811232b8:	0023883a 	mov	r17,zero
811232bc:	003d9d06 	br	81122934 <__reset+0xfb102934>
811232c0:	d9002c17 	ldw	r4,176(sp)
811232c4:	d9801e04 	addi	r6,sp,120
811232c8:	b80b883a 	mov	r5,r23
811232cc:	112d8c00 	call	8112d8c0 <__sprint_r>
811232d0:	103a031e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
811232d4:	d8c02017 	ldw	r3,128(sp)
811232d8:	da000404 	addi	r8,sp,16
811232dc:	003d9406 	br	81122930 <__reset+0xfb102930>
811232e0:	01204574 	movhi	r4,33045
811232e4:	2133a384 	addi	r4,r4,-12658
811232e8:	d9002b15 	stw	r4,172(sp)
811232ec:	d9002b17 	ldw	r4,172(sp)
811232f0:	1c47883a 	add	r3,r3,r17
811232f4:	10800044 	addi	r2,r2,1
811232f8:	41000015 	stw	r4,0(r8)
811232fc:	44400115 	stw	r17,4(r8)
81123300:	d8c02015 	stw	r3,128(sp)
81123304:	d8801f15 	stw	r2,124(sp)
81123308:	010001c4 	movi	r4,7
8112330c:	20bfd716 	blt	r4,r2,8112326c <__reset+0xfb10326c>
81123310:	42000204 	addi	r8,r8,8
81123314:	003fdd06 	br	8112328c <__reset+0xfb10328c>
81123318:	d9002c17 	ldw	r4,176(sp)
8112331c:	d9801e04 	addi	r6,sp,120
81123320:	b80b883a 	mov	r5,r23
81123324:	112d8c00 	call	8112d8c0 <__sprint_r>
81123328:	1039ed1e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
8112332c:	d8802617 	ldw	r2,152(sp)
81123330:	d8c02017 	ldw	r3,128(sp)
81123334:	da000404 	addi	r8,sp,16
81123338:	003e1006 	br	81122b7c <__reset+0xfb102b7c>
8112333c:	00800044 	movi	r2,1
81123340:	10803fcc 	andi	r2,r2,255
81123344:	00c00044 	movi	r3,1
81123348:	10fa3526 	beq	r2,r3,81121c20 <__reset+0xfb101c20>
8112334c:	00c00084 	movi	r3,2
81123350:	10fbcb26 	beq	r2,r3,81122280 <__reset+0xfb102280>
81123354:	003a8f06 	br	81121d94 <__reset+0xfb101d94>
81123358:	01204574 	movhi	r4,33045
8112335c:	2133a784 	addi	r4,r4,-12642
81123360:	d9003515 	stw	r4,212(sp)
81123364:	003b7606 	br	81122140 <__reset+0xfb102140>
81123368:	d8802917 	ldw	r2,164(sp)
8112336c:	00c00184 	movi	r3,6
81123370:	1880012e 	bgeu	r3,r2,81123378 <___vfprintf_internal_r+0x1ca8>
81123374:	1805883a 	mov	r2,r3
81123378:	d8802e15 	stw	r2,184(sp)
8112337c:	1000ef16 	blt	r2,zero,8112373c <___vfprintf_internal_r+0x206c>
81123380:	04204574 	movhi	r16,33045
81123384:	d8802a15 	stw	r2,168(sp)
81123388:	dcc02d15 	stw	r19,180(sp)
8112338c:	d8002915 	stw	zero,164(sp)
81123390:	d8003215 	stw	zero,200(sp)
81123394:	84339904 	addi	r16,r16,-12700
81123398:	0039883a 	mov	fp,zero
8112339c:	003aa206 	br	81121e28 <__reset+0xfb101e28>
811233a0:	0021883a 	mov	r16,zero
811233a4:	003e0706 	br	81122bc4 <__reset+0xfb102bc4>
811233a8:	d9002c17 	ldw	r4,176(sp)
811233ac:	d9801e04 	addi	r6,sp,120
811233b0:	b80b883a 	mov	r5,r23
811233b4:	112d8c00 	call	8112d8c0 <__sprint_r>
811233b8:	1039c91e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
811233bc:	d8802617 	ldw	r2,152(sp)
811233c0:	d9403317 	ldw	r5,204(sp)
811233c4:	d8c02017 	ldw	r3,128(sp)
811233c8:	da000404 	addi	r8,sp,16
811233cc:	2885c83a 	sub	r2,r5,r2
811233d0:	003dfb06 	br	81122bc0 <__reset+0xfb102bc0>
811233d4:	9080004c 	andi	r2,r18,1
811233d8:	103e8f1e 	bne	r2,zero,81122e18 <__reset+0xfb102e18>
811233dc:	d8802117 	ldw	r2,132(sp)
811233e0:	003e9e06 	br	81122e5c <__reset+0xfb102e5c>
811233e4:	1025883a 	mov	r18,r2
811233e8:	0039883a 	mov	fp,zero
811233ec:	00800084 	movi	r2,2
811233f0:	003fd306 	br	81123340 <__reset+0xfb103340>
811233f4:	07000b44 	movi	fp,45
811233f8:	df002785 	stb	fp,158(sp)
811233fc:	003a4006 	br	81121d00 <__reset+0xfb101d00>
81123400:	00c00b44 	movi	r3,45
81123404:	d8c02785 	stb	r3,158(sp)
81123408:	d8802a15 	stw	r2,168(sp)
8112340c:	dc802b17 	ldw	r18,172(sp)
81123410:	d8002915 	stw	zero,164(sp)
81123414:	07000b44 	movi	fp,45
81123418:	003a8006 	br	81121e1c <__reset+0xfb101e1c>
8112341c:	04204574 	movhi	r16,33045
81123420:	84338e04 	addi	r16,r16,-12744
81123424:	003f4706 	br	81123144 <__reset+0xfb103144>
81123428:	d8c02d17 	ldw	r3,180(sp)
8112342c:	d9002f17 	ldw	r4,188(sp)
81123430:	18800017 	ldw	r2,0(r3)
81123434:	18c00104 	addi	r3,r3,4
81123438:	d8c02d15 	stw	r3,180(sp)
8112343c:	11000015 	stw	r4,0(r2)
81123440:	0038dd06 	br	811217b8 <__reset+0xfb1017b8>
81123444:	dd802617 	ldw	r22,152(sp)
81123448:	00bfff44 	movi	r2,-3
8112344c:	b0801c16 	blt	r22,r2,811234c0 <___vfprintf_internal_r+0x1df0>
81123450:	d9402917 	ldw	r5,164(sp)
81123454:	2d801a16 	blt	r5,r22,811234c0 <___vfprintf_internal_r+0x1df0>
81123458:	dd803215 	stw	r22,200(sp)
8112345c:	003e8906 	br	81122e84 <__reset+0xfb102e84>
81123460:	01204574 	movhi	r4,33045
81123464:	2133a384 	addi	r4,r4,-12658
81123468:	d9002b15 	stw	r4,172(sp)
8112346c:	003c9106 	br	811226b4 <__reset+0xfb1026b4>
81123470:	e005883a 	mov	r2,fp
81123474:	003e7906 	br	81122e5c <__reset+0xfb102e5c>
81123478:	d9402917 	ldw	r5,164(sp)
8112347c:	df002783 	ldbu	fp,158(sp)
81123480:	dcc02d15 	stw	r19,180(sp)
81123484:	d9402a15 	stw	r5,168(sp)
81123488:	d9402e15 	stw	r5,184(sp)
8112348c:	d8002915 	stw	zero,164(sp)
81123490:	d8003215 	stw	zero,200(sp)
81123494:	003a5d06 	br	81121e0c <__reset+0xfb101e0c>
81123498:	9080004c 	andi	r2,r18,1
8112349c:	0039883a 	mov	fp,zero
811234a0:	10000426 	beq	r2,zero,811234b4 <___vfprintf_internal_r+0x1de4>
811234a4:	00800c04 	movi	r2,48
811234a8:	dc001dc4 	addi	r16,sp,119
811234ac:	d8801dc5 	stb	r2,119(sp)
811234b0:	003b8006 	br	811222b4 <__reset+0xfb1022b4>
811234b4:	d8002e15 	stw	zero,184(sp)
811234b8:	dc001e04 	addi	r16,sp,120
811234bc:	003a4d06 	br	81121df4 <__reset+0xfb101df4>
811234c0:	8c7fff84 	addi	r17,r17,-2
811234c4:	b5bfffc4 	addi	r22,r22,-1
811234c8:	dd802615 	stw	r22,152(sp)
811234cc:	dc4022c5 	stb	r17,139(sp)
811234d0:	b000bf16 	blt	r22,zero,811237d0 <___vfprintf_internal_r+0x2100>
811234d4:	00800ac4 	movi	r2,43
811234d8:	d8802305 	stb	r2,140(sp)
811234dc:	00800244 	movi	r2,9
811234e0:	15807016 	blt	r2,r22,811236a4 <___vfprintf_internal_r+0x1fd4>
811234e4:	00800c04 	movi	r2,48
811234e8:	b5800c04 	addi	r22,r22,48
811234ec:	d8802345 	stb	r2,141(sp)
811234f0:	dd802385 	stb	r22,142(sp)
811234f4:	d88023c4 	addi	r2,sp,143
811234f8:	df0022c4 	addi	fp,sp,139
811234fc:	d8c03317 	ldw	r3,204(sp)
81123500:	1739c83a 	sub	fp,r2,fp
81123504:	d9003317 	ldw	r4,204(sp)
81123508:	e0c7883a 	add	r3,fp,r3
8112350c:	df003a15 	stw	fp,232(sp)
81123510:	d8c02e15 	stw	r3,184(sp)
81123514:	00800044 	movi	r2,1
81123518:	1100b30e 	bge	r2,r4,811237e8 <___vfprintf_internal_r+0x2118>
8112351c:	d8c02e17 	ldw	r3,184(sp)
81123520:	18c00044 	addi	r3,r3,1
81123524:	d8c02e15 	stw	r3,184(sp)
81123528:	1805883a 	mov	r2,r3
8112352c:	1800ac16 	blt	r3,zero,811237e0 <___vfprintf_internal_r+0x2110>
81123530:	d8003215 	stw	zero,200(sp)
81123534:	003e5d06 	br	81122eac <__reset+0xfb102eac>
81123538:	d9002c17 	ldw	r4,176(sp)
8112353c:	d9801e04 	addi	r6,sp,120
81123540:	b80b883a 	mov	r5,r23
81123544:	112d8c00 	call	8112d8c0 <__sprint_r>
81123548:	1039651e 	bne	r2,zero,81121ae0 <__reset+0xfb101ae0>
8112354c:	dc402617 	ldw	r17,152(sp)
81123550:	d8c02017 	ldw	r3,128(sp)
81123554:	d8801f17 	ldw	r2,124(sp)
81123558:	da000404 	addi	r8,sp,16
8112355c:	003ed606 	br	811230b8 <__reset+0xfb1030b8>
81123560:	582b883a 	mov	r21,r11
81123564:	d8002915 	stw	zero,164(sp)
81123568:	0038bd06 	br	81121860 <__reset+0xfb101860>
8112356c:	d8802917 	ldw	r2,164(sp)
81123570:	103e071e 	bne	r2,zero,81122d90 <__reset+0xfb102d90>
81123574:	dc002915 	stw	r16,164(sp)
81123578:	003e0506 	br	81122d90 <__reset+0xfb102d90>
8112357c:	d9002917 	ldw	r4,164(sp)
81123580:	20c00044 	addi	r3,r4,1
81123584:	003e0f06 	br	81122dc4 <__reset+0xfb102dc4>
81123588:	01400184 	movi	r5,6
8112358c:	d9402915 	stw	r5,164(sp)
81123590:	003dff06 	br	81122d90 <__reset+0xfb102d90>
81123594:	d8802104 	addi	r2,sp,132
81123598:	d8800315 	stw	r2,12(sp)
8112359c:	d8802504 	addi	r2,sp,148
811235a0:	d8800215 	stw	r2,8(sp)
811235a4:	d8802604 	addi	r2,sp,152
811235a8:	d8800115 	stw	r2,4(sp)
811235ac:	d8802917 	ldw	r2,164(sp)
811235b0:	d9403617 	ldw	r5,216(sp)
811235b4:	d9002c17 	ldw	r4,176(sp)
811235b8:	d8800015 	stw	r2,0(sp)
811235bc:	01c000c4 	movi	r7,3
811235c0:	980d883a 	mov	r6,r19
811235c4:	da003d15 	stw	r8,244(sp)
811235c8:	11257dc0 	call	811257dc <_dtoa_r>
811235cc:	d8c02917 	ldw	r3,164(sp)
811235d0:	da003d17 	ldw	r8,244(sp)
811235d4:	1021883a 	mov	r16,r2
811235d8:	10f9883a 	add	fp,r2,r3
811235dc:	81000007 	ldb	r4,0(r16)
811235e0:	00800c04 	movi	r2,48
811235e4:	20805e26 	beq	r4,r2,81123760 <___vfprintf_internal_r+0x2090>
811235e8:	d8c02617 	ldw	r3,152(sp)
811235ec:	e0f9883a 	add	fp,fp,r3
811235f0:	003e0a06 	br	81122e1c <__reset+0xfb102e1c>
811235f4:	00c00b44 	movi	r3,45
811235f8:	24e0003c 	xorhi	r19,r4,32768
811235fc:	d8c02a05 	stb	r3,168(sp)
81123600:	003de906 	br	81122da8 <__reset+0xfb102da8>
81123604:	d8c03217 	ldw	r3,200(sp)
81123608:	00c07a0e 	bge	zero,r3,811237f4 <___vfprintf_internal_r+0x2124>
8112360c:	00800044 	movi	r2,1
81123610:	d9003317 	ldw	r4,204(sp)
81123614:	1105883a 	add	r2,r2,r4
81123618:	d8802e15 	stw	r2,184(sp)
8112361c:	10004e16 	blt	r2,zero,81123758 <___vfprintf_internal_r+0x2088>
81123620:	044019c4 	movi	r17,103
81123624:	003e2106 	br	81122eac <__reset+0xfb102eac>
81123628:	d9002917 	ldw	r4,164(sp)
8112362c:	d8802104 	addi	r2,sp,132
81123630:	d8800315 	stw	r2,12(sp)
81123634:	d9000015 	stw	r4,0(sp)
81123638:	d8802504 	addi	r2,sp,148
8112363c:	d9403617 	ldw	r5,216(sp)
81123640:	d9002c17 	ldw	r4,176(sp)
81123644:	d8800215 	stw	r2,8(sp)
81123648:	d8802604 	addi	r2,sp,152
8112364c:	d8800115 	stw	r2,4(sp)
81123650:	01c000c4 	movi	r7,3
81123654:	980d883a 	mov	r6,r19
81123658:	da003d15 	stw	r8,244(sp)
8112365c:	11257dc0 	call	811257dc <_dtoa_r>
81123660:	d8c02917 	ldw	r3,164(sp)
81123664:	da003d17 	ldw	r8,244(sp)
81123668:	1021883a 	mov	r16,r2
8112366c:	00801184 	movi	r2,70
81123670:	80f9883a 	add	fp,r16,r3
81123674:	88bfd926 	beq	r17,r2,811235dc <__reset+0xfb1035dc>
81123678:	003de806 	br	81122e1c <__reset+0xfb102e1c>
8112367c:	d9002917 	ldw	r4,164(sp)
81123680:	00c04d0e 	bge	zero,r3,811237b8 <___vfprintf_internal_r+0x20e8>
81123684:	2000441e 	bne	r4,zero,81123798 <___vfprintf_internal_r+0x20c8>
81123688:	9480004c 	andi	r18,r18,1
8112368c:	9000421e 	bne	r18,zero,81123798 <___vfprintf_internal_r+0x20c8>
81123690:	1805883a 	mov	r2,r3
81123694:	18007016 	blt	r3,zero,81123858 <___vfprintf_internal_r+0x2188>
81123698:	d8c03217 	ldw	r3,200(sp)
8112369c:	d8c02e15 	stw	r3,184(sp)
811236a0:	003e0206 	br	81122eac <__reset+0xfb102eac>
811236a4:	df0022c4 	addi	fp,sp,139
811236a8:	dc002915 	stw	r16,164(sp)
811236ac:	4027883a 	mov	r19,r8
811236b0:	e021883a 	mov	r16,fp
811236b4:	b009883a 	mov	r4,r22
811236b8:	01400284 	movi	r5,10
811236bc:	1130c380 	call	81130c38 <__modsi3>
811236c0:	10800c04 	addi	r2,r2,48
811236c4:	843fffc4 	addi	r16,r16,-1
811236c8:	b009883a 	mov	r4,r22
811236cc:	01400284 	movi	r5,10
811236d0:	80800005 	stb	r2,0(r16)
811236d4:	1130bb40 	call	81130bb4 <__divsi3>
811236d8:	102d883a 	mov	r22,r2
811236dc:	00800244 	movi	r2,9
811236e0:	15bff416 	blt	r2,r22,811236b4 <__reset+0xfb1036b4>
811236e4:	9811883a 	mov	r8,r19
811236e8:	b0800c04 	addi	r2,r22,48
811236ec:	8027883a 	mov	r19,r16
811236f0:	997fffc4 	addi	r5,r19,-1
811236f4:	98bfffc5 	stb	r2,-1(r19)
811236f8:	dc002917 	ldw	r16,164(sp)
811236fc:	2f006a2e 	bgeu	r5,fp,811238a8 <___vfprintf_internal_r+0x21d8>
81123700:	d9c02384 	addi	r7,sp,142
81123704:	3ccfc83a 	sub	r7,r7,r19
81123708:	d9002344 	addi	r4,sp,141
8112370c:	e1cf883a 	add	r7,fp,r7
81123710:	00000106 	br	81123718 <___vfprintf_internal_r+0x2048>
81123714:	28800003 	ldbu	r2,0(r5)
81123718:	20800005 	stb	r2,0(r4)
8112371c:	21000044 	addi	r4,r4,1
81123720:	29400044 	addi	r5,r5,1
81123724:	393ffb1e 	bne	r7,r4,81123714 <__reset+0xfb103714>
81123728:	d8802304 	addi	r2,sp,140
8112372c:	14c5c83a 	sub	r2,r2,r19
81123730:	d8c02344 	addi	r3,sp,141
81123734:	1885883a 	add	r2,r3,r2
81123738:	003f7006 	br	811234fc <__reset+0xfb1034fc>
8112373c:	0005883a 	mov	r2,zero
81123740:	003f0f06 	br	81123380 <__reset+0xfb103380>
81123744:	d8c03217 	ldw	r3,200(sp)
81123748:	18c00044 	addi	r3,r3,1
8112374c:	d8c02e15 	stw	r3,184(sp)
81123750:	1805883a 	mov	r2,r3
81123754:	183fb20e 	bge	r3,zero,81123620 <__reset+0xfb103620>
81123758:	0005883a 	mov	r2,zero
8112375c:	003fb006 	br	81123620 <__reset+0xfb103620>
81123760:	d9003617 	ldw	r4,216(sp)
81123764:	000d883a 	mov	r6,zero
81123768:	000f883a 	mov	r7,zero
8112376c:	980b883a 	mov	r5,r19
81123770:	d8c03c15 	stw	r3,240(sp)
81123774:	da003d15 	stw	r8,244(sp)
81123778:	11321080 	call	81132108 <__eqdf2>
8112377c:	d8c03c17 	ldw	r3,240(sp)
81123780:	da003d17 	ldw	r8,244(sp)
81123784:	103f9826 	beq	r2,zero,811235e8 <__reset+0xfb1035e8>
81123788:	00800044 	movi	r2,1
8112378c:	10c7c83a 	sub	r3,r2,r3
81123790:	d8c02615 	stw	r3,152(sp)
81123794:	003f9506 	br	811235ec <__reset+0xfb1035ec>
81123798:	d9002917 	ldw	r4,164(sp)
8112379c:	d8c03217 	ldw	r3,200(sp)
811237a0:	20800044 	addi	r2,r4,1
811237a4:	1885883a 	add	r2,r3,r2
811237a8:	d8802e15 	stw	r2,184(sp)
811237ac:	103dbf0e 	bge	r2,zero,81122eac <__reset+0xfb102eac>
811237b0:	0005883a 	mov	r2,zero
811237b4:	003dbd06 	br	81122eac <__reset+0xfb102eac>
811237b8:	2000211e 	bne	r4,zero,81123840 <___vfprintf_internal_r+0x2170>
811237bc:	9480004c 	andi	r18,r18,1
811237c0:	90001f1e 	bne	r18,zero,81123840 <___vfprintf_internal_r+0x2170>
811237c4:	00800044 	movi	r2,1
811237c8:	d8802e15 	stw	r2,184(sp)
811237cc:	003db706 	br	81122eac <__reset+0xfb102eac>
811237d0:	00800b44 	movi	r2,45
811237d4:	05adc83a 	sub	r22,zero,r22
811237d8:	d8802305 	stb	r2,140(sp)
811237dc:	003f3f06 	br	811234dc <__reset+0xfb1034dc>
811237e0:	0005883a 	mov	r2,zero
811237e4:	003f5206 	br	81123530 <__reset+0xfb103530>
811237e8:	90a4703a 	and	r18,r18,r2
811237ec:	903f4e26 	beq	r18,zero,81123528 <__reset+0xfb103528>
811237f0:	003f4a06 	br	8112351c <__reset+0xfb10351c>
811237f4:	00800084 	movi	r2,2
811237f8:	10c5c83a 	sub	r2,r2,r3
811237fc:	003f8406 	br	81123610 <__reset+0xfb103610>
81123800:	d8802d17 	ldw	r2,180(sp)
81123804:	d9002d17 	ldw	r4,180(sp)
81123808:	ac400043 	ldbu	r17,1(r21)
8112380c:	10800017 	ldw	r2,0(r2)
81123810:	582b883a 	mov	r21,r11
81123814:	d8802915 	stw	r2,164(sp)
81123818:	20800104 	addi	r2,r4,4
8112381c:	d9002917 	ldw	r4,164(sp)
81123820:	d8802d15 	stw	r2,180(sp)
81123824:	203e7a0e 	bge	r4,zero,81123210 <__reset+0xfb103210>
81123828:	8c403fcc 	andi	r17,r17,255
8112382c:	00bfffc4 	movi	r2,-1
81123830:	8c40201c 	xori	r17,r17,128
81123834:	d8802915 	stw	r2,164(sp)
81123838:	8c7fe004 	addi	r17,r17,-128
8112383c:	00380706 	br	8112185c <__reset+0xfb10185c>
81123840:	d8c02917 	ldw	r3,164(sp)
81123844:	18c00084 	addi	r3,r3,2
81123848:	d8c02e15 	stw	r3,184(sp)
8112384c:	1805883a 	mov	r2,r3
81123850:	183d960e 	bge	r3,zero,81122eac <__reset+0xfb102eac>
81123854:	003fd606 	br	811237b0 <__reset+0xfb1037b0>
81123858:	0005883a 	mov	r2,zero
8112385c:	003f8e06 	br	81123698 <__reset+0xfb103698>
81123860:	9080004c 	andi	r2,r18,1
81123864:	103f811e 	bne	r2,zero,8112366c <__reset+0xfb10366c>
81123868:	d8802117 	ldw	r2,132(sp)
8112386c:	1405c83a 	sub	r2,r2,r16
81123870:	d8803315 	stw	r2,204(sp)
81123874:	b47ef326 	beq	r22,r17,81123444 <__reset+0xfb103444>
81123878:	dd802617 	ldw	r22,152(sp)
8112387c:	003f1106 	br	811234c4 <__reset+0xfb1034c4>
81123880:	d9c02785 	stb	r7,158(sp)
81123884:	00390406 	br	81121c98 <__reset+0xfb101c98>
81123888:	d9c02785 	stb	r7,158(sp)
8112388c:	0038d306 	br	81121bdc <__reset+0xfb101bdc>
81123890:	d9c02785 	stb	r7,158(sp)
81123894:	003a6106 	br	8112221c <__reset+0xfb10221c>
81123898:	d9c02785 	stb	r7,158(sp)
8112389c:	003af806 	br	81122480 <__reset+0xfb102480>
811238a0:	0005883a 	mov	r2,zero
811238a4:	003d7e06 	br	81122ea0 <__reset+0xfb102ea0>
811238a8:	d8802344 	addi	r2,sp,141
811238ac:	003f1306 	br	811234fc <__reset+0xfb1034fc>
811238b0:	d9c02785 	stb	r7,158(sp)
811238b4:	00392306 	br	81121d44 <__reset+0xfb101d44>
811238b8:	d9c02785 	stb	r7,158(sp)
811238bc:	003aa906 	br	81122364 <__reset+0xfb102364>
811238c0:	d9c02785 	stb	r7,158(sp)
811238c4:	003a3d06 	br	811221bc <__reset+0xfb1021bc>
811238c8:	d9c02785 	stb	r7,158(sp)
811238cc:	003aca06 	br	811223f8 <__reset+0xfb1023f8>

811238d0 <__vfprintf_internal>:
811238d0:	00a04574 	movhi	r2,33045
811238d4:	10bd6304 	addi	r2,r2,-2676
811238d8:	300f883a 	mov	r7,r6
811238dc:	280d883a 	mov	r6,r5
811238e0:	200b883a 	mov	r5,r4
811238e4:	11000017 	ldw	r4,0(r2)
811238e8:	11216d01 	jmpi	811216d0 <___vfprintf_internal_r>

811238ec <__sbprintf>:
811238ec:	defee204 	addi	sp,sp,-1144
811238f0:	de00012e 	bgeu	sp,et,811238f8 <__sbprintf+0xc>
811238f4:	003b68fa 	trap	3
811238f8:	2880030b 	ldhu	r2,12(r5)
811238fc:	2ac01917 	ldw	r11,100(r5)
81123900:	2a80038b 	ldhu	r10,14(r5)
81123904:	2a400717 	ldw	r9,28(r5)
81123908:	2a000917 	ldw	r8,36(r5)
8112390c:	00c10004 	movi	r3,1024
81123910:	dc011a15 	stw	r16,1128(sp)
81123914:	10bfff4c 	andi	r2,r2,65533
81123918:	2821883a 	mov	r16,r5
8112391c:	d8cb883a 	add	r5,sp,r3
81123920:	dc811c15 	stw	r18,1136(sp)
81123924:	dc411b15 	stw	r17,1132(sp)
81123928:	dfc11d15 	stw	ra,1140(sp)
8112392c:	2025883a 	mov	r18,r4
81123930:	d881030d 	sth	r2,1036(sp)
81123934:	dac11915 	stw	r11,1124(sp)
81123938:	da81038d 	sth	r10,1038(sp)
8112393c:	da410715 	stw	r9,1052(sp)
81123940:	da010915 	stw	r8,1060(sp)
81123944:	dec10015 	stw	sp,1024(sp)
81123948:	dec10415 	stw	sp,1040(sp)
8112394c:	d8c10215 	stw	r3,1032(sp)
81123950:	d8c10515 	stw	r3,1044(sp)
81123954:	d8010615 	stw	zero,1048(sp)
81123958:	11216d00 	call	811216d0 <___vfprintf_internal_r>
8112395c:	1023883a 	mov	r17,r2
81123960:	10000416 	blt	r2,zero,81123974 <__sbprintf+0x88>
81123964:	d9410004 	addi	r5,sp,1024
81123968:	9009883a 	mov	r4,r18
8112396c:	11270900 	call	81127090 <_fflush_r>
81123970:	10000d1e 	bne	r2,zero,811239a8 <__sbprintf+0xbc>
81123974:	d881030b 	ldhu	r2,1036(sp)
81123978:	1080100c 	andi	r2,r2,64
8112397c:	10000326 	beq	r2,zero,8112398c <__sbprintf+0xa0>
81123980:	8080030b 	ldhu	r2,12(r16)
81123984:	10801014 	ori	r2,r2,64
81123988:	8080030d 	sth	r2,12(r16)
8112398c:	8805883a 	mov	r2,r17
81123990:	dfc11d17 	ldw	ra,1140(sp)
81123994:	dc811c17 	ldw	r18,1136(sp)
81123998:	dc411b17 	ldw	r17,1132(sp)
8112399c:	dc011a17 	ldw	r16,1128(sp)
811239a0:	dec11e04 	addi	sp,sp,1144
811239a4:	f800283a 	ret
811239a8:	047fffc4 	movi	r17,-1
811239ac:	003ff106 	br	81123974 <__reset+0xfb103974>

811239b0 <__svfscanf_r>:
811239b0:	deff4b04 	addi	sp,sp,-724
811239b4:	de00012e 	bgeu	sp,et,811239bc <__svfscanf_r+0xc>
811239b8:	003b68fa 	trap	3
811239bc:	2880030b 	ldhu	r2,12(r5)
811239c0:	df00b315 	stw	fp,716(sp)
811239c4:	dd80b115 	stw	r22,708(sp)
811239c8:	dfc0b415 	stw	ra,720(sp)
811239cc:	ddc0b215 	stw	r23,712(sp)
811239d0:	dd40b015 	stw	r21,704(sp)
811239d4:	dd00af15 	stw	r20,700(sp)
811239d8:	dcc0ae15 	stw	r19,696(sp)
811239dc:	dc80ad15 	stw	r18,692(sp)
811239e0:	dc40ac15 	stw	r17,688(sp)
811239e4:	dc00ab15 	stw	r16,684(sp)
811239e8:	10c8000c 	andi	r3,r2,8192
811239ec:	d9c09c15 	stw	r7,624(sp)
811239f0:	2839883a 	mov	fp,r5
811239f4:	202d883a 	mov	r22,r4
811239f8:	1800061e 	bne	r3,zero,81123a14 <__svfscanf_r+0x64>
811239fc:	29001917 	ldw	r4,100(r5)
81123a00:	00f7ffc4 	movi	r3,-8193
81123a04:	10880014 	ori	r2,r2,8192
81123a08:	20c6703a 	and	r3,r4,r3
81123a0c:	2880030d 	sth	r2,12(r5)
81123a10:	28c01915 	stw	r3,100(r5)
81123a14:	30800003 	ldbu	r2,0(r6)
81123a18:	0021883a 	mov	r16,zero
81123a1c:	05e04574 	movhi	r23,33045
81123a20:	d800a115 	stw	zero,644(sp)
81123a24:	d8009e15 	stw	zero,632(sp)
81123a28:	d800a015 	stw	zero,640(sp)
81123a2c:	d8809b15 	stw	r2,620(sp)
81123a30:	bdfd6104 	addi	r23,r23,-2684
81123a34:	8025883a 	mov	r18,r16
81123a38:	35000044 	addi	r20,r6,1
81123a3c:	10001e26 	beq	r2,zero,81123ab8 <__svfscanf_r+0x108>
81123a40:	b9c00017 	ldw	r7,0(r23)
81123a44:	3887883a 	add	r3,r7,r2
81123a48:	18c00043 	ldbu	r3,1(r3)
81123a4c:	18c0020c 	andi	r3,r3,8
81123a50:	18001b26 	beq	r3,zero,81123ac0 <__svfscanf_r+0x110>
81123a54:	e0800117 	ldw	r2,4(fp)
81123a58:	00800e0e 	bge	zero,r2,81123a94 <__svfscanf_r+0xe4>
81123a5c:	e0c00017 	ldw	r3,0(fp)
81123a60:	b9000017 	ldw	r4,0(r23)
81123a64:	18800003 	ldbu	r2,0(r3)
81123a68:	2085883a 	add	r2,r4,r2
81123a6c:	10800043 	ldbu	r2,1(r2)
81123a70:	1080020c 	andi	r2,r2,8
81123a74:	10000b26 	beq	r2,zero,81123aa4 <__svfscanf_r+0xf4>
81123a78:	e0800117 	ldw	r2,4(fp)
81123a7c:	18c00044 	addi	r3,r3,1
81123a80:	e0c00015 	stw	r3,0(fp)
81123a84:	10bfffc4 	addi	r2,r2,-1
81123a88:	e0800115 	stw	r2,4(fp)
81123a8c:	94800044 	addi	r18,r18,1
81123a90:	00bff216 	blt	zero,r2,81123a5c <__reset+0xfb103a5c>
81123a94:	e00b883a 	mov	r5,fp
81123a98:	b009883a 	mov	r4,r22
81123a9c:	111ec900 	call	8111ec90 <__srefill_r>
81123aa0:	103fee26 	beq	r2,zero,81123a5c <__reset+0xfb103a5c>
81123aa4:	a00d883a 	mov	r6,r20
81123aa8:	30800003 	ldbu	r2,0(r6)
81123aac:	35000044 	addi	r20,r6,1
81123ab0:	d8809b15 	stw	r2,620(sp)
81123ab4:	103fe21e 	bne	r2,zero,81123a40 <__reset+0xfb103a40>
81123ab8:	d880a017 	ldw	r2,640(sp)
81123abc:	00009906 	br	81123d24 <__svfscanf_r+0x374>
81123ac0:	00c00944 	movi	r3,37
81123ac4:	10c0881e 	bne	r2,r3,81123ce8 <__svfscanf_r+0x338>
81123ac8:	30c00043 	ldbu	r3,1(r6)
81123acc:	0023883a 	mov	r17,zero
81123ad0:	0027883a 	mov	r19,zero
81123ad4:	01001e04 	movi	r4,120
81123ad8:	01401b04 	movi	r5,108
81123adc:	a1800044 	addi	r6,r20,1
81123ae0:	20c0a236 	bltu	r4,r3,81123d6c <__svfscanf_r+0x3bc>
81123ae4:	180490ba 	slli	r2,r3,2
81123ae8:	022044b4 	movhi	r8,33042
81123aec:	420ebf04 	addi	r8,r8,15100
81123af0:	1205883a 	add	r2,r2,r8
81123af4:	10800017 	ldw	r2,0(r2)
81123af8:	1000683a 	jmp	r2
81123afc:	81123d20 	cmpeqi	r4,r16,18676
81123b00:	81123d6c 	andhi	r4,r16,18677
81123b04:	81123d6c 	andhi	r4,r16,18677
81123b08:	81123d6c 	andhi	r4,r16,18677
81123b0c:	81123d6c 	andhi	r4,r16,18677
81123b10:	81123d6c 	andhi	r4,r16,18677
81123b14:	81123d6c 	andhi	r4,r16,18677
81123b18:	81123d6c 	andhi	r4,r16,18677
81123b1c:	81123d6c 	andhi	r4,r16,18677
81123b20:	81123d6c 	andhi	r4,r16,18677
81123b24:	81123d6c 	andhi	r4,r16,18677
81123b28:	81123d6c 	andhi	r4,r16,18677
81123b2c:	81123d6c 	andhi	r4,r16,18677
81123b30:	81123d6c 	andhi	r4,r16,18677
81123b34:	81123d6c 	andhi	r4,r16,18677
81123b38:	81123d6c 	andhi	r4,r16,18677
81123b3c:	81123d6c 	andhi	r4,r16,18677
81123b40:	81123d6c 	andhi	r4,r16,18677
81123b44:	81123d6c 	andhi	r4,r16,18677
81123b48:	81123d6c 	andhi	r4,r16,18677
81123b4c:	81123d6c 	andhi	r4,r16,18677
81123b50:	81123d6c 	andhi	r4,r16,18677
81123b54:	81123d6c 	andhi	r4,r16,18677
81123b58:	81123d6c 	andhi	r4,r16,18677
81123b5c:	81123d6c 	andhi	r4,r16,18677
81123b60:	81123d6c 	andhi	r4,r16,18677
81123b64:	81123d6c 	andhi	r4,r16,18677
81123b68:	81123d6c 	andhi	r4,r16,18677
81123b6c:	81123d6c 	andhi	r4,r16,18677
81123b70:	81123d6c 	andhi	r4,r16,18677
81123b74:	81123d6c 	andhi	r4,r16,18677
81123b78:	81123d6c 	andhi	r4,r16,18677
81123b7c:	81123d6c 	andhi	r4,r16,18677
81123b80:	81123d6c 	andhi	r4,r16,18677
81123b84:	81123d6c 	andhi	r4,r16,18677
81123b88:	81123d6c 	andhi	r4,r16,18677
81123b8c:	81123d6c 	andhi	r4,r16,18677
81123b90:	81123ce0 	cmpeqi	r4,r16,18675
81123b94:	81123d6c 	andhi	r4,r16,18677
81123b98:	81123d6c 	andhi	r4,r16,18677
81123b9c:	81123d6c 	andhi	r4,r16,18677
81123ba0:	81123d6c 	andhi	r4,r16,18677
81123ba4:	81123d54 	ori	r4,r16,18677
81123ba8:	81123d6c 	andhi	r4,r16,18677
81123bac:	81123d6c 	andhi	r4,r16,18677
81123bb0:	81123d6c 	andhi	r4,r16,18677
81123bb4:	81123d6c 	andhi	r4,r16,18677
81123bb8:	81123d6c 	andhi	r4,r16,18677
81123bbc:	81123e88 	cmpgei	r4,r16,18682
81123bc0:	81123e88 	cmpgei	r4,r16,18682
81123bc4:	81123e88 	cmpgei	r4,r16,18682
81123bc8:	81123e88 	cmpgei	r4,r16,18682
81123bcc:	81123e88 	cmpgei	r4,r16,18682
81123bd0:	81123e88 	cmpgei	r4,r16,18682
81123bd4:	81123e88 	cmpgei	r4,r16,18682
81123bd8:	81123e88 	cmpgei	r4,r16,18682
81123bdc:	81123e88 	cmpgei	r4,r16,18682
81123be0:	81123e88 	cmpgei	r4,r16,18682
81123be4:	81123d6c 	andhi	r4,r16,18677
81123be8:	81123d6c 	andhi	r4,r16,18677
81123bec:	81123d6c 	andhi	r4,r16,18677
81123bf0:	81123d6c 	andhi	r4,r16,18677
81123bf4:	81123d6c 	andhi	r4,r16,18677
81123bf8:	81123d6c 	andhi	r4,r16,18677
81123bfc:	81123d6c 	andhi	r4,r16,18677
81123c00:	81123d6c 	andhi	r4,r16,18677
81123c04:	81123d6c 	andhi	r4,r16,18677
81123c08:	81123d6c 	andhi	r4,r16,18677
81123c0c:	81123e5c 	xori	r4,r16,18681
81123c10:	81123f0c 	andi	r4,r16,18684
81123c14:	81123d6c 	andhi	r4,r16,18677
81123c18:	81123f0c 	andi	r4,r16,18684
81123c1c:	81123d6c 	andhi	r4,r16,18677
81123c20:	81123d6c 	andhi	r4,r16,18677
81123c24:	81123d6c 	andhi	r4,r16,18677
81123c28:	81123d6c 	andhi	r4,r16,18677
81123c2c:	81123ef8 	rdprs	r4,r16,18683
81123c30:	81123d6c 	andhi	r4,r16,18677
81123c34:	81123d6c 	andhi	r4,r16,18677
81123c38:	81123ecc 	andi	r4,r16,18683
81123c3c:	81123d6c 	andhi	r4,r16,18677
81123c40:	81123d6c 	andhi	r4,r16,18677
81123c44:	81123d6c 	andhi	r4,r16,18677
81123c48:	81123d6c 	andhi	r4,r16,18677
81123c4c:	81123d6c 	andhi	r4,r16,18677
81123c50:	81123d6c 	andhi	r4,r16,18677
81123c54:	81123d6c 	andhi	r4,r16,18677
81123c58:	81123d6c 	andhi	r4,r16,18677
81123c5c:	81123ea4 	muli	r4,r16,18682
81123c60:	81123d6c 	andhi	r4,r16,18677
81123c64:	81123d6c 	andhi	r4,r16,18677
81123c68:	81124040 	call	88112404 <__reset+0x20f2404>
81123c6c:	81123d6c 	andhi	r4,r16,18677
81123c70:	81123d6c 	andhi	r4,r16,18677
81123c74:	81123d6c 	andhi	r4,r16,18677
81123c78:	81123d6c 	andhi	r4,r16,18677
81123c7c:	81123d6c 	andhi	r4,r16,18677
81123c80:	81123d6c 	andhi	r4,r16,18677
81123c84:	81123d6c 	andhi	r4,r16,18677
81123c88:	81123fc4 	addi	r4,r16,18687
81123c8c:	81123f9c 	xori	r4,r16,18686
81123c90:	81123f0c 	andi	r4,r16,18684
81123c94:	81123f0c 	andi	r4,r16,18684
81123c98:	81123f0c 	andi	r4,r16,18684
81123c9c:	81123f88 	cmpgei	r4,r16,18686
81123ca0:	811240cc 	andi	r4,r16,18691
81123ca4:	81123d6c 	andhi	r4,r16,18677
81123ca8:	81123d6c 	andhi	r4,r16,18677
81123cac:	81123f74 	orhi	r4,r16,18685
81123cb0:	81123d6c 	andhi	r4,r16,18677
81123cb4:	81123f44 	addi	r4,r16,18685
81123cb8:	81123f20 	cmpeqi	r4,r16,18684
81123cbc:	81123e30 	cmpltui	r4,r16,18680
81123cc0:	81123d6c 	andhi	r4,r16,18677
81123cc4:	81123d6c 	andhi	r4,r16,18677
81123cc8:	81123e1c 	xori	r4,r16,18680
81123ccc:	81123d6c 	andhi	r4,r16,18677
81123cd0:	81123da4 	muli	r4,r16,18678
81123cd4:	81123d6c 	andhi	r4,r16,18677
81123cd8:	81123d6c 	andhi	r4,r16,18677
81123cdc:	81123ea4 	muli	r4,r16,18682
81123ce0:	d9809d15 	stw	r6,628(sp)
81123ce4:	3029883a 	mov	r20,r6
81123ce8:	e0800117 	ldw	r2,4(fp)
81123cec:	0081aa0e 	bge	zero,r2,81124398 <__svfscanf_r+0x9e8>
81123cf0:	e0800017 	ldw	r2,0(fp)
81123cf4:	a0ffffc3 	ldbu	r3,-1(r20)
81123cf8:	11000003 	ldbu	r4,0(r2)
81123cfc:	20ff6e1e 	bne	r4,r3,81123ab8 <__reset+0xfb103ab8>
81123d00:	e0c00117 	ldw	r3,4(fp)
81123d04:	10800044 	addi	r2,r2,1
81123d08:	e0800015 	stw	r2,0(fp)
81123d0c:	18bfffc4 	addi	r2,r3,-1
81123d10:	e0800115 	stw	r2,4(fp)
81123d14:	94800044 	addi	r18,r18,1
81123d18:	a00d883a 	mov	r6,r20
81123d1c:	003f6206 	br	81123aa8 <__reset+0xfb103aa8>
81123d20:	00bfffc4 	movi	r2,-1
81123d24:	dfc0b417 	ldw	ra,720(sp)
81123d28:	df00b317 	ldw	fp,716(sp)
81123d2c:	ddc0b217 	ldw	r23,712(sp)
81123d30:	dd80b117 	ldw	r22,708(sp)
81123d34:	dd40b017 	ldw	r21,704(sp)
81123d38:	dd00af17 	ldw	r20,700(sp)
81123d3c:	dcc0ae17 	ldw	r19,696(sp)
81123d40:	dc80ad17 	ldw	r18,692(sp)
81123d44:	dc40ac17 	ldw	r17,688(sp)
81123d48:	dc00ab17 	ldw	r16,684(sp)
81123d4c:	dec0b504 	addi	sp,sp,724
81123d50:	f800283a 	ret
81123d54:	a0800043 	ldbu	r2,1(r20)
81123d58:	3029883a 	mov	r20,r6
81123d5c:	8c400414 	ori	r17,r17,16
81123d60:	10c03fcc 	andi	r3,r2,255
81123d64:	a1800044 	addi	r6,r20,1
81123d68:	20ff5e2e 	bgeu	r4,r3,81123ae4 <__reset+0xfb103ae4>
81123d6c:	38c7883a 	add	r3,r7,r3
81123d70:	18800043 	ldbu	r2,1(r3)
81123d74:	d9809d15 	stw	r6,628(sp)
81123d78:	00c00044 	movi	r3,1
81123d7c:	108000cc 	andi	r2,r2,3
81123d80:	10c18f26 	beq	r2,r3,811243c0 <__svfscanf_r+0xa10>
81123d84:	e0800117 	ldw	r2,4(fp)
81123d88:	00808716 	blt	zero,r2,81123fa8 <__svfscanf_r+0x5f8>
81123d8c:	e00b883a 	mov	r5,fp
81123d90:	b009883a 	mov	r4,r22
81123d94:	111ec900 	call	8111ec90 <__srefill_r>
81123d98:	1001431e 	bne	r2,zero,811242a8 <__svfscanf_r+0x8f8>
81123d9c:	b9c00017 	ldw	r7,0(r23)
81123da0:	00008106 	br	81123fa8 <__svfscanf_r+0x5f8>
81123da4:	e0800117 	ldw	r2,4(fp)
81123da8:	d9809d15 	stw	r6,628(sp)
81123dac:	0081a30e 	bge	zero,r2,8112443c <__svfscanf_r+0xa8c>
81123db0:	00a044f4 	movhi	r2,33043
81123db4:	10aef004 	addi	r2,r2,-17472
81123db8:	02000284 	movi	r8,10
81123dbc:	d880a115 	stw	r2,644(sp)
81123dc0:	da009e15 	stw	r8,632(sp)
81123dc4:	050000c4 	movi	r20,3
81123dc8:	e0c00017 	ldw	r3,0(fp)
81123dcc:	00000206 	br	81123dd8 <__svfscanf_r+0x428>
81123dd0:	18c00044 	addi	r3,r3,1
81123dd4:	e0c00015 	stw	r3,0(fp)
81123dd8:	19000003 	ldbu	r4,0(r3)
81123ddc:	20803fcc 	andi	r2,r4,255
81123de0:	3885883a 	add	r2,r7,r2
81123de4:	10800043 	ldbu	r2,1(r2)
81123de8:	1140020c 	andi	r5,r2,8
81123dec:	2801ab26 	beq	r5,zero,8112449c <__svfscanf_r+0xaec>
81123df0:	e0800117 	ldw	r2,4(fp)
81123df4:	94800044 	addi	r18,r18,1
81123df8:	10bfffc4 	addi	r2,r2,-1
81123dfc:	e0800115 	stw	r2,4(fp)
81123e00:	00bff316 	blt	zero,r2,81123dd0 <__reset+0xfb103dd0>
81123e04:	e00b883a 	mov	r5,fp
81123e08:	b009883a 	mov	r4,r22
81123e0c:	111ec900 	call	8111ec90 <__srefill_r>
81123e10:	1001251e 	bne	r2,zero,811242a8 <__svfscanf_r+0x8f8>
81123e14:	b9c00017 	ldw	r7,0(r23)
81123e18:	003feb06 	br	81123dc8 <__reset+0xfb103dc8>
81123e1c:	e0800117 	ldw	r2,4(fp)
81123e20:	d9809d15 	stw	r6,628(sp)
81123e24:	00818b0e 	bge	zero,r2,81124454 <__svfscanf_r+0xaa4>
81123e28:	05000084 	movi	r20,2
81123e2c:	003fe606 	br	81123dc8 <__reset+0xfb103dc8>
81123e30:	e0800117 	ldw	r2,4(fp)
81123e34:	d9809d15 	stw	r6,628(sp)
81123e38:	8c408814 	ori	r17,r17,544
81123e3c:	00801d0e 	bge	zero,r2,81123eb4 <__svfscanf_r+0x504>
81123e40:	00a044f4 	movhi	r2,33043
81123e44:	10aef004 	addi	r2,r2,-17472
81123e48:	02000404 	movi	r8,16
81123e4c:	d880a115 	stw	r2,644(sp)
81123e50:	da009e15 	stw	r8,632(sp)
81123e54:	050000c4 	movi	r20,3
81123e58:	003fdb06 	br	81123dc8 <__reset+0xfb103dc8>
81123e5c:	e0800117 	ldw	r2,4(fp)
81123e60:	d9809d15 	stw	r6,628(sp)
81123e64:	8c400054 	ori	r17,r17,1
81123e68:	00bfc80e 	bge	zero,r2,81123d8c <__reset+0xfb103d8c>
81123e6c:	00e044b4 	movhi	r3,33042
81123e70:	18fca504 	addi	r3,r3,-3436
81123e74:	02000284 	movi	r8,10
81123e78:	d8c0a115 	stw	r3,644(sp)
81123e7c:	da009e15 	stw	r8,632(sp)
81123e80:	050000c4 	movi	r20,3
81123e84:	003fd006 	br	81123dc8 <__reset+0xfb103dc8>
81123e88:	9cc002a4 	muli	r19,r19,10
81123e8c:	a0800043 	ldbu	r2,1(r20)
81123e90:	3029883a 	mov	r20,r6
81123e94:	98e7883a 	add	r19,r19,r3
81123e98:	9cfff404 	addi	r19,r19,-48
81123e9c:	10c03fcc 	andi	r3,r2,255
81123ea0:	003f0e06 	br	81123adc <__reset+0xfb103adc>
81123ea4:	e0800117 	ldw	r2,4(fp)
81123ea8:	d9809d15 	stw	r6,628(sp)
81123eac:	8c408014 	ori	r17,r17,512
81123eb0:	00bfe316 	blt	zero,r2,81123e40 <__reset+0xfb103e40>
81123eb4:	e00b883a 	mov	r5,fp
81123eb8:	b009883a 	mov	r4,r22
81123ebc:	111ec900 	call	8111ec90 <__srefill_r>
81123ec0:	1000f91e 	bne	r2,zero,811242a8 <__svfscanf_r+0x8f8>
81123ec4:	b9c00017 	ldw	r7,0(r23)
81123ec8:	003fdd06 	br	81123e40 <__reset+0xfb103e40>
81123ecc:	e0800117 	ldw	r2,4(fp)
81123ed0:	d9809d15 	stw	r6,628(sp)
81123ed4:	8c400054 	ori	r17,r17,1
81123ed8:	0080140e 	bge	zero,r2,81123f2c <__svfscanf_r+0x57c>
81123edc:	00a044f4 	movhi	r2,33043
81123ee0:	10aef004 	addi	r2,r2,-17472
81123ee4:	02000204 	movi	r8,8
81123ee8:	d880a115 	stw	r2,644(sp)
81123eec:	da009e15 	stw	r8,632(sp)
81123ef0:	050000c4 	movi	r20,3
81123ef4:	003fb406 	br	81123dc8 <__reset+0xfb103dc8>
81123ef8:	a0800043 	ldbu	r2,1(r20)
81123efc:	8c400094 	ori	r17,r17,2
81123f00:	3029883a 	mov	r20,r6
81123f04:	10c03fcc 	andi	r3,r2,255
81123f08:	003ef406 	br	81123adc <__reset+0xfb103adc>
81123f0c:	e0800117 	ldw	r2,4(fp)
81123f10:	d9809d15 	stw	r6,628(sp)
81123f14:	0081420e 	bge	zero,r2,81124420 <__svfscanf_r+0xa70>
81123f18:	05000104 	movi	r20,4
81123f1c:	003faa06 	br	81123dc8 <__reset+0xfb103dc8>
81123f20:	e0800117 	ldw	r2,4(fp)
81123f24:	d9809d15 	stw	r6,628(sp)
81123f28:	00bfec16 	blt	zero,r2,81123edc <__reset+0xfb103edc>
81123f2c:	e00b883a 	mov	r5,fp
81123f30:	b009883a 	mov	r4,r22
81123f34:	111ec900 	call	8111ec90 <__srefill_r>
81123f38:	1000db1e 	bne	r2,zero,811242a8 <__svfscanf_r+0x8f8>
81123f3c:	b9c00017 	ldw	r7,0(r23)
81123f40:	003fe606 	br	81123edc <__reset+0xfb103edc>
81123f44:	d9809d15 	stw	r6,628(sp)
81123f48:	8880040c 	andi	r2,r17,16
81123f4c:	10009c1e 	bne	r2,zero,811241c0 <__svfscanf_r+0x810>
81123f50:	8880010c 	andi	r2,r17,4
81123f54:	10011e26 	beq	r2,zero,811243d0 <__svfscanf_r+0xa20>
81123f58:	da009c17 	ldw	r8,624(sp)
81123f5c:	3029883a 	mov	r20,r6
81123f60:	40800017 	ldw	r2,0(r8)
81123f64:	42000104 	addi	r8,r8,4
81123f68:	da009c15 	stw	r8,624(sp)
81123f6c:	1480000d 	sth	r18,0(r2)
81123f70:	003ecc06 	br	81123aa4 <__reset+0xfb103aa4>
81123f74:	a0c00043 	ldbu	r3,1(r20)
81123f78:	19410c26 	beq	r3,r5,811243ac <__svfscanf_r+0x9fc>
81123f7c:	8c400054 	ori	r17,r17,1
81123f80:	3029883a 	mov	r20,r6
81123f84:	003ed506 	br	81123adc <__reset+0xfb103adc>
81123f88:	a0800043 	ldbu	r2,1(r20)
81123f8c:	8c400114 	ori	r17,r17,4
81123f90:	3029883a 	mov	r20,r6
81123f94:	10c03fcc 	andi	r3,r2,255
81123f98:	003ed006 	br	81123adc <__reset+0xfb103adc>
81123f9c:	e0800117 	ldw	r2,4(fp)
81123fa0:	d9809d15 	stw	r6,628(sp)
81123fa4:	00bf790e 	bge	zero,r2,81123d8c <__reset+0xfb103d8c>
81123fa8:	00a044b4 	movhi	r2,33042
81123fac:	10bca504 	addi	r2,r2,-3436
81123fb0:	02000284 	movi	r8,10
81123fb4:	d880a115 	stw	r2,644(sp)
81123fb8:	da009e15 	stw	r8,632(sp)
81123fbc:	050000c4 	movi	r20,3
81123fc0:	003f8106 	br	81123dc8 <__reset+0xfb103dc8>
81123fc4:	e0800117 	ldw	r2,4(fp)
81123fc8:	d9809d15 	stw	r6,628(sp)
81123fcc:	0080c40e 	bge	zero,r2,811242e0 <__svfscanf_r+0x930>
81123fd0:	9800011e 	bne	r19,zero,81123fd8 <__svfscanf_r+0x628>
81123fd4:	04c00044 	movi	r19,1
81123fd8:	8880004c 	andi	r2,r17,1
81123fdc:	1000441e 	bne	r2,zero,811240f0 <__svfscanf_r+0x740>
81123fe0:	8c40040c 	andi	r17,r17,16
81123fe4:	8800da26 	beq	r17,zero,81124350 <__svfscanf_r+0x9a0>
81123fe8:	0021883a 	mov	r16,zero
81123fec:	00000806 	br	81124010 <__svfscanf_r+0x660>
81123ff0:	1887883a 	add	r3,r3,r2
81123ff4:	e00b883a 	mov	r5,fp
81123ff8:	b009883a 	mov	r4,r22
81123ffc:	e0c00015 	stw	r3,0(fp)
81124000:	80a1883a 	add	r16,r16,r2
81124004:	98a7c83a 	sub	r19,r19,r2
81124008:	111ec900 	call	8111ec90 <__srefill_r>
8112400c:	1000ca1e 	bne	r2,zero,81124338 <__svfscanf_r+0x988>
81124010:	e0800117 	ldw	r2,4(fp)
81124014:	e0c00017 	ldw	r3,0(fp)
81124018:	14fff516 	blt	r2,r19,81123ff0 <__reset+0xfb103ff0>
8112401c:	14c5c83a 	sub	r2,r2,r19
81124020:	1cd5883a 	add	r10,r3,r19
81124024:	84e1883a 	add	r16,r16,r19
81124028:	e0800115 	stw	r2,4(fp)
8112402c:	e2800015 	stw	r10,0(fp)
81124030:	dd009d17 	ldw	r20,628(sp)
81124034:	9425883a 	add	r18,r18,r16
81124038:	a00d883a 	mov	r6,r20
8112403c:	003e9a06 	br	81123aa8 <__reset+0xfb103aa8>
81124040:	300b883a 	mov	r5,r6
81124044:	d9005884 	addi	r4,sp,354
81124048:	d9809d15 	stw	r6,628(sp)
8112404c:	1129f980 	call	81129f98 <__sccl>
81124050:	1029883a 	mov	r20,r2
81124054:	e0800117 	ldw	r2,4(fp)
81124058:	0081050e 	bge	zero,r2,81124470 <__svfscanf_r+0xac0>
8112405c:	e1000017 	ldw	r4,0(fp)
81124060:	20800003 	ldbu	r2,0(r4)
81124064:	98005926 	beq	r19,zero,811241cc <__svfscanf_r+0x81c>
81124068:	8c40040c 	andi	r17,r17,16
8112406c:	88005a26 	beq	r17,zero,811241d8 <__svfscanf_r+0x828>
81124070:	9823883a 	mov	r17,r19
81124074:	0021883a 	mov	r16,zero
81124078:	00000106 	br	81124080 <__svfscanf_r+0x6d0>
8112407c:	20800003 	ldbu	r2,0(r4)
81124080:	10803fcc 	andi	r2,r2,255
81124084:	d8c05884 	addi	r3,sp,354
81124088:	1885883a 	add	r2,r3,r2
8112408c:	10800007 	ldb	r2,0(r2)
81124090:	1000ad26 	beq	r2,zero,81124348 <__svfscanf_r+0x998>
81124094:	e0800117 	ldw	r2,4(fp)
81124098:	21000044 	addi	r4,r4,1
8112409c:	84000044 	addi	r16,r16,1
811240a0:	10bfffc4 	addi	r2,r2,-1
811240a4:	e0800115 	stw	r2,4(fp)
811240a8:	e1000015 	stw	r4,0(fp)
811240ac:	84c0a026 	beq	r16,r19,81124330 <__svfscanf_r+0x980>
811240b0:	00bff216 	blt	zero,r2,8112407c <__reset+0xfb10407c>
811240b4:	e00b883a 	mov	r5,fp
811240b8:	b009883a 	mov	r4,r22
811240bc:	111ec900 	call	8111ec90 <__srefill_r>
811240c0:	10009a1e 	bne	r2,zero,8112432c <__svfscanf_r+0x97c>
811240c4:	e1000017 	ldw	r4,0(fp)
811240c8:	003fec06 	br	8112407c <__reset+0xfb10407c>
811240cc:	e0800117 	ldw	r2,4(fp)
811240d0:	d9809d15 	stw	r6,628(sp)
811240d4:	0080eb0e 	bge	zero,r2,81124484 <__svfscanf_r+0xad4>
811240d8:	00a044b4 	movhi	r2,33042
811240dc:	10bca504 	addi	r2,r2,-3436
811240e0:	d880a115 	stw	r2,644(sp)
811240e4:	d8009e15 	stw	zero,632(sp)
811240e8:	050000c4 	movi	r20,3
811240ec:	003f3606 	br	81123dc8 <__reset+0xfb103dc8>
811240f0:	dd409904 	addi	r21,sp,612
811240f4:	8c40040c 	andi	r17,r17,16
811240f8:	01800204 	movi	r6,8
811240fc:	000b883a 	mov	r5,zero
81124100:	a809883a 	mov	r4,r21
81124104:	dc409f15 	stw	r17,636(sp)
81124108:	111e8140 	call	8111e814 <memset>
8112410c:	dc409f17 	ldw	r17,636(sp)
81124110:	88006e26 	beq	r17,zero,811242cc <__svfscanf_r+0x91c>
81124114:	0029883a 	mov	r20,zero
81124118:	0023883a 	mov	r17,zero
8112411c:	11283b40 	call	811283b4 <__locale_mb_cur_max>
81124120:	14406126 	beq	r2,r17,811242a8 <__svfscanf_r+0x8f8>
81124124:	e0800017 	ldw	r2,0(fp)
81124128:	e0c00117 	ldw	r3,4(fp)
8112412c:	d9000104 	addi	r4,sp,4
81124130:	12000003 	ldbu	r8,0(r2)
81124134:	18ffffc4 	addi	r3,r3,-1
81124138:	10800044 	addi	r2,r2,1
8112413c:	e0c00115 	stw	r3,4(fp)
81124140:	e0800015 	stw	r2,0(fp)
81124144:	8c000044 	addi	r16,r17,1
81124148:	dd400015 	stw	r21,0(sp)
8112414c:	2463883a 	add	r17,r4,r17
81124150:	200d883a 	mov	r6,r4
81124154:	a00b883a 	mov	r5,r20
81124158:	800f883a 	mov	r7,r16
8112415c:	b009883a 	mov	r4,r22
81124160:	8a000005 	stb	r8,0(r17)
81124164:	11284700 	call	81128470 <_mbrtowc_r>
81124168:	017fffc4 	movi	r5,-1
8112416c:	11404e26 	beq	r2,r5,811242a8 <__svfscanf_r+0x8f8>
81124170:	1000601e 	bne	r2,zero,811242f4 <__svfscanf_r+0x944>
81124174:	da009f17 	ldw	r8,636(sp)
81124178:	4000641e 	bne	r8,zero,8112430c <__svfscanf_r+0x95c>
8112417c:	a0000015 	stw	zero,0(r20)
81124180:	9425883a 	add	r18,r18,r16
81124184:	9967883a 	add	r19,r19,r5
81124188:	a5000104 	addi	r20,r20,4
8112418c:	e0800117 	ldw	r2,4(fp)
81124190:	0023883a 	mov	r17,zero
81124194:	00804b16 	blt	zero,r2,811242c4 <__svfscanf_r+0x914>
81124198:	e00b883a 	mov	r5,fp
8112419c:	b009883a 	mov	r4,r22
811241a0:	111ec900 	call	8111ec90 <__srefill_r>
811241a4:	10004726 	beq	r2,zero,811242c4 <__svfscanf_r+0x914>
811241a8:	88003f1e 	bne	r17,zero,811242a8 <__svfscanf_r+0x8f8>
811241ac:	d8c09f17 	ldw	r3,636(sp)
811241b0:	1800031e 	bne	r3,zero,811241c0 <__svfscanf_r+0x810>
811241b4:	da00a017 	ldw	r8,640(sp)
811241b8:	42000044 	addi	r8,r8,1
811241bc:	da00a015 	stw	r8,640(sp)
811241c0:	dd009d17 	ldw	r20,628(sp)
811241c4:	a00d883a 	mov	r6,r20
811241c8:	003e3706 	br	81123aa8 <__reset+0xfb103aa8>
811241cc:	8c40040c 	andi	r17,r17,16
811241d0:	04ffffc4 	movi	r19,-1
811241d4:	883fa61e 	bne	r17,zero,81124070 <__reset+0xfb104070>
811241d8:	da009c17 	ldw	r8,624(sp)
811241dc:	9abfffc4 	addi	r10,r19,-1
811241e0:	44000017 	ldw	r16,0(r8)
811241e4:	44400104 	addi	r17,r8,4
811241e8:	8007883a 	mov	r3,r16
811241ec:	82ab883a 	add	r21,r16,r10
811241f0:	00000306 	br	81124200 <__svfscanf_r+0x850>
811241f4:	e1000017 	ldw	r4,0(fp)
811241f8:	9807883a 	mov	r3,r19
811241fc:	20800003 	ldbu	r2,0(r4)
81124200:	10803fcc 	andi	r2,r2,255
81124204:	d9405884 	addi	r5,sp,354
81124208:	2885883a 	add	r2,r5,r2
8112420c:	10800007 	ldb	r2,0(r2)
81124210:	10004b26 	beq	r2,zero,81124340 <__svfscanf_r+0x990>
81124214:	e0800117 	ldw	r2,4(fp)
81124218:	21400044 	addi	r5,r4,1
8112421c:	e1400015 	stw	r5,0(fp)
81124220:	10bfffc4 	addi	r2,r2,-1
81124224:	e0800115 	stw	r2,4(fp)
81124228:	20800003 	ldbu	r2,0(r4)
8112422c:	1cc00044 	addi	r19,r3,1
81124230:	18800005 	stb	r2,0(r3)
81124234:	1d400726 	beq	r3,r21,81124254 <__svfscanf_r+0x8a4>
81124238:	e0800117 	ldw	r2,4(fp)
8112423c:	00bfed16 	blt	zero,r2,811241f4 <__reset+0xfb1041f4>
81124240:	e00b883a 	mov	r5,fp
81124244:	b009883a 	mov	r4,r22
81124248:	111ec900 	call	8111ec90 <__srefill_r>
8112424c:	103fe926 	beq	r2,zero,811241f4 <__reset+0xfb1041f4>
81124250:	84c01526 	beq	r16,r19,811242a8 <__svfscanf_r+0x8f8>
81124254:	9c21c83a 	sub	r16,r19,r16
81124258:	803e1726 	beq	r16,zero,81123ab8 <__reset+0xfb103ab8>
8112425c:	da00a017 	ldw	r8,640(sp)
81124260:	98000005 	stb	zero,0(r19)
81124264:	dc409c15 	stw	r17,624(sp)
81124268:	42000044 	addi	r8,r8,1
8112426c:	da00a015 	stw	r8,640(sp)
81124270:	9425883a 	add	r18,r18,r16
81124274:	a00d883a 	mov	r6,r20
81124278:	003e0b06 	br	81123aa8 <__reset+0xfb103aa8>
8112427c:	017fff84 	movi	r5,-2
81124280:	11439b1e 	bne	r2,r5,811250f0 <__svfscanf_r+0x1740>
81124284:	8821883a 	mov	r16,r17
81124288:	e0800117 	ldw	r2,4(fp)
8112428c:	0082e516 	blt	zero,r2,81124e24 <__svfscanf_r+0x1474>
81124290:	e00b883a 	mov	r5,fp
81124294:	b009883a 	mov	r4,r22
81124298:	111ec900 	call	8111ec90 <__srefill_r>
8112429c:	1002e126 	beq	r2,zero,81124e24 <__svfscanf_r+0x1474>
811242a0:	dc409f17 	ldw	r17,636(sp)
811242a4:	8002e826 	beq	r16,zero,81124e48 <__svfscanf_r+0x1498>
811242a8:	da00a017 	ldw	r8,640(sp)
811242ac:	403e9c26 	beq	r8,zero,81123d20 <__reset+0xfb103d20>
811242b0:	e080030b 	ldhu	r2,12(fp)
811242b4:	1080100c 	andi	r2,r2,64
811242b8:	103e991e 	bne	r2,zero,81123d20 <__reset+0xfb103d20>
811242bc:	4005883a 	mov	r2,r8
811242c0:	003e9806 	br	81123d24 <__reset+0xfb103d24>
811242c4:	983f951e 	bne	r19,zero,8112411c <__reset+0xfb10411c>
811242c8:	003fb806 	br	811241ac <__reset+0xfb1041ac>
811242cc:	da009c17 	ldw	r8,624(sp)
811242d0:	45000017 	ldw	r20,0(r8)
811242d4:	42000104 	addi	r8,r8,4
811242d8:	da009c15 	stw	r8,624(sp)
811242dc:	003f8e06 	br	81124118 <__reset+0xfb104118>
811242e0:	e00b883a 	mov	r5,fp
811242e4:	b009883a 	mov	r4,r22
811242e8:	111ec900 	call	8111ec90 <__srefill_r>
811242ec:	103f3826 	beq	r2,zero,81123fd0 <__reset+0xfb103fd0>
811242f0:	003fed06 	br	811242a8 <__reset+0xfb1042a8>
811242f4:	00ffff84 	movi	r3,-2
811242f8:	10c0071e 	bne	r2,r3,81124318 <__svfscanf_r+0x968>
811242fc:	e0800117 	ldw	r2,4(fp)
81124300:	8023883a 	mov	r17,r16
81124304:	00bf8516 	blt	zero,r2,8112411c <__reset+0xfb10411c>
81124308:	003fa306 	br	81124198 <__reset+0xfb104198>
8112430c:	9425883a 	add	r18,r18,r16
81124310:	9cffffc4 	addi	r19,r19,-1
81124314:	003f9d06 	br	8112418c <__reset+0xfb10418c>
81124318:	da009f17 	ldw	r8,636(sp)
8112431c:	9425883a 	add	r18,r18,r16
81124320:	9cffffc4 	addi	r19,r19,-1
81124324:	403f9826 	beq	r8,zero,81124188 <__reset+0xfb104188>
81124328:	003f9806 	br	8112418c <__reset+0xfb10418c>
8112432c:	8023883a 	mov	r17,r16
81124330:	8821883a 	mov	r16,r17
81124334:	003fce06 	br	81124270 <__reset+0xfb104270>
81124338:	803f3d1e 	bne	r16,zero,81124030 <__reset+0xfb104030>
8112433c:	003fda06 	br	811242a8 <__reset+0xfb1042a8>
81124340:	1827883a 	mov	r19,r3
81124344:	003fc306 	br	81124254 <__reset+0xfb104254>
81124348:	803fc91e 	bne	r16,zero,81124270 <__reset+0xfb104270>
8112434c:	003dda06 	br	81123ab8 <__reset+0xfb103ab8>
81124350:	da009c17 	ldw	r8,624(sp)
81124354:	df000015 	stw	fp,0(sp)
81124358:	980f883a 	mov	r7,r19
8112435c:	41400017 	ldw	r5,0(r8)
81124360:	01800044 	movi	r6,1
81124364:	b009883a 	mov	r4,r22
81124368:	11275880 	call	81127588 <_fread_r>
8112436c:	da009c17 	ldw	r8,624(sp)
81124370:	40c00104 	addi	r3,r8,4
81124374:	103fcc26 	beq	r2,zero,811242a8 <__reset+0xfb1042a8>
81124378:	da00a017 	ldw	r8,640(sp)
8112437c:	dd009d17 	ldw	r20,628(sp)
81124380:	90a5883a 	add	r18,r18,r2
81124384:	42000044 	addi	r8,r8,1
81124388:	da00a015 	stw	r8,640(sp)
8112438c:	d8c09c15 	stw	r3,624(sp)
81124390:	a00d883a 	mov	r6,r20
81124394:	003dc406 	br	81123aa8 <__reset+0xfb103aa8>
81124398:	e00b883a 	mov	r5,fp
8112439c:	b009883a 	mov	r4,r22
811243a0:	111ec900 	call	8111ec90 <__srefill_r>
811243a4:	103e5226 	beq	r2,zero,81123cf0 <__reset+0xfb103cf0>
811243a8:	003fbf06 	br	811242a8 <__reset+0xfb1042a8>
811243ac:	a0800083 	ldbu	r2,2(r20)
811243b0:	8c400094 	ori	r17,r17,2
811243b4:	a5000084 	addi	r20,r20,2
811243b8:	10c03fcc 	andi	r3,r2,255
811243bc:	003dc706 	br	81123adc <__reset+0xfb103adc>
811243c0:	e0800117 	ldw	r2,4(fp)
811243c4:	88e2b03a 	or	r17,r17,r3
811243c8:	00bef716 	blt	zero,r2,81123fa8 <__reset+0xfb103fa8>
811243cc:	003e6f06 	br	81123d8c <__reset+0xfb103d8c>
811243d0:	8880004c 	andi	r2,r17,1
811243d4:	10000b1e 	bne	r2,zero,81124404 <__svfscanf_r+0xa54>
811243d8:	8c40008c 	andi	r17,r17,2
811243dc:	88000926 	beq	r17,zero,81124404 <__svfscanf_r+0xa54>
811243e0:	da009c17 	ldw	r8,624(sp)
811243e4:	9007d7fa 	srai	r3,r18,31
811243e8:	dd009d17 	ldw	r20,628(sp)
811243ec:	40800017 	ldw	r2,0(r8)
811243f0:	42000104 	addi	r8,r8,4
811243f4:	da009c15 	stw	r8,624(sp)
811243f8:	14800015 	stw	r18,0(r2)
811243fc:	10c00115 	stw	r3,4(r2)
81124400:	003da806 	br	81123aa4 <__reset+0xfb103aa4>
81124404:	da009c17 	ldw	r8,624(sp)
81124408:	dd009d17 	ldw	r20,628(sp)
8112440c:	40800017 	ldw	r2,0(r8)
81124410:	42000104 	addi	r8,r8,4
81124414:	da009c15 	stw	r8,624(sp)
81124418:	14800015 	stw	r18,0(r2)
8112441c:	003da106 	br	81123aa4 <__reset+0xfb103aa4>
81124420:	e00b883a 	mov	r5,fp
81124424:	b009883a 	mov	r4,r22
81124428:	111ec900 	call	8111ec90 <__srefill_r>
8112442c:	103f9e1e 	bne	r2,zero,811242a8 <__reset+0xfb1042a8>
81124430:	b9c00017 	ldw	r7,0(r23)
81124434:	05000104 	movi	r20,4
81124438:	003e6306 	br	81123dc8 <__reset+0xfb103dc8>
8112443c:	e00b883a 	mov	r5,fp
81124440:	b009883a 	mov	r4,r22
81124444:	111ec900 	call	8111ec90 <__srefill_r>
81124448:	103f971e 	bne	r2,zero,811242a8 <__reset+0xfb1042a8>
8112444c:	b9c00017 	ldw	r7,0(r23)
81124450:	003e5706 	br	81123db0 <__reset+0xfb103db0>
81124454:	e00b883a 	mov	r5,fp
81124458:	b009883a 	mov	r4,r22
8112445c:	111ec900 	call	8111ec90 <__srefill_r>
81124460:	103f911e 	bne	r2,zero,811242a8 <__reset+0xfb1042a8>
81124464:	b9c00017 	ldw	r7,0(r23)
81124468:	05000084 	movi	r20,2
8112446c:	003e5606 	br	81123dc8 <__reset+0xfb103dc8>
81124470:	e00b883a 	mov	r5,fp
81124474:	b009883a 	mov	r4,r22
81124478:	111ec900 	call	8111ec90 <__srefill_r>
8112447c:	103ef726 	beq	r2,zero,8112405c <__reset+0xfb10405c>
81124480:	003f8906 	br	811242a8 <__reset+0xfb1042a8>
81124484:	e00b883a 	mov	r5,fp
81124488:	b009883a 	mov	r4,r22
8112448c:	111ec900 	call	8111ec90 <__srefill_r>
81124490:	103f851e 	bne	r2,zero,811242a8 <__reset+0xfb1042a8>
81124494:	b9c00017 	ldw	r7,0(r23)
81124498:	003f0f06 	br	811240d8 <__reset+0xfb1040d8>
8112449c:	014000c4 	movi	r5,3
811244a0:	a1414a26 	beq	r20,r5,811249cc <__svfscanf_r+0x101c>
811244a4:	01000104 	movi	r4,4
811244a8:	a101f11e 	bne	r20,r4,81124c70 <__svfscanf_r+0x12c0>
811244ac:	b009883a 	mov	r4,r22
811244b0:	11283d80 	call	811283d8 <_localeconv_r>
811244b4:	10800017 	ldw	r2,0(r2)
811244b8:	98ffffc4 	addi	r3,r19,-1
811244bc:	d880a315 	stw	r2,652(sp)
811244c0:	00805704 	movi	r2,348
811244c4:	10c21e2e 	bgeu	r2,r3,81124d40 <__svfscanf_r+0x1390>
811244c8:	9cffa8c4 	addi	r19,r19,-349
811244cc:	dcc0a215 	stw	r19,648(sp)
811244d0:	04c05744 	movi	r19,349
811244d4:	8d01e014 	ori	r20,r17,1920
811244d8:	0023883a 	mov	r17,zero
811244dc:	dc000104 	addi	r16,sp,4
811244e0:	8805883a 	mov	r2,r17
811244e4:	0019883a 	mov	r12,zero
811244e8:	8023883a 	mov	r17,r16
811244ec:	b007883a 	mov	r3,r22
811244f0:	9821883a 	mov	r16,r19
811244f4:	002b883a 	mov	r21,zero
811244f8:	d800a515 	stw	zero,660(sp)
811244fc:	d800a415 	stw	zero,656(sp)
81124500:	d8009f15 	stw	zero,636(sp)
81124504:	01c01384 	movi	r7,78
81124508:	602d883a 	mov	r22,r12
8112450c:	1027883a 	mov	r19,r2
81124510:	e1000017 	ldw	r4,0(fp)
81124514:	21400003 	ldbu	r5,0(r4)
81124518:	28bff544 	addi	r2,r5,-43
8112451c:	10803fcc 	andi	r2,r2,255
81124520:	38810e36 	bltu	r7,r2,8112495c <__svfscanf_r+0xfac>
81124524:	100490ba 	slli	r2,r2,2
81124528:	01a044b4 	movhi	r6,33042
8112452c:	31914f04 	addi	r6,r6,17724
81124530:	1185883a 	add	r2,r2,r6
81124534:	10800017 	ldw	r2,0(r2)
81124538:	1000683a 	jmp	r2
8112453c:	81124834 	orhi	r4,r16,18720
81124540:	8112495c 	xori	r4,r16,18725
81124544:	81124834 	orhi	r4,r16,18720
81124548:	8112495c 	xori	r4,r16,18725
8112454c:	8112495c 	xori	r4,r16,18725
81124550:	81124808 	cmpgei	r4,r16,18720
81124554:	81124678 	rdprs	r4,r16,18713
81124558:	81124678 	rdprs	r4,r16,18713
8112455c:	81124678 	rdprs	r4,r16,18713
81124560:	81124678 	rdprs	r4,r16,18713
81124564:	81124678 	rdprs	r4,r16,18713
81124568:	81124678 	rdprs	r4,r16,18713
8112456c:	81124678 	rdprs	r4,r16,18713
81124570:	81124678 	rdprs	r4,r16,18713
81124574:	81124678 	rdprs	r4,r16,18713
81124578:	8112495c 	xori	r4,r16,18725
8112457c:	8112495c 	xori	r4,r16,18725
81124580:	8112495c 	xori	r4,r16,18725
81124584:	8112495c 	xori	r4,r16,18725
81124588:	8112495c 	xori	r4,r16,18725
8112458c:	8112495c 	xori	r4,r16,18725
81124590:	8112495c 	xori	r4,r16,18725
81124594:	8112494c 	andi	r4,r16,18725
81124598:	8112495c 	xori	r4,r16,18725
8112459c:	8112495c 	xori	r4,r16,18725
811245a0:	8112495c 	xori	r4,r16,18725
811245a4:	81124908 	cmpgei	r4,r16,18724
811245a8:	811248ec 	andhi	r4,r16,18723
811245ac:	8112495c 	xori	r4,r16,18725
811245b0:	8112495c 	xori	r4,r16,18725
811245b4:	811248b8 	rdprs	r4,r16,18722
811245b8:	8112495c 	xori	r4,r16,18725
811245bc:	8112495c 	xori	r4,r16,18725
811245c0:	8112495c 	xori	r4,r16,18725
811245c4:	8112495c 	xori	r4,r16,18725
811245c8:	81124880 	call	88112488 <__reset+0x20f2488>
811245cc:	8112495c 	xori	r4,r16,18725
811245d0:	8112495c 	xori	r4,r16,18725
811245d4:	8112495c 	xori	r4,r16,18725
811245d8:	8112495c 	xori	r4,r16,18725
811245dc:	8112495c 	xori	r4,r16,18725
811245e0:	81124864 	muli	r4,r16,18721
811245e4:	8112495c 	xori	r4,r16,18725
811245e8:	8112495c 	xori	r4,r16,18725
811245ec:	8112495c 	xori	r4,r16,18725
811245f0:	8112495c 	xori	r4,r16,18725
811245f4:	81124848 	cmpgei	r4,r16,18721
811245f8:	8112495c 	xori	r4,r16,18725
811245fc:	8112495c 	xori	r4,r16,18725
81124600:	8112495c 	xori	r4,r16,18725
81124604:	8112495c 	xori	r4,r16,18725
81124608:	8112495c 	xori	r4,r16,18725
8112460c:	8112495c 	xori	r4,r16,18725
81124610:	8112495c 	xori	r4,r16,18725
81124614:	8112494c 	andi	r4,r16,18725
81124618:	8112495c 	xori	r4,r16,18725
8112461c:	8112495c 	xori	r4,r16,18725
81124620:	8112495c 	xori	r4,r16,18725
81124624:	81124908 	cmpgei	r4,r16,18724
81124628:	811248ec 	andhi	r4,r16,18723
8112462c:	8112495c 	xori	r4,r16,18725
81124630:	8112495c 	xori	r4,r16,18725
81124634:	811248b8 	rdprs	r4,r16,18722
81124638:	8112495c 	xori	r4,r16,18725
8112463c:	8112495c 	xori	r4,r16,18725
81124640:	8112495c 	xori	r4,r16,18725
81124644:	8112495c 	xori	r4,r16,18725
81124648:	81124880 	call	88112488 <__reset+0x20f2488>
8112464c:	8112495c 	xori	r4,r16,18725
81124650:	8112495c 	xori	r4,r16,18725
81124654:	8112495c 	xori	r4,r16,18725
81124658:	8112495c 	xori	r4,r16,18725
8112465c:	8112495c 	xori	r4,r16,18725
81124660:	81124864 	muli	r4,r16,18721
81124664:	8112495c 	xori	r4,r16,18725
81124668:	8112495c 	xori	r4,r16,18725
8112466c:	8112495c 	xori	r4,r16,18725
81124670:	8112495c 	xori	r4,r16,18725
81124674:	81124848 	cmpgei	r4,r16,18721
81124678:	a8803fcc 	andi	r2,r21,255
8112467c:	1080201c 	xori	r2,r2,128
81124680:	10bfe004 	addi	r2,r2,-128
81124684:	b085883a 	add	r2,r22,r2
81124688:	10000d1e 	bne	r2,zero,811246c0 <__svfscanf_r+0xd10>
8112468c:	00bf9fc4 	movi	r2,-385
81124690:	a0a8703a 	and	r20,r20,r2
81124694:	89400005 	stb	r5,0(r17)
81124698:	8c400044 	addi	r17,r17,1
8112469c:	e0800117 	ldw	r2,4(fp)
811246a0:	843fffc4 	addi	r16,r16,-1
811246a4:	94800044 	addi	r18,r18,1
811246a8:	10bfffc4 	addi	r2,r2,-1
811246ac:	e0800115 	stw	r2,4(fp)
811246b0:	0080b40e 	bge	zero,r2,81124984 <__svfscanf_r+0xfd4>
811246b4:	21000044 	addi	r4,r4,1
811246b8:	e1000015 	stw	r4,0(fp)
811246bc:	803f941e 	bne	r16,zero,81124510 <__reset+0xfb104510>
811246c0:	8821883a 	mov	r16,r17
811246c4:	b019883a 	mov	r12,r22
811246c8:	9823883a 	mov	r17,r19
811246cc:	182d883a 	mov	r22,r3
811246d0:	9801961e 	bne	r19,zero,81124d2c <__svfscanf_r+0x137c>
811246d4:	633fffc4 	addi	r12,r12,-1
811246d8:	00800044 	movi	r2,1
811246dc:	1302882e 	bgeu	r2,r12,81125100 <__svfscanf_r+0x1750>
811246e0:	a8803fcc 	andi	r2,r21,255
811246e4:	1080201c 	xori	r2,r2,128
811246e8:	10bfe004 	addi	r2,r2,-128
811246ec:	113fffc4 	addi	r4,r2,-1
811246f0:	01400184 	movi	r5,6
811246f4:	29001136 	bltu	r5,r4,8112473c <__svfscanf_r+0xd8c>
811246f8:	01000084 	movi	r4,2
811246fc:	2082900e 	bge	r4,r2,81125140 <__svfscanf_r+0x1790>
81124700:	00c000c4 	movi	r3,3
81124704:	10c00d26 	beq	r2,r3,8112473c <__svfscanf_r+0xd8c>
81124708:	9425c83a 	sub	r18,r18,r16
8112470c:	1827883a 	mov	r19,r3
81124710:	843fffc4 	addi	r16,r16,-1
81124714:	81400007 	ldb	r5,0(r16)
81124718:	e00d883a 	mov	r6,fp
8112471c:	b009883a 	mov	r4,r22
81124720:	112d6080 	call	8112d608 <_ungetc_r>
81124724:	a8bfffc4 	addi	r2,r21,-1
81124728:	10c03fcc 	andi	r3,r2,255
8112472c:	8493883a 	add	r9,r16,r18
81124730:	102b883a 	mov	r21,r2
81124734:	98fff636 	bltu	r19,r3,81124710 <__reset+0xfb104710>
81124738:	4825883a 	mov	r18,r9
8112473c:	a080400c 	andi	r2,r20,256
81124740:	10001426 	beq	r2,zero,81124794 <__svfscanf_r+0xde4>
81124744:	a081000c 	andi	r2,r20,1024
81124748:	1002571e 	bne	r2,zero,811250a8 <__svfscanf_r+0x16f8>
8112474c:	817fffc7 	ldb	r5,-1(r16)
81124750:	00801944 	movi	r2,101
81124754:	84ffffc4 	addi	r19,r16,-1
81124758:	957fffc4 	addi	r21,r18,-1
8112475c:	28800826 	beq	r5,r2,81124780 <__svfscanf_r+0xdd0>
81124760:	00801144 	movi	r2,69
81124764:	28800626 	beq	r5,r2,81124780 <__svfscanf_r+0xdd0>
81124768:	e00d883a 	mov	r6,fp
8112476c:	b009883a 	mov	r4,r22
81124770:	112d6080 	call	8112d608 <_ungetc_r>
81124774:	817fff87 	ldb	r5,-2(r16)
81124778:	84ffff84 	addi	r19,r16,-2
8112477c:	957fff84 	addi	r21,r18,-2
81124780:	e00d883a 	mov	r6,fp
81124784:	b009883a 	mov	r4,r22
81124788:	112d6080 	call	8112d608 <_ungetc_r>
8112478c:	a825883a 	mov	r18,r21
81124790:	9821883a 	mov	r16,r19
81124794:	a080040c 	andi	r2,r20,16
81124798:	103e891e 	bne	r2,zero,811241c0 <__reset+0xfb1041c0>
8112479c:	80000005 	stb	zero,0(r16)
811247a0:	a081800c 	andi	r2,r20,1536
811247a4:	01010004 	movi	r4,1024
811247a8:	1101dd26 	beq	r2,r4,81124f20 <__svfscanf_r+0x1570>
811247ac:	da00a417 	ldw	r8,656(sp)
811247b0:	4001e71e 	bne	r8,zero,81124f50 <__svfscanf_r+0x15a0>
811247b4:	000d883a 	mov	r6,zero
811247b8:	d9400104 	addi	r5,sp,4
811247bc:	b009883a 	mov	r4,r22
811247c0:	112a1b80 	call	8112a1b8 <_strtod_r>
811247c4:	1021883a 	mov	r16,r2
811247c8:	a080004c 	andi	r2,r20,1
811247cc:	1000021e 	bne	r2,zero,811247d8 <__svfscanf_r+0xe28>
811247d0:	a2c0008c 	andi	r11,r20,2
811247d4:	5801e826 	beq	r11,zero,81124f78 <__svfscanf_r+0x15c8>
811247d8:	da009c17 	ldw	r8,624(sp)
811247dc:	40800017 	ldw	r2,0(r8)
811247e0:	42000104 	addi	r8,r8,4
811247e4:	da009c15 	stw	r8,624(sp)
811247e8:	14000015 	stw	r16,0(r2)
811247ec:	10c00115 	stw	r3,4(r2)
811247f0:	da00a017 	ldw	r8,640(sp)
811247f4:	dd009d17 	ldw	r20,628(sp)
811247f8:	42000044 	addi	r8,r8,1
811247fc:	da00a015 	stw	r8,640(sp)
81124800:	a00d883a 	mov	r6,r20
81124804:	003ca806 	br	81123aa8 <__reset+0xfb103aa8>
81124808:	a080400c 	andi	r2,r20,256
8112480c:	103f9a26 	beq	r2,zero,81124678 <__reset+0xfb104678>
81124810:	da00a217 	ldw	r8,648(sp)
81124814:	00bfdfc4 	movi	r2,-129
81124818:	a0a8703a 	and	r20,r20,r2
8112481c:	9cc00044 	addi	r19,r19,1
81124820:	403f9e26 	beq	r8,zero,8112469c <__reset+0xfb10469c>
81124824:	423fffc4 	addi	r8,r8,-1
81124828:	da00a215 	stw	r8,648(sp)
8112482c:	84000044 	addi	r16,r16,1
81124830:	003f9a06 	br	8112469c <__reset+0xfb10469c>
81124834:	a080200c 	andi	r2,r20,128
81124838:	103fa126 	beq	r2,zero,811246c0 <__reset+0xfb1046c0>
8112483c:	00bfdfc4 	movi	r2,-129
81124840:	a0a8703a 	and	r20,r20,r2
81124844:	003f9306 	br	81124694 <__reset+0xfb104694>
81124848:	a8803fcc 	andi	r2,r21,255
8112484c:	1080201c 	xori	r2,r2,128
81124850:	10bfe004 	addi	r2,r2,-128
81124854:	020001c4 	movi	r8,7
81124858:	123f991e 	bne	r2,r8,811246c0 <__reset+0xfb1046c0>
8112485c:	05400204 	movi	r21,8
81124860:	003f8c06 	br	81124694 <__reset+0xfb104694>
81124864:	a8803fcc 	andi	r2,r21,255
81124868:	1080201c 	xori	r2,r2,128
8112486c:	10bfe004 	addi	r2,r2,-128
81124870:	01800184 	movi	r6,6
81124874:	11bf921e 	bne	r2,r6,811246c0 <__reset+0xfb1046c0>
81124878:	054001c4 	movi	r21,7
8112487c:	003f8506 	br	81124694 <__reset+0xfb104694>
81124880:	b000491e 	bne	r22,zero,811249a8 <__svfscanf_r+0xff8>
81124884:	9800031e 	bne	r19,zero,81124894 <__svfscanf_r+0xee4>
81124888:	a081c00c 	andi	r2,r20,1792
8112488c:	0181c004 	movi	r6,1792
81124890:	11819f26 	beq	r2,r6,81124f10 <__svfscanf_r+0x1560>
81124894:	a8803fcc 	andi	r2,r21,255
81124898:	1080201c 	xori	r2,r2,128
8112489c:	10bfe004 	addi	r2,r2,-128
811248a0:	01800044 	movi	r6,1
811248a4:	11800226 	beq	r2,r6,811248b0 <__svfscanf_r+0xf00>
811248a8:	01800104 	movi	r6,4
811248ac:	11bf841e 	bne	r2,r6,811246c0 <__reset+0xfb1046c0>
811248b0:	ad400044 	addi	r21,r21,1
811248b4:	003f7706 	br	81124694 <__reset+0xfb104694>
811248b8:	a8803fcc 	andi	r2,r21,255
811248bc:	1080201c 	xori	r2,r2,128
811248c0:	10bfe004 	addi	r2,r2,-128
811248c4:	10003c1e 	bne	r2,zero,811249b8 <__svfscanf_r+0x1008>
811248c8:	9801141e 	bne	r19,zero,81124d1c <__svfscanf_r+0x136c>
811248cc:	a081c00c 	andi	r2,r20,1792
811248d0:	0181c004 	movi	r6,1792
811248d4:	11818226 	beq	r2,r6,81124ee0 <__svfscanf_r+0x1530>
811248d8:	8821883a 	mov	r16,r17
811248dc:	b019883a 	mov	r12,r22
811248e0:	9823883a 	mov	r17,r19
811248e4:	182d883a 	mov	r22,r3
811248e8:	003f7a06 	br	811246d4 <__reset+0xfb1046d4>
811248ec:	a8803fcc 	andi	r2,r21,255
811248f0:	1080201c 	xori	r2,r2,128
811248f4:	10bfe004 	addi	r2,r2,-128
811248f8:	01800084 	movi	r6,2
811248fc:	11bf701e 	bne	r2,r6,811246c0 <__reset+0xfb1046c0>
81124900:	054000c4 	movi	r21,3
81124904:	003f6306 	br	81124694 <__reset+0xfb104694>
81124908:	a081400c 	andi	r2,r20,1280
8112490c:	01810004 	movi	r6,1024
81124910:	11800326 	beq	r2,r6,81124920 <__svfscanf_r+0xf70>
81124914:	a184703a 	and	r2,r20,r6
81124918:	103f6926 	beq	r2,zero,811246c0 <__reset+0xfb1046c0>
8112491c:	983fee26 	beq	r19,zero,811248d8 <__reset+0xfb1048d8>
81124920:	a080800c 	andi	r2,r20,512
81124924:	1000041e 	bne	r2,zero,81124938 <__svfscanf_r+0xf88>
81124928:	da009f17 	ldw	r8,636(sp)
8112492c:	dc40a515 	stw	r17,660(sp)
81124930:	9a27c83a 	sub	r19,r19,r8
81124934:	dcc0a415 	stw	r19,656(sp)
81124938:	00be1fc4 	movi	r2,-1921
8112493c:	a0a8703a 	and	r20,r20,r2
81124940:	a5006014 	ori	r20,r20,384
81124944:	0027883a 	mov	r19,zero
81124948:	003f5206 	br	81124694 <__reset+0xfb104694>
8112494c:	00800044 	movi	r2,1
81124950:	b0bf5b1e 	bne	r22,r2,811246c0 <__reset+0xfb1046c0>
81124954:	05800084 	movi	r22,2
81124958:	003f4e06 	br	81124694 <__reset+0xfb104694>
8112495c:	d980a317 	ldw	r6,652(sp)
81124960:	30800003 	ldbu	r2,0(r6)
81124964:	29803fcc 	andi	r6,r5,255
81124968:	30bf551e 	bne	r6,r2,811246c0 <__reset+0xfb1046c0>
8112496c:	a080800c 	andi	r2,r20,512
81124970:	103f5326 	beq	r2,zero,811246c0 <__reset+0xfb1046c0>
81124974:	023f5fc4 	movi	r8,-641
81124978:	a228703a 	and	r20,r20,r8
8112497c:	dcc09f15 	stw	r19,636(sp)
81124980:	003f4406 	br	81124694 <__reset+0xfb104694>
81124984:	1809883a 	mov	r4,r3
81124988:	e00b883a 	mov	r5,fp
8112498c:	d8c0a615 	stw	r3,664(sp)
81124990:	d9c0aa15 	stw	r7,680(sp)
81124994:	111ec900 	call	8111ec90 <__srefill_r>
81124998:	d8c0a617 	ldw	r3,664(sp)
8112499c:	d9c0aa17 	ldw	r7,680(sp)
811249a0:	103f4626 	beq	r2,zero,811246bc <__reset+0xfb1046bc>
811249a4:	003f4606 	br	811246c0 <__reset+0xfb1046c0>
811249a8:	00800084 	movi	r2,2
811249ac:	b0bfb91e 	bne	r22,r2,81124894 <__reset+0xfb104894>
811249b0:	058000c4 	movi	r22,3
811249b4:	003f3706 	br	81124694 <__reset+0xfb104694>
811249b8:	018000c4 	movi	r6,3
811249bc:	11bfbc26 	beq	r2,r6,811248b0 <__reset+0xfb1048b0>
811249c0:	01800144 	movi	r6,5
811249c4:	11bfba26 	beq	r2,r6,811248b0 <__reset+0xfb1048b0>
811249c8:	003f3d06 	br	811246c0 <__reset+0xfb1046c0>
811249cc:	98bfffc4 	addi	r2,r19,-1
811249d0:	01405704 	movi	r5,348
811249d4:	2880d82e 	bgeu	r5,r2,81124d38 <__svfscanf_r+0x1388>
811249d8:	99ffa8c4 	addi	r7,r19,-349
811249dc:	04c05744 	movi	r19,349
811249e0:	8c436014 	ori	r17,r17,3456
811249e4:	9013883a 	mov	r9,r18
811249e8:	8825883a 	mov	r18,r17
811249ec:	dc409e17 	ldw	r17,632(sp)
811249f0:	0029883a 	mov	r20,zero
811249f4:	dc000104 	addi	r16,sp,4
811249f8:	05401344 	movi	r21,77
811249fc:	02c08004 	movi	r11,512
81124a00:	01bf7fc4 	movi	r6,-513
81124a04:	023fdfc4 	movi	r8,-129
81124a08:	20bff544 	addi	r2,r4,-43
81124a0c:	10803fcc 	andi	r2,r2,255
81124a10:	a8807236 	bltu	r21,r2,81124bdc <__svfscanf_r+0x122c>
81124a14:	100490ba 	slli	r2,r2,2
81124a18:	016044b4 	movhi	r5,33042
81124a1c:	29528b04 	addi	r5,r5,18988
81124a20:	1145883a 	add	r2,r2,r5
81124a24:	10800017 	ldw	r2,0(r2)
81124a28:	1000683a 	jmp	r2
81124a2c:	81124c60 	cmpeqi	r4,r16,18737
81124a30:	81124bdc 	xori	r4,r16,18735
81124a34:	81124c60 	cmpeqi	r4,r16,18737
81124a38:	81124bdc 	xori	r4,r16,18735
81124a3c:	81124bdc 	xori	r4,r16,18735
81124a40:	81124c38 	rdprs	r4,r16,18736
81124a44:	81124c18 	cmpnei	r4,r16,18736
81124a48:	81124c18 	cmpnei	r4,r16,18736
81124a4c:	81124c18 	cmpnei	r4,r16,18736
81124a50:	81124c18 	cmpnei	r4,r16,18736
81124a54:	81124c18 	cmpnei	r4,r16,18736
81124a58:	81124c18 	cmpnei	r4,r16,18736
81124a5c:	81124c18 	cmpnei	r4,r16,18736
81124a60:	81124bc0 	call	881124bc <__reset+0x20f24bc>
81124a64:	81124bc0 	call	881124bc <__reset+0x20f24bc>
81124a68:	81124bdc 	xori	r4,r16,18735
81124a6c:	81124bdc 	xori	r4,r16,18735
81124a70:	81124bdc 	xori	r4,r16,18735
81124a74:	81124bdc 	xori	r4,r16,18735
81124a78:	81124bdc 	xori	r4,r16,18735
81124a7c:	81124bdc 	xori	r4,r16,18735
81124a80:	81124bdc 	xori	r4,r16,18735
81124a84:	81124bac 	andhi	r4,r16,18734
81124a88:	81124bac 	andhi	r4,r16,18734
81124a8c:	81124bac 	andhi	r4,r16,18734
81124a90:	81124bac 	andhi	r4,r16,18734
81124a94:	81124bac 	andhi	r4,r16,18734
81124a98:	81124bac 	andhi	r4,r16,18734
81124a9c:	81124bdc 	xori	r4,r16,18735
81124aa0:	81124bdc 	xori	r4,r16,18735
81124aa4:	81124bdc 	xori	r4,r16,18735
81124aa8:	81124bdc 	xori	r4,r16,18735
81124aac:	81124bdc 	xori	r4,r16,18735
81124ab0:	81124bdc 	xori	r4,r16,18735
81124ab4:	81124bdc 	xori	r4,r16,18735
81124ab8:	81124bdc 	xori	r4,r16,18735
81124abc:	81124bdc 	xori	r4,r16,18735
81124ac0:	81124bdc 	xori	r4,r16,18735
81124ac4:	81124bdc 	xori	r4,r16,18735
81124ac8:	81124bdc 	xori	r4,r16,18735
81124acc:	81124bdc 	xori	r4,r16,18735
81124ad0:	81124bdc 	xori	r4,r16,18735
81124ad4:	81124bdc 	xori	r4,r16,18735
81124ad8:	81124bdc 	xori	r4,r16,18735
81124adc:	81124bdc 	xori	r4,r16,18735
81124ae0:	81124b64 	muli	r4,r16,18733
81124ae4:	81124bdc 	xori	r4,r16,18735
81124ae8:	81124bdc 	xori	r4,r16,18735
81124aec:	81124bdc 	xori	r4,r16,18735
81124af0:	81124bdc 	xori	r4,r16,18735
81124af4:	81124bdc 	xori	r4,r16,18735
81124af8:	81124bdc 	xori	r4,r16,18735
81124afc:	81124bdc 	xori	r4,r16,18735
81124b00:	81124bdc 	xori	r4,r16,18735
81124b04:	81124bac 	andhi	r4,r16,18734
81124b08:	81124bac 	andhi	r4,r16,18734
81124b0c:	81124bac 	andhi	r4,r16,18734
81124b10:	81124bac 	andhi	r4,r16,18734
81124b14:	81124bac 	andhi	r4,r16,18734
81124b18:	81124bac 	andhi	r4,r16,18734
81124b1c:	81124bdc 	xori	r4,r16,18735
81124b20:	81124bdc 	xori	r4,r16,18735
81124b24:	81124bdc 	xori	r4,r16,18735
81124b28:	81124bdc 	xori	r4,r16,18735
81124b2c:	81124bdc 	xori	r4,r16,18735
81124b30:	81124bdc 	xori	r4,r16,18735
81124b34:	81124bdc 	xori	r4,r16,18735
81124b38:	81124bdc 	xori	r4,r16,18735
81124b3c:	81124bdc 	xori	r4,r16,18735
81124b40:	81124bdc 	xori	r4,r16,18735
81124b44:	81124bdc 	xori	r4,r16,18735
81124b48:	81124bdc 	xori	r4,r16,18735
81124b4c:	81124bdc 	xori	r4,r16,18735
81124b50:	81124bdc 	xori	r4,r16,18735
81124b54:	81124bdc 	xori	r4,r16,18735
81124b58:	81124bdc 	xori	r4,r16,18735
81124b5c:	81124bdc 	xori	r4,r16,18735
81124b60:	81124b64 	muli	r4,r16,18733
81124b64:	9081800c 	andi	r2,r18,1536
81124b68:	12c01c1e 	bne	r2,r11,81124bdc <__svfscanf_r+0x122c>
81124b6c:	91a4703a 	and	r18,r18,r6
81124b70:	94814014 	ori	r18,r18,1280
81124b74:	04400404 	movi	r17,16
81124b78:	81000005 	stb	r4,0(r16)
81124b7c:	84000044 	addi	r16,r16,1
81124b80:	e0800117 	ldw	r2,4(fp)
81124b84:	10bfffc4 	addi	r2,r2,-1
81124b88:	e0800115 	stw	r2,4(fp)
81124b8c:	0080540e 	bge	zero,r2,81124ce0 <__svfscanf_r+0x1330>
81124b90:	18c00044 	addi	r3,r3,1
81124b94:	e0c00015 	stw	r3,0(fp)
81124b98:	9cffffc4 	addi	r19,r19,-1
81124b9c:	98000f26 	beq	r19,zero,81124bdc <__svfscanf_r+0x122c>
81124ba0:	e0c00017 	ldw	r3,0(fp)
81124ba4:	19000003 	ldbu	r4,0(r3)
81124ba8:	003f9706 	br	81124a08 <__reset+0xfb104a08>
81124bac:	00800284 	movi	r2,10
81124bb0:	14400a0e 	bge	r2,r17,81124bdc <__svfscanf_r+0x122c>
81124bb4:	00bd1fc4 	movi	r2,-2945
81124bb8:	90a4703a 	and	r18,r18,r2
81124bbc:	003fee06 	br	81124b78 <__reset+0xfb104b78>
81124bc0:	01604574 	movhi	r5,33045
81124bc4:	8c63883a 	add	r17,r17,r17
81124bc8:	2973ad84 	addi	r5,r5,-12618
81124bcc:	2c45883a 	add	r2,r5,r17
81124bd0:	1440000f 	ldh	r17,0(r2)
81124bd4:	00800204 	movi	r2,8
81124bd8:	147ff616 	blt	r2,r17,81124bb4 <__reset+0xfb104bb4>
81124bdc:	dc409e15 	stw	r17,632(sp)
81124be0:	9023883a 	mov	r17,r18
81124be4:	8880400c 	andi	r2,r17,256
81124be8:	4825883a 	mov	r18,r9
81124bec:	10000426 	beq	r2,zero,81124c00 <__svfscanf_r+0x1250>
81124bf0:	d9800104 	addi	r6,sp,4
81124bf4:	3400be36 	bltu	r6,r16,81124ef0 <__svfscanf_r+0x1540>
81124bf8:	da000104 	addi	r8,sp,4
81124bfc:	443bae26 	beq	r8,r16,81123ab8 <__reset+0xfb103ab8>
81124c00:	8880040c 	andi	r2,r17,16
81124c04:	10009326 	beq	r2,zero,81124e54 <__svfscanf_r+0x14a4>
81124c08:	d8800104 	addi	r2,sp,4
81124c0c:	80a1c83a 	sub	r16,r16,r2
81124c10:	8521883a 	add	r16,r16,r20
81124c14:	003d0606 	br	81124030 <__reset+0xfb104030>
81124c18:	01604574 	movhi	r5,33045
81124c1c:	8c63883a 	add	r17,r17,r17
81124c20:	2973ad84 	addi	r5,r5,-12618
81124c24:	2c45883a 	add	r2,r5,r17
81124c28:	1440000f 	ldh	r17,0(r2)
81124c2c:	00bd1fc4 	movi	r2,-2945
81124c30:	90a4703a 	and	r18,r18,r2
81124c34:	003fd006 	br	81124b78 <__reset+0xfb104b78>
81124c38:	9082000c 	andi	r2,r18,2048
81124c3c:	103fce26 	beq	r2,zero,81124b78 <__reset+0xfb104b78>
81124c40:	8800021e 	bne	r17,zero,81124c4c <__svfscanf_r+0x129c>
81124c44:	94808014 	ori	r18,r18,512
81124c48:	04400204 	movi	r17,8
81124c4c:	9081000c 	andi	r2,r18,1024
81124c50:	10009426 	beq	r2,zero,81124ea4 <__svfscanf_r+0x14f4>
81124c54:	00be9fc4 	movi	r2,-1409
81124c58:	90a4703a 	and	r18,r18,r2
81124c5c:	003fc606 	br	81124b78 <__reset+0xfb104b78>
81124c60:	9080200c 	andi	r2,r18,128
81124c64:	103fdd26 	beq	r2,zero,81124bdc <__reset+0xfb104bdc>
81124c68:	9224703a 	and	r18,r18,r8
81124c6c:	003fc206 	br	81124b78 <__reset+0xfb104b78>
81124c70:	9800011e 	bne	r19,zero,81124c78 <__svfscanf_r+0x12c8>
81124c74:	04ffffc4 	movi	r19,-1
81124c78:	8900004c 	andi	r4,r17,1
81124c7c:	20005b1e 	bne	r4,zero,81124dec <__svfscanf_r+0x143c>
81124c80:	8c40040c 	andi	r17,r17,16
81124c84:	88003026 	beq	r17,zero,81124d48 <__svfscanf_r+0x1398>
81124c88:	0021883a 	mov	r16,zero
81124c8c:	00000306 	br	81124c9c <__svfscanf_r+0x12ec>
81124c90:	18800003 	ldbu	r2,0(r3)
81124c94:	3885883a 	add	r2,r7,r2
81124c98:	10800043 	ldbu	r2,1(r2)
81124c9c:	1080020c 	andi	r2,r2,8
81124ca0:	103ce31e 	bne	r2,zero,81124030 <__reset+0xfb104030>
81124ca4:	e0800117 	ldw	r2,4(fp)
81124ca8:	18c00044 	addi	r3,r3,1
81124cac:	84000044 	addi	r16,r16,1
81124cb0:	10bfffc4 	addi	r2,r2,-1
81124cb4:	e0800115 	stw	r2,4(fp)
81124cb8:	e0c00015 	stw	r3,0(fp)
81124cbc:	84fcdc26 	beq	r16,r19,81124030 <__reset+0xfb104030>
81124cc0:	00bff316 	blt	zero,r2,81124c90 <__reset+0xfb104c90>
81124cc4:	e00b883a 	mov	r5,fp
81124cc8:	b009883a 	mov	r4,r22
81124ccc:	111ec900 	call	8111ec90 <__srefill_r>
81124cd0:	103cd71e 	bne	r2,zero,81124030 <__reset+0xfb104030>
81124cd4:	b9c00017 	ldw	r7,0(r23)
81124cd8:	e0c00017 	ldw	r3,0(fp)
81124cdc:	003fec06 	br	81124c90 <__reset+0xfb104c90>
81124ce0:	e00b883a 	mov	r5,fp
81124ce4:	b009883a 	mov	r4,r22
81124ce8:	d980a715 	stw	r6,668(sp)
81124cec:	d9c0aa15 	stw	r7,680(sp)
81124cf0:	da00a815 	stw	r8,672(sp)
81124cf4:	da40a915 	stw	r9,676(sp)
81124cf8:	dac0a615 	stw	r11,664(sp)
81124cfc:	111ec900 	call	8111ec90 <__srefill_r>
81124d00:	d980a717 	ldw	r6,668(sp)
81124d04:	d9c0aa17 	ldw	r7,680(sp)
81124d08:	da00a817 	ldw	r8,672(sp)
81124d0c:	da40a917 	ldw	r9,676(sp)
81124d10:	dac0a617 	ldw	r11,664(sp)
81124d14:	103fa026 	beq	r2,zero,81124b98 <__reset+0xfb104b98>
81124d18:	003fb006 	br	81124bdc <__reset+0xfb104bdc>
81124d1c:	8821883a 	mov	r16,r17
81124d20:	b019883a 	mov	r12,r22
81124d24:	9823883a 	mov	r17,r19
81124d28:	182d883a 	mov	r22,r3
81124d2c:	00bfbfc4 	movi	r2,-257
81124d30:	a0a8703a 	and	r20,r20,r2
81124d34:	003e6706 	br	811246d4 <__reset+0xfb1046d4>
81124d38:	000f883a 	mov	r7,zero
81124d3c:	003f2806 	br	811249e0 <__reset+0xfb1049e0>
81124d40:	d800a215 	stw	zero,648(sp)
81124d44:	003de306 	br	811244d4 <__reset+0xfb1044d4>
81124d48:	da009c17 	ldw	r8,624(sp)
81124d4c:	9abfffc4 	addi	r10,r19,-1
81124d50:	44400017 	ldw	r17,0(r8)
81124d54:	44000104 	addi	r16,r8,4
81124d58:	880b883a 	mov	r5,r17
81124d5c:	8aa9883a 	add	r20,r17,r10
81124d60:	00000606 	br	81124d7c <__svfscanf_r+0x13cc>
81124d64:	e0c00017 	ldw	r3,0(fp)
81124d68:	b9000017 	ldw	r4,0(r23)
81124d6c:	a80b883a 	mov	r5,r21
81124d70:	18800003 	ldbu	r2,0(r3)
81124d74:	2085883a 	add	r2,r4,r2
81124d78:	10800043 	ldbu	r2,1(r2)
81124d7c:	1080020c 	andi	r2,r2,8
81124d80:	1000551e 	bne	r2,zero,81124ed8 <__svfscanf_r+0x1528>
81124d84:	e0800117 	ldw	r2,4(fp)
81124d88:	19000044 	addi	r4,r3,1
81124d8c:	e1000015 	stw	r4,0(fp)
81124d90:	10bfffc4 	addi	r2,r2,-1
81124d94:	e0800115 	stw	r2,4(fp)
81124d98:	18800003 	ldbu	r2,0(r3)
81124d9c:	2d400044 	addi	r21,r5,1
81124da0:	a827883a 	mov	r19,r21
81124da4:	28800005 	stb	r2,0(r5)
81124da8:	2d000626 	beq	r5,r20,81124dc4 <__svfscanf_r+0x1414>
81124dac:	e0800117 	ldw	r2,4(fp)
81124db0:	00bfec16 	blt	zero,r2,81124d64 <__reset+0xfb104d64>
81124db4:	e00b883a 	mov	r5,fp
81124db8:	b009883a 	mov	r4,r22
81124dbc:	111ec900 	call	8111ec90 <__srefill_r>
81124dc0:	103fe826 	beq	r2,zero,81124d64 <__reset+0xfb104d64>
81124dc4:	da00a017 	ldw	r8,640(sp)
81124dc8:	dd009d17 	ldw	r20,628(sp)
81124dcc:	9c63c83a 	sub	r17,r19,r17
81124dd0:	42000044 	addi	r8,r8,1
81124dd4:	98000005 	stb	zero,0(r19)
81124dd8:	9465883a 	add	r18,r18,r17
81124ddc:	da00a015 	stw	r8,640(sp)
81124de0:	dc009c15 	stw	r16,624(sp)
81124de4:	a00d883a 	mov	r6,r20
81124de8:	003b2f06 	br	81123aa8 <__reset+0xfb103aa8>
81124dec:	dd409904 	addi	r21,sp,612
81124df0:	8c40040c 	andi	r17,r17,16
81124df4:	01800204 	movi	r6,8
81124df8:	000b883a 	mov	r5,zero
81124dfc:	a809883a 	mov	r4,r21
81124e00:	111e8140 	call	8111e814 <memset>
81124e04:	8800401e 	bne	r17,zero,81124f08 <__svfscanf_r+0x1558>
81124e08:	da009c17 	ldw	r8,624(sp)
81124e0c:	45000017 	ldw	r20,0(r8)
81124e10:	42000104 	addi	r8,r8,4
81124e14:	da009c15 	stw	r8,624(sp)
81124e18:	000d883a 	mov	r6,zero
81124e1c:	3021883a 	mov	r16,r6
81124e20:	dc409f15 	stw	r17,636(sp)
81124e24:	e0800017 	ldw	r2,0(fp)
81124e28:	b8c00017 	ldw	r3,0(r23)
81124e2c:	10800003 	ldbu	r2,0(r2)
81124e30:	1885883a 	add	r2,r3,r2
81124e34:	10800043 	ldbu	r2,1(r2)
81124e38:	1080020c 	andi	r2,r2,8
81124e3c:	1000011e 	bne	r2,zero,81124e44 <__svfscanf_r+0x1494>
81124e40:	9800701e 	bne	r19,zero,81125004 <__svfscanf_r+0x1654>
81124e44:	dc409f17 	ldw	r17,636(sp)
81124e48:	883cdd1e 	bne	r17,zero,811241c0 <__reset+0xfb1041c0>
81124e4c:	a0000015 	stw	zero,0(r20)
81124e50:	003cd806 	br	811241b4 <__reset+0xfb1041b4>
81124e54:	d9c09e17 	ldw	r7,632(sp)
81124e58:	da00a117 	ldw	r8,644(sp)
81124e5c:	000d883a 	mov	r6,zero
81124e60:	d9400104 	addi	r5,sp,4
81124e64:	b009883a 	mov	r4,r22
81124e68:	80000005 	stb	zero,0(r16)
81124e6c:	403ee83a 	callr	r8
81124e70:	88c0080c 	andi	r3,r17,32
81124e74:	1800121e 	bne	r3,zero,81124ec0 <__svfscanf_r+0x1510>
81124e78:	88c0010c 	andi	r3,r17,4
81124e7c:	18004d26 	beq	r3,zero,81124fb4 <__svfscanf_r+0x1604>
81124e80:	da009c17 	ldw	r8,624(sp)
81124e84:	40c00017 	ldw	r3,0(r8)
81124e88:	42000104 	addi	r8,r8,4
81124e8c:	da009c15 	stw	r8,624(sp)
81124e90:	1880000d 	sth	r2,0(r3)
81124e94:	da00a017 	ldw	r8,640(sp)
81124e98:	42000044 	addi	r8,r8,1
81124e9c:	da00a015 	stw	r8,640(sp)
81124ea0:	003f5906 	br	81124c08 <__reset+0xfb104c08>
81124ea4:	00bf1fc4 	movi	r2,-897
81124ea8:	90a4703a 	and	r18,r18,r2
81124eac:	38000226 	beq	r7,zero,81124eb8 <__svfscanf_r+0x1508>
81124eb0:	39ffffc4 	addi	r7,r7,-1
81124eb4:	9cc00044 	addi	r19,r19,1
81124eb8:	a5000044 	addi	r20,r20,1
81124ebc:	003f3006 	br	81124b80 <__reset+0xfb104b80>
81124ec0:	da009c17 	ldw	r8,624(sp)
81124ec4:	40c00017 	ldw	r3,0(r8)
81124ec8:	42000104 	addi	r8,r8,4
81124ecc:	da009c15 	stw	r8,624(sp)
81124ed0:	18800015 	stw	r2,0(r3)
81124ed4:	003fef06 	br	81124e94 <__reset+0xfb104e94>
81124ed8:	2827883a 	mov	r19,r5
81124edc:	003fb906 	br	81124dc4 <__reset+0xfb104dc4>
81124ee0:	01be1fc4 	movi	r6,-1921
81124ee4:	a1a8703a 	and	r20,r20,r6
81124ee8:	05400044 	movi	r21,1
81124eec:	003de906 	br	81124694 <__reset+0xfb104694>
81124ef0:	817fffc7 	ldb	r5,-1(r16)
81124ef4:	e00d883a 	mov	r6,fp
81124ef8:	b009883a 	mov	r4,r22
81124efc:	843fffc4 	addi	r16,r16,-1
81124f00:	112d6080 	call	8112d608 <_ungetc_r>
81124f04:	003f3c06 	br	81124bf8 <__reset+0xfb104bf8>
81124f08:	dd009b04 	addi	r20,sp,620
81124f0c:	003fc206 	br	81124e18 <__reset+0xfb104e18>
81124f10:	00be1fc4 	movi	r2,-1921
81124f14:	a0a8703a 	and	r20,r20,r2
81124f18:	05800044 	movi	r22,1
81124f1c:	003ddd06 	br	81124694 <__reset+0xfb104694>
81124f20:	d8c09f17 	ldw	r3,636(sp)
81124f24:	88e3c83a 	sub	r17,r17,r3
81124f28:	044dc83a 	sub	r6,zero,r17
81124f2c:	883e2126 	beq	r17,zero,811247b4 <__reset+0xfb1047b4>
81124f30:	d88055c4 	addi	r2,sp,343
81124f34:	80800136 	bltu	r16,r2,81124f3c <__svfscanf_r+0x158c>
81124f38:	dc005584 	addi	r16,sp,342
81124f3c:	01604574 	movhi	r5,33045
81124f40:	2973ac04 	addi	r5,r5,-12624
81124f44:	8009883a 	mov	r4,r16
81124f48:	111efa40 	call	8111efa4 <sprintf>
81124f4c:	003e1906 	br	811247b4 <__reset+0xfb1047b4>
81124f50:	d8c0a517 	ldw	r3,660(sp)
81124f54:	000d883a 	mov	r6,zero
81124f58:	01c00284 	movi	r7,10
81124f5c:	19400044 	addi	r5,r3,1
81124f60:	b009883a 	mov	r4,r22
81124f64:	111f2940 	call	8111f294 <_strtol_r>
81124f68:	da00a417 	ldw	r8,656(sp)
81124f6c:	dc00a517 	ldw	r16,660(sp)
81124f70:	120dc83a 	sub	r6,r2,r8
81124f74:	003fee06 	br	81124f30 <__reset+0xfb104f30>
81124f78:	da009c17 	ldw	r8,624(sp)
81124f7c:	180b883a 	mov	r5,r3
81124f80:	8009883a 	mov	r4,r16
81124f84:	45000017 	ldw	r20,0(r8)
81124f88:	44400104 	addi	r17,r8,4
81124f8c:	d8c0a615 	stw	r3,664(sp)
81124f90:	1129f240 	call	81129f24 <__fpclassifyd>
81124f94:	d8c0a617 	ldw	r3,664(sp)
81124f98:	10006426 	beq	r2,zero,8112512c <__svfscanf_r+0x177c>
81124f9c:	8009883a 	mov	r4,r16
81124fa0:	180b883a 	mov	r5,r3
81124fa4:	111d2ac0 	call	8111d2ac <__truncdfsf2>
81124fa8:	a0800015 	stw	r2,0(r20)
81124fac:	dc409c15 	stw	r17,624(sp)
81124fb0:	003e0f06 	br	811247f0 <__reset+0xfb1047f0>
81124fb4:	88c0004c 	andi	r3,r17,1
81124fb8:	183fc11e 	bne	r3,zero,81124ec0 <__reset+0xfb104ec0>
81124fbc:	8c40008c 	andi	r17,r17,2
81124fc0:	883fbf26 	beq	r17,zero,81124ec0 <__reset+0xfb104ec0>
81124fc4:	da00a117 	ldw	r8,644(sp)
81124fc8:	00a044f4 	movhi	r2,33043
81124fcc:	10aef004 	addi	r2,r2,-17472
81124fd0:	d9c09e17 	ldw	r7,632(sp)
81124fd4:	000d883a 	mov	r6,zero
81124fd8:	d9400104 	addi	r5,sp,4
81124fdc:	b009883a 	mov	r4,r22
81124fe0:	40806226 	beq	r8,r2,8112516c <__svfscanf_r+0x17bc>
81124fe4:	112b8d80 	call	8112b8d8 <_strtoll_r>
81124fe8:	da009c17 	ldw	r8,624(sp)
81124fec:	41000017 	ldw	r4,0(r8)
81124ff0:	42000104 	addi	r8,r8,4
81124ff4:	da009c15 	stw	r8,624(sp)
81124ff8:	20800015 	stw	r2,0(r4)
81124ffc:	20c00115 	stw	r3,4(r4)
81125000:	003fa406 	br	81124e94 <__reset+0xfb104e94>
81125004:	11283b40 	call	811283b4 <__locale_mb_cur_max>
81125008:	80bca726 	beq	r16,r2,811242a8 <__reset+0xfb1042a8>
8112500c:	e0800017 	ldw	r2,0(fp)
81125010:	e1000117 	ldw	r4,4(fp)
81125014:	d8c00104 	addi	r3,sp,4
81125018:	12000003 	ldbu	r8,0(r2)
8112501c:	213fffc4 	addi	r4,r4,-1
81125020:	10800044 	addi	r2,r2,1
81125024:	e1000115 	stw	r4,4(fp)
81125028:	e0800015 	stw	r2,0(fp)
8112502c:	84400044 	addi	r17,r16,1
81125030:	dd400015 	stw	r21,0(sp)
81125034:	1c21883a 	add	r16,r3,r16
81125038:	b009883a 	mov	r4,r22
8112503c:	880f883a 	mov	r7,r17
81125040:	180d883a 	mov	r6,r3
81125044:	a00b883a 	mov	r5,r20
81125048:	82000005 	stb	r8,0(r16)
8112504c:	11284700 	call	81128470 <_mbrtowc_r>
81125050:	013fffc4 	movi	r4,-1
81125054:	113c9426 	beq	r2,r4,811242a8 <__reset+0xfb1042a8>
81125058:	103c881e 	bne	r2,zero,8112427c <__reset+0xfb10427c>
8112505c:	a0000015 	stw	zero,0(r20)
81125060:	0009883a 	mov	r4,zero
81125064:	11282f40 	call	811282f4 <iswspace>
81125068:	10001a26 	beq	r2,zero,811250d4 <__svfscanf_r+0x1724>
8112506c:	8821883a 	mov	r16,r17
81125070:	dc409f17 	ldw	r17,636(sp)
81125074:	803f7426 	beq	r16,zero,81124e48 <__reset+0xfb104e48>
81125078:	843fffc4 	addi	r16,r16,-1
8112507c:	d9800104 	addi	r6,sp,4
81125080:	342b883a 	add	r21,r6,r16
81125084:	00000106 	br	8112508c <__svfscanf_r+0x16dc>
81125088:	843fffc4 	addi	r16,r16,-1
8112508c:	a9400003 	ldbu	r5,0(r21)
81125090:	e00d883a 	mov	r6,fp
81125094:	b009883a 	mov	r4,r22
81125098:	112d6080 	call	8112d608 <_ungetc_r>
8112509c:	ad7fffc4 	addi	r21,r21,-1
811250a0:	803ff91e 	bne	r16,zero,81125088 <__reset+0xfb105088>
811250a4:	003f6806 	br	81124e48 <__reset+0xfb104e48>
811250a8:	d9800104 	addi	r6,sp,4
811250ac:	802b883a 	mov	r21,r16
811250b0:	343a812e 	bgeu	r6,r16,81123ab8 <__reset+0xfb103ab8>
811250b4:	ad7fffc4 	addi	r21,r21,-1
811250b8:	a9400007 	ldb	r5,0(r21)
811250bc:	e00d883a 	mov	r6,fp
811250c0:	b009883a 	mov	r4,r22
811250c4:	112d6080 	call	8112d608 <_ungetc_r>
811250c8:	da000104 	addi	r8,sp,4
811250cc:	457ff91e 	bne	r8,r21,811250b4 <__reset+0xfb1050b4>
811250d0:	003a7906 	br	81123ab8 <__reset+0xfb103ab8>
811250d4:	da009f17 	ldw	r8,636(sp)
811250d8:	9465883a 	add	r18,r18,r17
811250dc:	9cffffc4 	addi	r19,r19,-1
811250e0:	4000051e 	bne	r8,zero,811250f8 <__svfscanf_r+0x1748>
811250e4:	a5000104 	addi	r20,r20,4
811250e8:	0021883a 	mov	r16,zero
811250ec:	003c6606 	br	81124288 <__reset+0xfb104288>
811250f0:	a1000017 	ldw	r4,0(r20)
811250f4:	003fdb06 	br	81125064 <__reset+0xfb105064>
811250f8:	0021883a 	mov	r16,zero
811250fc:	003c6206 	br	81124288 <__reset+0xfb104288>
81125100:	d8800104 	addi	r2,sp,4
81125104:	802b883a 	mov	r21,r16
81125108:	143a6b2e 	bgeu	r2,r16,81123ab8 <__reset+0xfb103ab8>
8112510c:	ad7fffc4 	addi	r21,r21,-1
81125110:	a9400007 	ldb	r5,0(r21)
81125114:	e00d883a 	mov	r6,fp
81125118:	b009883a 	mov	r4,r22
8112511c:	112d6080 	call	8112d608 <_ungetc_r>
81125120:	d8c00104 	addi	r3,sp,4
81125124:	1d7ff91e 	bne	r3,r21,8112510c <__reset+0xfb10510c>
81125128:	003a6306 	br	81123ab8 <__reset+0xfb103ab8>
8112512c:	0009883a 	mov	r4,zero
81125130:	112a0680 	call	8112a068 <nanf>
81125134:	a0800015 	stw	r2,0(r20)
81125138:	dc409c15 	stw	r17,624(sp)
8112513c:	003dac06 	br	811247f0 <__reset+0xfb1047f0>
81125140:	d9000104 	addi	r4,sp,4
81125144:	802b883a 	mov	r21,r16
81125148:	243a5b2e 	bgeu	r4,r16,81123ab8 <__reset+0xfb103ab8>
8112514c:	ad7fffc4 	addi	r21,r21,-1
81125150:	a9400007 	ldb	r5,0(r21)
81125154:	e00d883a 	mov	r6,fp
81125158:	b009883a 	mov	r4,r22
8112515c:	112d6080 	call	8112d608 <_ungetc_r>
81125160:	d9400104 	addi	r5,sp,4
81125164:	2d7ff91e 	bne	r5,r21,8112514c <__reset+0xfb10514c>
81125168:	003a5306 	br	81123ab8 <__reset+0xfb103ab8>
8112516c:	112be300 	call	8112be30 <_strtoull_r>
81125170:	003f9d06 	br	81124fe8 <__reset+0xfb104fe8>

81125174 <vfscanf>:
81125174:	00a04574 	movhi	r2,33045
81125178:	defffb04 	addi	sp,sp,-20
8112517c:	10bd6304 	addi	r2,r2,-2676
81125180:	de00012e 	bgeu	sp,et,81125188 <vfscanf+0x14>
81125184:	003b68fa 	trap	3
81125188:	dc000215 	stw	r16,8(sp)
8112518c:	14000017 	ldw	r16,0(r2)
81125190:	dc400315 	stw	r17,12(sp)
81125194:	dfc00415 	stw	ra,16(sp)
81125198:	2023883a 	mov	r17,r4
8112519c:	80000826 	beq	r16,zero,811251c0 <vfscanf+0x4c>
811251a0:	80800e17 	ldw	r2,56(r16)
811251a4:	1000061e 	bne	r2,zero,811251c0 <vfscanf+0x4c>
811251a8:	8009883a 	mov	r4,r16
811251ac:	d9400015 	stw	r5,0(sp)
811251b0:	d9800115 	stw	r6,4(sp)
811251b4:	112748c0 	call	8112748c <__sinit>
811251b8:	d9800117 	ldw	r6,4(sp)
811251bc:	d9400017 	ldw	r5,0(sp)
811251c0:	300f883a 	mov	r7,r6
811251c4:	8009883a 	mov	r4,r16
811251c8:	280d883a 	mov	r6,r5
811251cc:	880b883a 	mov	r5,r17
811251d0:	dfc00417 	ldw	ra,16(sp)
811251d4:	dc400317 	ldw	r17,12(sp)
811251d8:	dc000217 	ldw	r16,8(sp)
811251dc:	dec00504 	addi	sp,sp,20
811251e0:	11239b01 	jmpi	811239b0 <__svfscanf_r>

811251e4 <__svfscanf>:
811251e4:	00a04574 	movhi	r2,33045
811251e8:	10bd6304 	addi	r2,r2,-2676
811251ec:	300f883a 	mov	r7,r6
811251f0:	280d883a 	mov	r6,r5
811251f4:	200b883a 	mov	r5,r4
811251f8:	11000017 	ldw	r4,0(r2)
811251fc:	11239b01 	jmpi	811239b0 <__svfscanf_r>

81125200 <_vfscanf_r>:
81125200:	defffb04 	addi	sp,sp,-20
81125204:	de00012e 	bgeu	sp,et,8112520c <_vfscanf_r+0xc>
81125208:	003b68fa 	trap	3
8112520c:	dc000315 	stw	r16,12(sp)
81125210:	dfc00415 	stw	ra,16(sp)
81125214:	2021883a 	mov	r16,r4
81125218:	20000926 	beq	r4,zero,81125240 <_vfscanf_r+0x40>
8112521c:	20800e17 	ldw	r2,56(r4)
81125220:	1000071e 	bne	r2,zero,81125240 <_vfscanf_r+0x40>
81125224:	d9400015 	stw	r5,0(sp)
81125228:	d9800115 	stw	r6,4(sp)
8112522c:	d9c00215 	stw	r7,8(sp)
81125230:	112748c0 	call	8112748c <__sinit>
81125234:	d9c00217 	ldw	r7,8(sp)
81125238:	d9800117 	ldw	r6,4(sp)
8112523c:	d9400017 	ldw	r5,0(sp)
81125240:	8009883a 	mov	r4,r16
81125244:	dfc00417 	ldw	ra,16(sp)
81125248:	dc000317 	ldw	r16,12(sp)
8112524c:	dec00504 	addi	sp,sp,20
81125250:	11239b01 	jmpi	811239b0 <__svfscanf_r>

81125254 <__swbuf_r>:
81125254:	defffb04 	addi	sp,sp,-20
81125258:	de00012e 	bgeu	sp,et,81125260 <__swbuf_r+0xc>
8112525c:	003b68fa 	trap	3
81125260:	dcc00315 	stw	r19,12(sp)
81125264:	dc800215 	stw	r18,8(sp)
81125268:	dc000015 	stw	r16,0(sp)
8112526c:	dfc00415 	stw	ra,16(sp)
81125270:	dc400115 	stw	r17,4(sp)
81125274:	2025883a 	mov	r18,r4
81125278:	2827883a 	mov	r19,r5
8112527c:	3021883a 	mov	r16,r6
81125280:	20000226 	beq	r4,zero,8112528c <__swbuf_r+0x38>
81125284:	20800e17 	ldw	r2,56(r4)
81125288:	10004226 	beq	r2,zero,81125394 <__swbuf_r+0x140>
8112528c:	80800617 	ldw	r2,24(r16)
81125290:	8100030b 	ldhu	r4,12(r16)
81125294:	80800215 	stw	r2,8(r16)
81125298:	2080020c 	andi	r2,r4,8
8112529c:	10003626 	beq	r2,zero,81125378 <__swbuf_r+0x124>
811252a0:	80c00417 	ldw	r3,16(r16)
811252a4:	18003426 	beq	r3,zero,81125378 <__swbuf_r+0x124>
811252a8:	2088000c 	andi	r2,r4,8192
811252ac:	9c403fcc 	andi	r17,r19,255
811252b0:	10001a26 	beq	r2,zero,8112531c <__swbuf_r+0xc8>
811252b4:	80800017 	ldw	r2,0(r16)
811252b8:	81000517 	ldw	r4,20(r16)
811252bc:	10c7c83a 	sub	r3,r2,r3
811252c0:	1900200e 	bge	r3,r4,81125344 <__swbuf_r+0xf0>
811252c4:	18c00044 	addi	r3,r3,1
811252c8:	81000217 	ldw	r4,8(r16)
811252cc:	11400044 	addi	r5,r2,1
811252d0:	81400015 	stw	r5,0(r16)
811252d4:	213fffc4 	addi	r4,r4,-1
811252d8:	81000215 	stw	r4,8(r16)
811252dc:	14c00005 	stb	r19,0(r2)
811252e0:	80800517 	ldw	r2,20(r16)
811252e4:	10c01e26 	beq	r2,r3,81125360 <__swbuf_r+0x10c>
811252e8:	8080030b 	ldhu	r2,12(r16)
811252ec:	1080004c 	andi	r2,r2,1
811252f0:	10000226 	beq	r2,zero,811252fc <__swbuf_r+0xa8>
811252f4:	00800284 	movi	r2,10
811252f8:	88801926 	beq	r17,r2,81125360 <__swbuf_r+0x10c>
811252fc:	8805883a 	mov	r2,r17
81125300:	dfc00417 	ldw	ra,16(sp)
81125304:	dcc00317 	ldw	r19,12(sp)
81125308:	dc800217 	ldw	r18,8(sp)
8112530c:	dc400117 	ldw	r17,4(sp)
81125310:	dc000017 	ldw	r16,0(sp)
81125314:	dec00504 	addi	sp,sp,20
81125318:	f800283a 	ret
8112531c:	81401917 	ldw	r5,100(r16)
81125320:	00b7ffc4 	movi	r2,-8193
81125324:	21080014 	ori	r4,r4,8192
81125328:	2884703a 	and	r2,r5,r2
8112532c:	80801915 	stw	r2,100(r16)
81125330:	80800017 	ldw	r2,0(r16)
81125334:	8100030d 	sth	r4,12(r16)
81125338:	81000517 	ldw	r4,20(r16)
8112533c:	10c7c83a 	sub	r3,r2,r3
81125340:	193fe016 	blt	r3,r4,811252c4 <__reset+0xfb1052c4>
81125344:	800b883a 	mov	r5,r16
81125348:	9009883a 	mov	r4,r18
8112534c:	11270900 	call	81127090 <_fflush_r>
81125350:	1000071e 	bne	r2,zero,81125370 <__swbuf_r+0x11c>
81125354:	80800017 	ldw	r2,0(r16)
81125358:	00c00044 	movi	r3,1
8112535c:	003fda06 	br	811252c8 <__reset+0xfb1052c8>
81125360:	800b883a 	mov	r5,r16
81125364:	9009883a 	mov	r4,r18
81125368:	11270900 	call	81127090 <_fflush_r>
8112536c:	103fe326 	beq	r2,zero,811252fc <__reset+0xfb1052fc>
81125370:	00bfffc4 	movi	r2,-1
81125374:	003fe206 	br	81125300 <__reset+0xfb105300>
81125378:	800b883a 	mov	r5,r16
8112537c:	9009883a 	mov	r4,r18
81125380:	112541c0 	call	8112541c <__swsetup_r>
81125384:	103ffa1e 	bne	r2,zero,81125370 <__reset+0xfb105370>
81125388:	8100030b 	ldhu	r4,12(r16)
8112538c:	80c00417 	ldw	r3,16(r16)
81125390:	003fc506 	br	811252a8 <__reset+0xfb1052a8>
81125394:	112748c0 	call	8112748c <__sinit>
81125398:	003fbc06 	br	8112528c <__reset+0xfb10528c>

8112539c <__swbuf>:
8112539c:	00a04574 	movhi	r2,33045
811253a0:	10bd6304 	addi	r2,r2,-2676
811253a4:	280d883a 	mov	r6,r5
811253a8:	200b883a 	mov	r5,r4
811253ac:	11000017 	ldw	r4,0(r2)
811253b0:	11252541 	jmpi	81125254 <__swbuf_r>

811253b4 <_write_r>:
811253b4:	defffd04 	addi	sp,sp,-12
811253b8:	de00012e 	bgeu	sp,et,811253c0 <_write_r+0xc>
811253bc:	003b68fa 	trap	3
811253c0:	2805883a 	mov	r2,r5
811253c4:	dc000015 	stw	r16,0(sp)
811253c8:	04204574 	movhi	r16,33045
811253cc:	dc400115 	stw	r17,4(sp)
811253d0:	300b883a 	mov	r5,r6
811253d4:	843dd504 	addi	r16,r16,-2220
811253d8:	2023883a 	mov	r17,r4
811253dc:	380d883a 	mov	r6,r7
811253e0:	1009883a 	mov	r4,r2
811253e4:	dfc00215 	stw	ra,8(sp)
811253e8:	80000015 	stw	zero,0(r16)
811253ec:	1134a6c0 	call	81134a6c <write>
811253f0:	00ffffc4 	movi	r3,-1
811253f4:	10c00526 	beq	r2,r3,8112540c <_write_r+0x58>
811253f8:	dfc00217 	ldw	ra,8(sp)
811253fc:	dc400117 	ldw	r17,4(sp)
81125400:	dc000017 	ldw	r16,0(sp)
81125404:	dec00304 	addi	sp,sp,12
81125408:	f800283a 	ret
8112540c:	80c00017 	ldw	r3,0(r16)
81125410:	183ff926 	beq	r3,zero,811253f8 <__reset+0xfb1053f8>
81125414:	88c00015 	stw	r3,0(r17)
81125418:	003ff706 	br	811253f8 <__reset+0xfb1053f8>

8112541c <__swsetup_r>:
8112541c:	00a04574 	movhi	r2,33045
81125420:	defffd04 	addi	sp,sp,-12
81125424:	10bd6304 	addi	r2,r2,-2676
81125428:	de00012e 	bgeu	sp,et,81125430 <__swsetup_r+0x14>
8112542c:	003b68fa 	trap	3
81125430:	dc400115 	stw	r17,4(sp)
81125434:	2023883a 	mov	r17,r4
81125438:	11000017 	ldw	r4,0(r2)
8112543c:	dc000015 	stw	r16,0(sp)
81125440:	dfc00215 	stw	ra,8(sp)
81125444:	2821883a 	mov	r16,r5
81125448:	20000226 	beq	r4,zero,81125454 <__swsetup_r+0x38>
8112544c:	20800e17 	ldw	r2,56(r4)
81125450:	10003126 	beq	r2,zero,81125518 <__swsetup_r+0xfc>
81125454:	8080030b 	ldhu	r2,12(r16)
81125458:	10c0020c 	andi	r3,r2,8
8112545c:	1009883a 	mov	r4,r2
81125460:	18000f26 	beq	r3,zero,811254a0 <__swsetup_r+0x84>
81125464:	80c00417 	ldw	r3,16(r16)
81125468:	18001526 	beq	r3,zero,811254c0 <__swsetup_r+0xa4>
8112546c:	1100004c 	andi	r4,r2,1
81125470:	20001c1e 	bne	r4,zero,811254e4 <__swsetup_r+0xc8>
81125474:	1080008c 	andi	r2,r2,2
81125478:	1000291e 	bne	r2,zero,81125520 <__swsetup_r+0x104>
8112547c:	80800517 	ldw	r2,20(r16)
81125480:	80800215 	stw	r2,8(r16)
81125484:	18001c26 	beq	r3,zero,811254f8 <__swsetup_r+0xdc>
81125488:	0005883a 	mov	r2,zero
8112548c:	dfc00217 	ldw	ra,8(sp)
81125490:	dc400117 	ldw	r17,4(sp)
81125494:	dc000017 	ldw	r16,0(sp)
81125498:	dec00304 	addi	sp,sp,12
8112549c:	f800283a 	ret
811254a0:	2080040c 	andi	r2,r4,16
811254a4:	10002e26 	beq	r2,zero,81125560 <__swsetup_r+0x144>
811254a8:	2080010c 	andi	r2,r4,4
811254ac:	10001e1e 	bne	r2,zero,81125528 <__swsetup_r+0x10c>
811254b0:	80c00417 	ldw	r3,16(r16)
811254b4:	20800214 	ori	r2,r4,8
811254b8:	8080030d 	sth	r2,12(r16)
811254bc:	183feb1e 	bne	r3,zero,8112546c <__reset+0xfb10546c>
811254c0:	1100a00c 	andi	r4,r2,640
811254c4:	01408004 	movi	r5,512
811254c8:	217fe826 	beq	r4,r5,8112546c <__reset+0xfb10546c>
811254cc:	800b883a 	mov	r5,r16
811254d0:	8809883a 	mov	r4,r17
811254d4:	111dcec0 	call	8111dcec <__smakebuf_r>
811254d8:	8080030b 	ldhu	r2,12(r16)
811254dc:	80c00417 	ldw	r3,16(r16)
811254e0:	003fe206 	br	8112546c <__reset+0xfb10546c>
811254e4:	80800517 	ldw	r2,20(r16)
811254e8:	80000215 	stw	zero,8(r16)
811254ec:	0085c83a 	sub	r2,zero,r2
811254f0:	80800615 	stw	r2,24(r16)
811254f4:	183fe41e 	bne	r3,zero,81125488 <__reset+0xfb105488>
811254f8:	80c0030b 	ldhu	r3,12(r16)
811254fc:	0005883a 	mov	r2,zero
81125500:	1900200c 	andi	r4,r3,128
81125504:	203fe126 	beq	r4,zero,8112548c <__reset+0xfb10548c>
81125508:	18c01014 	ori	r3,r3,64
8112550c:	80c0030d 	sth	r3,12(r16)
81125510:	00bfffc4 	movi	r2,-1
81125514:	003fdd06 	br	8112548c <__reset+0xfb10548c>
81125518:	112748c0 	call	8112748c <__sinit>
8112551c:	003fcd06 	br	81125454 <__reset+0xfb105454>
81125520:	0005883a 	mov	r2,zero
81125524:	003fd606 	br	81125480 <__reset+0xfb105480>
81125528:	81400c17 	ldw	r5,48(r16)
8112552c:	28000626 	beq	r5,zero,81125548 <__swsetup_r+0x12c>
81125530:	80801004 	addi	r2,r16,64
81125534:	28800326 	beq	r5,r2,81125544 <__swsetup_r+0x128>
81125538:	8809883a 	mov	r4,r17
8112553c:	11279240 	call	81127924 <_free_r>
81125540:	8100030b 	ldhu	r4,12(r16)
81125544:	80000c15 	stw	zero,48(r16)
81125548:	80c00417 	ldw	r3,16(r16)
8112554c:	00bff6c4 	movi	r2,-37
81125550:	1108703a 	and	r4,r2,r4
81125554:	80000115 	stw	zero,4(r16)
81125558:	80c00015 	stw	r3,0(r16)
8112555c:	003fd506 	br	811254b4 <__reset+0xfb1054b4>
81125560:	00800244 	movi	r2,9
81125564:	88800015 	stw	r2,0(r17)
81125568:	20801014 	ori	r2,r4,64
8112556c:	8080030d 	sth	r2,12(r16)
81125570:	00bfffc4 	movi	r2,-1
81125574:	003fc506 	br	8112548c <__reset+0xfb10548c>

81125578 <_close_r>:
81125578:	defffd04 	addi	sp,sp,-12
8112557c:	de00012e 	bgeu	sp,et,81125584 <_close_r+0xc>
81125580:	003b68fa 	trap	3
81125584:	dc000015 	stw	r16,0(sp)
81125588:	04204574 	movhi	r16,33045
8112558c:	dc400115 	stw	r17,4(sp)
81125590:	843dd504 	addi	r16,r16,-2220
81125594:	2023883a 	mov	r17,r4
81125598:	2809883a 	mov	r4,r5
8112559c:	dfc00215 	stw	ra,8(sp)
811255a0:	80000015 	stw	zero,0(r16)
811255a4:	1132fec0 	call	81132fec <close>
811255a8:	00ffffc4 	movi	r3,-1
811255ac:	10c00526 	beq	r2,r3,811255c4 <_close_r+0x4c>
811255b0:	dfc00217 	ldw	ra,8(sp)
811255b4:	dc400117 	ldw	r17,4(sp)
811255b8:	dc000017 	ldw	r16,0(sp)
811255bc:	dec00304 	addi	sp,sp,12
811255c0:	f800283a 	ret
811255c4:	80c00017 	ldw	r3,0(r16)
811255c8:	183ff926 	beq	r3,zero,811255b0 <__reset+0xfb1055b0>
811255cc:	88c00015 	stw	r3,0(r17)
811255d0:	003ff706 	br	811255b0 <__reset+0xfb1055b0>

811255d4 <quorem>:
811255d4:	defff704 	addi	sp,sp,-36
811255d8:	de00012e 	bgeu	sp,et,811255e0 <quorem+0xc>
811255dc:	003b68fa 	trap	3
811255e0:	dc800215 	stw	r18,8(sp)
811255e4:	20800417 	ldw	r2,16(r4)
811255e8:	2c800417 	ldw	r18,16(r5)
811255ec:	dfc00815 	stw	ra,32(sp)
811255f0:	ddc00715 	stw	r23,28(sp)
811255f4:	dd800615 	stw	r22,24(sp)
811255f8:	dd400515 	stw	r21,20(sp)
811255fc:	dd000415 	stw	r20,16(sp)
81125600:	dcc00315 	stw	r19,12(sp)
81125604:	dc400115 	stw	r17,4(sp)
81125608:	dc000015 	stw	r16,0(sp)
8112560c:	14807116 	blt	r2,r18,811257d4 <quorem+0x200>
81125610:	94bfffc4 	addi	r18,r18,-1
81125614:	94ad883a 	add	r22,r18,r18
81125618:	b5ad883a 	add	r22,r22,r22
8112561c:	2c400504 	addi	r17,r5,20
81125620:	8da9883a 	add	r20,r17,r22
81125624:	25400504 	addi	r21,r4,20
81125628:	282f883a 	mov	r23,r5
8112562c:	adad883a 	add	r22,r21,r22
81125630:	a1400017 	ldw	r5,0(r20)
81125634:	2021883a 	mov	r16,r4
81125638:	b1000017 	ldw	r4,0(r22)
8112563c:	29400044 	addi	r5,r5,1
81125640:	1130cac0 	call	81130cac <__udivsi3>
81125644:	1027883a 	mov	r19,r2
81125648:	10002c26 	beq	r2,zero,811256fc <quorem+0x128>
8112564c:	a813883a 	mov	r9,r21
81125650:	880b883a 	mov	r5,r17
81125654:	0009883a 	mov	r4,zero
81125658:	000d883a 	mov	r6,zero
8112565c:	2a000017 	ldw	r8,0(r5)
81125660:	49c00017 	ldw	r7,0(r9)
81125664:	29400104 	addi	r5,r5,4
81125668:	40bfffcc 	andi	r2,r8,65535
8112566c:	14c5383a 	mul	r2,r2,r19
81125670:	4010d43a 	srli	r8,r8,16
81125674:	38ffffcc 	andi	r3,r7,65535
81125678:	1105883a 	add	r2,r2,r4
8112567c:	1008d43a 	srli	r4,r2,16
81125680:	44d1383a 	mul	r8,r8,r19
81125684:	198d883a 	add	r6,r3,r6
81125688:	10ffffcc 	andi	r3,r2,65535
8112568c:	30c7c83a 	sub	r3,r6,r3
81125690:	380ed43a 	srli	r7,r7,16
81125694:	4105883a 	add	r2,r8,r4
81125698:	180dd43a 	srai	r6,r3,16
8112569c:	113fffcc 	andi	r4,r2,65535
811256a0:	390fc83a 	sub	r7,r7,r4
811256a4:	398d883a 	add	r6,r7,r6
811256a8:	300e943a 	slli	r7,r6,16
811256ac:	18ffffcc 	andi	r3,r3,65535
811256b0:	1008d43a 	srli	r4,r2,16
811256b4:	38ceb03a 	or	r7,r7,r3
811256b8:	49c00015 	stw	r7,0(r9)
811256bc:	300dd43a 	srai	r6,r6,16
811256c0:	4a400104 	addi	r9,r9,4
811256c4:	a17fe52e 	bgeu	r20,r5,8112565c <__reset+0xfb10565c>
811256c8:	b0800017 	ldw	r2,0(r22)
811256cc:	10000b1e 	bne	r2,zero,811256fc <quorem+0x128>
811256d0:	b0bfff04 	addi	r2,r22,-4
811256d4:	a880082e 	bgeu	r21,r2,811256f8 <quorem+0x124>
811256d8:	b0ffff17 	ldw	r3,-4(r22)
811256dc:	18000326 	beq	r3,zero,811256ec <quorem+0x118>
811256e0:	00000506 	br	811256f8 <quorem+0x124>
811256e4:	10c00017 	ldw	r3,0(r2)
811256e8:	1800031e 	bne	r3,zero,811256f8 <quorem+0x124>
811256ec:	10bfff04 	addi	r2,r2,-4
811256f0:	94bfffc4 	addi	r18,r18,-1
811256f4:	a8bffb36 	bltu	r21,r2,811256e4 <__reset+0xfb1056e4>
811256f8:	84800415 	stw	r18,16(r16)
811256fc:	b80b883a 	mov	r5,r23
81125700:	8009883a 	mov	r4,r16
81125704:	11291f40 	call	811291f4 <__mcmp>
81125708:	10002616 	blt	r2,zero,811257a4 <quorem+0x1d0>
8112570c:	9cc00044 	addi	r19,r19,1
81125710:	a805883a 	mov	r2,r21
81125714:	000b883a 	mov	r5,zero
81125718:	11000017 	ldw	r4,0(r2)
8112571c:	89800017 	ldw	r6,0(r17)
81125720:	10800104 	addi	r2,r2,4
81125724:	20ffffcc 	andi	r3,r4,65535
81125728:	194b883a 	add	r5,r3,r5
8112572c:	30ffffcc 	andi	r3,r6,65535
81125730:	28c7c83a 	sub	r3,r5,r3
81125734:	300cd43a 	srli	r6,r6,16
81125738:	2008d43a 	srli	r4,r4,16
8112573c:	180bd43a 	srai	r5,r3,16
81125740:	18ffffcc 	andi	r3,r3,65535
81125744:	2189c83a 	sub	r4,r4,r6
81125748:	2149883a 	add	r4,r4,r5
8112574c:	200c943a 	slli	r6,r4,16
81125750:	8c400104 	addi	r17,r17,4
81125754:	200bd43a 	srai	r5,r4,16
81125758:	30c6b03a 	or	r3,r6,r3
8112575c:	10ffff15 	stw	r3,-4(r2)
81125760:	a47fed2e 	bgeu	r20,r17,81125718 <__reset+0xfb105718>
81125764:	9485883a 	add	r2,r18,r18
81125768:	1085883a 	add	r2,r2,r2
8112576c:	a887883a 	add	r3,r21,r2
81125770:	18800017 	ldw	r2,0(r3)
81125774:	10000b1e 	bne	r2,zero,811257a4 <quorem+0x1d0>
81125778:	18bfff04 	addi	r2,r3,-4
8112577c:	a880082e 	bgeu	r21,r2,811257a0 <quorem+0x1cc>
81125780:	18ffff17 	ldw	r3,-4(r3)
81125784:	18000326 	beq	r3,zero,81125794 <quorem+0x1c0>
81125788:	00000506 	br	811257a0 <quorem+0x1cc>
8112578c:	10c00017 	ldw	r3,0(r2)
81125790:	1800031e 	bne	r3,zero,811257a0 <quorem+0x1cc>
81125794:	10bfff04 	addi	r2,r2,-4
81125798:	94bfffc4 	addi	r18,r18,-1
8112579c:	a8bffb36 	bltu	r21,r2,8112578c <__reset+0xfb10578c>
811257a0:	84800415 	stw	r18,16(r16)
811257a4:	9805883a 	mov	r2,r19
811257a8:	dfc00817 	ldw	ra,32(sp)
811257ac:	ddc00717 	ldw	r23,28(sp)
811257b0:	dd800617 	ldw	r22,24(sp)
811257b4:	dd400517 	ldw	r21,20(sp)
811257b8:	dd000417 	ldw	r20,16(sp)
811257bc:	dcc00317 	ldw	r19,12(sp)
811257c0:	dc800217 	ldw	r18,8(sp)
811257c4:	dc400117 	ldw	r17,4(sp)
811257c8:	dc000017 	ldw	r16,0(sp)
811257cc:	dec00904 	addi	sp,sp,36
811257d0:	f800283a 	ret
811257d4:	0005883a 	mov	r2,zero
811257d8:	003ff306 	br	811257a8 <__reset+0xfb1057a8>

811257dc <_dtoa_r>:
811257dc:	deffde04 	addi	sp,sp,-136
811257e0:	de00012e 	bgeu	sp,et,811257e8 <_dtoa_r+0xc>
811257e4:	003b68fa 	trap	3
811257e8:	20801017 	ldw	r2,64(r4)
811257ec:	df002015 	stw	fp,128(sp)
811257f0:	dcc01b15 	stw	r19,108(sp)
811257f4:	dc801a15 	stw	r18,104(sp)
811257f8:	dc401915 	stw	r17,100(sp)
811257fc:	dc001815 	stw	r16,96(sp)
81125800:	dfc02115 	stw	ra,132(sp)
81125804:	ddc01f15 	stw	r23,124(sp)
81125808:	dd801e15 	stw	r22,120(sp)
8112580c:	dd401d15 	stw	r21,116(sp)
81125810:	dd001c15 	stw	r20,112(sp)
81125814:	d9c00315 	stw	r7,12(sp)
81125818:	2039883a 	mov	fp,r4
8112581c:	3023883a 	mov	r17,r6
81125820:	2825883a 	mov	r18,r5
81125824:	dc002417 	ldw	r16,144(sp)
81125828:	3027883a 	mov	r19,r6
8112582c:	10000826 	beq	r2,zero,81125850 <_dtoa_r+0x74>
81125830:	21801117 	ldw	r6,68(r4)
81125834:	00c00044 	movi	r3,1
81125838:	100b883a 	mov	r5,r2
8112583c:	1986983a 	sll	r3,r3,r6
81125840:	11800115 	stw	r6,4(r2)
81125844:	10c00215 	stw	r3,8(r2)
81125848:	11289a40 	call	811289a4 <_Bfree>
8112584c:	e0001015 	stw	zero,64(fp)
81125850:	88002e16 	blt	r17,zero,8112590c <_dtoa_r+0x130>
81125854:	80000015 	stw	zero,0(r16)
81125858:	889ffc2c 	andhi	r2,r17,32752
8112585c:	00dffc34 	movhi	r3,32752
81125860:	10c01c26 	beq	r2,r3,811258d4 <_dtoa_r+0xf8>
81125864:	000d883a 	mov	r6,zero
81125868:	000f883a 	mov	r7,zero
8112586c:	9009883a 	mov	r4,r18
81125870:	980b883a 	mov	r5,r19
81125874:	11321080 	call	81132108 <__eqdf2>
81125878:	10002b1e 	bne	r2,zero,81125928 <_dtoa_r+0x14c>
8112587c:	d9c02317 	ldw	r7,140(sp)
81125880:	00800044 	movi	r2,1
81125884:	38800015 	stw	r2,0(r7)
81125888:	d8802517 	ldw	r2,148(sp)
8112588c:	10019e26 	beq	r2,zero,81125f08 <_dtoa_r+0x72c>
81125890:	d8c02517 	ldw	r3,148(sp)
81125894:	00a04574 	movhi	r2,33045
81125898:	10b39b44 	addi	r2,r2,-12691
8112589c:	18800015 	stw	r2,0(r3)
811258a0:	10bfffc4 	addi	r2,r2,-1
811258a4:	dfc02117 	ldw	ra,132(sp)
811258a8:	df002017 	ldw	fp,128(sp)
811258ac:	ddc01f17 	ldw	r23,124(sp)
811258b0:	dd801e17 	ldw	r22,120(sp)
811258b4:	dd401d17 	ldw	r21,116(sp)
811258b8:	dd001c17 	ldw	r20,112(sp)
811258bc:	dcc01b17 	ldw	r19,108(sp)
811258c0:	dc801a17 	ldw	r18,104(sp)
811258c4:	dc401917 	ldw	r17,100(sp)
811258c8:	dc001817 	ldw	r16,96(sp)
811258cc:	dec02204 	addi	sp,sp,136
811258d0:	f800283a 	ret
811258d4:	d8c02317 	ldw	r3,140(sp)
811258d8:	0089c3c4 	movi	r2,9999
811258dc:	18800015 	stw	r2,0(r3)
811258e0:	90017726 	beq	r18,zero,81125ec0 <_dtoa_r+0x6e4>
811258e4:	00a04574 	movhi	r2,33045
811258e8:	10b3b904 	addi	r2,r2,-12572
811258ec:	d9002517 	ldw	r4,148(sp)
811258f0:	203fec26 	beq	r4,zero,811258a4 <__reset+0xfb1058a4>
811258f4:	10c000c7 	ldb	r3,3(r2)
811258f8:	1801781e 	bne	r3,zero,81125edc <_dtoa_r+0x700>
811258fc:	10c000c4 	addi	r3,r2,3
81125900:	d9802517 	ldw	r6,148(sp)
81125904:	30c00015 	stw	r3,0(r6)
81125908:	003fe606 	br	811258a4 <__reset+0xfb1058a4>
8112590c:	04e00034 	movhi	r19,32768
81125910:	9cffffc4 	addi	r19,r19,-1
81125914:	00800044 	movi	r2,1
81125918:	8ce6703a 	and	r19,r17,r19
8112591c:	80800015 	stw	r2,0(r16)
81125920:	9823883a 	mov	r17,r19
81125924:	003fcc06 	br	81125858 <__reset+0xfb105858>
81125928:	d8800204 	addi	r2,sp,8
8112592c:	d8800015 	stw	r2,0(sp)
81125930:	d9c00104 	addi	r7,sp,4
81125934:	900b883a 	mov	r5,r18
81125938:	980d883a 	mov	r6,r19
8112593c:	e009883a 	mov	r4,fp
81125940:	8820d53a 	srli	r16,r17,20
81125944:	11295d00 	call	811295d0 <__d2b>
81125948:	d8800915 	stw	r2,36(sp)
8112594c:	8001651e 	bne	r16,zero,81125ee4 <_dtoa_r+0x708>
81125950:	dd800217 	ldw	r22,8(sp)
81125954:	dc000117 	ldw	r16,4(sp)
81125958:	00800804 	movi	r2,32
8112595c:	b421883a 	add	r16,r22,r16
81125960:	80c10c84 	addi	r3,r16,1074
81125964:	10c2d10e 	bge	r2,r3,811264ac <_dtoa_r+0xcd0>
81125968:	00801004 	movi	r2,64
8112596c:	81010484 	addi	r4,r16,1042
81125970:	10c7c83a 	sub	r3,r2,r3
81125974:	9108d83a 	srl	r4,r18,r4
81125978:	88e2983a 	sll	r17,r17,r3
8112597c:	2448b03a 	or	r4,r4,r17
81125980:	1132dc80 	call	81132dc8 <__floatunsidf>
81125984:	017f8434 	movhi	r5,65040
81125988:	01800044 	movi	r6,1
8112598c:	1009883a 	mov	r4,r2
81125990:	194b883a 	add	r5,r3,r5
81125994:	843fffc4 	addi	r16,r16,-1
81125998:	d9801115 	stw	r6,68(sp)
8112599c:	000d883a 	mov	r6,zero
811259a0:	01cffe34 	movhi	r7,16376
811259a4:	11323600 	call	81132360 <__subdf3>
811259a8:	0198dbf4 	movhi	r6,25455
811259ac:	01cff4f4 	movhi	r7,16339
811259b0:	3190d844 	addi	r6,r6,17249
811259b4:	39e1e9c4 	addi	r7,r7,-30809
811259b8:	1009883a 	mov	r4,r2
811259bc:	180b883a 	mov	r5,r3
811259c0:	111ca740 	call	8111ca74 <__muldf3>
811259c4:	01a2d874 	movhi	r6,35681
811259c8:	01cff1f4 	movhi	r7,16327
811259cc:	31b22cc4 	addi	r6,r6,-14157
811259d0:	39e28a04 	addi	r7,r7,-30168
811259d4:	180b883a 	mov	r5,r3
811259d8:	1009883a 	mov	r4,r2
811259dc:	1130f640 	call	81130f64 <__adddf3>
811259e0:	8009883a 	mov	r4,r16
811259e4:	1029883a 	mov	r20,r2
811259e8:	1823883a 	mov	r17,r3
811259ec:	1132ce40 	call	81132ce4 <__floatsidf>
811259f0:	019427f4 	movhi	r6,20639
811259f4:	01cff4f4 	movhi	r7,16339
811259f8:	319e7ec4 	addi	r6,r6,31227
811259fc:	39d104c4 	addi	r7,r7,17427
81125a00:	1009883a 	mov	r4,r2
81125a04:	180b883a 	mov	r5,r3
81125a08:	111ca740 	call	8111ca74 <__muldf3>
81125a0c:	100d883a 	mov	r6,r2
81125a10:	180f883a 	mov	r7,r3
81125a14:	a009883a 	mov	r4,r20
81125a18:	880b883a 	mov	r5,r17
81125a1c:	1130f640 	call	81130f64 <__adddf3>
81125a20:	1009883a 	mov	r4,r2
81125a24:	180b883a 	mov	r5,r3
81125a28:	1029883a 	mov	r20,r2
81125a2c:	1823883a 	mov	r17,r3
81125a30:	1132c640 	call	81132c64 <__fixdfsi>
81125a34:	000d883a 	mov	r6,zero
81125a38:	000f883a 	mov	r7,zero
81125a3c:	a009883a 	mov	r4,r20
81125a40:	880b883a 	mov	r5,r17
81125a44:	d8800515 	stw	r2,20(sp)
81125a48:	113226c0 	call	8113226c <__ledf2>
81125a4c:	10028716 	blt	r2,zero,8112646c <_dtoa_r+0xc90>
81125a50:	d8c00517 	ldw	r3,20(sp)
81125a54:	00800584 	movi	r2,22
81125a58:	10c27536 	bltu	r2,r3,81126430 <_dtoa_r+0xc54>
81125a5c:	180490fa 	slli	r2,r3,3
81125a60:	00e04574 	movhi	r3,33045
81125a64:	18f3d404 	addi	r3,r3,-12464
81125a68:	1885883a 	add	r2,r3,r2
81125a6c:	11000017 	ldw	r4,0(r2)
81125a70:	11400117 	ldw	r5,4(r2)
81125a74:	900d883a 	mov	r6,r18
81125a78:	980f883a 	mov	r7,r19
81125a7c:	11321900 	call	81132190 <__gedf2>
81125a80:	00828d0e 	bge	zero,r2,811264b8 <_dtoa_r+0xcdc>
81125a84:	d9000517 	ldw	r4,20(sp)
81125a88:	d8000e15 	stw	zero,56(sp)
81125a8c:	213fffc4 	addi	r4,r4,-1
81125a90:	d9000515 	stw	r4,20(sp)
81125a94:	b42dc83a 	sub	r22,r22,r16
81125a98:	b5bfffc4 	addi	r22,r22,-1
81125a9c:	b0026f16 	blt	r22,zero,8112645c <_dtoa_r+0xc80>
81125aa0:	d8000815 	stw	zero,32(sp)
81125aa4:	d9c00517 	ldw	r7,20(sp)
81125aa8:	38026416 	blt	r7,zero,8112643c <_dtoa_r+0xc60>
81125aac:	b1ed883a 	add	r22,r22,r7
81125ab0:	d9c00d15 	stw	r7,52(sp)
81125ab4:	d8000a15 	stw	zero,40(sp)
81125ab8:	d9800317 	ldw	r6,12(sp)
81125abc:	00800244 	movi	r2,9
81125ac0:	11811436 	bltu	r2,r6,81125f14 <_dtoa_r+0x738>
81125ac4:	00800144 	movi	r2,5
81125ac8:	1184e10e 	bge	r2,r6,81126e50 <_dtoa_r+0x1674>
81125acc:	31bfff04 	addi	r6,r6,-4
81125ad0:	d9800315 	stw	r6,12(sp)
81125ad4:	0023883a 	mov	r17,zero
81125ad8:	d9800317 	ldw	r6,12(sp)
81125adc:	008000c4 	movi	r2,3
81125ae0:	30836726 	beq	r6,r2,81126880 <_dtoa_r+0x10a4>
81125ae4:	1183410e 	bge	r2,r6,811267ec <_dtoa_r+0x1010>
81125ae8:	d9c00317 	ldw	r7,12(sp)
81125aec:	00800104 	movi	r2,4
81125af0:	38827c26 	beq	r7,r2,811264e4 <_dtoa_r+0xd08>
81125af4:	00800144 	movi	r2,5
81125af8:	3884c41e 	bne	r7,r2,81126e0c <_dtoa_r+0x1630>
81125afc:	00800044 	movi	r2,1
81125b00:	d8800b15 	stw	r2,44(sp)
81125b04:	d8c00517 	ldw	r3,20(sp)
81125b08:	d9002217 	ldw	r4,136(sp)
81125b0c:	1907883a 	add	r3,r3,r4
81125b10:	19800044 	addi	r6,r3,1
81125b14:	d8c00c15 	stw	r3,48(sp)
81125b18:	d9800615 	stw	r6,24(sp)
81125b1c:	0183a40e 	bge	zero,r6,811269b0 <_dtoa_r+0x11d4>
81125b20:	d9800617 	ldw	r6,24(sp)
81125b24:	3021883a 	mov	r16,r6
81125b28:	e0001115 	stw	zero,68(fp)
81125b2c:	008005c4 	movi	r2,23
81125b30:	1184c92e 	bgeu	r2,r6,81126e58 <_dtoa_r+0x167c>
81125b34:	00c00044 	movi	r3,1
81125b38:	00800104 	movi	r2,4
81125b3c:	1085883a 	add	r2,r2,r2
81125b40:	11000504 	addi	r4,r2,20
81125b44:	180b883a 	mov	r5,r3
81125b48:	18c00044 	addi	r3,r3,1
81125b4c:	313ffb2e 	bgeu	r6,r4,81125b3c <__reset+0xfb105b3c>
81125b50:	e1401115 	stw	r5,68(fp)
81125b54:	e009883a 	mov	r4,fp
81125b58:	11288f40 	call	811288f4 <_Balloc>
81125b5c:	d8800715 	stw	r2,28(sp)
81125b60:	e0801015 	stw	r2,64(fp)
81125b64:	00800384 	movi	r2,14
81125b68:	1400f736 	bltu	r2,r16,81125f48 <_dtoa_r+0x76c>
81125b6c:	8800f626 	beq	r17,zero,81125f48 <_dtoa_r+0x76c>
81125b70:	d9c00517 	ldw	r7,20(sp)
81125b74:	01c39a0e 	bge	zero,r7,811269e0 <_dtoa_r+0x1204>
81125b78:	388003cc 	andi	r2,r7,15
81125b7c:	100490fa 	slli	r2,r2,3
81125b80:	382bd13a 	srai	r21,r7,4
81125b84:	00e04574 	movhi	r3,33045
81125b88:	18f3d404 	addi	r3,r3,-12464
81125b8c:	1885883a 	add	r2,r3,r2
81125b90:	a8c0040c 	andi	r3,r21,16
81125b94:	12400017 	ldw	r9,0(r2)
81125b98:	12000117 	ldw	r8,4(r2)
81125b9c:	18037926 	beq	r3,zero,81126984 <_dtoa_r+0x11a8>
81125ba0:	00a04574 	movhi	r2,33045
81125ba4:	10b3ca04 	addi	r2,r2,-12504
81125ba8:	11800817 	ldw	r6,32(r2)
81125bac:	11c00917 	ldw	r7,36(r2)
81125bb0:	9009883a 	mov	r4,r18
81125bb4:	980b883a 	mov	r5,r19
81125bb8:	da001715 	stw	r8,92(sp)
81125bbc:	da401615 	stw	r9,88(sp)
81125bc0:	11318180 	call	81131818 <__divdf3>
81125bc4:	da001717 	ldw	r8,92(sp)
81125bc8:	da401617 	ldw	r9,88(sp)
81125bcc:	ad4003cc 	andi	r21,r21,15
81125bd0:	040000c4 	movi	r16,3
81125bd4:	1023883a 	mov	r17,r2
81125bd8:	1829883a 	mov	r20,r3
81125bdc:	a8001126 	beq	r21,zero,81125c24 <_dtoa_r+0x448>
81125be0:	05e04574 	movhi	r23,33045
81125be4:	bdf3ca04 	addi	r23,r23,-12504
81125be8:	4805883a 	mov	r2,r9
81125bec:	4007883a 	mov	r3,r8
81125bf0:	a980004c 	andi	r6,r21,1
81125bf4:	1009883a 	mov	r4,r2
81125bf8:	a82bd07a 	srai	r21,r21,1
81125bfc:	180b883a 	mov	r5,r3
81125c00:	30000426 	beq	r6,zero,81125c14 <_dtoa_r+0x438>
81125c04:	b9800017 	ldw	r6,0(r23)
81125c08:	b9c00117 	ldw	r7,4(r23)
81125c0c:	84000044 	addi	r16,r16,1
81125c10:	111ca740 	call	8111ca74 <__muldf3>
81125c14:	bdc00204 	addi	r23,r23,8
81125c18:	a83ff51e 	bne	r21,zero,81125bf0 <__reset+0xfb105bf0>
81125c1c:	1013883a 	mov	r9,r2
81125c20:	1811883a 	mov	r8,r3
81125c24:	480d883a 	mov	r6,r9
81125c28:	400f883a 	mov	r7,r8
81125c2c:	8809883a 	mov	r4,r17
81125c30:	a00b883a 	mov	r5,r20
81125c34:	11318180 	call	81131818 <__divdf3>
81125c38:	d8800f15 	stw	r2,60(sp)
81125c3c:	d8c01015 	stw	r3,64(sp)
81125c40:	d8c00e17 	ldw	r3,56(sp)
81125c44:	18000626 	beq	r3,zero,81125c60 <_dtoa_r+0x484>
81125c48:	d9000f17 	ldw	r4,60(sp)
81125c4c:	d9401017 	ldw	r5,64(sp)
81125c50:	000d883a 	mov	r6,zero
81125c54:	01cffc34 	movhi	r7,16368
81125c58:	113226c0 	call	8113226c <__ledf2>
81125c5c:	10040b16 	blt	r2,zero,81126c8c <_dtoa_r+0x14b0>
81125c60:	8009883a 	mov	r4,r16
81125c64:	1132ce40 	call	81132ce4 <__floatsidf>
81125c68:	d9800f17 	ldw	r6,60(sp)
81125c6c:	d9c01017 	ldw	r7,64(sp)
81125c70:	1009883a 	mov	r4,r2
81125c74:	180b883a 	mov	r5,r3
81125c78:	111ca740 	call	8111ca74 <__muldf3>
81125c7c:	000d883a 	mov	r6,zero
81125c80:	01d00734 	movhi	r7,16412
81125c84:	1009883a 	mov	r4,r2
81125c88:	180b883a 	mov	r5,r3
81125c8c:	1130f640 	call	81130f64 <__adddf3>
81125c90:	1021883a 	mov	r16,r2
81125c94:	d8800617 	ldw	r2,24(sp)
81125c98:	047f3034 	movhi	r17,64704
81125c9c:	1c63883a 	add	r17,r3,r17
81125ca0:	10031826 	beq	r2,zero,81126904 <_dtoa_r+0x1128>
81125ca4:	d8c00517 	ldw	r3,20(sp)
81125ca8:	db000617 	ldw	r12,24(sp)
81125cac:	d8c01315 	stw	r3,76(sp)
81125cb0:	d9000b17 	ldw	r4,44(sp)
81125cb4:	20038f26 	beq	r4,zero,81126af4 <_dtoa_r+0x1318>
81125cb8:	60bfffc4 	addi	r2,r12,-1
81125cbc:	100490fa 	slli	r2,r2,3
81125cc0:	00e04574 	movhi	r3,33045
81125cc4:	18f3d404 	addi	r3,r3,-12464
81125cc8:	1885883a 	add	r2,r3,r2
81125ccc:	11800017 	ldw	r6,0(r2)
81125cd0:	11c00117 	ldw	r7,4(r2)
81125cd4:	d8800717 	ldw	r2,28(sp)
81125cd8:	0009883a 	mov	r4,zero
81125cdc:	014ff834 	movhi	r5,16352
81125ce0:	db001615 	stw	r12,88(sp)
81125ce4:	15c00044 	addi	r23,r2,1
81125ce8:	11318180 	call	81131818 <__divdf3>
81125cec:	800d883a 	mov	r6,r16
81125cf0:	880f883a 	mov	r7,r17
81125cf4:	1009883a 	mov	r4,r2
81125cf8:	180b883a 	mov	r5,r3
81125cfc:	11323600 	call	81132360 <__subdf3>
81125d00:	d9401017 	ldw	r5,64(sp)
81125d04:	d9000f17 	ldw	r4,60(sp)
81125d08:	102b883a 	mov	r21,r2
81125d0c:	d8c01215 	stw	r3,72(sp)
81125d10:	1132c640 	call	81132c64 <__fixdfsi>
81125d14:	1009883a 	mov	r4,r2
81125d18:	1029883a 	mov	r20,r2
81125d1c:	1132ce40 	call	81132ce4 <__floatsidf>
81125d20:	d9000f17 	ldw	r4,60(sp)
81125d24:	d9401017 	ldw	r5,64(sp)
81125d28:	100d883a 	mov	r6,r2
81125d2c:	180f883a 	mov	r7,r3
81125d30:	11323600 	call	81132360 <__subdf3>
81125d34:	1823883a 	mov	r17,r3
81125d38:	d8c00717 	ldw	r3,28(sp)
81125d3c:	d9401217 	ldw	r5,72(sp)
81125d40:	a2000c04 	addi	r8,r20,48
81125d44:	1021883a 	mov	r16,r2
81125d48:	1a000005 	stb	r8,0(r3)
81125d4c:	800d883a 	mov	r6,r16
81125d50:	880f883a 	mov	r7,r17
81125d54:	a809883a 	mov	r4,r21
81125d58:	4029883a 	mov	r20,r8
81125d5c:	11321900 	call	81132190 <__gedf2>
81125d60:	00841d16 	blt	zero,r2,81126dd8 <_dtoa_r+0x15fc>
81125d64:	800d883a 	mov	r6,r16
81125d68:	880f883a 	mov	r7,r17
81125d6c:	0009883a 	mov	r4,zero
81125d70:	014ffc34 	movhi	r5,16368
81125d74:	11323600 	call	81132360 <__subdf3>
81125d78:	d9401217 	ldw	r5,72(sp)
81125d7c:	100d883a 	mov	r6,r2
81125d80:	180f883a 	mov	r7,r3
81125d84:	a809883a 	mov	r4,r21
81125d88:	11321900 	call	81132190 <__gedf2>
81125d8c:	db001617 	ldw	r12,88(sp)
81125d90:	00840e16 	blt	zero,r2,81126dcc <_dtoa_r+0x15f0>
81125d94:	00800044 	movi	r2,1
81125d98:	13006b0e 	bge	r2,r12,81125f48 <_dtoa_r+0x76c>
81125d9c:	d9000717 	ldw	r4,28(sp)
81125da0:	dd800f15 	stw	r22,60(sp)
81125da4:	dcc01015 	stw	r19,64(sp)
81125da8:	2319883a 	add	r12,r4,r12
81125dac:	dcc01217 	ldw	r19,72(sp)
81125db0:	602d883a 	mov	r22,r12
81125db4:	dc801215 	stw	r18,72(sp)
81125db8:	b825883a 	mov	r18,r23
81125dbc:	00000906 	br	81125de4 <_dtoa_r+0x608>
81125dc0:	11323600 	call	81132360 <__subdf3>
81125dc4:	a80d883a 	mov	r6,r21
81125dc8:	980f883a 	mov	r7,r19
81125dcc:	1009883a 	mov	r4,r2
81125dd0:	180b883a 	mov	r5,r3
81125dd4:	113226c0 	call	8113226c <__ledf2>
81125dd8:	1003e816 	blt	r2,zero,81126d7c <_dtoa_r+0x15a0>
81125ddc:	b825883a 	mov	r18,r23
81125de0:	bd83e926 	beq	r23,r22,81126d88 <_dtoa_r+0x15ac>
81125de4:	a809883a 	mov	r4,r21
81125de8:	980b883a 	mov	r5,r19
81125dec:	000d883a 	mov	r6,zero
81125df0:	01d00934 	movhi	r7,16420
81125df4:	111ca740 	call	8111ca74 <__muldf3>
81125df8:	000d883a 	mov	r6,zero
81125dfc:	01d00934 	movhi	r7,16420
81125e00:	8009883a 	mov	r4,r16
81125e04:	880b883a 	mov	r5,r17
81125e08:	102b883a 	mov	r21,r2
81125e0c:	1827883a 	mov	r19,r3
81125e10:	111ca740 	call	8111ca74 <__muldf3>
81125e14:	180b883a 	mov	r5,r3
81125e18:	1009883a 	mov	r4,r2
81125e1c:	1821883a 	mov	r16,r3
81125e20:	1023883a 	mov	r17,r2
81125e24:	1132c640 	call	81132c64 <__fixdfsi>
81125e28:	1009883a 	mov	r4,r2
81125e2c:	1029883a 	mov	r20,r2
81125e30:	1132ce40 	call	81132ce4 <__floatsidf>
81125e34:	8809883a 	mov	r4,r17
81125e38:	800b883a 	mov	r5,r16
81125e3c:	100d883a 	mov	r6,r2
81125e40:	180f883a 	mov	r7,r3
81125e44:	11323600 	call	81132360 <__subdf3>
81125e48:	a5000c04 	addi	r20,r20,48
81125e4c:	a80d883a 	mov	r6,r21
81125e50:	980f883a 	mov	r7,r19
81125e54:	1009883a 	mov	r4,r2
81125e58:	180b883a 	mov	r5,r3
81125e5c:	95000005 	stb	r20,0(r18)
81125e60:	1021883a 	mov	r16,r2
81125e64:	1823883a 	mov	r17,r3
81125e68:	113226c0 	call	8113226c <__ledf2>
81125e6c:	bdc00044 	addi	r23,r23,1
81125e70:	800d883a 	mov	r6,r16
81125e74:	880f883a 	mov	r7,r17
81125e78:	0009883a 	mov	r4,zero
81125e7c:	014ffc34 	movhi	r5,16368
81125e80:	103fcf0e 	bge	r2,zero,81125dc0 <__reset+0xfb105dc0>
81125e84:	d8c01317 	ldw	r3,76(sp)
81125e88:	d8c00515 	stw	r3,20(sp)
81125e8c:	d9400917 	ldw	r5,36(sp)
81125e90:	e009883a 	mov	r4,fp
81125e94:	11289a40 	call	811289a4 <_Bfree>
81125e98:	d9000517 	ldw	r4,20(sp)
81125e9c:	d9802317 	ldw	r6,140(sp)
81125ea0:	d9c02517 	ldw	r7,148(sp)
81125ea4:	b8000005 	stb	zero,0(r23)
81125ea8:	20800044 	addi	r2,r4,1
81125eac:	30800015 	stw	r2,0(r6)
81125eb0:	3802aa26 	beq	r7,zero,8112695c <_dtoa_r+0x1180>
81125eb4:	3dc00015 	stw	r23,0(r7)
81125eb8:	d8800717 	ldw	r2,28(sp)
81125ebc:	003e7906 	br	811258a4 <__reset+0xfb1058a4>
81125ec0:	00800434 	movhi	r2,16
81125ec4:	10bfffc4 	addi	r2,r2,-1
81125ec8:	88a2703a 	and	r17,r17,r2
81125ecc:	883e851e 	bne	r17,zero,811258e4 <__reset+0xfb1058e4>
81125ed0:	00a04574 	movhi	r2,33045
81125ed4:	10b3b604 	addi	r2,r2,-12584
81125ed8:	003e8406 	br	811258ec <__reset+0xfb1058ec>
81125edc:	10c00204 	addi	r3,r2,8
81125ee0:	003e8706 	br	81125900 <__reset+0xfb105900>
81125ee4:	01400434 	movhi	r5,16
81125ee8:	297fffc4 	addi	r5,r5,-1
81125eec:	994a703a 	and	r5,r19,r5
81125ef0:	9009883a 	mov	r4,r18
81125ef4:	843f0044 	addi	r16,r16,-1023
81125ef8:	294ffc34 	orhi	r5,r5,16368
81125efc:	dd800217 	ldw	r22,8(sp)
81125f00:	d8001115 	stw	zero,68(sp)
81125f04:	003ea506 	br	8112599c <__reset+0xfb10599c>
81125f08:	00a04574 	movhi	r2,33045
81125f0c:	10b39b04 	addi	r2,r2,-12692
81125f10:	003e6406 	br	811258a4 <__reset+0xfb1058a4>
81125f14:	e0001115 	stw	zero,68(fp)
81125f18:	000b883a 	mov	r5,zero
81125f1c:	e009883a 	mov	r4,fp
81125f20:	11288f40 	call	811288f4 <_Balloc>
81125f24:	01bfffc4 	movi	r6,-1
81125f28:	01c00044 	movi	r7,1
81125f2c:	d8800715 	stw	r2,28(sp)
81125f30:	d9800c15 	stw	r6,48(sp)
81125f34:	e0801015 	stw	r2,64(fp)
81125f38:	d8000315 	stw	zero,12(sp)
81125f3c:	d9c00b15 	stw	r7,44(sp)
81125f40:	d9800615 	stw	r6,24(sp)
81125f44:	d8002215 	stw	zero,136(sp)
81125f48:	d8800117 	ldw	r2,4(sp)
81125f4c:	10008916 	blt	r2,zero,81126174 <_dtoa_r+0x998>
81125f50:	d9000517 	ldw	r4,20(sp)
81125f54:	00c00384 	movi	r3,14
81125f58:	19008616 	blt	r3,r4,81126174 <_dtoa_r+0x998>
81125f5c:	200490fa 	slli	r2,r4,3
81125f60:	00e04574 	movhi	r3,33045
81125f64:	d9802217 	ldw	r6,136(sp)
81125f68:	18f3d404 	addi	r3,r3,-12464
81125f6c:	1885883a 	add	r2,r3,r2
81125f70:	14000017 	ldw	r16,0(r2)
81125f74:	14400117 	ldw	r17,4(r2)
81125f78:	30016316 	blt	r6,zero,81126508 <_dtoa_r+0xd2c>
81125f7c:	800d883a 	mov	r6,r16
81125f80:	880f883a 	mov	r7,r17
81125f84:	9009883a 	mov	r4,r18
81125f88:	980b883a 	mov	r5,r19
81125f8c:	11318180 	call	81131818 <__divdf3>
81125f90:	180b883a 	mov	r5,r3
81125f94:	1009883a 	mov	r4,r2
81125f98:	1132c640 	call	81132c64 <__fixdfsi>
81125f9c:	1009883a 	mov	r4,r2
81125fa0:	102b883a 	mov	r21,r2
81125fa4:	1132ce40 	call	81132ce4 <__floatsidf>
81125fa8:	800d883a 	mov	r6,r16
81125fac:	880f883a 	mov	r7,r17
81125fb0:	1009883a 	mov	r4,r2
81125fb4:	180b883a 	mov	r5,r3
81125fb8:	111ca740 	call	8111ca74 <__muldf3>
81125fbc:	100d883a 	mov	r6,r2
81125fc0:	180f883a 	mov	r7,r3
81125fc4:	9009883a 	mov	r4,r18
81125fc8:	980b883a 	mov	r5,r19
81125fcc:	11323600 	call	81132360 <__subdf3>
81125fd0:	d9c00717 	ldw	r7,28(sp)
81125fd4:	1009883a 	mov	r4,r2
81125fd8:	a8800c04 	addi	r2,r21,48
81125fdc:	38800005 	stb	r2,0(r7)
81125fe0:	3dc00044 	addi	r23,r7,1
81125fe4:	d9c00617 	ldw	r7,24(sp)
81125fe8:	01800044 	movi	r6,1
81125fec:	180b883a 	mov	r5,r3
81125ff0:	2005883a 	mov	r2,r4
81125ff4:	39803826 	beq	r7,r6,811260d8 <_dtoa_r+0x8fc>
81125ff8:	000d883a 	mov	r6,zero
81125ffc:	01d00934 	movhi	r7,16420
81126000:	111ca740 	call	8111ca74 <__muldf3>
81126004:	000d883a 	mov	r6,zero
81126008:	000f883a 	mov	r7,zero
8112600c:	1009883a 	mov	r4,r2
81126010:	180b883a 	mov	r5,r3
81126014:	1025883a 	mov	r18,r2
81126018:	1827883a 	mov	r19,r3
8112601c:	11321080 	call	81132108 <__eqdf2>
81126020:	103f9a26 	beq	r2,zero,81125e8c <__reset+0xfb105e8c>
81126024:	d9c00617 	ldw	r7,24(sp)
81126028:	d8c00717 	ldw	r3,28(sp)
8112602c:	b829883a 	mov	r20,r23
81126030:	38bfffc4 	addi	r2,r7,-1
81126034:	18ad883a 	add	r22,r3,r2
81126038:	00000a06 	br	81126064 <_dtoa_r+0x888>
8112603c:	111ca740 	call	8111ca74 <__muldf3>
81126040:	000d883a 	mov	r6,zero
81126044:	000f883a 	mov	r7,zero
81126048:	1009883a 	mov	r4,r2
8112604c:	180b883a 	mov	r5,r3
81126050:	1025883a 	mov	r18,r2
81126054:	1827883a 	mov	r19,r3
81126058:	b829883a 	mov	r20,r23
8112605c:	11321080 	call	81132108 <__eqdf2>
81126060:	103f8a26 	beq	r2,zero,81125e8c <__reset+0xfb105e8c>
81126064:	800d883a 	mov	r6,r16
81126068:	880f883a 	mov	r7,r17
8112606c:	9009883a 	mov	r4,r18
81126070:	980b883a 	mov	r5,r19
81126074:	11318180 	call	81131818 <__divdf3>
81126078:	180b883a 	mov	r5,r3
8112607c:	1009883a 	mov	r4,r2
81126080:	1132c640 	call	81132c64 <__fixdfsi>
81126084:	1009883a 	mov	r4,r2
81126088:	102b883a 	mov	r21,r2
8112608c:	1132ce40 	call	81132ce4 <__floatsidf>
81126090:	800d883a 	mov	r6,r16
81126094:	880f883a 	mov	r7,r17
81126098:	1009883a 	mov	r4,r2
8112609c:	180b883a 	mov	r5,r3
811260a0:	111ca740 	call	8111ca74 <__muldf3>
811260a4:	100d883a 	mov	r6,r2
811260a8:	180f883a 	mov	r7,r3
811260ac:	9009883a 	mov	r4,r18
811260b0:	980b883a 	mov	r5,r19
811260b4:	11323600 	call	81132360 <__subdf3>
811260b8:	aa000c04 	addi	r8,r21,48
811260bc:	a2000005 	stb	r8,0(r20)
811260c0:	000d883a 	mov	r6,zero
811260c4:	01d00934 	movhi	r7,16420
811260c8:	1009883a 	mov	r4,r2
811260cc:	180b883a 	mov	r5,r3
811260d0:	a5c00044 	addi	r23,r20,1
811260d4:	b53fd91e 	bne	r22,r20,8112603c <__reset+0xfb10603c>
811260d8:	100d883a 	mov	r6,r2
811260dc:	180f883a 	mov	r7,r3
811260e0:	1009883a 	mov	r4,r2
811260e4:	180b883a 	mov	r5,r3
811260e8:	1130f640 	call	81130f64 <__adddf3>
811260ec:	100d883a 	mov	r6,r2
811260f0:	180f883a 	mov	r7,r3
811260f4:	8009883a 	mov	r4,r16
811260f8:	880b883a 	mov	r5,r17
811260fc:	1027883a 	mov	r19,r2
81126100:	1825883a 	mov	r18,r3
81126104:	113226c0 	call	8113226c <__ledf2>
81126108:	10000816 	blt	r2,zero,8112612c <_dtoa_r+0x950>
8112610c:	980d883a 	mov	r6,r19
81126110:	900f883a 	mov	r7,r18
81126114:	8009883a 	mov	r4,r16
81126118:	880b883a 	mov	r5,r17
8112611c:	11321080 	call	81132108 <__eqdf2>
81126120:	103f5a1e 	bne	r2,zero,81125e8c <__reset+0xfb105e8c>
81126124:	ad40004c 	andi	r21,r21,1
81126128:	a83f5826 	beq	r21,zero,81125e8c <__reset+0xfb105e8c>
8112612c:	bd3fffc3 	ldbu	r20,-1(r23)
81126130:	b8bfffc4 	addi	r2,r23,-1
81126134:	1007883a 	mov	r3,r2
81126138:	01400e44 	movi	r5,57
8112613c:	d9800717 	ldw	r6,28(sp)
81126140:	00000506 	br	81126158 <_dtoa_r+0x97c>
81126144:	18ffffc4 	addi	r3,r3,-1
81126148:	11824726 	beq	r2,r6,81126a68 <_dtoa_r+0x128c>
8112614c:	1d000003 	ldbu	r20,0(r3)
81126150:	102f883a 	mov	r23,r2
81126154:	10bfffc4 	addi	r2,r2,-1
81126158:	a1003fcc 	andi	r4,r20,255
8112615c:	2100201c 	xori	r4,r4,128
81126160:	213fe004 	addi	r4,r4,-128
81126164:	217ff726 	beq	r4,r5,81126144 <__reset+0xfb106144>
81126168:	a2000044 	addi	r8,r20,1
8112616c:	12000005 	stb	r8,0(r2)
81126170:	003f4606 	br	81125e8c <__reset+0xfb105e8c>
81126174:	d9000b17 	ldw	r4,44(sp)
81126178:	2000c826 	beq	r4,zero,8112649c <_dtoa_r+0xcc0>
8112617c:	d9800317 	ldw	r6,12(sp)
81126180:	00c00044 	movi	r3,1
81126184:	1980f90e 	bge	r3,r6,8112656c <_dtoa_r+0xd90>
81126188:	d8800617 	ldw	r2,24(sp)
8112618c:	d8c00a17 	ldw	r3,40(sp)
81126190:	157fffc4 	addi	r21,r2,-1
81126194:	1d41f316 	blt	r3,r21,81126964 <_dtoa_r+0x1188>
81126198:	1d6bc83a 	sub	r21,r3,r21
8112619c:	d9c00617 	ldw	r7,24(sp)
811261a0:	3802aa16 	blt	r7,zero,81126c4c <_dtoa_r+0x1470>
811261a4:	dd000817 	ldw	r20,32(sp)
811261a8:	d8800617 	ldw	r2,24(sp)
811261ac:	d8c00817 	ldw	r3,32(sp)
811261b0:	01400044 	movi	r5,1
811261b4:	e009883a 	mov	r4,fp
811261b8:	1887883a 	add	r3,r3,r2
811261bc:	d8c00815 	stw	r3,32(sp)
811261c0:	b0ad883a 	add	r22,r22,r2
811261c4:	1128d180 	call	81128d18 <__i2b>
811261c8:	1023883a 	mov	r17,r2
811261cc:	a0000826 	beq	r20,zero,811261f0 <_dtoa_r+0xa14>
811261d0:	0580070e 	bge	zero,r22,811261f0 <_dtoa_r+0xa14>
811261d4:	a005883a 	mov	r2,r20
811261d8:	b500b916 	blt	r22,r20,811264c0 <_dtoa_r+0xce4>
811261dc:	d9000817 	ldw	r4,32(sp)
811261e0:	a0a9c83a 	sub	r20,r20,r2
811261e4:	b0adc83a 	sub	r22,r22,r2
811261e8:	2089c83a 	sub	r4,r4,r2
811261ec:	d9000815 	stw	r4,32(sp)
811261f0:	d9800a17 	ldw	r6,40(sp)
811261f4:	0181810e 	bge	zero,r6,811267fc <_dtoa_r+0x1020>
811261f8:	d9c00b17 	ldw	r7,44(sp)
811261fc:	3800b326 	beq	r7,zero,811264cc <_dtoa_r+0xcf0>
81126200:	a800b226 	beq	r21,zero,811264cc <_dtoa_r+0xcf0>
81126204:	880b883a 	mov	r5,r17
81126208:	a80d883a 	mov	r6,r21
8112620c:	e009883a 	mov	r4,fp
81126210:	1128f5c0 	call	81128f5c <__pow5mult>
81126214:	d9800917 	ldw	r6,36(sp)
81126218:	100b883a 	mov	r5,r2
8112621c:	e009883a 	mov	r4,fp
81126220:	1023883a 	mov	r17,r2
81126224:	1128d5c0 	call	81128d5c <__multiply>
81126228:	1021883a 	mov	r16,r2
8112622c:	d8800a17 	ldw	r2,40(sp)
81126230:	d9400917 	ldw	r5,36(sp)
81126234:	e009883a 	mov	r4,fp
81126238:	1545c83a 	sub	r2,r2,r21
8112623c:	d8800a15 	stw	r2,40(sp)
81126240:	11289a40 	call	811289a4 <_Bfree>
81126244:	d8c00a17 	ldw	r3,40(sp)
81126248:	18009f1e 	bne	r3,zero,811264c8 <_dtoa_r+0xcec>
8112624c:	05c00044 	movi	r23,1
81126250:	e009883a 	mov	r4,fp
81126254:	b80b883a 	mov	r5,r23
81126258:	1128d180 	call	81128d18 <__i2b>
8112625c:	d9000d17 	ldw	r4,52(sp)
81126260:	102b883a 	mov	r21,r2
81126264:	2000ce26 	beq	r4,zero,811265a0 <_dtoa_r+0xdc4>
81126268:	200d883a 	mov	r6,r4
8112626c:	100b883a 	mov	r5,r2
81126270:	e009883a 	mov	r4,fp
81126274:	1128f5c0 	call	81128f5c <__pow5mult>
81126278:	d9800317 	ldw	r6,12(sp)
8112627c:	102b883a 	mov	r21,r2
81126280:	b981810e 	bge	r23,r6,81126888 <_dtoa_r+0x10ac>
81126284:	0027883a 	mov	r19,zero
81126288:	a8800417 	ldw	r2,16(r21)
8112628c:	05c00804 	movi	r23,32
81126290:	10800104 	addi	r2,r2,4
81126294:	1085883a 	add	r2,r2,r2
81126298:	1085883a 	add	r2,r2,r2
8112629c:	a885883a 	add	r2,r21,r2
811262a0:	11000017 	ldw	r4,0(r2)
811262a4:	1128c000 	call	81128c00 <__hi0bits>
811262a8:	b885c83a 	sub	r2,r23,r2
811262ac:	1585883a 	add	r2,r2,r22
811262b0:	108007cc 	andi	r2,r2,31
811262b4:	1000b326 	beq	r2,zero,81126584 <_dtoa_r+0xda8>
811262b8:	00c00804 	movi	r3,32
811262bc:	1887c83a 	sub	r3,r3,r2
811262c0:	01000104 	movi	r4,4
811262c4:	20c2cd0e 	bge	r4,r3,81126dfc <_dtoa_r+0x1620>
811262c8:	00c00704 	movi	r3,28
811262cc:	1885c83a 	sub	r2,r3,r2
811262d0:	d8c00817 	ldw	r3,32(sp)
811262d4:	a0a9883a 	add	r20,r20,r2
811262d8:	b0ad883a 	add	r22,r22,r2
811262dc:	1887883a 	add	r3,r3,r2
811262e0:	d8c00815 	stw	r3,32(sp)
811262e4:	d9800817 	ldw	r6,32(sp)
811262e8:	0180040e 	bge	zero,r6,811262fc <_dtoa_r+0xb20>
811262ec:	800b883a 	mov	r5,r16
811262f0:	e009883a 	mov	r4,fp
811262f4:	11290a40 	call	811290a4 <__lshift>
811262f8:	1021883a 	mov	r16,r2
811262fc:	0580050e 	bge	zero,r22,81126314 <_dtoa_r+0xb38>
81126300:	a80b883a 	mov	r5,r21
81126304:	b00d883a 	mov	r6,r22
81126308:	e009883a 	mov	r4,fp
8112630c:	11290a40 	call	811290a4 <__lshift>
81126310:	102b883a 	mov	r21,r2
81126314:	d9c00e17 	ldw	r7,56(sp)
81126318:	3801211e 	bne	r7,zero,811267a0 <_dtoa_r+0xfc4>
8112631c:	d9800617 	ldw	r6,24(sp)
81126320:	0181380e 	bge	zero,r6,81126804 <_dtoa_r+0x1028>
81126324:	d8c00b17 	ldw	r3,44(sp)
81126328:	1800ab1e 	bne	r3,zero,811265d8 <_dtoa_r+0xdfc>
8112632c:	dc800717 	ldw	r18,28(sp)
81126330:	dcc00617 	ldw	r19,24(sp)
81126334:	9029883a 	mov	r20,r18
81126338:	00000206 	br	81126344 <_dtoa_r+0xb68>
8112633c:	11289cc0 	call	811289cc <__multadd>
81126340:	1021883a 	mov	r16,r2
81126344:	a80b883a 	mov	r5,r21
81126348:	8009883a 	mov	r4,r16
8112634c:	11255d40 	call	811255d4 <quorem>
81126350:	10800c04 	addi	r2,r2,48
81126354:	90800005 	stb	r2,0(r18)
81126358:	94800044 	addi	r18,r18,1
8112635c:	9507c83a 	sub	r3,r18,r20
81126360:	000f883a 	mov	r7,zero
81126364:	01800284 	movi	r6,10
81126368:	800b883a 	mov	r5,r16
8112636c:	e009883a 	mov	r4,fp
81126370:	1cfff216 	blt	r3,r19,8112633c <__reset+0xfb10633c>
81126374:	1011883a 	mov	r8,r2
81126378:	d8800617 	ldw	r2,24(sp)
8112637c:	0082370e 	bge	zero,r2,81126c5c <_dtoa_r+0x1480>
81126380:	d9000717 	ldw	r4,28(sp)
81126384:	0025883a 	mov	r18,zero
81126388:	20af883a 	add	r23,r4,r2
8112638c:	01800044 	movi	r6,1
81126390:	800b883a 	mov	r5,r16
81126394:	e009883a 	mov	r4,fp
81126398:	da001715 	stw	r8,92(sp)
8112639c:	11290a40 	call	811290a4 <__lshift>
811263a0:	a80b883a 	mov	r5,r21
811263a4:	1009883a 	mov	r4,r2
811263a8:	d8800915 	stw	r2,36(sp)
811263ac:	11291f40 	call	811291f4 <__mcmp>
811263b0:	da001717 	ldw	r8,92(sp)
811263b4:	0081800e 	bge	zero,r2,811269b8 <_dtoa_r+0x11dc>
811263b8:	b93fffc3 	ldbu	r4,-1(r23)
811263bc:	b8bfffc4 	addi	r2,r23,-1
811263c0:	1007883a 	mov	r3,r2
811263c4:	01800e44 	movi	r6,57
811263c8:	d9c00717 	ldw	r7,28(sp)
811263cc:	00000506 	br	811263e4 <_dtoa_r+0xc08>
811263d0:	18ffffc4 	addi	r3,r3,-1
811263d4:	11c12326 	beq	r2,r7,81126864 <_dtoa_r+0x1088>
811263d8:	19000003 	ldbu	r4,0(r3)
811263dc:	102f883a 	mov	r23,r2
811263e0:	10bfffc4 	addi	r2,r2,-1
811263e4:	21403fcc 	andi	r5,r4,255
811263e8:	2940201c 	xori	r5,r5,128
811263ec:	297fe004 	addi	r5,r5,-128
811263f0:	29bff726 	beq	r5,r6,811263d0 <__reset+0xfb1063d0>
811263f4:	21000044 	addi	r4,r4,1
811263f8:	11000005 	stb	r4,0(r2)
811263fc:	a80b883a 	mov	r5,r21
81126400:	e009883a 	mov	r4,fp
81126404:	11289a40 	call	811289a4 <_Bfree>
81126408:	883ea026 	beq	r17,zero,81125e8c <__reset+0xfb105e8c>
8112640c:	90000426 	beq	r18,zero,81126420 <_dtoa_r+0xc44>
81126410:	94400326 	beq	r18,r17,81126420 <_dtoa_r+0xc44>
81126414:	900b883a 	mov	r5,r18
81126418:	e009883a 	mov	r4,fp
8112641c:	11289a40 	call	811289a4 <_Bfree>
81126420:	880b883a 	mov	r5,r17
81126424:	e009883a 	mov	r4,fp
81126428:	11289a40 	call	811289a4 <_Bfree>
8112642c:	003e9706 	br	81125e8c <__reset+0xfb105e8c>
81126430:	01800044 	movi	r6,1
81126434:	d9800e15 	stw	r6,56(sp)
81126438:	003d9606 	br	81125a94 <__reset+0xfb105a94>
8112643c:	d8800817 	ldw	r2,32(sp)
81126440:	d8c00517 	ldw	r3,20(sp)
81126444:	d8000d15 	stw	zero,52(sp)
81126448:	10c5c83a 	sub	r2,r2,r3
8112644c:	00c9c83a 	sub	r4,zero,r3
81126450:	d8800815 	stw	r2,32(sp)
81126454:	d9000a15 	stw	r4,40(sp)
81126458:	003d9706 	br	81125ab8 <__reset+0xfb105ab8>
8112645c:	05adc83a 	sub	r22,zero,r22
81126460:	dd800815 	stw	r22,32(sp)
81126464:	002d883a 	mov	r22,zero
81126468:	003d8e06 	br	81125aa4 <__reset+0xfb105aa4>
8112646c:	d9000517 	ldw	r4,20(sp)
81126470:	1132ce40 	call	81132ce4 <__floatsidf>
81126474:	100d883a 	mov	r6,r2
81126478:	180f883a 	mov	r7,r3
8112647c:	a009883a 	mov	r4,r20
81126480:	880b883a 	mov	r5,r17
81126484:	11321080 	call	81132108 <__eqdf2>
81126488:	103d7126 	beq	r2,zero,81125a50 <__reset+0xfb105a50>
8112648c:	d9c00517 	ldw	r7,20(sp)
81126490:	39ffffc4 	addi	r7,r7,-1
81126494:	d9c00515 	stw	r7,20(sp)
81126498:	003d6d06 	br	81125a50 <__reset+0xfb105a50>
8112649c:	dd400a17 	ldw	r21,40(sp)
811264a0:	dd000817 	ldw	r20,32(sp)
811264a4:	0023883a 	mov	r17,zero
811264a8:	003f4806 	br	811261cc <__reset+0xfb1061cc>
811264ac:	10e3c83a 	sub	r17,r2,r3
811264b0:	9448983a 	sll	r4,r18,r17
811264b4:	003d3206 	br	81125980 <__reset+0xfb105980>
811264b8:	d8000e15 	stw	zero,56(sp)
811264bc:	003d7506 	br	81125a94 <__reset+0xfb105a94>
811264c0:	b005883a 	mov	r2,r22
811264c4:	003f4506 	br	811261dc <__reset+0xfb1061dc>
811264c8:	dc000915 	stw	r16,36(sp)
811264cc:	d9800a17 	ldw	r6,40(sp)
811264d0:	d9400917 	ldw	r5,36(sp)
811264d4:	e009883a 	mov	r4,fp
811264d8:	1128f5c0 	call	81128f5c <__pow5mult>
811264dc:	1021883a 	mov	r16,r2
811264e0:	003f5a06 	br	8112624c <__reset+0xfb10624c>
811264e4:	01c00044 	movi	r7,1
811264e8:	d9c00b15 	stw	r7,44(sp)
811264ec:	d8802217 	ldw	r2,136(sp)
811264f0:	0081280e 	bge	zero,r2,81126994 <_dtoa_r+0x11b8>
811264f4:	100d883a 	mov	r6,r2
811264f8:	1021883a 	mov	r16,r2
811264fc:	d8800c15 	stw	r2,48(sp)
81126500:	d8800615 	stw	r2,24(sp)
81126504:	003d8806 	br	81125b28 <__reset+0xfb105b28>
81126508:	d8800617 	ldw	r2,24(sp)
8112650c:	00be9b16 	blt	zero,r2,81125f7c <__reset+0xfb105f7c>
81126510:	10010f1e 	bne	r2,zero,81126950 <_dtoa_r+0x1174>
81126514:	880b883a 	mov	r5,r17
81126518:	000d883a 	mov	r6,zero
8112651c:	01d00534 	movhi	r7,16404
81126520:	8009883a 	mov	r4,r16
81126524:	111ca740 	call	8111ca74 <__muldf3>
81126528:	900d883a 	mov	r6,r18
8112652c:	980f883a 	mov	r7,r19
81126530:	1009883a 	mov	r4,r2
81126534:	180b883a 	mov	r5,r3
81126538:	11321900 	call	81132190 <__gedf2>
8112653c:	002b883a 	mov	r21,zero
81126540:	0023883a 	mov	r17,zero
81126544:	1000bf16 	blt	r2,zero,81126844 <_dtoa_r+0x1068>
81126548:	d9802217 	ldw	r6,136(sp)
8112654c:	ddc00717 	ldw	r23,28(sp)
81126550:	018c303a 	nor	r6,zero,r6
81126554:	d9800515 	stw	r6,20(sp)
81126558:	a80b883a 	mov	r5,r21
8112655c:	e009883a 	mov	r4,fp
81126560:	11289a40 	call	811289a4 <_Bfree>
81126564:	883e4926 	beq	r17,zero,81125e8c <__reset+0xfb105e8c>
81126568:	003fad06 	br	81126420 <__reset+0xfb106420>
8112656c:	d9c01117 	ldw	r7,68(sp)
81126570:	3801bc26 	beq	r7,zero,81126c64 <_dtoa_r+0x1488>
81126574:	10810cc4 	addi	r2,r2,1075
81126578:	dd400a17 	ldw	r21,40(sp)
8112657c:	dd000817 	ldw	r20,32(sp)
81126580:	003f0a06 	br	811261ac <__reset+0xfb1061ac>
81126584:	00800704 	movi	r2,28
81126588:	d9000817 	ldw	r4,32(sp)
8112658c:	a0a9883a 	add	r20,r20,r2
81126590:	b0ad883a 	add	r22,r22,r2
81126594:	2089883a 	add	r4,r4,r2
81126598:	d9000815 	stw	r4,32(sp)
8112659c:	003f5106 	br	811262e4 <__reset+0xfb1062e4>
811265a0:	d8c00317 	ldw	r3,12(sp)
811265a4:	b8c1fc0e 	bge	r23,r3,81126d98 <_dtoa_r+0x15bc>
811265a8:	0027883a 	mov	r19,zero
811265ac:	b805883a 	mov	r2,r23
811265b0:	003f3e06 	br	811262ac <__reset+0xfb1062ac>
811265b4:	880b883a 	mov	r5,r17
811265b8:	e009883a 	mov	r4,fp
811265bc:	000f883a 	mov	r7,zero
811265c0:	01800284 	movi	r6,10
811265c4:	11289cc0 	call	811289cc <__multadd>
811265c8:	d9000c17 	ldw	r4,48(sp)
811265cc:	1023883a 	mov	r17,r2
811265d0:	0102040e 	bge	zero,r4,81126de4 <_dtoa_r+0x1608>
811265d4:	d9000615 	stw	r4,24(sp)
811265d8:	0500050e 	bge	zero,r20,811265f0 <_dtoa_r+0xe14>
811265dc:	880b883a 	mov	r5,r17
811265e0:	a00d883a 	mov	r6,r20
811265e4:	e009883a 	mov	r4,fp
811265e8:	11290a40 	call	811290a4 <__lshift>
811265ec:	1023883a 	mov	r17,r2
811265f0:	9801241e 	bne	r19,zero,81126a84 <_dtoa_r+0x12a8>
811265f4:	8829883a 	mov	r20,r17
811265f8:	d9000617 	ldw	r4,24(sp)
811265fc:	dcc00717 	ldw	r19,28(sp)
81126600:	9480004c 	andi	r18,r18,1
81126604:	20bfffc4 	addi	r2,r4,-1
81126608:	9885883a 	add	r2,r19,r2
8112660c:	d8800415 	stw	r2,16(sp)
81126610:	dc800615 	stw	r18,24(sp)
81126614:	a80b883a 	mov	r5,r21
81126618:	8009883a 	mov	r4,r16
8112661c:	11255d40 	call	811255d4 <quorem>
81126620:	880b883a 	mov	r5,r17
81126624:	8009883a 	mov	r4,r16
81126628:	102f883a 	mov	r23,r2
8112662c:	11291f40 	call	811291f4 <__mcmp>
81126630:	a80b883a 	mov	r5,r21
81126634:	a00d883a 	mov	r6,r20
81126638:	e009883a 	mov	r4,fp
8112663c:	102d883a 	mov	r22,r2
81126640:	11292540 	call	81129254 <__mdiff>
81126644:	1007883a 	mov	r3,r2
81126648:	10800317 	ldw	r2,12(r2)
8112664c:	bc800c04 	addi	r18,r23,48
81126650:	180b883a 	mov	r5,r3
81126654:	10004e1e 	bne	r2,zero,81126790 <_dtoa_r+0xfb4>
81126658:	8009883a 	mov	r4,r16
8112665c:	d8c01615 	stw	r3,88(sp)
81126660:	11291f40 	call	811291f4 <__mcmp>
81126664:	d8c01617 	ldw	r3,88(sp)
81126668:	e009883a 	mov	r4,fp
8112666c:	d8801615 	stw	r2,88(sp)
81126670:	180b883a 	mov	r5,r3
81126674:	11289a40 	call	811289a4 <_Bfree>
81126678:	d8801617 	ldw	r2,88(sp)
8112667c:	1000041e 	bne	r2,zero,81126690 <_dtoa_r+0xeb4>
81126680:	d9800317 	ldw	r6,12(sp)
81126684:	3000021e 	bne	r6,zero,81126690 <_dtoa_r+0xeb4>
81126688:	d8c00617 	ldw	r3,24(sp)
8112668c:	18003726 	beq	r3,zero,8112676c <_dtoa_r+0xf90>
81126690:	b0002016 	blt	r22,zero,81126714 <_dtoa_r+0xf38>
81126694:	b000041e 	bne	r22,zero,811266a8 <_dtoa_r+0xecc>
81126698:	d9000317 	ldw	r4,12(sp)
8112669c:	2000021e 	bne	r4,zero,811266a8 <_dtoa_r+0xecc>
811266a0:	d8c00617 	ldw	r3,24(sp)
811266a4:	18001b26 	beq	r3,zero,81126714 <_dtoa_r+0xf38>
811266a8:	00810716 	blt	zero,r2,81126ac8 <_dtoa_r+0x12ec>
811266ac:	d8c00417 	ldw	r3,16(sp)
811266b0:	9d800044 	addi	r22,r19,1
811266b4:	9c800005 	stb	r18,0(r19)
811266b8:	b02f883a 	mov	r23,r22
811266bc:	98c10626 	beq	r19,r3,81126ad8 <_dtoa_r+0x12fc>
811266c0:	800b883a 	mov	r5,r16
811266c4:	000f883a 	mov	r7,zero
811266c8:	01800284 	movi	r6,10
811266cc:	e009883a 	mov	r4,fp
811266d0:	11289cc0 	call	811289cc <__multadd>
811266d4:	1021883a 	mov	r16,r2
811266d8:	000f883a 	mov	r7,zero
811266dc:	01800284 	movi	r6,10
811266e0:	880b883a 	mov	r5,r17
811266e4:	e009883a 	mov	r4,fp
811266e8:	8d002526 	beq	r17,r20,81126780 <_dtoa_r+0xfa4>
811266ec:	11289cc0 	call	811289cc <__multadd>
811266f0:	a00b883a 	mov	r5,r20
811266f4:	000f883a 	mov	r7,zero
811266f8:	01800284 	movi	r6,10
811266fc:	e009883a 	mov	r4,fp
81126700:	1023883a 	mov	r17,r2
81126704:	11289cc0 	call	811289cc <__multadd>
81126708:	1029883a 	mov	r20,r2
8112670c:	b027883a 	mov	r19,r22
81126710:	003fc006 	br	81126614 <__reset+0xfb106614>
81126714:	9011883a 	mov	r8,r18
81126718:	00800e0e 	bge	zero,r2,81126754 <_dtoa_r+0xf78>
8112671c:	800b883a 	mov	r5,r16
81126720:	01800044 	movi	r6,1
81126724:	e009883a 	mov	r4,fp
81126728:	da001715 	stw	r8,92(sp)
8112672c:	11290a40 	call	811290a4 <__lshift>
81126730:	a80b883a 	mov	r5,r21
81126734:	1009883a 	mov	r4,r2
81126738:	1021883a 	mov	r16,r2
8112673c:	11291f40 	call	811291f4 <__mcmp>
81126740:	da001717 	ldw	r8,92(sp)
81126744:	0081960e 	bge	zero,r2,81126da0 <_dtoa_r+0x15c4>
81126748:	00800e44 	movi	r2,57
8112674c:	40817026 	beq	r8,r2,81126d10 <_dtoa_r+0x1534>
81126750:	ba000c44 	addi	r8,r23,49
81126754:	8825883a 	mov	r18,r17
81126758:	9dc00044 	addi	r23,r19,1
8112675c:	9a000005 	stb	r8,0(r19)
81126760:	a023883a 	mov	r17,r20
81126764:	dc000915 	stw	r16,36(sp)
81126768:	003f2406 	br	811263fc <__reset+0xfb1063fc>
8112676c:	00800e44 	movi	r2,57
81126770:	9011883a 	mov	r8,r18
81126774:	90816626 	beq	r18,r2,81126d10 <_dtoa_r+0x1534>
81126778:	05bff516 	blt	zero,r22,81126750 <__reset+0xfb106750>
8112677c:	003ff506 	br	81126754 <__reset+0xfb106754>
81126780:	11289cc0 	call	811289cc <__multadd>
81126784:	1023883a 	mov	r17,r2
81126788:	1029883a 	mov	r20,r2
8112678c:	003fdf06 	br	8112670c <__reset+0xfb10670c>
81126790:	e009883a 	mov	r4,fp
81126794:	11289a40 	call	811289a4 <_Bfree>
81126798:	00800044 	movi	r2,1
8112679c:	003fbc06 	br	81126690 <__reset+0xfb106690>
811267a0:	a80b883a 	mov	r5,r21
811267a4:	8009883a 	mov	r4,r16
811267a8:	11291f40 	call	811291f4 <__mcmp>
811267ac:	103edb0e 	bge	r2,zero,8112631c <__reset+0xfb10631c>
811267b0:	800b883a 	mov	r5,r16
811267b4:	000f883a 	mov	r7,zero
811267b8:	01800284 	movi	r6,10
811267bc:	e009883a 	mov	r4,fp
811267c0:	11289cc0 	call	811289cc <__multadd>
811267c4:	1021883a 	mov	r16,r2
811267c8:	d8800517 	ldw	r2,20(sp)
811267cc:	d8c00b17 	ldw	r3,44(sp)
811267d0:	10bfffc4 	addi	r2,r2,-1
811267d4:	d8800515 	stw	r2,20(sp)
811267d8:	183f761e 	bne	r3,zero,811265b4 <__reset+0xfb1065b4>
811267dc:	d9000c17 	ldw	r4,48(sp)
811267e0:	0101730e 	bge	zero,r4,81126db0 <_dtoa_r+0x15d4>
811267e4:	d9000615 	stw	r4,24(sp)
811267e8:	003ed006 	br	8112632c <__reset+0xfb10632c>
811267ec:	00800084 	movi	r2,2
811267f0:	3081861e 	bne	r6,r2,81126e0c <_dtoa_r+0x1630>
811267f4:	d8000b15 	stw	zero,44(sp)
811267f8:	003f3c06 	br	811264ec <__reset+0xfb1064ec>
811267fc:	dc000917 	ldw	r16,36(sp)
81126800:	003e9206 	br	8112624c <__reset+0xfb10624c>
81126804:	d9c00317 	ldw	r7,12(sp)
81126808:	00800084 	movi	r2,2
8112680c:	11fec50e 	bge	r2,r7,81126324 <__reset+0xfb106324>
81126810:	d9000617 	ldw	r4,24(sp)
81126814:	20013c1e 	bne	r4,zero,81126d08 <_dtoa_r+0x152c>
81126818:	a80b883a 	mov	r5,r21
8112681c:	000f883a 	mov	r7,zero
81126820:	01800144 	movi	r6,5
81126824:	e009883a 	mov	r4,fp
81126828:	11289cc0 	call	811289cc <__multadd>
8112682c:	100b883a 	mov	r5,r2
81126830:	8009883a 	mov	r4,r16
81126834:	102b883a 	mov	r21,r2
81126838:	11291f40 	call	811291f4 <__mcmp>
8112683c:	dc000915 	stw	r16,36(sp)
81126840:	00bf410e 	bge	zero,r2,81126548 <__reset+0xfb106548>
81126844:	d9c00717 	ldw	r7,28(sp)
81126848:	00800c44 	movi	r2,49
8112684c:	38800005 	stb	r2,0(r7)
81126850:	d8800517 	ldw	r2,20(sp)
81126854:	3dc00044 	addi	r23,r7,1
81126858:	10800044 	addi	r2,r2,1
8112685c:	d8800515 	stw	r2,20(sp)
81126860:	003f3d06 	br	81126558 <__reset+0xfb106558>
81126864:	d9800517 	ldw	r6,20(sp)
81126868:	d9c00717 	ldw	r7,28(sp)
8112686c:	00800c44 	movi	r2,49
81126870:	31800044 	addi	r6,r6,1
81126874:	d9800515 	stw	r6,20(sp)
81126878:	38800005 	stb	r2,0(r7)
8112687c:	003edf06 	br	811263fc <__reset+0xfb1063fc>
81126880:	d8000b15 	stw	zero,44(sp)
81126884:	003c9f06 	br	81125b04 <__reset+0xfb105b04>
81126888:	903e7e1e 	bne	r18,zero,81126284 <__reset+0xfb106284>
8112688c:	00800434 	movhi	r2,16
81126890:	10bfffc4 	addi	r2,r2,-1
81126894:	9884703a 	and	r2,r19,r2
81126898:	1000ea1e 	bne	r2,zero,81126c44 <_dtoa_r+0x1468>
8112689c:	9cdffc2c 	andhi	r19,r19,32752
811268a0:	9800e826 	beq	r19,zero,81126c44 <_dtoa_r+0x1468>
811268a4:	d9c00817 	ldw	r7,32(sp)
811268a8:	b5800044 	addi	r22,r22,1
811268ac:	04c00044 	movi	r19,1
811268b0:	39c00044 	addi	r7,r7,1
811268b4:	d9c00815 	stw	r7,32(sp)
811268b8:	d8800d17 	ldw	r2,52(sp)
811268bc:	103e721e 	bne	r2,zero,81126288 <__reset+0xfb106288>
811268c0:	00800044 	movi	r2,1
811268c4:	003e7906 	br	811262ac <__reset+0xfb1062ac>
811268c8:	8009883a 	mov	r4,r16
811268cc:	1132ce40 	call	81132ce4 <__floatsidf>
811268d0:	d9800f17 	ldw	r6,60(sp)
811268d4:	d9c01017 	ldw	r7,64(sp)
811268d8:	1009883a 	mov	r4,r2
811268dc:	180b883a 	mov	r5,r3
811268e0:	111ca740 	call	8111ca74 <__muldf3>
811268e4:	000d883a 	mov	r6,zero
811268e8:	01d00734 	movhi	r7,16412
811268ec:	1009883a 	mov	r4,r2
811268f0:	180b883a 	mov	r5,r3
811268f4:	1130f640 	call	81130f64 <__adddf3>
811268f8:	047f3034 	movhi	r17,64704
811268fc:	1021883a 	mov	r16,r2
81126900:	1c63883a 	add	r17,r3,r17
81126904:	d9000f17 	ldw	r4,60(sp)
81126908:	d9401017 	ldw	r5,64(sp)
8112690c:	000d883a 	mov	r6,zero
81126910:	01d00534 	movhi	r7,16404
81126914:	11323600 	call	81132360 <__subdf3>
81126918:	800d883a 	mov	r6,r16
8112691c:	880f883a 	mov	r7,r17
81126920:	1009883a 	mov	r4,r2
81126924:	180b883a 	mov	r5,r3
81126928:	102b883a 	mov	r21,r2
8112692c:	1829883a 	mov	r20,r3
81126930:	11321900 	call	81132190 <__gedf2>
81126934:	00806c16 	blt	zero,r2,81126ae8 <_dtoa_r+0x130c>
81126938:	89e0003c 	xorhi	r7,r17,32768
8112693c:	800d883a 	mov	r6,r16
81126940:	a809883a 	mov	r4,r21
81126944:	a00b883a 	mov	r5,r20
81126948:	113226c0 	call	8113226c <__ledf2>
8112694c:	103d7e0e 	bge	r2,zero,81125f48 <__reset+0xfb105f48>
81126950:	002b883a 	mov	r21,zero
81126954:	0023883a 	mov	r17,zero
81126958:	003efb06 	br	81126548 <__reset+0xfb106548>
8112695c:	d8800717 	ldw	r2,28(sp)
81126960:	003bd006 	br	811258a4 <__reset+0xfb1058a4>
81126964:	d9000a17 	ldw	r4,40(sp)
81126968:	d9800d17 	ldw	r6,52(sp)
8112696c:	dd400a15 	stw	r21,40(sp)
81126970:	a905c83a 	sub	r2,r21,r4
81126974:	308d883a 	add	r6,r6,r2
81126978:	d9800d15 	stw	r6,52(sp)
8112697c:	002b883a 	mov	r21,zero
81126980:	003e0606 	br	8112619c <__reset+0xfb10619c>
81126984:	9023883a 	mov	r17,r18
81126988:	9829883a 	mov	r20,r19
8112698c:	04000084 	movi	r16,2
81126990:	003c9206 	br	81125bdc <__reset+0xfb105bdc>
81126994:	04000044 	movi	r16,1
81126998:	dc000c15 	stw	r16,48(sp)
8112699c:	dc000615 	stw	r16,24(sp)
811269a0:	dc002215 	stw	r16,136(sp)
811269a4:	e0001115 	stw	zero,68(fp)
811269a8:	000b883a 	mov	r5,zero
811269ac:	003c6906 	br	81125b54 <__reset+0xfb105b54>
811269b0:	3021883a 	mov	r16,r6
811269b4:	003ffb06 	br	811269a4 <__reset+0xfb1069a4>
811269b8:	1000021e 	bne	r2,zero,811269c4 <_dtoa_r+0x11e8>
811269bc:	4200004c 	andi	r8,r8,1
811269c0:	403e7d1e 	bne	r8,zero,811263b8 <__reset+0xfb1063b8>
811269c4:	01000c04 	movi	r4,48
811269c8:	00000106 	br	811269d0 <_dtoa_r+0x11f4>
811269cc:	102f883a 	mov	r23,r2
811269d0:	b8bfffc4 	addi	r2,r23,-1
811269d4:	10c00007 	ldb	r3,0(r2)
811269d8:	193ffc26 	beq	r3,r4,811269cc <__reset+0xfb1069cc>
811269dc:	003e8706 	br	811263fc <__reset+0xfb1063fc>
811269e0:	d8800517 	ldw	r2,20(sp)
811269e4:	00a3c83a 	sub	r17,zero,r2
811269e8:	8800a426 	beq	r17,zero,81126c7c <_dtoa_r+0x14a0>
811269ec:	888003cc 	andi	r2,r17,15
811269f0:	100490fa 	slli	r2,r2,3
811269f4:	00e04574 	movhi	r3,33045
811269f8:	18f3d404 	addi	r3,r3,-12464
811269fc:	1885883a 	add	r2,r3,r2
81126a00:	11800017 	ldw	r6,0(r2)
81126a04:	11c00117 	ldw	r7,4(r2)
81126a08:	9009883a 	mov	r4,r18
81126a0c:	980b883a 	mov	r5,r19
81126a10:	8823d13a 	srai	r17,r17,4
81126a14:	111ca740 	call	8111ca74 <__muldf3>
81126a18:	d8800f15 	stw	r2,60(sp)
81126a1c:	d8c01015 	stw	r3,64(sp)
81126a20:	8800e826 	beq	r17,zero,81126dc4 <_dtoa_r+0x15e8>
81126a24:	05204574 	movhi	r20,33045
81126a28:	a533ca04 	addi	r20,r20,-12504
81126a2c:	04000084 	movi	r16,2
81126a30:	8980004c 	andi	r6,r17,1
81126a34:	1009883a 	mov	r4,r2
81126a38:	8823d07a 	srai	r17,r17,1
81126a3c:	180b883a 	mov	r5,r3
81126a40:	30000426 	beq	r6,zero,81126a54 <_dtoa_r+0x1278>
81126a44:	a1800017 	ldw	r6,0(r20)
81126a48:	a1c00117 	ldw	r7,4(r20)
81126a4c:	84000044 	addi	r16,r16,1
81126a50:	111ca740 	call	8111ca74 <__muldf3>
81126a54:	a5000204 	addi	r20,r20,8
81126a58:	883ff51e 	bne	r17,zero,81126a30 <__reset+0xfb106a30>
81126a5c:	d8800f15 	stw	r2,60(sp)
81126a60:	d8c01015 	stw	r3,64(sp)
81126a64:	003c7606 	br	81125c40 <__reset+0xfb105c40>
81126a68:	00c00c04 	movi	r3,48
81126a6c:	10c00005 	stb	r3,0(r2)
81126a70:	d8c00517 	ldw	r3,20(sp)
81126a74:	bd3fffc3 	ldbu	r20,-1(r23)
81126a78:	18c00044 	addi	r3,r3,1
81126a7c:	d8c00515 	stw	r3,20(sp)
81126a80:	003db906 	br	81126168 <__reset+0xfb106168>
81126a84:	89400117 	ldw	r5,4(r17)
81126a88:	e009883a 	mov	r4,fp
81126a8c:	11288f40 	call	811288f4 <_Balloc>
81126a90:	89800417 	ldw	r6,16(r17)
81126a94:	89400304 	addi	r5,r17,12
81126a98:	11000304 	addi	r4,r2,12
81126a9c:	31800084 	addi	r6,r6,2
81126aa0:	318d883a 	add	r6,r6,r6
81126aa4:	318d883a 	add	r6,r6,r6
81126aa8:	1027883a 	mov	r19,r2
81126aac:	111e6c40 	call	8111e6c4 <memcpy>
81126ab0:	01800044 	movi	r6,1
81126ab4:	980b883a 	mov	r5,r19
81126ab8:	e009883a 	mov	r4,fp
81126abc:	11290a40 	call	811290a4 <__lshift>
81126ac0:	1029883a 	mov	r20,r2
81126ac4:	003ecc06 	br	811265f8 <__reset+0xfb1065f8>
81126ac8:	00800e44 	movi	r2,57
81126acc:	90809026 	beq	r18,r2,81126d10 <_dtoa_r+0x1534>
81126ad0:	92000044 	addi	r8,r18,1
81126ad4:	003f1f06 	br	81126754 <__reset+0xfb106754>
81126ad8:	9011883a 	mov	r8,r18
81126adc:	8825883a 	mov	r18,r17
81126ae0:	a023883a 	mov	r17,r20
81126ae4:	003e2906 	br	8112638c <__reset+0xfb10638c>
81126ae8:	002b883a 	mov	r21,zero
81126aec:	0023883a 	mov	r17,zero
81126af0:	003f5406 	br	81126844 <__reset+0xfb106844>
81126af4:	61bfffc4 	addi	r6,r12,-1
81126af8:	300490fa 	slli	r2,r6,3
81126afc:	00e04574 	movhi	r3,33045
81126b00:	18f3d404 	addi	r3,r3,-12464
81126b04:	1885883a 	add	r2,r3,r2
81126b08:	11000017 	ldw	r4,0(r2)
81126b0c:	11400117 	ldw	r5,4(r2)
81126b10:	d8800717 	ldw	r2,28(sp)
81126b14:	880f883a 	mov	r7,r17
81126b18:	d9801215 	stw	r6,72(sp)
81126b1c:	800d883a 	mov	r6,r16
81126b20:	db001615 	stw	r12,88(sp)
81126b24:	15c00044 	addi	r23,r2,1
81126b28:	111ca740 	call	8111ca74 <__muldf3>
81126b2c:	d9401017 	ldw	r5,64(sp)
81126b30:	d9000f17 	ldw	r4,60(sp)
81126b34:	d8c01515 	stw	r3,84(sp)
81126b38:	d8801415 	stw	r2,80(sp)
81126b3c:	1132c640 	call	81132c64 <__fixdfsi>
81126b40:	1009883a 	mov	r4,r2
81126b44:	1021883a 	mov	r16,r2
81126b48:	1132ce40 	call	81132ce4 <__floatsidf>
81126b4c:	d9000f17 	ldw	r4,60(sp)
81126b50:	d9401017 	ldw	r5,64(sp)
81126b54:	100d883a 	mov	r6,r2
81126b58:	180f883a 	mov	r7,r3
81126b5c:	11323600 	call	81132360 <__subdf3>
81126b60:	1829883a 	mov	r20,r3
81126b64:	d8c00717 	ldw	r3,28(sp)
81126b68:	84000c04 	addi	r16,r16,48
81126b6c:	1023883a 	mov	r17,r2
81126b70:	1c000005 	stb	r16,0(r3)
81126b74:	db001617 	ldw	r12,88(sp)
81126b78:	00800044 	movi	r2,1
81126b7c:	60802226 	beq	r12,r2,81126c08 <_dtoa_r+0x142c>
81126b80:	d9c00717 	ldw	r7,28(sp)
81126b84:	8805883a 	mov	r2,r17
81126b88:	b82b883a 	mov	r21,r23
81126b8c:	3b19883a 	add	r12,r7,r12
81126b90:	6023883a 	mov	r17,r12
81126b94:	a007883a 	mov	r3,r20
81126b98:	dc800f15 	stw	r18,60(sp)
81126b9c:	000d883a 	mov	r6,zero
81126ba0:	01d00934 	movhi	r7,16420
81126ba4:	1009883a 	mov	r4,r2
81126ba8:	180b883a 	mov	r5,r3
81126bac:	111ca740 	call	8111ca74 <__muldf3>
81126bb0:	180b883a 	mov	r5,r3
81126bb4:	1009883a 	mov	r4,r2
81126bb8:	1829883a 	mov	r20,r3
81126bbc:	1025883a 	mov	r18,r2
81126bc0:	1132c640 	call	81132c64 <__fixdfsi>
81126bc4:	1009883a 	mov	r4,r2
81126bc8:	1021883a 	mov	r16,r2
81126bcc:	1132ce40 	call	81132ce4 <__floatsidf>
81126bd0:	100d883a 	mov	r6,r2
81126bd4:	180f883a 	mov	r7,r3
81126bd8:	9009883a 	mov	r4,r18
81126bdc:	a00b883a 	mov	r5,r20
81126be0:	84000c04 	addi	r16,r16,48
81126be4:	11323600 	call	81132360 <__subdf3>
81126be8:	ad400044 	addi	r21,r21,1
81126bec:	ac3fffc5 	stb	r16,-1(r21)
81126bf0:	ac7fea1e 	bne	r21,r17,81126b9c <__reset+0xfb106b9c>
81126bf4:	1023883a 	mov	r17,r2
81126bf8:	d8801217 	ldw	r2,72(sp)
81126bfc:	dc800f17 	ldw	r18,60(sp)
81126c00:	1829883a 	mov	r20,r3
81126c04:	b8af883a 	add	r23,r23,r2
81126c08:	d9001417 	ldw	r4,80(sp)
81126c0c:	d9401517 	ldw	r5,84(sp)
81126c10:	000d883a 	mov	r6,zero
81126c14:	01cff834 	movhi	r7,16352
81126c18:	1130f640 	call	81130f64 <__adddf3>
81126c1c:	880d883a 	mov	r6,r17
81126c20:	a00f883a 	mov	r7,r20
81126c24:	1009883a 	mov	r4,r2
81126c28:	180b883a 	mov	r5,r3
81126c2c:	113226c0 	call	8113226c <__ledf2>
81126c30:	10003e0e 	bge	r2,zero,81126d2c <_dtoa_r+0x1550>
81126c34:	d9001317 	ldw	r4,76(sp)
81126c38:	bd3fffc3 	ldbu	r20,-1(r23)
81126c3c:	d9000515 	stw	r4,20(sp)
81126c40:	003d3b06 	br	81126130 <__reset+0xfb106130>
81126c44:	0027883a 	mov	r19,zero
81126c48:	003f1b06 	br	811268b8 <__reset+0xfb1068b8>
81126c4c:	d8800817 	ldw	r2,32(sp)
81126c50:	11e9c83a 	sub	r20,r2,r7
81126c54:	0005883a 	mov	r2,zero
81126c58:	003d5406 	br	811261ac <__reset+0xfb1061ac>
81126c5c:	00800044 	movi	r2,1
81126c60:	003dc706 	br	81126380 <__reset+0xfb106380>
81126c64:	d8c00217 	ldw	r3,8(sp)
81126c68:	00800d84 	movi	r2,54
81126c6c:	dd400a17 	ldw	r21,40(sp)
81126c70:	10c5c83a 	sub	r2,r2,r3
81126c74:	dd000817 	ldw	r20,32(sp)
81126c78:	003d4c06 	br	811261ac <__reset+0xfb1061ac>
81126c7c:	dc800f15 	stw	r18,60(sp)
81126c80:	dcc01015 	stw	r19,64(sp)
81126c84:	04000084 	movi	r16,2
81126c88:	003bed06 	br	81125c40 <__reset+0xfb105c40>
81126c8c:	d9000617 	ldw	r4,24(sp)
81126c90:	203f0d26 	beq	r4,zero,811268c8 <__reset+0xfb1068c8>
81126c94:	d9800c17 	ldw	r6,48(sp)
81126c98:	01bcab0e 	bge	zero,r6,81125f48 <__reset+0xfb105f48>
81126c9c:	d9401017 	ldw	r5,64(sp)
81126ca0:	d9000f17 	ldw	r4,60(sp)
81126ca4:	000d883a 	mov	r6,zero
81126ca8:	01d00934 	movhi	r7,16420
81126cac:	111ca740 	call	8111ca74 <__muldf3>
81126cb0:	81000044 	addi	r4,r16,1
81126cb4:	d8800f15 	stw	r2,60(sp)
81126cb8:	d8c01015 	stw	r3,64(sp)
81126cbc:	1132ce40 	call	81132ce4 <__floatsidf>
81126cc0:	d9800f17 	ldw	r6,60(sp)
81126cc4:	d9c01017 	ldw	r7,64(sp)
81126cc8:	1009883a 	mov	r4,r2
81126ccc:	180b883a 	mov	r5,r3
81126cd0:	111ca740 	call	8111ca74 <__muldf3>
81126cd4:	01d00734 	movhi	r7,16412
81126cd8:	000d883a 	mov	r6,zero
81126cdc:	1009883a 	mov	r4,r2
81126ce0:	180b883a 	mov	r5,r3
81126ce4:	1130f640 	call	81130f64 <__adddf3>
81126ce8:	d9c00517 	ldw	r7,20(sp)
81126cec:	047f3034 	movhi	r17,64704
81126cf0:	1021883a 	mov	r16,r2
81126cf4:	39ffffc4 	addi	r7,r7,-1
81126cf8:	d9c01315 	stw	r7,76(sp)
81126cfc:	1c63883a 	add	r17,r3,r17
81126d00:	db000c17 	ldw	r12,48(sp)
81126d04:	003bea06 	br	81125cb0 <__reset+0xfb105cb0>
81126d08:	dc000915 	stw	r16,36(sp)
81126d0c:	003e0e06 	br	81126548 <__reset+0xfb106548>
81126d10:	01000e44 	movi	r4,57
81126d14:	8825883a 	mov	r18,r17
81126d18:	9dc00044 	addi	r23,r19,1
81126d1c:	99000005 	stb	r4,0(r19)
81126d20:	a023883a 	mov	r17,r20
81126d24:	dc000915 	stw	r16,36(sp)
81126d28:	003da406 	br	811263bc <__reset+0xfb1063bc>
81126d2c:	d9801417 	ldw	r6,80(sp)
81126d30:	d9c01517 	ldw	r7,84(sp)
81126d34:	0009883a 	mov	r4,zero
81126d38:	014ff834 	movhi	r5,16352
81126d3c:	11323600 	call	81132360 <__subdf3>
81126d40:	880d883a 	mov	r6,r17
81126d44:	a00f883a 	mov	r7,r20
81126d48:	1009883a 	mov	r4,r2
81126d4c:	180b883a 	mov	r5,r3
81126d50:	11321900 	call	81132190 <__gedf2>
81126d54:	00bc7c0e 	bge	zero,r2,81125f48 <__reset+0xfb105f48>
81126d58:	01000c04 	movi	r4,48
81126d5c:	00000106 	br	81126d64 <_dtoa_r+0x1588>
81126d60:	102f883a 	mov	r23,r2
81126d64:	b8bfffc4 	addi	r2,r23,-1
81126d68:	10c00007 	ldb	r3,0(r2)
81126d6c:	193ffc26 	beq	r3,r4,81126d60 <__reset+0xfb106d60>
81126d70:	d9801317 	ldw	r6,76(sp)
81126d74:	d9800515 	stw	r6,20(sp)
81126d78:	003c4406 	br	81125e8c <__reset+0xfb105e8c>
81126d7c:	d9801317 	ldw	r6,76(sp)
81126d80:	d9800515 	stw	r6,20(sp)
81126d84:	003cea06 	br	81126130 <__reset+0xfb106130>
81126d88:	dd800f17 	ldw	r22,60(sp)
81126d8c:	dcc01017 	ldw	r19,64(sp)
81126d90:	dc801217 	ldw	r18,72(sp)
81126d94:	003c6c06 	br	81125f48 <__reset+0xfb105f48>
81126d98:	903e031e 	bne	r18,zero,811265a8 <__reset+0xfb1065a8>
81126d9c:	003ebb06 	br	8112688c <__reset+0xfb10688c>
81126da0:	103e6c1e 	bne	r2,zero,81126754 <__reset+0xfb106754>
81126da4:	4080004c 	andi	r2,r8,1
81126da8:	103e6a26 	beq	r2,zero,81126754 <__reset+0xfb106754>
81126dac:	003e6606 	br	81126748 <__reset+0xfb106748>
81126db0:	d8c00317 	ldw	r3,12(sp)
81126db4:	00800084 	movi	r2,2
81126db8:	10c02916 	blt	r2,r3,81126e60 <_dtoa_r+0x1684>
81126dbc:	d9000c17 	ldw	r4,48(sp)
81126dc0:	003e8806 	br	811267e4 <__reset+0xfb1067e4>
81126dc4:	04000084 	movi	r16,2
81126dc8:	003b9d06 	br	81125c40 <__reset+0xfb105c40>
81126dcc:	d9001317 	ldw	r4,76(sp)
81126dd0:	d9000515 	stw	r4,20(sp)
81126dd4:	003cd606 	br	81126130 <__reset+0xfb106130>
81126dd8:	d8801317 	ldw	r2,76(sp)
81126ddc:	d8800515 	stw	r2,20(sp)
81126de0:	003c2a06 	br	81125e8c <__reset+0xfb105e8c>
81126de4:	d9800317 	ldw	r6,12(sp)
81126de8:	00800084 	movi	r2,2
81126dec:	11801516 	blt	r2,r6,81126e44 <_dtoa_r+0x1668>
81126df0:	d9c00c17 	ldw	r7,48(sp)
81126df4:	d9c00615 	stw	r7,24(sp)
81126df8:	003df706 	br	811265d8 <__reset+0xfb1065d8>
81126dfc:	193d3926 	beq	r3,r4,811262e4 <__reset+0xfb1062e4>
81126e00:	00c00f04 	movi	r3,60
81126e04:	1885c83a 	sub	r2,r3,r2
81126e08:	003ddf06 	br	81126588 <__reset+0xfb106588>
81126e0c:	e009883a 	mov	r4,fp
81126e10:	e0001115 	stw	zero,68(fp)
81126e14:	000b883a 	mov	r5,zero
81126e18:	11288f40 	call	811288f4 <_Balloc>
81126e1c:	d8800715 	stw	r2,28(sp)
81126e20:	d8c00717 	ldw	r3,28(sp)
81126e24:	00bfffc4 	movi	r2,-1
81126e28:	01000044 	movi	r4,1
81126e2c:	d8800c15 	stw	r2,48(sp)
81126e30:	e0c01015 	stw	r3,64(fp)
81126e34:	d9000b15 	stw	r4,44(sp)
81126e38:	d8800615 	stw	r2,24(sp)
81126e3c:	d8002215 	stw	zero,136(sp)
81126e40:	003c4106 	br	81125f48 <__reset+0xfb105f48>
81126e44:	d8c00c17 	ldw	r3,48(sp)
81126e48:	d8c00615 	stw	r3,24(sp)
81126e4c:	003e7006 	br	81126810 <__reset+0xfb106810>
81126e50:	04400044 	movi	r17,1
81126e54:	003b2006 	br	81125ad8 <__reset+0xfb105ad8>
81126e58:	000b883a 	mov	r5,zero
81126e5c:	003b3d06 	br	81125b54 <__reset+0xfb105b54>
81126e60:	d8800c17 	ldw	r2,48(sp)
81126e64:	d8800615 	stw	r2,24(sp)
81126e68:	003e6906 	br	81126810 <__reset+0xfb106810>

81126e6c <__sflush_r>:
81126e6c:	defffb04 	addi	sp,sp,-20
81126e70:	de00012e 	bgeu	sp,et,81126e78 <__sflush_r+0xc>
81126e74:	003b68fa 	trap	3
81126e78:	2880030b 	ldhu	r2,12(r5)
81126e7c:	dcc00315 	stw	r19,12(sp)
81126e80:	dc400115 	stw	r17,4(sp)
81126e84:	dfc00415 	stw	ra,16(sp)
81126e88:	dc800215 	stw	r18,8(sp)
81126e8c:	dc000015 	stw	r16,0(sp)
81126e90:	10c0020c 	andi	r3,r2,8
81126e94:	2823883a 	mov	r17,r5
81126e98:	2027883a 	mov	r19,r4
81126e9c:	1800311e 	bne	r3,zero,81126f64 <__sflush_r+0xf8>
81126ea0:	28c00117 	ldw	r3,4(r5)
81126ea4:	10820014 	ori	r2,r2,2048
81126ea8:	2880030d 	sth	r2,12(r5)
81126eac:	00c04b0e 	bge	zero,r3,81126fdc <__sflush_r+0x170>
81126eb0:	8a000a17 	ldw	r8,40(r17)
81126eb4:	40002326 	beq	r8,zero,81126f44 <__sflush_r+0xd8>
81126eb8:	9c000017 	ldw	r16,0(r19)
81126ebc:	10c4000c 	andi	r3,r2,4096
81126ec0:	98000015 	stw	zero,0(r19)
81126ec4:	18004826 	beq	r3,zero,81126fe8 <__sflush_r+0x17c>
81126ec8:	89801417 	ldw	r6,80(r17)
81126ecc:	10c0010c 	andi	r3,r2,4
81126ed0:	18000626 	beq	r3,zero,81126eec <__sflush_r+0x80>
81126ed4:	88c00117 	ldw	r3,4(r17)
81126ed8:	88800c17 	ldw	r2,48(r17)
81126edc:	30cdc83a 	sub	r6,r6,r3
81126ee0:	10000226 	beq	r2,zero,81126eec <__sflush_r+0x80>
81126ee4:	88800f17 	ldw	r2,60(r17)
81126ee8:	308dc83a 	sub	r6,r6,r2
81126eec:	89400717 	ldw	r5,28(r17)
81126ef0:	000f883a 	mov	r7,zero
81126ef4:	9809883a 	mov	r4,r19
81126ef8:	403ee83a 	callr	r8
81126efc:	00ffffc4 	movi	r3,-1
81126f00:	10c04426 	beq	r2,r3,81127014 <__sflush_r+0x1a8>
81126f04:	88c0030b 	ldhu	r3,12(r17)
81126f08:	89000417 	ldw	r4,16(r17)
81126f0c:	88000115 	stw	zero,4(r17)
81126f10:	197dffcc 	andi	r5,r3,63487
81126f14:	8940030d 	sth	r5,12(r17)
81126f18:	89000015 	stw	r4,0(r17)
81126f1c:	18c4000c 	andi	r3,r3,4096
81126f20:	18002c1e 	bne	r3,zero,81126fd4 <__sflush_r+0x168>
81126f24:	89400c17 	ldw	r5,48(r17)
81126f28:	9c000015 	stw	r16,0(r19)
81126f2c:	28000526 	beq	r5,zero,81126f44 <__sflush_r+0xd8>
81126f30:	88801004 	addi	r2,r17,64
81126f34:	28800226 	beq	r5,r2,81126f40 <__sflush_r+0xd4>
81126f38:	9809883a 	mov	r4,r19
81126f3c:	11279240 	call	81127924 <_free_r>
81126f40:	88000c15 	stw	zero,48(r17)
81126f44:	0005883a 	mov	r2,zero
81126f48:	dfc00417 	ldw	ra,16(sp)
81126f4c:	dcc00317 	ldw	r19,12(sp)
81126f50:	dc800217 	ldw	r18,8(sp)
81126f54:	dc400117 	ldw	r17,4(sp)
81126f58:	dc000017 	ldw	r16,0(sp)
81126f5c:	dec00504 	addi	sp,sp,20
81126f60:	f800283a 	ret
81126f64:	2c800417 	ldw	r18,16(r5)
81126f68:	903ff626 	beq	r18,zero,81126f44 <__reset+0xfb106f44>
81126f6c:	2c000017 	ldw	r16,0(r5)
81126f70:	108000cc 	andi	r2,r2,3
81126f74:	2c800015 	stw	r18,0(r5)
81126f78:	84a1c83a 	sub	r16,r16,r18
81126f7c:	1000131e 	bne	r2,zero,81126fcc <__sflush_r+0x160>
81126f80:	28800517 	ldw	r2,20(r5)
81126f84:	88800215 	stw	r2,8(r17)
81126f88:	04000316 	blt	zero,r16,81126f98 <__sflush_r+0x12c>
81126f8c:	003fed06 	br	81126f44 <__reset+0xfb106f44>
81126f90:	90a5883a 	add	r18,r18,r2
81126f94:	043feb0e 	bge	zero,r16,81126f44 <__reset+0xfb106f44>
81126f98:	88800917 	ldw	r2,36(r17)
81126f9c:	89400717 	ldw	r5,28(r17)
81126fa0:	800f883a 	mov	r7,r16
81126fa4:	900d883a 	mov	r6,r18
81126fa8:	9809883a 	mov	r4,r19
81126fac:	103ee83a 	callr	r2
81126fb0:	80a1c83a 	sub	r16,r16,r2
81126fb4:	00bff616 	blt	zero,r2,81126f90 <__reset+0xfb106f90>
81126fb8:	88c0030b 	ldhu	r3,12(r17)
81126fbc:	00bfffc4 	movi	r2,-1
81126fc0:	18c01014 	ori	r3,r3,64
81126fc4:	88c0030d 	sth	r3,12(r17)
81126fc8:	003fdf06 	br	81126f48 <__reset+0xfb106f48>
81126fcc:	0005883a 	mov	r2,zero
81126fd0:	003fec06 	br	81126f84 <__reset+0xfb106f84>
81126fd4:	88801415 	stw	r2,80(r17)
81126fd8:	003fd206 	br	81126f24 <__reset+0xfb106f24>
81126fdc:	28c00f17 	ldw	r3,60(r5)
81126fe0:	00ffb316 	blt	zero,r3,81126eb0 <__reset+0xfb106eb0>
81126fe4:	003fd706 	br	81126f44 <__reset+0xfb106f44>
81126fe8:	89400717 	ldw	r5,28(r17)
81126fec:	000d883a 	mov	r6,zero
81126ff0:	01c00044 	movi	r7,1
81126ff4:	9809883a 	mov	r4,r19
81126ff8:	403ee83a 	callr	r8
81126ffc:	100d883a 	mov	r6,r2
81127000:	00bfffc4 	movi	r2,-1
81127004:	30801426 	beq	r6,r2,81127058 <__sflush_r+0x1ec>
81127008:	8880030b 	ldhu	r2,12(r17)
8112700c:	8a000a17 	ldw	r8,40(r17)
81127010:	003fae06 	br	81126ecc <__reset+0xfb106ecc>
81127014:	98c00017 	ldw	r3,0(r19)
81127018:	183fba26 	beq	r3,zero,81126f04 <__reset+0xfb106f04>
8112701c:	01000744 	movi	r4,29
81127020:	19000626 	beq	r3,r4,8112703c <__sflush_r+0x1d0>
81127024:	01000584 	movi	r4,22
81127028:	19000426 	beq	r3,r4,8112703c <__sflush_r+0x1d0>
8112702c:	88c0030b 	ldhu	r3,12(r17)
81127030:	18c01014 	ori	r3,r3,64
81127034:	88c0030d 	sth	r3,12(r17)
81127038:	003fc306 	br	81126f48 <__reset+0xfb106f48>
8112703c:	8880030b 	ldhu	r2,12(r17)
81127040:	88c00417 	ldw	r3,16(r17)
81127044:	88000115 	stw	zero,4(r17)
81127048:	10bdffcc 	andi	r2,r2,63487
8112704c:	8880030d 	sth	r2,12(r17)
81127050:	88c00015 	stw	r3,0(r17)
81127054:	003fb306 	br	81126f24 <__reset+0xfb106f24>
81127058:	98800017 	ldw	r2,0(r19)
8112705c:	103fea26 	beq	r2,zero,81127008 <__reset+0xfb107008>
81127060:	00c00744 	movi	r3,29
81127064:	10c00226 	beq	r2,r3,81127070 <__sflush_r+0x204>
81127068:	00c00584 	movi	r3,22
8112706c:	10c0031e 	bne	r2,r3,8112707c <__sflush_r+0x210>
81127070:	9c000015 	stw	r16,0(r19)
81127074:	0005883a 	mov	r2,zero
81127078:	003fb306 	br	81126f48 <__reset+0xfb106f48>
8112707c:	88c0030b 	ldhu	r3,12(r17)
81127080:	3005883a 	mov	r2,r6
81127084:	18c01014 	ori	r3,r3,64
81127088:	88c0030d 	sth	r3,12(r17)
8112708c:	003fae06 	br	81126f48 <__reset+0xfb106f48>

81127090 <_fflush_r>:
81127090:	defffd04 	addi	sp,sp,-12
81127094:	de00012e 	bgeu	sp,et,8112709c <_fflush_r+0xc>
81127098:	003b68fa 	trap	3
8112709c:	dc000115 	stw	r16,4(sp)
811270a0:	dfc00215 	stw	ra,8(sp)
811270a4:	2021883a 	mov	r16,r4
811270a8:	20000226 	beq	r4,zero,811270b4 <_fflush_r+0x24>
811270ac:	20800e17 	ldw	r2,56(r4)
811270b0:	10000c26 	beq	r2,zero,811270e4 <_fflush_r+0x54>
811270b4:	2880030f 	ldh	r2,12(r5)
811270b8:	1000051e 	bne	r2,zero,811270d0 <_fflush_r+0x40>
811270bc:	0005883a 	mov	r2,zero
811270c0:	dfc00217 	ldw	ra,8(sp)
811270c4:	dc000117 	ldw	r16,4(sp)
811270c8:	dec00304 	addi	sp,sp,12
811270cc:	f800283a 	ret
811270d0:	8009883a 	mov	r4,r16
811270d4:	dfc00217 	ldw	ra,8(sp)
811270d8:	dc000117 	ldw	r16,4(sp)
811270dc:	dec00304 	addi	sp,sp,12
811270e0:	1126e6c1 	jmpi	81126e6c <__sflush_r>
811270e4:	d9400015 	stw	r5,0(sp)
811270e8:	112748c0 	call	8112748c <__sinit>
811270ec:	d9400017 	ldw	r5,0(sp)
811270f0:	003ff006 	br	811270b4 <__reset+0xfb1070b4>

811270f4 <fflush>:
811270f4:	20000526 	beq	r4,zero,8112710c <fflush+0x18>
811270f8:	00a04574 	movhi	r2,33045
811270fc:	10bd6304 	addi	r2,r2,-2676
81127100:	200b883a 	mov	r5,r4
81127104:	11000017 	ldw	r4,0(r2)
81127108:	11270901 	jmpi	81127090 <_fflush_r>
8112710c:	00a04574 	movhi	r2,33045
81127110:	10bd6204 	addi	r2,r2,-2680
81127114:	11000017 	ldw	r4,0(r2)
81127118:	016044b4 	movhi	r5,33042
8112711c:	295c2404 	addi	r5,r5,28816
81127120:	11281cc1 	jmpi	811281cc <_fwalk_reent>

81127124 <__fp_unlock>:
81127124:	0005883a 	mov	r2,zero
81127128:	f800283a 	ret

8112712c <_cleanup_r>:
8112712c:	016044f4 	movhi	r5,33043
81127130:	297bba04 	addi	r5,r5,-4376
81127134:	11281cc1 	jmpi	811281cc <_fwalk_reent>

81127138 <__sinit.part.1>:
81127138:	defff704 	addi	sp,sp,-36
8112713c:	00e044b4 	movhi	r3,33042
81127140:	de00012e 	bgeu	sp,et,81127148 <__sinit.part.1+0x10>
81127144:	003b68fa 	trap	3
81127148:	18dc4b04 	addi	r3,r3,28972
8112714c:	dfc00815 	stw	ra,32(sp)
81127150:	ddc00715 	stw	r23,28(sp)
81127154:	dd800615 	stw	r22,24(sp)
81127158:	dd400515 	stw	r21,20(sp)
8112715c:	dd000415 	stw	r20,16(sp)
81127160:	dcc00315 	stw	r19,12(sp)
81127164:	dc800215 	stw	r18,8(sp)
81127168:	dc400115 	stw	r17,4(sp)
8112716c:	dc000015 	stw	r16,0(sp)
81127170:	24000117 	ldw	r16,4(r4)
81127174:	20c00f15 	stw	r3,60(r4)
81127178:	2080bb04 	addi	r2,r4,748
8112717c:	00c000c4 	movi	r3,3
81127180:	20c0b915 	stw	r3,740(r4)
81127184:	2080ba15 	stw	r2,744(r4)
81127188:	2000b815 	stw	zero,736(r4)
8112718c:	05c00204 	movi	r23,8
81127190:	00800104 	movi	r2,4
81127194:	2025883a 	mov	r18,r4
81127198:	b80d883a 	mov	r6,r23
8112719c:	81001704 	addi	r4,r16,92
811271a0:	000b883a 	mov	r5,zero
811271a4:	80000015 	stw	zero,0(r16)
811271a8:	80000115 	stw	zero,4(r16)
811271ac:	80000215 	stw	zero,8(r16)
811271b0:	8080030d 	sth	r2,12(r16)
811271b4:	80001915 	stw	zero,100(r16)
811271b8:	8000038d 	sth	zero,14(r16)
811271bc:	80000415 	stw	zero,16(r16)
811271c0:	80000515 	stw	zero,20(r16)
811271c4:	80000615 	stw	zero,24(r16)
811271c8:	111e8140 	call	8111e814 <memset>
811271cc:	05a044b4 	movhi	r22,33042
811271d0:	94400217 	ldw	r17,8(r18)
811271d4:	056044b4 	movhi	r21,33042
811271d8:	052044b4 	movhi	r20,33042
811271dc:	04e044b4 	movhi	r19,33042
811271e0:	b5bc0604 	addi	r22,r22,-4072
811271e4:	ad7c1f04 	addi	r21,r21,-3972
811271e8:	a53c4004 	addi	r20,r20,-3840
811271ec:	9cfc5904 	addi	r19,r19,-3740
811271f0:	85800815 	stw	r22,32(r16)
811271f4:	85400915 	stw	r21,36(r16)
811271f8:	85000a15 	stw	r20,40(r16)
811271fc:	84c00b15 	stw	r19,44(r16)
81127200:	84000715 	stw	r16,28(r16)
81127204:	00800284 	movi	r2,10
81127208:	8880030d 	sth	r2,12(r17)
8112720c:	00800044 	movi	r2,1
81127210:	b80d883a 	mov	r6,r23
81127214:	89001704 	addi	r4,r17,92
81127218:	000b883a 	mov	r5,zero
8112721c:	88000015 	stw	zero,0(r17)
81127220:	88000115 	stw	zero,4(r17)
81127224:	88000215 	stw	zero,8(r17)
81127228:	88001915 	stw	zero,100(r17)
8112722c:	8880038d 	sth	r2,14(r17)
81127230:	88000415 	stw	zero,16(r17)
81127234:	88000515 	stw	zero,20(r17)
81127238:	88000615 	stw	zero,24(r17)
8112723c:	111e8140 	call	8111e814 <memset>
81127240:	94000317 	ldw	r16,12(r18)
81127244:	00800484 	movi	r2,18
81127248:	8c400715 	stw	r17,28(r17)
8112724c:	8d800815 	stw	r22,32(r17)
81127250:	8d400915 	stw	r21,36(r17)
81127254:	8d000a15 	stw	r20,40(r17)
81127258:	8cc00b15 	stw	r19,44(r17)
8112725c:	8080030d 	sth	r2,12(r16)
81127260:	00800084 	movi	r2,2
81127264:	80000015 	stw	zero,0(r16)
81127268:	80000115 	stw	zero,4(r16)
8112726c:	80000215 	stw	zero,8(r16)
81127270:	80001915 	stw	zero,100(r16)
81127274:	8080038d 	sth	r2,14(r16)
81127278:	80000415 	stw	zero,16(r16)
8112727c:	80000515 	stw	zero,20(r16)
81127280:	80000615 	stw	zero,24(r16)
81127284:	b80d883a 	mov	r6,r23
81127288:	000b883a 	mov	r5,zero
8112728c:	81001704 	addi	r4,r16,92
81127290:	111e8140 	call	8111e814 <memset>
81127294:	00800044 	movi	r2,1
81127298:	84000715 	stw	r16,28(r16)
8112729c:	85800815 	stw	r22,32(r16)
811272a0:	85400915 	stw	r21,36(r16)
811272a4:	85000a15 	stw	r20,40(r16)
811272a8:	84c00b15 	stw	r19,44(r16)
811272ac:	90800e15 	stw	r2,56(r18)
811272b0:	dfc00817 	ldw	ra,32(sp)
811272b4:	ddc00717 	ldw	r23,28(sp)
811272b8:	dd800617 	ldw	r22,24(sp)
811272bc:	dd400517 	ldw	r21,20(sp)
811272c0:	dd000417 	ldw	r20,16(sp)
811272c4:	dcc00317 	ldw	r19,12(sp)
811272c8:	dc800217 	ldw	r18,8(sp)
811272cc:	dc400117 	ldw	r17,4(sp)
811272d0:	dc000017 	ldw	r16,0(sp)
811272d4:	dec00904 	addi	sp,sp,36
811272d8:	f800283a 	ret

811272dc <__fp_lock>:
811272dc:	0005883a 	mov	r2,zero
811272e0:	f800283a 	ret

811272e4 <__sfmoreglue>:
811272e4:	defffc04 	addi	sp,sp,-16
811272e8:	de00012e 	bgeu	sp,et,811272f0 <__sfmoreglue+0xc>
811272ec:	003b68fa 	trap	3
811272f0:	dc400115 	stw	r17,4(sp)
811272f4:	2c7fffc4 	addi	r17,r5,-1
811272f8:	8c401a24 	muli	r17,r17,104
811272fc:	dc800215 	stw	r18,8(sp)
81127300:	2825883a 	mov	r18,r5
81127304:	89401d04 	addi	r5,r17,116
81127308:	dc000015 	stw	r16,0(sp)
8112730c:	dfc00315 	stw	ra,12(sp)
81127310:	111deb00 	call	8111deb0 <_malloc_r>
81127314:	1021883a 	mov	r16,r2
81127318:	10000726 	beq	r2,zero,81127338 <__sfmoreglue+0x54>
8112731c:	11000304 	addi	r4,r2,12
81127320:	10000015 	stw	zero,0(r2)
81127324:	14800115 	stw	r18,4(r2)
81127328:	11000215 	stw	r4,8(r2)
8112732c:	89801a04 	addi	r6,r17,104
81127330:	000b883a 	mov	r5,zero
81127334:	111e8140 	call	8111e814 <memset>
81127338:	8005883a 	mov	r2,r16
8112733c:	dfc00317 	ldw	ra,12(sp)
81127340:	dc800217 	ldw	r18,8(sp)
81127344:	dc400117 	ldw	r17,4(sp)
81127348:	dc000017 	ldw	r16,0(sp)
8112734c:	dec00404 	addi	sp,sp,16
81127350:	f800283a 	ret

81127354 <__sfp>:
81127354:	defffb04 	addi	sp,sp,-20
81127358:	de00012e 	bgeu	sp,et,81127360 <__sfp+0xc>
8112735c:	003b68fa 	trap	3
81127360:	dc000015 	stw	r16,0(sp)
81127364:	04204574 	movhi	r16,33045
81127368:	843d6204 	addi	r16,r16,-2680
8112736c:	dcc00315 	stw	r19,12(sp)
81127370:	2027883a 	mov	r19,r4
81127374:	81000017 	ldw	r4,0(r16)
81127378:	dfc00415 	stw	ra,16(sp)
8112737c:	dc800215 	stw	r18,8(sp)
81127380:	20800e17 	ldw	r2,56(r4)
81127384:	dc400115 	stw	r17,4(sp)
81127388:	1000021e 	bne	r2,zero,81127394 <__sfp+0x40>
8112738c:	11271380 	call	81127138 <__sinit.part.1>
81127390:	81000017 	ldw	r4,0(r16)
81127394:	2480b804 	addi	r18,r4,736
81127398:	047fffc4 	movi	r17,-1
8112739c:	91000117 	ldw	r4,4(r18)
811273a0:	94000217 	ldw	r16,8(r18)
811273a4:	213fffc4 	addi	r4,r4,-1
811273a8:	20000a16 	blt	r4,zero,811273d4 <__sfp+0x80>
811273ac:	8080030f 	ldh	r2,12(r16)
811273b0:	10000c26 	beq	r2,zero,811273e4 <__sfp+0x90>
811273b4:	80c01d04 	addi	r3,r16,116
811273b8:	00000206 	br	811273c4 <__sfp+0x70>
811273bc:	18bfe60f 	ldh	r2,-104(r3)
811273c0:	10000826 	beq	r2,zero,811273e4 <__sfp+0x90>
811273c4:	213fffc4 	addi	r4,r4,-1
811273c8:	1c3ffd04 	addi	r16,r3,-12
811273cc:	18c01a04 	addi	r3,r3,104
811273d0:	247ffa1e 	bne	r4,r17,811273bc <__reset+0xfb1073bc>
811273d4:	90800017 	ldw	r2,0(r18)
811273d8:	10001d26 	beq	r2,zero,81127450 <__sfp+0xfc>
811273dc:	1025883a 	mov	r18,r2
811273e0:	003fee06 	br	8112739c <__reset+0xfb10739c>
811273e4:	00bfffc4 	movi	r2,-1
811273e8:	8080038d 	sth	r2,14(r16)
811273ec:	00800044 	movi	r2,1
811273f0:	8080030d 	sth	r2,12(r16)
811273f4:	80001915 	stw	zero,100(r16)
811273f8:	80000015 	stw	zero,0(r16)
811273fc:	80000215 	stw	zero,8(r16)
81127400:	80000115 	stw	zero,4(r16)
81127404:	80000415 	stw	zero,16(r16)
81127408:	80000515 	stw	zero,20(r16)
8112740c:	80000615 	stw	zero,24(r16)
81127410:	01800204 	movi	r6,8
81127414:	000b883a 	mov	r5,zero
81127418:	81001704 	addi	r4,r16,92
8112741c:	111e8140 	call	8111e814 <memset>
81127420:	8005883a 	mov	r2,r16
81127424:	80000c15 	stw	zero,48(r16)
81127428:	80000d15 	stw	zero,52(r16)
8112742c:	80001115 	stw	zero,68(r16)
81127430:	80001215 	stw	zero,72(r16)
81127434:	dfc00417 	ldw	ra,16(sp)
81127438:	dcc00317 	ldw	r19,12(sp)
8112743c:	dc800217 	ldw	r18,8(sp)
81127440:	dc400117 	ldw	r17,4(sp)
81127444:	dc000017 	ldw	r16,0(sp)
81127448:	dec00504 	addi	sp,sp,20
8112744c:	f800283a 	ret
81127450:	01400104 	movi	r5,4
81127454:	9809883a 	mov	r4,r19
81127458:	11272e40 	call	811272e4 <__sfmoreglue>
8112745c:	90800015 	stw	r2,0(r18)
81127460:	103fde1e 	bne	r2,zero,811273dc <__reset+0xfb1073dc>
81127464:	00800304 	movi	r2,12
81127468:	98800015 	stw	r2,0(r19)
8112746c:	0005883a 	mov	r2,zero
81127470:	003ff006 	br	81127434 <__reset+0xfb107434>

81127474 <_cleanup>:
81127474:	00a04574 	movhi	r2,33045
81127478:	10bd6204 	addi	r2,r2,-2680
8112747c:	11000017 	ldw	r4,0(r2)
81127480:	016044f4 	movhi	r5,33043
81127484:	297bba04 	addi	r5,r5,-4376
81127488:	11281cc1 	jmpi	811281cc <_fwalk_reent>

8112748c <__sinit>:
8112748c:	20800e17 	ldw	r2,56(r4)
81127490:	10000126 	beq	r2,zero,81127498 <__sinit+0xc>
81127494:	f800283a 	ret
81127498:	11271381 	jmpi	81127138 <__sinit.part.1>

8112749c <__sfp_lock_acquire>:
8112749c:	f800283a 	ret

811274a0 <__sfp_lock_release>:
811274a0:	f800283a 	ret

811274a4 <__sinit_lock_acquire>:
811274a4:	f800283a 	ret

811274a8 <__sinit_lock_release>:
811274a8:	f800283a 	ret

811274ac <__fp_lock_all>:
811274ac:	00a04574 	movhi	r2,33045
811274b0:	10bd6304 	addi	r2,r2,-2676
811274b4:	11000017 	ldw	r4,0(r2)
811274b8:	016044b4 	movhi	r5,33042
811274bc:	295cb704 	addi	r5,r5,29404
811274c0:	11281001 	jmpi	81128100 <_fwalk>

811274c4 <__fp_unlock_all>:
811274c4:	00a04574 	movhi	r2,33045
811274c8:	10bd6304 	addi	r2,r2,-2676
811274cc:	11000017 	ldw	r4,0(r2)
811274d0:	016044b4 	movhi	r5,33042
811274d4:	295c4904 	addi	r5,r5,28964
811274d8:	11281001 	jmpi	81128100 <_fwalk>

811274dc <__sflags>:
811274dc:	28800007 	ldb	r2,0(r5)
811274e0:	00c01c84 	movi	r3,114
811274e4:	10c02426 	beq	r2,r3,81127578 <__sflags+0x9c>
811274e8:	00c01dc4 	movi	r3,119
811274ec:	10c01e26 	beq	r2,r3,81127568 <__sflags+0x8c>
811274f0:	00c01844 	movi	r3,97
811274f4:	10c00426 	beq	r2,r3,81127508 <__sflags+0x2c>
811274f8:	00800584 	movi	r2,22
811274fc:	20800015 	stw	r2,0(r4)
81127500:	0005883a 	mov	r2,zero
81127504:	f800283a 	ret
81127508:	02c08204 	movi	r11,520
8112750c:	01000044 	movi	r4,1
81127510:	00804204 	movi	r2,264
81127514:	01c00ac4 	movi	r7,43
81127518:	02bff8c4 	movi	r10,-29
8112751c:	027fff04 	movi	r9,-4
81127520:	02001e04 	movi	r8,120
81127524:	29400044 	addi	r5,r5,1
81127528:	28c00007 	ldb	r3,0(r5)
8112752c:	18000626 	beq	r3,zero,81127548 <__sflags+0x6c>
81127530:	19c00826 	beq	r3,r7,81127554 <__sflags+0x78>
81127534:	1a3ffb1e 	bne	r3,r8,81127524 <__reset+0xfb107524>
81127538:	29400044 	addi	r5,r5,1
8112753c:	28c00007 	ldb	r3,0(r5)
81127540:	21020014 	ori	r4,r4,2048
81127544:	183ffa1e 	bne	r3,zero,81127530 <__reset+0xfb107530>
81127548:	22c8b03a 	or	r4,r4,r11
8112754c:	31000015 	stw	r4,0(r6)
81127550:	f800283a 	ret
81127554:	1284703a 	and	r2,r2,r10
81127558:	2248703a 	and	r4,r4,r9
8112755c:	10800414 	ori	r2,r2,16
81127560:	21000094 	ori	r4,r4,2
81127564:	003fef06 	br	81127524 <__reset+0xfb107524>
81127568:	02c18004 	movi	r11,1536
8112756c:	01000044 	movi	r4,1
81127570:	00800204 	movi	r2,8
81127574:	003fe706 	br	81127514 <__reset+0xfb107514>
81127578:	0017883a 	mov	r11,zero
8112757c:	0009883a 	mov	r4,zero
81127580:	00800104 	movi	r2,4
81127584:	003fe306 	br	81127514 <__reset+0xfb107514>

81127588 <_fread_r>:
81127588:	defff404 	addi	sp,sp,-48
8112758c:	de00012e 	bgeu	sp,et,81127594 <_fread_r+0xc>
81127590:	003b68fa 	trap	3
81127594:	dd800815 	stw	r22,32(sp)
81127598:	39ad383a 	mul	r22,r7,r6
8112759c:	dc000215 	stw	r16,8(sp)
811275a0:	dfc00b15 	stw	ra,44(sp)
811275a4:	df000a15 	stw	fp,40(sp)
811275a8:	ddc00915 	stw	r23,36(sp)
811275ac:	dd400715 	stw	r21,28(sp)
811275b0:	dd000615 	stw	r20,24(sp)
811275b4:	dcc00515 	stw	r19,20(sp)
811275b8:	dc800415 	stw	r18,16(sp)
811275bc:	dc400315 	stw	r17,12(sp)
811275c0:	dc000c17 	ldw	r16,48(sp)
811275c4:	b0003b26 	beq	r22,zero,811276b4 <_fread_r+0x12c>
811275c8:	302f883a 	mov	r23,r6
811275cc:	382b883a 	mov	r21,r7
811275d0:	2029883a 	mov	r20,r4
811275d4:	2827883a 	mov	r19,r5
811275d8:	20000226 	beq	r4,zero,811275e4 <_fread_r+0x5c>
811275dc:	20800e17 	ldw	r2,56(r4)
811275e0:	10006e26 	beq	r2,zero,8112779c <_fread_r+0x214>
811275e4:	8080030b 	ldhu	r2,12(r16)
811275e8:	10c8000c 	andi	r3,r2,8192
811275ec:	1800061e 	bne	r3,zero,81127608 <_fread_r+0x80>
811275f0:	81001917 	ldw	r4,100(r16)
811275f4:	00f7ffc4 	movi	r3,-8193
811275f8:	10880014 	ori	r2,r2,8192
811275fc:	20c6703a 	and	r3,r4,r3
81127600:	8080030d 	sth	r2,12(r16)
81127604:	80c01915 	stw	r3,100(r16)
81127608:	84400117 	ldw	r17,4(r16)
8112760c:	88005f16 	blt	r17,zero,8112778c <_fread_r+0x204>
81127610:	8809883a 	mov	r4,r17
81127614:	1080008c 	andi	r2,r2,2
81127618:	1000281e 	bne	r2,zero,811276bc <_fread_r+0x134>
8112761c:	b025883a 	mov	r18,r22
81127620:	00000b06 	br	81127650 <_fread_r+0xc8>
81127624:	111e6c40 	call	8111e6c4 <memcpy>
81127628:	80800017 	ldw	r2,0(r16)
8112762c:	9c67883a 	add	r19,r19,r17
81127630:	9465c83a 	sub	r18,r18,r17
81127634:	1463883a 	add	r17,r2,r17
81127638:	800b883a 	mov	r5,r16
8112763c:	a009883a 	mov	r4,r20
81127640:	84400015 	stw	r17,0(r16)
81127644:	111ec900 	call	8111ec90 <__srefill_r>
81127648:	10004c1e 	bne	r2,zero,8112777c <_fread_r+0x1f4>
8112764c:	84400117 	ldw	r17,4(r16)
81127650:	880d883a 	mov	r6,r17
81127654:	9809883a 	mov	r4,r19
81127658:	81400017 	ldw	r5,0(r16)
8112765c:	8cbff136 	bltu	r17,r18,81127624 <__reset+0xfb107624>
81127660:	900d883a 	mov	r6,r18
81127664:	111e6c40 	call	8111e6c4 <memcpy>
81127668:	80c00117 	ldw	r3,4(r16)
8112766c:	81000017 	ldw	r4,0(r16)
81127670:	a805883a 	mov	r2,r21
81127674:	1c87c83a 	sub	r3,r3,r18
81127678:	24a5883a 	add	r18,r4,r18
8112767c:	80c00115 	stw	r3,4(r16)
81127680:	84800015 	stw	r18,0(r16)
81127684:	dfc00b17 	ldw	ra,44(sp)
81127688:	df000a17 	ldw	fp,40(sp)
8112768c:	ddc00917 	ldw	r23,36(sp)
81127690:	dd800817 	ldw	r22,32(sp)
81127694:	dd400717 	ldw	r21,28(sp)
81127698:	dd000617 	ldw	r20,24(sp)
8112769c:	dcc00517 	ldw	r19,20(sp)
811276a0:	dc800417 	ldw	r18,16(sp)
811276a4:	dc400317 	ldw	r17,12(sp)
811276a8:	dc000217 	ldw	r16,8(sp)
811276ac:	dec00c04 	addi	sp,sp,48
811276b0:	f800283a 	ret
811276b4:	0005883a 	mov	r2,zero
811276b8:	003ff206 	br	81127684 <__reset+0xfb107684>
811276bc:	b007883a 	mov	r3,r22
811276c0:	2580012e 	bgeu	r4,r22,811276c8 <_fread_r+0x140>
811276c4:	2007883a 	mov	r3,r4
811276c8:	81400017 	ldw	r5,0(r16)
811276cc:	180d883a 	mov	r6,r3
811276d0:	9809883a 	mov	r4,r19
811276d4:	d8c00115 	stw	r3,4(sp)
811276d8:	111e6c40 	call	8111e6c4 <memcpy>
811276dc:	d8c00117 	ldw	r3,4(sp)
811276e0:	84400017 	ldw	r17,0(r16)
811276e4:	80800117 	ldw	r2,4(r16)
811276e8:	81400c17 	ldw	r5,48(r16)
811276ec:	88e3883a 	add	r17,r17,r3
811276f0:	10c5c83a 	sub	r2,r2,r3
811276f4:	84400015 	stw	r17,0(r16)
811276f8:	80800115 	stw	r2,4(r16)
811276fc:	b0e5c83a 	sub	r18,r22,r3
81127700:	28002b26 	beq	r5,zero,811277b0 <_fread_r+0x228>
81127704:	90002b26 	beq	r18,zero,811277b4 <_fread_r+0x22c>
81127708:	80801004 	addi	r2,r16,64
8112770c:	28800526 	beq	r5,r2,81127724 <_fread_r+0x19c>
81127710:	a009883a 	mov	r4,r20
81127714:	d8c00115 	stw	r3,4(sp)
81127718:	11279240 	call	81127924 <_free_r>
8112771c:	d8c00117 	ldw	r3,4(sp)
81127720:	84400017 	ldw	r17,0(r16)
81127724:	80000c15 	stw	zero,48(r16)
81127728:	80800517 	ldw	r2,20(r16)
8112772c:	87000417 	ldw	fp,16(r16)
81127730:	98e7883a 	add	r19,r19,r3
81127734:	d8800015 	stw	r2,0(sp)
81127738:	00000106 	br	81127740 <_fread_r+0x1b8>
8112773c:	90001d26 	beq	r18,zero,811277b4 <_fread_r+0x22c>
81127740:	84c00415 	stw	r19,16(r16)
81127744:	84800515 	stw	r18,20(r16)
81127748:	84c00015 	stw	r19,0(r16)
8112774c:	a009883a 	mov	r4,r20
81127750:	800b883a 	mov	r5,r16
81127754:	111ec900 	call	8111ec90 <__srefill_r>
81127758:	d9000017 	ldw	r4,0(sp)
8112775c:	80c00117 	ldw	r3,4(r16)
81127760:	87000415 	stw	fp,16(r16)
81127764:	81000515 	stw	r4,20(r16)
81127768:	84400015 	stw	r17,0(r16)
8112776c:	80000115 	stw	zero,4(r16)
81127770:	90e5c83a 	sub	r18,r18,r3
81127774:	98e7883a 	add	r19,r19,r3
81127778:	103ff026 	beq	r2,zero,8112773c <__reset+0xfb10773c>
8112777c:	b80b883a 	mov	r5,r23
81127780:	b489c83a 	sub	r4,r22,r18
81127784:	1130cac0 	call	81130cac <__udivsi3>
81127788:	003fbe06 	br	81127684 <__reset+0xfb107684>
8112778c:	80000115 	stw	zero,4(r16)
81127790:	0009883a 	mov	r4,zero
81127794:	0023883a 	mov	r17,zero
81127798:	003f9e06 	br	81127614 <__reset+0xfb107614>
8112779c:	112748c0 	call	8112748c <__sinit>
811277a0:	8080030b 	ldhu	r2,12(r16)
811277a4:	10c8000c 	andi	r3,r2,8192
811277a8:	183f971e 	bne	r3,zero,81127608 <__reset+0xfb107608>
811277ac:	003f9006 	br	811275f0 <__reset+0xfb1075f0>
811277b0:	903fdd1e 	bne	r18,zero,81127728 <__reset+0xfb107728>
811277b4:	a805883a 	mov	r2,r21
811277b8:	003fb206 	br	81127684 <__reset+0xfb107684>

811277bc <fread>:
811277bc:	defffe04 	addi	sp,sp,-8
811277c0:	00a04574 	movhi	r2,33045
811277c4:	de00012e 	bgeu	sp,et,811277cc <fread+0x10>
811277c8:	003b68fa 	trap	3
811277cc:	10bd6304 	addi	r2,r2,-2676
811277d0:	d9c00015 	stw	r7,0(sp)
811277d4:	300f883a 	mov	r7,r6
811277d8:	280d883a 	mov	r6,r5
811277dc:	200b883a 	mov	r5,r4
811277e0:	11000017 	ldw	r4,0(r2)
811277e4:	dfc00115 	stw	ra,4(sp)
811277e8:	11275880 	call	81127588 <_fread_r>
811277ec:	dfc00117 	ldw	ra,4(sp)
811277f0:	dec00204 	addi	sp,sp,8
811277f4:	f800283a 	ret

811277f8 <_malloc_trim_r>:
811277f8:	defffb04 	addi	sp,sp,-20
811277fc:	de00012e 	bgeu	sp,et,81127804 <_malloc_trim_r+0xc>
81127800:	003b68fa 	trap	3
81127804:	dcc00315 	stw	r19,12(sp)
81127808:	04e04574 	movhi	r19,33045
8112780c:	dc800215 	stw	r18,8(sp)
81127810:	dc400115 	stw	r17,4(sp)
81127814:	dc000015 	stw	r16,0(sp)
81127818:	dfc00415 	stw	ra,16(sp)
8112781c:	2821883a 	mov	r16,r5
81127820:	9cf72104 	addi	r19,r19,-9084
81127824:	2025883a 	mov	r18,r4
81127828:	1134cac0 	call	81134cac <__malloc_lock>
8112782c:	98800217 	ldw	r2,8(r19)
81127830:	14400117 	ldw	r17,4(r2)
81127834:	00bfff04 	movi	r2,-4
81127838:	88a2703a 	and	r17,r17,r2
8112783c:	8c21c83a 	sub	r16,r17,r16
81127840:	8403fbc4 	addi	r16,r16,4079
81127844:	8020d33a 	srli	r16,r16,12
81127848:	0083ffc4 	movi	r2,4095
8112784c:	843fffc4 	addi	r16,r16,-1
81127850:	8020933a 	slli	r16,r16,12
81127854:	1400060e 	bge	r2,r16,81127870 <_malloc_trim_r+0x78>
81127858:	000b883a 	mov	r5,zero
8112785c:	9009883a 	mov	r4,r18
81127860:	111ee6c0 	call	8111ee6c <_sbrk_r>
81127864:	98c00217 	ldw	r3,8(r19)
81127868:	1c47883a 	add	r3,r3,r17
8112786c:	10c00a26 	beq	r2,r3,81127898 <_malloc_trim_r+0xa0>
81127870:	9009883a 	mov	r4,r18
81127874:	1134dd40 	call	81134dd4 <__malloc_unlock>
81127878:	0005883a 	mov	r2,zero
8112787c:	dfc00417 	ldw	ra,16(sp)
81127880:	dcc00317 	ldw	r19,12(sp)
81127884:	dc800217 	ldw	r18,8(sp)
81127888:	dc400117 	ldw	r17,4(sp)
8112788c:	dc000017 	ldw	r16,0(sp)
81127890:	dec00504 	addi	sp,sp,20
81127894:	f800283a 	ret
81127898:	040bc83a 	sub	r5,zero,r16
8112789c:	9009883a 	mov	r4,r18
811278a0:	111ee6c0 	call	8111ee6c <_sbrk_r>
811278a4:	00ffffc4 	movi	r3,-1
811278a8:	10c00d26 	beq	r2,r3,811278e0 <_malloc_trim_r+0xe8>
811278ac:	00e04574 	movhi	r3,33045
811278b0:	18fe6504 	addi	r3,r3,-1644
811278b4:	18800017 	ldw	r2,0(r3)
811278b8:	99000217 	ldw	r4,8(r19)
811278bc:	8c23c83a 	sub	r17,r17,r16
811278c0:	8c400054 	ori	r17,r17,1
811278c4:	1421c83a 	sub	r16,r2,r16
811278c8:	24400115 	stw	r17,4(r4)
811278cc:	9009883a 	mov	r4,r18
811278d0:	1c000015 	stw	r16,0(r3)
811278d4:	1134dd40 	call	81134dd4 <__malloc_unlock>
811278d8:	00800044 	movi	r2,1
811278dc:	003fe706 	br	8112787c <__reset+0xfb10787c>
811278e0:	000b883a 	mov	r5,zero
811278e4:	9009883a 	mov	r4,r18
811278e8:	111ee6c0 	call	8111ee6c <_sbrk_r>
811278ec:	99000217 	ldw	r4,8(r19)
811278f0:	014003c4 	movi	r5,15
811278f4:	1107c83a 	sub	r3,r2,r4
811278f8:	28ffdd0e 	bge	r5,r3,81127870 <__reset+0xfb107870>
811278fc:	01604574 	movhi	r5,33045
81127900:	297d6404 	addi	r5,r5,-2672
81127904:	29400017 	ldw	r5,0(r5)
81127908:	18c00054 	ori	r3,r3,1
8112790c:	20c00115 	stw	r3,4(r4)
81127910:	00e04574 	movhi	r3,33045
81127914:	1145c83a 	sub	r2,r2,r5
81127918:	18fe6504 	addi	r3,r3,-1644
8112791c:	18800015 	stw	r2,0(r3)
81127920:	003fd306 	br	81127870 <__reset+0xfb107870>

81127924 <_free_r>:
81127924:	28004326 	beq	r5,zero,81127a34 <_free_r+0x110>
81127928:	defffd04 	addi	sp,sp,-12
8112792c:	de00012e 	bgeu	sp,et,81127934 <_free_r+0x10>
81127930:	003b68fa 	trap	3
81127934:	dc400115 	stw	r17,4(sp)
81127938:	dc000015 	stw	r16,0(sp)
8112793c:	2023883a 	mov	r17,r4
81127940:	2821883a 	mov	r16,r5
81127944:	dfc00215 	stw	ra,8(sp)
81127948:	1134cac0 	call	81134cac <__malloc_lock>
8112794c:	81ffff17 	ldw	r7,-4(r16)
81127950:	00bfff84 	movi	r2,-2
81127954:	01204574 	movhi	r4,33045
81127958:	81bffe04 	addi	r6,r16,-8
8112795c:	3884703a 	and	r2,r7,r2
81127960:	21372104 	addi	r4,r4,-9084
81127964:	308b883a 	add	r5,r6,r2
81127968:	2a400117 	ldw	r9,4(r5)
8112796c:	22000217 	ldw	r8,8(r4)
81127970:	00ffff04 	movi	r3,-4
81127974:	48c6703a 	and	r3,r9,r3
81127978:	2a005726 	beq	r5,r8,81127ad8 <_free_r+0x1b4>
8112797c:	28c00115 	stw	r3,4(r5)
81127980:	39c0004c 	andi	r7,r7,1
81127984:	3800091e 	bne	r7,zero,811279ac <_free_r+0x88>
81127988:	823ffe17 	ldw	r8,-8(r16)
8112798c:	22400204 	addi	r9,r4,8
81127990:	320dc83a 	sub	r6,r6,r8
81127994:	31c00217 	ldw	r7,8(r6)
81127998:	1205883a 	add	r2,r2,r8
8112799c:	3a406526 	beq	r7,r9,81127b34 <_free_r+0x210>
811279a0:	32000317 	ldw	r8,12(r6)
811279a4:	3a000315 	stw	r8,12(r7)
811279a8:	41c00215 	stw	r7,8(r8)
811279ac:	28cf883a 	add	r7,r5,r3
811279b0:	39c00117 	ldw	r7,4(r7)
811279b4:	39c0004c 	andi	r7,r7,1
811279b8:	38003a26 	beq	r7,zero,81127aa4 <_free_r+0x180>
811279bc:	10c00054 	ori	r3,r2,1
811279c0:	30c00115 	stw	r3,4(r6)
811279c4:	3087883a 	add	r3,r6,r2
811279c8:	18800015 	stw	r2,0(r3)
811279cc:	00c07fc4 	movi	r3,511
811279d0:	18801936 	bltu	r3,r2,81127a38 <_free_r+0x114>
811279d4:	1004d0fa 	srli	r2,r2,3
811279d8:	01c00044 	movi	r7,1
811279dc:	21400117 	ldw	r5,4(r4)
811279e0:	10c00044 	addi	r3,r2,1
811279e4:	18c7883a 	add	r3,r3,r3
811279e8:	1005d0ba 	srai	r2,r2,2
811279ec:	18c7883a 	add	r3,r3,r3
811279f0:	18c7883a 	add	r3,r3,r3
811279f4:	1907883a 	add	r3,r3,r4
811279f8:	3884983a 	sll	r2,r7,r2
811279fc:	19c00017 	ldw	r7,0(r3)
81127a00:	1a3ffe04 	addi	r8,r3,-8
81127a04:	1144b03a 	or	r2,r2,r5
81127a08:	32000315 	stw	r8,12(r6)
81127a0c:	31c00215 	stw	r7,8(r6)
81127a10:	20800115 	stw	r2,4(r4)
81127a14:	19800015 	stw	r6,0(r3)
81127a18:	39800315 	stw	r6,12(r7)
81127a1c:	8809883a 	mov	r4,r17
81127a20:	dfc00217 	ldw	ra,8(sp)
81127a24:	dc400117 	ldw	r17,4(sp)
81127a28:	dc000017 	ldw	r16,0(sp)
81127a2c:	dec00304 	addi	sp,sp,12
81127a30:	1134dd41 	jmpi	81134dd4 <__malloc_unlock>
81127a34:	f800283a 	ret
81127a38:	100ad27a 	srli	r5,r2,9
81127a3c:	00c00104 	movi	r3,4
81127a40:	19404a36 	bltu	r3,r5,81127b6c <_free_r+0x248>
81127a44:	100ad1ba 	srli	r5,r2,6
81127a48:	28c00e44 	addi	r3,r5,57
81127a4c:	18c7883a 	add	r3,r3,r3
81127a50:	29400e04 	addi	r5,r5,56
81127a54:	18c7883a 	add	r3,r3,r3
81127a58:	18c7883a 	add	r3,r3,r3
81127a5c:	1909883a 	add	r4,r3,r4
81127a60:	20c00017 	ldw	r3,0(r4)
81127a64:	01e04574 	movhi	r7,33045
81127a68:	213ffe04 	addi	r4,r4,-8
81127a6c:	39f72104 	addi	r7,r7,-9084
81127a70:	20c04426 	beq	r4,r3,81127b84 <_free_r+0x260>
81127a74:	01ffff04 	movi	r7,-4
81127a78:	19400117 	ldw	r5,4(r3)
81127a7c:	29ca703a 	and	r5,r5,r7
81127a80:	1140022e 	bgeu	r2,r5,81127a8c <_free_r+0x168>
81127a84:	18c00217 	ldw	r3,8(r3)
81127a88:	20fffb1e 	bne	r4,r3,81127a78 <__reset+0xfb107a78>
81127a8c:	19000317 	ldw	r4,12(r3)
81127a90:	31000315 	stw	r4,12(r6)
81127a94:	30c00215 	stw	r3,8(r6)
81127a98:	21800215 	stw	r6,8(r4)
81127a9c:	19800315 	stw	r6,12(r3)
81127aa0:	003fde06 	br	81127a1c <__reset+0xfb107a1c>
81127aa4:	29c00217 	ldw	r7,8(r5)
81127aa8:	10c5883a 	add	r2,r2,r3
81127aac:	00e04574 	movhi	r3,33045
81127ab0:	18f72304 	addi	r3,r3,-9076
81127ab4:	38c03b26 	beq	r7,r3,81127ba4 <_free_r+0x280>
81127ab8:	2a000317 	ldw	r8,12(r5)
81127abc:	11400054 	ori	r5,r2,1
81127ac0:	3087883a 	add	r3,r6,r2
81127ac4:	3a000315 	stw	r8,12(r7)
81127ac8:	41c00215 	stw	r7,8(r8)
81127acc:	31400115 	stw	r5,4(r6)
81127ad0:	18800015 	stw	r2,0(r3)
81127ad4:	003fbd06 	br	811279cc <__reset+0xfb1079cc>
81127ad8:	39c0004c 	andi	r7,r7,1
81127adc:	10c5883a 	add	r2,r2,r3
81127ae0:	3800071e 	bne	r7,zero,81127b00 <_free_r+0x1dc>
81127ae4:	81fffe17 	ldw	r7,-8(r16)
81127ae8:	31cdc83a 	sub	r6,r6,r7
81127aec:	30c00317 	ldw	r3,12(r6)
81127af0:	31400217 	ldw	r5,8(r6)
81127af4:	11c5883a 	add	r2,r2,r7
81127af8:	28c00315 	stw	r3,12(r5)
81127afc:	19400215 	stw	r5,8(r3)
81127b00:	10c00054 	ori	r3,r2,1
81127b04:	30c00115 	stw	r3,4(r6)
81127b08:	00e04574 	movhi	r3,33045
81127b0c:	18fd6504 	addi	r3,r3,-2668
81127b10:	18c00017 	ldw	r3,0(r3)
81127b14:	21800215 	stw	r6,8(r4)
81127b18:	10ffc036 	bltu	r2,r3,81127a1c <__reset+0xfb107a1c>
81127b1c:	00a04574 	movhi	r2,33045
81127b20:	10bdd804 	addi	r2,r2,-2208
81127b24:	11400017 	ldw	r5,0(r2)
81127b28:	8809883a 	mov	r4,r17
81127b2c:	11277f80 	call	811277f8 <_malloc_trim_r>
81127b30:	003fba06 	br	81127a1c <__reset+0xfb107a1c>
81127b34:	28c9883a 	add	r4,r5,r3
81127b38:	21000117 	ldw	r4,4(r4)
81127b3c:	2100004c 	andi	r4,r4,1
81127b40:	2000391e 	bne	r4,zero,81127c28 <_free_r+0x304>
81127b44:	29c00217 	ldw	r7,8(r5)
81127b48:	29000317 	ldw	r4,12(r5)
81127b4c:	1885883a 	add	r2,r3,r2
81127b50:	10c00054 	ori	r3,r2,1
81127b54:	39000315 	stw	r4,12(r7)
81127b58:	21c00215 	stw	r7,8(r4)
81127b5c:	30c00115 	stw	r3,4(r6)
81127b60:	308d883a 	add	r6,r6,r2
81127b64:	30800015 	stw	r2,0(r6)
81127b68:	003fac06 	br	81127a1c <__reset+0xfb107a1c>
81127b6c:	00c00504 	movi	r3,20
81127b70:	19401536 	bltu	r3,r5,81127bc8 <_free_r+0x2a4>
81127b74:	28c01704 	addi	r3,r5,92
81127b78:	18c7883a 	add	r3,r3,r3
81127b7c:	294016c4 	addi	r5,r5,91
81127b80:	003fb406 	br	81127a54 <__reset+0xfb107a54>
81127b84:	280bd0ba 	srai	r5,r5,2
81127b88:	00c00044 	movi	r3,1
81127b8c:	38800117 	ldw	r2,4(r7)
81127b90:	194a983a 	sll	r5,r3,r5
81127b94:	2007883a 	mov	r3,r4
81127b98:	2884b03a 	or	r2,r5,r2
81127b9c:	38800115 	stw	r2,4(r7)
81127ba0:	003fbb06 	br	81127a90 <__reset+0xfb107a90>
81127ba4:	21800515 	stw	r6,20(r4)
81127ba8:	21800415 	stw	r6,16(r4)
81127bac:	10c00054 	ori	r3,r2,1
81127bb0:	31c00315 	stw	r7,12(r6)
81127bb4:	31c00215 	stw	r7,8(r6)
81127bb8:	30c00115 	stw	r3,4(r6)
81127bbc:	308d883a 	add	r6,r6,r2
81127bc0:	30800015 	stw	r2,0(r6)
81127bc4:	003f9506 	br	81127a1c <__reset+0xfb107a1c>
81127bc8:	00c01504 	movi	r3,84
81127bcc:	19400536 	bltu	r3,r5,81127be4 <_free_r+0x2c0>
81127bd0:	100ad33a 	srli	r5,r2,12
81127bd4:	28c01bc4 	addi	r3,r5,111
81127bd8:	18c7883a 	add	r3,r3,r3
81127bdc:	29401b84 	addi	r5,r5,110
81127be0:	003f9c06 	br	81127a54 <__reset+0xfb107a54>
81127be4:	00c05504 	movi	r3,340
81127be8:	19400536 	bltu	r3,r5,81127c00 <_free_r+0x2dc>
81127bec:	100ad3fa 	srli	r5,r2,15
81127bf0:	28c01e04 	addi	r3,r5,120
81127bf4:	18c7883a 	add	r3,r3,r3
81127bf8:	29401dc4 	addi	r5,r5,119
81127bfc:	003f9506 	br	81127a54 <__reset+0xfb107a54>
81127c00:	00c15504 	movi	r3,1364
81127c04:	19400536 	bltu	r3,r5,81127c1c <_free_r+0x2f8>
81127c08:	100ad4ba 	srli	r5,r2,18
81127c0c:	28c01f44 	addi	r3,r5,125
81127c10:	18c7883a 	add	r3,r3,r3
81127c14:	29401f04 	addi	r5,r5,124
81127c18:	003f8e06 	br	81127a54 <__reset+0xfb107a54>
81127c1c:	00c03f84 	movi	r3,254
81127c20:	01401f84 	movi	r5,126
81127c24:	003f8b06 	br	81127a54 <__reset+0xfb107a54>
81127c28:	10c00054 	ori	r3,r2,1
81127c2c:	30c00115 	stw	r3,4(r6)
81127c30:	308d883a 	add	r6,r6,r2
81127c34:	30800015 	stw	r2,0(r6)
81127c38:	003f7806 	br	81127a1c <__reset+0xfb107a1c>

81127c3c <__sfvwrite_r>:
81127c3c:	30800217 	ldw	r2,8(r6)
81127c40:	10006926 	beq	r2,zero,81127de8 <__sfvwrite_r+0x1ac>
81127c44:	defff404 	addi	sp,sp,-48
81127c48:	de00012e 	bgeu	sp,et,81127c50 <__sfvwrite_r+0x14>
81127c4c:	003b68fa 	trap	3
81127c50:	28c0030b 	ldhu	r3,12(r5)
81127c54:	dd400715 	stw	r21,28(sp)
81127c58:	dd000615 	stw	r20,24(sp)
81127c5c:	dc000215 	stw	r16,8(sp)
81127c60:	dfc00b15 	stw	ra,44(sp)
81127c64:	df000a15 	stw	fp,40(sp)
81127c68:	ddc00915 	stw	r23,36(sp)
81127c6c:	dd800815 	stw	r22,32(sp)
81127c70:	dcc00515 	stw	r19,20(sp)
81127c74:	dc800415 	stw	r18,16(sp)
81127c78:	dc400315 	stw	r17,12(sp)
81127c7c:	1880020c 	andi	r2,r3,8
81127c80:	2821883a 	mov	r16,r5
81127c84:	202b883a 	mov	r21,r4
81127c88:	3029883a 	mov	r20,r6
81127c8c:	10002726 	beq	r2,zero,81127d2c <__sfvwrite_r+0xf0>
81127c90:	28800417 	ldw	r2,16(r5)
81127c94:	10002526 	beq	r2,zero,81127d2c <__sfvwrite_r+0xf0>
81127c98:	1880008c 	andi	r2,r3,2
81127c9c:	a4400017 	ldw	r17,0(r20)
81127ca0:	10002a26 	beq	r2,zero,81127d4c <__sfvwrite_r+0x110>
81127ca4:	05a00034 	movhi	r22,32768
81127ca8:	0027883a 	mov	r19,zero
81127cac:	0025883a 	mov	r18,zero
81127cb0:	b5bf0004 	addi	r22,r22,-1024
81127cb4:	980d883a 	mov	r6,r19
81127cb8:	a809883a 	mov	r4,r21
81127cbc:	90004626 	beq	r18,zero,81127dd8 <__sfvwrite_r+0x19c>
81127cc0:	900f883a 	mov	r7,r18
81127cc4:	b480022e 	bgeu	r22,r18,81127cd0 <__sfvwrite_r+0x94>
81127cc8:	01e00034 	movhi	r7,32768
81127ccc:	39ff0004 	addi	r7,r7,-1024
81127cd0:	80800917 	ldw	r2,36(r16)
81127cd4:	81400717 	ldw	r5,28(r16)
81127cd8:	103ee83a 	callr	r2
81127cdc:	0080570e 	bge	zero,r2,81127e3c <__sfvwrite_r+0x200>
81127ce0:	a0c00217 	ldw	r3,8(r20)
81127ce4:	98a7883a 	add	r19,r19,r2
81127ce8:	90a5c83a 	sub	r18,r18,r2
81127cec:	1885c83a 	sub	r2,r3,r2
81127cf0:	a0800215 	stw	r2,8(r20)
81127cf4:	103fef1e 	bne	r2,zero,81127cb4 <__reset+0xfb107cb4>
81127cf8:	0005883a 	mov	r2,zero
81127cfc:	dfc00b17 	ldw	ra,44(sp)
81127d00:	df000a17 	ldw	fp,40(sp)
81127d04:	ddc00917 	ldw	r23,36(sp)
81127d08:	dd800817 	ldw	r22,32(sp)
81127d0c:	dd400717 	ldw	r21,28(sp)
81127d10:	dd000617 	ldw	r20,24(sp)
81127d14:	dcc00517 	ldw	r19,20(sp)
81127d18:	dc800417 	ldw	r18,16(sp)
81127d1c:	dc400317 	ldw	r17,12(sp)
81127d20:	dc000217 	ldw	r16,8(sp)
81127d24:	dec00c04 	addi	sp,sp,48
81127d28:	f800283a 	ret
81127d2c:	800b883a 	mov	r5,r16
81127d30:	a809883a 	mov	r4,r21
81127d34:	112541c0 	call	8112541c <__swsetup_r>
81127d38:	1000eb1e 	bne	r2,zero,811280e8 <__sfvwrite_r+0x4ac>
81127d3c:	80c0030b 	ldhu	r3,12(r16)
81127d40:	a4400017 	ldw	r17,0(r20)
81127d44:	1880008c 	andi	r2,r3,2
81127d48:	103fd61e 	bne	r2,zero,81127ca4 <__reset+0xfb107ca4>
81127d4c:	1880004c 	andi	r2,r3,1
81127d50:	10003f1e 	bne	r2,zero,81127e50 <__sfvwrite_r+0x214>
81127d54:	0039883a 	mov	fp,zero
81127d58:	0025883a 	mov	r18,zero
81127d5c:	90001a26 	beq	r18,zero,81127dc8 <__sfvwrite_r+0x18c>
81127d60:	1880800c 	andi	r2,r3,512
81127d64:	84c00217 	ldw	r19,8(r16)
81127d68:	10002126 	beq	r2,zero,81127df0 <__sfvwrite_r+0x1b4>
81127d6c:	982f883a 	mov	r23,r19
81127d70:	94c09336 	bltu	r18,r19,81127fc0 <__sfvwrite_r+0x384>
81127d74:	1881200c 	andi	r2,r3,1152
81127d78:	10009e1e 	bne	r2,zero,81127ff4 <__sfvwrite_r+0x3b8>
81127d7c:	81000017 	ldw	r4,0(r16)
81127d80:	b80d883a 	mov	r6,r23
81127d84:	e00b883a 	mov	r5,fp
81127d88:	11287980 	call	81128798 <memmove>
81127d8c:	80c00217 	ldw	r3,8(r16)
81127d90:	81000017 	ldw	r4,0(r16)
81127d94:	9005883a 	mov	r2,r18
81127d98:	1ce7c83a 	sub	r19,r3,r19
81127d9c:	25cf883a 	add	r7,r4,r23
81127da0:	84c00215 	stw	r19,8(r16)
81127da4:	81c00015 	stw	r7,0(r16)
81127da8:	a0c00217 	ldw	r3,8(r20)
81127dac:	e0b9883a 	add	fp,fp,r2
81127db0:	90a5c83a 	sub	r18,r18,r2
81127db4:	18a7c83a 	sub	r19,r3,r2
81127db8:	a4c00215 	stw	r19,8(r20)
81127dbc:	983fce26 	beq	r19,zero,81127cf8 <__reset+0xfb107cf8>
81127dc0:	80c0030b 	ldhu	r3,12(r16)
81127dc4:	903fe61e 	bne	r18,zero,81127d60 <__reset+0xfb107d60>
81127dc8:	8f000017 	ldw	fp,0(r17)
81127dcc:	8c800117 	ldw	r18,4(r17)
81127dd0:	8c400204 	addi	r17,r17,8
81127dd4:	003fe106 	br	81127d5c <__reset+0xfb107d5c>
81127dd8:	8cc00017 	ldw	r19,0(r17)
81127ddc:	8c800117 	ldw	r18,4(r17)
81127de0:	8c400204 	addi	r17,r17,8
81127de4:	003fb306 	br	81127cb4 <__reset+0xfb107cb4>
81127de8:	0005883a 	mov	r2,zero
81127dec:	f800283a 	ret
81127df0:	81000017 	ldw	r4,0(r16)
81127df4:	80800417 	ldw	r2,16(r16)
81127df8:	11005736 	bltu	r2,r4,81127f58 <__sfvwrite_r+0x31c>
81127dfc:	85c00517 	ldw	r23,20(r16)
81127e00:	95c05536 	bltu	r18,r23,81127f58 <__sfvwrite_r+0x31c>
81127e04:	00a00034 	movhi	r2,32768
81127e08:	10bfffc4 	addi	r2,r2,-1
81127e0c:	9009883a 	mov	r4,r18
81127e10:	1480012e 	bgeu	r2,r18,81127e18 <__sfvwrite_r+0x1dc>
81127e14:	1009883a 	mov	r4,r2
81127e18:	b80b883a 	mov	r5,r23
81127e1c:	1130bb40 	call	81130bb4 <__divsi3>
81127e20:	15cf383a 	mul	r7,r2,r23
81127e24:	81400717 	ldw	r5,28(r16)
81127e28:	80800917 	ldw	r2,36(r16)
81127e2c:	e00d883a 	mov	r6,fp
81127e30:	a809883a 	mov	r4,r21
81127e34:	103ee83a 	callr	r2
81127e38:	00bfdb16 	blt	zero,r2,81127da8 <__reset+0xfb107da8>
81127e3c:	8080030b 	ldhu	r2,12(r16)
81127e40:	10801014 	ori	r2,r2,64
81127e44:	8080030d 	sth	r2,12(r16)
81127e48:	00bfffc4 	movi	r2,-1
81127e4c:	003fab06 	br	81127cfc <__reset+0xfb107cfc>
81127e50:	0027883a 	mov	r19,zero
81127e54:	0011883a 	mov	r8,zero
81127e58:	0039883a 	mov	fp,zero
81127e5c:	0025883a 	mov	r18,zero
81127e60:	90001f26 	beq	r18,zero,81127ee0 <__sfvwrite_r+0x2a4>
81127e64:	40005a26 	beq	r8,zero,81127fd0 <__sfvwrite_r+0x394>
81127e68:	982d883a 	mov	r22,r19
81127e6c:	94c0012e 	bgeu	r18,r19,81127e74 <__sfvwrite_r+0x238>
81127e70:	902d883a 	mov	r22,r18
81127e74:	81000017 	ldw	r4,0(r16)
81127e78:	80800417 	ldw	r2,16(r16)
81127e7c:	b02f883a 	mov	r23,r22
81127e80:	81c00517 	ldw	r7,20(r16)
81127e84:	1100032e 	bgeu	r2,r4,81127e94 <__sfvwrite_r+0x258>
81127e88:	80c00217 	ldw	r3,8(r16)
81127e8c:	38c7883a 	add	r3,r7,r3
81127e90:	1d801816 	blt	r3,r22,81127ef4 <__sfvwrite_r+0x2b8>
81127e94:	b1c03e16 	blt	r22,r7,81127f90 <__sfvwrite_r+0x354>
81127e98:	80800917 	ldw	r2,36(r16)
81127e9c:	81400717 	ldw	r5,28(r16)
81127ea0:	e00d883a 	mov	r6,fp
81127ea4:	da000115 	stw	r8,4(sp)
81127ea8:	a809883a 	mov	r4,r21
81127eac:	103ee83a 	callr	r2
81127eb0:	102f883a 	mov	r23,r2
81127eb4:	da000117 	ldw	r8,4(sp)
81127eb8:	00bfe00e 	bge	zero,r2,81127e3c <__reset+0xfb107e3c>
81127ebc:	9de7c83a 	sub	r19,r19,r23
81127ec0:	98001f26 	beq	r19,zero,81127f40 <__sfvwrite_r+0x304>
81127ec4:	a0800217 	ldw	r2,8(r20)
81127ec8:	e5f9883a 	add	fp,fp,r23
81127ecc:	95e5c83a 	sub	r18,r18,r23
81127ed0:	15efc83a 	sub	r23,r2,r23
81127ed4:	a5c00215 	stw	r23,8(r20)
81127ed8:	b83f8726 	beq	r23,zero,81127cf8 <__reset+0xfb107cf8>
81127edc:	903fe11e 	bne	r18,zero,81127e64 <__reset+0xfb107e64>
81127ee0:	8f000017 	ldw	fp,0(r17)
81127ee4:	8c800117 	ldw	r18,4(r17)
81127ee8:	0011883a 	mov	r8,zero
81127eec:	8c400204 	addi	r17,r17,8
81127ef0:	003fdb06 	br	81127e60 <__reset+0xfb107e60>
81127ef4:	180d883a 	mov	r6,r3
81127ef8:	e00b883a 	mov	r5,fp
81127efc:	da000115 	stw	r8,4(sp)
81127f00:	d8c00015 	stw	r3,0(sp)
81127f04:	11287980 	call	81128798 <memmove>
81127f08:	d8c00017 	ldw	r3,0(sp)
81127f0c:	80800017 	ldw	r2,0(r16)
81127f10:	800b883a 	mov	r5,r16
81127f14:	a809883a 	mov	r4,r21
81127f18:	10c5883a 	add	r2,r2,r3
81127f1c:	80800015 	stw	r2,0(r16)
81127f20:	d8c00015 	stw	r3,0(sp)
81127f24:	11270900 	call	81127090 <_fflush_r>
81127f28:	d8c00017 	ldw	r3,0(sp)
81127f2c:	da000117 	ldw	r8,4(sp)
81127f30:	103fc21e 	bne	r2,zero,81127e3c <__reset+0xfb107e3c>
81127f34:	182f883a 	mov	r23,r3
81127f38:	9de7c83a 	sub	r19,r19,r23
81127f3c:	983fe11e 	bne	r19,zero,81127ec4 <__reset+0xfb107ec4>
81127f40:	800b883a 	mov	r5,r16
81127f44:	a809883a 	mov	r4,r21
81127f48:	11270900 	call	81127090 <_fflush_r>
81127f4c:	103fbb1e 	bne	r2,zero,81127e3c <__reset+0xfb107e3c>
81127f50:	0011883a 	mov	r8,zero
81127f54:	003fdb06 	br	81127ec4 <__reset+0xfb107ec4>
81127f58:	94c0012e 	bgeu	r18,r19,81127f60 <__sfvwrite_r+0x324>
81127f5c:	9027883a 	mov	r19,r18
81127f60:	980d883a 	mov	r6,r19
81127f64:	e00b883a 	mov	r5,fp
81127f68:	11287980 	call	81128798 <memmove>
81127f6c:	80800217 	ldw	r2,8(r16)
81127f70:	80c00017 	ldw	r3,0(r16)
81127f74:	14c5c83a 	sub	r2,r2,r19
81127f78:	1cc7883a 	add	r3,r3,r19
81127f7c:	80800215 	stw	r2,8(r16)
81127f80:	80c00015 	stw	r3,0(r16)
81127f84:	10004326 	beq	r2,zero,81128094 <__sfvwrite_r+0x458>
81127f88:	9805883a 	mov	r2,r19
81127f8c:	003f8606 	br	81127da8 <__reset+0xfb107da8>
81127f90:	b00d883a 	mov	r6,r22
81127f94:	e00b883a 	mov	r5,fp
81127f98:	da000115 	stw	r8,4(sp)
81127f9c:	11287980 	call	81128798 <memmove>
81127fa0:	80800217 	ldw	r2,8(r16)
81127fa4:	80c00017 	ldw	r3,0(r16)
81127fa8:	da000117 	ldw	r8,4(sp)
81127fac:	1585c83a 	sub	r2,r2,r22
81127fb0:	1dad883a 	add	r22,r3,r22
81127fb4:	80800215 	stw	r2,8(r16)
81127fb8:	85800015 	stw	r22,0(r16)
81127fbc:	003fbf06 	br	81127ebc <__reset+0xfb107ebc>
81127fc0:	81000017 	ldw	r4,0(r16)
81127fc4:	9027883a 	mov	r19,r18
81127fc8:	902f883a 	mov	r23,r18
81127fcc:	003f6c06 	br	81127d80 <__reset+0xfb107d80>
81127fd0:	900d883a 	mov	r6,r18
81127fd4:	01400284 	movi	r5,10
81127fd8:	e009883a 	mov	r4,fp
81127fdc:	11286b40 	call	811286b4 <memchr>
81127fe0:	10003e26 	beq	r2,zero,811280dc <__sfvwrite_r+0x4a0>
81127fe4:	10800044 	addi	r2,r2,1
81127fe8:	1727c83a 	sub	r19,r2,fp
81127fec:	02000044 	movi	r8,1
81127ff0:	003f9d06 	br	81127e68 <__reset+0xfb107e68>
81127ff4:	80800517 	ldw	r2,20(r16)
81127ff8:	81400417 	ldw	r5,16(r16)
81127ffc:	81c00017 	ldw	r7,0(r16)
81128000:	10a7883a 	add	r19,r2,r2
81128004:	9885883a 	add	r2,r19,r2
81128008:	1026d7fa 	srli	r19,r2,31
8112800c:	396dc83a 	sub	r22,r7,r5
81128010:	b1000044 	addi	r4,r22,1
81128014:	9885883a 	add	r2,r19,r2
81128018:	1027d07a 	srai	r19,r2,1
8112801c:	2485883a 	add	r2,r4,r18
81128020:	980d883a 	mov	r6,r19
81128024:	9880022e 	bgeu	r19,r2,81128030 <__sfvwrite_r+0x3f4>
81128028:	1027883a 	mov	r19,r2
8112802c:	100d883a 	mov	r6,r2
81128030:	18c1000c 	andi	r3,r3,1024
81128034:	18001c26 	beq	r3,zero,811280a8 <__sfvwrite_r+0x46c>
81128038:	300b883a 	mov	r5,r6
8112803c:	a809883a 	mov	r4,r21
81128040:	111deb00 	call	8111deb0 <_malloc_r>
81128044:	102f883a 	mov	r23,r2
81128048:	10002926 	beq	r2,zero,811280f0 <__sfvwrite_r+0x4b4>
8112804c:	81400417 	ldw	r5,16(r16)
81128050:	b00d883a 	mov	r6,r22
81128054:	1009883a 	mov	r4,r2
81128058:	111e6c40 	call	8111e6c4 <memcpy>
8112805c:	8080030b 	ldhu	r2,12(r16)
81128060:	00fedfc4 	movi	r3,-1153
81128064:	10c4703a 	and	r2,r2,r3
81128068:	10802014 	ori	r2,r2,128
8112806c:	8080030d 	sth	r2,12(r16)
81128070:	bd89883a 	add	r4,r23,r22
81128074:	9d8fc83a 	sub	r7,r19,r22
81128078:	85c00415 	stw	r23,16(r16)
8112807c:	84c00515 	stw	r19,20(r16)
81128080:	81000015 	stw	r4,0(r16)
81128084:	9027883a 	mov	r19,r18
81128088:	81c00215 	stw	r7,8(r16)
8112808c:	902f883a 	mov	r23,r18
81128090:	003f3b06 	br	81127d80 <__reset+0xfb107d80>
81128094:	800b883a 	mov	r5,r16
81128098:	a809883a 	mov	r4,r21
8112809c:	11270900 	call	81127090 <_fflush_r>
811280a0:	103fb926 	beq	r2,zero,81127f88 <__reset+0xfb107f88>
811280a4:	003f6506 	br	81127e3c <__reset+0xfb107e3c>
811280a8:	a809883a 	mov	r4,r21
811280ac:	11299b80 	call	811299b8 <_realloc_r>
811280b0:	102f883a 	mov	r23,r2
811280b4:	103fee1e 	bne	r2,zero,81128070 <__reset+0xfb108070>
811280b8:	81400417 	ldw	r5,16(r16)
811280bc:	a809883a 	mov	r4,r21
811280c0:	11279240 	call	81127924 <_free_r>
811280c4:	8080030b 	ldhu	r2,12(r16)
811280c8:	00ffdfc4 	movi	r3,-129
811280cc:	1884703a 	and	r2,r3,r2
811280d0:	00c00304 	movi	r3,12
811280d4:	a8c00015 	stw	r3,0(r21)
811280d8:	003f5906 	br	81127e40 <__reset+0xfb107e40>
811280dc:	94c00044 	addi	r19,r18,1
811280e0:	02000044 	movi	r8,1
811280e4:	003f6006 	br	81127e68 <__reset+0xfb107e68>
811280e8:	00bfffc4 	movi	r2,-1
811280ec:	003f0306 	br	81127cfc <__reset+0xfb107cfc>
811280f0:	00800304 	movi	r2,12
811280f4:	a8800015 	stw	r2,0(r21)
811280f8:	8080030b 	ldhu	r2,12(r16)
811280fc:	003f5006 	br	81127e40 <__reset+0xfb107e40>

81128100 <_fwalk>:
81128100:	defff704 	addi	sp,sp,-36
81128104:	de00012e 	bgeu	sp,et,8112810c <_fwalk+0xc>
81128108:	003b68fa 	trap	3
8112810c:	dd000415 	stw	r20,16(sp)
81128110:	dfc00815 	stw	ra,32(sp)
81128114:	ddc00715 	stw	r23,28(sp)
81128118:	dd800615 	stw	r22,24(sp)
8112811c:	dd400515 	stw	r21,20(sp)
81128120:	dcc00315 	stw	r19,12(sp)
81128124:	dc800215 	stw	r18,8(sp)
81128128:	dc400115 	stw	r17,4(sp)
8112812c:	dc000015 	stw	r16,0(sp)
81128130:	2500b804 	addi	r20,r4,736
81128134:	a0002326 	beq	r20,zero,811281c4 <_fwalk+0xc4>
81128138:	282b883a 	mov	r21,r5
8112813c:	002f883a 	mov	r23,zero
81128140:	05800044 	movi	r22,1
81128144:	04ffffc4 	movi	r19,-1
81128148:	a4400117 	ldw	r17,4(r20)
8112814c:	a4800217 	ldw	r18,8(r20)
81128150:	8c7fffc4 	addi	r17,r17,-1
81128154:	88000d16 	blt	r17,zero,8112818c <_fwalk+0x8c>
81128158:	94000304 	addi	r16,r18,12
8112815c:	94800384 	addi	r18,r18,14
81128160:	8080000b 	ldhu	r2,0(r16)
81128164:	8c7fffc4 	addi	r17,r17,-1
81128168:	813ffd04 	addi	r4,r16,-12
8112816c:	b080042e 	bgeu	r22,r2,81128180 <_fwalk+0x80>
81128170:	9080000f 	ldh	r2,0(r18)
81128174:	14c00226 	beq	r2,r19,81128180 <_fwalk+0x80>
81128178:	a83ee83a 	callr	r21
8112817c:	b8aeb03a 	or	r23,r23,r2
81128180:	84001a04 	addi	r16,r16,104
81128184:	94801a04 	addi	r18,r18,104
81128188:	8cfff51e 	bne	r17,r19,81128160 <__reset+0xfb108160>
8112818c:	a5000017 	ldw	r20,0(r20)
81128190:	a03fed1e 	bne	r20,zero,81128148 <__reset+0xfb108148>
81128194:	b805883a 	mov	r2,r23
81128198:	dfc00817 	ldw	ra,32(sp)
8112819c:	ddc00717 	ldw	r23,28(sp)
811281a0:	dd800617 	ldw	r22,24(sp)
811281a4:	dd400517 	ldw	r21,20(sp)
811281a8:	dd000417 	ldw	r20,16(sp)
811281ac:	dcc00317 	ldw	r19,12(sp)
811281b0:	dc800217 	ldw	r18,8(sp)
811281b4:	dc400117 	ldw	r17,4(sp)
811281b8:	dc000017 	ldw	r16,0(sp)
811281bc:	dec00904 	addi	sp,sp,36
811281c0:	f800283a 	ret
811281c4:	002f883a 	mov	r23,zero
811281c8:	003ff206 	br	81128194 <__reset+0xfb108194>

811281cc <_fwalk_reent>:
811281cc:	defff704 	addi	sp,sp,-36
811281d0:	de00012e 	bgeu	sp,et,811281d8 <_fwalk_reent+0xc>
811281d4:	003b68fa 	trap	3
811281d8:	dd000415 	stw	r20,16(sp)
811281dc:	dfc00815 	stw	ra,32(sp)
811281e0:	ddc00715 	stw	r23,28(sp)
811281e4:	dd800615 	stw	r22,24(sp)
811281e8:	dd400515 	stw	r21,20(sp)
811281ec:	dcc00315 	stw	r19,12(sp)
811281f0:	dc800215 	stw	r18,8(sp)
811281f4:	dc400115 	stw	r17,4(sp)
811281f8:	dc000015 	stw	r16,0(sp)
811281fc:	2500b804 	addi	r20,r4,736
81128200:	a0002326 	beq	r20,zero,81128290 <_fwalk_reent+0xc4>
81128204:	282b883a 	mov	r21,r5
81128208:	2027883a 	mov	r19,r4
8112820c:	002f883a 	mov	r23,zero
81128210:	05800044 	movi	r22,1
81128214:	04bfffc4 	movi	r18,-1
81128218:	a4400117 	ldw	r17,4(r20)
8112821c:	a4000217 	ldw	r16,8(r20)
81128220:	8c7fffc4 	addi	r17,r17,-1
81128224:	88000c16 	blt	r17,zero,81128258 <_fwalk_reent+0x8c>
81128228:	84000304 	addi	r16,r16,12
8112822c:	8080000b 	ldhu	r2,0(r16)
81128230:	8c7fffc4 	addi	r17,r17,-1
81128234:	817ffd04 	addi	r5,r16,-12
81128238:	b080052e 	bgeu	r22,r2,81128250 <_fwalk_reent+0x84>
8112823c:	8080008f 	ldh	r2,2(r16)
81128240:	9809883a 	mov	r4,r19
81128244:	14800226 	beq	r2,r18,81128250 <_fwalk_reent+0x84>
81128248:	a83ee83a 	callr	r21
8112824c:	b8aeb03a 	or	r23,r23,r2
81128250:	84001a04 	addi	r16,r16,104
81128254:	8cbff51e 	bne	r17,r18,8112822c <__reset+0xfb10822c>
81128258:	a5000017 	ldw	r20,0(r20)
8112825c:	a03fee1e 	bne	r20,zero,81128218 <__reset+0xfb108218>
81128260:	b805883a 	mov	r2,r23
81128264:	dfc00817 	ldw	ra,32(sp)
81128268:	ddc00717 	ldw	r23,28(sp)
8112826c:	dd800617 	ldw	r22,24(sp)
81128270:	dd400517 	ldw	r21,20(sp)
81128274:	dd000417 	ldw	r20,16(sp)
81128278:	dcc00317 	ldw	r19,12(sp)
8112827c:	dc800217 	ldw	r18,8(sp)
81128280:	dc400117 	ldw	r17,4(sp)
81128284:	dc000017 	ldw	r16,0(sp)
81128288:	dec00904 	addi	sp,sp,36
8112828c:	f800283a 	ret
81128290:	002f883a 	mov	r23,zero
81128294:	003ff206 	br	81128260 <__reset+0xfb108260>

81128298 <_isatty_r>:
81128298:	defffd04 	addi	sp,sp,-12
8112829c:	de00012e 	bgeu	sp,et,811282a4 <_isatty_r+0xc>
811282a0:	003b68fa 	trap	3
811282a4:	dc000015 	stw	r16,0(sp)
811282a8:	04204574 	movhi	r16,33045
811282ac:	dc400115 	stw	r17,4(sp)
811282b0:	843dd504 	addi	r16,r16,-2220
811282b4:	2023883a 	mov	r17,r4
811282b8:	2809883a 	mov	r4,r5
811282bc:	dfc00215 	stw	ra,8(sp)
811282c0:	80000015 	stw	zero,0(r16)
811282c4:	11333e80 	call	811333e8 <isatty>
811282c8:	00ffffc4 	movi	r3,-1
811282cc:	10c00526 	beq	r2,r3,811282e4 <_isatty_r+0x4c>
811282d0:	dfc00217 	ldw	ra,8(sp)
811282d4:	dc400117 	ldw	r17,4(sp)
811282d8:	dc000017 	ldw	r16,0(sp)
811282dc:	dec00304 	addi	sp,sp,12
811282e0:	f800283a 	ret
811282e4:	80c00017 	ldw	r3,0(r16)
811282e8:	183ff926 	beq	r3,zero,811282d0 <__reset+0xfb1082d0>
811282ec:	88c00015 	stw	r3,0(r17)
811282f0:	003ff706 	br	811282d0 <__reset+0xfb1082d0>

811282f4 <iswspace>:
811282f4:	00803fc4 	movi	r2,255
811282f8:	11000836 	bltu	r2,r4,8112831c <iswspace+0x28>
811282fc:	00a04574 	movhi	r2,33045
81128300:	10bd6104 	addi	r2,r2,-2684
81128304:	10800017 	ldw	r2,0(r2)
81128308:	1109883a 	add	r4,r2,r4
8112830c:	20800043 	ldbu	r2,1(r4)
81128310:	1080020c 	andi	r2,r2,8
81128314:	10803fcc 	andi	r2,r2,255
81128318:	f800283a 	ret
8112831c:	0005883a 	mov	r2,zero
81128320:	f800283a 	ret

81128324 <_setlocale_r>:
81128324:	30001d26 	beq	r6,zero,8112839c <_setlocale_r+0x78>
81128328:	01604574 	movhi	r5,33045
8112832c:	defffe04 	addi	sp,sp,-8
81128330:	2973ba04 	addi	r5,r5,-12568
81128334:	3009883a 	mov	r4,r6
81128338:	de00012e 	bgeu	sp,et,81128340 <_setlocale_r+0x1c>
8112833c:	003b68fa 	trap	3
81128340:	dc000015 	stw	r16,0(sp)
81128344:	dfc00115 	stw	ra,4(sp)
81128348:	3021883a 	mov	r16,r6
8112834c:	112a0700 	call	8112a070 <strcmp>
81128350:	1000061e 	bne	r2,zero,8112836c <_setlocale_r+0x48>
81128354:	00a04574 	movhi	r2,33045
81128358:	10b38904 	addi	r2,r2,-12764
8112835c:	dfc00117 	ldw	ra,4(sp)
81128360:	dc000017 	ldw	r16,0(sp)
81128364:	dec00204 	addi	sp,sp,8
81128368:	f800283a 	ret
8112836c:	01604574 	movhi	r5,33045
81128370:	29738904 	addi	r5,r5,-12764
81128374:	8009883a 	mov	r4,r16
81128378:	112a0700 	call	8112a070 <strcmp>
8112837c:	103ff526 	beq	r2,zero,81128354 <__reset+0xfb108354>
81128380:	01604574 	movhi	r5,33045
81128384:	29739304 	addi	r5,r5,-12724
81128388:	8009883a 	mov	r4,r16
8112838c:	112a0700 	call	8112a070 <strcmp>
81128390:	103ff026 	beq	r2,zero,81128354 <__reset+0xfb108354>
81128394:	0005883a 	mov	r2,zero
81128398:	003ff006 	br	8112835c <__reset+0xfb10835c>
8112839c:	00a04574 	movhi	r2,33045
811283a0:	10b38904 	addi	r2,r2,-12764
811283a4:	f800283a 	ret

811283a8 <__locale_charset>:
811283a8:	00a04574 	movhi	r2,33045
811283ac:	10b82b04 	addi	r2,r2,-8020
811283b0:	f800283a 	ret

811283b4 <__locale_mb_cur_max>:
811283b4:	00a04574 	movhi	r2,33045
811283b8:	10bd6604 	addi	r2,r2,-2664
811283bc:	10800017 	ldw	r2,0(r2)
811283c0:	f800283a 	ret

811283c4 <__locale_msgcharset>:
811283c4:	00a04574 	movhi	r2,33045
811283c8:	10b82304 	addi	r2,r2,-8052
811283cc:	f800283a 	ret

811283d0 <__locale_cjk_lang>:
811283d0:	0005883a 	mov	r2,zero
811283d4:	f800283a 	ret

811283d8 <_localeconv_r>:
811283d8:	00a04574 	movhi	r2,33045
811283dc:	10b83304 	addi	r2,r2,-7988
811283e0:	f800283a 	ret

811283e4 <setlocale>:
811283e4:	00a04574 	movhi	r2,33045
811283e8:	10bd6304 	addi	r2,r2,-2676
811283ec:	280d883a 	mov	r6,r5
811283f0:	200b883a 	mov	r5,r4
811283f4:	11000017 	ldw	r4,0(r2)
811283f8:	11283241 	jmpi	81128324 <_setlocale_r>

811283fc <localeconv>:
811283fc:	00a04574 	movhi	r2,33045
81128400:	10b83304 	addi	r2,r2,-7988
81128404:	f800283a 	ret

81128408 <_lseek_r>:
81128408:	defffd04 	addi	sp,sp,-12
8112840c:	de00012e 	bgeu	sp,et,81128414 <_lseek_r+0xc>
81128410:	003b68fa 	trap	3
81128414:	2805883a 	mov	r2,r5
81128418:	dc000015 	stw	r16,0(sp)
8112841c:	04204574 	movhi	r16,33045
81128420:	dc400115 	stw	r17,4(sp)
81128424:	300b883a 	mov	r5,r6
81128428:	843dd504 	addi	r16,r16,-2220
8112842c:	2023883a 	mov	r17,r4
81128430:	380d883a 	mov	r6,r7
81128434:	1009883a 	mov	r4,r2
81128438:	dfc00215 	stw	ra,8(sp)
8112843c:	80000015 	stw	zero,0(r16)
81128440:	1133fe40 	call	81133fe4 <lseek>
81128444:	00ffffc4 	movi	r3,-1
81128448:	10c00526 	beq	r2,r3,81128460 <_lseek_r+0x58>
8112844c:	dfc00217 	ldw	ra,8(sp)
81128450:	dc400117 	ldw	r17,4(sp)
81128454:	dc000017 	ldw	r16,0(sp)
81128458:	dec00304 	addi	sp,sp,12
8112845c:	f800283a 	ret
81128460:	80c00017 	ldw	r3,0(r16)
81128464:	183ff926 	beq	r3,zero,8112844c <__reset+0xfb10844c>
81128468:	88c00015 	stw	r3,0(r17)
8112846c:	003ff706 	br	8112844c <__reset+0xfb10844c>

81128470 <_mbrtowc_r>:
81128470:	defff704 	addi	sp,sp,-36
81128474:	00a04574 	movhi	r2,33045
81128478:	de00012e 	bgeu	sp,et,81128480 <_mbrtowc_r+0x10>
8112847c:	003b68fa 	trap	3
81128480:	10bd6704 	addi	r2,r2,-2660
81128484:	dc800715 	stw	r18,28(sp)
81128488:	dc400615 	stw	r17,24(sp)
8112848c:	dc000515 	stw	r16,20(sp)
81128490:	dfc00815 	stw	ra,32(sp)
81128494:	2021883a 	mov	r16,r4
81128498:	dc400917 	ldw	r17,36(sp)
8112849c:	14800017 	ldw	r18,0(r2)
811284a0:	30001626 	beq	r6,zero,811284fc <_mbrtowc_r+0x8c>
811284a4:	d9400215 	stw	r5,8(sp)
811284a8:	d9800315 	stw	r6,12(sp)
811284ac:	d9c00415 	stw	r7,16(sp)
811284b0:	11283a80 	call	811283a8 <__locale_charset>
811284b4:	d9c00417 	ldw	r7,16(sp)
811284b8:	d9800317 	ldw	r6,12(sp)
811284bc:	d9400217 	ldw	r5,8(sp)
811284c0:	d8800015 	stw	r2,0(sp)
811284c4:	dc400115 	stw	r17,4(sp)
811284c8:	8009883a 	mov	r4,r16
811284cc:	903ee83a 	callr	r18
811284d0:	00ffffc4 	movi	r3,-1
811284d4:	10c0031e 	bne	r2,r3,811284e4 <_mbrtowc_r+0x74>
811284d8:	88000015 	stw	zero,0(r17)
811284dc:	00c02284 	movi	r3,138
811284e0:	80c00015 	stw	r3,0(r16)
811284e4:	dfc00817 	ldw	ra,32(sp)
811284e8:	dc800717 	ldw	r18,28(sp)
811284ec:	dc400617 	ldw	r17,24(sp)
811284f0:	dc000517 	ldw	r16,20(sp)
811284f4:	dec00904 	addi	sp,sp,36
811284f8:	f800283a 	ret
811284fc:	11283a80 	call	811283a8 <__locale_charset>
81128500:	01a04574 	movhi	r6,33045
81128504:	31b39304 	addi	r6,r6,-12724
81128508:	dc400115 	stw	r17,4(sp)
8112850c:	d8800015 	stw	r2,0(sp)
81128510:	01c00044 	movi	r7,1
81128514:	000b883a 	mov	r5,zero
81128518:	8009883a 	mov	r4,r16
8112851c:	903ee83a 	callr	r18
81128520:	003feb06 	br	811284d0 <__reset+0xfb1084d0>

81128524 <mbrtowc>:
81128524:	defff704 	addi	sp,sp,-36
81128528:	00a04574 	movhi	r2,33045
8112852c:	de00012e 	bgeu	sp,et,81128534 <mbrtowc+0x10>
81128530:	003b68fa 	trap	3
81128534:	10bd6304 	addi	r2,r2,-2676
81128538:	dc800415 	stw	r18,16(sp)
8112853c:	dc400315 	stw	r17,12(sp)
81128540:	dfc00815 	stw	ra,32(sp)
81128544:	dd400715 	stw	r21,28(sp)
81128548:	dd000615 	stw	r20,24(sp)
8112854c:	dcc00515 	stw	r19,20(sp)
81128550:	dc000215 	stw	r16,8(sp)
81128554:	3825883a 	mov	r18,r7
81128558:	14400017 	ldw	r17,0(r2)
8112855c:	28001c26 	beq	r5,zero,811285d0 <mbrtowc+0xac>
81128560:	00a04574 	movhi	r2,33045
81128564:	10bd6704 	addi	r2,r2,-2660
81128568:	15400017 	ldw	r21,0(r2)
8112856c:	2821883a 	mov	r16,r5
81128570:	2027883a 	mov	r19,r4
81128574:	3029883a 	mov	r20,r6
81128578:	11283a80 	call	811283a8 <__locale_charset>
8112857c:	d8800015 	stw	r2,0(sp)
81128580:	dc800115 	stw	r18,4(sp)
81128584:	a00f883a 	mov	r7,r20
81128588:	800d883a 	mov	r6,r16
8112858c:	980b883a 	mov	r5,r19
81128590:	8809883a 	mov	r4,r17
81128594:	a83ee83a 	callr	r21
81128598:	00ffffc4 	movi	r3,-1
8112859c:	10c0031e 	bne	r2,r3,811285ac <mbrtowc+0x88>
811285a0:	90000015 	stw	zero,0(r18)
811285a4:	00c02284 	movi	r3,138
811285a8:	88c00015 	stw	r3,0(r17)
811285ac:	dfc00817 	ldw	ra,32(sp)
811285b0:	dd400717 	ldw	r21,28(sp)
811285b4:	dd000617 	ldw	r20,24(sp)
811285b8:	dcc00517 	ldw	r19,20(sp)
811285bc:	dc800417 	ldw	r18,16(sp)
811285c0:	dc400317 	ldw	r17,12(sp)
811285c4:	dc000217 	ldw	r16,8(sp)
811285c8:	dec00904 	addi	sp,sp,36
811285cc:	f800283a 	ret
811285d0:	00a04574 	movhi	r2,33045
811285d4:	10bd6704 	addi	r2,r2,-2660
811285d8:	14000017 	ldw	r16,0(r2)
811285dc:	11283a80 	call	811283a8 <__locale_charset>
811285e0:	01a04574 	movhi	r6,33045
811285e4:	31b39304 	addi	r6,r6,-12724
811285e8:	dc800115 	stw	r18,4(sp)
811285ec:	d8800015 	stw	r2,0(sp)
811285f0:	01c00044 	movi	r7,1
811285f4:	000b883a 	mov	r5,zero
811285f8:	8809883a 	mov	r4,r17
811285fc:	803ee83a 	callr	r16
81128600:	003fe506 	br	81128598 <__reset+0xfb108598>

81128604 <__ascii_mbtowc>:
81128604:	deffff04 	addi	sp,sp,-4
81128608:	de00012e 	bgeu	sp,et,81128610 <__ascii_mbtowc+0xc>
8112860c:	003b68fa 	trap	3
81128610:	28000826 	beq	r5,zero,81128634 <__ascii_mbtowc+0x30>
81128614:	30000926 	beq	r6,zero,8112863c <__ascii_mbtowc+0x38>
81128618:	38000b26 	beq	r7,zero,81128648 <__ascii_mbtowc+0x44>
8112861c:	30800003 	ldbu	r2,0(r6)
81128620:	28800015 	stw	r2,0(r5)
81128624:	30800003 	ldbu	r2,0(r6)
81128628:	1004c03a 	cmpne	r2,r2,zero
8112862c:	dec00104 	addi	sp,sp,4
81128630:	f800283a 	ret
81128634:	d80b883a 	mov	r5,sp
81128638:	303ff71e 	bne	r6,zero,81128618 <__reset+0xfb108618>
8112863c:	0005883a 	mov	r2,zero
81128640:	dec00104 	addi	sp,sp,4
81128644:	f800283a 	ret
81128648:	00bfff84 	movi	r2,-2
8112864c:	003ff706 	br	8112862c <__reset+0xfb10862c>

81128650 <_mbtowc_r>:
81128650:	00a04574 	movhi	r2,33045
81128654:	defff804 	addi	sp,sp,-32
81128658:	10bd6704 	addi	r2,r2,-2660
8112865c:	de00012e 	bgeu	sp,et,81128664 <_mbtowc_r+0x14>
81128660:	003b68fa 	trap	3
81128664:	dfc00715 	stw	ra,28(sp)
81128668:	dc000615 	stw	r16,24(sp)
8112866c:	14000017 	ldw	r16,0(r2)
81128670:	d9000215 	stw	r4,8(sp)
81128674:	d9400315 	stw	r5,12(sp)
81128678:	d9800415 	stw	r6,16(sp)
8112867c:	d9c00515 	stw	r7,20(sp)
81128680:	11283a80 	call	811283a8 <__locale_charset>
81128684:	d8800015 	stw	r2,0(sp)
81128688:	d8800817 	ldw	r2,32(sp)
8112868c:	d9c00517 	ldw	r7,20(sp)
81128690:	d9800417 	ldw	r6,16(sp)
81128694:	d9400317 	ldw	r5,12(sp)
81128698:	d9000217 	ldw	r4,8(sp)
8112869c:	d8800115 	stw	r2,4(sp)
811286a0:	803ee83a 	callr	r16
811286a4:	dfc00717 	ldw	ra,28(sp)
811286a8:	dc000617 	ldw	r16,24(sp)
811286ac:	dec00804 	addi	sp,sp,32
811286b0:	f800283a 	ret

811286b4 <memchr>:
811286b4:	208000cc 	andi	r2,r4,3
811286b8:	280f883a 	mov	r7,r5
811286bc:	10003426 	beq	r2,zero,81128790 <memchr+0xdc>
811286c0:	30bfffc4 	addi	r2,r6,-1
811286c4:	30001a26 	beq	r6,zero,81128730 <memchr+0x7c>
811286c8:	20c00003 	ldbu	r3,0(r4)
811286cc:	29803fcc 	andi	r6,r5,255
811286d0:	30c0051e 	bne	r6,r3,811286e8 <memchr+0x34>
811286d4:	00001806 	br	81128738 <memchr+0x84>
811286d8:	10001526 	beq	r2,zero,81128730 <memchr+0x7c>
811286dc:	20c00003 	ldbu	r3,0(r4)
811286e0:	10bfffc4 	addi	r2,r2,-1
811286e4:	30c01426 	beq	r6,r3,81128738 <memchr+0x84>
811286e8:	21000044 	addi	r4,r4,1
811286ec:	20c000cc 	andi	r3,r4,3
811286f0:	183ff91e 	bne	r3,zero,811286d8 <__reset+0xfb1086d8>
811286f4:	020000c4 	movi	r8,3
811286f8:	40801136 	bltu	r8,r2,81128740 <memchr+0x8c>
811286fc:	10000c26 	beq	r2,zero,81128730 <memchr+0x7c>
81128700:	20c00003 	ldbu	r3,0(r4)
81128704:	29403fcc 	andi	r5,r5,255
81128708:	28c00b26 	beq	r5,r3,81128738 <memchr+0x84>
8112870c:	20c00044 	addi	r3,r4,1
81128710:	39803fcc 	andi	r6,r7,255
81128714:	2089883a 	add	r4,r4,r2
81128718:	00000306 	br	81128728 <memchr+0x74>
8112871c:	18c00044 	addi	r3,r3,1
81128720:	197fffc3 	ldbu	r5,-1(r3)
81128724:	31400526 	beq	r6,r5,8112873c <memchr+0x88>
81128728:	1805883a 	mov	r2,r3
8112872c:	20fffb1e 	bne	r4,r3,8112871c <__reset+0xfb10871c>
81128730:	0005883a 	mov	r2,zero
81128734:	f800283a 	ret
81128738:	2005883a 	mov	r2,r4
8112873c:	f800283a 	ret
81128740:	28c03fcc 	andi	r3,r5,255
81128744:	1812923a 	slli	r9,r3,8
81128748:	02ffbff4 	movhi	r11,65279
8112874c:	02a02074 	movhi	r10,32897
81128750:	48d2b03a 	or	r9,r9,r3
81128754:	4806943a 	slli	r3,r9,16
81128758:	5affbfc4 	addi	r11,r11,-257
8112875c:	52a02004 	addi	r10,r10,-32640
81128760:	48d2b03a 	or	r9,r9,r3
81128764:	20c00017 	ldw	r3,0(r4)
81128768:	48c6f03a 	xor	r3,r9,r3
8112876c:	1acd883a 	add	r6,r3,r11
81128770:	00c6303a 	nor	r3,zero,r3
81128774:	30c6703a 	and	r3,r6,r3
81128778:	1a86703a 	and	r3,r3,r10
8112877c:	183fe01e 	bne	r3,zero,81128700 <__reset+0xfb108700>
81128780:	10bfff04 	addi	r2,r2,-4
81128784:	21000104 	addi	r4,r4,4
81128788:	40bff636 	bltu	r8,r2,81128764 <__reset+0xfb108764>
8112878c:	003fdb06 	br	811286fc <__reset+0xfb1086fc>
81128790:	3005883a 	mov	r2,r6
81128794:	003fd706 	br	811286f4 <__reset+0xfb1086f4>

81128798 <memmove>:
81128798:	2005883a 	mov	r2,r4
8112879c:	29000b2e 	bgeu	r5,r4,811287cc <memmove+0x34>
811287a0:	298f883a 	add	r7,r5,r6
811287a4:	21c0092e 	bgeu	r4,r7,811287cc <memmove+0x34>
811287a8:	2187883a 	add	r3,r4,r6
811287ac:	198bc83a 	sub	r5,r3,r6
811287b0:	30004826 	beq	r6,zero,811288d4 <memmove+0x13c>
811287b4:	39ffffc4 	addi	r7,r7,-1
811287b8:	39000003 	ldbu	r4,0(r7)
811287bc:	18ffffc4 	addi	r3,r3,-1
811287c0:	19000005 	stb	r4,0(r3)
811287c4:	28fffb1e 	bne	r5,r3,811287b4 <__reset+0xfb1087b4>
811287c8:	f800283a 	ret
811287cc:	00c003c4 	movi	r3,15
811287d0:	1980412e 	bgeu	r3,r6,811288d8 <memmove+0x140>
811287d4:	2886b03a 	or	r3,r5,r2
811287d8:	18c000cc 	andi	r3,r3,3
811287dc:	1800401e 	bne	r3,zero,811288e0 <memmove+0x148>
811287e0:	33fffc04 	addi	r15,r6,-16
811287e4:	781ed13a 	srli	r15,r15,4
811287e8:	28c00104 	addi	r3,r5,4
811287ec:	13400104 	addi	r13,r2,4
811287f0:	781c913a 	slli	r14,r15,4
811287f4:	2b000204 	addi	r12,r5,8
811287f8:	12c00204 	addi	r11,r2,8
811287fc:	73800504 	addi	r14,r14,20
81128800:	2a800304 	addi	r10,r5,12
81128804:	12400304 	addi	r9,r2,12
81128808:	2b9d883a 	add	r14,r5,r14
8112880c:	2811883a 	mov	r8,r5
81128810:	100f883a 	mov	r7,r2
81128814:	41000017 	ldw	r4,0(r8)
81128818:	39c00404 	addi	r7,r7,16
8112881c:	18c00404 	addi	r3,r3,16
81128820:	393ffc15 	stw	r4,-16(r7)
81128824:	193ffc17 	ldw	r4,-16(r3)
81128828:	6b400404 	addi	r13,r13,16
8112882c:	5ac00404 	addi	r11,r11,16
81128830:	693ffc15 	stw	r4,-16(r13)
81128834:	61000017 	ldw	r4,0(r12)
81128838:	4a400404 	addi	r9,r9,16
8112883c:	42000404 	addi	r8,r8,16
81128840:	593ffc15 	stw	r4,-16(r11)
81128844:	51000017 	ldw	r4,0(r10)
81128848:	63000404 	addi	r12,r12,16
8112884c:	52800404 	addi	r10,r10,16
81128850:	493ffc15 	stw	r4,-16(r9)
81128854:	1bbfef1e 	bne	r3,r14,81128814 <__reset+0xfb108814>
81128858:	79000044 	addi	r4,r15,1
8112885c:	2008913a 	slli	r4,r4,4
81128860:	328003cc 	andi	r10,r6,15
81128864:	02c000c4 	movi	r11,3
81128868:	1107883a 	add	r3,r2,r4
8112886c:	290b883a 	add	r5,r5,r4
81128870:	5a801e2e 	bgeu	r11,r10,811288ec <memmove+0x154>
81128874:	1813883a 	mov	r9,r3
81128878:	2811883a 	mov	r8,r5
8112887c:	500f883a 	mov	r7,r10
81128880:	41000017 	ldw	r4,0(r8)
81128884:	4a400104 	addi	r9,r9,4
81128888:	39ffff04 	addi	r7,r7,-4
8112888c:	493fff15 	stw	r4,-4(r9)
81128890:	42000104 	addi	r8,r8,4
81128894:	59fffa36 	bltu	r11,r7,81128880 <__reset+0xfb108880>
81128898:	513fff04 	addi	r4,r10,-4
8112889c:	2008d0ba 	srli	r4,r4,2
811288a0:	318000cc 	andi	r6,r6,3
811288a4:	21000044 	addi	r4,r4,1
811288a8:	2109883a 	add	r4,r4,r4
811288ac:	2109883a 	add	r4,r4,r4
811288b0:	1907883a 	add	r3,r3,r4
811288b4:	290b883a 	add	r5,r5,r4
811288b8:	30000b26 	beq	r6,zero,811288e8 <memmove+0x150>
811288bc:	198d883a 	add	r6,r3,r6
811288c0:	29c00003 	ldbu	r7,0(r5)
811288c4:	18c00044 	addi	r3,r3,1
811288c8:	29400044 	addi	r5,r5,1
811288cc:	19ffffc5 	stb	r7,-1(r3)
811288d0:	19bffb1e 	bne	r3,r6,811288c0 <__reset+0xfb1088c0>
811288d4:	f800283a 	ret
811288d8:	1007883a 	mov	r3,r2
811288dc:	003ff606 	br	811288b8 <__reset+0xfb1088b8>
811288e0:	1007883a 	mov	r3,r2
811288e4:	003ff506 	br	811288bc <__reset+0xfb1088bc>
811288e8:	f800283a 	ret
811288ec:	500d883a 	mov	r6,r10
811288f0:	003ff106 	br	811288b8 <__reset+0xfb1088b8>

811288f4 <_Balloc>:
811288f4:	defffc04 	addi	sp,sp,-16
811288f8:	de00012e 	bgeu	sp,et,81128900 <_Balloc+0xc>
811288fc:	003b68fa 	trap	3
81128900:	20801317 	ldw	r2,76(r4)
81128904:	dc400115 	stw	r17,4(sp)
81128908:	dc000015 	stw	r16,0(sp)
8112890c:	dfc00315 	stw	ra,12(sp)
81128910:	dc800215 	stw	r18,8(sp)
81128914:	2023883a 	mov	r17,r4
81128918:	2821883a 	mov	r16,r5
8112891c:	10000f26 	beq	r2,zero,8112895c <_Balloc+0x68>
81128920:	8407883a 	add	r3,r16,r16
81128924:	18c7883a 	add	r3,r3,r3
81128928:	10c7883a 	add	r3,r2,r3
8112892c:	18800017 	ldw	r2,0(r3)
81128930:	10001126 	beq	r2,zero,81128978 <_Balloc+0x84>
81128934:	11000017 	ldw	r4,0(r2)
81128938:	19000015 	stw	r4,0(r3)
8112893c:	10000415 	stw	zero,16(r2)
81128940:	10000315 	stw	zero,12(r2)
81128944:	dfc00317 	ldw	ra,12(sp)
81128948:	dc800217 	ldw	r18,8(sp)
8112894c:	dc400117 	ldw	r17,4(sp)
81128950:	dc000017 	ldw	r16,0(sp)
81128954:	dec00404 	addi	sp,sp,16
81128958:	f800283a 	ret
8112895c:	01800844 	movi	r6,33
81128960:	01400104 	movi	r5,4
81128964:	112ee1c0 	call	8112ee1c <_calloc_r>
81128968:	88801315 	stw	r2,76(r17)
8112896c:	103fec1e 	bne	r2,zero,81128920 <__reset+0xfb108920>
81128970:	0005883a 	mov	r2,zero
81128974:	003ff306 	br	81128944 <__reset+0xfb108944>
81128978:	01400044 	movi	r5,1
8112897c:	2c24983a 	sll	r18,r5,r16
81128980:	8809883a 	mov	r4,r17
81128984:	91800144 	addi	r6,r18,5
81128988:	318d883a 	add	r6,r6,r6
8112898c:	318d883a 	add	r6,r6,r6
81128990:	112ee1c0 	call	8112ee1c <_calloc_r>
81128994:	103ff626 	beq	r2,zero,81128970 <__reset+0xfb108970>
81128998:	14000115 	stw	r16,4(r2)
8112899c:	14800215 	stw	r18,8(r2)
811289a0:	003fe606 	br	8112893c <__reset+0xfb10893c>

811289a4 <_Bfree>:
811289a4:	28000826 	beq	r5,zero,811289c8 <_Bfree+0x24>
811289a8:	28c00117 	ldw	r3,4(r5)
811289ac:	20801317 	ldw	r2,76(r4)
811289b0:	18c7883a 	add	r3,r3,r3
811289b4:	18c7883a 	add	r3,r3,r3
811289b8:	10c5883a 	add	r2,r2,r3
811289bc:	10c00017 	ldw	r3,0(r2)
811289c0:	28c00015 	stw	r3,0(r5)
811289c4:	11400015 	stw	r5,0(r2)
811289c8:	f800283a 	ret

811289cc <__multadd>:
811289cc:	defffa04 	addi	sp,sp,-24
811289d0:	de00012e 	bgeu	sp,et,811289d8 <__multadd+0xc>
811289d4:	003b68fa 	trap	3
811289d8:	0011883a 	mov	r8,zero
811289dc:	dc800315 	stw	r18,12(sp)
811289e0:	dc400215 	stw	r17,8(sp)
811289e4:	dc000115 	stw	r16,4(sp)
811289e8:	2823883a 	mov	r17,r5
811289ec:	2c000417 	ldw	r16,16(r5)
811289f0:	dfc00515 	stw	ra,20(sp)
811289f4:	dcc00415 	stw	r19,16(sp)
811289f8:	2025883a 	mov	r18,r4
811289fc:	29400504 	addi	r5,r5,20
81128a00:	28c00017 	ldw	r3,0(r5)
81128a04:	29400104 	addi	r5,r5,4
81128a08:	42000044 	addi	r8,r8,1
81128a0c:	18bfffcc 	andi	r2,r3,65535
81128a10:	1185383a 	mul	r2,r2,r6
81128a14:	1806d43a 	srli	r3,r3,16
81128a18:	11cf883a 	add	r7,r2,r7
81128a1c:	3808d43a 	srli	r4,r7,16
81128a20:	1987383a 	mul	r3,r3,r6
81128a24:	38bfffcc 	andi	r2,r7,65535
81128a28:	1907883a 	add	r3,r3,r4
81128a2c:	1808943a 	slli	r4,r3,16
81128a30:	180ed43a 	srli	r7,r3,16
81128a34:	2085883a 	add	r2,r4,r2
81128a38:	28bfff15 	stw	r2,-4(r5)
81128a3c:	443ff016 	blt	r8,r16,81128a00 <__reset+0xfb108a00>
81128a40:	38000926 	beq	r7,zero,81128a68 <__multadd+0x9c>
81128a44:	88800217 	ldw	r2,8(r17)
81128a48:	80800f0e 	bge	r16,r2,81128a88 <__multadd+0xbc>
81128a4c:	80800144 	addi	r2,r16,5
81128a50:	1085883a 	add	r2,r2,r2
81128a54:	1085883a 	add	r2,r2,r2
81128a58:	8885883a 	add	r2,r17,r2
81128a5c:	11c00015 	stw	r7,0(r2)
81128a60:	84000044 	addi	r16,r16,1
81128a64:	8c000415 	stw	r16,16(r17)
81128a68:	8805883a 	mov	r2,r17
81128a6c:	dfc00517 	ldw	ra,20(sp)
81128a70:	dcc00417 	ldw	r19,16(sp)
81128a74:	dc800317 	ldw	r18,12(sp)
81128a78:	dc400217 	ldw	r17,8(sp)
81128a7c:	dc000117 	ldw	r16,4(sp)
81128a80:	dec00604 	addi	sp,sp,24
81128a84:	f800283a 	ret
81128a88:	89400117 	ldw	r5,4(r17)
81128a8c:	9009883a 	mov	r4,r18
81128a90:	d9c00015 	stw	r7,0(sp)
81128a94:	29400044 	addi	r5,r5,1
81128a98:	11288f40 	call	811288f4 <_Balloc>
81128a9c:	89800417 	ldw	r6,16(r17)
81128aa0:	89400304 	addi	r5,r17,12
81128aa4:	11000304 	addi	r4,r2,12
81128aa8:	31800084 	addi	r6,r6,2
81128aac:	318d883a 	add	r6,r6,r6
81128ab0:	318d883a 	add	r6,r6,r6
81128ab4:	1027883a 	mov	r19,r2
81128ab8:	111e6c40 	call	8111e6c4 <memcpy>
81128abc:	d9c00017 	ldw	r7,0(sp)
81128ac0:	88000a26 	beq	r17,zero,81128aec <__multadd+0x120>
81128ac4:	88c00117 	ldw	r3,4(r17)
81128ac8:	90801317 	ldw	r2,76(r18)
81128acc:	18c7883a 	add	r3,r3,r3
81128ad0:	18c7883a 	add	r3,r3,r3
81128ad4:	10c5883a 	add	r2,r2,r3
81128ad8:	10c00017 	ldw	r3,0(r2)
81128adc:	88c00015 	stw	r3,0(r17)
81128ae0:	14400015 	stw	r17,0(r2)
81128ae4:	9823883a 	mov	r17,r19
81128ae8:	003fd806 	br	81128a4c <__reset+0xfb108a4c>
81128aec:	9823883a 	mov	r17,r19
81128af0:	003fd606 	br	81128a4c <__reset+0xfb108a4c>

81128af4 <__s2b>:
81128af4:	defff904 	addi	sp,sp,-28
81128af8:	de00012e 	bgeu	sp,et,81128b00 <__s2b+0xc>
81128afc:	003b68fa 	trap	3
81128b00:	dc400115 	stw	r17,4(sp)
81128b04:	dc000015 	stw	r16,0(sp)
81128b08:	2023883a 	mov	r17,r4
81128b0c:	2821883a 	mov	r16,r5
81128b10:	39000204 	addi	r4,r7,8
81128b14:	01400244 	movi	r5,9
81128b18:	dcc00315 	stw	r19,12(sp)
81128b1c:	dc800215 	stw	r18,8(sp)
81128b20:	dfc00615 	stw	ra,24(sp)
81128b24:	dd400515 	stw	r21,20(sp)
81128b28:	dd000415 	stw	r20,16(sp)
81128b2c:	3825883a 	mov	r18,r7
81128b30:	3027883a 	mov	r19,r6
81128b34:	1130bb40 	call	81130bb4 <__divsi3>
81128b38:	00c00044 	movi	r3,1
81128b3c:	000b883a 	mov	r5,zero
81128b40:	1880030e 	bge	r3,r2,81128b50 <__s2b+0x5c>
81128b44:	18c7883a 	add	r3,r3,r3
81128b48:	29400044 	addi	r5,r5,1
81128b4c:	18bffd16 	blt	r3,r2,81128b44 <__reset+0xfb108b44>
81128b50:	8809883a 	mov	r4,r17
81128b54:	11288f40 	call	811288f4 <_Balloc>
81128b58:	d8c00717 	ldw	r3,28(sp)
81128b5c:	10c00515 	stw	r3,20(r2)
81128b60:	00c00044 	movi	r3,1
81128b64:	10c00415 	stw	r3,16(r2)
81128b68:	00c00244 	movi	r3,9
81128b6c:	1cc0210e 	bge	r3,r19,81128bf4 <__s2b+0x100>
81128b70:	80eb883a 	add	r21,r16,r3
81128b74:	a829883a 	mov	r20,r21
81128b78:	84e1883a 	add	r16,r16,r19
81128b7c:	a1c00007 	ldb	r7,0(r20)
81128b80:	01800284 	movi	r6,10
81128b84:	a5000044 	addi	r20,r20,1
81128b88:	100b883a 	mov	r5,r2
81128b8c:	39fff404 	addi	r7,r7,-48
81128b90:	8809883a 	mov	r4,r17
81128b94:	11289cc0 	call	811289cc <__multadd>
81128b98:	a43ff81e 	bne	r20,r16,81128b7c <__reset+0xfb108b7c>
81128b9c:	ace1883a 	add	r16,r21,r19
81128ba0:	843ffe04 	addi	r16,r16,-8
81128ba4:	9c800a0e 	bge	r19,r18,81128bd0 <__s2b+0xdc>
81128ba8:	94e5c83a 	sub	r18,r18,r19
81128bac:	84a5883a 	add	r18,r16,r18
81128bb0:	81c00007 	ldb	r7,0(r16)
81128bb4:	01800284 	movi	r6,10
81128bb8:	84000044 	addi	r16,r16,1
81128bbc:	100b883a 	mov	r5,r2
81128bc0:	39fff404 	addi	r7,r7,-48
81128bc4:	8809883a 	mov	r4,r17
81128bc8:	11289cc0 	call	811289cc <__multadd>
81128bcc:	84bff81e 	bne	r16,r18,81128bb0 <__reset+0xfb108bb0>
81128bd0:	dfc00617 	ldw	ra,24(sp)
81128bd4:	dd400517 	ldw	r21,20(sp)
81128bd8:	dd000417 	ldw	r20,16(sp)
81128bdc:	dcc00317 	ldw	r19,12(sp)
81128be0:	dc800217 	ldw	r18,8(sp)
81128be4:	dc400117 	ldw	r17,4(sp)
81128be8:	dc000017 	ldw	r16,0(sp)
81128bec:	dec00704 	addi	sp,sp,28
81128bf0:	f800283a 	ret
81128bf4:	84000284 	addi	r16,r16,10
81128bf8:	1827883a 	mov	r19,r3
81128bfc:	003fe906 	br	81128ba4 <__reset+0xfb108ba4>

81128c00 <__hi0bits>:
81128c00:	20bfffec 	andhi	r2,r4,65535
81128c04:	1000141e 	bne	r2,zero,81128c58 <__hi0bits+0x58>
81128c08:	2008943a 	slli	r4,r4,16
81128c0c:	00800404 	movi	r2,16
81128c10:	20ffc02c 	andhi	r3,r4,65280
81128c14:	1800021e 	bne	r3,zero,81128c20 <__hi0bits+0x20>
81128c18:	2008923a 	slli	r4,r4,8
81128c1c:	10800204 	addi	r2,r2,8
81128c20:	20fc002c 	andhi	r3,r4,61440
81128c24:	1800021e 	bne	r3,zero,81128c30 <__hi0bits+0x30>
81128c28:	2008913a 	slli	r4,r4,4
81128c2c:	10800104 	addi	r2,r2,4
81128c30:	20f0002c 	andhi	r3,r4,49152
81128c34:	1800031e 	bne	r3,zero,81128c44 <__hi0bits+0x44>
81128c38:	2109883a 	add	r4,r4,r4
81128c3c:	10800084 	addi	r2,r2,2
81128c40:	2109883a 	add	r4,r4,r4
81128c44:	20000316 	blt	r4,zero,81128c54 <__hi0bits+0x54>
81128c48:	2110002c 	andhi	r4,r4,16384
81128c4c:	2000041e 	bne	r4,zero,81128c60 <__hi0bits+0x60>
81128c50:	00800804 	movi	r2,32
81128c54:	f800283a 	ret
81128c58:	0005883a 	mov	r2,zero
81128c5c:	003fec06 	br	81128c10 <__reset+0xfb108c10>
81128c60:	10800044 	addi	r2,r2,1
81128c64:	f800283a 	ret

81128c68 <__lo0bits>:
81128c68:	20c00017 	ldw	r3,0(r4)
81128c6c:	188001cc 	andi	r2,r3,7
81128c70:	10000826 	beq	r2,zero,81128c94 <__lo0bits+0x2c>
81128c74:	1880004c 	andi	r2,r3,1
81128c78:	1000211e 	bne	r2,zero,81128d00 <__lo0bits+0x98>
81128c7c:	1880008c 	andi	r2,r3,2
81128c80:	1000211e 	bne	r2,zero,81128d08 <__lo0bits+0xa0>
81128c84:	1806d0ba 	srli	r3,r3,2
81128c88:	00800084 	movi	r2,2
81128c8c:	20c00015 	stw	r3,0(r4)
81128c90:	f800283a 	ret
81128c94:	18bfffcc 	andi	r2,r3,65535
81128c98:	10001326 	beq	r2,zero,81128ce8 <__lo0bits+0x80>
81128c9c:	0005883a 	mov	r2,zero
81128ca0:	19403fcc 	andi	r5,r3,255
81128ca4:	2800021e 	bne	r5,zero,81128cb0 <__lo0bits+0x48>
81128ca8:	1806d23a 	srli	r3,r3,8
81128cac:	10800204 	addi	r2,r2,8
81128cb0:	194003cc 	andi	r5,r3,15
81128cb4:	2800021e 	bne	r5,zero,81128cc0 <__lo0bits+0x58>
81128cb8:	1806d13a 	srli	r3,r3,4
81128cbc:	10800104 	addi	r2,r2,4
81128cc0:	194000cc 	andi	r5,r3,3
81128cc4:	2800021e 	bne	r5,zero,81128cd0 <__lo0bits+0x68>
81128cc8:	1806d0ba 	srli	r3,r3,2
81128ccc:	10800084 	addi	r2,r2,2
81128cd0:	1940004c 	andi	r5,r3,1
81128cd4:	2800081e 	bne	r5,zero,81128cf8 <__lo0bits+0x90>
81128cd8:	1806d07a 	srli	r3,r3,1
81128cdc:	1800051e 	bne	r3,zero,81128cf4 <__lo0bits+0x8c>
81128ce0:	00800804 	movi	r2,32
81128ce4:	f800283a 	ret
81128ce8:	1806d43a 	srli	r3,r3,16
81128cec:	00800404 	movi	r2,16
81128cf0:	003feb06 	br	81128ca0 <__reset+0xfb108ca0>
81128cf4:	10800044 	addi	r2,r2,1
81128cf8:	20c00015 	stw	r3,0(r4)
81128cfc:	f800283a 	ret
81128d00:	0005883a 	mov	r2,zero
81128d04:	f800283a 	ret
81128d08:	1806d07a 	srli	r3,r3,1
81128d0c:	00800044 	movi	r2,1
81128d10:	20c00015 	stw	r3,0(r4)
81128d14:	f800283a 	ret

81128d18 <__i2b>:
81128d18:	defffd04 	addi	sp,sp,-12
81128d1c:	de00012e 	bgeu	sp,et,81128d24 <__i2b+0xc>
81128d20:	003b68fa 	trap	3
81128d24:	dc000015 	stw	r16,0(sp)
81128d28:	04000044 	movi	r16,1
81128d2c:	dc400115 	stw	r17,4(sp)
81128d30:	2823883a 	mov	r17,r5
81128d34:	800b883a 	mov	r5,r16
81128d38:	dfc00215 	stw	ra,8(sp)
81128d3c:	11288f40 	call	811288f4 <_Balloc>
81128d40:	14400515 	stw	r17,20(r2)
81128d44:	14000415 	stw	r16,16(r2)
81128d48:	dfc00217 	ldw	ra,8(sp)
81128d4c:	dc400117 	ldw	r17,4(sp)
81128d50:	dc000017 	ldw	r16,0(sp)
81128d54:	dec00304 	addi	sp,sp,12
81128d58:	f800283a 	ret

81128d5c <__multiply>:
81128d5c:	defffa04 	addi	sp,sp,-24
81128d60:	de00012e 	bgeu	sp,et,81128d68 <__multiply+0xc>
81128d64:	003b68fa 	trap	3
81128d68:	dcc00315 	stw	r19,12(sp)
81128d6c:	dc800215 	stw	r18,8(sp)
81128d70:	34c00417 	ldw	r19,16(r6)
81128d74:	2c800417 	ldw	r18,16(r5)
81128d78:	dd000415 	stw	r20,16(sp)
81128d7c:	dc400115 	stw	r17,4(sp)
81128d80:	dfc00515 	stw	ra,20(sp)
81128d84:	dc000015 	stw	r16,0(sp)
81128d88:	2829883a 	mov	r20,r5
81128d8c:	3023883a 	mov	r17,r6
81128d90:	94c0050e 	bge	r18,r19,81128da8 <__multiply+0x4c>
81128d94:	9007883a 	mov	r3,r18
81128d98:	3029883a 	mov	r20,r6
81128d9c:	9825883a 	mov	r18,r19
81128da0:	2823883a 	mov	r17,r5
81128da4:	1827883a 	mov	r19,r3
81128da8:	a0800217 	ldw	r2,8(r20)
81128dac:	94e1883a 	add	r16,r18,r19
81128db0:	a1400117 	ldw	r5,4(r20)
81128db4:	1400010e 	bge	r2,r16,81128dbc <__multiply+0x60>
81128db8:	29400044 	addi	r5,r5,1
81128dbc:	11288f40 	call	811288f4 <_Balloc>
81128dc0:	8415883a 	add	r10,r16,r16
81128dc4:	12c00504 	addi	r11,r2,20
81128dc8:	5295883a 	add	r10,r10,r10
81128dcc:	5a95883a 	add	r10,r11,r10
81128dd0:	5807883a 	mov	r3,r11
81128dd4:	5a80032e 	bgeu	r11,r10,81128de4 <__multiply+0x88>
81128dd8:	18000015 	stw	zero,0(r3)
81128ddc:	18c00104 	addi	r3,r3,4
81128de0:	1abffd36 	bltu	r3,r10,81128dd8 <__reset+0xfb108dd8>
81128de4:	9ce7883a 	add	r19,r19,r19
81128de8:	94a5883a 	add	r18,r18,r18
81128dec:	89800504 	addi	r6,r17,20
81128df0:	9ce7883a 	add	r19,r19,r19
81128df4:	a3400504 	addi	r13,r20,20
81128df8:	94a5883a 	add	r18,r18,r18
81128dfc:	34d9883a 	add	r12,r6,r19
81128e00:	6c93883a 	add	r9,r13,r18
81128e04:	3300422e 	bgeu	r6,r12,81128f10 <__multiply+0x1b4>
81128e08:	37c00017 	ldw	ra,0(r6)
81128e0c:	fbffffcc 	andi	r15,ra,65535
81128e10:	78001b26 	beq	r15,zero,81128e80 <__multiply+0x124>
81128e14:	5811883a 	mov	r8,r11
81128e18:	681d883a 	mov	r14,r13
81128e1c:	000f883a 	mov	r7,zero
81128e20:	71000017 	ldw	r4,0(r14)
81128e24:	40c00017 	ldw	r3,0(r8)
81128e28:	73800104 	addi	r14,r14,4
81128e2c:	217fffcc 	andi	r5,r4,65535
81128e30:	2bcb383a 	mul	r5,r5,r15
81128e34:	2008d43a 	srli	r4,r4,16
81128e38:	1c7fffcc 	andi	r17,r3,65535
81128e3c:	2c4b883a 	add	r5,r5,r17
81128e40:	29cb883a 	add	r5,r5,r7
81128e44:	23c9383a 	mul	r4,r4,r15
81128e48:	1806d43a 	srli	r3,r3,16
81128e4c:	280ed43a 	srli	r7,r5,16
81128e50:	297fffcc 	andi	r5,r5,65535
81128e54:	20c7883a 	add	r3,r4,r3
81128e58:	19c7883a 	add	r3,r3,r7
81128e5c:	1808943a 	slli	r4,r3,16
81128e60:	4023883a 	mov	r17,r8
81128e64:	180ed43a 	srli	r7,r3,16
81128e68:	214ab03a 	or	r5,r4,r5
81128e6c:	41400015 	stw	r5,0(r8)
81128e70:	42000104 	addi	r8,r8,4
81128e74:	727fea36 	bltu	r14,r9,81128e20 <__reset+0xfb108e20>
81128e78:	89c00115 	stw	r7,4(r17)
81128e7c:	37c00017 	ldw	ra,0(r6)
81128e80:	f83ed43a 	srli	ra,ra,16
81128e84:	f8001f26 	beq	ra,zero,81128f04 <__multiply+0x1a8>
81128e88:	58c00017 	ldw	r3,0(r11)
81128e8c:	681d883a 	mov	r14,r13
81128e90:	581f883a 	mov	r15,r11
81128e94:	1811883a 	mov	r8,r3
81128e98:	5825883a 	mov	r18,r11
81128e9c:	000f883a 	mov	r7,zero
81128ea0:	00000106 	br	81128ea8 <__multiply+0x14c>
81128ea4:	8825883a 	mov	r18,r17
81128ea8:	7140000b 	ldhu	r5,0(r14)
81128eac:	4010d43a 	srli	r8,r8,16
81128eb0:	193fffcc 	andi	r4,r3,65535
81128eb4:	2fcb383a 	mul	r5,r5,ra
81128eb8:	7bc00104 	addi	r15,r15,4
81128ebc:	73800104 	addi	r14,r14,4
81128ec0:	2a0b883a 	add	r5,r5,r8
81128ec4:	29cb883a 	add	r5,r5,r7
81128ec8:	2806943a 	slli	r3,r5,16
81128ecc:	94400104 	addi	r17,r18,4
81128ed0:	280ad43a 	srli	r5,r5,16
81128ed4:	1908b03a 	or	r4,r3,r4
81128ed8:	793fff15 	stw	r4,-4(r15)
81128edc:	70ffff17 	ldw	r3,-4(r14)
81128ee0:	8a000017 	ldw	r8,0(r17)
81128ee4:	1806d43a 	srli	r3,r3,16
81128ee8:	413fffcc 	andi	r4,r8,65535
81128eec:	1fc7383a 	mul	r3,r3,ra
81128ef0:	1907883a 	add	r3,r3,r4
81128ef4:	1947883a 	add	r3,r3,r5
81128ef8:	180ed43a 	srli	r7,r3,16
81128efc:	727fe936 	bltu	r14,r9,81128ea4 <__reset+0xfb108ea4>
81128f00:	90c00115 	stw	r3,4(r18)
81128f04:	31800104 	addi	r6,r6,4
81128f08:	5ac00104 	addi	r11,r11,4
81128f0c:	333fbe36 	bltu	r6,r12,81128e08 <__reset+0xfb108e08>
81128f10:	0400090e 	bge	zero,r16,81128f38 <__multiply+0x1dc>
81128f14:	50ffff17 	ldw	r3,-4(r10)
81128f18:	52bfff04 	addi	r10,r10,-4
81128f1c:	18000326 	beq	r3,zero,81128f2c <__multiply+0x1d0>
81128f20:	00000506 	br	81128f38 <__multiply+0x1dc>
81128f24:	50c00017 	ldw	r3,0(r10)
81128f28:	1800031e 	bne	r3,zero,81128f38 <__multiply+0x1dc>
81128f2c:	843fffc4 	addi	r16,r16,-1
81128f30:	52bfff04 	addi	r10,r10,-4
81128f34:	803ffb1e 	bne	r16,zero,81128f24 <__reset+0xfb108f24>
81128f38:	14000415 	stw	r16,16(r2)
81128f3c:	dfc00517 	ldw	ra,20(sp)
81128f40:	dd000417 	ldw	r20,16(sp)
81128f44:	dcc00317 	ldw	r19,12(sp)
81128f48:	dc800217 	ldw	r18,8(sp)
81128f4c:	dc400117 	ldw	r17,4(sp)
81128f50:	dc000017 	ldw	r16,0(sp)
81128f54:	dec00604 	addi	sp,sp,24
81128f58:	f800283a 	ret

81128f5c <__pow5mult>:
81128f5c:	defffa04 	addi	sp,sp,-24
81128f60:	de00012e 	bgeu	sp,et,81128f68 <__pow5mult+0xc>
81128f64:	003b68fa 	trap	3
81128f68:	308000cc 	andi	r2,r6,3
81128f6c:	dcc00315 	stw	r19,12(sp)
81128f70:	dc000015 	stw	r16,0(sp)
81128f74:	dfc00515 	stw	ra,20(sp)
81128f78:	dd000415 	stw	r20,16(sp)
81128f7c:	dc800215 	stw	r18,8(sp)
81128f80:	dc400115 	stw	r17,4(sp)
81128f84:	3021883a 	mov	r16,r6
81128f88:	2027883a 	mov	r19,r4
81128f8c:	10002f1e 	bne	r2,zero,8112904c <__pow5mult+0xf0>
81128f90:	2825883a 	mov	r18,r5
81128f94:	8021d0ba 	srai	r16,r16,2
81128f98:	80001a26 	beq	r16,zero,81129004 <__pow5mult+0xa8>
81128f9c:	9c401217 	ldw	r17,72(r19)
81128fa0:	8800061e 	bne	r17,zero,81128fbc <__pow5mult+0x60>
81128fa4:	00003406 	br	81129078 <__pow5mult+0x11c>
81128fa8:	8021d07a 	srai	r16,r16,1
81128fac:	80001526 	beq	r16,zero,81129004 <__pow5mult+0xa8>
81128fb0:	88800017 	ldw	r2,0(r17)
81128fb4:	10001c26 	beq	r2,zero,81129028 <__pow5mult+0xcc>
81128fb8:	1023883a 	mov	r17,r2
81128fbc:	8080004c 	andi	r2,r16,1
81128fc0:	103ff926 	beq	r2,zero,81128fa8 <__reset+0xfb108fa8>
81128fc4:	880d883a 	mov	r6,r17
81128fc8:	900b883a 	mov	r5,r18
81128fcc:	9809883a 	mov	r4,r19
81128fd0:	1128d5c0 	call	81128d5c <__multiply>
81128fd4:	90001b26 	beq	r18,zero,81129044 <__pow5mult+0xe8>
81128fd8:	91000117 	ldw	r4,4(r18)
81128fdc:	98c01317 	ldw	r3,76(r19)
81128fe0:	8021d07a 	srai	r16,r16,1
81128fe4:	2109883a 	add	r4,r4,r4
81128fe8:	2109883a 	add	r4,r4,r4
81128fec:	1907883a 	add	r3,r3,r4
81128ff0:	19000017 	ldw	r4,0(r3)
81128ff4:	91000015 	stw	r4,0(r18)
81128ff8:	1c800015 	stw	r18,0(r3)
81128ffc:	1025883a 	mov	r18,r2
81129000:	803feb1e 	bne	r16,zero,81128fb0 <__reset+0xfb108fb0>
81129004:	9005883a 	mov	r2,r18
81129008:	dfc00517 	ldw	ra,20(sp)
8112900c:	dd000417 	ldw	r20,16(sp)
81129010:	dcc00317 	ldw	r19,12(sp)
81129014:	dc800217 	ldw	r18,8(sp)
81129018:	dc400117 	ldw	r17,4(sp)
8112901c:	dc000017 	ldw	r16,0(sp)
81129020:	dec00604 	addi	sp,sp,24
81129024:	f800283a 	ret
81129028:	880d883a 	mov	r6,r17
8112902c:	880b883a 	mov	r5,r17
81129030:	9809883a 	mov	r4,r19
81129034:	1128d5c0 	call	81128d5c <__multiply>
81129038:	88800015 	stw	r2,0(r17)
8112903c:	10000015 	stw	zero,0(r2)
81129040:	003fdd06 	br	81128fb8 <__reset+0xfb108fb8>
81129044:	1025883a 	mov	r18,r2
81129048:	003fd706 	br	81128fa8 <__reset+0xfb108fa8>
8112904c:	10bfffc4 	addi	r2,r2,-1
81129050:	1085883a 	add	r2,r2,r2
81129054:	00e04574 	movhi	r3,33045
81129058:	18f3bd04 	addi	r3,r3,-12556
8112905c:	1085883a 	add	r2,r2,r2
81129060:	1885883a 	add	r2,r3,r2
81129064:	11800017 	ldw	r6,0(r2)
81129068:	000f883a 	mov	r7,zero
8112906c:	11289cc0 	call	811289cc <__multadd>
81129070:	1025883a 	mov	r18,r2
81129074:	003fc706 	br	81128f94 <__reset+0xfb108f94>
81129078:	05000044 	movi	r20,1
8112907c:	a00b883a 	mov	r5,r20
81129080:	9809883a 	mov	r4,r19
81129084:	11288f40 	call	811288f4 <_Balloc>
81129088:	1023883a 	mov	r17,r2
8112908c:	00809c44 	movi	r2,625
81129090:	88800515 	stw	r2,20(r17)
81129094:	8d000415 	stw	r20,16(r17)
81129098:	9c401215 	stw	r17,72(r19)
8112909c:	88000015 	stw	zero,0(r17)
811290a0:	003fc606 	br	81128fbc <__reset+0xfb108fbc>

811290a4 <__lshift>:
811290a4:	defff904 	addi	sp,sp,-28
811290a8:	de00012e 	bgeu	sp,et,811290b0 <__lshift+0xc>
811290ac:	003b68fa 	trap	3
811290b0:	dd400515 	stw	r21,20(sp)
811290b4:	dcc00315 	stw	r19,12(sp)
811290b8:	302bd17a 	srai	r21,r6,5
811290bc:	2cc00417 	ldw	r19,16(r5)
811290c0:	28800217 	ldw	r2,8(r5)
811290c4:	dd000415 	stw	r20,16(sp)
811290c8:	ace7883a 	add	r19,r21,r19
811290cc:	dc800215 	stw	r18,8(sp)
811290d0:	dc400115 	stw	r17,4(sp)
811290d4:	dc000015 	stw	r16,0(sp)
811290d8:	dfc00615 	stw	ra,24(sp)
811290dc:	9c000044 	addi	r16,r19,1
811290e0:	2823883a 	mov	r17,r5
811290e4:	3029883a 	mov	r20,r6
811290e8:	2025883a 	mov	r18,r4
811290ec:	29400117 	ldw	r5,4(r5)
811290f0:	1400030e 	bge	r2,r16,81129100 <__lshift+0x5c>
811290f4:	1085883a 	add	r2,r2,r2
811290f8:	29400044 	addi	r5,r5,1
811290fc:	143ffd16 	blt	r2,r16,811290f4 <__reset+0xfb1090f4>
81129100:	9009883a 	mov	r4,r18
81129104:	11288f40 	call	811288f4 <_Balloc>
81129108:	10c00504 	addi	r3,r2,20
8112910c:	0540070e 	bge	zero,r21,8112912c <__lshift+0x88>
81129110:	ad6b883a 	add	r21,r21,r21
81129114:	ad6b883a 	add	r21,r21,r21
81129118:	1809883a 	mov	r4,r3
8112911c:	1d47883a 	add	r3,r3,r21
81129120:	20000015 	stw	zero,0(r4)
81129124:	21000104 	addi	r4,r4,4
81129128:	193ffd1e 	bne	r3,r4,81129120 <__reset+0xfb109120>
8112912c:	8a000417 	ldw	r8,16(r17)
81129130:	89000504 	addi	r4,r17,20
81129134:	a18007cc 	andi	r6,r20,31
81129138:	4211883a 	add	r8,r8,r8
8112913c:	4211883a 	add	r8,r8,r8
81129140:	2211883a 	add	r8,r4,r8
81129144:	30002326 	beq	r6,zero,811291d4 <__lshift+0x130>
81129148:	02400804 	movi	r9,32
8112914c:	4993c83a 	sub	r9,r9,r6
81129150:	000b883a 	mov	r5,zero
81129154:	21c00017 	ldw	r7,0(r4)
81129158:	1815883a 	mov	r10,r3
8112915c:	18c00104 	addi	r3,r3,4
81129160:	398e983a 	sll	r7,r7,r6
81129164:	21000104 	addi	r4,r4,4
81129168:	394ab03a 	or	r5,r7,r5
8112916c:	197fff15 	stw	r5,-4(r3)
81129170:	217fff17 	ldw	r5,-4(r4)
81129174:	2a4ad83a 	srl	r5,r5,r9
81129178:	223ff636 	bltu	r4,r8,81129154 <__reset+0xfb109154>
8112917c:	51400115 	stw	r5,4(r10)
81129180:	28001a1e 	bne	r5,zero,811291ec <__lshift+0x148>
81129184:	843fffc4 	addi	r16,r16,-1
81129188:	14000415 	stw	r16,16(r2)
8112918c:	88000826 	beq	r17,zero,811291b0 <__lshift+0x10c>
81129190:	89000117 	ldw	r4,4(r17)
81129194:	90c01317 	ldw	r3,76(r18)
81129198:	2109883a 	add	r4,r4,r4
8112919c:	2109883a 	add	r4,r4,r4
811291a0:	1907883a 	add	r3,r3,r4
811291a4:	19000017 	ldw	r4,0(r3)
811291a8:	89000015 	stw	r4,0(r17)
811291ac:	1c400015 	stw	r17,0(r3)
811291b0:	dfc00617 	ldw	ra,24(sp)
811291b4:	dd400517 	ldw	r21,20(sp)
811291b8:	dd000417 	ldw	r20,16(sp)
811291bc:	dcc00317 	ldw	r19,12(sp)
811291c0:	dc800217 	ldw	r18,8(sp)
811291c4:	dc400117 	ldw	r17,4(sp)
811291c8:	dc000017 	ldw	r16,0(sp)
811291cc:	dec00704 	addi	sp,sp,28
811291d0:	f800283a 	ret
811291d4:	21400017 	ldw	r5,0(r4)
811291d8:	18c00104 	addi	r3,r3,4
811291dc:	21000104 	addi	r4,r4,4
811291e0:	197fff15 	stw	r5,-4(r3)
811291e4:	223ffb36 	bltu	r4,r8,811291d4 <__reset+0xfb1091d4>
811291e8:	003fe606 	br	81129184 <__reset+0xfb109184>
811291ec:	9c000084 	addi	r16,r19,2
811291f0:	003fe406 	br	81129184 <__reset+0xfb109184>

811291f4 <__mcmp>:
811291f4:	20800417 	ldw	r2,16(r4)
811291f8:	28c00417 	ldw	r3,16(r5)
811291fc:	10c5c83a 	sub	r2,r2,r3
81129200:	1000111e 	bne	r2,zero,81129248 <__mcmp+0x54>
81129204:	18c7883a 	add	r3,r3,r3
81129208:	18c7883a 	add	r3,r3,r3
8112920c:	21000504 	addi	r4,r4,20
81129210:	29400504 	addi	r5,r5,20
81129214:	20c5883a 	add	r2,r4,r3
81129218:	28cb883a 	add	r5,r5,r3
8112921c:	00000106 	br	81129224 <__mcmp+0x30>
81129220:	20800a2e 	bgeu	r4,r2,8112924c <__mcmp+0x58>
81129224:	10bfff04 	addi	r2,r2,-4
81129228:	297fff04 	addi	r5,r5,-4
8112922c:	11800017 	ldw	r6,0(r2)
81129230:	28c00017 	ldw	r3,0(r5)
81129234:	30fffa26 	beq	r6,r3,81129220 <__reset+0xfb109220>
81129238:	30c00236 	bltu	r6,r3,81129244 <__mcmp+0x50>
8112923c:	00800044 	movi	r2,1
81129240:	f800283a 	ret
81129244:	00bfffc4 	movi	r2,-1
81129248:	f800283a 	ret
8112924c:	0005883a 	mov	r2,zero
81129250:	f800283a 	ret

81129254 <__mdiff>:
81129254:	defffa04 	addi	sp,sp,-24
81129258:	de00012e 	bgeu	sp,et,81129260 <__mdiff+0xc>
8112925c:	003b68fa 	trap	3
81129260:	28c00417 	ldw	r3,16(r5)
81129264:	30800417 	ldw	r2,16(r6)
81129268:	dcc00315 	stw	r19,12(sp)
8112926c:	dc800215 	stw	r18,8(sp)
81129270:	dfc00515 	stw	ra,20(sp)
81129274:	dd000415 	stw	r20,16(sp)
81129278:	dc400115 	stw	r17,4(sp)
8112927c:	dc000015 	stw	r16,0(sp)
81129280:	1887c83a 	sub	r3,r3,r2
81129284:	2825883a 	mov	r18,r5
81129288:	3027883a 	mov	r19,r6
8112928c:	1800141e 	bne	r3,zero,811292e0 <__mdiff+0x8c>
81129290:	1085883a 	add	r2,r2,r2
81129294:	1085883a 	add	r2,r2,r2
81129298:	2a000504 	addi	r8,r5,20
8112929c:	34000504 	addi	r16,r6,20
811292a0:	4087883a 	add	r3,r8,r2
811292a4:	8085883a 	add	r2,r16,r2
811292a8:	00000106 	br	811292b0 <__mdiff+0x5c>
811292ac:	40c0592e 	bgeu	r8,r3,81129414 <__mdiff+0x1c0>
811292b0:	18ffff04 	addi	r3,r3,-4
811292b4:	10bfff04 	addi	r2,r2,-4
811292b8:	19c00017 	ldw	r7,0(r3)
811292bc:	11400017 	ldw	r5,0(r2)
811292c0:	397ffa26 	beq	r7,r5,811292ac <__reset+0xfb1092ac>
811292c4:	3940592e 	bgeu	r7,r5,8112942c <__mdiff+0x1d8>
811292c8:	9005883a 	mov	r2,r18
811292cc:	4023883a 	mov	r17,r8
811292d0:	9825883a 	mov	r18,r19
811292d4:	05000044 	movi	r20,1
811292d8:	1027883a 	mov	r19,r2
811292dc:	00000406 	br	811292f0 <__mdiff+0x9c>
811292e0:	18005616 	blt	r3,zero,8112943c <__mdiff+0x1e8>
811292e4:	34400504 	addi	r17,r6,20
811292e8:	2c000504 	addi	r16,r5,20
811292ec:	0029883a 	mov	r20,zero
811292f0:	91400117 	ldw	r5,4(r18)
811292f4:	11288f40 	call	811288f4 <_Balloc>
811292f8:	92400417 	ldw	r9,16(r18)
811292fc:	9b000417 	ldw	r12,16(r19)
81129300:	12c00504 	addi	r11,r2,20
81129304:	4a51883a 	add	r8,r9,r9
81129308:	6319883a 	add	r12,r12,r12
8112930c:	4211883a 	add	r8,r8,r8
81129310:	6319883a 	add	r12,r12,r12
81129314:	15000315 	stw	r20,12(r2)
81129318:	8211883a 	add	r8,r16,r8
8112931c:	8b19883a 	add	r12,r17,r12
81129320:	0007883a 	mov	r3,zero
81129324:	81400017 	ldw	r5,0(r16)
81129328:	89c00017 	ldw	r7,0(r17)
8112932c:	59800104 	addi	r6,r11,4
81129330:	293fffcc 	andi	r4,r5,65535
81129334:	20c7883a 	add	r3,r4,r3
81129338:	393fffcc 	andi	r4,r7,65535
8112933c:	1909c83a 	sub	r4,r3,r4
81129340:	280ad43a 	srli	r5,r5,16
81129344:	380ed43a 	srli	r7,r7,16
81129348:	2007d43a 	srai	r3,r4,16
8112934c:	213fffcc 	andi	r4,r4,65535
81129350:	29cbc83a 	sub	r5,r5,r7
81129354:	28c7883a 	add	r3,r5,r3
81129358:	180a943a 	slli	r5,r3,16
8112935c:	8c400104 	addi	r17,r17,4
81129360:	84000104 	addi	r16,r16,4
81129364:	2908b03a 	or	r4,r5,r4
81129368:	59000015 	stw	r4,0(r11)
8112936c:	1807d43a 	srai	r3,r3,16
81129370:	3015883a 	mov	r10,r6
81129374:	3017883a 	mov	r11,r6
81129378:	8b3fea36 	bltu	r17,r12,81129324 <__reset+0xfb109324>
8112937c:	8200162e 	bgeu	r16,r8,811293d8 <__mdiff+0x184>
81129380:	8017883a 	mov	r11,r16
81129384:	59400017 	ldw	r5,0(r11)
81129388:	31800104 	addi	r6,r6,4
8112938c:	5ac00104 	addi	r11,r11,4
81129390:	293fffcc 	andi	r4,r5,65535
81129394:	20c7883a 	add	r3,r4,r3
81129398:	280ed43a 	srli	r7,r5,16
8112939c:	180bd43a 	srai	r5,r3,16
811293a0:	193fffcc 	andi	r4,r3,65535
811293a4:	3947883a 	add	r3,r7,r5
811293a8:	180a943a 	slli	r5,r3,16
811293ac:	1807d43a 	srai	r3,r3,16
811293b0:	2908b03a 	or	r4,r5,r4
811293b4:	313fff15 	stw	r4,-4(r6)
811293b8:	5a3ff236 	bltu	r11,r8,81129384 <__reset+0xfb109384>
811293bc:	0406303a 	nor	r3,zero,r16
811293c0:	1a07883a 	add	r3,r3,r8
811293c4:	1806d0ba 	srli	r3,r3,2
811293c8:	18c00044 	addi	r3,r3,1
811293cc:	18c7883a 	add	r3,r3,r3
811293d0:	18c7883a 	add	r3,r3,r3
811293d4:	50d5883a 	add	r10,r10,r3
811293d8:	50ffff04 	addi	r3,r10,-4
811293dc:	2000041e 	bne	r4,zero,811293f0 <__mdiff+0x19c>
811293e0:	18ffff04 	addi	r3,r3,-4
811293e4:	19000017 	ldw	r4,0(r3)
811293e8:	4a7fffc4 	addi	r9,r9,-1
811293ec:	203ffc26 	beq	r4,zero,811293e0 <__reset+0xfb1093e0>
811293f0:	12400415 	stw	r9,16(r2)
811293f4:	dfc00517 	ldw	ra,20(sp)
811293f8:	dd000417 	ldw	r20,16(sp)
811293fc:	dcc00317 	ldw	r19,12(sp)
81129400:	dc800217 	ldw	r18,8(sp)
81129404:	dc400117 	ldw	r17,4(sp)
81129408:	dc000017 	ldw	r16,0(sp)
8112940c:	dec00604 	addi	sp,sp,24
81129410:	f800283a 	ret
81129414:	000b883a 	mov	r5,zero
81129418:	11288f40 	call	811288f4 <_Balloc>
8112941c:	00c00044 	movi	r3,1
81129420:	10c00415 	stw	r3,16(r2)
81129424:	10000515 	stw	zero,20(r2)
81129428:	003ff206 	br	811293f4 <__reset+0xfb1093f4>
8112942c:	8023883a 	mov	r17,r16
81129430:	0029883a 	mov	r20,zero
81129434:	4021883a 	mov	r16,r8
81129438:	003fad06 	br	811292f0 <__reset+0xfb1092f0>
8112943c:	9005883a 	mov	r2,r18
81129440:	94400504 	addi	r17,r18,20
81129444:	9c000504 	addi	r16,r19,20
81129448:	9825883a 	mov	r18,r19
8112944c:	05000044 	movi	r20,1
81129450:	1027883a 	mov	r19,r2
81129454:	003fa606 	br	811292f0 <__reset+0xfb1092f0>

81129458 <__ulp>:
81129458:	295ffc2c 	andhi	r5,r5,32752
8112945c:	00bf3034 	movhi	r2,64704
81129460:	2887883a 	add	r3,r5,r2
81129464:	00c0020e 	bge	zero,r3,81129470 <__ulp+0x18>
81129468:	0005883a 	mov	r2,zero
8112946c:	f800283a 	ret
81129470:	00c7c83a 	sub	r3,zero,r3
81129474:	1807d53a 	srai	r3,r3,20
81129478:	008004c4 	movi	r2,19
8112947c:	10c00b0e 	bge	r2,r3,811294ac <__ulp+0x54>
81129480:	18bffb04 	addi	r2,r3,-20
81129484:	01000784 	movi	r4,30
81129488:	0007883a 	mov	r3,zero
8112948c:	20800516 	blt	r4,r2,811294a4 <__ulp+0x4c>
81129490:	010007c4 	movi	r4,31
81129494:	2089c83a 	sub	r4,r4,r2
81129498:	00800044 	movi	r2,1
8112949c:	1104983a 	sll	r2,r2,r4
811294a0:	f800283a 	ret
811294a4:	00800044 	movi	r2,1
811294a8:	f800283a 	ret
811294ac:	01400234 	movhi	r5,8
811294b0:	28c7d83a 	sra	r3,r5,r3
811294b4:	0005883a 	mov	r2,zero
811294b8:	f800283a 	ret

811294bc <__b2d>:
811294bc:	defffa04 	addi	sp,sp,-24
811294c0:	de00012e 	bgeu	sp,et,811294c8 <__b2d+0xc>
811294c4:	003b68fa 	trap	3
811294c8:	dc000015 	stw	r16,0(sp)
811294cc:	24000417 	ldw	r16,16(r4)
811294d0:	dc400115 	stw	r17,4(sp)
811294d4:	24400504 	addi	r17,r4,20
811294d8:	8421883a 	add	r16,r16,r16
811294dc:	8421883a 	add	r16,r16,r16
811294e0:	8c21883a 	add	r16,r17,r16
811294e4:	dc800215 	stw	r18,8(sp)
811294e8:	84bfff17 	ldw	r18,-4(r16)
811294ec:	dd000415 	stw	r20,16(sp)
811294f0:	dcc00315 	stw	r19,12(sp)
811294f4:	9009883a 	mov	r4,r18
811294f8:	2829883a 	mov	r20,r5
811294fc:	dfc00515 	stw	ra,20(sp)
81129500:	1128c000 	call	81128c00 <__hi0bits>
81129504:	00c00804 	movi	r3,32
81129508:	1889c83a 	sub	r4,r3,r2
8112950c:	a1000015 	stw	r4,0(r20)
81129510:	01000284 	movi	r4,10
81129514:	84ffff04 	addi	r19,r16,-4
81129518:	20801216 	blt	r4,r2,81129564 <__b2d+0xa8>
8112951c:	018002c4 	movi	r6,11
81129520:	308dc83a 	sub	r6,r6,r2
81129524:	9186d83a 	srl	r3,r18,r6
81129528:	18cffc34 	orhi	r3,r3,16368
8112952c:	8cc0212e 	bgeu	r17,r19,811295b4 <__b2d+0xf8>
81129530:	813ffe17 	ldw	r4,-8(r16)
81129534:	218cd83a 	srl	r6,r4,r6
81129538:	10800544 	addi	r2,r2,21
8112953c:	9084983a 	sll	r2,r18,r2
81129540:	1184b03a 	or	r2,r2,r6
81129544:	dfc00517 	ldw	ra,20(sp)
81129548:	dd000417 	ldw	r20,16(sp)
8112954c:	dcc00317 	ldw	r19,12(sp)
81129550:	dc800217 	ldw	r18,8(sp)
81129554:	dc400117 	ldw	r17,4(sp)
81129558:	dc000017 	ldw	r16,0(sp)
8112955c:	dec00604 	addi	sp,sp,24
81129560:	f800283a 	ret
81129564:	8cc00f2e 	bgeu	r17,r19,811295a4 <__b2d+0xe8>
81129568:	117ffd44 	addi	r5,r2,-11
8112956c:	80bffe17 	ldw	r2,-8(r16)
81129570:	28000e26 	beq	r5,zero,811295ac <__b2d+0xf0>
81129574:	1949c83a 	sub	r4,r3,r5
81129578:	9164983a 	sll	r18,r18,r5
8112957c:	1106d83a 	srl	r3,r2,r4
81129580:	81bffe04 	addi	r6,r16,-8
81129584:	948ffc34 	orhi	r18,r18,16368
81129588:	90c6b03a 	or	r3,r18,r3
8112958c:	89800e2e 	bgeu	r17,r6,811295c8 <__b2d+0x10c>
81129590:	81bffd17 	ldw	r6,-12(r16)
81129594:	1144983a 	sll	r2,r2,r5
81129598:	310ad83a 	srl	r5,r6,r4
8112959c:	2884b03a 	or	r2,r5,r2
811295a0:	003fe806 	br	81129544 <__reset+0xfb109544>
811295a4:	10bffd44 	addi	r2,r2,-11
811295a8:	1000041e 	bne	r2,zero,811295bc <__b2d+0x100>
811295ac:	90cffc34 	orhi	r3,r18,16368
811295b0:	003fe406 	br	81129544 <__reset+0xfb109544>
811295b4:	000d883a 	mov	r6,zero
811295b8:	003fdf06 	br	81129538 <__reset+0xfb109538>
811295bc:	90a4983a 	sll	r18,r18,r2
811295c0:	0005883a 	mov	r2,zero
811295c4:	003ff906 	br	811295ac <__reset+0xfb1095ac>
811295c8:	1144983a 	sll	r2,r2,r5
811295cc:	003fdd06 	br	81129544 <__reset+0xfb109544>

811295d0 <__d2b>:
811295d0:	defff804 	addi	sp,sp,-32
811295d4:	de00012e 	bgeu	sp,et,811295dc <__d2b+0xc>
811295d8:	003b68fa 	trap	3
811295dc:	dc000215 	stw	r16,8(sp)
811295e0:	3021883a 	mov	r16,r6
811295e4:	dc400315 	stw	r17,12(sp)
811295e8:	8022907a 	slli	r17,r16,1
811295ec:	dd000615 	stw	r20,24(sp)
811295f0:	2829883a 	mov	r20,r5
811295f4:	01400044 	movi	r5,1
811295f8:	dcc00515 	stw	r19,20(sp)
811295fc:	dc800415 	stw	r18,16(sp)
81129600:	dfc00715 	stw	ra,28(sp)
81129604:	3825883a 	mov	r18,r7
81129608:	8822d57a 	srli	r17,r17,21
8112960c:	11288f40 	call	811288f4 <_Balloc>
81129610:	1027883a 	mov	r19,r2
81129614:	00800434 	movhi	r2,16
81129618:	10bfffc4 	addi	r2,r2,-1
8112961c:	808c703a 	and	r6,r16,r2
81129620:	88000126 	beq	r17,zero,81129628 <__d2b+0x58>
81129624:	31800434 	orhi	r6,r6,16
81129628:	d9800015 	stw	r6,0(sp)
8112962c:	a0002426 	beq	r20,zero,811296c0 <__d2b+0xf0>
81129630:	d9000104 	addi	r4,sp,4
81129634:	dd000115 	stw	r20,4(sp)
81129638:	1128c680 	call	81128c68 <__lo0bits>
8112963c:	d8c00017 	ldw	r3,0(sp)
81129640:	10002f1e 	bne	r2,zero,81129700 <__d2b+0x130>
81129644:	d9000117 	ldw	r4,4(sp)
81129648:	99000515 	stw	r4,20(r19)
8112964c:	1821003a 	cmpeq	r16,r3,zero
81129650:	01000084 	movi	r4,2
81129654:	2421c83a 	sub	r16,r4,r16
81129658:	98c00615 	stw	r3,24(r19)
8112965c:	9c000415 	stw	r16,16(r19)
81129660:	88001f1e 	bne	r17,zero,811296e0 <__d2b+0x110>
81129664:	10bef384 	addi	r2,r2,-1074
81129668:	90800015 	stw	r2,0(r18)
8112966c:	00900034 	movhi	r2,16384
81129670:	10bfffc4 	addi	r2,r2,-1
81129674:	8085883a 	add	r2,r16,r2
81129678:	1085883a 	add	r2,r2,r2
8112967c:	1085883a 	add	r2,r2,r2
81129680:	9885883a 	add	r2,r19,r2
81129684:	11000517 	ldw	r4,20(r2)
81129688:	8020917a 	slli	r16,r16,5
8112968c:	1128c000 	call	81128c00 <__hi0bits>
81129690:	d8c00817 	ldw	r3,32(sp)
81129694:	8085c83a 	sub	r2,r16,r2
81129698:	18800015 	stw	r2,0(r3)
8112969c:	9805883a 	mov	r2,r19
811296a0:	dfc00717 	ldw	ra,28(sp)
811296a4:	dd000617 	ldw	r20,24(sp)
811296a8:	dcc00517 	ldw	r19,20(sp)
811296ac:	dc800417 	ldw	r18,16(sp)
811296b0:	dc400317 	ldw	r17,12(sp)
811296b4:	dc000217 	ldw	r16,8(sp)
811296b8:	dec00804 	addi	sp,sp,32
811296bc:	f800283a 	ret
811296c0:	d809883a 	mov	r4,sp
811296c4:	1128c680 	call	81128c68 <__lo0bits>
811296c8:	d8c00017 	ldw	r3,0(sp)
811296cc:	04000044 	movi	r16,1
811296d0:	9c000415 	stw	r16,16(r19)
811296d4:	98c00515 	stw	r3,20(r19)
811296d8:	10800804 	addi	r2,r2,32
811296dc:	883fe126 	beq	r17,zero,81129664 <__reset+0xfb109664>
811296e0:	00c00d44 	movi	r3,53
811296e4:	8c7ef344 	addi	r17,r17,-1075
811296e8:	88a3883a 	add	r17,r17,r2
811296ec:	1885c83a 	sub	r2,r3,r2
811296f0:	d8c00817 	ldw	r3,32(sp)
811296f4:	94400015 	stw	r17,0(r18)
811296f8:	18800015 	stw	r2,0(r3)
811296fc:	003fe706 	br	8112969c <__reset+0xfb10969c>
81129700:	01000804 	movi	r4,32
81129704:	2089c83a 	sub	r4,r4,r2
81129708:	1908983a 	sll	r4,r3,r4
8112970c:	d9400117 	ldw	r5,4(sp)
81129710:	1886d83a 	srl	r3,r3,r2
81129714:	2148b03a 	or	r4,r4,r5
81129718:	99000515 	stw	r4,20(r19)
8112971c:	d8c00015 	stw	r3,0(sp)
81129720:	003fca06 	br	8112964c <__reset+0xfb10964c>

81129724 <__ratio>:
81129724:	defff904 	addi	sp,sp,-28
81129728:	de00012e 	bgeu	sp,et,81129730 <__ratio+0xc>
8112972c:	003b68fa 	trap	3
81129730:	dc400315 	stw	r17,12(sp)
81129734:	2823883a 	mov	r17,r5
81129738:	d9400104 	addi	r5,sp,4
8112973c:	dfc00615 	stw	ra,24(sp)
81129740:	dcc00515 	stw	r19,20(sp)
81129744:	dc800415 	stw	r18,16(sp)
81129748:	2027883a 	mov	r19,r4
8112974c:	dc000215 	stw	r16,8(sp)
81129750:	11294bc0 	call	811294bc <__b2d>
81129754:	d80b883a 	mov	r5,sp
81129758:	8809883a 	mov	r4,r17
8112975c:	1025883a 	mov	r18,r2
81129760:	1821883a 	mov	r16,r3
81129764:	11294bc0 	call	811294bc <__b2d>
81129768:	8a000417 	ldw	r8,16(r17)
8112976c:	99000417 	ldw	r4,16(r19)
81129770:	d9400117 	ldw	r5,4(sp)
81129774:	2209c83a 	sub	r4,r4,r8
81129778:	2010917a 	slli	r8,r4,5
8112977c:	d9000017 	ldw	r4,0(sp)
81129780:	2909c83a 	sub	r4,r5,r4
81129784:	4109883a 	add	r4,r8,r4
81129788:	01000e0e 	bge	zero,r4,811297c4 <__ratio+0xa0>
8112978c:	2008953a 	slli	r4,r4,20
81129790:	2421883a 	add	r16,r4,r16
81129794:	100d883a 	mov	r6,r2
81129798:	180f883a 	mov	r7,r3
8112979c:	9009883a 	mov	r4,r18
811297a0:	800b883a 	mov	r5,r16
811297a4:	11318180 	call	81131818 <__divdf3>
811297a8:	dfc00617 	ldw	ra,24(sp)
811297ac:	dcc00517 	ldw	r19,20(sp)
811297b0:	dc800417 	ldw	r18,16(sp)
811297b4:	dc400317 	ldw	r17,12(sp)
811297b8:	dc000217 	ldw	r16,8(sp)
811297bc:	dec00704 	addi	sp,sp,28
811297c0:	f800283a 	ret
811297c4:	2008953a 	slli	r4,r4,20
811297c8:	1907c83a 	sub	r3,r3,r4
811297cc:	003ff106 	br	81129794 <__reset+0xfb109794>

811297d0 <_mprec_log10>:
811297d0:	defffe04 	addi	sp,sp,-8
811297d4:	de00012e 	bgeu	sp,et,811297dc <_mprec_log10+0xc>
811297d8:	003b68fa 	trap	3
811297dc:	008005c4 	movi	r2,23
811297e0:	dc000015 	stw	r16,0(sp)
811297e4:	dfc00115 	stw	ra,4(sp)
811297e8:	2021883a 	mov	r16,r4
811297ec:	11000d0e 	bge	r2,r4,81129824 <_mprec_log10+0x54>
811297f0:	0005883a 	mov	r2,zero
811297f4:	00cffc34 	movhi	r3,16368
811297f8:	843fffc4 	addi	r16,r16,-1
811297fc:	000d883a 	mov	r6,zero
81129800:	01d00934 	movhi	r7,16420
81129804:	1009883a 	mov	r4,r2
81129808:	180b883a 	mov	r5,r3
8112980c:	111ca740 	call	8111ca74 <__muldf3>
81129810:	803ff91e 	bne	r16,zero,811297f8 <__reset+0xfb1097f8>
81129814:	dfc00117 	ldw	ra,4(sp)
81129818:	dc000017 	ldw	r16,0(sp)
8112981c:	dec00204 	addi	sp,sp,8
81129820:	f800283a 	ret
81129824:	202090fa 	slli	r16,r4,3
81129828:	00a04574 	movhi	r2,33045
8112982c:	10b3d404 	addi	r2,r2,-12464
81129830:	1421883a 	add	r16,r2,r16
81129834:	80800017 	ldw	r2,0(r16)
81129838:	80c00117 	ldw	r3,4(r16)
8112983c:	dfc00117 	ldw	ra,4(sp)
81129840:	dc000017 	ldw	r16,0(sp)
81129844:	dec00204 	addi	sp,sp,8
81129848:	f800283a 	ret

8112984c <__copybits>:
8112984c:	297fffc4 	addi	r5,r5,-1
81129850:	280fd17a 	srai	r7,r5,5
81129854:	30c00417 	ldw	r3,16(r6)
81129858:	30800504 	addi	r2,r6,20
8112985c:	39c00044 	addi	r7,r7,1
81129860:	18c7883a 	add	r3,r3,r3
81129864:	39cf883a 	add	r7,r7,r7
81129868:	18c7883a 	add	r3,r3,r3
8112986c:	39cf883a 	add	r7,r7,r7
81129870:	10c7883a 	add	r3,r2,r3
81129874:	21cf883a 	add	r7,r4,r7
81129878:	10c00d2e 	bgeu	r2,r3,811298b0 <__copybits+0x64>
8112987c:	200b883a 	mov	r5,r4
81129880:	12000017 	ldw	r8,0(r2)
81129884:	29400104 	addi	r5,r5,4
81129888:	10800104 	addi	r2,r2,4
8112988c:	2a3fff15 	stw	r8,-4(r5)
81129890:	10fffb36 	bltu	r2,r3,81129880 <__reset+0xfb109880>
81129894:	1985c83a 	sub	r2,r3,r6
81129898:	10bffac4 	addi	r2,r2,-21
8112989c:	1004d0ba 	srli	r2,r2,2
811298a0:	10800044 	addi	r2,r2,1
811298a4:	1085883a 	add	r2,r2,r2
811298a8:	1085883a 	add	r2,r2,r2
811298ac:	2089883a 	add	r4,r4,r2
811298b0:	21c0032e 	bgeu	r4,r7,811298c0 <__copybits+0x74>
811298b4:	20000015 	stw	zero,0(r4)
811298b8:	21000104 	addi	r4,r4,4
811298bc:	21fffd36 	bltu	r4,r7,811298b4 <__reset+0xfb1098b4>
811298c0:	f800283a 	ret

811298c4 <__any_on>:
811298c4:	20c00417 	ldw	r3,16(r4)
811298c8:	2805d17a 	srai	r2,r5,5
811298cc:	21000504 	addi	r4,r4,20
811298d0:	18800d0e 	bge	r3,r2,81129908 <__any_on+0x44>
811298d4:	18c7883a 	add	r3,r3,r3
811298d8:	18c7883a 	add	r3,r3,r3
811298dc:	20c7883a 	add	r3,r4,r3
811298e0:	20c0192e 	bgeu	r4,r3,81129948 <__any_on+0x84>
811298e4:	18bfff17 	ldw	r2,-4(r3)
811298e8:	18ffff04 	addi	r3,r3,-4
811298ec:	1000041e 	bne	r2,zero,81129900 <__any_on+0x3c>
811298f0:	20c0142e 	bgeu	r4,r3,81129944 <__any_on+0x80>
811298f4:	18ffff04 	addi	r3,r3,-4
811298f8:	19400017 	ldw	r5,0(r3)
811298fc:	283ffc26 	beq	r5,zero,811298f0 <__reset+0xfb1098f0>
81129900:	00800044 	movi	r2,1
81129904:	f800283a 	ret
81129908:	10c00a0e 	bge	r2,r3,81129934 <__any_on+0x70>
8112990c:	1085883a 	add	r2,r2,r2
81129910:	1085883a 	add	r2,r2,r2
81129914:	294007cc 	andi	r5,r5,31
81129918:	2087883a 	add	r3,r4,r2
8112991c:	283ff026 	beq	r5,zero,811298e0 <__reset+0xfb1098e0>
81129920:	19800017 	ldw	r6,0(r3)
81129924:	3144d83a 	srl	r2,r6,r5
81129928:	114a983a 	sll	r5,r2,r5
8112992c:	317ff41e 	bne	r6,r5,81129900 <__reset+0xfb109900>
81129930:	003feb06 	br	811298e0 <__reset+0xfb1098e0>
81129934:	1085883a 	add	r2,r2,r2
81129938:	1085883a 	add	r2,r2,r2
8112993c:	2087883a 	add	r3,r4,r2
81129940:	003fe706 	br	811298e0 <__reset+0xfb1098e0>
81129944:	f800283a 	ret
81129948:	0005883a 	mov	r2,zero
8112994c:	f800283a 	ret

81129950 <_read_r>:
81129950:	defffd04 	addi	sp,sp,-12
81129954:	de00012e 	bgeu	sp,et,8112995c <_read_r+0xc>
81129958:	003b68fa 	trap	3
8112995c:	2805883a 	mov	r2,r5
81129960:	dc000015 	stw	r16,0(sp)
81129964:	04204574 	movhi	r16,33045
81129968:	dc400115 	stw	r17,4(sp)
8112996c:	300b883a 	mov	r5,r6
81129970:	843dd504 	addi	r16,r16,-2220
81129974:	2023883a 	mov	r17,r4
81129978:	380d883a 	mov	r6,r7
8112997c:	1009883a 	mov	r4,r2
81129980:	dfc00215 	stw	ra,8(sp)
81129984:	80000015 	stw	zero,0(r16)
81129988:	11344cc0 	call	811344cc <read>
8112998c:	00ffffc4 	movi	r3,-1
81129990:	10c00526 	beq	r2,r3,811299a8 <_read_r+0x58>
81129994:	dfc00217 	ldw	ra,8(sp)
81129998:	dc400117 	ldw	r17,4(sp)
8112999c:	dc000017 	ldw	r16,0(sp)
811299a0:	dec00304 	addi	sp,sp,12
811299a4:	f800283a 	ret
811299a8:	80c00017 	ldw	r3,0(r16)
811299ac:	183ff926 	beq	r3,zero,81129994 <__reset+0xfb109994>
811299b0:	88c00015 	stw	r3,0(r17)
811299b4:	003ff706 	br	81129994 <__reset+0xfb109994>

811299b8 <_realloc_r>:
811299b8:	defff604 	addi	sp,sp,-40
811299bc:	de00012e 	bgeu	sp,et,811299c4 <_realloc_r+0xc>
811299c0:	003b68fa 	trap	3
811299c4:	dc800215 	stw	r18,8(sp)
811299c8:	dfc00915 	stw	ra,36(sp)
811299cc:	df000815 	stw	fp,32(sp)
811299d0:	ddc00715 	stw	r23,28(sp)
811299d4:	dd800615 	stw	r22,24(sp)
811299d8:	dd400515 	stw	r21,20(sp)
811299dc:	dd000415 	stw	r20,16(sp)
811299e0:	dcc00315 	stw	r19,12(sp)
811299e4:	dc400115 	stw	r17,4(sp)
811299e8:	dc000015 	stw	r16,0(sp)
811299ec:	3025883a 	mov	r18,r6
811299f0:	2800b726 	beq	r5,zero,81129cd0 <_realloc_r+0x318>
811299f4:	282b883a 	mov	r21,r5
811299f8:	2029883a 	mov	r20,r4
811299fc:	1134cac0 	call	81134cac <__malloc_lock>
81129a00:	a8bfff17 	ldw	r2,-4(r21)
81129a04:	043fff04 	movi	r16,-4
81129a08:	90c002c4 	addi	r3,r18,11
81129a0c:	01000584 	movi	r4,22
81129a10:	acfffe04 	addi	r19,r21,-8
81129a14:	1420703a 	and	r16,r2,r16
81129a18:	20c0332e 	bgeu	r4,r3,81129ae8 <_realloc_r+0x130>
81129a1c:	047ffe04 	movi	r17,-8
81129a20:	1c62703a 	and	r17,r3,r17
81129a24:	8807883a 	mov	r3,r17
81129a28:	88005816 	blt	r17,zero,81129b8c <_realloc_r+0x1d4>
81129a2c:	8c805736 	bltu	r17,r18,81129b8c <_realloc_r+0x1d4>
81129a30:	80c0300e 	bge	r16,r3,81129af4 <_realloc_r+0x13c>
81129a34:	07204574 	movhi	fp,33045
81129a38:	e7372104 	addi	fp,fp,-9084
81129a3c:	e1c00217 	ldw	r7,8(fp)
81129a40:	9c09883a 	add	r4,r19,r16
81129a44:	22000117 	ldw	r8,4(r4)
81129a48:	21c06326 	beq	r4,r7,81129bd8 <_realloc_r+0x220>
81129a4c:	017fff84 	movi	r5,-2
81129a50:	414a703a 	and	r5,r8,r5
81129a54:	214b883a 	add	r5,r4,r5
81129a58:	29800117 	ldw	r6,4(r5)
81129a5c:	3180004c 	andi	r6,r6,1
81129a60:	30003f26 	beq	r6,zero,81129b60 <_realloc_r+0x1a8>
81129a64:	1080004c 	andi	r2,r2,1
81129a68:	10008326 	beq	r2,zero,81129c78 <_realloc_r+0x2c0>
81129a6c:	900b883a 	mov	r5,r18
81129a70:	a009883a 	mov	r4,r20
81129a74:	111deb00 	call	8111deb0 <_malloc_r>
81129a78:	1025883a 	mov	r18,r2
81129a7c:	10011e26 	beq	r2,zero,81129ef8 <_realloc_r+0x540>
81129a80:	a93fff17 	ldw	r4,-4(r21)
81129a84:	10fffe04 	addi	r3,r2,-8
81129a88:	00bfff84 	movi	r2,-2
81129a8c:	2084703a 	and	r2,r4,r2
81129a90:	9885883a 	add	r2,r19,r2
81129a94:	1880ee26 	beq	r3,r2,81129e50 <_realloc_r+0x498>
81129a98:	81bfff04 	addi	r6,r16,-4
81129a9c:	00800904 	movi	r2,36
81129aa0:	1180b836 	bltu	r2,r6,81129d84 <_realloc_r+0x3cc>
81129aa4:	00c004c4 	movi	r3,19
81129aa8:	19809636 	bltu	r3,r6,81129d04 <_realloc_r+0x34c>
81129aac:	9005883a 	mov	r2,r18
81129ab0:	a807883a 	mov	r3,r21
81129ab4:	19000017 	ldw	r4,0(r3)
81129ab8:	11000015 	stw	r4,0(r2)
81129abc:	19000117 	ldw	r4,4(r3)
81129ac0:	11000115 	stw	r4,4(r2)
81129ac4:	18c00217 	ldw	r3,8(r3)
81129ac8:	10c00215 	stw	r3,8(r2)
81129acc:	a80b883a 	mov	r5,r21
81129ad0:	a009883a 	mov	r4,r20
81129ad4:	11279240 	call	81127924 <_free_r>
81129ad8:	a009883a 	mov	r4,r20
81129adc:	1134dd40 	call	81134dd4 <__malloc_unlock>
81129ae0:	9005883a 	mov	r2,r18
81129ae4:	00001206 	br	81129b30 <_realloc_r+0x178>
81129ae8:	00c00404 	movi	r3,16
81129aec:	1823883a 	mov	r17,r3
81129af0:	003fce06 	br	81129a2c <__reset+0xfb109a2c>
81129af4:	a825883a 	mov	r18,r21
81129af8:	8445c83a 	sub	r2,r16,r17
81129afc:	00c003c4 	movi	r3,15
81129b00:	18802636 	bltu	r3,r2,81129b9c <_realloc_r+0x1e4>
81129b04:	99800117 	ldw	r6,4(r19)
81129b08:	9c07883a 	add	r3,r19,r16
81129b0c:	3180004c 	andi	r6,r6,1
81129b10:	3420b03a 	or	r16,r6,r16
81129b14:	9c000115 	stw	r16,4(r19)
81129b18:	18800117 	ldw	r2,4(r3)
81129b1c:	10800054 	ori	r2,r2,1
81129b20:	18800115 	stw	r2,4(r3)
81129b24:	a009883a 	mov	r4,r20
81129b28:	1134dd40 	call	81134dd4 <__malloc_unlock>
81129b2c:	9005883a 	mov	r2,r18
81129b30:	dfc00917 	ldw	ra,36(sp)
81129b34:	df000817 	ldw	fp,32(sp)
81129b38:	ddc00717 	ldw	r23,28(sp)
81129b3c:	dd800617 	ldw	r22,24(sp)
81129b40:	dd400517 	ldw	r21,20(sp)
81129b44:	dd000417 	ldw	r20,16(sp)
81129b48:	dcc00317 	ldw	r19,12(sp)
81129b4c:	dc800217 	ldw	r18,8(sp)
81129b50:	dc400117 	ldw	r17,4(sp)
81129b54:	dc000017 	ldw	r16,0(sp)
81129b58:	dec00a04 	addi	sp,sp,40
81129b5c:	f800283a 	ret
81129b60:	017fff04 	movi	r5,-4
81129b64:	414a703a 	and	r5,r8,r5
81129b68:	814d883a 	add	r6,r16,r5
81129b6c:	30c01f16 	blt	r6,r3,81129bec <_realloc_r+0x234>
81129b70:	20800317 	ldw	r2,12(r4)
81129b74:	20c00217 	ldw	r3,8(r4)
81129b78:	a825883a 	mov	r18,r21
81129b7c:	3021883a 	mov	r16,r6
81129b80:	18800315 	stw	r2,12(r3)
81129b84:	10c00215 	stw	r3,8(r2)
81129b88:	003fdb06 	br	81129af8 <__reset+0xfb109af8>
81129b8c:	00800304 	movi	r2,12
81129b90:	a0800015 	stw	r2,0(r20)
81129b94:	0005883a 	mov	r2,zero
81129b98:	003fe506 	br	81129b30 <__reset+0xfb109b30>
81129b9c:	98c00117 	ldw	r3,4(r19)
81129ba0:	9c4b883a 	add	r5,r19,r17
81129ba4:	11000054 	ori	r4,r2,1
81129ba8:	18c0004c 	andi	r3,r3,1
81129bac:	1c62b03a 	or	r17,r3,r17
81129bb0:	9c400115 	stw	r17,4(r19)
81129bb4:	29000115 	stw	r4,4(r5)
81129bb8:	2885883a 	add	r2,r5,r2
81129bbc:	10c00117 	ldw	r3,4(r2)
81129bc0:	29400204 	addi	r5,r5,8
81129bc4:	a009883a 	mov	r4,r20
81129bc8:	18c00054 	ori	r3,r3,1
81129bcc:	10c00115 	stw	r3,4(r2)
81129bd0:	11279240 	call	81127924 <_free_r>
81129bd4:	003fd306 	br	81129b24 <__reset+0xfb109b24>
81129bd8:	017fff04 	movi	r5,-4
81129bdc:	414a703a 	and	r5,r8,r5
81129be0:	89800404 	addi	r6,r17,16
81129be4:	8151883a 	add	r8,r16,r5
81129be8:	4180590e 	bge	r8,r6,81129d50 <_realloc_r+0x398>
81129bec:	1080004c 	andi	r2,r2,1
81129bf0:	103f9e1e 	bne	r2,zero,81129a6c <__reset+0xfb109a6c>
81129bf4:	adbffe17 	ldw	r22,-8(r21)
81129bf8:	00bfff04 	movi	r2,-4
81129bfc:	9dadc83a 	sub	r22,r19,r22
81129c00:	b1800117 	ldw	r6,4(r22)
81129c04:	3084703a 	and	r2,r6,r2
81129c08:	20002026 	beq	r4,zero,81129c8c <_realloc_r+0x2d4>
81129c0c:	80af883a 	add	r23,r16,r2
81129c10:	b96f883a 	add	r23,r23,r5
81129c14:	21c05f26 	beq	r4,r7,81129d94 <_realloc_r+0x3dc>
81129c18:	b8c01c16 	blt	r23,r3,81129c8c <_realloc_r+0x2d4>
81129c1c:	20800317 	ldw	r2,12(r4)
81129c20:	20c00217 	ldw	r3,8(r4)
81129c24:	81bfff04 	addi	r6,r16,-4
81129c28:	01000904 	movi	r4,36
81129c2c:	18800315 	stw	r2,12(r3)
81129c30:	10c00215 	stw	r3,8(r2)
81129c34:	b0c00217 	ldw	r3,8(r22)
81129c38:	b0800317 	ldw	r2,12(r22)
81129c3c:	b4800204 	addi	r18,r22,8
81129c40:	18800315 	stw	r2,12(r3)
81129c44:	10c00215 	stw	r3,8(r2)
81129c48:	21801b36 	bltu	r4,r6,81129cb8 <_realloc_r+0x300>
81129c4c:	008004c4 	movi	r2,19
81129c50:	1180352e 	bgeu	r2,r6,81129d28 <_realloc_r+0x370>
81129c54:	a8800017 	ldw	r2,0(r21)
81129c58:	b0800215 	stw	r2,8(r22)
81129c5c:	a8800117 	ldw	r2,4(r21)
81129c60:	b0800315 	stw	r2,12(r22)
81129c64:	008006c4 	movi	r2,27
81129c68:	11807f36 	bltu	r2,r6,81129e68 <_realloc_r+0x4b0>
81129c6c:	b0800404 	addi	r2,r22,16
81129c70:	ad400204 	addi	r21,r21,8
81129c74:	00002d06 	br	81129d2c <_realloc_r+0x374>
81129c78:	adbffe17 	ldw	r22,-8(r21)
81129c7c:	00bfff04 	movi	r2,-4
81129c80:	9dadc83a 	sub	r22,r19,r22
81129c84:	b1000117 	ldw	r4,4(r22)
81129c88:	2084703a 	and	r2,r4,r2
81129c8c:	b03f7726 	beq	r22,zero,81129a6c <__reset+0xfb109a6c>
81129c90:	80af883a 	add	r23,r16,r2
81129c94:	b8ff7516 	blt	r23,r3,81129a6c <__reset+0xfb109a6c>
81129c98:	b0800317 	ldw	r2,12(r22)
81129c9c:	b0c00217 	ldw	r3,8(r22)
81129ca0:	81bfff04 	addi	r6,r16,-4
81129ca4:	01000904 	movi	r4,36
81129ca8:	18800315 	stw	r2,12(r3)
81129cac:	10c00215 	stw	r3,8(r2)
81129cb0:	b4800204 	addi	r18,r22,8
81129cb4:	21bfe52e 	bgeu	r4,r6,81129c4c <__reset+0xfb109c4c>
81129cb8:	a80b883a 	mov	r5,r21
81129cbc:	9009883a 	mov	r4,r18
81129cc0:	11287980 	call	81128798 <memmove>
81129cc4:	b821883a 	mov	r16,r23
81129cc8:	b027883a 	mov	r19,r22
81129ccc:	003f8a06 	br	81129af8 <__reset+0xfb109af8>
81129cd0:	300b883a 	mov	r5,r6
81129cd4:	dfc00917 	ldw	ra,36(sp)
81129cd8:	df000817 	ldw	fp,32(sp)
81129cdc:	ddc00717 	ldw	r23,28(sp)
81129ce0:	dd800617 	ldw	r22,24(sp)
81129ce4:	dd400517 	ldw	r21,20(sp)
81129ce8:	dd000417 	ldw	r20,16(sp)
81129cec:	dcc00317 	ldw	r19,12(sp)
81129cf0:	dc800217 	ldw	r18,8(sp)
81129cf4:	dc400117 	ldw	r17,4(sp)
81129cf8:	dc000017 	ldw	r16,0(sp)
81129cfc:	dec00a04 	addi	sp,sp,40
81129d00:	111deb01 	jmpi	8111deb0 <_malloc_r>
81129d04:	a8c00017 	ldw	r3,0(r21)
81129d08:	90c00015 	stw	r3,0(r18)
81129d0c:	a8c00117 	ldw	r3,4(r21)
81129d10:	90c00115 	stw	r3,4(r18)
81129d14:	00c006c4 	movi	r3,27
81129d18:	19804536 	bltu	r3,r6,81129e30 <_realloc_r+0x478>
81129d1c:	90800204 	addi	r2,r18,8
81129d20:	a8c00204 	addi	r3,r21,8
81129d24:	003f6306 	br	81129ab4 <__reset+0xfb109ab4>
81129d28:	9005883a 	mov	r2,r18
81129d2c:	a8c00017 	ldw	r3,0(r21)
81129d30:	b821883a 	mov	r16,r23
81129d34:	b027883a 	mov	r19,r22
81129d38:	10c00015 	stw	r3,0(r2)
81129d3c:	a8c00117 	ldw	r3,4(r21)
81129d40:	10c00115 	stw	r3,4(r2)
81129d44:	a8c00217 	ldw	r3,8(r21)
81129d48:	10c00215 	stw	r3,8(r2)
81129d4c:	003f6a06 	br	81129af8 <__reset+0xfb109af8>
81129d50:	9c67883a 	add	r19,r19,r17
81129d54:	4445c83a 	sub	r2,r8,r17
81129d58:	e4c00215 	stw	r19,8(fp)
81129d5c:	10800054 	ori	r2,r2,1
81129d60:	98800115 	stw	r2,4(r19)
81129d64:	a8bfff17 	ldw	r2,-4(r21)
81129d68:	a009883a 	mov	r4,r20
81129d6c:	1080004c 	andi	r2,r2,1
81129d70:	1462b03a 	or	r17,r2,r17
81129d74:	ac7fff15 	stw	r17,-4(r21)
81129d78:	1134dd40 	call	81134dd4 <__malloc_unlock>
81129d7c:	a805883a 	mov	r2,r21
81129d80:	003f6b06 	br	81129b30 <__reset+0xfb109b30>
81129d84:	a80b883a 	mov	r5,r21
81129d88:	9009883a 	mov	r4,r18
81129d8c:	11287980 	call	81128798 <memmove>
81129d90:	003f4e06 	br	81129acc <__reset+0xfb109acc>
81129d94:	89000404 	addi	r4,r17,16
81129d98:	b93fbc16 	blt	r23,r4,81129c8c <__reset+0xfb109c8c>
81129d9c:	b0800317 	ldw	r2,12(r22)
81129da0:	b0c00217 	ldw	r3,8(r22)
81129da4:	81bfff04 	addi	r6,r16,-4
81129da8:	01000904 	movi	r4,36
81129dac:	18800315 	stw	r2,12(r3)
81129db0:	10c00215 	stw	r3,8(r2)
81129db4:	b4800204 	addi	r18,r22,8
81129db8:	21804336 	bltu	r4,r6,81129ec8 <_realloc_r+0x510>
81129dbc:	008004c4 	movi	r2,19
81129dc0:	11803f2e 	bgeu	r2,r6,81129ec0 <_realloc_r+0x508>
81129dc4:	a8800017 	ldw	r2,0(r21)
81129dc8:	b0800215 	stw	r2,8(r22)
81129dcc:	a8800117 	ldw	r2,4(r21)
81129dd0:	b0800315 	stw	r2,12(r22)
81129dd4:	008006c4 	movi	r2,27
81129dd8:	11803f36 	bltu	r2,r6,81129ed8 <_realloc_r+0x520>
81129ddc:	b0800404 	addi	r2,r22,16
81129de0:	ad400204 	addi	r21,r21,8
81129de4:	a8c00017 	ldw	r3,0(r21)
81129de8:	10c00015 	stw	r3,0(r2)
81129dec:	a8c00117 	ldw	r3,4(r21)
81129df0:	10c00115 	stw	r3,4(r2)
81129df4:	a8c00217 	ldw	r3,8(r21)
81129df8:	10c00215 	stw	r3,8(r2)
81129dfc:	b447883a 	add	r3,r22,r17
81129e00:	bc45c83a 	sub	r2,r23,r17
81129e04:	e0c00215 	stw	r3,8(fp)
81129e08:	10800054 	ori	r2,r2,1
81129e0c:	18800115 	stw	r2,4(r3)
81129e10:	b0800117 	ldw	r2,4(r22)
81129e14:	a009883a 	mov	r4,r20
81129e18:	1080004c 	andi	r2,r2,1
81129e1c:	1462b03a 	or	r17,r2,r17
81129e20:	b4400115 	stw	r17,4(r22)
81129e24:	1134dd40 	call	81134dd4 <__malloc_unlock>
81129e28:	9005883a 	mov	r2,r18
81129e2c:	003f4006 	br	81129b30 <__reset+0xfb109b30>
81129e30:	a8c00217 	ldw	r3,8(r21)
81129e34:	90c00215 	stw	r3,8(r18)
81129e38:	a8c00317 	ldw	r3,12(r21)
81129e3c:	90c00315 	stw	r3,12(r18)
81129e40:	30801126 	beq	r6,r2,81129e88 <_realloc_r+0x4d0>
81129e44:	90800404 	addi	r2,r18,16
81129e48:	a8c00404 	addi	r3,r21,16
81129e4c:	003f1906 	br	81129ab4 <__reset+0xfb109ab4>
81129e50:	90ffff17 	ldw	r3,-4(r18)
81129e54:	00bfff04 	movi	r2,-4
81129e58:	a825883a 	mov	r18,r21
81129e5c:	1884703a 	and	r2,r3,r2
81129e60:	80a1883a 	add	r16,r16,r2
81129e64:	003f2406 	br	81129af8 <__reset+0xfb109af8>
81129e68:	a8800217 	ldw	r2,8(r21)
81129e6c:	b0800415 	stw	r2,16(r22)
81129e70:	a8800317 	ldw	r2,12(r21)
81129e74:	b0800515 	stw	r2,20(r22)
81129e78:	31000a26 	beq	r6,r4,81129ea4 <_realloc_r+0x4ec>
81129e7c:	b0800604 	addi	r2,r22,24
81129e80:	ad400404 	addi	r21,r21,16
81129e84:	003fa906 	br	81129d2c <__reset+0xfb109d2c>
81129e88:	a9000417 	ldw	r4,16(r21)
81129e8c:	90800604 	addi	r2,r18,24
81129e90:	a8c00604 	addi	r3,r21,24
81129e94:	91000415 	stw	r4,16(r18)
81129e98:	a9000517 	ldw	r4,20(r21)
81129e9c:	91000515 	stw	r4,20(r18)
81129ea0:	003f0406 	br	81129ab4 <__reset+0xfb109ab4>
81129ea4:	a8c00417 	ldw	r3,16(r21)
81129ea8:	ad400604 	addi	r21,r21,24
81129eac:	b0800804 	addi	r2,r22,32
81129eb0:	b0c00615 	stw	r3,24(r22)
81129eb4:	a8ffff17 	ldw	r3,-4(r21)
81129eb8:	b0c00715 	stw	r3,28(r22)
81129ebc:	003f9b06 	br	81129d2c <__reset+0xfb109d2c>
81129ec0:	9005883a 	mov	r2,r18
81129ec4:	003fc706 	br	81129de4 <__reset+0xfb109de4>
81129ec8:	a80b883a 	mov	r5,r21
81129ecc:	9009883a 	mov	r4,r18
81129ed0:	11287980 	call	81128798 <memmove>
81129ed4:	003fc906 	br	81129dfc <__reset+0xfb109dfc>
81129ed8:	a8800217 	ldw	r2,8(r21)
81129edc:	b0800415 	stw	r2,16(r22)
81129ee0:	a8800317 	ldw	r2,12(r21)
81129ee4:	b0800515 	stw	r2,20(r22)
81129ee8:	31000726 	beq	r6,r4,81129f08 <_realloc_r+0x550>
81129eec:	b0800604 	addi	r2,r22,24
81129ef0:	ad400404 	addi	r21,r21,16
81129ef4:	003fbb06 	br	81129de4 <__reset+0xfb109de4>
81129ef8:	a009883a 	mov	r4,r20
81129efc:	1134dd40 	call	81134dd4 <__malloc_unlock>
81129f00:	0005883a 	mov	r2,zero
81129f04:	003f0a06 	br	81129b30 <__reset+0xfb109b30>
81129f08:	a8c00417 	ldw	r3,16(r21)
81129f0c:	ad400604 	addi	r21,r21,24
81129f10:	b0800804 	addi	r2,r22,32
81129f14:	b0c00615 	stw	r3,24(r22)
81129f18:	a8ffff17 	ldw	r3,-4(r21)
81129f1c:	b0c00715 	stw	r3,28(r22)
81129f20:	003fb006 	br	81129de4 <__reset+0xfb109de4>

81129f24 <__fpclassifyd>:
81129f24:	00a00034 	movhi	r2,32768
81129f28:	10bfffc4 	addi	r2,r2,-1
81129f2c:	2884703a 	and	r2,r5,r2
81129f30:	10000726 	beq	r2,zero,81129f50 <__fpclassifyd+0x2c>
81129f34:	00fffc34 	movhi	r3,65520
81129f38:	019ff834 	movhi	r6,32736
81129f3c:	28c7883a 	add	r3,r5,r3
81129f40:	31bfffc4 	addi	r6,r6,-1
81129f44:	30c00536 	bltu	r6,r3,81129f5c <__fpclassifyd+0x38>
81129f48:	00800104 	movi	r2,4
81129f4c:	f800283a 	ret
81129f50:	2000021e 	bne	r4,zero,81129f5c <__fpclassifyd+0x38>
81129f54:	00800084 	movi	r2,2
81129f58:	f800283a 	ret
81129f5c:	00dffc34 	movhi	r3,32752
81129f60:	019ff834 	movhi	r6,32736
81129f64:	28cb883a 	add	r5,r5,r3
81129f68:	31bfffc4 	addi	r6,r6,-1
81129f6c:	317ff62e 	bgeu	r6,r5,81129f48 <__reset+0xfb109f48>
81129f70:	01400434 	movhi	r5,16
81129f74:	297fffc4 	addi	r5,r5,-1
81129f78:	28800236 	bltu	r5,r2,81129f84 <__fpclassifyd+0x60>
81129f7c:	008000c4 	movi	r2,3
81129f80:	f800283a 	ret
81129f84:	10c00226 	beq	r2,r3,81129f90 <__fpclassifyd+0x6c>
81129f88:	0005883a 	mov	r2,zero
81129f8c:	f800283a 	ret
81129f90:	2005003a 	cmpeq	r2,r4,zero
81129f94:	f800283a 	ret

81129f98 <__sccl>:
81129f98:	2a000003 	ldbu	r8,0(r5)
81129f9c:	00801784 	movi	r2,94
81129fa0:	40802a26 	beq	r8,r2,8112a04c <__sccl+0xb4>
81129fa4:	29400044 	addi	r5,r5,1
81129fa8:	000f883a 	mov	r7,zero
81129fac:	0013883a 	mov	r9,zero
81129fb0:	2007883a 	mov	r3,r4
81129fb4:	21804004 	addi	r6,r4,256
81129fb8:	19c00005 	stb	r7,0(r3)
81129fbc:	18c00044 	addi	r3,r3,1
81129fc0:	19bffd1e 	bne	r3,r6,81129fb8 <__reset+0xfb109fb8>
81129fc4:	40001126 	beq	r8,zero,8112a00c <__sccl+0x74>
81129fc8:	00800044 	movi	r2,1
81129fcc:	124fc83a 	sub	r7,r2,r9
81129fd0:	02800b44 	movi	r10,45
81129fd4:	02c01744 	movi	r11,93
81129fd8:	2205883a 	add	r2,r4,r8
81129fdc:	11c00005 	stb	r7,0(r2)
81129fe0:	28800044 	addi	r2,r5,1
81129fe4:	28c00003 	ldbu	r3,0(r5)
81129fe8:	1a800a26 	beq	r3,r10,8112a014 <__sccl+0x7c>
81129fec:	1ac00426 	beq	r3,r11,8112a000 <__sccl+0x68>
81129ff0:	18000426 	beq	r3,zero,8112a004 <__sccl+0x6c>
81129ff4:	1811883a 	mov	r8,r3
81129ff8:	100b883a 	mov	r5,r2
81129ffc:	003ff606 	br	81129fd8 <__reset+0xfb109fd8>
8112a000:	f800283a 	ret
8112a004:	2805883a 	mov	r2,r5
8112a008:	f800283a 	ret
8112a00c:	28bfffc4 	addi	r2,r5,-1
8112a010:	f800283a 	ret
8112a014:	12400003 	ldbu	r9,0(r2)
8112a018:	4ac01126 	beq	r9,r11,8112a060 <__sccl+0xc8>
8112a01c:	4a001016 	blt	r9,r8,8112a060 <__sccl+0xc8>
8112a020:	41800044 	addi	r6,r8,1
8112a024:	29400084 	addi	r5,r5,2
8112a028:	2187883a 	add	r3,r4,r6
8112a02c:	00000106 	br	8112a034 <__sccl+0x9c>
8112a030:	31800044 	addi	r6,r6,1
8112a034:	19c00005 	stb	r7,0(r3)
8112a038:	3011883a 	mov	r8,r6
8112a03c:	18c00044 	addi	r3,r3,1
8112a040:	327ffb16 	blt	r6,r9,8112a030 <__reset+0xfb10a030>
8112a044:	10800084 	addi	r2,r2,2
8112a048:	003fe606 	br	81129fe4 <__reset+0xfb109fe4>
8112a04c:	2a000043 	ldbu	r8,1(r5)
8112a050:	01c00044 	movi	r7,1
8112a054:	29400084 	addi	r5,r5,2
8112a058:	02400044 	movi	r9,1
8112a05c:	003fd406 	br	81129fb0 <__reset+0xfb109fb0>
8112a060:	5011883a 	mov	r8,r10
8112a064:	003fe406 	br	81129ff8 <__reset+0xfb109ff8>

8112a068 <nanf>:
8112a068:	009ff034 	movhi	r2,32704
8112a06c:	f800283a 	ret

8112a070 <strcmp>:
8112a070:	2144b03a 	or	r2,r4,r5
8112a074:	108000cc 	andi	r2,r2,3
8112a078:	1000171e 	bne	r2,zero,8112a0d8 <strcmp+0x68>
8112a07c:	20800017 	ldw	r2,0(r4)
8112a080:	28c00017 	ldw	r3,0(r5)
8112a084:	10c0141e 	bne	r2,r3,8112a0d8 <strcmp+0x68>
8112a088:	027fbff4 	movhi	r9,65279
8112a08c:	4a7fbfc4 	addi	r9,r9,-257
8112a090:	0086303a 	nor	r3,zero,r2
8112a094:	02202074 	movhi	r8,32897
8112a098:	1245883a 	add	r2,r2,r9
8112a09c:	42202004 	addi	r8,r8,-32640
8112a0a0:	10c4703a 	and	r2,r2,r3
8112a0a4:	1204703a 	and	r2,r2,r8
8112a0a8:	10000226 	beq	r2,zero,8112a0b4 <strcmp+0x44>
8112a0ac:	00002306 	br	8112a13c <strcmp+0xcc>
8112a0b0:	1000221e 	bne	r2,zero,8112a13c <strcmp+0xcc>
8112a0b4:	21000104 	addi	r4,r4,4
8112a0b8:	20c00017 	ldw	r3,0(r4)
8112a0bc:	29400104 	addi	r5,r5,4
8112a0c0:	29800017 	ldw	r6,0(r5)
8112a0c4:	1a4f883a 	add	r7,r3,r9
8112a0c8:	00c4303a 	nor	r2,zero,r3
8112a0cc:	3884703a 	and	r2,r7,r2
8112a0d0:	1204703a 	and	r2,r2,r8
8112a0d4:	19bff626 	beq	r3,r6,8112a0b0 <__reset+0xfb10a0b0>
8112a0d8:	20800003 	ldbu	r2,0(r4)
8112a0dc:	10c03fcc 	andi	r3,r2,255
8112a0e0:	18c0201c 	xori	r3,r3,128
8112a0e4:	18ffe004 	addi	r3,r3,-128
8112a0e8:	18000c26 	beq	r3,zero,8112a11c <strcmp+0xac>
8112a0ec:	29800007 	ldb	r6,0(r5)
8112a0f0:	19800326 	beq	r3,r6,8112a100 <strcmp+0x90>
8112a0f4:	00001306 	br	8112a144 <strcmp+0xd4>
8112a0f8:	29800007 	ldb	r6,0(r5)
8112a0fc:	11800b1e 	bne	r2,r6,8112a12c <strcmp+0xbc>
8112a100:	21000044 	addi	r4,r4,1
8112a104:	20c00003 	ldbu	r3,0(r4)
8112a108:	29400044 	addi	r5,r5,1
8112a10c:	18803fcc 	andi	r2,r3,255
8112a110:	1080201c 	xori	r2,r2,128
8112a114:	10bfe004 	addi	r2,r2,-128
8112a118:	103ff71e 	bne	r2,zero,8112a0f8 <__reset+0xfb10a0f8>
8112a11c:	0007883a 	mov	r3,zero
8112a120:	28800003 	ldbu	r2,0(r5)
8112a124:	1885c83a 	sub	r2,r3,r2
8112a128:	f800283a 	ret
8112a12c:	28800003 	ldbu	r2,0(r5)
8112a130:	18c03fcc 	andi	r3,r3,255
8112a134:	1885c83a 	sub	r2,r3,r2
8112a138:	f800283a 	ret
8112a13c:	0005883a 	mov	r2,zero
8112a140:	f800283a 	ret
8112a144:	10c03fcc 	andi	r3,r2,255
8112a148:	003ff506 	br	8112a120 <__reset+0xfb10a120>

8112a14c <sulp>:
8112a14c:	defffd04 	addi	sp,sp,-12
8112a150:	de00012e 	bgeu	sp,et,8112a158 <sulp+0xc>
8112a154:	003b68fa 	trap	3
8112a158:	dc400115 	stw	r17,4(sp)
8112a15c:	3023883a 	mov	r17,r6
8112a160:	dc000015 	stw	r16,0(sp)
8112a164:	dfc00215 	stw	ra,8(sp)
8112a168:	2821883a 	mov	r16,r5
8112a16c:	11294580 	call	81129458 <__ulp>
8112a170:	88000c26 	beq	r17,zero,8112a1a4 <sulp+0x58>
8112a174:	841ffc2c 	andhi	r16,r16,32752
8112a178:	8020d53a 	srli	r16,r16,20
8112a17c:	01c01ac4 	movi	r7,107
8112a180:	3c21c83a 	sub	r16,r7,r16
8112a184:	0400070e 	bge	zero,r16,8112a1a4 <sulp+0x58>
8112a188:	8020953a 	slli	r16,r16,20
8112a18c:	01cffc34 	movhi	r7,16368
8112a190:	000d883a 	mov	r6,zero
8112a194:	81cf883a 	add	r7,r16,r7
8112a198:	1009883a 	mov	r4,r2
8112a19c:	180b883a 	mov	r5,r3
8112a1a0:	111ca740 	call	8111ca74 <__muldf3>
8112a1a4:	dfc00217 	ldw	ra,8(sp)
8112a1a8:	dc400117 	ldw	r17,4(sp)
8112a1ac:	dc000017 	ldw	r16,0(sp)
8112a1b0:	dec00304 	addi	sp,sp,12
8112a1b4:	f800283a 	ret

8112a1b8 <_strtod_r>:
8112a1b8:	deffe204 	addi	sp,sp,-120
8112a1bc:	de00012e 	bgeu	sp,et,8112a1c4 <_strtod_r+0xc>
8112a1c0:	003b68fa 	trap	3
8112a1c4:	ddc01b15 	stw	r23,108(sp)
8112a1c8:	dd001815 	stw	r20,96(sp)
8112a1cc:	dc801615 	stw	r18,88(sp)
8112a1d0:	dc401515 	stw	r17,84(sp)
8112a1d4:	dc001415 	stw	r16,80(sp)
8112a1d8:	d9400615 	stw	r5,24(sp)
8112a1dc:	dfc01d15 	stw	ra,116(sp)
8112a1e0:	df001c15 	stw	fp,112(sp)
8112a1e4:	dd801a15 	stw	r22,104(sp)
8112a1e8:	dd401915 	stw	r21,100(sp)
8112a1ec:	dcc01715 	stw	r19,92(sp)
8112a1f0:	2021883a 	mov	r16,r4
8112a1f4:	d8000515 	stw	zero,20(sp)
8112a1f8:	2809883a 	mov	r4,r5
8112a1fc:	20800003 	ldbu	r2,0(r4)
8112a200:	01e044f4 	movhi	r7,33043
8112a204:	282f883a 	mov	r23,r5
8112a208:	10c03fcc 	andi	r3,r2,255
8112a20c:	01400b44 	movi	r5,45
8112a210:	39e88d04 	addi	r7,r7,-24012
8112a214:	3029883a 	mov	r20,r6
8112a218:	0025883a 	mov	r18,zero
8112a21c:	0023883a 	mov	r17,zero
8112a220:	28c0ba36 	bltu	r5,r3,8112a50c <_strtod_r+0x354>
8112a224:	180690ba 	slli	r3,r3,2
8112a228:	19c7883a 	add	r3,r3,r7
8112a22c:	18c00017 	ldw	r3,0(r3)
8112a230:	1800683a 	jmp	r3
8112a234:	8112a2f4 	orhi	r4,r16,19083
8112a238:	8112a50c 	andi	r4,r16,19092
8112a23c:	8112a50c 	andi	r4,r16,19092
8112a240:	8112a50c 	andi	r4,r16,19092
8112a244:	8112a50c 	andi	r4,r16,19092
8112a248:	8112a50c 	andi	r4,r16,19092
8112a24c:	8112a50c 	andi	r4,r16,19092
8112a250:	8112a50c 	andi	r4,r16,19092
8112a254:	8112a50c 	andi	r4,r16,19092
8112a258:	8112a4f8 	rdprs	r4,r16,19091
8112a25c:	8112a4f8 	rdprs	r4,r16,19091
8112a260:	8112a4f8 	rdprs	r4,r16,19091
8112a264:	8112a4f8 	rdprs	r4,r16,19091
8112a268:	8112a4f8 	rdprs	r4,r16,19091
8112a26c:	8112a50c 	andi	r4,r16,19092
8112a270:	8112a50c 	andi	r4,r16,19092
8112a274:	8112a50c 	andi	r4,r16,19092
8112a278:	8112a50c 	andi	r4,r16,19092
8112a27c:	8112a50c 	andi	r4,r16,19092
8112a280:	8112a50c 	andi	r4,r16,19092
8112a284:	8112a50c 	andi	r4,r16,19092
8112a288:	8112a50c 	andi	r4,r16,19092
8112a28c:	8112a50c 	andi	r4,r16,19092
8112a290:	8112a50c 	andi	r4,r16,19092
8112a294:	8112a50c 	andi	r4,r16,19092
8112a298:	8112a50c 	andi	r4,r16,19092
8112a29c:	8112a50c 	andi	r4,r16,19092
8112a2a0:	8112a50c 	andi	r4,r16,19092
8112a2a4:	8112a50c 	andi	r4,r16,19092
8112a2a8:	8112a50c 	andi	r4,r16,19092
8112a2ac:	8112a50c 	andi	r4,r16,19092
8112a2b0:	8112a50c 	andi	r4,r16,19092
8112a2b4:	8112a4f8 	rdprs	r4,r16,19091
8112a2b8:	8112a50c 	andi	r4,r16,19092
8112a2bc:	8112a50c 	andi	r4,r16,19092
8112a2c0:	8112a50c 	andi	r4,r16,19092
8112a2c4:	8112a50c 	andi	r4,r16,19092
8112a2c8:	8112a50c 	andi	r4,r16,19092
8112a2cc:	8112a50c 	andi	r4,r16,19092
8112a2d0:	8112a50c 	andi	r4,r16,19092
8112a2d4:	8112a50c 	andi	r4,r16,19092
8112a2d8:	8112a50c 	andi	r4,r16,19092
8112a2dc:	8112a50c 	andi	r4,r16,19092
8112a2e0:	8112a34c 	andi	r4,r16,19085
8112a2e4:	8112a50c 	andi	r4,r16,19092
8112a2e8:	8112a4ec 	andhi	r4,r16,19091
8112a2ec:	00801244 	movi	r2,73
8112a2f0:	88843526 	beq	r17,r2,8112b3c8 <_strtod_r+0x1210>
8112a2f4:	002b883a 	mov	r21,zero
8112a2f8:	002d883a 	mov	r22,zero
8112a2fc:	a0000526 	beq	r20,zero,8112a314 <_strtod_r+0x15c>
8112a300:	d8000715 	stw	zero,28(sp)
8112a304:	a5c00015 	stw	r23,0(r20)
8112a308:	d9000717 	ldw	r4,28(sp)
8112a30c:	20000126 	beq	r4,zero,8112a314 <_strtod_r+0x15c>
8112a310:	b5a0003c 	xorhi	r22,r22,32768
8112a314:	a805883a 	mov	r2,r21
8112a318:	b007883a 	mov	r3,r22
8112a31c:	dfc01d17 	ldw	ra,116(sp)
8112a320:	df001c17 	ldw	fp,112(sp)
8112a324:	ddc01b17 	ldw	r23,108(sp)
8112a328:	dd801a17 	ldw	r22,104(sp)
8112a32c:	dd401917 	ldw	r21,100(sp)
8112a330:	dd001817 	ldw	r20,96(sp)
8112a334:	dcc01717 	ldw	r19,92(sp)
8112a338:	dc801617 	ldw	r18,88(sp)
8112a33c:	dc401517 	ldw	r17,84(sp)
8112a340:	dc001417 	ldw	r16,80(sp)
8112a344:	dec01e04 	addi	sp,sp,120
8112a348:	f800283a 	ret
8112a34c:	d8000715 	stw	zero,28(sp)
8112a350:	24c00044 	addi	r19,r4,1
8112a354:	dcc00615 	stw	r19,24(sp)
8112a358:	20800043 	ldbu	r2,1(r4)
8112a35c:	10c03fcc 	andi	r3,r2,255
8112a360:	18c0201c 	xori	r3,r3,128
8112a364:	18ffe004 	addi	r3,r3,-128
8112a368:	183fe226 	beq	r3,zero,8112a2f4 <__reset+0xfb10a2f4>
8112a36c:	11403fcc 	andi	r5,r2,255
8112a370:	2940201c 	xori	r5,r5,128
8112a374:	297fe004 	addi	r5,r5,-128
8112a378:	00c00c04 	movi	r3,48
8112a37c:	28c0e526 	beq	r5,r3,8112a714 <_strtod_r+0x55c>
8112a380:	dcc00815 	stw	r19,32(sp)
8112a384:	0025883a 	mov	r18,zero
8112a388:	10fff404 	addi	r3,r2,-48
8112a38c:	18c03fcc 	andi	r3,r3,255
8112a390:	01000244 	movi	r4,9
8112a394:	20c37536 	bltu	r4,r3,8112b16c <_strtod_r+0xfb4>
8112a398:	dd400817 	ldw	r21,32(sp)
8112a39c:	0027883a 	mov	r19,zero
8112a3a0:	0039883a 	mov	fp,zero
8112a3a4:	002d883a 	mov	r22,zero
8112a3a8:	01400204 	movi	r5,8
8112a3ac:	2d805a16 	blt	r5,r22,8112a518 <_strtod_r+0x360>
8112a3b0:	e70002a4 	muli	fp,fp,10
8112a3b4:	10c03fcc 	andi	r3,r2,255
8112a3b8:	18c0201c 	xori	r3,r3,128
8112a3bc:	18ffe004 	addi	r3,r3,-128
8112a3c0:	e0f9883a 	add	fp,fp,r3
8112a3c4:	e73ff404 	addi	fp,fp,-48
8112a3c8:	ad400044 	addi	r21,r21,1
8112a3cc:	dd400615 	stw	r21,24(sp)
8112a3d0:	a8800003 	ldbu	r2,0(r21)
8112a3d4:	b5800044 	addi	r22,r22,1
8112a3d8:	10fff404 	addi	r3,r2,-48
8112a3dc:	18c03fcc 	andi	r3,r3,255
8112a3e0:	20fff22e 	bgeu	r4,r3,8112a3ac <__reset+0xfb10a3ac>
8112a3e4:	14403fcc 	andi	r17,r2,255
8112a3e8:	8c40201c 	xori	r17,r17,128
8112a3ec:	8c7fe004 	addi	r17,r17,-128
8112a3f0:	8009883a 	mov	r4,r16
8112a3f4:	11283d80 	call	811283d8 <_localeconv_r>
8112a3f8:	11400017 	ldw	r5,0(r2)
8112a3fc:	8009883a 	mov	r4,r16
8112a400:	d9401315 	stw	r5,76(sp)
8112a404:	11283d80 	call	811283d8 <_localeconv_r>
8112a408:	11000017 	ldw	r4,0(r2)
8112a40c:	111f1b80 	call	8111f1b8 <strlen>
8112a410:	d9401317 	ldw	r5,76(sp)
8112a414:	100d883a 	mov	r6,r2
8112a418:	a809883a 	mov	r4,r21
8112a41c:	112fda80 	call	8112fda8 <strncmp>
8112a420:	1000ce26 	beq	r2,zero,8112a75c <_strtod_r+0x5a4>
8112a424:	b013883a 	mov	r9,r22
8112a428:	000b883a 	mov	r5,zero
8112a42c:	0015883a 	mov	r10,zero
8112a430:	0017883a 	mov	r11,zero
8112a434:	00801944 	movi	r2,101
8112a438:	88807826 	beq	r17,r2,8112a61c <_strtod_r+0x464>
8112a43c:	00801144 	movi	r2,69
8112a440:	88807626 	beq	r17,r2,8112a61c <_strtod_r+0x464>
8112a444:	002b883a 	mov	r21,zero
8112a448:	48003d1e 	bne	r9,zero,8112a540 <_strtod_r+0x388>
8112a44c:	2800391e 	bne	r5,zero,8112a534 <_strtod_r+0x37c>
8112a450:	9000381e 	bne	r18,zero,8112a534 <_strtod_r+0x37c>
8112a454:	583fa71e 	bne	r11,zero,8112a2f4 <__reset+0xfb10a2f4>
8112a458:	00801384 	movi	r2,78
8112a45c:	88800526 	beq	r17,r2,8112a474 <_strtod_r+0x2bc>
8112a460:	147fa20e 	bge	r2,r17,8112a2ec <__reset+0xfb10a2ec>
8112a464:	00801a44 	movi	r2,105
8112a468:	8883d726 	beq	r17,r2,8112b3c8 <_strtod_r+0x1210>
8112a46c:	00801b84 	movi	r2,110
8112a470:	88bfa01e 	bne	r17,r2,8112a2f4 <__reset+0xfb10a2f4>
8112a474:	01604574 	movhi	r5,33045
8112a478:	d9000617 	ldw	r4,24(sp)
8112a47c:	29740904 	addi	r5,r5,-12252
8112a480:	01c00644 	movi	r7,25
8112a484:	00000b06 	br	8112a4b4 <_strtod_r+0x2fc>
8112a488:	21000044 	addi	r4,r4,1
8112a48c:	20800003 	ldbu	r2,0(r4)
8112a490:	10ffefc4 	addi	r3,r2,-65
8112a494:	10803fcc 	andi	r2,r2,255
8112a498:	1080201c 	xori	r2,r2,128
8112a49c:	18c03fcc 	andi	r3,r3,255
8112a4a0:	10bfe004 	addi	r2,r2,-128
8112a4a4:	38c00136 	bltu	r7,r3,8112a4ac <_strtod_r+0x2f4>
8112a4a8:	10800804 	addi	r2,r2,32
8112a4ac:	29400044 	addi	r5,r5,1
8112a4b0:	11bf901e 	bne	r2,r6,8112a2f4 <__reset+0xfb10a2f4>
8112a4b4:	29800007 	ldb	r6,0(r5)
8112a4b8:	303ff31e 	bne	r6,zero,8112a488 <__reset+0xfb10a488>
8112a4bc:	20800044 	addi	r2,r4,1
8112a4c0:	d8800615 	stw	r2,24(sp)
8112a4c4:	20c00047 	ldb	r3,1(r4)
8112a4c8:	00800a04 	movi	r2,40
8112a4cc:	18849d26 	beq	r3,r2,8112b744 <_strtod_r+0x158c>
8112a4d0:	047ffe34 	movhi	r17,65528
8112a4d4:	0025883a 	mov	r18,zero
8112a4d8:	902b883a 	mov	r21,r18
8112a4dc:	882d883a 	mov	r22,r17
8112a4e0:	a03f8926 	beq	r20,zero,8112a308 <__reset+0xfb10a308>
8112a4e4:	ddc00617 	ldw	r23,24(sp)
8112a4e8:	003f8606 	br	8112a304 <__reset+0xfb10a304>
8112a4ec:	00800044 	movi	r2,1
8112a4f0:	d8800715 	stw	r2,28(sp)
8112a4f4:	003f9606 	br	8112a350 <__reset+0xfb10a350>
8112a4f8:	21000044 	addi	r4,r4,1
8112a4fc:	d9000615 	stw	r4,24(sp)
8112a500:	20800003 	ldbu	r2,0(r4)
8112a504:	10c03fcc 	andi	r3,r2,255
8112a508:	28ff462e 	bgeu	r5,r3,8112a224 <__reset+0xfb10a224>
8112a50c:	2027883a 	mov	r19,r4
8112a510:	d8000715 	stw	zero,28(sp)
8112a514:	003f9506 	br	8112a36c <__reset+0xfb10a36c>
8112a518:	9cc002a4 	muli	r19,r19,10
8112a51c:	10803fcc 	andi	r2,r2,255
8112a520:	1080201c 	xori	r2,r2,128
8112a524:	10bfe004 	addi	r2,r2,-128
8112a528:	9885883a 	add	r2,r19,r2
8112a52c:	14fff404 	addi	r19,r2,-48
8112a530:	003fa506 	br	8112a3c8 <__reset+0xfb10a3c8>
8112a534:	002b883a 	mov	r21,zero
8112a538:	002d883a 	mov	r22,zero
8112a53c:	003fe806 	br	8112a4e0 <__reset+0xfb10a4e0>
8112a540:	aaabc83a 	sub	r21,r21,r10
8112a544:	b000011e 	bne	r22,zero,8112a54c <_strtod_r+0x394>
8112a548:	482d883a 	mov	r22,r9
8112a54c:	00800404 	movi	r2,16
8112a550:	482f883a 	mov	r23,r9
8112a554:	1240010e 	bge	r2,r9,8112a55c <_strtod_r+0x3a4>
8112a558:	102f883a 	mov	r23,r2
8112a55c:	e009883a 	mov	r4,fp
8112a560:	da401315 	stw	r9,76(sp)
8112a564:	1132dc80 	call	81132dc8 <__floatunsidf>
8112a568:	1025883a 	mov	r18,r2
8112a56c:	00800244 	movi	r2,9
8112a570:	1823883a 	mov	r17,r3
8112a574:	da401317 	ldw	r9,76(sp)
8112a578:	15c0160e 	bge	r2,r23,8112a5d4 <_strtod_r+0x41c>
8112a57c:	b8bffdc4 	addi	r2,r23,-9
8112a580:	100490fa 	slli	r2,r2,3
8112a584:	180b883a 	mov	r5,r3
8112a588:	00e04574 	movhi	r3,33045
8112a58c:	18f3d404 	addi	r3,r3,-12464
8112a590:	1885883a 	add	r2,r3,r2
8112a594:	11800017 	ldw	r6,0(r2)
8112a598:	11c00117 	ldw	r7,4(r2)
8112a59c:	9009883a 	mov	r4,r18
8112a5a0:	111ca740 	call	8111ca74 <__muldf3>
8112a5a4:	9809883a 	mov	r4,r19
8112a5a8:	1025883a 	mov	r18,r2
8112a5ac:	1823883a 	mov	r17,r3
8112a5b0:	1132dc80 	call	81132dc8 <__floatunsidf>
8112a5b4:	9009883a 	mov	r4,r18
8112a5b8:	880b883a 	mov	r5,r17
8112a5bc:	100d883a 	mov	r6,r2
8112a5c0:	180f883a 	mov	r7,r3
8112a5c4:	1130f640 	call	81130f64 <__adddf3>
8112a5c8:	da401317 	ldw	r9,76(sp)
8112a5cc:	1025883a 	mov	r18,r2
8112a5d0:	1823883a 	mov	r17,r3
8112a5d4:	008003c4 	movi	r2,15
8112a5d8:	12407b16 	blt	r2,r9,8112a7c8 <_strtod_r+0x610>
8112a5dc:	a83fbe26 	beq	r21,zero,8112a4d8 <__reset+0xfb10a4d8>
8112a5e0:	0543670e 	bge	zero,r21,8112b380 <_strtod_r+0x11c8>
8112a5e4:	00c00584 	movi	r3,22
8112a5e8:	1d42e816 	blt	r3,r21,8112b18c <_strtod_r+0xfd4>
8112a5ec:	a82a90fa 	slli	r21,r21,3
8112a5f0:	00a04574 	movhi	r2,33045
8112a5f4:	10b3d404 	addi	r2,r2,-12464
8112a5f8:	1545883a 	add	r2,r2,r21
8112a5fc:	11000017 	ldw	r4,0(r2)
8112a600:	11400117 	ldw	r5,4(r2)
8112a604:	900d883a 	mov	r6,r18
8112a608:	880f883a 	mov	r7,r17
8112a60c:	111ca740 	call	8111ca74 <__muldf3>
8112a610:	102b883a 	mov	r21,r2
8112a614:	182d883a 	mov	r22,r3
8112a618:	003fb106 	br	8112a4e0 <__reset+0xfb10a4e0>
8112a61c:	4801b526 	beq	r9,zero,8112acf4 <_strtod_r+0xb3c>
8112a620:	ddc00617 	ldw	r23,24(sp)
8112a624:	00c00ac4 	movi	r3,43
8112a628:	b8800044 	addi	r2,r23,1
8112a62c:	d8800615 	stw	r2,24(sp)
8112a630:	b8800047 	ldb	r2,1(r23)
8112a634:	10c1e926 	beq	r2,r3,8112addc <_strtod_r+0xc24>
8112a638:	00c00b44 	movi	r3,45
8112a63c:	10c1ec26 	beq	r2,r3,8112adf0 <_strtod_r+0xc38>
8112a640:	1023883a 	mov	r17,r2
8112a644:	0019883a 	mov	r12,zero
8112a648:	88bff404 	addi	r2,r17,-48
8112a64c:	00c00244 	movi	r3,9
8112a650:	1881b736 	bltu	r3,r2,8112ad30 <_strtod_r+0xb78>
8112a654:	00800c04 	movi	r2,48
8112a658:	8880071e 	bne	r17,r2,8112a678 <_strtod_r+0x4c0>
8112a65c:	d8800617 	ldw	r2,24(sp)
8112a660:	8807883a 	mov	r3,r17
8112a664:	10800044 	addi	r2,r2,1
8112a668:	d8800615 	stw	r2,24(sp)
8112a66c:	14400007 	ldb	r17,0(r2)
8112a670:	10800044 	addi	r2,r2,1
8112a674:	88fffc26 	beq	r17,r3,8112a668 <__reset+0xfb10a668>
8112a678:	88bff3c4 	addi	r2,r17,-49
8112a67c:	00c00204 	movi	r3,8
8112a680:	18bf7036 	bltu	r3,r2,8112a444 <__reset+0xfb10a444>
8112a684:	db800617 	ldw	r14,24(sp)
8112a688:	88bff404 	addi	r2,r17,-48
8112a68c:	03400244 	movi	r13,9
8112a690:	71c00044 	addi	r7,r14,1
8112a694:	d9c00615 	stw	r7,24(sp)
8112a698:	74400043 	ldbu	r17,1(r14)
8112a69c:	88fff404 	addi	r3,r17,-48
8112a6a0:	8c403fcc 	andi	r17,r17,255
8112a6a4:	8c40201c 	xori	r17,r17,128
8112a6a8:	18c03fcc 	andi	r3,r3,255
8112a6ac:	8c7fe004 	addi	r17,r17,-128
8112a6b0:	68c00e36 	bltu	r13,r3,8112a6ec <_strtod_r+0x534>
8112a6b4:	71000084 	addi	r4,r14,2
8112a6b8:	d9000615 	stw	r4,24(sp)
8112a6bc:	108002a4 	muli	r2,r2,10
8112a6c0:	21800003 	ldbu	r6,0(r4)
8112a6c4:	200f883a 	mov	r7,r4
8112a6c8:	1463883a 	add	r17,r2,r17
8112a6cc:	30fff404 	addi	r3,r6,-48
8112a6d0:	88bff404 	addi	r2,r17,-48
8112a6d4:	34403fcc 	andi	r17,r6,255
8112a6d8:	8c40201c 	xori	r17,r17,128
8112a6dc:	18c03fcc 	andi	r3,r3,255
8112a6e0:	8c7fe004 	addi	r17,r17,-128
8112a6e4:	21000044 	addi	r4,r4,1
8112a6e8:	68fff32e 	bgeu	r13,r3,8112a6b8 <__reset+0xfb10a6b8>
8112a6ec:	3b8fc83a 	sub	r7,r7,r14
8112a6f0:	00c00204 	movi	r3,8
8112a6f4:	19c29716 	blt	r3,r7,8112b154 <_strtod_r+0xf9c>
8112a6f8:	102b883a 	mov	r21,r2
8112a6fc:	009387c4 	movi	r2,19999
8112a700:	1540010e 	bge	r2,r21,8112a708 <_strtod_r+0x550>
8112a704:	102b883a 	mov	r21,r2
8112a708:	603f4f26 	beq	r12,zero,8112a448 <__reset+0xfb10a448>
8112a70c:	056bc83a 	sub	r21,zero,r21
8112a710:	003f4d06 	br	8112a448 <__reset+0xfb10a448>
8112a714:	98800047 	ldb	r2,1(r19)
8112a718:	00c01604 	movi	r3,88
8112a71c:	10c1de26 	beq	r2,r3,8112ae98 <_strtod_r+0xce0>
8112a720:	00c01e04 	movi	r3,120
8112a724:	10c1dc26 	beq	r2,r3,8112ae98 <_strtod_r+0xce0>
8112a728:	98c00044 	addi	r3,r19,1
8112a72c:	1827883a 	mov	r19,r3
8112a730:	d8c00615 	stw	r3,24(sp)
8112a734:	18c00044 	addi	r3,r3,1
8112a738:	18bfffc3 	ldbu	r2,-1(r3)
8112a73c:	11003fcc 	andi	r4,r2,255
8112a740:	2100201c 	xori	r4,r4,128
8112a744:	213fe004 	addi	r4,r4,-128
8112a748:	217ff826 	beq	r4,r5,8112a72c <__reset+0xfb10a72c>
8112a74c:	203f7926 	beq	r4,zero,8112a534 <__reset+0xfb10a534>
8112a750:	dcc00815 	stw	r19,32(sp)
8112a754:	04800044 	movi	r18,1
8112a758:	003f0b06 	br	8112a388 <__reset+0xfb10a388>
8112a75c:	8009883a 	mov	r4,r16
8112a760:	11283d80 	call	811283d8 <_localeconv_r>
8112a764:	11000017 	ldw	r4,0(r2)
8112a768:	111f1b80 	call	8111f1b8 <strlen>
8112a76c:	d8c00617 	ldw	r3,24(sp)
8112a770:	1885883a 	add	r2,r3,r2
8112a774:	d8800615 	stw	r2,24(sp)
8112a778:	14400007 	ldb	r17,0(r2)
8112a77c:	b001881e 	bne	r22,zero,8112ada0 <_strtod_r+0xbe8>
8112a780:	00c00c04 	movi	r3,48
8112a784:	88c3391e 	bne	r17,r3,8112b46c <_strtod_r+0x12b4>
8112a788:	10c00044 	addi	r3,r2,1
8112a78c:	8809883a 	mov	r4,r17
8112a790:	d8c00615 	stw	r3,24(sp)
8112a794:	1c400007 	ldb	r17,0(r3)
8112a798:	188bc83a 	sub	r5,r3,r2
8112a79c:	18c00044 	addi	r3,r3,1
8112a7a0:	893ffb26 	beq	r17,r4,8112a790 <__reset+0xfb10a790>
8112a7a4:	88bff3c4 	addi	r2,r17,-49
8112a7a8:	00c00204 	movi	r3,8
8112a7ac:	1882e72e 	bgeu	r3,r2,8112b34c <_strtod_r+0x1194>
8112a7b0:	00801944 	movi	r2,101
8112a7b4:	88814d26 	beq	r17,r2,8112acec <_strtod_r+0xb34>
8112a7b8:	0013883a 	mov	r9,zero
8112a7bc:	0015883a 	mov	r10,zero
8112a7c0:	02c00044 	movi	r11,1
8112a7c4:	003f1d06 	br	8112a43c <__reset+0xfb10a43c>
8112a7c8:	4defc83a 	sub	r23,r9,r23
8112a7cc:	bd6f883a 	add	r23,r23,r21
8112a7d0:	05c21e0e 	bge	zero,r23,8112b04c <_strtod_r+0xe94>
8112a7d4:	b88003cc 	andi	r2,r23,15
8112a7d8:	10000d26 	beq	r2,zero,8112a810 <_strtod_r+0x658>
8112a7dc:	100490fa 	slli	r2,r2,3
8112a7e0:	00e04574 	movhi	r3,33045
8112a7e4:	18f3d404 	addi	r3,r3,-12464
8112a7e8:	1885883a 	add	r2,r3,r2
8112a7ec:	11000017 	ldw	r4,0(r2)
8112a7f0:	11400117 	ldw	r5,4(r2)
8112a7f4:	900d883a 	mov	r6,r18
8112a7f8:	880f883a 	mov	r7,r17
8112a7fc:	da401315 	stw	r9,76(sp)
8112a800:	111ca740 	call	8111ca74 <__muldf3>
8112a804:	da401317 	ldw	r9,76(sp)
8112a808:	1025883a 	mov	r18,r2
8112a80c:	1823883a 	mov	r17,r3
8112a810:	023ffc04 	movi	r8,-16
8112a814:	ba10703a 	and	r8,r23,r8
8112a818:	40003c26 	beq	r8,zero,8112a90c <_strtod_r+0x754>
8112a81c:	00804d04 	movi	r2,308
8112a820:	1201cd16 	blt	r2,r8,8112af58 <_strtod_r+0xda0>
8112a824:	4011d13a 	srai	r8,r8,4
8112a828:	03000044 	movi	r12,1
8112a82c:	62037c0e 	bge	r12,r8,8112b620 <_strtod_r+0x1468>
8112a830:	01204574 	movhi	r4,33045
8112a834:	2133ca04 	addi	r4,r4,-12504
8112a838:	2015883a 	mov	r10,r4
8112a83c:	0027883a 	mov	r19,zero
8112a840:	d9000915 	stw	r4,36(sp)
8112a844:	9005883a 	mov	r2,r18
8112a848:	8807883a 	mov	r3,r17
8112a84c:	dc000c15 	stw	r16,48(sp)
8112a850:	dc800e15 	stw	r18,56(sp)
8112a854:	9821883a 	mov	r16,r19
8112a858:	0009883a 	mov	r4,zero
8112a85c:	8827883a 	mov	r19,r17
8112a860:	602f883a 	mov	r23,r12
8112a864:	da400a15 	stw	r9,40(sp)
8112a868:	5025883a 	mov	r18,r10
8112a86c:	4023883a 	mov	r17,r8
8112a870:	8980004c 	andi	r6,r17,1
8112a874:	30000626 	beq	r6,zero,8112a890 <_strtod_r+0x6d8>
8112a878:	91800017 	ldw	r6,0(r18)
8112a87c:	91c00117 	ldw	r7,4(r18)
8112a880:	1009883a 	mov	r4,r2
8112a884:	180b883a 	mov	r5,r3
8112a888:	111ca740 	call	8111ca74 <__muldf3>
8112a88c:	01000044 	movi	r4,1
8112a890:	8823d07a 	srai	r17,r17,1
8112a894:	84000044 	addi	r16,r16,1
8112a898:	94800204 	addi	r18,r18,8
8112a89c:	8dfff41e 	bne	r17,r23,8112a870 <__reset+0xfb10a870>
8112a8a0:	21003fcc 	andi	r4,r4,255
8112a8a4:	9823883a 	mov	r17,r19
8112a8a8:	da400a17 	ldw	r9,40(sp)
8112a8ac:	8027883a 	mov	r19,r16
8112a8b0:	dc800e17 	ldw	r18,56(sp)
8112a8b4:	dc000c17 	ldw	r16,48(sp)
8112a8b8:	2003b11e 	bne	r4,zero,8112b780 <_strtod_r+0x15c8>
8112a8bc:	981690fa 	slli	r11,r19,3
8112a8c0:	d8800917 	ldw	r2,36(sp)
8112a8c4:	01ff2c34 	movhi	r7,64688
8112a8c8:	900d883a 	mov	r6,r18
8112a8cc:	12ef883a 	add	r23,r2,r11
8112a8d0:	b9000017 	ldw	r4,0(r23)
8112a8d4:	b9400117 	ldw	r5,4(r23)
8112a8d8:	89cf883a 	add	r7,r17,r7
8112a8dc:	da401315 	stw	r9,76(sp)
8112a8e0:	111ca740 	call	8111ca74 <__muldf3>
8112a8e4:	1025883a 	mov	r18,r2
8112a8e8:	011f2834 	movhi	r4,31904
8112a8ec:	189ffc2c 	andhi	r2,r3,32752
8112a8f0:	da401317 	ldw	r9,76(sp)
8112a8f4:	20819836 	bltu	r4,r2,8112af58 <_strtod_r+0xda0>
8112a8f8:	011f2434 	movhi	r4,31888
8112a8fc:	2083382e 	bgeu	r4,r2,8112b5e0 <_strtod_r+0x1428>
8112a900:	045ffc34 	movhi	r17,32752
8112a904:	8c7fffc4 	addi	r17,r17,-1
8112a908:	04bfffc4 	movi	r18,-1
8112a90c:	d8000915 	stw	zero,36(sp)
8112a910:	d9400817 	ldw	r5,32(sp)
8112a914:	df000015 	stw	fp,0(sp)
8112a918:	480f883a 	mov	r7,r9
8112a91c:	b00d883a 	mov	r6,r22
8112a920:	8009883a 	mov	r4,r16
8112a924:	1128af40 	call	81128af4 <__s2b>
8112a928:	d8800815 	stw	r2,32(sp)
8112a92c:	10018a26 	beq	r2,zero,8112af58 <_strtod_r+0xda0>
8112a930:	a807d7fa 	srai	r3,r21,31
8112a934:	0545c83a 	sub	r2,zero,r21
8112a938:	dd400a15 	stw	r21,40(sp)
8112a93c:	1886703a 	and	r3,r3,r2
8112a940:	d8c00c15 	stw	r3,48(sp)
8112a944:	a8013516 	blt	r21,zero,8112ae1c <_strtod_r+0xc64>
8112a948:	d9400817 	ldw	r5,32(sp)
8112a94c:	0011883a 	mov	r8,zero
8112a950:	0027883a 	mov	r19,zero
8112a954:	29400304 	addi	r5,r5,12
8112a958:	d9400f15 	stw	r5,60(sp)
8112a95c:	402b883a 	mov	r21,r8
8112a960:	dd001215 	stw	r20,72(sp)
8112a964:	d8800817 	ldw	r2,32(sp)
8112a968:	8009883a 	mov	r4,r16
8112a96c:	11400117 	ldw	r5,4(r2)
8112a970:	11288f40 	call	811288f4 <_Balloc>
8112a974:	1029883a 	mov	r20,r2
8112a978:	10012d26 	beq	r2,zero,8112ae30 <_strtod_r+0xc78>
8112a97c:	d8c00817 	ldw	r3,32(sp)
8112a980:	d9400f17 	ldw	r5,60(sp)
8112a984:	11000304 	addi	r4,r2,12
8112a988:	19800417 	ldw	r6,16(r3)
8112a98c:	31800084 	addi	r6,r6,2
8112a990:	318d883a 	add	r6,r6,r6
8112a994:	318d883a 	add	r6,r6,r6
8112a998:	111e6c40 	call	8111e6c4 <memcpy>
8112a99c:	d9000204 	addi	r4,sp,8
8112a9a0:	d9000015 	stw	r4,0(sp)
8112a9a4:	d9c00404 	addi	r7,sp,16
8112a9a8:	900b883a 	mov	r5,r18
8112a9ac:	880d883a 	mov	r6,r17
8112a9b0:	8009883a 	mov	r4,r16
8112a9b4:	11295d00 	call	811295d0 <__d2b>
8112a9b8:	d8800515 	stw	r2,20(sp)
8112a9bc:	dc801115 	stw	r18,68(sp)
8112a9c0:	dc401015 	stw	r17,64(sp)
8112a9c4:	10027c26 	beq	r2,zero,8112b3b8 <_strtod_r+0x1200>
8112a9c8:	01400044 	movi	r5,1
8112a9cc:	8009883a 	mov	r4,r16
8112a9d0:	1128d180 	call	81128d18 <__i2b>
8112a9d4:	1027883a 	mov	r19,r2
8112a9d8:	10011526 	beq	r2,zero,8112ae30 <_strtod_r+0xc78>
8112a9dc:	d8800417 	ldw	r2,16(sp)
8112a9e0:	1000c816 	blt	r2,zero,8112ad04 <_strtod_r+0xb4c>
8112a9e4:	d9400c17 	ldw	r5,48(sp)
8112a9e8:	d9000a17 	ldw	r4,40(sp)
8112a9ec:	28ad883a 	add	r22,r5,r2
8112a9f0:	d9400917 	ldw	r5,36(sp)
8112a9f4:	df000217 	ldw	fp,8(sp)
8112a9f8:	05ff0084 	movi	r23,-1022
8112a9fc:	1147c83a 	sub	r3,r2,r5
8112aa00:	1f07883a 	add	r3,r3,fp
8112aa04:	00800d84 	movi	r2,54
8112aa08:	18ffffc4 	addi	r3,r3,-1
8112aa0c:	1739c83a 	sub	fp,r2,fp
8112aa10:	1dc0a50e 	bge	r3,r23,8112aca8 <_strtod_r+0xaf0>
8112aa14:	b8efc83a 	sub	r23,r23,r3
8112aa18:	008007c4 	movi	r2,31
8112aa1c:	e5f9c83a 	sub	fp,fp,r23
8112aa20:	15c0bc16 	blt	r2,r23,8112ad14 <_strtod_r+0xb5c>
8112aa24:	00800044 	movi	r2,1
8112aa28:	15c4983a 	sll	r2,r2,r23
8112aa2c:	d8000b15 	stw	zero,44(sp)
8112aa30:	d8800d15 	stw	r2,52(sp)
8112aa34:	2707883a 	add	r3,r4,fp
8112aa38:	d9000917 	ldw	r4,36(sp)
8112aa3c:	b739883a 	add	fp,r22,fp
8112aa40:	20ef883a 	add	r23,r4,r3
8112aa44:	b009883a 	mov	r4,r22
8112aa48:	e580010e 	bge	fp,r22,8112aa50 <_strtod_r+0x898>
8112aa4c:	e009883a 	mov	r4,fp
8112aa50:	b805883a 	mov	r2,r23
8112aa54:	25c0010e 	bge	r4,r23,8112aa5c <_strtod_r+0x8a4>
8112aa58:	2005883a 	mov	r2,r4
8112aa5c:	0080030e 	bge	zero,r2,8112aa6c <_strtod_r+0x8b4>
8112aa60:	e0b9c83a 	sub	fp,fp,r2
8112aa64:	b8afc83a 	sub	r23,r23,r2
8112aa68:	b0adc83a 	sub	r22,r22,r2
8112aa6c:	d9400c17 	ldw	r5,48(sp)
8112aa70:	28001126 	beq	r5,zero,8112aab8 <_strtod_r+0x900>
8112aa74:	280d883a 	mov	r6,r5
8112aa78:	8009883a 	mov	r4,r16
8112aa7c:	980b883a 	mov	r5,r19
8112aa80:	1128f5c0 	call	81128f5c <__pow5mult>
8112aa84:	1027883a 	mov	r19,r2
8112aa88:	1000e926 	beq	r2,zero,8112ae30 <_strtod_r+0xc78>
8112aa8c:	d9800517 	ldw	r6,20(sp)
8112aa90:	100b883a 	mov	r5,r2
8112aa94:	8009883a 	mov	r4,r16
8112aa98:	1128d5c0 	call	81128d5c <__multiply>
8112aa9c:	1000e426 	beq	r2,zero,8112ae30 <_strtod_r+0xc78>
8112aaa0:	d9400517 	ldw	r5,20(sp)
8112aaa4:	8009883a 	mov	r4,r16
8112aaa8:	d8801315 	stw	r2,76(sp)
8112aaac:	11289a40 	call	811289a4 <_Bfree>
8112aab0:	d8801317 	ldw	r2,76(sp)
8112aab4:	d8800515 	stw	r2,20(sp)
8112aab8:	0700060e 	bge	zero,fp,8112aad4 <_strtod_r+0x91c>
8112aabc:	d9400517 	ldw	r5,20(sp)
8112aac0:	e00d883a 	mov	r6,fp
8112aac4:	8009883a 	mov	r4,r16
8112aac8:	11290a40 	call	811290a4 <__lshift>
8112aacc:	d8800515 	stw	r2,20(sp)
8112aad0:	10023926 	beq	r2,zero,8112b3b8 <_strtod_r+0x1200>
8112aad4:	d8800a17 	ldw	r2,40(sp)
8112aad8:	10000626 	beq	r2,zero,8112aaf4 <_strtod_r+0x93c>
8112aadc:	d9800a17 	ldw	r6,40(sp)
8112aae0:	a00b883a 	mov	r5,r20
8112aae4:	8009883a 	mov	r4,r16
8112aae8:	1128f5c0 	call	81128f5c <__pow5mult>
8112aaec:	1029883a 	mov	r20,r2
8112aaf0:	1000cf26 	beq	r2,zero,8112ae30 <_strtod_r+0xc78>
8112aaf4:	05c0060e 	bge	zero,r23,8112ab10 <_strtod_r+0x958>
8112aaf8:	a00b883a 	mov	r5,r20
8112aafc:	b80d883a 	mov	r6,r23
8112ab00:	8009883a 	mov	r4,r16
8112ab04:	11290a40 	call	811290a4 <__lshift>
8112ab08:	1029883a 	mov	r20,r2
8112ab0c:	1000c826 	beq	r2,zero,8112ae30 <_strtod_r+0xc78>
8112ab10:	0580060e 	bge	zero,r22,8112ab2c <_strtod_r+0x974>
8112ab14:	980b883a 	mov	r5,r19
8112ab18:	b00d883a 	mov	r6,r22
8112ab1c:	8009883a 	mov	r4,r16
8112ab20:	11290a40 	call	811290a4 <__lshift>
8112ab24:	1027883a 	mov	r19,r2
8112ab28:	1000c126 	beq	r2,zero,8112ae30 <_strtod_r+0xc78>
8112ab2c:	d9400517 	ldw	r5,20(sp)
8112ab30:	a00d883a 	mov	r6,r20
8112ab34:	8009883a 	mov	r4,r16
8112ab38:	11292540 	call	81129254 <__mdiff>
8112ab3c:	102b883a 	mov	r21,r2
8112ab40:	1000bb26 	beq	r2,zero,8112ae30 <_strtod_r+0xc78>
8112ab44:	10c00317 	ldw	r3,12(r2)
8112ab48:	980b883a 	mov	r5,r19
8112ab4c:	10000315 	stw	zero,12(r2)
8112ab50:	1009883a 	mov	r4,r2
8112ab54:	d8c00e15 	stw	r3,56(sp)
8112ab58:	11291f40 	call	811291f4 <__mcmp>
8112ab5c:	10027616 	blt	r2,zero,8112b538 <_strtod_r+0x1380>
8112ab60:	10024426 	beq	r2,zero,8112b474 <_strtod_r+0x12bc>
8112ab64:	980b883a 	mov	r5,r19
8112ab68:	a809883a 	mov	r4,r21
8112ab6c:	11297240 	call	81129724 <__ratio>
8112ab70:	000d883a 	mov	r6,zero
8112ab74:	01d00034 	movhi	r7,16384
8112ab78:	1009883a 	mov	r4,r2
8112ab7c:	180b883a 	mov	r5,r3
8112ab80:	102f883a 	mov	r23,r2
8112ab84:	182d883a 	mov	r22,r3
8112ab88:	113226c0 	call	8113226c <__ledf2>
8112ab8c:	00804a16 	blt	zero,r2,8112acb8 <_strtod_r+0xb00>
8112ab90:	d9400e17 	ldw	r5,56(sp)
8112ab94:	28006b26 	beq	r5,zero,8112ad44 <_strtod_r+0xb8c>
8112ab98:	058ffc34 	movhi	r22,16368
8112ab9c:	d8000b15 	stw	zero,44(sp)
8112aba0:	d8000d15 	stw	zero,52(sp)
8112aba4:	b02f883a 	mov	r23,r22
8112aba8:	8f1ffc2c 	andhi	fp,r17,32752
8112abac:	009ff834 	movhi	r2,32736
8112abb0:	e080cd26 	beq	fp,r2,8112aee8 <_strtod_r+0xd30>
8112abb4:	d9400917 	ldw	r5,36(sp)
8112abb8:	28001a26 	beq	r5,zero,8112ac24 <_strtod_r+0xa6c>
8112abbc:	0081a834 	movhi	r2,1696
8112abc0:	17001836 	bltu	r2,fp,8112ac24 <_strtod_r+0xa6c>
8112abc4:	d9000d17 	ldw	r4,52(sp)
8112abc8:	01d07834 	movhi	r7,16864
8112abcc:	39ffffc4 	addi	r7,r7,-1
8112abd0:	01bff034 	movhi	r6,65472
8112abd4:	b80b883a 	mov	r5,r23
8112abd8:	113226c0 	call	8113226c <__ledf2>
8112abdc:	00800e16 	blt	zero,r2,8112ac18 <_strtod_r+0xa60>
8112abe0:	d9000d17 	ldw	r4,52(sp)
8112abe4:	b80b883a 	mov	r5,r23
8112abe8:	11300780 	call	81130078 <__fixunsdfsi>
8112abec:	10018126 	beq	r2,zero,8112b1f4 <_strtod_r+0x103c>
8112abf0:	1009883a 	mov	r4,r2
8112abf4:	1132dc80 	call	81132dc8 <__floatunsidf>
8112abf8:	d8800d15 	stw	r2,52(sp)
8112abfc:	182f883a 	mov	r23,r3
8112ac00:	d8800e17 	ldw	r2,56(sp)
8112ac04:	1001791e 	bne	r2,zero,8112b1ec <_strtod_r+0x1034>
8112ac08:	ba20003c 	xorhi	r8,r23,32768
8112ac0c:	d8c00d17 	ldw	r3,52(sp)
8112ac10:	402d883a 	mov	r22,r8
8112ac14:	d8c00b15 	stw	r3,44(sp)
8112ac18:	0081ac34 	movhi	r2,1712
8112ac1c:	b091883a 	add	r8,r22,r2
8112ac20:	472dc83a 	sub	r22,r8,fp
8112ac24:	9009883a 	mov	r4,r18
8112ac28:	880b883a 	mov	r5,r17
8112ac2c:	11294580 	call	81129458 <__ulp>
8112ac30:	d9000b17 	ldw	r4,44(sp)
8112ac34:	b00b883a 	mov	r5,r22
8112ac38:	100d883a 	mov	r6,r2
8112ac3c:	180f883a 	mov	r7,r3
8112ac40:	111ca740 	call	8111ca74 <__muldf3>
8112ac44:	900d883a 	mov	r6,r18
8112ac48:	880f883a 	mov	r7,r17
8112ac4c:	1009883a 	mov	r4,r2
8112ac50:	180b883a 	mov	r5,r3
8112ac54:	1130f640 	call	81130f64 <__adddf3>
8112ac58:	1025883a 	mov	r18,r2
8112ac5c:	1823883a 	mov	r17,r3
8112ac60:	182d883a 	mov	r22,r3
8112ac64:	d9000917 	ldw	r4,36(sp)
8112ac68:	2000021e 	bne	r4,zero,8112ac74 <_strtod_r+0xabc>
8112ac6c:	b09ffc2c 	andhi	r2,r22,32752
8112ac70:	e080be26 	beq	fp,r2,8112af6c <_strtod_r+0xdb4>
8112ac74:	d9400517 	ldw	r5,20(sp)
8112ac78:	8009883a 	mov	r4,r16
8112ac7c:	11289a40 	call	811289a4 <_Bfree>
8112ac80:	a00b883a 	mov	r5,r20
8112ac84:	8009883a 	mov	r4,r16
8112ac88:	11289a40 	call	811289a4 <_Bfree>
8112ac8c:	980b883a 	mov	r5,r19
8112ac90:	8009883a 	mov	r4,r16
8112ac94:	11289a40 	call	811289a4 <_Bfree>
8112ac98:	a80b883a 	mov	r5,r21
8112ac9c:	8009883a 	mov	r4,r16
8112aca0:	11289a40 	call	811289a4 <_Bfree>
8112aca4:	003f2f06 	br	8112a964 <__reset+0xfb10a964>
8112aca8:	00c00044 	movi	r3,1
8112acac:	d8000b15 	stw	zero,44(sp)
8112acb0:	d8c00d15 	stw	r3,52(sp)
8112acb4:	003f5f06 	br	8112aa34 <__reset+0xfb10aa34>
8112acb8:	b809883a 	mov	r4,r23
8112acbc:	000d883a 	mov	r6,zero
8112acc0:	01cff834 	movhi	r7,16352
8112acc4:	b00b883a 	mov	r5,r22
8112acc8:	111ca740 	call	8111ca74 <__muldf3>
8112accc:	d9000e17 	ldw	r4,56(sp)
8112acd0:	d8800d15 	stw	r2,52(sp)
8112acd4:	182f883a 	mov	r23,r3
8112acd8:	2000181e 	bne	r4,zero,8112ad3c <_strtod_r+0xb84>
8112acdc:	1a20003c 	xorhi	r8,r3,32768
8112ace0:	d8800b15 	stw	r2,44(sp)
8112ace4:	402d883a 	mov	r22,r8
8112ace8:	003faf06 	br	8112aba8 <__reset+0xfb10aba8>
8112acec:	0015883a 	mov	r10,zero
8112acf0:	02c00044 	movi	r11,1
8112acf4:	2800011e 	bne	r5,zero,8112acfc <_strtod_r+0xb44>
8112acf8:	903d7e26 	beq	r18,zero,8112a2f4 <__reset+0xfb10a2f4>
8112acfc:	0013883a 	mov	r9,zero
8112ad00:	003e4706 	br	8112a620 <__reset+0xfb10a620>
8112ad04:	d8c00a17 	ldw	r3,40(sp)
8112ad08:	dd800c17 	ldw	r22,48(sp)
8112ad0c:	1889c83a 	sub	r4,r3,r2
8112ad10:	003f3706 	br	8112a9f0 <__reset+0xfb10a9f0>
8112ad14:	00bef884 	movi	r2,-1054
8112ad18:	05c00044 	movi	r23,1
8112ad1c:	10c5c83a 	sub	r2,r2,r3
8112ad20:	b884983a 	sll	r2,r23,r2
8112ad24:	ddc00d15 	stw	r23,52(sp)
8112ad28:	d8800b15 	stw	r2,44(sp)
8112ad2c:	003f4106 	br	8112aa34 <__reset+0xfb10aa34>
8112ad30:	ddc00615 	stw	r23,24(sp)
8112ad34:	002b883a 	mov	r21,zero
8112ad38:	003dc306 	br	8112a448 <__reset+0xfb10a448>
8112ad3c:	1811883a 	mov	r8,r3
8112ad40:	003fe706 	br	8112ace0 <__reset+0xfb10ace0>
8112ad44:	90002e1e 	bne	r18,zero,8112ae00 <_strtod_r+0xc48>
8112ad48:	00c00434 	movhi	r3,16
8112ad4c:	18ffffc4 	addi	r3,r3,-1
8112ad50:	88c4703a 	and	r2,r17,r3
8112ad54:	10002c1e 	bne	r2,zero,8112ae08 <_strtod_r+0xc50>
8112ad58:	000d883a 	mov	r6,zero
8112ad5c:	01cffc34 	movhi	r7,16368
8112ad60:	b809883a 	mov	r4,r23
8112ad64:	b00b883a 	mov	r5,r22
8112ad68:	113226c0 	call	8113226c <__ledf2>
8112ad6c:	10021716 	blt	r2,zero,8112b5cc <_strtod_r+0x1414>
8112ad70:	b809883a 	mov	r4,r23
8112ad74:	b00b883a 	mov	r5,r22
8112ad78:	000d883a 	mov	r6,zero
8112ad7c:	01cff834 	movhi	r7,16352
8112ad80:	111ca740 	call	8111ca74 <__muldf3>
8112ad84:	d8800d15 	stw	r2,52(sp)
8112ad88:	182f883a 	mov	r23,r3
8112ad8c:	102d883a 	mov	r22,r2
8112ad90:	1a20003c 	xorhi	r8,r3,32768
8112ad94:	dd800b15 	stw	r22,44(sp)
8112ad98:	402d883a 	mov	r22,r8
8112ad9c:	003f8206 	br	8112aba8 <__reset+0xfb10aba8>
8112ada0:	b013883a 	mov	r9,r22
8112ada4:	000b883a 	mov	r5,zero
8112ada8:	0015883a 	mov	r10,zero
8112adac:	893ff404 	addi	r4,r17,-48
8112adb0:	00800244 	movi	r2,9
8112adb4:	11001036 	bltu	r2,r4,8112adf8 <_strtod_r+0xc40>
8112adb8:	28c00044 	addi	r3,r5,1
8112adbc:	2023883a 	mov	r17,r4
8112adc0:	20014d1e 	bne	r4,zero,8112b2f8 <_strtod_r+0x1140>
8112adc4:	d9800617 	ldw	r6,24(sp)
8112adc8:	180b883a 	mov	r5,r3
8112adcc:	30800044 	addi	r2,r6,1
8112add0:	d8800615 	stw	r2,24(sp)
8112add4:	34400047 	ldb	r17,1(r6)
8112add8:	003ff406 	br	8112adac <__reset+0xfb10adac>
8112addc:	0019883a 	mov	r12,zero
8112ade0:	b8800084 	addi	r2,r23,2
8112ade4:	d8800615 	stw	r2,24(sp)
8112ade8:	bc400087 	ldb	r17,2(r23)
8112adec:	003e1606 	br	8112a648 <__reset+0xfb10a648>
8112adf0:	03000044 	movi	r12,1
8112adf4:	003ffa06 	br	8112ade0 <__reset+0xfb10ade0>
8112adf8:	02c00044 	movi	r11,1
8112adfc:	003d8d06 	br	8112a434 <__reset+0xfb10a434>
8112ae00:	00800044 	movi	r2,1
8112ae04:	9080fe26 	beq	r18,r2,8112b200 <_strtod_r+0x1048>
8112ae08:	d8000b15 	stw	zero,44(sp)
8112ae0c:	05affc34 	movhi	r22,49136
8112ae10:	d8000d15 	stw	zero,52(sp)
8112ae14:	05cffc34 	movhi	r23,16368
8112ae18:	003f6306 	br	8112aba8 <__reset+0xfb10aba8>
8112ae1c:	d8000a15 	stw	zero,40(sp)
8112ae20:	003ec906 	br	8112a948 <__reset+0xfb10a948>
8112ae24:	d9001117 	ldw	r4,68(sp)
8112ae28:	00bfffc4 	movi	r2,-1
8112ae2c:	2080461e 	bne	r4,r2,8112af48 <_strtod_r+0xd90>
8112ae30:	dd000a15 	stw	r20,40(sp)
8112ae34:	dd001217 	ldw	r20,72(sp)
8112ae38:	a811883a 	mov	r8,r21
8112ae3c:	d8800517 	ldw	r2,20(sp)
8112ae40:	00c00884 	movi	r3,34
8112ae44:	80c00015 	stw	r3,0(r16)
8112ae48:	002b883a 	mov	r21,zero
8112ae4c:	059ffc34 	movhi	r22,32752
8112ae50:	100b883a 	mov	r5,r2
8112ae54:	8009883a 	mov	r4,r16
8112ae58:	da001315 	stw	r8,76(sp)
8112ae5c:	11289a40 	call	811289a4 <_Bfree>
8112ae60:	d9400a17 	ldw	r5,40(sp)
8112ae64:	8009883a 	mov	r4,r16
8112ae68:	11289a40 	call	811289a4 <_Bfree>
8112ae6c:	980b883a 	mov	r5,r19
8112ae70:	8009883a 	mov	r4,r16
8112ae74:	11289a40 	call	811289a4 <_Bfree>
8112ae78:	d9400817 	ldw	r5,32(sp)
8112ae7c:	8009883a 	mov	r4,r16
8112ae80:	11289a40 	call	811289a4 <_Bfree>
8112ae84:	da001317 	ldw	r8,76(sp)
8112ae88:	8009883a 	mov	r4,r16
8112ae8c:	400b883a 	mov	r5,r8
8112ae90:	11289a40 	call	811289a4 <_Bfree>
8112ae94:	003d9206 	br	8112a4e0 <__reset+0xfb10a4e0>
8112ae98:	d8c00717 	ldw	r3,28(sp)
8112ae9c:	d8800504 	addi	r2,sp,20
8112aea0:	01a04574 	movhi	r6,33045
8112aea4:	31b40f04 	addi	r6,r6,-12228
8112aea8:	d8c00115 	stw	r3,4(sp)
8112aeac:	d8800015 	stw	r2,0(sp)
8112aeb0:	d9c00404 	addi	r7,sp,16
8112aeb4:	d9400604 	addi	r5,sp,24
8112aeb8:	8009883a 	mov	r4,r16
8112aebc:	112f30c0 	call	8112f30c <__gethex>
8112aec0:	154001cc 	andi	r21,r2,7
8112aec4:	a83d9b26 	beq	r21,zero,8112a534 <__reset+0xfb10a534>
8112aec8:	00c00184 	movi	r3,6
8112aecc:	a8c0d61e 	bne	r21,r3,8112b228 <_strtod_r+0x1070>
8112aed0:	9cc00044 	addi	r19,r19,1
8112aed4:	dcc00615 	stw	r19,24(sp)
8112aed8:	002b883a 	mov	r21,zero
8112aedc:	002d883a 	mov	r22,zero
8112aee0:	d8000715 	stw	zero,28(sp)
8112aee4:	003d7e06 	br	8112a4e0 <__reset+0xfb10a4e0>
8112aee8:	00bf2c34 	movhi	r2,64688
8112aeec:	88a3883a 	add	r17,r17,r2
8112aef0:	9009883a 	mov	r4,r18
8112aef4:	880b883a 	mov	r5,r17
8112aef8:	11294580 	call	81129458 <__ulp>
8112aefc:	d9000b17 	ldw	r4,44(sp)
8112af00:	100d883a 	mov	r6,r2
8112af04:	180f883a 	mov	r7,r3
8112af08:	b00b883a 	mov	r5,r22
8112af0c:	111ca740 	call	8111ca74 <__muldf3>
8112af10:	900d883a 	mov	r6,r18
8112af14:	180b883a 	mov	r5,r3
8112af18:	880f883a 	mov	r7,r17
8112af1c:	1009883a 	mov	r4,r2
8112af20:	1130f640 	call	81130f64 <__adddf3>
8112af24:	015f2834 	movhi	r5,31904
8112af28:	1025883a 	mov	r18,r2
8112af2c:	297fffc4 	addi	r5,r5,-1
8112af30:	189ffc2c 	andhi	r2,r3,32752
8112af34:	2880892e 	bgeu	r5,r2,8112b15c <_strtod_r+0xfa4>
8112af38:	d8801017 	ldw	r2,64(sp)
8112af3c:	00dffc34 	movhi	r3,32752
8112af40:	18ffffc4 	addi	r3,r3,-1
8112af44:	10ffb726 	beq	r2,r3,8112ae24 <__reset+0xfb10ae24>
8112af48:	045ffc34 	movhi	r17,32752
8112af4c:	8c7fffc4 	addi	r17,r17,-1
8112af50:	04bfffc4 	movi	r18,-1
8112af54:	003f4706 	br	8112ac74 <__reset+0xfb10ac74>
8112af58:	00800884 	movi	r2,34
8112af5c:	80800015 	stw	r2,0(r16)
8112af60:	002b883a 	mov	r21,zero
8112af64:	059ffc34 	movhi	r22,32752
8112af68:	003d5d06 	br	8112a4e0 <__reset+0xfb10a4e0>
8112af6c:	d9000d17 	ldw	r4,52(sp)
8112af70:	b80b883a 	mov	r5,r23
8112af74:	1132c640 	call	81132c64 <__fixdfsi>
8112af78:	1009883a 	mov	r4,r2
8112af7c:	1132ce40 	call	81132ce4 <__floatsidf>
8112af80:	d9000d17 	ldw	r4,52(sp)
8112af84:	b80b883a 	mov	r5,r23
8112af88:	100d883a 	mov	r6,r2
8112af8c:	180f883a 	mov	r7,r3
8112af90:	11323600 	call	81132360 <__subdf3>
8112af94:	d9400e17 	ldw	r5,56(sp)
8112af98:	1039883a 	mov	fp,r2
8112af9c:	182f883a 	mov	r23,r3
8112afa0:	2800141e 	bne	r5,zero,8112aff4 <_strtod_r+0xe3c>
8112afa4:	9000131e 	bne	r18,zero,8112aff4 <_strtod_r+0xe3c>
8112afa8:	00800434 	movhi	r2,16
8112afac:	10bfffc4 	addi	r2,r2,-1
8112afb0:	b0ac703a 	and	r22,r22,r2
8112afb4:	b0000f1e 	bne	r22,zero,8112aff4 <_strtod_r+0xe3c>
8112afb8:	01a52834 	movhi	r6,38048
8112afbc:	01cff434 	movhi	r7,16336
8112afc0:	318d6544 	addi	r6,r6,13717
8112afc4:	39ffffc4 	addi	r7,r7,-1
8112afc8:	e009883a 	mov	r4,fp
8112afcc:	180b883a 	mov	r5,r3
8112afd0:	113226c0 	call	8113226c <__ledf2>
8112afd4:	103f270e 	bge	r2,zero,8112ac74 <__reset+0xfb10ac74>
8112afd8:	dd000a15 	stw	r20,40(sp)
8112afdc:	a811883a 	mov	r8,r21
8112afe0:	dd001217 	ldw	r20,72(sp)
8112afe4:	d8800517 	ldw	r2,20(sp)
8112afe8:	002b883a 	mov	r21,zero
8112afec:	882d883a 	mov	r22,r17
8112aff0:	003f9706 	br	8112ae50 <__reset+0xfb10ae50>
8112aff4:	01a52834 	movhi	r6,38048
8112aff8:	01cff834 	movhi	r7,16352
8112affc:	318d6544 	addi	r6,r6,13717
8112b000:	39ffffc4 	addi	r7,r7,-1
8112b004:	e009883a 	mov	r4,fp
8112b008:	b80b883a 	mov	r5,r23
8112b00c:	113226c0 	call	8113226c <__ledf2>
8112b010:	10000716 	blt	r2,zero,8112b030 <_strtod_r+0xe78>
8112b014:	018d6c34 	movhi	r6,13744
8112b018:	31b94d44 	addi	r6,r6,-6859
8112b01c:	01cff834 	movhi	r7,16352
8112b020:	e009883a 	mov	r4,fp
8112b024:	b80b883a 	mov	r5,r23
8112b028:	11321900 	call	81132190 <__gedf2>
8112b02c:	00bf110e 	bge	zero,r2,8112ac74 <__reset+0xfb10ac74>
8112b030:	dd000a15 	stw	r20,40(sp)
8112b034:	a811883a 	mov	r8,r21
8112b038:	dd001217 	ldw	r20,72(sp)
8112b03c:	d8800517 	ldw	r2,20(sp)
8112b040:	902b883a 	mov	r21,r18
8112b044:	882d883a 	mov	r22,r17
8112b048:	003f8106 	br	8112ae50 <__reset+0xfb10ae50>
8112b04c:	b83e2f26 	beq	r23,zero,8112a90c <__reset+0xfb10a90c>
8112b050:	05efc83a 	sub	r23,zero,r23
8112b054:	b88003cc 	andi	r2,r23,15
8112b058:	10000d26 	beq	r2,zero,8112b090 <_strtod_r+0xed8>
8112b05c:	100490fa 	slli	r2,r2,3
8112b060:	00e04574 	movhi	r3,33045
8112b064:	18f3d404 	addi	r3,r3,-12464
8112b068:	1885883a 	add	r2,r3,r2
8112b06c:	11800017 	ldw	r6,0(r2)
8112b070:	11c00117 	ldw	r7,4(r2)
8112b074:	9009883a 	mov	r4,r18
8112b078:	880b883a 	mov	r5,r17
8112b07c:	da401315 	stw	r9,76(sp)
8112b080:	11318180 	call	81131818 <__divdf3>
8112b084:	da401317 	ldw	r9,76(sp)
8112b088:	1025883a 	mov	r18,r2
8112b08c:	1823883a 	mov	r17,r3
8112b090:	b82fd13a 	srai	r23,r23,4
8112b094:	b83e1d26 	beq	r23,zero,8112a90c <__reset+0xfb10a90c>
8112b098:	008007c4 	movi	r2,31
8112b09c:	15c02816 	blt	r2,r23,8112b140 <_strtod_r+0xf88>
8112b0a0:	b880040c 	andi	r2,r23,16
8112b0a4:	10019726 	beq	r2,zero,8112b704 <_strtod_r+0x154c>
8112b0a8:	05c1880e 	bge	zero,r23,8112b6cc <_strtod_r+0x1514>
8112b0ac:	00c01a84 	movi	r3,106
8112b0b0:	d8c00915 	stw	r3,36(sp)
8112b0b4:	04e04574 	movhi	r19,33045
8112b0b8:	9cf41404 	addi	r19,r19,-12208
8112b0bc:	8807883a 	mov	r3,r17
8112b0c0:	9005883a 	mov	r2,r18
8112b0c4:	8023883a 	mov	r17,r16
8112b0c8:	0009883a 	mov	r4,zero
8112b0cc:	9821883a 	mov	r16,r19
8112b0d0:	da400a15 	stw	r9,40(sp)
8112b0d4:	1827883a 	mov	r19,r3
8112b0d8:	b980004c 	andi	r6,r23,1
8112b0dc:	30000626 	beq	r6,zero,8112b0f8 <_strtod_r+0xf40>
8112b0e0:	81800017 	ldw	r6,0(r16)
8112b0e4:	81c00117 	ldw	r7,4(r16)
8112b0e8:	1009883a 	mov	r4,r2
8112b0ec:	180b883a 	mov	r5,r3
8112b0f0:	111ca740 	call	8111ca74 <__muldf3>
8112b0f4:	01000044 	movi	r4,1
8112b0f8:	b82fd07a 	srai	r23,r23,1
8112b0fc:	84000204 	addi	r16,r16,8
8112b100:	b83ff51e 	bne	r23,zero,8112b0d8 <__reset+0xfb10b0d8>
8112b104:	21003fcc 	andi	r4,r4,255
8112b108:	8821883a 	mov	r16,r17
8112b10c:	da400a17 	ldw	r9,40(sp)
8112b110:	9823883a 	mov	r17,r19
8112b114:	2001a51e 	bne	r4,zero,8112b7ac <_strtod_r+0x15f4>
8112b118:	d9000917 	ldw	r4,36(sp)
8112b11c:	20016d1e 	bne	r4,zero,8112b6d4 <_strtod_r+0x151c>
8112b120:	000d883a 	mov	r6,zero
8112b124:	000f883a 	mov	r7,zero
8112b128:	9009883a 	mov	r4,r18
8112b12c:	880b883a 	mov	r5,r17
8112b130:	da401315 	stw	r9,76(sp)
8112b134:	11321080 	call	81132108 <__eqdf2>
8112b138:	da401317 	ldw	r9,76(sp)
8112b13c:	103df41e 	bne	r2,zero,8112a910 <__reset+0xfb10a910>
8112b140:	00800884 	movi	r2,34
8112b144:	80800015 	stw	r2,0(r16)
8112b148:	002b883a 	mov	r21,zero
8112b14c:	002d883a 	mov	r22,zero
8112b150:	003ce306 	br	8112a4e0 <__reset+0xfb10a4e0>
8112b154:	055387c4 	movi	r21,19999
8112b158:	003d6b06 	br	8112a708 <__reset+0xfb10a708>
8112b15c:	0440d434 	movhi	r17,848
8112b160:	1c63883a 	add	r17,r3,r17
8112b164:	882d883a 	mov	r22,r17
8112b168:	003ebe06 	br	8112ac64 <__reset+0xfb10ac64>
8112b16c:	14403fcc 	andi	r17,r2,255
8112b170:	8c40201c 	xori	r17,r17,128
8112b174:	8c7fe004 	addi	r17,r17,-128
8112b178:	dd400817 	ldw	r21,32(sp)
8112b17c:	0027883a 	mov	r19,zero
8112b180:	0039883a 	mov	fp,zero
8112b184:	002d883a 	mov	r22,zero
8112b188:	003c9906 	br	8112a3f0 <__reset+0xfb10a3f0>
8112b18c:	00c00944 	movi	r3,37
8112b190:	1a47c83a 	sub	r3,r3,r9
8112b194:	1d7d8c16 	blt	r3,r21,8112a7c8 <__reset+0xfb10a7c8>
8112b198:	1261c83a 	sub	r16,r2,r9
8112b19c:	800490fa 	slli	r2,r16,3
8112b1a0:	04e04574 	movhi	r19,33045
8112b1a4:	9cf3d404 	addi	r19,r19,-12464
8112b1a8:	9885883a 	add	r2,r19,r2
8112b1ac:	11000017 	ldw	r4,0(r2)
8112b1b0:	11400117 	ldw	r5,4(r2)
8112b1b4:	900d883a 	mov	r6,r18
8112b1b8:	880f883a 	mov	r7,r17
8112b1bc:	111ca740 	call	8111ca74 <__muldf3>
8112b1c0:	ac0dc83a 	sub	r6,r21,r16
8112b1c4:	300c90fa 	slli	r6,r6,3
8112b1c8:	1009883a 	mov	r4,r2
8112b1cc:	180b883a 	mov	r5,r3
8112b1d0:	9985883a 	add	r2,r19,r6
8112b1d4:	11800017 	ldw	r6,0(r2)
8112b1d8:	11c00117 	ldw	r7,4(r2)
8112b1dc:	111ca740 	call	8111ca74 <__muldf3>
8112b1e0:	102b883a 	mov	r21,r2
8112b1e4:	182d883a 	mov	r22,r3
8112b1e8:	003cbd06 	br	8112a4e0 <__reset+0xfb10a4e0>
8112b1ec:	b811883a 	mov	r8,r23
8112b1f0:	003e8606 	br	8112ac0c <__reset+0xfb10ac0c>
8112b1f4:	d8000d15 	stw	zero,52(sp)
8112b1f8:	05cffc34 	movhi	r23,16368
8112b1fc:	003e8006 	br	8112ac00 <__reset+0xfb10ac00>
8112b200:	883f011e 	bne	r17,zero,8112ae08 <__reset+0xfb10ae08>
8112b204:	dd000a15 	stw	r20,40(sp)
8112b208:	dd001217 	ldw	r20,72(sp)
8112b20c:	a811883a 	mov	r8,r21
8112b210:	00800884 	movi	r2,34
8112b214:	80800015 	stw	r2,0(r16)
8112b218:	002b883a 	mov	r21,zero
8112b21c:	d8800517 	ldw	r2,20(sp)
8112b220:	002d883a 	mov	r22,zero
8112b224:	003f0a06 	br	8112ae50 <__reset+0xfb10ae50>
8112b228:	d9800517 	ldw	r6,20(sp)
8112b22c:	30000826 	beq	r6,zero,8112b250 <_strtod_r+0x1098>
8112b230:	01400d44 	movi	r5,53
8112b234:	d9000204 	addi	r4,sp,8
8112b238:	d8801315 	stw	r2,76(sp)
8112b23c:	112984c0 	call	8112984c <__copybits>
8112b240:	d9400517 	ldw	r5,20(sp)
8112b244:	8009883a 	mov	r4,r16
8112b248:	11289a40 	call	811289a4 <_Bfree>
8112b24c:	d8801317 	ldw	r2,76(sp)
8112b250:	00c00184 	movi	r3,6
8112b254:	1d400f36 	bltu	r3,r21,8112b294 <_strtod_r+0x10dc>
8112b258:	a82a90ba 	slli	r21,r21,2
8112b25c:	00e044f4 	movhi	r3,33043
8112b260:	18ec9c04 	addi	r3,r3,-19856
8112b264:	a8eb883a 	add	r21,r21,r3
8112b268:	a8c00017 	ldw	r3,0(r21)
8112b26c:	1800683a 	jmp	r3
8112b270:	8112b2ec 	andhi	r4,r16,19147
8112b274:	8112b2c4 	addi	r4,r16,19147
8112b278:	8112b2a8 	cmpgeui	r4,r16,19146
8112b27c:	8112b28c 	andi	r4,r16,19146
8112b280:	8112b2b4 	orhi	r4,r16,19146
8112b284:	8112b2c4 	addi	r4,r16,19147
8112b288:	8112b2ec 	andhi	r4,r16,19147
8112b28c:	045ffc34 	movhi	r17,32752
8112b290:	0025883a 	mov	r18,zero
8112b294:	1080020c 	andi	r2,r2,8
8112b298:	902b883a 	mov	r21,r18
8112b29c:	103c8f26 	beq	r2,zero,8112a4dc <__reset+0xfb10a4dc>
8112b2a0:	8da00034 	orhi	r22,r17,32768
8112b2a4:	003c8e06 	br	8112a4e0 <__reset+0xfb10a4e0>
8112b2a8:	dc800217 	ldw	r18,8(sp)
8112b2ac:	dc400317 	ldw	r17,12(sp)
8112b2b0:	003ff806 	br	8112b294 <__reset+0xfb10b294>
8112b2b4:	04600034 	movhi	r17,32768
8112b2b8:	8c7fffc4 	addi	r17,r17,-1
8112b2bc:	04bfffc4 	movi	r18,-1
8112b2c0:	003ff406 	br	8112b294 <__reset+0xfb10b294>
8112b2c4:	d8c00417 	ldw	r3,16(sp)
8112b2c8:	dc400317 	ldw	r17,12(sp)
8112b2cc:	013ffc34 	movhi	r4,65520
8112b2d0:	18c10cc4 	addi	r3,r3,1075
8112b2d4:	1806953a 	slli	r3,r3,20
8112b2d8:	213fffc4 	addi	r4,r4,-1
8112b2dc:	8922703a 	and	r17,r17,r4
8112b2e0:	dc800217 	ldw	r18,8(sp)
8112b2e4:	88e2b03a 	or	r17,r17,r3
8112b2e8:	003fea06 	br	8112b294 <__reset+0xfb10b294>
8112b2ec:	0023883a 	mov	r17,zero
8112b2f0:	0025883a 	mov	r18,zero
8112b2f4:	003fe706 	br	8112b294 <__reset+0xfb10b294>
8112b2f8:	01800044 	movi	r6,1
8112b2fc:	50d5883a 	add	r10,r10,r3
8112b300:	2a4b883a 	add	r5,r5,r9
8112b304:	19811a26 	beq	r3,r6,8112b770 <_strtod_r+0x15b8>
8112b308:	01800204 	movi	r6,8
8112b30c:	01c00404 	movi	r7,16
8112b310:	4a400044 	addi	r9,r9,1
8112b314:	48bfffc4 	addi	r2,r9,-1
8112b318:	30801616 	blt	r6,r2,8112b374 <_strtod_r+0x11bc>
8112b31c:	e70002a4 	muli	fp,fp,10
8112b320:	497ffb1e 	bne	r9,r5,8112b310 <__reset+0xfb10b310>
8112b324:	d9800617 	ldw	r6,24(sp)
8112b328:	4a400044 	addi	r9,r9,1
8112b32c:	00c00204 	movi	r3,8
8112b330:	19400c0e 	bge	r3,r5,8112b364 <_strtod_r+0x11ac>
8112b334:	00800404 	movi	r2,16
8112b338:	000b883a 	mov	r5,zero
8112b33c:	127ea316 	blt	r2,r9,8112adcc <__reset+0xfb10adcc>
8112b340:	988002a4 	muli	r2,r19,10
8112b344:	20a7883a 	add	r19,r4,r2
8112b348:	003ea006 	br	8112adcc <__reset+0xfb10adcc>
8112b34c:	d8800617 	ldw	r2,24(sp)
8112b350:	8c7ff404 	addi	r17,r17,-48
8112b354:	2a800044 	addi	r10,r5,1
8112b358:	d8800815 	stw	r2,32(sp)
8112b35c:	100d883a 	mov	r6,r2
8112b360:	02400044 	movi	r9,1
8112b364:	e08002a4 	muli	r2,fp,10
8112b368:	000b883a 	mov	r5,zero
8112b36c:	88b9883a 	add	fp,r17,r2
8112b370:	003e9606 	br	8112adcc <__reset+0xfb10adcc>
8112b374:	3a7fea16 	blt	r7,r9,8112b320 <__reset+0xfb10b320>
8112b378:	9cc002a4 	muli	r19,r19,10
8112b37c:	003fe806 	br	8112b320 <__reset+0xfb10b320>
8112b380:	00bffa84 	movi	r2,-22
8112b384:	a8bd1016 	blt	r21,r2,8112a7c8 <__reset+0xfb10a7c8>
8112b388:	a82a90fa 	slli	r21,r21,3
8112b38c:	00a04574 	movhi	r2,33045
8112b390:	10b3d404 	addi	r2,r2,-12464
8112b394:	1545c83a 	sub	r2,r2,r21
8112b398:	11800017 	ldw	r6,0(r2)
8112b39c:	11c00117 	ldw	r7,4(r2)
8112b3a0:	9009883a 	mov	r4,r18
8112b3a4:	880b883a 	mov	r5,r17
8112b3a8:	11318180 	call	81131818 <__divdf3>
8112b3ac:	102b883a 	mov	r21,r2
8112b3b0:	182d883a 	mov	r22,r3
8112b3b4:	003c4a06 	br	8112a4e0 <__reset+0xfb10a4e0>
8112b3b8:	dd000a15 	stw	r20,40(sp)
8112b3bc:	a811883a 	mov	r8,r21
8112b3c0:	dd001217 	ldw	r20,72(sp)
8112b3c4:	003e9e06 	br	8112ae40 <__reset+0xfb10ae40>
8112b3c8:	01604574 	movhi	r5,33045
8112b3cc:	d9000617 	ldw	r4,24(sp)
8112b3d0:	29740604 	addi	r5,r5,-12264
8112b3d4:	01c00644 	movi	r7,25
8112b3d8:	00000b06 	br	8112b408 <_strtod_r+0x1250>
8112b3dc:	21000044 	addi	r4,r4,1
8112b3e0:	20800003 	ldbu	r2,0(r4)
8112b3e4:	10ffefc4 	addi	r3,r2,-65
8112b3e8:	10803fcc 	andi	r2,r2,255
8112b3ec:	1080201c 	xori	r2,r2,128
8112b3f0:	18c03fcc 	andi	r3,r3,255
8112b3f4:	10bfe004 	addi	r2,r2,-128
8112b3f8:	38c00136 	bltu	r7,r3,8112b400 <_strtod_r+0x1248>
8112b3fc:	10800804 	addi	r2,r2,32
8112b400:	29400044 	addi	r5,r5,1
8112b404:	11bbbb1e 	bne	r2,r6,8112a2f4 <__reset+0xfb10a2f4>
8112b408:	29800007 	ldb	r6,0(r5)
8112b40c:	303ff31e 	bne	r6,zero,8112b3dc <__reset+0xfb10b3dc>
8112b410:	01a04574 	movhi	r6,33045
8112b414:	d9000615 	stw	r4,24(sp)
8112b418:	31b40704 	addi	r6,r6,-12260
8112b41c:	200b883a 	mov	r5,r4
8112b420:	02000644 	movi	r8,25
8112b424:	00000a06 	br	8112b450 <_strtod_r+0x1298>
8112b428:	28800003 	ldbu	r2,0(r5)
8112b42c:	10ffefc4 	addi	r3,r2,-65
8112b430:	10803fcc 	andi	r2,r2,255
8112b434:	1080201c 	xori	r2,r2,128
8112b438:	18c03fcc 	andi	r3,r3,255
8112b43c:	10bfe004 	addi	r2,r2,-128
8112b440:	40c00136 	bltu	r8,r3,8112b448 <_strtod_r+0x1290>
8112b444:	10800804 	addi	r2,r2,32
8112b448:	31800044 	addi	r6,r6,1
8112b44c:	11c0711e 	bne	r2,r7,8112b614 <_strtod_r+0x145c>
8112b450:	31c00007 	ldb	r7,0(r6)
8112b454:	29400044 	addi	r5,r5,1
8112b458:	383ff31e 	bne	r7,zero,8112b428 <__reset+0xfb10b428>
8112b45c:	d9400615 	stw	r5,24(sp)
8112b460:	045ffc34 	movhi	r17,32752
8112b464:	0025883a 	mov	r18,zero
8112b468:	003c1b06 	br	8112a4d8 <__reset+0xfb10a4d8>
8112b46c:	000b883a 	mov	r5,zero
8112b470:	003ccc06 	br	8112a7a4 <__reset+0xfb10a7a4>
8112b474:	d9400e17 	ldw	r5,56(sp)
8112b478:	dd000a15 	stw	r20,40(sp)
8112b47c:	00800434 	movhi	r2,16
8112b480:	a811883a 	mov	r8,r21
8112b484:	dd001217 	ldw	r20,72(sp)
8112b488:	dd401117 	ldw	r21,68(sp)
8112b48c:	dd801017 	ldw	r22,64(sp)
8112b490:	10bfffc4 	addi	r2,r2,-1
8112b494:	28005626 	beq	r5,zero,8112b5f0 <_strtod_r+0x1438>
8112b498:	8886703a 	and	r3,r17,r2
8112b49c:	18807826 	beq	r3,r2,8112b680 <_strtod_r+0x14c8>
8112b4a0:	d8c00b17 	ldw	r3,44(sp)
8112b4a4:	18005726 	beq	r3,zero,8112b604 <_strtod_r+0x144c>
8112b4a8:	1c44703a 	and	r2,r3,r17
8112b4ac:	10000f26 	beq	r2,zero,8112b4ec <_strtod_r+0x1334>
8112b4b0:	d9000e17 	ldw	r4,56(sp)
8112b4b4:	d9800917 	ldw	r6,36(sp)
8112b4b8:	20005e26 	beq	r4,zero,8112b634 <_strtod_r+0x147c>
8112b4bc:	9009883a 	mov	r4,r18
8112b4c0:	880b883a 	mov	r5,r17
8112b4c4:	da001315 	stw	r8,76(sp)
8112b4c8:	112a14c0 	call	8112a14c <sulp>
8112b4cc:	100d883a 	mov	r6,r2
8112b4d0:	180f883a 	mov	r7,r3
8112b4d4:	9009883a 	mov	r4,r18
8112b4d8:	880b883a 	mov	r5,r17
8112b4dc:	1130f640 	call	81130f64 <__adddf3>
8112b4e0:	da001317 	ldw	r8,76(sp)
8112b4e4:	102b883a 	mov	r21,r2
8112b4e8:	182d883a 	mov	r22,r3
8112b4ec:	d8c00917 	ldw	r3,36(sp)
8112b4f0:	18000f26 	beq	r3,zero,8112b530 <_strtod_r+0x1378>
8112b4f4:	a809883a 	mov	r4,r21
8112b4f8:	b00b883a 	mov	r5,r22
8112b4fc:	000d883a 	mov	r6,zero
8112b500:	01ce5434 	movhi	r7,14672
8112b504:	da001315 	stw	r8,76(sp)
8112b508:	111ca740 	call	8111ca74 <__muldf3>
8112b50c:	102b883a 	mov	r21,r2
8112b510:	182d883a 	mov	r22,r3
8112b514:	da001317 	ldw	r8,76(sp)
8112b518:	1800051e 	bne	r3,zero,8112b530 <_strtod_r+0x1378>
8112b51c:	d8800517 	ldw	r2,20(sp)
8112b520:	a83e4b1e 	bne	r21,zero,8112ae50 <__reset+0xfb10ae50>
8112b524:	00c00884 	movi	r3,34
8112b528:	80c00015 	stw	r3,0(r16)
8112b52c:	003e4806 	br	8112ae50 <__reset+0xfb10ae50>
8112b530:	d8800517 	ldw	r2,20(sp)
8112b534:	003e4606 	br	8112ae50 <__reset+0xfb10ae50>
8112b538:	d9000e17 	ldw	r4,56(sp)
8112b53c:	dd000a15 	stw	r20,40(sp)
8112b540:	a811883a 	mov	r8,r21
8112b544:	dd001217 	ldw	r20,72(sp)
8112b548:	dd401117 	ldw	r21,68(sp)
8112b54c:	dd801017 	ldw	r22,64(sp)
8112b550:	203fe61e 	bne	r4,zero,8112b4ec <__reset+0xfb10b4ec>
8112b554:	903fe51e 	bne	r18,zero,8112b4ec <__reset+0xfb10b4ec>
8112b558:	00800434 	movhi	r2,16
8112b55c:	10bfffc4 	addi	r2,r2,-1
8112b560:	8884703a 	and	r2,r17,r2
8112b564:	103fe11e 	bne	r2,zero,8112b4ec <__reset+0xfb10b4ec>
8112b568:	8ddffc2c 	andhi	r23,r17,32752
8112b56c:	0081ac34 	movhi	r2,1712
8112b570:	15ffde2e 	bgeu	r2,r23,8112b4ec <__reset+0xfb10b4ec>
8112b574:	40800517 	ldw	r2,20(r8)
8112b578:	1000031e 	bne	r2,zero,8112b588 <_strtod_r+0x13d0>
8112b57c:	40800417 	ldw	r2,16(r8)
8112b580:	00c00044 	movi	r3,1
8112b584:	18bfd90e 	bge	r3,r2,8112b4ec <__reset+0xfb10b4ec>
8112b588:	400b883a 	mov	r5,r8
8112b58c:	01800044 	movi	r6,1
8112b590:	8009883a 	mov	r4,r16
8112b594:	11290a40 	call	811290a4 <__lshift>
8112b598:	980b883a 	mov	r5,r19
8112b59c:	1009883a 	mov	r4,r2
8112b5a0:	d8801315 	stw	r2,76(sp)
8112b5a4:	11291f40 	call	811291f4 <__mcmp>
8112b5a8:	da001317 	ldw	r8,76(sp)
8112b5ac:	00bfcf0e 	bge	zero,r2,8112b4ec <__reset+0xfb10b4ec>
8112b5b0:	d8c00917 	ldw	r3,36(sp)
8112b5b4:	18005c26 	beq	r3,zero,8112b728 <_strtod_r+0x1570>
8112b5b8:	0081ac34 	movhi	r2,1712
8112b5bc:	15c05a16 	blt	r2,r23,8112b728 <_strtod_r+0x1570>
8112b5c0:	0080dc34 	movhi	r2,880
8112b5c4:	15ffcb16 	blt	r2,r23,8112b4f4 <__reset+0xfb10b4f4>
8112b5c8:	003f1106 	br	8112b210 <__reset+0xfb10b210>
8112b5cc:	002d883a 	mov	r22,zero
8112b5d0:	022ff834 	movhi	r8,49120
8112b5d4:	d8000d15 	stw	zero,52(sp)
8112b5d8:	05cff834 	movhi	r23,16352
8112b5dc:	003ded06 	br	8112ad94 <__reset+0xfb10ad94>
8112b5e0:	0440d434 	movhi	r17,848
8112b5e4:	1c63883a 	add	r17,r3,r17
8112b5e8:	d8000915 	stw	zero,36(sp)
8112b5ec:	003cc806 	br	8112a910 <__reset+0xfb10a910>
8112b5f0:	8884703a 	and	r2,r17,r2
8112b5f4:	103faa1e 	bne	r2,zero,8112b4a0 <__reset+0xfb10b4a0>
8112b5f8:	903fa91e 	bne	r18,zero,8112b4a0 <__reset+0xfb10b4a0>
8112b5fc:	8ddffc2c 	andhi	r23,r17,32752
8112b600:	003feb06 	br	8112b5b0 <__reset+0xfb10b5b0>
8112b604:	d8c00d17 	ldw	r3,52(sp)
8112b608:	1cae703a 	and	r23,r3,r18
8112b60c:	b83fb726 	beq	r23,zero,8112b4ec <__reset+0xfb10b4ec>
8112b610:	003fa706 	br	8112b4b0 <__reset+0xfb10b4b0>
8112b614:	21000044 	addi	r4,r4,1
8112b618:	d9000615 	stw	r4,24(sp)
8112b61c:	003f9006 	br	8112b460 <__reset+0xfb10b460>
8112b620:	01604574 	movhi	r5,33045
8112b624:	2973ca04 	addi	r5,r5,-12504
8112b628:	d9400915 	stw	r5,36(sp)
8112b62c:	0027883a 	mov	r19,zero
8112b630:	003ca206 	br	8112a8bc <__reset+0xfb10a8bc>
8112b634:	9009883a 	mov	r4,r18
8112b638:	880b883a 	mov	r5,r17
8112b63c:	da001315 	stw	r8,76(sp)
8112b640:	112a14c0 	call	8112a14c <sulp>
8112b644:	100d883a 	mov	r6,r2
8112b648:	180f883a 	mov	r7,r3
8112b64c:	9009883a 	mov	r4,r18
8112b650:	880b883a 	mov	r5,r17
8112b654:	11323600 	call	81132360 <__subdf3>
8112b658:	000d883a 	mov	r6,zero
8112b65c:	000f883a 	mov	r7,zero
8112b660:	1009883a 	mov	r4,r2
8112b664:	180b883a 	mov	r5,r3
8112b668:	102b883a 	mov	r21,r2
8112b66c:	182d883a 	mov	r22,r3
8112b670:	11321080 	call	81132108 <__eqdf2>
8112b674:	da001317 	ldw	r8,76(sp)
8112b678:	103ee526 	beq	r2,zero,8112b210 <__reset+0xfb10b210>
8112b67c:	003f9b06 	br	8112b4ec <__reset+0xfb10b4ec>
8112b680:	d8800917 	ldw	r2,36(sp)
8112b684:	10002226 	beq	r2,zero,8112b710 <_strtod_r+0x1558>
8112b688:	889ffc2c 	andhi	r2,r17,32752
8112b68c:	00c1a834 	movhi	r3,1696
8112b690:	18801f36 	bltu	r3,r2,8112b710 <_strtod_r+0x1558>
8112b694:	1004d53a 	srli	r2,r2,20
8112b698:	00c01ac4 	movi	r3,107
8112b69c:	1887c83a 	sub	r3,r3,r2
8112b6a0:	00bfffc4 	movi	r2,-1
8112b6a4:	10c4983a 	sll	r2,r2,r3
8112b6a8:	14bf7d1e 	bne	r2,r18,8112b4a0 <__reset+0xfb10b4a0>
8112b6ac:	00dffc34 	movhi	r3,32752
8112b6b0:	18ffffc4 	addi	r3,r3,-1
8112b6b4:	88c03526 	beq	r17,r3,8112b78c <_strtod_r+0x15d4>
8112b6b8:	8c5ffc2c 	andhi	r17,r17,32752
8112b6bc:	00800434 	movhi	r2,16
8112b6c0:	002b883a 	mov	r21,zero
8112b6c4:	88ad883a 	add	r22,r17,r2
8112b6c8:	003f8806 	br	8112b4ec <__reset+0xfb10b4ec>
8112b6cc:	01401a84 	movi	r5,106
8112b6d0:	d9400915 	stw	r5,36(sp)
8112b6d4:	8ddffc2c 	andhi	r23,r17,32752
8112b6d8:	b82ed53a 	srli	r23,r23,20
8112b6dc:	00801ac4 	movi	r2,107
8112b6e0:	15c5c83a 	sub	r2,r2,r23
8112b6e4:	00be8e0e 	bge	zero,r2,8112b120 <__reset+0xfb10b120>
8112b6e8:	00c007c4 	movi	r3,31
8112b6ec:	18800a0e 	bge	r3,r2,8112b718 <_strtod_r+0x1560>
8112b6f0:	00c00d04 	movi	r3,52
8112b6f4:	0025883a 	mov	r18,zero
8112b6f8:	1880270e 	bge	r3,r2,8112b798 <_strtod_r+0x15e0>
8112b6fc:	0440dc34 	movhi	r17,880
8112b700:	003e8706 	br	8112b120 <__reset+0xfb10b120>
8112b704:	d8000915 	stw	zero,36(sp)
8112b708:	05fe6a16 	blt	zero,r23,8112b0b4 <__reset+0xfb10b0b4>
8112b70c:	003e8406 	br	8112b120 <__reset+0xfb10b120>
8112b710:	00bfffc4 	movi	r2,-1
8112b714:	003fe406 	br	8112b6a8 <__reset+0xfb10b6a8>
8112b718:	00ffffc4 	movi	r3,-1
8112b71c:	1884983a 	sll	r2,r3,r2
8112b720:	14a4703a 	and	r18,r2,r18
8112b724:	003e7e06 	br	8112b120 <__reset+0xfb10b120>
8112b728:	00bffc34 	movhi	r2,65520
8112b72c:	b8af883a 	add	r23,r23,r2
8112b730:	057fffc4 	movi	r21,-1
8112b734:	00800434 	movhi	r2,16
8112b738:	1545883a 	add	r2,r2,r21
8112b73c:	b8acb03a 	or	r22,r23,r2
8112b740:	003f6a06 	br	8112b4ec <__reset+0xfb10b4ec>
8112b744:	01604574 	movhi	r5,33045
8112b748:	29740a04 	addi	r5,r5,-12248
8112b74c:	d9800204 	addi	r6,sp,8
8112b750:	d9000604 	addi	r4,sp,24
8112b754:	112fb440 	call	8112fb44 <__hexnan>
8112b758:	00c00144 	movi	r3,5
8112b75c:	10fb5c1e 	bne	r2,r3,8112a4d0 <__reset+0xfb10a4d0>
8112b760:	dc400317 	ldw	r17,12(sp)
8112b764:	dc800217 	ldw	r18,8(sp)
8112b768:	8c5ffc34 	orhi	r17,r17,32752
8112b76c:	003b5a06 	br	8112a4d8 <__reset+0xfb10a4d8>
8112b770:	480b883a 	mov	r5,r9
8112b774:	d9800617 	ldw	r6,24(sp)
8112b778:	4a400044 	addi	r9,r9,1
8112b77c:	003eeb06 	br	8112b32c <__reset+0xfb10b32c>
8112b780:	1025883a 	mov	r18,r2
8112b784:	1823883a 	mov	r17,r3
8112b788:	003c4c06 	br	8112a8bc <__reset+0xfb10a8bc>
8112b78c:	00ffffc4 	movi	r3,-1
8112b790:	10ffc91e 	bne	r2,r3,8112b6b8 <__reset+0xfb10b6b8>
8112b794:	003da906 	br	8112ae3c <__reset+0xfb10ae3c>
8112b798:	10bff804 	addi	r2,r2,-32
8112b79c:	00ffffc4 	movi	r3,-1
8112b7a0:	1884983a 	sll	r2,r3,r2
8112b7a4:	1462703a 	and	r17,r2,r17
8112b7a8:	003e5d06 	br	8112b120 <__reset+0xfb10b120>
8112b7ac:	1025883a 	mov	r18,r2
8112b7b0:	1823883a 	mov	r17,r3
8112b7b4:	003e5806 	br	8112b118 <__reset+0xfb10b118>

8112b7b8 <strtod>:
8112b7b8:	00a04574 	movhi	r2,33045
8112b7bc:	10bd6304 	addi	r2,r2,-2676
8112b7c0:	280d883a 	mov	r6,r5
8112b7c4:	200b883a 	mov	r5,r4
8112b7c8:	11000017 	ldw	r4,0(r2)
8112b7cc:	112a1b81 	jmpi	8112a1b8 <_strtod_r>

8112b7d0 <strtof>:
8112b7d0:	defffb04 	addi	sp,sp,-20
8112b7d4:	de00012e 	bgeu	sp,et,8112b7dc <strtof+0xc>
8112b7d8:	003b68fa 	trap	3
8112b7dc:	dcc00315 	stw	r19,12(sp)
8112b7e0:	04e04574 	movhi	r19,33045
8112b7e4:	9cfd6304 	addi	r19,r19,-2676
8112b7e8:	280d883a 	mov	r6,r5
8112b7ec:	200b883a 	mov	r5,r4
8112b7f0:	99000017 	ldw	r4,0(r19)
8112b7f4:	dfc00415 	stw	ra,16(sp)
8112b7f8:	dc800215 	stw	r18,8(sp)
8112b7fc:	dc400115 	stw	r17,4(sp)
8112b800:	dc000015 	stw	r16,0(sp)
8112b804:	112a1b80 	call	8112a1b8 <_strtod_r>
8112b808:	1009883a 	mov	r4,r2
8112b80c:	180b883a 	mov	r5,r3
8112b810:	1025883a 	mov	r18,r2
8112b814:	1823883a 	mov	r17,r3
8112b818:	111d2ac0 	call	8111d2ac <__truncdfsf2>
8112b81c:	000b883a 	mov	r5,zero
8112b820:	1009883a 	mov	r4,r2
8112b824:	1021883a 	mov	r16,r2
8112b828:	1130d680 	call	81130d68 <__eqsf2>
8112b82c:	1000111e 	bne	r2,zero,8112b874 <strtof+0xa4>
8112b830:	000d883a 	mov	r6,zero
8112b834:	000f883a 	mov	r7,zero
8112b838:	9009883a 	mov	r4,r18
8112b83c:	880b883a 	mov	r5,r17
8112b840:	11321080 	call	81132108 <__eqdf2>
8112b844:	10000b26 	beq	r2,zero,8112b874 <strtof+0xa4>
8112b848:	98800017 	ldw	r2,0(r19)
8112b84c:	00c00884 	movi	r3,34
8112b850:	10c00015 	stw	r3,0(r2)
8112b854:	8005883a 	mov	r2,r16
8112b858:	dfc00417 	ldw	ra,16(sp)
8112b85c:	dcc00317 	ldw	r19,12(sp)
8112b860:	dc800217 	ldw	r18,8(sp)
8112b864:	dc400117 	ldw	r17,4(sp)
8112b868:	dc000017 	ldw	r16,0(sp)
8112b86c:	dec00504 	addi	sp,sp,20
8112b870:	f800283a 	ret
8112b874:	015fe034 	movhi	r5,32640
8112b878:	297fffc4 	addi	r5,r5,-1
8112b87c:	8009883a 	mov	r4,r16
8112b880:	1130de00 	call	81130de0 <__gesf2>
8112b884:	0080070e 	bge	zero,r2,8112b8a4 <strtof+0xd4>
8112b888:	01dffc34 	movhi	r7,32752
8112b88c:	39ffffc4 	addi	r7,r7,-1
8112b890:	01bfffc4 	movi	r6,-1
8112b894:	9009883a 	mov	r4,r18
8112b898:	880b883a 	mov	r5,r17
8112b89c:	11321900 	call	81132190 <__gedf2>
8112b8a0:	00bfe90e 	bge	zero,r2,8112b848 <__reset+0xfb10b848>
8112b8a4:	017fe034 	movhi	r5,65408
8112b8a8:	297fffc4 	addi	r5,r5,-1
8112b8ac:	8009883a 	mov	r4,r16
8112b8b0:	1130e9c0 	call	81130e9c <__lesf2>
8112b8b4:	103fe70e 	bge	r2,zero,8112b854 <__reset+0xfb10b854>
8112b8b8:	01fffc34 	movhi	r7,65520
8112b8bc:	39ffffc4 	addi	r7,r7,-1
8112b8c0:	01bfffc4 	movi	r6,-1
8112b8c4:	9009883a 	mov	r4,r18
8112b8c8:	880b883a 	mov	r5,r17
8112b8cc:	113226c0 	call	8113226c <__ledf2>
8112b8d0:	103fdd0e 	bge	r2,zero,8112b848 <__reset+0xfb10b848>
8112b8d4:	003fdf06 	br	8112b854 <__reset+0xfb10b854>

8112b8d8 <_strtoll_r>:
8112b8d8:	00a04574 	movhi	r2,33045
8112b8dc:	defff304 	addi	sp,sp,-52
8112b8e0:	10bd6104 	addi	r2,r2,-2684
8112b8e4:	de00012e 	bgeu	sp,et,8112b8ec <_strtoll_r+0x14>
8112b8e8:	003b68fa 	trap	3
8112b8ec:	dc800515 	stw	r18,20(sp)
8112b8f0:	14800017 	ldw	r18,0(r2)
8112b8f4:	dd800915 	stw	r22,36(sp)
8112b8f8:	dd400815 	stw	r21,32(sp)
8112b8fc:	dcc00615 	stw	r19,24(sp)
8112b900:	d9000015 	stw	r4,0(sp)
8112b904:	dfc00c15 	stw	ra,48(sp)
8112b908:	df000b15 	stw	fp,44(sp)
8112b90c:	ddc00a15 	stw	r23,40(sp)
8112b910:	dd000715 	stw	r20,28(sp)
8112b914:	dc400415 	stw	r17,16(sp)
8112b918:	dc000315 	stw	r16,12(sp)
8112b91c:	282d883a 	mov	r22,r5
8112b920:	302b883a 	mov	r21,r6
8112b924:	3827883a 	mov	r19,r7
8112b928:	2809883a 	mov	r4,r5
8112b92c:	24000003 	ldbu	r16,0(r4)
8112b930:	24400044 	addi	r17,r4,1
8112b934:	2007883a 	mov	r3,r4
8112b938:	9405883a 	add	r2,r18,r16
8112b93c:	10800043 	ldbu	r2,1(r2)
8112b940:	8809883a 	mov	r4,r17
8112b944:	1080020c 	andi	r2,r2,8
8112b948:	103ff81e 	bne	r2,zero,8112b92c <__reset+0xfb10b92c>
8112b94c:	00800b44 	movi	r2,45
8112b950:	80807826 	beq	r16,r2,8112bb34 <_strtoll_r+0x25c>
8112b954:	00800ac4 	movi	r2,43
8112b958:	80807a26 	beq	r16,r2,8112bb44 <_strtoll_r+0x26c>
8112b95c:	0039883a 	mov	fp,zero
8112b960:	98004e26 	beq	r19,zero,8112ba9c <_strtoll_r+0x1c4>
8112b964:	00800404 	movi	r2,16
8112b968:	98808226 	beq	r19,r2,8112bb74 <_strtoll_r+0x29c>
8112b96c:	982fd7fa 	srai	r23,r19,31
8112b970:	9829883a 	mov	r20,r19
8112b974:	e0004f26 	beq	fp,zero,8112bab4 <_strtoll_r+0x1dc>
8112b978:	0017883a 	mov	r11,zero
8112b97c:	02a00034 	movhi	r10,32768
8112b980:	5809883a 	mov	r4,r11
8112b984:	500b883a 	mov	r5,r10
8112b988:	a00d883a 	mov	r6,r20
8112b98c:	b80f883a 	mov	r7,r23
8112b990:	da800215 	stw	r10,8(sp)
8112b994:	dac00115 	stw	r11,4(sp)
8112b998:	11306740 	call	81130674 <__umoddi3>
8112b99c:	dac00117 	ldw	r11,4(sp)
8112b9a0:	da800217 	ldw	r10,8(sp)
8112b9a4:	a00d883a 	mov	r6,r20
8112b9a8:	5809883a 	mov	r4,r11
8112b9ac:	500b883a 	mov	r5,r10
8112b9b0:	b80f883a 	mov	r7,r23
8112b9b4:	d8800115 	stw	r2,4(sp)
8112b9b8:	11300f40 	call	811300f4 <__udivdi3>
8112b9bc:	9409883a 	add	r4,r18,r16
8112b9c0:	21000043 	ldbu	r4,1(r4)
8112b9c4:	1019883a 	mov	r12,r2
8112b9c8:	880b883a 	mov	r5,r17
8112b9cc:	2240010c 	andi	r9,r4,4
8112b9d0:	0015883a 	mov	r10,zero
8112b9d4:	000d883a 	mov	r6,zero
8112b9d8:	000f883a 	mov	r7,zero
8112b9dc:	03400044 	movi	r13,1
8112b9e0:	02ffffc4 	movi	r11,-1
8112b9e4:	da000117 	ldw	r8,4(sp)
8112b9e8:	48000d26 	beq	r9,zero,8112ba20 <_strtoll_r+0x148>
8112b9ec:	843ff404 	addi	r16,r16,-48
8112b9f0:	84c0110e 	bge	r16,r19,8112ba38 <_strtoll_r+0x160>
8112b9f4:	52c00426 	beq	r10,r11,8112ba08 <_strtoll_r+0x130>
8112b9f8:	19c00236 	bltu	r3,r7,8112ba04 <_strtoll_r+0x12c>
8112b9fc:	38c0311e 	bne	r7,r3,8112bac4 <_strtoll_r+0x1ec>
8112ba00:	6180302e 	bgeu	r12,r6,8112bac4 <_strtoll_r+0x1ec>
8112ba04:	02bfffc4 	movi	r10,-1
8112ba08:	2c000003 	ldbu	r16,0(r5)
8112ba0c:	29400044 	addi	r5,r5,1
8112ba10:	9409883a 	add	r4,r18,r16
8112ba14:	21000043 	ldbu	r4,1(r4)
8112ba18:	2240010c 	andi	r9,r4,4
8112ba1c:	483ff31e 	bne	r9,zero,8112b9ec <__reset+0xfb10b9ec>
8112ba20:	210000cc 	andi	r4,r4,3
8112ba24:	20000426 	beq	r4,zero,8112ba38 <_strtoll_r+0x160>
8112ba28:	23403426 	beq	r4,r13,8112bafc <_strtoll_r+0x224>
8112ba2c:	008015c4 	movi	r2,87
8112ba30:	80a1c83a 	sub	r16,r16,r2
8112ba34:	84ffef16 	blt	r16,r19,8112b9f4 <__reset+0xfb10b9f4>
8112ba38:	00bfffc4 	movi	r2,-1
8112ba3c:	50803426 	beq	r10,r2,8112bb10 <_strtoll_r+0x238>
8112ba40:	e0000426 	beq	fp,zero,8112ba54 <_strtoll_r+0x17c>
8112ba44:	018dc83a 	sub	r6,zero,r6
8112ba48:	3004c03a 	cmpne	r2,r6,zero
8112ba4c:	01e1c83a 	sub	r16,zero,r7
8112ba50:	808fc83a 	sub	r7,r16,r2
8112ba54:	3005883a 	mov	r2,r6
8112ba58:	3807883a 	mov	r3,r7
8112ba5c:	a8000326 	beq	r21,zero,8112ba6c <_strtoll_r+0x194>
8112ba60:	5000321e 	bne	r10,zero,8112bb2c <_strtoll_r+0x254>
8112ba64:	b00b883a 	mov	r5,r22
8112ba68:	a9400015 	stw	r5,0(r21)
8112ba6c:	dfc00c17 	ldw	ra,48(sp)
8112ba70:	df000b17 	ldw	fp,44(sp)
8112ba74:	ddc00a17 	ldw	r23,40(sp)
8112ba78:	dd800917 	ldw	r22,36(sp)
8112ba7c:	dd400817 	ldw	r21,32(sp)
8112ba80:	dd000717 	ldw	r20,28(sp)
8112ba84:	dcc00617 	ldw	r19,24(sp)
8112ba88:	dc800517 	ldw	r18,20(sp)
8112ba8c:	dc400417 	ldw	r17,16(sp)
8112ba90:	dc000317 	ldw	r16,12(sp)
8112ba94:	dec00d04 	addi	sp,sp,52
8112ba98:	f800283a 	ret
8112ba9c:	00800c04 	movi	r2,48
8112baa0:	80802c26 	beq	r16,r2,8112bb54 <_strtoll_r+0x27c>
8112baa4:	05000284 	movi	r20,10
8112baa8:	002f883a 	mov	r23,zero
8112baac:	a027883a 	mov	r19,r20
8112bab0:	e03fb11e 	bne	fp,zero,8112b978 <__reset+0xfb10b978>
8112bab4:	02a00034 	movhi	r10,32768
8112bab8:	52bfffc4 	addi	r10,r10,-1
8112babc:	02ffffc4 	movi	r11,-1
8112bac0:	003faf06 	br	8112b980 <__reset+0xfb10b980>
8112bac4:	33000f26 	beq	r6,r12,8112bb04 <_strtoll_r+0x22c>
8112bac8:	b985383a 	mul	r2,r23,r6
8112bacc:	3d0f383a 	mul	r7,r7,r20
8112bad0:	3508383a 	mulxuu	r4,r6,r20
8112bad4:	350d383a 	mul	r6,r6,r20
8112bad8:	8013d7fa 	srai	r9,r16,31
8112badc:	388f883a 	add	r7,r7,r2
8112bae0:	818d883a 	add	r6,r16,r6
8112bae4:	390f883a 	add	r7,r7,r4
8112bae8:	3421803a 	cmpltu	r16,r6,r16
8112baec:	49cf883a 	add	r7,r9,r7
8112baf0:	81cf883a 	add	r7,r16,r7
8112baf4:	02800044 	movi	r10,1
8112baf8:	003fc306 	br	8112ba08 <__reset+0xfb10ba08>
8112bafc:	00800dc4 	movi	r2,55
8112bb00:	003fcb06 	br	8112ba30 <__reset+0xfb10ba30>
8112bb04:	38fff01e 	bne	r7,r3,8112bac8 <__reset+0xfb10bac8>
8112bb08:	443fbe16 	blt	r8,r16,8112ba04 <__reset+0xfb10ba04>
8112bb0c:	003fee06 	br	8112bac8 <__reset+0xfb10bac8>
8112bb10:	e0002426 	beq	fp,zero,8112bba4 <_strtoll_r+0x2cc>
8112bb14:	0005883a 	mov	r2,zero
8112bb18:	00e00034 	movhi	r3,32768
8112bb1c:	d9800017 	ldw	r6,0(sp)
8112bb20:	01000884 	movi	r4,34
8112bb24:	31000015 	stw	r4,0(r6)
8112bb28:	a83fd026 	beq	r21,zero,8112ba6c <__reset+0xfb10ba6c>
8112bb2c:	297fffc4 	addi	r5,r5,-1
8112bb30:	003fcd06 	br	8112ba68 <__reset+0xfb10ba68>
8112bb34:	1c400084 	addi	r17,r3,2
8112bb38:	1c000043 	ldbu	r16,1(r3)
8112bb3c:	07000044 	movi	fp,1
8112bb40:	003f8706 	br	8112b960 <__reset+0xfb10b960>
8112bb44:	1c400084 	addi	r17,r3,2
8112bb48:	1c000043 	ldbu	r16,1(r3)
8112bb4c:	0039883a 	mov	fp,zero
8112bb50:	003f8306 	br	8112b960 <__reset+0xfb10b960>
8112bb54:	88800003 	ldbu	r2,0(r17)
8112bb58:	00c01604 	movi	r3,88
8112bb5c:	108037cc 	andi	r2,r2,223
8112bb60:	10c00a26 	beq	r2,r3,8112bb8c <_strtoll_r+0x2b4>
8112bb64:	05000204 	movi	r20,8
8112bb68:	002f883a 	mov	r23,zero
8112bb6c:	a027883a 	mov	r19,r20
8112bb70:	003f8006 	br	8112b974 <__reset+0xfb10b974>
8112bb74:	00800c04 	movi	r2,48
8112bb78:	80800e1e 	bne	r16,r2,8112bbb4 <_strtoll_r+0x2dc>
8112bb7c:	88800003 	ldbu	r2,0(r17)
8112bb80:	00c01604 	movi	r3,88
8112bb84:	108037cc 	andi	r2,r2,223
8112bb88:	10c00a1e 	bne	r2,r3,8112bbb4 <_strtoll_r+0x2dc>
8112bb8c:	05000404 	movi	r20,16
8112bb90:	8c000043 	ldbu	r16,1(r17)
8112bb94:	002f883a 	mov	r23,zero
8112bb98:	8c400084 	addi	r17,r17,2
8112bb9c:	a027883a 	mov	r19,r20
8112bba0:	003f7406 	br	8112b974 <__reset+0xfb10b974>
8112bba4:	00e00034 	movhi	r3,32768
8112bba8:	18ffffc4 	addi	r3,r3,-1
8112bbac:	5005883a 	mov	r2,r10
8112bbb0:	003fda06 	br	8112bb1c <__reset+0xfb10bb1c>
8112bbb4:	9829883a 	mov	r20,r19
8112bbb8:	002f883a 	mov	r23,zero
8112bbbc:	003f6d06 	br	8112b974 <__reset+0xfb10b974>

8112bbc0 <_strtoul_r>:
8112bbc0:	00a04574 	movhi	r2,33045
8112bbc4:	defff604 	addi	sp,sp,-40
8112bbc8:	10bd6104 	addi	r2,r2,-2684
8112bbcc:	de00012e 	bgeu	sp,et,8112bbd4 <_strtoul_r+0x14>
8112bbd0:	003b68fa 	trap	3
8112bbd4:	dc800315 	stw	r18,12(sp)
8112bbd8:	14800017 	ldw	r18,0(r2)
8112bbdc:	dd400615 	stw	r21,24(sp)
8112bbe0:	dd000515 	stw	r20,20(sp)
8112bbe4:	dcc00415 	stw	r19,16(sp)
8112bbe8:	2029883a 	mov	r20,r4
8112bbec:	dfc00915 	stw	ra,36(sp)
8112bbf0:	ddc00815 	stw	r23,32(sp)
8112bbf4:	dd800715 	stw	r22,28(sp)
8112bbf8:	dc400215 	stw	r17,8(sp)
8112bbfc:	dc000115 	stw	r16,4(sp)
8112bc00:	2827883a 	mov	r19,r5
8112bc04:	382b883a 	mov	r21,r7
8112bc08:	2809883a 	mov	r4,r5
8112bc0c:	24000003 	ldbu	r16,0(r4)
8112bc10:	24400044 	addi	r17,r4,1
8112bc14:	2007883a 	mov	r3,r4
8112bc18:	9405883a 	add	r2,r18,r16
8112bc1c:	10800043 	ldbu	r2,1(r2)
8112bc20:	8809883a 	mov	r4,r17
8112bc24:	1080020c 	andi	r2,r2,8
8112bc28:	103ff81e 	bne	r2,zero,8112bc0c <__reset+0xfb10bc0c>
8112bc2c:	00800b44 	movi	r2,45
8112bc30:	80805326 	beq	r16,r2,8112bd80 <_strtoul_r+0x1c0>
8112bc34:	00800ac4 	movi	r2,43
8112bc38:	80805526 	beq	r16,r2,8112bd90 <_strtoul_r+0x1d0>
8112bc3c:	002f883a 	mov	r23,zero
8112bc40:	a8000f26 	beq	r21,zero,8112bc80 <_strtoul_r+0xc0>
8112bc44:	00800404 	movi	r2,16
8112bc48:	a8805f26 	beq	r21,r2,8112bdc8 <_strtoul_r+0x208>
8112bc4c:	013fffc4 	movi	r4,-1
8112bc50:	a80b883a 	mov	r5,r21
8112bc54:	d9800015 	stw	r6,0(sp)
8112bc58:	1130cac0 	call	81130cac <__udivsi3>
8112bc5c:	a80b883a 	mov	r5,r21
8112bc60:	013fffc4 	movi	r4,-1
8112bc64:	102d883a 	mov	r22,r2
8112bc68:	1130d100 	call	81130d10 <__umodsi3>
8112bc6c:	d9800017 	ldw	r6,0(sp)
8112bc70:	1019883a 	mov	r12,r2
8112bc74:	a817883a 	mov	r11,r21
8112bc78:	b00f883a 	mov	r7,r22
8112bc7c:	00000706 	br	8112bc9c <_strtoul_r+0xdc>
8112bc80:	00800c04 	movi	r2,48
8112bc84:	80804626 	beq	r16,r2,8112bda0 <_strtoul_r+0x1e0>
8112bc88:	05400284 	movi	r21,10
8112bc8c:	01c666b4 	movhi	r7,6554
8112bc90:	03000144 	movi	r12,5
8112bc94:	39e66644 	addi	r7,r7,-26215
8112bc98:	a817883a 	mov	r11,r21
8112bc9c:	9407883a 	add	r3,r18,r16
8112bca0:	18c00043 	ldbu	r3,1(r3)
8112bca4:	8809883a 	mov	r4,r17
8112bca8:	0011883a 	mov	r8,zero
8112bcac:	1940010c 	andi	r5,r3,4
8112bcb0:	0005883a 	mov	r2,zero
8112bcb4:	02800044 	movi	r10,1
8112bcb8:	027fffc4 	movi	r9,-1
8112bcbc:	28000e26 	beq	r5,zero,8112bcf8 <_strtoul_r+0x138>
8112bcc0:	843ff404 	addi	r16,r16,-48
8112bcc4:	8540120e 	bge	r16,r21,8112bd10 <_strtoul_r+0x150>
8112bcc8:	42400526 	beq	r8,r9,8112bce0 <_strtoul_r+0x120>
8112bccc:	38802236 	bltu	r7,r2,8112bd58 <_strtoul_r+0x198>
8112bcd0:	11c02026 	beq	r2,r7,8112bd54 <_strtoul_r+0x194>
8112bcd4:	12c5383a 	mul	r2,r2,r11
8112bcd8:	02000044 	movi	r8,1
8112bcdc:	8085883a 	add	r2,r16,r2
8112bce0:	24000003 	ldbu	r16,0(r4)
8112bce4:	21000044 	addi	r4,r4,1
8112bce8:	9407883a 	add	r3,r18,r16
8112bcec:	18c00043 	ldbu	r3,1(r3)
8112bcf0:	1940010c 	andi	r5,r3,4
8112bcf4:	283ff21e 	bne	r5,zero,8112bcc0 <__reset+0xfb10bcc0>
8112bcf8:	18c000cc 	andi	r3,r3,3
8112bcfc:	18000426 	beq	r3,zero,8112bd10 <_strtoul_r+0x150>
8112bd00:	1a801726 	beq	r3,r10,8112bd60 <_strtoul_r+0x1a0>
8112bd04:	00c015c4 	movi	r3,87
8112bd08:	80e1c83a 	sub	r16,r16,r3
8112bd0c:	857fee16 	blt	r16,r21,8112bcc8 <__reset+0xfb10bcc8>
8112bd10:	40001516 	blt	r8,zero,8112bd68 <_strtoul_r+0x1a8>
8112bd14:	b8000126 	beq	r23,zero,8112bd1c <_strtoul_r+0x15c>
8112bd18:	0085c83a 	sub	r2,zero,r2
8112bd1c:	30000226 	beq	r6,zero,8112bd28 <_strtoul_r+0x168>
8112bd20:	4000151e 	bne	r8,zero,8112bd78 <_strtoul_r+0x1b8>
8112bd24:	34c00015 	stw	r19,0(r6)
8112bd28:	dfc00917 	ldw	ra,36(sp)
8112bd2c:	ddc00817 	ldw	r23,32(sp)
8112bd30:	dd800717 	ldw	r22,28(sp)
8112bd34:	dd400617 	ldw	r21,24(sp)
8112bd38:	dd000517 	ldw	r20,20(sp)
8112bd3c:	dcc00417 	ldw	r19,16(sp)
8112bd40:	dc800317 	ldw	r18,12(sp)
8112bd44:	dc400217 	ldw	r17,8(sp)
8112bd48:	dc000117 	ldw	r16,4(sp)
8112bd4c:	dec00a04 	addi	sp,sp,40
8112bd50:	f800283a 	ret
8112bd54:	643fdf0e 	bge	r12,r16,8112bcd4 <__reset+0xfb10bcd4>
8112bd58:	023fffc4 	movi	r8,-1
8112bd5c:	003fe006 	br	8112bce0 <__reset+0xfb10bce0>
8112bd60:	00c00dc4 	movi	r3,55
8112bd64:	003fe806 	br	8112bd08 <__reset+0xfb10bd08>
8112bd68:	00800884 	movi	r2,34
8112bd6c:	a0800015 	stw	r2,0(r20)
8112bd70:	00bfffc4 	movi	r2,-1
8112bd74:	303fec26 	beq	r6,zero,8112bd28 <__reset+0xfb10bd28>
8112bd78:	24ffffc4 	addi	r19,r4,-1
8112bd7c:	003fe906 	br	8112bd24 <__reset+0xfb10bd24>
8112bd80:	1c400084 	addi	r17,r3,2
8112bd84:	1c000043 	ldbu	r16,1(r3)
8112bd88:	05c00044 	movi	r23,1
8112bd8c:	003fac06 	br	8112bc40 <__reset+0xfb10bc40>
8112bd90:	1c400084 	addi	r17,r3,2
8112bd94:	1c000043 	ldbu	r16,1(r3)
8112bd98:	002f883a 	mov	r23,zero
8112bd9c:	003fa806 	br	8112bc40 <__reset+0xfb10bc40>
8112bda0:	88800003 	ldbu	r2,0(r17)
8112bda4:	00c01604 	movi	r3,88
8112bda8:	108037cc 	andi	r2,r2,223
8112bdac:	10c00c26 	beq	r2,r3,8112bde0 <_strtoul_r+0x220>
8112bdb0:	05400204 	movi	r21,8
8112bdb4:	01c80034 	movhi	r7,8192
8112bdb8:	030001c4 	movi	r12,7
8112bdbc:	39ffffc4 	addi	r7,r7,-1
8112bdc0:	a817883a 	mov	r11,r21
8112bdc4:	003fb506 	br	8112bc9c <__reset+0xfb10bc9c>
8112bdc8:	00800c04 	movi	r2,48
8112bdcc:	80800c1e 	bne	r16,r2,8112be00 <_strtoul_r+0x240>
8112bdd0:	88800003 	ldbu	r2,0(r17)
8112bdd4:	00c01604 	movi	r3,88
8112bdd8:	108037cc 	andi	r2,r2,223
8112bddc:	10c0081e 	bne	r2,r3,8112be00 <_strtoul_r+0x240>
8112bde0:	02c00404 	movi	r11,16
8112bde4:	05840034 	movhi	r22,4096
8112bde8:	8c000043 	ldbu	r16,1(r17)
8112bdec:	030003c4 	movi	r12,15
8112bdf0:	8c400084 	addi	r17,r17,2
8112bdf4:	b5bfffc4 	addi	r22,r22,-1
8112bdf8:	582b883a 	mov	r21,r11
8112bdfc:	003f9e06 	br	8112bc78 <__reset+0xfb10bc78>
8112be00:	01c40034 	movhi	r7,4096
8112be04:	030003c4 	movi	r12,15
8112be08:	39ffffc4 	addi	r7,r7,-1
8112be0c:	a817883a 	mov	r11,r21
8112be10:	003fa206 	br	8112bc9c <__reset+0xfb10bc9c>

8112be14 <strtoul>:
8112be14:	00a04574 	movhi	r2,33045
8112be18:	10bd6304 	addi	r2,r2,-2676
8112be1c:	300f883a 	mov	r7,r6
8112be20:	280d883a 	mov	r6,r5
8112be24:	200b883a 	mov	r5,r4
8112be28:	11000017 	ldw	r4,0(r2)
8112be2c:	112bbc01 	jmpi	8112bbc0 <_strtoul_r>

8112be30 <_strtoull_r>:
8112be30:	00a04574 	movhi	r2,33045
8112be34:	defff404 	addi	sp,sp,-48
8112be38:	10bd6104 	addi	r2,r2,-2684
8112be3c:	de00012e 	bgeu	sp,et,8112be44 <_strtoull_r+0x14>
8112be40:	003b68fa 	trap	3
8112be44:	dc400315 	stw	r17,12(sp)
8112be48:	14400017 	ldw	r17,0(r2)
8112be4c:	dd400715 	stw	r21,28(sp)
8112be50:	dd000615 	stw	r20,24(sp)
8112be54:	dcc00515 	stw	r19,20(sp)
8112be58:	dc800415 	stw	r18,16(sp)
8112be5c:	dfc00b15 	stw	ra,44(sp)
8112be60:	df000a15 	stw	fp,40(sp)
8112be64:	ddc00915 	stw	r23,36(sp)
8112be68:	dd800815 	stw	r22,32(sp)
8112be6c:	dc000215 	stw	r16,8(sp)
8112be70:	2827883a 	mov	r19,r5
8112be74:	202b883a 	mov	r21,r4
8112be78:	3029883a 	mov	r20,r6
8112be7c:	3825883a 	mov	r18,r7
8112be80:	2807883a 	mov	r3,r5
8112be84:	1c000003 	ldbu	r16,0(r3)
8112be88:	1f000044 	addi	fp,r3,1
8112be8c:	1809883a 	mov	r4,r3
8112be90:	8c05883a 	add	r2,r17,r16
8112be94:	10800043 	ldbu	r2,1(r2)
8112be98:	e007883a 	mov	r3,fp
8112be9c:	1080020c 	andi	r2,r2,8
8112bea0:	103ff81e 	bne	r2,zero,8112be84 <__reset+0xfb10be84>
8112bea4:	00800b44 	movi	r2,45
8112bea8:	80806e26 	beq	r16,r2,8112c064 <_strtoull_r+0x234>
8112beac:	00800ac4 	movi	r2,43
8112beb0:	80807026 	beq	r16,r2,8112c074 <_strtoull_r+0x244>
8112beb4:	002f883a 	mov	r23,zero
8112beb8:	90001426 	beq	r18,zero,8112bf0c <_strtoull_r+0xdc>
8112bebc:	00800404 	movi	r2,16
8112bec0:	90807c26 	beq	r18,r2,8112c0b4 <_strtoull_r+0x284>
8112bec4:	902dd7fa 	srai	r22,r18,31
8112bec8:	013fffc4 	movi	r4,-1
8112becc:	200b883a 	mov	r5,r4
8112bed0:	900d883a 	mov	r6,r18
8112bed4:	b00f883a 	mov	r7,r22
8112bed8:	11300f40 	call	811300f4 <__udivdi3>
8112bedc:	013fffc4 	movi	r4,-1
8112bee0:	900d883a 	mov	r6,r18
8112bee4:	b00f883a 	mov	r7,r22
8112bee8:	200b883a 	mov	r5,r4
8112beec:	d8c00115 	stw	r3,4(sp)
8112bef0:	d8800015 	stw	r2,0(sp)
8112bef4:	11306740 	call	81130674 <__umoddi3>
8112bef8:	101b883a 	mov	r13,r2
8112befc:	9015883a 	mov	r10,r18
8112bf00:	dac00017 	ldw	r11,0(sp)
8112bf04:	da000117 	ldw	r8,4(sp)
8112bf08:	00000a06 	br	8112bf34 <_strtoull_r+0x104>
8112bf0c:	00800c04 	movi	r2,48
8112bf10:	80805c26 	beq	r16,r2,8112c084 <_strtoull_r+0x254>
8112bf14:	02800284 	movi	r10,10
8112bf18:	02e666b4 	movhi	r11,39322
8112bf1c:	020666b4 	movhi	r8,6554
8112bf20:	03400144 	movi	r13,5
8112bf24:	5ae66644 	addi	r11,r11,-26215
8112bf28:	42266644 	addi	r8,r8,-26215
8112bf2c:	002d883a 	mov	r22,zero
8112bf30:	5025883a 	mov	r18,r10
8112bf34:	8c0b883a 	add	r5,r17,r16
8112bf38:	29400043 	ldbu	r5,1(r5)
8112bf3c:	e009883a 	mov	r4,fp
8112bf40:	000f883a 	mov	r7,zero
8112bf44:	2980010c 	andi	r6,r5,4
8112bf48:	0005883a 	mov	r2,zero
8112bf4c:	0007883a 	mov	r3,zero
8112bf50:	03000044 	movi	r12,1
8112bf54:	027fffc4 	movi	r9,-1
8112bf58:	30000d26 	beq	r6,zero,8112bf90 <_strtoull_r+0x160>
8112bf5c:	843ff404 	addi	r16,r16,-48
8112bf60:	8480110e 	bge	r16,r18,8112bfa8 <_strtoull_r+0x178>
8112bf64:	3a400426 	beq	r7,r9,8112bf78 <_strtoull_r+0x148>
8112bf68:	40c00236 	bltu	r8,r3,8112bf74 <_strtoull_r+0x144>
8112bf6c:	1a00231e 	bne	r3,r8,8112bffc <_strtoull_r+0x1cc>
8112bf70:	5880222e 	bgeu	r11,r2,8112bffc <_strtoull_r+0x1cc>
8112bf74:	01ffffc4 	movi	r7,-1
8112bf78:	24000003 	ldbu	r16,0(r4)
8112bf7c:	21000044 	addi	r4,r4,1
8112bf80:	8c0b883a 	add	r5,r17,r16
8112bf84:	29400043 	ldbu	r5,1(r5)
8112bf88:	2980010c 	andi	r6,r5,4
8112bf8c:	303ff31e 	bne	r6,zero,8112bf5c <__reset+0xfb10bf5c>
8112bf90:	294000cc 	andi	r5,r5,3
8112bf94:	28000426 	beq	r5,zero,8112bfa8 <_strtoull_r+0x178>
8112bf98:	2b002626 	beq	r5,r12,8112c034 <_strtoull_r+0x204>
8112bf9c:	014015c4 	movi	r5,87
8112bfa0:	8161c83a 	sub	r16,r16,r5
8112bfa4:	84bfef16 	blt	r16,r18,8112bf64 <__reset+0xfb10bf64>
8112bfa8:	38002716 	blt	r7,zero,8112c048 <_strtoull_r+0x218>
8112bfac:	b8000426 	beq	r23,zero,8112bfc0 <_strtoull_r+0x190>
8112bfb0:	0085c83a 	sub	r2,zero,r2
8112bfb4:	100ac03a 	cmpne	r5,r2,zero
8112bfb8:	00e1c83a 	sub	r16,zero,r3
8112bfbc:	8147c83a 	sub	r3,r16,r5
8112bfc0:	a0000226 	beq	r20,zero,8112bfcc <_strtoull_r+0x19c>
8112bfc4:	3800251e 	bne	r7,zero,8112c05c <_strtoull_r+0x22c>
8112bfc8:	a4c00015 	stw	r19,0(r20)
8112bfcc:	dfc00b17 	ldw	ra,44(sp)
8112bfd0:	df000a17 	ldw	fp,40(sp)
8112bfd4:	ddc00917 	ldw	r23,36(sp)
8112bfd8:	dd800817 	ldw	r22,32(sp)
8112bfdc:	dd400717 	ldw	r21,28(sp)
8112bfe0:	dd000617 	ldw	r20,24(sp)
8112bfe4:	dcc00517 	ldw	r19,20(sp)
8112bfe8:	dc800417 	ldw	r18,16(sp)
8112bfec:	dc400317 	ldw	r17,12(sp)
8112bff0:	dc000217 	ldw	r16,8(sp)
8112bff4:	dec00c04 	addi	sp,sp,48
8112bff8:	f800283a 	ret
8112bffc:	12c00f26 	beq	r2,r11,8112c03c <_strtoull_r+0x20c>
8112c000:	b08d383a 	mul	r6,r22,r2
8112c004:	1a87383a 	mul	r3,r3,r10
8112c008:	128a383a 	mulxuu	r5,r2,r10
8112c00c:	1285383a 	mul	r2,r2,r10
8112c010:	800fd7fa 	srai	r7,r16,31
8112c014:	1987883a 	add	r3,r3,r6
8112c018:	8085883a 	add	r2,r16,r2
8112c01c:	1947883a 	add	r3,r3,r5
8112c020:	38c7883a 	add	r3,r7,r3
8112c024:	1421803a 	cmpltu	r16,r2,r16
8112c028:	80c7883a 	add	r3,r16,r3
8112c02c:	01c00044 	movi	r7,1
8112c030:	003fd106 	br	8112bf78 <__reset+0xfb10bf78>
8112c034:	01400dc4 	movi	r5,55
8112c038:	003fd906 	br	8112bfa0 <__reset+0xfb10bfa0>
8112c03c:	1a3ff01e 	bne	r3,r8,8112c000 <__reset+0xfb10c000>
8112c040:	6c3fcc16 	blt	r13,r16,8112bf74 <__reset+0xfb10bf74>
8112c044:	003fee06 	br	8112c000 <__reset+0xfb10c000>
8112c048:	00800884 	movi	r2,34
8112c04c:	a8800015 	stw	r2,0(r21)
8112c050:	00bfffc4 	movi	r2,-1
8112c054:	1007883a 	mov	r3,r2
8112c058:	a03fdc26 	beq	r20,zero,8112bfcc <__reset+0xfb10bfcc>
8112c05c:	24ffffc4 	addi	r19,r4,-1
8112c060:	003fd906 	br	8112bfc8 <__reset+0xfb10bfc8>
8112c064:	27000084 	addi	fp,r4,2
8112c068:	24000043 	ldbu	r16,1(r4)
8112c06c:	05c00044 	movi	r23,1
8112c070:	003f9106 	br	8112beb8 <__reset+0xfb10beb8>
8112c074:	27000084 	addi	fp,r4,2
8112c078:	24000043 	ldbu	r16,1(r4)
8112c07c:	002f883a 	mov	r23,zero
8112c080:	003f8d06 	br	8112beb8 <__reset+0xfb10beb8>
8112c084:	e0800003 	ldbu	r2,0(fp)
8112c088:	00c01604 	movi	r3,88
8112c08c:	108037cc 	andi	r2,r2,223
8112c090:	10c00e26 	beq	r2,r3,8112c0cc <_strtoull_r+0x29c>
8112c094:	02800204 	movi	r10,8
8112c098:	02ffffc4 	movi	r11,-1
8112c09c:	02080034 	movhi	r8,8192
8112c0a0:	034001c4 	movi	r13,7
8112c0a4:	42d1883a 	add	r8,r8,r11
8112c0a8:	002d883a 	mov	r22,zero
8112c0ac:	5025883a 	mov	r18,r10
8112c0b0:	003fa006 	br	8112bf34 <__reset+0xfb10bf34>
8112c0b4:	00800c04 	movi	r2,48
8112c0b8:	80800e1e 	bne	r16,r2,8112c0f4 <_strtoull_r+0x2c4>
8112c0bc:	e0800003 	ldbu	r2,0(fp)
8112c0c0:	00c01604 	movi	r3,88
8112c0c4:	108037cc 	andi	r2,r2,223
8112c0c8:	10c00a1e 	bne	r2,r3,8112c0f4 <_strtoull_r+0x2c4>
8112c0cc:	02800404 	movi	r10,16
8112c0d0:	02ffffc4 	movi	r11,-1
8112c0d4:	02040034 	movhi	r8,4096
8112c0d8:	e4000043 	ldbu	r16,1(fp)
8112c0dc:	034003c4 	movi	r13,15
8112c0e0:	e7000084 	addi	fp,fp,2
8112c0e4:	42d1883a 	add	r8,r8,r11
8112c0e8:	002d883a 	mov	r22,zero
8112c0ec:	5025883a 	mov	r18,r10
8112c0f0:	003f9006 	br	8112bf34 <__reset+0xfb10bf34>
8112c0f4:	02ffffc4 	movi	r11,-1
8112c0f8:	02040034 	movhi	r8,4096
8112c0fc:	034003c4 	movi	r13,15
8112c100:	42d1883a 	add	r8,r8,r11
8112c104:	9015883a 	mov	r10,r18
8112c108:	002d883a 	mov	r22,zero
8112c10c:	003f8906 	br	8112bf34 <__reset+0xfb10bf34>

8112c110 <__ssprint_r>:
8112c110:	defff604 	addi	sp,sp,-40
8112c114:	de00012e 	bgeu	sp,et,8112c11c <__ssprint_r+0xc>
8112c118:	003b68fa 	trap	3
8112c11c:	30800217 	ldw	r2,8(r6)
8112c120:	dc800215 	stw	r18,8(sp)
8112c124:	dfc00915 	stw	ra,36(sp)
8112c128:	df000815 	stw	fp,32(sp)
8112c12c:	ddc00715 	stw	r23,28(sp)
8112c130:	dd800615 	stw	r22,24(sp)
8112c134:	dd400515 	stw	r21,20(sp)
8112c138:	dd000415 	stw	r20,16(sp)
8112c13c:	dcc00315 	stw	r19,12(sp)
8112c140:	dc400115 	stw	r17,4(sp)
8112c144:	dc000015 	stw	r16,0(sp)
8112c148:	3025883a 	mov	r18,r6
8112c14c:	10005826 	beq	r2,zero,8112c2b0 <__ssprint_r+0x1a0>
8112c150:	2027883a 	mov	r19,r4
8112c154:	35c00017 	ldw	r23,0(r6)
8112c158:	29000017 	ldw	r4,0(r5)
8112c15c:	28800217 	ldw	r2,8(r5)
8112c160:	2823883a 	mov	r17,r5
8112c164:	0039883a 	mov	fp,zero
8112c168:	0021883a 	mov	r16,zero
8112c16c:	80003926 	beq	r16,zero,8112c254 <__ssprint_r+0x144>
8112c170:	102b883a 	mov	r21,r2
8112c174:	102d883a 	mov	r22,r2
8112c178:	80803a36 	bltu	r16,r2,8112c264 <__ssprint_r+0x154>
8112c17c:	88c0030b 	ldhu	r3,12(r17)
8112c180:	1881200c 	andi	r2,r3,1152
8112c184:	10002626 	beq	r2,zero,8112c220 <__ssprint_r+0x110>
8112c188:	88800517 	ldw	r2,20(r17)
8112c18c:	89400417 	ldw	r5,16(r17)
8112c190:	81800044 	addi	r6,r16,1
8112c194:	108f883a 	add	r7,r2,r2
8112c198:	3885883a 	add	r2,r7,r2
8112c19c:	100ed7fa 	srli	r7,r2,31
8112c1a0:	216dc83a 	sub	r22,r4,r5
8112c1a4:	3589883a 	add	r4,r6,r22
8112c1a8:	3885883a 	add	r2,r7,r2
8112c1ac:	102bd07a 	srai	r21,r2,1
8112c1b0:	a80d883a 	mov	r6,r21
8112c1b4:	a900022e 	bgeu	r21,r4,8112c1c0 <__ssprint_r+0xb0>
8112c1b8:	202b883a 	mov	r21,r4
8112c1bc:	200d883a 	mov	r6,r4
8112c1c0:	18c1000c 	andi	r3,r3,1024
8112c1c4:	18002a26 	beq	r3,zero,8112c270 <__ssprint_r+0x160>
8112c1c8:	300b883a 	mov	r5,r6
8112c1cc:	9809883a 	mov	r4,r19
8112c1d0:	111deb00 	call	8111deb0 <_malloc_r>
8112c1d4:	1029883a 	mov	r20,r2
8112c1d8:	10002c26 	beq	r2,zero,8112c28c <__ssprint_r+0x17c>
8112c1dc:	89400417 	ldw	r5,16(r17)
8112c1e0:	b00d883a 	mov	r6,r22
8112c1e4:	1009883a 	mov	r4,r2
8112c1e8:	111e6c40 	call	8111e6c4 <memcpy>
8112c1ec:	8880030b 	ldhu	r2,12(r17)
8112c1f0:	00fedfc4 	movi	r3,-1153
8112c1f4:	10c4703a 	and	r2,r2,r3
8112c1f8:	10802014 	ori	r2,r2,128
8112c1fc:	8880030d 	sth	r2,12(r17)
8112c200:	a589883a 	add	r4,r20,r22
8112c204:	adadc83a 	sub	r22,r21,r22
8112c208:	8d400515 	stw	r21,20(r17)
8112c20c:	8d800215 	stw	r22,8(r17)
8112c210:	8d000415 	stw	r20,16(r17)
8112c214:	89000015 	stw	r4,0(r17)
8112c218:	802b883a 	mov	r21,r16
8112c21c:	802d883a 	mov	r22,r16
8112c220:	b00d883a 	mov	r6,r22
8112c224:	e00b883a 	mov	r5,fp
8112c228:	11287980 	call	81128798 <memmove>
8112c22c:	88800217 	ldw	r2,8(r17)
8112c230:	89000017 	ldw	r4,0(r17)
8112c234:	90c00217 	ldw	r3,8(r18)
8112c238:	1545c83a 	sub	r2,r2,r21
8112c23c:	2589883a 	add	r4,r4,r22
8112c240:	88800215 	stw	r2,8(r17)
8112c244:	89000015 	stw	r4,0(r17)
8112c248:	1c21c83a 	sub	r16,r3,r16
8112c24c:	94000215 	stw	r16,8(r18)
8112c250:	80001726 	beq	r16,zero,8112c2b0 <__ssprint_r+0x1a0>
8112c254:	bf000017 	ldw	fp,0(r23)
8112c258:	bc000117 	ldw	r16,4(r23)
8112c25c:	bdc00204 	addi	r23,r23,8
8112c260:	003fc206 	br	8112c16c <__reset+0xfb10c16c>
8112c264:	802b883a 	mov	r21,r16
8112c268:	802d883a 	mov	r22,r16
8112c26c:	003fec06 	br	8112c220 <__reset+0xfb10c220>
8112c270:	9809883a 	mov	r4,r19
8112c274:	11299b80 	call	811299b8 <_realloc_r>
8112c278:	1029883a 	mov	r20,r2
8112c27c:	103fe01e 	bne	r2,zero,8112c200 <__reset+0xfb10c200>
8112c280:	89400417 	ldw	r5,16(r17)
8112c284:	9809883a 	mov	r4,r19
8112c288:	11279240 	call	81127924 <_free_r>
8112c28c:	88c0030b 	ldhu	r3,12(r17)
8112c290:	00800304 	movi	r2,12
8112c294:	98800015 	stw	r2,0(r19)
8112c298:	18c01014 	ori	r3,r3,64
8112c29c:	88c0030d 	sth	r3,12(r17)
8112c2a0:	00bfffc4 	movi	r2,-1
8112c2a4:	90000215 	stw	zero,8(r18)
8112c2a8:	90000115 	stw	zero,4(r18)
8112c2ac:	00000206 	br	8112c2b8 <__ssprint_r+0x1a8>
8112c2b0:	90000115 	stw	zero,4(r18)
8112c2b4:	0005883a 	mov	r2,zero
8112c2b8:	dfc00917 	ldw	ra,36(sp)
8112c2bc:	df000817 	ldw	fp,32(sp)
8112c2c0:	ddc00717 	ldw	r23,28(sp)
8112c2c4:	dd800617 	ldw	r22,24(sp)
8112c2c8:	dd400517 	ldw	r21,20(sp)
8112c2cc:	dd000417 	ldw	r20,16(sp)
8112c2d0:	dcc00317 	ldw	r19,12(sp)
8112c2d4:	dc800217 	ldw	r18,8(sp)
8112c2d8:	dc400117 	ldw	r17,4(sp)
8112c2dc:	dc000017 	ldw	r16,0(sp)
8112c2e0:	dec00a04 	addi	sp,sp,40
8112c2e4:	f800283a 	ret

8112c2e8 <___svfiprintf_internal_r>:
8112c2e8:	deffc804 	addi	sp,sp,-224
8112c2ec:	de00012e 	bgeu	sp,et,8112c2f4 <___svfiprintf_internal_r+0xc>
8112c2f0:	003b68fa 	trap	3
8112c2f4:	2880030b 	ldhu	r2,12(r5)
8112c2f8:	dcc03115 	stw	r19,196(sp)
8112c2fc:	dfc03715 	stw	ra,220(sp)
8112c300:	df003615 	stw	fp,216(sp)
8112c304:	ddc03515 	stw	r23,212(sp)
8112c308:	dd803415 	stw	r22,208(sp)
8112c30c:	dd403315 	stw	r21,204(sp)
8112c310:	dd003215 	stw	r20,200(sp)
8112c314:	dc803015 	stw	r18,192(sp)
8112c318:	dc402f15 	stw	r17,188(sp)
8112c31c:	dc002e15 	stw	r16,184(sp)
8112c320:	d9402715 	stw	r5,156(sp)
8112c324:	d9002a15 	stw	r4,168(sp)
8112c328:	1080200c 	andi	r2,r2,128
8112c32c:	d9c02315 	stw	r7,140(sp)
8112c330:	3027883a 	mov	r19,r6
8112c334:	10000226 	beq	r2,zero,8112c340 <___svfiprintf_internal_r+0x58>
8112c338:	28800417 	ldw	r2,16(r5)
8112c33c:	10041d26 	beq	r2,zero,8112d3b4 <___svfiprintf_internal_r+0x10cc>
8112c340:	dac01a04 	addi	r11,sp,104
8112c344:	dac01e15 	stw	r11,120(sp)
8112c348:	d8801e17 	ldw	r2,120(sp)
8112c34c:	dac019c4 	addi	r11,sp,103
8112c350:	dd402a17 	ldw	r21,168(sp)
8112c354:	ddc02717 	ldw	r23,156(sp)
8112c358:	05a04574 	movhi	r22,33045
8112c35c:	05204574 	movhi	r20,33045
8112c360:	dac01f15 	stw	r11,124(sp)
8112c364:	12d7c83a 	sub	r11,r2,r11
8112c368:	b5b42204 	addi	r22,r22,-12152
8112c36c:	a5341e04 	addi	r20,r20,-12168
8112c370:	dec01a15 	stw	sp,104(sp)
8112c374:	d8001c15 	stw	zero,112(sp)
8112c378:	d8001b15 	stw	zero,108(sp)
8112c37c:	d811883a 	mov	r8,sp
8112c380:	d8002915 	stw	zero,164(sp)
8112c384:	d8002515 	stw	zero,148(sp)
8112c388:	dac02b15 	stw	r11,172(sp)
8112c38c:	98800007 	ldb	r2,0(r19)
8112c390:	1002dd26 	beq	r2,zero,8112cf08 <___svfiprintf_internal_r+0xc20>
8112c394:	00c00944 	movi	r3,37
8112c398:	9823883a 	mov	r17,r19
8112c39c:	10c0021e 	bne	r2,r3,8112c3a8 <___svfiprintf_internal_r+0xc0>
8112c3a0:	00001406 	br	8112c3f4 <___svfiprintf_internal_r+0x10c>
8112c3a4:	10c00326 	beq	r2,r3,8112c3b4 <___svfiprintf_internal_r+0xcc>
8112c3a8:	8c400044 	addi	r17,r17,1
8112c3ac:	88800007 	ldb	r2,0(r17)
8112c3b0:	103ffc1e 	bne	r2,zero,8112c3a4 <__reset+0xfb10c3a4>
8112c3b4:	8ce1c83a 	sub	r16,r17,r19
8112c3b8:	80000e26 	beq	r16,zero,8112c3f4 <___svfiprintf_internal_r+0x10c>
8112c3bc:	d8c01c17 	ldw	r3,112(sp)
8112c3c0:	d8801b17 	ldw	r2,108(sp)
8112c3c4:	44c00015 	stw	r19,0(r8)
8112c3c8:	1c07883a 	add	r3,r3,r16
8112c3cc:	10800044 	addi	r2,r2,1
8112c3d0:	d8c01c15 	stw	r3,112(sp)
8112c3d4:	44000115 	stw	r16,4(r8)
8112c3d8:	d8801b15 	stw	r2,108(sp)
8112c3dc:	00c001c4 	movi	r3,7
8112c3e0:	18831e16 	blt	r3,r2,8112d05c <___svfiprintf_internal_r+0xd74>
8112c3e4:	42000204 	addi	r8,r8,8
8112c3e8:	dac02517 	ldw	r11,148(sp)
8112c3ec:	5c17883a 	add	r11,r11,r16
8112c3f0:	dac02515 	stw	r11,148(sp)
8112c3f4:	88800007 	ldb	r2,0(r17)
8112c3f8:	1002c526 	beq	r2,zero,8112cf10 <___svfiprintf_internal_r+0xc28>
8112c3fc:	88c00047 	ldb	r3,1(r17)
8112c400:	8cc00044 	addi	r19,r17,1
8112c404:	d8001d85 	stb	zero,118(sp)
8112c408:	0009883a 	mov	r4,zero
8112c40c:	000f883a 	mov	r7,zero
8112c410:	043fffc4 	movi	r16,-1
8112c414:	d8002415 	stw	zero,144(sp)
8112c418:	0025883a 	mov	r18,zero
8112c41c:	01401604 	movi	r5,88
8112c420:	01800244 	movi	r6,9
8112c424:	02800a84 	movi	r10,42
8112c428:	02401b04 	movi	r9,108
8112c42c:	9cc00044 	addi	r19,r19,1
8112c430:	18bff804 	addi	r2,r3,-32
8112c434:	2881dd36 	bltu	r5,r2,8112cbac <___svfiprintf_internal_r+0x8c4>
8112c438:	100490ba 	slli	r2,r2,2
8112c43c:	02e044f4 	movhi	r11,33043
8112c440:	5af11404 	addi	r11,r11,-15280
8112c444:	12c5883a 	add	r2,r2,r11
8112c448:	10800017 	ldw	r2,0(r2)
8112c44c:	1000683a 	jmp	r2
8112c450:	8112c64c 	andi	r4,r16,19225
8112c454:	8112cbac 	andhi	r4,r16,19246
8112c458:	8112cbac 	andhi	r4,r16,19246
8112c45c:	8112c640 	call	88112c64 <__reset+0x20f2c64>
8112c460:	8112cbac 	andhi	r4,r16,19246
8112c464:	8112cbac 	andhi	r4,r16,19246
8112c468:	8112cbac 	andhi	r4,r16,19246
8112c46c:	8112cbac 	andhi	r4,r16,19246
8112c470:	8112cbac 	andhi	r4,r16,19246
8112c474:	8112cbac 	andhi	r4,r16,19246
8112c478:	8112c5b4 	orhi	r4,r16,19222
8112c47c:	8112c790 	cmplti	r4,r16,19230
8112c480:	8112cbac 	andhi	r4,r16,19246
8112c484:	8112c5e0 	cmpeqi	r4,r16,19223
8112c488:	8112cbe0 	cmpeqi	r4,r16,19247
8112c48c:	8112cbac 	andhi	r4,r16,19246
8112c490:	8112cbd4 	ori	r4,r16,19247
8112c494:	8112cb74 	orhi	r4,r16,19245
8112c498:	8112cb74 	orhi	r4,r16,19245
8112c49c:	8112cb74 	orhi	r4,r16,19245
8112c4a0:	8112cb74 	orhi	r4,r16,19245
8112c4a4:	8112cb74 	orhi	r4,r16,19245
8112c4a8:	8112cb74 	orhi	r4,r16,19245
8112c4ac:	8112cb74 	orhi	r4,r16,19245
8112c4b0:	8112cb74 	orhi	r4,r16,19245
8112c4b4:	8112cb74 	orhi	r4,r16,19245
8112c4b8:	8112cbac 	andhi	r4,r16,19246
8112c4bc:	8112cbac 	andhi	r4,r16,19246
8112c4c0:	8112cbac 	andhi	r4,r16,19246
8112c4c4:	8112cbac 	andhi	r4,r16,19246
8112c4c8:	8112cbac 	andhi	r4,r16,19246
8112c4cc:	8112cbac 	andhi	r4,r16,19246
8112c4d0:	8112cbac 	andhi	r4,r16,19246
8112c4d4:	8112cbac 	andhi	r4,r16,19246
8112c4d8:	8112cbac 	andhi	r4,r16,19246
8112c4dc:	8112cbac 	andhi	r4,r16,19246
8112c4e0:	8112cb10 	cmplti	r4,r16,19244
8112c4e4:	8112cbac 	andhi	r4,r16,19246
8112c4e8:	8112cbac 	andhi	r4,r16,19246
8112c4ec:	8112cbac 	andhi	r4,r16,19246
8112c4f0:	8112cbac 	andhi	r4,r16,19246
8112c4f4:	8112cbac 	andhi	r4,r16,19246
8112c4f8:	8112cbac 	andhi	r4,r16,19246
8112c4fc:	8112cbac 	andhi	r4,r16,19246
8112c500:	8112cbac 	andhi	r4,r16,19246
8112c504:	8112cbac 	andhi	r4,r16,19246
8112c508:	8112cbac 	andhi	r4,r16,19246
8112c50c:	8112cc88 	cmpgei	r4,r16,19250
8112c510:	8112cbac 	andhi	r4,r16,19246
8112c514:	8112cbac 	andhi	r4,r16,19246
8112c518:	8112cbac 	andhi	r4,r16,19246
8112c51c:	8112cbac 	andhi	r4,r16,19246
8112c520:	8112cbac 	andhi	r4,r16,19246
8112c524:	8112cc20 	cmpeqi	r4,r16,19248
8112c528:	8112cbac 	andhi	r4,r16,19246
8112c52c:	8112cbac 	andhi	r4,r16,19246
8112c530:	8112c954 	ori	r4,r16,19237
8112c534:	8112cbac 	andhi	r4,r16,19246
8112c538:	8112cbac 	andhi	r4,r16,19246
8112c53c:	8112cbac 	andhi	r4,r16,19246
8112c540:	8112cbac 	andhi	r4,r16,19246
8112c544:	8112cbac 	andhi	r4,r16,19246
8112c548:	8112cbac 	andhi	r4,r16,19246
8112c54c:	8112cbac 	andhi	r4,r16,19246
8112c550:	8112cbac 	andhi	r4,r16,19246
8112c554:	8112cbac 	andhi	r4,r16,19246
8112c558:	8112cbac 	andhi	r4,r16,19246
8112c55c:	8112c844 	addi	r4,r16,19233
8112c560:	8112c9f0 	cmpltui	r4,r16,19239
8112c564:	8112cbac 	andhi	r4,r16,19246
8112c568:	8112cbac 	andhi	r4,r16,19246
8112c56c:	8112cbac 	andhi	r4,r16,19246
8112c570:	8112c9e4 	muli	r4,r16,19239
8112c574:	8112c9f0 	cmpltui	r4,r16,19239
8112c578:	8112cbac 	andhi	r4,r16,19246
8112c57c:	8112cbac 	andhi	r4,r16,19246
8112c580:	8112c9d4 	ori	r4,r16,19239
8112c584:	8112cbac 	andhi	r4,r16,19246
8112c588:	8112c998 	cmpnei	r4,r16,19238
8112c58c:	8112c7a0 	cmpeqi	r4,r16,19230
8112c590:	8112c5ec 	andhi	r4,r16,19223
8112c594:	8112cb04 	addi	r4,r16,19244
8112c598:	8112cbac 	andhi	r4,r16,19246
8112c59c:	8112cab8 	rdprs	r4,r16,19242
8112c5a0:	8112cbac 	andhi	r4,r16,19246
8112c5a4:	8112c710 	cmplti	r4,r16,19228
8112c5a8:	8112cbac 	andhi	r4,r16,19246
8112c5ac:	8112cbac 	andhi	r4,r16,19246
8112c5b0:	8112c66c 	andhi	r4,r16,19225
8112c5b4:	dac02317 	ldw	r11,140(sp)
8112c5b8:	5ac00017 	ldw	r11,0(r11)
8112c5bc:	dac02415 	stw	r11,144(sp)
8112c5c0:	dac02317 	ldw	r11,140(sp)
8112c5c4:	58800104 	addi	r2,r11,4
8112c5c8:	dac02417 	ldw	r11,144(sp)
8112c5cc:	5802e90e 	bge	r11,zero,8112d174 <___svfiprintf_internal_r+0xe8c>
8112c5d0:	dac02417 	ldw	r11,144(sp)
8112c5d4:	d8802315 	stw	r2,140(sp)
8112c5d8:	02d7c83a 	sub	r11,zero,r11
8112c5dc:	dac02415 	stw	r11,144(sp)
8112c5e0:	94800114 	ori	r18,r18,4
8112c5e4:	98c00007 	ldb	r3,0(r19)
8112c5e8:	003f9006 	br	8112c42c <__reset+0xfb10c42c>
8112c5ec:	00800c04 	movi	r2,48
8112c5f0:	dac02317 	ldw	r11,140(sp)
8112c5f4:	d8801d05 	stb	r2,116(sp)
8112c5f8:	00801e04 	movi	r2,120
8112c5fc:	d8801d45 	stb	r2,117(sp)
8112c600:	d8001d85 	stb	zero,118(sp)
8112c604:	58c00104 	addi	r3,r11,4
8112c608:	5f000017 	ldw	fp,0(r11)
8112c60c:	0013883a 	mov	r9,zero
8112c610:	90800094 	ori	r2,r18,2
8112c614:	80032b16 	blt	r16,zero,8112d2c4 <___svfiprintf_internal_r+0xfdc>
8112c618:	00bfdfc4 	movi	r2,-129
8112c61c:	90a4703a 	and	r18,r18,r2
8112c620:	d8c02315 	stw	r3,140(sp)
8112c624:	94800094 	ori	r18,r18,2
8112c628:	e002dc26 	beq	fp,zero,8112d19c <___svfiprintf_internal_r+0xeb4>
8112c62c:	01204574 	movhi	r4,33045
8112c630:	21339404 	addi	r4,r4,-12720
8112c634:	0015883a 	mov	r10,zero
8112c638:	d9002915 	stw	r4,164(sp)
8112c63c:	00002306 	br	8112c6cc <___svfiprintf_internal_r+0x3e4>
8112c640:	94800054 	ori	r18,r18,1
8112c644:	98c00007 	ldb	r3,0(r19)
8112c648:	003f7806 	br	8112c42c <__reset+0xfb10c42c>
8112c64c:	38803fcc 	andi	r2,r7,255
8112c650:	1080201c 	xori	r2,r2,128
8112c654:	10bfe004 	addi	r2,r2,-128
8112c658:	1002f31e 	bne	r2,zero,8112d228 <___svfiprintf_internal_r+0xf40>
8112c65c:	01000044 	movi	r4,1
8112c660:	01c00804 	movi	r7,32
8112c664:	98c00007 	ldb	r3,0(r19)
8112c668:	003f7006 	br	8112c42c <__reset+0xfb10c42c>
8112c66c:	21003fcc 	andi	r4,r4,255
8112c670:	2003aa1e 	bne	r4,zero,8112d51c <___svfiprintf_internal_r+0x1234>
8112c674:	00a04574 	movhi	r2,33045
8112c678:	10b39404 	addi	r2,r2,-12720
8112c67c:	d8802915 	stw	r2,164(sp)
8112c680:	9080080c 	andi	r2,r18,32
8112c684:	1000ba26 	beq	r2,zero,8112c970 <___svfiprintf_internal_r+0x688>
8112c688:	dac02317 	ldw	r11,140(sp)
8112c68c:	5f000017 	ldw	fp,0(r11)
8112c690:	5a400117 	ldw	r9,4(r11)
8112c694:	5ac00204 	addi	r11,r11,8
8112c698:	dac02315 	stw	r11,140(sp)
8112c69c:	9080004c 	andi	r2,r18,1
8112c6a0:	10029026 	beq	r2,zero,8112d0e4 <___svfiprintf_internal_r+0xdfc>
8112c6a4:	e244b03a 	or	r2,fp,r9
8112c6a8:	1002d41e 	bne	r2,zero,8112d1fc <___svfiprintf_internal_r+0xf14>
8112c6ac:	d8001d85 	stb	zero,118(sp)
8112c6b0:	80030b16 	blt	r16,zero,8112d2e0 <___svfiprintf_internal_r+0xff8>
8112c6b4:	00bfdfc4 	movi	r2,-129
8112c6b8:	90a4703a 	and	r18,r18,r2
8112c6bc:	0015883a 	mov	r10,zero
8112c6c0:	80002426 	beq	r16,zero,8112c754 <___svfiprintf_internal_r+0x46c>
8112c6c4:	0039883a 	mov	fp,zero
8112c6c8:	0013883a 	mov	r9,zero
8112c6cc:	d9002917 	ldw	r4,164(sp)
8112c6d0:	dc401a04 	addi	r17,sp,104
8112c6d4:	e08003cc 	andi	r2,fp,15
8112c6d8:	4806973a 	slli	r3,r9,28
8112c6dc:	2085883a 	add	r2,r4,r2
8112c6e0:	e038d13a 	srli	fp,fp,4
8112c6e4:	10800003 	ldbu	r2,0(r2)
8112c6e8:	4812d13a 	srli	r9,r9,4
8112c6ec:	8c7fffc4 	addi	r17,r17,-1
8112c6f0:	1f38b03a 	or	fp,r3,fp
8112c6f4:	88800005 	stb	r2,0(r17)
8112c6f8:	e244b03a 	or	r2,fp,r9
8112c6fc:	103ff51e 	bne	r2,zero,8112c6d4 <__reset+0xfb10c6d4>
8112c700:	dac01e17 	ldw	r11,120(sp)
8112c704:	5c57c83a 	sub	r11,r11,r17
8112c708:	dac02115 	stw	r11,132(sp)
8112c70c:	00001406 	br	8112c760 <___svfiprintf_internal_r+0x478>
8112c710:	21003fcc 	andi	r4,r4,255
8112c714:	2003741e 	bne	r4,zero,8112d4e8 <___svfiprintf_internal_r+0x1200>
8112c718:	9080080c 	andi	r2,r18,32
8112c71c:	10014526 	beq	r2,zero,8112cc34 <___svfiprintf_internal_r+0x94c>
8112c720:	dac02317 	ldw	r11,140(sp)
8112c724:	d8001d85 	stb	zero,118(sp)
8112c728:	58c00204 	addi	r3,r11,8
8112c72c:	5f000017 	ldw	fp,0(r11)
8112c730:	5a400117 	ldw	r9,4(r11)
8112c734:	8002d916 	blt	r16,zero,8112d29c <___svfiprintf_internal_r+0xfb4>
8112c738:	013fdfc4 	movi	r4,-129
8112c73c:	e244b03a 	or	r2,fp,r9
8112c740:	d8c02315 	stw	r3,140(sp)
8112c744:	9124703a 	and	r18,r18,r4
8112c748:	0015883a 	mov	r10,zero
8112c74c:	1000b91e 	bne	r2,zero,8112ca34 <___svfiprintf_internal_r+0x74c>
8112c750:	8002e61e 	bne	r16,zero,8112d2ec <___svfiprintf_internal_r+0x1004>
8112c754:	0021883a 	mov	r16,zero
8112c758:	d8002115 	stw	zero,132(sp)
8112c75c:	dc401a04 	addi	r17,sp,104
8112c760:	d8c02117 	ldw	r3,132(sp)
8112c764:	dc002015 	stw	r16,128(sp)
8112c768:	80c0010e 	bge	r16,r3,8112c770 <___svfiprintf_internal_r+0x488>
8112c76c:	d8c02015 	stw	r3,128(sp)
8112c770:	52803fcc 	andi	r10,r10,255
8112c774:	5280201c 	xori	r10,r10,128
8112c778:	52bfe004 	addi	r10,r10,-128
8112c77c:	50003c26 	beq	r10,zero,8112c870 <___svfiprintf_internal_r+0x588>
8112c780:	dac02017 	ldw	r11,128(sp)
8112c784:	5ac00044 	addi	r11,r11,1
8112c788:	dac02015 	stw	r11,128(sp)
8112c78c:	00003806 	br	8112c870 <___svfiprintf_internal_r+0x588>
8112c790:	01000044 	movi	r4,1
8112c794:	01c00ac4 	movi	r7,43
8112c798:	98c00007 	ldb	r3,0(r19)
8112c79c:	003f2306 	br	8112c42c <__reset+0xfb10c42c>
8112c7a0:	21003fcc 	andi	r4,r4,255
8112c7a4:	2003481e 	bne	r4,zero,8112d4c8 <___svfiprintf_internal_r+0x11e0>
8112c7a8:	9080080c 	andi	r2,r18,32
8112c7ac:	10013b26 	beq	r2,zero,8112cc9c <___svfiprintf_internal_r+0x9b4>
8112c7b0:	dac02317 	ldw	r11,140(sp)
8112c7b4:	d8001d85 	stb	zero,118(sp)
8112c7b8:	58800204 	addi	r2,r11,8
8112c7bc:	5f000017 	ldw	fp,0(r11)
8112c7c0:	5a400117 	ldw	r9,4(r11)
8112c7c4:	8002a816 	blt	r16,zero,8112d268 <___svfiprintf_internal_r+0xf80>
8112c7c8:	013fdfc4 	movi	r4,-129
8112c7cc:	e246b03a 	or	r3,fp,r9
8112c7d0:	d8802315 	stw	r2,140(sp)
8112c7d4:	9124703a 	and	r18,r18,r4
8112c7d8:	18013c26 	beq	r3,zero,8112cccc <___svfiprintf_internal_r+0x9e4>
8112c7dc:	0015883a 	mov	r10,zero
8112c7e0:	dc401a04 	addi	r17,sp,104
8112c7e4:	e006d0fa 	srli	r3,fp,3
8112c7e8:	4808977a 	slli	r4,r9,29
8112c7ec:	4812d0fa 	srli	r9,r9,3
8112c7f0:	e70001cc 	andi	fp,fp,7
8112c7f4:	e0800c04 	addi	r2,fp,48
8112c7f8:	8c7fffc4 	addi	r17,r17,-1
8112c7fc:	20f8b03a 	or	fp,r4,r3
8112c800:	88800005 	stb	r2,0(r17)
8112c804:	e246b03a 	or	r3,fp,r9
8112c808:	183ff61e 	bne	r3,zero,8112c7e4 <__reset+0xfb10c7e4>
8112c80c:	90c0004c 	andi	r3,r18,1
8112c810:	1800a526 	beq	r3,zero,8112caa8 <___svfiprintf_internal_r+0x7c0>
8112c814:	10803fcc 	andi	r2,r2,255
8112c818:	1080201c 	xori	r2,r2,128
8112c81c:	10bfe004 	addi	r2,r2,-128
8112c820:	00c00c04 	movi	r3,48
8112c824:	10ffb626 	beq	r2,r3,8112c700 <__reset+0xfb10c700>
8112c828:	88ffffc5 	stb	r3,-1(r17)
8112c82c:	d8c01e17 	ldw	r3,120(sp)
8112c830:	88bfffc4 	addi	r2,r17,-1
8112c834:	1023883a 	mov	r17,r2
8112c838:	1887c83a 	sub	r3,r3,r2
8112c83c:	d8c02115 	stw	r3,132(sp)
8112c840:	003fc706 	br	8112c760 <__reset+0xfb10c760>
8112c844:	dac02317 	ldw	r11,140(sp)
8112c848:	00c00044 	movi	r3,1
8112c84c:	d8c02015 	stw	r3,128(sp)
8112c850:	58800017 	ldw	r2,0(r11)
8112c854:	5ac00104 	addi	r11,r11,4
8112c858:	d8001d85 	stb	zero,118(sp)
8112c85c:	d8801005 	stb	r2,64(sp)
8112c860:	dac02315 	stw	r11,140(sp)
8112c864:	d8c02115 	stw	r3,132(sp)
8112c868:	dc401004 	addi	r17,sp,64
8112c86c:	0021883a 	mov	r16,zero
8112c870:	90c0008c 	andi	r3,r18,2
8112c874:	d8c02215 	stw	r3,136(sp)
8112c878:	18000326 	beq	r3,zero,8112c888 <___svfiprintf_internal_r+0x5a0>
8112c87c:	dac02017 	ldw	r11,128(sp)
8112c880:	5ac00084 	addi	r11,r11,2
8112c884:	dac02015 	stw	r11,128(sp)
8112c888:	90c0210c 	andi	r3,r18,132
8112c88c:	d8c02615 	stw	r3,152(sp)
8112c890:	1801131e 	bne	r3,zero,8112cce0 <___svfiprintf_internal_r+0x9f8>
8112c894:	dac02417 	ldw	r11,144(sp)
8112c898:	d8c02017 	ldw	r3,128(sp)
8112c89c:	58f9c83a 	sub	fp,r11,r3
8112c8a0:	07010f0e 	bge	zero,fp,8112cce0 <___svfiprintf_internal_r+0x9f8>
8112c8a4:	02400404 	movi	r9,16
8112c8a8:	d8c01c17 	ldw	r3,112(sp)
8112c8ac:	d8801b17 	ldw	r2,108(sp)
8112c8b0:	4f02d60e 	bge	r9,fp,8112d40c <___svfiprintf_internal_r+0x1124>
8112c8b4:	01604574 	movhi	r5,33045
8112c8b8:	29742204 	addi	r5,r5,-12152
8112c8bc:	d9402815 	stw	r5,160(sp)
8112c8c0:	028001c4 	movi	r10,7
8112c8c4:	00000306 	br	8112c8d4 <___svfiprintf_internal_r+0x5ec>
8112c8c8:	e73ffc04 	addi	fp,fp,-16
8112c8cc:	42000204 	addi	r8,r8,8
8112c8d0:	4f00150e 	bge	r9,fp,8112c928 <___svfiprintf_internal_r+0x640>
8112c8d4:	18c00404 	addi	r3,r3,16
8112c8d8:	10800044 	addi	r2,r2,1
8112c8dc:	45800015 	stw	r22,0(r8)
8112c8e0:	42400115 	stw	r9,4(r8)
8112c8e4:	d8c01c15 	stw	r3,112(sp)
8112c8e8:	d8801b15 	stw	r2,108(sp)
8112c8ec:	50bff60e 	bge	r10,r2,8112c8c8 <__reset+0xfb10c8c8>
8112c8f0:	d9801a04 	addi	r6,sp,104
8112c8f4:	b80b883a 	mov	r5,r23
8112c8f8:	a809883a 	mov	r4,r21
8112c8fc:	da402c15 	stw	r9,176(sp)
8112c900:	da802d15 	stw	r10,180(sp)
8112c904:	112c1100 	call	8112c110 <__ssprint_r>
8112c908:	da402c17 	ldw	r9,176(sp)
8112c90c:	da802d17 	ldw	r10,180(sp)
8112c910:	1001851e 	bne	r2,zero,8112cf28 <___svfiprintf_internal_r+0xc40>
8112c914:	e73ffc04 	addi	fp,fp,-16
8112c918:	d8c01c17 	ldw	r3,112(sp)
8112c91c:	d8801b17 	ldw	r2,108(sp)
8112c920:	d811883a 	mov	r8,sp
8112c924:	4f3feb16 	blt	r9,fp,8112c8d4 <__reset+0xfb10c8d4>
8112c928:	dac02817 	ldw	r11,160(sp)
8112c92c:	e0c7883a 	add	r3,fp,r3
8112c930:	10800044 	addi	r2,r2,1
8112c934:	42c00015 	stw	r11,0(r8)
8112c938:	47000115 	stw	fp,4(r8)
8112c93c:	d8c01c15 	stw	r3,112(sp)
8112c940:	d8801b15 	stw	r2,108(sp)
8112c944:	010001c4 	movi	r4,7
8112c948:	2081ee16 	blt	r4,r2,8112d104 <___svfiprintf_internal_r+0xe1c>
8112c94c:	42000204 	addi	r8,r8,8
8112c950:	0000e506 	br	8112cce8 <___svfiprintf_internal_r+0xa00>
8112c954:	21003fcc 	andi	r4,r4,255
8112c958:	2002dd1e 	bne	r4,zero,8112d4d0 <___svfiprintf_internal_r+0x11e8>
8112c95c:	00a04574 	movhi	r2,33045
8112c960:	10b38f04 	addi	r2,r2,-12740
8112c964:	d8802915 	stw	r2,164(sp)
8112c968:	9080080c 	andi	r2,r18,32
8112c96c:	103f461e 	bne	r2,zero,8112c688 <__reset+0xfb10c688>
8112c970:	9080040c 	andi	r2,r18,16
8112c974:	10022e1e 	bne	r2,zero,8112d230 <___svfiprintf_internal_r+0xf48>
8112c978:	9080100c 	andi	r2,r18,64
8112c97c:	dac02317 	ldw	r11,140(sp)
8112c980:	10027326 	beq	r2,zero,8112d350 <___svfiprintf_internal_r+0x1068>
8112c984:	5f00000b 	ldhu	fp,0(r11)
8112c988:	5ac00104 	addi	r11,r11,4
8112c98c:	0013883a 	mov	r9,zero
8112c990:	dac02315 	stw	r11,140(sp)
8112c994:	003f4106 	br	8112c69c <__reset+0xfb10c69c>
8112c998:	21003fcc 	andi	r4,r4,255
8112c99c:	2002e11e 	bne	r4,zero,8112d524 <___svfiprintf_internal_r+0x123c>
8112c9a0:	9080080c 	andi	r2,r18,32
8112c9a4:	1002011e 	bne	r2,zero,8112d1ac <___svfiprintf_internal_r+0xec4>
8112c9a8:	9080040c 	andi	r2,r18,16
8112c9ac:	10023e1e 	bne	r2,zero,8112d2a8 <___svfiprintf_internal_r+0xfc0>
8112c9b0:	9480100c 	andi	r18,r18,64
8112c9b4:	90023c26 	beq	r18,zero,8112d2a8 <___svfiprintf_internal_r+0xfc0>
8112c9b8:	dac02317 	ldw	r11,140(sp)
8112c9bc:	58800017 	ldw	r2,0(r11)
8112c9c0:	5ac00104 	addi	r11,r11,4
8112c9c4:	dac02315 	stw	r11,140(sp)
8112c9c8:	dac02517 	ldw	r11,148(sp)
8112c9cc:	12c0000d 	sth	r11,0(r2)
8112c9d0:	003e6e06 	br	8112c38c <__reset+0xfb10c38c>
8112c9d4:	98c00007 	ldb	r3,0(r19)
8112c9d8:	1a422926 	beq	r3,r9,8112d280 <___svfiprintf_internal_r+0xf98>
8112c9dc:	94800414 	ori	r18,r18,16
8112c9e0:	003e9206 	br	8112c42c <__reset+0xfb10c42c>
8112c9e4:	94801014 	ori	r18,r18,64
8112c9e8:	98c00007 	ldb	r3,0(r19)
8112c9ec:	003e8f06 	br	8112c42c <__reset+0xfb10c42c>
8112c9f0:	21003fcc 	andi	r4,r4,255
8112c9f4:	2002c71e 	bne	r4,zero,8112d514 <___svfiprintf_internal_r+0x122c>
8112c9f8:	9080080c 	andi	r2,r18,32
8112c9fc:	10004926 	beq	r2,zero,8112cb24 <___svfiprintf_internal_r+0x83c>
8112ca00:	dac02317 	ldw	r11,140(sp)
8112ca04:	58800117 	ldw	r2,4(r11)
8112ca08:	5f000017 	ldw	fp,0(r11)
8112ca0c:	5ac00204 	addi	r11,r11,8
8112ca10:	dac02315 	stw	r11,140(sp)
8112ca14:	1013883a 	mov	r9,r2
8112ca18:	10004b16 	blt	r2,zero,8112cb48 <___svfiprintf_internal_r+0x860>
8112ca1c:	da801d83 	ldbu	r10,118(sp)
8112ca20:	8001cb16 	blt	r16,zero,8112d150 <___svfiprintf_internal_r+0xe68>
8112ca24:	00ffdfc4 	movi	r3,-129
8112ca28:	e244b03a 	or	r2,fp,r9
8112ca2c:	90e4703a 	and	r18,r18,r3
8112ca30:	103f4726 	beq	r2,zero,8112c750 <__reset+0xfb10c750>
8112ca34:	48008c26 	beq	r9,zero,8112cc68 <___svfiprintf_internal_r+0x980>
8112ca38:	dc802015 	stw	r18,128(sp)
8112ca3c:	dc002115 	stw	r16,132(sp)
8112ca40:	dc401a04 	addi	r17,sp,104
8112ca44:	e021883a 	mov	r16,fp
8112ca48:	da002215 	stw	r8,136(sp)
8112ca4c:	5039883a 	mov	fp,r10
8112ca50:	4825883a 	mov	r18,r9
8112ca54:	8009883a 	mov	r4,r16
8112ca58:	900b883a 	mov	r5,r18
8112ca5c:	01800284 	movi	r6,10
8112ca60:	000f883a 	mov	r7,zero
8112ca64:	11306740 	call	81130674 <__umoddi3>
8112ca68:	10800c04 	addi	r2,r2,48
8112ca6c:	8c7fffc4 	addi	r17,r17,-1
8112ca70:	8009883a 	mov	r4,r16
8112ca74:	900b883a 	mov	r5,r18
8112ca78:	88800005 	stb	r2,0(r17)
8112ca7c:	01800284 	movi	r6,10
8112ca80:	000f883a 	mov	r7,zero
8112ca84:	11300f40 	call	811300f4 <__udivdi3>
8112ca88:	1021883a 	mov	r16,r2
8112ca8c:	10c4b03a 	or	r2,r2,r3
8112ca90:	1825883a 	mov	r18,r3
8112ca94:	103fef1e 	bne	r2,zero,8112ca54 <__reset+0xfb10ca54>
8112ca98:	dc802017 	ldw	r18,128(sp)
8112ca9c:	dc002117 	ldw	r16,132(sp)
8112caa0:	da002217 	ldw	r8,136(sp)
8112caa4:	e015883a 	mov	r10,fp
8112caa8:	d8c01e17 	ldw	r3,120(sp)
8112caac:	1c47c83a 	sub	r3,r3,r17
8112cab0:	d8c02115 	stw	r3,132(sp)
8112cab4:	003f2a06 	br	8112c760 <__reset+0xfb10c760>
8112cab8:	dac02317 	ldw	r11,140(sp)
8112cabc:	d8001d85 	stb	zero,118(sp)
8112cac0:	5c400017 	ldw	r17,0(r11)
8112cac4:	5f000104 	addi	fp,r11,4
8112cac8:	88022f26 	beq	r17,zero,8112d388 <___svfiprintf_internal_r+0x10a0>
8112cacc:	80022516 	blt	r16,zero,8112d364 <___svfiprintf_internal_r+0x107c>
8112cad0:	800d883a 	mov	r6,r16
8112cad4:	000b883a 	mov	r5,zero
8112cad8:	8809883a 	mov	r4,r17
8112cadc:	da002c15 	stw	r8,176(sp)
8112cae0:	11286b40 	call	811286b4 <memchr>
8112cae4:	da002c17 	ldw	r8,176(sp)
8112cae8:	10026426 	beq	r2,zero,8112d47c <___svfiprintf_internal_r+0x1194>
8112caec:	1445c83a 	sub	r2,r2,r17
8112caf0:	d8802115 	stw	r2,132(sp)
8112caf4:	da801d83 	ldbu	r10,118(sp)
8112caf8:	df002315 	stw	fp,140(sp)
8112cafc:	0021883a 	mov	r16,zero
8112cb00:	003f1706 	br	8112c760 <__reset+0xfb10c760>
8112cb04:	94800814 	ori	r18,r18,32
8112cb08:	98c00007 	ldb	r3,0(r19)
8112cb0c:	003e4706 	br	8112c42c <__reset+0xfb10c42c>
8112cb10:	21003fcc 	andi	r4,r4,255
8112cb14:	2002701e 	bne	r4,zero,8112d4d8 <___svfiprintf_internal_r+0x11f0>
8112cb18:	94800414 	ori	r18,r18,16
8112cb1c:	9080080c 	andi	r2,r18,32
8112cb20:	103fb71e 	bne	r2,zero,8112ca00 <__reset+0xfb10ca00>
8112cb24:	9080040c 	andi	r2,r18,16
8112cb28:	1001ab26 	beq	r2,zero,8112d1d8 <___svfiprintf_internal_r+0xef0>
8112cb2c:	dac02317 	ldw	r11,140(sp)
8112cb30:	5f000017 	ldw	fp,0(r11)
8112cb34:	5ac00104 	addi	r11,r11,4
8112cb38:	dac02315 	stw	r11,140(sp)
8112cb3c:	e013d7fa 	srai	r9,fp,31
8112cb40:	4805883a 	mov	r2,r9
8112cb44:	103fb50e 	bge	r2,zero,8112ca1c <__reset+0xfb10ca1c>
8112cb48:	0739c83a 	sub	fp,zero,fp
8112cb4c:	02800b44 	movi	r10,45
8112cb50:	e004c03a 	cmpne	r2,fp,zero
8112cb54:	0253c83a 	sub	r9,zero,r9
8112cb58:	da801d85 	stb	r10,118(sp)
8112cb5c:	4893c83a 	sub	r9,r9,r2
8112cb60:	80023016 	blt	r16,zero,8112d424 <___svfiprintf_internal_r+0x113c>
8112cb64:	00bfdfc4 	movi	r2,-129
8112cb68:	90a4703a 	and	r18,r18,r2
8112cb6c:	483fb21e 	bne	r9,zero,8112ca38 <__reset+0xfb10ca38>
8112cb70:	00003d06 	br	8112cc68 <___svfiprintf_internal_r+0x980>
8112cb74:	9817883a 	mov	r11,r19
8112cb78:	d8002415 	stw	zero,144(sp)
8112cb7c:	18bff404 	addi	r2,r3,-48
8112cb80:	0019883a 	mov	r12,zero
8112cb84:	58c00007 	ldb	r3,0(r11)
8112cb88:	630002a4 	muli	r12,r12,10
8112cb8c:	9cc00044 	addi	r19,r19,1
8112cb90:	9817883a 	mov	r11,r19
8112cb94:	1319883a 	add	r12,r2,r12
8112cb98:	18bff404 	addi	r2,r3,-48
8112cb9c:	30bff92e 	bgeu	r6,r2,8112cb84 <__reset+0xfb10cb84>
8112cba0:	db002415 	stw	r12,144(sp)
8112cba4:	18bff804 	addi	r2,r3,-32
8112cba8:	28be232e 	bgeu	r5,r2,8112c438 <__reset+0xfb10c438>
8112cbac:	21003fcc 	andi	r4,r4,255
8112cbb0:	20024b1e 	bne	r4,zero,8112d4e0 <___svfiprintf_internal_r+0x11f8>
8112cbb4:	1800d626 	beq	r3,zero,8112cf10 <___svfiprintf_internal_r+0xc28>
8112cbb8:	02c00044 	movi	r11,1
8112cbbc:	dac02015 	stw	r11,128(sp)
8112cbc0:	d8c01005 	stb	r3,64(sp)
8112cbc4:	d8001d85 	stb	zero,118(sp)
8112cbc8:	dac02115 	stw	r11,132(sp)
8112cbcc:	dc401004 	addi	r17,sp,64
8112cbd0:	003f2606 	br	8112c86c <__reset+0xfb10c86c>
8112cbd4:	94802014 	ori	r18,r18,128
8112cbd8:	98c00007 	ldb	r3,0(r19)
8112cbdc:	003e1306 	br	8112c42c <__reset+0xfb10c42c>
8112cbe0:	98c00007 	ldb	r3,0(r19)
8112cbe4:	9ac00044 	addi	r11,r19,1
8112cbe8:	1a822b26 	beq	r3,r10,8112d498 <___svfiprintf_internal_r+0x11b0>
8112cbec:	18bff404 	addi	r2,r3,-48
8112cbf0:	0021883a 	mov	r16,zero
8112cbf4:	30821e36 	bltu	r6,r2,8112d470 <___svfiprintf_internal_r+0x1188>
8112cbf8:	58c00007 	ldb	r3,0(r11)
8112cbfc:	840002a4 	muli	r16,r16,10
8112cc00:	5cc00044 	addi	r19,r11,1
8112cc04:	9817883a 	mov	r11,r19
8112cc08:	80a1883a 	add	r16,r16,r2
8112cc0c:	18bff404 	addi	r2,r3,-48
8112cc10:	30bff92e 	bgeu	r6,r2,8112cbf8 <__reset+0xfb10cbf8>
8112cc14:	803e060e 	bge	r16,zero,8112c430 <__reset+0xfb10c430>
8112cc18:	043fffc4 	movi	r16,-1
8112cc1c:	003e0406 	br	8112c430 <__reset+0xfb10c430>
8112cc20:	21003fcc 	andi	r4,r4,255
8112cc24:	2002371e 	bne	r4,zero,8112d504 <___svfiprintf_internal_r+0x121c>
8112cc28:	94800414 	ori	r18,r18,16
8112cc2c:	9080080c 	andi	r2,r18,32
8112cc30:	103ebb1e 	bne	r2,zero,8112c720 <__reset+0xfb10c720>
8112cc34:	9080040c 	andi	r2,r18,16
8112cc38:	10013b26 	beq	r2,zero,8112d128 <___svfiprintf_internal_r+0xe40>
8112cc3c:	dac02317 	ldw	r11,140(sp)
8112cc40:	d8001d85 	stb	zero,118(sp)
8112cc44:	0013883a 	mov	r9,zero
8112cc48:	58800104 	addi	r2,r11,4
8112cc4c:	5f000017 	ldw	fp,0(r11)
8112cc50:	80013d16 	blt	r16,zero,8112d148 <___svfiprintf_internal_r+0xe60>
8112cc54:	00ffdfc4 	movi	r3,-129
8112cc58:	d8802315 	stw	r2,140(sp)
8112cc5c:	90e4703a 	and	r18,r18,r3
8112cc60:	0015883a 	mov	r10,zero
8112cc64:	e03eba26 	beq	fp,zero,8112c750 <__reset+0xfb10c750>
8112cc68:	00800244 	movi	r2,9
8112cc6c:	173f7236 	bltu	r2,fp,8112ca38 <__reset+0xfb10ca38>
8112cc70:	dac02b17 	ldw	r11,172(sp)
8112cc74:	e7000c04 	addi	fp,fp,48
8112cc78:	df0019c5 	stb	fp,103(sp)
8112cc7c:	dac02115 	stw	r11,132(sp)
8112cc80:	dc4019c4 	addi	r17,sp,103
8112cc84:	003eb606 	br	8112c760 <__reset+0xfb10c760>
8112cc88:	21003fcc 	andi	r4,r4,255
8112cc8c:	20021f1e 	bne	r4,zero,8112d50c <___svfiprintf_internal_r+0x1224>
8112cc90:	94800414 	ori	r18,r18,16
8112cc94:	9080080c 	andi	r2,r18,32
8112cc98:	103ec51e 	bne	r2,zero,8112c7b0 <__reset+0xfb10c7b0>
8112cc9c:	9080040c 	andi	r2,r18,16
8112cca0:	10016926 	beq	r2,zero,8112d248 <___svfiprintf_internal_r+0xf60>
8112cca4:	dac02317 	ldw	r11,140(sp)
8112cca8:	d8001d85 	stb	zero,118(sp)
8112ccac:	0013883a 	mov	r9,zero
8112ccb0:	58800104 	addi	r2,r11,4
8112ccb4:	5f000017 	ldw	fp,0(r11)
8112ccb8:	80016b16 	blt	r16,zero,8112d268 <___svfiprintf_internal_r+0xf80>
8112ccbc:	00ffdfc4 	movi	r3,-129
8112ccc0:	d8802315 	stw	r2,140(sp)
8112ccc4:	90e4703a 	and	r18,r18,r3
8112ccc8:	e03ec41e 	bne	fp,zero,8112c7dc <__reset+0xfb10c7dc>
8112cccc:	0015883a 	mov	r10,zero
8112ccd0:	8001c226 	beq	r16,zero,8112d3dc <___svfiprintf_internal_r+0x10f4>
8112ccd4:	0039883a 	mov	fp,zero
8112ccd8:	0013883a 	mov	r9,zero
8112ccdc:	003ec006 	br	8112c7e0 <__reset+0xfb10c7e0>
8112cce0:	d8c01c17 	ldw	r3,112(sp)
8112cce4:	d8801b17 	ldw	r2,108(sp)
8112cce8:	d9001d87 	ldb	r4,118(sp)
8112ccec:	20000b26 	beq	r4,zero,8112cd1c <___svfiprintf_internal_r+0xa34>
8112ccf0:	d9001d84 	addi	r4,sp,118
8112ccf4:	18c00044 	addi	r3,r3,1
8112ccf8:	10800044 	addi	r2,r2,1
8112ccfc:	41000015 	stw	r4,0(r8)
8112cd00:	01000044 	movi	r4,1
8112cd04:	41000115 	stw	r4,4(r8)
8112cd08:	d8c01c15 	stw	r3,112(sp)
8112cd0c:	d8801b15 	stw	r2,108(sp)
8112cd10:	010001c4 	movi	r4,7
8112cd14:	2080e116 	blt	r4,r2,8112d09c <___svfiprintf_internal_r+0xdb4>
8112cd18:	42000204 	addi	r8,r8,8
8112cd1c:	dac02217 	ldw	r11,136(sp)
8112cd20:	58000b26 	beq	r11,zero,8112cd50 <___svfiprintf_internal_r+0xa68>
8112cd24:	d9001d04 	addi	r4,sp,116
8112cd28:	18c00084 	addi	r3,r3,2
8112cd2c:	10800044 	addi	r2,r2,1
8112cd30:	41000015 	stw	r4,0(r8)
8112cd34:	01000084 	movi	r4,2
8112cd38:	41000115 	stw	r4,4(r8)
8112cd3c:	d8c01c15 	stw	r3,112(sp)
8112cd40:	d8801b15 	stw	r2,108(sp)
8112cd44:	010001c4 	movi	r4,7
8112cd48:	2080dd16 	blt	r4,r2,8112d0c0 <___svfiprintf_internal_r+0xdd8>
8112cd4c:	42000204 	addi	r8,r8,8
8112cd50:	dac02617 	ldw	r11,152(sp)
8112cd54:	01002004 	movi	r4,128
8112cd58:	59008426 	beq	r11,r4,8112cf6c <___svfiprintf_internal_r+0xc84>
8112cd5c:	dac02117 	ldw	r11,132(sp)
8112cd60:	82e1c83a 	sub	r16,r16,r11
8112cd64:	0400270e 	bge	zero,r16,8112ce04 <___svfiprintf_internal_r+0xb1c>
8112cd68:	01c00404 	movi	r7,16
8112cd6c:	3c016a0e 	bge	r7,r16,8112d318 <___svfiprintf_internal_r+0x1030>
8112cd70:	01604574 	movhi	r5,33045
8112cd74:	29741e04 	addi	r5,r5,-12168
8112cd78:	d9402215 	stw	r5,136(sp)
8112cd7c:	070001c4 	movi	fp,7
8112cd80:	00000306 	br	8112cd90 <___svfiprintf_internal_r+0xaa8>
8112cd84:	843ffc04 	addi	r16,r16,-16
8112cd88:	42000204 	addi	r8,r8,8
8112cd8c:	3c00130e 	bge	r7,r16,8112cddc <___svfiprintf_internal_r+0xaf4>
8112cd90:	18c00404 	addi	r3,r3,16
8112cd94:	10800044 	addi	r2,r2,1
8112cd98:	45000015 	stw	r20,0(r8)
8112cd9c:	41c00115 	stw	r7,4(r8)
8112cda0:	d8c01c15 	stw	r3,112(sp)
8112cda4:	d8801b15 	stw	r2,108(sp)
8112cda8:	e0bff60e 	bge	fp,r2,8112cd84 <__reset+0xfb10cd84>
8112cdac:	d9801a04 	addi	r6,sp,104
8112cdb0:	b80b883a 	mov	r5,r23
8112cdb4:	a809883a 	mov	r4,r21
8112cdb8:	d9c02c15 	stw	r7,176(sp)
8112cdbc:	112c1100 	call	8112c110 <__ssprint_r>
8112cdc0:	d9c02c17 	ldw	r7,176(sp)
8112cdc4:	1000581e 	bne	r2,zero,8112cf28 <___svfiprintf_internal_r+0xc40>
8112cdc8:	843ffc04 	addi	r16,r16,-16
8112cdcc:	d8c01c17 	ldw	r3,112(sp)
8112cdd0:	d8801b17 	ldw	r2,108(sp)
8112cdd4:	d811883a 	mov	r8,sp
8112cdd8:	3c3fed16 	blt	r7,r16,8112cd90 <__reset+0xfb10cd90>
8112cddc:	dac02217 	ldw	r11,136(sp)
8112cde0:	1c07883a 	add	r3,r3,r16
8112cde4:	10800044 	addi	r2,r2,1
8112cde8:	42c00015 	stw	r11,0(r8)
8112cdec:	44000115 	stw	r16,4(r8)
8112cdf0:	d8c01c15 	stw	r3,112(sp)
8112cdf4:	d8801b15 	stw	r2,108(sp)
8112cdf8:	010001c4 	movi	r4,7
8112cdfc:	20809e16 	blt	r4,r2,8112d078 <___svfiprintf_internal_r+0xd90>
8112ce00:	42000204 	addi	r8,r8,8
8112ce04:	dac02117 	ldw	r11,132(sp)
8112ce08:	10800044 	addi	r2,r2,1
8112ce0c:	44400015 	stw	r17,0(r8)
8112ce10:	58c7883a 	add	r3,r11,r3
8112ce14:	42c00115 	stw	r11,4(r8)
8112ce18:	d8c01c15 	stw	r3,112(sp)
8112ce1c:	d8801b15 	stw	r2,108(sp)
8112ce20:	010001c4 	movi	r4,7
8112ce24:	20807f16 	blt	r4,r2,8112d024 <___svfiprintf_internal_r+0xd3c>
8112ce28:	42000204 	addi	r8,r8,8
8112ce2c:	9480010c 	andi	r18,r18,4
8112ce30:	90002926 	beq	r18,zero,8112ced8 <___svfiprintf_internal_r+0xbf0>
8112ce34:	dac02417 	ldw	r11,144(sp)
8112ce38:	d8802017 	ldw	r2,128(sp)
8112ce3c:	58a1c83a 	sub	r16,r11,r2
8112ce40:	0400250e 	bge	zero,r16,8112ced8 <___svfiprintf_internal_r+0xbf0>
8112ce44:	04400404 	movi	r17,16
8112ce48:	d8801b17 	ldw	r2,108(sp)
8112ce4c:	8c017c0e 	bge	r17,r16,8112d440 <___svfiprintf_internal_r+0x1158>
8112ce50:	01604574 	movhi	r5,33045
8112ce54:	29742204 	addi	r5,r5,-12152
8112ce58:	d9402815 	stw	r5,160(sp)
8112ce5c:	048001c4 	movi	r18,7
8112ce60:	00000306 	br	8112ce70 <___svfiprintf_internal_r+0xb88>
8112ce64:	843ffc04 	addi	r16,r16,-16
8112ce68:	42000204 	addi	r8,r8,8
8112ce6c:	8c00110e 	bge	r17,r16,8112ceb4 <___svfiprintf_internal_r+0xbcc>
8112ce70:	18c00404 	addi	r3,r3,16
8112ce74:	10800044 	addi	r2,r2,1
8112ce78:	45800015 	stw	r22,0(r8)
8112ce7c:	44400115 	stw	r17,4(r8)
8112ce80:	d8c01c15 	stw	r3,112(sp)
8112ce84:	d8801b15 	stw	r2,108(sp)
8112ce88:	90bff60e 	bge	r18,r2,8112ce64 <__reset+0xfb10ce64>
8112ce8c:	d9801a04 	addi	r6,sp,104
8112ce90:	b80b883a 	mov	r5,r23
8112ce94:	a809883a 	mov	r4,r21
8112ce98:	112c1100 	call	8112c110 <__ssprint_r>
8112ce9c:	1000221e 	bne	r2,zero,8112cf28 <___svfiprintf_internal_r+0xc40>
8112cea0:	843ffc04 	addi	r16,r16,-16
8112cea4:	d8c01c17 	ldw	r3,112(sp)
8112cea8:	d8801b17 	ldw	r2,108(sp)
8112ceac:	d811883a 	mov	r8,sp
8112ceb0:	8c3fef16 	blt	r17,r16,8112ce70 <__reset+0xfb10ce70>
8112ceb4:	dac02817 	ldw	r11,160(sp)
8112ceb8:	1c07883a 	add	r3,r3,r16
8112cebc:	10800044 	addi	r2,r2,1
8112cec0:	42c00015 	stw	r11,0(r8)
8112cec4:	44000115 	stw	r16,4(r8)
8112cec8:	d8c01c15 	stw	r3,112(sp)
8112cecc:	d8801b15 	stw	r2,108(sp)
8112ced0:	010001c4 	movi	r4,7
8112ced4:	2080aa16 	blt	r4,r2,8112d180 <___svfiprintf_internal_r+0xe98>
8112ced8:	d8802417 	ldw	r2,144(sp)
8112cedc:	dac02017 	ldw	r11,128(sp)
8112cee0:	12c0010e 	bge	r2,r11,8112cee8 <___svfiprintf_internal_r+0xc00>
8112cee4:	5805883a 	mov	r2,r11
8112cee8:	dac02517 	ldw	r11,148(sp)
8112ceec:	5897883a 	add	r11,r11,r2
8112cef0:	dac02515 	stw	r11,148(sp)
8112cef4:	1800531e 	bne	r3,zero,8112d044 <___svfiprintf_internal_r+0xd5c>
8112cef8:	98800007 	ldb	r2,0(r19)
8112cefc:	d8001b15 	stw	zero,108(sp)
8112cf00:	d811883a 	mov	r8,sp
8112cf04:	103d231e 	bne	r2,zero,8112c394 <__reset+0xfb10c394>
8112cf08:	9823883a 	mov	r17,r19
8112cf0c:	003d3906 	br	8112c3f4 <__reset+0xfb10c3f4>
8112cf10:	d8801c17 	ldw	r2,112(sp)
8112cf14:	10000426 	beq	r2,zero,8112cf28 <___svfiprintf_internal_r+0xc40>
8112cf18:	d9402717 	ldw	r5,156(sp)
8112cf1c:	d9002a17 	ldw	r4,168(sp)
8112cf20:	d9801a04 	addi	r6,sp,104
8112cf24:	112c1100 	call	8112c110 <__ssprint_r>
8112cf28:	dac02717 	ldw	r11,156(sp)
8112cf2c:	d8802517 	ldw	r2,148(sp)
8112cf30:	58c0030b 	ldhu	r3,12(r11)
8112cf34:	18c0100c 	andi	r3,r3,64
8112cf38:	1801381e 	bne	r3,zero,8112d41c <___svfiprintf_internal_r+0x1134>
8112cf3c:	dfc03717 	ldw	ra,220(sp)
8112cf40:	df003617 	ldw	fp,216(sp)
8112cf44:	ddc03517 	ldw	r23,212(sp)
8112cf48:	dd803417 	ldw	r22,208(sp)
8112cf4c:	dd403317 	ldw	r21,204(sp)
8112cf50:	dd003217 	ldw	r20,200(sp)
8112cf54:	dcc03117 	ldw	r19,196(sp)
8112cf58:	dc803017 	ldw	r18,192(sp)
8112cf5c:	dc402f17 	ldw	r17,188(sp)
8112cf60:	dc002e17 	ldw	r16,184(sp)
8112cf64:	dec03804 	addi	sp,sp,224
8112cf68:	f800283a 	ret
8112cf6c:	dac02417 	ldw	r11,144(sp)
8112cf70:	d9002017 	ldw	r4,128(sp)
8112cf74:	5939c83a 	sub	fp,r11,r4
8112cf78:	073f780e 	bge	zero,fp,8112cd5c <__reset+0xfb10cd5c>
8112cf7c:	02400404 	movi	r9,16
8112cf80:	4f01370e 	bge	r9,fp,8112d460 <___svfiprintf_internal_r+0x1178>
8112cf84:	02e04574 	movhi	r11,33045
8112cf88:	5af41e04 	addi	r11,r11,-12168
8112cf8c:	dac02215 	stw	r11,136(sp)
8112cf90:	028001c4 	movi	r10,7
8112cf94:	00000306 	br	8112cfa4 <___svfiprintf_internal_r+0xcbc>
8112cf98:	e73ffc04 	addi	fp,fp,-16
8112cf9c:	42000204 	addi	r8,r8,8
8112cfa0:	4f00150e 	bge	r9,fp,8112cff8 <___svfiprintf_internal_r+0xd10>
8112cfa4:	18c00404 	addi	r3,r3,16
8112cfa8:	10800044 	addi	r2,r2,1
8112cfac:	45000015 	stw	r20,0(r8)
8112cfb0:	42400115 	stw	r9,4(r8)
8112cfb4:	d8c01c15 	stw	r3,112(sp)
8112cfb8:	d8801b15 	stw	r2,108(sp)
8112cfbc:	50bff60e 	bge	r10,r2,8112cf98 <__reset+0xfb10cf98>
8112cfc0:	d9801a04 	addi	r6,sp,104
8112cfc4:	b80b883a 	mov	r5,r23
8112cfc8:	a809883a 	mov	r4,r21
8112cfcc:	da402c15 	stw	r9,176(sp)
8112cfd0:	da802d15 	stw	r10,180(sp)
8112cfd4:	112c1100 	call	8112c110 <__ssprint_r>
8112cfd8:	da402c17 	ldw	r9,176(sp)
8112cfdc:	da802d17 	ldw	r10,180(sp)
8112cfe0:	103fd11e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112cfe4:	e73ffc04 	addi	fp,fp,-16
8112cfe8:	d8c01c17 	ldw	r3,112(sp)
8112cfec:	d8801b17 	ldw	r2,108(sp)
8112cff0:	d811883a 	mov	r8,sp
8112cff4:	4f3feb16 	blt	r9,fp,8112cfa4 <__reset+0xfb10cfa4>
8112cff8:	dac02217 	ldw	r11,136(sp)
8112cffc:	1f07883a 	add	r3,r3,fp
8112d000:	10800044 	addi	r2,r2,1
8112d004:	42c00015 	stw	r11,0(r8)
8112d008:	47000115 	stw	fp,4(r8)
8112d00c:	d8c01c15 	stw	r3,112(sp)
8112d010:	d8801b15 	stw	r2,108(sp)
8112d014:	010001c4 	movi	r4,7
8112d018:	2080b616 	blt	r4,r2,8112d2f4 <___svfiprintf_internal_r+0x100c>
8112d01c:	42000204 	addi	r8,r8,8
8112d020:	003f4e06 	br	8112cd5c <__reset+0xfb10cd5c>
8112d024:	d9801a04 	addi	r6,sp,104
8112d028:	b80b883a 	mov	r5,r23
8112d02c:	a809883a 	mov	r4,r21
8112d030:	112c1100 	call	8112c110 <__ssprint_r>
8112d034:	103fbc1e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112d038:	d8c01c17 	ldw	r3,112(sp)
8112d03c:	d811883a 	mov	r8,sp
8112d040:	003f7a06 	br	8112ce2c <__reset+0xfb10ce2c>
8112d044:	d9801a04 	addi	r6,sp,104
8112d048:	b80b883a 	mov	r5,r23
8112d04c:	a809883a 	mov	r4,r21
8112d050:	112c1100 	call	8112c110 <__ssprint_r>
8112d054:	103fa826 	beq	r2,zero,8112cef8 <__reset+0xfb10cef8>
8112d058:	003fb306 	br	8112cf28 <__reset+0xfb10cf28>
8112d05c:	d9801a04 	addi	r6,sp,104
8112d060:	b80b883a 	mov	r5,r23
8112d064:	a809883a 	mov	r4,r21
8112d068:	112c1100 	call	8112c110 <__ssprint_r>
8112d06c:	103fae1e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112d070:	d811883a 	mov	r8,sp
8112d074:	003cdc06 	br	8112c3e8 <__reset+0xfb10c3e8>
8112d078:	d9801a04 	addi	r6,sp,104
8112d07c:	b80b883a 	mov	r5,r23
8112d080:	a809883a 	mov	r4,r21
8112d084:	112c1100 	call	8112c110 <__ssprint_r>
8112d088:	103fa71e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112d08c:	d8c01c17 	ldw	r3,112(sp)
8112d090:	d8801b17 	ldw	r2,108(sp)
8112d094:	d811883a 	mov	r8,sp
8112d098:	003f5a06 	br	8112ce04 <__reset+0xfb10ce04>
8112d09c:	d9801a04 	addi	r6,sp,104
8112d0a0:	b80b883a 	mov	r5,r23
8112d0a4:	a809883a 	mov	r4,r21
8112d0a8:	112c1100 	call	8112c110 <__ssprint_r>
8112d0ac:	103f9e1e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112d0b0:	d8c01c17 	ldw	r3,112(sp)
8112d0b4:	d8801b17 	ldw	r2,108(sp)
8112d0b8:	d811883a 	mov	r8,sp
8112d0bc:	003f1706 	br	8112cd1c <__reset+0xfb10cd1c>
8112d0c0:	d9801a04 	addi	r6,sp,104
8112d0c4:	b80b883a 	mov	r5,r23
8112d0c8:	a809883a 	mov	r4,r21
8112d0cc:	112c1100 	call	8112c110 <__ssprint_r>
8112d0d0:	103f951e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112d0d4:	d8c01c17 	ldw	r3,112(sp)
8112d0d8:	d8801b17 	ldw	r2,108(sp)
8112d0dc:	d811883a 	mov	r8,sp
8112d0e0:	003f1b06 	br	8112cd50 <__reset+0xfb10cd50>
8112d0e4:	d8001d85 	stb	zero,118(sp)
8112d0e8:	80007b16 	blt	r16,zero,8112d2d8 <___svfiprintf_internal_r+0xff0>
8112d0ec:	00ffdfc4 	movi	r3,-129
8112d0f0:	e244b03a 	or	r2,fp,r9
8112d0f4:	90e4703a 	and	r18,r18,r3
8112d0f8:	103d7026 	beq	r2,zero,8112c6bc <__reset+0xfb10c6bc>
8112d0fc:	0015883a 	mov	r10,zero
8112d100:	003d7206 	br	8112c6cc <__reset+0xfb10c6cc>
8112d104:	d9801a04 	addi	r6,sp,104
8112d108:	b80b883a 	mov	r5,r23
8112d10c:	a809883a 	mov	r4,r21
8112d110:	112c1100 	call	8112c110 <__ssprint_r>
8112d114:	103f841e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112d118:	d8c01c17 	ldw	r3,112(sp)
8112d11c:	d8801b17 	ldw	r2,108(sp)
8112d120:	d811883a 	mov	r8,sp
8112d124:	003ef006 	br	8112cce8 <__reset+0xfb10cce8>
8112d128:	9080100c 	andi	r2,r18,64
8112d12c:	d8001d85 	stb	zero,118(sp)
8112d130:	dac02317 	ldw	r11,140(sp)
8112d134:	10008126 	beq	r2,zero,8112d33c <___svfiprintf_internal_r+0x1054>
8112d138:	58800104 	addi	r2,r11,4
8112d13c:	5f00000b 	ldhu	fp,0(r11)
8112d140:	0013883a 	mov	r9,zero
8112d144:	803ec30e 	bge	r16,zero,8112cc54 <__reset+0xfb10cc54>
8112d148:	d8802315 	stw	r2,140(sp)
8112d14c:	0015883a 	mov	r10,zero
8112d150:	e244b03a 	or	r2,fp,r9
8112d154:	103e371e 	bne	r2,zero,8112ca34 <__reset+0xfb10ca34>
8112d158:	00800044 	movi	r2,1
8112d15c:	10803fcc 	andi	r2,r2,255
8112d160:	00c00044 	movi	r3,1
8112d164:	10c06126 	beq	r2,r3,8112d2ec <___svfiprintf_internal_r+0x1004>
8112d168:	00c00084 	movi	r3,2
8112d16c:	10fd5526 	beq	r2,r3,8112c6c4 <__reset+0xfb10c6c4>
8112d170:	003ed806 	br	8112ccd4 <__reset+0xfb10ccd4>
8112d174:	d8802315 	stw	r2,140(sp)
8112d178:	98c00007 	ldb	r3,0(r19)
8112d17c:	003cab06 	br	8112c42c <__reset+0xfb10c42c>
8112d180:	d9801a04 	addi	r6,sp,104
8112d184:	b80b883a 	mov	r5,r23
8112d188:	a809883a 	mov	r4,r21
8112d18c:	112c1100 	call	8112c110 <__ssprint_r>
8112d190:	103f651e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112d194:	d8c01c17 	ldw	r3,112(sp)
8112d198:	003f4f06 	br	8112ced8 <__reset+0xfb10ced8>
8112d19c:	00a04574 	movhi	r2,33045
8112d1a0:	10b39404 	addi	r2,r2,-12720
8112d1a4:	d8802915 	stw	r2,164(sp)
8112d1a8:	003d4406 	br	8112c6bc <__reset+0xfb10c6bc>
8112d1ac:	dac02317 	ldw	r11,140(sp)
8112d1b0:	58800017 	ldw	r2,0(r11)
8112d1b4:	dac02517 	ldw	r11,148(sp)
8112d1b8:	5807d7fa 	srai	r3,r11,31
8112d1bc:	dac02317 	ldw	r11,140(sp)
8112d1c0:	10c00115 	stw	r3,4(r2)
8112d1c4:	5ac00104 	addi	r11,r11,4
8112d1c8:	dac02315 	stw	r11,140(sp)
8112d1cc:	dac02517 	ldw	r11,148(sp)
8112d1d0:	12c00015 	stw	r11,0(r2)
8112d1d4:	003c6d06 	br	8112c38c <__reset+0xfb10c38c>
8112d1d8:	9080100c 	andi	r2,r18,64
8112d1dc:	dac02317 	ldw	r11,140(sp)
8112d1e0:	103e5326 	beq	r2,zero,8112cb30 <__reset+0xfb10cb30>
8112d1e4:	5f00000f 	ldh	fp,0(r11)
8112d1e8:	5ac00104 	addi	r11,r11,4
8112d1ec:	dac02315 	stw	r11,140(sp)
8112d1f0:	e013d7fa 	srai	r9,fp,31
8112d1f4:	4805883a 	mov	r2,r9
8112d1f8:	003e0706 	br	8112ca18 <__reset+0xfb10ca18>
8112d1fc:	00800c04 	movi	r2,48
8112d200:	d8801d05 	stb	r2,116(sp)
8112d204:	d8c01d45 	stb	r3,117(sp)
8112d208:	d8001d85 	stb	zero,118(sp)
8112d20c:	90800094 	ori	r2,r18,2
8112d210:	80008f16 	blt	r16,zero,8112d450 <___svfiprintf_internal_r+0x1168>
8112d214:	00bfdfc4 	movi	r2,-129
8112d218:	90a4703a 	and	r18,r18,r2
8112d21c:	94800094 	ori	r18,r18,2
8112d220:	0015883a 	mov	r10,zero
8112d224:	003d2906 	br	8112c6cc <__reset+0xfb10c6cc>
8112d228:	98c00007 	ldb	r3,0(r19)
8112d22c:	003c7f06 	br	8112c42c <__reset+0xfb10c42c>
8112d230:	dac02317 	ldw	r11,140(sp)
8112d234:	0013883a 	mov	r9,zero
8112d238:	5f000017 	ldw	fp,0(r11)
8112d23c:	5ac00104 	addi	r11,r11,4
8112d240:	dac02315 	stw	r11,140(sp)
8112d244:	003d1506 	br	8112c69c <__reset+0xfb10c69c>
8112d248:	9080100c 	andi	r2,r18,64
8112d24c:	d8001d85 	stb	zero,118(sp)
8112d250:	dac02317 	ldw	r11,140(sp)
8112d254:	10003426 	beq	r2,zero,8112d328 <___svfiprintf_internal_r+0x1040>
8112d258:	58800104 	addi	r2,r11,4
8112d25c:	5f00000b 	ldhu	fp,0(r11)
8112d260:	0013883a 	mov	r9,zero
8112d264:	803e950e 	bge	r16,zero,8112ccbc <__reset+0xfb10ccbc>
8112d268:	e246b03a 	or	r3,fp,r9
8112d26c:	d8802315 	stw	r2,140(sp)
8112d270:	183d5a1e 	bne	r3,zero,8112c7dc <__reset+0xfb10c7dc>
8112d274:	0015883a 	mov	r10,zero
8112d278:	0005883a 	mov	r2,zero
8112d27c:	003fb706 	br	8112d15c <__reset+0xfb10d15c>
8112d280:	98c00043 	ldbu	r3,1(r19)
8112d284:	94800814 	ori	r18,r18,32
8112d288:	9cc00044 	addi	r19,r19,1
8112d28c:	18c03fcc 	andi	r3,r3,255
8112d290:	18c0201c 	xori	r3,r3,128
8112d294:	18ffe004 	addi	r3,r3,-128
8112d298:	003c6406 	br	8112c42c <__reset+0xfb10c42c>
8112d29c:	d8c02315 	stw	r3,140(sp)
8112d2a0:	0015883a 	mov	r10,zero
8112d2a4:	003faa06 	br	8112d150 <__reset+0xfb10d150>
8112d2a8:	dac02317 	ldw	r11,140(sp)
8112d2ac:	58800017 	ldw	r2,0(r11)
8112d2b0:	5ac00104 	addi	r11,r11,4
8112d2b4:	dac02315 	stw	r11,140(sp)
8112d2b8:	dac02517 	ldw	r11,148(sp)
8112d2bc:	12c00015 	stw	r11,0(r2)
8112d2c0:	003c3206 	br	8112c38c <__reset+0xfb10c38c>
8112d2c4:	01204574 	movhi	r4,33045
8112d2c8:	21339404 	addi	r4,r4,-12720
8112d2cc:	d9002915 	stw	r4,164(sp)
8112d2d0:	d8c02315 	stw	r3,140(sp)
8112d2d4:	1025883a 	mov	r18,r2
8112d2d8:	e244b03a 	or	r2,fp,r9
8112d2dc:	103f871e 	bne	r2,zero,8112d0fc <__reset+0xfb10d0fc>
8112d2e0:	0015883a 	mov	r10,zero
8112d2e4:	00800084 	movi	r2,2
8112d2e8:	003f9c06 	br	8112d15c <__reset+0xfb10d15c>
8112d2ec:	0039883a 	mov	fp,zero
8112d2f0:	003e5f06 	br	8112cc70 <__reset+0xfb10cc70>
8112d2f4:	d9801a04 	addi	r6,sp,104
8112d2f8:	b80b883a 	mov	r5,r23
8112d2fc:	a809883a 	mov	r4,r21
8112d300:	112c1100 	call	8112c110 <__ssprint_r>
8112d304:	103f081e 	bne	r2,zero,8112cf28 <__reset+0xfb10cf28>
8112d308:	d8c01c17 	ldw	r3,112(sp)
8112d30c:	d8801b17 	ldw	r2,108(sp)
8112d310:	d811883a 	mov	r8,sp
8112d314:	003e9106 	br	8112cd5c <__reset+0xfb10cd5c>
8112d318:	01204574 	movhi	r4,33045
8112d31c:	21341e04 	addi	r4,r4,-12168
8112d320:	d9002215 	stw	r4,136(sp)
8112d324:	003ead06 	br	8112cddc <__reset+0xfb10cddc>
8112d328:	58800104 	addi	r2,r11,4
8112d32c:	5f000017 	ldw	fp,0(r11)
8112d330:	0013883a 	mov	r9,zero
8112d334:	803e610e 	bge	r16,zero,8112ccbc <__reset+0xfb10ccbc>
8112d338:	003fcb06 	br	8112d268 <__reset+0xfb10d268>
8112d33c:	58800104 	addi	r2,r11,4
8112d340:	5f000017 	ldw	fp,0(r11)
8112d344:	0013883a 	mov	r9,zero
8112d348:	803e420e 	bge	r16,zero,8112cc54 <__reset+0xfb10cc54>
8112d34c:	003f7e06 	br	8112d148 <__reset+0xfb10d148>
8112d350:	5f000017 	ldw	fp,0(r11)
8112d354:	5ac00104 	addi	r11,r11,4
8112d358:	0013883a 	mov	r9,zero
8112d35c:	dac02315 	stw	r11,140(sp)
8112d360:	003cce06 	br	8112c69c <__reset+0xfb10c69c>
8112d364:	8809883a 	mov	r4,r17
8112d368:	da002c15 	stw	r8,176(sp)
8112d36c:	111f1b80 	call	8111f1b8 <strlen>
8112d370:	d8802115 	stw	r2,132(sp)
8112d374:	da801d83 	ldbu	r10,118(sp)
8112d378:	df002315 	stw	fp,140(sp)
8112d37c:	0021883a 	mov	r16,zero
8112d380:	da002c17 	ldw	r8,176(sp)
8112d384:	003cf606 	br	8112c760 <__reset+0xfb10c760>
8112d388:	00800184 	movi	r2,6
8112d38c:	1400012e 	bgeu	r2,r16,8112d394 <___svfiprintf_internal_r+0x10ac>
8112d390:	1021883a 	mov	r16,r2
8112d394:	dc002115 	stw	r16,132(sp)
8112d398:	8005883a 	mov	r2,r16
8112d39c:	80003c16 	blt	r16,zero,8112d490 <___svfiprintf_internal_r+0x11a8>
8112d3a0:	04604574 	movhi	r17,33045
8112d3a4:	d8802015 	stw	r2,128(sp)
8112d3a8:	df002315 	stw	fp,140(sp)
8112d3ac:	8c739904 	addi	r17,r17,-12700
8112d3b0:	003d2e06 	br	8112c86c <__reset+0xfb10c86c>
8112d3b4:	04001004 	movi	r16,64
8112d3b8:	800b883a 	mov	r5,r16
8112d3bc:	111deb00 	call	8111deb0 <_malloc_r>
8112d3c0:	dac02717 	ldw	r11,156(sp)
8112d3c4:	58800015 	stw	r2,0(r11)
8112d3c8:	58800415 	stw	r2,16(r11)
8112d3cc:	10004826 	beq	r2,zero,8112d4f0 <___svfiprintf_internal_r+0x1208>
8112d3d0:	dac02717 	ldw	r11,156(sp)
8112d3d4:	5c000515 	stw	r16,20(r11)
8112d3d8:	003bd906 	br	8112c340 <__reset+0xfb10c340>
8112d3dc:	9080004c 	andi	r2,r18,1
8112d3e0:	0015883a 	mov	r10,zero
8112d3e4:	10000626 	beq	r2,zero,8112d400 <___svfiprintf_internal_r+0x1118>
8112d3e8:	dac02b17 	ldw	r11,172(sp)
8112d3ec:	00800c04 	movi	r2,48
8112d3f0:	d88019c5 	stb	r2,103(sp)
8112d3f4:	dac02115 	stw	r11,132(sp)
8112d3f8:	dc4019c4 	addi	r17,sp,103
8112d3fc:	003cd806 	br	8112c760 <__reset+0xfb10c760>
8112d400:	d8002115 	stw	zero,132(sp)
8112d404:	dc401a04 	addi	r17,sp,104
8112d408:	003cd506 	br	8112c760 <__reset+0xfb10c760>
8112d40c:	01204574 	movhi	r4,33045
8112d410:	21342204 	addi	r4,r4,-12152
8112d414:	d9002815 	stw	r4,160(sp)
8112d418:	003d4306 	br	8112c928 <__reset+0xfb10c928>
8112d41c:	00bfffc4 	movi	r2,-1
8112d420:	003ec606 	br	8112cf3c <__reset+0xfb10cf3c>
8112d424:	00800044 	movi	r2,1
8112d428:	10803fcc 	andi	r2,r2,255
8112d42c:	00c00044 	movi	r3,1
8112d430:	10fd8026 	beq	r2,r3,8112ca34 <__reset+0xfb10ca34>
8112d434:	00c00084 	movi	r3,2
8112d438:	10fca426 	beq	r2,r3,8112c6cc <__reset+0xfb10c6cc>
8112d43c:	003ce806 	br	8112c7e0 <__reset+0xfb10c7e0>
8112d440:	01204574 	movhi	r4,33045
8112d444:	21342204 	addi	r4,r4,-12152
8112d448:	d9002815 	stw	r4,160(sp)
8112d44c:	003e9906 	br	8112ceb4 <__reset+0xfb10ceb4>
8112d450:	1025883a 	mov	r18,r2
8112d454:	0015883a 	mov	r10,zero
8112d458:	00800084 	movi	r2,2
8112d45c:	003ff206 	br	8112d428 <__reset+0xfb10d428>
8112d460:	01604574 	movhi	r5,33045
8112d464:	29741e04 	addi	r5,r5,-12168
8112d468:	d9402215 	stw	r5,136(sp)
8112d46c:	003ee206 	br	8112cff8 <__reset+0xfb10cff8>
8112d470:	5827883a 	mov	r19,r11
8112d474:	0021883a 	mov	r16,zero
8112d478:	003bed06 	br	8112c430 <__reset+0xfb10c430>
8112d47c:	dc002115 	stw	r16,132(sp)
8112d480:	da801d83 	ldbu	r10,118(sp)
8112d484:	df002315 	stw	fp,140(sp)
8112d488:	0021883a 	mov	r16,zero
8112d48c:	003cb406 	br	8112c760 <__reset+0xfb10c760>
8112d490:	0005883a 	mov	r2,zero
8112d494:	003fc206 	br	8112d3a0 <__reset+0xfb10d3a0>
8112d498:	d8802317 	ldw	r2,140(sp)
8112d49c:	98c00043 	ldbu	r3,1(r19)
8112d4a0:	5827883a 	mov	r19,r11
8112d4a4:	14000017 	ldw	r16,0(r2)
8112d4a8:	10800104 	addi	r2,r2,4
8112d4ac:	d8802315 	stw	r2,140(sp)
8112d4b0:	803f760e 	bge	r16,zero,8112d28c <__reset+0xfb10d28c>
8112d4b4:	18c03fcc 	andi	r3,r3,255
8112d4b8:	18c0201c 	xori	r3,r3,128
8112d4bc:	043fffc4 	movi	r16,-1
8112d4c0:	18ffe004 	addi	r3,r3,-128
8112d4c4:	003bd906 	br	8112c42c <__reset+0xfb10c42c>
8112d4c8:	d9c01d85 	stb	r7,118(sp)
8112d4cc:	003cb606 	br	8112c7a8 <__reset+0xfb10c7a8>
8112d4d0:	d9c01d85 	stb	r7,118(sp)
8112d4d4:	003d2106 	br	8112c95c <__reset+0xfb10c95c>
8112d4d8:	d9c01d85 	stb	r7,118(sp)
8112d4dc:	003d8e06 	br	8112cb18 <__reset+0xfb10cb18>
8112d4e0:	d9c01d85 	stb	r7,118(sp)
8112d4e4:	003db306 	br	8112cbb4 <__reset+0xfb10cbb4>
8112d4e8:	d9c01d85 	stb	r7,118(sp)
8112d4ec:	003c8a06 	br	8112c718 <__reset+0xfb10c718>
8112d4f0:	dac02a17 	ldw	r11,168(sp)
8112d4f4:	00800304 	movi	r2,12
8112d4f8:	58800015 	stw	r2,0(r11)
8112d4fc:	00bfffc4 	movi	r2,-1
8112d500:	003e8e06 	br	8112cf3c <__reset+0xfb10cf3c>
8112d504:	d9c01d85 	stb	r7,118(sp)
8112d508:	003dc706 	br	8112cc28 <__reset+0xfb10cc28>
8112d50c:	d9c01d85 	stb	r7,118(sp)
8112d510:	003ddf06 	br	8112cc90 <__reset+0xfb10cc90>
8112d514:	d9c01d85 	stb	r7,118(sp)
8112d518:	003d3706 	br	8112c9f8 <__reset+0xfb10c9f8>
8112d51c:	d9c01d85 	stb	r7,118(sp)
8112d520:	003c5406 	br	8112c674 <__reset+0xfb10c674>
8112d524:	d9c01d85 	stb	r7,118(sp)
8112d528:	003d1d06 	br	8112c9a0 <__reset+0xfb10c9a0>

8112d52c <__submore>:
8112d52c:	defffa04 	addi	sp,sp,-24
8112d530:	de00012e 	bgeu	sp,et,8112d538 <__submore+0xc>
8112d534:	003b68fa 	trap	3
8112d538:	dc000015 	stw	r16,0(sp)
8112d53c:	2821883a 	mov	r16,r5
8112d540:	29400c17 	ldw	r5,48(r5)
8112d544:	dfc00515 	stw	ra,20(sp)
8112d548:	dd000415 	stw	r20,16(sp)
8112d54c:	dcc00315 	stw	r19,12(sp)
8112d550:	dc800215 	stw	r18,8(sp)
8112d554:	dc400115 	stw	r17,4(sp)
8112d558:	80801004 	addi	r2,r16,64
8112d55c:	28801726 	beq	r5,r2,8112d5bc <__submore+0x90>
8112d560:	84400d17 	ldw	r17,52(r16)
8112d564:	8c67883a 	add	r19,r17,r17
8112d568:	980d883a 	mov	r6,r19
8112d56c:	11299b80 	call	811299b8 <_realloc_r>
8112d570:	1025883a 	mov	r18,r2
8112d574:	10002226 	beq	r2,zero,8112d600 <__submore+0xd4>
8112d578:	1469883a 	add	r20,r2,r17
8112d57c:	880d883a 	mov	r6,r17
8112d580:	100b883a 	mov	r5,r2
8112d584:	a009883a 	mov	r4,r20
8112d588:	111e6c40 	call	8111e6c4 <memcpy>
8112d58c:	0005883a 	mov	r2,zero
8112d590:	85000015 	stw	r20,0(r16)
8112d594:	84800c15 	stw	r18,48(r16)
8112d598:	84c00d15 	stw	r19,52(r16)
8112d59c:	dfc00517 	ldw	ra,20(sp)
8112d5a0:	dd000417 	ldw	r20,16(sp)
8112d5a4:	dcc00317 	ldw	r19,12(sp)
8112d5a8:	dc800217 	ldw	r18,8(sp)
8112d5ac:	dc400117 	ldw	r17,4(sp)
8112d5b0:	dc000017 	ldw	r16,0(sp)
8112d5b4:	dec00604 	addi	sp,sp,24
8112d5b8:	f800283a 	ret
8112d5bc:	04410004 	movi	r17,1024
8112d5c0:	880b883a 	mov	r5,r17
8112d5c4:	111deb00 	call	8111deb0 <_malloc_r>
8112d5c8:	1007883a 	mov	r3,r2
8112d5cc:	10000c26 	beq	r2,zero,8112d600 <__submore+0xd4>
8112d5d0:	80801083 	ldbu	r2,66(r16)
8112d5d4:	80c00c15 	stw	r3,48(r16)
8112d5d8:	84400d15 	stw	r17,52(r16)
8112d5dc:	1880ffc5 	stb	r2,1023(r3)
8112d5e0:	81401043 	ldbu	r5,65(r16)
8112d5e4:	1900ff44 	addi	r4,r3,1021
8112d5e8:	0005883a 	mov	r2,zero
8112d5ec:	1940ff85 	stb	r5,1022(r3)
8112d5f0:	81401003 	ldbu	r5,64(r16)
8112d5f4:	1940ff45 	stb	r5,1021(r3)
8112d5f8:	81000015 	stw	r4,0(r16)
8112d5fc:	003fe706 	br	8112d59c <__reset+0xfb10d59c>
8112d600:	00bfffc4 	movi	r2,-1
8112d604:	003fe506 	br	8112d59c <__reset+0xfb10d59c>

8112d608 <_ungetc_r>:
8112d608:	00bfffc4 	movi	r2,-1
8112d60c:	28806326 	beq	r5,r2,8112d79c <_ungetc_r+0x194>
8112d610:	defffb04 	addi	sp,sp,-20
8112d614:	de00012e 	bgeu	sp,et,8112d61c <_ungetc_r+0x14>
8112d618:	003b68fa 	trap	3
8112d61c:	dcc00315 	stw	r19,12(sp)
8112d620:	dc400115 	stw	r17,4(sp)
8112d624:	dc000015 	stw	r16,0(sp)
8112d628:	dfc00415 	stw	ra,16(sp)
8112d62c:	dc800215 	stw	r18,8(sp)
8112d630:	2023883a 	mov	r17,r4
8112d634:	3021883a 	mov	r16,r6
8112d638:	2827883a 	mov	r19,r5
8112d63c:	20000226 	beq	r4,zero,8112d648 <_ungetc_r+0x40>
8112d640:	20800e17 	ldw	r2,56(r4)
8112d644:	10002e26 	beq	r2,zero,8112d700 <_ungetc_r+0xf8>
8112d648:	80c0030b 	ldhu	r3,12(r16)
8112d64c:	1888000c 	andi	r2,r3,8192
8112d650:	1000051e 	bne	r2,zero,8112d668 <_ungetc_r+0x60>
8112d654:	81001917 	ldw	r4,100(r16)
8112d658:	00b7ffc4 	movi	r2,-8193
8112d65c:	18c80014 	ori	r3,r3,8192
8112d660:	2084703a 	and	r2,r4,r2
8112d664:	80801915 	stw	r2,100(r16)
8112d668:	00bff7c4 	movi	r2,-33
8112d66c:	1884703a 	and	r2,r3,r2
8112d670:	8080030d 	sth	r2,12(r16)
8112d674:	1900010c 	andi	r4,r3,4
8112d678:	2000061e 	bne	r4,zero,8112d694 <_ungetc_r+0x8c>
8112d67c:	1900040c 	andi	r4,r3,16
8112d680:	20001d26 	beq	r4,zero,8112d6f8 <_ungetc_r+0xf0>
8112d684:	18c0020c 	andi	r3,r3,8
8112d688:	1800331e 	bne	r3,zero,8112d758 <_ungetc_r+0x150>
8112d68c:	10800114 	ori	r2,r2,4
8112d690:	8080030d 	sth	r2,12(r16)
8112d694:	80800c17 	ldw	r2,48(r16)
8112d698:	9c803fcc 	andi	r18,r19,255
8112d69c:	10001a26 	beq	r2,zero,8112d708 <_ungetc_r+0x100>
8112d6a0:	80c00117 	ldw	r3,4(r16)
8112d6a4:	80800d17 	ldw	r2,52(r16)
8112d6a8:	18800f0e 	bge	r3,r2,8112d6e8 <_ungetc_r+0xe0>
8112d6ac:	80c00017 	ldw	r3,0(r16)
8112d6b0:	9005883a 	mov	r2,r18
8112d6b4:	193fffc4 	addi	r4,r3,-1
8112d6b8:	81000015 	stw	r4,0(r16)
8112d6bc:	1cffffc5 	stb	r19,-1(r3)
8112d6c0:	80c00117 	ldw	r3,4(r16)
8112d6c4:	18c00044 	addi	r3,r3,1
8112d6c8:	80c00115 	stw	r3,4(r16)
8112d6cc:	dfc00417 	ldw	ra,16(sp)
8112d6d0:	dcc00317 	ldw	r19,12(sp)
8112d6d4:	dc800217 	ldw	r18,8(sp)
8112d6d8:	dc400117 	ldw	r17,4(sp)
8112d6dc:	dc000017 	ldw	r16,0(sp)
8112d6e0:	dec00504 	addi	sp,sp,20
8112d6e4:	f800283a 	ret
8112d6e8:	800b883a 	mov	r5,r16
8112d6ec:	8809883a 	mov	r4,r17
8112d6f0:	112d52c0 	call	8112d52c <__submore>
8112d6f4:	103fed26 	beq	r2,zero,8112d6ac <__reset+0xfb10d6ac>
8112d6f8:	00bfffc4 	movi	r2,-1
8112d6fc:	003ff306 	br	8112d6cc <__reset+0xfb10d6cc>
8112d700:	112748c0 	call	8112748c <__sinit>
8112d704:	003fd006 	br	8112d648 <__reset+0xfb10d648>
8112d708:	80c00417 	ldw	r3,16(r16)
8112d70c:	80800017 	ldw	r2,0(r16)
8112d710:	18000326 	beq	r3,zero,8112d720 <_ungetc_r+0x118>
8112d714:	1880022e 	bgeu	r3,r2,8112d720 <_ungetc_r+0x118>
8112d718:	10ffffc3 	ldbu	r3,-1(r2)
8112d71c:	90c01826 	beq	r18,r3,8112d780 <_ungetc_r+0x178>
8112d720:	81400117 	ldw	r5,4(r16)
8112d724:	80800e15 	stw	r2,56(r16)
8112d728:	008000c4 	movi	r2,3
8112d72c:	81001004 	addi	r4,r16,64
8112d730:	80c01084 	addi	r3,r16,66
8112d734:	80800d15 	stw	r2,52(r16)
8112d738:	00800044 	movi	r2,1
8112d73c:	80800115 	stw	r2,4(r16)
8112d740:	81400f15 	stw	r5,60(r16)
8112d744:	81000c15 	stw	r4,48(r16)
8112d748:	84c01085 	stb	r19,66(r16)
8112d74c:	80c00015 	stw	r3,0(r16)
8112d750:	9005883a 	mov	r2,r18
8112d754:	003fdd06 	br	8112d6cc <__reset+0xfb10d6cc>
8112d758:	800b883a 	mov	r5,r16
8112d75c:	8809883a 	mov	r4,r17
8112d760:	11270900 	call	81127090 <_fflush_r>
8112d764:	103fe41e 	bne	r2,zero,8112d6f8 <__reset+0xfb10d6f8>
8112d768:	8080030b 	ldhu	r2,12(r16)
8112d76c:	00fffdc4 	movi	r3,-9
8112d770:	80000215 	stw	zero,8(r16)
8112d774:	1884703a 	and	r2,r3,r2
8112d778:	80000615 	stw	zero,24(r16)
8112d77c:	003fc306 	br	8112d68c <__reset+0xfb10d68c>
8112d780:	80c00117 	ldw	r3,4(r16)
8112d784:	10bfffc4 	addi	r2,r2,-1
8112d788:	80800015 	stw	r2,0(r16)
8112d78c:	18800044 	addi	r2,r3,1
8112d790:	80800115 	stw	r2,4(r16)
8112d794:	9005883a 	mov	r2,r18
8112d798:	003fcc06 	br	8112d6cc <__reset+0xfb10d6cc>
8112d79c:	00bfffc4 	movi	r2,-1
8112d7a0:	f800283a 	ret

8112d7a4 <ungetc>:
8112d7a4:	00a04574 	movhi	r2,33045
8112d7a8:	10bd6304 	addi	r2,r2,-2676
8112d7ac:	280d883a 	mov	r6,r5
8112d7b0:	200b883a 	mov	r5,r4
8112d7b4:	11000017 	ldw	r4,0(r2)
8112d7b8:	112d6081 	jmpi	8112d608 <_ungetc_r>

8112d7bc <__sprint_r.part.0>:
8112d7bc:	defff604 	addi	sp,sp,-40
8112d7c0:	de00012e 	bgeu	sp,et,8112d7c8 <__sprint_r.part.0+0xc>
8112d7c4:	003b68fa 	trap	3
8112d7c8:	28801917 	ldw	r2,100(r5)
8112d7cc:	dd400515 	stw	r21,20(sp)
8112d7d0:	dfc00915 	stw	ra,36(sp)
8112d7d4:	df000815 	stw	fp,32(sp)
8112d7d8:	ddc00715 	stw	r23,28(sp)
8112d7dc:	dd800615 	stw	r22,24(sp)
8112d7e0:	dd000415 	stw	r20,16(sp)
8112d7e4:	dcc00315 	stw	r19,12(sp)
8112d7e8:	dc800215 	stw	r18,8(sp)
8112d7ec:	dc400115 	stw	r17,4(sp)
8112d7f0:	dc000015 	stw	r16,0(sp)
8112d7f4:	1088000c 	andi	r2,r2,8192
8112d7f8:	302b883a 	mov	r21,r6
8112d7fc:	10002e26 	beq	r2,zero,8112d8b8 <__sprint_r.part.0+0xfc>
8112d800:	30800217 	ldw	r2,8(r6)
8112d804:	35800017 	ldw	r22,0(r6)
8112d808:	10002926 	beq	r2,zero,8112d8b0 <__sprint_r.part.0+0xf4>
8112d80c:	2827883a 	mov	r19,r5
8112d810:	2029883a 	mov	r20,r4
8112d814:	b5c00104 	addi	r23,r22,4
8112d818:	04bfffc4 	movi	r18,-1
8112d81c:	bc400017 	ldw	r17,0(r23)
8112d820:	b4000017 	ldw	r16,0(r22)
8112d824:	0039883a 	mov	fp,zero
8112d828:	8822d0ba 	srli	r17,r17,2
8112d82c:	8800031e 	bne	r17,zero,8112d83c <__sprint_r.part.0+0x80>
8112d830:	00001806 	br	8112d894 <__sprint_r.part.0+0xd8>
8112d834:	84000104 	addi	r16,r16,4
8112d838:	8f001526 	beq	r17,fp,8112d890 <__sprint_r.part.0+0xd4>
8112d83c:	81400017 	ldw	r5,0(r16)
8112d840:	980d883a 	mov	r6,r19
8112d844:	a009883a 	mov	r4,r20
8112d848:	112f1600 	call	8112f160 <_fputwc_r>
8112d84c:	e7000044 	addi	fp,fp,1
8112d850:	14bff81e 	bne	r2,r18,8112d834 <__reset+0xfb10d834>
8112d854:	9005883a 	mov	r2,r18
8112d858:	a8000215 	stw	zero,8(r21)
8112d85c:	a8000115 	stw	zero,4(r21)
8112d860:	dfc00917 	ldw	ra,36(sp)
8112d864:	df000817 	ldw	fp,32(sp)
8112d868:	ddc00717 	ldw	r23,28(sp)
8112d86c:	dd800617 	ldw	r22,24(sp)
8112d870:	dd400517 	ldw	r21,20(sp)
8112d874:	dd000417 	ldw	r20,16(sp)
8112d878:	dcc00317 	ldw	r19,12(sp)
8112d87c:	dc800217 	ldw	r18,8(sp)
8112d880:	dc400117 	ldw	r17,4(sp)
8112d884:	dc000017 	ldw	r16,0(sp)
8112d888:	dec00a04 	addi	sp,sp,40
8112d88c:	f800283a 	ret
8112d890:	a8800217 	ldw	r2,8(r21)
8112d894:	8c63883a 	add	r17,r17,r17
8112d898:	8c63883a 	add	r17,r17,r17
8112d89c:	1445c83a 	sub	r2,r2,r17
8112d8a0:	a8800215 	stw	r2,8(r21)
8112d8a4:	b5800204 	addi	r22,r22,8
8112d8a8:	bdc00204 	addi	r23,r23,8
8112d8ac:	103fdb1e 	bne	r2,zero,8112d81c <__reset+0xfb10d81c>
8112d8b0:	0005883a 	mov	r2,zero
8112d8b4:	003fe806 	br	8112d858 <__reset+0xfb10d858>
8112d8b8:	1127c3c0 	call	81127c3c <__sfvwrite_r>
8112d8bc:	003fe606 	br	8112d858 <__reset+0xfb10d858>

8112d8c0 <__sprint_r>:
8112d8c0:	30c00217 	ldw	r3,8(r6)
8112d8c4:	18000126 	beq	r3,zero,8112d8cc <__sprint_r+0xc>
8112d8c8:	112d7bc1 	jmpi	8112d7bc <__sprint_r.part.0>
8112d8cc:	30000115 	stw	zero,4(r6)
8112d8d0:	0005883a 	mov	r2,zero
8112d8d4:	f800283a 	ret

8112d8d8 <___vfiprintf_internal_r>:
8112d8d8:	deffc904 	addi	sp,sp,-220
8112d8dc:	de00012e 	bgeu	sp,et,8112d8e4 <___vfiprintf_internal_r+0xc>
8112d8e0:	003b68fa 	trap	3
8112d8e4:	df003515 	stw	fp,212(sp)
8112d8e8:	dd003115 	stw	r20,196(sp)
8112d8ec:	dfc03615 	stw	ra,216(sp)
8112d8f0:	ddc03415 	stw	r23,208(sp)
8112d8f4:	dd803315 	stw	r22,204(sp)
8112d8f8:	dd403215 	stw	r21,200(sp)
8112d8fc:	dcc03015 	stw	r19,192(sp)
8112d900:	dc802f15 	stw	r18,188(sp)
8112d904:	dc402e15 	stw	r17,184(sp)
8112d908:	dc002d15 	stw	r16,180(sp)
8112d90c:	d9002015 	stw	r4,128(sp)
8112d910:	d9c02215 	stw	r7,136(sp)
8112d914:	2829883a 	mov	r20,r5
8112d918:	3039883a 	mov	fp,r6
8112d91c:	20000226 	beq	r4,zero,8112d928 <___vfiprintf_internal_r+0x50>
8112d920:	20800e17 	ldw	r2,56(r4)
8112d924:	1000cf26 	beq	r2,zero,8112dc64 <___vfiprintf_internal_r+0x38c>
8112d928:	a080030b 	ldhu	r2,12(r20)
8112d92c:	10c8000c 	andi	r3,r2,8192
8112d930:	1800061e 	bne	r3,zero,8112d94c <___vfiprintf_internal_r+0x74>
8112d934:	a1001917 	ldw	r4,100(r20)
8112d938:	00f7ffc4 	movi	r3,-8193
8112d93c:	10880014 	ori	r2,r2,8192
8112d940:	20c6703a 	and	r3,r4,r3
8112d944:	a080030d 	sth	r2,12(r20)
8112d948:	a0c01915 	stw	r3,100(r20)
8112d94c:	10c0020c 	andi	r3,r2,8
8112d950:	1800a926 	beq	r3,zero,8112dbf8 <___vfiprintf_internal_r+0x320>
8112d954:	a0c00417 	ldw	r3,16(r20)
8112d958:	1800a726 	beq	r3,zero,8112dbf8 <___vfiprintf_internal_r+0x320>
8112d95c:	1080068c 	andi	r2,r2,26
8112d960:	00c00284 	movi	r3,10
8112d964:	10c0ac26 	beq	r2,r3,8112dc18 <___vfiprintf_internal_r+0x340>
8112d968:	da801a04 	addi	r10,sp,104
8112d96c:	da801e15 	stw	r10,120(sp)
8112d970:	d8801e17 	ldw	r2,120(sp)
8112d974:	da8019c4 	addi	r10,sp,103
8112d978:	05a04574 	movhi	r22,33045
8112d97c:	05e04574 	movhi	r23,33045
8112d980:	da801f15 	stw	r10,124(sp)
8112d984:	1295c83a 	sub	r10,r2,r10
8112d988:	b5b42a04 	addi	r22,r22,-12120
8112d98c:	bdf42604 	addi	r23,r23,-12136
8112d990:	dec01a15 	stw	sp,104(sp)
8112d994:	d8001c15 	stw	zero,112(sp)
8112d998:	d8001b15 	stw	zero,108(sp)
8112d99c:	d8002615 	stw	zero,152(sp)
8112d9a0:	d8002315 	stw	zero,140(sp)
8112d9a4:	da802715 	stw	r10,156(sp)
8112d9a8:	d811883a 	mov	r8,sp
8112d9ac:	dd002115 	stw	r20,132(sp)
8112d9b0:	e021883a 	mov	r16,fp
8112d9b4:	80800007 	ldb	r2,0(r16)
8112d9b8:	1003ea26 	beq	r2,zero,8112e964 <___vfiprintf_internal_r+0x108c>
8112d9bc:	00c00944 	movi	r3,37
8112d9c0:	8025883a 	mov	r18,r16
8112d9c4:	10c0021e 	bne	r2,r3,8112d9d0 <___vfiprintf_internal_r+0xf8>
8112d9c8:	00001606 	br	8112da24 <___vfiprintf_internal_r+0x14c>
8112d9cc:	10c00326 	beq	r2,r3,8112d9dc <___vfiprintf_internal_r+0x104>
8112d9d0:	94800044 	addi	r18,r18,1
8112d9d4:	90800007 	ldb	r2,0(r18)
8112d9d8:	103ffc1e 	bne	r2,zero,8112d9cc <__reset+0xfb10d9cc>
8112d9dc:	9423c83a 	sub	r17,r18,r16
8112d9e0:	88001026 	beq	r17,zero,8112da24 <___vfiprintf_internal_r+0x14c>
8112d9e4:	d8c01c17 	ldw	r3,112(sp)
8112d9e8:	d8801b17 	ldw	r2,108(sp)
8112d9ec:	44000015 	stw	r16,0(r8)
8112d9f0:	88c7883a 	add	r3,r17,r3
8112d9f4:	10800044 	addi	r2,r2,1
8112d9f8:	44400115 	stw	r17,4(r8)
8112d9fc:	d8c01c15 	stw	r3,112(sp)
8112da00:	d8801b15 	stw	r2,108(sp)
8112da04:	010001c4 	movi	r4,7
8112da08:	2080760e 	bge	r4,r2,8112dbe4 <___vfiprintf_internal_r+0x30c>
8112da0c:	1803821e 	bne	r3,zero,8112e818 <___vfiprintf_internal_r+0xf40>
8112da10:	da802317 	ldw	r10,140(sp)
8112da14:	d8001b15 	stw	zero,108(sp)
8112da18:	d811883a 	mov	r8,sp
8112da1c:	5455883a 	add	r10,r10,r17
8112da20:	da802315 	stw	r10,140(sp)
8112da24:	90800007 	ldb	r2,0(r18)
8112da28:	10044626 	beq	r2,zero,8112eb44 <___vfiprintf_internal_r+0x126c>
8112da2c:	90c00047 	ldb	r3,1(r18)
8112da30:	94000044 	addi	r16,r18,1
8112da34:	d8001d85 	stb	zero,118(sp)
8112da38:	0009883a 	mov	r4,zero
8112da3c:	000f883a 	mov	r7,zero
8112da40:	027fffc4 	movi	r9,-1
8112da44:	0023883a 	mov	r17,zero
8112da48:	0029883a 	mov	r20,zero
8112da4c:	01401604 	movi	r5,88
8112da50:	01800244 	movi	r6,9
8112da54:	03400a84 	movi	r13,42
8112da58:	03001b04 	movi	r12,108
8112da5c:	84000044 	addi	r16,r16,1
8112da60:	18bff804 	addi	r2,r3,-32
8112da64:	28827336 	bltu	r5,r2,8112e434 <___vfiprintf_internal_r+0xb5c>
8112da68:	100490ba 	slli	r2,r2,2
8112da6c:	02a044f4 	movhi	r10,33043
8112da70:	52b6a004 	addi	r10,r10,-9600
8112da74:	1285883a 	add	r2,r2,r10
8112da78:	10800017 	ldw	r2,0(r2)
8112da7c:	1000683a 	jmp	r2
8112da80:	8112e168 	cmpgeui	r4,r16,19333
8112da84:	8112e434 	orhi	r4,r16,19344
8112da88:	8112e434 	orhi	r4,r16,19344
8112da8c:	8112e188 	cmpgei	r4,r16,19334
8112da90:	8112e434 	orhi	r4,r16,19344
8112da94:	8112e434 	orhi	r4,r16,19344
8112da98:	8112e434 	orhi	r4,r16,19344
8112da9c:	8112e434 	orhi	r4,r16,19344
8112daa0:	8112e434 	orhi	r4,r16,19344
8112daa4:	8112e434 	orhi	r4,r16,19344
8112daa8:	8112e370 	cmpltui	r4,r16,19341
8112daac:	8112e38c 	andi	r4,r16,19342
8112dab0:	8112e434 	orhi	r4,r16,19344
8112dab4:	8112dc74 	orhi	r4,r16,19313
8112dab8:	8112e39c 	xori	r4,r16,19342
8112dabc:	8112e434 	orhi	r4,r16,19344
8112dac0:	8112e194 	ori	r4,r16,19334
8112dac4:	8112e1a0 	cmpeqi	r4,r16,19334
8112dac8:	8112e1a0 	cmpeqi	r4,r16,19334
8112dacc:	8112e1a0 	cmpeqi	r4,r16,19334
8112dad0:	8112e1a0 	cmpeqi	r4,r16,19334
8112dad4:	8112e1a0 	cmpeqi	r4,r16,19334
8112dad8:	8112e1a0 	cmpeqi	r4,r16,19334
8112dadc:	8112e1a0 	cmpeqi	r4,r16,19334
8112dae0:	8112e1a0 	cmpeqi	r4,r16,19334
8112dae4:	8112e1a0 	cmpeqi	r4,r16,19334
8112dae8:	8112e434 	orhi	r4,r16,19344
8112daec:	8112e434 	orhi	r4,r16,19344
8112daf0:	8112e434 	orhi	r4,r16,19344
8112daf4:	8112e434 	orhi	r4,r16,19344
8112daf8:	8112e434 	orhi	r4,r16,19344
8112dafc:	8112e434 	orhi	r4,r16,19344
8112db00:	8112e434 	orhi	r4,r16,19344
8112db04:	8112e434 	orhi	r4,r16,19344
8112db08:	8112e434 	orhi	r4,r16,19344
8112db0c:	8112e434 	orhi	r4,r16,19344
8112db10:	8112e1cc 	andi	r4,r16,19335
8112db14:	8112e434 	orhi	r4,r16,19344
8112db18:	8112e434 	orhi	r4,r16,19344
8112db1c:	8112e434 	orhi	r4,r16,19344
8112db20:	8112e434 	orhi	r4,r16,19344
8112db24:	8112e434 	orhi	r4,r16,19344
8112db28:	8112e434 	orhi	r4,r16,19344
8112db2c:	8112e434 	orhi	r4,r16,19344
8112db30:	8112e434 	orhi	r4,r16,19344
8112db34:	8112e434 	orhi	r4,r16,19344
8112db38:	8112e434 	orhi	r4,r16,19344
8112db3c:	8112e204 	addi	r4,r16,19336
8112db40:	8112e434 	orhi	r4,r16,19344
8112db44:	8112e434 	orhi	r4,r16,19344
8112db48:	8112e434 	orhi	r4,r16,19344
8112db4c:	8112e434 	orhi	r4,r16,19344
8112db50:	8112e434 	orhi	r4,r16,19344
8112db54:	8112e25c 	xori	r4,r16,19337
8112db58:	8112e434 	orhi	r4,r16,19344
8112db5c:	8112e434 	orhi	r4,r16,19344
8112db60:	8112e2cc 	andi	r4,r16,19339
8112db64:	8112e434 	orhi	r4,r16,19344
8112db68:	8112e434 	orhi	r4,r16,19344
8112db6c:	8112e434 	orhi	r4,r16,19344
8112db70:	8112e434 	orhi	r4,r16,19344
8112db74:	8112e434 	orhi	r4,r16,19344
8112db78:	8112e434 	orhi	r4,r16,19344
8112db7c:	8112e434 	orhi	r4,r16,19344
8112db80:	8112e434 	orhi	r4,r16,19344
8112db84:	8112e434 	orhi	r4,r16,19344
8112db88:	8112e434 	orhi	r4,r16,19344
8112db8c:	8112e078 	rdprs	r4,r16,19329
8112db90:	8112e0a4 	muli	r4,r16,19330
8112db94:	8112e434 	orhi	r4,r16,19344
8112db98:	8112e434 	orhi	r4,r16,19344
8112db9c:	8112e434 	orhi	r4,r16,19344
8112dba0:	8112e3dc 	xori	r4,r16,19343
8112dba4:	8112e0a4 	muli	r4,r16,19330
8112dba8:	8112e434 	orhi	r4,r16,19344
8112dbac:	8112e434 	orhi	r4,r16,19344
8112dbb0:	8112df38 	rdprs	r4,r16,19324
8112dbb4:	8112e434 	orhi	r4,r16,19344
8112dbb8:	8112df48 	cmpgei	r4,r16,19325
8112dbbc:	8112df84 	addi	r4,r16,19326
8112dbc0:	8112dc80 	call	88112dc8 <__reset+0x20f2dc8>
8112dbc4:	8112df2c 	andhi	r4,r16,19324
8112dbc8:	8112e434 	orhi	r4,r16,19344
8112dbcc:	8112e308 	cmpgei	r4,r16,19340
8112dbd0:	8112e434 	orhi	r4,r16,19344
8112dbd4:	8112e360 	cmpeqi	r4,r16,19341
8112dbd8:	8112e434 	orhi	r4,r16,19344
8112dbdc:	8112e434 	orhi	r4,r16,19344
8112dbe0:	8112e024 	muli	r4,r16,19328
8112dbe4:	42000204 	addi	r8,r8,8
8112dbe8:	da802317 	ldw	r10,140(sp)
8112dbec:	5455883a 	add	r10,r10,r17
8112dbf0:	da802315 	stw	r10,140(sp)
8112dbf4:	003f8b06 	br	8112da24 <__reset+0xfb10da24>
8112dbf8:	d9002017 	ldw	r4,128(sp)
8112dbfc:	a00b883a 	mov	r5,r20
8112dc00:	112541c0 	call	8112541c <__swsetup_r>
8112dc04:	1003b11e 	bne	r2,zero,8112eacc <___vfiprintf_internal_r+0x11f4>
8112dc08:	a080030b 	ldhu	r2,12(r20)
8112dc0c:	00c00284 	movi	r3,10
8112dc10:	1080068c 	andi	r2,r2,26
8112dc14:	10ff541e 	bne	r2,r3,8112d968 <__reset+0xfb10d968>
8112dc18:	a080038f 	ldh	r2,14(r20)
8112dc1c:	103f5216 	blt	r2,zero,8112d968 <__reset+0xfb10d968>
8112dc20:	d9c02217 	ldw	r7,136(sp)
8112dc24:	d9002017 	ldw	r4,128(sp)
8112dc28:	e00d883a 	mov	r6,fp
8112dc2c:	a00b883a 	mov	r5,r20
8112dc30:	112ed580 	call	8112ed58 <__sbprintf>
8112dc34:	dfc03617 	ldw	ra,216(sp)
8112dc38:	df003517 	ldw	fp,212(sp)
8112dc3c:	ddc03417 	ldw	r23,208(sp)
8112dc40:	dd803317 	ldw	r22,204(sp)
8112dc44:	dd403217 	ldw	r21,200(sp)
8112dc48:	dd003117 	ldw	r20,196(sp)
8112dc4c:	dcc03017 	ldw	r19,192(sp)
8112dc50:	dc802f17 	ldw	r18,188(sp)
8112dc54:	dc402e17 	ldw	r17,184(sp)
8112dc58:	dc002d17 	ldw	r16,180(sp)
8112dc5c:	dec03704 	addi	sp,sp,220
8112dc60:	f800283a 	ret
8112dc64:	112748c0 	call	8112748c <__sinit>
8112dc68:	003f2f06 	br	8112d928 <__reset+0xfb10d928>
8112dc6c:	0463c83a 	sub	r17,zero,r17
8112dc70:	d8802215 	stw	r2,136(sp)
8112dc74:	a5000114 	ori	r20,r20,4
8112dc78:	80c00007 	ldb	r3,0(r16)
8112dc7c:	003f7706 	br	8112da5c <__reset+0xfb10da5c>
8112dc80:	00800c04 	movi	r2,48
8112dc84:	da802217 	ldw	r10,136(sp)
8112dc88:	d8801d05 	stb	r2,116(sp)
8112dc8c:	00801e04 	movi	r2,120
8112dc90:	d8801d45 	stb	r2,117(sp)
8112dc94:	d8001d85 	stb	zero,118(sp)
8112dc98:	50c00104 	addi	r3,r10,4
8112dc9c:	54800017 	ldw	r18,0(r10)
8112dca0:	0027883a 	mov	r19,zero
8112dca4:	a0800094 	ori	r2,r20,2
8112dca8:	48030b16 	blt	r9,zero,8112e8d8 <___vfiprintf_internal_r+0x1000>
8112dcac:	00bfdfc4 	movi	r2,-129
8112dcb0:	a096703a 	and	r11,r20,r2
8112dcb4:	d8c02215 	stw	r3,136(sp)
8112dcb8:	5d000094 	ori	r20,r11,2
8112dcbc:	90032b1e 	bne	r18,zero,8112e96c <___vfiprintf_internal_r+0x1094>
8112dcc0:	00a04574 	movhi	r2,33045
8112dcc4:	10b39404 	addi	r2,r2,-12720
8112dcc8:	d8802615 	stw	r2,152(sp)
8112dccc:	0039883a 	mov	fp,zero
8112dcd0:	48017b1e 	bne	r9,zero,8112e2c0 <___vfiprintf_internal_r+0x9e8>
8112dcd4:	0013883a 	mov	r9,zero
8112dcd8:	0027883a 	mov	r19,zero
8112dcdc:	dd401a04 	addi	r21,sp,104
8112dce0:	4825883a 	mov	r18,r9
8112dce4:	4cc0010e 	bge	r9,r19,8112dcec <___vfiprintf_internal_r+0x414>
8112dce8:	9825883a 	mov	r18,r19
8112dcec:	e7003fcc 	andi	fp,fp,255
8112dcf0:	e700201c 	xori	fp,fp,128
8112dcf4:	e73fe004 	addi	fp,fp,-128
8112dcf8:	e0000126 	beq	fp,zero,8112dd00 <___vfiprintf_internal_r+0x428>
8112dcfc:	94800044 	addi	r18,r18,1
8112dd00:	a380008c 	andi	r14,r20,2
8112dd04:	70000126 	beq	r14,zero,8112dd0c <___vfiprintf_internal_r+0x434>
8112dd08:	94800084 	addi	r18,r18,2
8112dd0c:	a700210c 	andi	fp,r20,132
8112dd10:	e001df1e 	bne	fp,zero,8112e490 <___vfiprintf_internal_r+0xbb8>
8112dd14:	8c87c83a 	sub	r3,r17,r18
8112dd18:	00c1dd0e 	bge	zero,r3,8112e490 <___vfiprintf_internal_r+0xbb8>
8112dd1c:	01c00404 	movi	r7,16
8112dd20:	d8801c17 	ldw	r2,112(sp)
8112dd24:	38c3ad0e 	bge	r7,r3,8112ebdc <___vfiprintf_internal_r+0x1304>
8112dd28:	02a04574 	movhi	r10,33045
8112dd2c:	52b42a04 	addi	r10,r10,-12120
8112dd30:	dc002915 	stw	r16,164(sp)
8112dd34:	d9801b17 	ldw	r6,108(sp)
8112dd38:	da802415 	stw	r10,144(sp)
8112dd3c:	03c001c4 	movi	r15,7
8112dd40:	da402515 	stw	r9,148(sp)
8112dd44:	db802815 	stw	r14,160(sp)
8112dd48:	1821883a 	mov	r16,r3
8112dd4c:	00000506 	br	8112dd64 <___vfiprintf_internal_r+0x48c>
8112dd50:	31400084 	addi	r5,r6,2
8112dd54:	42000204 	addi	r8,r8,8
8112dd58:	200d883a 	mov	r6,r4
8112dd5c:	843ffc04 	addi	r16,r16,-16
8112dd60:	3c000d0e 	bge	r7,r16,8112dd98 <___vfiprintf_internal_r+0x4c0>
8112dd64:	10800404 	addi	r2,r2,16
8112dd68:	31000044 	addi	r4,r6,1
8112dd6c:	45800015 	stw	r22,0(r8)
8112dd70:	41c00115 	stw	r7,4(r8)
8112dd74:	d8801c15 	stw	r2,112(sp)
8112dd78:	d9001b15 	stw	r4,108(sp)
8112dd7c:	793ff40e 	bge	r15,r4,8112dd50 <__reset+0xfb10dd50>
8112dd80:	1001b51e 	bne	r2,zero,8112e458 <___vfiprintf_internal_r+0xb80>
8112dd84:	843ffc04 	addi	r16,r16,-16
8112dd88:	000d883a 	mov	r6,zero
8112dd8c:	01400044 	movi	r5,1
8112dd90:	d811883a 	mov	r8,sp
8112dd94:	3c3ff316 	blt	r7,r16,8112dd64 <__reset+0xfb10dd64>
8112dd98:	8007883a 	mov	r3,r16
8112dd9c:	da402517 	ldw	r9,148(sp)
8112dda0:	db802817 	ldw	r14,160(sp)
8112dda4:	dc002917 	ldw	r16,164(sp)
8112dda8:	da802417 	ldw	r10,144(sp)
8112ddac:	1885883a 	add	r2,r3,r2
8112ddb0:	40c00115 	stw	r3,4(r8)
8112ddb4:	42800015 	stw	r10,0(r8)
8112ddb8:	d8801c15 	stw	r2,112(sp)
8112ddbc:	d9401b15 	stw	r5,108(sp)
8112ddc0:	00c001c4 	movi	r3,7
8112ddc4:	19426016 	blt	r3,r5,8112e748 <___vfiprintf_internal_r+0xe70>
8112ddc8:	d8c01d87 	ldb	r3,118(sp)
8112ddcc:	42000204 	addi	r8,r8,8
8112ddd0:	29000044 	addi	r4,r5,1
8112ddd4:	1801b31e 	bne	r3,zero,8112e4a4 <___vfiprintf_internal_r+0xbcc>
8112ddd8:	7001c026 	beq	r14,zero,8112e4dc <___vfiprintf_internal_r+0xc04>
8112dddc:	d8c01d04 	addi	r3,sp,116
8112dde0:	10800084 	addi	r2,r2,2
8112dde4:	40c00015 	stw	r3,0(r8)
8112dde8:	00c00084 	movi	r3,2
8112ddec:	40c00115 	stw	r3,4(r8)
8112ddf0:	d8801c15 	stw	r2,112(sp)
8112ddf4:	d9001b15 	stw	r4,108(sp)
8112ddf8:	00c001c4 	movi	r3,7
8112ddfc:	1902650e 	bge	r3,r4,8112e794 <___vfiprintf_internal_r+0xebc>
8112de00:	10029a1e 	bne	r2,zero,8112e86c <___vfiprintf_internal_r+0xf94>
8112de04:	00c02004 	movi	r3,128
8112de08:	01000044 	movi	r4,1
8112de0c:	000b883a 	mov	r5,zero
8112de10:	d811883a 	mov	r8,sp
8112de14:	e0c1b31e 	bne	fp,r3,8112e4e4 <___vfiprintf_internal_r+0xc0c>
8112de18:	8cb9c83a 	sub	fp,r17,r18
8112de1c:	0701b10e 	bge	zero,fp,8112e4e4 <___vfiprintf_internal_r+0xc0c>
8112de20:	01c00404 	movi	r7,16
8112de24:	3f03890e 	bge	r7,fp,8112ec4c <___vfiprintf_internal_r+0x1374>
8112de28:	00e04574 	movhi	r3,33045
8112de2c:	18f42604 	addi	r3,r3,-12136
8112de30:	d8c02415 	stw	r3,144(sp)
8112de34:	8007883a 	mov	r3,r16
8112de38:	034001c4 	movi	r13,7
8112de3c:	e021883a 	mov	r16,fp
8112de40:	da402515 	stw	r9,148(sp)
8112de44:	1839883a 	mov	fp,r3
8112de48:	00000506 	br	8112de60 <___vfiprintf_internal_r+0x588>
8112de4c:	29800084 	addi	r6,r5,2
8112de50:	42000204 	addi	r8,r8,8
8112de54:	180b883a 	mov	r5,r3
8112de58:	843ffc04 	addi	r16,r16,-16
8112de5c:	3c000d0e 	bge	r7,r16,8112de94 <___vfiprintf_internal_r+0x5bc>
8112de60:	10800404 	addi	r2,r2,16
8112de64:	28c00044 	addi	r3,r5,1
8112de68:	45c00015 	stw	r23,0(r8)
8112de6c:	41c00115 	stw	r7,4(r8)
8112de70:	d8801c15 	stw	r2,112(sp)
8112de74:	d8c01b15 	stw	r3,108(sp)
8112de78:	68fff40e 	bge	r13,r3,8112de4c <__reset+0xfb10de4c>
8112de7c:	1002241e 	bne	r2,zero,8112e710 <___vfiprintf_internal_r+0xe38>
8112de80:	843ffc04 	addi	r16,r16,-16
8112de84:	01800044 	movi	r6,1
8112de88:	000b883a 	mov	r5,zero
8112de8c:	d811883a 	mov	r8,sp
8112de90:	3c3ff316 	blt	r7,r16,8112de60 <__reset+0xfb10de60>
8112de94:	da402517 	ldw	r9,148(sp)
8112de98:	e007883a 	mov	r3,fp
8112de9c:	8039883a 	mov	fp,r16
8112dea0:	1821883a 	mov	r16,r3
8112dea4:	d8c02417 	ldw	r3,144(sp)
8112dea8:	1705883a 	add	r2,r2,fp
8112deac:	47000115 	stw	fp,4(r8)
8112deb0:	40c00015 	stw	r3,0(r8)
8112deb4:	d8801c15 	stw	r2,112(sp)
8112deb8:	d9801b15 	stw	r6,108(sp)
8112debc:	00c001c4 	movi	r3,7
8112dec0:	19827616 	blt	r3,r6,8112e89c <___vfiprintf_internal_r+0xfc4>
8112dec4:	4cf9c83a 	sub	fp,r9,r19
8112dec8:	42000204 	addi	r8,r8,8
8112decc:	31000044 	addi	r4,r6,1
8112ded0:	300b883a 	mov	r5,r6
8112ded4:	07018516 	blt	zero,fp,8112e4ec <___vfiprintf_internal_r+0xc14>
8112ded8:	9885883a 	add	r2,r19,r2
8112dedc:	45400015 	stw	r21,0(r8)
8112dee0:	44c00115 	stw	r19,4(r8)
8112dee4:	d8801c15 	stw	r2,112(sp)
8112dee8:	d9001b15 	stw	r4,108(sp)
8112deec:	00c001c4 	movi	r3,7
8112def0:	1901dd0e 	bge	r3,r4,8112e668 <___vfiprintf_internal_r+0xd90>
8112def4:	1002401e 	bne	r2,zero,8112e7f8 <___vfiprintf_internal_r+0xf20>
8112def8:	d8001b15 	stw	zero,108(sp)
8112defc:	a2c0010c 	andi	r11,r20,4
8112df00:	58000226 	beq	r11,zero,8112df0c <___vfiprintf_internal_r+0x634>
8112df04:	8ca7c83a 	sub	r19,r17,r18
8112df08:	04c2f216 	blt	zero,r19,8112ead4 <___vfiprintf_internal_r+0x11fc>
8112df0c:	8c80010e 	bge	r17,r18,8112df14 <___vfiprintf_internal_r+0x63c>
8112df10:	9023883a 	mov	r17,r18
8112df14:	da802317 	ldw	r10,140(sp)
8112df18:	5455883a 	add	r10,r10,r17
8112df1c:	da802315 	stw	r10,140(sp)
8112df20:	d8001b15 	stw	zero,108(sp)
8112df24:	d811883a 	mov	r8,sp
8112df28:	003ea206 	br	8112d9b4 <__reset+0xfb10d9b4>
8112df2c:	a5000814 	ori	r20,r20,32
8112df30:	80c00007 	ldb	r3,0(r16)
8112df34:	003ec906 	br	8112da5c <__reset+0xfb10da5c>
8112df38:	80c00007 	ldb	r3,0(r16)
8112df3c:	1b030926 	beq	r3,r12,8112eb64 <___vfiprintf_internal_r+0x128c>
8112df40:	a5000414 	ori	r20,r20,16
8112df44:	003ec506 	br	8112da5c <__reset+0xfb10da5c>
8112df48:	21003fcc 	andi	r4,r4,255
8112df4c:	20035e1e 	bne	r4,zero,8112ecc8 <___vfiprintf_internal_r+0x13f0>
8112df50:	a080080c 	andi	r2,r20,32
8112df54:	1002a526 	beq	r2,zero,8112e9ec <___vfiprintf_internal_r+0x1114>
8112df58:	da802217 	ldw	r10,136(sp)
8112df5c:	50800017 	ldw	r2,0(r10)
8112df60:	da802317 	ldw	r10,140(sp)
8112df64:	5007d7fa 	srai	r3,r10,31
8112df68:	da802217 	ldw	r10,136(sp)
8112df6c:	10c00115 	stw	r3,4(r2)
8112df70:	52800104 	addi	r10,r10,4
8112df74:	da802215 	stw	r10,136(sp)
8112df78:	da802317 	ldw	r10,140(sp)
8112df7c:	12800015 	stw	r10,0(r2)
8112df80:	003e8c06 	br	8112d9b4 <__reset+0xfb10d9b4>
8112df84:	21003fcc 	andi	r4,r4,255
8112df88:	2003511e 	bne	r4,zero,8112ecd0 <___vfiprintf_internal_r+0x13f8>
8112df8c:	a080080c 	andi	r2,r20,32
8112df90:	1000a126 	beq	r2,zero,8112e218 <___vfiprintf_internal_r+0x940>
8112df94:	da802217 	ldw	r10,136(sp)
8112df98:	d8001d85 	stb	zero,118(sp)
8112df9c:	50800204 	addi	r2,r10,8
8112dfa0:	54800017 	ldw	r18,0(r10)
8112dfa4:	54c00117 	ldw	r19,4(r10)
8112dfa8:	4802b416 	blt	r9,zero,8112ea7c <___vfiprintf_internal_r+0x11a4>
8112dfac:	013fdfc4 	movi	r4,-129
8112dfb0:	94c6b03a 	or	r3,r18,r19
8112dfb4:	d8802215 	stw	r2,136(sp)
8112dfb8:	a128703a 	and	r20,r20,r4
8112dfbc:	1800a226 	beq	r3,zero,8112e248 <___vfiprintf_internal_r+0x970>
8112dfc0:	0039883a 	mov	fp,zero
8112dfc4:	dd401a04 	addi	r21,sp,104
8112dfc8:	9006d0fa 	srli	r3,r18,3
8112dfcc:	9808977a 	slli	r4,r19,29
8112dfd0:	9826d0fa 	srli	r19,r19,3
8112dfd4:	948001cc 	andi	r18,r18,7
8112dfd8:	90800c04 	addi	r2,r18,48
8112dfdc:	ad7fffc4 	addi	r21,r21,-1
8112dfe0:	20e4b03a 	or	r18,r4,r3
8112dfe4:	a8800005 	stb	r2,0(r21)
8112dfe8:	94c6b03a 	or	r3,r18,r19
8112dfec:	183ff61e 	bne	r3,zero,8112dfc8 <__reset+0xfb10dfc8>
8112dff0:	a0c0004c 	andi	r3,r20,1
8112dff4:	18005926 	beq	r3,zero,8112e15c <___vfiprintf_internal_r+0x884>
8112dff8:	10803fcc 	andi	r2,r2,255
8112dffc:	1080201c 	xori	r2,r2,128
8112e000:	10bfe004 	addi	r2,r2,-128
8112e004:	00c00c04 	movi	r3,48
8112e008:	10c05426 	beq	r2,r3,8112e15c <___vfiprintf_internal_r+0x884>
8112e00c:	da801e17 	ldw	r10,120(sp)
8112e010:	a8bfffc4 	addi	r2,r21,-1
8112e014:	a8ffffc5 	stb	r3,-1(r21)
8112e018:	50a7c83a 	sub	r19,r10,r2
8112e01c:	102b883a 	mov	r21,r2
8112e020:	003f2f06 	br	8112dce0 <__reset+0xfb10dce0>
8112e024:	21003fcc 	andi	r4,r4,255
8112e028:	2003421e 	bne	r4,zero,8112ed34 <___vfiprintf_internal_r+0x145c>
8112e02c:	00a04574 	movhi	r2,33045
8112e030:	10b39404 	addi	r2,r2,-12720
8112e034:	d8802615 	stw	r2,152(sp)
8112e038:	a080080c 	andi	r2,r20,32
8112e03c:	1000aa26 	beq	r2,zero,8112e2e8 <___vfiprintf_internal_r+0xa10>
8112e040:	da802217 	ldw	r10,136(sp)
8112e044:	54800017 	ldw	r18,0(r10)
8112e048:	54c00117 	ldw	r19,4(r10)
8112e04c:	52800204 	addi	r10,r10,8
8112e050:	da802215 	stw	r10,136(sp)
8112e054:	a080004c 	andi	r2,r20,1
8112e058:	1001d226 	beq	r2,zero,8112e7a4 <___vfiprintf_internal_r+0xecc>
8112e05c:	94c4b03a 	or	r2,r18,r19
8112e060:	1002351e 	bne	r2,zero,8112e938 <___vfiprintf_internal_r+0x1060>
8112e064:	d8001d85 	stb	zero,118(sp)
8112e068:	48022216 	blt	r9,zero,8112e8f4 <___vfiprintf_internal_r+0x101c>
8112e06c:	00bfdfc4 	movi	r2,-129
8112e070:	a0a8703a 	and	r20,r20,r2
8112e074:	003f1506 	br	8112dccc <__reset+0xfb10dccc>
8112e078:	da802217 	ldw	r10,136(sp)
8112e07c:	04800044 	movi	r18,1
8112e080:	d8001d85 	stb	zero,118(sp)
8112e084:	50800017 	ldw	r2,0(r10)
8112e088:	52800104 	addi	r10,r10,4
8112e08c:	da802215 	stw	r10,136(sp)
8112e090:	d8801005 	stb	r2,64(sp)
8112e094:	9027883a 	mov	r19,r18
8112e098:	dd401004 	addi	r21,sp,64
8112e09c:	0013883a 	mov	r9,zero
8112e0a0:	003f1706 	br	8112dd00 <__reset+0xfb10dd00>
8112e0a4:	21003fcc 	andi	r4,r4,255
8112e0a8:	2003201e 	bne	r4,zero,8112ed2c <___vfiprintf_internal_r+0x1454>
8112e0ac:	a080080c 	andi	r2,r20,32
8112e0b0:	10004b26 	beq	r2,zero,8112e1e0 <___vfiprintf_internal_r+0x908>
8112e0b4:	da802217 	ldw	r10,136(sp)
8112e0b8:	50800117 	ldw	r2,4(r10)
8112e0bc:	54800017 	ldw	r18,0(r10)
8112e0c0:	52800204 	addi	r10,r10,8
8112e0c4:	da802215 	stw	r10,136(sp)
8112e0c8:	1027883a 	mov	r19,r2
8112e0cc:	10022c16 	blt	r2,zero,8112e980 <___vfiprintf_internal_r+0x10a8>
8112e0d0:	df001d83 	ldbu	fp,118(sp)
8112e0d4:	48007216 	blt	r9,zero,8112e2a0 <___vfiprintf_internal_r+0x9c8>
8112e0d8:	00ffdfc4 	movi	r3,-129
8112e0dc:	94c4b03a 	or	r2,r18,r19
8112e0e0:	a0e8703a 	and	r20,r20,r3
8112e0e4:	1000cc26 	beq	r2,zero,8112e418 <___vfiprintf_internal_r+0xb40>
8112e0e8:	98021026 	beq	r19,zero,8112e92c <___vfiprintf_internal_r+0x1054>
8112e0ec:	dc402415 	stw	r17,144(sp)
8112e0f0:	dc002515 	stw	r16,148(sp)
8112e0f4:	9823883a 	mov	r17,r19
8112e0f8:	9021883a 	mov	r16,r18
8112e0fc:	dd401a04 	addi	r21,sp,104
8112e100:	4825883a 	mov	r18,r9
8112e104:	4027883a 	mov	r19,r8
8112e108:	8009883a 	mov	r4,r16
8112e10c:	880b883a 	mov	r5,r17
8112e110:	01800284 	movi	r6,10
8112e114:	000f883a 	mov	r7,zero
8112e118:	11306740 	call	81130674 <__umoddi3>
8112e11c:	10800c04 	addi	r2,r2,48
8112e120:	ad7fffc4 	addi	r21,r21,-1
8112e124:	8009883a 	mov	r4,r16
8112e128:	880b883a 	mov	r5,r17
8112e12c:	a8800005 	stb	r2,0(r21)
8112e130:	01800284 	movi	r6,10
8112e134:	000f883a 	mov	r7,zero
8112e138:	11300f40 	call	811300f4 <__udivdi3>
8112e13c:	1021883a 	mov	r16,r2
8112e140:	10c4b03a 	or	r2,r2,r3
8112e144:	1823883a 	mov	r17,r3
8112e148:	103fef1e 	bne	r2,zero,8112e108 <__reset+0xfb10e108>
8112e14c:	dc402417 	ldw	r17,144(sp)
8112e150:	dc002517 	ldw	r16,148(sp)
8112e154:	9013883a 	mov	r9,r18
8112e158:	9811883a 	mov	r8,r19
8112e15c:	da801e17 	ldw	r10,120(sp)
8112e160:	5567c83a 	sub	r19,r10,r21
8112e164:	003ede06 	br	8112dce0 <__reset+0xfb10dce0>
8112e168:	38803fcc 	andi	r2,r7,255
8112e16c:	1080201c 	xori	r2,r2,128
8112e170:	10bfe004 	addi	r2,r2,-128
8112e174:	1002371e 	bne	r2,zero,8112ea54 <___vfiprintf_internal_r+0x117c>
8112e178:	01000044 	movi	r4,1
8112e17c:	01c00804 	movi	r7,32
8112e180:	80c00007 	ldb	r3,0(r16)
8112e184:	003e3506 	br	8112da5c <__reset+0xfb10da5c>
8112e188:	a5000054 	ori	r20,r20,1
8112e18c:	80c00007 	ldb	r3,0(r16)
8112e190:	003e3206 	br	8112da5c <__reset+0xfb10da5c>
8112e194:	a5002014 	ori	r20,r20,128
8112e198:	80c00007 	ldb	r3,0(r16)
8112e19c:	003e2f06 	br	8112da5c <__reset+0xfb10da5c>
8112e1a0:	8015883a 	mov	r10,r16
8112e1a4:	0023883a 	mov	r17,zero
8112e1a8:	18bff404 	addi	r2,r3,-48
8112e1ac:	50c00007 	ldb	r3,0(r10)
8112e1b0:	8c4002a4 	muli	r17,r17,10
8112e1b4:	84000044 	addi	r16,r16,1
8112e1b8:	8015883a 	mov	r10,r16
8112e1bc:	1463883a 	add	r17,r2,r17
8112e1c0:	18bff404 	addi	r2,r3,-48
8112e1c4:	30bff92e 	bgeu	r6,r2,8112e1ac <__reset+0xfb10e1ac>
8112e1c8:	003e2506 	br	8112da60 <__reset+0xfb10da60>
8112e1cc:	21003fcc 	andi	r4,r4,255
8112e1d0:	2002d41e 	bne	r4,zero,8112ed24 <___vfiprintf_internal_r+0x144c>
8112e1d4:	a5000414 	ori	r20,r20,16
8112e1d8:	a080080c 	andi	r2,r20,32
8112e1dc:	103fb51e 	bne	r2,zero,8112e0b4 <__reset+0xfb10e0b4>
8112e1e0:	a080040c 	andi	r2,r20,16
8112e1e4:	1001f826 	beq	r2,zero,8112e9c8 <___vfiprintf_internal_r+0x10f0>
8112e1e8:	da802217 	ldw	r10,136(sp)
8112e1ec:	54800017 	ldw	r18,0(r10)
8112e1f0:	52800104 	addi	r10,r10,4
8112e1f4:	da802215 	stw	r10,136(sp)
8112e1f8:	9027d7fa 	srai	r19,r18,31
8112e1fc:	9805883a 	mov	r2,r19
8112e200:	003fb206 	br	8112e0cc <__reset+0xfb10e0cc>
8112e204:	21003fcc 	andi	r4,r4,255
8112e208:	2002c41e 	bne	r4,zero,8112ed1c <___vfiprintf_internal_r+0x1444>
8112e20c:	a5000414 	ori	r20,r20,16
8112e210:	a080080c 	andi	r2,r20,32
8112e214:	103f5f1e 	bne	r2,zero,8112df94 <__reset+0xfb10df94>
8112e218:	a080040c 	andi	r2,r20,16
8112e21c:	10020f26 	beq	r2,zero,8112ea5c <___vfiprintf_internal_r+0x1184>
8112e220:	da802217 	ldw	r10,136(sp)
8112e224:	d8001d85 	stb	zero,118(sp)
8112e228:	0027883a 	mov	r19,zero
8112e22c:	50800104 	addi	r2,r10,4
8112e230:	54800017 	ldw	r18,0(r10)
8112e234:	48021116 	blt	r9,zero,8112ea7c <___vfiprintf_internal_r+0x11a4>
8112e238:	00ffdfc4 	movi	r3,-129
8112e23c:	d8802215 	stw	r2,136(sp)
8112e240:	a0e8703a 	and	r20,r20,r3
8112e244:	903f5e1e 	bne	r18,zero,8112dfc0 <__reset+0xfb10dfc0>
8112e248:	0039883a 	mov	fp,zero
8112e24c:	4802a626 	beq	r9,zero,8112ece8 <___vfiprintf_internal_r+0x1410>
8112e250:	0025883a 	mov	r18,zero
8112e254:	0027883a 	mov	r19,zero
8112e258:	003f5a06 	br	8112dfc4 <__reset+0xfb10dfc4>
8112e25c:	21003fcc 	andi	r4,r4,255
8112e260:	20029f1e 	bne	r4,zero,8112ece0 <___vfiprintf_internal_r+0x1408>
8112e264:	a5000414 	ori	r20,r20,16
8112e268:	a080080c 	andi	r2,r20,32
8112e26c:	10005e1e 	bne	r2,zero,8112e3e8 <___vfiprintf_internal_r+0xb10>
8112e270:	a080040c 	andi	r2,r20,16
8112e274:	1001a21e 	bne	r2,zero,8112e900 <___vfiprintf_internal_r+0x1028>
8112e278:	a080100c 	andi	r2,r20,64
8112e27c:	d8001d85 	stb	zero,118(sp)
8112e280:	da802217 	ldw	r10,136(sp)
8112e284:	1002231e 	bne	r2,zero,8112eb14 <___vfiprintf_internal_r+0x123c>
8112e288:	50800104 	addi	r2,r10,4
8112e28c:	54800017 	ldw	r18,0(r10)
8112e290:	0027883a 	mov	r19,zero
8112e294:	4801a00e 	bge	r9,zero,8112e918 <___vfiprintf_internal_r+0x1040>
8112e298:	d8802215 	stw	r2,136(sp)
8112e29c:	0039883a 	mov	fp,zero
8112e2a0:	94c4b03a 	or	r2,r18,r19
8112e2a4:	103f901e 	bne	r2,zero,8112e0e8 <__reset+0xfb10e0e8>
8112e2a8:	00800044 	movi	r2,1
8112e2ac:	10803fcc 	andi	r2,r2,255
8112e2b0:	00c00044 	movi	r3,1
8112e2b4:	10c05926 	beq	r2,r3,8112e41c <___vfiprintf_internal_r+0xb44>
8112e2b8:	00c00084 	movi	r3,2
8112e2bc:	10ffe41e 	bne	r2,r3,8112e250 <__reset+0xfb10e250>
8112e2c0:	0025883a 	mov	r18,zero
8112e2c4:	0027883a 	mov	r19,zero
8112e2c8:	00013d06 	br	8112e7c0 <___vfiprintf_internal_r+0xee8>
8112e2cc:	21003fcc 	andi	r4,r4,255
8112e2d0:	2002811e 	bne	r4,zero,8112ecd8 <___vfiprintf_internal_r+0x1400>
8112e2d4:	00a04574 	movhi	r2,33045
8112e2d8:	10b38f04 	addi	r2,r2,-12740
8112e2dc:	d8802615 	stw	r2,152(sp)
8112e2e0:	a080080c 	andi	r2,r20,32
8112e2e4:	103f561e 	bne	r2,zero,8112e040 <__reset+0xfb10e040>
8112e2e8:	a080040c 	andi	r2,r20,16
8112e2ec:	1001d126 	beq	r2,zero,8112ea34 <___vfiprintf_internal_r+0x115c>
8112e2f0:	da802217 	ldw	r10,136(sp)
8112e2f4:	0027883a 	mov	r19,zero
8112e2f8:	54800017 	ldw	r18,0(r10)
8112e2fc:	52800104 	addi	r10,r10,4
8112e300:	da802215 	stw	r10,136(sp)
8112e304:	003f5306 	br	8112e054 <__reset+0xfb10e054>
8112e308:	da802217 	ldw	r10,136(sp)
8112e30c:	d8001d85 	stb	zero,118(sp)
8112e310:	55400017 	ldw	r21,0(r10)
8112e314:	50c00104 	addi	r3,r10,4
8112e318:	a8024226 	beq	r21,zero,8112ec24 <___vfiprintf_internal_r+0x134c>
8112e31c:	48021816 	blt	r9,zero,8112eb80 <___vfiprintf_internal_r+0x12a8>
8112e320:	480d883a 	mov	r6,r9
8112e324:	000b883a 	mov	r5,zero
8112e328:	a809883a 	mov	r4,r21
8112e32c:	d8c02a15 	stw	r3,168(sp)
8112e330:	da002b15 	stw	r8,172(sp)
8112e334:	da402c15 	stw	r9,176(sp)
8112e338:	11286b40 	call	811286b4 <memchr>
8112e33c:	d8c02a17 	ldw	r3,168(sp)
8112e340:	da002b17 	ldw	r8,172(sp)
8112e344:	da402c17 	ldw	r9,176(sp)
8112e348:	10024826 	beq	r2,zero,8112ec6c <___vfiprintf_internal_r+0x1394>
8112e34c:	1567c83a 	sub	r19,r2,r21
8112e350:	df001d83 	ldbu	fp,118(sp)
8112e354:	d8c02215 	stw	r3,136(sp)
8112e358:	0013883a 	mov	r9,zero
8112e35c:	003e6006 	br	8112dce0 <__reset+0xfb10dce0>
8112e360:	21003fcc 	andi	r4,r4,255
8112e364:	203fc026 	beq	r4,zero,8112e268 <__reset+0xfb10e268>
8112e368:	d9c01d85 	stb	r7,118(sp)
8112e36c:	003fbe06 	br	8112e268 <__reset+0xfb10e268>
8112e370:	da802217 	ldw	r10,136(sp)
8112e374:	54400017 	ldw	r17,0(r10)
8112e378:	50800104 	addi	r2,r10,4
8112e37c:	883e3b16 	blt	r17,zero,8112dc6c <__reset+0xfb10dc6c>
8112e380:	d8802215 	stw	r2,136(sp)
8112e384:	80c00007 	ldb	r3,0(r16)
8112e388:	003db406 	br	8112da5c <__reset+0xfb10da5c>
8112e38c:	01000044 	movi	r4,1
8112e390:	01c00ac4 	movi	r7,43
8112e394:	80c00007 	ldb	r3,0(r16)
8112e398:	003db006 	br	8112da5c <__reset+0xfb10da5c>
8112e39c:	80c00007 	ldb	r3,0(r16)
8112e3a0:	82800044 	addi	r10,r16,1
8112e3a4:	1b423c26 	beq	r3,r13,8112ec98 <___vfiprintf_internal_r+0x13c0>
8112e3a8:	18bff404 	addi	r2,r3,-48
8112e3ac:	0013883a 	mov	r9,zero
8112e3b0:	30822b36 	bltu	r6,r2,8112ec60 <___vfiprintf_internal_r+0x1388>
8112e3b4:	50c00007 	ldb	r3,0(r10)
8112e3b8:	4a4002a4 	muli	r9,r9,10
8112e3bc:	54000044 	addi	r16,r10,1
8112e3c0:	8015883a 	mov	r10,r16
8112e3c4:	4893883a 	add	r9,r9,r2
8112e3c8:	18bff404 	addi	r2,r3,-48
8112e3cc:	30bff92e 	bgeu	r6,r2,8112e3b4 <__reset+0xfb10e3b4>
8112e3d0:	483da30e 	bge	r9,zero,8112da60 <__reset+0xfb10da60>
8112e3d4:	027fffc4 	movi	r9,-1
8112e3d8:	003da106 	br	8112da60 <__reset+0xfb10da60>
8112e3dc:	a5001014 	ori	r20,r20,64
8112e3e0:	80c00007 	ldb	r3,0(r16)
8112e3e4:	003d9d06 	br	8112da5c <__reset+0xfb10da5c>
8112e3e8:	da802217 	ldw	r10,136(sp)
8112e3ec:	d8001d85 	stb	zero,118(sp)
8112e3f0:	50c00204 	addi	r3,r10,8
8112e3f4:	54800017 	ldw	r18,0(r10)
8112e3f8:	54c00117 	ldw	r19,4(r10)
8112e3fc:	4801ca16 	blt	r9,zero,8112eb28 <___vfiprintf_internal_r+0x1250>
8112e400:	013fdfc4 	movi	r4,-129
8112e404:	94c4b03a 	or	r2,r18,r19
8112e408:	d8c02215 	stw	r3,136(sp)
8112e40c:	a128703a 	and	r20,r20,r4
8112e410:	0039883a 	mov	fp,zero
8112e414:	103f341e 	bne	r2,zero,8112e0e8 <__reset+0xfb10e0e8>
8112e418:	483e2e26 	beq	r9,zero,8112dcd4 <__reset+0xfb10dcd4>
8112e41c:	0025883a 	mov	r18,zero
8112e420:	94800c04 	addi	r18,r18,48
8112e424:	dc8019c5 	stb	r18,103(sp)
8112e428:	dcc02717 	ldw	r19,156(sp)
8112e42c:	dd4019c4 	addi	r21,sp,103
8112e430:	003e2b06 	br	8112dce0 <__reset+0xfb10dce0>
8112e434:	21003fcc 	andi	r4,r4,255
8112e438:	2002361e 	bne	r4,zero,8112ed14 <___vfiprintf_internal_r+0x143c>
8112e43c:	1801c126 	beq	r3,zero,8112eb44 <___vfiprintf_internal_r+0x126c>
8112e440:	04800044 	movi	r18,1
8112e444:	d8c01005 	stb	r3,64(sp)
8112e448:	d8001d85 	stb	zero,118(sp)
8112e44c:	9027883a 	mov	r19,r18
8112e450:	dd401004 	addi	r21,sp,64
8112e454:	003f1106 	br	8112e09c <__reset+0xfb10e09c>
8112e458:	d9402117 	ldw	r5,132(sp)
8112e45c:	d9002017 	ldw	r4,128(sp)
8112e460:	d9801a04 	addi	r6,sp,104
8112e464:	d9c02b15 	stw	r7,172(sp)
8112e468:	dbc02a15 	stw	r15,168(sp)
8112e46c:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e470:	d9c02b17 	ldw	r7,172(sp)
8112e474:	dbc02a17 	ldw	r15,168(sp)
8112e478:	10006d1e 	bne	r2,zero,8112e630 <___vfiprintf_internal_r+0xd58>
8112e47c:	d9801b17 	ldw	r6,108(sp)
8112e480:	d8801c17 	ldw	r2,112(sp)
8112e484:	d811883a 	mov	r8,sp
8112e488:	31400044 	addi	r5,r6,1
8112e48c:	003e3306 	br	8112dd5c <__reset+0xfb10dd5c>
8112e490:	d9401b17 	ldw	r5,108(sp)
8112e494:	d8801c17 	ldw	r2,112(sp)
8112e498:	29000044 	addi	r4,r5,1
8112e49c:	d8c01d87 	ldb	r3,118(sp)
8112e4a0:	183e4d26 	beq	r3,zero,8112ddd8 <__reset+0xfb10ddd8>
8112e4a4:	00c00044 	movi	r3,1
8112e4a8:	d9401d84 	addi	r5,sp,118
8112e4ac:	10c5883a 	add	r2,r2,r3
8112e4b0:	41400015 	stw	r5,0(r8)
8112e4b4:	40c00115 	stw	r3,4(r8)
8112e4b8:	d8801c15 	stw	r2,112(sp)
8112e4bc:	d9001b15 	stw	r4,108(sp)
8112e4c0:	014001c4 	movi	r5,7
8112e4c4:	2900a90e 	bge	r5,r4,8112e76c <___vfiprintf_internal_r+0xe94>
8112e4c8:	1000da1e 	bne	r2,zero,8112e834 <___vfiprintf_internal_r+0xf5c>
8112e4cc:	7000ab1e 	bne	r14,zero,8112e77c <___vfiprintf_internal_r+0xea4>
8112e4d0:	000b883a 	mov	r5,zero
8112e4d4:	1809883a 	mov	r4,r3
8112e4d8:	d811883a 	mov	r8,sp
8112e4dc:	00c02004 	movi	r3,128
8112e4e0:	e0fe4d26 	beq	fp,r3,8112de18 <__reset+0xfb10de18>
8112e4e4:	4cf9c83a 	sub	fp,r9,r19
8112e4e8:	073e7b0e 	bge	zero,fp,8112ded8 <__reset+0xfb10ded8>
8112e4ec:	01c00404 	movi	r7,16
8112e4f0:	3f01900e 	bge	r7,fp,8112eb34 <___vfiprintf_internal_r+0x125c>
8112e4f4:	00e04574 	movhi	r3,33045
8112e4f8:	18f42604 	addi	r3,r3,-12136
8112e4fc:	d8c02415 	stw	r3,144(sp)
8112e500:	034001c4 	movi	r13,7
8112e504:	00000506 	br	8112e51c <___vfiprintf_internal_r+0xc44>
8112e508:	29000084 	addi	r4,r5,2
8112e50c:	42000204 	addi	r8,r8,8
8112e510:	180b883a 	mov	r5,r3
8112e514:	e73ffc04 	addi	fp,fp,-16
8112e518:	3f000d0e 	bge	r7,fp,8112e550 <___vfiprintf_internal_r+0xc78>
8112e51c:	10800404 	addi	r2,r2,16
8112e520:	28c00044 	addi	r3,r5,1
8112e524:	45c00015 	stw	r23,0(r8)
8112e528:	41c00115 	stw	r7,4(r8)
8112e52c:	d8801c15 	stw	r2,112(sp)
8112e530:	d8c01b15 	stw	r3,108(sp)
8112e534:	68fff40e 	bge	r13,r3,8112e508 <__reset+0xfb10e508>
8112e538:	1000101e 	bne	r2,zero,8112e57c <___vfiprintf_internal_r+0xca4>
8112e53c:	e73ffc04 	addi	fp,fp,-16
8112e540:	01000044 	movi	r4,1
8112e544:	000b883a 	mov	r5,zero
8112e548:	d811883a 	mov	r8,sp
8112e54c:	3f3ff316 	blt	r7,fp,8112e51c <__reset+0xfb10e51c>
8112e550:	da802417 	ldw	r10,144(sp)
8112e554:	1705883a 	add	r2,r2,fp
8112e558:	47000115 	stw	fp,4(r8)
8112e55c:	42800015 	stw	r10,0(r8)
8112e560:	d8801c15 	stw	r2,112(sp)
8112e564:	d9001b15 	stw	r4,108(sp)
8112e568:	00c001c4 	movi	r3,7
8112e56c:	19003616 	blt	r3,r4,8112e648 <___vfiprintf_internal_r+0xd70>
8112e570:	42000204 	addi	r8,r8,8
8112e574:	21000044 	addi	r4,r4,1
8112e578:	003e5706 	br	8112ded8 <__reset+0xfb10ded8>
8112e57c:	d9402117 	ldw	r5,132(sp)
8112e580:	d9002017 	ldw	r4,128(sp)
8112e584:	d9801a04 	addi	r6,sp,104
8112e588:	d9c02b15 	stw	r7,172(sp)
8112e58c:	db402a15 	stw	r13,168(sp)
8112e590:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e594:	d9c02b17 	ldw	r7,172(sp)
8112e598:	db402a17 	ldw	r13,168(sp)
8112e59c:	1000241e 	bne	r2,zero,8112e630 <___vfiprintf_internal_r+0xd58>
8112e5a0:	d9401b17 	ldw	r5,108(sp)
8112e5a4:	d8801c17 	ldw	r2,112(sp)
8112e5a8:	d811883a 	mov	r8,sp
8112e5ac:	29000044 	addi	r4,r5,1
8112e5b0:	003fd806 	br	8112e514 <__reset+0xfb10e514>
8112e5b4:	d9401b17 	ldw	r5,108(sp)
8112e5b8:	00e04574 	movhi	r3,33045
8112e5bc:	18f42a04 	addi	r3,r3,-12120
8112e5c0:	d8c02415 	stw	r3,144(sp)
8112e5c4:	29400044 	addi	r5,r5,1
8112e5c8:	d8c02417 	ldw	r3,144(sp)
8112e5cc:	14c5883a 	add	r2,r2,r19
8112e5d0:	44c00115 	stw	r19,4(r8)
8112e5d4:	40c00015 	stw	r3,0(r8)
8112e5d8:	d8801c15 	stw	r2,112(sp)
8112e5dc:	d9401b15 	stw	r5,108(sp)
8112e5e0:	00c001c4 	movi	r3,7
8112e5e4:	1940070e 	bge	r3,r5,8112e604 <___vfiprintf_internal_r+0xd2c>
8112e5e8:	103e4826 	beq	r2,zero,8112df0c <__reset+0xfb10df0c>
8112e5ec:	d9402117 	ldw	r5,132(sp)
8112e5f0:	d9002017 	ldw	r4,128(sp)
8112e5f4:	d9801a04 	addi	r6,sp,104
8112e5f8:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e5fc:	10000c1e 	bne	r2,zero,8112e630 <___vfiprintf_internal_r+0xd58>
8112e600:	d8801c17 	ldw	r2,112(sp)
8112e604:	8c80010e 	bge	r17,r18,8112e60c <___vfiprintf_internal_r+0xd34>
8112e608:	9023883a 	mov	r17,r18
8112e60c:	da802317 	ldw	r10,140(sp)
8112e610:	5455883a 	add	r10,r10,r17
8112e614:	da802315 	stw	r10,140(sp)
8112e618:	103e4126 	beq	r2,zero,8112df20 <__reset+0xfb10df20>
8112e61c:	d9402117 	ldw	r5,132(sp)
8112e620:	d9002017 	ldw	r4,128(sp)
8112e624:	d9801a04 	addi	r6,sp,104
8112e628:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e62c:	103e3c26 	beq	r2,zero,8112df20 <__reset+0xfb10df20>
8112e630:	dd002117 	ldw	r20,132(sp)
8112e634:	a080030b 	ldhu	r2,12(r20)
8112e638:	1080100c 	andi	r2,r2,64
8112e63c:	1001231e 	bne	r2,zero,8112eacc <___vfiprintf_internal_r+0x11f4>
8112e640:	d8802317 	ldw	r2,140(sp)
8112e644:	003d7b06 	br	8112dc34 <__reset+0xfb10dc34>
8112e648:	1000991e 	bne	r2,zero,8112e8b0 <___vfiprintf_internal_r+0xfd8>
8112e64c:	00c00044 	movi	r3,1
8112e650:	9805883a 	mov	r2,r19
8112e654:	dd400015 	stw	r21,0(sp)
8112e658:	dcc00115 	stw	r19,4(sp)
8112e65c:	dcc01c15 	stw	r19,112(sp)
8112e660:	d8c01b15 	stw	r3,108(sp)
8112e664:	d811883a 	mov	r8,sp
8112e668:	42000204 	addi	r8,r8,8
8112e66c:	a2c0010c 	andi	r11,r20,4
8112e670:	583fe426 	beq	r11,zero,8112e604 <__reset+0xfb10e604>
8112e674:	8ca7c83a 	sub	r19,r17,r18
8112e678:	04ffe20e 	bge	zero,r19,8112e604 <__reset+0xfb10e604>
8112e67c:	01c00404 	movi	r7,16
8112e680:	3cffcc0e 	bge	r7,r19,8112e5b4 <__reset+0xfb10e5b4>
8112e684:	02a04574 	movhi	r10,33045
8112e688:	52b42a04 	addi	r10,r10,-12120
8112e68c:	d9001b17 	ldw	r4,108(sp)
8112e690:	da802415 	stw	r10,144(sp)
8112e694:	382b883a 	mov	r21,r7
8112e698:	050001c4 	movi	r20,7
8112e69c:	df002017 	ldw	fp,128(sp)
8112e6a0:	00000506 	br	8112e6b8 <___vfiprintf_internal_r+0xde0>
8112e6a4:	21400084 	addi	r5,r4,2
8112e6a8:	42000204 	addi	r8,r8,8
8112e6ac:	1809883a 	mov	r4,r3
8112e6b0:	9cfffc04 	addi	r19,r19,-16
8112e6b4:	acffc40e 	bge	r21,r19,8112e5c8 <__reset+0xfb10e5c8>
8112e6b8:	10800404 	addi	r2,r2,16
8112e6bc:	20c00044 	addi	r3,r4,1
8112e6c0:	45800015 	stw	r22,0(r8)
8112e6c4:	45400115 	stw	r21,4(r8)
8112e6c8:	d8801c15 	stw	r2,112(sp)
8112e6cc:	d8c01b15 	stw	r3,108(sp)
8112e6d0:	a0fff40e 	bge	r20,r3,8112e6a4 <__reset+0xfb10e6a4>
8112e6d4:	1000041e 	bne	r2,zero,8112e6e8 <___vfiprintf_internal_r+0xe10>
8112e6d8:	01400044 	movi	r5,1
8112e6dc:	0009883a 	mov	r4,zero
8112e6e0:	d811883a 	mov	r8,sp
8112e6e4:	003ff206 	br	8112e6b0 <__reset+0xfb10e6b0>
8112e6e8:	d9402117 	ldw	r5,132(sp)
8112e6ec:	d9801a04 	addi	r6,sp,104
8112e6f0:	e009883a 	mov	r4,fp
8112e6f4:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e6f8:	103fcd1e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112e6fc:	d9001b17 	ldw	r4,108(sp)
8112e700:	d8801c17 	ldw	r2,112(sp)
8112e704:	d811883a 	mov	r8,sp
8112e708:	21400044 	addi	r5,r4,1
8112e70c:	003fe806 	br	8112e6b0 <__reset+0xfb10e6b0>
8112e710:	d9402117 	ldw	r5,132(sp)
8112e714:	d9002017 	ldw	r4,128(sp)
8112e718:	d9801a04 	addi	r6,sp,104
8112e71c:	d9c02b15 	stw	r7,172(sp)
8112e720:	db402a15 	stw	r13,168(sp)
8112e724:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e728:	d9c02b17 	ldw	r7,172(sp)
8112e72c:	db402a17 	ldw	r13,168(sp)
8112e730:	103fbf1e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112e734:	d9401b17 	ldw	r5,108(sp)
8112e738:	d8801c17 	ldw	r2,112(sp)
8112e73c:	d811883a 	mov	r8,sp
8112e740:	29800044 	addi	r6,r5,1
8112e744:	003dc406 	br	8112de58 <__reset+0xfb10de58>
8112e748:	1000d21e 	bne	r2,zero,8112ea94 <___vfiprintf_internal_r+0x11bc>
8112e74c:	d8c01d87 	ldb	r3,118(sp)
8112e750:	18009526 	beq	r3,zero,8112e9a8 <___vfiprintf_internal_r+0x10d0>
8112e754:	00800044 	movi	r2,1
8112e758:	d8c01d84 	addi	r3,sp,118
8112e75c:	1009883a 	mov	r4,r2
8112e760:	d8c00015 	stw	r3,0(sp)
8112e764:	d8800115 	stw	r2,4(sp)
8112e768:	d811883a 	mov	r8,sp
8112e76c:	200b883a 	mov	r5,r4
8112e770:	42000204 	addi	r8,r8,8
8112e774:	21000044 	addi	r4,r4,1
8112e778:	003d9706 	br	8112ddd8 <__reset+0xfb10ddd8>
8112e77c:	d9001d04 	addi	r4,sp,116
8112e780:	00800084 	movi	r2,2
8112e784:	d9000015 	stw	r4,0(sp)
8112e788:	d8800115 	stw	r2,4(sp)
8112e78c:	1809883a 	mov	r4,r3
8112e790:	d811883a 	mov	r8,sp
8112e794:	200b883a 	mov	r5,r4
8112e798:	42000204 	addi	r8,r8,8
8112e79c:	21000044 	addi	r4,r4,1
8112e7a0:	003f4e06 	br	8112e4dc <__reset+0xfb10e4dc>
8112e7a4:	d8001d85 	stb	zero,118(sp)
8112e7a8:	48005016 	blt	r9,zero,8112e8ec <___vfiprintf_internal_r+0x1014>
8112e7ac:	00ffdfc4 	movi	r3,-129
8112e7b0:	94c4b03a 	or	r2,r18,r19
8112e7b4:	a0e8703a 	and	r20,r20,r3
8112e7b8:	103d4426 	beq	r2,zero,8112dccc <__reset+0xfb10dccc>
8112e7bc:	0039883a 	mov	fp,zero
8112e7c0:	d9002617 	ldw	r4,152(sp)
8112e7c4:	dd401a04 	addi	r21,sp,104
8112e7c8:	908003cc 	andi	r2,r18,15
8112e7cc:	9806973a 	slli	r3,r19,28
8112e7d0:	2085883a 	add	r2,r4,r2
8112e7d4:	9024d13a 	srli	r18,r18,4
8112e7d8:	10800003 	ldbu	r2,0(r2)
8112e7dc:	9826d13a 	srli	r19,r19,4
8112e7e0:	ad7fffc4 	addi	r21,r21,-1
8112e7e4:	1ca4b03a 	or	r18,r3,r18
8112e7e8:	a8800005 	stb	r2,0(r21)
8112e7ec:	94c4b03a 	or	r2,r18,r19
8112e7f0:	103ff51e 	bne	r2,zero,8112e7c8 <__reset+0xfb10e7c8>
8112e7f4:	003e5906 	br	8112e15c <__reset+0xfb10e15c>
8112e7f8:	d9402117 	ldw	r5,132(sp)
8112e7fc:	d9002017 	ldw	r4,128(sp)
8112e800:	d9801a04 	addi	r6,sp,104
8112e804:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e808:	103f891e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112e80c:	d8801c17 	ldw	r2,112(sp)
8112e810:	d811883a 	mov	r8,sp
8112e814:	003f9506 	br	8112e66c <__reset+0xfb10e66c>
8112e818:	d9402117 	ldw	r5,132(sp)
8112e81c:	d9002017 	ldw	r4,128(sp)
8112e820:	d9801a04 	addi	r6,sp,104
8112e824:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e828:	103f811e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112e82c:	d811883a 	mov	r8,sp
8112e830:	003ced06 	br	8112dbe8 <__reset+0xfb10dbe8>
8112e834:	d9402117 	ldw	r5,132(sp)
8112e838:	d9002017 	ldw	r4,128(sp)
8112e83c:	d9801a04 	addi	r6,sp,104
8112e840:	da402c15 	stw	r9,176(sp)
8112e844:	db802a15 	stw	r14,168(sp)
8112e848:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e84c:	da402c17 	ldw	r9,176(sp)
8112e850:	db802a17 	ldw	r14,168(sp)
8112e854:	103f761e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112e858:	d9401b17 	ldw	r5,108(sp)
8112e85c:	d8801c17 	ldw	r2,112(sp)
8112e860:	d811883a 	mov	r8,sp
8112e864:	29000044 	addi	r4,r5,1
8112e868:	003d5b06 	br	8112ddd8 <__reset+0xfb10ddd8>
8112e86c:	d9402117 	ldw	r5,132(sp)
8112e870:	d9002017 	ldw	r4,128(sp)
8112e874:	d9801a04 	addi	r6,sp,104
8112e878:	da402c15 	stw	r9,176(sp)
8112e87c:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e880:	da402c17 	ldw	r9,176(sp)
8112e884:	103f6a1e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112e888:	d9401b17 	ldw	r5,108(sp)
8112e88c:	d8801c17 	ldw	r2,112(sp)
8112e890:	d811883a 	mov	r8,sp
8112e894:	29000044 	addi	r4,r5,1
8112e898:	003f1006 	br	8112e4dc <__reset+0xfb10e4dc>
8112e89c:	1000c31e 	bne	r2,zero,8112ebac <___vfiprintf_internal_r+0x12d4>
8112e8a0:	01000044 	movi	r4,1
8112e8a4:	000b883a 	mov	r5,zero
8112e8a8:	d811883a 	mov	r8,sp
8112e8ac:	003f0d06 	br	8112e4e4 <__reset+0xfb10e4e4>
8112e8b0:	d9402117 	ldw	r5,132(sp)
8112e8b4:	d9002017 	ldw	r4,128(sp)
8112e8b8:	d9801a04 	addi	r6,sp,104
8112e8bc:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112e8c0:	103f5b1e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112e8c4:	d9001b17 	ldw	r4,108(sp)
8112e8c8:	d8801c17 	ldw	r2,112(sp)
8112e8cc:	d811883a 	mov	r8,sp
8112e8d0:	21000044 	addi	r4,r4,1
8112e8d4:	003d8006 	br	8112ded8 <__reset+0xfb10ded8>
8112e8d8:	01204574 	movhi	r4,33045
8112e8dc:	21339404 	addi	r4,r4,-12720
8112e8e0:	d9002615 	stw	r4,152(sp)
8112e8e4:	d8c02215 	stw	r3,136(sp)
8112e8e8:	1029883a 	mov	r20,r2
8112e8ec:	94c4b03a 	or	r2,r18,r19
8112e8f0:	103fb21e 	bne	r2,zero,8112e7bc <__reset+0xfb10e7bc>
8112e8f4:	0039883a 	mov	fp,zero
8112e8f8:	00800084 	movi	r2,2
8112e8fc:	003e6b06 	br	8112e2ac <__reset+0xfb10e2ac>
8112e900:	da802217 	ldw	r10,136(sp)
8112e904:	d8001d85 	stb	zero,118(sp)
8112e908:	0027883a 	mov	r19,zero
8112e90c:	50800104 	addi	r2,r10,4
8112e910:	54800017 	ldw	r18,0(r10)
8112e914:	483e6016 	blt	r9,zero,8112e298 <__reset+0xfb10e298>
8112e918:	00ffdfc4 	movi	r3,-129
8112e91c:	d8802215 	stw	r2,136(sp)
8112e920:	a0e8703a 	and	r20,r20,r3
8112e924:	0039883a 	mov	fp,zero
8112e928:	903ebb26 	beq	r18,zero,8112e418 <__reset+0xfb10e418>
8112e92c:	00800244 	movi	r2,9
8112e930:	14bdee36 	bltu	r2,r18,8112e0ec <__reset+0xfb10e0ec>
8112e934:	003eba06 	br	8112e420 <__reset+0xfb10e420>
8112e938:	00800c04 	movi	r2,48
8112e93c:	d8c01d45 	stb	r3,117(sp)
8112e940:	d8801d05 	stb	r2,116(sp)
8112e944:	d8001d85 	stb	zero,118(sp)
8112e948:	a0c00094 	ori	r3,r20,2
8112e94c:	4800a916 	blt	r9,zero,8112ebf4 <___vfiprintf_internal_r+0x131c>
8112e950:	00bfdfc4 	movi	r2,-129
8112e954:	a096703a 	and	r11,r20,r2
8112e958:	5d000094 	ori	r20,r11,2
8112e95c:	0039883a 	mov	fp,zero
8112e960:	003f9706 	br	8112e7c0 <__reset+0xfb10e7c0>
8112e964:	8025883a 	mov	r18,r16
8112e968:	003c2e06 	br	8112da24 <__reset+0xfb10da24>
8112e96c:	00a04574 	movhi	r2,33045
8112e970:	10b39404 	addi	r2,r2,-12720
8112e974:	0039883a 	mov	fp,zero
8112e978:	d8802615 	stw	r2,152(sp)
8112e97c:	003f9006 	br	8112e7c0 <__reset+0xfb10e7c0>
8112e980:	04a5c83a 	sub	r18,zero,r18
8112e984:	07000b44 	movi	fp,45
8112e988:	9004c03a 	cmpne	r2,r18,zero
8112e98c:	04e7c83a 	sub	r19,zero,r19
8112e990:	df001d85 	stb	fp,118(sp)
8112e994:	98a7c83a 	sub	r19,r19,r2
8112e998:	48009f16 	blt	r9,zero,8112ec18 <___vfiprintf_internal_r+0x1340>
8112e99c:	00bfdfc4 	movi	r2,-129
8112e9a0:	a0a8703a 	and	r20,r20,r2
8112e9a4:	003dd006 	br	8112e0e8 <__reset+0xfb10e0e8>
8112e9a8:	70004c26 	beq	r14,zero,8112eadc <___vfiprintf_internal_r+0x1204>
8112e9ac:	00800084 	movi	r2,2
8112e9b0:	d8c01d04 	addi	r3,sp,116
8112e9b4:	d8c00015 	stw	r3,0(sp)
8112e9b8:	d8800115 	stw	r2,4(sp)
8112e9bc:	01000044 	movi	r4,1
8112e9c0:	d811883a 	mov	r8,sp
8112e9c4:	003f7306 	br	8112e794 <__reset+0xfb10e794>
8112e9c8:	a080100c 	andi	r2,r20,64
8112e9cc:	da802217 	ldw	r10,136(sp)
8112e9d0:	103e0626 	beq	r2,zero,8112e1ec <__reset+0xfb10e1ec>
8112e9d4:	5480000f 	ldh	r18,0(r10)
8112e9d8:	52800104 	addi	r10,r10,4
8112e9dc:	da802215 	stw	r10,136(sp)
8112e9e0:	9027d7fa 	srai	r19,r18,31
8112e9e4:	9805883a 	mov	r2,r19
8112e9e8:	003db806 	br	8112e0cc <__reset+0xfb10e0cc>
8112e9ec:	a080040c 	andi	r2,r20,16
8112e9f0:	1000091e 	bne	r2,zero,8112ea18 <___vfiprintf_internal_r+0x1140>
8112e9f4:	a2c0100c 	andi	r11,r20,64
8112e9f8:	58000726 	beq	r11,zero,8112ea18 <___vfiprintf_internal_r+0x1140>
8112e9fc:	da802217 	ldw	r10,136(sp)
8112ea00:	50800017 	ldw	r2,0(r10)
8112ea04:	52800104 	addi	r10,r10,4
8112ea08:	da802215 	stw	r10,136(sp)
8112ea0c:	da802317 	ldw	r10,140(sp)
8112ea10:	1280000d 	sth	r10,0(r2)
8112ea14:	003be706 	br	8112d9b4 <__reset+0xfb10d9b4>
8112ea18:	da802217 	ldw	r10,136(sp)
8112ea1c:	50800017 	ldw	r2,0(r10)
8112ea20:	52800104 	addi	r10,r10,4
8112ea24:	da802215 	stw	r10,136(sp)
8112ea28:	da802317 	ldw	r10,140(sp)
8112ea2c:	12800015 	stw	r10,0(r2)
8112ea30:	003be006 	br	8112d9b4 <__reset+0xfb10d9b4>
8112ea34:	a080100c 	andi	r2,r20,64
8112ea38:	da802217 	ldw	r10,136(sp)
8112ea3c:	10003026 	beq	r2,zero,8112eb00 <___vfiprintf_internal_r+0x1228>
8112ea40:	5480000b 	ldhu	r18,0(r10)
8112ea44:	52800104 	addi	r10,r10,4
8112ea48:	0027883a 	mov	r19,zero
8112ea4c:	da802215 	stw	r10,136(sp)
8112ea50:	003d8006 	br	8112e054 <__reset+0xfb10e054>
8112ea54:	80c00007 	ldb	r3,0(r16)
8112ea58:	003c0006 	br	8112da5c <__reset+0xfb10da5c>
8112ea5c:	a080100c 	andi	r2,r20,64
8112ea60:	d8001d85 	stb	zero,118(sp)
8112ea64:	da802217 	ldw	r10,136(sp)
8112ea68:	1000201e 	bne	r2,zero,8112eaec <___vfiprintf_internal_r+0x1214>
8112ea6c:	50800104 	addi	r2,r10,4
8112ea70:	54800017 	ldw	r18,0(r10)
8112ea74:	0027883a 	mov	r19,zero
8112ea78:	483def0e 	bge	r9,zero,8112e238 <__reset+0xfb10e238>
8112ea7c:	94c6b03a 	or	r3,r18,r19
8112ea80:	d8802215 	stw	r2,136(sp)
8112ea84:	183d4e1e 	bne	r3,zero,8112dfc0 <__reset+0xfb10dfc0>
8112ea88:	0039883a 	mov	fp,zero
8112ea8c:	0005883a 	mov	r2,zero
8112ea90:	003e0606 	br	8112e2ac <__reset+0xfb10e2ac>
8112ea94:	d9402117 	ldw	r5,132(sp)
8112ea98:	d9002017 	ldw	r4,128(sp)
8112ea9c:	d9801a04 	addi	r6,sp,104
8112eaa0:	da402c15 	stw	r9,176(sp)
8112eaa4:	db802a15 	stw	r14,168(sp)
8112eaa8:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112eaac:	da402c17 	ldw	r9,176(sp)
8112eab0:	db802a17 	ldw	r14,168(sp)
8112eab4:	103ede1e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112eab8:	d9401b17 	ldw	r5,108(sp)
8112eabc:	d8801c17 	ldw	r2,112(sp)
8112eac0:	d811883a 	mov	r8,sp
8112eac4:	29000044 	addi	r4,r5,1
8112eac8:	003e7406 	br	8112e49c <__reset+0xfb10e49c>
8112eacc:	00bfffc4 	movi	r2,-1
8112ead0:	003c5806 	br	8112dc34 <__reset+0xfb10dc34>
8112ead4:	d811883a 	mov	r8,sp
8112ead8:	003ee806 	br	8112e67c <__reset+0xfb10e67c>
8112eadc:	000b883a 	mov	r5,zero
8112eae0:	01000044 	movi	r4,1
8112eae4:	d811883a 	mov	r8,sp
8112eae8:	003e7c06 	br	8112e4dc <__reset+0xfb10e4dc>
8112eaec:	50800104 	addi	r2,r10,4
8112eaf0:	5480000b 	ldhu	r18,0(r10)
8112eaf4:	0027883a 	mov	r19,zero
8112eaf8:	483dcf0e 	bge	r9,zero,8112e238 <__reset+0xfb10e238>
8112eafc:	003fdf06 	br	8112ea7c <__reset+0xfb10ea7c>
8112eb00:	54800017 	ldw	r18,0(r10)
8112eb04:	52800104 	addi	r10,r10,4
8112eb08:	0027883a 	mov	r19,zero
8112eb0c:	da802215 	stw	r10,136(sp)
8112eb10:	003d5006 	br	8112e054 <__reset+0xfb10e054>
8112eb14:	50800104 	addi	r2,r10,4
8112eb18:	5480000b 	ldhu	r18,0(r10)
8112eb1c:	0027883a 	mov	r19,zero
8112eb20:	483f7d0e 	bge	r9,zero,8112e918 <__reset+0xfb10e918>
8112eb24:	003ddc06 	br	8112e298 <__reset+0xfb10e298>
8112eb28:	d8c02215 	stw	r3,136(sp)
8112eb2c:	0039883a 	mov	fp,zero
8112eb30:	003ddb06 	br	8112e2a0 <__reset+0xfb10e2a0>
8112eb34:	02a04574 	movhi	r10,33045
8112eb38:	52b42604 	addi	r10,r10,-12136
8112eb3c:	da802415 	stw	r10,144(sp)
8112eb40:	003e8306 	br	8112e550 <__reset+0xfb10e550>
8112eb44:	d8801c17 	ldw	r2,112(sp)
8112eb48:	dd002117 	ldw	r20,132(sp)
8112eb4c:	103eb926 	beq	r2,zero,8112e634 <__reset+0xfb10e634>
8112eb50:	d9002017 	ldw	r4,128(sp)
8112eb54:	d9801a04 	addi	r6,sp,104
8112eb58:	a00b883a 	mov	r5,r20
8112eb5c:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112eb60:	003eb406 	br	8112e634 <__reset+0xfb10e634>
8112eb64:	80c00043 	ldbu	r3,1(r16)
8112eb68:	a5000814 	ori	r20,r20,32
8112eb6c:	84000044 	addi	r16,r16,1
8112eb70:	18c03fcc 	andi	r3,r3,255
8112eb74:	18c0201c 	xori	r3,r3,128
8112eb78:	18ffe004 	addi	r3,r3,-128
8112eb7c:	003bb706 	br	8112da5c <__reset+0xfb10da5c>
8112eb80:	a809883a 	mov	r4,r21
8112eb84:	d8c02a15 	stw	r3,168(sp)
8112eb88:	da002b15 	stw	r8,172(sp)
8112eb8c:	111f1b80 	call	8111f1b8 <strlen>
8112eb90:	d8c02a17 	ldw	r3,168(sp)
8112eb94:	1027883a 	mov	r19,r2
8112eb98:	df001d83 	ldbu	fp,118(sp)
8112eb9c:	d8c02215 	stw	r3,136(sp)
8112eba0:	0013883a 	mov	r9,zero
8112eba4:	da002b17 	ldw	r8,172(sp)
8112eba8:	003c4d06 	br	8112dce0 <__reset+0xfb10dce0>
8112ebac:	d9402117 	ldw	r5,132(sp)
8112ebb0:	d9002017 	ldw	r4,128(sp)
8112ebb4:	d9801a04 	addi	r6,sp,104
8112ebb8:	da402c15 	stw	r9,176(sp)
8112ebbc:	112d7bc0 	call	8112d7bc <__sprint_r.part.0>
8112ebc0:	da402c17 	ldw	r9,176(sp)
8112ebc4:	103e9a1e 	bne	r2,zero,8112e630 <__reset+0xfb10e630>
8112ebc8:	d9401b17 	ldw	r5,108(sp)
8112ebcc:	d8801c17 	ldw	r2,112(sp)
8112ebd0:	d811883a 	mov	r8,sp
8112ebd4:	29000044 	addi	r4,r5,1
8112ebd8:	003e4206 	br	8112e4e4 <__reset+0xfb10e4e4>
8112ebdc:	d9401b17 	ldw	r5,108(sp)
8112ebe0:	01204574 	movhi	r4,33045
8112ebe4:	21342a04 	addi	r4,r4,-12120
8112ebe8:	d9002415 	stw	r4,144(sp)
8112ebec:	29400044 	addi	r5,r5,1
8112ebf0:	003c6d06 	br	8112dda8 <__reset+0xfb10dda8>
8112ebf4:	0039883a 	mov	fp,zero
8112ebf8:	00800084 	movi	r2,2
8112ebfc:	10803fcc 	andi	r2,r2,255
8112ec00:	01000044 	movi	r4,1
8112ec04:	11001e26 	beq	r2,r4,8112ec80 <___vfiprintf_internal_r+0x13a8>
8112ec08:	01000084 	movi	r4,2
8112ec0c:	11001e1e 	bne	r2,r4,8112ec88 <___vfiprintf_internal_r+0x13b0>
8112ec10:	1829883a 	mov	r20,r3
8112ec14:	003eea06 	br	8112e7c0 <__reset+0xfb10e7c0>
8112ec18:	a007883a 	mov	r3,r20
8112ec1c:	00800044 	movi	r2,1
8112ec20:	003ff606 	br	8112ebfc <__reset+0xfb10ebfc>
8112ec24:	00800184 	movi	r2,6
8112ec28:	1240012e 	bgeu	r2,r9,8112ec30 <___vfiprintf_internal_r+0x1358>
8112ec2c:	1013883a 	mov	r9,r2
8112ec30:	4827883a 	mov	r19,r9
8112ec34:	4825883a 	mov	r18,r9
8112ec38:	48001516 	blt	r9,zero,8112ec90 <___vfiprintf_internal_r+0x13b8>
8112ec3c:	05604574 	movhi	r21,33045
8112ec40:	d8c02215 	stw	r3,136(sp)
8112ec44:	ad739904 	addi	r21,r21,-12700
8112ec48:	003d1406 	br	8112e09c <__reset+0xfb10e09c>
8112ec4c:	02a04574 	movhi	r10,33045
8112ec50:	52b42604 	addi	r10,r10,-12136
8112ec54:	da802415 	stw	r10,144(sp)
8112ec58:	200d883a 	mov	r6,r4
8112ec5c:	003c9106 	br	8112dea4 <__reset+0xfb10dea4>
8112ec60:	5021883a 	mov	r16,r10
8112ec64:	0013883a 	mov	r9,zero
8112ec68:	003b7d06 	br	8112da60 <__reset+0xfb10da60>
8112ec6c:	4827883a 	mov	r19,r9
8112ec70:	df001d83 	ldbu	fp,118(sp)
8112ec74:	d8c02215 	stw	r3,136(sp)
8112ec78:	0013883a 	mov	r9,zero
8112ec7c:	003c1806 	br	8112dce0 <__reset+0xfb10dce0>
8112ec80:	1829883a 	mov	r20,r3
8112ec84:	003d1806 	br	8112e0e8 <__reset+0xfb10e0e8>
8112ec88:	1829883a 	mov	r20,r3
8112ec8c:	003ccd06 	br	8112dfc4 <__reset+0xfb10dfc4>
8112ec90:	0025883a 	mov	r18,zero
8112ec94:	003fe906 	br	8112ec3c <__reset+0xfb10ec3c>
8112ec98:	d8802217 	ldw	r2,136(sp)
8112ec9c:	80c00043 	ldbu	r3,1(r16)
8112eca0:	5021883a 	mov	r16,r10
8112eca4:	12400017 	ldw	r9,0(r2)
8112eca8:	10800104 	addi	r2,r2,4
8112ecac:	d8802215 	stw	r2,136(sp)
8112ecb0:	483faf0e 	bge	r9,zero,8112eb70 <__reset+0xfb10eb70>
8112ecb4:	18c03fcc 	andi	r3,r3,255
8112ecb8:	18c0201c 	xori	r3,r3,128
8112ecbc:	027fffc4 	movi	r9,-1
8112ecc0:	18ffe004 	addi	r3,r3,-128
8112ecc4:	003b6506 	br	8112da5c <__reset+0xfb10da5c>
8112ecc8:	d9c01d85 	stb	r7,118(sp)
8112eccc:	003ca006 	br	8112df50 <__reset+0xfb10df50>
8112ecd0:	d9c01d85 	stb	r7,118(sp)
8112ecd4:	003cad06 	br	8112df8c <__reset+0xfb10df8c>
8112ecd8:	d9c01d85 	stb	r7,118(sp)
8112ecdc:	003d7d06 	br	8112e2d4 <__reset+0xfb10e2d4>
8112ece0:	d9c01d85 	stb	r7,118(sp)
8112ece4:	003d5f06 	br	8112e264 <__reset+0xfb10e264>
8112ece8:	a080004c 	andi	r2,r20,1
8112ecec:	0039883a 	mov	fp,zero
8112ecf0:	10000526 	beq	r2,zero,8112ed08 <___vfiprintf_internal_r+0x1430>
8112ecf4:	00800c04 	movi	r2,48
8112ecf8:	d88019c5 	stb	r2,103(sp)
8112ecfc:	dcc02717 	ldw	r19,156(sp)
8112ed00:	dd4019c4 	addi	r21,sp,103
8112ed04:	003bf606 	br	8112dce0 <__reset+0xfb10dce0>
8112ed08:	0027883a 	mov	r19,zero
8112ed0c:	dd401a04 	addi	r21,sp,104
8112ed10:	003bf306 	br	8112dce0 <__reset+0xfb10dce0>
8112ed14:	d9c01d85 	stb	r7,118(sp)
8112ed18:	003dc806 	br	8112e43c <__reset+0xfb10e43c>
8112ed1c:	d9c01d85 	stb	r7,118(sp)
8112ed20:	003d3a06 	br	8112e20c <__reset+0xfb10e20c>
8112ed24:	d9c01d85 	stb	r7,118(sp)
8112ed28:	003d2a06 	br	8112e1d4 <__reset+0xfb10e1d4>
8112ed2c:	d9c01d85 	stb	r7,118(sp)
8112ed30:	003cde06 	br	8112e0ac <__reset+0xfb10e0ac>
8112ed34:	d9c01d85 	stb	r7,118(sp)
8112ed38:	003cbc06 	br	8112e02c <__reset+0xfb10e02c>

8112ed3c <__vfiprintf_internal>:
8112ed3c:	00a04574 	movhi	r2,33045
8112ed40:	10bd6304 	addi	r2,r2,-2676
8112ed44:	300f883a 	mov	r7,r6
8112ed48:	280d883a 	mov	r6,r5
8112ed4c:	200b883a 	mov	r5,r4
8112ed50:	11000017 	ldw	r4,0(r2)
8112ed54:	112d8d81 	jmpi	8112d8d8 <___vfiprintf_internal_r>

8112ed58 <__sbprintf>:
8112ed58:	defee204 	addi	sp,sp,-1144
8112ed5c:	de00012e 	bgeu	sp,et,8112ed64 <__sbprintf+0xc>
8112ed60:	003b68fa 	trap	3
8112ed64:	2880030b 	ldhu	r2,12(r5)
8112ed68:	2ac01917 	ldw	r11,100(r5)
8112ed6c:	2a80038b 	ldhu	r10,14(r5)
8112ed70:	2a400717 	ldw	r9,28(r5)
8112ed74:	2a000917 	ldw	r8,36(r5)
8112ed78:	00c10004 	movi	r3,1024
8112ed7c:	dc011a15 	stw	r16,1128(sp)
8112ed80:	10bfff4c 	andi	r2,r2,65533
8112ed84:	2821883a 	mov	r16,r5
8112ed88:	d8cb883a 	add	r5,sp,r3
8112ed8c:	dc811c15 	stw	r18,1136(sp)
8112ed90:	dc411b15 	stw	r17,1132(sp)
8112ed94:	dfc11d15 	stw	ra,1140(sp)
8112ed98:	2025883a 	mov	r18,r4
8112ed9c:	d881030d 	sth	r2,1036(sp)
8112eda0:	dac11915 	stw	r11,1124(sp)
8112eda4:	da81038d 	sth	r10,1038(sp)
8112eda8:	da410715 	stw	r9,1052(sp)
8112edac:	da010915 	stw	r8,1060(sp)
8112edb0:	dec10015 	stw	sp,1024(sp)
8112edb4:	dec10415 	stw	sp,1040(sp)
8112edb8:	d8c10215 	stw	r3,1032(sp)
8112edbc:	d8c10515 	stw	r3,1044(sp)
8112edc0:	d8010615 	stw	zero,1048(sp)
8112edc4:	112d8d80 	call	8112d8d8 <___vfiprintf_internal_r>
8112edc8:	1023883a 	mov	r17,r2
8112edcc:	10000416 	blt	r2,zero,8112ede0 <__sbprintf+0x88>
8112edd0:	d9410004 	addi	r5,sp,1024
8112edd4:	9009883a 	mov	r4,r18
8112edd8:	11270900 	call	81127090 <_fflush_r>
8112eddc:	10000d1e 	bne	r2,zero,8112ee14 <__sbprintf+0xbc>
8112ede0:	d881030b 	ldhu	r2,1036(sp)
8112ede4:	1080100c 	andi	r2,r2,64
8112ede8:	10000326 	beq	r2,zero,8112edf8 <__sbprintf+0xa0>
8112edec:	8080030b 	ldhu	r2,12(r16)
8112edf0:	10801014 	ori	r2,r2,64
8112edf4:	8080030d 	sth	r2,12(r16)
8112edf8:	8805883a 	mov	r2,r17
8112edfc:	dfc11d17 	ldw	ra,1140(sp)
8112ee00:	dc811c17 	ldw	r18,1136(sp)
8112ee04:	dc411b17 	ldw	r17,1132(sp)
8112ee08:	dc011a17 	ldw	r16,1128(sp)
8112ee0c:	dec11e04 	addi	sp,sp,1144
8112ee10:	f800283a 	ret
8112ee14:	047fffc4 	movi	r17,-1
8112ee18:	003ff106 	br	8112ede0 <__reset+0xfb10ede0>

8112ee1c <_calloc_r>:
8112ee1c:	298b383a 	mul	r5,r5,r6
8112ee20:	defffe04 	addi	sp,sp,-8
8112ee24:	de00012e 	bgeu	sp,et,8112ee2c <_calloc_r+0x10>
8112ee28:	003b68fa 	trap	3
8112ee2c:	dfc00115 	stw	ra,4(sp)
8112ee30:	dc000015 	stw	r16,0(sp)
8112ee34:	111deb00 	call	8111deb0 <_malloc_r>
8112ee38:	10002926 	beq	r2,zero,8112eee0 <_calloc_r+0xc4>
8112ee3c:	11bfff17 	ldw	r6,-4(r2)
8112ee40:	1021883a 	mov	r16,r2
8112ee44:	00bfff04 	movi	r2,-4
8112ee48:	308c703a 	and	r6,r6,r2
8112ee4c:	00c00904 	movi	r3,36
8112ee50:	308d883a 	add	r6,r6,r2
8112ee54:	19801636 	bltu	r3,r6,8112eeb0 <_calloc_r+0x94>
8112ee58:	008004c4 	movi	r2,19
8112ee5c:	11800b2e 	bgeu	r2,r6,8112ee8c <_calloc_r+0x70>
8112ee60:	80000015 	stw	zero,0(r16)
8112ee64:	80000115 	stw	zero,4(r16)
8112ee68:	008006c4 	movi	r2,27
8112ee6c:	11801a2e 	bgeu	r2,r6,8112eed8 <_calloc_r+0xbc>
8112ee70:	80000215 	stw	zero,8(r16)
8112ee74:	80000315 	stw	zero,12(r16)
8112ee78:	30c0151e 	bne	r6,r3,8112eed0 <_calloc_r+0xb4>
8112ee7c:	80000415 	stw	zero,16(r16)
8112ee80:	80800604 	addi	r2,r16,24
8112ee84:	80000515 	stw	zero,20(r16)
8112ee88:	00000106 	br	8112ee90 <_calloc_r+0x74>
8112ee8c:	8005883a 	mov	r2,r16
8112ee90:	10000015 	stw	zero,0(r2)
8112ee94:	10000115 	stw	zero,4(r2)
8112ee98:	10000215 	stw	zero,8(r2)
8112ee9c:	8005883a 	mov	r2,r16
8112eea0:	dfc00117 	ldw	ra,4(sp)
8112eea4:	dc000017 	ldw	r16,0(sp)
8112eea8:	dec00204 	addi	sp,sp,8
8112eeac:	f800283a 	ret
8112eeb0:	000b883a 	mov	r5,zero
8112eeb4:	8009883a 	mov	r4,r16
8112eeb8:	111e8140 	call	8111e814 <memset>
8112eebc:	8005883a 	mov	r2,r16
8112eec0:	dfc00117 	ldw	ra,4(sp)
8112eec4:	dc000017 	ldw	r16,0(sp)
8112eec8:	dec00204 	addi	sp,sp,8
8112eecc:	f800283a 	ret
8112eed0:	80800404 	addi	r2,r16,16
8112eed4:	003fee06 	br	8112ee90 <__reset+0xfb10ee90>
8112eed8:	80800204 	addi	r2,r16,8
8112eedc:	003fec06 	br	8112ee90 <__reset+0xfb10ee90>
8112eee0:	0005883a 	mov	r2,zero
8112eee4:	003fee06 	br	8112eea0 <__reset+0xfb10eea0>

8112eee8 <_fclose_r>:
8112eee8:	28003b26 	beq	r5,zero,8112efd8 <_fclose_r+0xf0>
8112eeec:	defffc04 	addi	sp,sp,-16
8112eef0:	de00012e 	bgeu	sp,et,8112eef8 <_fclose_r+0x10>
8112eef4:	003b68fa 	trap	3
8112eef8:	dc400115 	stw	r17,4(sp)
8112eefc:	dc000015 	stw	r16,0(sp)
8112ef00:	dfc00315 	stw	ra,12(sp)
8112ef04:	dc800215 	stw	r18,8(sp)
8112ef08:	2023883a 	mov	r17,r4
8112ef0c:	2821883a 	mov	r16,r5
8112ef10:	20000226 	beq	r4,zero,8112ef1c <_fclose_r+0x34>
8112ef14:	20800e17 	ldw	r2,56(r4)
8112ef18:	10002726 	beq	r2,zero,8112efb8 <_fclose_r+0xd0>
8112ef1c:	8080030f 	ldh	r2,12(r16)
8112ef20:	1000071e 	bne	r2,zero,8112ef40 <_fclose_r+0x58>
8112ef24:	0005883a 	mov	r2,zero
8112ef28:	dfc00317 	ldw	ra,12(sp)
8112ef2c:	dc800217 	ldw	r18,8(sp)
8112ef30:	dc400117 	ldw	r17,4(sp)
8112ef34:	dc000017 	ldw	r16,0(sp)
8112ef38:	dec00404 	addi	sp,sp,16
8112ef3c:	f800283a 	ret
8112ef40:	800b883a 	mov	r5,r16
8112ef44:	8809883a 	mov	r4,r17
8112ef48:	1126e6c0 	call	81126e6c <__sflush_r>
8112ef4c:	1025883a 	mov	r18,r2
8112ef50:	80800b17 	ldw	r2,44(r16)
8112ef54:	10000426 	beq	r2,zero,8112ef68 <_fclose_r+0x80>
8112ef58:	81400717 	ldw	r5,28(r16)
8112ef5c:	8809883a 	mov	r4,r17
8112ef60:	103ee83a 	callr	r2
8112ef64:	10001616 	blt	r2,zero,8112efc0 <_fclose_r+0xd8>
8112ef68:	8080030b 	ldhu	r2,12(r16)
8112ef6c:	1080200c 	andi	r2,r2,128
8112ef70:	1000151e 	bne	r2,zero,8112efc8 <_fclose_r+0xe0>
8112ef74:	81400c17 	ldw	r5,48(r16)
8112ef78:	28000526 	beq	r5,zero,8112ef90 <_fclose_r+0xa8>
8112ef7c:	80801004 	addi	r2,r16,64
8112ef80:	28800226 	beq	r5,r2,8112ef8c <_fclose_r+0xa4>
8112ef84:	8809883a 	mov	r4,r17
8112ef88:	11279240 	call	81127924 <_free_r>
8112ef8c:	80000c15 	stw	zero,48(r16)
8112ef90:	81401117 	ldw	r5,68(r16)
8112ef94:	28000326 	beq	r5,zero,8112efa4 <_fclose_r+0xbc>
8112ef98:	8809883a 	mov	r4,r17
8112ef9c:	11279240 	call	81127924 <_free_r>
8112efa0:	80001115 	stw	zero,68(r16)
8112efa4:	112749c0 	call	8112749c <__sfp_lock_acquire>
8112efa8:	8000030d 	sth	zero,12(r16)
8112efac:	11274a00 	call	811274a0 <__sfp_lock_release>
8112efb0:	9005883a 	mov	r2,r18
8112efb4:	003fdc06 	br	8112ef28 <__reset+0xfb10ef28>
8112efb8:	112748c0 	call	8112748c <__sinit>
8112efbc:	003fd706 	br	8112ef1c <__reset+0xfb10ef1c>
8112efc0:	04bfffc4 	movi	r18,-1
8112efc4:	003fe806 	br	8112ef68 <__reset+0xfb10ef68>
8112efc8:	81400417 	ldw	r5,16(r16)
8112efcc:	8809883a 	mov	r4,r17
8112efd0:	11279240 	call	81127924 <_free_r>
8112efd4:	003fe706 	br	8112ef74 <__reset+0xfb10ef74>
8112efd8:	0005883a 	mov	r2,zero
8112efdc:	f800283a 	ret

8112efe0 <fclose>:
8112efe0:	00a04574 	movhi	r2,33045
8112efe4:	10bd6304 	addi	r2,r2,-2676
8112efe8:	200b883a 	mov	r5,r4
8112efec:	11000017 	ldw	r4,0(r2)
8112eff0:	112eee81 	jmpi	8112eee8 <_fclose_r>

8112eff4 <__fputwc>:
8112eff4:	defff804 	addi	sp,sp,-32
8112eff8:	de00012e 	bgeu	sp,et,8112f000 <__fputwc+0xc>
8112effc:	003b68fa 	trap	3
8112f000:	dcc00415 	stw	r19,16(sp)
8112f004:	dc800315 	stw	r18,12(sp)
8112f008:	dc000115 	stw	r16,4(sp)
8112f00c:	dfc00715 	stw	ra,28(sp)
8112f010:	dd400615 	stw	r21,24(sp)
8112f014:	dd000515 	stw	r20,20(sp)
8112f018:	dc400215 	stw	r17,8(sp)
8112f01c:	2027883a 	mov	r19,r4
8112f020:	2825883a 	mov	r18,r5
8112f024:	3021883a 	mov	r16,r6
8112f028:	11283b40 	call	811283b4 <__locale_mb_cur_max>
8112f02c:	00c00044 	movi	r3,1
8112f030:	10c03e26 	beq	r2,r3,8112f12c <__fputwc+0x138>
8112f034:	81c01704 	addi	r7,r16,92
8112f038:	900d883a 	mov	r6,r18
8112f03c:	d80b883a 	mov	r5,sp
8112f040:	9809883a 	mov	r4,r19
8112f044:	112fe780 	call	8112fe78 <_wcrtomb_r>
8112f048:	1029883a 	mov	r20,r2
8112f04c:	00bfffc4 	movi	r2,-1
8112f050:	a0802026 	beq	r20,r2,8112f0d4 <__fputwc+0xe0>
8112f054:	d9400003 	ldbu	r5,0(sp)
8112f058:	a0001c26 	beq	r20,zero,8112f0cc <__fputwc+0xd8>
8112f05c:	0023883a 	mov	r17,zero
8112f060:	05400284 	movi	r21,10
8112f064:	00000906 	br	8112f08c <__fputwc+0x98>
8112f068:	80800017 	ldw	r2,0(r16)
8112f06c:	11400005 	stb	r5,0(r2)
8112f070:	80c00017 	ldw	r3,0(r16)
8112f074:	18c00044 	addi	r3,r3,1
8112f078:	80c00015 	stw	r3,0(r16)
8112f07c:	8c400044 	addi	r17,r17,1
8112f080:	dc45883a 	add	r2,sp,r17
8112f084:	8d00112e 	bgeu	r17,r20,8112f0cc <__fputwc+0xd8>
8112f088:	11400003 	ldbu	r5,0(r2)
8112f08c:	80c00217 	ldw	r3,8(r16)
8112f090:	18ffffc4 	addi	r3,r3,-1
8112f094:	80c00215 	stw	r3,8(r16)
8112f098:	183ff30e 	bge	r3,zero,8112f068 <__reset+0xfb10f068>
8112f09c:	80800617 	ldw	r2,24(r16)
8112f0a0:	18801916 	blt	r3,r2,8112f108 <__fputwc+0x114>
8112f0a4:	80800017 	ldw	r2,0(r16)
8112f0a8:	11400005 	stb	r5,0(r2)
8112f0ac:	80800017 	ldw	r2,0(r16)
8112f0b0:	10c00003 	ldbu	r3,0(r2)
8112f0b4:	10800044 	addi	r2,r2,1
8112f0b8:	1d402326 	beq	r3,r21,8112f148 <__fputwc+0x154>
8112f0bc:	80800015 	stw	r2,0(r16)
8112f0c0:	8c400044 	addi	r17,r17,1
8112f0c4:	dc45883a 	add	r2,sp,r17
8112f0c8:	8d3fef36 	bltu	r17,r20,8112f088 <__reset+0xfb10f088>
8112f0cc:	9005883a 	mov	r2,r18
8112f0d0:	00000406 	br	8112f0e4 <__fputwc+0xf0>
8112f0d4:	80c0030b 	ldhu	r3,12(r16)
8112f0d8:	a005883a 	mov	r2,r20
8112f0dc:	18c01014 	ori	r3,r3,64
8112f0e0:	80c0030d 	sth	r3,12(r16)
8112f0e4:	dfc00717 	ldw	ra,28(sp)
8112f0e8:	dd400617 	ldw	r21,24(sp)
8112f0ec:	dd000517 	ldw	r20,20(sp)
8112f0f0:	dcc00417 	ldw	r19,16(sp)
8112f0f4:	dc800317 	ldw	r18,12(sp)
8112f0f8:	dc400217 	ldw	r17,8(sp)
8112f0fc:	dc000117 	ldw	r16,4(sp)
8112f100:	dec00804 	addi	sp,sp,32
8112f104:	f800283a 	ret
8112f108:	800d883a 	mov	r6,r16
8112f10c:	29403fcc 	andi	r5,r5,255
8112f110:	9809883a 	mov	r4,r19
8112f114:	11252540 	call	81125254 <__swbuf_r>
8112f118:	10bfffe0 	cmpeqi	r2,r2,-1
8112f11c:	10803fcc 	andi	r2,r2,255
8112f120:	103fd626 	beq	r2,zero,8112f07c <__reset+0xfb10f07c>
8112f124:	00bfffc4 	movi	r2,-1
8112f128:	003fee06 	br	8112f0e4 <__reset+0xfb10f0e4>
8112f12c:	90ffffc4 	addi	r3,r18,-1
8112f130:	01003f84 	movi	r4,254
8112f134:	20ffbf36 	bltu	r4,r3,8112f034 <__reset+0xfb10f034>
8112f138:	900b883a 	mov	r5,r18
8112f13c:	dc800005 	stb	r18,0(sp)
8112f140:	1029883a 	mov	r20,r2
8112f144:	003fc506 	br	8112f05c <__reset+0xfb10f05c>
8112f148:	800d883a 	mov	r6,r16
8112f14c:	a80b883a 	mov	r5,r21
8112f150:	9809883a 	mov	r4,r19
8112f154:	11252540 	call	81125254 <__swbuf_r>
8112f158:	10bfffe0 	cmpeqi	r2,r2,-1
8112f15c:	003fef06 	br	8112f11c <__reset+0xfb10f11c>

8112f160 <_fputwc_r>:
8112f160:	3080030b 	ldhu	r2,12(r6)
8112f164:	10c8000c 	andi	r3,r2,8192
8112f168:	1800051e 	bne	r3,zero,8112f180 <_fputwc_r+0x20>
8112f16c:	30c01917 	ldw	r3,100(r6)
8112f170:	10880014 	ori	r2,r2,8192
8112f174:	3080030d 	sth	r2,12(r6)
8112f178:	18880014 	ori	r2,r3,8192
8112f17c:	30801915 	stw	r2,100(r6)
8112f180:	112eff41 	jmpi	8112eff4 <__fputwc>

8112f184 <fputwc>:
8112f184:	00a04574 	movhi	r2,33045
8112f188:	defffc04 	addi	sp,sp,-16
8112f18c:	10bd6304 	addi	r2,r2,-2676
8112f190:	de00012e 	bgeu	sp,et,8112f198 <fputwc+0x14>
8112f194:	003b68fa 	trap	3
8112f198:	dc000115 	stw	r16,4(sp)
8112f19c:	14000017 	ldw	r16,0(r2)
8112f1a0:	dc400215 	stw	r17,8(sp)
8112f1a4:	dfc00315 	stw	ra,12(sp)
8112f1a8:	2023883a 	mov	r17,r4
8112f1ac:	80000226 	beq	r16,zero,8112f1b8 <fputwc+0x34>
8112f1b0:	80800e17 	ldw	r2,56(r16)
8112f1b4:	10001026 	beq	r2,zero,8112f1f8 <fputwc+0x74>
8112f1b8:	2880030b 	ldhu	r2,12(r5)
8112f1bc:	10c8000c 	andi	r3,r2,8192
8112f1c0:	1800051e 	bne	r3,zero,8112f1d8 <fputwc+0x54>
8112f1c4:	28c01917 	ldw	r3,100(r5)
8112f1c8:	10880014 	ori	r2,r2,8192
8112f1cc:	2880030d 	sth	r2,12(r5)
8112f1d0:	18880014 	ori	r2,r3,8192
8112f1d4:	28801915 	stw	r2,100(r5)
8112f1d8:	280d883a 	mov	r6,r5
8112f1dc:	8009883a 	mov	r4,r16
8112f1e0:	880b883a 	mov	r5,r17
8112f1e4:	dfc00317 	ldw	ra,12(sp)
8112f1e8:	dc400217 	ldw	r17,8(sp)
8112f1ec:	dc000117 	ldw	r16,4(sp)
8112f1f0:	dec00404 	addi	sp,sp,16
8112f1f4:	112eff41 	jmpi	8112eff4 <__fputwc>
8112f1f8:	8009883a 	mov	r4,r16
8112f1fc:	d9400015 	stw	r5,0(sp)
8112f200:	112748c0 	call	8112748c <__sinit>
8112f204:	d9400017 	ldw	r5,0(sp)
8112f208:	003feb06 	br	8112f1b8 <__reset+0xfb10f1b8>

8112f20c <rshift>:
8112f20c:	2807d17a 	srai	r3,r5,5
8112f210:	20800417 	ldw	r2,16(r4)
8112f214:	22000504 	addi	r8,r4,20
8112f218:	1880250e 	bge	r3,r2,8112f2b0 <rshift+0xa4>
8112f21c:	1085883a 	add	r2,r2,r2
8112f220:	18c7883a 	add	r3,r3,r3
8112f224:	1085883a 	add	r2,r2,r2
8112f228:	18c7883a 	add	r3,r3,r3
8112f22c:	294007cc 	andi	r5,r5,31
8112f230:	4085883a 	add	r2,r8,r2
8112f234:	40c7883a 	add	r3,r8,r3
8112f238:	28002026 	beq	r5,zero,8112f2bc <rshift+0xb0>
8112f23c:	19800017 	ldw	r6,0(r3)
8112f240:	02c00804 	movi	r11,32
8112f244:	19c00104 	addi	r7,r3,4
8112f248:	5957c83a 	sub	r11,r11,r5
8112f24c:	314cd83a 	srl	r6,r6,r5
8112f250:	38802c2e 	bgeu	r7,r2,8112f304 <rshift+0xf8>
8112f254:	4015883a 	mov	r10,r8
8112f258:	3a400017 	ldw	r9,0(r7)
8112f25c:	52800104 	addi	r10,r10,4
8112f260:	39c00104 	addi	r7,r7,4
8112f264:	4ad2983a 	sll	r9,r9,r11
8112f268:	498cb03a 	or	r6,r9,r6
8112f26c:	51bfff15 	stw	r6,-4(r10)
8112f270:	39bfff17 	ldw	r6,-4(r7)
8112f274:	314cd83a 	srl	r6,r6,r5
8112f278:	38bff736 	bltu	r7,r2,8112f258 <__reset+0xfb10f258>
8112f27c:	10c7c83a 	sub	r3,r2,r3
8112f280:	18fffec4 	addi	r3,r3,-5
8112f284:	1806d0ba 	srli	r3,r3,2
8112f288:	18c00044 	addi	r3,r3,1
8112f28c:	18c7883a 	add	r3,r3,r3
8112f290:	18c7883a 	add	r3,r3,r3
8112f294:	40c7883a 	add	r3,r8,r3
8112f298:	19800015 	stw	r6,0(r3)
8112f29c:	30000126 	beq	r6,zero,8112f2a4 <rshift+0x98>
8112f2a0:	18c00104 	addi	r3,r3,4
8112f2a4:	1a05c83a 	sub	r2,r3,r8
8112f2a8:	1005d0ba 	srai	r2,r2,2
8112f2ac:	00001206 	br	8112f2f8 <rshift+0xec>
8112f2b0:	20000415 	stw	zero,16(r4)
8112f2b4:	20000515 	stw	zero,20(r4)
8112f2b8:	f800283a 	ret
8112f2bc:	18bffc2e 	bgeu	r3,r2,8112f2b0 <__reset+0xfb10f2b0>
8112f2c0:	180d883a 	mov	r6,r3
8112f2c4:	400b883a 	mov	r5,r8
8112f2c8:	31c00017 	ldw	r7,0(r6)
8112f2cc:	29400104 	addi	r5,r5,4
8112f2d0:	31800104 	addi	r6,r6,4
8112f2d4:	29ffff15 	stw	r7,-4(r5)
8112f2d8:	30bffb36 	bltu	r6,r2,8112f2c8 <__reset+0xfb10f2c8>
8112f2dc:	00c6303a 	nor	r3,zero,r3
8112f2e0:	1885883a 	add	r2,r3,r2
8112f2e4:	1004d0ba 	srli	r2,r2,2
8112f2e8:	10800044 	addi	r2,r2,1
8112f2ec:	1085883a 	add	r2,r2,r2
8112f2f0:	1085883a 	add	r2,r2,r2
8112f2f4:	1005d0ba 	srai	r2,r2,2
8112f2f8:	20800415 	stw	r2,16(r4)
8112f2fc:	103fed26 	beq	r2,zero,8112f2b4 <__reset+0xfb10f2b4>
8112f300:	f800283a 	ret
8112f304:	4007883a 	mov	r3,r8
8112f308:	003fe306 	br	8112f298 <__reset+0xfb10f298>

8112f30c <__gethex>:
8112f30c:	deffeb04 	addi	sp,sp,-84
8112f310:	de00012e 	bgeu	sp,et,8112f318 <__gethex+0xc>
8112f314:	003b68fa 	trap	3
8112f318:	dfc01415 	stw	ra,80(sp)
8112f31c:	dd801115 	stw	r22,68(sp)
8112f320:	dcc00e15 	stw	r19,56(sp)
8112f324:	dc800d15 	stw	r18,52(sp)
8112f328:	2827883a 	mov	r19,r5
8112f32c:	d9000115 	stw	r4,4(sp)
8112f330:	d9800015 	stw	r6,0(sp)
8112f334:	d9c00415 	stw	r7,16(sp)
8112f338:	df001315 	stw	fp,76(sp)
8112f33c:	ddc01215 	stw	r23,72(sp)
8112f340:	dd401015 	stw	r21,64(sp)
8112f344:	dd000f15 	stw	r20,60(sp)
8112f348:	dc400c15 	stw	r17,48(sp)
8112f34c:	dc000b15 	stw	r16,44(sp)
8112f350:	11283d80 	call	811283d8 <_localeconv_r>
8112f354:	14800017 	ldw	r18,0(r2)
8112f358:	9009883a 	mov	r4,r18
8112f35c:	111f1b80 	call	8111f1b8 <strlen>
8112f360:	98c00017 	ldw	r3,0(r19)
8112f364:	102d883a 	mov	r22,r2
8112f368:	9085883a 	add	r2,r18,r2
8112f36c:	10bfffc3 	ldbu	r2,-1(r2)
8112f370:	19000083 	ldbu	r4,2(r3)
8112f374:	d8800305 	stb	r2,12(sp)
8112f378:	00800c04 	movi	r2,48
8112f37c:	2081521e 	bne	r4,r2,8112f8c8 <__gethex+0x5bc>
8112f380:	017fff84 	movi	r5,-2
8112f384:	188000c4 	addi	r2,r3,3
8112f388:	28cbc83a 	sub	r5,r5,r3
8112f38c:	200d883a 	mov	r6,r4
8112f390:	28a3883a 	add	r17,r5,r2
8112f394:	102b883a 	mov	r21,r2
8112f398:	10800044 	addi	r2,r2,1
8112f39c:	113fffc3 	ldbu	r4,-1(r2)
8112f3a0:	21bffb26 	beq	r4,r6,8112f390 <__reset+0xfb10f390>
8112f3a4:	05204574 	movhi	r20,33045
8112f3a8:	a5342e04 	addi	r20,r20,-12104
8112f3ac:	a109883a 	add	r4,r20,r4
8112f3b0:	20800003 	ldbu	r2,0(r4)
8112f3b4:	10008826 	beq	r2,zero,8112f5d8 <__gethex+0x2cc>
8112f3b8:	a8800003 	ldbu	r2,0(r21)
8112f3bc:	0015883a 	mov	r10,zero
8112f3c0:	002f883a 	mov	r23,zero
8112f3c4:	a085883a 	add	r2,r20,r2
8112f3c8:	10800003 	ldbu	r2,0(r2)
8112f3cc:	a821883a 	mov	r16,r21
8112f3d0:	10000526 	beq	r2,zero,8112f3e8 <__gethex+0xdc>
8112f3d4:	84000044 	addi	r16,r16,1
8112f3d8:	80800003 	ldbu	r2,0(r16)
8112f3dc:	a085883a 	add	r2,r20,r2
8112f3e0:	10800003 	ldbu	r2,0(r2)
8112f3e4:	103ffb1e 	bne	r2,zero,8112f3d4 <__reset+0xfb10f3d4>
8112f3e8:	b00d883a 	mov	r6,r22
8112f3ec:	900b883a 	mov	r5,r18
8112f3f0:	8009883a 	mov	r4,r16
8112f3f4:	da800a15 	stw	r10,40(sp)
8112f3f8:	112fda80 	call	8112fda8 <strncmp>
8112f3fc:	da800a17 	ldw	r10,40(sp)
8112f400:	1000031e 	bne	r2,zero,8112f410 <__gethex+0x104>
8112f404:	b8015226 	beq	r23,zero,8112f950 <__gethex+0x644>
8112f408:	80800003 	ldbu	r2,0(r16)
8112f40c:	00000206 	br	8112f418 <__gethex+0x10c>
8112f410:	80800003 	ldbu	r2,0(r16)
8112f414:	b8011f26 	beq	r23,zero,8112f894 <__gethex+0x588>
8112f418:	85efc83a 	sub	r23,r16,r23
8112f41c:	bdef883a 	add	r23,r23,r23
8112f420:	bdef883a 	add	r23,r23,r23
8112f424:	05efc83a 	sub	r23,zero,r23
8112f428:	10803fcc 	andi	r2,r2,255
8112f42c:	01001404 	movi	r4,80
8112f430:	11008626 	beq	r2,r4,8112f64c <__gethex+0x340>
8112f434:	01001c04 	movi	r4,112
8112f438:	11008426 	beq	r2,r4,8112f64c <__gethex+0x340>
8112f43c:	8039883a 	mov	fp,r16
8112f440:	9c000015 	stw	r16,0(r19)
8112f444:	5000711e 	bne	r10,zero,8112f60c <__gethex+0x300>
8112f448:	e545c83a 	sub	r2,fp,r21
8112f44c:	10bfffc4 	addi	r2,r2,-1
8112f450:	010001c4 	movi	r4,7
8112f454:	000b883a 	mov	r5,zero
8112f458:	2080030e 	bge	r4,r2,8112f468 <__gethex+0x15c>
8112f45c:	1005d07a 	srai	r2,r2,1
8112f460:	29400044 	addi	r5,r5,1
8112f464:	20bffd16 	blt	r4,r2,8112f45c <__reset+0xfb10f45c>
8112f468:	d9000117 	ldw	r4,4(sp)
8112f46c:	11288f40 	call	811288f4 <_Balloc>
8112f470:	10c00504 	addi	r3,r2,20
8112f474:	d8c00215 	stw	r3,8(sp)
8112f478:	1021883a 	mov	r16,r2
8112f47c:	af01732e 	bgeu	r21,fp,8112fa4c <__gethex+0x740>
8112f480:	dc400303 	ldbu	r17,12(sp)
8112f484:	03400044 	movi	r13,1
8112f488:	1815883a 	mov	r10,r3
8112f48c:	0013883a 	mov	r9,zero
8112f490:	0027883a 	mov	r19,zero
8112f494:	6d9bc83a 	sub	r13,r13,r22
8112f498:	02c00804 	movi	r11,32
8112f49c:	e0bfffc3 	ldbu	r2,-1(fp)
8112f4a0:	e3bfffc4 	addi	r14,fp,-1
8112f4a4:	88803026 	beq	r17,r2,8112f568 <__gethex+0x25c>
8112f4a8:	9ac04526 	beq	r19,r11,8112f5c0 <__gethex+0x2b4>
8112f4ac:	980b883a 	mov	r5,r19
8112f4b0:	9cc00104 	addi	r19,r19,4
8112f4b4:	e13fffc3 	ldbu	r4,-1(fp)
8112f4b8:	7039883a 	mov	fp,r14
8112f4bc:	a109883a 	add	r4,r20,r4
8112f4c0:	20800003 	ldbu	r2,0(r4)
8112f4c4:	108003cc 	andi	r2,r2,15
8112f4c8:	1144983a 	sll	r2,r2,r5
8112f4cc:	4892b03a 	or	r9,r9,r2
8112f4d0:	af3ff236 	bltu	r21,fp,8112f49c <__reset+0xfb10f49c>
8112f4d4:	d8c00217 	ldw	r3,8(sp)
8112f4d8:	50800104 	addi	r2,r10,4
8112f4dc:	52400015 	stw	r9,0(r10)
8112f4e0:	10c5c83a 	sub	r2,r2,r3
8112f4e4:	1005d0ba 	srai	r2,r2,2
8112f4e8:	4809883a 	mov	r4,r9
8112f4ec:	80800415 	stw	r2,16(r16)
8112f4f0:	1022917a 	slli	r17,r2,5
8112f4f4:	1128c000 	call	81128c00 <__hi0bits>
8112f4f8:	d8c00017 	ldw	r3,0(sp)
8112f4fc:	8885c83a 	sub	r2,r17,r2
8112f500:	1c800017 	ldw	r18,0(r3)
8112f504:	9080c716 	blt	r18,r2,8112f824 <__gethex+0x518>
8112f508:	1480e416 	blt	r2,r18,8112f89c <__gethex+0x590>
8112f50c:	0027883a 	mov	r19,zero
8112f510:	d8c00017 	ldw	r3,0(sp)
8112f514:	18800217 	ldw	r2,8(r3)
8112f518:	15c08d16 	blt	r2,r23,8112f750 <__gethex+0x444>
8112f51c:	d8c00017 	ldw	r3,0(sp)
8112f520:	18800117 	ldw	r2,4(r3)
8112f524:	b880aa0e 	bge	r23,r2,8112f7d0 <__gethex+0x4c4>
8112f528:	15efc83a 	sub	r23,r2,r23
8112f52c:	bc80ed16 	blt	r23,r18,8112f8e4 <__gethex+0x5d8>
8112f530:	18c00317 	ldw	r3,12(r3)
8112f534:	01000084 	movi	r4,2
8112f538:	19014926 	beq	r3,r4,8112fa60 <__gethex+0x754>
8112f53c:	010000c4 	movi	r4,3
8112f540:	19012e26 	beq	r3,r4,8112f9fc <__gethex+0x6f0>
8112f544:	01000044 	movi	r4,1
8112f548:	19014826 	beq	r3,r4,8112fa6c <__gethex+0x760>
8112f54c:	d9000117 	ldw	r4,4(sp)
8112f550:	800b883a 	mov	r5,r16
8112f554:	11289a40 	call	811289a4 <_Bfree>
8112f558:	d8801517 	ldw	r2,84(sp)
8112f55c:	10000015 	stw	zero,0(r2)
8112f560:	00801404 	movi	r2,80
8112f564:	00002b06 	br	8112f614 <__gethex+0x308>
8112f568:	735f883a 	add	r15,r14,r13
8112f56c:	7d7fce36 	bltu	r15,r21,8112f4a8 <__reset+0xfb10f4a8>
8112f570:	7809883a 	mov	r4,r15
8112f574:	b00d883a 	mov	r6,r22
8112f578:	900b883a 	mov	r5,r18
8112f57c:	da400515 	stw	r9,20(sp)
8112f580:	da800a15 	stw	r10,40(sp)
8112f584:	dac00915 	stw	r11,36(sp)
8112f588:	db400815 	stw	r13,32(sp)
8112f58c:	db800615 	stw	r14,24(sp)
8112f590:	dbc00715 	stw	r15,28(sp)
8112f594:	112fda80 	call	8112fda8 <strncmp>
8112f598:	da400517 	ldw	r9,20(sp)
8112f59c:	da800a17 	ldw	r10,40(sp)
8112f5a0:	dac00917 	ldw	r11,36(sp)
8112f5a4:	db400817 	ldw	r13,32(sp)
8112f5a8:	db800617 	ldw	r14,24(sp)
8112f5ac:	dbc00717 	ldw	r15,28(sp)
8112f5b0:	103fbd1e 	bne	r2,zero,8112f4a8 <__reset+0xfb10f4a8>
8112f5b4:	7839883a 	mov	fp,r15
8112f5b8:	af3fb836 	bltu	r21,fp,8112f49c <__reset+0xfb10f49c>
8112f5bc:	003fc506 	br	8112f4d4 <__reset+0xfb10f4d4>
8112f5c0:	04c00104 	movi	r19,4
8112f5c4:	52400015 	stw	r9,0(r10)
8112f5c8:	000b883a 	mov	r5,zero
8112f5cc:	54d5883a 	add	r10,r10,r19
8112f5d0:	0013883a 	mov	r9,zero
8112f5d4:	003fb706 	br	8112f4b4 <__reset+0xfb10f4b4>
8112f5d8:	b00d883a 	mov	r6,r22
8112f5dc:	900b883a 	mov	r5,r18
8112f5e0:	a809883a 	mov	r4,r21
8112f5e4:	112fda80 	call	8112fda8 <strncmp>
8112f5e8:	10006426 	beq	r2,zero,8112f77c <__gethex+0x470>
8112f5ec:	a8800003 	ldbu	r2,0(r21)
8112f5f0:	a821883a 	mov	r16,r21
8112f5f4:	10803fcc 	andi	r2,r2,255
8112f5f8:	01001404 	movi	r4,80
8112f5fc:	11001126 	beq	r2,r4,8112f644 <__gethex+0x338>
8112f600:	01001c04 	movi	r4,112
8112f604:	11000f26 	beq	r2,r4,8112f644 <__gethex+0x338>
8112f608:	9c000015 	stw	r16,0(r19)
8112f60c:	8800831e 	bne	r17,zero,8112f81c <__gethex+0x510>
8112f610:	00800184 	movi	r2,6
8112f614:	dfc01417 	ldw	ra,80(sp)
8112f618:	df001317 	ldw	fp,76(sp)
8112f61c:	ddc01217 	ldw	r23,72(sp)
8112f620:	dd801117 	ldw	r22,68(sp)
8112f624:	dd401017 	ldw	r21,64(sp)
8112f628:	dd000f17 	ldw	r20,60(sp)
8112f62c:	dcc00e17 	ldw	r19,56(sp)
8112f630:	dc800d17 	ldw	r18,52(sp)
8112f634:	dc400c17 	ldw	r17,48(sp)
8112f638:	dc000b17 	ldw	r16,44(sp)
8112f63c:	dec01504 	addi	sp,sp,84
8112f640:	f800283a 	ret
8112f644:	002f883a 	mov	r23,zero
8112f648:	02800044 	movi	r10,1
8112f64c:	80800043 	ldbu	r2,1(r16)
8112f650:	01400ac4 	movi	r5,43
8112f654:	11003fcc 	andi	r4,r2,255
8112f658:	21406e26 	beq	r4,r5,8112f814 <__gethex+0x508>
8112f65c:	01400b44 	movi	r5,45
8112f660:	21404226 	beq	r4,r5,8112f76c <__gethex+0x460>
8112f664:	81400044 	addi	r5,r16,1
8112f668:	000d883a 	mov	r6,zero
8112f66c:	10803fcc 	andi	r2,r2,255
8112f670:	a085883a 	add	r2,r20,r2
8112f674:	11000003 	ldbu	r4,0(r2)
8112f678:	03000604 	movi	r12,24
8112f67c:	20bfffc4 	addi	r2,r4,-1
8112f680:	10803fcc 	andi	r2,r2,255
8112f684:	60bf6d36 	bltu	r12,r2,8112f43c <__reset+0xfb10f43c>
8112f688:	2ac00043 	ldbu	r11,1(r5)
8112f68c:	20803fcc 	andi	r2,r4,255
8112f690:	01204574 	movhi	r4,33045
8112f694:	21342e04 	addi	r4,r4,-12104
8112f698:	22c9883a 	add	r4,r4,r11
8112f69c:	23400003 	ldbu	r13,0(r4)
8112f6a0:	10bffc04 	addi	r2,r2,-16
8112f6a4:	29400044 	addi	r5,r5,1
8112f6a8:	693fffc4 	addi	r4,r13,-1
8112f6ac:	21003fcc 	andi	r4,r4,255
8112f6b0:	6b403fcc 	andi	r13,r13,255
8112f6b4:	61000b36 	bltu	r12,r4,8112f6e4 <__gethex+0x3d8>
8112f6b8:	29400044 	addi	r5,r5,1
8112f6bc:	29000003 	ldbu	r4,0(r5)
8112f6c0:	108002a4 	muli	r2,r2,10
8112f6c4:	a109883a 	add	r4,r20,r4
8112f6c8:	22c00003 	ldbu	r11,0(r4)
8112f6cc:	1345883a 	add	r2,r2,r13
8112f6d0:	10bffc04 	addi	r2,r2,-16
8112f6d4:	593fffc4 	addi	r4,r11,-1
8112f6d8:	21003fcc 	andi	r4,r4,255
8112f6dc:	5b403fcc 	andi	r13,r11,255
8112f6e0:	613ff52e 	bgeu	r12,r4,8112f6b8 <__reset+0xfb10f6b8>
8112f6e4:	30000126 	beq	r6,zero,8112f6ec <__gethex+0x3e0>
8112f6e8:	0085c83a 	sub	r2,zero,r2
8112f6ec:	8039883a 	mov	fp,r16
8112f6f0:	b8af883a 	add	r23,r23,r2
8112f6f4:	2821883a 	mov	r16,r5
8112f6f8:	003f5106 	br	8112f440 <__reset+0xfb10f440>
8112f6fc:	80800217 	ldw	r2,8(r16)
8112f700:	e080f00e 	bge	fp,r2,8112fac4 <__gethex+0x7b8>
8112f704:	e007883a 	mov	r3,fp
8112f708:	18800144 	addi	r2,r3,5
8112f70c:	1085883a 	add	r2,r2,r2
8112f710:	18c00044 	addi	r3,r3,1
8112f714:	1085883a 	add	r2,r2,r2
8112f718:	8085883a 	add	r2,r16,r2
8112f71c:	80c00415 	stw	r3,16(r16)
8112f720:	01000044 	movi	r4,1
8112f724:	11000015 	stw	r4,0(r2)
8112f728:	00800084 	movi	r2,2
8112f72c:	8880d826 	beq	r17,r2,8112fa90 <__gethex+0x784>
8112f730:	e0c0ac0e 	bge	fp,r3,8112f9e4 <__gethex+0x6d8>
8112f734:	01400044 	movi	r5,1
8112f738:	8009883a 	mov	r4,r16
8112f73c:	112f20c0 	call	8112f20c <rshift>
8112f740:	d8c00017 	ldw	r3,0(sp)
8112f744:	bdc00044 	addi	r23,r23,1
8112f748:	18800217 	ldw	r2,8(r3)
8112f74c:	15c0a70e 	bge	r2,r23,8112f9ec <__gethex+0x6e0>
8112f750:	d9000117 	ldw	r4,4(sp)
8112f754:	800b883a 	mov	r5,r16
8112f758:	11289a40 	call	811289a4 <_Bfree>
8112f75c:	d9001517 	ldw	r4,84(sp)
8112f760:	008028c4 	movi	r2,163
8112f764:	20000015 	stw	zero,0(r4)
8112f768:	003faa06 	br	8112f614 <__reset+0xfb10f614>
8112f76c:	01800044 	movi	r6,1
8112f770:	80800083 	ldbu	r2,2(r16)
8112f774:	81400084 	addi	r5,r16,2
8112f778:	003fbc06 	br	8112f66c <__reset+0xfb10f66c>
8112f77c:	ada1883a 	add	r16,r21,r22
8112f780:	81000003 	ldbu	r4,0(r16)
8112f784:	21403fcc 	andi	r5,r4,255
8112f788:	a145883a 	add	r2,r20,r5
8112f78c:	10800003 	ldbu	r2,0(r2)
8112f790:	11803fcc 	andi	r6,r2,255
8112f794:	30004f26 	beq	r6,zero,8112f8d4 <__gethex+0x5c8>
8112f798:	00c00c04 	movi	r3,48
8112f79c:	802b883a 	mov	r21,r16
8112f7a0:	28c0061e 	bne	r5,r3,8112f7bc <__gethex+0x4b0>
8112f7a4:	2809883a 	mov	r4,r5
8112f7a8:	ad400044 	addi	r21,r21,1
8112f7ac:	a8800003 	ldbu	r2,0(r21)
8112f7b0:	113ffd26 	beq	r2,r4,8112f7a8 <__reset+0xfb10f7a8>
8112f7b4:	a085883a 	add	r2,r20,r2
8112f7b8:	10800003 	ldbu	r2,0(r2)
8112f7bc:	10803fcc 	andi	r2,r2,255
8112f7c0:	1015003a 	cmpeq	r10,r2,zero
8112f7c4:	802f883a 	mov	r23,r16
8112f7c8:	04400044 	movi	r17,1
8112f7cc:	003eff06 	br	8112f3cc <__reset+0xfb10f3cc>
8112f7d0:	04400044 	movi	r17,1
8112f7d4:	98000926 	beq	r19,zero,8112f7fc <__gethex+0x4f0>
8112f7d8:	d8c00017 	ldw	r3,0(sp)
8112f7dc:	18800317 	ldw	r2,12(r3)
8112f7e0:	00c00084 	movi	r3,2
8112f7e4:	10c06826 	beq	r2,r3,8112f988 <__gethex+0x67c>
8112f7e8:	00c000c4 	movi	r3,3
8112f7ec:	10c06a26 	beq	r2,r3,8112f998 <__gethex+0x68c>
8112f7f0:	00c00044 	movi	r3,1
8112f7f4:	10c08d26 	beq	r2,r3,8112fa2c <__gethex+0x720>
8112f7f8:	8c400414 	ori	r17,r17,16
8112f7fc:	d9001517 	ldw	r4,84(sp)
8112f800:	d8c00417 	ldw	r3,16(sp)
8112f804:	8805883a 	mov	r2,r17
8112f808:	24000015 	stw	r16,0(r4)
8112f80c:	1dc00015 	stw	r23,0(r3)
8112f810:	003f8006 	br	8112f614 <__reset+0xfb10f614>
8112f814:	000d883a 	mov	r6,zero
8112f818:	003fd506 	br	8112f770 <__reset+0xfb10f770>
8112f81c:	0005883a 	mov	r2,zero
8112f820:	003f7c06 	br	8112f614 <__reset+0xfb10f614>
8112f824:	14a3c83a 	sub	r17,r2,r18
8112f828:	880b883a 	mov	r5,r17
8112f82c:	8009883a 	mov	r4,r16
8112f830:	11298c40 	call	811298c4 <__any_on>
8112f834:	10002926 	beq	r2,zero,8112f8dc <__gethex+0x5d0>
8112f838:	897fffc4 	addi	r5,r17,-1
8112f83c:	2807d17a 	srai	r3,r5,5
8112f840:	d8800217 	ldw	r2,8(sp)
8112f844:	290007cc 	andi	r4,r5,31
8112f848:	18c7883a 	add	r3,r3,r3
8112f84c:	18c7883a 	add	r3,r3,r3
8112f850:	04c00044 	movi	r19,1
8112f854:	10c7883a 	add	r3,r2,r3
8112f858:	9908983a 	sll	r4,r19,r4
8112f85c:	18c00017 	ldw	r3,0(r3)
8112f860:	20c6703a 	and	r3,r4,r3
8112f864:	18000626 	beq	r3,zero,8112f880 <__gethex+0x574>
8112f868:	99407b0e 	bge	r19,r5,8112fa58 <__gethex+0x74c>
8112f86c:	897fff84 	addi	r5,r17,-2
8112f870:	8009883a 	mov	r4,r16
8112f874:	11298c40 	call	811298c4 <__any_on>
8112f878:	10007726 	beq	r2,zero,8112fa58 <__gethex+0x74c>
8112f87c:	04c000c4 	movi	r19,3
8112f880:	880b883a 	mov	r5,r17
8112f884:	8009883a 	mov	r4,r16
8112f888:	112f20c0 	call	8112f20c <rshift>
8112f88c:	bc6f883a 	add	r23,r23,r17
8112f890:	003f1f06 	br	8112f510 <__reset+0xfb10f510>
8112f894:	002f883a 	mov	r23,zero
8112f898:	003ee306 	br	8112f428 <__reset+0xfb10f428>
8112f89c:	d9000117 	ldw	r4,4(sp)
8112f8a0:	90a3c83a 	sub	r17,r18,r2
8112f8a4:	800b883a 	mov	r5,r16
8112f8a8:	880d883a 	mov	r6,r17
8112f8ac:	11290a40 	call	811290a4 <__lshift>
8112f8b0:	10c00504 	addi	r3,r2,20
8112f8b4:	1021883a 	mov	r16,r2
8112f8b8:	bc6fc83a 	sub	r23,r23,r17
8112f8bc:	d8c00215 	stw	r3,8(sp)
8112f8c0:	0027883a 	mov	r19,zero
8112f8c4:	003f1206 	br	8112f510 <__reset+0xfb10f510>
8112f8c8:	1d400084 	addi	r21,r3,2
8112f8cc:	0023883a 	mov	r17,zero
8112f8d0:	003eb406 	br	8112f3a4 <__reset+0xfb10f3a4>
8112f8d4:	2005883a 	mov	r2,r4
8112f8d8:	003f4606 	br	8112f5f4 <__reset+0xfb10f5f4>
8112f8dc:	0027883a 	mov	r19,zero
8112f8e0:	003fe706 	br	8112f880 <__reset+0xfb10f880>
8112f8e4:	bc7fffc4 	addi	r17,r23,-1
8112f8e8:	9800421e 	bne	r19,zero,8112f9f4 <__gethex+0x6e8>
8112f8ec:	88000426 	beq	r17,zero,8112f900 <__gethex+0x5f4>
8112f8f0:	880b883a 	mov	r5,r17
8112f8f4:	8009883a 	mov	r4,r16
8112f8f8:	11298c40 	call	811298c4 <__any_on>
8112f8fc:	1027883a 	mov	r19,r2
8112f900:	8805d17a 	srai	r2,r17,5
8112f904:	d8c00217 	ldw	r3,8(sp)
8112f908:	8c4007cc 	andi	r17,r17,31
8112f90c:	1085883a 	add	r2,r2,r2
8112f910:	1085883a 	add	r2,r2,r2
8112f914:	1885883a 	add	r2,r3,r2
8112f918:	00c00044 	movi	r3,1
8112f91c:	1c62983a 	sll	r17,r3,r17
8112f920:	10800017 	ldw	r2,0(r2)
8112f924:	8884703a 	and	r2,r17,r2
8112f928:	10000126 	beq	r2,zero,8112f930 <__gethex+0x624>
8112f92c:	9cc00094 	ori	r19,r19,2
8112f930:	b80b883a 	mov	r5,r23
8112f934:	8009883a 	mov	r4,r16
8112f938:	112f20c0 	call	8112f20c <rshift>
8112f93c:	d8c00017 	ldw	r3,0(sp)
8112f940:	95e5c83a 	sub	r18,r18,r23
8112f944:	04400084 	movi	r17,2
8112f948:	1dc00117 	ldw	r23,4(r3)
8112f94c:	003fa106 	br	8112f7d4 <__reset+0xfb10f7d4>
8112f950:	85af883a 	add	r23,r16,r22
8112f954:	b8800003 	ldbu	r2,0(r23)
8112f958:	b821883a 	mov	r16,r23
8112f95c:	11003fcc 	andi	r4,r2,255
8112f960:	a109883a 	add	r4,r20,r4
8112f964:	21000003 	ldbu	r4,0(r4)
8112f968:	203eaa26 	beq	r4,zero,8112f414 <__reset+0xfb10f414>
8112f96c:	84000044 	addi	r16,r16,1
8112f970:	80800003 	ldbu	r2,0(r16)
8112f974:	11003fcc 	andi	r4,r2,255
8112f978:	a109883a 	add	r4,r20,r4
8112f97c:	21000003 	ldbu	r4,0(r4)
8112f980:	203ffa1e 	bne	r4,zero,8112f96c <__reset+0xfb10f96c>
8112f984:	003ea306 	br	8112f414 <__reset+0xfb10f414>
8112f988:	d9001617 	ldw	r4,88(sp)
8112f98c:	00800044 	movi	r2,1
8112f990:	1109c83a 	sub	r4,r2,r4
8112f994:	d9001615 	stw	r4,88(sp)
8112f998:	d8801617 	ldw	r2,88(sp)
8112f99c:	103f9626 	beq	r2,zero,8112f7f8 <__reset+0xfb10f7f8>
8112f9a0:	87000417 	ldw	fp,16(r16)
8112f9a4:	d9800217 	ldw	r6,8(sp)
8112f9a8:	013fffc4 	movi	r4,-1
8112f9ac:	e727883a 	add	r19,fp,fp
8112f9b0:	9ce7883a 	add	r19,r19,r19
8112f9b4:	3005883a 	mov	r2,r6
8112f9b8:	34cb883a 	add	r5,r6,r19
8112f9bc:	00000306 	br	8112f9cc <__gethex+0x6c0>
8112f9c0:	10000015 	stw	zero,0(r2)
8112f9c4:	10800104 	addi	r2,r2,4
8112f9c8:	117f4c2e 	bgeu	r2,r5,8112f6fc <__reset+0xfb10f6fc>
8112f9cc:	10c00017 	ldw	r3,0(r2)
8112f9d0:	193ffb26 	beq	r3,r4,8112f9c0 <__reset+0xfb10f9c0>
8112f9d4:	18c00044 	addi	r3,r3,1
8112f9d8:	10c00015 	stw	r3,0(r2)
8112f9dc:	00800084 	movi	r2,2
8112f9e0:	88802b26 	beq	r17,r2,8112fa90 <__gethex+0x784>
8112f9e4:	948007cc 	andi	r18,r18,31
8112f9e8:	90002f1e 	bne	r18,zero,8112faa8 <__gethex+0x79c>
8112f9ec:	04400844 	movi	r17,33
8112f9f0:	003f8206 	br	8112f7fc <__reset+0xfb10f7fc>
8112f9f4:	04c00044 	movi	r19,1
8112f9f8:	003fc106 	br	8112f900 <__reset+0xfb10f900>
8112f9fc:	d8c01617 	ldw	r3,88(sp)
8112fa00:	183ed226 	beq	r3,zero,8112f54c <__reset+0xfb10f54c>
8112fa04:	d8c00417 	ldw	r3,16(sp)
8112fa08:	d9001517 	ldw	r4,84(sp)
8112fa0c:	18800015 	stw	r2,0(r3)
8112fa10:	d8c00217 	ldw	r3,8(sp)
8112fa14:	00800044 	movi	r2,1
8112fa18:	80800415 	stw	r2,16(r16)
8112fa1c:	18800015 	stw	r2,0(r3)
8112fa20:	24000015 	stw	r16,0(r4)
8112fa24:	00801884 	movi	r2,98
8112fa28:	003efa06 	br	8112f614 <__reset+0xfb10f614>
8112fa2c:	9880008c 	andi	r2,r19,2
8112fa30:	103f7126 	beq	r2,zero,8112f7f8 <__reset+0xfb10f7f8>
8112fa34:	d8c00217 	ldw	r3,8(sp)
8112fa38:	18800017 	ldw	r2,0(r3)
8112fa3c:	9884b03a 	or	r2,r19,r2
8112fa40:	1080004c 	andi	r2,r2,1
8112fa44:	103fd61e 	bne	r2,zero,8112f9a0 <__reset+0xfb10f9a0>
8112fa48:	003f6b06 	br	8112f7f8 <__reset+0xfb10f7f8>
8112fa4c:	da800217 	ldw	r10,8(sp)
8112fa50:	0013883a 	mov	r9,zero
8112fa54:	003e9f06 	br	8112f4d4 <__reset+0xfb10f4d4>
8112fa58:	04c00084 	movi	r19,2
8112fa5c:	003f8806 	br	8112f880 <__reset+0xfb10f880>
8112fa60:	d9001617 	ldw	r4,88(sp)
8112fa64:	203fe726 	beq	r4,zero,8112fa04 <__reset+0xfb10fa04>
8112fa68:	003eb806 	br	8112f54c <__reset+0xfb10f54c>
8112fa6c:	95feb71e 	bne	r18,r23,8112f54c <__reset+0xfb10f54c>
8112fa70:	1cbfe40e 	bge	r3,r18,8112fa04 <__reset+0xfb10fa04>
8112fa74:	917fffc4 	addi	r5,r18,-1
8112fa78:	8009883a 	mov	r4,r16
8112fa7c:	11298c40 	call	811298c4 <__any_on>
8112fa80:	103eb226 	beq	r2,zero,8112f54c <__reset+0xfb10f54c>
8112fa84:	d8c00017 	ldw	r3,0(sp)
8112fa88:	18800117 	ldw	r2,4(r3)
8112fa8c:	003fdd06 	br	8112fa04 <__reset+0xfb10fa04>
8112fa90:	d8c00017 	ldw	r3,0(sp)
8112fa94:	18800017 	ldw	r2,0(r3)
8112fa98:	10bfffc4 	addi	r2,r2,-1
8112fa9c:	90801c26 	beq	r18,r2,8112fb10 <__gethex+0x804>
8112faa0:	04400884 	movi	r17,34
8112faa4:	003f5506 	br	8112f7fc <__reset+0xfb10f7fc>
8112faa8:	34c5883a 	add	r2,r6,r19
8112faac:	113fff17 	ldw	r4,-4(r2)
8112fab0:	1128c000 	call	81128c00 <__hi0bits>
8112fab4:	00c00804 	movi	r3,32
8112fab8:	1ca5c83a 	sub	r18,r3,r18
8112fabc:	14bfcb0e 	bge	r2,r18,8112f9ec <__reset+0xfb10f9ec>
8112fac0:	003f1c06 	br	8112f734 <__reset+0xfb10f734>
8112fac4:	81400117 	ldw	r5,4(r16)
8112fac8:	d9000117 	ldw	r4,4(sp)
8112facc:	29400044 	addi	r5,r5,1
8112fad0:	11288f40 	call	811288f4 <_Balloc>
8112fad4:	81800417 	ldw	r6,16(r16)
8112fad8:	81400304 	addi	r5,r16,12
8112fadc:	11000304 	addi	r4,r2,12
8112fae0:	31800084 	addi	r6,r6,2
8112fae4:	318d883a 	add	r6,r6,r6
8112fae8:	318d883a 	add	r6,r6,r6
8112faec:	1029883a 	mov	r20,r2
8112faf0:	111e6c40 	call	8111e6c4 <memcpy>
8112faf4:	d9000117 	ldw	r4,4(sp)
8112faf8:	800b883a 	mov	r5,r16
8112fafc:	a021883a 	mov	r16,r20
8112fb00:	11289a40 	call	811289a4 <_Bfree>
8112fb04:	a0c00417 	ldw	r3,16(r20)
8112fb08:	a1800504 	addi	r6,r20,20
8112fb0c:	003efe06 	br	8112f708 <__reset+0xfb10f708>
8112fb10:	9005d17a 	srai	r2,r18,5
8112fb14:	944007cc 	andi	r17,r18,31
8112fb18:	1085883a 	add	r2,r2,r2
8112fb1c:	1085883a 	add	r2,r2,r2
8112fb20:	3087883a 	add	r3,r6,r2
8112fb24:	00800044 	movi	r2,1
8112fb28:	1462983a 	sll	r17,r2,r17
8112fb2c:	18800017 	ldw	r2,0(r3)
8112fb30:	8884703a 	and	r2,r17,r2
8112fb34:	1022c03a 	cmpne	r17,r2,zero
8112fb38:	00800884 	movi	r2,34
8112fb3c:	1463c83a 	sub	r17,r2,r17
8112fb40:	003f2e06 	br	8112f7fc <__reset+0xfb10f7fc>

8112fb44 <__hexnan>:
8112fb44:	defff904 	addi	sp,sp,-28
8112fb48:	de00012e 	bgeu	sp,et,8112fb50 <__hexnan+0xc>
8112fb4c:	003b68fa 	trap	3
8112fb50:	dc800215 	stw	r18,8(sp)
8112fb54:	2c800017 	ldw	r18,0(r5)
8112fb58:	dfc00615 	stw	ra,24(sp)
8112fb5c:	dd400515 	stw	r21,20(sp)
8112fb60:	901fd17a 	srai	r15,r18,5
8112fb64:	dd000415 	stw	r20,16(sp)
8112fb68:	dcc00315 	stw	r19,12(sp)
8112fb6c:	7bdf883a 	add	r15,r15,r15
8112fb70:	7bdf883a 	add	r15,r15,r15
8112fb74:	dc400115 	stw	r17,4(sp)
8112fb78:	dc000015 	stw	r16,0(sp)
8112fb7c:	948007cc 	andi	r18,r18,31
8112fb80:	33df883a 	add	r15,r6,r15
8112fb84:	90000126 	beq	r18,zero,8112fb8c <__hexnan+0x48>
8112fb88:	7bc00104 	addi	r15,r15,4
8112fb8c:	22000017 	ldw	r8,0(r4)
8112fb90:	7affff04 	addi	r11,r15,-4
8112fb94:	03a04574 	movhi	r14,33045
8112fb98:	783fff15 	stw	zero,-4(r15)
8112fb9c:	581b883a 	mov	r13,r11
8112fba0:	580b883a 	mov	r5,r11
8112fba4:	000f883a 	mov	r7,zero
8112fba8:	003f883a 	mov	ra,zero
8112fbac:	0019883a 	mov	r12,zero
8112fbb0:	73b42e04 	addi	r14,r14,-12104
8112fbb4:	04400204 	movi	r17,8
8112fbb8:	04000804 	movi	r16,32
8112fbbc:	04c001c4 	movi	r19,7
8112fbc0:	42000044 	addi	r8,r8,1
8112fbc4:	40c00003 	ldbu	r3,0(r8)
8112fbc8:	18001d26 	beq	r3,zero,8112fc40 <__hexnan+0xfc>
8112fbcc:	70c5883a 	add	r2,r14,r3
8112fbd0:	10800003 	ldbu	r2,0(r2)
8112fbd4:	12403fcc 	andi	r9,r2,255
8112fbd8:	4800301e 	bne	r9,zero,8112fc9c <__hexnan+0x158>
8112fbdc:	80c04236 	bltu	r16,r3,8112fce8 <__hexnan+0x1a4>
8112fbe0:	fb3ff70e 	bge	ra,r12,8112fbc0 <__reset+0xfb10fbc0>
8112fbe4:	2b40112e 	bgeu	r5,r13,8112fc2c <__hexnan+0xe8>
8112fbe8:	99c01016 	blt	r19,r7,8112fc2c <__hexnan+0xe8>
8112fbec:	89e9c83a 	sub	r20,r17,r7
8112fbf0:	a529883a 	add	r20,r20,r20
8112fbf4:	2a800017 	ldw	r10,0(r5)
8112fbf8:	a529883a 	add	r20,r20,r20
8112fbfc:	852bc83a 	sub	r21,r16,r20
8112fc00:	28c00104 	addi	r3,r5,4
8112fc04:	2805883a 	mov	r2,r5
8112fc08:	19c00017 	ldw	r7,0(r3)
8112fc0c:	10800104 	addi	r2,r2,4
8112fc10:	18c00104 	addi	r3,r3,4
8112fc14:	3d52983a 	sll	r9,r7,r21
8112fc18:	4a92b03a 	or	r9,r9,r10
8112fc1c:	3d14d83a 	srl	r10,r7,r20
8112fc20:	127fff15 	stw	r9,-4(r2)
8112fc24:	1abfff15 	stw	r10,-4(r3)
8112fc28:	137ff736 	bltu	r2,r13,8112fc08 <__reset+0xfb10fc08>
8112fc2c:	31402836 	bltu	r6,r5,8112fcd0 <__hexnan+0x18c>
8112fc30:	42000044 	addi	r8,r8,1
8112fc34:	40c00003 	ldbu	r3,0(r8)
8112fc38:	01c00204 	movi	r7,8
8112fc3c:	183fe31e 	bne	r3,zero,8112fbcc <__reset+0xfb10fbcc>
8112fc40:	60002b26 	beq	r12,zero,8112fcf0 <__hexnan+0x1ac>
8112fc44:	2b40022e 	bgeu	r5,r13,8112fc50 <__hexnan+0x10c>
8112fc48:	008001c4 	movi	r2,7
8112fc4c:	11c0430e 	bge	r2,r7,8112fd5c <__hexnan+0x218>
8112fc50:	3140312e 	bgeu	r6,r5,8112fd18 <__hexnan+0x1d4>
8112fc54:	3007883a 	mov	r3,r6
8112fc58:	29000017 	ldw	r4,0(r5)
8112fc5c:	18800104 	addi	r2,r3,4
8112fc60:	29400104 	addi	r5,r5,4
8112fc64:	19000015 	stw	r4,0(r3)
8112fc68:	1007883a 	mov	r3,r2
8112fc6c:	597ffa2e 	bgeu	r11,r5,8112fc58 <__reset+0xfb10fc58>
8112fc70:	10000015 	stw	zero,0(r2)
8112fc74:	10800104 	addi	r2,r2,4
8112fc78:	58bffd2e 	bgeu	r11,r2,8112fc70 <__reset+0xfb10fc70>
8112fc7c:	78bfff17 	ldw	r2,-4(r15)
8112fc80:	1000041e 	bne	r2,zero,8112fc94 <__hexnan+0x150>
8112fc84:	32c02d26 	beq	r6,r11,8112fd3c <__hexnan+0x1f8>
8112fc88:	5affff04 	addi	r11,r11,-4
8112fc8c:	58800017 	ldw	r2,0(r11)
8112fc90:	103ffc26 	beq	r2,zero,8112fc84 <__reset+0xfb10fc84>
8112fc94:	00800144 	movi	r2,5
8112fc98:	00001606 	br	8112fcf4 <__hexnan+0x1b0>
8112fc9c:	39c00044 	addi	r7,r7,1
8112fca0:	63000044 	addi	r12,r12,1
8112fca4:	89c0040e 	bge	r17,r7,8112fcb8 <__hexnan+0x174>
8112fca8:	317fc52e 	bgeu	r6,r5,8112fbc0 <__reset+0xfb10fbc0>
8112fcac:	283fff15 	stw	zero,-4(r5)
8112fcb0:	01c00044 	movi	r7,1
8112fcb4:	297fff04 	addi	r5,r5,-4
8112fcb8:	28c00017 	ldw	r3,0(r5)
8112fcbc:	108003cc 	andi	r2,r2,15
8112fcc0:	1806913a 	slli	r3,r3,4
8112fcc4:	1884b03a 	or	r2,r3,r2
8112fcc8:	28800015 	stw	r2,0(r5)
8112fccc:	003fbc06 	br	8112fbc0 <__reset+0xfb10fbc0>
8112fcd0:	2b7fff04 	addi	r13,r5,-4
8112fcd4:	283fff15 	stw	zero,-4(r5)
8112fcd8:	603f883a 	mov	ra,r12
8112fcdc:	680b883a 	mov	r5,r13
8112fce0:	000f883a 	mov	r7,zero
8112fce4:	003fb606 	br	8112fbc0 <__reset+0xfb10fbc0>
8112fce8:	00800a44 	movi	r2,41
8112fcec:	18801726 	beq	r3,r2,8112fd4c <__hexnan+0x208>
8112fcf0:	00800104 	movi	r2,4
8112fcf4:	dfc00617 	ldw	ra,24(sp)
8112fcf8:	dd400517 	ldw	r21,20(sp)
8112fcfc:	dd000417 	ldw	r20,16(sp)
8112fd00:	dcc00317 	ldw	r19,12(sp)
8112fd04:	dc800217 	ldw	r18,8(sp)
8112fd08:	dc400117 	ldw	r17,4(sp)
8112fd0c:	dc000017 	ldw	r16,0(sp)
8112fd10:	dec00704 	addi	sp,sp,28
8112fd14:	f800283a 	ret
8112fd18:	903fd826 	beq	r18,zero,8112fc7c <__reset+0xfb10fc7c>
8112fd1c:	00c00804 	movi	r3,32
8112fd20:	1ca5c83a 	sub	r18,r3,r18
8112fd24:	00ffffc4 	movi	r3,-1
8112fd28:	78bfff17 	ldw	r2,-4(r15)
8112fd2c:	1c86d83a 	srl	r3,r3,r18
8112fd30:	1884703a 	and	r2,r3,r2
8112fd34:	78bfff15 	stw	r2,-4(r15)
8112fd38:	003fd106 	br	8112fc80 <__reset+0xfb10fc80>
8112fd3c:	00800044 	movi	r2,1
8112fd40:	58800015 	stw	r2,0(r11)
8112fd44:	00800144 	movi	r2,5
8112fd48:	003fea06 	br	8112fcf4 <__reset+0xfb10fcf4>
8112fd4c:	42000044 	addi	r8,r8,1
8112fd50:	22000015 	stw	r8,0(r4)
8112fd54:	603fbb1e 	bne	r12,zero,8112fc44 <__reset+0xfb10fc44>
8112fd58:	003fe506 	br	8112fcf0 <__reset+0xfb10fcf0>
8112fd5c:	02400204 	movi	r9,8
8112fd60:	49d3c83a 	sub	r9,r9,r7
8112fd64:	4a53883a 	add	r9,r9,r9
8112fd68:	2a000017 	ldw	r8,0(r5)
8112fd6c:	4a53883a 	add	r9,r9,r9
8112fd70:	02800804 	movi	r10,32
8112fd74:	5255c83a 	sub	r10,r10,r9
8112fd78:	28c00104 	addi	r3,r5,4
8112fd7c:	2805883a 	mov	r2,r5
8112fd80:	19c00017 	ldw	r7,0(r3)
8112fd84:	10800104 	addi	r2,r2,4
8112fd88:	18c00104 	addi	r3,r3,4
8112fd8c:	3a88983a 	sll	r4,r7,r10
8112fd90:	2208b03a 	or	r4,r4,r8
8112fd94:	3a50d83a 	srl	r8,r7,r9
8112fd98:	113fff15 	stw	r4,-4(r2)
8112fd9c:	1a3fff15 	stw	r8,-4(r3)
8112fda0:	137ff736 	bltu	r2,r13,8112fd80 <__reset+0xfb10fd80>
8112fda4:	003faa06 	br	8112fc50 <__reset+0xfb10fc50>

8112fda8 <strncmp>:
8112fda8:	30003126 	beq	r6,zero,8112fe70 <strncmp+0xc8>
8112fdac:	2144b03a 	or	r2,r4,r5
8112fdb0:	108000cc 	andi	r2,r2,3
8112fdb4:	10001e1e 	bne	r2,zero,8112fe30 <strncmp+0x88>
8112fdb8:	024000c4 	movi	r9,3
8112fdbc:	49801c2e 	bgeu	r9,r6,8112fe30 <strncmp+0x88>
8112fdc0:	20800017 	ldw	r2,0(r4)
8112fdc4:	28c00017 	ldw	r3,0(r5)
8112fdc8:	10c0191e 	bne	r2,r3,8112fe30 <strncmp+0x88>
8112fdcc:	31bfff04 	addi	r6,r6,-4
8112fdd0:	30002726 	beq	r6,zero,8112fe70 <strncmp+0xc8>
8112fdd4:	02ffbff4 	movhi	r11,65279
8112fdd8:	5affbfc4 	addi	r11,r11,-257
8112fddc:	0086303a 	nor	r3,zero,r2
8112fde0:	02a02074 	movhi	r10,32897
8112fde4:	12c5883a 	add	r2,r2,r11
8112fde8:	52a02004 	addi	r10,r10,-32640
8112fdec:	10c4703a 	and	r2,r2,r3
8112fdf0:	1284703a 	and	r2,r2,r10
8112fdf4:	10000b26 	beq	r2,zero,8112fe24 <strncmp+0x7c>
8112fdf8:	00001d06 	br	8112fe70 <strncmp+0xc8>
8112fdfc:	20c00017 	ldw	r3,0(r4)
8112fe00:	29c00017 	ldw	r7,0(r5)
8112fe04:	1ad1883a 	add	r8,r3,r11
8112fe08:	00c4303a 	nor	r2,zero,r3
8112fe0c:	4084703a 	and	r2,r8,r2
8112fe10:	1284703a 	and	r2,r2,r10
8112fe14:	19c0061e 	bne	r3,r7,8112fe30 <strncmp+0x88>
8112fe18:	31bfff04 	addi	r6,r6,-4
8112fe1c:	30001426 	beq	r6,zero,8112fe70 <strncmp+0xc8>
8112fe20:	1000131e 	bne	r2,zero,8112fe70 <strncmp+0xc8>
8112fe24:	21000104 	addi	r4,r4,4
8112fe28:	29400104 	addi	r5,r5,4
8112fe2c:	49bff336 	bltu	r9,r6,8112fdfc <__reset+0xfb10fdfc>
8112fe30:	28800007 	ldb	r2,0(r5)
8112fe34:	20c00007 	ldb	r3,0(r4)
8112fe38:	31bfffc4 	addi	r6,r6,-1
8112fe3c:	10c0081e 	bne	r2,r3,8112fe60 <strncmp+0xb8>
8112fe40:	30000b26 	beq	r6,zero,8112fe70 <strncmp+0xc8>
8112fe44:	10000a26 	beq	r2,zero,8112fe70 <strncmp+0xc8>
8112fe48:	21000044 	addi	r4,r4,1
8112fe4c:	29400044 	addi	r5,r5,1
8112fe50:	20800007 	ldb	r2,0(r4)
8112fe54:	28c00007 	ldb	r3,0(r5)
8112fe58:	31bfffc4 	addi	r6,r6,-1
8112fe5c:	10fff826 	beq	r2,r3,8112fe40 <__reset+0xfb10fe40>
8112fe60:	20800003 	ldbu	r2,0(r4)
8112fe64:	28c00003 	ldbu	r3,0(r5)
8112fe68:	10c5c83a 	sub	r2,r2,r3
8112fe6c:	f800283a 	ret
8112fe70:	0005883a 	mov	r2,zero
8112fe74:	f800283a 	ret

8112fe78 <_wcrtomb_r>:
8112fe78:	defff604 	addi	sp,sp,-40
8112fe7c:	00a04574 	movhi	r2,33045
8112fe80:	de00012e 	bgeu	sp,et,8112fe88 <_wcrtomb_r+0x10>
8112fe84:	003b68fa 	trap	3
8112fe88:	10bd6804 	addi	r2,r2,-2656
8112fe8c:	dc800815 	stw	r18,32(sp)
8112fe90:	dc400715 	stw	r17,28(sp)
8112fe94:	dc000615 	stw	r16,24(sp)
8112fe98:	dfc00915 	stw	ra,36(sp)
8112fe9c:	2021883a 	mov	r16,r4
8112fea0:	3823883a 	mov	r17,r7
8112fea4:	14800017 	ldw	r18,0(r2)
8112fea8:	28001426 	beq	r5,zero,8112fefc <_wcrtomb_r+0x84>
8112feac:	d9400415 	stw	r5,16(sp)
8112feb0:	d9800515 	stw	r6,20(sp)
8112feb4:	11283a80 	call	811283a8 <__locale_charset>
8112feb8:	d9800517 	ldw	r6,20(sp)
8112febc:	d9400417 	ldw	r5,16(sp)
8112fec0:	100f883a 	mov	r7,r2
8112fec4:	dc400015 	stw	r17,0(sp)
8112fec8:	8009883a 	mov	r4,r16
8112fecc:	903ee83a 	callr	r18
8112fed0:	00ffffc4 	movi	r3,-1
8112fed4:	10c0031e 	bne	r2,r3,8112fee4 <_wcrtomb_r+0x6c>
8112fed8:	88000015 	stw	zero,0(r17)
8112fedc:	00c02284 	movi	r3,138
8112fee0:	80c00015 	stw	r3,0(r16)
8112fee4:	dfc00917 	ldw	ra,36(sp)
8112fee8:	dc800817 	ldw	r18,32(sp)
8112feec:	dc400717 	ldw	r17,28(sp)
8112fef0:	dc000617 	ldw	r16,24(sp)
8112fef4:	dec00a04 	addi	sp,sp,40
8112fef8:	f800283a 	ret
8112fefc:	11283a80 	call	811283a8 <__locale_charset>
8112ff00:	100f883a 	mov	r7,r2
8112ff04:	dc400015 	stw	r17,0(sp)
8112ff08:	000d883a 	mov	r6,zero
8112ff0c:	d9400104 	addi	r5,sp,4
8112ff10:	8009883a 	mov	r4,r16
8112ff14:	903ee83a 	callr	r18
8112ff18:	003fed06 	br	8112fed0 <__reset+0xfb10fed0>

8112ff1c <wcrtomb>:
8112ff1c:	defff604 	addi	sp,sp,-40
8112ff20:	00a04574 	movhi	r2,33045
8112ff24:	de00012e 	bgeu	sp,et,8112ff2c <wcrtomb+0x10>
8112ff28:	003b68fa 	trap	3
8112ff2c:	10bd6304 	addi	r2,r2,-2676
8112ff30:	dc800615 	stw	r18,24(sp)
8112ff34:	dc400515 	stw	r17,20(sp)
8112ff38:	dfc00915 	stw	ra,36(sp)
8112ff3c:	dd000815 	stw	r20,32(sp)
8112ff40:	dcc00715 	stw	r19,28(sp)
8112ff44:	dc000415 	stw	r16,16(sp)
8112ff48:	3025883a 	mov	r18,r6
8112ff4c:	14400017 	ldw	r17,0(r2)
8112ff50:	20001926 	beq	r4,zero,8112ffb8 <wcrtomb+0x9c>
8112ff54:	00a04574 	movhi	r2,33045
8112ff58:	10bd6804 	addi	r2,r2,-2656
8112ff5c:	15000017 	ldw	r20,0(r2)
8112ff60:	2021883a 	mov	r16,r4
8112ff64:	2827883a 	mov	r19,r5
8112ff68:	11283a80 	call	811283a8 <__locale_charset>
8112ff6c:	100f883a 	mov	r7,r2
8112ff70:	dc800015 	stw	r18,0(sp)
8112ff74:	980d883a 	mov	r6,r19
8112ff78:	800b883a 	mov	r5,r16
8112ff7c:	8809883a 	mov	r4,r17
8112ff80:	a03ee83a 	callr	r20
8112ff84:	00ffffc4 	movi	r3,-1
8112ff88:	10c0031e 	bne	r2,r3,8112ff98 <wcrtomb+0x7c>
8112ff8c:	90000015 	stw	zero,0(r18)
8112ff90:	00c02284 	movi	r3,138
8112ff94:	88c00015 	stw	r3,0(r17)
8112ff98:	dfc00917 	ldw	ra,36(sp)
8112ff9c:	dd000817 	ldw	r20,32(sp)
8112ffa0:	dcc00717 	ldw	r19,28(sp)
8112ffa4:	dc800617 	ldw	r18,24(sp)
8112ffa8:	dc400517 	ldw	r17,20(sp)
8112ffac:	dc000417 	ldw	r16,16(sp)
8112ffb0:	dec00a04 	addi	sp,sp,40
8112ffb4:	f800283a 	ret
8112ffb8:	00a04574 	movhi	r2,33045
8112ffbc:	10bd6804 	addi	r2,r2,-2656
8112ffc0:	14000017 	ldw	r16,0(r2)
8112ffc4:	11283a80 	call	811283a8 <__locale_charset>
8112ffc8:	100f883a 	mov	r7,r2
8112ffcc:	dc800015 	stw	r18,0(sp)
8112ffd0:	000d883a 	mov	r6,zero
8112ffd4:	d9400104 	addi	r5,sp,4
8112ffd8:	8809883a 	mov	r4,r17
8112ffdc:	803ee83a 	callr	r16
8112ffe0:	003fe806 	br	8112ff84 <__reset+0xfb10ff84>

8112ffe4 <__ascii_wctomb>:
8112ffe4:	28000526 	beq	r5,zero,8112fffc <__ascii_wctomb+0x18>
8112ffe8:	00803fc4 	movi	r2,255
8112ffec:	11800536 	bltu	r2,r6,81130004 <__ascii_wctomb+0x20>
8112fff0:	29800005 	stb	r6,0(r5)
8112fff4:	00800044 	movi	r2,1
8112fff8:	f800283a 	ret
8112fffc:	0005883a 	mov	r2,zero
81130000:	f800283a 	ret
81130004:	00802284 	movi	r2,138
81130008:	20800015 	stw	r2,0(r4)
8113000c:	00bfffc4 	movi	r2,-1
81130010:	f800283a 	ret

81130014 <_wctomb_r>:
81130014:	00a04574 	movhi	r2,33045
81130018:	defff904 	addi	sp,sp,-28
8113001c:	10bd6804 	addi	r2,r2,-2656
81130020:	de00012e 	bgeu	sp,et,81130028 <_wctomb_r+0x14>
81130024:	003b68fa 	trap	3
81130028:	dfc00615 	stw	ra,24(sp)
8113002c:	dc400515 	stw	r17,20(sp)
81130030:	dc000415 	stw	r16,16(sp)
81130034:	3823883a 	mov	r17,r7
81130038:	14000017 	ldw	r16,0(r2)
8113003c:	d9000115 	stw	r4,4(sp)
81130040:	d9400215 	stw	r5,8(sp)
81130044:	d9800315 	stw	r6,12(sp)
81130048:	11283a80 	call	811283a8 <__locale_charset>
8113004c:	d9800317 	ldw	r6,12(sp)
81130050:	d9400217 	ldw	r5,8(sp)
81130054:	d9000117 	ldw	r4,4(sp)
81130058:	100f883a 	mov	r7,r2
8113005c:	dc400015 	stw	r17,0(sp)
81130060:	803ee83a 	callr	r16
81130064:	dfc00617 	ldw	ra,24(sp)
81130068:	dc400517 	ldw	r17,20(sp)
8113006c:	dc000417 	ldw	r16,16(sp)
81130070:	dec00704 	addi	sp,sp,28
81130074:	f800283a 	ret

81130078 <__fixunsdfsi>:
81130078:	defffd04 	addi	sp,sp,-12
8113007c:	000d883a 	mov	r6,zero
81130080:	01d07834 	movhi	r7,16864
81130084:	de00012e 	bgeu	sp,et,8113008c <__fixunsdfsi+0x14>
81130088:	003b68fa 	trap	3
8113008c:	dc400115 	stw	r17,4(sp)
81130090:	dc000015 	stw	r16,0(sp)
81130094:	dfc00215 	stw	ra,8(sp)
81130098:	2023883a 	mov	r17,r4
8113009c:	2821883a 	mov	r16,r5
811300a0:	11321900 	call	81132190 <__gedf2>
811300a4:	1000080e 	bge	r2,zero,811300c8 <__fixunsdfsi+0x50>
811300a8:	8809883a 	mov	r4,r17
811300ac:	800b883a 	mov	r5,r16
811300b0:	1132c640 	call	81132c64 <__fixdfsi>
811300b4:	dfc00217 	ldw	ra,8(sp)
811300b8:	dc400117 	ldw	r17,4(sp)
811300bc:	dc000017 	ldw	r16,0(sp)
811300c0:	dec00304 	addi	sp,sp,12
811300c4:	f800283a 	ret
811300c8:	000d883a 	mov	r6,zero
811300cc:	01d07834 	movhi	r7,16864
811300d0:	8809883a 	mov	r4,r17
811300d4:	800b883a 	mov	r5,r16
811300d8:	11323600 	call	81132360 <__subdf3>
811300dc:	180b883a 	mov	r5,r3
811300e0:	1009883a 	mov	r4,r2
811300e4:	1132c640 	call	81132c64 <__fixdfsi>
811300e8:	00e00034 	movhi	r3,32768
811300ec:	10c5883a 	add	r2,r2,r3
811300f0:	003ff006 	br	811300b4 <__reset+0xfb1100b4>

811300f4 <__udivdi3>:
811300f4:	defff504 	addi	sp,sp,-44
811300f8:	de00012e 	bgeu	sp,et,81130100 <__udivdi3+0xc>
811300fc:	003b68fa 	trap	3
81130100:	dcc00415 	stw	r19,16(sp)
81130104:	dc000115 	stw	r16,4(sp)
81130108:	dfc00a15 	stw	ra,40(sp)
8113010c:	df000915 	stw	fp,36(sp)
81130110:	ddc00815 	stw	r23,32(sp)
81130114:	dd800715 	stw	r22,28(sp)
81130118:	dd400615 	stw	r21,24(sp)
8113011c:	dd000515 	stw	r20,20(sp)
81130120:	dc800315 	stw	r18,12(sp)
81130124:	dc400215 	stw	r17,8(sp)
81130128:	2027883a 	mov	r19,r4
8113012c:	2821883a 	mov	r16,r5
81130130:	3800411e 	bne	r7,zero,81130238 <__udivdi3+0x144>
81130134:	3023883a 	mov	r17,r6
81130138:	2025883a 	mov	r18,r4
8113013c:	2980522e 	bgeu	r5,r6,81130288 <__udivdi3+0x194>
81130140:	00bfffd4 	movui	r2,65535
81130144:	282d883a 	mov	r22,r5
81130148:	1180a836 	bltu	r2,r6,811303ec <__udivdi3+0x2f8>
8113014c:	00803fc4 	movi	r2,255
81130150:	1185803a 	cmpltu	r2,r2,r6
81130154:	100490fa 	slli	r2,r2,3
81130158:	3086d83a 	srl	r3,r6,r2
8113015c:	01204574 	movhi	r4,33045
81130160:	2132a804 	addi	r4,r4,-13664
81130164:	20c7883a 	add	r3,r4,r3
81130168:	18c00003 	ldbu	r3,0(r3)
8113016c:	1885883a 	add	r2,r3,r2
81130170:	00c00804 	movi	r3,32
81130174:	1887c83a 	sub	r3,r3,r2
81130178:	18000526 	beq	r3,zero,81130190 <__udivdi3+0x9c>
8113017c:	80e0983a 	sll	r16,r16,r3
81130180:	9884d83a 	srl	r2,r19,r2
81130184:	30e2983a 	sll	r17,r6,r3
81130188:	98e4983a 	sll	r18,r19,r3
8113018c:	142cb03a 	or	r22,r2,r16
81130190:	882ad43a 	srli	r21,r17,16
81130194:	b009883a 	mov	r4,r22
81130198:	8d3fffcc 	andi	r20,r17,65535
8113019c:	a80b883a 	mov	r5,r21
811301a0:	1130d100 	call	81130d10 <__umodsi3>
811301a4:	b009883a 	mov	r4,r22
811301a8:	a80b883a 	mov	r5,r21
811301ac:	1027883a 	mov	r19,r2
811301b0:	1130cac0 	call	81130cac <__udivsi3>
811301b4:	102d883a 	mov	r22,r2
811301b8:	9826943a 	slli	r19,r19,16
811301bc:	9004d43a 	srli	r2,r18,16
811301c0:	a5a1383a 	mul	r16,r20,r22
811301c4:	14c4b03a 	or	r2,r2,r19
811301c8:	1400052e 	bgeu	r2,r16,811301e0 <__udivdi3+0xec>
811301cc:	1445883a 	add	r2,r2,r17
811301d0:	b0ffffc4 	addi	r3,r22,-1
811301d4:	14400136 	bltu	r2,r17,811301dc <__udivdi3+0xe8>
811301d8:	14012336 	bltu	r2,r16,81130668 <__udivdi3+0x574>
811301dc:	182d883a 	mov	r22,r3
811301e0:	1421c83a 	sub	r16,r2,r16
811301e4:	a80b883a 	mov	r5,r21
811301e8:	8009883a 	mov	r4,r16
811301ec:	1130d100 	call	81130d10 <__umodsi3>
811301f0:	1027883a 	mov	r19,r2
811301f4:	a80b883a 	mov	r5,r21
811301f8:	8009883a 	mov	r4,r16
811301fc:	1130cac0 	call	81130cac <__udivsi3>
81130200:	9826943a 	slli	r19,r19,16
81130204:	a0a9383a 	mul	r20,r20,r2
81130208:	94bfffcc 	andi	r18,r18,65535
8113020c:	94e4b03a 	or	r18,r18,r19
81130210:	9500052e 	bgeu	r18,r20,81130228 <__udivdi3+0x134>
81130214:	8ca5883a 	add	r18,r17,r18
81130218:	10ffffc4 	addi	r3,r2,-1
8113021c:	9440f136 	bltu	r18,r17,811305e4 <__udivdi3+0x4f0>
81130220:	9500f02e 	bgeu	r18,r20,811305e4 <__udivdi3+0x4f0>
81130224:	10bfff84 	addi	r2,r2,-2
81130228:	b00c943a 	slli	r6,r22,16
8113022c:	0007883a 	mov	r3,zero
81130230:	3084b03a 	or	r2,r6,r2
81130234:	00005906 	br	8113039c <__udivdi3+0x2a8>
81130238:	29c05636 	bltu	r5,r7,81130394 <__udivdi3+0x2a0>
8113023c:	00bfffd4 	movui	r2,65535
81130240:	11c0622e 	bgeu	r2,r7,811303cc <__udivdi3+0x2d8>
81130244:	00804034 	movhi	r2,256
81130248:	10bfffc4 	addi	r2,r2,-1
8113024c:	11c0ee36 	bltu	r2,r7,81130608 <__udivdi3+0x514>
81130250:	00800404 	movi	r2,16
81130254:	3886d83a 	srl	r3,r7,r2
81130258:	01204574 	movhi	r4,33045
8113025c:	2132a804 	addi	r4,r4,-13664
81130260:	20c7883a 	add	r3,r4,r3
81130264:	18c00003 	ldbu	r3,0(r3)
81130268:	05400804 	movi	r21,32
8113026c:	1885883a 	add	r2,r3,r2
81130270:	a8abc83a 	sub	r21,r21,r2
81130274:	a800621e 	bne	r21,zero,81130400 <__udivdi3+0x30c>
81130278:	3c00e936 	bltu	r7,r16,81130620 <__udivdi3+0x52c>
8113027c:	9985403a 	cmpgeu	r2,r19,r6
81130280:	0007883a 	mov	r3,zero
81130284:	00004506 	br	8113039c <__udivdi3+0x2a8>
81130288:	3000041e 	bne	r6,zero,8113029c <__udivdi3+0x1a8>
8113028c:	000b883a 	mov	r5,zero
81130290:	01000044 	movi	r4,1
81130294:	1130cac0 	call	81130cac <__udivsi3>
81130298:	1023883a 	mov	r17,r2
8113029c:	00bfffd4 	movui	r2,65535
811302a0:	14404e2e 	bgeu	r2,r17,811303dc <__udivdi3+0x2e8>
811302a4:	00804034 	movhi	r2,256
811302a8:	10bfffc4 	addi	r2,r2,-1
811302ac:	1440d836 	bltu	r2,r17,81130610 <__udivdi3+0x51c>
811302b0:	00800404 	movi	r2,16
811302b4:	8886d83a 	srl	r3,r17,r2
811302b8:	01204574 	movhi	r4,33045
811302bc:	2132a804 	addi	r4,r4,-13664
811302c0:	20c7883a 	add	r3,r4,r3
811302c4:	18c00003 	ldbu	r3,0(r3)
811302c8:	1885883a 	add	r2,r3,r2
811302cc:	00c00804 	movi	r3,32
811302d0:	1887c83a 	sub	r3,r3,r2
811302d4:	18008f1e 	bne	r3,zero,81130514 <__udivdi3+0x420>
811302d8:	882ad43a 	srli	r21,r17,16
811302dc:	8461c83a 	sub	r16,r16,r17
811302e0:	8d3fffcc 	andi	r20,r17,65535
811302e4:	00c00044 	movi	r3,1
811302e8:	8009883a 	mov	r4,r16
811302ec:	a80b883a 	mov	r5,r21
811302f0:	d8c00015 	stw	r3,0(sp)
811302f4:	1130d100 	call	81130d10 <__umodsi3>
811302f8:	8009883a 	mov	r4,r16
811302fc:	a80b883a 	mov	r5,r21
81130300:	1027883a 	mov	r19,r2
81130304:	1130cac0 	call	81130cac <__udivsi3>
81130308:	9826943a 	slli	r19,r19,16
8113030c:	9008d43a 	srli	r4,r18,16
81130310:	1521383a 	mul	r16,r2,r20
81130314:	102d883a 	mov	r22,r2
81130318:	24c8b03a 	or	r4,r4,r19
8113031c:	d8c00017 	ldw	r3,0(sp)
81130320:	2400052e 	bgeu	r4,r16,81130338 <__udivdi3+0x244>
81130324:	2449883a 	add	r4,r4,r17
81130328:	b0bfffc4 	addi	r2,r22,-1
8113032c:	24400136 	bltu	r4,r17,81130334 <__udivdi3+0x240>
81130330:	2400ca36 	bltu	r4,r16,8113065c <__udivdi3+0x568>
81130334:	102d883a 	mov	r22,r2
81130338:	2421c83a 	sub	r16,r4,r16
8113033c:	a80b883a 	mov	r5,r21
81130340:	8009883a 	mov	r4,r16
81130344:	d8c00015 	stw	r3,0(sp)
81130348:	1130d100 	call	81130d10 <__umodsi3>
8113034c:	1027883a 	mov	r19,r2
81130350:	a80b883a 	mov	r5,r21
81130354:	8009883a 	mov	r4,r16
81130358:	1130cac0 	call	81130cac <__udivsi3>
8113035c:	9826943a 	slli	r19,r19,16
81130360:	1529383a 	mul	r20,r2,r20
81130364:	94bfffcc 	andi	r18,r18,65535
81130368:	94e4b03a 	or	r18,r18,r19
8113036c:	d8c00017 	ldw	r3,0(sp)
81130370:	9500052e 	bgeu	r18,r20,81130388 <__udivdi3+0x294>
81130374:	8ca5883a 	add	r18,r17,r18
81130378:	113fffc4 	addi	r4,r2,-1
8113037c:	94409736 	bltu	r18,r17,811305dc <__udivdi3+0x4e8>
81130380:	9500962e 	bgeu	r18,r20,811305dc <__udivdi3+0x4e8>
81130384:	10bfff84 	addi	r2,r2,-2
81130388:	b00c943a 	slli	r6,r22,16
8113038c:	3084b03a 	or	r2,r6,r2
81130390:	00000206 	br	8113039c <__udivdi3+0x2a8>
81130394:	0007883a 	mov	r3,zero
81130398:	0005883a 	mov	r2,zero
8113039c:	dfc00a17 	ldw	ra,40(sp)
811303a0:	df000917 	ldw	fp,36(sp)
811303a4:	ddc00817 	ldw	r23,32(sp)
811303a8:	dd800717 	ldw	r22,28(sp)
811303ac:	dd400617 	ldw	r21,24(sp)
811303b0:	dd000517 	ldw	r20,20(sp)
811303b4:	dcc00417 	ldw	r19,16(sp)
811303b8:	dc800317 	ldw	r18,12(sp)
811303bc:	dc400217 	ldw	r17,8(sp)
811303c0:	dc000117 	ldw	r16,4(sp)
811303c4:	dec00b04 	addi	sp,sp,44
811303c8:	f800283a 	ret
811303cc:	00803fc4 	movi	r2,255
811303d0:	11c5803a 	cmpltu	r2,r2,r7
811303d4:	100490fa 	slli	r2,r2,3
811303d8:	003f9e06 	br	81130254 <__reset+0xfb110254>
811303dc:	00803fc4 	movi	r2,255
811303e0:	1445803a 	cmpltu	r2,r2,r17
811303e4:	100490fa 	slli	r2,r2,3
811303e8:	003fb206 	br	811302b4 <__reset+0xfb1102b4>
811303ec:	00804034 	movhi	r2,256
811303f0:	10bfffc4 	addi	r2,r2,-1
811303f4:	11808836 	bltu	r2,r6,81130618 <__udivdi3+0x524>
811303f8:	00800404 	movi	r2,16
811303fc:	003f5606 	br	81130158 <__reset+0xfb110158>
81130400:	30aed83a 	srl	r23,r6,r2
81130404:	3d4e983a 	sll	r7,r7,r21
81130408:	80acd83a 	srl	r22,r16,r2
8113040c:	9884d83a 	srl	r2,r19,r2
81130410:	3deeb03a 	or	r23,r7,r23
81130414:	b824d43a 	srli	r18,r23,16
81130418:	8560983a 	sll	r16,r16,r21
8113041c:	b009883a 	mov	r4,r22
81130420:	900b883a 	mov	r5,r18
81130424:	3568983a 	sll	r20,r6,r21
81130428:	1420b03a 	or	r16,r2,r16
8113042c:	1130d100 	call	81130d10 <__umodsi3>
81130430:	b009883a 	mov	r4,r22
81130434:	900b883a 	mov	r5,r18
81130438:	1023883a 	mov	r17,r2
8113043c:	1130cac0 	call	81130cac <__udivsi3>
81130440:	8808943a 	slli	r4,r17,16
81130444:	bf3fffcc 	andi	fp,r23,65535
81130448:	8006d43a 	srli	r3,r16,16
8113044c:	e0a3383a 	mul	r17,fp,r2
81130450:	100d883a 	mov	r6,r2
81130454:	1906b03a 	or	r3,r3,r4
81130458:	1c40042e 	bgeu	r3,r17,8113046c <__udivdi3+0x378>
8113045c:	1dc7883a 	add	r3,r3,r23
81130460:	10bfffc4 	addi	r2,r2,-1
81130464:	1dc0752e 	bgeu	r3,r23,8113063c <__udivdi3+0x548>
81130468:	100d883a 	mov	r6,r2
8113046c:	1c63c83a 	sub	r17,r3,r17
81130470:	900b883a 	mov	r5,r18
81130474:	8809883a 	mov	r4,r17
81130478:	d9800015 	stw	r6,0(sp)
8113047c:	1130d100 	call	81130d10 <__umodsi3>
81130480:	102d883a 	mov	r22,r2
81130484:	8809883a 	mov	r4,r17
81130488:	900b883a 	mov	r5,r18
8113048c:	1130cac0 	call	81130cac <__udivsi3>
81130490:	b02c943a 	slli	r22,r22,16
81130494:	e089383a 	mul	r4,fp,r2
81130498:	843fffcc 	andi	r16,r16,65535
8113049c:	85a0b03a 	or	r16,r16,r22
811304a0:	d9800017 	ldw	r6,0(sp)
811304a4:	8100042e 	bgeu	r16,r4,811304b8 <__udivdi3+0x3c4>
811304a8:	85e1883a 	add	r16,r16,r23
811304ac:	10ffffc4 	addi	r3,r2,-1
811304b0:	85c05e2e 	bgeu	r16,r23,8113062c <__udivdi3+0x538>
811304b4:	1805883a 	mov	r2,r3
811304b8:	300c943a 	slli	r6,r6,16
811304bc:	a17fffcc 	andi	r5,r20,65535
811304c0:	a028d43a 	srli	r20,r20,16
811304c4:	3084b03a 	or	r2,r6,r2
811304c8:	10ffffcc 	andi	r3,r2,65535
811304cc:	100cd43a 	srli	r6,r2,16
811304d0:	194f383a 	mul	r7,r3,r5
811304d4:	1d07383a 	mul	r3,r3,r20
811304d8:	314b383a 	mul	r5,r6,r5
811304dc:	3810d43a 	srli	r8,r7,16
811304e0:	8121c83a 	sub	r16,r16,r4
811304e4:	1947883a 	add	r3,r3,r5
811304e8:	40c7883a 	add	r3,r8,r3
811304ec:	350d383a 	mul	r6,r6,r20
811304f0:	1940022e 	bgeu	r3,r5,811304fc <__udivdi3+0x408>
811304f4:	01000074 	movhi	r4,1
811304f8:	310d883a 	add	r6,r6,r4
811304fc:	1828d43a 	srli	r20,r3,16
81130500:	a18d883a 	add	r6,r20,r6
81130504:	81803e36 	bltu	r16,r6,81130600 <__udivdi3+0x50c>
81130508:	81803826 	beq	r16,r6,811305ec <__udivdi3+0x4f8>
8113050c:	0007883a 	mov	r3,zero
81130510:	003fa206 	br	8113039c <__reset+0xfb11039c>
81130514:	88e2983a 	sll	r17,r17,r3
81130518:	80a8d83a 	srl	r20,r16,r2
8113051c:	80e0983a 	sll	r16,r16,r3
81130520:	882ad43a 	srli	r21,r17,16
81130524:	9884d83a 	srl	r2,r19,r2
81130528:	a009883a 	mov	r4,r20
8113052c:	a80b883a 	mov	r5,r21
81130530:	142eb03a 	or	r23,r2,r16
81130534:	98e4983a 	sll	r18,r19,r3
81130538:	1130d100 	call	81130d10 <__umodsi3>
8113053c:	a009883a 	mov	r4,r20
81130540:	a80b883a 	mov	r5,r21
81130544:	1021883a 	mov	r16,r2
81130548:	1130cac0 	call	81130cac <__udivsi3>
8113054c:	1039883a 	mov	fp,r2
81130550:	8d3fffcc 	andi	r20,r17,65535
81130554:	8020943a 	slli	r16,r16,16
81130558:	b804d43a 	srli	r2,r23,16
8113055c:	a72d383a 	mul	r22,r20,fp
81130560:	1404b03a 	or	r2,r2,r16
81130564:	1580062e 	bgeu	r2,r22,81130580 <__udivdi3+0x48c>
81130568:	1445883a 	add	r2,r2,r17
8113056c:	e0ffffc4 	addi	r3,fp,-1
81130570:	14403836 	bltu	r2,r17,81130654 <__udivdi3+0x560>
81130574:	1580372e 	bgeu	r2,r22,81130654 <__udivdi3+0x560>
81130578:	e73fff84 	addi	fp,fp,-2
8113057c:	1445883a 	add	r2,r2,r17
81130580:	15adc83a 	sub	r22,r2,r22
81130584:	a80b883a 	mov	r5,r21
81130588:	b009883a 	mov	r4,r22
8113058c:	1130d100 	call	81130d10 <__umodsi3>
81130590:	1027883a 	mov	r19,r2
81130594:	b009883a 	mov	r4,r22
81130598:	a80b883a 	mov	r5,r21
8113059c:	1130cac0 	call	81130cac <__udivsi3>
811305a0:	9826943a 	slli	r19,r19,16
811305a4:	a0a1383a 	mul	r16,r20,r2
811305a8:	b93fffcc 	andi	r4,r23,65535
811305ac:	24c8b03a 	or	r4,r4,r19
811305b0:	2400062e 	bgeu	r4,r16,811305cc <__udivdi3+0x4d8>
811305b4:	2449883a 	add	r4,r4,r17
811305b8:	10ffffc4 	addi	r3,r2,-1
811305bc:	24402336 	bltu	r4,r17,8113064c <__udivdi3+0x558>
811305c0:	2400222e 	bgeu	r4,r16,8113064c <__udivdi3+0x558>
811305c4:	10bfff84 	addi	r2,r2,-2
811305c8:	2449883a 	add	r4,r4,r17
811305cc:	e038943a 	slli	fp,fp,16
811305d0:	2421c83a 	sub	r16,r4,r16
811305d4:	e086b03a 	or	r3,fp,r2
811305d8:	003f4306 	br	811302e8 <__reset+0xfb1102e8>
811305dc:	2005883a 	mov	r2,r4
811305e0:	003f6906 	br	81130388 <__reset+0xfb110388>
811305e4:	1805883a 	mov	r2,r3
811305e8:	003f0f06 	br	81130228 <__reset+0xfb110228>
811305ec:	1806943a 	slli	r3,r3,16
811305f0:	9d66983a 	sll	r19,r19,r21
811305f4:	39ffffcc 	andi	r7,r7,65535
811305f8:	19c7883a 	add	r3,r3,r7
811305fc:	98ffc32e 	bgeu	r19,r3,8113050c <__reset+0xfb11050c>
81130600:	10bfffc4 	addi	r2,r2,-1
81130604:	003fc106 	br	8113050c <__reset+0xfb11050c>
81130608:	00800604 	movi	r2,24
8113060c:	003f1106 	br	81130254 <__reset+0xfb110254>
81130610:	00800604 	movi	r2,24
81130614:	003f2706 	br	811302b4 <__reset+0xfb1102b4>
81130618:	00800604 	movi	r2,24
8113061c:	003ece06 	br	81130158 <__reset+0xfb110158>
81130620:	0007883a 	mov	r3,zero
81130624:	00800044 	movi	r2,1
81130628:	003f5c06 	br	8113039c <__reset+0xfb11039c>
8113062c:	813fa12e 	bgeu	r16,r4,811304b4 <__reset+0xfb1104b4>
81130630:	10bfff84 	addi	r2,r2,-2
81130634:	85e1883a 	add	r16,r16,r23
81130638:	003f9f06 	br	811304b8 <__reset+0xfb1104b8>
8113063c:	1c7f8a2e 	bgeu	r3,r17,81130468 <__reset+0xfb110468>
81130640:	31bfff84 	addi	r6,r6,-2
81130644:	1dc7883a 	add	r3,r3,r23
81130648:	003f8806 	br	8113046c <__reset+0xfb11046c>
8113064c:	1805883a 	mov	r2,r3
81130650:	003fde06 	br	811305cc <__reset+0xfb1105cc>
81130654:	1839883a 	mov	fp,r3
81130658:	003fc906 	br	81130580 <__reset+0xfb110580>
8113065c:	b5bfff84 	addi	r22,r22,-2
81130660:	2449883a 	add	r4,r4,r17
81130664:	003f3406 	br	81130338 <__reset+0xfb110338>
81130668:	b5bfff84 	addi	r22,r22,-2
8113066c:	1445883a 	add	r2,r2,r17
81130670:	003edb06 	br	811301e0 <__reset+0xfb1101e0>

81130674 <__umoddi3>:
81130674:	defff404 	addi	sp,sp,-48
81130678:	de00012e 	bgeu	sp,et,81130680 <__umoddi3+0xc>
8113067c:	003b68fa 	trap	3
81130680:	df000a15 	stw	fp,40(sp)
81130684:	dc400315 	stw	r17,12(sp)
81130688:	dc000215 	stw	r16,8(sp)
8113068c:	dfc00b15 	stw	ra,44(sp)
81130690:	ddc00915 	stw	r23,36(sp)
81130694:	dd800815 	stw	r22,32(sp)
81130698:	dd400715 	stw	r21,28(sp)
8113069c:	dd000615 	stw	r20,24(sp)
811306a0:	dcc00515 	stw	r19,20(sp)
811306a4:	dc800415 	stw	r18,16(sp)
811306a8:	2021883a 	mov	r16,r4
811306ac:	2823883a 	mov	r17,r5
811306b0:	2839883a 	mov	fp,r5
811306b4:	38003c1e 	bne	r7,zero,811307a8 <__umoddi3+0x134>
811306b8:	3027883a 	mov	r19,r6
811306bc:	2029883a 	mov	r20,r4
811306c0:	2980512e 	bgeu	r5,r6,81130808 <__umoddi3+0x194>
811306c4:	00bfffd4 	movui	r2,65535
811306c8:	11809a36 	bltu	r2,r6,81130934 <__umoddi3+0x2c0>
811306cc:	01003fc4 	movi	r4,255
811306d0:	2189803a 	cmpltu	r4,r4,r6
811306d4:	200890fa 	slli	r4,r4,3
811306d8:	3104d83a 	srl	r2,r6,r4
811306dc:	00e04574 	movhi	r3,33045
811306e0:	18f2a804 	addi	r3,r3,-13664
811306e4:	1885883a 	add	r2,r3,r2
811306e8:	10c00003 	ldbu	r3,0(r2)
811306ec:	00800804 	movi	r2,32
811306f0:	1909883a 	add	r4,r3,r4
811306f4:	1125c83a 	sub	r18,r2,r4
811306f8:	90000526 	beq	r18,zero,81130710 <__umoddi3+0x9c>
811306fc:	8ca2983a 	sll	r17,r17,r18
81130700:	8108d83a 	srl	r4,r16,r4
81130704:	34a6983a 	sll	r19,r6,r18
81130708:	84a8983a 	sll	r20,r16,r18
8113070c:	2478b03a 	or	fp,r4,r17
81130710:	982ed43a 	srli	r23,r19,16
81130714:	e009883a 	mov	r4,fp
81130718:	9dbfffcc 	andi	r22,r19,65535
8113071c:	b80b883a 	mov	r5,r23
81130720:	1130d100 	call	81130d10 <__umodsi3>
81130724:	e009883a 	mov	r4,fp
81130728:	b80b883a 	mov	r5,r23
8113072c:	102b883a 	mov	r21,r2
81130730:	1130cac0 	call	81130cac <__udivsi3>
81130734:	a806943a 	slli	r3,r21,16
81130738:	a008d43a 	srli	r4,r20,16
8113073c:	b085383a 	mul	r2,r22,r2
81130740:	20c8b03a 	or	r4,r4,r3
81130744:	2080032e 	bgeu	r4,r2,81130754 <__umoddi3+0xe0>
81130748:	24c9883a 	add	r4,r4,r19
8113074c:	24c00136 	bltu	r4,r19,81130754 <__umoddi3+0xe0>
81130750:	20811036 	bltu	r4,r2,81130b94 <__umoddi3+0x520>
81130754:	20abc83a 	sub	r21,r4,r2
81130758:	b80b883a 	mov	r5,r23
8113075c:	a809883a 	mov	r4,r21
81130760:	1130d100 	call	81130d10 <__umodsi3>
81130764:	1023883a 	mov	r17,r2
81130768:	b80b883a 	mov	r5,r23
8113076c:	a809883a 	mov	r4,r21
81130770:	1130cac0 	call	81130cac <__udivsi3>
81130774:	8822943a 	slli	r17,r17,16
81130778:	b085383a 	mul	r2,r22,r2
8113077c:	a0ffffcc 	andi	r3,r20,65535
81130780:	1c46b03a 	or	r3,r3,r17
81130784:	1880042e 	bgeu	r3,r2,81130798 <__umoddi3+0x124>
81130788:	1cc7883a 	add	r3,r3,r19
8113078c:	1cc00236 	bltu	r3,r19,81130798 <__umoddi3+0x124>
81130790:	1880012e 	bgeu	r3,r2,81130798 <__umoddi3+0x124>
81130794:	1cc7883a 	add	r3,r3,r19
81130798:	1885c83a 	sub	r2,r3,r2
8113079c:	1484d83a 	srl	r2,r2,r18
811307a0:	0007883a 	mov	r3,zero
811307a4:	00004f06 	br	811308e4 <__umoddi3+0x270>
811307a8:	29c04c36 	bltu	r5,r7,811308dc <__umoddi3+0x268>
811307ac:	00bfffd4 	movui	r2,65535
811307b0:	11c0582e 	bgeu	r2,r7,81130914 <__umoddi3+0x2a0>
811307b4:	00804034 	movhi	r2,256
811307b8:	10bfffc4 	addi	r2,r2,-1
811307bc:	11c0e736 	bltu	r2,r7,81130b5c <__umoddi3+0x4e8>
811307c0:	01000404 	movi	r4,16
811307c4:	3904d83a 	srl	r2,r7,r4
811307c8:	00e04574 	movhi	r3,33045
811307cc:	18f2a804 	addi	r3,r3,-13664
811307d0:	1885883a 	add	r2,r3,r2
811307d4:	14c00003 	ldbu	r19,0(r2)
811307d8:	00c00804 	movi	r3,32
811307dc:	9927883a 	add	r19,r19,r4
811307e0:	1ce9c83a 	sub	r20,r3,r19
811307e4:	a000581e 	bne	r20,zero,81130948 <__umoddi3+0x2d4>
811307e8:	3c400136 	bltu	r7,r17,811307f0 <__umoddi3+0x17c>
811307ec:	8180eb36 	bltu	r16,r6,81130b9c <__umoddi3+0x528>
811307f0:	8185c83a 	sub	r2,r16,r6
811307f4:	89e3c83a 	sub	r17,r17,r7
811307f8:	8089803a 	cmpltu	r4,r16,r2
811307fc:	8939c83a 	sub	fp,r17,r4
81130800:	e007883a 	mov	r3,fp
81130804:	00003706 	br	811308e4 <__umoddi3+0x270>
81130808:	3000041e 	bne	r6,zero,8113081c <__umoddi3+0x1a8>
8113080c:	000b883a 	mov	r5,zero
81130810:	01000044 	movi	r4,1
81130814:	1130cac0 	call	81130cac <__udivsi3>
81130818:	1027883a 	mov	r19,r2
8113081c:	00bfffd4 	movui	r2,65535
81130820:	14c0402e 	bgeu	r2,r19,81130924 <__umoddi3+0x2b0>
81130824:	00804034 	movhi	r2,256
81130828:	10bfffc4 	addi	r2,r2,-1
8113082c:	14c0cd36 	bltu	r2,r19,81130b64 <__umoddi3+0x4f0>
81130830:	00800404 	movi	r2,16
81130834:	9886d83a 	srl	r3,r19,r2
81130838:	01204574 	movhi	r4,33045
8113083c:	2132a804 	addi	r4,r4,-13664
81130840:	20c7883a 	add	r3,r4,r3
81130844:	18c00003 	ldbu	r3,0(r3)
81130848:	1887883a 	add	r3,r3,r2
8113084c:	00800804 	movi	r2,32
81130850:	10e5c83a 	sub	r18,r2,r3
81130854:	9000901e 	bne	r18,zero,81130a98 <__umoddi3+0x424>
81130858:	982cd43a 	srli	r22,r19,16
8113085c:	8ce3c83a 	sub	r17,r17,r19
81130860:	9d7fffcc 	andi	r21,r19,65535
81130864:	b00b883a 	mov	r5,r22
81130868:	8809883a 	mov	r4,r17
8113086c:	1130d100 	call	81130d10 <__umodsi3>
81130870:	8809883a 	mov	r4,r17
81130874:	b00b883a 	mov	r5,r22
81130878:	1021883a 	mov	r16,r2
8113087c:	1130cac0 	call	81130cac <__udivsi3>
81130880:	8006943a 	slli	r3,r16,16
81130884:	a008d43a 	srli	r4,r20,16
81130888:	1545383a 	mul	r2,r2,r21
8113088c:	20c8b03a 	or	r4,r4,r3
81130890:	2080042e 	bgeu	r4,r2,811308a4 <__umoddi3+0x230>
81130894:	24c9883a 	add	r4,r4,r19
81130898:	24c00236 	bltu	r4,r19,811308a4 <__umoddi3+0x230>
8113089c:	2080012e 	bgeu	r4,r2,811308a4 <__umoddi3+0x230>
811308a0:	24c9883a 	add	r4,r4,r19
811308a4:	20a1c83a 	sub	r16,r4,r2
811308a8:	b00b883a 	mov	r5,r22
811308ac:	8009883a 	mov	r4,r16
811308b0:	1130d100 	call	81130d10 <__umodsi3>
811308b4:	1023883a 	mov	r17,r2
811308b8:	b00b883a 	mov	r5,r22
811308bc:	8009883a 	mov	r4,r16
811308c0:	1130cac0 	call	81130cac <__udivsi3>
811308c4:	8822943a 	slli	r17,r17,16
811308c8:	1545383a 	mul	r2,r2,r21
811308cc:	a53fffcc 	andi	r20,r20,65535
811308d0:	a446b03a 	or	r3,r20,r17
811308d4:	18bfb02e 	bgeu	r3,r2,81130798 <__reset+0xfb110798>
811308d8:	003fab06 	br	81130788 <__reset+0xfb110788>
811308dc:	2005883a 	mov	r2,r4
811308e0:	2807883a 	mov	r3,r5
811308e4:	dfc00b17 	ldw	ra,44(sp)
811308e8:	df000a17 	ldw	fp,40(sp)
811308ec:	ddc00917 	ldw	r23,36(sp)
811308f0:	dd800817 	ldw	r22,32(sp)
811308f4:	dd400717 	ldw	r21,28(sp)
811308f8:	dd000617 	ldw	r20,24(sp)
811308fc:	dcc00517 	ldw	r19,20(sp)
81130900:	dc800417 	ldw	r18,16(sp)
81130904:	dc400317 	ldw	r17,12(sp)
81130908:	dc000217 	ldw	r16,8(sp)
8113090c:	dec00c04 	addi	sp,sp,48
81130910:	f800283a 	ret
81130914:	04c03fc4 	movi	r19,255
81130918:	99c9803a 	cmpltu	r4,r19,r7
8113091c:	200890fa 	slli	r4,r4,3
81130920:	003fa806 	br	811307c4 <__reset+0xfb1107c4>
81130924:	00803fc4 	movi	r2,255
81130928:	14c5803a 	cmpltu	r2,r2,r19
8113092c:	100490fa 	slli	r2,r2,3
81130930:	003fc006 	br	81130834 <__reset+0xfb110834>
81130934:	00804034 	movhi	r2,256
81130938:	10bfffc4 	addi	r2,r2,-1
8113093c:	11808b36 	bltu	r2,r6,81130b6c <__umoddi3+0x4f8>
81130940:	01000404 	movi	r4,16
81130944:	003f6406 	br	811306d8 <__reset+0xfb1106d8>
81130948:	34c4d83a 	srl	r2,r6,r19
8113094c:	3d0e983a 	sll	r7,r7,r20
81130950:	8cf8d83a 	srl	fp,r17,r19
81130954:	8d10983a 	sll	r8,r17,r20
81130958:	38aab03a 	or	r21,r7,r2
8113095c:	a82cd43a 	srli	r22,r21,16
81130960:	84e2d83a 	srl	r17,r16,r19
81130964:	e009883a 	mov	r4,fp
81130968:	b00b883a 	mov	r5,r22
8113096c:	8a22b03a 	or	r17,r17,r8
81130970:	3524983a 	sll	r18,r6,r20
81130974:	1130d100 	call	81130d10 <__umodsi3>
81130978:	e009883a 	mov	r4,fp
8113097c:	b00b883a 	mov	r5,r22
81130980:	102f883a 	mov	r23,r2
81130984:	1130cac0 	call	81130cac <__udivsi3>
81130988:	100d883a 	mov	r6,r2
8113098c:	b808943a 	slli	r4,r23,16
81130990:	aa3fffcc 	andi	r8,r21,65535
81130994:	8804d43a 	srli	r2,r17,16
81130998:	41af383a 	mul	r23,r8,r6
8113099c:	8520983a 	sll	r16,r16,r20
811309a0:	1104b03a 	or	r2,r2,r4
811309a4:	15c0042e 	bgeu	r2,r23,811309b8 <__umoddi3+0x344>
811309a8:	1545883a 	add	r2,r2,r21
811309ac:	30ffffc4 	addi	r3,r6,-1
811309b0:	1540742e 	bgeu	r2,r21,81130b84 <__umoddi3+0x510>
811309b4:	180d883a 	mov	r6,r3
811309b8:	15efc83a 	sub	r23,r2,r23
811309bc:	b00b883a 	mov	r5,r22
811309c0:	b809883a 	mov	r4,r23
811309c4:	d9800115 	stw	r6,4(sp)
811309c8:	da000015 	stw	r8,0(sp)
811309cc:	1130d100 	call	81130d10 <__umodsi3>
811309d0:	b00b883a 	mov	r5,r22
811309d4:	b809883a 	mov	r4,r23
811309d8:	1039883a 	mov	fp,r2
811309dc:	1130cac0 	call	81130cac <__udivsi3>
811309e0:	da000017 	ldw	r8,0(sp)
811309e4:	e038943a 	slli	fp,fp,16
811309e8:	100b883a 	mov	r5,r2
811309ec:	4089383a 	mul	r4,r8,r2
811309f0:	8a3fffcc 	andi	r8,r17,65535
811309f4:	4710b03a 	or	r8,r8,fp
811309f8:	d9800117 	ldw	r6,4(sp)
811309fc:	4100042e 	bgeu	r8,r4,81130a10 <__umoddi3+0x39c>
81130a00:	4551883a 	add	r8,r8,r21
81130a04:	10bfffc4 	addi	r2,r2,-1
81130a08:	45405a2e 	bgeu	r8,r21,81130b74 <__umoddi3+0x500>
81130a0c:	100b883a 	mov	r5,r2
81130a10:	300c943a 	slli	r6,r6,16
81130a14:	91ffffcc 	andi	r7,r18,65535
81130a18:	9004d43a 	srli	r2,r18,16
81130a1c:	314cb03a 	or	r6,r6,r5
81130a20:	317fffcc 	andi	r5,r6,65535
81130a24:	300cd43a 	srli	r6,r6,16
81130a28:	29d3383a 	mul	r9,r5,r7
81130a2c:	288b383a 	mul	r5,r5,r2
81130a30:	31cf383a 	mul	r7,r6,r7
81130a34:	4806d43a 	srli	r3,r9,16
81130a38:	4111c83a 	sub	r8,r8,r4
81130a3c:	29cb883a 	add	r5,r5,r7
81130a40:	194b883a 	add	r5,r3,r5
81130a44:	3085383a 	mul	r2,r6,r2
81130a48:	29c0022e 	bgeu	r5,r7,81130a54 <__umoddi3+0x3e0>
81130a4c:	00c00074 	movhi	r3,1
81130a50:	10c5883a 	add	r2,r2,r3
81130a54:	2808d43a 	srli	r4,r5,16
81130a58:	280a943a 	slli	r5,r5,16
81130a5c:	4a7fffcc 	andi	r9,r9,65535
81130a60:	2085883a 	add	r2,r4,r2
81130a64:	2a4b883a 	add	r5,r5,r9
81130a68:	40803636 	bltu	r8,r2,81130b44 <__umoddi3+0x4d0>
81130a6c:	40804d26 	beq	r8,r2,81130ba4 <__umoddi3+0x530>
81130a70:	4089c83a 	sub	r4,r8,r2
81130a74:	280f883a 	mov	r7,r5
81130a78:	81cfc83a 	sub	r7,r16,r7
81130a7c:	81c7803a 	cmpltu	r3,r16,r7
81130a80:	20c7c83a 	sub	r3,r4,r3
81130a84:	1cc4983a 	sll	r2,r3,r19
81130a88:	3d0ed83a 	srl	r7,r7,r20
81130a8c:	1d06d83a 	srl	r3,r3,r20
81130a90:	11c4b03a 	or	r2,r2,r7
81130a94:	003f9306 	br	811308e4 <__reset+0xfb1108e4>
81130a98:	9ca6983a 	sll	r19,r19,r18
81130a9c:	88e8d83a 	srl	r20,r17,r3
81130aa0:	80c4d83a 	srl	r2,r16,r3
81130aa4:	982cd43a 	srli	r22,r19,16
81130aa8:	8ca2983a 	sll	r17,r17,r18
81130aac:	a009883a 	mov	r4,r20
81130ab0:	b00b883a 	mov	r5,r22
81130ab4:	1478b03a 	or	fp,r2,r17
81130ab8:	1130d100 	call	81130d10 <__umodsi3>
81130abc:	a009883a 	mov	r4,r20
81130ac0:	b00b883a 	mov	r5,r22
81130ac4:	1023883a 	mov	r17,r2
81130ac8:	1130cac0 	call	81130cac <__udivsi3>
81130acc:	9d7fffcc 	andi	r21,r19,65535
81130ad0:	880a943a 	slli	r5,r17,16
81130ad4:	e008d43a 	srli	r4,fp,16
81130ad8:	a885383a 	mul	r2,r21,r2
81130adc:	84a8983a 	sll	r20,r16,r18
81130ae0:	2148b03a 	or	r4,r4,r5
81130ae4:	2080042e 	bgeu	r4,r2,81130af8 <__umoddi3+0x484>
81130ae8:	24c9883a 	add	r4,r4,r19
81130aec:	24c00236 	bltu	r4,r19,81130af8 <__umoddi3+0x484>
81130af0:	2080012e 	bgeu	r4,r2,81130af8 <__umoddi3+0x484>
81130af4:	24c9883a 	add	r4,r4,r19
81130af8:	20a3c83a 	sub	r17,r4,r2
81130afc:	b00b883a 	mov	r5,r22
81130b00:	8809883a 	mov	r4,r17
81130b04:	1130d100 	call	81130d10 <__umodsi3>
81130b08:	102f883a 	mov	r23,r2
81130b0c:	8809883a 	mov	r4,r17
81130b10:	b00b883a 	mov	r5,r22
81130b14:	1130cac0 	call	81130cac <__udivsi3>
81130b18:	b82e943a 	slli	r23,r23,16
81130b1c:	a885383a 	mul	r2,r21,r2
81130b20:	e13fffcc 	andi	r4,fp,65535
81130b24:	25c8b03a 	or	r4,r4,r23
81130b28:	2080042e 	bgeu	r4,r2,81130b3c <__umoddi3+0x4c8>
81130b2c:	24c9883a 	add	r4,r4,r19
81130b30:	24c00236 	bltu	r4,r19,81130b3c <__umoddi3+0x4c8>
81130b34:	2080012e 	bgeu	r4,r2,81130b3c <__umoddi3+0x4c8>
81130b38:	24c9883a 	add	r4,r4,r19
81130b3c:	20a3c83a 	sub	r17,r4,r2
81130b40:	003f4806 	br	81130864 <__reset+0xfb110864>
81130b44:	2c8fc83a 	sub	r7,r5,r18
81130b48:	1545c83a 	sub	r2,r2,r21
81130b4c:	29cb803a 	cmpltu	r5,r5,r7
81130b50:	1145c83a 	sub	r2,r2,r5
81130b54:	4089c83a 	sub	r4,r8,r2
81130b58:	003fc706 	br	81130a78 <__reset+0xfb110a78>
81130b5c:	01000604 	movi	r4,24
81130b60:	003f1806 	br	811307c4 <__reset+0xfb1107c4>
81130b64:	00800604 	movi	r2,24
81130b68:	003f3206 	br	81130834 <__reset+0xfb110834>
81130b6c:	01000604 	movi	r4,24
81130b70:	003ed906 	br	811306d8 <__reset+0xfb1106d8>
81130b74:	413fa52e 	bgeu	r8,r4,81130a0c <__reset+0xfb110a0c>
81130b78:	297fff84 	addi	r5,r5,-2
81130b7c:	4551883a 	add	r8,r8,r21
81130b80:	003fa306 	br	81130a10 <__reset+0xfb110a10>
81130b84:	15ff8b2e 	bgeu	r2,r23,811309b4 <__reset+0xfb1109b4>
81130b88:	31bfff84 	addi	r6,r6,-2
81130b8c:	1545883a 	add	r2,r2,r21
81130b90:	003f8906 	br	811309b8 <__reset+0xfb1109b8>
81130b94:	24c9883a 	add	r4,r4,r19
81130b98:	003eee06 	br	81130754 <__reset+0xfb110754>
81130b9c:	8005883a 	mov	r2,r16
81130ba0:	003f1706 	br	81130800 <__reset+0xfb110800>
81130ba4:	817fe736 	bltu	r16,r5,81130b44 <__reset+0xfb110b44>
81130ba8:	280f883a 	mov	r7,r5
81130bac:	0009883a 	mov	r4,zero
81130bb0:	003fb106 	br	81130a78 <__reset+0xfb110a78>

81130bb4 <__divsi3>:
81130bb4:	20001b16 	blt	r4,zero,81130c24 <__divsi3+0x70>
81130bb8:	000f883a 	mov	r7,zero
81130bbc:	28001616 	blt	r5,zero,81130c18 <__divsi3+0x64>
81130bc0:	200d883a 	mov	r6,r4
81130bc4:	29001a2e 	bgeu	r5,r4,81130c30 <__divsi3+0x7c>
81130bc8:	00800804 	movi	r2,32
81130bcc:	00c00044 	movi	r3,1
81130bd0:	00000106 	br	81130bd8 <__divsi3+0x24>
81130bd4:	10000d26 	beq	r2,zero,81130c0c <__divsi3+0x58>
81130bd8:	294b883a 	add	r5,r5,r5
81130bdc:	10bfffc4 	addi	r2,r2,-1
81130be0:	18c7883a 	add	r3,r3,r3
81130be4:	293ffb36 	bltu	r5,r4,81130bd4 <__reset+0xfb110bd4>
81130be8:	0005883a 	mov	r2,zero
81130bec:	18000726 	beq	r3,zero,81130c0c <__divsi3+0x58>
81130bf0:	0005883a 	mov	r2,zero
81130bf4:	31400236 	bltu	r6,r5,81130c00 <__divsi3+0x4c>
81130bf8:	314dc83a 	sub	r6,r6,r5
81130bfc:	10c4b03a 	or	r2,r2,r3
81130c00:	1806d07a 	srli	r3,r3,1
81130c04:	280ad07a 	srli	r5,r5,1
81130c08:	183ffa1e 	bne	r3,zero,81130bf4 <__reset+0xfb110bf4>
81130c0c:	38000126 	beq	r7,zero,81130c14 <__divsi3+0x60>
81130c10:	0085c83a 	sub	r2,zero,r2
81130c14:	f800283a 	ret
81130c18:	014bc83a 	sub	r5,zero,r5
81130c1c:	39c0005c 	xori	r7,r7,1
81130c20:	003fe706 	br	81130bc0 <__reset+0xfb110bc0>
81130c24:	0109c83a 	sub	r4,zero,r4
81130c28:	01c00044 	movi	r7,1
81130c2c:	003fe306 	br	81130bbc <__reset+0xfb110bbc>
81130c30:	00c00044 	movi	r3,1
81130c34:	003fee06 	br	81130bf0 <__reset+0xfb110bf0>

81130c38 <__modsi3>:
81130c38:	20001716 	blt	r4,zero,81130c98 <__modsi3+0x60>
81130c3c:	000f883a 	mov	r7,zero
81130c40:	2005883a 	mov	r2,r4
81130c44:	28001216 	blt	r5,zero,81130c90 <__modsi3+0x58>
81130c48:	2900162e 	bgeu	r5,r4,81130ca4 <__modsi3+0x6c>
81130c4c:	01800804 	movi	r6,32
81130c50:	00c00044 	movi	r3,1
81130c54:	00000106 	br	81130c5c <__modsi3+0x24>
81130c58:	30000a26 	beq	r6,zero,81130c84 <__modsi3+0x4c>
81130c5c:	294b883a 	add	r5,r5,r5
81130c60:	31bfffc4 	addi	r6,r6,-1
81130c64:	18c7883a 	add	r3,r3,r3
81130c68:	293ffb36 	bltu	r5,r4,81130c58 <__reset+0xfb110c58>
81130c6c:	18000526 	beq	r3,zero,81130c84 <__modsi3+0x4c>
81130c70:	1806d07a 	srli	r3,r3,1
81130c74:	11400136 	bltu	r2,r5,81130c7c <__modsi3+0x44>
81130c78:	1145c83a 	sub	r2,r2,r5
81130c7c:	280ad07a 	srli	r5,r5,1
81130c80:	183ffb1e 	bne	r3,zero,81130c70 <__reset+0xfb110c70>
81130c84:	38000126 	beq	r7,zero,81130c8c <__modsi3+0x54>
81130c88:	0085c83a 	sub	r2,zero,r2
81130c8c:	f800283a 	ret
81130c90:	014bc83a 	sub	r5,zero,r5
81130c94:	003fec06 	br	81130c48 <__reset+0xfb110c48>
81130c98:	0109c83a 	sub	r4,zero,r4
81130c9c:	01c00044 	movi	r7,1
81130ca0:	003fe706 	br	81130c40 <__reset+0xfb110c40>
81130ca4:	00c00044 	movi	r3,1
81130ca8:	003ff106 	br	81130c70 <__reset+0xfb110c70>

81130cac <__udivsi3>:
81130cac:	200d883a 	mov	r6,r4
81130cb0:	2900152e 	bgeu	r5,r4,81130d08 <__udivsi3+0x5c>
81130cb4:	28001416 	blt	r5,zero,81130d08 <__udivsi3+0x5c>
81130cb8:	00800804 	movi	r2,32
81130cbc:	00c00044 	movi	r3,1
81130cc0:	00000206 	br	81130ccc <__udivsi3+0x20>
81130cc4:	10000e26 	beq	r2,zero,81130d00 <__udivsi3+0x54>
81130cc8:	28000516 	blt	r5,zero,81130ce0 <__udivsi3+0x34>
81130ccc:	294b883a 	add	r5,r5,r5
81130cd0:	10bfffc4 	addi	r2,r2,-1
81130cd4:	18c7883a 	add	r3,r3,r3
81130cd8:	293ffa36 	bltu	r5,r4,81130cc4 <__reset+0xfb110cc4>
81130cdc:	18000826 	beq	r3,zero,81130d00 <__udivsi3+0x54>
81130ce0:	0005883a 	mov	r2,zero
81130ce4:	31400236 	bltu	r6,r5,81130cf0 <__udivsi3+0x44>
81130ce8:	314dc83a 	sub	r6,r6,r5
81130cec:	10c4b03a 	or	r2,r2,r3
81130cf0:	1806d07a 	srli	r3,r3,1
81130cf4:	280ad07a 	srli	r5,r5,1
81130cf8:	183ffa1e 	bne	r3,zero,81130ce4 <__reset+0xfb110ce4>
81130cfc:	f800283a 	ret
81130d00:	0005883a 	mov	r2,zero
81130d04:	f800283a 	ret
81130d08:	00c00044 	movi	r3,1
81130d0c:	003ff406 	br	81130ce0 <__reset+0xfb110ce0>

81130d10 <__umodsi3>:
81130d10:	2005883a 	mov	r2,r4
81130d14:	2900122e 	bgeu	r5,r4,81130d60 <__umodsi3+0x50>
81130d18:	28001116 	blt	r5,zero,81130d60 <__umodsi3+0x50>
81130d1c:	01800804 	movi	r6,32
81130d20:	00c00044 	movi	r3,1
81130d24:	00000206 	br	81130d30 <__umodsi3+0x20>
81130d28:	30000c26 	beq	r6,zero,81130d5c <__umodsi3+0x4c>
81130d2c:	28000516 	blt	r5,zero,81130d44 <__umodsi3+0x34>
81130d30:	294b883a 	add	r5,r5,r5
81130d34:	31bfffc4 	addi	r6,r6,-1
81130d38:	18c7883a 	add	r3,r3,r3
81130d3c:	293ffa36 	bltu	r5,r4,81130d28 <__reset+0xfb110d28>
81130d40:	18000626 	beq	r3,zero,81130d5c <__umodsi3+0x4c>
81130d44:	1806d07a 	srli	r3,r3,1
81130d48:	11400136 	bltu	r2,r5,81130d50 <__umodsi3+0x40>
81130d4c:	1145c83a 	sub	r2,r2,r5
81130d50:	280ad07a 	srli	r5,r5,1
81130d54:	183ffb1e 	bne	r3,zero,81130d44 <__reset+0xfb110d44>
81130d58:	f800283a 	ret
81130d5c:	f800283a 	ret
81130d60:	00c00044 	movi	r3,1
81130d64:	003ff706 	br	81130d44 <__reset+0xfb110d44>

81130d68 <__eqsf2>:
81130d68:	2006d5fa 	srli	r3,r4,23
81130d6c:	280cd5fa 	srli	r6,r5,23
81130d70:	01c02034 	movhi	r7,128
81130d74:	39ffffc4 	addi	r7,r7,-1
81130d78:	18c03fcc 	andi	r3,r3,255
81130d7c:	02003fc4 	movi	r8,255
81130d80:	3904703a 	and	r2,r7,r4
81130d84:	31803fcc 	andi	r6,r6,255
81130d88:	394e703a 	and	r7,r7,r5
81130d8c:	2008d7fa 	srli	r4,r4,31
81130d90:	280ad7fa 	srli	r5,r5,31
81130d94:	1a000d26 	beq	r3,r8,81130dcc <__eqsf2+0x64>
81130d98:	02003fc4 	movi	r8,255
81130d9c:	32000826 	beq	r6,r8,81130dc0 <__eqsf2+0x58>
81130da0:	19800226 	beq	r3,r6,81130dac <__eqsf2+0x44>
81130da4:	00800044 	movi	r2,1
81130da8:	f800283a 	ret
81130dac:	11fffd1e 	bne	r2,r7,81130da4 <__reset+0xfb110da4>
81130db0:	21400926 	beq	r4,r5,81130dd8 <__eqsf2+0x70>
81130db4:	183ffb1e 	bne	r3,zero,81130da4 <__reset+0xfb110da4>
81130db8:	1004c03a 	cmpne	r2,r2,zero
81130dbc:	f800283a 	ret
81130dc0:	383ff726 	beq	r7,zero,81130da0 <__reset+0xfb110da0>
81130dc4:	00800044 	movi	r2,1
81130dc8:	f800283a 	ret
81130dcc:	103ff226 	beq	r2,zero,81130d98 <__reset+0xfb110d98>
81130dd0:	00800044 	movi	r2,1
81130dd4:	f800283a 	ret
81130dd8:	0005883a 	mov	r2,zero
81130ddc:	f800283a 	ret

81130de0 <__gesf2>:
81130de0:	2004d5fa 	srli	r2,r4,23
81130de4:	2806d5fa 	srli	r3,r5,23
81130de8:	01802034 	movhi	r6,128
81130dec:	31bfffc4 	addi	r6,r6,-1
81130df0:	10803fcc 	andi	r2,r2,255
81130df4:	01c03fc4 	movi	r7,255
81130df8:	3110703a 	and	r8,r6,r4
81130dfc:	18c03fcc 	andi	r3,r3,255
81130e00:	314c703a 	and	r6,r6,r5
81130e04:	2008d7fa 	srli	r4,r4,31
81130e08:	280ad7fa 	srli	r5,r5,31
81130e0c:	11c01926 	beq	r2,r7,81130e74 <__gesf2+0x94>
81130e10:	01c03fc4 	movi	r7,255
81130e14:	19c00f26 	beq	r3,r7,81130e54 <__gesf2+0x74>
81130e18:	1000061e 	bne	r2,zero,81130e34 <__gesf2+0x54>
81130e1c:	400f003a 	cmpeq	r7,r8,zero
81130e20:	1800071e 	bne	r3,zero,81130e40 <__gesf2+0x60>
81130e24:	3000061e 	bne	r6,zero,81130e40 <__gesf2+0x60>
81130e28:	0005883a 	mov	r2,zero
81130e2c:	40000e1e 	bne	r8,zero,81130e68 <__gesf2+0x88>
81130e30:	f800283a 	ret
81130e34:	18000a1e 	bne	r3,zero,81130e60 <__gesf2+0x80>
81130e38:	30000b26 	beq	r6,zero,81130e68 <__gesf2+0x88>
81130e3c:	000f883a 	mov	r7,zero
81130e40:	29403fcc 	andi	r5,r5,255
81130e44:	38000726 	beq	r7,zero,81130e64 <__gesf2+0x84>
81130e48:	28000826 	beq	r5,zero,81130e6c <__gesf2+0x8c>
81130e4c:	00800044 	movi	r2,1
81130e50:	f800283a 	ret
81130e54:	303ff026 	beq	r6,zero,81130e18 <__reset+0xfb110e18>
81130e58:	00bfff84 	movi	r2,-2
81130e5c:	f800283a 	ret
81130e60:	29403fcc 	andi	r5,r5,255
81130e64:	21400526 	beq	r4,r5,81130e7c <__gesf2+0x9c>
81130e68:	203ff826 	beq	r4,zero,81130e4c <__reset+0xfb110e4c>
81130e6c:	00bfffc4 	movi	r2,-1
81130e70:	f800283a 	ret
81130e74:	403fe626 	beq	r8,zero,81130e10 <__reset+0xfb110e10>
81130e78:	003ff706 	br	81130e58 <__reset+0xfb110e58>
81130e7c:	18bffa16 	blt	r3,r2,81130e68 <__reset+0xfb110e68>
81130e80:	10c00216 	blt	r2,r3,81130e8c <__gesf2+0xac>
81130e84:	323ff836 	bltu	r6,r8,81130e68 <__reset+0xfb110e68>
81130e88:	4180022e 	bgeu	r8,r6,81130e94 <__gesf2+0xb4>
81130e8c:	203fef1e 	bne	r4,zero,81130e4c <__reset+0xfb110e4c>
81130e90:	003ff606 	br	81130e6c <__reset+0xfb110e6c>
81130e94:	0005883a 	mov	r2,zero
81130e98:	f800283a 	ret

81130e9c <__lesf2>:
81130e9c:	2004d5fa 	srli	r2,r4,23
81130ea0:	280cd5fa 	srli	r6,r5,23
81130ea4:	00c02034 	movhi	r3,128
81130ea8:	18ffffc4 	addi	r3,r3,-1
81130eac:	10803fcc 	andi	r2,r2,255
81130eb0:	01c03fc4 	movi	r7,255
81130eb4:	1910703a 	and	r8,r3,r4
81130eb8:	31803fcc 	andi	r6,r6,255
81130ebc:	1946703a 	and	r3,r3,r5
81130ec0:	2008d7fa 	srli	r4,r4,31
81130ec4:	280ad7fa 	srli	r5,r5,31
81130ec8:	11c01b26 	beq	r2,r7,81130f38 <__lesf2+0x9c>
81130ecc:	01c03fc4 	movi	r7,255
81130ed0:	31c01126 	beq	r6,r7,81130f18 <__lesf2+0x7c>
81130ed4:	1000071e 	bne	r2,zero,81130ef4 <__lesf2+0x58>
81130ed8:	400f003a 	cmpeq	r7,r8,zero
81130edc:	21003fcc 	andi	r4,r4,255
81130ee0:	3000081e 	bne	r6,zero,81130f04 <__lesf2+0x68>
81130ee4:	1800071e 	bne	r3,zero,81130f04 <__lesf2+0x68>
81130ee8:	0005883a 	mov	r2,zero
81130eec:	40000f1e 	bne	r8,zero,81130f2c <__lesf2+0x90>
81130ef0:	f800283a 	ret
81130ef4:	21003fcc 	andi	r4,r4,255
81130ef8:	30000a1e 	bne	r6,zero,81130f24 <__lesf2+0x88>
81130efc:	18000b26 	beq	r3,zero,81130f2c <__lesf2+0x90>
81130f00:	000f883a 	mov	r7,zero
81130f04:	29403fcc 	andi	r5,r5,255
81130f08:	38000726 	beq	r7,zero,81130f28 <__lesf2+0x8c>
81130f0c:	28000826 	beq	r5,zero,81130f30 <__lesf2+0x94>
81130f10:	00800044 	movi	r2,1
81130f14:	f800283a 	ret
81130f18:	183fee26 	beq	r3,zero,81130ed4 <__reset+0xfb110ed4>
81130f1c:	00800084 	movi	r2,2
81130f20:	f800283a 	ret
81130f24:	29403fcc 	andi	r5,r5,255
81130f28:	21400626 	beq	r4,r5,81130f44 <__lesf2+0xa8>
81130f2c:	203ff826 	beq	r4,zero,81130f10 <__reset+0xfb110f10>
81130f30:	00bfffc4 	movi	r2,-1
81130f34:	f800283a 	ret
81130f38:	403fe426 	beq	r8,zero,81130ecc <__reset+0xfb110ecc>
81130f3c:	00800084 	movi	r2,2
81130f40:	f800283a 	ret
81130f44:	30bff916 	blt	r6,r2,81130f2c <__reset+0xfb110f2c>
81130f48:	11800216 	blt	r2,r6,81130f54 <__lesf2+0xb8>
81130f4c:	1a3ff736 	bltu	r3,r8,81130f2c <__reset+0xfb110f2c>
81130f50:	40c0022e 	bgeu	r8,r3,81130f5c <__lesf2+0xc0>
81130f54:	203fee1e 	bne	r4,zero,81130f10 <__reset+0xfb110f10>
81130f58:	003ff506 	br	81130f30 <__reset+0xfb110f30>
81130f5c:	0005883a 	mov	r2,zero
81130f60:	f800283a 	ret

81130f64 <__adddf3>:
81130f64:	02c00434 	movhi	r11,16
81130f68:	5affffc4 	addi	r11,r11,-1
81130f6c:	2806d7fa 	srli	r3,r5,31
81130f70:	2ad4703a 	and	r10,r5,r11
81130f74:	3ad2703a 	and	r9,r7,r11
81130f78:	3804d53a 	srli	r2,r7,20
81130f7c:	3018d77a 	srli	r12,r6,29
81130f80:	280ad53a 	srli	r5,r5,20
81130f84:	501490fa 	slli	r10,r10,3
81130f88:	2010d77a 	srli	r8,r4,29
81130f8c:	481290fa 	slli	r9,r9,3
81130f90:	380ed7fa 	srli	r7,r7,31
81130f94:	defffb04 	addi	sp,sp,-20
81130f98:	de00012e 	bgeu	sp,et,81130fa0 <__adddf3+0x3c>
81130f9c:	003b68fa 	trap	3
81130fa0:	dc800215 	stw	r18,8(sp)
81130fa4:	dc400115 	stw	r17,4(sp)
81130fa8:	dc000015 	stw	r16,0(sp)
81130fac:	dfc00415 	stw	ra,16(sp)
81130fb0:	dcc00315 	stw	r19,12(sp)
81130fb4:	1c803fcc 	andi	r18,r3,255
81130fb8:	2c01ffcc 	andi	r16,r5,2047
81130fbc:	5210b03a 	or	r8,r10,r8
81130fc0:	202290fa 	slli	r17,r4,3
81130fc4:	1081ffcc 	andi	r2,r2,2047
81130fc8:	4b12b03a 	or	r9,r9,r12
81130fcc:	300c90fa 	slli	r6,r6,3
81130fd0:	91c07526 	beq	r18,r7,811311a8 <__adddf3+0x244>
81130fd4:	8087c83a 	sub	r3,r16,r2
81130fd8:	00c0ab0e 	bge	zero,r3,81131288 <__adddf3+0x324>
81130fdc:	10002a1e 	bne	r2,zero,81131088 <__adddf3+0x124>
81130fe0:	4984b03a 	or	r2,r9,r6
81130fe4:	1000961e 	bne	r2,zero,81131240 <__adddf3+0x2dc>
81130fe8:	888001cc 	andi	r2,r17,7
81130fec:	10000726 	beq	r2,zero,8113100c <__adddf3+0xa8>
81130ff0:	888003cc 	andi	r2,r17,15
81130ff4:	00c00104 	movi	r3,4
81130ff8:	10c00426 	beq	r2,r3,8113100c <__adddf3+0xa8>
81130ffc:	88c7883a 	add	r3,r17,r3
81131000:	1c63803a 	cmpltu	r17,r3,r17
81131004:	4451883a 	add	r8,r8,r17
81131008:	1823883a 	mov	r17,r3
8113100c:	4080202c 	andhi	r2,r8,128
81131010:	10005926 	beq	r2,zero,81131178 <__adddf3+0x214>
81131014:	84000044 	addi	r16,r16,1
81131018:	0081ffc4 	movi	r2,2047
8113101c:	8080ba26 	beq	r16,r2,81131308 <__adddf3+0x3a4>
81131020:	00bfe034 	movhi	r2,65408
81131024:	10bfffc4 	addi	r2,r2,-1
81131028:	4090703a 	and	r8,r8,r2
8113102c:	4004977a 	slli	r2,r8,29
81131030:	4010927a 	slli	r8,r8,9
81131034:	8822d0fa 	srli	r17,r17,3
81131038:	8401ffcc 	andi	r16,r16,2047
8113103c:	4010d33a 	srli	r8,r8,12
81131040:	9007883a 	mov	r3,r18
81131044:	1444b03a 	or	r2,r2,r17
81131048:	8401ffcc 	andi	r16,r16,2047
8113104c:	8020953a 	slli	r16,r16,20
81131050:	18c03fcc 	andi	r3,r3,255
81131054:	01000434 	movhi	r4,16
81131058:	213fffc4 	addi	r4,r4,-1
8113105c:	180697fa 	slli	r3,r3,31
81131060:	4110703a 	and	r8,r8,r4
81131064:	4410b03a 	or	r8,r8,r16
81131068:	40c6b03a 	or	r3,r8,r3
8113106c:	dfc00417 	ldw	ra,16(sp)
81131070:	dcc00317 	ldw	r19,12(sp)
81131074:	dc800217 	ldw	r18,8(sp)
81131078:	dc400117 	ldw	r17,4(sp)
8113107c:	dc000017 	ldw	r16,0(sp)
81131080:	dec00504 	addi	sp,sp,20
81131084:	f800283a 	ret
81131088:	0081ffc4 	movi	r2,2047
8113108c:	80bfd626 	beq	r16,r2,81130fe8 <__reset+0xfb110fe8>
81131090:	4a402034 	orhi	r9,r9,128
81131094:	00800e04 	movi	r2,56
81131098:	10c09f16 	blt	r2,r3,81131318 <__adddf3+0x3b4>
8113109c:	008007c4 	movi	r2,31
811310a0:	10c0c216 	blt	r2,r3,811313ac <__adddf3+0x448>
811310a4:	00800804 	movi	r2,32
811310a8:	10c5c83a 	sub	r2,r2,r3
811310ac:	488a983a 	sll	r5,r9,r2
811310b0:	30c8d83a 	srl	r4,r6,r3
811310b4:	3084983a 	sll	r2,r6,r2
811310b8:	48c6d83a 	srl	r3,r9,r3
811310bc:	290cb03a 	or	r6,r5,r4
811310c0:	1004c03a 	cmpne	r2,r2,zero
811310c4:	308cb03a 	or	r6,r6,r2
811310c8:	898dc83a 	sub	r6,r17,r6
811310cc:	89a3803a 	cmpltu	r17,r17,r6
811310d0:	40d1c83a 	sub	r8,r8,r3
811310d4:	4451c83a 	sub	r8,r8,r17
811310d8:	3023883a 	mov	r17,r6
811310dc:	4080202c 	andhi	r2,r8,128
811310e0:	10002326 	beq	r2,zero,81131170 <__adddf3+0x20c>
811310e4:	04c02034 	movhi	r19,128
811310e8:	9cffffc4 	addi	r19,r19,-1
811310ec:	44e6703a 	and	r19,r8,r19
811310f0:	98007626 	beq	r19,zero,811312cc <__adddf3+0x368>
811310f4:	9809883a 	mov	r4,r19
811310f8:	111d4540 	call	8111d454 <__clzsi2>
811310fc:	10fffe04 	addi	r3,r2,-8
81131100:	010007c4 	movi	r4,31
81131104:	20c07716 	blt	r4,r3,811312e4 <__adddf3+0x380>
81131108:	00800804 	movi	r2,32
8113110c:	10c5c83a 	sub	r2,r2,r3
81131110:	8884d83a 	srl	r2,r17,r2
81131114:	98d0983a 	sll	r8,r19,r3
81131118:	88e2983a 	sll	r17,r17,r3
8113111c:	1204b03a 	or	r2,r2,r8
81131120:	1c007416 	blt	r3,r16,811312f4 <__adddf3+0x390>
81131124:	1c21c83a 	sub	r16,r3,r16
81131128:	82000044 	addi	r8,r16,1
8113112c:	00c007c4 	movi	r3,31
81131130:	1a009116 	blt	r3,r8,81131378 <__adddf3+0x414>
81131134:	00c00804 	movi	r3,32
81131138:	1a07c83a 	sub	r3,r3,r8
8113113c:	8a08d83a 	srl	r4,r17,r8
81131140:	88e2983a 	sll	r17,r17,r3
81131144:	10c6983a 	sll	r3,r2,r3
81131148:	1210d83a 	srl	r8,r2,r8
8113114c:	8804c03a 	cmpne	r2,r17,zero
81131150:	1906b03a 	or	r3,r3,r4
81131154:	18a2b03a 	or	r17,r3,r2
81131158:	0021883a 	mov	r16,zero
8113115c:	003fa206 	br	81130fe8 <__reset+0xfb110fe8>
81131160:	1890b03a 	or	r8,r3,r2
81131164:	40017d26 	beq	r8,zero,8113175c <__adddf3+0x7f8>
81131168:	1011883a 	mov	r8,r2
8113116c:	1823883a 	mov	r17,r3
81131170:	888001cc 	andi	r2,r17,7
81131174:	103f9e1e 	bne	r2,zero,81130ff0 <__reset+0xfb110ff0>
81131178:	4004977a 	slli	r2,r8,29
8113117c:	8822d0fa 	srli	r17,r17,3
81131180:	4010d0fa 	srli	r8,r8,3
81131184:	9007883a 	mov	r3,r18
81131188:	1444b03a 	or	r2,r2,r17
8113118c:	0101ffc4 	movi	r4,2047
81131190:	81002426 	beq	r16,r4,81131224 <__adddf3+0x2c0>
81131194:	8120703a 	and	r16,r16,r4
81131198:	01000434 	movhi	r4,16
8113119c:	213fffc4 	addi	r4,r4,-1
811311a0:	4110703a 	and	r8,r8,r4
811311a4:	003fa806 	br	81131048 <__reset+0xfb111048>
811311a8:	8089c83a 	sub	r4,r16,r2
811311ac:	01005e0e 	bge	zero,r4,81131328 <__adddf3+0x3c4>
811311b0:	10002b26 	beq	r2,zero,81131260 <__adddf3+0x2fc>
811311b4:	0081ffc4 	movi	r2,2047
811311b8:	80bf8b26 	beq	r16,r2,81130fe8 <__reset+0xfb110fe8>
811311bc:	4a402034 	orhi	r9,r9,128
811311c0:	00800e04 	movi	r2,56
811311c4:	1100a40e 	bge	r2,r4,81131458 <__adddf3+0x4f4>
811311c8:	498cb03a 	or	r6,r9,r6
811311cc:	300ac03a 	cmpne	r5,r6,zero
811311d0:	0013883a 	mov	r9,zero
811311d4:	2c4b883a 	add	r5,r5,r17
811311d8:	2c63803a 	cmpltu	r17,r5,r17
811311dc:	4a11883a 	add	r8,r9,r8
811311e0:	8a11883a 	add	r8,r17,r8
811311e4:	2823883a 	mov	r17,r5
811311e8:	4080202c 	andhi	r2,r8,128
811311ec:	103fe026 	beq	r2,zero,81131170 <__reset+0xfb111170>
811311f0:	84000044 	addi	r16,r16,1
811311f4:	0081ffc4 	movi	r2,2047
811311f8:	8080d226 	beq	r16,r2,81131544 <__adddf3+0x5e0>
811311fc:	00bfe034 	movhi	r2,65408
81131200:	10bfffc4 	addi	r2,r2,-1
81131204:	4090703a 	and	r8,r8,r2
81131208:	880ad07a 	srli	r5,r17,1
8113120c:	400897fa 	slli	r4,r8,31
81131210:	88c0004c 	andi	r3,r17,1
81131214:	28e2b03a 	or	r17,r5,r3
81131218:	4010d07a 	srli	r8,r8,1
8113121c:	2462b03a 	or	r17,r4,r17
81131220:	003f7106 	br	81130fe8 <__reset+0xfb110fe8>
81131224:	4088b03a 	or	r4,r8,r2
81131228:	20014526 	beq	r4,zero,81131740 <__adddf3+0x7dc>
8113122c:	01000434 	movhi	r4,16
81131230:	42000234 	orhi	r8,r8,8
81131234:	213fffc4 	addi	r4,r4,-1
81131238:	4110703a 	and	r8,r8,r4
8113123c:	003f8206 	br	81131048 <__reset+0xfb111048>
81131240:	18ffffc4 	addi	r3,r3,-1
81131244:	1800491e 	bne	r3,zero,8113136c <__adddf3+0x408>
81131248:	898bc83a 	sub	r5,r17,r6
8113124c:	8963803a 	cmpltu	r17,r17,r5
81131250:	4251c83a 	sub	r8,r8,r9
81131254:	4451c83a 	sub	r8,r8,r17
81131258:	2823883a 	mov	r17,r5
8113125c:	003f9f06 	br	811310dc <__reset+0xfb1110dc>
81131260:	4984b03a 	or	r2,r9,r6
81131264:	103f6026 	beq	r2,zero,81130fe8 <__reset+0xfb110fe8>
81131268:	213fffc4 	addi	r4,r4,-1
8113126c:	2000931e 	bne	r4,zero,811314bc <__adddf3+0x558>
81131270:	898d883a 	add	r6,r17,r6
81131274:	3463803a 	cmpltu	r17,r6,r17
81131278:	4251883a 	add	r8,r8,r9
8113127c:	8a11883a 	add	r8,r17,r8
81131280:	3023883a 	mov	r17,r6
81131284:	003fd806 	br	811311e8 <__reset+0xfb1111e8>
81131288:	1800541e 	bne	r3,zero,811313dc <__adddf3+0x478>
8113128c:	80800044 	addi	r2,r16,1
81131290:	1081ffcc 	andi	r2,r2,2047
81131294:	00c00044 	movi	r3,1
81131298:	1880a00e 	bge	r3,r2,8113151c <__adddf3+0x5b8>
8113129c:	8989c83a 	sub	r4,r17,r6
811312a0:	8905803a 	cmpltu	r2,r17,r4
811312a4:	4267c83a 	sub	r19,r8,r9
811312a8:	98a7c83a 	sub	r19,r19,r2
811312ac:	9880202c 	andhi	r2,r19,128
811312b0:	10006326 	beq	r2,zero,81131440 <__adddf3+0x4dc>
811312b4:	3463c83a 	sub	r17,r6,r17
811312b8:	4a07c83a 	sub	r3,r9,r8
811312bc:	344d803a 	cmpltu	r6,r6,r17
811312c0:	19a7c83a 	sub	r19,r3,r6
811312c4:	3825883a 	mov	r18,r7
811312c8:	983f8a1e 	bne	r19,zero,811310f4 <__reset+0xfb1110f4>
811312cc:	8809883a 	mov	r4,r17
811312d0:	111d4540 	call	8111d454 <__clzsi2>
811312d4:	10800804 	addi	r2,r2,32
811312d8:	10fffe04 	addi	r3,r2,-8
811312dc:	010007c4 	movi	r4,31
811312e0:	20ff890e 	bge	r4,r3,81131108 <__reset+0xfb111108>
811312e4:	10bff604 	addi	r2,r2,-40
811312e8:	8884983a 	sll	r2,r17,r2
811312ec:	0023883a 	mov	r17,zero
811312f0:	1c3f8c0e 	bge	r3,r16,81131124 <__reset+0xfb111124>
811312f4:	023fe034 	movhi	r8,65408
811312f8:	423fffc4 	addi	r8,r8,-1
811312fc:	80e1c83a 	sub	r16,r16,r3
81131300:	1210703a 	and	r8,r2,r8
81131304:	003f3806 	br	81130fe8 <__reset+0xfb110fe8>
81131308:	9007883a 	mov	r3,r18
8113130c:	0011883a 	mov	r8,zero
81131310:	0005883a 	mov	r2,zero
81131314:	003f4c06 	br	81131048 <__reset+0xfb111048>
81131318:	498cb03a 	or	r6,r9,r6
8113131c:	300cc03a 	cmpne	r6,r6,zero
81131320:	0007883a 	mov	r3,zero
81131324:	003f6806 	br	811310c8 <__reset+0xfb1110c8>
81131328:	20009c1e 	bne	r4,zero,8113159c <__adddf3+0x638>
8113132c:	80800044 	addi	r2,r16,1
81131330:	1141ffcc 	andi	r5,r2,2047
81131334:	01000044 	movi	r4,1
81131338:	2140670e 	bge	r4,r5,811314d8 <__adddf3+0x574>
8113133c:	0101ffc4 	movi	r4,2047
81131340:	11007f26 	beq	r2,r4,81131540 <__adddf3+0x5dc>
81131344:	898d883a 	add	r6,r17,r6
81131348:	4247883a 	add	r3,r8,r9
8113134c:	3451803a 	cmpltu	r8,r6,r17
81131350:	40d1883a 	add	r8,r8,r3
81131354:	402297fa 	slli	r17,r8,31
81131358:	300cd07a 	srli	r6,r6,1
8113135c:	4010d07a 	srli	r8,r8,1
81131360:	1021883a 	mov	r16,r2
81131364:	89a2b03a 	or	r17,r17,r6
81131368:	003f1f06 	br	81130fe8 <__reset+0xfb110fe8>
8113136c:	0081ffc4 	movi	r2,2047
81131370:	80bf481e 	bne	r16,r2,81131094 <__reset+0xfb111094>
81131374:	003f1c06 	br	81130fe8 <__reset+0xfb110fe8>
81131378:	843ff844 	addi	r16,r16,-31
8113137c:	01000804 	movi	r4,32
81131380:	1406d83a 	srl	r3,r2,r16
81131384:	41005026 	beq	r8,r4,811314c8 <__adddf3+0x564>
81131388:	01001004 	movi	r4,64
8113138c:	2211c83a 	sub	r8,r4,r8
81131390:	1204983a 	sll	r2,r2,r8
81131394:	88a2b03a 	or	r17,r17,r2
81131398:	8822c03a 	cmpne	r17,r17,zero
8113139c:	1c62b03a 	or	r17,r3,r17
811313a0:	0011883a 	mov	r8,zero
811313a4:	0021883a 	mov	r16,zero
811313a8:	003f7106 	br	81131170 <__reset+0xfb111170>
811313ac:	193ff804 	addi	r4,r3,-32
811313b0:	00800804 	movi	r2,32
811313b4:	4908d83a 	srl	r4,r9,r4
811313b8:	18804526 	beq	r3,r2,811314d0 <__adddf3+0x56c>
811313bc:	00801004 	movi	r2,64
811313c0:	10c5c83a 	sub	r2,r2,r3
811313c4:	4886983a 	sll	r3,r9,r2
811313c8:	198cb03a 	or	r6,r3,r6
811313cc:	300cc03a 	cmpne	r6,r6,zero
811313d0:	218cb03a 	or	r6,r4,r6
811313d4:	0007883a 	mov	r3,zero
811313d8:	003f3b06 	br	811310c8 <__reset+0xfb1110c8>
811313dc:	80002a26 	beq	r16,zero,81131488 <__adddf3+0x524>
811313e0:	0101ffc4 	movi	r4,2047
811313e4:	11006826 	beq	r2,r4,81131588 <__adddf3+0x624>
811313e8:	00c7c83a 	sub	r3,zero,r3
811313ec:	42002034 	orhi	r8,r8,128
811313f0:	01000e04 	movi	r4,56
811313f4:	20c07c16 	blt	r4,r3,811315e8 <__adddf3+0x684>
811313f8:	010007c4 	movi	r4,31
811313fc:	20c0da16 	blt	r4,r3,81131768 <__adddf3+0x804>
81131400:	01000804 	movi	r4,32
81131404:	20c9c83a 	sub	r4,r4,r3
81131408:	4114983a 	sll	r10,r8,r4
8113140c:	88cad83a 	srl	r5,r17,r3
81131410:	8908983a 	sll	r4,r17,r4
81131414:	40c6d83a 	srl	r3,r8,r3
81131418:	5162b03a 	or	r17,r10,r5
8113141c:	2008c03a 	cmpne	r4,r4,zero
81131420:	8922b03a 	or	r17,r17,r4
81131424:	3463c83a 	sub	r17,r6,r17
81131428:	48c7c83a 	sub	r3,r9,r3
8113142c:	344d803a 	cmpltu	r6,r6,r17
81131430:	1991c83a 	sub	r8,r3,r6
81131434:	1021883a 	mov	r16,r2
81131438:	3825883a 	mov	r18,r7
8113143c:	003f2706 	br	811310dc <__reset+0xfb1110dc>
81131440:	24d0b03a 	or	r8,r4,r19
81131444:	40001b1e 	bne	r8,zero,811314b4 <__adddf3+0x550>
81131448:	0005883a 	mov	r2,zero
8113144c:	0007883a 	mov	r3,zero
81131450:	0021883a 	mov	r16,zero
81131454:	003f4d06 	br	8113118c <__reset+0xfb11118c>
81131458:	008007c4 	movi	r2,31
8113145c:	11003c16 	blt	r2,r4,81131550 <__adddf3+0x5ec>
81131460:	00800804 	movi	r2,32
81131464:	1105c83a 	sub	r2,r2,r4
81131468:	488e983a 	sll	r7,r9,r2
8113146c:	310ad83a 	srl	r5,r6,r4
81131470:	3084983a 	sll	r2,r6,r2
81131474:	4912d83a 	srl	r9,r9,r4
81131478:	394ab03a 	or	r5,r7,r5
8113147c:	1004c03a 	cmpne	r2,r2,zero
81131480:	288ab03a 	or	r5,r5,r2
81131484:	003f5306 	br	811311d4 <__reset+0xfb1111d4>
81131488:	4448b03a 	or	r4,r8,r17
8113148c:	20003e26 	beq	r4,zero,81131588 <__adddf3+0x624>
81131490:	00c6303a 	nor	r3,zero,r3
81131494:	18003a1e 	bne	r3,zero,81131580 <__adddf3+0x61c>
81131498:	3463c83a 	sub	r17,r6,r17
8113149c:	4a07c83a 	sub	r3,r9,r8
811314a0:	344d803a 	cmpltu	r6,r6,r17
811314a4:	1991c83a 	sub	r8,r3,r6
811314a8:	1021883a 	mov	r16,r2
811314ac:	3825883a 	mov	r18,r7
811314b0:	003f0a06 	br	811310dc <__reset+0xfb1110dc>
811314b4:	2023883a 	mov	r17,r4
811314b8:	003f0d06 	br	811310f0 <__reset+0xfb1110f0>
811314bc:	0081ffc4 	movi	r2,2047
811314c0:	80bf3f1e 	bne	r16,r2,811311c0 <__reset+0xfb1111c0>
811314c4:	003ec806 	br	81130fe8 <__reset+0xfb110fe8>
811314c8:	0005883a 	mov	r2,zero
811314cc:	003fb106 	br	81131394 <__reset+0xfb111394>
811314d0:	0007883a 	mov	r3,zero
811314d4:	003fbc06 	br	811313c8 <__reset+0xfb1113c8>
811314d8:	4444b03a 	or	r2,r8,r17
811314dc:	8000871e 	bne	r16,zero,811316fc <__adddf3+0x798>
811314e0:	1000ba26 	beq	r2,zero,811317cc <__adddf3+0x868>
811314e4:	4984b03a 	or	r2,r9,r6
811314e8:	103ebf26 	beq	r2,zero,81130fe8 <__reset+0xfb110fe8>
811314ec:	8985883a 	add	r2,r17,r6
811314f0:	4247883a 	add	r3,r8,r9
811314f4:	1451803a 	cmpltu	r8,r2,r17
811314f8:	40d1883a 	add	r8,r8,r3
811314fc:	40c0202c 	andhi	r3,r8,128
81131500:	1023883a 	mov	r17,r2
81131504:	183f1a26 	beq	r3,zero,81131170 <__reset+0xfb111170>
81131508:	00bfe034 	movhi	r2,65408
8113150c:	10bfffc4 	addi	r2,r2,-1
81131510:	2021883a 	mov	r16,r4
81131514:	4090703a 	and	r8,r8,r2
81131518:	003eb306 	br	81130fe8 <__reset+0xfb110fe8>
8113151c:	4444b03a 	or	r2,r8,r17
81131520:	8000291e 	bne	r16,zero,811315c8 <__adddf3+0x664>
81131524:	10004b1e 	bne	r2,zero,81131654 <__adddf3+0x6f0>
81131528:	4990b03a 	or	r8,r9,r6
8113152c:	40008b26 	beq	r8,zero,8113175c <__adddf3+0x7f8>
81131530:	4811883a 	mov	r8,r9
81131534:	3023883a 	mov	r17,r6
81131538:	3825883a 	mov	r18,r7
8113153c:	003eaa06 	br	81130fe8 <__reset+0xfb110fe8>
81131540:	1021883a 	mov	r16,r2
81131544:	0011883a 	mov	r8,zero
81131548:	0005883a 	mov	r2,zero
8113154c:	003f0f06 	br	8113118c <__reset+0xfb11118c>
81131550:	217ff804 	addi	r5,r4,-32
81131554:	00800804 	movi	r2,32
81131558:	494ad83a 	srl	r5,r9,r5
8113155c:	20807d26 	beq	r4,r2,81131754 <__adddf3+0x7f0>
81131560:	00801004 	movi	r2,64
81131564:	1109c83a 	sub	r4,r2,r4
81131568:	4912983a 	sll	r9,r9,r4
8113156c:	498cb03a 	or	r6,r9,r6
81131570:	300cc03a 	cmpne	r6,r6,zero
81131574:	298ab03a 	or	r5,r5,r6
81131578:	0013883a 	mov	r9,zero
8113157c:	003f1506 	br	811311d4 <__reset+0xfb1111d4>
81131580:	0101ffc4 	movi	r4,2047
81131584:	113f9a1e 	bne	r2,r4,811313f0 <__reset+0xfb1113f0>
81131588:	4811883a 	mov	r8,r9
8113158c:	3023883a 	mov	r17,r6
81131590:	1021883a 	mov	r16,r2
81131594:	3825883a 	mov	r18,r7
81131598:	003e9306 	br	81130fe8 <__reset+0xfb110fe8>
8113159c:	8000161e 	bne	r16,zero,811315f8 <__adddf3+0x694>
811315a0:	444ab03a 	or	r5,r8,r17
811315a4:	28005126 	beq	r5,zero,811316ec <__adddf3+0x788>
811315a8:	0108303a 	nor	r4,zero,r4
811315ac:	20004d1e 	bne	r4,zero,811316e4 <__adddf3+0x780>
811315b0:	89a3883a 	add	r17,r17,r6
811315b4:	4253883a 	add	r9,r8,r9
811315b8:	898d803a 	cmpltu	r6,r17,r6
811315bc:	3251883a 	add	r8,r6,r9
811315c0:	1021883a 	mov	r16,r2
811315c4:	003f0806 	br	811311e8 <__reset+0xfb1111e8>
811315c8:	1000301e 	bne	r2,zero,8113168c <__adddf3+0x728>
811315cc:	4984b03a 	or	r2,r9,r6
811315d0:	10007126 	beq	r2,zero,81131798 <__adddf3+0x834>
811315d4:	4811883a 	mov	r8,r9
811315d8:	3023883a 	mov	r17,r6
811315dc:	3825883a 	mov	r18,r7
811315e0:	0401ffc4 	movi	r16,2047
811315e4:	003e8006 	br	81130fe8 <__reset+0xfb110fe8>
811315e8:	4462b03a 	or	r17,r8,r17
811315ec:	8822c03a 	cmpne	r17,r17,zero
811315f0:	0007883a 	mov	r3,zero
811315f4:	003f8b06 	br	81131424 <__reset+0xfb111424>
811315f8:	0141ffc4 	movi	r5,2047
811315fc:	11403b26 	beq	r2,r5,811316ec <__adddf3+0x788>
81131600:	0109c83a 	sub	r4,zero,r4
81131604:	42002034 	orhi	r8,r8,128
81131608:	01400e04 	movi	r5,56
8113160c:	29006716 	blt	r5,r4,811317ac <__adddf3+0x848>
81131610:	014007c4 	movi	r5,31
81131614:	29007016 	blt	r5,r4,811317d8 <__adddf3+0x874>
81131618:	01400804 	movi	r5,32
8113161c:	290bc83a 	sub	r5,r5,r4
81131620:	4154983a 	sll	r10,r8,r5
81131624:	890ed83a 	srl	r7,r17,r4
81131628:	894a983a 	sll	r5,r17,r5
8113162c:	4108d83a 	srl	r4,r8,r4
81131630:	51e2b03a 	or	r17,r10,r7
81131634:	280ac03a 	cmpne	r5,r5,zero
81131638:	8962b03a 	or	r17,r17,r5
8113163c:	89a3883a 	add	r17,r17,r6
81131640:	2253883a 	add	r9,r4,r9
81131644:	898d803a 	cmpltu	r6,r17,r6
81131648:	3251883a 	add	r8,r6,r9
8113164c:	1021883a 	mov	r16,r2
81131650:	003ee506 	br	811311e8 <__reset+0xfb1111e8>
81131654:	4984b03a 	or	r2,r9,r6
81131658:	103e6326 	beq	r2,zero,81130fe8 <__reset+0xfb110fe8>
8113165c:	8987c83a 	sub	r3,r17,r6
81131660:	88c9803a 	cmpltu	r4,r17,r3
81131664:	4245c83a 	sub	r2,r8,r9
81131668:	1105c83a 	sub	r2,r2,r4
8113166c:	1100202c 	andhi	r4,r2,128
81131670:	203ebb26 	beq	r4,zero,81131160 <__reset+0xfb111160>
81131674:	3463c83a 	sub	r17,r6,r17
81131678:	4a07c83a 	sub	r3,r9,r8
8113167c:	344d803a 	cmpltu	r6,r6,r17
81131680:	1991c83a 	sub	r8,r3,r6
81131684:	3825883a 	mov	r18,r7
81131688:	003e5706 	br	81130fe8 <__reset+0xfb110fe8>
8113168c:	4984b03a 	or	r2,r9,r6
81131690:	10002e26 	beq	r2,zero,8113174c <__adddf3+0x7e8>
81131694:	4004d0fa 	srli	r2,r8,3
81131698:	8822d0fa 	srli	r17,r17,3
8113169c:	4010977a 	slli	r8,r8,29
811316a0:	10c0022c 	andhi	r3,r2,8
811316a4:	4462b03a 	or	r17,r8,r17
811316a8:	18000826 	beq	r3,zero,811316cc <__adddf3+0x768>
811316ac:	4808d0fa 	srli	r4,r9,3
811316b0:	20c0022c 	andhi	r3,r4,8
811316b4:	1800051e 	bne	r3,zero,811316cc <__adddf3+0x768>
811316b8:	300cd0fa 	srli	r6,r6,3
811316bc:	4806977a 	slli	r3,r9,29
811316c0:	2005883a 	mov	r2,r4
811316c4:	3825883a 	mov	r18,r7
811316c8:	19a2b03a 	or	r17,r3,r6
811316cc:	8810d77a 	srli	r8,r17,29
811316d0:	100490fa 	slli	r2,r2,3
811316d4:	882290fa 	slli	r17,r17,3
811316d8:	0401ffc4 	movi	r16,2047
811316dc:	4090b03a 	or	r8,r8,r2
811316e0:	003e4106 	br	81130fe8 <__reset+0xfb110fe8>
811316e4:	0141ffc4 	movi	r5,2047
811316e8:	117fc71e 	bne	r2,r5,81131608 <__reset+0xfb111608>
811316ec:	4811883a 	mov	r8,r9
811316f0:	3023883a 	mov	r17,r6
811316f4:	1021883a 	mov	r16,r2
811316f8:	003e3b06 	br	81130fe8 <__reset+0xfb110fe8>
811316fc:	10002f26 	beq	r2,zero,811317bc <__adddf3+0x858>
81131700:	4984b03a 	or	r2,r9,r6
81131704:	10001126 	beq	r2,zero,8113174c <__adddf3+0x7e8>
81131708:	4004d0fa 	srli	r2,r8,3
8113170c:	8822d0fa 	srli	r17,r17,3
81131710:	4010977a 	slli	r8,r8,29
81131714:	10c0022c 	andhi	r3,r2,8
81131718:	4462b03a 	or	r17,r8,r17
8113171c:	183feb26 	beq	r3,zero,811316cc <__reset+0xfb1116cc>
81131720:	4808d0fa 	srli	r4,r9,3
81131724:	20c0022c 	andhi	r3,r4,8
81131728:	183fe81e 	bne	r3,zero,811316cc <__reset+0xfb1116cc>
8113172c:	300cd0fa 	srli	r6,r6,3
81131730:	4806977a 	slli	r3,r9,29
81131734:	2005883a 	mov	r2,r4
81131738:	19a2b03a 	or	r17,r3,r6
8113173c:	003fe306 	br	811316cc <__reset+0xfb1116cc>
81131740:	0011883a 	mov	r8,zero
81131744:	0005883a 	mov	r2,zero
81131748:	003e3f06 	br	81131048 <__reset+0xfb111048>
8113174c:	0401ffc4 	movi	r16,2047
81131750:	003e2506 	br	81130fe8 <__reset+0xfb110fe8>
81131754:	0013883a 	mov	r9,zero
81131758:	003f8406 	br	8113156c <__reset+0xfb11156c>
8113175c:	0005883a 	mov	r2,zero
81131760:	0007883a 	mov	r3,zero
81131764:	003e8906 	br	8113118c <__reset+0xfb11118c>
81131768:	197ff804 	addi	r5,r3,-32
8113176c:	01000804 	movi	r4,32
81131770:	414ad83a 	srl	r5,r8,r5
81131774:	19002426 	beq	r3,r4,81131808 <__adddf3+0x8a4>
81131778:	01001004 	movi	r4,64
8113177c:	20c7c83a 	sub	r3,r4,r3
81131780:	40c6983a 	sll	r3,r8,r3
81131784:	1c46b03a 	or	r3,r3,r17
81131788:	1806c03a 	cmpne	r3,r3,zero
8113178c:	28e2b03a 	or	r17,r5,r3
81131790:	0007883a 	mov	r3,zero
81131794:	003f2306 	br	81131424 <__reset+0xfb111424>
81131798:	0007883a 	mov	r3,zero
8113179c:	5811883a 	mov	r8,r11
811317a0:	00bfffc4 	movi	r2,-1
811317a4:	0401ffc4 	movi	r16,2047
811317a8:	003e7806 	br	8113118c <__reset+0xfb11118c>
811317ac:	4462b03a 	or	r17,r8,r17
811317b0:	8822c03a 	cmpne	r17,r17,zero
811317b4:	0009883a 	mov	r4,zero
811317b8:	003fa006 	br	8113163c <__reset+0xfb11163c>
811317bc:	4811883a 	mov	r8,r9
811317c0:	3023883a 	mov	r17,r6
811317c4:	0401ffc4 	movi	r16,2047
811317c8:	003e0706 	br	81130fe8 <__reset+0xfb110fe8>
811317cc:	4811883a 	mov	r8,r9
811317d0:	3023883a 	mov	r17,r6
811317d4:	003e0406 	br	81130fe8 <__reset+0xfb110fe8>
811317d8:	21fff804 	addi	r7,r4,-32
811317dc:	01400804 	movi	r5,32
811317e0:	41ced83a 	srl	r7,r8,r7
811317e4:	21400a26 	beq	r4,r5,81131810 <__adddf3+0x8ac>
811317e8:	01401004 	movi	r5,64
811317ec:	2909c83a 	sub	r4,r5,r4
811317f0:	4108983a 	sll	r4,r8,r4
811317f4:	2448b03a 	or	r4,r4,r17
811317f8:	2008c03a 	cmpne	r4,r4,zero
811317fc:	3922b03a 	or	r17,r7,r4
81131800:	0009883a 	mov	r4,zero
81131804:	003f8d06 	br	8113163c <__reset+0xfb11163c>
81131808:	0007883a 	mov	r3,zero
8113180c:	003fdd06 	br	81131784 <__reset+0xfb111784>
81131810:	0009883a 	mov	r4,zero
81131814:	003ff706 	br	811317f4 <__reset+0xfb1117f4>

81131818 <__divdf3>:
81131818:	defff204 	addi	sp,sp,-56
8113181c:	de00012e 	bgeu	sp,et,81131824 <__divdf3+0xc>
81131820:	003b68fa 	trap	3
81131824:	dd400915 	stw	r21,36(sp)
81131828:	282ad53a 	srli	r21,r5,20
8113182c:	dd000815 	stw	r20,32(sp)
81131830:	2828d7fa 	srli	r20,r5,31
81131834:	dc000415 	stw	r16,16(sp)
81131838:	04000434 	movhi	r16,16
8113183c:	df000c15 	stw	fp,48(sp)
81131840:	843fffc4 	addi	r16,r16,-1
81131844:	dfc00d15 	stw	ra,52(sp)
81131848:	ddc00b15 	stw	r23,44(sp)
8113184c:	dd800a15 	stw	r22,40(sp)
81131850:	dcc00715 	stw	r19,28(sp)
81131854:	dc800615 	stw	r18,24(sp)
81131858:	dc400515 	stw	r17,20(sp)
8113185c:	ad41ffcc 	andi	r21,r21,2047
81131860:	2c20703a 	and	r16,r5,r16
81131864:	a7003fcc 	andi	fp,r20,255
81131868:	a8006126 	beq	r21,zero,811319f0 <__divdf3+0x1d8>
8113186c:	0081ffc4 	movi	r2,2047
81131870:	2025883a 	mov	r18,r4
81131874:	a8803726 	beq	r21,r2,81131954 <__divdf3+0x13c>
81131878:	80800434 	orhi	r2,r16,16
8113187c:	100490fa 	slli	r2,r2,3
81131880:	2020d77a 	srli	r16,r4,29
81131884:	202490fa 	slli	r18,r4,3
81131888:	ad7f0044 	addi	r21,r21,-1023
8113188c:	80a0b03a 	or	r16,r16,r2
81131890:	0027883a 	mov	r19,zero
81131894:	0013883a 	mov	r9,zero
81131898:	3804d53a 	srli	r2,r7,20
8113189c:	382cd7fa 	srli	r22,r7,31
811318a0:	04400434 	movhi	r17,16
811318a4:	8c7fffc4 	addi	r17,r17,-1
811318a8:	1081ffcc 	andi	r2,r2,2047
811318ac:	3011883a 	mov	r8,r6
811318b0:	3c62703a 	and	r17,r7,r17
811318b4:	b5c03fcc 	andi	r23,r22,255
811318b8:	10006c26 	beq	r2,zero,81131a6c <__divdf3+0x254>
811318bc:	00c1ffc4 	movi	r3,2047
811318c0:	10c06426 	beq	r2,r3,81131a54 <__divdf3+0x23c>
811318c4:	88c00434 	orhi	r3,r17,16
811318c8:	180690fa 	slli	r3,r3,3
811318cc:	3022d77a 	srli	r17,r6,29
811318d0:	301090fa 	slli	r8,r6,3
811318d4:	10bf0044 	addi	r2,r2,-1023
811318d8:	88e2b03a 	or	r17,r17,r3
811318dc:	000f883a 	mov	r7,zero
811318e0:	a58cf03a 	xor	r6,r20,r22
811318e4:	3cc8b03a 	or	r4,r7,r19
811318e8:	a8abc83a 	sub	r21,r21,r2
811318ec:	008003c4 	movi	r2,15
811318f0:	3007883a 	mov	r3,r6
811318f4:	34c03fcc 	andi	r19,r6,255
811318f8:	11009036 	bltu	r2,r4,81131b3c <__divdf3+0x324>
811318fc:	200890ba 	slli	r4,r4,2
81131900:	00a044f4 	movhi	r2,33043
81131904:	10864504 	addi	r2,r2,6420
81131908:	2089883a 	add	r4,r4,r2
8113190c:	20800017 	ldw	r2,0(r4)
81131910:	1000683a 	jmp	r2
81131914:	81131b3c 	xorhi	r4,r16,19564
81131918:	8113198c 	andi	r4,r16,19558
8113191c:	81131b2c 	andhi	r4,r16,19564
81131920:	81131980 	call	88113198 <__reset+0x20f3198>
81131924:	81131b2c 	andhi	r4,r16,19564
81131928:	81131b00 	call	881131b0 <__reset+0x20f31b0>
8113192c:	81131b2c 	andhi	r4,r16,19564
81131930:	81131980 	call	88113198 <__reset+0x20f3198>
81131934:	8113198c 	andi	r4,r16,19558
81131938:	8113198c 	andi	r4,r16,19558
8113193c:	81131b00 	call	881131b0 <__reset+0x20f31b0>
81131940:	81131980 	call	88113198 <__reset+0x20f3198>
81131944:	81131970 	cmpltui	r4,r16,19557
81131948:	81131970 	cmpltui	r4,r16,19557
8113194c:	81131970 	cmpltui	r4,r16,19557
81131950:	81131e20 	cmpeqi	r4,r16,19576
81131954:	2404b03a 	or	r2,r4,r16
81131958:	1000661e 	bne	r2,zero,81131af4 <__divdf3+0x2dc>
8113195c:	04c00204 	movi	r19,8
81131960:	0021883a 	mov	r16,zero
81131964:	0025883a 	mov	r18,zero
81131968:	02400084 	movi	r9,2
8113196c:	003fca06 	br	81131898 <__reset+0xfb111898>
81131970:	8023883a 	mov	r17,r16
81131974:	9011883a 	mov	r8,r18
81131978:	e02f883a 	mov	r23,fp
8113197c:	480f883a 	mov	r7,r9
81131980:	00800084 	movi	r2,2
81131984:	3881311e 	bne	r7,r2,81131e4c <__divdf3+0x634>
81131988:	b827883a 	mov	r19,r23
8113198c:	98c0004c 	andi	r3,r19,1
81131990:	0081ffc4 	movi	r2,2047
81131994:	000b883a 	mov	r5,zero
81131998:	0025883a 	mov	r18,zero
8113199c:	1004953a 	slli	r2,r2,20
811319a0:	18c03fcc 	andi	r3,r3,255
811319a4:	04400434 	movhi	r17,16
811319a8:	8c7fffc4 	addi	r17,r17,-1
811319ac:	180697fa 	slli	r3,r3,31
811319b0:	2c4a703a 	and	r5,r5,r17
811319b4:	288ab03a 	or	r5,r5,r2
811319b8:	28c6b03a 	or	r3,r5,r3
811319bc:	9005883a 	mov	r2,r18
811319c0:	dfc00d17 	ldw	ra,52(sp)
811319c4:	df000c17 	ldw	fp,48(sp)
811319c8:	ddc00b17 	ldw	r23,44(sp)
811319cc:	dd800a17 	ldw	r22,40(sp)
811319d0:	dd400917 	ldw	r21,36(sp)
811319d4:	dd000817 	ldw	r20,32(sp)
811319d8:	dcc00717 	ldw	r19,28(sp)
811319dc:	dc800617 	ldw	r18,24(sp)
811319e0:	dc400517 	ldw	r17,20(sp)
811319e4:	dc000417 	ldw	r16,16(sp)
811319e8:	dec00e04 	addi	sp,sp,56
811319ec:	f800283a 	ret
811319f0:	2404b03a 	or	r2,r4,r16
811319f4:	2027883a 	mov	r19,r4
811319f8:	10003926 	beq	r2,zero,81131ae0 <__divdf3+0x2c8>
811319fc:	80012e26 	beq	r16,zero,81131eb8 <__divdf3+0x6a0>
81131a00:	8009883a 	mov	r4,r16
81131a04:	d9800315 	stw	r6,12(sp)
81131a08:	d9c00215 	stw	r7,8(sp)
81131a0c:	111d4540 	call	8111d454 <__clzsi2>
81131a10:	d9800317 	ldw	r6,12(sp)
81131a14:	d9c00217 	ldw	r7,8(sp)
81131a18:	113ffd44 	addi	r4,r2,-11
81131a1c:	00c00704 	movi	r3,28
81131a20:	19012116 	blt	r3,r4,81131ea8 <__divdf3+0x690>
81131a24:	00c00744 	movi	r3,29
81131a28:	147ffe04 	addi	r17,r2,-8
81131a2c:	1907c83a 	sub	r3,r3,r4
81131a30:	8460983a 	sll	r16,r16,r17
81131a34:	98c6d83a 	srl	r3,r19,r3
81131a38:	9c64983a 	sll	r18,r19,r17
81131a3c:	1c20b03a 	or	r16,r3,r16
81131a40:	1080fcc4 	addi	r2,r2,1011
81131a44:	00abc83a 	sub	r21,zero,r2
81131a48:	0027883a 	mov	r19,zero
81131a4c:	0013883a 	mov	r9,zero
81131a50:	003f9106 	br	81131898 <__reset+0xfb111898>
81131a54:	3446b03a 	or	r3,r6,r17
81131a58:	18001f1e 	bne	r3,zero,81131ad8 <__divdf3+0x2c0>
81131a5c:	0023883a 	mov	r17,zero
81131a60:	0011883a 	mov	r8,zero
81131a64:	01c00084 	movi	r7,2
81131a68:	003f9d06 	br	811318e0 <__reset+0xfb1118e0>
81131a6c:	3446b03a 	or	r3,r6,r17
81131a70:	18001526 	beq	r3,zero,81131ac8 <__divdf3+0x2b0>
81131a74:	88011b26 	beq	r17,zero,81131ee4 <__divdf3+0x6cc>
81131a78:	8809883a 	mov	r4,r17
81131a7c:	d9800315 	stw	r6,12(sp)
81131a80:	da400115 	stw	r9,4(sp)
81131a84:	111d4540 	call	8111d454 <__clzsi2>
81131a88:	d9800317 	ldw	r6,12(sp)
81131a8c:	da400117 	ldw	r9,4(sp)
81131a90:	113ffd44 	addi	r4,r2,-11
81131a94:	00c00704 	movi	r3,28
81131a98:	19010e16 	blt	r3,r4,81131ed4 <__divdf3+0x6bc>
81131a9c:	00c00744 	movi	r3,29
81131aa0:	123ffe04 	addi	r8,r2,-8
81131aa4:	1907c83a 	sub	r3,r3,r4
81131aa8:	8a22983a 	sll	r17,r17,r8
81131aac:	30c6d83a 	srl	r3,r6,r3
81131ab0:	3210983a 	sll	r8,r6,r8
81131ab4:	1c62b03a 	or	r17,r3,r17
81131ab8:	1080fcc4 	addi	r2,r2,1011
81131abc:	0085c83a 	sub	r2,zero,r2
81131ac0:	000f883a 	mov	r7,zero
81131ac4:	003f8606 	br	811318e0 <__reset+0xfb1118e0>
81131ac8:	0023883a 	mov	r17,zero
81131acc:	0011883a 	mov	r8,zero
81131ad0:	01c00044 	movi	r7,1
81131ad4:	003f8206 	br	811318e0 <__reset+0xfb1118e0>
81131ad8:	01c000c4 	movi	r7,3
81131adc:	003f8006 	br	811318e0 <__reset+0xfb1118e0>
81131ae0:	04c00104 	movi	r19,4
81131ae4:	0021883a 	mov	r16,zero
81131ae8:	0025883a 	mov	r18,zero
81131aec:	02400044 	movi	r9,1
81131af0:	003f6906 	br	81131898 <__reset+0xfb111898>
81131af4:	04c00304 	movi	r19,12
81131af8:	024000c4 	movi	r9,3
81131afc:	003f6606 	br	81131898 <__reset+0xfb111898>
81131b00:	01400434 	movhi	r5,16
81131b04:	0007883a 	mov	r3,zero
81131b08:	297fffc4 	addi	r5,r5,-1
81131b0c:	04bfffc4 	movi	r18,-1
81131b10:	0081ffc4 	movi	r2,2047
81131b14:	003fa106 	br	8113199c <__reset+0xfb11199c>
81131b18:	00c00044 	movi	r3,1
81131b1c:	1887c83a 	sub	r3,r3,r2
81131b20:	01000e04 	movi	r4,56
81131b24:	20c1210e 	bge	r4,r3,81131fac <__divdf3+0x794>
81131b28:	98c0004c 	andi	r3,r19,1
81131b2c:	0005883a 	mov	r2,zero
81131b30:	000b883a 	mov	r5,zero
81131b34:	0025883a 	mov	r18,zero
81131b38:	003f9806 	br	8113199c <__reset+0xfb11199c>
81131b3c:	8c00fd36 	bltu	r17,r16,81131f34 <__divdf3+0x71c>
81131b40:	8440fb26 	beq	r16,r17,81131f30 <__divdf3+0x718>
81131b44:	8007883a 	mov	r3,r16
81131b48:	ad7fffc4 	addi	r21,r21,-1
81131b4c:	0021883a 	mov	r16,zero
81131b50:	4004d63a 	srli	r2,r8,24
81131b54:	8822923a 	slli	r17,r17,8
81131b58:	1809883a 	mov	r4,r3
81131b5c:	402c923a 	slli	r22,r8,8
81131b60:	88b8b03a 	or	fp,r17,r2
81131b64:	e028d43a 	srli	r20,fp,16
81131b68:	d8c00015 	stw	r3,0(sp)
81131b6c:	e5ffffcc 	andi	r23,fp,65535
81131b70:	a00b883a 	mov	r5,r20
81131b74:	1130cac0 	call	81130cac <__udivsi3>
81131b78:	d8c00017 	ldw	r3,0(sp)
81131b7c:	a00b883a 	mov	r5,r20
81131b80:	d8800315 	stw	r2,12(sp)
81131b84:	1809883a 	mov	r4,r3
81131b88:	1130d100 	call	81130d10 <__umodsi3>
81131b8c:	d9800317 	ldw	r6,12(sp)
81131b90:	1006943a 	slli	r3,r2,16
81131b94:	9004d43a 	srli	r2,r18,16
81131b98:	b9a3383a 	mul	r17,r23,r6
81131b9c:	10c4b03a 	or	r2,r2,r3
81131ba0:	1440062e 	bgeu	r2,r17,81131bbc <__divdf3+0x3a4>
81131ba4:	1705883a 	add	r2,r2,fp
81131ba8:	30ffffc4 	addi	r3,r6,-1
81131bac:	1700ee36 	bltu	r2,fp,81131f68 <__divdf3+0x750>
81131bb0:	1440ed2e 	bgeu	r2,r17,81131f68 <__divdf3+0x750>
81131bb4:	31bfff84 	addi	r6,r6,-2
81131bb8:	1705883a 	add	r2,r2,fp
81131bbc:	1463c83a 	sub	r17,r2,r17
81131bc0:	a00b883a 	mov	r5,r20
81131bc4:	8809883a 	mov	r4,r17
81131bc8:	d9800315 	stw	r6,12(sp)
81131bcc:	1130cac0 	call	81130cac <__udivsi3>
81131bd0:	a00b883a 	mov	r5,r20
81131bd4:	8809883a 	mov	r4,r17
81131bd8:	d8800215 	stw	r2,8(sp)
81131bdc:	1130d100 	call	81130d10 <__umodsi3>
81131be0:	d9c00217 	ldw	r7,8(sp)
81131be4:	1004943a 	slli	r2,r2,16
81131be8:	94bfffcc 	andi	r18,r18,65535
81131bec:	b9d1383a 	mul	r8,r23,r7
81131bf0:	90a4b03a 	or	r18,r18,r2
81131bf4:	d9800317 	ldw	r6,12(sp)
81131bf8:	9200062e 	bgeu	r18,r8,81131c14 <__divdf3+0x3fc>
81131bfc:	9725883a 	add	r18,r18,fp
81131c00:	38bfffc4 	addi	r2,r7,-1
81131c04:	9700d636 	bltu	r18,fp,81131f60 <__divdf3+0x748>
81131c08:	9200d52e 	bgeu	r18,r8,81131f60 <__divdf3+0x748>
81131c0c:	39ffff84 	addi	r7,r7,-2
81131c10:	9725883a 	add	r18,r18,fp
81131c14:	3004943a 	slli	r2,r6,16
81131c18:	b012d43a 	srli	r9,r22,16
81131c1c:	b1bfffcc 	andi	r6,r22,65535
81131c20:	11e2b03a 	or	r17,r2,r7
81131c24:	8806d43a 	srli	r3,r17,16
81131c28:	893fffcc 	andi	r4,r17,65535
81131c2c:	218b383a 	mul	r5,r4,r6
81131c30:	30c5383a 	mul	r2,r6,r3
81131c34:	2249383a 	mul	r4,r4,r9
81131c38:	280ed43a 	srli	r7,r5,16
81131c3c:	9225c83a 	sub	r18,r18,r8
81131c40:	2089883a 	add	r4,r4,r2
81131c44:	3909883a 	add	r4,r7,r4
81131c48:	1a47383a 	mul	r3,r3,r9
81131c4c:	2080022e 	bgeu	r4,r2,81131c58 <__divdf3+0x440>
81131c50:	00800074 	movhi	r2,1
81131c54:	1887883a 	add	r3,r3,r2
81131c58:	2004d43a 	srli	r2,r4,16
81131c5c:	2008943a 	slli	r4,r4,16
81131c60:	297fffcc 	andi	r5,r5,65535
81131c64:	10c7883a 	add	r3,r2,r3
81131c68:	2149883a 	add	r4,r4,r5
81131c6c:	90c0a536 	bltu	r18,r3,81131f04 <__divdf3+0x6ec>
81131c70:	90c0bf26 	beq	r18,r3,81131f70 <__divdf3+0x758>
81131c74:	90c7c83a 	sub	r3,r18,r3
81131c78:	810fc83a 	sub	r7,r16,r4
81131c7c:	81e5803a 	cmpltu	r18,r16,r7
81131c80:	1ca5c83a 	sub	r18,r3,r18
81131c84:	e480c126 	beq	fp,r18,81131f8c <__divdf3+0x774>
81131c88:	a00b883a 	mov	r5,r20
81131c8c:	9009883a 	mov	r4,r18
81131c90:	d9800315 	stw	r6,12(sp)
81131c94:	d9c00215 	stw	r7,8(sp)
81131c98:	da400115 	stw	r9,4(sp)
81131c9c:	1130cac0 	call	81130cac <__udivsi3>
81131ca0:	a00b883a 	mov	r5,r20
81131ca4:	9009883a 	mov	r4,r18
81131ca8:	d8800015 	stw	r2,0(sp)
81131cac:	1130d100 	call	81130d10 <__umodsi3>
81131cb0:	d9c00217 	ldw	r7,8(sp)
81131cb4:	da000017 	ldw	r8,0(sp)
81131cb8:	1006943a 	slli	r3,r2,16
81131cbc:	3804d43a 	srli	r2,r7,16
81131cc0:	ba21383a 	mul	r16,r23,r8
81131cc4:	d9800317 	ldw	r6,12(sp)
81131cc8:	10c4b03a 	or	r2,r2,r3
81131ccc:	da400117 	ldw	r9,4(sp)
81131cd0:	1400062e 	bgeu	r2,r16,81131cec <__divdf3+0x4d4>
81131cd4:	1705883a 	add	r2,r2,fp
81131cd8:	40ffffc4 	addi	r3,r8,-1
81131cdc:	1700ad36 	bltu	r2,fp,81131f94 <__divdf3+0x77c>
81131ce0:	1400ac2e 	bgeu	r2,r16,81131f94 <__divdf3+0x77c>
81131ce4:	423fff84 	addi	r8,r8,-2
81131ce8:	1705883a 	add	r2,r2,fp
81131cec:	1421c83a 	sub	r16,r2,r16
81131cf0:	a00b883a 	mov	r5,r20
81131cf4:	8009883a 	mov	r4,r16
81131cf8:	d9800315 	stw	r6,12(sp)
81131cfc:	d9c00215 	stw	r7,8(sp)
81131d00:	da000015 	stw	r8,0(sp)
81131d04:	da400115 	stw	r9,4(sp)
81131d08:	1130cac0 	call	81130cac <__udivsi3>
81131d0c:	8009883a 	mov	r4,r16
81131d10:	a00b883a 	mov	r5,r20
81131d14:	1025883a 	mov	r18,r2
81131d18:	1130d100 	call	81130d10 <__umodsi3>
81131d1c:	d9c00217 	ldw	r7,8(sp)
81131d20:	1004943a 	slli	r2,r2,16
81131d24:	bcaf383a 	mul	r23,r23,r18
81131d28:	393fffcc 	andi	r4,r7,65535
81131d2c:	2088b03a 	or	r4,r4,r2
81131d30:	d9800317 	ldw	r6,12(sp)
81131d34:	da000017 	ldw	r8,0(sp)
81131d38:	da400117 	ldw	r9,4(sp)
81131d3c:	25c0062e 	bgeu	r4,r23,81131d58 <__divdf3+0x540>
81131d40:	2709883a 	add	r4,r4,fp
81131d44:	90bfffc4 	addi	r2,r18,-1
81131d48:	27009436 	bltu	r4,fp,81131f9c <__divdf3+0x784>
81131d4c:	25c0932e 	bgeu	r4,r23,81131f9c <__divdf3+0x784>
81131d50:	94bfff84 	addi	r18,r18,-2
81131d54:	2709883a 	add	r4,r4,fp
81131d58:	4004943a 	slli	r2,r8,16
81131d5c:	25efc83a 	sub	r23,r4,r23
81131d60:	1490b03a 	or	r8,r2,r18
81131d64:	4008d43a 	srli	r4,r8,16
81131d68:	40ffffcc 	andi	r3,r8,65535
81131d6c:	30c5383a 	mul	r2,r6,r3
81131d70:	1a47383a 	mul	r3,r3,r9
81131d74:	310d383a 	mul	r6,r6,r4
81131d78:	100ad43a 	srli	r5,r2,16
81131d7c:	4913383a 	mul	r9,r9,r4
81131d80:	1987883a 	add	r3,r3,r6
81131d84:	28c7883a 	add	r3,r5,r3
81131d88:	1980022e 	bgeu	r3,r6,81131d94 <__divdf3+0x57c>
81131d8c:	01000074 	movhi	r4,1
81131d90:	4913883a 	add	r9,r9,r4
81131d94:	1808d43a 	srli	r4,r3,16
81131d98:	1806943a 	slli	r3,r3,16
81131d9c:	10bfffcc 	andi	r2,r2,65535
81131da0:	2253883a 	add	r9,r4,r9
81131da4:	1887883a 	add	r3,r3,r2
81131da8:	ba403836 	bltu	r23,r9,81131e8c <__divdf3+0x674>
81131dac:	ba403626 	beq	r23,r9,81131e88 <__divdf3+0x670>
81131db0:	42000054 	ori	r8,r8,1
81131db4:	a880ffc4 	addi	r2,r21,1023
81131db8:	00bf570e 	bge	zero,r2,81131b18 <__reset+0xfb111b18>
81131dbc:	40c001cc 	andi	r3,r8,7
81131dc0:	18000726 	beq	r3,zero,81131de0 <__divdf3+0x5c8>
81131dc4:	40c003cc 	andi	r3,r8,15
81131dc8:	01000104 	movi	r4,4
81131dcc:	19000426 	beq	r3,r4,81131de0 <__divdf3+0x5c8>
81131dd0:	4107883a 	add	r3,r8,r4
81131dd4:	1a11803a 	cmpltu	r8,r3,r8
81131dd8:	8a23883a 	add	r17,r17,r8
81131ddc:	1811883a 	mov	r8,r3
81131de0:	88c0402c 	andhi	r3,r17,256
81131de4:	18000426 	beq	r3,zero,81131df8 <__divdf3+0x5e0>
81131de8:	00ffc034 	movhi	r3,65280
81131dec:	18ffffc4 	addi	r3,r3,-1
81131df0:	a8810004 	addi	r2,r21,1024
81131df4:	88e2703a 	and	r17,r17,r3
81131df8:	00c1ff84 	movi	r3,2046
81131dfc:	18bee316 	blt	r3,r2,8113198c <__reset+0xfb11198c>
81131e00:	8824977a 	slli	r18,r17,29
81131e04:	4010d0fa 	srli	r8,r8,3
81131e08:	8822927a 	slli	r17,r17,9
81131e0c:	1081ffcc 	andi	r2,r2,2047
81131e10:	9224b03a 	or	r18,r18,r8
81131e14:	880ad33a 	srli	r5,r17,12
81131e18:	98c0004c 	andi	r3,r19,1
81131e1c:	003edf06 	br	8113199c <__reset+0xfb11199c>
81131e20:	8080022c 	andhi	r2,r16,8
81131e24:	10001226 	beq	r2,zero,81131e70 <__divdf3+0x658>
81131e28:	8880022c 	andhi	r2,r17,8
81131e2c:	1000101e 	bne	r2,zero,81131e70 <__divdf3+0x658>
81131e30:	00800434 	movhi	r2,16
81131e34:	89400234 	orhi	r5,r17,8
81131e38:	10bfffc4 	addi	r2,r2,-1
81131e3c:	b007883a 	mov	r3,r22
81131e40:	288a703a 	and	r5,r5,r2
81131e44:	4025883a 	mov	r18,r8
81131e48:	003f3106 	br	81131b10 <__reset+0xfb111b10>
81131e4c:	008000c4 	movi	r2,3
81131e50:	3880a626 	beq	r7,r2,811320ec <__divdf3+0x8d4>
81131e54:	00800044 	movi	r2,1
81131e58:	3880521e 	bne	r7,r2,81131fa4 <__divdf3+0x78c>
81131e5c:	b807883a 	mov	r3,r23
81131e60:	0005883a 	mov	r2,zero
81131e64:	000b883a 	mov	r5,zero
81131e68:	0025883a 	mov	r18,zero
81131e6c:	003ecb06 	br	8113199c <__reset+0xfb11199c>
81131e70:	00800434 	movhi	r2,16
81131e74:	81400234 	orhi	r5,r16,8
81131e78:	10bfffc4 	addi	r2,r2,-1
81131e7c:	a007883a 	mov	r3,r20
81131e80:	288a703a 	and	r5,r5,r2
81131e84:	003f2206 	br	81131b10 <__reset+0xfb111b10>
81131e88:	183fca26 	beq	r3,zero,81131db4 <__reset+0xfb111db4>
81131e8c:	e5ef883a 	add	r23,fp,r23
81131e90:	40bfffc4 	addi	r2,r8,-1
81131e94:	bf00392e 	bgeu	r23,fp,81131f7c <__divdf3+0x764>
81131e98:	1011883a 	mov	r8,r2
81131e9c:	ba7fc41e 	bne	r23,r9,81131db0 <__reset+0xfb111db0>
81131ea0:	b0ffc31e 	bne	r22,r3,81131db0 <__reset+0xfb111db0>
81131ea4:	003fc306 	br	81131db4 <__reset+0xfb111db4>
81131ea8:	143ff604 	addi	r16,r2,-40
81131eac:	9c20983a 	sll	r16,r19,r16
81131eb0:	0025883a 	mov	r18,zero
81131eb4:	003ee206 	br	81131a40 <__reset+0xfb111a40>
81131eb8:	d9800315 	stw	r6,12(sp)
81131ebc:	d9c00215 	stw	r7,8(sp)
81131ec0:	111d4540 	call	8111d454 <__clzsi2>
81131ec4:	10800804 	addi	r2,r2,32
81131ec8:	d9c00217 	ldw	r7,8(sp)
81131ecc:	d9800317 	ldw	r6,12(sp)
81131ed0:	003ed106 	br	81131a18 <__reset+0xfb111a18>
81131ed4:	147ff604 	addi	r17,r2,-40
81131ed8:	3462983a 	sll	r17,r6,r17
81131edc:	0011883a 	mov	r8,zero
81131ee0:	003ef506 	br	81131ab8 <__reset+0xfb111ab8>
81131ee4:	3009883a 	mov	r4,r6
81131ee8:	d9800315 	stw	r6,12(sp)
81131eec:	da400115 	stw	r9,4(sp)
81131ef0:	111d4540 	call	8111d454 <__clzsi2>
81131ef4:	10800804 	addi	r2,r2,32
81131ef8:	da400117 	ldw	r9,4(sp)
81131efc:	d9800317 	ldw	r6,12(sp)
81131f00:	003ee306 	br	81131a90 <__reset+0xfb111a90>
81131f04:	85a1883a 	add	r16,r16,r22
81131f08:	8585803a 	cmpltu	r2,r16,r22
81131f0c:	1705883a 	add	r2,r2,fp
81131f10:	14a5883a 	add	r18,r2,r18
81131f14:	88bfffc4 	addi	r2,r17,-1
81131f18:	e4800c2e 	bgeu	fp,r18,81131f4c <__divdf3+0x734>
81131f1c:	90c03e36 	bltu	r18,r3,81132018 <__divdf3+0x800>
81131f20:	1c806926 	beq	r3,r18,811320c8 <__divdf3+0x8b0>
81131f24:	90c7c83a 	sub	r3,r18,r3
81131f28:	1023883a 	mov	r17,r2
81131f2c:	003f5206 	br	81131c78 <__reset+0xfb111c78>
81131f30:	923f0436 	bltu	r18,r8,81131b44 <__reset+0xfb111b44>
81131f34:	800897fa 	slli	r4,r16,31
81131f38:	9004d07a 	srli	r2,r18,1
81131f3c:	8006d07a 	srli	r3,r16,1
81131f40:	902097fa 	slli	r16,r18,31
81131f44:	20a4b03a 	or	r18,r4,r2
81131f48:	003f0106 	br	81131b50 <__reset+0xfb111b50>
81131f4c:	e4bff51e 	bne	fp,r18,81131f24 <__reset+0xfb111f24>
81131f50:	85bff22e 	bgeu	r16,r22,81131f1c <__reset+0xfb111f1c>
81131f54:	e0c7c83a 	sub	r3,fp,r3
81131f58:	1023883a 	mov	r17,r2
81131f5c:	003f4606 	br	81131c78 <__reset+0xfb111c78>
81131f60:	100f883a 	mov	r7,r2
81131f64:	003f2b06 	br	81131c14 <__reset+0xfb111c14>
81131f68:	180d883a 	mov	r6,r3
81131f6c:	003f1306 	br	81131bbc <__reset+0xfb111bbc>
81131f70:	813fe436 	bltu	r16,r4,81131f04 <__reset+0xfb111f04>
81131f74:	0007883a 	mov	r3,zero
81131f78:	003f3f06 	br	81131c78 <__reset+0xfb111c78>
81131f7c:	ba402c36 	bltu	r23,r9,81132030 <__divdf3+0x818>
81131f80:	4dc05426 	beq	r9,r23,811320d4 <__divdf3+0x8bc>
81131f84:	1011883a 	mov	r8,r2
81131f88:	003f8906 	br	81131db0 <__reset+0xfb111db0>
81131f8c:	023fffc4 	movi	r8,-1
81131f90:	003f8806 	br	81131db4 <__reset+0xfb111db4>
81131f94:	1811883a 	mov	r8,r3
81131f98:	003f5406 	br	81131cec <__reset+0xfb111cec>
81131f9c:	1025883a 	mov	r18,r2
81131fa0:	003f6d06 	br	81131d58 <__reset+0xfb111d58>
81131fa4:	b827883a 	mov	r19,r23
81131fa8:	003f8206 	br	81131db4 <__reset+0xfb111db4>
81131fac:	010007c4 	movi	r4,31
81131fb0:	20c02616 	blt	r4,r3,8113204c <__divdf3+0x834>
81131fb4:	00800804 	movi	r2,32
81131fb8:	10c5c83a 	sub	r2,r2,r3
81131fbc:	888a983a 	sll	r5,r17,r2
81131fc0:	40c8d83a 	srl	r4,r8,r3
81131fc4:	4084983a 	sll	r2,r8,r2
81131fc8:	88e2d83a 	srl	r17,r17,r3
81131fcc:	2906b03a 	or	r3,r5,r4
81131fd0:	1004c03a 	cmpne	r2,r2,zero
81131fd4:	1886b03a 	or	r3,r3,r2
81131fd8:	188001cc 	andi	r2,r3,7
81131fdc:	10000726 	beq	r2,zero,81131ffc <__divdf3+0x7e4>
81131fe0:	188003cc 	andi	r2,r3,15
81131fe4:	01000104 	movi	r4,4
81131fe8:	11000426 	beq	r2,r4,81131ffc <__divdf3+0x7e4>
81131fec:	1805883a 	mov	r2,r3
81131ff0:	10c00104 	addi	r3,r2,4
81131ff4:	1885803a 	cmpltu	r2,r3,r2
81131ff8:	88a3883a 	add	r17,r17,r2
81131ffc:	8880202c 	andhi	r2,r17,128
81132000:	10002726 	beq	r2,zero,811320a0 <__divdf3+0x888>
81132004:	98c0004c 	andi	r3,r19,1
81132008:	00800044 	movi	r2,1
8113200c:	000b883a 	mov	r5,zero
81132010:	0025883a 	mov	r18,zero
81132014:	003e6106 	br	8113199c <__reset+0xfb11199c>
81132018:	85a1883a 	add	r16,r16,r22
8113201c:	8585803a 	cmpltu	r2,r16,r22
81132020:	1705883a 	add	r2,r2,fp
81132024:	14a5883a 	add	r18,r2,r18
81132028:	8c7fff84 	addi	r17,r17,-2
8113202c:	003f1106 	br	81131c74 <__reset+0xfb111c74>
81132030:	b589883a 	add	r4,r22,r22
81132034:	25ad803a 	cmpltu	r22,r4,r22
81132038:	b739883a 	add	fp,r22,fp
8113203c:	40bfff84 	addi	r2,r8,-2
81132040:	bf2f883a 	add	r23,r23,fp
81132044:	202d883a 	mov	r22,r4
81132048:	003f9306 	br	81131e98 <__reset+0xfb111e98>
8113204c:	013ff844 	movi	r4,-31
81132050:	2085c83a 	sub	r2,r4,r2
81132054:	8888d83a 	srl	r4,r17,r2
81132058:	00800804 	movi	r2,32
8113205c:	18802126 	beq	r3,r2,811320e4 <__divdf3+0x8cc>
81132060:	00801004 	movi	r2,64
81132064:	10c5c83a 	sub	r2,r2,r3
81132068:	8884983a 	sll	r2,r17,r2
8113206c:	1204b03a 	or	r2,r2,r8
81132070:	1004c03a 	cmpne	r2,r2,zero
81132074:	2084b03a 	or	r2,r4,r2
81132078:	144001cc 	andi	r17,r2,7
8113207c:	88000d1e 	bne	r17,zero,811320b4 <__divdf3+0x89c>
81132080:	000b883a 	mov	r5,zero
81132084:	1024d0fa 	srli	r18,r2,3
81132088:	98c0004c 	andi	r3,r19,1
8113208c:	0005883a 	mov	r2,zero
81132090:	9464b03a 	or	r18,r18,r17
81132094:	003e4106 	br	8113199c <__reset+0xfb11199c>
81132098:	1007883a 	mov	r3,r2
8113209c:	0023883a 	mov	r17,zero
811320a0:	880a927a 	slli	r5,r17,9
811320a4:	1805883a 	mov	r2,r3
811320a8:	8822977a 	slli	r17,r17,29
811320ac:	280ad33a 	srli	r5,r5,12
811320b0:	003ff406 	br	81132084 <__reset+0xfb112084>
811320b4:	10c003cc 	andi	r3,r2,15
811320b8:	01000104 	movi	r4,4
811320bc:	193ff626 	beq	r3,r4,81132098 <__reset+0xfb112098>
811320c0:	0023883a 	mov	r17,zero
811320c4:	003fca06 	br	81131ff0 <__reset+0xfb111ff0>
811320c8:	813fd336 	bltu	r16,r4,81132018 <__reset+0xfb112018>
811320cc:	1023883a 	mov	r17,r2
811320d0:	003fa806 	br	81131f74 <__reset+0xfb111f74>
811320d4:	b0ffd636 	bltu	r22,r3,81132030 <__reset+0xfb112030>
811320d8:	1011883a 	mov	r8,r2
811320dc:	b0ff341e 	bne	r22,r3,81131db0 <__reset+0xfb111db0>
811320e0:	003f3406 	br	81131db4 <__reset+0xfb111db4>
811320e4:	0005883a 	mov	r2,zero
811320e8:	003fe006 	br	8113206c <__reset+0xfb11206c>
811320ec:	00800434 	movhi	r2,16
811320f0:	89400234 	orhi	r5,r17,8
811320f4:	10bfffc4 	addi	r2,r2,-1
811320f8:	b807883a 	mov	r3,r23
811320fc:	288a703a 	and	r5,r5,r2
81132100:	4025883a 	mov	r18,r8
81132104:	003e8206 	br	81131b10 <__reset+0xfb111b10>

81132108 <__eqdf2>:
81132108:	2804d53a 	srli	r2,r5,20
8113210c:	3806d53a 	srli	r3,r7,20
81132110:	02000434 	movhi	r8,16
81132114:	423fffc4 	addi	r8,r8,-1
81132118:	1081ffcc 	andi	r2,r2,2047
8113211c:	0281ffc4 	movi	r10,2047
81132120:	2a12703a 	and	r9,r5,r8
81132124:	18c1ffcc 	andi	r3,r3,2047
81132128:	3a10703a 	and	r8,r7,r8
8113212c:	280ad7fa 	srli	r5,r5,31
81132130:	380ed7fa 	srli	r7,r7,31
81132134:	12801026 	beq	r2,r10,81132178 <__eqdf2+0x70>
81132138:	0281ffc4 	movi	r10,2047
8113213c:	1a800a26 	beq	r3,r10,81132168 <__eqdf2+0x60>
81132140:	10c00226 	beq	r2,r3,8113214c <__eqdf2+0x44>
81132144:	00800044 	movi	r2,1
81132148:	f800283a 	ret
8113214c:	4a3ffd1e 	bne	r9,r8,81132144 <__reset+0xfb112144>
81132150:	21bffc1e 	bne	r4,r6,81132144 <__reset+0xfb112144>
81132154:	29c00c26 	beq	r5,r7,81132188 <__eqdf2+0x80>
81132158:	103ffa1e 	bne	r2,zero,81132144 <__reset+0xfb112144>
8113215c:	2244b03a 	or	r2,r4,r9
81132160:	1004c03a 	cmpne	r2,r2,zero
81132164:	f800283a 	ret
81132168:	3214b03a 	or	r10,r6,r8
8113216c:	503ff426 	beq	r10,zero,81132140 <__reset+0xfb112140>
81132170:	00800044 	movi	r2,1
81132174:	f800283a 	ret
81132178:	2254b03a 	or	r10,r4,r9
8113217c:	503fee26 	beq	r10,zero,81132138 <__reset+0xfb112138>
81132180:	00800044 	movi	r2,1
81132184:	f800283a 	ret
81132188:	0005883a 	mov	r2,zero
8113218c:	f800283a 	ret

81132190 <__gedf2>:
81132190:	2804d53a 	srli	r2,r5,20
81132194:	3806d53a 	srli	r3,r7,20
81132198:	02000434 	movhi	r8,16
8113219c:	423fffc4 	addi	r8,r8,-1
811321a0:	1081ffcc 	andi	r2,r2,2047
811321a4:	0241ffc4 	movi	r9,2047
811321a8:	2a14703a 	and	r10,r5,r8
811321ac:	18c1ffcc 	andi	r3,r3,2047
811321b0:	3a10703a 	and	r8,r7,r8
811321b4:	280ad7fa 	srli	r5,r5,31
811321b8:	380ed7fa 	srli	r7,r7,31
811321bc:	12401d26 	beq	r2,r9,81132234 <__gedf2+0xa4>
811321c0:	0241ffc4 	movi	r9,2047
811321c4:	1a401226 	beq	r3,r9,81132210 <__gedf2+0x80>
811321c8:	1000081e 	bne	r2,zero,811321ec <__gedf2+0x5c>
811321cc:	2296b03a 	or	r11,r4,r10
811321d0:	5813003a 	cmpeq	r9,r11,zero
811321d4:	1800091e 	bne	r3,zero,811321fc <__gedf2+0x6c>
811321d8:	3218b03a 	or	r12,r6,r8
811321dc:	6000071e 	bne	r12,zero,811321fc <__gedf2+0x6c>
811321e0:	0005883a 	mov	r2,zero
811321e4:	5800101e 	bne	r11,zero,81132228 <__gedf2+0x98>
811321e8:	f800283a 	ret
811321ec:	18000c1e 	bne	r3,zero,81132220 <__gedf2+0x90>
811321f0:	3212b03a 	or	r9,r6,r8
811321f4:	48000c26 	beq	r9,zero,81132228 <__gedf2+0x98>
811321f8:	0013883a 	mov	r9,zero
811321fc:	39c03fcc 	andi	r7,r7,255
81132200:	48000826 	beq	r9,zero,81132224 <__gedf2+0x94>
81132204:	38000926 	beq	r7,zero,8113222c <__gedf2+0x9c>
81132208:	00800044 	movi	r2,1
8113220c:	f800283a 	ret
81132210:	3212b03a 	or	r9,r6,r8
81132214:	483fec26 	beq	r9,zero,811321c8 <__reset+0xfb1121c8>
81132218:	00bfff84 	movi	r2,-2
8113221c:	f800283a 	ret
81132220:	39c03fcc 	andi	r7,r7,255
81132224:	29c00626 	beq	r5,r7,81132240 <__gedf2+0xb0>
81132228:	283ff726 	beq	r5,zero,81132208 <__reset+0xfb112208>
8113222c:	00bfffc4 	movi	r2,-1
81132230:	f800283a 	ret
81132234:	2292b03a 	or	r9,r4,r10
81132238:	483fe126 	beq	r9,zero,811321c0 <__reset+0xfb1121c0>
8113223c:	003ff606 	br	81132218 <__reset+0xfb112218>
81132240:	18bff916 	blt	r3,r2,81132228 <__reset+0xfb112228>
81132244:	10c00316 	blt	r2,r3,81132254 <__gedf2+0xc4>
81132248:	42bff736 	bltu	r8,r10,81132228 <__reset+0xfb112228>
8113224c:	52000326 	beq	r10,r8,8113225c <__gedf2+0xcc>
81132250:	5200042e 	bgeu	r10,r8,81132264 <__gedf2+0xd4>
81132254:	283fec1e 	bne	r5,zero,81132208 <__reset+0xfb112208>
81132258:	003ff406 	br	8113222c <__reset+0xfb11222c>
8113225c:	313ff236 	bltu	r6,r4,81132228 <__reset+0xfb112228>
81132260:	21bffc36 	bltu	r4,r6,81132254 <__reset+0xfb112254>
81132264:	0005883a 	mov	r2,zero
81132268:	f800283a 	ret

8113226c <__ledf2>:
8113226c:	2804d53a 	srli	r2,r5,20
81132270:	3810d53a 	srli	r8,r7,20
81132274:	00c00434 	movhi	r3,16
81132278:	18ffffc4 	addi	r3,r3,-1
8113227c:	1081ffcc 	andi	r2,r2,2047
81132280:	0241ffc4 	movi	r9,2047
81132284:	28d4703a 	and	r10,r5,r3
81132288:	4201ffcc 	andi	r8,r8,2047
8113228c:	38c6703a 	and	r3,r7,r3
81132290:	280ad7fa 	srli	r5,r5,31
81132294:	380ed7fa 	srli	r7,r7,31
81132298:	12401f26 	beq	r2,r9,81132318 <__ledf2+0xac>
8113229c:	0241ffc4 	movi	r9,2047
811322a0:	42401426 	beq	r8,r9,811322f4 <__ledf2+0x88>
811322a4:	1000091e 	bne	r2,zero,811322cc <__ledf2+0x60>
811322a8:	2296b03a 	or	r11,r4,r10
811322ac:	5813003a 	cmpeq	r9,r11,zero
811322b0:	29403fcc 	andi	r5,r5,255
811322b4:	40000a1e 	bne	r8,zero,811322e0 <__ledf2+0x74>
811322b8:	30d8b03a 	or	r12,r6,r3
811322bc:	6000081e 	bne	r12,zero,811322e0 <__ledf2+0x74>
811322c0:	0005883a 	mov	r2,zero
811322c4:	5800111e 	bne	r11,zero,8113230c <__ledf2+0xa0>
811322c8:	f800283a 	ret
811322cc:	29403fcc 	andi	r5,r5,255
811322d0:	40000c1e 	bne	r8,zero,81132304 <__ledf2+0x98>
811322d4:	30d2b03a 	or	r9,r6,r3
811322d8:	48000c26 	beq	r9,zero,8113230c <__ledf2+0xa0>
811322dc:	0013883a 	mov	r9,zero
811322e0:	39c03fcc 	andi	r7,r7,255
811322e4:	48000826 	beq	r9,zero,81132308 <__ledf2+0x9c>
811322e8:	38001126 	beq	r7,zero,81132330 <__ledf2+0xc4>
811322ec:	00800044 	movi	r2,1
811322f0:	f800283a 	ret
811322f4:	30d2b03a 	or	r9,r6,r3
811322f8:	483fea26 	beq	r9,zero,811322a4 <__reset+0xfb1122a4>
811322fc:	00800084 	movi	r2,2
81132300:	f800283a 	ret
81132304:	39c03fcc 	andi	r7,r7,255
81132308:	39400726 	beq	r7,r5,81132328 <__ledf2+0xbc>
8113230c:	2800081e 	bne	r5,zero,81132330 <__ledf2+0xc4>
81132310:	00800044 	movi	r2,1
81132314:	f800283a 	ret
81132318:	2292b03a 	or	r9,r4,r10
8113231c:	483fdf26 	beq	r9,zero,8113229c <__reset+0xfb11229c>
81132320:	00800084 	movi	r2,2
81132324:	f800283a 	ret
81132328:	4080030e 	bge	r8,r2,81132338 <__ledf2+0xcc>
8113232c:	383fef26 	beq	r7,zero,811322ec <__reset+0xfb1122ec>
81132330:	00bfffc4 	movi	r2,-1
81132334:	f800283a 	ret
81132338:	123feb16 	blt	r2,r8,811322e8 <__reset+0xfb1122e8>
8113233c:	1abff336 	bltu	r3,r10,8113230c <__reset+0xfb11230c>
81132340:	50c00326 	beq	r10,r3,81132350 <__ledf2+0xe4>
81132344:	50c0042e 	bgeu	r10,r3,81132358 <__ledf2+0xec>
81132348:	283fe81e 	bne	r5,zero,811322ec <__reset+0xfb1122ec>
8113234c:	003ff806 	br	81132330 <__reset+0xfb112330>
81132350:	313fee36 	bltu	r6,r4,8113230c <__reset+0xfb11230c>
81132354:	21bffc36 	bltu	r4,r6,81132348 <__reset+0xfb112348>
81132358:	0005883a 	mov	r2,zero
8113235c:	f800283a 	ret

81132360 <__subdf3>:
81132360:	02000434 	movhi	r8,16
81132364:	423fffc4 	addi	r8,r8,-1
81132368:	defffb04 	addi	sp,sp,-20
8113236c:	2a14703a 	and	r10,r5,r8
81132370:	3812d53a 	srli	r9,r7,20
81132374:	3a10703a 	and	r8,r7,r8
81132378:	de00012e 	bgeu	sp,et,81132380 <__subdf3+0x20>
8113237c:	003b68fa 	trap	3
81132380:	2006d77a 	srli	r3,r4,29
81132384:	3004d77a 	srli	r2,r6,29
81132388:	dc000015 	stw	r16,0(sp)
8113238c:	501490fa 	slli	r10,r10,3
81132390:	2820d53a 	srli	r16,r5,20
81132394:	401090fa 	slli	r8,r8,3
81132398:	dc800215 	stw	r18,8(sp)
8113239c:	dc400115 	stw	r17,4(sp)
811323a0:	dfc00415 	stw	ra,16(sp)
811323a4:	202290fa 	slli	r17,r4,3
811323a8:	dcc00315 	stw	r19,12(sp)
811323ac:	4a41ffcc 	andi	r9,r9,2047
811323b0:	0101ffc4 	movi	r4,2047
811323b4:	2824d7fa 	srli	r18,r5,31
811323b8:	8401ffcc 	andi	r16,r16,2047
811323bc:	50c6b03a 	or	r3,r10,r3
811323c0:	380ed7fa 	srli	r7,r7,31
811323c4:	408ab03a 	or	r5,r8,r2
811323c8:	300c90fa 	slli	r6,r6,3
811323cc:	49009626 	beq	r9,r4,81132628 <__subdf3+0x2c8>
811323d0:	39c0005c 	xori	r7,r7,1
811323d4:	8245c83a 	sub	r2,r16,r9
811323d8:	3c807426 	beq	r7,r18,811325ac <__subdf3+0x24c>
811323dc:	0080af0e 	bge	zero,r2,8113269c <__subdf3+0x33c>
811323e0:	48002a1e 	bne	r9,zero,8113248c <__subdf3+0x12c>
811323e4:	2988b03a 	or	r4,r5,r6
811323e8:	20009a1e 	bne	r4,zero,81132654 <__subdf3+0x2f4>
811323ec:	888001cc 	andi	r2,r17,7
811323f0:	10000726 	beq	r2,zero,81132410 <__subdf3+0xb0>
811323f4:	888003cc 	andi	r2,r17,15
811323f8:	01000104 	movi	r4,4
811323fc:	11000426 	beq	r2,r4,81132410 <__subdf3+0xb0>
81132400:	890b883a 	add	r5,r17,r4
81132404:	2c63803a 	cmpltu	r17,r5,r17
81132408:	1c47883a 	add	r3,r3,r17
8113240c:	2823883a 	mov	r17,r5
81132410:	1880202c 	andhi	r2,r3,128
81132414:	10005926 	beq	r2,zero,8113257c <__subdf3+0x21c>
81132418:	84000044 	addi	r16,r16,1
8113241c:	0081ffc4 	movi	r2,2047
81132420:	8080be26 	beq	r16,r2,8113271c <__subdf3+0x3bc>
81132424:	017fe034 	movhi	r5,65408
81132428:	297fffc4 	addi	r5,r5,-1
8113242c:	1946703a 	and	r3,r3,r5
81132430:	1804977a 	slli	r2,r3,29
81132434:	1806927a 	slli	r3,r3,9
81132438:	8822d0fa 	srli	r17,r17,3
8113243c:	8401ffcc 	andi	r16,r16,2047
81132440:	180ad33a 	srli	r5,r3,12
81132444:	9100004c 	andi	r4,r18,1
81132448:	1444b03a 	or	r2,r2,r17
8113244c:	80c1ffcc 	andi	r3,r16,2047
81132450:	1820953a 	slli	r16,r3,20
81132454:	20c03fcc 	andi	r3,r4,255
81132458:	180897fa 	slli	r4,r3,31
8113245c:	00c00434 	movhi	r3,16
81132460:	18ffffc4 	addi	r3,r3,-1
81132464:	28c6703a 	and	r3,r5,r3
81132468:	1c06b03a 	or	r3,r3,r16
8113246c:	1906b03a 	or	r3,r3,r4
81132470:	dfc00417 	ldw	ra,16(sp)
81132474:	dcc00317 	ldw	r19,12(sp)
81132478:	dc800217 	ldw	r18,8(sp)
8113247c:	dc400117 	ldw	r17,4(sp)
81132480:	dc000017 	ldw	r16,0(sp)
81132484:	dec00504 	addi	sp,sp,20
81132488:	f800283a 	ret
8113248c:	0101ffc4 	movi	r4,2047
81132490:	813fd626 	beq	r16,r4,811323ec <__reset+0xfb1123ec>
81132494:	29402034 	orhi	r5,r5,128
81132498:	01000e04 	movi	r4,56
8113249c:	2080a316 	blt	r4,r2,8113272c <__subdf3+0x3cc>
811324a0:	010007c4 	movi	r4,31
811324a4:	2080c616 	blt	r4,r2,811327c0 <__subdf3+0x460>
811324a8:	01000804 	movi	r4,32
811324ac:	2089c83a 	sub	r4,r4,r2
811324b0:	2910983a 	sll	r8,r5,r4
811324b4:	308ed83a 	srl	r7,r6,r2
811324b8:	3108983a 	sll	r4,r6,r4
811324bc:	2884d83a 	srl	r2,r5,r2
811324c0:	41ccb03a 	or	r6,r8,r7
811324c4:	2008c03a 	cmpne	r4,r4,zero
811324c8:	310cb03a 	or	r6,r6,r4
811324cc:	898dc83a 	sub	r6,r17,r6
811324d0:	89a3803a 	cmpltu	r17,r17,r6
811324d4:	1887c83a 	sub	r3,r3,r2
811324d8:	1c47c83a 	sub	r3,r3,r17
811324dc:	3023883a 	mov	r17,r6
811324e0:	1880202c 	andhi	r2,r3,128
811324e4:	10002326 	beq	r2,zero,81132574 <__subdf3+0x214>
811324e8:	04c02034 	movhi	r19,128
811324ec:	9cffffc4 	addi	r19,r19,-1
811324f0:	1ce6703a 	and	r19,r3,r19
811324f4:	98007a26 	beq	r19,zero,811326e0 <__subdf3+0x380>
811324f8:	9809883a 	mov	r4,r19
811324fc:	111d4540 	call	8111d454 <__clzsi2>
81132500:	113ffe04 	addi	r4,r2,-8
81132504:	00c007c4 	movi	r3,31
81132508:	19007b16 	blt	r3,r4,811326f8 <__subdf3+0x398>
8113250c:	00800804 	movi	r2,32
81132510:	1105c83a 	sub	r2,r2,r4
81132514:	8884d83a 	srl	r2,r17,r2
81132518:	9906983a 	sll	r3,r19,r4
8113251c:	8922983a 	sll	r17,r17,r4
81132520:	10c4b03a 	or	r2,r2,r3
81132524:	24007816 	blt	r4,r16,81132708 <__subdf3+0x3a8>
81132528:	2421c83a 	sub	r16,r4,r16
8113252c:	80c00044 	addi	r3,r16,1
81132530:	010007c4 	movi	r4,31
81132534:	20c09516 	blt	r4,r3,8113278c <__subdf3+0x42c>
81132538:	01400804 	movi	r5,32
8113253c:	28cbc83a 	sub	r5,r5,r3
81132540:	88c8d83a 	srl	r4,r17,r3
81132544:	8962983a 	sll	r17,r17,r5
81132548:	114a983a 	sll	r5,r2,r5
8113254c:	10c6d83a 	srl	r3,r2,r3
81132550:	8804c03a 	cmpne	r2,r17,zero
81132554:	290ab03a 	or	r5,r5,r4
81132558:	28a2b03a 	or	r17,r5,r2
8113255c:	0021883a 	mov	r16,zero
81132560:	003fa206 	br	811323ec <__reset+0xfb1123ec>
81132564:	2090b03a 	or	r8,r4,r2
81132568:	40018e26 	beq	r8,zero,81132ba4 <__subdf3+0x844>
8113256c:	1007883a 	mov	r3,r2
81132570:	2023883a 	mov	r17,r4
81132574:	888001cc 	andi	r2,r17,7
81132578:	103f9e1e 	bne	r2,zero,811323f4 <__reset+0xfb1123f4>
8113257c:	1804977a 	slli	r2,r3,29
81132580:	8822d0fa 	srli	r17,r17,3
81132584:	1810d0fa 	srli	r8,r3,3
81132588:	9100004c 	andi	r4,r18,1
8113258c:	1444b03a 	or	r2,r2,r17
81132590:	00c1ffc4 	movi	r3,2047
81132594:	80c02826 	beq	r16,r3,81132638 <__subdf3+0x2d8>
81132598:	01400434 	movhi	r5,16
8113259c:	297fffc4 	addi	r5,r5,-1
811325a0:	80e0703a 	and	r16,r16,r3
811325a4:	414a703a 	and	r5,r8,r5
811325a8:	003fa806 	br	8113244c <__reset+0xfb11244c>
811325ac:	0080630e 	bge	zero,r2,8113273c <__subdf3+0x3dc>
811325b0:	48003026 	beq	r9,zero,81132674 <__subdf3+0x314>
811325b4:	0101ffc4 	movi	r4,2047
811325b8:	813f8c26 	beq	r16,r4,811323ec <__reset+0xfb1123ec>
811325bc:	29402034 	orhi	r5,r5,128
811325c0:	01000e04 	movi	r4,56
811325c4:	2080a90e 	bge	r4,r2,8113286c <__subdf3+0x50c>
811325c8:	298cb03a 	or	r6,r5,r6
811325cc:	3012c03a 	cmpne	r9,r6,zero
811325d0:	0005883a 	mov	r2,zero
811325d4:	4c53883a 	add	r9,r9,r17
811325d8:	4c63803a 	cmpltu	r17,r9,r17
811325dc:	10c7883a 	add	r3,r2,r3
811325e0:	88c7883a 	add	r3,r17,r3
811325e4:	4823883a 	mov	r17,r9
811325e8:	1880202c 	andhi	r2,r3,128
811325ec:	1000d026 	beq	r2,zero,81132930 <__subdf3+0x5d0>
811325f0:	84000044 	addi	r16,r16,1
811325f4:	0081ffc4 	movi	r2,2047
811325f8:	8080fe26 	beq	r16,r2,811329f4 <__subdf3+0x694>
811325fc:	00bfe034 	movhi	r2,65408
81132600:	10bfffc4 	addi	r2,r2,-1
81132604:	1886703a 	and	r3,r3,r2
81132608:	880ad07a 	srli	r5,r17,1
8113260c:	180497fa 	slli	r2,r3,31
81132610:	8900004c 	andi	r4,r17,1
81132614:	2922b03a 	or	r17,r5,r4
81132618:	1806d07a 	srli	r3,r3,1
8113261c:	1462b03a 	or	r17,r2,r17
81132620:	3825883a 	mov	r18,r7
81132624:	003f7106 	br	811323ec <__reset+0xfb1123ec>
81132628:	2984b03a 	or	r2,r5,r6
8113262c:	103f6826 	beq	r2,zero,811323d0 <__reset+0xfb1123d0>
81132630:	39c03fcc 	andi	r7,r7,255
81132634:	003f6706 	br	811323d4 <__reset+0xfb1123d4>
81132638:	4086b03a 	or	r3,r8,r2
8113263c:	18015226 	beq	r3,zero,81132b88 <__subdf3+0x828>
81132640:	00c00434 	movhi	r3,16
81132644:	41400234 	orhi	r5,r8,8
81132648:	18ffffc4 	addi	r3,r3,-1
8113264c:	28ca703a 	and	r5,r5,r3
81132650:	003f7e06 	br	8113244c <__reset+0xfb11244c>
81132654:	10bfffc4 	addi	r2,r2,-1
81132658:	1000491e 	bne	r2,zero,81132780 <__subdf3+0x420>
8113265c:	898fc83a 	sub	r7,r17,r6
81132660:	89e3803a 	cmpltu	r17,r17,r7
81132664:	1947c83a 	sub	r3,r3,r5
81132668:	1c47c83a 	sub	r3,r3,r17
8113266c:	3823883a 	mov	r17,r7
81132670:	003f9b06 	br	811324e0 <__reset+0xfb1124e0>
81132674:	2988b03a 	or	r4,r5,r6
81132678:	203f5c26 	beq	r4,zero,811323ec <__reset+0xfb1123ec>
8113267c:	10bfffc4 	addi	r2,r2,-1
81132680:	1000931e 	bne	r2,zero,811328d0 <__subdf3+0x570>
81132684:	898d883a 	add	r6,r17,r6
81132688:	3463803a 	cmpltu	r17,r6,r17
8113268c:	1947883a 	add	r3,r3,r5
81132690:	88c7883a 	add	r3,r17,r3
81132694:	3023883a 	mov	r17,r6
81132698:	003fd306 	br	811325e8 <__reset+0xfb1125e8>
8113269c:	1000541e 	bne	r2,zero,811327f0 <__subdf3+0x490>
811326a0:	80800044 	addi	r2,r16,1
811326a4:	1081ffcc 	andi	r2,r2,2047
811326a8:	01000044 	movi	r4,1
811326ac:	2080a20e 	bge	r4,r2,81132938 <__subdf3+0x5d8>
811326b0:	8989c83a 	sub	r4,r17,r6
811326b4:	8905803a 	cmpltu	r2,r17,r4
811326b8:	1967c83a 	sub	r19,r3,r5
811326bc:	98a7c83a 	sub	r19,r19,r2
811326c0:	9880202c 	andhi	r2,r19,128
811326c4:	10006326 	beq	r2,zero,81132854 <__subdf3+0x4f4>
811326c8:	3463c83a 	sub	r17,r6,r17
811326cc:	28c7c83a 	sub	r3,r5,r3
811326d0:	344d803a 	cmpltu	r6,r6,r17
811326d4:	19a7c83a 	sub	r19,r3,r6
811326d8:	3825883a 	mov	r18,r7
811326dc:	983f861e 	bne	r19,zero,811324f8 <__reset+0xfb1124f8>
811326e0:	8809883a 	mov	r4,r17
811326e4:	111d4540 	call	8111d454 <__clzsi2>
811326e8:	10800804 	addi	r2,r2,32
811326ec:	113ffe04 	addi	r4,r2,-8
811326f0:	00c007c4 	movi	r3,31
811326f4:	193f850e 	bge	r3,r4,8113250c <__reset+0xfb11250c>
811326f8:	10bff604 	addi	r2,r2,-40
811326fc:	8884983a 	sll	r2,r17,r2
81132700:	0023883a 	mov	r17,zero
81132704:	243f880e 	bge	r4,r16,81132528 <__reset+0xfb112528>
81132708:	00ffe034 	movhi	r3,65408
8113270c:	18ffffc4 	addi	r3,r3,-1
81132710:	8121c83a 	sub	r16,r16,r4
81132714:	10c6703a 	and	r3,r2,r3
81132718:	003f3406 	br	811323ec <__reset+0xfb1123ec>
8113271c:	9100004c 	andi	r4,r18,1
81132720:	000b883a 	mov	r5,zero
81132724:	0005883a 	mov	r2,zero
81132728:	003f4806 	br	8113244c <__reset+0xfb11244c>
8113272c:	298cb03a 	or	r6,r5,r6
81132730:	300cc03a 	cmpne	r6,r6,zero
81132734:	0005883a 	mov	r2,zero
81132738:	003f6406 	br	811324cc <__reset+0xfb1124cc>
8113273c:	10009a1e 	bne	r2,zero,811329a8 <__subdf3+0x648>
81132740:	82400044 	addi	r9,r16,1
81132744:	4881ffcc 	andi	r2,r9,2047
81132748:	02800044 	movi	r10,1
8113274c:	5080670e 	bge	r10,r2,811328ec <__subdf3+0x58c>
81132750:	0081ffc4 	movi	r2,2047
81132754:	4880af26 	beq	r9,r2,81132a14 <__subdf3+0x6b4>
81132758:	898d883a 	add	r6,r17,r6
8113275c:	1945883a 	add	r2,r3,r5
81132760:	3447803a 	cmpltu	r3,r6,r17
81132764:	1887883a 	add	r3,r3,r2
81132768:	182297fa 	slli	r17,r3,31
8113276c:	300cd07a 	srli	r6,r6,1
81132770:	1806d07a 	srli	r3,r3,1
81132774:	4821883a 	mov	r16,r9
81132778:	89a2b03a 	or	r17,r17,r6
8113277c:	003f1b06 	br	811323ec <__reset+0xfb1123ec>
81132780:	0101ffc4 	movi	r4,2047
81132784:	813f441e 	bne	r16,r4,81132498 <__reset+0xfb112498>
81132788:	003f1806 	br	811323ec <__reset+0xfb1123ec>
8113278c:	843ff844 	addi	r16,r16,-31
81132790:	01400804 	movi	r5,32
81132794:	1408d83a 	srl	r4,r2,r16
81132798:	19405026 	beq	r3,r5,811328dc <__subdf3+0x57c>
8113279c:	01401004 	movi	r5,64
811327a0:	28c7c83a 	sub	r3,r5,r3
811327a4:	10c4983a 	sll	r2,r2,r3
811327a8:	88a2b03a 	or	r17,r17,r2
811327ac:	8822c03a 	cmpne	r17,r17,zero
811327b0:	2462b03a 	or	r17,r4,r17
811327b4:	0007883a 	mov	r3,zero
811327b8:	0021883a 	mov	r16,zero
811327bc:	003f6d06 	br	81132574 <__reset+0xfb112574>
811327c0:	11fff804 	addi	r7,r2,-32
811327c4:	01000804 	movi	r4,32
811327c8:	29ced83a 	srl	r7,r5,r7
811327cc:	11004526 	beq	r2,r4,811328e4 <__subdf3+0x584>
811327d0:	01001004 	movi	r4,64
811327d4:	2089c83a 	sub	r4,r4,r2
811327d8:	2904983a 	sll	r2,r5,r4
811327dc:	118cb03a 	or	r6,r2,r6
811327e0:	300cc03a 	cmpne	r6,r6,zero
811327e4:	398cb03a 	or	r6,r7,r6
811327e8:	0005883a 	mov	r2,zero
811327ec:	003f3706 	br	811324cc <__reset+0xfb1124cc>
811327f0:	80002a26 	beq	r16,zero,8113289c <__subdf3+0x53c>
811327f4:	0101ffc4 	movi	r4,2047
811327f8:	49006626 	beq	r9,r4,81132994 <__subdf3+0x634>
811327fc:	0085c83a 	sub	r2,zero,r2
81132800:	18c02034 	orhi	r3,r3,128
81132804:	01000e04 	movi	r4,56
81132808:	20807e16 	blt	r4,r2,81132a04 <__subdf3+0x6a4>
8113280c:	010007c4 	movi	r4,31
81132810:	2080e716 	blt	r4,r2,81132bb0 <__subdf3+0x850>
81132814:	01000804 	movi	r4,32
81132818:	2089c83a 	sub	r4,r4,r2
8113281c:	1914983a 	sll	r10,r3,r4
81132820:	8890d83a 	srl	r8,r17,r2
81132824:	8908983a 	sll	r4,r17,r4
81132828:	1884d83a 	srl	r2,r3,r2
8113282c:	5222b03a 	or	r17,r10,r8
81132830:	2006c03a 	cmpne	r3,r4,zero
81132834:	88e2b03a 	or	r17,r17,r3
81132838:	3463c83a 	sub	r17,r6,r17
8113283c:	2885c83a 	sub	r2,r5,r2
81132840:	344d803a 	cmpltu	r6,r6,r17
81132844:	1187c83a 	sub	r3,r2,r6
81132848:	4821883a 	mov	r16,r9
8113284c:	3825883a 	mov	r18,r7
81132850:	003f2306 	br	811324e0 <__reset+0xfb1124e0>
81132854:	24d0b03a 	or	r8,r4,r19
81132858:	40001b1e 	bne	r8,zero,811328c8 <__subdf3+0x568>
8113285c:	0005883a 	mov	r2,zero
81132860:	0009883a 	mov	r4,zero
81132864:	0021883a 	mov	r16,zero
81132868:	003f4906 	br	81132590 <__reset+0xfb112590>
8113286c:	010007c4 	movi	r4,31
81132870:	20803a16 	blt	r4,r2,8113295c <__subdf3+0x5fc>
81132874:	01000804 	movi	r4,32
81132878:	2089c83a 	sub	r4,r4,r2
8113287c:	2912983a 	sll	r9,r5,r4
81132880:	3090d83a 	srl	r8,r6,r2
81132884:	3108983a 	sll	r4,r6,r4
81132888:	2884d83a 	srl	r2,r5,r2
8113288c:	4a12b03a 	or	r9,r9,r8
81132890:	2008c03a 	cmpne	r4,r4,zero
81132894:	4912b03a 	or	r9,r9,r4
81132898:	003f4e06 	br	811325d4 <__reset+0xfb1125d4>
8113289c:	1c48b03a 	or	r4,r3,r17
811328a0:	20003c26 	beq	r4,zero,81132994 <__subdf3+0x634>
811328a4:	0084303a 	nor	r2,zero,r2
811328a8:	1000381e 	bne	r2,zero,8113298c <__subdf3+0x62c>
811328ac:	3463c83a 	sub	r17,r6,r17
811328b0:	28c5c83a 	sub	r2,r5,r3
811328b4:	344d803a 	cmpltu	r6,r6,r17
811328b8:	1187c83a 	sub	r3,r2,r6
811328bc:	4821883a 	mov	r16,r9
811328c0:	3825883a 	mov	r18,r7
811328c4:	003f0606 	br	811324e0 <__reset+0xfb1124e0>
811328c8:	2023883a 	mov	r17,r4
811328cc:	003f0906 	br	811324f4 <__reset+0xfb1124f4>
811328d0:	0101ffc4 	movi	r4,2047
811328d4:	813f3a1e 	bne	r16,r4,811325c0 <__reset+0xfb1125c0>
811328d8:	003ec406 	br	811323ec <__reset+0xfb1123ec>
811328dc:	0005883a 	mov	r2,zero
811328e0:	003fb106 	br	811327a8 <__reset+0xfb1127a8>
811328e4:	0005883a 	mov	r2,zero
811328e8:	003fbc06 	br	811327dc <__reset+0xfb1127dc>
811328ec:	1c44b03a 	or	r2,r3,r17
811328f0:	80008e1e 	bne	r16,zero,81132b2c <__subdf3+0x7cc>
811328f4:	1000c826 	beq	r2,zero,81132c18 <__subdf3+0x8b8>
811328f8:	2984b03a 	or	r2,r5,r6
811328fc:	103ebb26 	beq	r2,zero,811323ec <__reset+0xfb1123ec>
81132900:	8989883a 	add	r4,r17,r6
81132904:	1945883a 	add	r2,r3,r5
81132908:	2447803a 	cmpltu	r3,r4,r17
8113290c:	1887883a 	add	r3,r3,r2
81132910:	1880202c 	andhi	r2,r3,128
81132914:	2023883a 	mov	r17,r4
81132918:	103f1626 	beq	r2,zero,81132574 <__reset+0xfb112574>
8113291c:	00bfe034 	movhi	r2,65408
81132920:	10bfffc4 	addi	r2,r2,-1
81132924:	5021883a 	mov	r16,r10
81132928:	1886703a 	and	r3,r3,r2
8113292c:	003eaf06 	br	811323ec <__reset+0xfb1123ec>
81132930:	3825883a 	mov	r18,r7
81132934:	003f0f06 	br	81132574 <__reset+0xfb112574>
81132938:	1c44b03a 	or	r2,r3,r17
8113293c:	8000251e 	bne	r16,zero,811329d4 <__subdf3+0x674>
81132940:	1000661e 	bne	r2,zero,81132adc <__subdf3+0x77c>
81132944:	2990b03a 	or	r8,r5,r6
81132948:	40009626 	beq	r8,zero,81132ba4 <__subdf3+0x844>
8113294c:	2807883a 	mov	r3,r5
81132950:	3023883a 	mov	r17,r6
81132954:	3825883a 	mov	r18,r7
81132958:	003ea406 	br	811323ec <__reset+0xfb1123ec>
8113295c:	127ff804 	addi	r9,r2,-32
81132960:	01000804 	movi	r4,32
81132964:	2a52d83a 	srl	r9,r5,r9
81132968:	11008c26 	beq	r2,r4,81132b9c <__subdf3+0x83c>
8113296c:	01001004 	movi	r4,64
81132970:	2085c83a 	sub	r2,r4,r2
81132974:	2884983a 	sll	r2,r5,r2
81132978:	118cb03a 	or	r6,r2,r6
8113297c:	300cc03a 	cmpne	r6,r6,zero
81132980:	4992b03a 	or	r9,r9,r6
81132984:	0005883a 	mov	r2,zero
81132988:	003f1206 	br	811325d4 <__reset+0xfb1125d4>
8113298c:	0101ffc4 	movi	r4,2047
81132990:	493f9c1e 	bne	r9,r4,81132804 <__reset+0xfb112804>
81132994:	2807883a 	mov	r3,r5
81132998:	3023883a 	mov	r17,r6
8113299c:	4821883a 	mov	r16,r9
811329a0:	3825883a 	mov	r18,r7
811329a4:	003e9106 	br	811323ec <__reset+0xfb1123ec>
811329a8:	80001f1e 	bne	r16,zero,81132a28 <__subdf3+0x6c8>
811329ac:	1c48b03a 	or	r4,r3,r17
811329b0:	20005a26 	beq	r4,zero,81132b1c <__subdf3+0x7bc>
811329b4:	0084303a 	nor	r2,zero,r2
811329b8:	1000561e 	bne	r2,zero,81132b14 <__subdf3+0x7b4>
811329bc:	89a3883a 	add	r17,r17,r6
811329c0:	1945883a 	add	r2,r3,r5
811329c4:	898d803a 	cmpltu	r6,r17,r6
811329c8:	3087883a 	add	r3,r6,r2
811329cc:	4821883a 	mov	r16,r9
811329d0:	003f0506 	br	811325e8 <__reset+0xfb1125e8>
811329d4:	10002b1e 	bne	r2,zero,81132a84 <__subdf3+0x724>
811329d8:	2984b03a 	or	r2,r5,r6
811329dc:	10008026 	beq	r2,zero,81132be0 <__subdf3+0x880>
811329e0:	2807883a 	mov	r3,r5
811329e4:	3023883a 	mov	r17,r6
811329e8:	3825883a 	mov	r18,r7
811329ec:	0401ffc4 	movi	r16,2047
811329f0:	003e7e06 	br	811323ec <__reset+0xfb1123ec>
811329f4:	3809883a 	mov	r4,r7
811329f8:	0011883a 	mov	r8,zero
811329fc:	0005883a 	mov	r2,zero
81132a00:	003ee306 	br	81132590 <__reset+0xfb112590>
81132a04:	1c62b03a 	or	r17,r3,r17
81132a08:	8822c03a 	cmpne	r17,r17,zero
81132a0c:	0005883a 	mov	r2,zero
81132a10:	003f8906 	br	81132838 <__reset+0xfb112838>
81132a14:	3809883a 	mov	r4,r7
81132a18:	4821883a 	mov	r16,r9
81132a1c:	0011883a 	mov	r8,zero
81132a20:	0005883a 	mov	r2,zero
81132a24:	003eda06 	br	81132590 <__reset+0xfb112590>
81132a28:	0101ffc4 	movi	r4,2047
81132a2c:	49003b26 	beq	r9,r4,81132b1c <__subdf3+0x7bc>
81132a30:	0085c83a 	sub	r2,zero,r2
81132a34:	18c02034 	orhi	r3,r3,128
81132a38:	01000e04 	movi	r4,56
81132a3c:	20806e16 	blt	r4,r2,81132bf8 <__subdf3+0x898>
81132a40:	010007c4 	movi	r4,31
81132a44:	20807716 	blt	r4,r2,81132c24 <__subdf3+0x8c4>
81132a48:	01000804 	movi	r4,32
81132a4c:	2089c83a 	sub	r4,r4,r2
81132a50:	1914983a 	sll	r10,r3,r4
81132a54:	8890d83a 	srl	r8,r17,r2
81132a58:	8908983a 	sll	r4,r17,r4
81132a5c:	1884d83a 	srl	r2,r3,r2
81132a60:	5222b03a 	or	r17,r10,r8
81132a64:	2006c03a 	cmpne	r3,r4,zero
81132a68:	88e2b03a 	or	r17,r17,r3
81132a6c:	89a3883a 	add	r17,r17,r6
81132a70:	1145883a 	add	r2,r2,r5
81132a74:	898d803a 	cmpltu	r6,r17,r6
81132a78:	3087883a 	add	r3,r6,r2
81132a7c:	4821883a 	mov	r16,r9
81132a80:	003ed906 	br	811325e8 <__reset+0xfb1125e8>
81132a84:	2984b03a 	or	r2,r5,r6
81132a88:	10004226 	beq	r2,zero,81132b94 <__subdf3+0x834>
81132a8c:	1808d0fa 	srli	r4,r3,3
81132a90:	8822d0fa 	srli	r17,r17,3
81132a94:	1806977a 	slli	r3,r3,29
81132a98:	2080022c 	andhi	r2,r4,8
81132a9c:	1c62b03a 	or	r17,r3,r17
81132aa0:	10000826 	beq	r2,zero,81132ac4 <__subdf3+0x764>
81132aa4:	2812d0fa 	srli	r9,r5,3
81132aa8:	4880022c 	andhi	r2,r9,8
81132aac:	1000051e 	bne	r2,zero,81132ac4 <__subdf3+0x764>
81132ab0:	300cd0fa 	srli	r6,r6,3
81132ab4:	2804977a 	slli	r2,r5,29
81132ab8:	4809883a 	mov	r4,r9
81132abc:	3825883a 	mov	r18,r7
81132ac0:	11a2b03a 	or	r17,r2,r6
81132ac4:	8806d77a 	srli	r3,r17,29
81132ac8:	200890fa 	slli	r4,r4,3
81132acc:	882290fa 	slli	r17,r17,3
81132ad0:	0401ffc4 	movi	r16,2047
81132ad4:	1906b03a 	or	r3,r3,r4
81132ad8:	003e4406 	br	811323ec <__reset+0xfb1123ec>
81132adc:	2984b03a 	or	r2,r5,r6
81132ae0:	103e4226 	beq	r2,zero,811323ec <__reset+0xfb1123ec>
81132ae4:	8989c83a 	sub	r4,r17,r6
81132ae8:	8911803a 	cmpltu	r8,r17,r4
81132aec:	1945c83a 	sub	r2,r3,r5
81132af0:	1205c83a 	sub	r2,r2,r8
81132af4:	1200202c 	andhi	r8,r2,128
81132af8:	403e9a26 	beq	r8,zero,81132564 <__reset+0xfb112564>
81132afc:	3463c83a 	sub	r17,r6,r17
81132b00:	28c5c83a 	sub	r2,r5,r3
81132b04:	344d803a 	cmpltu	r6,r6,r17
81132b08:	1187c83a 	sub	r3,r2,r6
81132b0c:	3825883a 	mov	r18,r7
81132b10:	003e3606 	br	811323ec <__reset+0xfb1123ec>
81132b14:	0101ffc4 	movi	r4,2047
81132b18:	493fc71e 	bne	r9,r4,81132a38 <__reset+0xfb112a38>
81132b1c:	2807883a 	mov	r3,r5
81132b20:	3023883a 	mov	r17,r6
81132b24:	4821883a 	mov	r16,r9
81132b28:	003e3006 	br	811323ec <__reset+0xfb1123ec>
81132b2c:	10003626 	beq	r2,zero,81132c08 <__subdf3+0x8a8>
81132b30:	2984b03a 	or	r2,r5,r6
81132b34:	10001726 	beq	r2,zero,81132b94 <__subdf3+0x834>
81132b38:	1808d0fa 	srli	r4,r3,3
81132b3c:	8822d0fa 	srli	r17,r17,3
81132b40:	1806977a 	slli	r3,r3,29
81132b44:	2080022c 	andhi	r2,r4,8
81132b48:	1c62b03a 	or	r17,r3,r17
81132b4c:	10000726 	beq	r2,zero,81132b6c <__subdf3+0x80c>
81132b50:	2812d0fa 	srli	r9,r5,3
81132b54:	4880022c 	andhi	r2,r9,8
81132b58:	1000041e 	bne	r2,zero,81132b6c <__subdf3+0x80c>
81132b5c:	300cd0fa 	srli	r6,r6,3
81132b60:	2804977a 	slli	r2,r5,29
81132b64:	4809883a 	mov	r4,r9
81132b68:	11a2b03a 	or	r17,r2,r6
81132b6c:	8806d77a 	srli	r3,r17,29
81132b70:	200890fa 	slli	r4,r4,3
81132b74:	882290fa 	slli	r17,r17,3
81132b78:	3825883a 	mov	r18,r7
81132b7c:	1906b03a 	or	r3,r3,r4
81132b80:	0401ffc4 	movi	r16,2047
81132b84:	003e1906 	br	811323ec <__reset+0xfb1123ec>
81132b88:	000b883a 	mov	r5,zero
81132b8c:	0005883a 	mov	r2,zero
81132b90:	003e2e06 	br	8113244c <__reset+0xfb11244c>
81132b94:	0401ffc4 	movi	r16,2047
81132b98:	003e1406 	br	811323ec <__reset+0xfb1123ec>
81132b9c:	0005883a 	mov	r2,zero
81132ba0:	003f7506 	br	81132978 <__reset+0xfb112978>
81132ba4:	0005883a 	mov	r2,zero
81132ba8:	0009883a 	mov	r4,zero
81132bac:	003e7806 	br	81132590 <__reset+0xfb112590>
81132bb0:	123ff804 	addi	r8,r2,-32
81132bb4:	01000804 	movi	r4,32
81132bb8:	1a10d83a 	srl	r8,r3,r8
81132bbc:	11002526 	beq	r2,r4,81132c54 <__subdf3+0x8f4>
81132bc0:	01001004 	movi	r4,64
81132bc4:	2085c83a 	sub	r2,r4,r2
81132bc8:	1884983a 	sll	r2,r3,r2
81132bcc:	1444b03a 	or	r2,r2,r17
81132bd0:	1004c03a 	cmpne	r2,r2,zero
81132bd4:	40a2b03a 	or	r17,r8,r2
81132bd8:	0005883a 	mov	r2,zero
81132bdc:	003f1606 	br	81132838 <__reset+0xfb112838>
81132be0:	02000434 	movhi	r8,16
81132be4:	0009883a 	mov	r4,zero
81132be8:	423fffc4 	addi	r8,r8,-1
81132bec:	00bfffc4 	movi	r2,-1
81132bf0:	0401ffc4 	movi	r16,2047
81132bf4:	003e6606 	br	81132590 <__reset+0xfb112590>
81132bf8:	1c62b03a 	or	r17,r3,r17
81132bfc:	8822c03a 	cmpne	r17,r17,zero
81132c00:	0005883a 	mov	r2,zero
81132c04:	003f9906 	br	81132a6c <__reset+0xfb112a6c>
81132c08:	2807883a 	mov	r3,r5
81132c0c:	3023883a 	mov	r17,r6
81132c10:	0401ffc4 	movi	r16,2047
81132c14:	003df506 	br	811323ec <__reset+0xfb1123ec>
81132c18:	2807883a 	mov	r3,r5
81132c1c:	3023883a 	mov	r17,r6
81132c20:	003df206 	br	811323ec <__reset+0xfb1123ec>
81132c24:	123ff804 	addi	r8,r2,-32
81132c28:	01000804 	movi	r4,32
81132c2c:	1a10d83a 	srl	r8,r3,r8
81132c30:	11000a26 	beq	r2,r4,81132c5c <__subdf3+0x8fc>
81132c34:	01001004 	movi	r4,64
81132c38:	2085c83a 	sub	r2,r4,r2
81132c3c:	1884983a 	sll	r2,r3,r2
81132c40:	1444b03a 	or	r2,r2,r17
81132c44:	1004c03a 	cmpne	r2,r2,zero
81132c48:	40a2b03a 	or	r17,r8,r2
81132c4c:	0005883a 	mov	r2,zero
81132c50:	003f8606 	br	81132a6c <__reset+0xfb112a6c>
81132c54:	0005883a 	mov	r2,zero
81132c58:	003fdc06 	br	81132bcc <__reset+0xfb112bcc>
81132c5c:	0005883a 	mov	r2,zero
81132c60:	003ff706 	br	81132c40 <__reset+0xfb112c40>

81132c64 <__fixdfsi>:
81132c64:	280cd53a 	srli	r6,r5,20
81132c68:	00c00434 	movhi	r3,16
81132c6c:	18ffffc4 	addi	r3,r3,-1
81132c70:	3181ffcc 	andi	r6,r6,2047
81132c74:	01c0ff84 	movi	r7,1022
81132c78:	28c6703a 	and	r3,r5,r3
81132c7c:	280ad7fa 	srli	r5,r5,31
81132c80:	3980120e 	bge	r7,r6,81132ccc <__fixdfsi+0x68>
81132c84:	00810744 	movi	r2,1053
81132c88:	11800c16 	blt	r2,r6,81132cbc <__fixdfsi+0x58>
81132c8c:	00810cc4 	movi	r2,1075
81132c90:	1185c83a 	sub	r2,r2,r6
81132c94:	01c007c4 	movi	r7,31
81132c98:	18c00434 	orhi	r3,r3,16
81132c9c:	38800d16 	blt	r7,r2,81132cd4 <__fixdfsi+0x70>
81132ca0:	31befb44 	addi	r6,r6,-1043
81132ca4:	2084d83a 	srl	r2,r4,r2
81132ca8:	1986983a 	sll	r3,r3,r6
81132cac:	1884b03a 	or	r2,r3,r2
81132cb0:	28000726 	beq	r5,zero,81132cd0 <__fixdfsi+0x6c>
81132cb4:	0085c83a 	sub	r2,zero,r2
81132cb8:	f800283a 	ret
81132cbc:	00a00034 	movhi	r2,32768
81132cc0:	10bfffc4 	addi	r2,r2,-1
81132cc4:	2885883a 	add	r2,r5,r2
81132cc8:	f800283a 	ret
81132ccc:	0005883a 	mov	r2,zero
81132cd0:	f800283a 	ret
81132cd4:	008104c4 	movi	r2,1043
81132cd8:	1185c83a 	sub	r2,r2,r6
81132cdc:	1884d83a 	srl	r2,r3,r2
81132ce0:	003ff306 	br	81132cb0 <__reset+0xfb112cb0>

81132ce4 <__floatsidf>:
81132ce4:	defffd04 	addi	sp,sp,-12
81132ce8:	de00012e 	bgeu	sp,et,81132cf0 <__floatsidf+0xc>
81132cec:	003b68fa 	trap	3
81132cf0:	dfc00215 	stw	ra,8(sp)
81132cf4:	dc400115 	stw	r17,4(sp)
81132cf8:	dc000015 	stw	r16,0(sp)
81132cfc:	20002b26 	beq	r4,zero,81132dac <__floatsidf+0xc8>
81132d00:	2023883a 	mov	r17,r4
81132d04:	2020d7fa 	srli	r16,r4,31
81132d08:	20002d16 	blt	r4,zero,81132dc0 <__floatsidf+0xdc>
81132d0c:	8809883a 	mov	r4,r17
81132d10:	111d4540 	call	8111d454 <__clzsi2>
81132d14:	01410784 	movi	r5,1054
81132d18:	288bc83a 	sub	r5,r5,r2
81132d1c:	01010cc4 	movi	r4,1075
81132d20:	2149c83a 	sub	r4,r4,r5
81132d24:	00c007c4 	movi	r3,31
81132d28:	1900160e 	bge	r3,r4,81132d84 <__floatsidf+0xa0>
81132d2c:	00c104c4 	movi	r3,1043
81132d30:	1947c83a 	sub	r3,r3,r5
81132d34:	88c6983a 	sll	r3,r17,r3
81132d38:	00800434 	movhi	r2,16
81132d3c:	10bfffc4 	addi	r2,r2,-1
81132d40:	1886703a 	and	r3,r3,r2
81132d44:	2941ffcc 	andi	r5,r5,2047
81132d48:	800d883a 	mov	r6,r16
81132d4c:	0005883a 	mov	r2,zero
81132d50:	280a953a 	slli	r5,r5,20
81132d54:	31803fcc 	andi	r6,r6,255
81132d58:	01000434 	movhi	r4,16
81132d5c:	300c97fa 	slli	r6,r6,31
81132d60:	213fffc4 	addi	r4,r4,-1
81132d64:	1906703a 	and	r3,r3,r4
81132d68:	1946b03a 	or	r3,r3,r5
81132d6c:	1986b03a 	or	r3,r3,r6
81132d70:	dfc00217 	ldw	ra,8(sp)
81132d74:	dc400117 	ldw	r17,4(sp)
81132d78:	dc000017 	ldw	r16,0(sp)
81132d7c:	dec00304 	addi	sp,sp,12
81132d80:	f800283a 	ret
81132d84:	00c002c4 	movi	r3,11
81132d88:	1887c83a 	sub	r3,r3,r2
81132d8c:	88c6d83a 	srl	r3,r17,r3
81132d90:	8904983a 	sll	r2,r17,r4
81132d94:	01000434 	movhi	r4,16
81132d98:	213fffc4 	addi	r4,r4,-1
81132d9c:	2941ffcc 	andi	r5,r5,2047
81132da0:	1906703a 	and	r3,r3,r4
81132da4:	800d883a 	mov	r6,r16
81132da8:	003fe906 	br	81132d50 <__reset+0xfb112d50>
81132dac:	000d883a 	mov	r6,zero
81132db0:	000b883a 	mov	r5,zero
81132db4:	0007883a 	mov	r3,zero
81132db8:	0005883a 	mov	r2,zero
81132dbc:	003fe406 	br	81132d50 <__reset+0xfb112d50>
81132dc0:	0123c83a 	sub	r17,zero,r4
81132dc4:	003fd106 	br	81132d0c <__reset+0xfb112d0c>

81132dc8 <__floatunsidf>:
81132dc8:	defffe04 	addi	sp,sp,-8
81132dcc:	de00012e 	bgeu	sp,et,81132dd4 <__floatunsidf+0xc>
81132dd0:	003b68fa 	trap	3
81132dd4:	dc000015 	stw	r16,0(sp)
81132dd8:	dfc00115 	stw	ra,4(sp)
81132ddc:	2021883a 	mov	r16,r4
81132de0:	20002226 	beq	r4,zero,81132e6c <__floatunsidf+0xa4>
81132de4:	111d4540 	call	8111d454 <__clzsi2>
81132de8:	01010784 	movi	r4,1054
81132dec:	2089c83a 	sub	r4,r4,r2
81132df0:	01810cc4 	movi	r6,1075
81132df4:	310dc83a 	sub	r6,r6,r4
81132df8:	00c007c4 	movi	r3,31
81132dfc:	1980120e 	bge	r3,r6,81132e48 <__floatunsidf+0x80>
81132e00:	00c104c4 	movi	r3,1043
81132e04:	1907c83a 	sub	r3,r3,r4
81132e08:	80ca983a 	sll	r5,r16,r3
81132e0c:	00800434 	movhi	r2,16
81132e10:	10bfffc4 	addi	r2,r2,-1
81132e14:	2101ffcc 	andi	r4,r4,2047
81132e18:	0021883a 	mov	r16,zero
81132e1c:	288a703a 	and	r5,r5,r2
81132e20:	2008953a 	slli	r4,r4,20
81132e24:	00c00434 	movhi	r3,16
81132e28:	18ffffc4 	addi	r3,r3,-1
81132e2c:	28c6703a 	and	r3,r5,r3
81132e30:	8005883a 	mov	r2,r16
81132e34:	1906b03a 	or	r3,r3,r4
81132e38:	dfc00117 	ldw	ra,4(sp)
81132e3c:	dc000017 	ldw	r16,0(sp)
81132e40:	dec00204 	addi	sp,sp,8
81132e44:	f800283a 	ret
81132e48:	00c002c4 	movi	r3,11
81132e4c:	188bc83a 	sub	r5,r3,r2
81132e50:	814ad83a 	srl	r5,r16,r5
81132e54:	00c00434 	movhi	r3,16
81132e58:	18ffffc4 	addi	r3,r3,-1
81132e5c:	81a0983a 	sll	r16,r16,r6
81132e60:	2101ffcc 	andi	r4,r4,2047
81132e64:	28ca703a 	and	r5,r5,r3
81132e68:	003fed06 	br	81132e20 <__reset+0xfb112e20>
81132e6c:	0009883a 	mov	r4,zero
81132e70:	000b883a 	mov	r5,zero
81132e74:	003fea06 	br	81132e20 <__reset+0xfb112e20>

81132e78 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81132e78:	defffb04 	addi	sp,sp,-20
81132e7c:	de00012e 	bgeu	sp,et,81132e84 <alt_busy_sleep+0xc>
81132e80:	003b68fa 	trap	3
81132e84:	df000415 	stw	fp,16(sp)
81132e88:	df000404 	addi	fp,sp,16
81132e8c:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81132e90:	008000c4 	movi	r2,3
81132e94:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
81132e98:	e0fffd17 	ldw	r3,-12(fp)
81132e9c:	008003f4 	movhi	r2,15
81132ea0:	10909004 	addi	r2,r2,16960
81132ea4:	1887383a 	mul	r3,r3,r2
81132ea8:	00817db4 	movhi	r2,1526
81132eac:	10b84004 	addi	r2,r2,-7936
81132eb0:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81132eb4:	00a00034 	movhi	r2,32768
81132eb8:	10bfffc4 	addi	r2,r2,-1
81132ebc:	10c5203a 	divu	r2,r2,r3
81132ec0:	e0ffff17 	ldw	r3,-4(fp)
81132ec4:	1885203a 	divu	r2,r3,r2
81132ec8:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81132ecc:	e0bffe17 	ldw	r2,-8(fp)
81132ed0:	10002526 	beq	r2,zero,81132f68 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
81132ed4:	e03ffc15 	stw	zero,-16(fp)
81132ed8:	00001406 	br	81132f2c <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81132edc:	00a00034 	movhi	r2,32768
81132ee0:	10bfffc4 	addi	r2,r2,-1
81132ee4:	10bfffc4 	addi	r2,r2,-1
81132ee8:	103ffe1e 	bne	r2,zero,81132ee4 <__reset+0xfb112ee4>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81132eec:	e0fffd17 	ldw	r3,-12(fp)
81132ef0:	008003f4 	movhi	r2,15
81132ef4:	10909004 	addi	r2,r2,16960
81132ef8:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81132efc:	00817db4 	movhi	r2,1526
81132f00:	10b84004 	addi	r2,r2,-7936
81132f04:	10c7203a 	divu	r3,r2,r3
81132f08:	00a00034 	movhi	r2,32768
81132f0c:	10bfffc4 	addi	r2,r2,-1
81132f10:	10c5203a 	divu	r2,r2,r3
81132f14:	e0ffff17 	ldw	r3,-4(fp)
81132f18:	1885c83a 	sub	r2,r3,r2
81132f1c:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81132f20:	e0bffc17 	ldw	r2,-16(fp)
81132f24:	10800044 	addi	r2,r2,1
81132f28:	e0bffc15 	stw	r2,-16(fp)
81132f2c:	e0fffc17 	ldw	r3,-16(fp)
81132f30:	e0bffe17 	ldw	r2,-8(fp)
81132f34:	18bfe916 	blt	r3,r2,81132edc <__reset+0xfb112edc>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81132f38:	e0fffd17 	ldw	r3,-12(fp)
81132f3c:	008003f4 	movhi	r2,15
81132f40:	10909004 	addi	r2,r2,16960
81132f44:	1887383a 	mul	r3,r3,r2
81132f48:	00817db4 	movhi	r2,1526
81132f4c:	10b84004 	addi	r2,r2,-7936
81132f50:	10c7203a 	divu	r3,r2,r3
81132f54:	e0bfff17 	ldw	r2,-4(fp)
81132f58:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81132f5c:	10bfffc4 	addi	r2,r2,-1
81132f60:	103ffe1e 	bne	r2,zero,81132f5c <__reset+0xfb112f5c>
81132f64:	00000b06 	br	81132f94 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81132f68:	e0fffd17 	ldw	r3,-12(fp)
81132f6c:	008003f4 	movhi	r2,15
81132f70:	10909004 	addi	r2,r2,16960
81132f74:	1887383a 	mul	r3,r3,r2
81132f78:	00817db4 	movhi	r2,1526
81132f7c:	10b84004 	addi	r2,r2,-7936
81132f80:	10c7203a 	divu	r3,r2,r3
81132f84:	e0bfff17 	ldw	r2,-4(fp)
81132f88:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81132f8c:	10bfffc4 	addi	r2,r2,-1
81132f90:	00bffe16 	blt	zero,r2,81132f8c <__reset+0xfb112f8c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81132f94:	0005883a 	mov	r2,zero
}
81132f98:	e037883a 	mov	sp,fp
81132f9c:	df000017 	ldw	fp,0(sp)
81132fa0:	dec00104 	addi	sp,sp,4
81132fa4:	f800283a 	ret

81132fa8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132fa8:	defffe04 	addi	sp,sp,-8
81132fac:	de00012e 	bgeu	sp,et,81132fb4 <alt_get_errno+0xc>
81132fb0:	003b68fa 	trap	3
81132fb4:	dfc00115 	stw	ra,4(sp)
81132fb8:	df000015 	stw	fp,0(sp)
81132fbc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81132fc0:	d0a01017 	ldw	r2,-32704(gp)
81132fc4:	10000326 	beq	r2,zero,81132fd4 <alt_get_errno+0x2c>
81132fc8:	d0a01017 	ldw	r2,-32704(gp)
81132fcc:	103ee83a 	callr	r2
81132fd0:	00000106 	br	81132fd8 <alt_get_errno+0x30>
81132fd4:	d0a07704 	addi	r2,gp,-32292
}
81132fd8:	e037883a 	mov	sp,fp
81132fdc:	dfc00117 	ldw	ra,4(sp)
81132fe0:	df000017 	ldw	fp,0(sp)
81132fe4:	dec00204 	addi	sp,sp,8
81132fe8:	f800283a 	ret

81132fec <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81132fec:	defffb04 	addi	sp,sp,-20
81132ff0:	de00012e 	bgeu	sp,et,81132ff8 <close+0xc>
81132ff4:	003b68fa 	trap	3
81132ff8:	dfc00415 	stw	ra,16(sp)
81132ffc:	df000315 	stw	fp,12(sp)
81133000:	df000304 	addi	fp,sp,12
81133004:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81133008:	e0bfff17 	ldw	r2,-4(fp)
8113300c:	10000616 	blt	r2,zero,81133028 <close+0x3c>
81133010:	e0bfff17 	ldw	r2,-4(fp)
81133014:	10c00324 	muli	r3,r2,12
81133018:	00a04574 	movhi	r2,33045
8113301c:	10b84b04 	addi	r2,r2,-7892
81133020:	1885883a 	add	r2,r3,r2
81133024:	00000106 	br	8113302c <close+0x40>
81133028:	0005883a 	mov	r2,zero
8113302c:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81133030:	e0bffd17 	ldw	r2,-12(fp)
81133034:	10001926 	beq	r2,zero,8113309c <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81133038:	e0bffd17 	ldw	r2,-12(fp)
8113303c:	10800017 	ldw	r2,0(r2)
81133040:	10800417 	ldw	r2,16(r2)
81133044:	10000626 	beq	r2,zero,81133060 <close+0x74>
81133048:	e0bffd17 	ldw	r2,-12(fp)
8113304c:	10800017 	ldw	r2,0(r2)
81133050:	10800417 	ldw	r2,16(r2)
81133054:	e13ffd17 	ldw	r4,-12(fp)
81133058:	103ee83a 	callr	r2
8113305c:	00000106 	br	81133064 <close+0x78>
81133060:	0005883a 	mov	r2,zero
81133064:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81133068:	e13fff17 	ldw	r4,-4(fp)
8113306c:	11345d00 	call	811345d0 <alt_release_fd>
    if (rval < 0)
81133070:	e0bffe17 	ldw	r2,-8(fp)
81133074:	1000070e 	bge	r2,zero,81133094 <close+0xa8>
    {
      ALT_ERRNO = -rval;
81133078:	1132fa80 	call	81132fa8 <alt_get_errno>
8113307c:	1007883a 	mov	r3,r2
81133080:	e0bffe17 	ldw	r2,-8(fp)
81133084:	0085c83a 	sub	r2,zero,r2
81133088:	18800015 	stw	r2,0(r3)
      return -1;
8113308c:	00bfffc4 	movi	r2,-1
81133090:	00000706 	br	811330b0 <close+0xc4>
    }
    return 0;
81133094:	0005883a 	mov	r2,zero
81133098:	00000506 	br	811330b0 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
8113309c:	1132fa80 	call	81132fa8 <alt_get_errno>
811330a0:	1007883a 	mov	r3,r2
811330a4:	00801444 	movi	r2,81
811330a8:	18800015 	stw	r2,0(r3)
    return -1;
811330ac:	00bfffc4 	movi	r2,-1
  }
}
811330b0:	e037883a 	mov	sp,fp
811330b4:	dfc00117 	ldw	ra,4(sp)
811330b8:	df000017 	ldw	fp,0(sp)
811330bc:	dec00204 	addi	sp,sp,8
811330c0:	f800283a 	ret

811330c4 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
811330c4:	deffff04 	addi	sp,sp,-4
811330c8:	de00012e 	bgeu	sp,et,811330d0 <alt_dcache_flush_all+0xc>
811330cc:	003b68fa 	trap	3
811330d0:	df000015 	stw	fp,0(sp)
811330d4:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
811330d8:	0001883a 	nop
811330dc:	e037883a 	mov	sp,fp
811330e0:	df000017 	ldw	fp,0(sp)
811330e4:	dec00104 	addi	sp,sp,4
811330e8:	f800283a 	ret

811330ec <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
811330ec:	defffc04 	addi	sp,sp,-16
811330f0:	de00012e 	bgeu	sp,et,811330f8 <alt_dev_null_write+0xc>
811330f4:	003b68fa 	trap	3
811330f8:	df000315 	stw	fp,12(sp)
811330fc:	df000304 	addi	fp,sp,12
81133100:	e13ffd15 	stw	r4,-12(fp)
81133104:	e17ffe15 	stw	r5,-8(fp)
81133108:	e1bfff15 	stw	r6,-4(fp)
  return len;
8113310c:	e0bfff17 	ldw	r2,-4(fp)
}
81133110:	e037883a 	mov	sp,fp
81133114:	df000017 	ldw	fp,0(sp)
81133118:	dec00104 	addi	sp,sp,4
8113311c:	f800283a 	ret

81133120 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81133120:	defffe04 	addi	sp,sp,-8
81133124:	de00012e 	bgeu	sp,et,8113312c <alt_get_errno+0xc>
81133128:	003b68fa 	trap	3
8113312c:	dfc00115 	stw	ra,4(sp)
81133130:	df000015 	stw	fp,0(sp)
81133134:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81133138:	d0a01017 	ldw	r2,-32704(gp)
8113313c:	10000326 	beq	r2,zero,8113314c <alt_get_errno+0x2c>
81133140:	d0a01017 	ldw	r2,-32704(gp)
81133144:	103ee83a 	callr	r2
81133148:	00000106 	br	81133150 <alt_get_errno+0x30>
8113314c:	d0a07704 	addi	r2,gp,-32292
}
81133150:	e037883a 	mov	sp,fp
81133154:	dfc00117 	ldw	ra,4(sp)
81133158:	df000017 	ldw	fp,0(sp)
8113315c:	dec00204 	addi	sp,sp,8
81133160:	f800283a 	ret

81133164 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81133164:	defffb04 	addi	sp,sp,-20
81133168:	de00012e 	bgeu	sp,et,81133170 <fstat+0xc>
8113316c:	003b68fa 	trap	3
81133170:	dfc00415 	stw	ra,16(sp)
81133174:	df000315 	stw	fp,12(sp)
81133178:	df000304 	addi	fp,sp,12
8113317c:	e13ffe15 	stw	r4,-8(fp)
81133180:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81133184:	e0bffe17 	ldw	r2,-8(fp)
81133188:	10000616 	blt	r2,zero,811331a4 <fstat+0x40>
8113318c:	e0bffe17 	ldw	r2,-8(fp)
81133190:	10c00324 	muli	r3,r2,12
81133194:	00a04574 	movhi	r2,33045
81133198:	10b84b04 	addi	r2,r2,-7892
8113319c:	1885883a 	add	r2,r3,r2
811331a0:	00000106 	br	811331a8 <fstat+0x44>
811331a4:	0005883a 	mov	r2,zero
811331a8:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
811331ac:	e0bffd17 	ldw	r2,-12(fp)
811331b0:	10001026 	beq	r2,zero,811331f4 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
811331b4:	e0bffd17 	ldw	r2,-12(fp)
811331b8:	10800017 	ldw	r2,0(r2)
811331bc:	10800817 	ldw	r2,32(r2)
811331c0:	10000726 	beq	r2,zero,811331e0 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
811331c4:	e0bffd17 	ldw	r2,-12(fp)
811331c8:	10800017 	ldw	r2,0(r2)
811331cc:	10800817 	ldw	r2,32(r2)
811331d0:	e17fff17 	ldw	r5,-4(fp)
811331d4:	e13ffd17 	ldw	r4,-12(fp)
811331d8:	103ee83a 	callr	r2
811331dc:	00000a06 	br	81133208 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
811331e0:	e0bfff17 	ldw	r2,-4(fp)
811331e4:	00c80004 	movi	r3,8192
811331e8:	10c00115 	stw	r3,4(r2)
      return 0;
811331ec:	0005883a 	mov	r2,zero
811331f0:	00000506 	br	81133208 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811331f4:	11331200 	call	81133120 <alt_get_errno>
811331f8:	1007883a 	mov	r3,r2
811331fc:	00801444 	movi	r2,81
81133200:	18800015 	stw	r2,0(r3)
    return -1;
81133204:	00bfffc4 	movi	r2,-1
  }
}
81133208:	e037883a 	mov	sp,fp
8113320c:	dfc00117 	ldw	ra,4(sp)
81133210:	df000017 	ldw	fp,0(sp)
81133214:	dec00204 	addi	sp,sp,8
81133218:	f800283a 	ret

8113321c <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
8113321c:	defff004 	addi	sp,sp,-64
81133220:	de00012e 	bgeu	sp,et,81133228 <alt_irq_register+0xc>
81133224:	003b68fa 	trap	3
81133228:	df000f15 	stw	fp,60(sp)
8113322c:	df000f04 	addi	fp,sp,60
81133230:	e13ffd15 	stw	r4,-12(fp)
81133234:	e17ffe15 	stw	r5,-8(fp)
81133238:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
8113323c:	00bffa84 	movi	r2,-22
81133240:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81133244:	e0bffd17 	ldw	r2,-12(fp)
81133248:	10800828 	cmpgeui	r2,r2,32
8113324c:	1000501e 	bne	r2,zero,81133390 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133250:	0005303a 	rdctl	r2,status
81133254:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133258:	e0fff617 	ldw	r3,-40(fp)
8113325c:	00bfff84 	movi	r2,-2
81133260:	1884703a 	and	r2,r3,r2
81133264:	1001703a 	wrctl	status,r2
  
  return context;
81133268:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
8113326c:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81133270:	00a045f4 	movhi	r2,33047
81133274:	10a5e604 	addi	r2,r2,-26728
81133278:	e0fffd17 	ldw	r3,-12(fp)
8113327c:	180690fa 	slli	r3,r3,3
81133280:	10c5883a 	add	r2,r2,r3
81133284:	e0ffff17 	ldw	r3,-4(fp)
81133288:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
8113328c:	00a045f4 	movhi	r2,33047
81133290:	10a5e604 	addi	r2,r2,-26728
81133294:	e0fffd17 	ldw	r3,-12(fp)
81133298:	180690fa 	slli	r3,r3,3
8113329c:	10c5883a 	add	r2,r2,r3
811332a0:	10800104 	addi	r2,r2,4
811332a4:	e0fffe17 	ldw	r3,-8(fp)
811332a8:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
811332ac:	e0bfff17 	ldw	r2,-4(fp)
811332b0:	10001926 	beq	r2,zero,81133318 <alt_irq_register+0xfc>
811332b4:	e0bffd17 	ldw	r2,-12(fp)
811332b8:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811332bc:	0005303a 	rdctl	r2,status
811332c0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811332c4:	e0fff717 	ldw	r3,-36(fp)
811332c8:	00bfff84 	movi	r2,-2
811332cc:	1884703a 	and	r2,r3,r2
811332d0:	1001703a 	wrctl	status,r2
  
  return context;
811332d4:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811332d8:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
811332dc:	00c00044 	movi	r3,1
811332e0:	e0bff217 	ldw	r2,-56(fp)
811332e4:	1884983a 	sll	r2,r3,r2
811332e8:	1007883a 	mov	r3,r2
811332ec:	d0a07f17 	ldw	r2,-32260(gp)
811332f0:	1884b03a 	or	r2,r3,r2
811332f4:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811332f8:	d0a07f17 	ldw	r2,-32260(gp)
811332fc:	100170fa 	wrctl	ienable,r2
81133300:	e0bff817 	ldw	r2,-32(fp)
81133304:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133308:	e0bff917 	ldw	r2,-28(fp)
8113330c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81133310:	0005883a 	mov	r2,zero
81133314:	00001906 	br	8113337c <alt_irq_register+0x160>
81133318:	e0bffd17 	ldw	r2,-12(fp)
8113331c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133320:	0005303a 	rdctl	r2,status
81133324:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133328:	e0fffa17 	ldw	r3,-24(fp)
8113332c:	00bfff84 	movi	r2,-2
81133330:	1884703a 	and	r2,r3,r2
81133334:	1001703a 	wrctl	status,r2
  
  return context;
81133338:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8113333c:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81133340:	00c00044 	movi	r3,1
81133344:	e0bff417 	ldw	r2,-48(fp)
81133348:	1884983a 	sll	r2,r3,r2
8113334c:	0084303a 	nor	r2,zero,r2
81133350:	1007883a 	mov	r3,r2
81133354:	d0a07f17 	ldw	r2,-32260(gp)
81133358:	1884703a 	and	r2,r3,r2
8113335c:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81133360:	d0a07f17 	ldw	r2,-32260(gp)
81133364:	100170fa 	wrctl	ienable,r2
81133368:	e0bffb17 	ldw	r2,-20(fp)
8113336c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133370:	e0bffc17 	ldw	r2,-16(fp)
81133374:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81133378:	0005883a 	mov	r2,zero
8113337c:	e0bff115 	stw	r2,-60(fp)
81133380:	e0bff317 	ldw	r2,-52(fp)
81133384:	e0bff515 	stw	r2,-44(fp)
81133388:	e0bff517 	ldw	r2,-44(fp)
8113338c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81133390:	e0bff117 	ldw	r2,-60(fp)
}
81133394:	e037883a 	mov	sp,fp
81133398:	df000017 	ldw	fp,0(sp)
8113339c:	dec00104 	addi	sp,sp,4
811333a0:	f800283a 	ret

811333a4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811333a4:	defffe04 	addi	sp,sp,-8
811333a8:	de00012e 	bgeu	sp,et,811333b0 <alt_get_errno+0xc>
811333ac:	003b68fa 	trap	3
811333b0:	dfc00115 	stw	ra,4(sp)
811333b4:	df000015 	stw	fp,0(sp)
811333b8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811333bc:	d0a01017 	ldw	r2,-32704(gp)
811333c0:	10000326 	beq	r2,zero,811333d0 <alt_get_errno+0x2c>
811333c4:	d0a01017 	ldw	r2,-32704(gp)
811333c8:	103ee83a 	callr	r2
811333cc:	00000106 	br	811333d4 <alt_get_errno+0x30>
811333d0:	d0a07704 	addi	r2,gp,-32292
}
811333d4:	e037883a 	mov	sp,fp
811333d8:	dfc00117 	ldw	ra,4(sp)
811333dc:	df000017 	ldw	fp,0(sp)
811333e0:	dec00204 	addi	sp,sp,8
811333e4:	f800283a 	ret

811333e8 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
811333e8:	deffed04 	addi	sp,sp,-76
811333ec:	de00012e 	bgeu	sp,et,811333f4 <isatty+0xc>
811333f0:	003b68fa 	trap	3
811333f4:	dfc01215 	stw	ra,72(sp)
811333f8:	df001115 	stw	fp,68(sp)
811333fc:	df001104 	addi	fp,sp,68
81133400:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81133404:	e0bfff17 	ldw	r2,-4(fp)
81133408:	10000616 	blt	r2,zero,81133424 <isatty+0x3c>
8113340c:	e0bfff17 	ldw	r2,-4(fp)
81133410:	10c00324 	muli	r3,r2,12
81133414:	00a04574 	movhi	r2,33045
81133418:	10b84b04 	addi	r2,r2,-7892
8113341c:	1885883a 	add	r2,r3,r2
81133420:	00000106 	br	81133428 <isatty+0x40>
81133424:	0005883a 	mov	r2,zero
81133428:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
8113342c:	e0bfef17 	ldw	r2,-68(fp)
81133430:	10000e26 	beq	r2,zero,8113346c <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81133434:	e0bfef17 	ldw	r2,-68(fp)
81133438:	10800017 	ldw	r2,0(r2)
8113343c:	10800817 	ldw	r2,32(r2)
81133440:	1000021e 	bne	r2,zero,8113344c <isatty+0x64>
    {
      return 1;
81133444:	00800044 	movi	r2,1
81133448:	00000d06 	br	81133480 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
8113344c:	e0bff004 	addi	r2,fp,-64
81133450:	100b883a 	mov	r5,r2
81133454:	e13fff17 	ldw	r4,-4(fp)
81133458:	11331640 	call	81133164 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
8113345c:	e0bff117 	ldw	r2,-60(fp)
81133460:	10880020 	cmpeqi	r2,r2,8192
81133464:	10803fcc 	andi	r2,r2,255
81133468:	00000506 	br	81133480 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8113346c:	11333a40 	call	811333a4 <alt_get_errno>
81133470:	1007883a 	mov	r3,r2
81133474:	00801444 	movi	r2,81
81133478:	18800015 	stw	r2,0(r3)
    return 0;
8113347c:	0005883a 	mov	r2,zero
  }
}
81133480:	e037883a 	mov	sp,fp
81133484:	dfc00117 	ldw	ra,4(sp)
81133488:	df000017 	ldw	fp,0(sp)
8113348c:	dec00204 	addi	sp,sp,8
81133490:	f800283a 	ret

81133494 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81133494:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81133498:	318c2404 	addi	r6,r6,12432

8113349c <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
8113349c:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
811334a0:	01c00826 	beq	zero,r7,811334c4 <end_tx>

811334a4 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
811334a4:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
811334a8:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
811334ac:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
811334b0:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
811334b4:	283ffb26 	beq	r5,zero,811334a4 <__reset+0xfb1134a4>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
811334b8:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
811334bc:	21000044 	addi	r4,r4,1
	br tx_next_char
811334c0:	003ff606 	br	8113349c <__reset+0xfb11349c>

811334c4 <end_tx>:
end_tx:	
        ret
811334c4:	f800283a 	ret

811334c8 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
811334c8:	defffd04 	addi	sp,sp,-12
811334cc:	de00012e 	bgeu	sp,et,811334d4 <alt_log_txchar+0xc>
811334d0:	003b68fa 	trap	3
811334d4:	df000215 	stw	fp,8(sp)
811334d8:	df000204 	addi	fp,sp,8
811334dc:	e13ffe15 	stw	r4,-8(fp)
811334e0:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
811334e4:	0001883a 	nop
811334e8:	e0bfff17 	ldw	r2,-4(fp)
811334ec:	10800104 	addi	r2,r2,4
811334f0:	10800037 	ldwio	r2,0(r2)
811334f4:	10bfffec 	andhi	r2,r2,65535
811334f8:	103ffb26 	beq	r2,zero,811334e8 <__reset+0xfb1134e8>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
811334fc:	e0bfff17 	ldw	r2,-4(fp)
81133500:	e0fffe17 	ldw	r3,-8(fp)
81133504:	10c00035 	stwio	r3,0(r2)
}
81133508:	0001883a 	nop
8113350c:	e037883a 	mov	sp,fp
81133510:	df000017 	ldw	fp,0(sp)
81133514:	dec00104 	addi	sp,sp,4
81133518:	f800283a 	ret

8113351c <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
8113351c:	defffb04 	addi	sp,sp,-20
81133520:	de00012e 	bgeu	sp,et,81133528 <alt_log_repchar+0xc>
81133524:	003b68fa 	trap	3
81133528:	dfc00415 	stw	ra,16(sp)
8113352c:	df000315 	stw	fp,12(sp)
81133530:	df000304 	addi	fp,sp,12
81133534:	2005883a 	mov	r2,r4
81133538:	e17ffe15 	stw	r5,-8(fp)
8113353c:	e1bfff15 	stw	r6,-4(fp)
81133540:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
81133544:	00000506 	br	8113355c <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81133548:	e0bffd07 	ldb	r2,-12(fp)
8113354c:	e0ffff17 	ldw	r3,-4(fp)
81133550:	180b883a 	mov	r5,r3
81133554:	1009883a 	mov	r4,r2
81133558:	11334c80 	call	811334c8 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
8113355c:	e0bffe17 	ldw	r2,-8(fp)
81133560:	10ffffc4 	addi	r3,r2,-1
81133564:	e0fffe15 	stw	r3,-8(fp)
81133568:	00bff716 	blt	zero,r2,81133548 <__reset+0xfb113548>
    alt_log_txchar(c,(char*) base);
}
8113356c:	0001883a 	nop
81133570:	e037883a 	mov	sp,fp
81133574:	dfc00117 	ldw	ra,4(sp)
81133578:	df000017 	ldw	fp,0(sp)
8113357c:	dec00204 	addi	sp,sp,8
81133580:	f800283a 	ret

81133584 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81133584:	deffe904 	addi	sp,sp,-92
81133588:	de00012e 	bgeu	sp,et,81133590 <alt_log_private_printf+0xc>
8113358c:	003b68fa 	trap	3
81133590:	dfc01615 	stw	ra,88(sp)
81133594:	df001515 	stw	fp,84(sp)
81133598:	dc001415 	stw	r16,80(sp)
8113359c:	df001504 	addi	fp,sp,84
811335a0:	e13ffc15 	stw	r4,-16(fp)
811335a4:	e17ffd15 	stw	r5,-12(fp)
811335a8:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
811335ac:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
811335b0:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
811335b4:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
811335b8:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
811335bc:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
811335c0:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
811335c4:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
811335c8:	e0bffc17 	ldw	r2,-16(fp)
811335cc:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
811335d0:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
811335d4:	00014b06 	br	81133b04 <alt_log_private_printf+0x580>
    {
    switch(state)
811335d8:	e0bfec17 	ldw	r2,-80(fp)
811335dc:	10c00060 	cmpeqi	r3,r2,1
811335e0:	18001b1e 	bne	r3,zero,81133650 <alt_log_private_printf+0xcc>
811335e4:	10c000a0 	cmpeqi	r3,r2,2
811335e8:	18002d1e 	bne	r3,zero,811336a0 <alt_log_private_printf+0x11c>
811335ec:	10000126 	beq	r2,zero,811335f4 <alt_log_private_printf+0x70>
811335f0:	00014406 	br	81133b04 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
811335f4:	e0bffb07 	ldb	r2,-20(fp)
811335f8:	10800958 	cmpnei	r2,r2,37
811335fc:	10000e1e 	bne	r2,zero,81133638 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81133600:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81133604:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81133608:	00800284 	movi	r2,10
8113360c:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81133610:	00800044 	movi	r2,1
81133614:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81133618:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
8113361c:	00bfffc4 	movi	r2,-1
81133620:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81133624:	00bfffc4 	movi	r2,-1
81133628:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
8113362c:	00800044 	movi	r2,1
81133630:	e0bfec15 	stw	r2,-80(fp)
81133634:	00013306 	br	81133b04 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81133638:	e0bffb07 	ldb	r2,-20(fp)
8113363c:	e0fffd17 	ldw	r3,-12(fp)
81133640:	180b883a 	mov	r5,r3
81133644:	1009883a 	mov	r4,r2
81133648:	11334c80 	call	811334c8 <alt_log_txchar>
        }
        break;
8113364c:	00012d06 	br	81133b04 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81133650:	e0bffb07 	ldb	r2,-20(fp)
81133654:	10800c18 	cmpnei	r2,r2,48
81133658:	1000051e 	bne	r2,zero,81133670 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
8113365c:	00800044 	movi	r2,1
81133660:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81133664:	00800084 	movi	r2,2
81133668:	e0bfec15 	stw	r2,-80(fp)
8113366c:	00012506 	br	81133b04 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81133670:	e0bffb07 	ldb	r2,-20(fp)
81133674:	10800958 	cmpnei	r2,r2,37
81133678:	1000071e 	bne	r2,zero,81133698 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
8113367c:	e0bffb07 	ldb	r2,-20(fp)
81133680:	e0fffd17 	ldw	r3,-12(fp)
81133684:	180b883a 	mov	r5,r3
81133688:	1009883a 	mov	r4,r2
8113368c:	11334c80 	call	811334c8 <alt_log_txchar>
          state = pfState_chars;
81133690:	e03fec15 	stw	zero,-80(fp)
81133694:	00011b06 	br	81133b04 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81133698:	00800084 	movi	r2,2
8113369c:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
811336a0:	e0bffb07 	ldb	r2,-20(fp)
811336a4:	10800b98 	cmpnei	r2,r2,46
811336a8:	1000021e 	bne	r2,zero,811336b4 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
811336ac:	e03ff015 	stw	zero,-64(fp)
811336b0:	00011306 	br	81133b00 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
811336b4:	e0bffb07 	ldb	r2,-20(fp)
811336b8:	10800c10 	cmplti	r2,r2,48
811336bc:	10001a1e 	bne	r2,zero,81133728 <alt_log_private_printf+0x1a4>
811336c0:	e0bffb07 	ldb	r2,-20(fp)
811336c4:	10800e88 	cmpgei	r2,r2,58
811336c8:	1000171e 	bne	r2,zero,81133728 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
811336cc:	e0bffb03 	ldbu	r2,-20(fp)
811336d0:	10bff404 	addi	r2,r2,-48
811336d4:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
811336d8:	e0bff017 	ldw	r2,-64(fp)
811336dc:	10000c0e 	bge	r2,zero,81133710 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
811336e0:	e0bfef17 	ldw	r2,-68(fp)
811336e4:	1000020e 	bge	r2,zero,811336f0 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
811336e8:	e03fef15 	stw	zero,-68(fp)
811336ec:	00000306 	br	811336fc <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
811336f0:	e0bfef17 	ldw	r2,-68(fp)
811336f4:	108002a4 	muli	r2,r2,10
811336f8:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
811336fc:	e0bffb07 	ldb	r2,-20(fp)
81133700:	e0ffef17 	ldw	r3,-68(fp)
81133704:	1885883a 	add	r2,r3,r2
81133708:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8113370c:	0000fc06 	br	81133b00 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81133710:	e0bff017 	ldw	r2,-64(fp)
81133714:	10c002a4 	muli	r3,r2,10
81133718:	e0bffb07 	ldb	r2,-20(fp)
8113371c:	1885883a 	add	r2,r3,r2
81133720:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81133724:	0000f606 	br	81133b00 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81133728:	e0bffb07 	ldb	r2,-20(fp)
8113372c:	10801b18 	cmpnei	r2,r2,108
81133730:	1000031e 	bne	r2,zero,81133740 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81133734:	00800044 	movi	r2,1
81133738:	e0bfee15 	stw	r2,-72(fp)
8113373c:	0000f006 	br	81133b00 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81133740:	e0bffb07 	ldb	r2,-20(fp)
81133744:	10bfea04 	addi	r2,r2,-88
81133748:	10c00868 	cmpgeui	r3,r2,33
8113374c:	1800eb1e 	bne	r3,zero,81133afc <alt_log_private_printf+0x578>
81133750:	100690ba 	slli	r3,r2,2
81133754:	00a044f4 	movhi	r2,33043
81133758:	108dda04 	addi	r2,r2,14184
8113375c:	1885883a 	add	r2,r3,r2
81133760:	10800017 	ldw	r2,0(r2)
81133764:	1000683a 	jmp	r2
81133768:	81133a28 	cmpgeui	r4,r16,19688
8113376c:	81133afc 	xorhi	r4,r16,19691
81133770:	81133afc 	xorhi	r4,r16,19691
81133774:	81133afc 	xorhi	r4,r16,19691
81133778:	81133afc 	xorhi	r4,r16,19691
8113377c:	81133afc 	xorhi	r4,r16,19691
81133780:	81133afc 	xorhi	r4,r16,19691
81133784:	81133afc 	xorhi	r4,r16,19691
81133788:	81133afc 	xorhi	r4,r16,19691
8113378c:	81133afc 	xorhi	r4,r16,19691
81133790:	81133afc 	xorhi	r4,r16,19691
81133794:	81133a40 	call	881133a4 <__reset+0x20f33a4>
81133798:	811337ec 	andhi	r4,r16,19679
8113379c:	81133afc 	xorhi	r4,r16,19691
811337a0:	81133afc 	xorhi	r4,r16,19691
811337a4:	81133afc 	xorhi	r4,r16,19691
811337a8:	81133afc 	xorhi	r4,r16,19691
811337ac:	811337ec 	andhi	r4,r16,19679
811337b0:	81133afc 	xorhi	r4,r16,19691
811337b4:	81133afc 	xorhi	r4,r16,19691
811337b8:	81133afc 	xorhi	r4,r16,19691
811337bc:	81133afc 	xorhi	r4,r16,19691
811337c0:	81133afc 	xorhi	r4,r16,19691
811337c4:	81133a08 	cmpgei	r4,r16,19688
811337c8:	81133afc 	xorhi	r4,r16,19691
811337cc:	81133afc 	xorhi	r4,r16,19691
811337d0:	81133afc 	xorhi	r4,r16,19691
811337d4:	81133a7c 	xorhi	r4,r16,19689
811337d8:	81133afc 	xorhi	r4,r16,19691
811337dc:	81133a00 	call	881133a0 <__reset+0x20f33a0>
811337e0:	81133afc 	xorhi	r4,r16,19691
811337e4:	81133afc 	xorhi	r4,r16,19691
811337e8:	81133a18 	cmpnei	r4,r16,19688
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
811337ec:	e0bfee17 	ldw	r2,-72(fp)
811337f0:	10000e26 	beq	r2,zero,8113382c <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
811337f4:	e0bff217 	ldw	r2,-56(fp)
811337f8:	10000626 	beq	r2,zero,81133814 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
811337fc:	e0bffe17 	ldw	r2,-8(fp)
81133800:	10c00104 	addi	r3,r2,4
81133804:	e0fffe15 	stw	r3,-8(fp)
81133808:	10800017 	ldw	r2,0(r2)
8113380c:	e0bff415 	stw	r2,-48(fp)
81133810:	00001306 	br	81133860 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81133814:	e0bffe17 	ldw	r2,-8(fp)
81133818:	10c00104 	addi	r3,r2,4
8113381c:	e0fffe15 	stw	r3,-8(fp)
81133820:	10800017 	ldw	r2,0(r2)
81133824:	e0bff415 	stw	r2,-48(fp)
81133828:	00000d06 	br	81133860 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
8113382c:	e0bff217 	ldw	r2,-56(fp)
81133830:	10000626 	beq	r2,zero,8113384c <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81133834:	e0bffe17 	ldw	r2,-8(fp)
81133838:	10c00104 	addi	r3,r2,4
8113383c:	e0fffe15 	stw	r3,-8(fp)
81133840:	10800017 	ldw	r2,0(r2)
81133844:	e0bff415 	stw	r2,-48(fp)
81133848:	00000506 	br	81133860 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
8113384c:	e0bffe17 	ldw	r2,-8(fp)
81133850:	10c00104 	addi	r3,r2,4
81133854:	e0fffe15 	stw	r3,-8(fp)
81133858:	10800017 	ldw	r2,0(r2)
8113385c:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81133860:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81133864:	e0bff217 	ldw	r2,-56(fp)
81133868:	10000726 	beq	r2,zero,81133888 <alt_log_private_printf+0x304>
8113386c:	e0bff417 	ldw	r2,-48(fp)
81133870:	1000050e 	bge	r2,zero,81133888 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81133874:	e0bff417 	ldw	r2,-48(fp)
81133878:	0085c83a 	sub	r2,zero,r2
8113387c:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81133880:	00800044 	movi	r2,1
81133884:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81133888:	e0bff417 	ldw	r2,-48(fp)
8113388c:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81133890:	00800044 	movi	r2,1
81133894:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81133898:	00800044 	movi	r2,1
8113389c:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
811338a0:	00000706 	br	811338c0 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
811338a4:	e0bff817 	ldw	r2,-32(fp)
811338a8:	10800044 	addi	r2,r2,1
811338ac:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
811338b0:	e0bff117 	ldw	r2,-60(fp)
811338b4:	e0fff517 	ldw	r3,-44(fp)
811338b8:	1885383a 	mul	r2,r3,r2
811338bc:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
811338c0:	e0bff117 	ldw	r2,-60(fp)
811338c4:	e0fff617 	ldw	r3,-40(fp)
811338c8:	1885203a 	divu	r2,r3,r2
811338cc:	e0bff615 	stw	r2,-40(fp)
811338d0:	e0bff617 	ldw	r2,-40(fp)
811338d4:	103ff31e 	bne	r2,zero,811338a4 <__reset+0xfb1138a4>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
811338d8:	e0ffef17 	ldw	r3,-68(fp)
811338dc:	e0bff817 	ldw	r2,-32(fp)
811338e0:	1885c83a 	sub	r2,r3,r2
811338e4:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
811338e8:	e0bfed17 	ldw	r2,-76(fp)
811338ec:	10000e26 	beq	r2,zero,81133928 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
811338f0:	e0bff717 	ldw	r2,-36(fp)
811338f4:	10000726 	beq	r2,zero,81133914 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
811338f8:	e0bffd17 	ldw	r2,-12(fp)
811338fc:	100b883a 	mov	r5,r2
81133900:	01000b44 	movi	r4,45
81133904:	11334c80 	call	811334c8 <alt_log_txchar>
                    fmtBeforeDecimal--;
81133908:	e0bfef17 	ldw	r2,-68(fp)
8113390c:	10bfffc4 	addi	r2,r2,-1
81133910:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81133914:	e1bffd17 	ldw	r6,-12(fp)
81133918:	e17fef17 	ldw	r5,-68(fp)
8113391c:	01000c04 	movi	r4,48
81133920:	113351c0 	call	8113351c <alt_log_repchar>
81133924:	00003206 	br	811339f0 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81133928:	e0bff717 	ldw	r2,-36(fp)
8113392c:	10000326 	beq	r2,zero,8113393c <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81133930:	e0bfef17 	ldw	r2,-68(fp)
81133934:	10bfffc4 	addi	r2,r2,-1
81133938:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
8113393c:	e1bffd17 	ldw	r6,-12(fp)
81133940:	e17fef17 	ldw	r5,-68(fp)
81133944:	01000804 	movi	r4,32
81133948:	113351c0 	call	8113351c <alt_log_repchar>
                    if(sign)
8113394c:	e0bff717 	ldw	r2,-36(fp)
81133950:	10002726 	beq	r2,zero,811339f0 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81133954:	e0bffd17 	ldw	r2,-12(fp)
81133958:	100b883a 	mov	r5,r2
8113395c:	01000b44 	movi	r4,45
81133960:	11334c80 	call	811334c8 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81133964:	00002206 	br	811339f0 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81133968:	e0fff417 	ldw	r3,-48(fp)
8113396c:	e0bff517 	ldw	r2,-44(fp)
81133970:	1885203a 	divu	r2,r3,r2
81133974:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81133978:	e0bff903 	ldbu	r2,-28(fp)
8113397c:	10800c04 	addi	r2,r2,48
81133980:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81133984:	e0bff903 	ldbu	r2,-28(fp)
81133988:	10800eb0 	cmpltui	r2,r2,58
8113398c:	1000081e 	bne	r2,zero,811339b0 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81133990:	e0bff317 	ldw	r2,-52(fp)
81133994:	10000226 	beq	r2,zero,811339a0 <alt_log_private_printf+0x41c>
81133998:	008001c4 	movi	r2,7
8113399c:	00000106 	br	811339a4 <alt_log_private_printf+0x420>
811339a0:	008009c4 	movi	r2,39
811339a4:	e0fff903 	ldbu	r3,-28(fp)
811339a8:	10c5883a 	add	r2,r2,r3
811339ac:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
811339b0:	e0bff903 	ldbu	r2,-28(fp)
811339b4:	e0fffd17 	ldw	r3,-12(fp)
811339b8:	180b883a 	mov	r5,r3
811339bc:	1009883a 	mov	r4,r2
811339c0:	11334c80 	call	811334c8 <alt_log_txchar>

                  v = v % p;
811339c4:	e0bff417 	ldw	r2,-48(fp)
811339c8:	e0fff517 	ldw	r3,-44(fp)
811339cc:	10c9203a 	divu	r4,r2,r3
811339d0:	e0fff517 	ldw	r3,-44(fp)
811339d4:	20c7383a 	mul	r3,r4,r3
811339d8:	10c5c83a 	sub	r2,r2,r3
811339dc:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
811339e0:	e0bff117 	ldw	r2,-60(fp)
811339e4:	e0fff517 	ldw	r3,-44(fp)
811339e8:	1885203a 	divu	r2,r3,r2
811339ec:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
811339f0:	e0bff517 	ldw	r2,-44(fp)
811339f4:	103fdc1e 	bne	r2,zero,81133968 <__reset+0xfb113968>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
811339f8:	e03fec15 	stw	zero,-80(fp)
              break;
811339fc:	00003f06 	br	81133afc <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81133a00:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81133a04:	003f7906 	br	811337ec <__reset+0xfb1137ec>
            case 'o':
              fmtSigned = 0;
81133a08:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81133a0c:	00800204 	movi	r2,8
81133a10:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81133a14:	003f7506 	br	811337ec <__reset+0xfb1137ec>
            case 'x':
              fmtSigned = 0;
81133a18:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81133a1c:	00800404 	movi	r2,16
81133a20:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81133a24:	003f7106 	br	811337ec <__reset+0xfb1137ec>
            case 'X':
              fmtSigned = 0;
81133a28:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81133a2c:	00800404 	movi	r2,16
81133a30:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81133a34:	00800044 	movi	r2,1
81133a38:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81133a3c:	003f6b06 	br	811337ec <__reset+0xfb1137ec>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81133a40:	e0bfef17 	ldw	r2,-68(fp)
81133a44:	10bfffc4 	addi	r2,r2,-1
81133a48:	e1bffd17 	ldw	r6,-12(fp)
81133a4c:	100b883a 	mov	r5,r2
81133a50:	01000804 	movi	r4,32
81133a54:	113351c0 	call	8113351c <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81133a58:	e0bffe17 	ldw	r2,-8(fp)
81133a5c:	10c00104 	addi	r3,r2,4
81133a60:	e0fffe15 	stw	r3,-8(fp)
81133a64:	10800017 	ldw	r2,0(r2)
81133a68:	e0fffd17 	ldw	r3,-12(fp)
81133a6c:	180b883a 	mov	r5,r3
81133a70:	1009883a 	mov	r4,r2
81133a74:	11334c80 	call	811334c8 <alt_log_txchar>
              break;
81133a78:	00002006 	br	81133afc <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81133a7c:	e0bffe17 	ldw	r2,-8(fp)
81133a80:	10c00104 	addi	r3,r2,4
81133a84:	e0fffe15 	stw	r3,-8(fp)
81133a88:	10800017 	ldw	r2,0(r2)
81133a8c:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81133a90:	e43fef17 	ldw	r16,-68(fp)
81133a94:	e13ffa17 	ldw	r4,-24(fp)
81133a98:	111f1b80 	call	8111f1b8 <strlen>
81133a9c:	8085c83a 	sub	r2,r16,r2
81133aa0:	e1bffd17 	ldw	r6,-12(fp)
81133aa4:	100b883a 	mov	r5,r2
81133aa8:	01000804 	movi	r4,32
81133aac:	113351c0 	call	8113351c <alt_log_repchar>

                while(*s)
81133ab0:	00000b06 	br	81133ae0 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81133ab4:	e0bffa17 	ldw	r2,-24(fp)
81133ab8:	10c00044 	addi	r3,r2,1
81133abc:	e0fffa15 	stw	r3,-24(fp)
81133ac0:	10800003 	ldbu	r2,0(r2)
81133ac4:	10803fcc 	andi	r2,r2,255
81133ac8:	1080201c 	xori	r2,r2,128
81133acc:	10bfe004 	addi	r2,r2,-128
81133ad0:	e0fffd17 	ldw	r3,-12(fp)
81133ad4:	180b883a 	mov	r5,r3
81133ad8:	1009883a 	mov	r4,r2
81133adc:	11334c80 	call	811334c8 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81133ae0:	e0bffa17 	ldw	r2,-24(fp)
81133ae4:	10800003 	ldbu	r2,0(r2)
81133ae8:	10803fcc 	andi	r2,r2,255
81133aec:	1080201c 	xori	r2,r2,128
81133af0:	10bfe004 	addi	r2,r2,-128
81133af4:	103fef1e 	bne	r2,zero,81133ab4 <__reset+0xfb113ab4>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81133af8:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81133afc:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81133b00:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81133b04:	e0bfeb17 	ldw	r2,-84(fp)
81133b08:	10c00044 	addi	r3,r2,1
81133b0c:	e0ffeb15 	stw	r3,-84(fp)
81133b10:	10800003 	ldbu	r2,0(r2)
81133b14:	e0bffb05 	stb	r2,-20(fp)
81133b18:	e0bffb07 	ldb	r2,-20(fp)
81133b1c:	103eae1e 	bne	r2,zero,811335d8 <__reset+0xfb1135d8>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81133b20:	0001883a 	nop
81133b24:	e6ffff04 	addi	sp,fp,-4
81133b28:	dfc00217 	ldw	ra,8(sp)
81133b2c:	df000117 	ldw	fp,4(sp)
81133b30:	dc000017 	ldw	r16,0(sp)
81133b34:	dec00304 	addi	sp,sp,12
81133b38:	f800283a 	ret

81133b3c <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81133b3c:	defff904 	addi	sp,sp,-28
81133b40:	de00012e 	bgeu	sp,et,81133b48 <alt_log_printf_proc+0xc>
81133b44:	003b68fa 	trap	3
81133b48:	dfc00315 	stw	ra,12(sp)
81133b4c:	df000215 	stw	fp,8(sp)
81133b50:	df000204 	addi	fp,sp,8
81133b54:	e13fff15 	stw	r4,-4(fp)
81133b58:	e1400215 	stw	r5,8(fp)
81133b5c:	e1800315 	stw	r6,12(fp)
81133b60:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81133b64:	e0800204 	addi	r2,fp,8
81133b68:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81133b6c:	e0bffe17 	ldw	r2,-8(fp)
81133b70:	100d883a 	mov	r6,r2
81133b74:	01604834 	movhi	r5,33056
81133b78:	294c2404 	addi	r5,r5,12432
81133b7c:	e13fff17 	ldw	r4,-4(fp)
81133b80:	11335840 	call	81133584 <alt_log_private_printf>
    return (0);
81133b84:	0005883a 	mov	r2,zero
}
81133b88:	e037883a 	mov	sp,fp
81133b8c:	dfc00117 	ldw	ra,4(sp)
81133b90:	df000017 	ldw	fp,0(sp)
81133b94:	dec00504 	addi	sp,sp,20
81133b98:	f800283a 	ret

81133b9c <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81133b9c:	defff904 	addi	sp,sp,-28
81133ba0:	de00012e 	bgeu	sp,et,81133ba8 <altera_avalon_jtag_uart_report_log+0xc>
81133ba4:	003b68fa 	trap	3
81133ba8:	dfc00615 	stw	ra,24(sp)
81133bac:	df000515 	stw	fp,20(sp)
81133bb0:	dc400415 	stw	r17,16(sp)
81133bb4:	dc000315 	stw	r16,12(sp)
81133bb8:	df000504 	addi	fp,sp,20
81133bbc:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81133bc0:	d0a08083 	ldbu	r2,-32254(gp)
81133bc4:	10803fcc 	andi	r2,r2,255
81133bc8:	10001426 	beq	r2,zero,81133c1c <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81133bcc:	e0bffd17 	ldw	r2,-12(fp)
81133bd0:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81133bd4:	00a04574 	movhi	r2,33045
81133bd8:	10b47104 	addi	r2,r2,-11836
81133bdc:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81133be0:	e0bffb17 	ldw	r2,-20(fp)
81133be4:	10800017 	ldw	r2,0(r2)
81133be8:	e1bffc17 	ldw	r6,-16(fp)
81133bec:	100b883a 	mov	r5,r2
81133bf0:	e13ffb17 	ldw	r4,-20(fp)
81133bf4:	1133c3c0 	call	81133c3c <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81133bf8:	d0e08717 	ldw	r3,-32228(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81133bfc:	00b33374 	movhi	r2,52429
81133c00:	10b33344 	addi	r2,r2,-13107
81133c04:	1888383a 	mulxuu	r4,r3,r2
81133c08:	1885383a 	mul	r2,r3,r2
81133c0c:	1021883a 	mov	r16,r2
81133c10:	2023883a 	mov	r17,r4
81133c14:	8804d0fa 	srli	r2,r17,3
81133c18:	00000106 	br	81133c20 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81133c1c:	0005883a 	mov	r2,zero
    }
}
81133c20:	e6fffe04 	addi	sp,fp,-8
81133c24:	dfc00317 	ldw	ra,12(sp)
81133c28:	df000217 	ldw	fp,8(sp)
81133c2c:	dc400117 	ldw	r17,4(sp)
81133c30:	dc000017 	ldw	r16,0(sp)
81133c34:	dec00404 	addi	sp,sp,16
81133c38:	f800283a 	ret

81133c3c <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81133c3c:	deffef04 	addi	sp,sp,-68
81133c40:	de00012e 	bgeu	sp,et,81133c48 <alt_log_jtag_uart_print_control_reg+0xc>
81133c44:	003b68fa 	trap	3
81133c48:	dfc01015 	stw	ra,64(sp)
81133c4c:	df000f15 	stw	fp,60(sp)
81133c50:	df000f04 	addi	fp,sp,60
81133c54:	e13ffd15 	stw	r4,-12(fp)
81133c58:	e17ffe15 	stw	r5,-8(fp)
81133c5c:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81133c60:	e0bffe17 	ldw	r2,-8(fp)
81133c64:	10800104 	addi	r2,r2,4
81133c68:	10800037 	ldwio	r2,0(r2)
81133c6c:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81133c70:	e0bff617 	ldw	r2,-40(fp)
81133c74:	1004d43a 	srli	r2,r2,16
81133c78:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81133c7c:	e0bff617 	ldw	r2,-40(fp)
81133c80:	1080008c 	andi	r2,r2,2
81133c84:	1004d07a 	srli	r2,r2,1
81133c88:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81133c8c:	e0bff617 	ldw	r2,-40(fp)
81133c90:	1080004c 	andi	r2,r2,1
81133c94:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
81133c98:	e0bff617 	ldw	r2,-40(fp)
81133c9c:	1080400c 	andi	r2,r2,256
81133ca0:	1004d23a 	srli	r2,r2,8
81133ca4:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
81133ca8:	e0bff617 	ldw	r2,-40(fp)
81133cac:	1080800c 	andi	r2,r2,512
81133cb0:	1004d27a 	srli	r2,r2,9
81133cb4:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
81133cb8:	e0bff617 	ldw	r2,-40(fp)
81133cbc:	1081000c 	andi	r2,r2,1024
81133cc0:	1004d2ba 	srli	r2,r2,10
81133cc4:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
81133cc8:	e0bffd17 	ldw	r2,-12(fp)
81133ccc:	10c01017 	ldw	r3,64(r2)
81133cd0:	e0bffd17 	ldw	r2,-12(fp)
81133cd4:	10800f17 	ldw	r2,60(r2)
81133cd8:	1887c83a 	sub	r3,r3,r2
81133cdc:	e0bff917 	ldw	r2,-28(fp)
81133ce0:	d8800415 	stw	r2,16(sp)
81133ce4:	e0bff817 	ldw	r2,-32(fp)
81133ce8:	d8800315 	stw	r2,12(sp)
81133cec:	e0bffa17 	ldw	r2,-24(fp)
81133cf0:	d8800215 	stw	r2,8(sp)
81133cf4:	e0bffb17 	ldw	r2,-20(fp)
81133cf8:	d8800115 	stw	r2,4(sp)
81133cfc:	e0bffc17 	ldw	r2,-16(fp)
81133d00:	d8800015 	stw	r2,0(sp)
81133d04:	e1fff717 	ldw	r7,-36(fp)
81133d08:	180d883a 	mov	r6,r3
81133d0c:	e17fff17 	ldw	r5,-4(fp)
81133d10:	01204574 	movhi	r4,33045
81133d14:	21347404 	addi	r4,r4,-11824
81133d18:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81133d1c:	0001883a 	nop

}
81133d20:	e037883a 	mov	sp,fp
81133d24:	dfc00117 	ldw	ra,4(sp)
81133d28:	df000017 	ldw	fp,0(sp)
81133d2c:	dec00204 	addi	sp,sp,8
81133d30:	f800283a 	ret

81133d34 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81133d34:	defffb04 	addi	sp,sp,-20
81133d38:	de00012e 	bgeu	sp,et,81133d40 <alt_log_jtag_uart_startup_info+0xc>
81133d3c:	003b68fa 	trap	3
81133d40:	dfc00415 	stw	ra,16(sp)
81133d44:	df000315 	stw	fp,12(sp)
81133d48:	df000304 	addi	fp,sp,12
81133d4c:	e13ffe15 	stw	r4,-8(fp)
81133d50:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81133d54:	00a04574 	movhi	r2,33045
81133d58:	10b48604 	addi	r2,r2,-11752
81133d5c:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81133d60:	e1bffd17 	ldw	r6,-12(fp)
81133d64:	e17fff17 	ldw	r5,-4(fp)
81133d68:	e13ffe17 	ldw	r4,-8(fp)
81133d6c:	1133c3c0 	call	81133c3c <alt_log_jtag_uart_print_control_reg>
     return;
81133d70:	0001883a 	nop
}
81133d74:	e037883a 	mov	sp,fp
81133d78:	dfc00117 	ldw	ra,4(sp)
81133d7c:	df000017 	ldw	fp,0(sp)
81133d80:	dec00204 	addi	sp,sp,8
81133d84:	f800283a 	ret

81133d88 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
81133d88:	defffb04 	addi	sp,sp,-20
81133d8c:	de00012e 	bgeu	sp,et,81133d94 <alt_log_jtag_uart_isr_proc+0xc>
81133d90:	003b68fa 	trap	3
81133d94:	dfc00415 	stw	ra,16(sp)
81133d98:	df000315 	stw	fp,12(sp)
81133d9c:	df000304 	addi	fp,sp,12
81133da0:	e13ffe15 	stw	r4,-8(fp)
81133da4:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
81133da8:	d0a080c3 	ldbu	r2,-32253(gp)
81133dac:	10803fcc 	andi	r2,r2,255
81133db0:	10000826 	beq	r2,zero,81133dd4 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
81133db4:	00a04574 	movhi	r2,33045
81133db8:	10b48b04 	addi	r2,r2,-11732
81133dbc:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
81133dc0:	e1bffd17 	ldw	r6,-12(fp)
81133dc4:	e17ffe17 	ldw	r5,-8(fp)
81133dc8:	e13fff17 	ldw	r4,-4(fp)
81133dcc:	1133c3c0 	call	81133c3c <alt_log_jtag_uart_print_control_reg>
    }
    return;
81133dd0:	0001883a 	nop
81133dd4:	0001883a 	nop
}
81133dd8:	e037883a 	mov	sp,fp
81133ddc:	dfc00117 	ldw	ra,4(sp)
81133de0:	df000017 	ldw	fp,0(sp)
81133de4:	dec00204 	addi	sp,sp,8
81133de8:	f800283a 	ret

81133dec <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81133dec:	defffa04 	addi	sp,sp,-24
81133df0:	de00012e 	bgeu	sp,et,81133df8 <alt_log_write+0xc>
81133df4:	003b68fa 	trap	3
81133df8:	dfc00515 	stw	ra,20(sp)
81133dfc:	df000415 	stw	fp,16(sp)
81133e00:	df000404 	addi	fp,sp,16
81133e04:	e13ffe15 	stw	r4,-8(fp)
81133e08:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81133e0c:	d0a08003 	ldbu	r2,-32256(gp)
81133e10:	10803fcc 	andi	r2,r2,255
81133e14:	10004026 	beq	r2,zero,81133f18 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81133e18:	e0bfff17 	ldw	r2,-4(fp)
81133e1c:	10c00430 	cmpltui	r3,r2,16
81133e20:	1800011e 	bne	r3,zero,81133e28 <alt_log_write+0x3c>
81133e24:	008003c4 	movi	r2,15
81133e28:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81133e2c:	e0bffd17 	ldw	r2,-12(fp)
81133e30:	10800088 	cmpgei	r2,r2,2
81133e34:	10003726 	beq	r2,zero,81133f14 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81133e38:	e0bffd17 	ldw	r2,-12(fp)
81133e3c:	100d883a 	mov	r6,r2
81133e40:	e17ffe17 	ldw	r5,-8(fp)
81133e44:	012045b4 	movhi	r4,33046
81133e48:	210c6004 	addi	r4,r4,12672
81133e4c:	1147db80 	call	81147db8 <strncpy>
    alt_log_write_buf[length-1]='\n';
81133e50:	e0bffd17 	ldw	r2,-12(fp)
81133e54:	10ffffc4 	addi	r3,r2,-1
81133e58:	00a045b4 	movhi	r2,33046
81133e5c:	108c6004 	addi	r2,r2,12672
81133e60:	10c5883a 	add	r2,r2,r3
81133e64:	00c00284 	movi	r3,10
81133e68:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81133e6c:	00a045b4 	movhi	r2,33046
81133e70:	108c6004 	addi	r2,r2,12672
81133e74:	e0fffd17 	ldw	r3,-12(fp)
81133e78:	10c5883a 	add	r2,r2,r3
81133e7c:	00c00344 	movi	r3,13
81133e80:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
81133e84:	e0bffd17 	ldw	r2,-12(fp)
81133e88:	10c00044 	addi	r3,r2,1
81133e8c:	00a045b4 	movhi	r2,33046
81133e90:	108c6004 	addi	r2,r2,12672
81133e94:	10c5883a 	add	r2,r2,r3
81133e98:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81133e9c:	e03ffc15 	stw	zero,-16(fp)
81133ea0:	00001306 	br	81133ef0 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
81133ea4:	00a045b4 	movhi	r2,33046
81133ea8:	108c6004 	addi	r2,r2,12672
81133eac:	e0fffc17 	ldw	r3,-16(fp)
81133eb0:	10c5883a 	add	r2,r2,r3
81133eb4:	10800003 	ldbu	r2,0(r2)
81133eb8:	10803fcc 	andi	r2,r2,255
81133ebc:	1080201c 	xori	r2,r2,128
81133ec0:	10bfe004 	addi	r2,r2,-128
81133ec4:	10800118 	cmpnei	r2,r2,4
81133ec8:	1000061e 	bne	r2,zero,81133ee4 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
81133ecc:	00a045b4 	movhi	r2,33046
81133ed0:	108c6004 	addi	r2,r2,12672
81133ed4:	e0fffc17 	ldw	r3,-16(fp)
81133ed8:	10c5883a 	add	r2,r2,r3
81133edc:	00c01104 	movi	r3,68
81133ee0:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81133ee4:	e0bffc17 	ldw	r2,-16(fp)
81133ee8:	10800044 	addi	r2,r2,1
81133eec:	e0bffc15 	stw	r2,-16(fp)
81133ef0:	e0fffc17 	ldw	r3,-16(fp)
81133ef4:	e0bffd17 	ldw	r2,-12(fp)
81133ef8:	18bfea16 	blt	r3,r2,81133ea4 <__reset+0xfb113ea4>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81133efc:	016045b4 	movhi	r5,33046
81133f00:	294c6004 	addi	r5,r5,12672
81133f04:	01204574 	movhi	r4,33045
81133f08:	21348e04 	addi	r4,r4,-11720
81133f0c:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
81133f10:	00000106 	br	81133f18 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81133f14:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81133f18:	e037883a 	mov	sp,fp
81133f1c:	dfc00117 	ldw	ra,4(sp)
81133f20:	df000017 	ldw	fp,0(sp)
81133f24:	dec00204 	addi	sp,sp,8
81133f28:	f800283a 	ret

81133f2c <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81133f2c:	defffe04 	addi	sp,sp,-8
81133f30:	de00012e 	bgeu	sp,et,81133f38 <alt_log_system_clock+0xc>
81133f34:	003b68fa 	trap	3
81133f38:	dfc00115 	stw	ra,4(sp)
81133f3c:	df000015 	stw	fp,0(sp)
81133f40:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81133f44:	d0a08043 	ldbu	r2,-32255(gp)
81133f48:	10803fcc 	andi	r2,r2,255
81133f4c:	10000e26 	beq	r2,zero,81133f88 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81133f50:	d0a08317 	ldw	r2,-32244(gp)
81133f54:	10800044 	addi	r2,r2,1
81133f58:	d0a08315 	stw	r2,-32244(gp)
81133f5c:	d0a08717 	ldw	r2,-32228(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81133f60:	d0e08317 	ldw	r3,-32244(gp)
81133f64:	10c0082e 	bgeu	r2,r3,81133f88 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81133f68:	d0208315 	stw	zero,-32244(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81133f6c:	d0a08217 	ldw	r2,-32248(gp)
81133f70:	10c00044 	addi	r3,r2,1
81133f74:	d0e08215 	stw	r3,-32248(gp)
81133f78:	100b883a 	mov	r5,r2
81133f7c:	01204574 	movhi	r4,33045
81133f80:	21349204 	addi	r4,r4,-11704
81133f84:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
        }
    }
}
81133f88:	0001883a 	nop
81133f8c:	e037883a 	mov	sp,fp
81133f90:	dfc00117 	ldw	ra,4(sp)
81133f94:	df000017 	ldw	fp,0(sp)
81133f98:	dec00204 	addi	sp,sp,8
81133f9c:	f800283a 	ret

81133fa0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81133fa0:	defffe04 	addi	sp,sp,-8
81133fa4:	de00012e 	bgeu	sp,et,81133fac <alt_get_errno+0xc>
81133fa8:	003b68fa 	trap	3
81133fac:	dfc00115 	stw	ra,4(sp)
81133fb0:	df000015 	stw	fp,0(sp)
81133fb4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81133fb8:	d0a01017 	ldw	r2,-32704(gp)
81133fbc:	10000326 	beq	r2,zero,81133fcc <alt_get_errno+0x2c>
81133fc0:	d0a01017 	ldw	r2,-32704(gp)
81133fc4:	103ee83a 	callr	r2
81133fc8:	00000106 	br	81133fd0 <alt_get_errno+0x30>
81133fcc:	d0a07704 	addi	r2,gp,-32292
}
81133fd0:	e037883a 	mov	sp,fp
81133fd4:	dfc00117 	ldw	ra,4(sp)
81133fd8:	df000017 	ldw	fp,0(sp)
81133fdc:	dec00204 	addi	sp,sp,8
81133fe0:	f800283a 	ret

81133fe4 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81133fe4:	defff904 	addi	sp,sp,-28
81133fe8:	de00012e 	bgeu	sp,et,81133ff0 <lseek+0xc>
81133fec:	003b68fa 	trap	3
81133ff0:	dfc00615 	stw	ra,24(sp)
81133ff4:	df000515 	stw	fp,20(sp)
81133ff8:	df000504 	addi	fp,sp,20
81133ffc:	e13ffd15 	stw	r4,-12(fp)
81134000:	e17ffe15 	stw	r5,-8(fp)
81134004:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81134008:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113400c:	e0bffd17 	ldw	r2,-12(fp)
81134010:	10000616 	blt	r2,zero,8113402c <lseek+0x48>
81134014:	e0bffd17 	ldw	r2,-12(fp)
81134018:	10c00324 	muli	r3,r2,12
8113401c:	00a04574 	movhi	r2,33045
81134020:	10b84b04 	addi	r2,r2,-7892
81134024:	1885883a 	add	r2,r3,r2
81134028:	00000106 	br	81134030 <lseek+0x4c>
8113402c:	0005883a 	mov	r2,zero
81134030:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81134034:	e0bffc17 	ldw	r2,-16(fp)
81134038:	10001026 	beq	r2,zero,8113407c <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
8113403c:	e0bffc17 	ldw	r2,-16(fp)
81134040:	10800017 	ldw	r2,0(r2)
81134044:	10800717 	ldw	r2,28(r2)
81134048:	10000926 	beq	r2,zero,81134070 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
8113404c:	e0bffc17 	ldw	r2,-16(fp)
81134050:	10800017 	ldw	r2,0(r2)
81134054:	10800717 	ldw	r2,28(r2)
81134058:	e1bfff17 	ldw	r6,-4(fp)
8113405c:	e17ffe17 	ldw	r5,-8(fp)
81134060:	e13ffc17 	ldw	r4,-16(fp)
81134064:	103ee83a 	callr	r2
81134068:	e0bffb15 	stw	r2,-20(fp)
8113406c:	00000506 	br	81134084 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81134070:	00bfde84 	movi	r2,-134
81134074:	e0bffb15 	stw	r2,-20(fp)
81134078:	00000206 	br	81134084 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
8113407c:	00bfebc4 	movi	r2,-81
81134080:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81134084:	e0bffb17 	ldw	r2,-20(fp)
81134088:	1000070e 	bge	r2,zero,811340a8 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
8113408c:	1133fa00 	call	81133fa0 <alt_get_errno>
81134090:	1007883a 	mov	r3,r2
81134094:	e0bffb17 	ldw	r2,-20(fp)
81134098:	0085c83a 	sub	r2,zero,r2
8113409c:	18800015 	stw	r2,0(r3)
    rc = -1;
811340a0:	00bfffc4 	movi	r2,-1
811340a4:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
811340a8:	e0bffb17 	ldw	r2,-20(fp)
}
811340ac:	e037883a 	mov	sp,fp
811340b0:	dfc00117 	ldw	ra,4(sp)
811340b4:	df000017 	ldw	fp,0(sp)
811340b8:	dec00204 	addi	sp,sp,8
811340bc:	f800283a 	ret

811340c0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
811340c0:	defff904 	addi	sp,sp,-28
811340c4:	de00012e 	bgeu	sp,et,811340cc <alt_main+0xc>
811340c8:	003b68fa 	trap	3
811340cc:	dfc00615 	stw	ra,24(sp)
811340d0:	df000515 	stw	fp,20(sp)
811340d4:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
811340d8:	d0a01217 	ldw	r2,-32696(gp)
811340dc:	10800058 	cmpnei	r2,r2,1
811340e0:	1000031e 	bne	r2,zero,811340f0 <alt_main+0x30>
811340e4:	01204574 	movhi	r4,33045
811340e8:	21349804 	addi	r4,r4,-11680
811340ec:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
811340f0:	0009883a 	mov	r4,zero
811340f4:	113ec180 	call	8113ec18 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
811340f8:	d0a01217 	ldw	r2,-32696(gp)
811340fc:	10800058 	cmpnei	r2,r2,1
81134100:	1000031e 	bne	r2,zero,81134110 <alt_main+0x50>
81134104:	01204574 	movhi	r4,33045
81134108:	2134a604 	addi	r4,r4,-11624
8113410c:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
  ALT_OS_INIT();
81134110:	11356ac0 	call	811356ac <OSInit>
81134114:	01000044 	movi	r4,1
81134118:	113b3c80 	call	8113b3c8 <OSSemCreate>
8113411c:	d0a08a15 	stw	r2,-32216(gp)
81134120:	01000044 	movi	r4,1
81134124:	113b3c80 	call	8113b3c8 <OSSemCreate>
81134128:	d0a08c15 	stw	r2,-32208(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
8113412c:	d0a01217 	ldw	r2,-32696(gp)
81134130:	10800058 	cmpnei	r2,r2,1
81134134:	1000031e 	bne	r2,zero,81134144 <alt_main+0x84>
81134138:	01204574 	movhi	r4,33045
8113413c:	2134b404 	addi	r4,r4,-11568
81134140:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
81134144:	d0a07e04 	addi	r2,gp,-32264
81134148:	e0bffc15 	stw	r2,-16(fp)
8113414c:	00800044 	movi	r2,1
81134150:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81134154:	e0bffd0b 	ldhu	r2,-12(fp)
81134158:	1009883a 	mov	r4,r2
8113415c:	113b3c80 	call	8113b3c8 <OSSemCreate>
81134160:	1007883a 	mov	r3,r2
81134164:	e0bffc17 	ldw	r2,-16(fp)
81134168:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
8113416c:	d0a01217 	ldw	r2,-32696(gp)
81134170:	10800058 	cmpnei	r2,r2,1
81134174:	1000031e 	bne	r2,zero,81134184 <alt_main+0xc4>
81134178:	01204574 	movhi	r4,33045
8113417c:	2134c204 	addi	r4,r4,-11512
81134180:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
  alt_sys_init();
81134184:	113ec580 	call	8113ec58 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
81134188:	d0a01217 	ldw	r2,-32696(gp)
8113418c:	10800058 	cmpnei	r2,r2,1
81134190:	1000031e 	bne	r2,zero,811341a0 <alt_main+0xe0>
81134194:	01204574 	movhi	r4,33045
81134198:	2134cc04 	addi	r4,r4,-11472
8113419c:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
811341a0:	d0a01217 	ldw	r2,-32696(gp)
811341a4:	10800058 	cmpnei	r2,r2,1
811341a8:	1000031e 	bne	r2,zero,811341b8 <alt_main+0xf8>
811341ac:	01204574 	movhi	r4,33045
811341b0:	2134d504 	addi	r4,r4,-11436
811341b4:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
811341b8:	01a04574 	movhi	r6,33045
811341bc:	31b4dd04 	addi	r6,r6,-11404
811341c0:	01604574 	movhi	r5,33045
811341c4:	2974e204 	addi	r5,r5,-11384
811341c8:	01204574 	movhi	r4,33045
811341cc:	2134e204 	addi	r4,r4,-11384
811341d0:	11475480 	call	81147548 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
811341d4:	d0a01217 	ldw	r2,-32696(gp)
811341d8:	10800058 	cmpnei	r2,r2,1
811341dc:	1000031e 	bne	r2,zero,811341ec <alt_main+0x12c>
811341e0:	01204574 	movhi	r4,33045
811341e4:	2134e604 	addi	r4,r4,-11368
811341e8:	1133b3c0 	call	81133b3c <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
811341ec:	d0a08417 	ldw	r2,-32240(gp)
811341f0:	d0e08517 	ldw	r3,-32236(gp)
811341f4:	d1208617 	ldw	r4,-32232(gp)
811341f8:	200d883a 	mov	r6,r4
811341fc:	180b883a 	mov	r5,r3
81134200:	1009883a 	mov	r4,r2
81134204:	1115bb40 	call	81115bb4 <main>
81134208:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
8113420c:	01000044 	movi	r4,1
81134210:	1132fec0 	call	81132fec <close>
  exit (result);
81134214:	e13ffb17 	ldw	r4,-20(fp)
81134218:	1147cfc0 	call	81147cfc <exit>

8113421c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113421c:	defffe04 	addi	sp,sp,-8
81134220:	de00012e 	bgeu	sp,et,81134228 <alt_get_errno+0xc>
81134224:	003b68fa 	trap	3
81134228:	dfc00115 	stw	ra,4(sp)
8113422c:	df000015 	stw	fp,0(sp)
81134230:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81134234:	d0a01017 	ldw	r2,-32704(gp)
81134238:	10000326 	beq	r2,zero,81134248 <alt_get_errno+0x2c>
8113423c:	d0a01017 	ldw	r2,-32704(gp)
81134240:	103ee83a 	callr	r2
81134244:	00000106 	br	8113424c <alt_get_errno+0x30>
81134248:	d0a07704 	addi	r2,gp,-32292
}
8113424c:	e037883a 	mov	sp,fp
81134250:	dfc00117 	ldw	ra,4(sp)
81134254:	df000017 	ldw	fp,0(sp)
81134258:	dec00204 	addi	sp,sp,8
8113425c:	f800283a 	ret

81134260 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81134260:	defffd04 	addi	sp,sp,-12
81134264:	de00012e 	bgeu	sp,et,8113426c <alt_file_locked+0xc>
81134268:	003b68fa 	trap	3
8113426c:	df000215 	stw	fp,8(sp)
81134270:	df000204 	addi	fp,sp,8
81134274:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81134278:	e0bfff17 	ldw	r2,-4(fp)
8113427c:	10800217 	ldw	r2,8(r2)
81134280:	10d00034 	orhi	r3,r2,16384
81134284:	e0bfff17 	ldw	r2,-4(fp)
81134288:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
8113428c:	e03ffe15 	stw	zero,-8(fp)
81134290:	00001d06 	br	81134308 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81134294:	00a04574 	movhi	r2,33045
81134298:	10b84b04 	addi	r2,r2,-7892
8113429c:	e0fffe17 	ldw	r3,-8(fp)
811342a0:	18c00324 	muli	r3,r3,12
811342a4:	10c5883a 	add	r2,r2,r3
811342a8:	10c00017 	ldw	r3,0(r2)
811342ac:	e0bfff17 	ldw	r2,-4(fp)
811342b0:	10800017 	ldw	r2,0(r2)
811342b4:	1880111e 	bne	r3,r2,811342fc <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811342b8:	00a04574 	movhi	r2,33045
811342bc:	10b84b04 	addi	r2,r2,-7892
811342c0:	e0fffe17 	ldw	r3,-8(fp)
811342c4:	18c00324 	muli	r3,r3,12
811342c8:	10c5883a 	add	r2,r2,r3
811342cc:	10800204 	addi	r2,r2,8
811342d0:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811342d4:	1000090e 	bge	r2,zero,811342fc <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
811342d8:	e0bffe17 	ldw	r2,-8(fp)
811342dc:	10c00324 	muli	r3,r2,12
811342e0:	00a04574 	movhi	r2,33045
811342e4:	10b84b04 	addi	r2,r2,-7892
811342e8:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811342ec:	e0bfff17 	ldw	r2,-4(fp)
811342f0:	18800226 	beq	r3,r2,811342fc <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
811342f4:	00bffcc4 	movi	r2,-13
811342f8:	00000806 	br	8113431c <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811342fc:	e0bffe17 	ldw	r2,-8(fp)
81134300:	10800044 	addi	r2,r2,1
81134304:	e0bffe15 	stw	r2,-8(fp)
81134308:	d0a00f17 	ldw	r2,-32708(gp)
8113430c:	1007883a 	mov	r3,r2
81134310:	e0bffe17 	ldw	r2,-8(fp)
81134314:	18bfdf2e 	bgeu	r3,r2,81134294 <__reset+0xfb114294>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81134318:	0005883a 	mov	r2,zero
}
8113431c:	e037883a 	mov	sp,fp
81134320:	df000017 	ldw	fp,0(sp)
81134324:	dec00104 	addi	sp,sp,4
81134328:	f800283a 	ret

8113432c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
8113432c:	defff604 	addi	sp,sp,-40
81134330:	de00012e 	bgeu	sp,et,81134338 <open+0xc>
81134334:	003b68fa 	trap	3
81134338:	dfc00915 	stw	ra,36(sp)
8113433c:	df000815 	stw	fp,32(sp)
81134340:	df000804 	addi	fp,sp,32
81134344:	e13ffd15 	stw	r4,-12(fp)
81134348:	e17ffe15 	stw	r5,-8(fp)
8113434c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81134350:	00bfffc4 	movi	r2,-1
81134354:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81134358:	00bffb44 	movi	r2,-19
8113435c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81134360:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81134364:	d1600d04 	addi	r5,gp,-32716
81134368:	e13ffd17 	ldw	r4,-12(fp)
8113436c:	1146f280 	call	81146f28 <alt_find_dev>
81134370:	e0bff815 	stw	r2,-32(fp)
81134374:	e0bff817 	ldw	r2,-32(fp)
81134378:	1000051e 	bne	r2,zero,81134390 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
8113437c:	e13ffd17 	ldw	r4,-12(fp)
81134380:	1146fc00 	call	81146fc0 <alt_find_file>
81134384:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81134388:	00800044 	movi	r2,1
8113438c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81134390:	e0bff817 	ldw	r2,-32(fp)
81134394:	10002926 	beq	r2,zero,8113443c <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81134398:	e13ff817 	ldw	r4,-32(fp)
8113439c:	11470d00 	call	811470d0 <alt_get_fd>
811343a0:	e0bff915 	stw	r2,-28(fp)
811343a4:	e0bff917 	ldw	r2,-28(fp)
811343a8:	1000030e 	bge	r2,zero,811343b8 <open+0x8c>
    {
      status = index;
811343ac:	e0bff917 	ldw	r2,-28(fp)
811343b0:	e0bffa15 	stw	r2,-24(fp)
811343b4:	00002306 	br	81134444 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
811343b8:	e0bff917 	ldw	r2,-28(fp)
811343bc:	10c00324 	muli	r3,r2,12
811343c0:	00a04574 	movhi	r2,33045
811343c4:	10b84b04 	addi	r2,r2,-7892
811343c8:	1885883a 	add	r2,r3,r2
811343cc:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
811343d0:	e0fffe17 	ldw	r3,-8(fp)
811343d4:	00900034 	movhi	r2,16384
811343d8:	10bfffc4 	addi	r2,r2,-1
811343dc:	1886703a 	and	r3,r3,r2
811343e0:	e0bffc17 	ldw	r2,-16(fp)
811343e4:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
811343e8:	e0bffb17 	ldw	r2,-20(fp)
811343ec:	1000051e 	bne	r2,zero,81134404 <open+0xd8>
811343f0:	e13ffc17 	ldw	r4,-16(fp)
811343f4:	11342600 	call	81134260 <alt_file_locked>
811343f8:	e0bffa15 	stw	r2,-24(fp)
811343fc:	e0bffa17 	ldw	r2,-24(fp)
81134400:	10001016 	blt	r2,zero,81134444 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81134404:	e0bff817 	ldw	r2,-32(fp)
81134408:	10800317 	ldw	r2,12(r2)
8113440c:	10000826 	beq	r2,zero,81134430 <open+0x104>
81134410:	e0bff817 	ldw	r2,-32(fp)
81134414:	10800317 	ldw	r2,12(r2)
81134418:	e1ffff17 	ldw	r7,-4(fp)
8113441c:	e1bffe17 	ldw	r6,-8(fp)
81134420:	e17ffd17 	ldw	r5,-12(fp)
81134424:	e13ffc17 	ldw	r4,-16(fp)
81134428:	103ee83a 	callr	r2
8113442c:	00000106 	br	81134434 <open+0x108>
81134430:	0005883a 	mov	r2,zero
81134434:	e0bffa15 	stw	r2,-24(fp)
81134438:	00000206 	br	81134444 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
8113443c:	00bffb44 	movi	r2,-19
81134440:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81134444:	e0bffa17 	ldw	r2,-24(fp)
81134448:	1000090e 	bge	r2,zero,81134470 <open+0x144>
  {
    alt_release_fd (index);  
8113444c:	e13ff917 	ldw	r4,-28(fp)
81134450:	11345d00 	call	811345d0 <alt_release_fd>
    ALT_ERRNO = -status;
81134454:	113421c0 	call	8113421c <alt_get_errno>
81134458:	1007883a 	mov	r3,r2
8113445c:	e0bffa17 	ldw	r2,-24(fp)
81134460:	0085c83a 	sub	r2,zero,r2
81134464:	18800015 	stw	r2,0(r3)
    return -1;
81134468:	00bfffc4 	movi	r2,-1
8113446c:	00000106 	br	81134474 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81134470:	e0bff917 	ldw	r2,-28(fp)
}
81134474:	e037883a 	mov	sp,fp
81134478:	dfc00117 	ldw	ra,4(sp)
8113447c:	df000017 	ldw	fp,0(sp)
81134480:	dec00204 	addi	sp,sp,8
81134484:	f800283a 	ret

81134488 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81134488:	defffe04 	addi	sp,sp,-8
8113448c:	de00012e 	bgeu	sp,et,81134494 <alt_get_errno+0xc>
81134490:	003b68fa 	trap	3
81134494:	dfc00115 	stw	ra,4(sp)
81134498:	df000015 	stw	fp,0(sp)
8113449c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811344a0:	d0a01017 	ldw	r2,-32704(gp)
811344a4:	10000326 	beq	r2,zero,811344b4 <alt_get_errno+0x2c>
811344a8:	d0a01017 	ldw	r2,-32704(gp)
811344ac:	103ee83a 	callr	r2
811344b0:	00000106 	br	811344b8 <alt_get_errno+0x30>
811344b4:	d0a07704 	addi	r2,gp,-32292
}
811344b8:	e037883a 	mov	sp,fp
811344bc:	dfc00117 	ldw	ra,4(sp)
811344c0:	df000017 	ldw	fp,0(sp)
811344c4:	dec00204 	addi	sp,sp,8
811344c8:	f800283a 	ret

811344cc <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
811344cc:	defff904 	addi	sp,sp,-28
811344d0:	de00012e 	bgeu	sp,et,811344d8 <read+0xc>
811344d4:	003b68fa 	trap	3
811344d8:	dfc00615 	stw	ra,24(sp)
811344dc:	df000515 	stw	fp,20(sp)
811344e0:	df000504 	addi	fp,sp,20
811344e4:	e13ffd15 	stw	r4,-12(fp)
811344e8:	e17ffe15 	stw	r5,-8(fp)
811344ec:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811344f0:	e0bffd17 	ldw	r2,-12(fp)
811344f4:	10000616 	blt	r2,zero,81134510 <read+0x44>
811344f8:	e0bffd17 	ldw	r2,-12(fp)
811344fc:	10c00324 	muli	r3,r2,12
81134500:	00a04574 	movhi	r2,33045
81134504:	10b84b04 	addi	r2,r2,-7892
81134508:	1885883a 	add	r2,r3,r2
8113450c:	00000106 	br	81134514 <read+0x48>
81134510:	0005883a 	mov	r2,zero
81134514:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81134518:	e0bffb17 	ldw	r2,-20(fp)
8113451c:	10002226 	beq	r2,zero,811345a8 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81134520:	e0bffb17 	ldw	r2,-20(fp)
81134524:	10800217 	ldw	r2,8(r2)
81134528:	108000cc 	andi	r2,r2,3
8113452c:	10800060 	cmpeqi	r2,r2,1
81134530:	1000181e 	bne	r2,zero,81134594 <read+0xc8>
        (fd->dev->read))
81134534:	e0bffb17 	ldw	r2,-20(fp)
81134538:	10800017 	ldw	r2,0(r2)
8113453c:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81134540:	10001426 	beq	r2,zero,81134594 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81134544:	e0bffb17 	ldw	r2,-20(fp)
81134548:	10800017 	ldw	r2,0(r2)
8113454c:	10800517 	ldw	r2,20(r2)
81134550:	e0ffff17 	ldw	r3,-4(fp)
81134554:	180d883a 	mov	r6,r3
81134558:	e17ffe17 	ldw	r5,-8(fp)
8113455c:	e13ffb17 	ldw	r4,-20(fp)
81134560:	103ee83a 	callr	r2
81134564:	e0bffc15 	stw	r2,-16(fp)
81134568:	e0bffc17 	ldw	r2,-16(fp)
8113456c:	1000070e 	bge	r2,zero,8113458c <read+0xc0>
        {
          ALT_ERRNO = -rval;
81134570:	11344880 	call	81134488 <alt_get_errno>
81134574:	1007883a 	mov	r3,r2
81134578:	e0bffc17 	ldw	r2,-16(fp)
8113457c:	0085c83a 	sub	r2,zero,r2
81134580:	18800015 	stw	r2,0(r3)
          return -1;
81134584:	00bfffc4 	movi	r2,-1
81134588:	00000c06 	br	811345bc <read+0xf0>
        }
        return rval;
8113458c:	e0bffc17 	ldw	r2,-16(fp)
81134590:	00000a06 	br	811345bc <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81134594:	11344880 	call	81134488 <alt_get_errno>
81134598:	1007883a 	mov	r3,r2
8113459c:	00800344 	movi	r2,13
811345a0:	18800015 	stw	r2,0(r3)
811345a4:	00000406 	br	811345b8 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
811345a8:	11344880 	call	81134488 <alt_get_errno>
811345ac:	1007883a 	mov	r3,r2
811345b0:	00801444 	movi	r2,81
811345b4:	18800015 	stw	r2,0(r3)
  }
  return -1;
811345b8:	00bfffc4 	movi	r2,-1
}
811345bc:	e037883a 	mov	sp,fp
811345c0:	dfc00117 	ldw	ra,4(sp)
811345c4:	df000017 	ldw	fp,0(sp)
811345c8:	dec00204 	addi	sp,sp,8
811345cc:	f800283a 	ret

811345d0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
811345d0:	defffe04 	addi	sp,sp,-8
811345d4:	de00012e 	bgeu	sp,et,811345dc <alt_release_fd+0xc>
811345d8:	003b68fa 	trap	3
811345dc:	df000115 	stw	fp,4(sp)
811345e0:	df000104 	addi	fp,sp,4
811345e4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
811345e8:	e0bfff17 	ldw	r2,-4(fp)
811345ec:	108000d0 	cmplti	r2,r2,3
811345f0:	10000d1e 	bne	r2,zero,81134628 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
811345f4:	00a04574 	movhi	r2,33045
811345f8:	10b84b04 	addi	r2,r2,-7892
811345fc:	e0ffff17 	ldw	r3,-4(fp)
81134600:	18c00324 	muli	r3,r3,12
81134604:	10c5883a 	add	r2,r2,r3
81134608:	10800204 	addi	r2,r2,8
8113460c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81134610:	00a04574 	movhi	r2,33045
81134614:	10b84b04 	addi	r2,r2,-7892
81134618:	e0ffff17 	ldw	r3,-4(fp)
8113461c:	18c00324 	muli	r3,r3,12
81134620:	10c5883a 	add	r2,r2,r3
81134624:	10000015 	stw	zero,0(r2)
  }
}
81134628:	0001883a 	nop
8113462c:	e037883a 	mov	sp,fp
81134630:	df000017 	ldw	fp,0(sp)
81134634:	dec00104 	addi	sp,sp,4
81134638:	f800283a 	ret

8113463c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
8113463c:	defff604 	addi	sp,sp,-40
81134640:	de00012e 	bgeu	sp,et,81134648 <sbrk+0xc>
81134644:	003b68fa 	trap	3
81134648:	df000915 	stw	fp,36(sp)
8113464c:	df000904 	addi	fp,sp,36
81134650:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134654:	0005303a 	rdctl	r2,status
81134658:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113465c:	e0fffe17 	ldw	r3,-8(fp)
81134660:	00bfff84 	movi	r2,-2
81134664:	1884703a 	and	r2,r3,r2
81134668:	1001703a 	wrctl	status,r2
  
  return context;
8113466c:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81134670:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81134674:	d0a01317 	ldw	r2,-32692(gp)
81134678:	10c000c4 	addi	r3,r2,3
8113467c:	00bfff04 	movi	r2,-4
81134680:	1884703a 	and	r2,r3,r2
81134684:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81134688:	d0e01317 	ldw	r3,-32692(gp)
8113468c:	e0bfff17 	ldw	r2,-4(fp)
81134690:	1887883a 	add	r3,r3,r2
81134694:	00a04834 	movhi	r2,33056
81134698:	10a80004 	addi	r2,r2,-24576
8113469c:	10c0062e 	bgeu	r2,r3,811346b8 <sbrk+0x7c>
811346a0:	e0bff817 	ldw	r2,-32(fp)
811346a4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811346a8:	e0bff717 	ldw	r2,-36(fp)
811346ac:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
811346b0:	00bfffc4 	movi	r2,-1
811346b4:	00001c06 	br	81134728 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
811346b8:	d0a01317 	ldw	r2,-32692(gp)
811346bc:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
811346c0:	d0e01317 	ldw	r3,-32692(gp)
811346c4:	e0bfff17 	ldw	r2,-4(fp)
811346c8:	1885883a 	add	r2,r3,r2
811346cc:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
811346d0:	c005883a 	mov	r2,et
811346d4:	e0bff915 	stw	r2,-28(fp)

  return limit; 
811346d8:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
811346dc:	e0bffa17 	ldw	r2,-24(fp)
811346e0:	18800c1e 	bne	r3,r2,81134714 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
811346e4:	d805883a 	mov	r2,sp
811346e8:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
811346ec:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
811346f0:	d0e01317 	ldw	r3,-32692(gp)
811346f4:	18800136 	bltu	r3,r2,811346fc <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
811346f8:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
811346fc:	d0a01317 	ldw	r2,-32692(gp)
81134700:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81134704:	e0bffc17 	ldw	r2,-16(fp)
81134708:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
8113470c:	e0bffc17 	ldw	r2,-16(fp)
81134710:	1031883a 	mov	et,r2
81134714:	e0bff817 	ldw	r2,-32(fp)
81134718:	e0bffd15 	stw	r2,-12(fp)
8113471c:	e0bffd17 	ldw	r2,-12(fp)
81134720:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81134724:	e0bffa17 	ldw	r2,-24(fp)
} 
81134728:	e037883a 	mov	sp,fp
8113472c:	df000017 	ldw	fp,0(sp)
81134730:	dec00104 	addi	sp,sp,4
81134734:	f800283a 	ret

81134738 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81134738:	defffa04 	addi	sp,sp,-24
8113473c:	de00012e 	bgeu	sp,et,81134744 <alt_alarm_stop+0xc>
81134740:	003b68fa 	trap	3
81134744:	df000515 	stw	fp,20(sp)
81134748:	df000504 	addi	fp,sp,20
8113474c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134750:	0005303a 	rdctl	r2,status
81134754:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134758:	e0fffc17 	ldw	r3,-16(fp)
8113475c:	00bfff84 	movi	r2,-2
81134760:	1884703a 	and	r2,r3,r2
81134764:	1001703a 	wrctl	status,r2
  
  return context;
81134768:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
8113476c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81134770:	e0bfff17 	ldw	r2,-4(fp)
81134774:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81134778:	e0bffd17 	ldw	r2,-12(fp)
8113477c:	10800017 	ldw	r2,0(r2)
81134780:	e0fffd17 	ldw	r3,-12(fp)
81134784:	18c00117 	ldw	r3,4(r3)
81134788:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
8113478c:	e0bffd17 	ldw	r2,-12(fp)
81134790:	10800117 	ldw	r2,4(r2)
81134794:	e0fffd17 	ldw	r3,-12(fp)
81134798:	18c00017 	ldw	r3,0(r3)
8113479c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
811347a0:	e0bffd17 	ldw	r2,-12(fp)
811347a4:	e0fffd17 	ldw	r3,-12(fp)
811347a8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
811347ac:	e0bffd17 	ldw	r2,-12(fp)
811347b0:	e0fffd17 	ldw	r3,-12(fp)
811347b4:	10c00015 	stw	r3,0(r2)
811347b8:	e0bffb17 	ldw	r2,-20(fp)
811347bc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811347c0:	e0bffe17 	ldw	r2,-8(fp)
811347c4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
811347c8:	0001883a 	nop
811347cc:	e037883a 	mov	sp,fp
811347d0:	df000017 	ldw	fp,0(sp)
811347d4:	dec00104 	addi	sp,sp,4
811347d8:	f800283a 	ret

811347dc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
811347dc:	defffb04 	addi	sp,sp,-20
811347e0:	de00012e 	bgeu	sp,et,811347e8 <alt_tick+0xc>
811347e4:	003b68fa 	trap	3
811347e8:	dfc00415 	stw	ra,16(sp)
811347ec:	df000315 	stw	fp,12(sp)
811347f0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
811347f4:	d0a01417 	ldw	r2,-32688(gp)
811347f8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
811347fc:	d0a08817 	ldw	r2,-32224(gp)
81134800:	10800044 	addi	r2,r2,1
81134804:	d0a08815 	stw	r2,-32224(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81134808:	00002e06 	br	811348c4 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
8113480c:	e0bffd17 	ldw	r2,-12(fp)
81134810:	10800017 	ldw	r2,0(r2)
81134814:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81134818:	e0bffd17 	ldw	r2,-12(fp)
8113481c:	10800403 	ldbu	r2,16(r2)
81134820:	10803fcc 	andi	r2,r2,255
81134824:	10000426 	beq	r2,zero,81134838 <alt_tick+0x5c>
81134828:	d0a08817 	ldw	r2,-32224(gp)
8113482c:	1000021e 	bne	r2,zero,81134838 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81134830:	e0bffd17 	ldw	r2,-12(fp)
81134834:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81134838:	e0bffd17 	ldw	r2,-12(fp)
8113483c:	10800217 	ldw	r2,8(r2)
81134840:	d0e08817 	ldw	r3,-32224(gp)
81134844:	18801d36 	bltu	r3,r2,811348bc <alt_tick+0xe0>
81134848:	e0bffd17 	ldw	r2,-12(fp)
8113484c:	10800403 	ldbu	r2,16(r2)
81134850:	10803fcc 	andi	r2,r2,255
81134854:	1000191e 	bne	r2,zero,811348bc <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81134858:	e0bffd17 	ldw	r2,-12(fp)
8113485c:	10800317 	ldw	r2,12(r2)
81134860:	e0fffd17 	ldw	r3,-12(fp)
81134864:	18c00517 	ldw	r3,20(r3)
81134868:	1809883a 	mov	r4,r3
8113486c:	103ee83a 	callr	r2
81134870:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81134874:	e0bfff17 	ldw	r2,-4(fp)
81134878:	1000031e 	bne	r2,zero,81134888 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
8113487c:	e13ffd17 	ldw	r4,-12(fp)
81134880:	11347380 	call	81134738 <alt_alarm_stop>
81134884:	00000d06 	br	811348bc <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81134888:	e0bffd17 	ldw	r2,-12(fp)
8113488c:	10c00217 	ldw	r3,8(r2)
81134890:	e0bfff17 	ldw	r2,-4(fp)
81134894:	1887883a 	add	r3,r3,r2
81134898:	e0bffd17 	ldw	r2,-12(fp)
8113489c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
811348a0:	e0bffd17 	ldw	r2,-12(fp)
811348a4:	10c00217 	ldw	r3,8(r2)
811348a8:	d0a08817 	ldw	r2,-32224(gp)
811348ac:	1880032e 	bgeu	r3,r2,811348bc <alt_tick+0xe0>
        {
          alarm->rollover = 1;
811348b0:	e0bffd17 	ldw	r2,-12(fp)
811348b4:	00c00044 	movi	r3,1
811348b8:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
811348bc:	e0bffe17 	ldw	r2,-8(fp)
811348c0:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
811348c4:	e0fffd17 	ldw	r3,-12(fp)
811348c8:	d0a01404 	addi	r2,gp,-32688
811348cc:	18bfcf1e 	bne	r3,r2,8113480c <__reset+0xfb11480c>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
811348d0:	1135b0c0 	call	81135b0c <OSTimeTick>
}
811348d4:	0001883a 	nop
811348d8:	e037883a 	mov	sp,fp
811348dc:	dfc00117 	ldw	ra,4(sp)
811348e0:	df000017 	ldw	fp,0(sp)
811348e4:	dec00204 	addi	sp,sp,8
811348e8:	f800283a 	ret

811348ec <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
811348ec:	defffb04 	addi	sp,sp,-20
811348f0:	de00012e 	bgeu	sp,et,811348f8 <usleep+0xc>
811348f4:	003b68fa 	trap	3
811348f8:	dfc00415 	stw	ra,16(sp)
811348fc:	df000315 	stw	fp,12(sp)
81134900:	df000304 	addi	fp,sp,12
81134904:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81134908:	d0a09003 	ldbu	r2,-32192(gp)
8113490c:	10803fcc 	andi	r2,r2,255
81134910:	1000031e 	bne	r2,zero,81134920 <usleep+0x34>
  {
    return alt_busy_sleep (us);
81134914:	e13fff17 	ldw	r4,-4(fp)
81134918:	1132e780 	call	81132e78 <alt_busy_sleep>
8113491c:	00003d06 	br	81134a14 <usleep+0x128>
81134920:	d0a08717 	ldw	r2,-32228(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81134924:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81134928:	e0ffff17 	ldw	r3,-4(fp)
8113492c:	0090c734 	movhi	r2,17180
81134930:	10b7a0c4 	addi	r2,r2,-8573
81134934:	1888383a 	mulxuu	r4,r3,r2
81134938:	1885383a 	mul	r2,r3,r2
8113493c:	1013883a 	mov	r9,r2
81134940:	2015883a 	mov	r10,r4
81134944:	5006d4ba 	srli	r3,r10,18
81134948:	e0bffe17 	ldw	r2,-8(fp)
8113494c:	1893383a 	mul	r9,r3,r2
81134950:	e0ffff17 	ldw	r3,-4(fp)
81134954:	0090c734 	movhi	r2,17180
81134958:	10b7a0c4 	addi	r2,r2,-8573
8113495c:	1888383a 	mulxuu	r4,r3,r2
81134960:	1885383a 	mul	r2,r3,r2
81134964:	100f883a 	mov	r7,r2
81134968:	2011883a 	mov	r8,r4
8113496c:	4004d4ba 	srli	r2,r8,18
81134970:	010003f4 	movhi	r4,15
81134974:	21109004 	addi	r4,r4,16960
81134978:	1105383a 	mul	r2,r2,r4
8113497c:	1885c83a 	sub	r2,r3,r2
81134980:	e0fffe17 	ldw	r3,-8(fp)
81134984:	10c7383a 	mul	r3,r2,r3
81134988:	0090c734 	movhi	r2,17180
8113498c:	10b7a0c4 	addi	r2,r2,-8573
81134990:	1888383a 	mulxuu	r4,r3,r2
81134994:	1885383a 	mul	r2,r3,r2
81134998:	100b883a 	mov	r5,r2
8113499c:	200d883a 	mov	r6,r4
811349a0:	3004d4ba 	srli	r2,r6,18
811349a4:	4885883a 	add	r2,r9,r2
811349a8:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
811349ac:	00000706 	br	811349cc <usleep+0xe0>
  {
    OSTimeDly(0xffff);
811349b0:	013fffd4 	movui	r4,65535
811349b4:	113d57c0 	call	8113d57c <OSTimeDly>
    ticks -= 0xffff;
811349b8:	e0fffd17 	ldw	r3,-12(fp)
811349bc:	00bffff4 	movhi	r2,65535
811349c0:	10800044 	addi	r2,r2,1
811349c4:	1885883a 	add	r2,r3,r2
811349c8:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
811349cc:	e0bffd17 	ldw	r2,-12(fp)
811349d0:	00ffffd4 	movui	r3,65535
811349d4:	18bff636 	bltu	r3,r2,811349b0 <__reset+0xfb1149b0>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
811349d8:	e0bffd17 	ldw	r2,-12(fp)
811349dc:	10bfffcc 	andi	r2,r2,65535
811349e0:	1009883a 	mov	r4,r2
811349e4:	113d57c0 	call	8113d57c <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
811349e8:	008003f4 	movhi	r2,15
811349ec:	10909004 	addi	r2,r2,16960
811349f0:	e0fffe17 	ldw	r3,-8(fp)
811349f4:	10c7203a 	divu	r3,r2,r3
811349f8:	e0bfff17 	ldw	r2,-4(fp)
811349fc:	10c9203a 	divu	r4,r2,r3
81134a00:	20c7383a 	mul	r3,r4,r3
81134a04:	10c5c83a 	sub	r2,r2,r3
81134a08:	1009883a 	mov	r4,r2
81134a0c:	1132e780 	call	81132e78 <alt_busy_sleep>

  return 0;  
81134a10:	0005883a 	mov	r2,zero
}
81134a14:	e037883a 	mov	sp,fp
81134a18:	dfc00117 	ldw	ra,4(sp)
81134a1c:	df000017 	ldw	fp,0(sp)
81134a20:	dec00204 	addi	sp,sp,8
81134a24:	f800283a 	ret

81134a28 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81134a28:	defffe04 	addi	sp,sp,-8
81134a2c:	de00012e 	bgeu	sp,et,81134a34 <alt_get_errno+0xc>
81134a30:	003b68fa 	trap	3
81134a34:	dfc00115 	stw	ra,4(sp)
81134a38:	df000015 	stw	fp,0(sp)
81134a3c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81134a40:	d0a01017 	ldw	r2,-32704(gp)
81134a44:	10000326 	beq	r2,zero,81134a54 <alt_get_errno+0x2c>
81134a48:	d0a01017 	ldw	r2,-32704(gp)
81134a4c:	103ee83a 	callr	r2
81134a50:	00000106 	br	81134a58 <alt_get_errno+0x30>
81134a54:	d0a07704 	addi	r2,gp,-32292
}
81134a58:	e037883a 	mov	sp,fp
81134a5c:	dfc00117 	ldw	ra,4(sp)
81134a60:	df000017 	ldw	fp,0(sp)
81134a64:	dec00204 	addi	sp,sp,8
81134a68:	f800283a 	ret

81134a6c <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81134a6c:	defff904 	addi	sp,sp,-28
81134a70:	de00012e 	bgeu	sp,et,81134a78 <write+0xc>
81134a74:	003b68fa 	trap	3
81134a78:	dfc00615 	stw	ra,24(sp)
81134a7c:	df000515 	stw	fp,20(sp)
81134a80:	df000504 	addi	fp,sp,20
81134a84:	e13ffd15 	stw	r4,-12(fp)
81134a88:	e17ffe15 	stw	r5,-8(fp)
81134a8c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81134a90:	e0bffd17 	ldw	r2,-12(fp)
81134a94:	10000616 	blt	r2,zero,81134ab0 <write+0x44>
81134a98:	e0bffd17 	ldw	r2,-12(fp)
81134a9c:	10c00324 	muli	r3,r2,12
81134aa0:	00a04574 	movhi	r2,33045
81134aa4:	10b84b04 	addi	r2,r2,-7892
81134aa8:	1885883a 	add	r2,r3,r2
81134aac:	00000106 	br	81134ab4 <write+0x48>
81134ab0:	0005883a 	mov	r2,zero
81134ab4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81134ab8:	e0bffb17 	ldw	r2,-20(fp)
81134abc:	10002426 	beq	r2,zero,81134b50 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81134ac0:	e0bffb17 	ldw	r2,-20(fp)
81134ac4:	10800217 	ldw	r2,8(r2)
81134ac8:	108000cc 	andi	r2,r2,3
81134acc:	10001b26 	beq	r2,zero,81134b3c <write+0xd0>
81134ad0:	e0bffb17 	ldw	r2,-20(fp)
81134ad4:	10800017 	ldw	r2,0(r2)
81134ad8:	10800617 	ldw	r2,24(r2)
81134adc:	10001726 	beq	r2,zero,81134b3c <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81134ae0:	e17fff17 	ldw	r5,-4(fp)
81134ae4:	e13ffe17 	ldw	r4,-8(fp)
81134ae8:	1133dec0 	call	81133dec <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81134aec:	e0bffb17 	ldw	r2,-20(fp)
81134af0:	10800017 	ldw	r2,0(r2)
81134af4:	10800617 	ldw	r2,24(r2)
81134af8:	e0ffff17 	ldw	r3,-4(fp)
81134afc:	180d883a 	mov	r6,r3
81134b00:	e17ffe17 	ldw	r5,-8(fp)
81134b04:	e13ffb17 	ldw	r4,-20(fp)
81134b08:	103ee83a 	callr	r2
81134b0c:	e0bffc15 	stw	r2,-16(fp)
81134b10:	e0bffc17 	ldw	r2,-16(fp)
81134b14:	1000070e 	bge	r2,zero,81134b34 <write+0xc8>
      {
        ALT_ERRNO = -rval;
81134b18:	1134a280 	call	81134a28 <alt_get_errno>
81134b1c:	1007883a 	mov	r3,r2
81134b20:	e0bffc17 	ldw	r2,-16(fp)
81134b24:	0085c83a 	sub	r2,zero,r2
81134b28:	18800015 	stw	r2,0(r3)
        return -1;
81134b2c:	00bfffc4 	movi	r2,-1
81134b30:	00000c06 	br	81134b64 <write+0xf8>
      }
      return rval;
81134b34:	e0bffc17 	ldw	r2,-16(fp)
81134b38:	00000a06 	br	81134b64 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81134b3c:	1134a280 	call	81134a28 <alt_get_errno>
81134b40:	1007883a 	mov	r3,r2
81134b44:	00800344 	movi	r2,13
81134b48:	18800015 	stw	r2,0(r3)
81134b4c:	00000406 	br	81134b60 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81134b50:	1134a280 	call	81134a28 <alt_get_errno>
81134b54:	1007883a 	mov	r3,r2
81134b58:	00801444 	movi	r2,81
81134b5c:	18800015 	stw	r2,0(r3)
  }
  return -1;
81134b60:	00bfffc4 	movi	r2,-1
}
81134b64:	e037883a 	mov	sp,fp
81134b68:	dfc00117 	ldw	ra,4(sp)
81134b6c:	df000017 	ldw	fp,0(sp)
81134b70:	dec00204 	addi	sp,sp,8
81134b74:	f800283a 	ret

81134b78 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81134b78:	deffde04 	addi	sp,sp,-136
81134b7c:	de00012e 	bgeu	sp,et,81134b84 <__env_lock+0xc>
81134b80:	003b68fa 	trap	3
81134b84:	dfc02115 	stw	ra,132(sp)
81134b88:	df002015 	stw	fp,128(sp)
81134b8c:	df002004 	addi	fp,sp,128
81134b90:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81134b94:	e0bfe104 	addi	r2,fp,-124
81134b98:	100b883a 	mov	r5,r2
81134b9c:	01003fc4 	movi	r4,255
81134ba0:	113d3d80 	call	8113d3d8 <OSTaskQuery>
81134ba4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81134ba8:	e0bffe83 	ldbu	r2,-6(fp)
81134bac:	10803fcc 	andi	r2,r2,255
81134bb0:	10001e1e 	bne	r2,zero,81134c2c <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81134bb4:	e0bfed83 	ldbu	r2,-74(fp)
81134bb8:	10803fcc 	andi	r2,r2,255
81134bbc:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81134bc0:	d0a08a17 	ldw	r2,-32216(gp)
81134bc4:	e0fffc04 	addi	r3,fp,-16
81134bc8:	180b883a 	mov	r5,r3
81134bcc:	1009883a 	mov	r4,r2
81134bd0:	113bb900 	call	8113bb90 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81134bd4:	e0bffe03 	ldbu	r2,-8(fp)
81134bd8:	10803fcc 	andi	r2,r2,255
81134bdc:	10000726 	beq	r2,zero,81134bfc <__env_lock+0x84>
81134be0:	d0a01617 	ldw	r2,-32680(gp)
81134be4:	e0ffe017 	ldw	r3,-128(fp)
81134be8:	1880041e 	bne	r3,r2,81134bfc <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81134bec:	d0a08917 	ldw	r2,-32220(gp)
81134bf0:	10800044 	addi	r2,r2,1
81134bf4:	d0a08915 	stw	r2,-32220(gp)
81134bf8:	00000a06 	br	81134c24 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81134bfc:	d0a08a17 	ldw	r2,-32216(gp)
81134c00:	e0fffe84 	addi	r3,fp,-6
81134c04:	180d883a 	mov	r6,r3
81134c08:	000b883a 	mov	r5,zero
81134c0c:	1009883a 	mov	r4,r2
81134c10:	113b6f00 	call	8113b6f0 <OSSemPend>
    locks  = 1;
81134c14:	00800044 	movi	r2,1
81134c18:	d0a08915 	stw	r2,-32220(gp)
    lockid = id;
81134c1c:	e0bfe017 	ldw	r2,-128(fp)
81134c20:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81134c24:	0001883a 	nop
81134c28:	00000106 	br	81134c30 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81134c2c:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81134c30:	e037883a 	mov	sp,fp
81134c34:	dfc00117 	ldw	ra,4(sp)
81134c38:	df000017 	ldw	fp,0(sp)
81134c3c:	dec00204 	addi	sp,sp,8
81134c40:	f800283a 	ret

81134c44 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81134c44:	defffd04 	addi	sp,sp,-12
81134c48:	de00012e 	bgeu	sp,et,81134c50 <__env_unlock+0xc>
81134c4c:	003b68fa 	trap	3
81134c50:	dfc00215 	stw	ra,8(sp)
81134c54:	df000115 	stw	fp,4(sp)
81134c58:	df000104 	addi	fp,sp,4
81134c5c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81134c60:	d0a08917 	ldw	r2,-32220(gp)
81134c64:	10000b26 	beq	r2,zero,81134c94 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81134c68:	d0a08917 	ldw	r2,-32220(gp)
81134c6c:	10bfffc4 	addi	r2,r2,-1
81134c70:	d0a08915 	stw	r2,-32220(gp)
81134c74:	d0a08917 	ldw	r2,-32220(gp)
81134c78:	1000071e 	bne	r2,zero,81134c98 <__env_unlock+0x54>
  {
    lockid = -1;
81134c7c:	00bfffc4 	movi	r2,-1
81134c80:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81134c84:	d0a08a17 	ldw	r2,-32216(gp)
81134c88:	1009883a 	mov	r4,r2
81134c8c:	113ba780 	call	8113ba78 <OSSemPost>
81134c90:	00000106 	br	81134c98 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81134c94:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81134c98:	e037883a 	mov	sp,fp
81134c9c:	dfc00117 	ldw	ra,4(sp)
81134ca0:	df000017 	ldw	fp,0(sp)
81134ca4:	dec00204 	addi	sp,sp,8
81134ca8:	f800283a 	ret

81134cac <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81134cac:	deffda04 	addi	sp,sp,-152
81134cb0:	de00012e 	bgeu	sp,et,81134cb8 <__malloc_lock+0xc>
81134cb4:	003b68fa 	trap	3
81134cb8:	dfc02515 	stw	ra,148(sp)
81134cbc:	df002415 	stw	fp,144(sp)
81134cc0:	df002404 	addi	fp,sp,144
81134cc4:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134cc8:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81134ccc:	d0a09003 	ldbu	r2,-32192(gp)
81134cd0:	10803fcc 	andi	r2,r2,255
81134cd4:	10800060 	cmpeqi	r2,r2,1
81134cd8:	10003626 	beq	r2,zero,81134db4 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81134cdc:	e0bfe104 	addi	r2,fp,-124
81134ce0:	100b883a 	mov	r5,r2
81134ce4:	01003fc4 	movi	r4,255
81134ce8:	113d3d80 	call	8113d3d8 <OSTaskQuery>
81134cec:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81134cf0:	e0bffe83 	ldbu	r2,-6(fp)
81134cf4:	10803fcc 	andi	r2,r2,255
81134cf8:	1000301e 	bne	r2,zero,81134dbc <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81134cfc:	e0bfed83 	ldbu	r2,-74(fp)
81134d00:	10803fcc 	andi	r2,r2,255
81134d04:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81134d08:	d0a08c17 	ldw	r2,-32208(gp)
81134d0c:	e0fffc04 	addi	r3,fp,-16
81134d10:	180b883a 	mov	r5,r3
81134d14:	1009883a 	mov	r4,r2
81134d18:	113bb900 	call	8113bb90 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134d1c:	0005303a 	rdctl	r2,status
81134d20:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134d24:	e0ffe017 	ldw	r3,-128(fp)
81134d28:	00bfff84 	movi	r2,-2
81134d2c:	1884703a 	and	r2,r3,r2
81134d30:	1001703a 	wrctl	status,r2
  
  return context;
81134d34:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81134d38:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81134d3c:	e0bffc0b 	ldhu	r2,-16(fp)
81134d40:	10bfffcc 	andi	r2,r2,65535
81134d44:	10000b1e 	bne	r2,zero,81134d74 <__malloc_lock+0xc8>
81134d48:	d0a01717 	ldw	r2,-32676(gp)
81134d4c:	e0ffdd17 	ldw	r3,-140(fp)
81134d50:	1880081e 	bne	r3,r2,81134d74 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81134d54:	d0a08b17 	ldw	r2,-32212(gp)
81134d58:	10800044 	addi	r2,r2,1
81134d5c:	d0a08b15 	stw	r2,-32212(gp)
81134d60:	e0bfdc17 	ldw	r2,-144(fp)
81134d64:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134d68:	e0bfde17 	ldw	r2,-136(fp)
81134d6c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81134d70:	00000e06 	br	81134dac <__malloc_lock+0x100>
81134d74:	e0bfdc17 	ldw	r2,-144(fp)
81134d78:	e0bfdf15 	stw	r2,-132(fp)
81134d7c:	e0bfdf17 	ldw	r2,-132(fp)
81134d80:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81134d84:	d0a08c17 	ldw	r2,-32208(gp)
81134d88:	e0fffe84 	addi	r3,fp,-6
81134d8c:	180d883a 	mov	r6,r3
81134d90:	000b883a 	mov	r5,zero
81134d94:	1009883a 	mov	r4,r2
81134d98:	113b6f00 	call	8113b6f0 <OSSemPend>
    locks  = 1;
81134d9c:	00800044 	movi	r2,1
81134da0:	d0a08b15 	stw	r2,-32212(gp)
    lockid = id;
81134da4:	e0bfdd17 	ldw	r2,-140(fp)
81134da8:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81134dac:	0001883a 	nop
81134db0:	00000306 	br	81134dc0 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81134db4:	0001883a 	nop
81134db8:	00000106 	br	81134dc0 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81134dbc:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81134dc0:	e037883a 	mov	sp,fp
81134dc4:	dfc00117 	ldw	ra,4(sp)
81134dc8:	df000017 	ldw	fp,0(sp)
81134dcc:	dec00204 	addi	sp,sp,8
81134dd0:	f800283a 	ret

81134dd4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
81134dd4:	defff804 	addi	sp,sp,-32
81134dd8:	de00012e 	bgeu	sp,et,81134de0 <__malloc_unlock+0xc>
81134ddc:	003b68fa 	trap	3
81134de0:	dfc00715 	stw	ra,28(sp)
81134de4:	df000615 	stw	fp,24(sp)
81134de8:	df000604 	addi	fp,sp,24
81134dec:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134df0:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
81134df4:	d0a09003 	ldbu	r2,-32192(gp)
81134df8:	10803fcc 	andi	r2,r2,255
81134dfc:	10800060 	cmpeqi	r2,r2,1
81134e00:	10002326 	beq	r2,zero,81134e90 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134e04:	0005303a 	rdctl	r2,status
81134e08:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134e0c:	e0fffe17 	ldw	r3,-8(fp)
81134e10:	00bfff84 	movi	r2,-2
81134e14:	1884703a 	and	r2,r3,r2
81134e18:	1001703a 	wrctl	status,r2
  
  return context;
81134e1c:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81134e20:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81134e24:	d0a08b17 	ldw	r2,-32212(gp)
81134e28:	1000051e 	bne	r2,zero,81134e40 <__malloc_unlock+0x6c>
81134e2c:	e0bffa17 	ldw	r2,-24(fp)
81134e30:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134e34:	e0bffb17 	ldw	r2,-20(fp)
81134e38:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81134e3c:	00001506 	br	81134e94 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81134e40:	d0a08b17 	ldw	r2,-32212(gp)
81134e44:	10bfffc4 	addi	r2,r2,-1
81134e48:	d0a08b15 	stw	r2,-32212(gp)
81134e4c:	d0a08b17 	ldw	r2,-32212(gp)
81134e50:	10000a1e 	bne	r2,zero,81134e7c <__malloc_unlock+0xa8>
  {
    lockid = -1;
81134e54:	00bfffc4 	movi	r2,-1
81134e58:	d0a01715 	stw	r2,-32676(gp)
81134e5c:	e0bffa17 	ldw	r2,-24(fp)
81134e60:	e0bffc15 	stw	r2,-16(fp)
81134e64:	e0bffc17 	ldw	r2,-16(fp)
81134e68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81134e6c:	d0a08c17 	ldw	r2,-32208(gp)
81134e70:	1009883a 	mov	r4,r2
81134e74:	113ba780 	call	8113ba78 <OSSemPost>
81134e78:	00000606 	br	81134e94 <__malloc_unlock+0xc0>
81134e7c:	e0bffa17 	ldw	r2,-24(fp)
81134e80:	e0bffd15 	stw	r2,-12(fp)
81134e84:	e0bffd17 	ldw	r2,-12(fp)
81134e88:	1001703a 	wrctl	status,r2
81134e8c:	00000106 	br	81134e94 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81134e90:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81134e94:	e037883a 	mov	sp,fp
81134e98:	dfc00117 	ldw	ra,4(sp)
81134e9c:	df000017 	ldw	fp,0(sp)
81134ea0:	dec00204 	addi	sp,sp,8
81134ea4:	f800283a 	ret

81134ea8 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81134ea8:	defff704 	addi	sp,sp,-36
81134eac:	de00012e 	bgeu	sp,et,81134eb4 <OSEventNameGet+0xc>
81134eb0:	003b68fa 	trap	3
81134eb4:	dfc00815 	stw	ra,32(sp)
81134eb8:	df000715 	stw	fp,28(sp)
81134ebc:	df000704 	addi	fp,sp,28
81134ec0:	e13ffd15 	stw	r4,-12(fp)
81134ec4:	e17ffe15 	stw	r5,-8(fp)
81134ec8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134ecc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81134ed0:	e0bfff17 	ldw	r2,-4(fp)
81134ed4:	1000021e 	bne	r2,zero,81134ee0 <OSEventNameGet+0x38>
        return (0);
81134ed8:	0005883a 	mov	r2,zero
81134edc:	00003706 	br	81134fbc <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81134ee0:	e0bffd17 	ldw	r2,-12(fp)
81134ee4:	1000051e 	bne	r2,zero,81134efc <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81134ee8:	e0bfff17 	ldw	r2,-4(fp)
81134eec:	00c00104 	movi	r3,4
81134ef0:	10c00005 	stb	r3,0(r2)
        return (0);
81134ef4:	0005883a 	mov	r2,zero
81134ef8:	00003006 	br	81134fbc <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81134efc:	e0bffe17 	ldw	r2,-8(fp)
81134f00:	1000051e 	bne	r2,zero,81134f18 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81134f04:	e0bfff17 	ldw	r2,-4(fp)
81134f08:	00c00304 	movi	r3,12
81134f0c:	10c00005 	stb	r3,0(r2)
        return (0);
81134f10:	0005883a 	mov	r2,zero
81134f14:	00002906 	br	81134fbc <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81134f18:	d0a0a003 	ldbu	r2,-32128(gp)
81134f1c:	10803fcc 	andi	r2,r2,255
81134f20:	10000526 	beq	r2,zero,81134f38 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81134f24:	e0bfff17 	ldw	r2,-4(fp)
81134f28:	00c00444 	movi	r3,17
81134f2c:	10c00005 	stb	r3,0(r2)
        return (0);
81134f30:	0005883a 	mov	r2,zero
81134f34:	00002106 	br	81134fbc <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81134f38:	e0bffd17 	ldw	r2,-12(fp)
81134f3c:	10800003 	ldbu	r2,0(r2)
81134f40:	10803fcc 	andi	r2,r2,255
81134f44:	10bfffc4 	addi	r2,r2,-1
81134f48:	10800128 	cmpgeui	r2,r2,4
81134f4c:	10000526 	beq	r2,zero,81134f64 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81134f50:	e0bfff17 	ldw	r2,-4(fp)
81134f54:	00c00044 	movi	r3,1
81134f58:	10c00005 	stb	r3,0(r2)
             return (0);
81134f5c:	0005883a 	mov	r2,zero
81134f60:	00001606 	br	81134fbc <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81134f64:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134f68:	0005303a 	rdctl	r2,status
81134f6c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134f70:	e0fffb17 	ldw	r3,-20(fp)
81134f74:	00bfff84 	movi	r2,-2
81134f78:	1884703a 	and	r2,r3,r2
81134f7c:	1001703a 	wrctl	status,r2
  
  return context;
81134f80:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81134f84:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81134f88:	e0bffd17 	ldw	r2,-12(fp)
81134f8c:	10800444 	addi	r2,r2,17
81134f90:	100b883a 	mov	r5,r2
81134f94:	e13ffe17 	ldw	r4,-8(fp)
81134f98:	11369940 	call	81136994 <OS_StrCopy>
81134f9c:	e0bffa05 	stb	r2,-24(fp)
81134fa0:	e0bff917 	ldw	r2,-28(fp)
81134fa4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134fa8:	e0bffc17 	ldw	r2,-16(fp)
81134fac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81134fb0:	e0bfff17 	ldw	r2,-4(fp)
81134fb4:	10000005 	stb	zero,0(r2)
    return (len);
81134fb8:	e0bffa03 	ldbu	r2,-24(fp)
}
81134fbc:	e037883a 	mov	sp,fp
81134fc0:	dfc00117 	ldw	ra,4(sp)
81134fc4:	df000017 	ldw	fp,0(sp)
81134fc8:	dec00204 	addi	sp,sp,8
81134fcc:	f800283a 	ret

81134fd0 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81134fd0:	defff604 	addi	sp,sp,-40
81134fd4:	de00012e 	bgeu	sp,et,81134fdc <OSEventNameSet+0xc>
81134fd8:	003b68fa 	trap	3
81134fdc:	dfc00915 	stw	ra,36(sp)
81134fe0:	df000815 	stw	fp,32(sp)
81134fe4:	df000804 	addi	fp,sp,32
81134fe8:	e13ffd15 	stw	r4,-12(fp)
81134fec:	e17ffe15 	stw	r5,-8(fp)
81134ff0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134ff4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81134ff8:	e0bfff17 	ldw	r2,-4(fp)
81134ffc:	10004026 	beq	r2,zero,81135100 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81135000:	e0bffd17 	ldw	r2,-12(fp)
81135004:	1000041e 	bne	r2,zero,81135018 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81135008:	e0bfff17 	ldw	r2,-4(fp)
8113500c:	00c00104 	movi	r3,4
81135010:	10c00005 	stb	r3,0(r2)
        return;
81135014:	00003b06 	br	81135104 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81135018:	e0bffe17 	ldw	r2,-8(fp)
8113501c:	1000041e 	bne	r2,zero,81135030 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81135020:	e0bfff17 	ldw	r2,-4(fp)
81135024:	00c00304 	movi	r3,12
81135028:	10c00005 	stb	r3,0(r2)
        return;
8113502c:	00003506 	br	81135104 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81135030:	d0a0a003 	ldbu	r2,-32128(gp)
81135034:	10803fcc 	andi	r2,r2,255
81135038:	10000426 	beq	r2,zero,8113504c <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113503c:	e0bfff17 	ldw	r2,-4(fp)
81135040:	00c00484 	movi	r3,18
81135044:	10c00005 	stb	r3,0(r2)
        return;
81135048:	00002e06 	br	81135104 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
8113504c:	e0bffd17 	ldw	r2,-12(fp)
81135050:	10800003 	ldbu	r2,0(r2)
81135054:	10803fcc 	andi	r2,r2,255
81135058:	10bfffc4 	addi	r2,r2,-1
8113505c:	10800128 	cmpgeui	r2,r2,4
81135060:	10000426 	beq	r2,zero,81135074 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81135064:	e0bfff17 	ldw	r2,-4(fp)
81135068:	00c00044 	movi	r3,1
8113506c:	10c00005 	stb	r3,0(r2)
             return;
81135070:	00002406 	br	81135104 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81135074:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135078:	0005303a 	rdctl	r2,status
8113507c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135080:	e0fffc17 	ldw	r3,-16(fp)
81135084:	00bfff84 	movi	r2,-2
81135088:	1884703a 	and	r2,r3,r2
8113508c:	1001703a 	wrctl	status,r2
  
  return context;
81135090:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81135094:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
81135098:	e13ffe17 	ldw	r4,-8(fp)
8113509c:	1136a100 	call	81136a10 <OS_StrLen>
811350a0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
811350a4:	e0bffa03 	ldbu	r2,-24(fp)
811350a8:	10800830 	cmpltui	r2,r2,32
811350ac:	1000081e 	bne	r2,zero,811350d0 <OSEventNameSet+0x100>
811350b0:	e0bff817 	ldw	r2,-32(fp)
811350b4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811350b8:	e0bff917 	ldw	r2,-28(fp)
811350bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
811350c0:	e0bfff17 	ldw	r2,-4(fp)
811350c4:	00c002c4 	movi	r3,11
811350c8:	10c00005 	stb	r3,0(r2)
        return;
811350cc:	00000d06 	br	81135104 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
811350d0:	e0bffd17 	ldw	r2,-12(fp)
811350d4:	10800444 	addi	r2,r2,17
811350d8:	e17ffe17 	ldw	r5,-8(fp)
811350dc:	1009883a 	mov	r4,r2
811350e0:	11369940 	call	81136994 <OS_StrCopy>
811350e4:	e0bff817 	ldw	r2,-32(fp)
811350e8:	e0bffb15 	stw	r2,-20(fp)
811350ec:	e0bffb17 	ldw	r2,-20(fp)
811350f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811350f4:	e0bfff17 	ldw	r2,-4(fp)
811350f8:	10000005 	stb	zero,0(r2)
811350fc:	00000106 	br	81135104 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81135100:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81135104:	e037883a 	mov	sp,fp
81135108:	dfc00117 	ldw	ra,4(sp)
8113510c:	df000017 	ldw	fp,0(sp)
81135110:	dec00204 	addi	sp,sp,8
81135114:	f800283a 	ret

81135118 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
81135118:	deffed04 	addi	sp,sp,-76
8113511c:	de00012e 	bgeu	sp,et,81135124 <OSEventPendMulti+0xc>
81135120:	003b68fa 	trap	3
81135124:	dfc01215 	stw	ra,72(sp)
81135128:	df001115 	stw	fp,68(sp)
8113512c:	df001104 	addi	fp,sp,68
81135130:	e13ffc15 	stw	r4,-16(fp)
81135134:	e17ffd15 	stw	r5,-12(fp)
81135138:	e1bffe15 	stw	r6,-8(fp)
8113513c:	3805883a 	mov	r2,r7
81135140:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81135144:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81135148:	e0800217 	ldw	r2,8(fp)
8113514c:	1000021e 	bne	r2,zero,81135158 <OSEventPendMulti+0x40>
        return (0);
81135150:	0005883a 	mov	r2,zero
81135154:	00015006 	br	81135698 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
81135158:	e0bffc17 	ldw	r2,-16(fp)
8113515c:	1000051e 	bne	r2,zero,81135174 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81135160:	e0800217 	ldw	r2,8(fp)
81135164:	00c00104 	movi	r3,4
81135168:	10c00005 	stb	r3,0(r2)
        return (0);
8113516c:	0005883a 	mov	r2,zero
81135170:	00014906 	br	81135698 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81135174:	e0bffd17 	ldw	r2,-12(fp)
81135178:	1000051e 	bne	r2,zero,81135190 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
8113517c:	e0800217 	ldw	r2,8(fp)
81135180:	00c00104 	movi	r3,4
81135184:	10c00005 	stb	r3,0(r2)
        return (0);
81135188:	0005883a 	mov	r2,zero
8113518c:	00014206 	br	81135698 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81135190:	e0bffe17 	ldw	r2,-8(fp)
81135194:	1000051e 	bne	r2,zero,811351ac <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
81135198:	e0800217 	ldw	r2,8(fp)
8113519c:	00c00104 	movi	r3,4
811351a0:	10c00005 	stb	r3,0(r2)
        return (0);
811351a4:	0005883a 	mov	r2,zero
811351a8:	00013b06 	br	81135698 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
811351ac:	e0bffd17 	ldw	r2,-12(fp)
811351b0:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
811351b4:	e0bffc17 	ldw	r2,-16(fp)
811351b8:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
811351bc:	e0bfef17 	ldw	r2,-68(fp)
811351c0:	10800017 	ldw	r2,0(r2)
811351c4:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
811351c8:	00001506 	br	81135220 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
811351cc:	e0bff017 	ldw	r2,-64(fp)
811351d0:	10800003 	ldbu	r2,0(r2)
811351d4:	10803fcc 	andi	r2,r2,255
811351d8:	10c000a0 	cmpeqi	r3,r2,2
811351dc:	1800071e 	bne	r3,zero,811351fc <OSEventPendMulti+0xe4>
811351e0:	108000e0 	cmpeqi	r2,r2,3
811351e4:	1000071e 	bne	r2,zero,81135204 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
811351e8:	e0800217 	ldw	r2,8(fp)
811351ec:	00c00044 	movi	r3,1
811351f0:	10c00005 	stb	r3,0(r2)
                 return (0);
811351f4:	0005883a 	mov	r2,zero
811351f8:	00012706 	br	81135698 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
811351fc:	0001883a 	nop
81135200:	00000106 	br	81135208 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81135204:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81135208:	e0bfef17 	ldw	r2,-68(fp)
8113520c:	10800104 	addi	r2,r2,4
81135210:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81135214:	e0bfef17 	ldw	r2,-68(fp)
81135218:	10800017 	ldw	r2,0(r2)
8113521c:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81135220:	e0bff017 	ldw	r2,-64(fp)
81135224:	103fe91e 	bne	r2,zero,811351cc <__reset+0xfb1151cc>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
81135228:	d0a0a003 	ldbu	r2,-32128(gp)
8113522c:	10803fcc 	andi	r2,r2,255
81135230:	10000526 	beq	r2,zero,81135248 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81135234:	e0800217 	ldw	r2,8(fp)
81135238:	00c00084 	movi	r3,2
8113523c:	10c00005 	stb	r3,0(r2)
        return (0);
81135240:	0005883a 	mov	r2,zero
81135244:	00011406 	br	81135698 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
81135248:	d0a08e03 	ldbu	r2,-32200(gp)
8113524c:	10803fcc 	andi	r2,r2,255
81135250:	10000526 	beq	r2,zero,81135268 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81135254:	e0800217 	ldw	r2,8(fp)
81135258:	00c00344 	movi	r3,13
8113525c:	10c00005 	stb	r3,0(r2)
        return (0);
81135260:	0005883a 	mov	r2,zero
81135264:	00010c06 	br	81135698 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135268:	0005303a 	rdctl	r2,status
8113526c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135270:	e0fffb17 	ldw	r3,-20(fp)
81135274:	00bfff84 	movi	r2,-2
81135278:	1884703a 	and	r2,r3,r2
8113527c:	1001703a 	wrctl	status,r2
  
  return context;
81135280:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81135284:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
81135288:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
8113528c:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
81135290:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81135294:	e0bffc17 	ldw	r2,-16(fp)
81135298:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
8113529c:	e0bfef17 	ldw	r2,-68(fp)
811352a0:	10800017 	ldw	r2,0(r2)
811352a4:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811352a8:	00006406 	br	8113543c <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
811352ac:	e0bff017 	ldw	r2,-64(fp)
811352b0:	10800003 	ldbu	r2,0(r2)
811352b4:	10803fcc 	andi	r2,r2,255
811352b8:	10c000a0 	cmpeqi	r3,r2,2
811352bc:	18001f1e 	bne	r3,zero,8113533c <OSEventPendMulti+0x224>
811352c0:	108000e0 	cmpeqi	r2,r2,3
811352c4:	10004c26 	beq	r2,zero,811353f8 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
811352c8:	e0bff017 	ldw	r2,-64(fp)
811352cc:	1080020b 	ldhu	r2,8(r2)
811352d0:	10bfffcc 	andi	r2,r2,65535
811352d4:	10001526 	beq	r2,zero,8113532c <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
811352d8:	e0bff017 	ldw	r2,-64(fp)
811352dc:	1080020b 	ldhu	r2,8(r2)
811352e0:	10bfffc4 	addi	r2,r2,-1
811352e4:	1007883a 	mov	r3,r2
811352e8:	e0bff017 	ldw	r2,-64(fp)
811352ec:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
811352f0:	e0bffd17 	ldw	r2,-12(fp)
811352f4:	10c00104 	addi	r3,r2,4
811352f8:	e0fffd15 	stw	r3,-12(fp)
811352fc:	e0fff017 	ldw	r3,-64(fp)
81135300:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
81135304:	00800044 	movi	r2,1
81135308:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
8113530c:	e0bffe17 	ldw	r2,-8(fp)
81135310:	10c00104 	addi	r3,r2,4
81135314:	e0fffe15 	stw	r3,-8(fp)
81135318:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
8113531c:	e0bff18b 	ldhu	r2,-58(fp)
81135320:	10800044 	addi	r2,r2,1
81135324:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
81135328:	00003e06 	br	81135424 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
8113532c:	e0bff203 	ldbu	r2,-56(fp)
81135330:	10800054 	ori	r2,r2,1
81135334:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81135338:	00003a06 	br	81135424 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
8113533c:	e0bff017 	ldw	r2,-64(fp)
81135340:	10800117 	ldw	r2,4(r2)
81135344:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
81135348:	e0bff517 	ldw	r2,-44(fp)
8113534c:	1080058b 	ldhu	r2,22(r2)
81135350:	10bfffcc 	andi	r2,r2,65535
81135354:	10002426 	beq	r2,zero,811353e8 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
81135358:	e0bffe17 	ldw	r2,-8(fp)
8113535c:	10c00104 	addi	r3,r2,4
81135360:	e0fffe15 	stw	r3,-8(fp)
81135364:	e0fff517 	ldw	r3,-44(fp)
81135368:	18c00417 	ldw	r3,16(r3)
8113536c:	19400104 	addi	r5,r3,4
81135370:	e13ff517 	ldw	r4,-44(fp)
81135374:	21400415 	stw	r5,16(r4)
81135378:	18c00017 	ldw	r3,0(r3)
8113537c:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81135380:	e0bff517 	ldw	r2,-44(fp)
81135384:	10c00417 	ldw	r3,16(r2)
81135388:	e0bff517 	ldw	r2,-44(fp)
8113538c:	10800217 	ldw	r2,8(r2)
81135390:	1880041e 	bne	r3,r2,811353a4 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81135394:	e0bff517 	ldw	r2,-44(fp)
81135398:	10c00117 	ldw	r3,4(r2)
8113539c:	e0bff517 	ldw	r2,-44(fp)
811353a0:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
811353a4:	e0bff517 	ldw	r2,-44(fp)
811353a8:	1080058b 	ldhu	r2,22(r2)
811353ac:	10bfffc4 	addi	r2,r2,-1
811353b0:	1007883a 	mov	r3,r2
811353b4:	e0bff517 	ldw	r2,-44(fp)
811353b8:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
811353bc:	e0bffd17 	ldw	r2,-12(fp)
811353c0:	10c00104 	addi	r3,r2,4
811353c4:	e0fffd15 	stw	r3,-12(fp)
811353c8:	e0fff017 	ldw	r3,-64(fp)
811353cc:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
811353d0:	00800044 	movi	r2,1
811353d4:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
811353d8:	e0bff18b 	ldhu	r2,-58(fp)
811353dc:	10800044 	addi	r2,r2,1
811353e0:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
811353e4:	00000f06 	br	81135424 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
811353e8:	e0bff203 	ldbu	r2,-56(fp)
811353ec:	10800114 	ori	r2,r2,4
811353f0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811353f4:	00000b06 	br	81135424 <OSEventPendMulti+0x30c>
811353f8:	e0bff317 	ldw	r2,-52(fp)
811353fc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135400:	e0bff417 	ldw	r2,-48(fp)
81135404:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81135408:	e0bffd17 	ldw	r2,-12(fp)
8113540c:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81135410:	e0800217 	ldw	r2,8(fp)
81135414:	00c00044 	movi	r3,1
81135418:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
8113541c:	e0bff18b 	ldhu	r2,-58(fp)
81135420:	00009d06 	br	81135698 <OSEventPendMulti+0x580>
        }
        pevents++;
81135424:	e0bfef17 	ldw	r2,-68(fp)
81135428:	10800104 	addi	r2,r2,4
8113542c:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81135430:	e0bfef17 	ldw	r2,-68(fp)
81135434:	10800017 	ldw	r2,0(r2)
81135438:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8113543c:	e0bff017 	ldw	r2,-64(fp)
81135440:	103f9a1e 	bne	r2,zero,811352ac <__reset+0xfb1152ac>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
81135444:	e0bff103 	ldbu	r2,-60(fp)
81135448:	10800058 	cmpnei	r2,r2,1
8113544c:	10000a1e 	bne	r2,zero,81135478 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81135450:	e0bffd17 	ldw	r2,-12(fp)
81135454:	10000015 	stw	zero,0(r2)
81135458:	e0bff317 	ldw	r2,-52(fp)
8113545c:	e0bff615 	stw	r2,-40(fp)
81135460:	e0bff617 	ldw	r2,-40(fp)
81135464:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
81135468:	e0800217 	ldw	r2,8(fp)
8113546c:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81135470:	e0bff18b 	ldhu	r2,-58(fp)
81135474:	00008806 	br	81135698 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81135478:	d0a0a117 	ldw	r2,-32124(gp)
8113547c:	d0e0a117 	ldw	r3,-32124(gp)
81135480:	19000c03 	ldbu	r4,48(r3)
81135484:	e0fff203 	ldbu	r3,-56(fp)
81135488:	20c6b03a 	or	r3,r4,r3
8113548c:	1809883a 	mov	r4,r3
81135490:	00ffe004 	movi	r3,-128
81135494:	20c6b03a 	or	r3,r4,r3
81135498:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113549c:	d0a0a117 	ldw	r2,-32124(gp)
811354a0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
811354a4:	d0a0a117 	ldw	r2,-32124(gp)
811354a8:	e0ffff0b 	ldhu	r3,-4(fp)
811354ac:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
811354b0:	e13ffc17 	ldw	r4,-16(fp)
811354b4:	113603c0 	call	8113603c <OS_EventTaskWaitMulti>
811354b8:	e0bff317 	ldw	r2,-52(fp)
811354bc:	e0bff915 	stw	r2,-28(fp)
811354c0:	e0bff917 	ldw	r2,-28(fp)
811354c4:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
811354c8:	11368400 	call	81136840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811354cc:	0005303a 	rdctl	r2,status
811354d0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811354d4:	e0fff717 	ldw	r3,-36(fp)
811354d8:	00bfff84 	movi	r2,-2
811354dc:	1884703a 	and	r2,r3,r2
811354e0:	1001703a 	wrctl	status,r2
  
  return context;
811354e4:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
811354e8:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
811354ec:	d0a0a117 	ldw	r2,-32124(gp)
811354f0:	10800c43 	ldbu	r2,49(r2)
811354f4:	10803fcc 	andi	r2,r2,255
811354f8:	10000226 	beq	r2,zero,81135504 <OSEventPendMulti+0x3ec>
811354fc:	108000a0 	cmpeqi	r2,r2,2
81135500:	10001826 	beq	r2,zero,81135564 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
81135504:	d0a0a117 	ldw	r2,-32124(gp)
81135508:	10800717 	ldw	r2,28(r2)
8113550c:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81135510:	e0bff017 	ldw	r2,-64(fp)
81135514:	10000b26 	beq	r2,zero,81135544 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81135518:	e0bffd17 	ldw	r2,-12(fp)
8113551c:	10c00104 	addi	r3,r2,4
81135520:	e0fffd15 	stw	r3,-12(fp)
81135524:	e0fff017 	ldw	r3,-64(fp)
81135528:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
8113552c:	e0bffd17 	ldw	r2,-12(fp)
81135530:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
81135534:	e0bff18b 	ldhu	r2,-58(fp)
81135538:	10800044 	addi	r2,r2,1
8113553c:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81135540:	00000d06 	br	81135578 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
81135544:	d0a0a117 	ldw	r2,-32124(gp)
81135548:	00c00044 	movi	r3,1
8113554c:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81135550:	d0a0a117 	ldw	r2,-32124(gp)
81135554:	e17ffc17 	ldw	r5,-16(fp)
81135558:	1009883a 	mov	r4,r2
8113555c:	11362540 	call	81136254 <OS_EventTaskRemoveMulti>
             }
			 break;
81135560:	00000506 	br	81135578 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81135564:	d0a0a117 	ldw	r2,-32124(gp)
81135568:	e17ffc17 	ldw	r5,-16(fp)
8113556c:	1009883a 	mov	r4,r2
81135570:	11362540 	call	81136254 <OS_EventTaskRemoveMulti>
             break;
81135574:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81135578:	d0a0a117 	ldw	r2,-32124(gp)
8113557c:	10800c43 	ldbu	r2,49(r2)
81135580:	10803fcc 	andi	r2,r2,255
81135584:	10000326 	beq	r2,zero,81135594 <OSEventPendMulti+0x47c>
81135588:	108000a0 	cmpeqi	r2,r2,2
8113558c:	1000231e 	bne	r2,zero,8113561c <OSEventPendMulti+0x504>
81135590:	00002a06 	br	8113563c <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81135594:	e0bff017 	ldw	r2,-64(fp)
81135598:	10800003 	ldbu	r2,0(r2)
8113559c:	10803fcc 	andi	r2,r2,255
811355a0:	0080100e 	bge	zero,r2,811355e4 <OSEventPendMulti+0x4cc>
811355a4:	10c000d0 	cmplti	r3,r2,3
811355a8:	1800071e 	bne	r3,zero,811355c8 <OSEventPendMulti+0x4b0>
811355ac:	108000e0 	cmpeqi	r2,r2,3
811355b0:	10000c26 	beq	r2,zero,811355e4 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
811355b4:	e0bffe17 	ldw	r2,-8(fp)
811355b8:	10c00104 	addi	r3,r2,4
811355bc:	e0fffe15 	stw	r3,-8(fp)
811355c0:	10000015 	stw	zero,0(r2)
                      break;
811355c4:	00001206 	br	81135610 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
811355c8:	e0bffe17 	ldw	r2,-8(fp)
811355cc:	10c00104 	addi	r3,r2,4
811355d0:	e0fffe15 	stw	r3,-8(fp)
811355d4:	d0e0a117 	ldw	r3,-32124(gp)
811355d8:	18c00917 	ldw	r3,36(r3)
811355dc:	10c00015 	stw	r3,0(r2)
                      break;
811355e0:	00000b06 	br	81135610 <OSEventPendMulti+0x4f8>
811355e4:	e0bff317 	ldw	r2,-52(fp)
811355e8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811355ec:	e0bff817 	ldw	r2,-32(fp)
811355f0:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
811355f4:	e0bffd17 	ldw	r2,-12(fp)
811355f8:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
811355fc:	e0800217 	ldw	r2,8(fp)
81135600:	00c00044 	movi	r3,1
81135604:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81135608:	e0bff18b 	ldhu	r2,-58(fp)
8113560c:	00002206 	br	81135698 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81135610:	e0800217 	ldw	r2,8(fp)
81135614:	10000005 	stb	zero,0(r2)
             break;
81135618:	00001006 	br	8113565c <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
8113561c:	e0bffe17 	ldw	r2,-8(fp)
81135620:	10c00104 	addi	r3,r2,4
81135624:	e0fffe15 	stw	r3,-8(fp)
81135628:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
8113562c:	e0800217 	ldw	r2,8(fp)
81135630:	00c00384 	movi	r3,14
81135634:	10c00005 	stb	r3,0(r2)
             break;
81135638:	00000806 	br	8113565c <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
8113563c:	e0bffe17 	ldw	r2,-8(fp)
81135640:	10c00104 	addi	r3,r2,4
81135644:	e0fffe15 	stw	r3,-8(fp)
81135648:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
8113564c:	e0800217 	ldw	r2,8(fp)
81135650:	00c00284 	movi	r3,10
81135654:	10c00005 	stb	r3,0(r2)
             break;
81135658:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
8113565c:	d0a0a117 	ldw	r2,-32124(gp)
81135660:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81135664:	d0a0a117 	ldw	r2,-32124(gp)
81135668:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
8113566c:	d0a0a117 	ldw	r2,-32124(gp)
81135670:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81135674:	d0a0a117 	ldw	r2,-32124(gp)
81135678:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
8113567c:	d0a0a117 	ldw	r2,-32124(gp)
81135680:	10000915 	stw	zero,36(r2)
81135684:	e0bff317 	ldw	r2,-52(fp)
81135688:	e0bffa15 	stw	r2,-24(fp)
8113568c:	e0bffa17 	ldw	r2,-24(fp)
81135690:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81135694:	e0bff18b 	ldhu	r2,-58(fp)
}
81135698:	e037883a 	mov	sp,fp
8113569c:	dfc00117 	ldw	ra,4(sp)
811356a0:	df000017 	ldw	fp,0(sp)
811356a4:	dec00204 	addi	sp,sp,8
811356a8:	f800283a 	ret

811356ac <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
811356ac:	defffe04 	addi	sp,sp,-8
811356b0:	de00012e 	bgeu	sp,et,811356b8 <OSInit+0xc>
811356b4:	003b68fa 	trap	3
811356b8:	dfc00115 	stw	ra,4(sp)
811356bc:	df000015 	stw	fp,0(sp)
811356c0:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
811356c4:	1147bb00 	call	81147bb0 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
811356c8:	11364b40 	call	811364b4 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
811356cc:	11365040 	call	81136504 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
811356d0:	11366880 	call	81136688 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
811356d4:	11363cc0 	call	811363cc <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
811356d8:	11386480 	call	81138648 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
811356dc:	1138f900 	call	81138f90 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
811356e0:	113b2600 	call	8113b260 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
811356e4:	11365780 	call	81136578 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
811356e8:	11366000 	call	81136600 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
811356ec:	113e6040 	call	8113e604 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
811356f0:	1147bdc0 	call	81147bdc <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
811356f4:	1136f640 	call	81136f64 <OSDebugInit>
#endif
}
811356f8:	0001883a 	nop
811356fc:	e037883a 	mov	sp,fp
81135700:	dfc00117 	ldw	ra,4(sp)
81135704:	df000017 	ldw	fp,0(sp)
81135708:	dec00204 	addi	sp,sp,8
8113570c:	f800283a 	ret

81135710 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81135710:	deffff04 	addi	sp,sp,-4
81135714:	de00012e 	bgeu	sp,et,8113571c <OSIntEnter+0xc>
81135718:	003b68fa 	trap	3
8113571c:	df000015 	stw	fp,0(sp)
81135720:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81135724:	d0a09003 	ldbu	r2,-32192(gp)
81135728:	10803fcc 	andi	r2,r2,255
8113572c:	10800058 	cmpnei	r2,r2,1
81135730:	1000071e 	bne	r2,zero,81135750 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81135734:	d0a0a003 	ldbu	r2,-32128(gp)
81135738:	10803fcc 	andi	r2,r2,255
8113573c:	10803fe0 	cmpeqi	r2,r2,255
81135740:	1000031e 	bne	r2,zero,81135750 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81135744:	d0a0a003 	ldbu	r2,-32128(gp)
81135748:	10800044 	addi	r2,r2,1
8113574c:	d0a0a005 	stb	r2,-32128(gp)
        }
    }
}
81135750:	0001883a 	nop
81135754:	e037883a 	mov	sp,fp
81135758:	df000017 	ldw	fp,0(sp)
8113575c:	dec00104 	addi	sp,sp,4
81135760:	f800283a 	ret

81135764 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81135764:	defffb04 	addi	sp,sp,-20
81135768:	de00012e 	bgeu	sp,et,81135770 <OSIntExit+0xc>
8113576c:	003b68fa 	trap	3
81135770:	dfc00415 	stw	ra,16(sp)
81135774:	df000315 	stw	fp,12(sp)
81135778:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113577c:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81135780:	d0a09003 	ldbu	r2,-32192(gp)
81135784:	10803fcc 	andi	r2,r2,255
81135788:	10800058 	cmpnei	r2,r2,1
8113578c:	10002f1e 	bne	r2,zero,8113584c <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135790:	0005303a 	rdctl	r2,status
81135794:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135798:	e0ffff17 	ldw	r3,-4(fp)
8113579c:	00bfff84 	movi	r2,-2
811357a0:	1884703a 	and	r2,r3,r2
811357a4:	1001703a 	wrctl	status,r2
  
  return context;
811357a8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
811357ac:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
811357b0:	d0a0a003 	ldbu	r2,-32128(gp)
811357b4:	10803fcc 	andi	r2,r2,255
811357b8:	10000326 	beq	r2,zero,811357c8 <OSIntExit+0x64>
            OSIntNesting--;
811357bc:	d0a0a003 	ldbu	r2,-32128(gp)
811357c0:	10bfffc4 	addi	r2,r2,-1
811357c4:	d0a0a005 	stb	r2,-32128(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
811357c8:	d0a0a003 	ldbu	r2,-32128(gp)
811357cc:	10803fcc 	andi	r2,r2,255
811357d0:	10001a1e 	bne	r2,zero,8113583c <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
811357d4:	d0a08e03 	ldbu	r2,-32200(gp)
811357d8:	10803fcc 	andi	r2,r2,255
811357dc:	1000171e 	bne	r2,zero,8113583c <OSIntExit+0xd8>
                OS_SchedNew();
811357e0:	11369180 	call	81136918 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
811357e4:	d0e09283 	ldbu	r3,-32182(gp)
811357e8:	d0a092c3 	ldbu	r2,-32181(gp)
811357ec:	18c03fcc 	andi	r3,r3,255
811357f0:	10803fcc 	andi	r2,r2,255
811357f4:	18801126 	beq	r3,r2,8113583c <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
811357f8:	d0a09283 	ldbu	r2,-32182(gp)
811357fc:	10c03fcc 	andi	r3,r2,255
81135800:	00a045f4 	movhi	r2,33047
81135804:	10a46104 	addi	r2,r2,-28284
81135808:	18c7883a 	add	r3,r3,r3
8113580c:	18c7883a 	add	r3,r3,r3
81135810:	10c5883a 	add	r2,r2,r3
81135814:	10800017 	ldw	r2,0(r2)
81135818:	d0a09b15 	stw	r2,-32148(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
8113581c:	d0a09b17 	ldw	r2,-32148(gp)
81135820:	10c00e17 	ldw	r3,56(r2)
81135824:	18c00044 	addi	r3,r3,1
81135828:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
8113582c:	d0a09517 	ldw	r2,-32172(gp)
81135830:	10800044 	addi	r2,r2,1
81135834:	d0a09515 	stw	r2,-32172(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81135838:	11478700 	call	81147870 <OSCtxSw>
8113583c:	e0bffd17 	ldw	r2,-12(fp)
81135840:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135844:	e0bffe17 	ldw	r2,-8(fp)
81135848:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8113584c:	0001883a 	nop
81135850:	e037883a 	mov	sp,fp
81135854:	dfc00117 	ldw	ra,4(sp)
81135858:	df000017 	ldw	fp,0(sp)
8113585c:	dec00204 	addi	sp,sp,8
81135860:	f800283a 	ret

81135864 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81135864:	defffc04 	addi	sp,sp,-16
81135868:	de00012e 	bgeu	sp,et,81135870 <OSSchedLock+0xc>
8113586c:	003b68fa 	trap	3
81135870:	df000315 	stw	fp,12(sp)
81135874:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135878:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
8113587c:	d0a09003 	ldbu	r2,-32192(gp)
81135880:	10803fcc 	andi	r2,r2,255
81135884:	10800058 	cmpnei	r2,r2,1
81135888:	1000161e 	bne	r2,zero,811358e4 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113588c:	0005303a 	rdctl	r2,status
81135890:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135894:	e0ffff17 	ldw	r3,-4(fp)
81135898:	00bfff84 	movi	r2,-2
8113589c:	1884703a 	and	r2,r3,r2
811358a0:	1001703a 	wrctl	status,r2
  
  return context;
811358a4:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
811358a8:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
811358ac:	d0a0a003 	ldbu	r2,-32128(gp)
811358b0:	10803fcc 	andi	r2,r2,255
811358b4:	1000071e 	bne	r2,zero,811358d4 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
811358b8:	d0a08e03 	ldbu	r2,-32200(gp)
811358bc:	10803fcc 	andi	r2,r2,255
811358c0:	10803fe0 	cmpeqi	r2,r2,255
811358c4:	1000031e 	bne	r2,zero,811358d4 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
811358c8:	d0a08e03 	ldbu	r2,-32200(gp)
811358cc:	10800044 	addi	r2,r2,1
811358d0:	d0a08e05 	stb	r2,-32200(gp)
811358d4:	e0bffd17 	ldw	r2,-12(fp)
811358d8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811358dc:	e0bffe17 	ldw	r2,-8(fp)
811358e0:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
811358e4:	0001883a 	nop
811358e8:	e037883a 	mov	sp,fp
811358ec:	df000017 	ldw	fp,0(sp)
811358f0:	dec00104 	addi	sp,sp,4
811358f4:	f800283a 	ret

811358f8 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
811358f8:	defff804 	addi	sp,sp,-32
811358fc:	de00012e 	bgeu	sp,et,81135904 <OSSchedUnlock+0xc>
81135900:	003b68fa 	trap	3
81135904:	dfc00715 	stw	ra,28(sp)
81135908:	df000615 	stw	fp,24(sp)
8113590c:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81135910:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81135914:	d0a09003 	ldbu	r2,-32192(gp)
81135918:	10803fcc 	andi	r2,r2,255
8113591c:	10800058 	cmpnei	r2,r2,1
81135920:	1000281e 	bne	r2,zero,811359c4 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135924:	0005303a 	rdctl	r2,status
81135928:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113592c:	e0ffff17 	ldw	r3,-4(fp)
81135930:	00bfff84 	movi	r2,-2
81135934:	1884703a 	and	r2,r3,r2
81135938:	1001703a 	wrctl	status,r2
  
  return context;
8113593c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81135940:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81135944:	d0a08e03 	ldbu	r2,-32200(gp)
81135948:	10803fcc 	andi	r2,r2,255
8113594c:	10001926 	beq	r2,zero,811359b4 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81135950:	d0a08e03 	ldbu	r2,-32200(gp)
81135954:	10bfffc4 	addi	r2,r2,-1
81135958:	d0a08e05 	stb	r2,-32200(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
8113595c:	d0a08e03 	ldbu	r2,-32200(gp)
81135960:	10803fcc 	andi	r2,r2,255
81135964:	10000e1e 	bne	r2,zero,811359a0 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81135968:	d0a0a003 	ldbu	r2,-32128(gp)
8113596c:	10803fcc 	andi	r2,r2,255
81135970:	1000061e 	bne	r2,zero,8113598c <OSSchedUnlock+0x94>
81135974:	e0bffa17 	ldw	r2,-24(fp)
81135978:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113597c:	e0bffb17 	ldw	r2,-20(fp)
81135980:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81135984:	11368400 	call	81136840 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81135988:	00000e06 	br	811359c4 <OSSchedUnlock+0xcc>
8113598c:	e0bffa17 	ldw	r2,-24(fp)
81135990:	e0bffc15 	stw	r2,-16(fp)
81135994:	e0bffc17 	ldw	r2,-16(fp)
81135998:	1001703a 	wrctl	status,r2
8113599c:	00000906 	br	811359c4 <OSSchedUnlock+0xcc>
811359a0:	e0bffa17 	ldw	r2,-24(fp)
811359a4:	e0bffd15 	stw	r2,-12(fp)
811359a8:	e0bffd17 	ldw	r2,-12(fp)
811359ac:	1001703a 	wrctl	status,r2
811359b0:	00000406 	br	811359c4 <OSSchedUnlock+0xcc>
811359b4:	e0bffa17 	ldw	r2,-24(fp)
811359b8:	e0bffe15 	stw	r2,-8(fp)
811359bc:	e0bffe17 	ldw	r2,-8(fp)
811359c0:	1001703a 	wrctl	status,r2
811359c4:	0001883a 	nop
811359c8:	e037883a 	mov	sp,fp
811359cc:	dfc00117 	ldw	ra,4(sp)
811359d0:	df000017 	ldw	fp,0(sp)
811359d4:	dec00204 	addi	sp,sp,8
811359d8:	f800283a 	ret

811359dc <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
811359dc:	defffe04 	addi	sp,sp,-8
811359e0:	de00012e 	bgeu	sp,et,811359e8 <OSStart+0xc>
811359e4:	003b68fa 	trap	3
811359e8:	dfc00115 	stw	ra,4(sp)
811359ec:	df000015 	stw	fp,0(sp)
811359f0:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
811359f4:	d0a09003 	ldbu	r2,-32192(gp)
811359f8:	10803fcc 	andi	r2,r2,255
811359fc:	10000f1e 	bne	r2,zero,81135a3c <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81135a00:	11369180 	call	81136918 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81135a04:	d0a09283 	ldbu	r2,-32182(gp)
81135a08:	d0a092c5 	stb	r2,-32181(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81135a0c:	d0a09283 	ldbu	r2,-32182(gp)
81135a10:	10c03fcc 	andi	r3,r2,255
81135a14:	00a045f4 	movhi	r2,33047
81135a18:	10a46104 	addi	r2,r2,-28284
81135a1c:	18c7883a 	add	r3,r3,r3
81135a20:	18c7883a 	add	r3,r3,r3
81135a24:	10c5883a 	add	r2,r2,r3
81135a28:	10800017 	ldw	r2,0(r2)
81135a2c:	d0a09b15 	stw	r2,-32148(gp)
        OSTCBCur      = OSTCBHighRdy;
81135a30:	d0a09b17 	ldw	r2,-32148(gp)
81135a34:	d0a0a115 	stw	r2,-32124(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81135a38:	114790c0 	call	8114790c <OSStartHighRdy>
    }
}
81135a3c:	0001883a 	nop
81135a40:	e037883a 	mov	sp,fp
81135a44:	dfc00117 	ldw	ra,4(sp)
81135a48:	df000017 	ldw	fp,0(sp)
81135a4c:	dec00204 	addi	sp,sp,8
81135a50:	f800283a 	ret

81135a54 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81135a54:	defff904 	addi	sp,sp,-28
81135a58:	de00012e 	bgeu	sp,et,81135a60 <OSStatInit+0xc>
81135a5c:	003b68fa 	trap	3
81135a60:	dfc00615 	stw	ra,24(sp)
81135a64:	df000515 	stw	fp,20(sp)
81135a68:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135a6c:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81135a70:	01000084 	movi	r4,2
81135a74:	113d57c0 	call	8113d57c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135a78:	0005303a 	rdctl	r2,status
81135a7c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135a80:	e0fffc17 	ldw	r3,-16(fp)
81135a84:	00bfff84 	movi	r2,-2
81135a88:	1884703a 	and	r2,r3,r2
81135a8c:	1001703a 	wrctl	status,r2
  
  return context;
81135a90:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81135a94:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81135a98:	d0209115 	stw	zero,-32188(gp)
81135a9c:	e0bffb17 	ldw	r2,-20(fp)
81135aa0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135aa4:	e0bffd17 	ldw	r2,-12(fp)
81135aa8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81135aac:	01001904 	movi	r4,100
81135ab0:	113d57c0 	call	8113d57c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135ab4:	0005303a 	rdctl	r2,status
81135ab8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135abc:	e0fffe17 	ldw	r3,-8(fp)
81135ac0:	00bfff84 	movi	r2,-2
81135ac4:	1884703a 	and	r2,r3,r2
81135ac8:	1001703a 	wrctl	status,r2
  
  return context;
81135acc:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81135ad0:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81135ad4:	d0a09117 	ldw	r2,-32188(gp)
81135ad8:	d0a09715 	stw	r2,-32164(gp)
    OSStatRdy    = OS_TRUE;
81135adc:	00800044 	movi	r2,1
81135ae0:	d0a0a605 	stb	r2,-32104(gp)
81135ae4:	e0bffb17 	ldw	r2,-20(fp)
81135ae8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135aec:	e0bfff17 	ldw	r2,-4(fp)
81135af0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81135af4:	0001883a 	nop
81135af8:	e037883a 	mov	sp,fp
81135afc:	dfc00117 	ldw	ra,4(sp)
81135b00:	df000017 	ldw	fp,0(sp)
81135b04:	dec00204 	addi	sp,sp,8
81135b08:	f800283a 	ret

81135b0c <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81135b0c:	defff704 	addi	sp,sp,-36
81135b10:	de00012e 	bgeu	sp,et,81135b18 <OSTimeTick+0xc>
81135b14:	003b68fa 	trap	3
81135b18:	dfc00815 	stw	ra,32(sp)
81135b1c:	df000715 	stw	fp,28(sp)
81135b20:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81135b24:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81135b28:	1147b5c0 	call	81147b5c <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135b2c:	0005303a 	rdctl	r2,status
81135b30:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135b34:	e0fffd17 	ldw	r3,-12(fp)
81135b38:	00bfff84 	movi	r2,-2
81135b3c:	1884703a 	and	r2,r3,r2
81135b40:	1001703a 	wrctl	status,r2
  
  return context;
81135b44:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81135b48:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81135b4c:	d0a0a317 	ldw	r2,-32116(gp)
81135b50:	10800044 	addi	r2,r2,1
81135b54:	d0a0a315 	stw	r2,-32116(gp)
81135b58:	e0bffb17 	ldw	r2,-20(fp)
81135b5c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135b60:	e0bfff17 	ldw	r2,-4(fp)
81135b64:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81135b68:	d0a09003 	ldbu	r2,-32192(gp)
81135b6c:	10803fcc 	andi	r2,r2,255
81135b70:	10800058 	cmpnei	r2,r2,1
81135b74:	10006a1e 	bne	r2,zero,81135d20 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81135b78:	d0a09403 	ldbu	r2,-32176(gp)
81135b7c:	10803fcc 	andi	r2,r2,255
81135b80:	10c00060 	cmpeqi	r3,r2,1
81135b84:	1800061e 	bne	r3,zero,81135ba0 <OSTimeTick+0x94>
81135b88:	10c000a0 	cmpeqi	r3,r2,2
81135b8c:	1800061e 	bne	r3,zero,81135ba8 <OSTimeTick+0x9c>
81135b90:	10000a1e 	bne	r2,zero,81135bbc <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81135b94:	00800044 	movi	r2,1
81135b98:	e0bffa05 	stb	r2,-24(fp)
                 break;
81135b9c:	00000b06 	br	81135bcc <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81135ba0:	e03ffa05 	stb	zero,-24(fp)
                 break;
81135ba4:	00000906 	br	81135bcc <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81135ba8:	00800044 	movi	r2,1
81135bac:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81135bb0:	00800044 	movi	r2,1
81135bb4:	d0a09405 	stb	r2,-32176(gp)
                 break;
81135bb8:	00000406 	br	81135bcc <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81135bbc:	00800044 	movi	r2,1
81135bc0:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81135bc4:	d0209405 	stb	zero,-32176(gp)
                 break;
81135bc8:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81135bcc:	e0bffa03 	ldbu	r2,-24(fp)
81135bd0:	10005226 	beq	r2,zero,81135d1c <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81135bd4:	d0a09317 	ldw	r2,-32180(gp)
81135bd8:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81135bdc:	00004906 	br	81135d04 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135be0:	0005303a 	rdctl	r2,status
81135be4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135be8:	e0fffc17 	ldw	r3,-16(fp)
81135bec:	00bfff84 	movi	r2,-2
81135bf0:	1884703a 	and	r2,r3,r2
81135bf4:	1001703a 	wrctl	status,r2
  
  return context;
81135bf8:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81135bfc:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81135c00:	e0bff917 	ldw	r2,-28(fp)
81135c04:	10800b8b 	ldhu	r2,46(r2)
81135c08:	10bfffcc 	andi	r2,r2,65535
81135c0c:	10003626 	beq	r2,zero,81135ce8 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81135c10:	e0bff917 	ldw	r2,-28(fp)
81135c14:	10800b8b 	ldhu	r2,46(r2)
81135c18:	10bfffc4 	addi	r2,r2,-1
81135c1c:	1007883a 	mov	r3,r2
81135c20:	e0bff917 	ldw	r2,-28(fp)
81135c24:	10c00b8d 	sth	r3,46(r2)
81135c28:	e0bff917 	ldw	r2,-28(fp)
81135c2c:	10800b8b 	ldhu	r2,46(r2)
81135c30:	10bfffcc 	andi	r2,r2,65535
81135c34:	10002c1e 	bne	r2,zero,81135ce8 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81135c38:	e0bff917 	ldw	r2,-28(fp)
81135c3c:	10800c03 	ldbu	r2,48(r2)
81135c40:	10803fcc 	andi	r2,r2,255
81135c44:	10800dcc 	andi	r2,r2,55
81135c48:	10000b26 	beq	r2,zero,81135c78 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81135c4c:	e0bff917 	ldw	r2,-28(fp)
81135c50:	10c00c03 	ldbu	r3,48(r2)
81135c54:	00bff204 	movi	r2,-56
81135c58:	1884703a 	and	r2,r3,r2
81135c5c:	1007883a 	mov	r3,r2
81135c60:	e0bff917 	ldw	r2,-28(fp)
81135c64:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81135c68:	e0bff917 	ldw	r2,-28(fp)
81135c6c:	00c00044 	movi	r3,1
81135c70:	10c00c45 	stb	r3,49(r2)
81135c74:	00000206 	br	81135c80 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81135c78:	e0bff917 	ldw	r2,-28(fp)
81135c7c:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81135c80:	e0bff917 	ldw	r2,-28(fp)
81135c84:	10800c03 	ldbu	r2,48(r2)
81135c88:	10803fcc 	andi	r2,r2,255
81135c8c:	1080020c 	andi	r2,r2,8
81135c90:	1000151e 	bne	r2,zero,81135ce8 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
81135c94:	e0bff917 	ldw	r2,-28(fp)
81135c98:	10c00d83 	ldbu	r3,54(r2)
81135c9c:	d0a09d03 	ldbu	r2,-32140(gp)
81135ca0:	1884b03a 	or	r2,r3,r2
81135ca4:	d0a09d05 	stb	r2,-32140(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81135ca8:	e0bff917 	ldw	r2,-28(fp)
81135cac:	10800d03 	ldbu	r2,52(r2)
81135cb0:	10c03fcc 	andi	r3,r2,255
81135cb4:	e0bff917 	ldw	r2,-28(fp)
81135cb8:	10800d03 	ldbu	r2,52(r2)
81135cbc:	11003fcc 	andi	r4,r2,255
81135cc0:	d0a09d44 	addi	r2,gp,-32139
81135cc4:	2085883a 	add	r2,r4,r2
81135cc8:	11000003 	ldbu	r4,0(r2)
81135ccc:	e0bff917 	ldw	r2,-28(fp)
81135cd0:	10800d43 	ldbu	r2,53(r2)
81135cd4:	2084b03a 	or	r2,r4,r2
81135cd8:	1009883a 	mov	r4,r2
81135cdc:	d0a09d44 	addi	r2,gp,-32139
81135ce0:	1885883a 	add	r2,r3,r2
81135ce4:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81135ce8:	e0bff917 	ldw	r2,-28(fp)
81135cec:	10800517 	ldw	r2,20(r2)
81135cf0:	e0bff915 	stw	r2,-28(fp)
81135cf4:	e0bffb17 	ldw	r2,-20(fp)
81135cf8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135cfc:	e0bffe17 	ldw	r2,-8(fp)
81135d00:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81135d04:	e0bff917 	ldw	r2,-28(fp)
81135d08:	10800c83 	ldbu	r2,50(r2)
81135d0c:	10803fcc 	andi	r2,r2,255
81135d10:	10800a98 	cmpnei	r2,r2,42
81135d14:	103fb21e 	bne	r2,zero,81135be0 <__reset+0xfb115be0>
81135d18:	00000106 	br	81135d20 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81135d1c:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81135d20:	e037883a 	mov	sp,fp
81135d24:	dfc00117 	ldw	ra,4(sp)
81135d28:	df000017 	ldw	fp,0(sp)
81135d2c:	dec00204 	addi	sp,sp,8
81135d30:	f800283a 	ret

81135d34 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
81135d34:	deffff04 	addi	sp,sp,-4
81135d38:	de00012e 	bgeu	sp,et,81135d40 <OSVersion+0xc>
81135d3c:	003b68fa 	trap	3
81135d40:	df000015 	stw	fp,0(sp)
81135d44:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81135d48:	00804784 	movi	r2,286
}
81135d4c:	e037883a 	mov	sp,fp
81135d50:	df000017 	ldw	fp,0(sp)
81135d54:	dec00104 	addi	sp,sp,4
81135d58:	f800283a 	ret

81135d5c <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81135d5c:	deffff04 	addi	sp,sp,-4
81135d60:	de00012e 	bgeu	sp,et,81135d68 <OS_Dummy+0xc>
81135d64:	003b68fa 	trap	3
81135d68:	df000015 	stw	fp,0(sp)
81135d6c:	d839883a 	mov	fp,sp
}
81135d70:	0001883a 	nop
81135d74:	e037883a 	mov	sp,fp
81135d78:	df000017 	ldw	fp,0(sp)
81135d7c:	dec00104 	addi	sp,sp,4
81135d80:	f800283a 	ret

81135d84 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
81135d84:	defff804 	addi	sp,sp,-32
81135d88:	de00012e 	bgeu	sp,et,81135d90 <OS_EventTaskRdy+0xc>
81135d8c:	003b68fa 	trap	3
81135d90:	dfc00715 	stw	ra,28(sp)
81135d94:	df000615 	stw	fp,24(sp)
81135d98:	df000604 	addi	fp,sp,24
81135d9c:	e13ffc15 	stw	r4,-16(fp)
81135da0:	e17ffd15 	stw	r5,-12(fp)
81135da4:	3007883a 	mov	r3,r6
81135da8:	3805883a 	mov	r2,r7
81135dac:	e0fffe05 	stb	r3,-8(fp)
81135db0:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
81135db4:	e0bffc17 	ldw	r2,-16(fp)
81135db8:	10800283 	ldbu	r2,10(r2)
81135dbc:	10c03fcc 	andi	r3,r2,255
81135dc0:	00a04574 	movhi	r2,33045
81135dc4:	10b4ee04 	addi	r2,r2,-11336
81135dc8:	10c5883a 	add	r2,r2,r3
81135dcc:	10800003 	ldbu	r2,0(r2)
81135dd0:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
81135dd4:	e0bffa03 	ldbu	r2,-24(fp)
81135dd8:	e0fffc17 	ldw	r3,-16(fp)
81135ddc:	1885883a 	add	r2,r3,r2
81135de0:	108002c4 	addi	r2,r2,11
81135de4:	10800003 	ldbu	r2,0(r2)
81135de8:	10c03fcc 	andi	r3,r2,255
81135dec:	00a04574 	movhi	r2,33045
81135df0:	10b4ee04 	addi	r2,r2,-11336
81135df4:	10c5883a 	add	r2,r2,r3
81135df8:	10800003 	ldbu	r2,0(r2)
81135dfc:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81135e00:	e0bffa03 	ldbu	r2,-24(fp)
81135e04:	100490fa 	slli	r2,r2,3
81135e08:	1007883a 	mov	r3,r2
81135e0c:	e0bffa43 	ldbu	r2,-23(fp)
81135e10:	1885883a 	add	r2,r3,r2
81135e14:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81135e18:	e0fffa83 	ldbu	r3,-22(fp)
81135e1c:	00a045f4 	movhi	r2,33047
81135e20:	10a46104 	addi	r2,r2,-28284
81135e24:	18c7883a 	add	r3,r3,r3
81135e28:	18c7883a 	add	r3,r3,r3
81135e2c:	10c5883a 	add	r2,r2,r3
81135e30:	10800017 	ldw	r2,0(r2)
81135e34:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81135e38:	e0bffb17 	ldw	r2,-20(fp)
81135e3c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81135e40:	e0bffb17 	ldw	r2,-20(fp)
81135e44:	e0fffd17 	ldw	r3,-12(fp)
81135e48:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81135e4c:	e0bffb17 	ldw	r2,-20(fp)
81135e50:	10800c03 	ldbu	r2,48(r2)
81135e54:	1007883a 	mov	r3,r2
81135e58:	e0bffe03 	ldbu	r2,-8(fp)
81135e5c:	0084303a 	nor	r2,zero,r2
81135e60:	1884703a 	and	r2,r3,r2
81135e64:	1007883a 	mov	r3,r2
81135e68:	e0bffb17 	ldw	r2,-20(fp)
81135e6c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81135e70:	e0bffb17 	ldw	r2,-20(fp)
81135e74:	e0ffff03 	ldbu	r3,-4(fp)
81135e78:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81135e7c:	e0bffb17 	ldw	r2,-20(fp)
81135e80:	10800c03 	ldbu	r2,48(r2)
81135e84:	10803fcc 	andi	r2,r2,255
81135e88:	1080020c 	andi	r2,r2,8
81135e8c:	1000111e 	bne	r2,zero,81135ed4 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
81135e90:	e0bffb17 	ldw	r2,-20(fp)
81135e94:	10c00d83 	ldbu	r3,54(r2)
81135e98:	d0a09d03 	ldbu	r2,-32140(gp)
81135e9c:	1884b03a 	or	r2,r3,r2
81135ea0:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
81135ea4:	e0fffa03 	ldbu	r3,-24(fp)
81135ea8:	e13ffa03 	ldbu	r4,-24(fp)
81135eac:	d0a09d44 	addi	r2,gp,-32139
81135eb0:	2085883a 	add	r2,r4,r2
81135eb4:	11000003 	ldbu	r4,0(r2)
81135eb8:	e0bffb17 	ldw	r2,-20(fp)
81135ebc:	10800d43 	ldbu	r2,53(r2)
81135ec0:	2084b03a 	or	r2,r4,r2
81135ec4:	1009883a 	mov	r4,r2
81135ec8:	d0a09d44 	addi	r2,gp,-32139
81135ecc:	1885883a 	add	r2,r3,r2
81135ed0:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
81135ed4:	e17ffc17 	ldw	r5,-16(fp)
81135ed8:	e13ffb17 	ldw	r4,-20(fp)
81135edc:	11361940 	call	81136194 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
81135ee0:	e0bffb17 	ldw	r2,-20(fp)
81135ee4:	10800817 	ldw	r2,32(r2)
81135ee8:	10000826 	beq	r2,zero,81135f0c <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81135eec:	e0bffb17 	ldw	r2,-20(fp)
81135ef0:	10800817 	ldw	r2,32(r2)
81135ef4:	100b883a 	mov	r5,r2
81135ef8:	e13ffb17 	ldw	r4,-20(fp)
81135efc:	11362540 	call	81136254 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81135f00:	e0bffb17 	ldw	r2,-20(fp)
81135f04:	e0fffc17 	ldw	r3,-16(fp)
81135f08:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81135f0c:	e0bffa83 	ldbu	r2,-22(fp)
}
81135f10:	e037883a 	mov	sp,fp
81135f14:	dfc00117 	ldw	ra,4(sp)
81135f18:	df000017 	ldw	fp,0(sp)
81135f1c:	dec00204 	addi	sp,sp,8
81135f20:	f800283a 	ret

81135f24 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
81135f24:	defffd04 	addi	sp,sp,-12
81135f28:	de00012e 	bgeu	sp,et,81135f30 <OS_EventTaskWait+0xc>
81135f2c:	003b68fa 	trap	3
81135f30:	df000215 	stw	fp,8(sp)
81135f34:	df000204 	addi	fp,sp,8
81135f38:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81135f3c:	d0a0a117 	ldw	r2,-32124(gp)
81135f40:	e0ffff17 	ldw	r3,-4(fp)
81135f44:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
81135f48:	d0a0a117 	ldw	r2,-32124(gp)
81135f4c:	10800d03 	ldbu	r2,52(r2)
81135f50:	10803fcc 	andi	r2,r2,255
81135f54:	d0e0a117 	ldw	r3,-32124(gp)
81135f58:	18c00d03 	ldbu	r3,52(r3)
81135f5c:	18c03fcc 	andi	r3,r3,255
81135f60:	e13fff17 	ldw	r4,-4(fp)
81135f64:	20c7883a 	add	r3,r4,r3
81135f68:	18c002c4 	addi	r3,r3,11
81135f6c:	19000003 	ldbu	r4,0(r3)
81135f70:	d0e0a117 	ldw	r3,-32124(gp)
81135f74:	18c00d43 	ldbu	r3,53(r3)
81135f78:	20c6b03a 	or	r3,r4,r3
81135f7c:	1809883a 	mov	r4,r3
81135f80:	e0ffff17 	ldw	r3,-4(fp)
81135f84:	1885883a 	add	r2,r3,r2
81135f88:	108002c4 	addi	r2,r2,11
81135f8c:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81135f90:	e0bfff17 	ldw	r2,-4(fp)
81135f94:	10c00283 	ldbu	r3,10(r2)
81135f98:	d0a0a117 	ldw	r2,-32124(gp)
81135f9c:	10800d83 	ldbu	r2,54(r2)
81135fa0:	1884b03a 	or	r2,r3,r2
81135fa4:	1007883a 	mov	r3,r2
81135fa8:	e0bfff17 	ldw	r2,-4(fp)
81135fac:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81135fb0:	d0a0a117 	ldw	r2,-32124(gp)
81135fb4:	10800d03 	ldbu	r2,52(r2)
81135fb8:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81135fbc:	e0fffe03 	ldbu	r3,-8(fp)
81135fc0:	e13ffe03 	ldbu	r4,-8(fp)
81135fc4:	d0a09d44 	addi	r2,gp,-32139
81135fc8:	2085883a 	add	r2,r4,r2
81135fcc:	10800003 	ldbu	r2,0(r2)
81135fd0:	1009883a 	mov	r4,r2
81135fd4:	d0a0a117 	ldw	r2,-32124(gp)
81135fd8:	10800d43 	ldbu	r2,53(r2)
81135fdc:	0084303a 	nor	r2,zero,r2
81135fe0:	2084703a 	and	r2,r4,r2
81135fe4:	1009883a 	mov	r4,r2
81135fe8:	d0a09d44 	addi	r2,gp,-32139
81135fec:	1885883a 	add	r2,r3,r2
81135ff0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81135ff4:	e0fffe03 	ldbu	r3,-8(fp)
81135ff8:	d0a09d44 	addi	r2,gp,-32139
81135ffc:	1885883a 	add	r2,r3,r2
81136000:	10800003 	ldbu	r2,0(r2)
81136004:	10803fcc 	andi	r2,r2,255
81136008:	1000071e 	bne	r2,zero,81136028 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113600c:	d0a0a117 	ldw	r2,-32124(gp)
81136010:	10800d83 	ldbu	r2,54(r2)
81136014:	0084303a 	nor	r2,zero,r2
81136018:	1007883a 	mov	r3,r2
8113601c:	d0a09d03 	ldbu	r2,-32140(gp)
81136020:	1884703a 	and	r2,r3,r2
81136024:	d0a09d05 	stb	r2,-32140(gp)
    }
}
81136028:	0001883a 	nop
8113602c:	e037883a 	mov	sp,fp
81136030:	df000017 	ldw	fp,0(sp)
81136034:	dec00104 	addi	sp,sp,4
81136038:	f800283a 	ret

8113603c <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
8113603c:	defffb04 	addi	sp,sp,-20
81136040:	de00012e 	bgeu	sp,et,81136048 <OS_EventTaskWaitMulti+0xc>
81136044:	003b68fa 	trap	3
81136048:	df000415 	stw	fp,16(sp)
8113604c:	df000404 	addi	fp,sp,16
81136050:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
81136054:	d0a0a117 	ldw	r2,-32124(gp)
81136058:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
8113605c:	d0a0a117 	ldw	r2,-32124(gp)
81136060:	e0ffff17 	ldw	r3,-4(fp)
81136064:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
81136068:	e0bfff17 	ldw	r2,-4(fp)
8113606c:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81136070:	e0bffc17 	ldw	r2,-16(fp)
81136074:	10800017 	ldw	r2,0(r2)
81136078:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113607c:	00002006 	br	81136100 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
81136080:	d0a0a117 	ldw	r2,-32124(gp)
81136084:	10800d03 	ldbu	r2,52(r2)
81136088:	10803fcc 	andi	r2,r2,255
8113608c:	d0e0a117 	ldw	r3,-32124(gp)
81136090:	18c00d03 	ldbu	r3,52(r3)
81136094:	18c03fcc 	andi	r3,r3,255
81136098:	e13ffd17 	ldw	r4,-12(fp)
8113609c:	20c7883a 	add	r3,r4,r3
811360a0:	18c002c4 	addi	r3,r3,11
811360a4:	19000003 	ldbu	r4,0(r3)
811360a8:	d0e0a117 	ldw	r3,-32124(gp)
811360ac:	18c00d43 	ldbu	r3,53(r3)
811360b0:	20c6b03a 	or	r3,r4,r3
811360b4:	1809883a 	mov	r4,r3
811360b8:	e0fffd17 	ldw	r3,-12(fp)
811360bc:	1885883a 	add	r2,r3,r2
811360c0:	108002c4 	addi	r2,r2,11
811360c4:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
811360c8:	e0bffd17 	ldw	r2,-12(fp)
811360cc:	10c00283 	ldbu	r3,10(r2)
811360d0:	d0a0a117 	ldw	r2,-32124(gp)
811360d4:	10800d83 	ldbu	r2,54(r2)
811360d8:	1884b03a 	or	r2,r3,r2
811360dc:	1007883a 	mov	r3,r2
811360e0:	e0bffd17 	ldw	r2,-12(fp)
811360e4:	10c00285 	stb	r3,10(r2)
        pevents++;
811360e8:	e0bffc17 	ldw	r2,-16(fp)
811360ec:	10800104 	addi	r2,r2,4
811360f0:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
811360f4:	e0bffc17 	ldw	r2,-16(fp)
811360f8:	10800017 	ldw	r2,0(r2)
811360fc:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81136100:	e0bffd17 	ldw	r2,-12(fp)
81136104:	103fde1e 	bne	r2,zero,81136080 <__reset+0xfb116080>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81136108:	d0a0a117 	ldw	r2,-32124(gp)
8113610c:	10800d03 	ldbu	r2,52(r2)
81136110:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81136114:	e0fffe03 	ldbu	r3,-8(fp)
81136118:	e13ffe03 	ldbu	r4,-8(fp)
8113611c:	d0a09d44 	addi	r2,gp,-32139
81136120:	2085883a 	add	r2,r4,r2
81136124:	10800003 	ldbu	r2,0(r2)
81136128:	1009883a 	mov	r4,r2
8113612c:	d0a0a117 	ldw	r2,-32124(gp)
81136130:	10800d43 	ldbu	r2,53(r2)
81136134:	0084303a 	nor	r2,zero,r2
81136138:	2084703a 	and	r2,r4,r2
8113613c:	1009883a 	mov	r4,r2
81136140:	d0a09d44 	addi	r2,gp,-32139
81136144:	1885883a 	add	r2,r3,r2
81136148:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113614c:	e0fffe03 	ldbu	r3,-8(fp)
81136150:	d0a09d44 	addi	r2,gp,-32139
81136154:	1885883a 	add	r2,r3,r2
81136158:	10800003 	ldbu	r2,0(r2)
8113615c:	10803fcc 	andi	r2,r2,255
81136160:	1000071e 	bne	r2,zero,81136180 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81136164:	d0a0a117 	ldw	r2,-32124(gp)
81136168:	10800d83 	ldbu	r2,54(r2)
8113616c:	0084303a 	nor	r2,zero,r2
81136170:	1007883a 	mov	r3,r2
81136174:	d0a09d03 	ldbu	r2,-32140(gp)
81136178:	1884703a 	and	r2,r3,r2
8113617c:	d0a09d05 	stb	r2,-32140(gp)
    }
}
81136180:	0001883a 	nop
81136184:	e037883a 	mov	sp,fp
81136188:	df000017 	ldw	fp,0(sp)
8113618c:	dec00104 	addi	sp,sp,4
81136190:	f800283a 	ret

81136194 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
81136194:	defffc04 	addi	sp,sp,-16
81136198:	de00012e 	bgeu	sp,et,811361a0 <OS_EventTaskRemove+0xc>
8113619c:	003b68fa 	trap	3
811361a0:	df000315 	stw	fp,12(sp)
811361a4:	df000304 	addi	fp,sp,12
811361a8:	e13ffe15 	stw	r4,-8(fp)
811361ac:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
811361b0:	e0bffe17 	ldw	r2,-8(fp)
811361b4:	10800d03 	ldbu	r2,52(r2)
811361b8:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
811361bc:	e0bffd03 	ldbu	r2,-12(fp)
811361c0:	e0fffd03 	ldbu	r3,-12(fp)
811361c4:	e13fff17 	ldw	r4,-4(fp)
811361c8:	20c7883a 	add	r3,r4,r3
811361cc:	18c002c4 	addi	r3,r3,11
811361d0:	18c00003 	ldbu	r3,0(r3)
811361d4:	1809883a 	mov	r4,r3
811361d8:	e0fffe17 	ldw	r3,-8(fp)
811361dc:	18c00d43 	ldbu	r3,53(r3)
811361e0:	00c6303a 	nor	r3,zero,r3
811361e4:	20c6703a 	and	r3,r4,r3
811361e8:	1809883a 	mov	r4,r3
811361ec:	e0ffff17 	ldw	r3,-4(fp)
811361f0:	1885883a 	add	r2,r3,r2
811361f4:	108002c4 	addi	r2,r2,11
811361f8:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
811361fc:	e0bffd03 	ldbu	r2,-12(fp)
81136200:	e0ffff17 	ldw	r3,-4(fp)
81136204:	1885883a 	add	r2,r3,r2
81136208:	108002c4 	addi	r2,r2,11
8113620c:	10800003 	ldbu	r2,0(r2)
81136210:	10803fcc 	andi	r2,r2,255
81136214:	10000a1e 	bne	r2,zero,81136240 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
81136218:	e0bfff17 	ldw	r2,-4(fp)
8113621c:	10800283 	ldbu	r2,10(r2)
81136220:	1007883a 	mov	r3,r2
81136224:	e0bffe17 	ldw	r2,-8(fp)
81136228:	10800d83 	ldbu	r2,54(r2)
8113622c:	0084303a 	nor	r2,zero,r2
81136230:	1884703a 	and	r2,r3,r2
81136234:	1007883a 	mov	r3,r2
81136238:	e0bfff17 	ldw	r2,-4(fp)
8113623c:	10c00285 	stb	r3,10(r2)
    }
}
81136240:	0001883a 	nop
81136244:	e037883a 	mov	sp,fp
81136248:	df000017 	ldw	fp,0(sp)
8113624c:	dec00104 	addi	sp,sp,4
81136250:	f800283a 	ret

81136254 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
81136254:	defffa04 	addi	sp,sp,-24
81136258:	de00012e 	bgeu	sp,et,81136260 <OS_EventTaskRemoveMulti+0xc>
8113625c:	003b68fa 	trap	3
81136260:	df000515 	stw	fp,20(sp)
81136264:	df000504 	addi	fp,sp,20
81136268:	e13ffe15 	stw	r4,-8(fp)
8113626c:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
81136270:	e0bffe17 	ldw	r2,-8(fp)
81136274:	10800d03 	ldbu	r2,52(r2)
81136278:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8113627c:	e0bffe17 	ldw	r2,-8(fp)
81136280:	10800d83 	ldbu	r2,54(r2)
81136284:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
81136288:	e0bffe17 	ldw	r2,-8(fp)
8113628c:	10800d43 	ldbu	r2,53(r2)
81136290:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
81136294:	e0bfff17 	ldw	r2,-4(fp)
81136298:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8113629c:	e0bffb17 	ldw	r2,-20(fp)
811362a0:	10800017 	ldw	r2,0(r2)
811362a4:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811362a8:	00002506 	br	81136340 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
811362ac:	e0bffd03 	ldbu	r2,-12(fp)
811362b0:	e0fffd03 	ldbu	r3,-12(fp)
811362b4:	e13ffc17 	ldw	r4,-16(fp)
811362b8:	20c7883a 	add	r3,r4,r3
811362bc:	18c002c4 	addi	r3,r3,11
811362c0:	18c00003 	ldbu	r3,0(r3)
811362c4:	1809883a 	mov	r4,r3
811362c8:	e0fffd83 	ldbu	r3,-10(fp)
811362cc:	00c6303a 	nor	r3,zero,r3
811362d0:	20c6703a 	and	r3,r4,r3
811362d4:	1809883a 	mov	r4,r3
811362d8:	e0fffc17 	ldw	r3,-16(fp)
811362dc:	1885883a 	add	r2,r3,r2
811362e0:	108002c4 	addi	r2,r2,11
811362e4:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
811362e8:	e0bffd03 	ldbu	r2,-12(fp)
811362ec:	e0fffc17 	ldw	r3,-16(fp)
811362f0:	1885883a 	add	r2,r3,r2
811362f4:	108002c4 	addi	r2,r2,11
811362f8:	10800003 	ldbu	r2,0(r2)
811362fc:	10803fcc 	andi	r2,r2,255
81136300:	1000091e 	bne	r2,zero,81136328 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
81136304:	e0bffc17 	ldw	r2,-16(fp)
81136308:	10800283 	ldbu	r2,10(r2)
8113630c:	1007883a 	mov	r3,r2
81136310:	e0bffd43 	ldbu	r2,-11(fp)
81136314:	0084303a 	nor	r2,zero,r2
81136318:	1884703a 	and	r2,r3,r2
8113631c:	1007883a 	mov	r3,r2
81136320:	e0bffc17 	ldw	r2,-16(fp)
81136324:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
81136328:	e0bffb17 	ldw	r2,-20(fp)
8113632c:	10800104 	addi	r2,r2,4
81136330:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
81136334:	e0bffb17 	ldw	r2,-20(fp)
81136338:	10800017 	ldw	r2,0(r2)
8113633c:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81136340:	e0bffc17 	ldw	r2,-16(fp)
81136344:	103fd91e 	bne	r2,zero,811362ac <__reset+0xfb1162ac>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
81136348:	0001883a 	nop
8113634c:	e037883a 	mov	sp,fp
81136350:	df000017 	ldw	fp,0(sp)
81136354:	dec00104 	addi	sp,sp,4
81136358:	f800283a 	ret

8113635c <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8113635c:	defffc04 	addi	sp,sp,-16
81136360:	de00012e 	bgeu	sp,et,81136368 <OS_EventWaitListInit+0xc>
81136364:	003b68fa 	trap	3
81136368:	df000315 	stw	fp,12(sp)
8113636c:	df000304 	addi	fp,sp,12
81136370:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
81136374:	e0bfff17 	ldw	r2,-4(fp)
81136378:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8113637c:	e0bfff17 	ldw	r2,-4(fp)
81136380:	108002c4 	addi	r2,r2,11
81136384:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81136388:	e03ffe05 	stb	zero,-8(fp)
8113638c:	00000706 	br	811363ac <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
81136390:	e0bffd17 	ldw	r2,-12(fp)
81136394:	10c00044 	addi	r3,r2,1
81136398:	e0fffd15 	stw	r3,-12(fp)
8113639c:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811363a0:	e0bffe03 	ldbu	r2,-8(fp)
811363a4:	10800044 	addi	r2,r2,1
811363a8:	e0bffe05 	stb	r2,-8(fp)
811363ac:	e0bffe03 	ldbu	r2,-8(fp)
811363b0:	108001b0 	cmpltui	r2,r2,6
811363b4:	103ff61e 	bne	r2,zero,81136390 <__reset+0xfb116390>
        *ptbl++ = 0;
    }
}
811363b8:	0001883a 	nop
811363bc:	e037883a 	mov	sp,fp
811363c0:	df000017 	ldw	fp,0(sp)
811363c4:	dec00104 	addi	sp,sp,4
811363c8:	f800283a 	ret

811363cc <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
811363cc:	defffb04 	addi	sp,sp,-20
811363d0:	de00012e 	bgeu	sp,et,811363d8 <OS_InitEventList+0xc>
811363d4:	003b68fa 	trap	3
811363d8:	dfc00415 	stw	ra,16(sp)
811363dc:	df000315 	stw	fp,12(sp)
811363e0:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
811363e4:	01434004 	movi	r5,3328
811363e8:	012045b4 	movhi	r4,33046
811363ec:	211cb304 	addi	r4,r4,29388
811363f0:	11367740 	call	81136774 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
811363f4:	00a045b4 	movhi	r2,33046
811363f8:	109cb304 	addi	r2,r2,29388
811363fc:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
81136400:	00a045b4 	movhi	r2,33046
81136404:	109cc004 	addi	r2,r2,29440
81136408:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113640c:	e03ffd0d 	sth	zero,-12(fp)
81136410:	00001306 	br	81136460 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
81136414:	e0bffe17 	ldw	r2,-8(fp)
81136418:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
8113641c:	e0bffe17 	ldw	r2,-8(fp)
81136420:	e0ffff17 	ldw	r3,-4(fp)
81136424:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
81136428:	e0bffe17 	ldw	r2,-8(fp)
8113642c:	00c00fc4 	movi	r3,63
81136430:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
81136434:	e0bffe17 	ldw	r2,-8(fp)
81136438:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8113643c:	e0bffe17 	ldw	r2,-8(fp)
81136440:	10800d04 	addi	r2,r2,52
81136444:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
81136448:	e0bfff17 	ldw	r2,-4(fp)
8113644c:	10800d04 	addi	r2,r2,52
81136450:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81136454:	e0bffd0b 	ldhu	r2,-12(fp)
81136458:	10800044 	addi	r2,r2,1
8113645c:	e0bffd0d 	sth	r2,-12(fp)
81136460:	e0bffd0b 	ldhu	r2,-12(fp)
81136464:	10800ff0 	cmpltui	r2,r2,63
81136468:	103fea1e 	bne	r2,zero,81136414 <__reset+0xfb116414>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8113646c:	e0bffe17 	ldw	r2,-8(fp)
81136470:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
81136474:	e0bffe17 	ldw	r2,-8(fp)
81136478:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8113647c:	e0bffe17 	ldw	r2,-8(fp)
81136480:	00c00fc4 	movi	r3,63
81136484:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
81136488:	e0bffe17 	ldw	r2,-8(fp)
8113648c:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
81136490:	00a045b4 	movhi	r2,33046
81136494:	109cb304 	addi	r2,r2,29388
81136498:	d0a09f15 	stw	r2,-32132(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8113649c:	0001883a 	nop
811364a0:	e037883a 	mov	sp,fp
811364a4:	dfc00117 	ldw	ra,4(sp)
811364a8:	df000017 	ldw	fp,0(sp)
811364ac:	dec00204 	addi	sp,sp,8
811364b0:	f800283a 	ret

811364b4 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
811364b4:	deffff04 	addi	sp,sp,-4
811364b8:	de00012e 	bgeu	sp,et,811364c0 <OS_InitMisc+0xc>
811364bc:	003b68fa 	trap	3
811364c0:	df000015 	stw	fp,0(sp)
811364c4:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
811364c8:	d020a315 	stw	zero,-32116(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
811364cc:	d020a005 	stb	zero,-32128(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
811364d0:	d0208e05 	stb	zero,-32200(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
811364d4:	d0209945 	stb	zero,-32155(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
811364d8:	d0209005 	stb	zero,-32192(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
811364dc:	d0209515 	stw	zero,-32172(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
811364e0:	d0209115 	stw	zero,-32188(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
811364e4:	d020a715 	stw	zero,-32100(gp)
    OSIdleCtrMax  = 0L;
811364e8:	d0209715 	stw	zero,-32164(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
811364ec:	d020a605 	stb	zero,-32104(gp)
#endif
}
811364f0:	0001883a 	nop
811364f4:	e037883a 	mov	sp,fp
811364f8:	df000017 	ldw	fp,0(sp)
811364fc:	dec00104 	addi	sp,sp,4
81136500:	f800283a 	ret

81136504 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
81136504:	defffd04 	addi	sp,sp,-12
81136508:	de00012e 	bgeu	sp,et,81136510 <OS_InitRdyList+0xc>
8113650c:	003b68fa 	trap	3
81136510:	df000215 	stw	fp,8(sp)
81136514:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
81136518:	d0209d05 	stb	zero,-32140(gp)
    prdytbl       = &OSRdyTbl[0];
8113651c:	d0a09d44 	addi	r2,gp,-32139
81136520:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81136524:	e03ffe05 	stb	zero,-8(fp)
81136528:	00000706 	br	81136548 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
8113652c:	e0bfff17 	ldw	r2,-4(fp)
81136530:	10c00044 	addi	r3,r2,1
81136534:	e0ffff15 	stw	r3,-4(fp)
81136538:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113653c:	e0bffe03 	ldbu	r2,-8(fp)
81136540:	10800044 	addi	r2,r2,1
81136544:	e0bffe05 	stb	r2,-8(fp)
81136548:	e0bffe03 	ldbu	r2,-8(fp)
8113654c:	108001b0 	cmpltui	r2,r2,6
81136550:	103ff61e 	bne	r2,zero,8113652c <__reset+0xfb11652c>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
81136554:	d02092c5 	stb	zero,-32181(gp)
    OSPrioHighRdy = 0;
81136558:	d0209285 	stb	zero,-32182(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8113655c:	d0209b15 	stw	zero,-32148(gp)
    OSTCBCur      = (OS_TCB *)0;
81136560:	d020a115 	stw	zero,-32124(gp)
}
81136564:	0001883a 	nop
81136568:	e037883a 	mov	sp,fp
8113656c:	df000017 	ldw	fp,0(sp)
81136570:	dec00104 	addi	sp,sp,4
81136574:	f800283a 	ret

81136578 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
81136578:	defff804 	addi	sp,sp,-32
8113657c:	de00012e 	bgeu	sp,et,81136584 <OS_InitTaskIdle+0xc>
81136580:	003b68fa 	trap	3
81136584:	dfc00715 	stw	ra,28(sp)
81136588:	df000615 	stw	fp,24(sp)
8113658c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
81136590:	008000c4 	movi	r2,3
81136594:	d8800415 	stw	r2,16(sp)
81136598:	d8000315 	stw	zero,12(sp)
8113659c:	00810004 	movi	r2,1024
811365a0:	d8800215 	stw	r2,8(sp)
811365a4:	00a045b4 	movhi	r2,33046
811365a8:	1098b304 	addi	r2,r2,25292
811365ac:	d8800115 	stw	r2,4(sp)
811365b0:	00bfffd4 	movui	r2,65535
811365b4:	d8800015 	stw	r2,0(sp)
811365b8:	01c00a84 	movi	r7,42
811365bc:	01a045b4 	movhi	r6,33046
811365c0:	319cb204 	addi	r6,r6,29384
811365c4:	000b883a 	mov	r5,zero
811365c8:	012044f4 	movhi	r4,33043
811365cc:	211a9b04 	addi	r4,r4,27244
811365d0:	113c45c0 	call	8113c45c <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
811365d4:	e1bfff04 	addi	r6,fp,-4
811365d8:	01604574 	movhi	r5,33045
811365dc:	29752e04 	addi	r5,r5,-11080
811365e0:	01000a84 	movi	r4,42
811365e4:	113cc8c0 	call	8113cc8c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
811365e8:	0001883a 	nop
811365ec:	e037883a 	mov	sp,fp
811365f0:	dfc00117 	ldw	ra,4(sp)
811365f4:	df000017 	ldw	fp,0(sp)
811365f8:	dec00204 	addi	sp,sp,8
811365fc:	f800283a 	ret

81136600 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
81136600:	defff804 	addi	sp,sp,-32
81136604:	de00012e 	bgeu	sp,et,8113660c <OS_InitTaskStat+0xc>
81136608:	003b68fa 	trap	3
8113660c:	dfc00715 	stw	ra,28(sp)
81136610:	df000615 	stw	fp,24(sp)
81136614:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81136618:	008000c4 	movi	r2,3
8113661c:	d8800415 	stw	r2,16(sp)
81136620:	d8000315 	stw	zero,12(sp)
81136624:	00810004 	movi	r2,1024
81136628:	d8800215 	stw	r2,8(sp)
8113662c:	00a045b4 	movhi	r2,33046
81136630:	1091f304 	addi	r2,r2,18380
81136634:	d8800115 	stw	r2,4(sp)
81136638:	00bfff94 	movui	r2,65534
8113663c:	d8800015 	stw	r2,0(sp)
81136640:	01c00a44 	movi	r7,41
81136644:	01a045b4 	movhi	r6,33046
81136648:	3195f204 	addi	r6,r6,22472
8113664c:	000b883a 	mov	r5,zero
81136650:	012044f4 	movhi	r4,33043
81136654:	211ab404 	addi	r4,r4,27344
81136658:	113c45c0 	call	8113c45c <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8113665c:	e1bfff04 	addi	r6,fp,-4
81136660:	01604574 	movhi	r5,33045
81136664:	29753204 	addi	r5,r5,-11064
81136668:	01000a44 	movi	r4,41
8113666c:	113cc8c0 	call	8113cc8c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
81136670:	0001883a 	nop
81136674:	e037883a 	mov	sp,fp
81136678:	dfc00117 	ldw	ra,4(sp)
8113667c:	df000017 	ldw	fp,0(sp)
81136680:	dec00204 	addi	sp,sp,8
81136684:	f800283a 	ret

81136688 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81136688:	defffb04 	addi	sp,sp,-20
8113668c:	de00012e 	bgeu	sp,et,81136694 <OS_InitTCBList+0xc>
81136690:	003b68fa 	trap	3
81136694:	dfc00415 	stw	ra,16(sp)
81136698:	df000315 	stw	fp,12(sp)
8113669c:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
811366a0:	01446e04 	movi	r5,4536
811366a4:	012045b4 	movhi	r4,33046
811366a8:	211ff304 	addi	r4,r4,32716
811366ac:	11367740 	call	81136774 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
811366b0:	01402b04 	movi	r5,172
811366b4:	012045f4 	movhi	r4,33047
811366b8:	21246104 	addi	r4,r4,-28284
811366bc:	11367740 	call	81136774 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
811366c0:	00a045b4 	movhi	r2,33046
811366c4:	109ff304 	addi	r2,r2,32716
811366c8:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
811366cc:	00a045f4 	movhi	r2,33047
811366d0:	10a00e04 	addi	r2,r2,-32712
811366d4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
811366d8:	e03ffd05 	stb	zero,-12(fp)
811366dc:	00001106 	br	81136724 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
811366e0:	e0bffe17 	ldw	r2,-8(fp)
811366e4:	e0ffff17 	ldw	r3,-4(fp)
811366e8:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
811366ec:	e0bffe17 	ldw	r2,-8(fp)
811366f0:	00c00fc4 	movi	r3,63
811366f4:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
811366f8:	e0bffe17 	ldw	r2,-8(fp)
811366fc:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81136700:	e0bffe17 	ldw	r2,-8(fp)
81136704:	10801b04 	addi	r2,r2,108
81136708:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
8113670c:	e0bfff17 	ldw	r2,-4(fp)
81136710:	10801b04 	addi	r2,r2,108
81136714:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81136718:	e0bffd03 	ldbu	r2,-12(fp)
8113671c:	10800044 	addi	r2,r2,1
81136720:	e0bffd05 	stb	r2,-12(fp)
81136724:	e0bffd03 	ldbu	r2,-12(fp)
81136728:	10800a70 	cmpltui	r2,r2,41
8113672c:	103fec1e 	bne	r2,zero,811366e0 <__reset+0xfb1166e0>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81136730:	e0bffe17 	ldw	r2,-8(fp)
81136734:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81136738:	e0bffe17 	ldw	r2,-8(fp)
8113673c:	00c00fc4 	movi	r3,63
81136740:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81136744:	e0bffe17 	ldw	r2,-8(fp)
81136748:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8113674c:	d0209315 	stw	zero,-32180(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81136750:	00a045b4 	movhi	r2,33046
81136754:	109ff304 	addi	r2,r2,32716
81136758:	d0a09815 	stw	r2,-32160(gp)
}
8113675c:	0001883a 	nop
81136760:	e037883a 	mov	sp,fp
81136764:	dfc00117 	ldw	ra,4(sp)
81136768:	df000017 	ldw	fp,0(sp)
8113676c:	dec00204 	addi	sp,sp,8
81136770:	f800283a 	ret

81136774 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81136774:	defffd04 	addi	sp,sp,-12
81136778:	de00012e 	bgeu	sp,et,81136780 <OS_MemClr+0xc>
8113677c:	003b68fa 	trap	3
81136780:	df000215 	stw	fp,8(sp)
81136784:	df000204 	addi	fp,sp,8
81136788:	e13ffe15 	stw	r4,-8(fp)
8113678c:	2805883a 	mov	r2,r5
81136790:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81136794:	00000706 	br	811367b4 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81136798:	e0bffe17 	ldw	r2,-8(fp)
8113679c:	10c00044 	addi	r3,r2,1
811367a0:	e0fffe15 	stw	r3,-8(fp)
811367a4:	10000005 	stb	zero,0(r2)
        size--;
811367a8:	e0bfff0b 	ldhu	r2,-4(fp)
811367ac:	10bfffc4 	addi	r2,r2,-1
811367b0:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
811367b4:	e0bfff0b 	ldhu	r2,-4(fp)
811367b8:	103ff71e 	bne	r2,zero,81136798 <__reset+0xfb116798>
        *pdest++ = (INT8U)0;
        size--;
    }
}
811367bc:	0001883a 	nop
811367c0:	e037883a 	mov	sp,fp
811367c4:	df000017 	ldw	fp,0(sp)
811367c8:	dec00104 	addi	sp,sp,4
811367cc:	f800283a 	ret

811367d0 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
811367d0:	defffc04 	addi	sp,sp,-16
811367d4:	de00012e 	bgeu	sp,et,811367dc <OS_MemCopy+0xc>
811367d8:	003b68fa 	trap	3
811367dc:	df000315 	stw	fp,12(sp)
811367e0:	df000304 	addi	fp,sp,12
811367e4:	e13ffd15 	stw	r4,-12(fp)
811367e8:	e17ffe15 	stw	r5,-8(fp)
811367ec:	3005883a 	mov	r2,r6
811367f0:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
811367f4:	00000b06 	br	81136824 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
811367f8:	e0bffd17 	ldw	r2,-12(fp)
811367fc:	10c00044 	addi	r3,r2,1
81136800:	e0fffd15 	stw	r3,-12(fp)
81136804:	e0fffe17 	ldw	r3,-8(fp)
81136808:	19000044 	addi	r4,r3,1
8113680c:	e13ffe15 	stw	r4,-8(fp)
81136810:	18c00003 	ldbu	r3,0(r3)
81136814:	10c00005 	stb	r3,0(r2)
        size--;
81136818:	e0bfff0b 	ldhu	r2,-4(fp)
8113681c:	10bfffc4 	addi	r2,r2,-1
81136820:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
81136824:	e0bfff0b 	ldhu	r2,-4(fp)
81136828:	103ff31e 	bne	r2,zero,811367f8 <__reset+0xfb1167f8>
        *pdest++ = *psrc++;
        size--;
    }
}
8113682c:	0001883a 	nop
81136830:	e037883a 	mov	sp,fp
81136834:	df000017 	ldw	fp,0(sp)
81136838:	dec00104 	addi	sp,sp,4
8113683c:	f800283a 	ret

81136840 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81136840:	defffb04 	addi	sp,sp,-20
81136844:	de00012e 	bgeu	sp,et,8113684c <OS_Sched+0xc>
81136848:	003b68fa 	trap	3
8113684c:	dfc00415 	stw	ra,16(sp)
81136850:	df000315 	stw	fp,12(sp)
81136854:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81136858:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113685c:	0005303a 	rdctl	r2,status
81136860:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136864:	e0ffff17 	ldw	r3,-4(fp)
81136868:	00bfff84 	movi	r2,-2
8113686c:	1884703a 	and	r2,r3,r2
81136870:	1001703a 	wrctl	status,r2
  
  return context;
81136874:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81136878:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8113687c:	d0a0a003 	ldbu	r2,-32128(gp)
81136880:	10803fcc 	andi	r2,r2,255
81136884:	10001a1e 	bne	r2,zero,811368f0 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81136888:	d0a08e03 	ldbu	r2,-32200(gp)
8113688c:	10803fcc 	andi	r2,r2,255
81136890:	1000171e 	bne	r2,zero,811368f0 <OS_Sched+0xb0>
            OS_SchedNew();
81136894:	11369180 	call	81136918 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81136898:	d0e09283 	ldbu	r3,-32182(gp)
8113689c:	d0a092c3 	ldbu	r2,-32181(gp)
811368a0:	18c03fcc 	andi	r3,r3,255
811368a4:	10803fcc 	andi	r2,r2,255
811368a8:	18801126 	beq	r3,r2,811368f0 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
811368ac:	d0a09283 	ldbu	r2,-32182(gp)
811368b0:	10c03fcc 	andi	r3,r2,255
811368b4:	00a045f4 	movhi	r2,33047
811368b8:	10a46104 	addi	r2,r2,-28284
811368bc:	18c7883a 	add	r3,r3,r3
811368c0:	18c7883a 	add	r3,r3,r3
811368c4:	10c5883a 	add	r2,r2,r3
811368c8:	10800017 	ldw	r2,0(r2)
811368cc:	d0a09b15 	stw	r2,-32148(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
811368d0:	d0a09b17 	ldw	r2,-32148(gp)
811368d4:	10c00e17 	ldw	r3,56(r2)
811368d8:	18c00044 	addi	r3,r3,1
811368dc:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
811368e0:	d0a09517 	ldw	r2,-32172(gp)
811368e4:	10800044 	addi	r2,r2,1
811368e8:	d0a09515 	stw	r2,-32172(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
811368ec:	11478700 	call	81147870 <OSCtxSw>
811368f0:	e0bffd17 	ldw	r2,-12(fp)
811368f4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811368f8:	e0bffe17 	ldw	r2,-8(fp)
811368fc:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81136900:	0001883a 	nop
81136904:	e037883a 	mov	sp,fp
81136908:	dfc00117 	ldw	ra,4(sp)
8113690c:	df000017 	ldw	fp,0(sp)
81136910:	dec00204 	addi	sp,sp,8
81136914:	f800283a 	ret

81136918 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81136918:	defffe04 	addi	sp,sp,-8
8113691c:	de00012e 	bgeu	sp,et,81136924 <OS_SchedNew+0xc>
81136920:	003b68fa 	trap	3
81136924:	df000115 	stw	fp,4(sp)
81136928:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
8113692c:	d0a09d03 	ldbu	r2,-32140(gp)
81136930:	10c03fcc 	andi	r3,r2,255
81136934:	00a04574 	movhi	r2,33045
81136938:	10b4ee04 	addi	r2,r2,-11336
8113693c:	10c5883a 	add	r2,r2,r3
81136940:	10800003 	ldbu	r2,0(r2)
81136944:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81136948:	e0bfff03 	ldbu	r2,-4(fp)
8113694c:	100490fa 	slli	r2,r2,3
81136950:	1009883a 	mov	r4,r2
81136954:	e0ffff03 	ldbu	r3,-4(fp)
81136958:	d0a09d44 	addi	r2,gp,-32139
8113695c:	1885883a 	add	r2,r3,r2
81136960:	10800003 	ldbu	r2,0(r2)
81136964:	10c03fcc 	andi	r3,r2,255
81136968:	00a04574 	movhi	r2,33045
8113696c:	10b4ee04 	addi	r2,r2,-11336
81136970:	10c5883a 	add	r2,r2,r3
81136974:	10800003 	ldbu	r2,0(r2)
81136978:	2085883a 	add	r2,r4,r2
8113697c:	d0a09285 	stb	r2,-32182(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81136980:	0001883a 	nop
81136984:	e037883a 	mov	sp,fp
81136988:	df000017 	ldw	fp,0(sp)
8113698c:	dec00104 	addi	sp,sp,4
81136990:	f800283a 	ret

81136994 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81136994:	defffc04 	addi	sp,sp,-16
81136998:	de00012e 	bgeu	sp,et,811369a0 <OS_StrCopy+0xc>
8113699c:	003b68fa 	trap	3
811369a0:	df000315 	stw	fp,12(sp)
811369a4:	df000304 	addi	fp,sp,12
811369a8:	e13ffe15 	stw	r4,-8(fp)
811369ac:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
811369b0:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
811369b4:	00000b06 	br	811369e4 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
811369b8:	e0bffe17 	ldw	r2,-8(fp)
811369bc:	10c00044 	addi	r3,r2,1
811369c0:	e0fffe15 	stw	r3,-8(fp)
811369c4:	e0ffff17 	ldw	r3,-4(fp)
811369c8:	19000044 	addi	r4,r3,1
811369cc:	e13fff15 	stw	r4,-4(fp)
811369d0:	18c00003 	ldbu	r3,0(r3)
811369d4:	10c00005 	stb	r3,0(r2)
        len++;
811369d8:	e0bffd03 	ldbu	r2,-12(fp)
811369dc:	10800044 	addi	r2,r2,1
811369e0:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
811369e4:	e0bfff17 	ldw	r2,-4(fp)
811369e8:	10800003 	ldbu	r2,0(r2)
811369ec:	10803fcc 	andi	r2,r2,255
811369f0:	103ff11e 	bne	r2,zero,811369b8 <__reset+0xfb1169b8>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
811369f4:	e0bffe17 	ldw	r2,-8(fp)
811369f8:	10000005 	stb	zero,0(r2)
    return (len);
811369fc:	e0bffd03 	ldbu	r2,-12(fp)
}
81136a00:	e037883a 	mov	sp,fp
81136a04:	df000017 	ldw	fp,0(sp)
81136a08:	dec00104 	addi	sp,sp,4
81136a0c:	f800283a 	ret

81136a10 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81136a10:	defffd04 	addi	sp,sp,-12
81136a14:	de00012e 	bgeu	sp,et,81136a1c <OS_StrLen+0xc>
81136a18:	003b68fa 	trap	3
81136a1c:	df000215 	stw	fp,8(sp)
81136a20:	df000204 	addi	fp,sp,8
81136a24:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81136a28:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81136a2c:	00000606 	br	81136a48 <OS_StrLen+0x38>
        psrc++;
81136a30:	e0bfff17 	ldw	r2,-4(fp)
81136a34:	10800044 	addi	r2,r2,1
81136a38:	e0bfff15 	stw	r2,-4(fp)
        len++;
81136a3c:	e0bffe03 	ldbu	r2,-8(fp)
81136a40:	10800044 	addi	r2,r2,1
81136a44:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81136a48:	e0bfff17 	ldw	r2,-4(fp)
81136a4c:	10800003 	ldbu	r2,0(r2)
81136a50:	10803fcc 	andi	r2,r2,255
81136a54:	103ff61e 	bne	r2,zero,81136a30 <__reset+0xfb116a30>
        psrc++;
        len++;
    }
    return (len);
81136a58:	e0bffe03 	ldbu	r2,-8(fp)
}
81136a5c:	e037883a 	mov	sp,fp
81136a60:	df000017 	ldw	fp,0(sp)
81136a64:	dec00104 	addi	sp,sp,4
81136a68:	f800283a 	ret

81136a6c <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81136a6c:	defffa04 	addi	sp,sp,-24
81136a70:	de00012e 	bgeu	sp,et,81136a78 <OS_TaskIdle+0xc>
81136a74:	003b68fa 	trap	3
81136a78:	dfc00515 	stw	ra,20(sp)
81136a7c:	df000415 	stw	fp,16(sp)
81136a80:	df000404 	addi	fp,sp,16
81136a84:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136a88:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136a8c:	0005303a 	rdctl	r2,status
81136a90:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136a94:	e0fffd17 	ldw	r3,-12(fp)
81136a98:	00bfff84 	movi	r2,-2
81136a9c:	1884703a 	and	r2,r3,r2
81136aa0:	1001703a 	wrctl	status,r2
  
  return context;
81136aa4:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81136aa8:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81136aac:	d0a09117 	ldw	r2,-32188(gp)
81136ab0:	10800044 	addi	r2,r2,1
81136ab4:	d0a09115 	stw	r2,-32188(gp)
81136ab8:	e0bffc17 	ldw	r2,-16(fp)
81136abc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136ac0:	e0bffe17 	ldw	r2,-8(fp)
81136ac4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81136ac8:	1147c040 	call	81147c04 <OSTaskIdleHook>
    }
81136acc:	003fef06 	br	81136a8c <__reset+0xfb116a8c>

81136ad0 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
81136ad0:	defff804 	addi	sp,sp,-32
81136ad4:	de00012e 	bgeu	sp,et,81136adc <OS_TaskStat+0xc>
81136ad8:	003b68fa 	trap	3
81136adc:	dfc00715 	stw	ra,28(sp)
81136ae0:	df000615 	stw	fp,24(sp)
81136ae4:	dc400515 	stw	r17,20(sp)
81136ae8:	dc000415 	stw	r16,16(sp)
81136aec:	df000604 	addi	fp,sp,24
81136af0:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136af4:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81136af8:	00000206 	br	81136b04 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81136afc:	01003204 	movi	r4,200
81136b00:	113d57c0 	call	8113d57c <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81136b04:	d0a0a603 	ldbu	r2,-32104(gp)
81136b08:	10803fcc 	andi	r2,r2,255
81136b0c:	103ffb26 	beq	r2,zero,81136afc <__reset+0xfb116afc>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81136b10:	d0e09717 	ldw	r3,-32164(gp)
81136b14:	00947b34 	movhi	r2,20972
81136b18:	10a147c4 	addi	r2,r2,-31457
81136b1c:	1888383a 	mulxuu	r4,r3,r2
81136b20:	1885383a 	mul	r2,r3,r2
81136b24:	1021883a 	mov	r16,r2
81136b28:	2023883a 	mov	r17,r4
81136b2c:	8804d17a 	srli	r2,r17,5
81136b30:	d0a09715 	stw	r2,-32164(gp)
    if (OSIdleCtrMax == 0L) {
81136b34:	d0a09717 	ldw	r2,-32164(gp)
81136b38:	1000031e 	bne	r2,zero,81136b48 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81136b3c:	d0209905 	stb	zero,-32156(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81136b40:	01003fc4 	movi	r4,255
81136b44:	113d1ec0 	call	8113d1ec <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136b48:	0005303a 	rdctl	r2,status
81136b4c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136b50:	e0fffb17 	ldw	r3,-20(fp)
81136b54:	00bfff84 	movi	r2,-2
81136b58:	1884703a 	and	r2,r3,r2
81136b5c:	1001703a 	wrctl	status,r2
  
  return context;
81136b60:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81136b64:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81136b68:	d0a09117 	ldw	r2,-32188(gp)
81136b6c:	d0a0a715 	stw	r2,-32100(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81136b70:	d0209115 	stw	zero,-32188(gp)
81136b74:	e0bffa17 	ldw	r2,-24(fp)
81136b78:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136b7c:	e0bffc17 	ldw	r2,-16(fp)
81136b80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81136b84:	d0e0a717 	ldw	r3,-32100(gp)
81136b88:	d0a09717 	ldw	r2,-32164(gp)
81136b8c:	1885203a 	divu	r2,r3,r2
81136b90:	1007883a 	mov	r3,r2
81136b94:	00801904 	movi	r2,100
81136b98:	10c5c83a 	sub	r2,r2,r3
81136b9c:	d0a09905 	stb	r2,-32156(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81136ba0:	1147b340 	call	81147b34 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81136ba4:	1136bb40 	call	81136bb4 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81136ba8:	01001904 	movi	r4,100
81136bac:	113d57c0 	call	8113d57c <OSTimeDly>
    }
81136bb0:	003fe506 	br	81136b48 <__reset+0xfb116b48>

81136bb4 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81136bb4:	defffa04 	addi	sp,sp,-24
81136bb8:	de00012e 	bgeu	sp,et,81136bc0 <OS_TaskStatStkChk+0xc>
81136bbc:	003b68fa 	trap	3
81136bc0:	dfc00515 	stw	ra,20(sp)
81136bc4:	df000415 	stw	fp,16(sp)
81136bc8:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81136bcc:	e03ffc05 	stb	zero,-16(fp)
81136bd0:	00002406 	br	81136c64 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
81136bd4:	e0bffc03 	ldbu	r2,-16(fp)
81136bd8:	e0fffe04 	addi	r3,fp,-8
81136bdc:	180b883a 	mov	r5,r3
81136be0:	1009883a 	mov	r4,r2
81136be4:	113d0240 	call	8113d024 <OSTaskStkChk>
81136be8:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
81136bec:	e0bffc43 	ldbu	r2,-15(fp)
81136bf0:	1000191e 	bne	r2,zero,81136c58 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
81136bf4:	e0fffc03 	ldbu	r3,-16(fp)
81136bf8:	00a045f4 	movhi	r2,33047
81136bfc:	10a46104 	addi	r2,r2,-28284
81136c00:	18c7883a 	add	r3,r3,r3
81136c04:	18c7883a 	add	r3,r3,r3
81136c08:	10c5883a 	add	r2,r2,r3
81136c0c:	10800017 	ldw	r2,0(r2)
81136c10:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
81136c14:	e0bffd17 	ldw	r2,-12(fp)
81136c18:	10000f26 	beq	r2,zero,81136c58 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81136c1c:	e0bffd17 	ldw	r2,-12(fp)
81136c20:	10800060 	cmpeqi	r2,r2,1
81136c24:	10000c1e 	bne	r2,zero,81136c58 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
81136c28:	e0bffd17 	ldw	r2,-12(fp)
81136c2c:	10c00217 	ldw	r3,8(r2)
81136c30:	e0bffd17 	ldw	r2,-12(fp)
81136c34:	10800317 	ldw	r2,12(r2)
81136c38:	1085883a 	add	r2,r2,r2
81136c3c:	1085883a 	add	r2,r2,r2
81136c40:	1887883a 	add	r3,r3,r2
81136c44:	e0bffd17 	ldw	r2,-12(fp)
81136c48:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81136c4c:	e0ffff17 	ldw	r3,-4(fp)
81136c50:	e0bffd17 	ldw	r2,-12(fp)
81136c54:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81136c58:	e0bffc03 	ldbu	r2,-16(fp)
81136c5c:	10800044 	addi	r2,r2,1
81136c60:	e0bffc05 	stb	r2,-16(fp)
81136c64:	e0bffc03 	ldbu	r2,-16(fp)
81136c68:	10800af0 	cmpltui	r2,r2,43
81136c6c:	103fd91e 	bne	r2,zero,81136bd4 <__reset+0xfb116bd4>
#endif
                }
            }
        }
    }
}
81136c70:	0001883a 	nop
81136c74:	e037883a 	mov	sp,fp
81136c78:	dfc00117 	ldw	ra,4(sp)
81136c7c:	df000017 	ldw	fp,0(sp)
81136c80:	dec00204 	addi	sp,sp,8
81136c84:	f800283a 	ret

81136c88 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81136c88:	defff204 	addi	sp,sp,-56
81136c8c:	de00012e 	bgeu	sp,et,81136c94 <OS_TCBInit+0xc>
81136c90:	003b68fa 	trap	3
81136c94:	dfc00d15 	stw	ra,52(sp)
81136c98:	df000c15 	stw	fp,48(sp)
81136c9c:	df000c04 	addi	fp,sp,48
81136ca0:	e17ffc15 	stw	r5,-16(fp)
81136ca4:	e1bffd15 	stw	r6,-12(fp)
81136ca8:	3807883a 	mov	r3,r7
81136cac:	e0800417 	ldw	r2,16(fp)
81136cb0:	e13ffb05 	stb	r4,-20(fp)
81136cb4:	e0fffe0d 	sth	r3,-8(fp)
81136cb8:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81136cbc:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136cc0:	0005303a 	rdctl	r2,status
81136cc4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136cc8:	e0fffa17 	ldw	r3,-24(fp)
81136ccc:	00bfff84 	movi	r2,-2
81136cd0:	1884703a 	and	r2,r3,r2
81136cd4:	1001703a 	wrctl	status,r2
  
  return context;
81136cd8:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
81136cdc:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
81136ce0:	d0a09817 	ldw	r2,-32160(gp)
81136ce4:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
81136ce8:	e0bff617 	ldw	r2,-40(fp)
81136cec:	10009326 	beq	r2,zero,81136f3c <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
81136cf0:	e0bff617 	ldw	r2,-40(fp)
81136cf4:	10800517 	ldw	r2,20(r2)
81136cf8:	d0a09815 	stw	r2,-32160(gp)
81136cfc:	e0bff417 	ldw	r2,-48(fp)
81136d00:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136d04:	e0bff817 	ldw	r2,-32(fp)
81136d08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81136d0c:	e0bff617 	ldw	r2,-40(fp)
81136d10:	e0fffc17 	ldw	r3,-16(fp)
81136d14:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81136d18:	e0bff617 	ldw	r2,-40(fp)
81136d1c:	e0fffb03 	ldbu	r3,-20(fp)
81136d20:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
81136d24:	e0bff617 	ldw	r2,-40(fp)
81136d28:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81136d2c:	e0bff617 	ldw	r2,-40(fp)
81136d30:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
81136d34:	e0bff617 	ldw	r2,-40(fp)
81136d38:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81136d3c:	e0bff617 	ldw	r2,-40(fp)
81136d40:	e0c00317 	ldw	r3,12(fp)
81136d44:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81136d48:	e0bff617 	ldw	r2,-40(fp)
81136d4c:	e0c00217 	ldw	r3,8(fp)
81136d50:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
81136d54:	e0bff617 	ldw	r2,-40(fp)
81136d58:	e0fffd17 	ldw	r3,-12(fp)
81136d5c:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81136d60:	e0bff617 	ldw	r2,-40(fp)
81136d64:	e0ffff0b 	ldhu	r3,-4(fp)
81136d68:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81136d6c:	e0bff617 	ldw	r2,-40(fp)
81136d70:	e0fffe0b 	ldhu	r3,-8(fp)
81136d74:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
81136d78:	e0bff617 	ldw	r2,-40(fp)
81136d7c:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81136d80:	e0bffb03 	ldbu	r2,-20(fp)
81136d84:	1004d0fa 	srli	r2,r2,3
81136d88:	1007883a 	mov	r3,r2
81136d8c:	e0bff617 	ldw	r2,-40(fp)
81136d90:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
81136d94:	e0bffb03 	ldbu	r2,-20(fp)
81136d98:	108001cc 	andi	r2,r2,7
81136d9c:	1007883a 	mov	r3,r2
81136da0:	e0bff617 	ldw	r2,-40(fp)
81136da4:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
81136da8:	e0bff617 	ldw	r2,-40(fp)
81136dac:	10800d03 	ldbu	r2,52(r2)
81136db0:	10803fcc 	andi	r2,r2,255
81136db4:	00c00044 	movi	r3,1
81136db8:	1884983a 	sll	r2,r3,r2
81136dbc:	1007883a 	mov	r3,r2
81136dc0:	e0bff617 	ldw	r2,-40(fp)
81136dc4:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
81136dc8:	e0bff617 	ldw	r2,-40(fp)
81136dcc:	10800cc3 	ldbu	r2,51(r2)
81136dd0:	10803fcc 	andi	r2,r2,255
81136dd4:	00c00044 	movi	r3,1
81136dd8:	1884983a 	sll	r2,r3,r2
81136ddc:	1007883a 	mov	r3,r2
81136de0:	e0bff617 	ldw	r2,-40(fp)
81136de4:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
81136de8:	e0bff617 	ldw	r2,-40(fp)
81136dec:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
81136df0:	e0bff617 	ldw	r2,-40(fp)
81136df4:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81136df8:	e0bff617 	ldw	r2,-40(fp)
81136dfc:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81136e00:	e0bff617 	ldw	r2,-40(fp)
81136e04:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81136e08:	e0bff617 	ldw	r2,-40(fp)
81136e0c:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81136e10:	e0bff617 	ldw	r2,-40(fp)
81136e14:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81136e18:	e0bff617 	ldw	r2,-40(fp)
81136e1c:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81136e20:	e0bff617 	ldw	r2,-40(fp)
81136e24:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81136e28:	e0bff617 	ldw	r2,-40(fp)
81136e2c:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81136e30:	e0bff617 	ldw	r2,-40(fp)
81136e34:	00c00fc4 	movi	r3,63
81136e38:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81136e3c:	e0bff617 	ldw	r2,-40(fp)
81136e40:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
81136e44:	e13ff617 	ldw	r4,-40(fp)
81136e48:	1147c2c0 	call	81147c2c <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81136e4c:	e13ff617 	ldw	r4,-40(fp)
81136e50:	1147ab40 	call	81147ab4 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136e54:	0005303a 	rdctl	r2,status
81136e58:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136e5c:	e0fff517 	ldw	r3,-44(fp)
81136e60:	00bfff84 	movi	r2,-2
81136e64:	1884703a 	and	r2,r3,r2
81136e68:	1001703a 	wrctl	status,r2
  
  return context;
81136e6c:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81136e70:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
81136e74:	e0fffb03 	ldbu	r3,-20(fp)
81136e78:	00a045f4 	movhi	r2,33047
81136e7c:	10a46104 	addi	r2,r2,-28284
81136e80:	18c7883a 	add	r3,r3,r3
81136e84:	18c7883a 	add	r3,r3,r3
81136e88:	10c5883a 	add	r2,r2,r3
81136e8c:	e0fff617 	ldw	r3,-40(fp)
81136e90:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
81136e94:	d0e09317 	ldw	r3,-32180(gp)
81136e98:	e0bff617 	ldw	r2,-40(fp)
81136e9c:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
81136ea0:	e0bff617 	ldw	r2,-40(fp)
81136ea4:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
81136ea8:	d0a09317 	ldw	r2,-32180(gp)
81136eac:	10000326 	beq	r2,zero,81136ebc <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
81136eb0:	d0a09317 	ldw	r2,-32180(gp)
81136eb4:	e0fff617 	ldw	r3,-40(fp)
81136eb8:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
81136ebc:	e0bff617 	ldw	r2,-40(fp)
81136ec0:	d0a09315 	stw	r2,-32180(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
81136ec4:	e0bff617 	ldw	r2,-40(fp)
81136ec8:	10c00d83 	ldbu	r3,54(r2)
81136ecc:	d0a09d03 	ldbu	r2,-32140(gp)
81136ed0:	1884b03a 	or	r2,r3,r2
81136ed4:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81136ed8:	e0bff617 	ldw	r2,-40(fp)
81136edc:	10800d03 	ldbu	r2,52(r2)
81136ee0:	10c03fcc 	andi	r3,r2,255
81136ee4:	e0bff617 	ldw	r2,-40(fp)
81136ee8:	10800d03 	ldbu	r2,52(r2)
81136eec:	11003fcc 	andi	r4,r2,255
81136ef0:	d0a09d44 	addi	r2,gp,-32139
81136ef4:	2085883a 	add	r2,r4,r2
81136ef8:	11000003 	ldbu	r4,0(r2)
81136efc:	e0bff617 	ldw	r2,-40(fp)
81136f00:	10800d43 	ldbu	r2,53(r2)
81136f04:	2084b03a 	or	r2,r4,r2
81136f08:	1009883a 	mov	r4,r2
81136f0c:	d0a09d44 	addi	r2,gp,-32139
81136f10:	1885883a 	add	r2,r3,r2
81136f14:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
81136f18:	d0a09943 	ldbu	r2,-32155(gp)
81136f1c:	10800044 	addi	r2,r2,1
81136f20:	d0a09945 	stb	r2,-32155(gp)
81136f24:	e0bff417 	ldw	r2,-48(fp)
81136f28:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136f2c:	e0bff717 	ldw	r2,-36(fp)
81136f30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81136f34:	0005883a 	mov	r2,zero
81136f38:	00000506 	br	81136f50 <OS_TCBInit+0x2c8>
81136f3c:	e0bff417 	ldw	r2,-48(fp)
81136f40:	e0bff915 	stw	r2,-28(fp)
81136f44:	e0bff917 	ldw	r2,-28(fp)
81136f48:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81136f4c:	00801084 	movi	r2,66
}
81136f50:	e037883a 	mov	sp,fp
81136f54:	dfc00117 	ldw	ra,4(sp)
81136f58:	df000017 	ldw	fp,0(sp)
81136f5c:	dec00204 	addi	sp,sp,8
81136f60:	f800283a 	ret

81136f64 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
81136f64:	defffe04 	addi	sp,sp,-8
81136f68:	de00012e 	bgeu	sp,et,81136f70 <OSDebugInit+0xc>
81136f6c:	003b68fa 	trap	3
81136f70:	df000115 	stw	fp,4(sp)
81136f74:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
81136f78:	d0a01804 	addi	r2,gp,-32672
81136f7c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81136f80:	d0a01904 	addi	r2,gp,-32668
81136f84:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
81136f88:	d0a01a84 	addi	r2,gp,-32662
81136f8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81136f90:	d0a01b04 	addi	r2,gp,-32660
81136f94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
81136f98:	d0a01a04 	addi	r2,gp,-32664
81136f9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
81136fa0:	d0a01b84 	addi	r2,gp,-32658
81136fa4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
81136fa8:	d0a01c04 	addi	r2,gp,-32656
81136fac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
81136fb0:	d0a01c84 	addi	r2,gp,-32654
81136fb4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
81136fb8:	d0a01d04 	addi	r2,gp,-32652
81136fbc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
81136fc0:	d0a01d84 	addi	r2,gp,-32650
81136fc4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
81136fc8:	d0a01e04 	addi	r2,gp,-32648
81136fcc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
81136fd0:	d0a01e84 	addi	r2,gp,-32646
81136fd4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
81136fd8:	d0a01f04 	addi	r2,gp,-32644
81136fdc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
81136fe0:	d0a01f84 	addi	r2,gp,-32642
81136fe4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
81136fe8:	d0a02004 	addi	r2,gp,-32640
81136fec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
81136ff0:	d0a02084 	addi	r2,gp,-32638
81136ff4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81136ff8:	d0a02104 	addi	r2,gp,-32636
81136ffc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81137000:	d0a02184 	addi	r2,gp,-32634
81137004:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81137008:	d0a02204 	addi	r2,gp,-32632
8113700c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81137010:	d0a02284 	addi	r2,gp,-32630
81137014:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
81137018:	d0a02304 	addi	r2,gp,-32628
8113701c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81137020:	d0a02384 	addi	r2,gp,-32626
81137024:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
81137028:	d0a02404 	addi	r2,gp,-32624
8113702c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81137030:	d0a02484 	addi	r2,gp,-32622
81137034:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
81137038:	d0a02504 	addi	r2,gp,-32620
8113703c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81137040:	d0a02584 	addi	r2,gp,-32618
81137044:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
81137048:	d0a02604 	addi	r2,gp,-32616
8113704c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81137050:	d0a02684 	addi	r2,gp,-32614
81137054:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
81137058:	d0a02704 	addi	r2,gp,-32612
8113705c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81137060:	d0a02784 	addi	r2,gp,-32610
81137064:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
81137068:	d0a02804 	addi	r2,gp,-32608
8113706c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81137070:	d0a02884 	addi	r2,gp,-32606
81137074:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
81137078:	d0a02904 	addi	r2,gp,-32604
8113707c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81137080:	d0a02984 	addi	r2,gp,-32602
81137084:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
81137088:	d0a02a04 	addi	r2,gp,-32600
8113708c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81137090:	d0a02a84 	addi	r2,gp,-32598
81137094:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
81137098:	d0a02b04 	addi	r2,gp,-32596
8113709c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
811370a0:	d0a02b84 	addi	r2,gp,-32594
811370a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
811370a8:	d0a02c04 	addi	r2,gp,-32592
811370ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
811370b0:	d0a02c84 	addi	r2,gp,-32590
811370b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
811370b8:	d0a02d04 	addi	r2,gp,-32588
811370bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
811370c0:	d0a02d84 	addi	r2,gp,-32586
811370c4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
811370c8:	d0a02e04 	addi	r2,gp,-32584
811370cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
811370d0:	d0a02e84 	addi	r2,gp,-32582
811370d4:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
811370d8:	00a045b4 	movhi	r2,33046
811370dc:	108e7f04 	addi	r2,r2,14844
811370e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
811370e4:	00a045b4 	movhi	r2,33046
811370e8:	108c6b04 	addi	r2,r2,12716
811370ec:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
811370f0:	d0a02f84 	addi	r2,gp,-32578
811370f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
811370f8:	d0a03004 	addi	r2,gp,-32576
811370fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81137100:	d0a03084 	addi	r2,gp,-32574
81137104:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81137108:	d0a03104 	addi	r2,gp,-32572
8113710c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81137110:	d0a03184 	addi	r2,gp,-32570
81137114:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
81137118:	d0a03204 	addi	r2,gp,-32568
8113711c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81137120:	d0a03284 	addi	r2,gp,-32566
81137124:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
81137128:	d0a03304 	addi	r2,gp,-32564
8113712c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81137130:	d0a03384 	addi	r2,gp,-32562
81137134:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
81137138:	d0a02f04 	addi	r2,gp,-32580
8113713c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81137140:	d0a03404 	addi	r2,gp,-32560
81137144:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
81137148:	0001883a 	nop
8113714c:	e037883a 	mov	sp,fp
81137150:	df000017 	ldw	fp,0(sp)
81137154:	dec00104 	addi	sp,sp,4
81137158:	f800283a 	ret

8113715c <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8113715c:	defff204 	addi	sp,sp,-56
81137160:	de00012e 	bgeu	sp,et,81137168 <OSFlagAccept+0xc>
81137164:	003b68fa 	trap	3
81137168:	df000d15 	stw	fp,52(sp)
8113716c:	df000d04 	addi	fp,sp,52
81137170:	e13ffc15 	stw	r4,-16(fp)
81137174:	2807883a 	mov	r3,r5
81137178:	3005883a 	mov	r2,r6
8113717c:	e1ffff15 	stw	r7,-4(fp)
81137180:	e0fffd0d 	sth	r3,-12(fp)
81137184:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81137188:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113718c:	e0bfff17 	ldw	r2,-4(fp)
81137190:	1000021e 	bne	r2,zero,8113719c <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
81137194:	0005883a 	mov	r2,zero
81137198:	0000b006 	br	8113745c <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113719c:	e0bffc17 	ldw	r2,-16(fp)
811371a0:	1000051e 	bne	r2,zero,811371b8 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811371a4:	e0bfff17 	ldw	r2,-4(fp)
811371a8:	00c01b84 	movi	r3,110
811371ac:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811371b0:	0005883a 	mov	r2,zero
811371b4:	0000a906 	br	8113745c <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
811371b8:	e0bffc17 	ldw	r2,-16(fp)
811371bc:	10800003 	ldbu	r2,0(r2)
811371c0:	10803fcc 	andi	r2,r2,255
811371c4:	10800160 	cmpeqi	r2,r2,5
811371c8:	1000051e 	bne	r2,zero,811371e0 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
811371cc:	e0bfff17 	ldw	r2,-4(fp)
811371d0:	00c00044 	movi	r3,1
811371d4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811371d8:	0005883a 	mov	r2,zero
811371dc:	00009f06 	br	8113745c <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
811371e0:	e0fffe03 	ldbu	r3,-8(fp)
811371e4:	00bfe004 	movi	r2,-128
811371e8:	1884703a 	and	r2,r3,r2
811371ec:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
811371f0:	e0bff503 	ldbu	r2,-44(fp)
811371f4:	10000626 	beq	r2,zero,81137210 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
811371f8:	e0bffe03 	ldbu	r2,-8(fp)
811371fc:	10801fcc 	andi	r2,r2,127
81137200:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81137204:	00800044 	movi	r2,1
81137208:	e0bff385 	stb	r2,-50(fp)
8113720c:	00000106 	br	81137214 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81137210:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
81137214:	e0bfff17 	ldw	r2,-4(fp)
81137218:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113721c:	0005303a 	rdctl	r2,status
81137220:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137224:	e0fffb17 	ldw	r3,-20(fp)
81137228:	00bfff84 	movi	r2,-2
8113722c:	1884703a 	and	r2,r3,r2
81137230:	1001703a 	wrctl	status,r2
  
  return context;
81137234:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
81137238:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8113723c:	e0bffe03 	ldbu	r2,-8(fp)
81137240:	10c00060 	cmpeqi	r3,r2,1
81137244:	18005f1e 	bne	r3,zero,811373c4 <OSFlagAccept+0x268>
81137248:	10c00088 	cmpgei	r3,r2,2
8113724c:	1800021e 	bne	r3,zero,81137258 <OSFlagAccept+0xfc>
81137250:	10003f26 	beq	r2,zero,81137350 <OSFlagAccept+0x1f4>
81137254:	00007706 	br	81137434 <OSFlagAccept+0x2d8>
81137258:	10c000a0 	cmpeqi	r3,r2,2
8113725c:	1800031e 	bne	r3,zero,8113726c <OSFlagAccept+0x110>
81137260:	108000e0 	cmpeqi	r2,r2,3
81137264:	10001e1e 	bne	r2,zero,811372e0 <OSFlagAccept+0x184>
81137268:	00007206 	br	81137434 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113726c:	e0bffc17 	ldw	r2,-16(fp)
81137270:	10c0020b 	ldhu	r3,8(r2)
81137274:	e0bffd0b 	ldhu	r2,-12(fp)
81137278:	1884703a 	and	r2,r3,r2
8113727c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81137280:	e0fff30b 	ldhu	r3,-52(fp)
81137284:	e0bffd0b 	ldhu	r2,-12(fp)
81137288:	18800d1e 	bne	r3,r2,811372c0 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113728c:	e0bff383 	ldbu	r2,-50(fp)
81137290:	10800058 	cmpnei	r2,r2,1
81137294:	10000d1e 	bne	r2,zero,811372cc <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81137298:	e0bffc17 	ldw	r2,-16(fp)
8113729c:	1080020b 	ldhu	r2,8(r2)
811372a0:	1007883a 	mov	r3,r2
811372a4:	e0bff30b 	ldhu	r2,-52(fp)
811372a8:	0084303a 	nor	r2,zero,r2
811372ac:	1884703a 	and	r2,r3,r2
811372b0:	1007883a 	mov	r3,r2
811372b4:	e0bffc17 	ldw	r2,-16(fp)
811372b8:	10c0020d 	sth	r3,8(r2)
811372bc:	00000306 	br	811372cc <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811372c0:	e0bfff17 	ldw	r2,-4(fp)
811372c4:	00c01c04 	movi	r3,112
811372c8:	10c00005 	stb	r3,0(r2)
811372cc:	e0bff417 	ldw	r2,-48(fp)
811372d0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811372d4:	e0bff617 	ldw	r2,-40(fp)
811372d8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811372dc:	00005e06 	br	81137458 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
811372e0:	e0bffc17 	ldw	r2,-16(fp)
811372e4:	10c0020b 	ldhu	r3,8(r2)
811372e8:	e0bffd0b 	ldhu	r2,-12(fp)
811372ec:	1884703a 	and	r2,r3,r2
811372f0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
811372f4:	e0bff30b 	ldhu	r2,-52(fp)
811372f8:	10000d26 	beq	r2,zero,81137330 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811372fc:	e0bff383 	ldbu	r2,-50(fp)
81137300:	10800058 	cmpnei	r2,r2,1
81137304:	10000d1e 	bne	r2,zero,8113733c <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81137308:	e0bffc17 	ldw	r2,-16(fp)
8113730c:	1080020b 	ldhu	r2,8(r2)
81137310:	1007883a 	mov	r3,r2
81137314:	e0bff30b 	ldhu	r2,-52(fp)
81137318:	0084303a 	nor	r2,zero,r2
8113731c:	1884703a 	and	r2,r3,r2
81137320:	1007883a 	mov	r3,r2
81137324:	e0bffc17 	ldw	r2,-16(fp)
81137328:	10c0020d 	sth	r3,8(r2)
8113732c:	00000306 	br	8113733c <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81137330:	e0bfff17 	ldw	r2,-4(fp)
81137334:	00c01c04 	movi	r3,112
81137338:	10c00005 	stb	r3,0(r2)
8113733c:	e0bff417 	ldw	r2,-48(fp)
81137340:	e0bff715 	stw	r2,-36(fp)
81137344:	e0bff717 	ldw	r2,-36(fp)
81137348:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113734c:	00004206 	br	81137458 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81137350:	e0bffc17 	ldw	r2,-16(fp)
81137354:	1080020b 	ldhu	r2,8(r2)
81137358:	0084303a 	nor	r2,zero,r2
8113735c:	1007883a 	mov	r3,r2
81137360:	e0bffd0b 	ldhu	r2,-12(fp)
81137364:	1884703a 	and	r2,r3,r2
81137368:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113736c:	e0fff30b 	ldhu	r3,-52(fp)
81137370:	e0bffd0b 	ldhu	r2,-12(fp)
81137374:	18800b1e 	bne	r3,r2,811373a4 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81137378:	e0bff383 	ldbu	r2,-50(fp)
8113737c:	10800058 	cmpnei	r2,r2,1
81137380:	10000b1e 	bne	r2,zero,811373b0 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81137384:	e0bffc17 	ldw	r2,-16(fp)
81137388:	10c0020b 	ldhu	r3,8(r2)
8113738c:	e0bff30b 	ldhu	r2,-52(fp)
81137390:	1884b03a 	or	r2,r3,r2
81137394:	1007883a 	mov	r3,r2
81137398:	e0bffc17 	ldw	r2,-16(fp)
8113739c:	10c0020d 	sth	r3,8(r2)
811373a0:	00000306 	br	811373b0 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811373a4:	e0bfff17 	ldw	r2,-4(fp)
811373a8:	00c01c04 	movi	r3,112
811373ac:	10c00005 	stb	r3,0(r2)
811373b0:	e0bff417 	ldw	r2,-48(fp)
811373b4:	e0bff815 	stw	r2,-32(fp)
811373b8:	e0bff817 	ldw	r2,-32(fp)
811373bc:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811373c0:	00002506 	br	81137458 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811373c4:	e0bffc17 	ldw	r2,-16(fp)
811373c8:	1080020b 	ldhu	r2,8(r2)
811373cc:	0084303a 	nor	r2,zero,r2
811373d0:	1007883a 	mov	r3,r2
811373d4:	e0bffd0b 	ldhu	r2,-12(fp)
811373d8:	1884703a 	and	r2,r3,r2
811373dc:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
811373e0:	e0bff30b 	ldhu	r2,-52(fp)
811373e4:	10000b26 	beq	r2,zero,81137414 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811373e8:	e0bff383 	ldbu	r2,-50(fp)
811373ec:	10800058 	cmpnei	r2,r2,1
811373f0:	10000b1e 	bne	r2,zero,81137420 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
811373f4:	e0bffc17 	ldw	r2,-16(fp)
811373f8:	10c0020b 	ldhu	r3,8(r2)
811373fc:	e0bff30b 	ldhu	r2,-52(fp)
81137400:	1884b03a 	or	r2,r3,r2
81137404:	1007883a 	mov	r3,r2
81137408:	e0bffc17 	ldw	r2,-16(fp)
8113740c:	10c0020d 	sth	r3,8(r2)
81137410:	00000306 	br	81137420 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81137414:	e0bfff17 	ldw	r2,-4(fp)
81137418:	00c01c04 	movi	r3,112
8113741c:	10c00005 	stb	r3,0(r2)
81137420:	e0bff417 	ldw	r2,-48(fp)
81137424:	e0bff915 	stw	r2,-28(fp)
81137428:	e0bff917 	ldw	r2,-28(fp)
8113742c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81137430:	00000906 	br	81137458 <OSFlagAccept+0x2fc>
81137434:	e0bff417 	ldw	r2,-48(fp)
81137438:	e0bffa15 	stw	r2,-24(fp)
8113743c:	e0bffa17 	ldw	r2,-24(fp)
81137440:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81137444:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
81137448:	e0bfff17 	ldw	r2,-4(fp)
8113744c:	00c01bc4 	movi	r3,111
81137450:	10c00005 	stb	r3,0(r2)
             break;
81137454:	0001883a 	nop
    }
    return (flags_rdy);
81137458:	e0bff30b 	ldhu	r2,-52(fp)
}
8113745c:	e037883a 	mov	sp,fp
81137460:	df000017 	ldw	fp,0(sp)
81137464:	dec00104 	addi	sp,sp,4
81137468:	f800283a 	ret

8113746c <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8113746c:	defff804 	addi	sp,sp,-32
81137470:	de00012e 	bgeu	sp,et,81137478 <OSFlagCreate+0xc>
81137474:	003b68fa 	trap	3
81137478:	df000715 	stw	fp,28(sp)
8113747c:	df000704 	addi	fp,sp,28
81137480:	2005883a 	mov	r2,r4
81137484:	e17fff15 	stw	r5,-4(fp)
81137488:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8113748c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
81137490:	e0bfff17 	ldw	r2,-4(fp)
81137494:	1000021e 	bne	r2,zero,811374a0 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
81137498:	0005883a 	mov	r2,zero
8113749c:	00003306 	br	8113756c <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
811374a0:	d0a0a003 	ldbu	r2,-32128(gp)
811374a4:	10803fcc 	andi	r2,r2,255
811374a8:	10000526 	beq	r2,zero,811374c0 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
811374ac:	e0bfff17 	ldw	r2,-4(fp)
811374b0:	00c00404 	movi	r3,16
811374b4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
811374b8:	0005883a 	mov	r2,zero
811374bc:	00002b06 	br	8113756c <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811374c0:	0005303a 	rdctl	r2,status
811374c4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811374c8:	e0fffd17 	ldw	r3,-12(fp)
811374cc:	00bfff84 	movi	r2,-2
811374d0:	1884703a 	and	r2,r3,r2
811374d4:	1001703a 	wrctl	status,r2
  
  return context;
811374d8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811374dc:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
811374e0:	d0a0a517 	ldw	r2,-32108(gp)
811374e4:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
811374e8:	e0bffb17 	ldw	r2,-20(fp)
811374ec:	10001726 	beq	r2,zero,8113754c <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
811374f0:	d0a0a517 	ldw	r2,-32108(gp)
811374f4:	10800117 	ldw	r2,4(r2)
811374f8:	d0a0a515 	stw	r2,-32108(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
811374fc:	e0bffb17 	ldw	r2,-20(fp)
81137500:	00c00144 	movi	r3,5
81137504:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81137508:	e0bffb17 	ldw	r2,-20(fp)
8113750c:	e0fffe0b 	ldhu	r3,-8(fp)
81137510:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
81137514:	e0bffb17 	ldw	r2,-20(fp)
81137518:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8113751c:	e0bffb17 	ldw	r2,-20(fp)
81137520:	00c00fc4 	movi	r3,63
81137524:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81137528:	e0bffb17 	ldw	r2,-20(fp)
8113752c:	100002c5 	stb	zero,11(r2)
81137530:	e0bff917 	ldw	r2,-28(fp)
81137534:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137538:	e0bffa17 	ldw	r2,-24(fp)
8113753c:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
81137540:	e0bfff17 	ldw	r2,-4(fp)
81137544:	10000005 	stb	zero,0(r2)
81137548:	00000706 	br	81137568 <OSFlagCreate+0xfc>
8113754c:	e0bff917 	ldw	r2,-28(fp)
81137550:	e0bffc15 	stw	r2,-16(fp)
81137554:	e0bffc17 	ldw	r2,-16(fp)
81137558:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8113755c:	e0bfff17 	ldw	r2,-4(fp)
81137560:	00c01c84 	movi	r3,114
81137564:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
81137568:	e0bffb17 	ldw	r2,-20(fp)
}
8113756c:	e037883a 	mov	sp,fp
81137570:	df000017 	ldw	fp,0(sp)
81137574:	dec00104 	addi	sp,sp,4
81137578:	f800283a 	ret

8113757c <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8113757c:	defff204 	addi	sp,sp,-56
81137580:	de00012e 	bgeu	sp,et,81137588 <OSFlagDel+0xc>
81137584:	003b68fa 	trap	3
81137588:	dfc00d15 	stw	ra,52(sp)
8113758c:	df000c15 	stw	fp,48(sp)
81137590:	df000c04 	addi	fp,sp,48
81137594:	e13ffd15 	stw	r4,-12(fp)
81137598:	2805883a 	mov	r2,r5
8113759c:	e1bfff15 	stw	r6,-4(fp)
811375a0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
811375a4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811375a8:	e0bfff17 	ldw	r2,-4(fp)
811375ac:	1000021e 	bne	r2,zero,811375b8 <OSFlagDel+0x3c>
        return (pgrp);
811375b0:	e0bffd17 	ldw	r2,-12(fp)
811375b4:	00008006 	br	811377b8 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811375b8:	e0bffd17 	ldw	r2,-12(fp)
811375bc:	1000051e 	bne	r2,zero,811375d4 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811375c0:	e0bfff17 	ldw	r2,-4(fp)
811375c4:	00c01b84 	movi	r3,110
811375c8:	10c00005 	stb	r3,0(r2)
        return (pgrp);
811375cc:	e0bffd17 	ldw	r2,-12(fp)
811375d0:	00007906 	br	811377b8 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811375d4:	d0a0a003 	ldbu	r2,-32128(gp)
811375d8:	10803fcc 	andi	r2,r2,255
811375dc:	10000526 	beq	r2,zero,811375f4 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
811375e0:	e0bfff17 	ldw	r2,-4(fp)
811375e4:	00c003c4 	movi	r3,15
811375e8:	10c00005 	stb	r3,0(r2)
        return (pgrp);
811375ec:	e0bffd17 	ldw	r2,-12(fp)
811375f0:	00007106 	br	811377b8 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
811375f4:	e0bffd17 	ldw	r2,-12(fp)
811375f8:	10800003 	ldbu	r2,0(r2)
811375fc:	10803fcc 	andi	r2,r2,255
81137600:	10800160 	cmpeqi	r2,r2,5
81137604:	1000051e 	bne	r2,zero,8113761c <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81137608:	e0bfff17 	ldw	r2,-4(fp)
8113760c:	00c00044 	movi	r3,1
81137610:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81137614:	e0bffd17 	ldw	r2,-12(fp)
81137618:	00006706 	br	811377b8 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113761c:	0005303a 	rdctl	r2,status
81137620:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137624:	e0fffc17 	ldw	r3,-16(fp)
81137628:	00bfff84 	movi	r2,-2
8113762c:	1884703a 	and	r2,r3,r2
81137630:	1001703a 	wrctl	status,r2
  
  return context;
81137634:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137638:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8113763c:	e0bffd17 	ldw	r2,-12(fp)
81137640:	10800117 	ldw	r2,4(r2)
81137644:	10000326 	beq	r2,zero,81137654 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81137648:	00800044 	movi	r2,1
8113764c:	e0bff405 	stb	r2,-48(fp)
81137650:	00000106 	br	81137658 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81137654:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81137658:	e0bffe03 	ldbu	r2,-8(fp)
8113765c:	10000326 	beq	r2,zero,8113766c <OSFlagDel+0xf0>
81137660:	10800060 	cmpeqi	r2,r2,1
81137664:	1000231e 	bne	r2,zero,811376f4 <OSFlagDel+0x178>
81137668:	00004806 	br	8113778c <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8113766c:	e0bff403 	ldbu	r2,-48(fp)
81137670:	1000161e 	bne	r2,zero,811376cc <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
81137674:	e0bffd17 	ldw	r2,-12(fp)
81137678:	00c00fc4 	movi	r3,63
8113767c:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81137680:	e0bffd17 	ldw	r2,-12(fp)
81137684:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81137688:	e0bffd17 	ldw	r2,-12(fp)
8113768c:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
81137690:	d0e0a517 	ldw	r3,-32108(gp)
81137694:	e0bffd17 	ldw	r2,-12(fp)
81137698:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113769c:	e0bffd17 	ldw	r2,-12(fp)
811376a0:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
811376a4:	e0bffd17 	ldw	r2,-12(fp)
811376a8:	d0a0a515 	stw	r2,-32108(gp)
811376ac:	e0bff717 	ldw	r2,-36(fp)
811376b0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811376b4:	e0bff817 	ldw	r2,-32(fp)
811376b8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
811376bc:	e0bfff17 	ldw	r2,-4(fp)
811376c0:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
811376c4:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
811376c8:	00003a06 	br	811377b4 <OSFlagDel+0x238>
811376cc:	e0bff717 	ldw	r2,-36(fp)
811376d0:	e0bff915 	stw	r2,-28(fp)
811376d4:	e0bff917 	ldw	r2,-28(fp)
811376d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
811376dc:	e0bfff17 	ldw	r2,-4(fp)
811376e0:	00c01244 	movi	r3,73
811376e4:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
811376e8:	e0bffd17 	ldw	r2,-12(fp)
811376ec:	e0bff615 	stw	r2,-40(fp)
             }
             break;
811376f0:	00003006 	br	811377b4 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811376f4:	e0bffd17 	ldw	r2,-12(fp)
811376f8:	10800117 	ldw	r2,4(r2)
811376fc:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81137700:	00000606 	br	8113771c <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
81137704:	000b883a 	mov	r5,zero
81137708:	e13ff517 	ldw	r4,-44(fp)
8113770c:	11387300 	call	81138730 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81137710:	e0bff517 	ldw	r2,-44(fp)
81137714:	10800017 	ldw	r2,0(r2)
81137718:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113771c:	e0bff517 	ldw	r2,-44(fp)
81137720:	103ff81e 	bne	r2,zero,81137704 <__reset+0xfb117704>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
81137724:	e0bffd17 	ldw	r2,-12(fp)
81137728:	00c00fc4 	movi	r3,63
8113772c:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81137730:	e0bffd17 	ldw	r2,-12(fp)
81137734:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81137738:	e0bffd17 	ldw	r2,-12(fp)
8113773c:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
81137740:	d0e0a517 	ldw	r3,-32108(gp)
81137744:	e0bffd17 	ldw	r2,-12(fp)
81137748:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113774c:	e0bffd17 	ldw	r2,-12(fp)
81137750:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
81137754:	e0bffd17 	ldw	r2,-12(fp)
81137758:	d0a0a515 	stw	r2,-32108(gp)
8113775c:	e0bff717 	ldw	r2,-36(fp)
81137760:	e0bffa15 	stw	r2,-24(fp)
81137764:	e0bffa17 	ldw	r2,-24(fp)
81137768:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113776c:	e0bff403 	ldbu	r2,-48(fp)
81137770:	10800058 	cmpnei	r2,r2,1
81137774:	1000011e 	bne	r2,zero,8113777c <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81137778:	11368400 	call	81136840 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8113777c:	e0bfff17 	ldw	r2,-4(fp)
81137780:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
81137784:	e03ff615 	stw	zero,-40(fp)
             break;
81137788:	00000a06 	br	811377b4 <OSFlagDel+0x238>
8113778c:	e0bff717 	ldw	r2,-36(fp)
81137790:	e0bffb15 	stw	r2,-20(fp)
81137794:	e0bffb17 	ldw	r2,-20(fp)
81137798:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8113779c:	e0bfff17 	ldw	r2,-4(fp)
811377a0:	00c001c4 	movi	r3,7
811377a4:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
811377a8:	e0bffd17 	ldw	r2,-12(fp)
811377ac:	e0bff615 	stw	r2,-40(fp)
             break;
811377b0:	0001883a 	nop
    }
    return (pgrp_return);
811377b4:	e0bff617 	ldw	r2,-40(fp)
}
811377b8:	e037883a 	mov	sp,fp
811377bc:	dfc00117 	ldw	ra,4(sp)
811377c0:	df000017 	ldw	fp,0(sp)
811377c4:	dec00204 	addi	sp,sp,8
811377c8:	f800283a 	ret

811377cc <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
811377cc:	defff604 	addi	sp,sp,-40
811377d0:	de00012e 	bgeu	sp,et,811377d8 <OSFlagNameGet+0xc>
811377d4:	003b68fa 	trap	3
811377d8:	dfc00915 	stw	ra,36(sp)
811377dc:	df000815 	stw	fp,32(sp)
811377e0:	df000804 	addi	fp,sp,32
811377e4:	e13ffd15 	stw	r4,-12(fp)
811377e8:	e17ffe15 	stw	r5,-8(fp)
811377ec:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811377f0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811377f4:	e0bfff17 	ldw	r2,-4(fp)
811377f8:	1000021e 	bne	r2,zero,81137804 <OSFlagNameGet+0x38>
        return (0);
811377fc:	0005883a 	mov	r2,zero
81137800:	00003906 	br	811378e8 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81137804:	e0bffd17 	ldw	r2,-12(fp)
81137808:	1000051e 	bne	r2,zero,81137820 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113780c:	e0bfff17 	ldw	r2,-4(fp)
81137810:	00c01b84 	movi	r3,110
81137814:	10c00005 	stb	r3,0(r2)
        return (0);
81137818:	0005883a 	mov	r2,zero
8113781c:	00003206 	br	811378e8 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81137820:	e0bffe17 	ldw	r2,-8(fp)
81137824:	1000051e 	bne	r2,zero,8113783c <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81137828:	e0bfff17 	ldw	r2,-4(fp)
8113782c:	00c00304 	movi	r3,12
81137830:	10c00005 	stb	r3,0(r2)
        return (0);
81137834:	0005883a 	mov	r2,zero
81137838:	00002b06 	br	811378e8 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113783c:	d0a0a003 	ldbu	r2,-32128(gp)
81137840:	10803fcc 	andi	r2,r2,255
81137844:	10000526 	beq	r2,zero,8113785c <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81137848:	e0bfff17 	ldw	r2,-4(fp)
8113784c:	00c00444 	movi	r3,17
81137850:	10c00005 	stb	r3,0(r2)
        return (0);
81137854:	0005883a 	mov	r2,zero
81137858:	00002306 	br	811378e8 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113785c:	0005303a 	rdctl	r2,status
81137860:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137864:	e0fffc17 	ldw	r3,-16(fp)
81137868:	00bfff84 	movi	r2,-2
8113786c:	1884703a 	and	r2,r3,r2
81137870:	1001703a 	wrctl	status,r2
  
  return context;
81137874:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137878:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113787c:	e0bffd17 	ldw	r2,-12(fp)
81137880:	10800003 	ldbu	r2,0(r2)
81137884:	10803fcc 	andi	r2,r2,255
81137888:	10800160 	cmpeqi	r2,r2,5
8113788c:	1000091e 	bne	r2,zero,811378b4 <OSFlagNameGet+0xe8>
81137890:	e0bff817 	ldw	r2,-32(fp)
81137894:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137898:	e0bff917 	ldw	r2,-28(fp)
8113789c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
811378a0:	e0bfff17 	ldw	r2,-4(fp)
811378a4:	00c00044 	movi	r3,1
811378a8:	10c00005 	stb	r3,0(r2)
        return (0);
811378ac:	0005883a 	mov	r2,zero
811378b0:	00000d06 	br	811378e8 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
811378b4:	e0bffd17 	ldw	r2,-12(fp)
811378b8:	10800284 	addi	r2,r2,10
811378bc:	100b883a 	mov	r5,r2
811378c0:	e13ffe17 	ldw	r4,-8(fp)
811378c4:	11369940 	call	81136994 <OS_StrCopy>
811378c8:	e0bffb05 	stb	r2,-20(fp)
811378cc:	e0bff817 	ldw	r2,-32(fp)
811378d0:	e0bffa15 	stw	r2,-24(fp)
811378d4:	e0bffa17 	ldw	r2,-24(fp)
811378d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811378dc:	e0bfff17 	ldw	r2,-4(fp)
811378e0:	10000005 	stb	zero,0(r2)
    return (len);
811378e4:	e0bffb03 	ldbu	r2,-20(fp)
}
811378e8:	e037883a 	mov	sp,fp
811378ec:	dfc00117 	ldw	ra,4(sp)
811378f0:	df000017 	ldw	fp,0(sp)
811378f4:	dec00204 	addi	sp,sp,8
811378f8:	f800283a 	ret

811378fc <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
811378fc:	defff504 	addi	sp,sp,-44
81137900:	de00012e 	bgeu	sp,et,81137908 <OSFlagNameSet+0xc>
81137904:	003b68fa 	trap	3
81137908:	dfc00a15 	stw	ra,40(sp)
8113790c:	df000915 	stw	fp,36(sp)
81137910:	df000904 	addi	fp,sp,36
81137914:	e13ffd15 	stw	r4,-12(fp)
81137918:	e17ffe15 	stw	r5,-8(fp)
8113791c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137920:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81137924:	e0bfff17 	ldw	r2,-4(fp)
81137928:	10004326 	beq	r2,zero,81137a38 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113792c:	e0bffd17 	ldw	r2,-12(fp)
81137930:	1000041e 	bne	r2,zero,81137944 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81137934:	e0bfff17 	ldw	r2,-4(fp)
81137938:	00c01b84 	movi	r3,110
8113793c:	10c00005 	stb	r3,0(r2)
        return;
81137940:	00003e06 	br	81137a3c <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81137944:	e0bffe17 	ldw	r2,-8(fp)
81137948:	1000041e 	bne	r2,zero,8113795c <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113794c:	e0bfff17 	ldw	r2,-4(fp)
81137950:	00c00304 	movi	r3,12
81137954:	10c00005 	stb	r3,0(r2)
        return;
81137958:	00003806 	br	81137a3c <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113795c:	d0a0a003 	ldbu	r2,-32128(gp)
81137960:	10803fcc 	andi	r2,r2,255
81137964:	10000426 	beq	r2,zero,81137978 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81137968:	e0bfff17 	ldw	r2,-4(fp)
8113796c:	00c00484 	movi	r3,18
81137970:	10c00005 	stb	r3,0(r2)
        return;
81137974:	00003106 	br	81137a3c <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137978:	0005303a 	rdctl	r2,status
8113797c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137980:	e0fffc17 	ldw	r3,-16(fp)
81137984:	00bfff84 	movi	r2,-2
81137988:	1884703a 	and	r2,r3,r2
8113798c:	1001703a 	wrctl	status,r2
  
  return context;
81137990:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137994:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81137998:	e0bffd17 	ldw	r2,-12(fp)
8113799c:	10800003 	ldbu	r2,0(r2)
811379a0:	10803fcc 	andi	r2,r2,255
811379a4:	10800160 	cmpeqi	r2,r2,5
811379a8:	1000081e 	bne	r2,zero,811379cc <OSFlagNameSet+0xd0>
811379ac:	e0bff717 	ldw	r2,-36(fp)
811379b0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811379b4:	e0bff817 	ldw	r2,-32(fp)
811379b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
811379bc:	e0bfff17 	ldw	r2,-4(fp)
811379c0:	00c00044 	movi	r3,1
811379c4:	10c00005 	stb	r3,0(r2)
        return;
811379c8:	00001c06 	br	81137a3c <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
811379cc:	e13ffe17 	ldw	r4,-8(fp)
811379d0:	1136a100 	call	81136a10 <OS_StrLen>
811379d4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
811379d8:	e0bffa03 	ldbu	r2,-24(fp)
811379dc:	10800830 	cmpltui	r2,r2,32
811379e0:	1000081e 	bne	r2,zero,81137a04 <OSFlagNameSet+0x108>
811379e4:	e0bff717 	ldw	r2,-36(fp)
811379e8:	e0bff915 	stw	r2,-28(fp)
811379ec:	e0bff917 	ldw	r2,-28(fp)
811379f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
811379f4:	e0bfff17 	ldw	r2,-4(fp)
811379f8:	00c01cc4 	movi	r3,115
811379fc:	10c00005 	stb	r3,0(r2)
        return;
81137a00:	00000e06 	br	81137a3c <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
81137a04:	e0bffd17 	ldw	r2,-12(fp)
81137a08:	10800284 	addi	r2,r2,10
81137a0c:	e17ffe17 	ldw	r5,-8(fp)
81137a10:	1009883a 	mov	r4,r2
81137a14:	11369940 	call	81136994 <OS_StrCopy>
81137a18:	e0bff717 	ldw	r2,-36(fp)
81137a1c:	e0bffb15 	stw	r2,-20(fp)
81137a20:	e0bffb17 	ldw	r2,-20(fp)
81137a24:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81137a28:	e0bfff17 	ldw	r2,-4(fp)
81137a2c:	10000005 	stb	zero,0(r2)
    return;
81137a30:	0001883a 	nop
81137a34:	00000106 	br	81137a3c <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81137a38:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
81137a3c:	e037883a 	mov	sp,fp
81137a40:	dfc00117 	ldw	ra,4(sp)
81137a44:	df000017 	ldw	fp,0(sp)
81137a48:	dec00204 	addi	sp,sp,8
81137a4c:	f800283a 	ret

81137a50 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
81137a50:	deffe104 	addi	sp,sp,-124
81137a54:	de00012e 	bgeu	sp,et,81137a5c <OSFlagPend+0xc>
81137a58:	003b68fa 	trap	3
81137a5c:	dfc01e15 	stw	ra,120(sp)
81137a60:	df001d15 	stw	fp,116(sp)
81137a64:	df001d04 	addi	fp,sp,116
81137a68:	e13ffc15 	stw	r4,-16(fp)
81137a6c:	2809883a 	mov	r4,r5
81137a70:	3007883a 	mov	r3,r6
81137a74:	3805883a 	mov	r2,r7
81137a78:	e13ffd0d 	sth	r4,-12(fp)
81137a7c:	e0fffe05 	stb	r3,-8(fp)
81137a80:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81137a84:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81137a88:	e0800217 	ldw	r2,8(fp)
81137a8c:	1000021e 	bne	r2,zero,81137a98 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
81137a90:	0005883a 	mov	r2,zero
81137a94:	00015906 	br	81137ffc <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81137a98:	e0bffc17 	ldw	r2,-16(fp)
81137a9c:	1000051e 	bne	r2,zero,81137ab4 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81137aa0:	e0800217 	ldw	r2,8(fp)
81137aa4:	00c01b84 	movi	r3,110
81137aa8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81137aac:	0005883a 	mov	r2,zero
81137ab0:	00015206 	br	81137ffc <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81137ab4:	d0a0a003 	ldbu	r2,-32128(gp)
81137ab8:	10803fcc 	andi	r2,r2,255
81137abc:	10000526 	beq	r2,zero,81137ad4 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81137ac0:	e0800217 	ldw	r2,8(fp)
81137ac4:	00c00084 	movi	r3,2
81137ac8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81137acc:	0005883a 	mov	r2,zero
81137ad0:	00014a06 	br	81137ffc <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81137ad4:	d0a08e03 	ldbu	r2,-32200(gp)
81137ad8:	10803fcc 	andi	r2,r2,255
81137adc:	10000526 	beq	r2,zero,81137af4 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81137ae0:	e0800217 	ldw	r2,8(fp)
81137ae4:	00c00344 	movi	r3,13
81137ae8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81137aec:	0005883a 	mov	r2,zero
81137af0:	00014206 	br	81137ffc <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81137af4:	e0bffc17 	ldw	r2,-16(fp)
81137af8:	10800003 	ldbu	r2,0(r2)
81137afc:	10803fcc 	andi	r2,r2,255
81137b00:	10800160 	cmpeqi	r2,r2,5
81137b04:	1000051e 	bne	r2,zero,81137b1c <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81137b08:	e0800217 	ldw	r2,8(fp)
81137b0c:	00c00044 	movi	r3,1
81137b10:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81137b14:	0005883a 	mov	r2,zero
81137b18:	00013806 	br	81137ffc <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81137b1c:	e0fffe03 	ldbu	r3,-8(fp)
81137b20:	00bfe004 	movi	r2,-128
81137b24:	1884703a 	and	r2,r3,r2
81137b28:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
81137b2c:	e0bfe603 	ldbu	r2,-104(fp)
81137b30:	10000626 	beq	r2,zero,81137b4c <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
81137b34:	e0bffe03 	ldbu	r2,-8(fp)
81137b38:	10801fcc 	andi	r2,r2,127
81137b3c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81137b40:	00800044 	movi	r2,1
81137b44:	e0bfe405 	stb	r2,-112(fp)
81137b48:	00000106 	br	81137b50 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
81137b4c:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137b50:	0005303a 	rdctl	r2,status
81137b54:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137b58:	e0fff617 	ldw	r3,-40(fp)
81137b5c:	00bfff84 	movi	r2,-2
81137b60:	1884703a 	and	r2,r3,r2
81137b64:	1001703a 	wrctl	status,r2
  
  return context;
81137b68:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81137b6c:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
81137b70:	e0bffe03 	ldbu	r2,-8(fp)
81137b74:	10c00060 	cmpeqi	r3,r2,1
81137b78:	1800921e 	bne	r3,zero,81137dc4 <OSFlagPend+0x374>
81137b7c:	10c00088 	cmpgei	r3,r2,2
81137b80:	1800021e 	bne	r3,zero,81137b8c <OSFlagPend+0x13c>
81137b84:	10006126 	beq	r2,zero,81137d0c <OSFlagPend+0x2bc>
81137b88:	0000bb06 	br	81137e78 <OSFlagPend+0x428>
81137b8c:	10c000a0 	cmpeqi	r3,r2,2
81137b90:	1800031e 	bne	r3,zero,81137ba0 <OSFlagPend+0x150>
81137b94:	108000e0 	cmpeqi	r2,r2,3
81137b98:	10002f1e 	bne	r2,zero,81137c58 <OSFlagPend+0x208>
81137b9c:	0000b606 	br	81137e78 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
81137ba0:	e0bffc17 	ldw	r2,-16(fp)
81137ba4:	10c0020b 	ldhu	r3,8(r2)
81137ba8:	e0bffd0b 	ldhu	r2,-12(fp)
81137bac:	1884703a 	and	r2,r3,r2
81137bb0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81137bb4:	e0ffe80b 	ldhu	r3,-96(fp)
81137bb8:	e0bffd0b 	ldhu	r2,-12(fp)
81137bbc:	1880171e 	bne	r3,r2,81137c1c <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81137bc0:	e0bfe403 	ldbu	r2,-112(fp)
81137bc4:	10800058 	cmpnei	r2,r2,1
81137bc8:	1000091e 	bne	r2,zero,81137bf0 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81137bcc:	e0bffc17 	ldw	r2,-16(fp)
81137bd0:	1080020b 	ldhu	r2,8(r2)
81137bd4:	1007883a 	mov	r3,r2
81137bd8:	e0bfe80b 	ldhu	r2,-96(fp)
81137bdc:	0084303a 	nor	r2,zero,r2
81137be0:	1884703a 	and	r2,r3,r2
81137be4:	1007883a 	mov	r3,r2
81137be8:	e0bffc17 	ldw	r2,-16(fp)
81137bec:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81137bf0:	d0a0a117 	ldw	r2,-32124(gp)
81137bf4:	e0ffe80b 	ldhu	r3,-96(fp)
81137bf8:	10c00b0d 	sth	r3,44(r2)
81137bfc:	e0bfe517 	ldw	r2,-108(fp)
81137c00:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137c04:	e0bfe717 	ldw	r2,-100(fp)
81137c08:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81137c0c:	e0800217 	ldw	r2,8(fp)
81137c10:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81137c14:	e0bfe80b 	ldhu	r2,-96(fp)
81137c18:	0000f806 	br	81137ffc <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81137c1c:	e13ffd0b 	ldhu	r4,-12(fp)
81137c20:	e17ffe03 	ldbu	r5,-8(fp)
81137c24:	e0bfff0b 	ldhu	r2,-4(fp)
81137c28:	e0fff704 	addi	r3,fp,-36
81137c2c:	d8800015 	stw	r2,0(sp)
81137c30:	280f883a 	mov	r7,r5
81137c34:	200d883a 	mov	r6,r4
81137c38:	180b883a 	mov	r5,r3
81137c3c:	e13ffc17 	ldw	r4,-16(fp)
81137c40:	11384e00 	call	811384e0 <OS_FlagBlock>
81137c44:	e0bfe517 	ldw	r2,-108(fp)
81137c48:	e0bfe915 	stw	r2,-92(fp)
81137c4c:	e0bfe917 	ldw	r2,-92(fp)
81137c50:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81137c54:	00009206 	br	81137ea0 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
81137c58:	e0bffc17 	ldw	r2,-16(fp)
81137c5c:	10c0020b 	ldhu	r3,8(r2)
81137c60:	e0bffd0b 	ldhu	r2,-12(fp)
81137c64:	1884703a 	and	r2,r3,r2
81137c68:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81137c6c:	e0bfe80b 	ldhu	r2,-96(fp)
81137c70:	10001726 	beq	r2,zero,81137cd0 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81137c74:	e0bfe403 	ldbu	r2,-112(fp)
81137c78:	10800058 	cmpnei	r2,r2,1
81137c7c:	1000091e 	bne	r2,zero,81137ca4 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81137c80:	e0bffc17 	ldw	r2,-16(fp)
81137c84:	1080020b 	ldhu	r2,8(r2)
81137c88:	1007883a 	mov	r3,r2
81137c8c:	e0bfe80b 	ldhu	r2,-96(fp)
81137c90:	0084303a 	nor	r2,zero,r2
81137c94:	1884703a 	and	r2,r3,r2
81137c98:	1007883a 	mov	r3,r2
81137c9c:	e0bffc17 	ldw	r2,-16(fp)
81137ca0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81137ca4:	d0a0a117 	ldw	r2,-32124(gp)
81137ca8:	e0ffe80b 	ldhu	r3,-96(fp)
81137cac:	10c00b0d 	sth	r3,44(r2)
81137cb0:	e0bfe517 	ldw	r2,-108(fp)
81137cb4:	e0bfea15 	stw	r2,-88(fp)
81137cb8:	e0bfea17 	ldw	r2,-88(fp)
81137cbc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81137cc0:	e0800217 	ldw	r2,8(fp)
81137cc4:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81137cc8:	e0bfe80b 	ldhu	r2,-96(fp)
81137ccc:	0000cb06 	br	81137ffc <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81137cd0:	e13ffd0b 	ldhu	r4,-12(fp)
81137cd4:	e17ffe03 	ldbu	r5,-8(fp)
81137cd8:	e0bfff0b 	ldhu	r2,-4(fp)
81137cdc:	e0fff704 	addi	r3,fp,-36
81137ce0:	d8800015 	stw	r2,0(sp)
81137ce4:	280f883a 	mov	r7,r5
81137ce8:	200d883a 	mov	r6,r4
81137cec:	180b883a 	mov	r5,r3
81137cf0:	e13ffc17 	ldw	r4,-16(fp)
81137cf4:	11384e00 	call	811384e0 <OS_FlagBlock>
81137cf8:	e0bfe517 	ldw	r2,-108(fp)
81137cfc:	e0bfeb15 	stw	r2,-84(fp)
81137d00:	e0bfeb17 	ldw	r2,-84(fp)
81137d04:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81137d08:	00006506 	br	81137ea0 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81137d0c:	e0bffc17 	ldw	r2,-16(fp)
81137d10:	1080020b 	ldhu	r2,8(r2)
81137d14:	0084303a 	nor	r2,zero,r2
81137d18:	1007883a 	mov	r3,r2
81137d1c:	e0bffd0b 	ldhu	r2,-12(fp)
81137d20:	1884703a 	and	r2,r3,r2
81137d24:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81137d28:	e0ffe80b 	ldhu	r3,-96(fp)
81137d2c:	e0bffd0b 	ldhu	r2,-12(fp)
81137d30:	1880151e 	bne	r3,r2,81137d88 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81137d34:	e0bfe403 	ldbu	r2,-112(fp)
81137d38:	10800058 	cmpnei	r2,r2,1
81137d3c:	1000071e 	bne	r2,zero,81137d5c <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81137d40:	e0bffc17 	ldw	r2,-16(fp)
81137d44:	10c0020b 	ldhu	r3,8(r2)
81137d48:	e0bfe80b 	ldhu	r2,-96(fp)
81137d4c:	1884b03a 	or	r2,r3,r2
81137d50:	1007883a 	mov	r3,r2
81137d54:	e0bffc17 	ldw	r2,-16(fp)
81137d58:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81137d5c:	d0a0a117 	ldw	r2,-32124(gp)
81137d60:	e0ffe80b 	ldhu	r3,-96(fp)
81137d64:	10c00b0d 	sth	r3,44(r2)
81137d68:	e0bfe517 	ldw	r2,-108(fp)
81137d6c:	e0bfec15 	stw	r2,-80(fp)
81137d70:	e0bfec17 	ldw	r2,-80(fp)
81137d74:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81137d78:	e0800217 	ldw	r2,8(fp)
81137d7c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81137d80:	e0bfe80b 	ldhu	r2,-96(fp)
81137d84:	00009d06 	br	81137ffc <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81137d88:	e13ffd0b 	ldhu	r4,-12(fp)
81137d8c:	e17ffe03 	ldbu	r5,-8(fp)
81137d90:	e0bfff0b 	ldhu	r2,-4(fp)
81137d94:	e0fff704 	addi	r3,fp,-36
81137d98:	d8800015 	stw	r2,0(sp)
81137d9c:	280f883a 	mov	r7,r5
81137da0:	200d883a 	mov	r6,r4
81137da4:	180b883a 	mov	r5,r3
81137da8:	e13ffc17 	ldw	r4,-16(fp)
81137dac:	11384e00 	call	811384e0 <OS_FlagBlock>
81137db0:	e0bfe517 	ldw	r2,-108(fp)
81137db4:	e0bfed15 	stw	r2,-76(fp)
81137db8:	e0bfed17 	ldw	r2,-76(fp)
81137dbc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81137dc0:	00003706 	br	81137ea0 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
81137dc4:	e0bffc17 	ldw	r2,-16(fp)
81137dc8:	1080020b 	ldhu	r2,8(r2)
81137dcc:	0084303a 	nor	r2,zero,r2
81137dd0:	1007883a 	mov	r3,r2
81137dd4:	e0bffd0b 	ldhu	r2,-12(fp)
81137dd8:	1884703a 	and	r2,r3,r2
81137ddc:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81137de0:	e0bfe80b 	ldhu	r2,-96(fp)
81137de4:	10001526 	beq	r2,zero,81137e3c <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81137de8:	e0bfe403 	ldbu	r2,-112(fp)
81137dec:	10800058 	cmpnei	r2,r2,1
81137df0:	1000071e 	bne	r2,zero,81137e10 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
81137df4:	e0bffc17 	ldw	r2,-16(fp)
81137df8:	10c0020b 	ldhu	r3,8(r2)
81137dfc:	e0bfe80b 	ldhu	r2,-96(fp)
81137e00:	1884b03a 	or	r2,r3,r2
81137e04:	1007883a 	mov	r3,r2
81137e08:	e0bffc17 	ldw	r2,-16(fp)
81137e0c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81137e10:	d0a0a117 	ldw	r2,-32124(gp)
81137e14:	e0ffe80b 	ldhu	r3,-96(fp)
81137e18:	10c00b0d 	sth	r3,44(r2)
81137e1c:	e0bfe517 	ldw	r2,-108(fp)
81137e20:	e0bfee15 	stw	r2,-72(fp)
81137e24:	e0bfee17 	ldw	r2,-72(fp)
81137e28:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81137e2c:	e0800217 	ldw	r2,8(fp)
81137e30:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81137e34:	e0bfe80b 	ldhu	r2,-96(fp)
81137e38:	00007006 	br	81137ffc <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81137e3c:	e13ffd0b 	ldhu	r4,-12(fp)
81137e40:	e17ffe03 	ldbu	r5,-8(fp)
81137e44:	e0bfff0b 	ldhu	r2,-4(fp)
81137e48:	e0fff704 	addi	r3,fp,-36
81137e4c:	d8800015 	stw	r2,0(sp)
81137e50:	280f883a 	mov	r7,r5
81137e54:	200d883a 	mov	r6,r4
81137e58:	180b883a 	mov	r5,r3
81137e5c:	e13ffc17 	ldw	r4,-16(fp)
81137e60:	11384e00 	call	811384e0 <OS_FlagBlock>
81137e64:	e0bfe517 	ldw	r2,-108(fp)
81137e68:	e0bfef15 	stw	r2,-68(fp)
81137e6c:	e0bfef17 	ldw	r2,-68(fp)
81137e70:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81137e74:	00000a06 	br	81137ea0 <OSFlagPend+0x450>
81137e78:	e0bfe517 	ldw	r2,-108(fp)
81137e7c:	e0bff015 	stw	r2,-64(fp)
81137e80:	e0bff017 	ldw	r2,-64(fp)
81137e84:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81137e88:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
81137e8c:	e0800217 	ldw	r2,8(fp)
81137e90:	00c01bc4 	movi	r3,111
81137e94:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
81137e98:	e0bfe80b 	ldhu	r2,-96(fp)
81137e9c:	00005706 	br	81137ffc <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
81137ea0:	11368400 	call	81136840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137ea4:	0005303a 	rdctl	r2,status
81137ea8:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137eac:	e0fff117 	ldw	r3,-60(fp)
81137eb0:	00bfff84 	movi	r2,-2
81137eb4:	1884703a 	and	r2,r3,r2
81137eb8:	1001703a 	wrctl	status,r2
  
  return context;
81137ebc:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
81137ec0:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
81137ec4:	d0a0a117 	ldw	r2,-32124(gp)
81137ec8:	10800c43 	ldbu	r2,49(r2)
81137ecc:	10803fcc 	andi	r2,r2,255
81137ed0:	10001c26 	beq	r2,zero,81137f44 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
81137ed4:	d0a0a117 	ldw	r2,-32124(gp)
81137ed8:	10800c43 	ldbu	r2,49(r2)
81137edc:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81137ee0:	d0a0a117 	ldw	r2,-32124(gp)
81137ee4:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
81137ee8:	e0bff704 	addi	r2,fp,-36
81137eec:	1009883a 	mov	r4,r2
81137ef0:	113882c0 	call	8113882c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
81137ef4:	d0a0a117 	ldw	r2,-32124(gp)
81137ef8:	10000c05 	stb	zero,48(r2)
81137efc:	e0bfe517 	ldw	r2,-108(fp)
81137f00:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137f04:	e0bff217 	ldw	r2,-56(fp)
81137f08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81137f0c:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
81137f10:	e0bff303 	ldbu	r2,-52(fp)
81137f14:	108000a0 	cmpeqi	r2,r2,2
81137f18:	10000426 	beq	r2,zero,81137f2c <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
81137f1c:	e0800217 	ldw	r2,8(fp)
81137f20:	00c00384 	movi	r3,14
81137f24:	10c00005 	stb	r3,0(r2)
                 break;
81137f28:	00000406 	br	81137f3c <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
81137f2c:	e0800217 	ldw	r2,8(fp)
81137f30:	00c00284 	movi	r3,10
81137f34:	10c00005 	stb	r3,0(r2)
                 break;
81137f38:	0001883a 	nop
        }
        return (flags_rdy);
81137f3c:	e0bfe80b 	ldhu	r2,-96(fp)
81137f40:	00002e06 	br	81137ffc <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
81137f44:	d0a0a117 	ldw	r2,-32124(gp)
81137f48:	10800b0b 	ldhu	r2,44(r2)
81137f4c:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
81137f50:	e0bfe403 	ldbu	r2,-112(fp)
81137f54:	10800058 	cmpnei	r2,r2,1
81137f58:	1000211e 	bne	r2,zero,81137fe0 <OSFlagPend+0x590>
        switch (wait_type) {
81137f5c:	e0bffe03 	ldbu	r2,-8(fp)
81137f60:	10001616 	blt	r2,zero,81137fbc <OSFlagPend+0x56c>
81137f64:	10c00090 	cmplti	r3,r2,2
81137f68:	18000c1e 	bne	r3,zero,81137f9c <OSFlagPend+0x54c>
81137f6c:	10800108 	cmpgei	r2,r2,4
81137f70:	1000121e 	bne	r2,zero,81137fbc <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
81137f74:	e0bffc17 	ldw	r2,-16(fp)
81137f78:	1080020b 	ldhu	r2,8(r2)
81137f7c:	1007883a 	mov	r3,r2
81137f80:	e0bfe80b 	ldhu	r2,-96(fp)
81137f84:	0084303a 	nor	r2,zero,r2
81137f88:	1884703a 	and	r2,r3,r2
81137f8c:	1007883a 	mov	r3,r2
81137f90:	e0bffc17 	ldw	r2,-16(fp)
81137f94:	10c0020d 	sth	r3,8(r2)
                 break;
81137f98:	00001106 	br	81137fe0 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
81137f9c:	e0bffc17 	ldw	r2,-16(fp)
81137fa0:	10c0020b 	ldhu	r3,8(r2)
81137fa4:	e0bfe80b 	ldhu	r2,-96(fp)
81137fa8:	1884b03a 	or	r2,r3,r2
81137fac:	1007883a 	mov	r3,r2
81137fb0:	e0bffc17 	ldw	r2,-16(fp)
81137fb4:	10c0020d 	sth	r3,8(r2)
                 break;
81137fb8:	00000906 	br	81137fe0 <OSFlagPend+0x590>
81137fbc:	e0bfe517 	ldw	r2,-108(fp)
81137fc0:	e0bff415 	stw	r2,-48(fp)
81137fc4:	e0bff417 	ldw	r2,-48(fp)
81137fc8:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81137fcc:	e0800217 	ldw	r2,8(fp)
81137fd0:	00c01bc4 	movi	r3,111
81137fd4:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81137fd8:	0005883a 	mov	r2,zero
81137fdc:	00000706 	br	81137ffc <OSFlagPend+0x5ac>
81137fe0:	e0bfe517 	ldw	r2,-108(fp)
81137fe4:	e0bff515 	stw	r2,-44(fp)
81137fe8:	e0bff517 	ldw	r2,-44(fp)
81137fec:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
81137ff0:	e0800217 	ldw	r2,8(fp)
81137ff4:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81137ff8:	e0bfe80b 	ldhu	r2,-96(fp)
}
81137ffc:	e037883a 	mov	sp,fp
81138000:	dfc00117 	ldw	ra,4(sp)
81138004:	df000017 	ldw	fp,0(sp)
81138008:	dec00204 	addi	sp,sp,8
8113800c:	f800283a 	ret

81138010 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81138010:	defffb04 	addi	sp,sp,-20
81138014:	de00012e 	bgeu	sp,et,8113801c <OSFlagPendGetFlagsRdy+0xc>
81138018:	003b68fa 	trap	3
8113801c:	df000415 	stw	fp,16(sp)
81138020:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81138024:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138028:	0005303a 	rdctl	r2,status
8113802c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138030:	e0fffe17 	ldw	r3,-8(fp)
81138034:	00bfff84 	movi	r2,-2
81138038:	1884703a 	and	r2,r3,r2
8113803c:	1001703a 	wrctl	status,r2
  
  return context;
81138040:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81138044:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
81138048:	d0a0a117 	ldw	r2,-32124(gp)
8113804c:	10800b0b 	ldhu	r2,44(r2)
81138050:	e0bffd0d 	sth	r2,-12(fp)
81138054:	e0bffc17 	ldw	r2,-16(fp)
81138058:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113805c:	e0bfff17 	ldw	r2,-4(fp)
81138060:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
81138064:	e0bffd0b 	ldhu	r2,-12(fp)
}
81138068:	e037883a 	mov	sp,fp
8113806c:	df000017 	ldw	fp,0(sp)
81138070:	dec00104 	addi	sp,sp,4
81138074:	f800283a 	ret

81138078 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
81138078:	deffef04 	addi	sp,sp,-68
8113807c:	de00012e 	bgeu	sp,et,81138084 <OSFlagPost+0xc>
81138080:	003b68fa 	trap	3
81138084:	dfc01015 	stw	ra,64(sp)
81138088:	df000f15 	stw	fp,60(sp)
8113808c:	df000f04 	addi	fp,sp,60
81138090:	e13ffc15 	stw	r4,-16(fp)
81138094:	2807883a 	mov	r3,r5
81138098:	3005883a 	mov	r2,r6
8113809c:	e1ffff15 	stw	r7,-4(fp)
811380a0:	e0fffd0d 	sth	r3,-12(fp)
811380a4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
811380a8:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
811380ac:	e0bfff17 	ldw	r2,-4(fp)
811380b0:	1000021e 	bne	r2,zero,811380bc <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
811380b4:	0005883a 	mov	r2,zero
811380b8:	0000d106 	br	81138400 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
811380bc:	e0bffc17 	ldw	r2,-16(fp)
811380c0:	1000051e 	bne	r2,zero,811380d8 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811380c4:	e0bfff17 	ldw	r2,-4(fp)
811380c8:	00c01b84 	movi	r3,110
811380cc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811380d0:	0005883a 	mov	r2,zero
811380d4:	0000ca06 	br	81138400 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
811380d8:	e0bffc17 	ldw	r2,-16(fp)
811380dc:	10800003 	ldbu	r2,0(r2)
811380e0:	10803fcc 	andi	r2,r2,255
811380e4:	10800160 	cmpeqi	r2,r2,5
811380e8:	1000051e 	bne	r2,zero,81138100 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
811380ec:	e0bfff17 	ldw	r2,-4(fp)
811380f0:	00c00044 	movi	r3,1
811380f4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811380f8:	0005883a 	mov	r2,zero
811380fc:	0000c006 	br	81138400 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138100:	0005303a 	rdctl	r2,status
81138104:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138108:	e0fffb17 	ldw	r3,-20(fp)
8113810c:	00bfff84 	movi	r2,-2
81138110:	1884703a 	and	r2,r3,r2
81138114:	1001703a 	wrctl	status,r2
  
  return context;
81138118:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113811c:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
81138120:	e0bffe03 	ldbu	r2,-8(fp)
81138124:	10000326 	beq	r2,zero,81138134 <OSFlagPost+0xbc>
81138128:	10800060 	cmpeqi	r2,r2,1
8113812c:	10000b1e 	bne	r2,zero,8113815c <OSFlagPost+0xe4>
81138130:	00001206 	br	8113817c <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
81138134:	e0bffc17 	ldw	r2,-16(fp)
81138138:	1080020b 	ldhu	r2,8(r2)
8113813c:	1007883a 	mov	r3,r2
81138140:	e0bffd0b 	ldhu	r2,-12(fp)
81138144:	0084303a 	nor	r2,zero,r2
81138148:	1884703a 	and	r2,r3,r2
8113814c:	1007883a 	mov	r3,r2
81138150:	e0bffc17 	ldw	r2,-16(fp)
81138154:	10c0020d 	sth	r3,8(r2)
             break;
81138158:	00001106 	br	811381a0 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113815c:	e0bffc17 	ldw	r2,-16(fp)
81138160:	10c0020b 	ldhu	r3,8(r2)
81138164:	e0bffd0b 	ldhu	r2,-12(fp)
81138168:	1884b03a 	or	r2,r3,r2
8113816c:	1007883a 	mov	r3,r2
81138170:	e0bffc17 	ldw	r2,-16(fp)
81138174:	10c0020d 	sth	r3,8(r2)
             break;
81138178:	00000906 	br	811381a0 <OSFlagPost+0x128>
8113817c:	e0bff317 	ldw	r2,-52(fp)
81138180:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138184:	e0bff417 	ldw	r2,-48(fp)
81138188:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113818c:	e0bfff17 	ldw	r2,-4(fp)
81138190:	00c01c44 	movi	r3,113
81138194:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
81138198:	0005883a 	mov	r2,zero
8113819c:	00009806 	br	81138400 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
811381a0:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811381a4:	e0bffc17 	ldw	r2,-16(fp)
811381a8:	10800117 	ldw	r2,4(r2)
811381ac:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
811381b0:	00007706 	br	81138390 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
811381b4:	e0bff117 	ldw	r2,-60(fp)
811381b8:	10800483 	ldbu	r2,18(r2)
811381bc:	10803fcc 	andi	r2,r2,255
811381c0:	10c00060 	cmpeqi	r3,r2,1
811381c4:	18004a1e 	bne	r3,zero,811382f0 <OSFlagPost+0x278>
811381c8:	10c00088 	cmpgei	r3,r2,2
811381cc:	1800021e 	bne	r3,zero,811381d8 <OSFlagPost+0x160>
811381d0:	10002f26 	beq	r2,zero,81138290 <OSFlagPost+0x218>
811381d4:	00005b06 	br	81138344 <OSFlagPost+0x2cc>
811381d8:	10c000a0 	cmpeqi	r3,r2,2
811381dc:	1800031e 	bne	r3,zero,811381ec <OSFlagPost+0x174>
811381e0:	108000e0 	cmpeqi	r2,r2,3
811381e4:	1000171e 	bne	r2,zero,81138244 <OSFlagPost+0x1cc>
811381e8:	00005606 	br	81138344 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811381ec:	e0bffc17 	ldw	r2,-16(fp)
811381f0:	10c0020b 	ldhu	r3,8(r2)
811381f4:	e0bff117 	ldw	r2,-60(fp)
811381f8:	1080040b 	ldhu	r2,16(r2)
811381fc:	1884703a 	and	r2,r3,r2
81138200:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81138204:	e0bff117 	ldw	r2,-60(fp)
81138208:	1080040b 	ldhu	r2,16(r2)
8113820c:	10ffffcc 	andi	r3,r2,65535
81138210:	e0bff60b 	ldhu	r2,-40(fp)
81138214:	1880541e 	bne	r3,r2,81138368 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81138218:	e0bff60b 	ldhu	r2,-40(fp)
8113821c:	100b883a 	mov	r5,r2
81138220:	e13ff117 	ldw	r4,-60(fp)
81138224:	11387300 	call	81138730 <OS_FlagTaskRdy>
81138228:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113822c:	e0bff683 	ldbu	r2,-38(fp)
81138230:	10800058 	cmpnei	r2,r2,1
81138234:	10004c1e 	bne	r2,zero,81138368 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81138238:	00800044 	movi	r2,1
8113823c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81138240:	00004906 	br	81138368 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81138244:	e0bffc17 	ldw	r2,-16(fp)
81138248:	10c0020b 	ldhu	r3,8(r2)
8113824c:	e0bff117 	ldw	r2,-60(fp)
81138250:	1080040b 	ldhu	r2,16(r2)
81138254:	1884703a 	and	r2,r3,r2
81138258:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113825c:	e0bff60b 	ldhu	r2,-40(fp)
81138260:	10004326 	beq	r2,zero,81138370 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81138264:	e0bff60b 	ldhu	r2,-40(fp)
81138268:	100b883a 	mov	r5,r2
8113826c:	e13ff117 	ldw	r4,-60(fp)
81138270:	11387300 	call	81138730 <OS_FlagTaskRdy>
81138274:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81138278:	e0bff683 	ldbu	r2,-38(fp)
8113827c:	10800058 	cmpnei	r2,r2,1
81138280:	10003b1e 	bne	r2,zero,81138370 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81138284:	00800044 	movi	r2,1
81138288:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113828c:	00003806 	br	81138370 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81138290:	e0bffc17 	ldw	r2,-16(fp)
81138294:	1080020b 	ldhu	r2,8(r2)
81138298:	0084303a 	nor	r2,zero,r2
8113829c:	1007883a 	mov	r3,r2
811382a0:	e0bff117 	ldw	r2,-60(fp)
811382a4:	1080040b 	ldhu	r2,16(r2)
811382a8:	1884703a 	and	r2,r3,r2
811382ac:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
811382b0:	e0bff117 	ldw	r2,-60(fp)
811382b4:	1080040b 	ldhu	r2,16(r2)
811382b8:	10ffffcc 	andi	r3,r2,65535
811382bc:	e0bff60b 	ldhu	r2,-40(fp)
811382c0:	18802d1e 	bne	r3,r2,81138378 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811382c4:	e0bff60b 	ldhu	r2,-40(fp)
811382c8:	100b883a 	mov	r5,r2
811382cc:	e13ff117 	ldw	r4,-60(fp)
811382d0:	11387300 	call	81138730 <OS_FlagTaskRdy>
811382d4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811382d8:	e0bff683 	ldbu	r2,-38(fp)
811382dc:	10800058 	cmpnei	r2,r2,1
811382e0:	1000251e 	bne	r2,zero,81138378 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811382e4:	00800044 	movi	r2,1
811382e8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811382ec:	00002206 	br	81138378 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811382f0:	e0bffc17 	ldw	r2,-16(fp)
811382f4:	1080020b 	ldhu	r2,8(r2)
811382f8:	0084303a 	nor	r2,zero,r2
811382fc:	1007883a 	mov	r3,r2
81138300:	e0bff117 	ldw	r2,-60(fp)
81138304:	1080040b 	ldhu	r2,16(r2)
81138308:	1884703a 	and	r2,r3,r2
8113830c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81138310:	e0bff60b 	ldhu	r2,-40(fp)
81138314:	10001a26 	beq	r2,zero,81138380 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81138318:	e0bff60b 	ldhu	r2,-40(fp)
8113831c:	100b883a 	mov	r5,r2
81138320:	e13ff117 	ldw	r4,-60(fp)
81138324:	11387300 	call	81138730 <OS_FlagTaskRdy>
81138328:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113832c:	e0bff683 	ldbu	r2,-38(fp)
81138330:	10800058 	cmpnei	r2,r2,1
81138334:	1000121e 	bne	r2,zero,81138380 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81138338:	00800044 	movi	r2,1
8113833c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81138340:	00000f06 	br	81138380 <OSFlagPost+0x308>
81138344:	e0bff317 	ldw	r2,-52(fp)
81138348:	e0bff515 	stw	r2,-44(fp)
8113834c:	e0bff517 	ldw	r2,-44(fp)
81138350:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81138354:	e0bfff17 	ldw	r2,-4(fp)
81138358:	00c01bc4 	movi	r3,111
8113835c:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81138360:	0005883a 	mov	r2,zero
81138364:	00002606 	br	81138400 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81138368:	0001883a 	nop
8113836c:	00000506 	br	81138384 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81138370:	0001883a 	nop
81138374:	00000306 	br	81138384 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81138378:	0001883a 	nop
8113837c:	00000106 	br	81138384 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81138380:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
81138384:	e0bff117 	ldw	r2,-60(fp)
81138388:	10800017 	ldw	r2,0(r2)
8113838c:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81138390:	e0bff117 	ldw	r2,-60(fp)
81138394:	103f871e 	bne	r2,zero,811381b4 <__reset+0xfb1181b4>
81138398:	e0bff317 	ldw	r2,-52(fp)
8113839c:	e0bff715 	stw	r2,-36(fp)
811383a0:	e0bff717 	ldw	r2,-36(fp)
811383a4:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
811383a8:	e0bff203 	ldbu	r2,-56(fp)
811383ac:	10800058 	cmpnei	r2,r2,1
811383b0:	1000011e 	bne	r2,zero,811383b8 <OSFlagPost+0x340>
        OS_Sched();
811383b4:	11368400 	call	81136840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811383b8:	0005303a 	rdctl	r2,status
811383bc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811383c0:	e0fffa17 	ldw	r3,-24(fp)
811383c4:	00bfff84 	movi	r2,-2
811383c8:	1884703a 	and	r2,r3,r2
811383cc:	1001703a 	wrctl	status,r2
  
  return context;
811383d0:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
811383d4:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
811383d8:	e0bffc17 	ldw	r2,-16(fp)
811383dc:	1080020b 	ldhu	r2,8(r2)
811383e0:	e0bff90d 	sth	r2,-28(fp)
811383e4:	e0bff317 	ldw	r2,-52(fp)
811383e8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811383ec:	e0bff817 	ldw	r2,-32(fp)
811383f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
811383f4:	e0bfff17 	ldw	r2,-4(fp)
811383f8:	10000005 	stb	zero,0(r2)
    return (flags_cur);
811383fc:	e0bff90b 	ldhu	r2,-28(fp)
}
81138400:	e037883a 	mov	sp,fp
81138404:	dfc00117 	ldw	ra,4(sp)
81138408:	df000017 	ldw	fp,0(sp)
8113840c:	dec00204 	addi	sp,sp,8
81138410:	f800283a 	ret

81138414 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
81138414:	defff904 	addi	sp,sp,-28
81138418:	de00012e 	bgeu	sp,et,81138420 <OSFlagQuery+0xc>
8113841c:	003b68fa 	trap	3
81138420:	df000615 	stw	fp,24(sp)
81138424:	df000604 	addi	fp,sp,24
81138428:	e13ffe15 	stw	r4,-8(fp)
8113842c:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
81138430:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
81138434:	e0bfff17 	ldw	r2,-4(fp)
81138438:	1000021e 	bne	r2,zero,81138444 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113843c:	0005883a 	mov	r2,zero
81138440:	00002306 	br	811384d0 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
81138444:	e0bffe17 	ldw	r2,-8(fp)
81138448:	1000051e 	bne	r2,zero,81138460 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113844c:	e0bfff17 	ldw	r2,-4(fp)
81138450:	00c01b84 	movi	r3,110
81138454:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81138458:	0005883a 	mov	r2,zero
8113845c:	00001c06 	br	811384d0 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
81138460:	e0bffe17 	ldw	r2,-8(fp)
81138464:	10800003 	ldbu	r2,0(r2)
81138468:	10803fcc 	andi	r2,r2,255
8113846c:	10800160 	cmpeqi	r2,r2,5
81138470:	1000051e 	bne	r2,zero,81138488 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81138474:	e0bfff17 	ldw	r2,-4(fp)
81138478:	00c00044 	movi	r3,1
8113847c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81138480:	0005883a 	mov	r2,zero
81138484:	00001206 	br	811384d0 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138488:	0005303a 	rdctl	r2,status
8113848c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138490:	e0fffc17 	ldw	r3,-16(fp)
81138494:	00bfff84 	movi	r2,-2
81138498:	1884703a 	and	r2,r3,r2
8113849c:	1001703a 	wrctl	status,r2
  
  return context;
811384a0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811384a4:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
811384a8:	e0bffe17 	ldw	r2,-8(fp)
811384ac:	1080020b 	ldhu	r2,8(r2)
811384b0:	e0bffb0d 	sth	r2,-20(fp)
811384b4:	e0bffa17 	ldw	r2,-24(fp)
811384b8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811384bc:	e0bffd17 	ldw	r2,-12(fp)
811384c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811384c4:	e0bfff17 	ldw	r2,-4(fp)
811384c8:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
811384cc:	e0bffb0b 	ldhu	r2,-20(fp)
}
811384d0:	e037883a 	mov	sp,fp
811384d4:	df000017 	ldw	fp,0(sp)
811384d8:	dec00104 	addi	sp,sp,4
811384dc:	f800283a 	ret

811384e0 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
811384e0:	defff804 	addi	sp,sp,-32
811384e4:	de00012e 	bgeu	sp,et,811384ec <OS_FlagBlock+0xc>
811384e8:	003b68fa 	trap	3
811384ec:	df000715 	stw	fp,28(sp)
811384f0:	df000704 	addi	fp,sp,28
811384f4:	e13ffb15 	stw	r4,-20(fp)
811384f8:	e17ffc15 	stw	r5,-16(fp)
811384fc:	3009883a 	mov	r4,r6
81138500:	3807883a 	mov	r3,r7
81138504:	e0800117 	ldw	r2,4(fp)
81138508:	e13ffd0d 	sth	r4,-12(fp)
8113850c:	e0fffe05 	stb	r3,-8(fp)
81138510:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
81138514:	d0a0a117 	ldw	r2,-32124(gp)
81138518:	d0e0a117 	ldw	r3,-32124(gp)
8113851c:	18c00c03 	ldbu	r3,48(r3)
81138520:	18c00814 	ori	r3,r3,32
81138524:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
81138528:	d0a0a117 	ldw	r2,-32124(gp)
8113852c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
81138530:	d0a0a117 	ldw	r2,-32124(gp)
81138534:	e0ffff0b 	ldhu	r3,-4(fp)
81138538:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113853c:	d0a0a117 	ldw	r2,-32124(gp)
81138540:	e0fffc17 	ldw	r3,-16(fp)
81138544:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
81138548:	e0bffc17 	ldw	r2,-16(fp)
8113854c:	e0fffd0b 	ldhu	r3,-12(fp)
81138550:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
81138554:	e0bffc17 	ldw	r2,-16(fp)
81138558:	e0fffe03 	ldbu	r3,-8(fp)
8113855c:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
81138560:	d0e0a117 	ldw	r3,-32124(gp)
81138564:	e0bffc17 	ldw	r2,-16(fp)
81138568:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113856c:	e0bffb17 	ldw	r2,-20(fp)
81138570:	10c00117 	ldw	r3,4(r2)
81138574:	e0bffc17 	ldw	r2,-16(fp)
81138578:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113857c:	e0bffc17 	ldw	r2,-16(fp)
81138580:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
81138584:	e0bffc17 	ldw	r2,-16(fp)
81138588:	e0fffb17 	ldw	r3,-20(fp)
8113858c:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81138590:	e0bffb17 	ldw	r2,-20(fp)
81138594:	10800117 	ldw	r2,4(r2)
81138598:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113859c:	e0bff917 	ldw	r2,-28(fp)
811385a0:	10000326 	beq	r2,zero,811385b0 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
811385a4:	e0bff917 	ldw	r2,-28(fp)
811385a8:	e0fffc17 	ldw	r3,-16(fp)
811385ac:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
811385b0:	e0bffb17 	ldw	r2,-20(fp)
811385b4:	e0fffc17 	ldw	r3,-16(fp)
811385b8:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
811385bc:	d0a0a117 	ldw	r2,-32124(gp)
811385c0:	10800d03 	ldbu	r2,52(r2)
811385c4:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
811385c8:	e0fffa03 	ldbu	r3,-24(fp)
811385cc:	e13ffa03 	ldbu	r4,-24(fp)
811385d0:	d0a09d44 	addi	r2,gp,-32139
811385d4:	2085883a 	add	r2,r4,r2
811385d8:	10800003 	ldbu	r2,0(r2)
811385dc:	1009883a 	mov	r4,r2
811385e0:	d0a0a117 	ldw	r2,-32124(gp)
811385e4:	10800d43 	ldbu	r2,53(r2)
811385e8:	0084303a 	nor	r2,zero,r2
811385ec:	2084703a 	and	r2,r4,r2
811385f0:	1009883a 	mov	r4,r2
811385f4:	d0a09d44 	addi	r2,gp,-32139
811385f8:	1885883a 	add	r2,r3,r2
811385fc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
81138600:	e0fffa03 	ldbu	r3,-24(fp)
81138604:	d0a09d44 	addi	r2,gp,-32139
81138608:	1885883a 	add	r2,r3,r2
8113860c:	10800003 	ldbu	r2,0(r2)
81138610:	10803fcc 	andi	r2,r2,255
81138614:	1000071e 	bne	r2,zero,81138634 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81138618:	d0a0a117 	ldw	r2,-32124(gp)
8113861c:	10800d83 	ldbu	r2,54(r2)
81138620:	0084303a 	nor	r2,zero,r2
81138624:	1007883a 	mov	r3,r2
81138628:	d0a09d03 	ldbu	r2,-32140(gp)
8113862c:	1884703a 	and	r2,r3,r2
81138630:	d0a09d05 	stb	r2,-32140(gp)
    }
}
81138634:	0001883a 	nop
81138638:	e037883a 	mov	sp,fp
8113863c:	df000017 	ldw	fp,0(sp)
81138640:	dec00104 	addi	sp,sp,4
81138644:	f800283a 	ret

81138648 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
81138648:	defffb04 	addi	sp,sp,-20
8113864c:	de00012e 	bgeu	sp,et,81138654 <OS_FlagInit+0xc>
81138650:	003b68fa 	trap	3
81138654:	dfc00415 	stw	ra,16(sp)
81138658:	df000315 	stw	fp,12(sp)
8113865c:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
81138660:	01421004 	movi	r5,2112
81138664:	012045b4 	movhi	r4,33046
81138668:	210c6f04 	addi	r4,r4,12732
8113866c:	11367740 	call	81136774 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
81138670:	00a045b4 	movhi	r2,33046
81138674:	108c6f04 	addi	r2,r2,12732
81138678:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113867c:	00a045b4 	movhi	r2,33046
81138680:	108c7a04 	addi	r2,r2,12776
81138684:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81138688:	e03ffd0d 	sth	zero,-12(fp)
8113868c:	00001306 	br	811386dc <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81138690:	e0bffe17 	ldw	r2,-8(fp)
81138694:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
81138698:	e0bffe17 	ldw	r2,-8(fp)
8113869c:	e0ffff17 	ldw	r3,-4(fp)
811386a0:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
811386a4:	e0bffe17 	ldw	r2,-8(fp)
811386a8:	00c00fc4 	movi	r3,63
811386ac:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
811386b0:	e0bffe17 	ldw	r2,-8(fp)
811386b4:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
811386b8:	e0bffe17 	ldw	r2,-8(fp)
811386bc:	10800b04 	addi	r2,r2,44
811386c0:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
811386c4:	e0bfff17 	ldw	r2,-4(fp)
811386c8:	10800b04 	addi	r2,r2,44
811386cc:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
811386d0:	e0bffd0b 	ldhu	r2,-12(fp)
811386d4:	10800044 	addi	r2,r2,1
811386d8:	e0bffd0d 	sth	r2,-12(fp)
811386dc:	e0bffd0b 	ldhu	r2,-12(fp)
811386e0:	10800bf0 	cmpltui	r2,r2,47
811386e4:	103fea1e 	bne	r2,zero,81138690 <__reset+0xfb118690>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
811386e8:	e0bffe17 	ldw	r2,-8(fp)
811386ec:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
811386f0:	e0bffe17 	ldw	r2,-8(fp)
811386f4:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
811386f8:	e0bffe17 	ldw	r2,-8(fp)
811386fc:	00c00fc4 	movi	r3,63
81138700:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81138704:	e0bffe17 	ldw	r2,-8(fp)
81138708:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113870c:	00a045b4 	movhi	r2,33046
81138710:	108c6f04 	addi	r2,r2,12732
81138714:	d0a0a515 	stw	r2,-32108(gp)
#endif
}
81138718:	0001883a 	nop
8113871c:	e037883a 	mov	sp,fp
81138720:	dfc00117 	ldw	ra,4(sp)
81138724:	df000017 	ldw	fp,0(sp)
81138728:	dec00204 	addi	sp,sp,8
8113872c:	f800283a 	ret

81138730 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
81138730:	defffa04 	addi	sp,sp,-24
81138734:	de00012e 	bgeu	sp,et,8113873c <OS_FlagTaskRdy+0xc>
81138738:	003b68fa 	trap	3
8113873c:	dfc00515 	stw	ra,20(sp)
81138740:	df000415 	stw	fp,16(sp)
81138744:	df000404 	addi	fp,sp,16
81138748:	e13ffe15 	stw	r4,-8(fp)
8113874c:	2805883a 	mov	r2,r5
81138750:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
81138754:	e0bffe17 	ldw	r2,-8(fp)
81138758:	10800217 	ldw	r2,8(r2)
8113875c:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
81138760:	e0bffd17 	ldw	r2,-12(fp)
81138764:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
81138768:	e0bffd17 	ldw	r2,-12(fp)
8113876c:	e0ffff0b 	ldhu	r3,-4(fp)
81138770:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
81138774:	e0bffd17 	ldw	r2,-12(fp)
81138778:	10c00c03 	ldbu	r3,48(r2)
8113877c:	00bff7c4 	movi	r2,-33
81138780:	1884703a 	and	r2,r3,r2
81138784:	1007883a 	mov	r3,r2
81138788:	e0bffd17 	ldw	r2,-12(fp)
8113878c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81138790:	e0bffd17 	ldw	r2,-12(fp)
81138794:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81138798:	e0bffd17 	ldw	r2,-12(fp)
8113879c:	10800c03 	ldbu	r2,48(r2)
811387a0:	10803fcc 	andi	r2,r2,255
811387a4:	1000181e 	bne	r2,zero,81138808 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
811387a8:	e0bffd17 	ldw	r2,-12(fp)
811387ac:	10c00d83 	ldbu	r3,54(r2)
811387b0:	d0a09d03 	ldbu	r2,-32140(gp)
811387b4:	1884b03a 	or	r2,r3,r2
811387b8:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811387bc:	e0bffd17 	ldw	r2,-12(fp)
811387c0:	10800d03 	ldbu	r2,52(r2)
811387c4:	10c03fcc 	andi	r3,r2,255
811387c8:	e0bffd17 	ldw	r2,-12(fp)
811387cc:	10800d03 	ldbu	r2,52(r2)
811387d0:	11003fcc 	andi	r4,r2,255
811387d4:	d0a09d44 	addi	r2,gp,-32139
811387d8:	2085883a 	add	r2,r4,r2
811387dc:	11000003 	ldbu	r4,0(r2)
811387e0:	e0bffd17 	ldw	r2,-12(fp)
811387e4:	10800d43 	ldbu	r2,53(r2)
811387e8:	2084b03a 	or	r2,r4,r2
811387ec:	1009883a 	mov	r4,r2
811387f0:	d0a09d44 	addi	r2,gp,-32139
811387f4:	1885883a 	add	r2,r3,r2
811387f8:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
811387fc:	00800044 	movi	r2,1
81138800:	e0bffc05 	stb	r2,-16(fp)
81138804:	00000106 	br	8113880c <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81138808:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113880c:	e13ffe17 	ldw	r4,-8(fp)
81138810:	113882c0 	call	8113882c <OS_FlagUnlink>
    return (sched);
81138814:	e0bffc03 	ldbu	r2,-16(fp)
}
81138818:	e037883a 	mov	sp,fp
8113881c:	dfc00117 	ldw	ra,4(sp)
81138820:	df000017 	ldw	fp,0(sp)
81138824:	dec00204 	addi	sp,sp,8
81138828:	f800283a 	ret

8113882c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113882c:	defffa04 	addi	sp,sp,-24
81138830:	de00012e 	bgeu	sp,et,81138838 <OS_FlagUnlink+0xc>
81138834:	003b68fa 	trap	3
81138838:	df000515 	stw	fp,20(sp)
8113883c:	df000504 	addi	fp,sp,20
81138840:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
81138844:	e0bfff17 	ldw	r2,-4(fp)
81138848:	10800117 	ldw	r2,4(r2)
8113884c:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81138850:	e0bfff17 	ldw	r2,-4(fp)
81138854:	10800017 	ldw	r2,0(r2)
81138858:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113885c:	e0bffb17 	ldw	r2,-20(fp)
81138860:	10000b1e 	bne	r2,zero,81138890 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
81138864:	e0bfff17 	ldw	r2,-4(fp)
81138868:	10800317 	ldw	r2,12(r2)
8113886c:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
81138870:	e0bffd17 	ldw	r2,-12(fp)
81138874:	e0fffc17 	ldw	r3,-16(fp)
81138878:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113887c:	e0bffc17 	ldw	r2,-16(fp)
81138880:	10000b26 	beq	r2,zero,811388b0 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
81138884:	e0bffc17 	ldw	r2,-16(fp)
81138888:	10000115 	stw	zero,4(r2)
8113888c:	00000806 	br	811388b0 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81138890:	e0bffb17 	ldw	r2,-20(fp)
81138894:	e0fffc17 	ldw	r3,-16(fp)
81138898:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113889c:	e0bffc17 	ldw	r2,-16(fp)
811388a0:	10000326 	beq	r2,zero,811388b0 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
811388a4:	e0bffc17 	ldw	r2,-16(fp)
811388a8:	e0fffb17 	ldw	r3,-20(fp)
811388ac:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
811388b0:	e0bfff17 	ldw	r2,-4(fp)
811388b4:	10800217 	ldw	r2,8(r2)
811388b8:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
811388bc:	e0bffe17 	ldw	r2,-8(fp)
811388c0:	10000a15 	stw	zero,40(r2)
#endif
}
811388c4:	0001883a 	nop
811388c8:	e037883a 	mov	sp,fp
811388cc:	df000017 	ldw	fp,0(sp)
811388d0:	dec00104 	addi	sp,sp,4
811388d4:	f800283a 	ret

811388d8 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
811388d8:	defff404 	addi	sp,sp,-48
811388dc:	de00012e 	bgeu	sp,et,811388e4 <OSMemCreate+0xc>
811388e0:	003b68fa 	trap	3
811388e4:	df000b15 	stw	fp,44(sp)
811388e8:	df000b04 	addi	fp,sp,44
811388ec:	e13ffc15 	stw	r4,-16(fp)
811388f0:	e17ffd15 	stw	r5,-12(fp)
811388f4:	e1bffe15 	stw	r6,-8(fp)
811388f8:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811388fc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81138900:	e0bfff17 	ldw	r2,-4(fp)
81138904:	1000021e 	bne	r2,zero,81138910 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81138908:	0005883a 	mov	r2,zero
8113890c:	00006506 	br	81138aa4 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81138910:	e0bffc17 	ldw	r2,-16(fp)
81138914:	1000051e 	bne	r2,zero,8113892c <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81138918:	e0bfff17 	ldw	r2,-4(fp)
8113891c:	00c01884 	movi	r3,98
81138920:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81138924:	0005883a 	mov	r2,zero
81138928:	00005e06 	br	81138aa4 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113892c:	e0bffc17 	ldw	r2,-16(fp)
81138930:	108000cc 	andi	r2,r2,3
81138934:	10000526 	beq	r2,zero,8113894c <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81138938:	e0bfff17 	ldw	r2,-4(fp)
8113893c:	00c01884 	movi	r3,98
81138940:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81138944:	0005883a 	mov	r2,zero
81138948:	00005606 	br	81138aa4 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113894c:	e0bffd17 	ldw	r2,-12(fp)
81138950:	108000a8 	cmpgeui	r2,r2,2
81138954:	1000051e 	bne	r2,zero,8113896c <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
81138958:	e0bfff17 	ldw	r2,-4(fp)
8113895c:	00c016c4 	movi	r3,91
81138960:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81138964:	0005883a 	mov	r2,zero
81138968:	00004e06 	br	81138aa4 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113896c:	e0bffe17 	ldw	r2,-8(fp)
81138970:	10800128 	cmpgeui	r2,r2,4
81138974:	1000051e 	bne	r2,zero,8113898c <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
81138978:	e0bfff17 	ldw	r2,-4(fp)
8113897c:	00c01704 	movi	r3,92
81138980:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81138984:	0005883a 	mov	r2,zero
81138988:	00004606 	br	81138aa4 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113898c:	0005303a 	rdctl	r2,status
81138990:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138994:	e0fffb17 	ldw	r3,-20(fp)
81138998:	00bfff84 	movi	r2,-2
8113899c:	1884703a 	and	r2,r3,r2
811389a0:	1001703a 	wrctl	status,r2
  
  return context;
811389a4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811389a8:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
811389ac:	d0a09a17 	ldw	r2,-32152(gp)
811389b0:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
811389b4:	d0a09a17 	ldw	r2,-32152(gp)
811389b8:	10000326 	beq	r2,zero,811389c8 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
811389bc:	d0a09a17 	ldw	r2,-32152(gp)
811389c0:	10800117 	ldw	r2,4(r2)
811389c4:	d0a09a15 	stw	r2,-32152(gp)
811389c8:	e0bff817 	ldw	r2,-32(fp)
811389cc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811389d0:	e0bff917 	ldw	r2,-28(fp)
811389d4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
811389d8:	e0bffa17 	ldw	r2,-24(fp)
811389dc:	1000051e 	bne	r2,zero,811389f4 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
811389e0:	e0bfff17 	ldw	r2,-4(fp)
811389e4:	00c01684 	movi	r3,90
811389e8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811389ec:	0005883a 	mov	r2,zero
811389f0:	00002c06 	br	81138aa4 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
811389f4:	e0bffc17 	ldw	r2,-16(fp)
811389f8:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
811389fc:	e0fffc17 	ldw	r3,-16(fp)
81138a00:	e0bffe17 	ldw	r2,-8(fp)
81138a04:	1885883a 	add	r2,r3,r2
81138a08:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81138a0c:	e03ff715 	stw	zero,-36(fp)
81138a10:	00000c06 	br	81138a44 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
81138a14:	e0bff617 	ldw	r2,-40(fp)
81138a18:	e0fff517 	ldw	r3,-44(fp)
81138a1c:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
81138a20:	e0bff517 	ldw	r2,-44(fp)
81138a24:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
81138a28:	e0fff517 	ldw	r3,-44(fp)
81138a2c:	e0bffe17 	ldw	r2,-8(fp)
81138a30:	1885883a 	add	r2,r3,r2
81138a34:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
81138a38:	e0bff717 	ldw	r2,-36(fp)
81138a3c:	10800044 	addi	r2,r2,1
81138a40:	e0bff715 	stw	r2,-36(fp)
81138a44:	e0bffd17 	ldw	r2,-12(fp)
81138a48:	10bfffc4 	addi	r2,r2,-1
81138a4c:	e0fff717 	ldw	r3,-36(fp)
81138a50:	18bff036 	bltu	r3,r2,81138a14 <__reset+0xfb118a14>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
81138a54:	e0bff617 	ldw	r2,-40(fp)
81138a58:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
81138a5c:	e0bffa17 	ldw	r2,-24(fp)
81138a60:	e0fffc17 	ldw	r3,-16(fp)
81138a64:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
81138a68:	e0bffa17 	ldw	r2,-24(fp)
81138a6c:	e0fffc17 	ldw	r3,-16(fp)
81138a70:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
81138a74:	e0bffa17 	ldw	r2,-24(fp)
81138a78:	e0fffd17 	ldw	r3,-12(fp)
81138a7c:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81138a80:	e0bffa17 	ldw	r2,-24(fp)
81138a84:	e0fffd17 	ldw	r3,-12(fp)
81138a88:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81138a8c:	e0bffa17 	ldw	r2,-24(fp)
81138a90:	e0fffe17 	ldw	r3,-8(fp)
81138a94:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
81138a98:	e0bfff17 	ldw	r2,-4(fp)
81138a9c:	10000005 	stb	zero,0(r2)
    return (pmem);
81138aa0:	e0bffa17 	ldw	r2,-24(fp)
}
81138aa4:	e037883a 	mov	sp,fp
81138aa8:	df000017 	ldw	fp,0(sp)
81138aac:	dec00104 	addi	sp,sp,4
81138ab0:	f800283a 	ret

81138ab4 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
81138ab4:	defff804 	addi	sp,sp,-32
81138ab8:	de00012e 	bgeu	sp,et,81138ac0 <OSMemGet+0xc>
81138abc:	003b68fa 	trap	3
81138ac0:	df000715 	stw	fp,28(sp)
81138ac4:	df000704 	addi	fp,sp,28
81138ac8:	e13ffe15 	stw	r4,-8(fp)
81138acc:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81138ad0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81138ad4:	e0bfff17 	ldw	r2,-4(fp)
81138ad8:	1000021e 	bne	r2,zero,81138ae4 <OSMemGet+0x30>
        return ((void *)0);
81138adc:	0005883a 	mov	r2,zero
81138ae0:	00002e06 	br	81138b9c <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
81138ae4:	e0bffe17 	ldw	r2,-8(fp)
81138ae8:	1000051e 	bne	r2,zero,81138b00 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81138aec:	e0bfff17 	ldw	r2,-4(fp)
81138af0:	00c01804 	movi	r3,96
81138af4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81138af8:	0005883a 	mov	r2,zero
81138afc:	00002706 	br	81138b9c <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138b00:	0005303a 	rdctl	r2,status
81138b04:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138b08:	e0fffd17 	ldw	r3,-12(fp)
81138b0c:	00bfff84 	movi	r2,-2
81138b10:	1884703a 	and	r2,r3,r2
81138b14:	1001703a 	wrctl	status,r2
  
  return context;
81138b18:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138b1c:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
81138b20:	e0bffe17 	ldw	r2,-8(fp)
81138b24:	10800417 	ldw	r2,16(r2)
81138b28:	10001426 	beq	r2,zero,81138b7c <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
81138b2c:	e0bffe17 	ldw	r2,-8(fp)
81138b30:	10800117 	ldw	r2,4(r2)
81138b34:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
81138b38:	e0bffb17 	ldw	r2,-20(fp)
81138b3c:	10c00017 	ldw	r3,0(r2)
81138b40:	e0bffe17 	ldw	r2,-8(fp)
81138b44:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
81138b48:	e0bffe17 	ldw	r2,-8(fp)
81138b4c:	10800417 	ldw	r2,16(r2)
81138b50:	10ffffc4 	addi	r3,r2,-1
81138b54:	e0bffe17 	ldw	r2,-8(fp)
81138b58:	10c00415 	stw	r3,16(r2)
81138b5c:	e0bff917 	ldw	r2,-28(fp)
81138b60:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138b64:	e0bffa17 	ldw	r2,-24(fp)
81138b68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
81138b6c:	e0bfff17 	ldw	r2,-4(fp)
81138b70:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
81138b74:	e0bffb17 	ldw	r2,-20(fp)
81138b78:	00000806 	br	81138b9c <OSMemGet+0xe8>
81138b7c:	e0bff917 	ldw	r2,-28(fp)
81138b80:	e0bffc15 	stw	r2,-16(fp)
81138b84:	e0bffc17 	ldw	r2,-16(fp)
81138b88:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81138b8c:	e0bfff17 	ldw	r2,-4(fp)
81138b90:	00c01744 	movi	r3,93
81138b94:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
81138b98:	0005883a 	mov	r2,zero
}
81138b9c:	e037883a 	mov	sp,fp
81138ba0:	df000017 	ldw	fp,0(sp)
81138ba4:	dec00104 	addi	sp,sp,4
81138ba8:	f800283a 	ret

81138bac <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81138bac:	defff704 	addi	sp,sp,-36
81138bb0:	de00012e 	bgeu	sp,et,81138bb8 <OSMemNameGet+0xc>
81138bb4:	003b68fa 	trap	3
81138bb8:	dfc00815 	stw	ra,32(sp)
81138bbc:	df000715 	stw	fp,28(sp)
81138bc0:	df000704 	addi	fp,sp,28
81138bc4:	e13ffd15 	stw	r4,-12(fp)
81138bc8:	e17ffe15 	stw	r5,-8(fp)
81138bcc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138bd0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81138bd4:	e0bfff17 	ldw	r2,-4(fp)
81138bd8:	1000021e 	bne	r2,zero,81138be4 <OSMemNameGet+0x38>
        return (0);
81138bdc:	0005883a 	mov	r2,zero
81138be0:	00002b06 	br	81138c90 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81138be4:	e0bffd17 	ldw	r2,-12(fp)
81138be8:	1000051e 	bne	r2,zero,81138c00 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81138bec:	e0bfff17 	ldw	r2,-4(fp)
81138bf0:	00c01804 	movi	r3,96
81138bf4:	10c00005 	stb	r3,0(r2)
        return (0);
81138bf8:	0005883a 	mov	r2,zero
81138bfc:	00002406 	br	81138c90 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81138c00:	e0bffe17 	ldw	r2,-8(fp)
81138c04:	1000051e 	bne	r2,zero,81138c1c <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81138c08:	e0bfff17 	ldw	r2,-4(fp)
81138c0c:	00c00304 	movi	r3,12
81138c10:	10c00005 	stb	r3,0(r2)
        return (0);
81138c14:	0005883a 	mov	r2,zero
81138c18:	00001d06 	br	81138c90 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81138c1c:	d0a0a003 	ldbu	r2,-32128(gp)
81138c20:	10803fcc 	andi	r2,r2,255
81138c24:	10000526 	beq	r2,zero,81138c3c <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81138c28:	e0bfff17 	ldw	r2,-4(fp)
81138c2c:	00c00444 	movi	r3,17
81138c30:	10c00005 	stb	r3,0(r2)
        return (0);
81138c34:	0005883a 	mov	r2,zero
81138c38:	00001506 	br	81138c90 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138c3c:	0005303a 	rdctl	r2,status
81138c40:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138c44:	e0fffb17 	ldw	r3,-20(fp)
81138c48:	00bfff84 	movi	r2,-2
81138c4c:	1884703a 	and	r2,r3,r2
81138c50:	1001703a 	wrctl	status,r2
  
  return context;
81138c54:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
81138c58:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
81138c5c:	e0bffd17 	ldw	r2,-12(fp)
81138c60:	10800504 	addi	r2,r2,20
81138c64:	100b883a 	mov	r5,r2
81138c68:	e13ffe17 	ldw	r4,-8(fp)
81138c6c:	11369940 	call	81136994 <OS_StrCopy>
81138c70:	e0bffa05 	stb	r2,-24(fp)
81138c74:	e0bff917 	ldw	r2,-28(fp)
81138c78:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c7c:	e0bffc17 	ldw	r2,-16(fp)
81138c80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138c84:	e0bfff17 	ldw	r2,-4(fp)
81138c88:	10000005 	stb	zero,0(r2)
    return (len);
81138c8c:	e0bffa03 	ldbu	r2,-24(fp)
}
81138c90:	e037883a 	mov	sp,fp
81138c94:	dfc00117 	ldw	ra,4(sp)
81138c98:	df000017 	ldw	fp,0(sp)
81138c9c:	dec00204 	addi	sp,sp,8
81138ca0:	f800283a 	ret

81138ca4 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81138ca4:	defff604 	addi	sp,sp,-40
81138ca8:	de00012e 	bgeu	sp,et,81138cb0 <OSMemNameSet+0xc>
81138cac:	003b68fa 	trap	3
81138cb0:	dfc00915 	stw	ra,36(sp)
81138cb4:	df000815 	stw	fp,32(sp)
81138cb8:	df000804 	addi	fp,sp,32
81138cbc:	e13ffd15 	stw	r4,-12(fp)
81138cc0:	e17ffe15 	stw	r5,-8(fp)
81138cc4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138cc8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81138ccc:	e0bfff17 	ldw	r2,-4(fp)
81138cd0:	10003526 	beq	r2,zero,81138da8 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81138cd4:	e0bffd17 	ldw	r2,-12(fp)
81138cd8:	1000041e 	bne	r2,zero,81138cec <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81138cdc:	e0bfff17 	ldw	r2,-4(fp)
81138ce0:	00c01804 	movi	r3,96
81138ce4:	10c00005 	stb	r3,0(r2)
        return;
81138ce8:	00003006 	br	81138dac <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81138cec:	e0bffe17 	ldw	r2,-8(fp)
81138cf0:	1000041e 	bne	r2,zero,81138d04 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81138cf4:	e0bfff17 	ldw	r2,-4(fp)
81138cf8:	00c00304 	movi	r3,12
81138cfc:	10c00005 	stb	r3,0(r2)
        return;
81138d00:	00002a06 	br	81138dac <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81138d04:	d0a0a003 	ldbu	r2,-32128(gp)
81138d08:	10803fcc 	andi	r2,r2,255
81138d0c:	10000426 	beq	r2,zero,81138d20 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81138d10:	e0bfff17 	ldw	r2,-4(fp)
81138d14:	00c00484 	movi	r3,18
81138d18:	10c00005 	stb	r3,0(r2)
        return;
81138d1c:	00002306 	br	81138dac <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d20:	0005303a 	rdctl	r2,status
81138d24:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138d28:	e0fffc17 	ldw	r3,-16(fp)
81138d2c:	00bfff84 	movi	r2,-2
81138d30:	1884703a 	and	r2,r3,r2
81138d34:	1001703a 	wrctl	status,r2
  
  return context;
81138d38:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138d3c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81138d40:	e13ffe17 	ldw	r4,-8(fp)
81138d44:	1136a100 	call	81136a10 <OS_StrLen>
81138d48:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
81138d4c:	e0bffa03 	ldbu	r2,-24(fp)
81138d50:	10800830 	cmpltui	r2,r2,32
81138d54:	1000081e 	bne	r2,zero,81138d78 <OSMemNameSet+0xd4>
81138d58:	e0bff817 	ldw	r2,-32(fp)
81138d5c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138d60:	e0bff917 	ldw	r2,-28(fp)
81138d64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
81138d68:	e0bfff17 	ldw	r2,-4(fp)
81138d6c:	00c018c4 	movi	r3,99
81138d70:	10c00005 	stb	r3,0(r2)
        return;
81138d74:	00000d06 	br	81138dac <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
81138d78:	e0bffd17 	ldw	r2,-12(fp)
81138d7c:	10800504 	addi	r2,r2,20
81138d80:	e17ffe17 	ldw	r5,-8(fp)
81138d84:	1009883a 	mov	r4,r2
81138d88:	11369940 	call	81136994 <OS_StrCopy>
81138d8c:	e0bff817 	ldw	r2,-32(fp)
81138d90:	e0bffb15 	stw	r2,-20(fp)
81138d94:	e0bffb17 	ldw	r2,-20(fp)
81138d98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138d9c:	e0bfff17 	ldw	r2,-4(fp)
81138da0:	10000005 	stb	zero,0(r2)
81138da4:	00000106 	br	81138dac <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81138da8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81138dac:	e037883a 	mov	sp,fp
81138db0:	dfc00117 	ldw	ra,4(sp)
81138db4:	df000017 	ldw	fp,0(sp)
81138db8:	dec00204 	addi	sp,sp,8
81138dbc:	f800283a 	ret

81138dc0 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
81138dc0:	defff904 	addi	sp,sp,-28
81138dc4:	de00012e 	bgeu	sp,et,81138dcc <OSMemPut+0xc>
81138dc8:	003b68fa 	trap	3
81138dcc:	df000615 	stw	fp,24(sp)
81138dd0:	df000604 	addi	fp,sp,24
81138dd4:	e13ffe15 	stw	r4,-8(fp)
81138dd8:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138ddc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81138de0:	e0bffe17 	ldw	r2,-8(fp)
81138de4:	1000021e 	bne	r2,zero,81138df0 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81138de8:	00801804 	movi	r2,96
81138dec:	00002806 	br	81138e90 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
81138df0:	e0bfff17 	ldw	r2,-4(fp)
81138df4:	1000021e 	bne	r2,zero,81138e00 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
81138df8:	008017c4 	movi	r2,95
81138dfc:	00002406 	br	81138e90 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e00:	0005303a 	rdctl	r2,status
81138e04:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e08:	e0fffd17 	ldw	r3,-12(fp)
81138e0c:	00bfff84 	movi	r2,-2
81138e10:	1884703a 	and	r2,r3,r2
81138e14:	1001703a 	wrctl	status,r2
  
  return context;
81138e18:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138e1c:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
81138e20:	e0bffe17 	ldw	r2,-8(fp)
81138e24:	10c00417 	ldw	r3,16(r2)
81138e28:	e0bffe17 	ldw	r2,-8(fp)
81138e2c:	10800317 	ldw	r2,12(r2)
81138e30:	18800636 	bltu	r3,r2,81138e4c <OSMemPut+0x8c>
81138e34:	e0bffa17 	ldw	r2,-24(fp)
81138e38:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138e3c:	e0bffb17 	ldw	r2,-20(fp)
81138e40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
81138e44:	00801784 	movi	r2,94
81138e48:	00001106 	br	81138e90 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
81138e4c:	e0bffe17 	ldw	r2,-8(fp)
81138e50:	10c00117 	ldw	r3,4(r2)
81138e54:	e0bfff17 	ldw	r2,-4(fp)
81138e58:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
81138e5c:	e0bffe17 	ldw	r2,-8(fp)
81138e60:	e0ffff17 	ldw	r3,-4(fp)
81138e64:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
81138e68:	e0bffe17 	ldw	r2,-8(fp)
81138e6c:	10800417 	ldw	r2,16(r2)
81138e70:	10c00044 	addi	r3,r2,1
81138e74:	e0bffe17 	ldw	r2,-8(fp)
81138e78:	10c00415 	stw	r3,16(r2)
81138e7c:	e0bffa17 	ldw	r2,-24(fp)
81138e80:	e0bffc15 	stw	r2,-16(fp)
81138e84:	e0bffc17 	ldw	r2,-16(fp)
81138e88:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
81138e8c:	0005883a 	mov	r2,zero
}
81138e90:	e037883a 	mov	sp,fp
81138e94:	df000017 	ldw	fp,0(sp)
81138e98:	dec00104 	addi	sp,sp,4
81138e9c:	f800283a 	ret

81138ea0 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
81138ea0:	defffa04 	addi	sp,sp,-24
81138ea4:	de00012e 	bgeu	sp,et,81138eac <OSMemQuery+0xc>
81138ea8:	003b68fa 	trap	3
81138eac:	df000515 	stw	fp,20(sp)
81138eb0:	df000504 	addi	fp,sp,20
81138eb4:	e13ffe15 	stw	r4,-8(fp)
81138eb8:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138ebc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81138ec0:	e0bffe17 	ldw	r2,-8(fp)
81138ec4:	1000021e 	bne	r2,zero,81138ed0 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81138ec8:	00801804 	movi	r2,96
81138ecc:	00002c06 	br	81138f80 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
81138ed0:	e0bfff17 	ldw	r2,-4(fp)
81138ed4:	1000021e 	bne	r2,zero,81138ee0 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
81138ed8:	00801844 	movi	r2,97
81138edc:	00002806 	br	81138f80 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138ee0:	0005303a 	rdctl	r2,status
81138ee4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138ee8:	e0fffc17 	ldw	r3,-16(fp)
81138eec:	00bfff84 	movi	r2,-2
81138ef0:	1884703a 	and	r2,r3,r2
81138ef4:	1001703a 	wrctl	status,r2
  
  return context;
81138ef8:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138efc:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
81138f00:	e0bffe17 	ldw	r2,-8(fp)
81138f04:	10c00017 	ldw	r3,0(r2)
81138f08:	e0bfff17 	ldw	r2,-4(fp)
81138f0c:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
81138f10:	e0bffe17 	ldw	r2,-8(fp)
81138f14:	10c00117 	ldw	r3,4(r2)
81138f18:	e0bfff17 	ldw	r2,-4(fp)
81138f1c:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
81138f20:	e0bffe17 	ldw	r2,-8(fp)
81138f24:	10c00217 	ldw	r3,8(r2)
81138f28:	e0bfff17 	ldw	r2,-4(fp)
81138f2c:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
81138f30:	e0bffe17 	ldw	r2,-8(fp)
81138f34:	10c00317 	ldw	r3,12(r2)
81138f38:	e0bfff17 	ldw	r2,-4(fp)
81138f3c:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
81138f40:	e0bffe17 	ldw	r2,-8(fp)
81138f44:	10c00417 	ldw	r3,16(r2)
81138f48:	e0bfff17 	ldw	r2,-4(fp)
81138f4c:	10c00415 	stw	r3,16(r2)
81138f50:	e0bffb17 	ldw	r2,-20(fp)
81138f54:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138f58:	e0bffd17 	ldw	r2,-12(fp)
81138f5c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
81138f60:	e0bfff17 	ldw	r2,-4(fp)
81138f64:	10c00317 	ldw	r3,12(r2)
81138f68:	e0bfff17 	ldw	r2,-4(fp)
81138f6c:	10800417 	ldw	r2,16(r2)
81138f70:	1887c83a 	sub	r3,r3,r2
81138f74:	e0bfff17 	ldw	r2,-4(fp)
81138f78:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
81138f7c:	0005883a 	mov	r2,zero
}
81138f80:	e037883a 	mov	sp,fp
81138f84:	df000017 	ldw	fp,0(sp)
81138f88:	dec00104 	addi	sp,sp,4
81138f8c:	f800283a 	ret

81138f90 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
81138f90:	defffc04 	addi	sp,sp,-16
81138f94:	de00012e 	bgeu	sp,et,81138f9c <OS_MemInit+0xc>
81138f98:	003b68fa 	trap	3
81138f9c:	dfc00315 	stw	ra,12(sp)
81138fa0:	df000215 	stw	fp,8(sp)
81138fa4:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
81138fa8:	01430c04 	movi	r5,3120
81138fac:	012045b4 	movhi	r4,33046
81138fb0:	210ee704 	addi	r4,r4,15260
81138fb4:	11367740 	call	81136774 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
81138fb8:	00a045b4 	movhi	r2,33046
81138fbc:	108ee704 	addi	r2,r2,15260
81138fc0:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81138fc4:	e03fff0d 	sth	zero,-4(fp)
81138fc8:	00001306 	br	81139018 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
81138fcc:	e0bfff0b 	ldhu	r2,-4(fp)
81138fd0:	10800044 	addi	r2,r2,1
81138fd4:	10c00d24 	muli	r3,r2,52
81138fd8:	00a045b4 	movhi	r2,33046
81138fdc:	108ee704 	addi	r2,r2,15260
81138fe0:	1887883a 	add	r3,r3,r2
81138fe4:	e0bffe17 	ldw	r2,-8(fp)
81138fe8:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
81138fec:	e0bffe17 	ldw	r2,-8(fp)
81138ff0:	00c00fc4 	movi	r3,63
81138ff4:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
81138ff8:	e0bffe17 	ldw	r2,-8(fp)
81138ffc:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
81139000:	e0bffe17 	ldw	r2,-8(fp)
81139004:	10800d04 	addi	r2,r2,52
81139008:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113900c:	e0bfff0b 	ldhu	r2,-4(fp)
81139010:	10800044 	addi	r2,r2,1
81139014:	e0bfff0d 	sth	r2,-4(fp)
81139018:	e0bfff0b 	ldhu	r2,-4(fp)
8113901c:	10800ef0 	cmpltui	r2,r2,59
81139020:	103fea1e 	bne	r2,zero,81138fcc <__reset+0xfb118fcc>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
81139024:	e0bffe17 	ldw	r2,-8(fp)
81139028:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113902c:	e0bffe17 	ldw	r2,-8(fp)
81139030:	00c00fc4 	movi	r3,63
81139034:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
81139038:	e0bffe17 	ldw	r2,-8(fp)
8113903c:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
81139040:	00a045b4 	movhi	r2,33046
81139044:	108ee704 	addi	r2,r2,15260
81139048:	d0a09a15 	stw	r2,-32152(gp)
#endif
}
8113904c:	0001883a 	nop
81139050:	e037883a 	mov	sp,fp
81139054:	dfc00117 	ldw	ra,4(sp)
81139058:	df000017 	ldw	fp,0(sp)
8113905c:	dec00204 	addi	sp,sp,8
81139060:	f800283a 	ret

81139064 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
81139064:	defff704 	addi	sp,sp,-36
81139068:	de00012e 	bgeu	sp,et,81139070 <OSMutexAccept+0xc>
8113906c:	003b68fa 	trap	3
81139070:	df000815 	stw	fp,32(sp)
81139074:	df000804 	addi	fp,sp,32
81139078:	e13ffe15 	stw	r4,-8(fp)
8113907c:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81139080:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
81139084:	e0bfff17 	ldw	r2,-4(fp)
81139088:	1000021e 	bne	r2,zero,81139094 <OSMutexAccept+0x30>
        return (OS_FALSE);
8113908c:	0005883a 	mov	r2,zero
81139090:	00005b06 	br	81139200 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81139094:	e0bffe17 	ldw	r2,-8(fp)
81139098:	1000051e 	bne	r2,zero,811390b0 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113909c:	e0bfff17 	ldw	r2,-4(fp)
811390a0:	00c00104 	movi	r3,4
811390a4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811390a8:	0005883a 	mov	r2,zero
811390ac:	00005406 	br	81139200 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
811390b0:	e0bffe17 	ldw	r2,-8(fp)
811390b4:	10800003 	ldbu	r2,0(r2)
811390b8:	10803fcc 	andi	r2,r2,255
811390bc:	10800120 	cmpeqi	r2,r2,4
811390c0:	1000051e 	bne	r2,zero,811390d8 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
811390c4:	e0bfff17 	ldw	r2,-4(fp)
811390c8:	00c00044 	movi	r3,1
811390cc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811390d0:	0005883a 	mov	r2,zero
811390d4:	00004a06 	br	81139200 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
811390d8:	d0a0a003 	ldbu	r2,-32128(gp)
811390dc:	10803fcc 	andi	r2,r2,255
811390e0:	10000526 	beq	r2,zero,811390f8 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
811390e4:	e0bfff17 	ldw	r2,-4(fp)
811390e8:	00c00084 	movi	r3,2
811390ec:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811390f0:	0005883a 	mov	r2,zero
811390f4:	00004206 	br	81139200 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811390f8:	0005303a 	rdctl	r2,status
811390fc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139100:	e0fffd17 	ldw	r3,-12(fp)
81139104:	00bfff84 	movi	r2,-2
81139108:	1884703a 	and	r2,r3,r2
8113910c:	1001703a 	wrctl	status,r2
  
  return context;
81139110:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
81139114:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
81139118:	e0bffe17 	ldw	r2,-8(fp)
8113911c:	1080020b 	ldhu	r2,8(r2)
81139120:	10bfffcc 	andi	r2,r2,65535
81139124:	1004d23a 	srli	r2,r2,8
81139128:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113912c:	e0bffe17 	ldw	r2,-8(fp)
81139130:	1080020b 	ldhu	r2,8(r2)
81139134:	10bfffcc 	andi	r2,r2,65535
81139138:	10803fcc 	andi	r2,r2,255
8113913c:	10803fd8 	cmpnei	r2,r2,255
81139140:	1000281e 	bne	r2,zero,811391e4 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
81139144:	e0bffe17 	ldw	r2,-8(fp)
81139148:	10c0020b 	ldhu	r3,8(r2)
8113914c:	00bfc004 	movi	r2,-256
81139150:	1884703a 	and	r2,r3,r2
81139154:	1007883a 	mov	r3,r2
81139158:	e0bffe17 	ldw	r2,-8(fp)
8113915c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
81139160:	e0bffe17 	ldw	r2,-8(fp)
81139164:	10c0020b 	ldhu	r3,8(r2)
81139168:	d0a0a117 	ldw	r2,-32124(gp)
8113916c:	10800c83 	ldbu	r2,50(r2)
81139170:	10803fcc 	andi	r2,r2,255
81139174:	1884b03a 	or	r2,r3,r2
81139178:	1007883a 	mov	r3,r2
8113917c:	e0bffe17 	ldw	r2,-8(fp)
81139180:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
81139184:	d0e0a117 	ldw	r3,-32124(gp)
81139188:	e0bffe17 	ldw	r2,-8(fp)
8113918c:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
81139190:	d0a0a117 	ldw	r2,-32124(gp)
81139194:	10800c83 	ldbu	r2,50(r2)
81139198:	10803fcc 	andi	r2,r2,255
8113919c:	e0fffa03 	ldbu	r3,-24(fp)
811391a0:	18800836 	bltu	r3,r2,811391c4 <OSMutexAccept+0x160>
811391a4:	e0bff817 	ldw	r2,-32(fp)
811391a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811391ac:	e0bff917 	ldw	r2,-28(fp)
811391b0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
811391b4:	e0bfff17 	ldw	r2,-4(fp)
811391b8:	00c01e04 	movi	r3,120
811391bc:	10c00005 	stb	r3,0(r2)
811391c0:	00000606 	br	811391dc <OSMutexAccept+0x178>
811391c4:	e0bff817 	ldw	r2,-32(fp)
811391c8:	e0bffb15 	stw	r2,-20(fp)
811391cc:	e0bffb17 	ldw	r2,-20(fp)
811391d0:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
811391d4:	e0bfff17 	ldw	r2,-4(fp)
811391d8:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
811391dc:	00800044 	movi	r2,1
811391e0:	00000706 	br	81139200 <OSMutexAccept+0x19c>
811391e4:	e0bff817 	ldw	r2,-32(fp)
811391e8:	e0bffc15 	stw	r2,-16(fp)
811391ec:	e0bffc17 	ldw	r2,-16(fp)
811391f0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811391f4:	e0bfff17 	ldw	r2,-4(fp)
811391f8:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
811391fc:	0005883a 	mov	r2,zero
}
81139200:	e037883a 	mov	sp,fp
81139204:	df000017 	ldw	fp,0(sp)
81139208:	dec00104 	addi	sp,sp,4
8113920c:	f800283a 	ret

81139210 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
81139210:	defff604 	addi	sp,sp,-40
81139214:	de00012e 	bgeu	sp,et,8113921c <OSMutexCreate+0xc>
81139218:	003b68fa 	trap	3
8113921c:	dfc00915 	stw	ra,36(sp)
81139220:	df000815 	stw	fp,32(sp)
81139224:	df000804 	addi	fp,sp,32
81139228:	2005883a 	mov	r2,r4
8113922c:	e17fff15 	stw	r5,-4(fp)
81139230:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139234:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81139238:	e0bfff17 	ldw	r2,-4(fp)
8113923c:	1000021e 	bne	r2,zero,81139248 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
81139240:	0005883a 	mov	r2,zero
81139244:	00006106 	br	811393cc <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
81139248:	e0bffe03 	ldbu	r2,-8(fp)
8113924c:	10800ab0 	cmpltui	r2,r2,42
81139250:	1000051e 	bne	r2,zero,81139268 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
81139254:	e0bfff17 	ldw	r2,-4(fp)
81139258:	00c00a84 	movi	r3,42
8113925c:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81139260:	0005883a 	mov	r2,zero
81139264:	00005906 	br	811393cc <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139268:	d0a0a003 	ldbu	r2,-32128(gp)
8113926c:	10803fcc 	andi	r2,r2,255
81139270:	10000526 	beq	r2,zero,81139288 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
81139274:	e0bfff17 	ldw	r2,-4(fp)
81139278:	00c00404 	movi	r3,16
8113927c:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81139280:	0005883a 	mov	r2,zero
81139284:	00005106 	br	811393cc <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139288:	0005303a 	rdctl	r2,status
8113928c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139290:	e0fffd17 	ldw	r3,-12(fp)
81139294:	00bfff84 	movi	r2,-2
81139298:	1884703a 	and	r2,r3,r2
8113929c:	1001703a 	wrctl	status,r2
  
  return context;
811392a0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811392a4:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
811392a8:	e0fffe03 	ldbu	r3,-8(fp)
811392ac:	00a045f4 	movhi	r2,33047
811392b0:	10a46104 	addi	r2,r2,-28284
811392b4:	18c7883a 	add	r3,r3,r3
811392b8:	18c7883a 	add	r3,r3,r3
811392bc:	10c5883a 	add	r2,r2,r3
811392c0:	10800017 	ldw	r2,0(r2)
811392c4:	10000926 	beq	r2,zero,811392ec <OSMutexCreate+0xdc>
811392c8:	e0bff817 	ldw	r2,-32(fp)
811392cc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811392d0:	e0bff917 	ldw	r2,-28(fp)
811392d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
811392d8:	e0bfff17 	ldw	r2,-4(fp)
811392dc:	00c00a04 	movi	r3,40
811392e0:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811392e4:	0005883a 	mov	r2,zero
811392e8:	00003806 	br	811393cc <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
811392ec:	e0fffe03 	ldbu	r3,-8(fp)
811392f0:	00a045f4 	movhi	r2,33047
811392f4:	10a46104 	addi	r2,r2,-28284
811392f8:	18c7883a 	add	r3,r3,r3
811392fc:	18c7883a 	add	r3,r3,r3
81139300:	10c5883a 	add	r2,r2,r3
81139304:	00c00044 	movi	r3,1
81139308:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113930c:	d0a09f17 	ldw	r2,-32132(gp)
81139310:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
81139314:	e0bffb17 	ldw	r2,-20(fp)
81139318:	1000101e 	bne	r2,zero,8113935c <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113931c:	e0fffe03 	ldbu	r3,-8(fp)
81139320:	00a045f4 	movhi	r2,33047
81139324:	10a46104 	addi	r2,r2,-28284
81139328:	18c7883a 	add	r3,r3,r3
8113932c:	18c7883a 	add	r3,r3,r3
81139330:	10c5883a 	add	r2,r2,r3
81139334:	10000015 	stw	zero,0(r2)
81139338:	e0bff817 	ldw	r2,-32(fp)
8113933c:	e0bffa15 	stw	r2,-24(fp)
81139340:	e0bffa17 	ldw	r2,-24(fp)
81139344:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
81139348:	e0bfff17 	ldw	r2,-4(fp)
8113934c:	00c00104 	movi	r3,4
81139350:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139354:	e0bffb17 	ldw	r2,-20(fp)
81139358:	00001c06 	br	811393cc <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113935c:	d0a09f17 	ldw	r2,-32132(gp)
81139360:	10800117 	ldw	r2,4(r2)
81139364:	d0a09f15 	stw	r2,-32132(gp)
81139368:	e0bff817 	ldw	r2,-32(fp)
8113936c:	e0bffc15 	stw	r2,-16(fp)
81139370:	e0bffc17 	ldw	r2,-16(fp)
81139374:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
81139378:	e0bffb17 	ldw	r2,-20(fp)
8113937c:	00c00104 	movi	r3,4
81139380:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
81139384:	e0bffe03 	ldbu	r2,-8(fp)
81139388:	1004923a 	slli	r2,r2,8
8113938c:	10803fd4 	ori	r2,r2,255
81139390:	1007883a 	mov	r3,r2
81139394:	e0bffb17 	ldw	r2,-20(fp)
81139398:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113939c:	e0bffb17 	ldw	r2,-20(fp)
811393a0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
811393a4:	e0bffb17 	ldw	r2,-20(fp)
811393a8:	00c00fc4 	movi	r3,63
811393ac:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
811393b0:	e0bffb17 	ldw	r2,-20(fp)
811393b4:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
811393b8:	e13ffb17 	ldw	r4,-20(fp)
811393bc:	113635c0 	call	8113635c <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
811393c0:	e0bfff17 	ldw	r2,-4(fp)
811393c4:	10000005 	stb	zero,0(r2)
    return (pevent);
811393c8:	e0bffb17 	ldw	r2,-20(fp)
}
811393cc:	e037883a 	mov	sp,fp
811393d0:	dfc00117 	ldw	ra,4(sp)
811393d4:	df000017 	ldw	fp,0(sp)
811393d8:	dec00204 	addi	sp,sp,8
811393dc:	f800283a 	ret

811393e0 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
811393e0:	defff004 	addi	sp,sp,-64
811393e4:	de00012e 	bgeu	sp,et,811393ec <OSMutexDel+0xc>
811393e8:	003b68fa 	trap	3
811393ec:	dfc00f15 	stw	ra,60(sp)
811393f0:	df000e15 	stw	fp,56(sp)
811393f4:	df000e04 	addi	fp,sp,56
811393f8:	e13ffd15 	stw	r4,-12(fp)
811393fc:	2805883a 	mov	r2,r5
81139400:	e1bfff15 	stw	r6,-4(fp)
81139404:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139408:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113940c:	e0bfff17 	ldw	r2,-4(fp)
81139410:	1000021e 	bne	r2,zero,8113941c <OSMutexDel+0x3c>
        return (pevent);
81139414:	e0bffd17 	ldw	r2,-12(fp)
81139418:	0000ad06 	br	811396d0 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113941c:	e0bffd17 	ldw	r2,-12(fp)
81139420:	1000051e 	bne	r2,zero,81139438 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81139424:	e0bfff17 	ldw	r2,-4(fp)
81139428:	00c00104 	movi	r3,4
8113942c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139430:	e0bffd17 	ldw	r2,-12(fp)
81139434:	0000a606 	br	811396d0 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81139438:	e0bffd17 	ldw	r2,-12(fp)
8113943c:	10800003 	ldbu	r2,0(r2)
81139440:	10803fcc 	andi	r2,r2,255
81139444:	10800120 	cmpeqi	r2,r2,4
81139448:	1000051e 	bne	r2,zero,81139460 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113944c:	e0bfff17 	ldw	r2,-4(fp)
81139450:	00c00044 	movi	r3,1
81139454:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139458:	e0bffd17 	ldw	r2,-12(fp)
8113945c:	00009c06 	br	811396d0 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139460:	d0a0a003 	ldbu	r2,-32128(gp)
81139464:	10803fcc 	andi	r2,r2,255
81139468:	10000526 	beq	r2,zero,81139480 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113946c:	e0bfff17 	ldw	r2,-4(fp)
81139470:	00c003c4 	movi	r3,15
81139474:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139478:	e0bffd17 	ldw	r2,-12(fp)
8113947c:	00009406 	br	811396d0 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139480:	0005303a 	rdctl	r2,status
81139484:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139488:	e0fffc17 	ldw	r3,-16(fp)
8113948c:	00bfff84 	movi	r2,-2
81139490:	1884703a 	and	r2,r3,r2
81139494:	1001703a 	wrctl	status,r2
  
  return context;
81139498:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113949c:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
811394a0:	e0bffd17 	ldw	r2,-12(fp)
811394a4:	10800283 	ldbu	r2,10(r2)
811394a8:	10803fcc 	andi	r2,r2,255
811394ac:	10000326 	beq	r2,zero,811394bc <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811394b0:	00800044 	movi	r2,1
811394b4:	e0bff205 	stb	r2,-56(fp)
811394b8:	00000106 	br	811394c0 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811394bc:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
811394c0:	e0bffe03 	ldbu	r2,-8(fp)
811394c4:	10000326 	beq	r2,zero,811394d4 <OSMutexDel+0xf4>
811394c8:	10800060 	cmpeqi	r2,r2,1
811394cc:	10002f1e 	bne	r2,zero,8113958c <OSMutexDel+0x1ac>
811394d0:	00007406 	br	811396a4 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
811394d4:	e0bff203 	ldbu	r2,-56(fp)
811394d8:	1000221e 	bne	r2,zero,81139564 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
811394dc:	e0bffd17 	ldw	r2,-12(fp)
811394e0:	00c00fc4 	movi	r3,63
811394e4:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
811394e8:	e0bffd17 	ldw	r2,-12(fp)
811394ec:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
811394f0:	e0bffd17 	ldw	r2,-12(fp)
811394f4:	1080020b 	ldhu	r2,8(r2)
811394f8:	10bfffcc 	andi	r2,r2,65535
811394fc:	1004d23a 	srli	r2,r2,8
81139500:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
81139504:	e0fff603 	ldbu	r3,-40(fp)
81139508:	00a045f4 	movhi	r2,33047
8113950c:	10a46104 	addi	r2,r2,-28284
81139510:	18c7883a 	add	r3,r3,r3
81139514:	18c7883a 	add	r3,r3,r3
81139518:	10c5883a 	add	r2,r2,r3
8113951c:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81139520:	e0bffd17 	ldw	r2,-12(fp)
81139524:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
81139528:	d0e09f17 	ldw	r3,-32132(gp)
8113952c:	e0bffd17 	ldw	r2,-12(fp)
81139530:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
81139534:	e0bffd17 	ldw	r2,-12(fp)
81139538:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113953c:	e0bffd17 	ldw	r2,-12(fp)
81139540:	d0a09f15 	stw	r2,-32132(gp)
81139544:	e0bff417 	ldw	r2,-48(fp)
81139548:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113954c:	e0bff517 	ldw	r2,-44(fp)
81139550:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
81139554:	e0bfff17 	ldw	r2,-4(fp)
81139558:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113955c:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
81139560:	00005a06 	br	811396cc <OSMutexDel+0x2ec>
81139564:	e0bff417 	ldw	r2,-48(fp)
81139568:	e0bff715 	stw	r2,-36(fp)
8113956c:	e0bff717 	ldw	r2,-36(fp)
81139570:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
81139574:	e0bfff17 	ldw	r2,-4(fp)
81139578:	00c01244 	movi	r3,73
8113957c:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
81139580:	e0bffd17 	ldw	r2,-12(fp)
81139584:	e0bff315 	stw	r2,-52(fp)
             }
             break;
81139588:	00005006 	br	811396cc <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113958c:	e0bffd17 	ldw	r2,-12(fp)
81139590:	1080020b 	ldhu	r2,8(r2)
81139594:	10bfffcc 	andi	r2,r2,65535
81139598:	1004d23a 	srli	r2,r2,8
8113959c:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
811395a0:	e0bffd17 	ldw	r2,-12(fp)
811395a4:	1080020b 	ldhu	r2,8(r2)
811395a8:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
811395ac:	e0bffd17 	ldw	r2,-12(fp)
811395b0:	10800117 	ldw	r2,4(r2)
811395b4:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
811395b8:	e0bffa17 	ldw	r2,-24(fp)
811395bc:	10000f26 	beq	r2,zero,811395fc <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
811395c0:	e0bffa17 	ldw	r2,-24(fp)
811395c4:	10800c83 	ldbu	r2,50(r2)
811395c8:	10c03fcc 	andi	r3,r2,255
811395cc:	e0bff603 	ldbu	r2,-40(fp)
811395d0:	18800a1e 	bne	r3,r2,811395fc <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
811395d4:	e0bff903 	ldbu	r2,-28(fp)
811395d8:	100b883a 	mov	r5,r2
811395dc:	e13ffa17 	ldw	r4,-24(fp)
811395e0:	113a01c0 	call	8113a01c <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
811395e4:	00000506 	br	811395fc <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
811395e8:	000f883a 	mov	r7,zero
811395ec:	01800404 	movi	r6,16
811395f0:	000b883a 	mov	r5,zero
811395f4:	e13ffd17 	ldw	r4,-12(fp)
811395f8:	1135d840 	call	81135d84 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
811395fc:	e0bffd17 	ldw	r2,-12(fp)
81139600:	10800283 	ldbu	r2,10(r2)
81139604:	10803fcc 	andi	r2,r2,255
81139608:	103ff71e 	bne	r2,zero,811395e8 <__reset+0xfb1195e8>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113960c:	e0bffd17 	ldw	r2,-12(fp)
81139610:	00c00fc4 	movi	r3,63
81139614:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81139618:	e0bffd17 	ldw	r2,-12(fp)
8113961c:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81139620:	e0bffd17 	ldw	r2,-12(fp)
81139624:	1080020b 	ldhu	r2,8(r2)
81139628:	10bfffcc 	andi	r2,r2,65535
8113962c:	1004d23a 	srli	r2,r2,8
81139630:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
81139634:	e0fff603 	ldbu	r3,-40(fp)
81139638:	00a045f4 	movhi	r2,33047
8113963c:	10a46104 	addi	r2,r2,-28284
81139640:	18c7883a 	add	r3,r3,r3
81139644:	18c7883a 	add	r3,r3,r3
81139648:	10c5883a 	add	r2,r2,r3
8113964c:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81139650:	e0bffd17 	ldw	r2,-12(fp)
81139654:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
81139658:	d0e09f17 	ldw	r3,-32132(gp)
8113965c:	e0bffd17 	ldw	r2,-12(fp)
81139660:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
81139664:	e0bffd17 	ldw	r2,-12(fp)
81139668:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113966c:	e0bffd17 	ldw	r2,-12(fp)
81139670:	d0a09f15 	stw	r2,-32132(gp)
81139674:	e0bff417 	ldw	r2,-48(fp)
81139678:	e0bff815 	stw	r2,-32(fp)
8113967c:	e0bff817 	ldw	r2,-32(fp)
81139680:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81139684:	e0bff203 	ldbu	r2,-56(fp)
81139688:	10800058 	cmpnei	r2,r2,1
8113968c:	1000011e 	bne	r2,zero,81139694 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81139690:	11368400 	call	81136840 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
81139694:	e0bfff17 	ldw	r2,-4(fp)
81139698:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113969c:	e03ff315 	stw	zero,-52(fp)
             break;
811396a0:	00000a06 	br	811396cc <OSMutexDel+0x2ec>
811396a4:	e0bff417 	ldw	r2,-48(fp)
811396a8:	e0bffb15 	stw	r2,-20(fp)
811396ac:	e0bffb17 	ldw	r2,-20(fp)
811396b0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
811396b4:	e0bfff17 	ldw	r2,-4(fp)
811396b8:	00c001c4 	movi	r3,7
811396bc:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
811396c0:	e0bffd17 	ldw	r2,-12(fp)
811396c4:	e0bff315 	stw	r2,-52(fp)
             break;
811396c8:	0001883a 	nop
    }
    return (pevent_return);
811396cc:	e0bff317 	ldw	r2,-52(fp)
}
811396d0:	e037883a 	mov	sp,fp
811396d4:	dfc00117 	ldw	ra,4(sp)
811396d8:	df000017 	ldw	fp,0(sp)
811396dc:	dec00204 	addi	sp,sp,8
811396e0:	f800283a 	ret

811396e4 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
811396e4:	deffee04 	addi	sp,sp,-72
811396e8:	de00012e 	bgeu	sp,et,811396f0 <OSMutexPend+0xc>
811396ec:	003b68fa 	trap	3
811396f0:	dfc01115 	stw	ra,68(sp)
811396f4:	df001015 	stw	fp,64(sp)
811396f8:	df001004 	addi	fp,sp,64
811396fc:	e13ffd15 	stw	r4,-12(fp)
81139700:	2805883a 	mov	r2,r5
81139704:	e1bfff15 	stw	r6,-4(fp)
81139708:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113970c:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81139710:	e0bfff17 	ldw	r2,-4(fp)
81139714:	10015626 	beq	r2,zero,81139c70 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81139718:	e0bffd17 	ldw	r2,-12(fp)
8113971c:	1000041e 	bne	r2,zero,81139730 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81139720:	e0bfff17 	ldw	r2,-4(fp)
81139724:	00c00104 	movi	r3,4
81139728:	10c00005 	stb	r3,0(r2)
        return;
8113972c:	00015106 	br	81139c74 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81139730:	e0bffd17 	ldw	r2,-12(fp)
81139734:	10800003 	ldbu	r2,0(r2)
81139738:	10803fcc 	andi	r2,r2,255
8113973c:	10800120 	cmpeqi	r2,r2,4
81139740:	1000041e 	bne	r2,zero,81139754 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81139744:	e0bfff17 	ldw	r2,-4(fp)
81139748:	00c00044 	movi	r3,1
8113974c:	10c00005 	stb	r3,0(r2)
        return;
81139750:	00014806 	br	81139c74 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139754:	d0a0a003 	ldbu	r2,-32128(gp)
81139758:	10803fcc 	andi	r2,r2,255
8113975c:	10000426 	beq	r2,zero,81139770 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81139760:	e0bfff17 	ldw	r2,-4(fp)
81139764:	00c00084 	movi	r3,2
81139768:	10c00005 	stb	r3,0(r2)
        return;
8113976c:	00014106 	br	81139c74 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81139770:	d0a08e03 	ldbu	r2,-32200(gp)
81139774:	10803fcc 	andi	r2,r2,255
81139778:	10000426 	beq	r2,zero,8113978c <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113977c:	e0bfff17 	ldw	r2,-4(fp)
81139780:	00c00344 	movi	r3,13
81139784:	10c00005 	stb	r3,0(r2)
        return;
81139788:	00013a06 	br	81139c74 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113978c:	0005303a 	rdctl	r2,status
81139790:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139794:	e0fffc17 	ldw	r3,-16(fp)
81139798:	00bfff84 	movi	r2,-2
8113979c:	1884703a 	and	r2,r3,r2
811397a0:	1001703a 	wrctl	status,r2
  
  return context;
811397a4:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
811397a8:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
811397ac:	e0bffd17 	ldw	r2,-12(fp)
811397b0:	1080020b 	ldhu	r2,8(r2)
811397b4:	10bfffcc 	andi	r2,r2,65535
811397b8:	1004d23a 	srli	r2,r2,8
811397bc:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
811397c0:	e0bffd17 	ldw	r2,-12(fp)
811397c4:	1080020b 	ldhu	r2,8(r2)
811397c8:	10803fcc 	andi	r2,r2,255
811397cc:	10803fd8 	cmpnei	r2,r2,255
811397d0:	1000271e 	bne	r2,zero,81139870 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
811397d4:	e0bffd17 	ldw	r2,-12(fp)
811397d8:	10c0020b 	ldhu	r3,8(r2)
811397dc:	00bfc004 	movi	r2,-256
811397e0:	1884703a 	and	r2,r3,r2
811397e4:	1007883a 	mov	r3,r2
811397e8:	e0bffd17 	ldw	r2,-12(fp)
811397ec:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
811397f0:	e0bffd17 	ldw	r2,-12(fp)
811397f4:	10c0020b 	ldhu	r3,8(r2)
811397f8:	d0a0a117 	ldw	r2,-32124(gp)
811397fc:	10800c83 	ldbu	r2,50(r2)
81139800:	10803fcc 	andi	r2,r2,255
81139804:	1884b03a 	or	r2,r3,r2
81139808:	1007883a 	mov	r3,r2
8113980c:	e0bffd17 	ldw	r2,-12(fp)
81139810:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
81139814:	d0e0a117 	ldw	r3,-32124(gp)
81139818:	e0bffd17 	ldw	r2,-12(fp)
8113981c:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
81139820:	d0a0a117 	ldw	r2,-32124(gp)
81139824:	10800c83 	ldbu	r2,50(r2)
81139828:	10803fcc 	andi	r2,r2,255
8113982c:	e0fff303 	ldbu	r3,-52(fp)
81139830:	18800836 	bltu	r3,r2,81139854 <OSMutexPend+0x170>
81139834:	e0bff117 	ldw	r2,-60(fp)
81139838:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113983c:	e0bff217 	ldw	r2,-56(fp)
81139840:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
81139844:	e0bfff17 	ldw	r2,-4(fp)
81139848:	00c01e04 	movi	r3,120
8113984c:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
81139850:	00010806 	br	81139c74 <OSMutexPend+0x590>
81139854:	e0bff117 	ldw	r2,-60(fp)
81139858:	e0bff415 	stw	r2,-48(fp)
8113985c:	e0bff417 	ldw	r2,-48(fp)
81139860:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81139864:	e0bfff17 	ldw	r2,-4(fp)
81139868:	10000005 	stb	zero,0(r2)
        }
        return;
8113986c:	00010106 	br	81139c74 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
81139870:	e0bffd17 	ldw	r2,-12(fp)
81139874:	1080020b 	ldhu	r2,8(r2)
81139878:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113987c:	e0bffd17 	ldw	r2,-12(fp)
81139880:	10800117 	ldw	r2,4(r2)
81139884:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
81139888:	e0bff717 	ldw	r2,-36(fp)
8113988c:	10800c83 	ldbu	r2,50(r2)
81139890:	10803fcc 	andi	r2,r2,255
81139894:	e0fff303 	ldbu	r3,-52(fp)
81139898:	1880b92e 	bgeu	r3,r2,81139b80 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113989c:	d0a0a117 	ldw	r2,-32124(gp)
811398a0:	10800c83 	ldbu	r2,50(r2)
811398a4:	10c03fcc 	andi	r3,r2,255
811398a8:	e0bff603 	ldbu	r2,-40(fp)
811398ac:	1880b42e 	bgeu	r3,r2,81139b80 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
811398b0:	e0bff717 	ldw	r2,-36(fp)
811398b4:	10800d03 	ldbu	r2,52(r2)
811398b8:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
811398bc:	e0fff803 	ldbu	r3,-32(fp)
811398c0:	d0a09d44 	addi	r2,gp,-32139
811398c4:	1885883a 	add	r2,r3,r2
811398c8:	10c00003 	ldbu	r3,0(r2)
811398cc:	e0bff717 	ldw	r2,-36(fp)
811398d0:	10800d43 	ldbu	r2,53(r2)
811398d4:	1884703a 	and	r2,r3,r2
811398d8:	10803fcc 	andi	r2,r2,255
811398dc:	10001e26 	beq	r2,zero,81139958 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
811398e0:	e0fff803 	ldbu	r3,-32(fp)
811398e4:	e13ff803 	ldbu	r4,-32(fp)
811398e8:	d0a09d44 	addi	r2,gp,-32139
811398ec:	2085883a 	add	r2,r4,r2
811398f0:	10800003 	ldbu	r2,0(r2)
811398f4:	1009883a 	mov	r4,r2
811398f8:	e0bff717 	ldw	r2,-36(fp)
811398fc:	10800d43 	ldbu	r2,53(r2)
81139900:	0084303a 	nor	r2,zero,r2
81139904:	2084703a 	and	r2,r4,r2
81139908:	1009883a 	mov	r4,r2
8113990c:	d0a09d44 	addi	r2,gp,-32139
81139910:	1885883a 	add	r2,r3,r2
81139914:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
81139918:	e0fff803 	ldbu	r3,-32(fp)
8113991c:	d0a09d44 	addi	r2,gp,-32139
81139920:	1885883a 	add	r2,r3,r2
81139924:	10800003 	ldbu	r2,0(r2)
81139928:	10803fcc 	andi	r2,r2,255
8113992c:	1000071e 	bne	r2,zero,8113994c <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
81139930:	e0bff717 	ldw	r2,-36(fp)
81139934:	10800d83 	ldbu	r2,54(r2)
81139938:	0084303a 	nor	r2,zero,r2
8113993c:	1007883a 	mov	r3,r2
81139940:	d0a09d03 	ldbu	r2,-32140(gp)
81139944:	1884703a 	and	r2,r3,r2
81139948:	d0a09d05 	stb	r2,-32140(gp)
                }
                rdy = OS_TRUE;
8113994c:	00800044 	movi	r2,1
81139950:	e0bff005 	stb	r2,-64(fp)
81139954:	00002a06 	br	81139a00 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81139958:	e0bff717 	ldw	r2,-36(fp)
8113995c:	10800717 	ldw	r2,28(r2)
81139960:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
81139964:	e0bff917 	ldw	r2,-28(fp)
81139968:	10002426 	beq	r2,zero,811399fc <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113996c:	e0bff717 	ldw	r2,-36(fp)
81139970:	10800d03 	ldbu	r2,52(r2)
81139974:	10803fcc 	andi	r2,r2,255
81139978:	e0fff717 	ldw	r3,-36(fp)
8113997c:	18c00d03 	ldbu	r3,52(r3)
81139980:	18c03fcc 	andi	r3,r3,255
81139984:	e13ff917 	ldw	r4,-28(fp)
81139988:	20c7883a 	add	r3,r4,r3
8113998c:	18c002c4 	addi	r3,r3,11
81139990:	18c00003 	ldbu	r3,0(r3)
81139994:	1809883a 	mov	r4,r3
81139998:	e0fff717 	ldw	r3,-36(fp)
8113999c:	18c00d43 	ldbu	r3,53(r3)
811399a0:	00c6303a 	nor	r3,zero,r3
811399a4:	20c6703a 	and	r3,r4,r3
811399a8:	1809883a 	mov	r4,r3
811399ac:	e0fff917 	ldw	r3,-28(fp)
811399b0:	1887883a 	add	r3,r3,r2
811399b4:	18c002c4 	addi	r3,r3,11
811399b8:	19000005 	stb	r4,0(r3)
811399bc:	e0fff917 	ldw	r3,-28(fp)
811399c0:	1885883a 	add	r2,r3,r2
811399c4:	108002c4 	addi	r2,r2,11
811399c8:	10800003 	ldbu	r2,0(r2)
811399cc:	10803fcc 	andi	r2,r2,255
811399d0:	10000a1e 	bne	r2,zero,811399fc <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
811399d4:	e0bff917 	ldw	r2,-28(fp)
811399d8:	10800283 	ldbu	r2,10(r2)
811399dc:	1007883a 	mov	r3,r2
811399e0:	e0bff717 	ldw	r2,-36(fp)
811399e4:	10800d83 	ldbu	r2,54(r2)
811399e8:	0084303a 	nor	r2,zero,r2
811399ec:	1884703a 	and	r2,r3,r2
811399f0:	1007883a 	mov	r3,r2
811399f4:	e0bff917 	ldw	r2,-28(fp)
811399f8:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
811399fc:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
81139a00:	e0bff717 	ldw	r2,-36(fp)
81139a04:	e0fff303 	ldbu	r3,-52(fp)
81139a08:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81139a0c:	e0bff717 	ldw	r2,-36(fp)
81139a10:	10800c83 	ldbu	r2,50(r2)
81139a14:	10803fcc 	andi	r2,r2,255
81139a18:	1004d0fa 	srli	r2,r2,3
81139a1c:	1007883a 	mov	r3,r2
81139a20:	e0bff717 	ldw	r2,-36(fp)
81139a24:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
81139a28:	e0bff717 	ldw	r2,-36(fp)
81139a2c:	10800c83 	ldbu	r2,50(r2)
81139a30:	108001cc 	andi	r2,r2,7
81139a34:	1007883a 	mov	r3,r2
81139a38:	e0bff717 	ldw	r2,-36(fp)
81139a3c:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
81139a40:	e0bff717 	ldw	r2,-36(fp)
81139a44:	10800d03 	ldbu	r2,52(r2)
81139a48:	10803fcc 	andi	r2,r2,255
81139a4c:	00c00044 	movi	r3,1
81139a50:	1884983a 	sll	r2,r3,r2
81139a54:	1007883a 	mov	r3,r2
81139a58:	e0bff717 	ldw	r2,-36(fp)
81139a5c:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
81139a60:	e0bff717 	ldw	r2,-36(fp)
81139a64:	10800cc3 	ldbu	r2,51(r2)
81139a68:	10803fcc 	andi	r2,r2,255
81139a6c:	00c00044 	movi	r3,1
81139a70:	1884983a 	sll	r2,r3,r2
81139a74:	1007883a 	mov	r3,r2
81139a78:	e0bff717 	ldw	r2,-36(fp)
81139a7c:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
81139a80:	e0bff003 	ldbu	r2,-64(fp)
81139a84:	10800058 	cmpnei	r2,r2,1
81139a88:	1000161e 	bne	r2,zero,81139ae4 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81139a8c:	e0bff717 	ldw	r2,-36(fp)
81139a90:	10c00d83 	ldbu	r3,54(r2)
81139a94:	d0a09d03 	ldbu	r2,-32140(gp)
81139a98:	1884b03a 	or	r2,r3,r2
81139a9c:	d0a09d05 	stb	r2,-32140(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81139aa0:	e0bff717 	ldw	r2,-36(fp)
81139aa4:	10800d03 	ldbu	r2,52(r2)
81139aa8:	10c03fcc 	andi	r3,r2,255
81139aac:	e0bff717 	ldw	r2,-36(fp)
81139ab0:	10800d03 	ldbu	r2,52(r2)
81139ab4:	11003fcc 	andi	r4,r2,255
81139ab8:	d0a09d44 	addi	r2,gp,-32139
81139abc:	2085883a 	add	r2,r4,r2
81139ac0:	11000003 	ldbu	r4,0(r2)
81139ac4:	e0bff717 	ldw	r2,-36(fp)
81139ac8:	10800d43 	ldbu	r2,53(r2)
81139acc:	2084b03a 	or	r2,r4,r2
81139ad0:	1009883a 	mov	r4,r2
81139ad4:	d0a09d44 	addi	r2,gp,-32139
81139ad8:	1885883a 	add	r2,r3,r2
81139adc:	11000005 	stb	r4,0(r2)
81139ae0:	00001f06 	br	81139b60 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81139ae4:	e0bff717 	ldw	r2,-36(fp)
81139ae8:	10800717 	ldw	r2,28(r2)
81139aec:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
81139af0:	e0bff917 	ldw	r2,-28(fp)
81139af4:	10001a26 	beq	r2,zero,81139b60 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81139af8:	e0bff917 	ldw	r2,-28(fp)
81139afc:	10c00283 	ldbu	r3,10(r2)
81139b00:	e0bff717 	ldw	r2,-36(fp)
81139b04:	10800d83 	ldbu	r2,54(r2)
81139b08:	1884b03a 	or	r2,r3,r2
81139b0c:	1007883a 	mov	r3,r2
81139b10:	e0bff917 	ldw	r2,-28(fp)
81139b14:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81139b18:	e0bff717 	ldw	r2,-36(fp)
81139b1c:	10800d03 	ldbu	r2,52(r2)
81139b20:	10803fcc 	andi	r2,r2,255
81139b24:	e0fff717 	ldw	r3,-36(fp)
81139b28:	18c00d03 	ldbu	r3,52(r3)
81139b2c:	18c03fcc 	andi	r3,r3,255
81139b30:	e13ff917 	ldw	r4,-28(fp)
81139b34:	20c7883a 	add	r3,r4,r3
81139b38:	18c002c4 	addi	r3,r3,11
81139b3c:	19000003 	ldbu	r4,0(r3)
81139b40:	e0fff717 	ldw	r3,-36(fp)
81139b44:	18c00d43 	ldbu	r3,53(r3)
81139b48:	20c6b03a 	or	r3,r4,r3
81139b4c:	1809883a 	mov	r4,r3
81139b50:	e0fff917 	ldw	r3,-28(fp)
81139b54:	1885883a 	add	r2,r3,r2
81139b58:	108002c4 	addi	r2,r2,11
81139b5c:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
81139b60:	e0fff303 	ldbu	r3,-52(fp)
81139b64:	00a045f4 	movhi	r2,33047
81139b68:	10a46104 	addi	r2,r2,-28284
81139b6c:	18c7883a 	add	r3,r3,r3
81139b70:	18c7883a 	add	r3,r3,r3
81139b74:	10c5883a 	add	r2,r2,r3
81139b78:	e0fff717 	ldw	r3,-36(fp)
81139b7c:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
81139b80:	d0a0a117 	ldw	r2,-32124(gp)
81139b84:	d0e0a117 	ldw	r3,-32124(gp)
81139b88:	18c00c03 	ldbu	r3,48(r3)
81139b8c:	18c00414 	ori	r3,r3,16
81139b90:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81139b94:	d0a0a117 	ldw	r2,-32124(gp)
81139b98:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
81139b9c:	d0a0a117 	ldw	r2,-32124(gp)
81139ba0:	e0fffe0b 	ldhu	r3,-8(fp)
81139ba4:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81139ba8:	e13ffd17 	ldw	r4,-12(fp)
81139bac:	1135f240 	call	81135f24 <OS_EventTaskWait>
81139bb0:	e0bff117 	ldw	r2,-60(fp)
81139bb4:	e0bffb15 	stw	r2,-20(fp)
81139bb8:	e0bffb17 	ldw	r2,-20(fp)
81139bbc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81139bc0:	11368400 	call	81136840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139bc4:	0005303a 	rdctl	r2,status
81139bc8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139bcc:	e0fff517 	ldw	r3,-44(fp)
81139bd0:	00bfff84 	movi	r2,-2
81139bd4:	1884703a 	and	r2,r3,r2
81139bd8:	1001703a 	wrctl	status,r2
  
  return context;
81139bdc:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
81139be0:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81139be4:	d0a0a117 	ldw	r2,-32124(gp)
81139be8:	10800c43 	ldbu	r2,49(r2)
81139bec:	10803fcc 	andi	r2,r2,255
81139bf0:	10000326 	beq	r2,zero,81139c00 <OSMutexPend+0x51c>
81139bf4:	108000a0 	cmpeqi	r2,r2,2
81139bf8:	1000041e 	bne	r2,zero,81139c0c <OSMutexPend+0x528>
81139bfc:	00000706 	br	81139c1c <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81139c00:	e0bfff17 	ldw	r2,-4(fp)
81139c04:	10000005 	stb	zero,0(r2)
             break;
81139c08:	00000c06 	br	81139c3c <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81139c0c:	e0bfff17 	ldw	r2,-4(fp)
81139c10:	00c00384 	movi	r3,14
81139c14:	10c00005 	stb	r3,0(r2)
             break;
81139c18:	00000806 	br	81139c3c <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81139c1c:	d0a0a117 	ldw	r2,-32124(gp)
81139c20:	e17ffd17 	ldw	r5,-12(fp)
81139c24:	1009883a 	mov	r4,r2
81139c28:	11361940 	call	81136194 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
81139c2c:	e0bfff17 	ldw	r2,-4(fp)
81139c30:	00c00284 	movi	r3,10
81139c34:	10c00005 	stb	r3,0(r2)
             break;
81139c38:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81139c3c:	d0a0a117 	ldw	r2,-32124(gp)
81139c40:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81139c44:	d0a0a117 	ldw	r2,-32124(gp)
81139c48:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81139c4c:	d0a0a117 	ldw	r2,-32124(gp)
81139c50:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81139c54:	d0a0a117 	ldw	r2,-32124(gp)
81139c58:	10000815 	stw	zero,32(r2)
81139c5c:	e0bff117 	ldw	r2,-60(fp)
81139c60:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139c64:	e0bffa17 	ldw	r2,-24(fp)
81139c68:	1001703a 	wrctl	status,r2
81139c6c:	00000106 	br	81139c74 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
81139c70:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81139c74:	e037883a 	mov	sp,fp
81139c78:	dfc00117 	ldw	ra,4(sp)
81139c7c:	df000017 	ldw	fp,0(sp)
81139c80:	dec00204 	addi	sp,sp,8
81139c84:	f800283a 	ret

81139c88 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
81139c88:	defff604 	addi	sp,sp,-40
81139c8c:	de00012e 	bgeu	sp,et,81139c94 <OSMutexPost+0xc>
81139c90:	003b68fa 	trap	3
81139c94:	dfc00915 	stw	ra,36(sp)
81139c98:	df000815 	stw	fp,32(sp)
81139c9c:	df000804 	addi	fp,sp,32
81139ca0:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139ca4:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81139ca8:	d0a0a003 	ldbu	r2,-32128(gp)
81139cac:	10803fcc 	andi	r2,r2,255
81139cb0:	10000226 	beq	r2,zero,81139cbc <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
81139cb4:	00800144 	movi	r2,5
81139cb8:	00007606 	br	81139e94 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139cbc:	e0bfff17 	ldw	r2,-4(fp)
81139cc0:	1000021e 	bne	r2,zero,81139ccc <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
81139cc4:	00800104 	movi	r2,4
81139cc8:	00007206 	br	81139e94 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
81139ccc:	e0bfff17 	ldw	r2,-4(fp)
81139cd0:	10800003 	ldbu	r2,0(r2)
81139cd4:	10803fcc 	andi	r2,r2,255
81139cd8:	10800120 	cmpeqi	r2,r2,4
81139cdc:	1000021e 	bne	r2,zero,81139ce8 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
81139ce0:	00800044 	movi	r2,1
81139ce4:	00006b06 	br	81139e94 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139ce8:	0005303a 	rdctl	r2,status
81139cec:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139cf0:	e0fffe17 	ldw	r3,-8(fp)
81139cf4:	00bfff84 	movi	r2,-2
81139cf8:	1884703a 	and	r2,r3,r2
81139cfc:	1001703a 	wrctl	status,r2
  
  return context;
81139d00:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81139d04:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
81139d08:	e0bfff17 	ldw	r2,-4(fp)
81139d0c:	1080020b 	ldhu	r2,8(r2)
81139d10:	10bfffcc 	andi	r2,r2,65535
81139d14:	1004d23a 	srli	r2,r2,8
81139d18:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
81139d1c:	e0bfff17 	ldw	r2,-4(fp)
81139d20:	1080020b 	ldhu	r2,8(r2)
81139d24:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
81139d28:	e0bfff17 	ldw	r2,-4(fp)
81139d2c:	10c00117 	ldw	r3,4(r2)
81139d30:	d0a0a117 	ldw	r2,-32124(gp)
81139d34:	18800626 	beq	r3,r2,81139d50 <OSMutexPost+0xc8>
81139d38:	e0bff817 	ldw	r2,-32(fp)
81139d3c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139d40:	e0bff917 	ldw	r2,-28(fp)
81139d44:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
81139d48:	00801904 	movi	r2,100
81139d4c:	00005106 	br	81139e94 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
81139d50:	d0a0a117 	ldw	r2,-32124(gp)
81139d54:	10800c83 	ldbu	r2,50(r2)
81139d58:	10c03fcc 	andi	r3,r2,255
81139d5c:	e0bffa03 	ldbu	r2,-24(fp)
81139d60:	1880051e 	bne	r3,r2,81139d78 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
81139d64:	d0a0a117 	ldw	r2,-32124(gp)
81139d68:	e0fffa43 	ldbu	r3,-23(fp)
81139d6c:	180b883a 	mov	r5,r3
81139d70:	1009883a 	mov	r4,r2
81139d74:	113a01c0 	call	8113a01c <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
81139d78:	e0fffa03 	ldbu	r3,-24(fp)
81139d7c:	00a045f4 	movhi	r2,33047
81139d80:	10a46104 	addi	r2,r2,-28284
81139d84:	18c7883a 	add	r3,r3,r3
81139d88:	18c7883a 	add	r3,r3,r3
81139d8c:	10c5883a 	add	r2,r2,r3
81139d90:	00c00044 	movi	r3,1
81139d94:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
81139d98:	e0bfff17 	ldw	r2,-4(fp)
81139d9c:	10800283 	ldbu	r2,10(r2)
81139da0:	10803fcc 	andi	r2,r2,255
81139da4:	10002e26 	beq	r2,zero,81139e60 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81139da8:	000f883a 	mov	r7,zero
81139dac:	01800404 	movi	r6,16
81139db0:	000b883a 	mov	r5,zero
81139db4:	e13fff17 	ldw	r4,-4(fp)
81139db8:	1135d840 	call	81135d84 <OS_EventTaskRdy>
81139dbc:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
81139dc0:	e0bfff17 	ldw	r2,-4(fp)
81139dc4:	10c0020b 	ldhu	r3,8(r2)
81139dc8:	00bfc004 	movi	r2,-256
81139dcc:	1884703a 	and	r2,r3,r2
81139dd0:	1007883a 	mov	r3,r2
81139dd4:	e0bfff17 	ldw	r2,-4(fp)
81139dd8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
81139ddc:	e0bfff17 	ldw	r2,-4(fp)
81139de0:	10c0020b 	ldhu	r3,8(r2)
81139de4:	e0bffa43 	ldbu	r2,-23(fp)
81139de8:	1884b03a 	or	r2,r3,r2
81139dec:	1007883a 	mov	r3,r2
81139df0:	e0bfff17 	ldw	r2,-4(fp)
81139df4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
81139df8:	e0fffa43 	ldbu	r3,-23(fp)
81139dfc:	00a045f4 	movhi	r2,33047
81139e00:	10a46104 	addi	r2,r2,-28284
81139e04:	18c7883a 	add	r3,r3,r3
81139e08:	18c7883a 	add	r3,r3,r3
81139e0c:	10c5883a 	add	r2,r2,r3
81139e10:	10c00017 	ldw	r3,0(r2)
81139e14:	e0bfff17 	ldw	r2,-4(fp)
81139e18:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
81139e1c:	e0bffa43 	ldbu	r2,-23(fp)
81139e20:	e0fffa03 	ldbu	r3,-24(fp)
81139e24:	18800736 	bltu	r3,r2,81139e44 <OSMutexPost+0x1bc>
81139e28:	e0bff817 	ldw	r2,-32(fp)
81139e2c:	e0bffb15 	stw	r2,-20(fp)
81139e30:	e0bffb17 	ldw	r2,-20(fp)
81139e34:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
81139e38:	11368400 	call	81136840 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
81139e3c:	00801e04 	movi	r2,120
81139e40:	00001406 	br	81139e94 <OSMutexPost+0x20c>
81139e44:	e0bff817 	ldw	r2,-32(fp)
81139e48:	e0bffc15 	stw	r2,-16(fp)
81139e4c:	e0bffc17 	ldw	r2,-16(fp)
81139e50:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
81139e54:	11368400 	call	81136840 <OS_Sched>
            return (OS_ERR_NONE);
81139e58:	0005883a 	mov	r2,zero
81139e5c:	00000d06 	br	81139e94 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
81139e60:	e0bfff17 	ldw	r2,-4(fp)
81139e64:	1080020b 	ldhu	r2,8(r2)
81139e68:	10803fd4 	ori	r2,r2,255
81139e6c:	1007883a 	mov	r3,r2
81139e70:	e0bfff17 	ldw	r2,-4(fp)
81139e74:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
81139e78:	e0bfff17 	ldw	r2,-4(fp)
81139e7c:	10000115 	stw	zero,4(r2)
81139e80:	e0bff817 	ldw	r2,-32(fp)
81139e84:	e0bffd15 	stw	r2,-12(fp)
81139e88:	e0bffd17 	ldw	r2,-12(fp)
81139e8c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139e90:	0005883a 	mov	r2,zero
}
81139e94:	e037883a 	mov	sp,fp
81139e98:	dfc00117 	ldw	ra,4(sp)
81139e9c:	df000017 	ldw	fp,0(sp)
81139ea0:	dec00204 	addi	sp,sp,8
81139ea4:	f800283a 	ret

81139ea8 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
81139ea8:	defff704 	addi	sp,sp,-36
81139eac:	de00012e 	bgeu	sp,et,81139eb4 <OSMutexQuery+0xc>
81139eb0:	003b68fa 	trap	3
81139eb4:	df000815 	stw	fp,32(sp)
81139eb8:	df000804 	addi	fp,sp,32
81139ebc:	e13ffe15 	stw	r4,-8(fp)
81139ec0:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139ec4:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139ec8:	d0a0a003 	ldbu	r2,-32128(gp)
81139ecc:	10803fcc 	andi	r2,r2,255
81139ed0:	10000226 	beq	r2,zero,81139edc <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
81139ed4:	00800184 	movi	r2,6
81139ed8:	00004c06 	br	8113a00c <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81139edc:	e0bffe17 	ldw	r2,-8(fp)
81139ee0:	1000021e 	bne	r2,zero,81139eec <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
81139ee4:	00800104 	movi	r2,4
81139ee8:	00004806 	br	8113a00c <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
81139eec:	e0bfff17 	ldw	r2,-4(fp)
81139ef0:	1000021e 	bne	r2,zero,81139efc <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
81139ef4:	00800244 	movi	r2,9
81139ef8:	00004406 	br	8113a00c <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81139efc:	e0bffe17 	ldw	r2,-8(fp)
81139f00:	10800003 	ldbu	r2,0(r2)
81139f04:	10803fcc 	andi	r2,r2,255
81139f08:	10800120 	cmpeqi	r2,r2,4
81139f0c:	1000021e 	bne	r2,zero,81139f18 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
81139f10:	00800044 	movi	r2,1
81139f14:	00003d06 	br	8113a00c <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139f18:	0005303a 	rdctl	r2,status
81139f1c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139f20:	e0fffd17 	ldw	r3,-12(fp)
81139f24:	00bfff84 	movi	r2,-2
81139f28:	1884703a 	and	r2,r3,r2
81139f2c:	1001703a 	wrctl	status,r2
  
  return context;
81139f30:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139f34:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
81139f38:	e0bffe17 	ldw	r2,-8(fp)
81139f3c:	1080020b 	ldhu	r2,8(r2)
81139f40:	10bfffcc 	andi	r2,r2,65535
81139f44:	1004d23a 	srli	r2,r2,8
81139f48:	1007883a 	mov	r3,r2
81139f4c:	e0bfff17 	ldw	r2,-4(fp)
81139f50:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
81139f54:	e0bffe17 	ldw	r2,-8(fp)
81139f58:	1080020b 	ldhu	r2,8(r2)
81139f5c:	1007883a 	mov	r3,r2
81139f60:	e0bfff17 	ldw	r2,-4(fp)
81139f64:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
81139f68:	e0bfff17 	ldw	r2,-4(fp)
81139f6c:	10800203 	ldbu	r2,8(r2)
81139f70:	10803fcc 	andi	r2,r2,255
81139f74:	10803fd8 	cmpnei	r2,r2,255
81139f78:	1000041e 	bne	r2,zero,81139f8c <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
81139f7c:	e0bfff17 	ldw	r2,-4(fp)
81139f80:	00c00044 	movi	r3,1
81139f84:	10c001c5 	stb	r3,7(r2)
81139f88:	00000206 	br	81139f94 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
81139f8c:	e0bfff17 	ldw	r2,-4(fp)
81139f90:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
81139f94:	e0bffe17 	ldw	r2,-8(fp)
81139f98:	10c00283 	ldbu	r3,10(r2)
81139f9c:	e0bfff17 	ldw	r2,-4(fp)
81139fa0:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
81139fa4:	e0bffe17 	ldw	r2,-8(fp)
81139fa8:	108002c4 	addi	r2,r2,11
81139fac:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
81139fb0:	e0bfff17 	ldw	r2,-4(fp)
81139fb4:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139fb8:	e03ff805 	stb	zero,-32(fp)
81139fbc:	00000b06 	br	81139fec <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
81139fc0:	e0bffa17 	ldw	r2,-24(fp)
81139fc4:	10c00044 	addi	r3,r2,1
81139fc8:	e0fffa15 	stw	r3,-24(fp)
81139fcc:	e0fff917 	ldw	r3,-28(fp)
81139fd0:	19000044 	addi	r4,r3,1
81139fd4:	e13ff915 	stw	r4,-28(fp)
81139fd8:	18c00003 	ldbu	r3,0(r3)
81139fdc:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139fe0:	e0bff803 	ldbu	r2,-32(fp)
81139fe4:	10800044 	addi	r2,r2,1
81139fe8:	e0bff805 	stb	r2,-32(fp)
81139fec:	e0bff803 	ldbu	r2,-32(fp)
81139ff0:	108001b0 	cmpltui	r2,r2,6
81139ff4:	103ff21e 	bne	r2,zero,81139fc0 <__reset+0xfb119fc0>
81139ff8:	e0bffb17 	ldw	r2,-20(fp)
81139ffc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a000:	e0bffc17 	ldw	r2,-16(fp)
8113a004:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a008:	0005883a 	mov	r2,zero
}
8113a00c:	e037883a 	mov	sp,fp
8113a010:	df000017 	ldw	fp,0(sp)
8113a014:	dec00104 	addi	sp,sp,4
8113a018:	f800283a 	ret

8113a01c <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113a01c:	defffc04 	addi	sp,sp,-16
8113a020:	de00012e 	bgeu	sp,et,8113a028 <OSMutex_RdyAtPrio+0xc>
8113a024:	003b68fa 	trap	3
8113a028:	df000315 	stw	fp,12(sp)
8113a02c:	df000304 	addi	fp,sp,12
8113a030:	e13ffe15 	stw	r4,-8(fp)
8113a034:	2805883a 	mov	r2,r5
8113a038:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113a03c:	e0bffe17 	ldw	r2,-8(fp)
8113a040:	10800d03 	ldbu	r2,52(r2)
8113a044:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113a048:	e0fffd03 	ldbu	r3,-12(fp)
8113a04c:	e13ffd03 	ldbu	r4,-12(fp)
8113a050:	d0a09d44 	addi	r2,gp,-32139
8113a054:	2085883a 	add	r2,r4,r2
8113a058:	10800003 	ldbu	r2,0(r2)
8113a05c:	1009883a 	mov	r4,r2
8113a060:	e0bffe17 	ldw	r2,-8(fp)
8113a064:	10800d43 	ldbu	r2,53(r2)
8113a068:	0084303a 	nor	r2,zero,r2
8113a06c:	2084703a 	and	r2,r4,r2
8113a070:	1009883a 	mov	r4,r2
8113a074:	d0a09d44 	addi	r2,gp,-32139
8113a078:	1885883a 	add	r2,r3,r2
8113a07c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113a080:	e0fffd03 	ldbu	r3,-12(fp)
8113a084:	d0a09d44 	addi	r2,gp,-32139
8113a088:	1885883a 	add	r2,r3,r2
8113a08c:	10800003 	ldbu	r2,0(r2)
8113a090:	10803fcc 	andi	r2,r2,255
8113a094:	1000071e 	bne	r2,zero,8113a0b4 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113a098:	e0bffe17 	ldw	r2,-8(fp)
8113a09c:	10800d83 	ldbu	r2,54(r2)
8113a0a0:	0084303a 	nor	r2,zero,r2
8113a0a4:	1007883a 	mov	r3,r2
8113a0a8:	d0a09d03 	ldbu	r2,-32140(gp)
8113a0ac:	1884703a 	and	r2,r3,r2
8113a0b0:	d0a09d05 	stb	r2,-32140(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113a0b4:	e0bffe17 	ldw	r2,-8(fp)
8113a0b8:	e0ffff03 	ldbu	r3,-4(fp)
8113a0bc:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113a0c0:	e0bfff03 	ldbu	r2,-4(fp)
8113a0c4:	1004d0fa 	srli	r2,r2,3
8113a0c8:	108001cc 	andi	r2,r2,7
8113a0cc:	1007883a 	mov	r3,r2
8113a0d0:	e0bffe17 	ldw	r2,-8(fp)
8113a0d4:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113a0d8:	e0bfff03 	ldbu	r2,-4(fp)
8113a0dc:	108001cc 	andi	r2,r2,7
8113a0e0:	1007883a 	mov	r3,r2
8113a0e4:	e0bffe17 	ldw	r2,-8(fp)
8113a0e8:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113a0ec:	e0bffe17 	ldw	r2,-8(fp)
8113a0f0:	10800d03 	ldbu	r2,52(r2)
8113a0f4:	10803fcc 	andi	r2,r2,255
8113a0f8:	00c00044 	movi	r3,1
8113a0fc:	1884983a 	sll	r2,r3,r2
8113a100:	1007883a 	mov	r3,r2
8113a104:	e0bffe17 	ldw	r2,-8(fp)
8113a108:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113a10c:	e0bffe17 	ldw	r2,-8(fp)
8113a110:	10800cc3 	ldbu	r2,51(r2)
8113a114:	10803fcc 	andi	r2,r2,255
8113a118:	00c00044 	movi	r3,1
8113a11c:	1884983a 	sll	r2,r3,r2
8113a120:	1007883a 	mov	r3,r2
8113a124:	e0bffe17 	ldw	r2,-8(fp)
8113a128:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113a12c:	e0bffe17 	ldw	r2,-8(fp)
8113a130:	10c00d83 	ldbu	r3,54(r2)
8113a134:	d0a09d03 	ldbu	r2,-32140(gp)
8113a138:	1884b03a 	or	r2,r3,r2
8113a13c:	d0a09d05 	stb	r2,-32140(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113a140:	e0bffe17 	ldw	r2,-8(fp)
8113a144:	10800d03 	ldbu	r2,52(r2)
8113a148:	10c03fcc 	andi	r3,r2,255
8113a14c:	e0bffe17 	ldw	r2,-8(fp)
8113a150:	10800d03 	ldbu	r2,52(r2)
8113a154:	11003fcc 	andi	r4,r2,255
8113a158:	d0a09d44 	addi	r2,gp,-32139
8113a15c:	2085883a 	add	r2,r4,r2
8113a160:	11000003 	ldbu	r4,0(r2)
8113a164:	e0bffe17 	ldw	r2,-8(fp)
8113a168:	10800d43 	ldbu	r2,53(r2)
8113a16c:	2084b03a 	or	r2,r4,r2
8113a170:	1009883a 	mov	r4,r2
8113a174:	d0a09d44 	addi	r2,gp,-32139
8113a178:	1885883a 	add	r2,r3,r2
8113a17c:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113a180:	e0ffff03 	ldbu	r3,-4(fp)
8113a184:	00a045f4 	movhi	r2,33047
8113a188:	10a46104 	addi	r2,r2,-28284
8113a18c:	18c7883a 	add	r3,r3,r3
8113a190:	18c7883a 	add	r3,r3,r3
8113a194:	10c5883a 	add	r2,r2,r3
8113a198:	e0fffe17 	ldw	r3,-8(fp)
8113a19c:	10c00015 	stw	r3,0(r2)
}
8113a1a0:	0001883a 	nop
8113a1a4:	e037883a 	mov	sp,fp
8113a1a8:	df000017 	ldw	fp,0(sp)
8113a1ac:	dec00104 	addi	sp,sp,4
8113a1b0:	f800283a 	ret

8113a1b4 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113a1b4:	defff804 	addi	sp,sp,-32
8113a1b8:	de00012e 	bgeu	sp,et,8113a1c0 <OSQAccept+0xc>
8113a1bc:	003b68fa 	trap	3
8113a1c0:	df000715 	stw	fp,28(sp)
8113a1c4:	df000704 	addi	fp,sp,28
8113a1c8:	e13ffe15 	stw	r4,-8(fp)
8113a1cc:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a1d0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a1d4:	e0bfff17 	ldw	r2,-4(fp)
8113a1d8:	1000021e 	bne	r2,zero,8113a1e4 <OSQAccept+0x30>
        return ((void *)0);
8113a1dc:	0005883a 	mov	r2,zero
8113a1e0:	00004206 	br	8113a2ec <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113a1e4:	e0bffe17 	ldw	r2,-8(fp)
8113a1e8:	1000051e 	bne	r2,zero,8113a200 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113a1ec:	e0bfff17 	ldw	r2,-4(fp)
8113a1f0:	00c00104 	movi	r3,4
8113a1f4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113a1f8:	0005883a 	mov	r2,zero
8113a1fc:	00003b06 	br	8113a2ec <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113a200:	e0bffe17 	ldw	r2,-8(fp)
8113a204:	10800003 	ldbu	r2,0(r2)
8113a208:	10803fcc 	andi	r2,r2,255
8113a20c:	108000a0 	cmpeqi	r2,r2,2
8113a210:	1000051e 	bne	r2,zero,8113a228 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113a214:	e0bfff17 	ldw	r2,-4(fp)
8113a218:	00c00044 	movi	r3,1
8113a21c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113a220:	0005883a 	mov	r2,zero
8113a224:	00003106 	br	8113a2ec <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a228:	0005303a 	rdctl	r2,status
8113a22c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a230:	e0fffd17 	ldw	r3,-12(fp)
8113a234:	00bfff84 	movi	r2,-2
8113a238:	1884703a 	and	r2,r3,r2
8113a23c:	1001703a 	wrctl	status,r2
  
  return context;
8113a240:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a244:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113a248:	e0bffe17 	ldw	r2,-8(fp)
8113a24c:	10800117 	ldw	r2,4(r2)
8113a250:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113a254:	e0bffc17 	ldw	r2,-16(fp)
8113a258:	1080058b 	ldhu	r2,22(r2)
8113a25c:	10bfffcc 	andi	r2,r2,65535
8113a260:	10001926 	beq	r2,zero,8113a2c8 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113a264:	e0bffc17 	ldw	r2,-16(fp)
8113a268:	10800417 	ldw	r2,16(r2)
8113a26c:	11000104 	addi	r4,r2,4
8113a270:	e0fffc17 	ldw	r3,-16(fp)
8113a274:	19000415 	stw	r4,16(r3)
8113a278:	10800017 	ldw	r2,0(r2)
8113a27c:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113a280:	e0bffc17 	ldw	r2,-16(fp)
8113a284:	1080058b 	ldhu	r2,22(r2)
8113a288:	10bfffc4 	addi	r2,r2,-1
8113a28c:	1007883a 	mov	r3,r2
8113a290:	e0bffc17 	ldw	r2,-16(fp)
8113a294:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113a298:	e0bffc17 	ldw	r2,-16(fp)
8113a29c:	10c00417 	ldw	r3,16(r2)
8113a2a0:	e0bffc17 	ldw	r2,-16(fp)
8113a2a4:	10800217 	ldw	r2,8(r2)
8113a2a8:	1880041e 	bne	r3,r2,8113a2bc <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113a2ac:	e0bffc17 	ldw	r2,-16(fp)
8113a2b0:	10c00117 	ldw	r3,4(r2)
8113a2b4:	e0bffc17 	ldw	r2,-16(fp)
8113a2b8:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113a2bc:	e0bfff17 	ldw	r2,-4(fp)
8113a2c0:	10000005 	stb	zero,0(r2)
8113a2c4:	00000406 	br	8113a2d8 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113a2c8:	e0bfff17 	ldw	r2,-4(fp)
8113a2cc:	00c007c4 	movi	r3,31
8113a2d0:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113a2d4:	e03ff915 	stw	zero,-28(fp)
8113a2d8:	e0bffa17 	ldw	r2,-24(fp)
8113a2dc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a2e0:	e0bffb17 	ldw	r2,-20(fp)
8113a2e4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113a2e8:	e0bff917 	ldw	r2,-28(fp)
}
8113a2ec:	e037883a 	mov	sp,fp
8113a2f0:	df000017 	ldw	fp,0(sp)
8113a2f4:	dec00104 	addi	sp,sp,4
8113a2f8:	f800283a 	ret

8113a2fc <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113a2fc:	defff404 	addi	sp,sp,-48
8113a300:	de00012e 	bgeu	sp,et,8113a308 <OSQCreate+0xc>
8113a304:	003b68fa 	trap	3
8113a308:	dfc00b15 	stw	ra,44(sp)
8113a30c:	df000a15 	stw	fp,40(sp)
8113a310:	df000a04 	addi	fp,sp,40
8113a314:	e13ffe15 	stw	r4,-8(fp)
8113a318:	2805883a 	mov	r2,r5
8113a31c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a320:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113a324:	d0a0a003 	ldbu	r2,-32128(gp)
8113a328:	10803fcc 	andi	r2,r2,255
8113a32c:	10000226 	beq	r2,zero,8113a338 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113a330:	0005883a 	mov	r2,zero
8113a334:	00005906 	br	8113a49c <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a338:	0005303a 	rdctl	r2,status
8113a33c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a340:	e0fffd17 	ldw	r3,-12(fp)
8113a344:	00bfff84 	movi	r2,-2
8113a348:	1884703a 	and	r2,r3,r2
8113a34c:	1001703a 	wrctl	status,r2
  
  return context;
8113a350:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a354:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113a358:	d0a09f17 	ldw	r2,-32132(gp)
8113a35c:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113a360:	d0a09f17 	ldw	r2,-32132(gp)
8113a364:	10000326 	beq	r2,zero,8113a374 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113a368:	d0a09f17 	ldw	r2,-32132(gp)
8113a36c:	10800117 	ldw	r2,4(r2)
8113a370:	d0a09f15 	stw	r2,-32132(gp)
8113a374:	e0bff717 	ldw	r2,-36(fp)
8113a378:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a37c:	e0bff817 	ldw	r2,-32(fp)
8113a380:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113a384:	e0bff617 	ldw	r2,-40(fp)
8113a388:	10004326 	beq	r2,zero,8113a498 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a38c:	0005303a 	rdctl	r2,status
8113a390:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a394:	e0fff917 	ldw	r3,-28(fp)
8113a398:	00bfff84 	movi	r2,-2
8113a39c:	1884703a 	and	r2,r3,r2
8113a3a0:	1001703a 	wrctl	status,r2
  
  return context;
8113a3a4:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113a3a8:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113a3ac:	d0a09c17 	ldw	r2,-32144(gp)
8113a3b0:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113a3b4:	e0bffb17 	ldw	r2,-20(fp)
8113a3b8:	10002d26 	beq	r2,zero,8113a470 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113a3bc:	d0a09c17 	ldw	r2,-32144(gp)
8113a3c0:	10800017 	ldw	r2,0(r2)
8113a3c4:	d0a09c15 	stw	r2,-32144(gp)
8113a3c8:	e0bff717 	ldw	r2,-36(fp)
8113a3cc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a3d0:	e0bffa17 	ldw	r2,-24(fp)
8113a3d4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113a3d8:	e0bffb17 	ldw	r2,-20(fp)
8113a3dc:	e0fffe17 	ldw	r3,-8(fp)
8113a3e0:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113a3e4:	e0bfff0b 	ldhu	r2,-4(fp)
8113a3e8:	1085883a 	add	r2,r2,r2
8113a3ec:	1085883a 	add	r2,r2,r2
8113a3f0:	1007883a 	mov	r3,r2
8113a3f4:	e0bffe17 	ldw	r2,-8(fp)
8113a3f8:	10c7883a 	add	r3,r2,r3
8113a3fc:	e0bffb17 	ldw	r2,-20(fp)
8113a400:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113a404:	e0bffb17 	ldw	r2,-20(fp)
8113a408:	e0fffe17 	ldw	r3,-8(fp)
8113a40c:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113a410:	e0bffb17 	ldw	r2,-20(fp)
8113a414:	e0fffe17 	ldw	r3,-8(fp)
8113a418:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113a41c:	e0bffb17 	ldw	r2,-20(fp)
8113a420:	e0ffff0b 	ldhu	r3,-4(fp)
8113a424:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113a428:	e0bffb17 	ldw	r2,-20(fp)
8113a42c:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113a430:	e0bff617 	ldw	r2,-40(fp)
8113a434:	00c00084 	movi	r3,2
8113a438:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113a43c:	e0bff617 	ldw	r2,-40(fp)
8113a440:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113a444:	e0bff617 	ldw	r2,-40(fp)
8113a448:	e0fffb17 	ldw	r3,-20(fp)
8113a44c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113a450:	e0bff617 	ldw	r2,-40(fp)
8113a454:	00c00fc4 	movi	r3,63
8113a458:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113a45c:	e0bff617 	ldw	r2,-40(fp)
8113a460:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113a464:	e13ff617 	ldw	r4,-40(fp)
8113a468:	113635c0 	call	8113635c <OS_EventWaitListInit>
8113a46c:	00000a06 	br	8113a498 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113a470:	d0e09f17 	ldw	r3,-32132(gp)
8113a474:	e0bff617 	ldw	r2,-40(fp)
8113a478:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113a47c:	e0bff617 	ldw	r2,-40(fp)
8113a480:	d0a09f15 	stw	r2,-32132(gp)
8113a484:	e0bff717 	ldw	r2,-36(fp)
8113a488:	e0bffc15 	stw	r2,-16(fp)
8113a48c:	e0bffc17 	ldw	r2,-16(fp)
8113a490:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113a494:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113a498:	e0bff617 	ldw	r2,-40(fp)
}
8113a49c:	e037883a 	mov	sp,fp
8113a4a0:	dfc00117 	ldw	ra,4(sp)
8113a4a4:	df000017 	ldw	fp,0(sp)
8113a4a8:	dec00204 	addi	sp,sp,8
8113a4ac:	f800283a 	ret

8113a4b0 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113a4b0:	defff204 	addi	sp,sp,-56
8113a4b4:	de00012e 	bgeu	sp,et,8113a4bc <OSQDel+0xc>
8113a4b8:	003b68fa 	trap	3
8113a4bc:	dfc00d15 	stw	ra,52(sp)
8113a4c0:	df000c15 	stw	fp,48(sp)
8113a4c4:	df000c04 	addi	fp,sp,48
8113a4c8:	e13ffd15 	stw	r4,-12(fp)
8113a4cc:	2805883a 	mov	r2,r5
8113a4d0:	e1bfff15 	stw	r6,-4(fp)
8113a4d4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a4d8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a4dc:	e0bfff17 	ldw	r2,-4(fp)
8113a4e0:	1000021e 	bne	r2,zero,8113a4ec <OSQDel+0x3c>
        return (pevent);
8113a4e4:	e0bffd17 	ldw	r2,-12(fp)
8113a4e8:	00008e06 	br	8113a724 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113a4ec:	e0bffd17 	ldw	r2,-12(fp)
8113a4f0:	1000051e 	bne	r2,zero,8113a508 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113a4f4:	e0bfff17 	ldw	r2,-4(fp)
8113a4f8:	00c00104 	movi	r3,4
8113a4fc:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a500:	e0bffd17 	ldw	r2,-12(fp)
8113a504:	00008706 	br	8113a724 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113a508:	e0bffd17 	ldw	r2,-12(fp)
8113a50c:	10800003 	ldbu	r2,0(r2)
8113a510:	10803fcc 	andi	r2,r2,255
8113a514:	108000a0 	cmpeqi	r2,r2,2
8113a518:	1000051e 	bne	r2,zero,8113a530 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113a51c:	e0bfff17 	ldw	r2,-4(fp)
8113a520:	00c00044 	movi	r3,1
8113a524:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a528:	e0bffd17 	ldw	r2,-12(fp)
8113a52c:	00007d06 	br	8113a724 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a530:	d0a0a003 	ldbu	r2,-32128(gp)
8113a534:	10803fcc 	andi	r2,r2,255
8113a538:	10000526 	beq	r2,zero,8113a550 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113a53c:	e0bfff17 	ldw	r2,-4(fp)
8113a540:	00c003c4 	movi	r3,15
8113a544:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a548:	e0bffd17 	ldw	r2,-12(fp)
8113a54c:	00007506 	br	8113a724 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a550:	0005303a 	rdctl	r2,status
8113a554:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a558:	e0fffc17 	ldw	r3,-16(fp)
8113a55c:	00bfff84 	movi	r2,-2
8113a560:	1884703a 	and	r2,r3,r2
8113a564:	1001703a 	wrctl	status,r2
  
  return context;
8113a568:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a56c:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113a570:	e0bffd17 	ldw	r2,-12(fp)
8113a574:	10800283 	ldbu	r2,10(r2)
8113a578:	10803fcc 	andi	r2,r2,255
8113a57c:	10000326 	beq	r2,zero,8113a58c <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113a580:	00800044 	movi	r2,1
8113a584:	e0bff405 	stb	r2,-48(fp)
8113a588:	00000106 	br	8113a590 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113a58c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113a590:	e0bffe03 	ldbu	r2,-8(fp)
8113a594:	10000326 	beq	r2,zero,8113a5a4 <OSQDel+0xf4>
8113a598:	10800060 	cmpeqi	r2,r2,1
8113a59c:	1000301e 	bne	r2,zero,8113a660 <OSQDel+0x1b0>
8113a5a0:	00005506 	br	8113a6f8 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113a5a4:	e0bff403 	ldbu	r2,-48(fp)
8113a5a8:	10001e1e 	bne	r2,zero,8113a624 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113a5ac:	e0bffd17 	ldw	r2,-12(fp)
8113a5b0:	00c00fc4 	movi	r3,63
8113a5b4:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113a5b8:	e0bffd17 	ldw	r2,-12(fp)
8113a5bc:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113a5c0:	e0bffd17 	ldw	r2,-12(fp)
8113a5c4:	10800117 	ldw	r2,4(r2)
8113a5c8:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113a5cc:	d0e09c17 	ldw	r3,-32144(gp)
8113a5d0:	e0bff817 	ldw	r2,-32(fp)
8113a5d4:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113a5d8:	e0bff817 	ldw	r2,-32(fp)
8113a5dc:	d0a09c15 	stw	r2,-32144(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113a5e0:	e0bffd17 	ldw	r2,-12(fp)
8113a5e4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113a5e8:	d0e09f17 	ldw	r3,-32132(gp)
8113a5ec:	e0bffd17 	ldw	r2,-12(fp)
8113a5f0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113a5f4:	e0bffd17 	ldw	r2,-12(fp)
8113a5f8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113a5fc:	e0bffd17 	ldw	r2,-12(fp)
8113a600:	d0a09f15 	stw	r2,-32132(gp)
8113a604:	e0bff617 	ldw	r2,-40(fp)
8113a608:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a60c:	e0bff717 	ldw	r2,-36(fp)
8113a610:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113a614:	e0bfff17 	ldw	r2,-4(fp)
8113a618:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113a61c:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113a620:	00003f06 	br	8113a720 <OSQDel+0x270>
8113a624:	e0bff617 	ldw	r2,-40(fp)
8113a628:	e0bff915 	stw	r2,-28(fp)
8113a62c:	e0bff917 	ldw	r2,-28(fp)
8113a630:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113a634:	e0bfff17 	ldw	r2,-4(fp)
8113a638:	00c01244 	movi	r3,73
8113a63c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113a640:	e0bffd17 	ldw	r2,-12(fp)
8113a644:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113a648:	00003506 	br	8113a720 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113a64c:	000f883a 	mov	r7,zero
8113a650:	01800104 	movi	r6,4
8113a654:	000b883a 	mov	r5,zero
8113a658:	e13ffd17 	ldw	r4,-12(fp)
8113a65c:	1135d840 	call	81135d84 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113a660:	e0bffd17 	ldw	r2,-12(fp)
8113a664:	10800283 	ldbu	r2,10(r2)
8113a668:	10803fcc 	andi	r2,r2,255
8113a66c:	103ff71e 	bne	r2,zero,8113a64c <__reset+0xfb11a64c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113a670:	e0bffd17 	ldw	r2,-12(fp)
8113a674:	00c00fc4 	movi	r3,63
8113a678:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113a67c:	e0bffd17 	ldw	r2,-12(fp)
8113a680:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113a684:	e0bffd17 	ldw	r2,-12(fp)
8113a688:	10800117 	ldw	r2,4(r2)
8113a68c:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113a690:	d0e09c17 	ldw	r3,-32144(gp)
8113a694:	e0bff817 	ldw	r2,-32(fp)
8113a698:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113a69c:	e0bff817 	ldw	r2,-32(fp)
8113a6a0:	d0a09c15 	stw	r2,-32144(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113a6a4:	e0bffd17 	ldw	r2,-12(fp)
8113a6a8:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113a6ac:	d0e09f17 	ldw	r3,-32132(gp)
8113a6b0:	e0bffd17 	ldw	r2,-12(fp)
8113a6b4:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113a6b8:	e0bffd17 	ldw	r2,-12(fp)
8113a6bc:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113a6c0:	e0bffd17 	ldw	r2,-12(fp)
8113a6c4:	d0a09f15 	stw	r2,-32132(gp)
8113a6c8:	e0bff617 	ldw	r2,-40(fp)
8113a6cc:	e0bffa15 	stw	r2,-24(fp)
8113a6d0:	e0bffa17 	ldw	r2,-24(fp)
8113a6d4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113a6d8:	e0bff403 	ldbu	r2,-48(fp)
8113a6dc:	10800058 	cmpnei	r2,r2,1
8113a6e0:	1000011e 	bne	r2,zero,8113a6e8 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113a6e4:	11368400 	call	81136840 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113a6e8:	e0bfff17 	ldw	r2,-4(fp)
8113a6ec:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113a6f0:	e03ff515 	stw	zero,-44(fp)
             break;
8113a6f4:	00000a06 	br	8113a720 <OSQDel+0x270>
8113a6f8:	e0bff617 	ldw	r2,-40(fp)
8113a6fc:	e0bffb15 	stw	r2,-20(fp)
8113a700:	e0bffb17 	ldw	r2,-20(fp)
8113a704:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113a708:	e0bfff17 	ldw	r2,-4(fp)
8113a70c:	00c001c4 	movi	r3,7
8113a710:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113a714:	e0bffd17 	ldw	r2,-12(fp)
8113a718:	e0bff515 	stw	r2,-44(fp)
             break;
8113a71c:	0001883a 	nop
    }
    return (pevent_return);
8113a720:	e0bff517 	ldw	r2,-44(fp)
}
8113a724:	e037883a 	mov	sp,fp
8113a728:	dfc00117 	ldw	ra,4(sp)
8113a72c:	df000017 	ldw	fp,0(sp)
8113a730:	dec00204 	addi	sp,sp,8
8113a734:	f800283a 	ret

8113a738 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113a738:	defffa04 	addi	sp,sp,-24
8113a73c:	de00012e 	bgeu	sp,et,8113a744 <OSQFlush+0xc>
8113a740:	003b68fa 	trap	3
8113a744:	df000515 	stw	fp,20(sp)
8113a748:	df000504 	addi	fp,sp,20
8113a74c:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a750:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a754:	e0bfff17 	ldw	r2,-4(fp)
8113a758:	1000021e 	bne	r2,zero,8113a764 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113a75c:	00800104 	movi	r2,4
8113a760:	00002106 	br	8113a7e8 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113a764:	e0bfff17 	ldw	r2,-4(fp)
8113a768:	10800003 	ldbu	r2,0(r2)
8113a76c:	10803fcc 	andi	r2,r2,255
8113a770:	108000a0 	cmpeqi	r2,r2,2
8113a774:	1000021e 	bne	r2,zero,8113a780 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113a778:	00800044 	movi	r2,1
8113a77c:	00001a06 	br	8113a7e8 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a780:	0005303a 	rdctl	r2,status
8113a784:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a788:	e0fffd17 	ldw	r3,-12(fp)
8113a78c:	00bfff84 	movi	r2,-2
8113a790:	1884703a 	and	r2,r3,r2
8113a794:	1001703a 	wrctl	status,r2
  
  return context;
8113a798:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a79c:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113a7a0:	e0bfff17 	ldw	r2,-4(fp)
8113a7a4:	10800117 	ldw	r2,4(r2)
8113a7a8:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113a7ac:	e0bffc17 	ldw	r2,-16(fp)
8113a7b0:	10c00117 	ldw	r3,4(r2)
8113a7b4:	e0bffc17 	ldw	r2,-16(fp)
8113a7b8:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113a7bc:	e0bffc17 	ldw	r2,-16(fp)
8113a7c0:	10c00117 	ldw	r3,4(r2)
8113a7c4:	e0bffc17 	ldw	r2,-16(fp)
8113a7c8:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113a7cc:	e0bffc17 	ldw	r2,-16(fp)
8113a7d0:	1000058d 	sth	zero,22(r2)
8113a7d4:	e0bffb17 	ldw	r2,-20(fp)
8113a7d8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a7dc:	e0bffe17 	ldw	r2,-8(fp)
8113a7e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a7e4:	0005883a 	mov	r2,zero
}
8113a7e8:	e037883a 	mov	sp,fp
8113a7ec:	df000017 	ldw	fp,0(sp)
8113a7f0:	dec00104 	addi	sp,sp,4
8113a7f4:	f800283a 	ret

8113a7f8 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113a7f8:	defff304 	addi	sp,sp,-52
8113a7fc:	de00012e 	bgeu	sp,et,8113a804 <OSQPend+0xc>
8113a800:	003b68fa 	trap	3
8113a804:	dfc00c15 	stw	ra,48(sp)
8113a808:	df000b15 	stw	fp,44(sp)
8113a80c:	df000b04 	addi	fp,sp,44
8113a810:	e13ffd15 	stw	r4,-12(fp)
8113a814:	2805883a 	mov	r2,r5
8113a818:	e1bfff15 	stw	r6,-4(fp)
8113a81c:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a820:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a824:	e0bfff17 	ldw	r2,-4(fp)
8113a828:	1000021e 	bne	r2,zero,8113a834 <OSQPend+0x3c>
        return ((void *)0);
8113a82c:	0005883a 	mov	r2,zero
8113a830:	00009106 	br	8113aa78 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113a834:	e0bffd17 	ldw	r2,-12(fp)
8113a838:	1000051e 	bne	r2,zero,8113a850 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113a83c:	e0bfff17 	ldw	r2,-4(fp)
8113a840:	00c00104 	movi	r3,4
8113a844:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113a848:	0005883a 	mov	r2,zero
8113a84c:	00008a06 	br	8113aa78 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113a850:	e0bffd17 	ldw	r2,-12(fp)
8113a854:	10800003 	ldbu	r2,0(r2)
8113a858:	10803fcc 	andi	r2,r2,255
8113a85c:	108000a0 	cmpeqi	r2,r2,2
8113a860:	1000051e 	bne	r2,zero,8113a878 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113a864:	e0bfff17 	ldw	r2,-4(fp)
8113a868:	00c00044 	movi	r3,1
8113a86c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113a870:	0005883a 	mov	r2,zero
8113a874:	00008006 	br	8113aa78 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113a878:	d0a0a003 	ldbu	r2,-32128(gp)
8113a87c:	10803fcc 	andi	r2,r2,255
8113a880:	10000526 	beq	r2,zero,8113a898 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113a884:	e0bfff17 	ldw	r2,-4(fp)
8113a888:	00c00084 	movi	r3,2
8113a88c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113a890:	0005883a 	mov	r2,zero
8113a894:	00007806 	br	8113aa78 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113a898:	d0a08e03 	ldbu	r2,-32200(gp)
8113a89c:	10803fcc 	andi	r2,r2,255
8113a8a0:	10000526 	beq	r2,zero,8113a8b8 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113a8a4:	e0bfff17 	ldw	r2,-4(fp)
8113a8a8:	00c00344 	movi	r3,13
8113a8ac:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113a8b0:	0005883a 	mov	r2,zero
8113a8b4:	00007006 	br	8113aa78 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a8b8:	0005303a 	rdctl	r2,status
8113a8bc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a8c0:	e0fffc17 	ldw	r3,-16(fp)
8113a8c4:	00bfff84 	movi	r2,-2
8113a8c8:	1884703a 	and	r2,r3,r2
8113a8cc:	1001703a 	wrctl	status,r2
  
  return context;
8113a8d0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a8d4:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113a8d8:	e0bffd17 	ldw	r2,-12(fp)
8113a8dc:	10800117 	ldw	r2,4(r2)
8113a8e0:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113a8e4:	e0bff817 	ldw	r2,-32(fp)
8113a8e8:	1080058b 	ldhu	r2,22(r2)
8113a8ec:	10bfffcc 	andi	r2,r2,65535
8113a8f0:	10001e26 	beq	r2,zero,8113a96c <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113a8f4:	e0bff817 	ldw	r2,-32(fp)
8113a8f8:	10800417 	ldw	r2,16(r2)
8113a8fc:	11000104 	addi	r4,r2,4
8113a900:	e0fff817 	ldw	r3,-32(fp)
8113a904:	19000415 	stw	r4,16(r3)
8113a908:	10800017 	ldw	r2,0(r2)
8113a90c:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113a910:	e0bff817 	ldw	r2,-32(fp)
8113a914:	1080058b 	ldhu	r2,22(r2)
8113a918:	10bfffc4 	addi	r2,r2,-1
8113a91c:	1007883a 	mov	r3,r2
8113a920:	e0bff817 	ldw	r2,-32(fp)
8113a924:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113a928:	e0bff817 	ldw	r2,-32(fp)
8113a92c:	10c00417 	ldw	r3,16(r2)
8113a930:	e0bff817 	ldw	r2,-32(fp)
8113a934:	10800217 	ldw	r2,8(r2)
8113a938:	1880041e 	bne	r3,r2,8113a94c <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113a93c:	e0bff817 	ldw	r2,-32(fp)
8113a940:	10c00117 	ldw	r3,4(r2)
8113a944:	e0bff817 	ldw	r2,-32(fp)
8113a948:	10c00415 	stw	r3,16(r2)
8113a94c:	e0bff617 	ldw	r2,-40(fp)
8113a950:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a954:	e0bff717 	ldw	r2,-36(fp)
8113a958:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113a95c:	e0bfff17 	ldw	r2,-4(fp)
8113a960:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113a964:	e0bff517 	ldw	r2,-44(fp)
8113a968:	00004306 	br	8113aa78 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113a96c:	d0a0a117 	ldw	r2,-32124(gp)
8113a970:	d0e0a117 	ldw	r3,-32124(gp)
8113a974:	18c00c03 	ldbu	r3,48(r3)
8113a978:	18c00114 	ori	r3,r3,4
8113a97c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113a980:	d0a0a117 	ldw	r2,-32124(gp)
8113a984:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113a988:	d0a0a117 	ldw	r2,-32124(gp)
8113a98c:	e0fffe0b 	ldhu	r3,-8(fp)
8113a990:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113a994:	e13ffd17 	ldw	r4,-12(fp)
8113a998:	1135f240 	call	81135f24 <OS_EventTaskWait>
8113a99c:	e0bff617 	ldw	r2,-40(fp)
8113a9a0:	e0bffb15 	stw	r2,-20(fp)
8113a9a4:	e0bffb17 	ldw	r2,-20(fp)
8113a9a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113a9ac:	11368400 	call	81136840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a9b0:	0005303a 	rdctl	r2,status
8113a9b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a9b8:	e0fff917 	ldw	r3,-28(fp)
8113a9bc:	00bfff84 	movi	r2,-2
8113a9c0:	1884703a 	and	r2,r3,r2
8113a9c4:	1001703a 	wrctl	status,r2
  
  return context;
8113a9c8:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113a9cc:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113a9d0:	d0a0a117 	ldw	r2,-32124(gp)
8113a9d4:	10800c43 	ldbu	r2,49(r2)
8113a9d8:	10803fcc 	andi	r2,r2,255
8113a9dc:	10000326 	beq	r2,zero,8113a9ec <OSQPend+0x1f4>
8113a9e0:	108000a0 	cmpeqi	r2,r2,2
8113a9e4:	1000071e 	bne	r2,zero,8113aa04 <OSQPend+0x20c>
8113a9e8:	00000b06 	br	8113aa18 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113a9ec:	d0a0a117 	ldw	r2,-32124(gp)
8113a9f0:	10800917 	ldw	r2,36(r2)
8113a9f4:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113a9f8:	e0bfff17 	ldw	r2,-4(fp)
8113a9fc:	10000005 	stb	zero,0(r2)
             break;
8113aa00:	00000e06 	br	8113aa3c <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113aa04:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113aa08:	e0bfff17 	ldw	r2,-4(fp)
8113aa0c:	00c00384 	movi	r3,14
8113aa10:	10c00005 	stb	r3,0(r2)
             break;
8113aa14:	00000906 	br	8113aa3c <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113aa18:	d0a0a117 	ldw	r2,-32124(gp)
8113aa1c:	e17ffd17 	ldw	r5,-12(fp)
8113aa20:	1009883a 	mov	r4,r2
8113aa24:	11361940 	call	81136194 <OS_EventTaskRemove>
             pmsg = (void *)0;
8113aa28:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113aa2c:	e0bfff17 	ldw	r2,-4(fp)
8113aa30:	00c00284 	movi	r3,10
8113aa34:	10c00005 	stb	r3,0(r2)
             break;
8113aa38:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113aa3c:	d0a0a117 	ldw	r2,-32124(gp)
8113aa40:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113aa44:	d0a0a117 	ldw	r2,-32124(gp)
8113aa48:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113aa4c:	d0a0a117 	ldw	r2,-32124(gp)
8113aa50:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113aa54:	d0a0a117 	ldw	r2,-32124(gp)
8113aa58:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113aa5c:	d0a0a117 	ldw	r2,-32124(gp)
8113aa60:	10000915 	stw	zero,36(r2)
8113aa64:	e0bff617 	ldw	r2,-40(fp)
8113aa68:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aa6c:	e0bffa17 	ldw	r2,-24(fp)
8113aa70:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113aa74:	e0bff517 	ldw	r2,-44(fp)
}
8113aa78:	e037883a 	mov	sp,fp
8113aa7c:	dfc00117 	ldw	ra,4(sp)
8113aa80:	df000017 	ldw	fp,0(sp)
8113aa84:	dec00204 	addi	sp,sp,8
8113aa88:	f800283a 	ret

8113aa8c <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113aa8c:	defff604 	addi	sp,sp,-40
8113aa90:	de00012e 	bgeu	sp,et,8113aa98 <OSQPendAbort+0xc>
8113aa94:	003b68fa 	trap	3
8113aa98:	dfc00915 	stw	ra,36(sp)
8113aa9c:	df000815 	stw	fp,32(sp)
8113aaa0:	df000804 	addi	fp,sp,32
8113aaa4:	e13ffd15 	stw	r4,-12(fp)
8113aaa8:	2805883a 	mov	r2,r5
8113aaac:	e1bfff15 	stw	r6,-4(fp)
8113aab0:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113aab4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113aab8:	e0bfff17 	ldw	r2,-4(fp)
8113aabc:	1000021e 	bne	r2,zero,8113aac8 <OSQPendAbort+0x3c>
        return (0);
8113aac0:	0005883a 	mov	r2,zero
8113aac4:	00004906 	br	8113abec <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113aac8:	e0bffd17 	ldw	r2,-12(fp)
8113aacc:	1000051e 	bne	r2,zero,8113aae4 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113aad0:	e0bfff17 	ldw	r2,-4(fp)
8113aad4:	00c00104 	movi	r3,4
8113aad8:	10c00005 	stb	r3,0(r2)
        return (0);
8113aadc:	0005883a 	mov	r2,zero
8113aae0:	00004206 	br	8113abec <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113aae4:	e0bffd17 	ldw	r2,-12(fp)
8113aae8:	10800003 	ldbu	r2,0(r2)
8113aaec:	10803fcc 	andi	r2,r2,255
8113aaf0:	108000a0 	cmpeqi	r2,r2,2
8113aaf4:	1000051e 	bne	r2,zero,8113ab0c <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113aaf8:	e0bfff17 	ldw	r2,-4(fp)
8113aafc:	00c00044 	movi	r3,1
8113ab00:	10c00005 	stb	r3,0(r2)
        return (0);
8113ab04:	0005883a 	mov	r2,zero
8113ab08:	00003806 	br	8113abec <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ab0c:	0005303a 	rdctl	r2,status
8113ab10:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ab14:	e0fffc17 	ldw	r3,-16(fp)
8113ab18:	00bfff84 	movi	r2,-2
8113ab1c:	1884703a 	and	r2,r3,r2
8113ab20:	1001703a 	wrctl	status,r2
  
  return context;
8113ab24:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ab28:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113ab2c:	e0bffd17 	ldw	r2,-12(fp)
8113ab30:	10800283 	ldbu	r2,10(r2)
8113ab34:	10803fcc 	andi	r2,r2,255
8113ab38:	10002526 	beq	r2,zero,8113abd0 <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113ab3c:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113ab40:	e0bffe03 	ldbu	r2,-8(fp)
8113ab44:	10800060 	cmpeqi	r2,r2,1
8113ab48:	10000e26 	beq	r2,zero,8113ab84 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113ab4c:	00000806 	br	8113ab70 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113ab50:	01c00084 	movi	r7,2
8113ab54:	01800104 	movi	r6,4
8113ab58:	000b883a 	mov	r5,zero
8113ab5c:	e13ffd17 	ldw	r4,-12(fp)
8113ab60:	1135d840 	call	81135d84 <OS_EventTaskRdy>
                     nbr_tasks++;
8113ab64:	e0bff803 	ldbu	r2,-32(fp)
8113ab68:	10800044 	addi	r2,r2,1
8113ab6c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113ab70:	e0bffd17 	ldw	r2,-12(fp)
8113ab74:	10800283 	ldbu	r2,10(r2)
8113ab78:	10803fcc 	andi	r2,r2,255
8113ab7c:	103ff41e 	bne	r2,zero,8113ab50 <__reset+0xfb11ab50>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113ab80:	00000906 	br	8113aba8 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113ab84:	01c00084 	movi	r7,2
8113ab88:	01800104 	movi	r6,4
8113ab8c:	000b883a 	mov	r5,zero
8113ab90:	e13ffd17 	ldw	r4,-12(fp)
8113ab94:	1135d840 	call	81135d84 <OS_EventTaskRdy>
                 nbr_tasks++;
8113ab98:	e0bff803 	ldbu	r2,-32(fp)
8113ab9c:	10800044 	addi	r2,r2,1
8113aba0:	e0bff805 	stb	r2,-32(fp)
                 break;
8113aba4:	0001883a 	nop
8113aba8:	e0bff917 	ldw	r2,-28(fp)
8113abac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113abb0:	e0bffa17 	ldw	r2,-24(fp)
8113abb4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113abb8:	11368400 	call	81136840 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113abbc:	e0bfff17 	ldw	r2,-4(fp)
8113abc0:	00c00384 	movi	r3,14
8113abc4:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113abc8:	e0bff803 	ldbu	r2,-32(fp)
8113abcc:	00000706 	br	8113abec <OSQPendAbort+0x160>
8113abd0:	e0bff917 	ldw	r2,-28(fp)
8113abd4:	e0bffb15 	stw	r2,-20(fp)
8113abd8:	e0bffb17 	ldw	r2,-20(fp)
8113abdc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113abe0:	e0bfff17 	ldw	r2,-4(fp)
8113abe4:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113abe8:	0005883a 	mov	r2,zero
}
8113abec:	e037883a 	mov	sp,fp
8113abf0:	dfc00117 	ldw	ra,4(sp)
8113abf4:	df000017 	ldw	fp,0(sp)
8113abf8:	dec00204 	addi	sp,sp,8
8113abfc:	f800283a 	ret

8113ac00 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113ac00:	defff604 	addi	sp,sp,-40
8113ac04:	de00012e 	bgeu	sp,et,8113ac0c <OSQPost+0xc>
8113ac08:	003b68fa 	trap	3
8113ac0c:	dfc00915 	stw	ra,36(sp)
8113ac10:	df000815 	stw	fp,32(sp)
8113ac14:	df000804 	addi	fp,sp,32
8113ac18:	e13ffe15 	stw	r4,-8(fp)
8113ac1c:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113ac20:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113ac24:	e0bffe17 	ldw	r2,-8(fp)
8113ac28:	1000021e 	bne	r2,zero,8113ac34 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113ac2c:	00800104 	movi	r2,4
8113ac30:	00004a06 	br	8113ad5c <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113ac34:	e0bffe17 	ldw	r2,-8(fp)
8113ac38:	10800003 	ldbu	r2,0(r2)
8113ac3c:	10803fcc 	andi	r2,r2,255
8113ac40:	108000a0 	cmpeqi	r2,r2,2
8113ac44:	1000021e 	bne	r2,zero,8113ac50 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113ac48:	00800044 	movi	r2,1
8113ac4c:	00004306 	br	8113ad5c <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ac50:	0005303a 	rdctl	r2,status
8113ac54:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ac58:	e0fffd17 	ldw	r3,-12(fp)
8113ac5c:	00bfff84 	movi	r2,-2
8113ac60:	1884703a 	and	r2,r3,r2
8113ac64:	1001703a 	wrctl	status,r2
  
  return context;
8113ac68:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113ac6c:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113ac70:	e0bffe17 	ldw	r2,-8(fp)
8113ac74:	10800283 	ldbu	r2,10(r2)
8113ac78:	10803fcc 	andi	r2,r2,255
8113ac7c:	10000c26 	beq	r2,zero,8113acb0 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113ac80:	000f883a 	mov	r7,zero
8113ac84:	01800104 	movi	r6,4
8113ac88:	e17fff17 	ldw	r5,-4(fp)
8113ac8c:	e13ffe17 	ldw	r4,-8(fp)
8113ac90:	1135d840 	call	81135d84 <OS_EventTaskRdy>
8113ac94:	e0bff817 	ldw	r2,-32(fp)
8113ac98:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ac9c:	e0bff917 	ldw	r2,-28(fp)
8113aca0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113aca4:	11368400 	call	81136840 <OS_Sched>
        return (OS_ERR_NONE);
8113aca8:	0005883a 	mov	r2,zero
8113acac:	00002b06 	br	8113ad5c <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113acb0:	e0bffe17 	ldw	r2,-8(fp)
8113acb4:	10800117 	ldw	r2,4(r2)
8113acb8:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113acbc:	e0bffb17 	ldw	r2,-20(fp)
8113acc0:	10c0058b 	ldhu	r3,22(r2)
8113acc4:	e0bffb17 	ldw	r2,-20(fp)
8113acc8:	1080050b 	ldhu	r2,20(r2)
8113accc:	18ffffcc 	andi	r3,r3,65535
8113acd0:	10bfffcc 	andi	r2,r2,65535
8113acd4:	18800636 	bltu	r3,r2,8113acf0 <OSQPost+0xf0>
8113acd8:	e0bff817 	ldw	r2,-32(fp)
8113acdc:	e0bffa15 	stw	r2,-24(fp)
8113ace0:	e0bffa17 	ldw	r2,-24(fp)
8113ace4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113ace8:	00800784 	movi	r2,30
8113acec:	00001b06 	br	8113ad5c <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113acf0:	e0bffb17 	ldw	r2,-20(fp)
8113acf4:	10800317 	ldw	r2,12(r2)
8113acf8:	11000104 	addi	r4,r2,4
8113acfc:	e0fffb17 	ldw	r3,-20(fp)
8113ad00:	19000315 	stw	r4,12(r3)
8113ad04:	e0ffff17 	ldw	r3,-4(fp)
8113ad08:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113ad0c:	e0bffb17 	ldw	r2,-20(fp)
8113ad10:	1080058b 	ldhu	r2,22(r2)
8113ad14:	10800044 	addi	r2,r2,1
8113ad18:	1007883a 	mov	r3,r2
8113ad1c:	e0bffb17 	ldw	r2,-20(fp)
8113ad20:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113ad24:	e0bffb17 	ldw	r2,-20(fp)
8113ad28:	10c00317 	ldw	r3,12(r2)
8113ad2c:	e0bffb17 	ldw	r2,-20(fp)
8113ad30:	10800217 	ldw	r2,8(r2)
8113ad34:	1880041e 	bne	r3,r2,8113ad48 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113ad38:	e0bffb17 	ldw	r2,-20(fp)
8113ad3c:	10c00117 	ldw	r3,4(r2)
8113ad40:	e0bffb17 	ldw	r2,-20(fp)
8113ad44:	10c00315 	stw	r3,12(r2)
8113ad48:	e0bff817 	ldw	r2,-32(fp)
8113ad4c:	e0bffc15 	stw	r2,-16(fp)
8113ad50:	e0bffc17 	ldw	r2,-16(fp)
8113ad54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113ad58:	0005883a 	mov	r2,zero
}
8113ad5c:	e037883a 	mov	sp,fp
8113ad60:	dfc00117 	ldw	ra,4(sp)
8113ad64:	df000017 	ldw	fp,0(sp)
8113ad68:	dec00204 	addi	sp,sp,8
8113ad6c:	f800283a 	ret

8113ad70 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113ad70:	defff604 	addi	sp,sp,-40
8113ad74:	de00012e 	bgeu	sp,et,8113ad7c <OSQPostFront+0xc>
8113ad78:	003b68fa 	trap	3
8113ad7c:	dfc00915 	stw	ra,36(sp)
8113ad80:	df000815 	stw	fp,32(sp)
8113ad84:	df000804 	addi	fp,sp,32
8113ad88:	e13ffe15 	stw	r4,-8(fp)
8113ad8c:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ad90:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ad94:	e0bffe17 	ldw	r2,-8(fp)
8113ad98:	1000021e 	bne	r2,zero,8113ada4 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113ad9c:	00800104 	movi	r2,4
8113ada0:	00004c06 	br	8113aed4 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113ada4:	e0bffe17 	ldw	r2,-8(fp)
8113ada8:	10800003 	ldbu	r2,0(r2)
8113adac:	10803fcc 	andi	r2,r2,255
8113adb0:	108000a0 	cmpeqi	r2,r2,2
8113adb4:	1000021e 	bne	r2,zero,8113adc0 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113adb8:	00800044 	movi	r2,1
8113adbc:	00004506 	br	8113aed4 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113adc0:	0005303a 	rdctl	r2,status
8113adc4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113adc8:	e0fffd17 	ldw	r3,-12(fp)
8113adcc:	00bfff84 	movi	r2,-2
8113add0:	1884703a 	and	r2,r3,r2
8113add4:	1001703a 	wrctl	status,r2
  
  return context;
8113add8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113addc:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113ade0:	e0bffe17 	ldw	r2,-8(fp)
8113ade4:	10800283 	ldbu	r2,10(r2)
8113ade8:	10803fcc 	andi	r2,r2,255
8113adec:	10000c26 	beq	r2,zero,8113ae20 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113adf0:	000f883a 	mov	r7,zero
8113adf4:	01800104 	movi	r6,4
8113adf8:	e17fff17 	ldw	r5,-4(fp)
8113adfc:	e13ffe17 	ldw	r4,-8(fp)
8113ae00:	1135d840 	call	81135d84 <OS_EventTaskRdy>
8113ae04:	e0bff817 	ldw	r2,-32(fp)
8113ae08:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ae0c:	e0bff917 	ldw	r2,-28(fp)
8113ae10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113ae14:	11368400 	call	81136840 <OS_Sched>
        return (OS_ERR_NONE);
8113ae18:	0005883a 	mov	r2,zero
8113ae1c:	00002d06 	br	8113aed4 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113ae20:	e0bffe17 	ldw	r2,-8(fp)
8113ae24:	10800117 	ldw	r2,4(r2)
8113ae28:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113ae2c:	e0bffb17 	ldw	r2,-20(fp)
8113ae30:	10c0058b 	ldhu	r3,22(r2)
8113ae34:	e0bffb17 	ldw	r2,-20(fp)
8113ae38:	1080050b 	ldhu	r2,20(r2)
8113ae3c:	18ffffcc 	andi	r3,r3,65535
8113ae40:	10bfffcc 	andi	r2,r2,65535
8113ae44:	18800636 	bltu	r3,r2,8113ae60 <OSQPostFront+0xf0>
8113ae48:	e0bff817 	ldw	r2,-32(fp)
8113ae4c:	e0bffa15 	stw	r2,-24(fp)
8113ae50:	e0bffa17 	ldw	r2,-24(fp)
8113ae54:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113ae58:	00800784 	movi	r2,30
8113ae5c:	00001d06 	br	8113aed4 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113ae60:	e0bffb17 	ldw	r2,-20(fp)
8113ae64:	10c00417 	ldw	r3,16(r2)
8113ae68:	e0bffb17 	ldw	r2,-20(fp)
8113ae6c:	10800117 	ldw	r2,4(r2)
8113ae70:	1880041e 	bne	r3,r2,8113ae84 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113ae74:	e0bffb17 	ldw	r2,-20(fp)
8113ae78:	10c00217 	ldw	r3,8(r2)
8113ae7c:	e0bffb17 	ldw	r2,-20(fp)
8113ae80:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113ae84:	e0bffb17 	ldw	r2,-20(fp)
8113ae88:	10800417 	ldw	r2,16(r2)
8113ae8c:	10ffff04 	addi	r3,r2,-4
8113ae90:	e0bffb17 	ldw	r2,-20(fp)
8113ae94:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113ae98:	e0bffb17 	ldw	r2,-20(fp)
8113ae9c:	10800417 	ldw	r2,16(r2)
8113aea0:	e0ffff17 	ldw	r3,-4(fp)
8113aea4:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113aea8:	e0bffb17 	ldw	r2,-20(fp)
8113aeac:	1080058b 	ldhu	r2,22(r2)
8113aeb0:	10800044 	addi	r2,r2,1
8113aeb4:	1007883a 	mov	r3,r2
8113aeb8:	e0bffb17 	ldw	r2,-20(fp)
8113aebc:	10c0058d 	sth	r3,22(r2)
8113aec0:	e0bff817 	ldw	r2,-32(fp)
8113aec4:	e0bffc15 	stw	r2,-16(fp)
8113aec8:	e0bffc17 	ldw	r2,-16(fp)
8113aecc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113aed0:	0005883a 	mov	r2,zero
}
8113aed4:	e037883a 	mov	sp,fp
8113aed8:	dfc00117 	ldw	ra,4(sp)
8113aedc:	df000017 	ldw	fp,0(sp)
8113aee0:	dec00204 	addi	sp,sp,8
8113aee4:	f800283a 	ret

8113aee8 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113aee8:	defff504 	addi	sp,sp,-44
8113aeec:	de00012e 	bgeu	sp,et,8113aef4 <OSQPostOpt+0xc>
8113aef0:	003b68fa 	trap	3
8113aef4:	dfc00a15 	stw	ra,40(sp)
8113aef8:	df000915 	stw	fp,36(sp)
8113aefc:	df000904 	addi	fp,sp,36
8113af00:	e13ffd15 	stw	r4,-12(fp)
8113af04:	e17ffe15 	stw	r5,-8(fp)
8113af08:	3005883a 	mov	r2,r6
8113af0c:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113af10:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113af14:	e0bffd17 	ldw	r2,-12(fp)
8113af18:	1000021e 	bne	r2,zero,8113af24 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113af1c:	00800104 	movi	r2,4
8113af20:	00007106 	br	8113b0e8 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113af24:	e0bffd17 	ldw	r2,-12(fp)
8113af28:	10800003 	ldbu	r2,0(r2)
8113af2c:	10803fcc 	andi	r2,r2,255
8113af30:	108000a0 	cmpeqi	r2,r2,2
8113af34:	1000021e 	bne	r2,zero,8113af40 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113af38:	00800044 	movi	r2,1
8113af3c:	00006a06 	br	8113b0e8 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113af40:	0005303a 	rdctl	r2,status
8113af44:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113af48:	e0fffc17 	ldw	r3,-16(fp)
8113af4c:	00bfff84 	movi	r2,-2
8113af50:	1884703a 	and	r2,r3,r2
8113af54:	1001703a 	wrctl	status,r2
  
  return context;
8113af58:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113af5c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113af60:	e0bffd17 	ldw	r2,-12(fp)
8113af64:	10800283 	ldbu	r2,10(r2)
8113af68:	10803fcc 	andi	r2,r2,255
8113af6c:	10001d26 	beq	r2,zero,8113afe4 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113af70:	e0bfff03 	ldbu	r2,-4(fp)
8113af74:	1080004c 	andi	r2,r2,1
8113af78:	10000b26 	beq	r2,zero,8113afa8 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113af7c:	00000506 	br	8113af94 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113af80:	000f883a 	mov	r7,zero
8113af84:	01800104 	movi	r6,4
8113af88:	e17ffe17 	ldw	r5,-8(fp)
8113af8c:	e13ffd17 	ldw	r4,-12(fp)
8113af90:	1135d840 	call	81135d84 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113af94:	e0bffd17 	ldw	r2,-12(fp)
8113af98:	10800283 	ldbu	r2,10(r2)
8113af9c:	10803fcc 	andi	r2,r2,255
8113afa0:	103ff71e 	bne	r2,zero,8113af80 <__reset+0xfb11af80>
8113afa4:	00000506 	br	8113afbc <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113afa8:	000f883a 	mov	r7,zero
8113afac:	01800104 	movi	r6,4
8113afb0:	e17ffe17 	ldw	r5,-8(fp)
8113afb4:	e13ffd17 	ldw	r4,-12(fp)
8113afb8:	1135d840 	call	81135d84 <OS_EventTaskRdy>
8113afbc:	e0bff717 	ldw	r2,-36(fp)
8113afc0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113afc4:	e0bff817 	ldw	r2,-32(fp)
8113afc8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113afcc:	e0bfff03 	ldbu	r2,-4(fp)
8113afd0:	1080010c 	andi	r2,r2,4
8113afd4:	1000011e 	bne	r2,zero,8113afdc <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113afd8:	11368400 	call	81136840 <OS_Sched>
        }
        return (OS_ERR_NONE);
8113afdc:	0005883a 	mov	r2,zero
8113afe0:	00004106 	br	8113b0e8 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113afe4:	e0bffd17 	ldw	r2,-12(fp)
8113afe8:	10800117 	ldw	r2,4(r2)
8113afec:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113aff0:	e0bffa17 	ldw	r2,-24(fp)
8113aff4:	10c0058b 	ldhu	r3,22(r2)
8113aff8:	e0bffa17 	ldw	r2,-24(fp)
8113affc:	1080050b 	ldhu	r2,20(r2)
8113b000:	18ffffcc 	andi	r3,r3,65535
8113b004:	10bfffcc 	andi	r2,r2,65535
8113b008:	18800636 	bltu	r3,r2,8113b024 <OSQPostOpt+0x13c>
8113b00c:	e0bff717 	ldw	r2,-36(fp)
8113b010:	e0bff915 	stw	r2,-28(fp)
8113b014:	e0bff917 	ldw	r2,-28(fp)
8113b018:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113b01c:	00800784 	movi	r2,30
8113b020:	00003106 	br	8113b0e8 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113b024:	e0bfff03 	ldbu	r2,-4(fp)
8113b028:	1080008c 	andi	r2,r2,2
8113b02c:	10001326 	beq	r2,zero,8113b07c <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113b030:	e0bffa17 	ldw	r2,-24(fp)
8113b034:	10c00417 	ldw	r3,16(r2)
8113b038:	e0bffa17 	ldw	r2,-24(fp)
8113b03c:	10800117 	ldw	r2,4(r2)
8113b040:	1880041e 	bne	r3,r2,8113b054 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113b044:	e0bffa17 	ldw	r2,-24(fp)
8113b048:	10c00217 	ldw	r3,8(r2)
8113b04c:	e0bffa17 	ldw	r2,-24(fp)
8113b050:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113b054:	e0bffa17 	ldw	r2,-24(fp)
8113b058:	10800417 	ldw	r2,16(r2)
8113b05c:	10ffff04 	addi	r3,r2,-4
8113b060:	e0bffa17 	ldw	r2,-24(fp)
8113b064:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113b068:	e0bffa17 	ldw	r2,-24(fp)
8113b06c:	10800417 	ldw	r2,16(r2)
8113b070:	e0fffe17 	ldw	r3,-8(fp)
8113b074:	10c00015 	stw	r3,0(r2)
8113b078:	00001006 	br	8113b0bc <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113b07c:	e0bffa17 	ldw	r2,-24(fp)
8113b080:	10800317 	ldw	r2,12(r2)
8113b084:	11000104 	addi	r4,r2,4
8113b088:	e0fffa17 	ldw	r3,-24(fp)
8113b08c:	19000315 	stw	r4,12(r3)
8113b090:	e0fffe17 	ldw	r3,-8(fp)
8113b094:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113b098:	e0bffa17 	ldw	r2,-24(fp)
8113b09c:	10c00317 	ldw	r3,12(r2)
8113b0a0:	e0bffa17 	ldw	r2,-24(fp)
8113b0a4:	10800217 	ldw	r2,8(r2)
8113b0a8:	1880041e 	bne	r3,r2,8113b0bc <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113b0ac:	e0bffa17 	ldw	r2,-24(fp)
8113b0b0:	10c00117 	ldw	r3,4(r2)
8113b0b4:	e0bffa17 	ldw	r2,-24(fp)
8113b0b8:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113b0bc:	e0bffa17 	ldw	r2,-24(fp)
8113b0c0:	1080058b 	ldhu	r2,22(r2)
8113b0c4:	10800044 	addi	r2,r2,1
8113b0c8:	1007883a 	mov	r3,r2
8113b0cc:	e0bffa17 	ldw	r2,-24(fp)
8113b0d0:	10c0058d 	sth	r3,22(r2)
8113b0d4:	e0bff717 	ldw	r2,-36(fp)
8113b0d8:	e0bffb15 	stw	r2,-20(fp)
8113b0dc:	e0bffb17 	ldw	r2,-20(fp)
8113b0e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113b0e4:	0005883a 	mov	r2,zero
}
8113b0e8:	e037883a 	mov	sp,fp
8113b0ec:	dfc00117 	ldw	ra,4(sp)
8113b0f0:	df000017 	ldw	fp,0(sp)
8113b0f4:	dec00204 	addi	sp,sp,8
8113b0f8:	f800283a 	ret

8113b0fc <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113b0fc:	defff604 	addi	sp,sp,-40
8113b100:	de00012e 	bgeu	sp,et,8113b108 <OSQQuery+0xc>
8113b104:	003b68fa 	trap	3
8113b108:	df000915 	stw	fp,36(sp)
8113b10c:	df000904 	addi	fp,sp,36
8113b110:	e13ffe15 	stw	r4,-8(fp)
8113b114:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113b118:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113b11c:	e0bffe17 	ldw	r2,-8(fp)
8113b120:	1000021e 	bne	r2,zero,8113b12c <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113b124:	00800104 	movi	r2,4
8113b128:	00004906 	br	8113b250 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113b12c:	e0bfff17 	ldw	r2,-4(fp)
8113b130:	1000021e 	bne	r2,zero,8113b13c <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113b134:	00800244 	movi	r2,9
8113b138:	00004506 	br	8113b250 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113b13c:	e0bffe17 	ldw	r2,-8(fp)
8113b140:	10800003 	ldbu	r2,0(r2)
8113b144:	10803fcc 	andi	r2,r2,255
8113b148:	108000a0 	cmpeqi	r2,r2,2
8113b14c:	1000021e 	bne	r2,zero,8113b158 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113b150:	00800044 	movi	r2,1
8113b154:	00003e06 	br	8113b250 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b158:	0005303a 	rdctl	r2,status
8113b15c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b160:	e0fffd17 	ldw	r3,-12(fp)
8113b164:	00bfff84 	movi	r2,-2
8113b168:	1884703a 	and	r2,r3,r2
8113b16c:	1001703a 	wrctl	status,r2
  
  return context;
8113b170:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113b174:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113b178:	e0bffe17 	ldw	r2,-8(fp)
8113b17c:	10c00283 	ldbu	r3,10(r2)
8113b180:	e0bfff17 	ldw	r2,-4(fp)
8113b184:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113b188:	e0bffe17 	ldw	r2,-8(fp)
8113b18c:	108002c4 	addi	r2,r2,11
8113b190:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113b194:	e0bfff17 	ldw	r2,-4(fp)
8113b198:	10800204 	addi	r2,r2,8
8113b19c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b1a0:	e03ff705 	stb	zero,-36(fp)
8113b1a4:	00000b06 	br	8113b1d4 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113b1a8:	e0bff917 	ldw	r2,-28(fp)
8113b1ac:	10c00044 	addi	r3,r2,1
8113b1b0:	e0fff915 	stw	r3,-28(fp)
8113b1b4:	e0fff817 	ldw	r3,-32(fp)
8113b1b8:	19000044 	addi	r4,r3,1
8113b1bc:	e13ff815 	stw	r4,-32(fp)
8113b1c0:	18c00003 	ldbu	r3,0(r3)
8113b1c4:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b1c8:	e0bff703 	ldbu	r2,-36(fp)
8113b1cc:	10800044 	addi	r2,r2,1
8113b1d0:	e0bff705 	stb	r2,-36(fp)
8113b1d4:	e0bff703 	ldbu	r2,-36(fp)
8113b1d8:	108001b0 	cmpltui	r2,r2,6
8113b1dc:	103ff21e 	bne	r2,zero,8113b1a8 <__reset+0xfb11b1a8>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113b1e0:	e0bffe17 	ldw	r2,-8(fp)
8113b1e4:	10800117 	ldw	r2,4(r2)
8113b1e8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113b1ec:	e0bffc17 	ldw	r2,-16(fp)
8113b1f0:	1080058b 	ldhu	r2,22(r2)
8113b1f4:	10bfffcc 	andi	r2,r2,65535
8113b1f8:	10000626 	beq	r2,zero,8113b214 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113b1fc:	e0bffc17 	ldw	r2,-16(fp)
8113b200:	10800417 	ldw	r2,16(r2)
8113b204:	10c00017 	ldw	r3,0(r2)
8113b208:	e0bfff17 	ldw	r2,-4(fp)
8113b20c:	10c00015 	stw	r3,0(r2)
8113b210:	00000206 	br	8113b21c <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113b214:	e0bfff17 	ldw	r2,-4(fp)
8113b218:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113b21c:	e0bffc17 	ldw	r2,-16(fp)
8113b220:	10c0058b 	ldhu	r3,22(r2)
8113b224:	e0bfff17 	ldw	r2,-4(fp)
8113b228:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113b22c:	e0bffc17 	ldw	r2,-16(fp)
8113b230:	10c0050b 	ldhu	r3,20(r2)
8113b234:	e0bfff17 	ldw	r2,-4(fp)
8113b238:	10c0018d 	sth	r3,6(r2)
8113b23c:	e0bffa17 	ldw	r2,-24(fp)
8113b240:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b244:	e0bffb17 	ldw	r2,-20(fp)
8113b248:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113b24c:	0005883a 	mov	r2,zero
}
8113b250:	e037883a 	mov	sp,fp
8113b254:	df000017 	ldw	fp,0(sp)
8113b258:	dec00104 	addi	sp,sp,4
8113b25c:	f800283a 	ret

8113b260 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113b260:	defffb04 	addi	sp,sp,-20
8113b264:	de00012e 	bgeu	sp,et,8113b26c <OS_QInit+0xc>
8113b268:	003b68fa 	trap	3
8113b26c:	dfc00415 	stw	ra,16(sp)
8113b270:	df000315 	stw	fp,12(sp)
8113b274:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113b278:	0140c004 	movi	r5,768
8113b27c:	012045b4 	movhi	r4,33046
8113b280:	2115f304 	addi	r4,r4,22476
8113b284:	11367740 	call	81136774 <OS_MemClr>
    pq1 = &OSQTbl[0];
8113b288:	00a045b4 	movhi	r2,33046
8113b28c:	1095f304 	addi	r2,r2,22476
8113b290:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113b294:	00a045b4 	movhi	r2,33046
8113b298:	1095f904 	addi	r2,r2,22500
8113b29c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113b2a0:	e03ffd0d 	sth	zero,-12(fp)
8113b2a4:	00000c06 	br	8113b2d8 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113b2a8:	e0bffe17 	ldw	r2,-8(fp)
8113b2ac:	e0ffff17 	ldw	r3,-4(fp)
8113b2b0:	10c00015 	stw	r3,0(r2)
        pq1++;
8113b2b4:	e0bffe17 	ldw	r2,-8(fp)
8113b2b8:	10800604 	addi	r2,r2,24
8113b2bc:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113b2c0:	e0bfff17 	ldw	r2,-4(fp)
8113b2c4:	10800604 	addi	r2,r2,24
8113b2c8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113b2cc:	e0bffd0b 	ldhu	r2,-12(fp)
8113b2d0:	10800044 	addi	r2,r2,1
8113b2d4:	e0bffd0d 	sth	r2,-12(fp)
8113b2d8:	e0bffd0b 	ldhu	r2,-12(fp)
8113b2dc:	108007f0 	cmpltui	r2,r2,31
8113b2e0:	103ff11e 	bne	r2,zero,8113b2a8 <__reset+0xfb11b2a8>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113b2e4:	e0bffe17 	ldw	r2,-8(fp)
8113b2e8:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113b2ec:	00a045b4 	movhi	r2,33046
8113b2f0:	1095f304 	addi	r2,r2,22476
8113b2f4:	d0a09c15 	stw	r2,-32144(gp)
#endif
}
8113b2f8:	0001883a 	nop
8113b2fc:	e037883a 	mov	sp,fp
8113b300:	dfc00117 	ldw	ra,4(sp)
8113b304:	df000017 	ldw	fp,0(sp)
8113b308:	dec00204 	addi	sp,sp,8
8113b30c:	f800283a 	ret

8113b310 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113b310:	defffa04 	addi	sp,sp,-24
8113b314:	de00012e 	bgeu	sp,et,8113b31c <OSSemAccept+0xc>
8113b318:	003b68fa 	trap	3
8113b31c:	df000515 	stw	fp,20(sp)
8113b320:	df000504 	addi	fp,sp,20
8113b324:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b328:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113b32c:	e0bfff17 	ldw	r2,-4(fp)
8113b330:	1000021e 	bne	r2,zero,8113b33c <OSSemAccept+0x2c>
        return (0);
8113b334:	0005883a 	mov	r2,zero
8113b338:	00001f06 	br	8113b3b8 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113b33c:	e0bfff17 	ldw	r2,-4(fp)
8113b340:	10800003 	ldbu	r2,0(r2)
8113b344:	10803fcc 	andi	r2,r2,255
8113b348:	108000e0 	cmpeqi	r2,r2,3
8113b34c:	1000021e 	bne	r2,zero,8113b358 <OSSemAccept+0x48>
        return (0);
8113b350:	0005883a 	mov	r2,zero
8113b354:	00001806 	br	8113b3b8 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b358:	0005303a 	rdctl	r2,status
8113b35c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b360:	e0fffe17 	ldw	r3,-8(fp)
8113b364:	00bfff84 	movi	r2,-2
8113b368:	1884703a 	and	r2,r3,r2
8113b36c:	1001703a 	wrctl	status,r2
  
  return context;
8113b370:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113b374:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113b378:	e0bfff17 	ldw	r2,-4(fp)
8113b37c:	1080020b 	ldhu	r2,8(r2)
8113b380:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113b384:	e0bffd0b 	ldhu	r2,-12(fp)
8113b388:	10000626 	beq	r2,zero,8113b3a4 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113b38c:	e0bfff17 	ldw	r2,-4(fp)
8113b390:	1080020b 	ldhu	r2,8(r2)
8113b394:	10bfffc4 	addi	r2,r2,-1
8113b398:	1007883a 	mov	r3,r2
8113b39c:	e0bfff17 	ldw	r2,-4(fp)
8113b3a0:	10c0020d 	sth	r3,8(r2)
8113b3a4:	e0bffb17 	ldw	r2,-20(fp)
8113b3a8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b3ac:	e0bffc17 	ldw	r2,-16(fp)
8113b3b0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113b3b4:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113b3b8:	e037883a 	mov	sp,fp
8113b3bc:	df000017 	ldw	fp,0(sp)
8113b3c0:	dec00104 	addi	sp,sp,4
8113b3c4:	f800283a 	ret

8113b3c8 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113b3c8:	defff904 	addi	sp,sp,-28
8113b3cc:	de00012e 	bgeu	sp,et,8113b3d4 <OSSemCreate+0xc>
8113b3d0:	003b68fa 	trap	3
8113b3d4:	dfc00615 	stw	ra,24(sp)
8113b3d8:	df000515 	stw	fp,20(sp)
8113b3dc:	df000504 	addi	fp,sp,20
8113b3e0:	2005883a 	mov	r2,r4
8113b3e4:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113b3e8:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113b3ec:	d0a0a003 	ldbu	r2,-32128(gp)
8113b3f0:	10803fcc 	andi	r2,r2,255
8113b3f4:	10000226 	beq	r2,zero,8113b400 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113b3f8:	0005883a 	mov	r2,zero
8113b3fc:	00002506 	br	8113b494 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b400:	0005303a 	rdctl	r2,status
8113b404:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b408:	e0fffe17 	ldw	r3,-8(fp)
8113b40c:	00bfff84 	movi	r2,-2
8113b410:	1884703a 	and	r2,r3,r2
8113b414:	1001703a 	wrctl	status,r2
  
  return context;
8113b418:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113b41c:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113b420:	d0a09f17 	ldw	r2,-32132(gp)
8113b424:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113b428:	d0a09f17 	ldw	r2,-32132(gp)
8113b42c:	10000326 	beq	r2,zero,8113b43c <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113b430:	d0a09f17 	ldw	r2,-32132(gp)
8113b434:	10800117 	ldw	r2,4(r2)
8113b438:	d0a09f15 	stw	r2,-32132(gp)
8113b43c:	e0bffb17 	ldw	r2,-20(fp)
8113b440:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b444:	e0bffc17 	ldw	r2,-16(fp)
8113b448:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113b44c:	e0bffd17 	ldw	r2,-12(fp)
8113b450:	10000f26 	beq	r2,zero,8113b490 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113b454:	e0bffd17 	ldw	r2,-12(fp)
8113b458:	00c000c4 	movi	r3,3
8113b45c:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113b460:	e0bffd17 	ldw	r2,-12(fp)
8113b464:	e0ffff0b 	ldhu	r3,-4(fp)
8113b468:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113b46c:	e0bffd17 	ldw	r2,-12(fp)
8113b470:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113b474:	e0bffd17 	ldw	r2,-12(fp)
8113b478:	00c00fc4 	movi	r3,63
8113b47c:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113b480:	e0bffd17 	ldw	r2,-12(fp)
8113b484:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113b488:	e13ffd17 	ldw	r4,-12(fp)
8113b48c:	113635c0 	call	8113635c <OS_EventWaitListInit>
    }
    return (pevent);
8113b490:	e0bffd17 	ldw	r2,-12(fp)
}
8113b494:	e037883a 	mov	sp,fp
8113b498:	dfc00117 	ldw	ra,4(sp)
8113b49c:	df000017 	ldw	fp,0(sp)
8113b4a0:	dec00204 	addi	sp,sp,8
8113b4a4:	f800283a 	ret

8113b4a8 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113b4a8:	defff304 	addi	sp,sp,-52
8113b4ac:	de00012e 	bgeu	sp,et,8113b4b4 <OSSemDel+0xc>
8113b4b0:	003b68fa 	trap	3
8113b4b4:	dfc00c15 	stw	ra,48(sp)
8113b4b8:	df000b15 	stw	fp,44(sp)
8113b4bc:	df000b04 	addi	fp,sp,44
8113b4c0:	e13ffd15 	stw	r4,-12(fp)
8113b4c4:	2805883a 	mov	r2,r5
8113b4c8:	e1bfff15 	stw	r6,-4(fp)
8113b4cc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113b4d0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113b4d4:	e0bfff17 	ldw	r2,-4(fp)
8113b4d8:	1000021e 	bne	r2,zero,8113b4e4 <OSSemDel+0x3c>
        return (pevent);
8113b4dc:	e0bffd17 	ldw	r2,-12(fp)
8113b4e0:	00007e06 	br	8113b6dc <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113b4e4:	e0bffd17 	ldw	r2,-12(fp)
8113b4e8:	1000051e 	bne	r2,zero,8113b500 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113b4ec:	e0bfff17 	ldw	r2,-4(fp)
8113b4f0:	00c00104 	movi	r3,4
8113b4f4:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113b4f8:	e0bffd17 	ldw	r2,-12(fp)
8113b4fc:	00007706 	br	8113b6dc <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113b500:	e0bffd17 	ldw	r2,-12(fp)
8113b504:	10800003 	ldbu	r2,0(r2)
8113b508:	10803fcc 	andi	r2,r2,255
8113b50c:	108000e0 	cmpeqi	r2,r2,3
8113b510:	1000051e 	bne	r2,zero,8113b528 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113b514:	e0bfff17 	ldw	r2,-4(fp)
8113b518:	00c00044 	movi	r3,1
8113b51c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113b520:	e0bffd17 	ldw	r2,-12(fp)
8113b524:	00006d06 	br	8113b6dc <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113b528:	d0a0a003 	ldbu	r2,-32128(gp)
8113b52c:	10803fcc 	andi	r2,r2,255
8113b530:	10000526 	beq	r2,zero,8113b548 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113b534:	e0bfff17 	ldw	r2,-4(fp)
8113b538:	00c003c4 	movi	r3,15
8113b53c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113b540:	e0bffd17 	ldw	r2,-12(fp)
8113b544:	00006506 	br	8113b6dc <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b548:	0005303a 	rdctl	r2,status
8113b54c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b550:	e0fffc17 	ldw	r3,-16(fp)
8113b554:	00bfff84 	movi	r2,-2
8113b558:	1884703a 	and	r2,r3,r2
8113b55c:	1001703a 	wrctl	status,r2
  
  return context;
8113b560:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b564:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113b568:	e0bffd17 	ldw	r2,-12(fp)
8113b56c:	10800283 	ldbu	r2,10(r2)
8113b570:	10803fcc 	andi	r2,r2,255
8113b574:	10000326 	beq	r2,zero,8113b584 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113b578:	00800044 	movi	r2,1
8113b57c:	e0bff505 	stb	r2,-44(fp)
8113b580:	00000106 	br	8113b588 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113b584:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113b588:	e0bffe03 	ldbu	r2,-8(fp)
8113b58c:	10000326 	beq	r2,zero,8113b59c <OSSemDel+0xf4>
8113b590:	10800060 	cmpeqi	r2,r2,1
8113b594:	1000281e 	bne	r2,zero,8113b638 <OSSemDel+0x190>
8113b598:	00004506 	br	8113b6b0 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113b59c:	e0bff503 	ldbu	r2,-44(fp)
8113b5a0:	1000161e 	bne	r2,zero,8113b5fc <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113b5a4:	e0bffd17 	ldw	r2,-12(fp)
8113b5a8:	00c00fc4 	movi	r3,63
8113b5ac:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113b5b0:	e0bffd17 	ldw	r2,-12(fp)
8113b5b4:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113b5b8:	e0bffd17 	ldw	r2,-12(fp)
8113b5bc:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113b5c0:	d0e09f17 	ldw	r3,-32132(gp)
8113b5c4:	e0bffd17 	ldw	r2,-12(fp)
8113b5c8:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113b5cc:	e0bffd17 	ldw	r2,-12(fp)
8113b5d0:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113b5d4:	e0bffd17 	ldw	r2,-12(fp)
8113b5d8:	d0a09f15 	stw	r2,-32132(gp)
8113b5dc:	e0bff717 	ldw	r2,-36(fp)
8113b5e0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b5e4:	e0bff817 	ldw	r2,-32(fp)
8113b5e8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113b5ec:	e0bfff17 	ldw	r2,-4(fp)
8113b5f0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113b5f4:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113b5f8:	00003706 	br	8113b6d8 <OSSemDel+0x230>
8113b5fc:	e0bff717 	ldw	r2,-36(fp)
8113b600:	e0bff915 	stw	r2,-28(fp)
8113b604:	e0bff917 	ldw	r2,-28(fp)
8113b608:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113b60c:	e0bfff17 	ldw	r2,-4(fp)
8113b610:	00c01244 	movi	r3,73
8113b614:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113b618:	e0bffd17 	ldw	r2,-12(fp)
8113b61c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113b620:	00002d06 	br	8113b6d8 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113b624:	000f883a 	mov	r7,zero
8113b628:	01800044 	movi	r6,1
8113b62c:	000b883a 	mov	r5,zero
8113b630:	e13ffd17 	ldw	r4,-12(fp)
8113b634:	1135d840 	call	81135d84 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113b638:	e0bffd17 	ldw	r2,-12(fp)
8113b63c:	10800283 	ldbu	r2,10(r2)
8113b640:	10803fcc 	andi	r2,r2,255
8113b644:	103ff71e 	bne	r2,zero,8113b624 <__reset+0xfb11b624>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113b648:	e0bffd17 	ldw	r2,-12(fp)
8113b64c:	00c00fc4 	movi	r3,63
8113b650:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113b654:	e0bffd17 	ldw	r2,-12(fp)
8113b658:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113b65c:	e0bffd17 	ldw	r2,-12(fp)
8113b660:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113b664:	d0e09f17 	ldw	r3,-32132(gp)
8113b668:	e0bffd17 	ldw	r2,-12(fp)
8113b66c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113b670:	e0bffd17 	ldw	r2,-12(fp)
8113b674:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113b678:	e0bffd17 	ldw	r2,-12(fp)
8113b67c:	d0a09f15 	stw	r2,-32132(gp)
8113b680:	e0bff717 	ldw	r2,-36(fp)
8113b684:	e0bffa15 	stw	r2,-24(fp)
8113b688:	e0bffa17 	ldw	r2,-24(fp)
8113b68c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113b690:	e0bff503 	ldbu	r2,-44(fp)
8113b694:	10800058 	cmpnei	r2,r2,1
8113b698:	1000011e 	bne	r2,zero,8113b6a0 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113b69c:	11368400 	call	81136840 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113b6a0:	e0bfff17 	ldw	r2,-4(fp)
8113b6a4:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113b6a8:	e03ff615 	stw	zero,-40(fp)
             break;
8113b6ac:	00000a06 	br	8113b6d8 <OSSemDel+0x230>
8113b6b0:	e0bff717 	ldw	r2,-36(fp)
8113b6b4:	e0bffb15 	stw	r2,-20(fp)
8113b6b8:	e0bffb17 	ldw	r2,-20(fp)
8113b6bc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113b6c0:	e0bfff17 	ldw	r2,-4(fp)
8113b6c4:	00c001c4 	movi	r3,7
8113b6c8:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113b6cc:	e0bffd17 	ldw	r2,-12(fp)
8113b6d0:	e0bff615 	stw	r2,-40(fp)
             break;
8113b6d4:	0001883a 	nop
    }
    return (pevent_return);
8113b6d8:	e0bff617 	ldw	r2,-40(fp)
}
8113b6dc:	e037883a 	mov	sp,fp
8113b6e0:	dfc00117 	ldw	ra,4(sp)
8113b6e4:	df000017 	ldw	fp,0(sp)
8113b6e8:	dec00204 	addi	sp,sp,8
8113b6ec:	f800283a 	ret

8113b6f0 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113b6f0:	defff504 	addi	sp,sp,-44
8113b6f4:	de00012e 	bgeu	sp,et,8113b6fc <OSSemPend+0xc>
8113b6f8:	003b68fa 	trap	3
8113b6fc:	dfc00a15 	stw	ra,40(sp)
8113b700:	df000915 	stw	fp,36(sp)
8113b704:	df000904 	addi	fp,sp,36
8113b708:	e13ffd15 	stw	r4,-12(fp)
8113b70c:	2805883a 	mov	r2,r5
8113b710:	e1bfff15 	stw	r6,-4(fp)
8113b714:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b718:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113b71c:	e0bfff17 	ldw	r2,-4(fp)
8113b720:	10007226 	beq	r2,zero,8113b8ec <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113b724:	e0bffd17 	ldw	r2,-12(fp)
8113b728:	1000041e 	bne	r2,zero,8113b73c <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113b72c:	e0bfff17 	ldw	r2,-4(fp)
8113b730:	00c00104 	movi	r3,4
8113b734:	10c00005 	stb	r3,0(r2)
        return;
8113b738:	00006d06 	br	8113b8f0 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113b73c:	e0bffd17 	ldw	r2,-12(fp)
8113b740:	10800003 	ldbu	r2,0(r2)
8113b744:	10803fcc 	andi	r2,r2,255
8113b748:	108000e0 	cmpeqi	r2,r2,3
8113b74c:	1000041e 	bne	r2,zero,8113b760 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113b750:	e0bfff17 	ldw	r2,-4(fp)
8113b754:	00c00044 	movi	r3,1
8113b758:	10c00005 	stb	r3,0(r2)
        return;
8113b75c:	00006406 	br	8113b8f0 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113b760:	d0a0a003 	ldbu	r2,-32128(gp)
8113b764:	10803fcc 	andi	r2,r2,255
8113b768:	10000426 	beq	r2,zero,8113b77c <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113b76c:	e0bfff17 	ldw	r2,-4(fp)
8113b770:	00c00084 	movi	r3,2
8113b774:	10c00005 	stb	r3,0(r2)
        return;
8113b778:	00005d06 	br	8113b8f0 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113b77c:	d0a08e03 	ldbu	r2,-32200(gp)
8113b780:	10803fcc 	andi	r2,r2,255
8113b784:	10000426 	beq	r2,zero,8113b798 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113b788:	e0bfff17 	ldw	r2,-4(fp)
8113b78c:	00c00344 	movi	r3,13
8113b790:	10c00005 	stb	r3,0(r2)
        return;
8113b794:	00005606 	br	8113b8f0 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b798:	0005303a 	rdctl	r2,status
8113b79c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b7a0:	e0fffc17 	ldw	r3,-16(fp)
8113b7a4:	00bfff84 	movi	r2,-2
8113b7a8:	1884703a 	and	r2,r3,r2
8113b7ac:	1001703a 	wrctl	status,r2
  
  return context;
8113b7b0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b7b4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113b7b8:	e0bffd17 	ldw	r2,-12(fp)
8113b7bc:	1080020b 	ldhu	r2,8(r2)
8113b7c0:	10bfffcc 	andi	r2,r2,65535
8113b7c4:	10000d26 	beq	r2,zero,8113b7fc <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113b7c8:	e0bffd17 	ldw	r2,-12(fp)
8113b7cc:	1080020b 	ldhu	r2,8(r2)
8113b7d0:	10bfffc4 	addi	r2,r2,-1
8113b7d4:	1007883a 	mov	r3,r2
8113b7d8:	e0bffd17 	ldw	r2,-12(fp)
8113b7dc:	10c0020d 	sth	r3,8(r2)
8113b7e0:	e0bff717 	ldw	r2,-36(fp)
8113b7e4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b7e8:	e0bff817 	ldw	r2,-32(fp)
8113b7ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113b7f0:	e0bfff17 	ldw	r2,-4(fp)
8113b7f4:	10000005 	stb	zero,0(r2)
        return;
8113b7f8:	00003d06 	br	8113b8f0 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113b7fc:	d0a0a117 	ldw	r2,-32124(gp)
8113b800:	d0e0a117 	ldw	r3,-32124(gp)
8113b804:	18c00c03 	ldbu	r3,48(r3)
8113b808:	18c00054 	ori	r3,r3,1
8113b80c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113b810:	d0a0a117 	ldw	r2,-32124(gp)
8113b814:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113b818:	d0a0a117 	ldw	r2,-32124(gp)
8113b81c:	e0fffe0b 	ldhu	r3,-8(fp)
8113b820:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113b824:	e13ffd17 	ldw	r4,-12(fp)
8113b828:	1135f240 	call	81135f24 <OS_EventTaskWait>
8113b82c:	e0bff717 	ldw	r2,-36(fp)
8113b830:	e0bffb15 	stw	r2,-20(fp)
8113b834:	e0bffb17 	ldw	r2,-20(fp)
8113b838:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113b83c:	11368400 	call	81136840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b840:	0005303a 	rdctl	r2,status
8113b844:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b848:	e0fff917 	ldw	r3,-28(fp)
8113b84c:	00bfff84 	movi	r2,-2
8113b850:	1884703a 	and	r2,r3,r2
8113b854:	1001703a 	wrctl	status,r2
  
  return context;
8113b858:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113b85c:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113b860:	d0a0a117 	ldw	r2,-32124(gp)
8113b864:	10800c43 	ldbu	r2,49(r2)
8113b868:	10803fcc 	andi	r2,r2,255
8113b86c:	10000326 	beq	r2,zero,8113b87c <OSSemPend+0x18c>
8113b870:	108000a0 	cmpeqi	r2,r2,2
8113b874:	1000041e 	bne	r2,zero,8113b888 <OSSemPend+0x198>
8113b878:	00000706 	br	8113b898 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113b87c:	e0bfff17 	ldw	r2,-4(fp)
8113b880:	10000005 	stb	zero,0(r2)
             break;
8113b884:	00000c06 	br	8113b8b8 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113b888:	e0bfff17 	ldw	r2,-4(fp)
8113b88c:	00c00384 	movi	r3,14
8113b890:	10c00005 	stb	r3,0(r2)
             break;
8113b894:	00000806 	br	8113b8b8 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113b898:	d0a0a117 	ldw	r2,-32124(gp)
8113b89c:	e17ffd17 	ldw	r5,-12(fp)
8113b8a0:	1009883a 	mov	r4,r2
8113b8a4:	11361940 	call	81136194 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113b8a8:	e0bfff17 	ldw	r2,-4(fp)
8113b8ac:	00c00284 	movi	r3,10
8113b8b0:	10c00005 	stb	r3,0(r2)
             break;
8113b8b4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113b8b8:	d0a0a117 	ldw	r2,-32124(gp)
8113b8bc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113b8c0:	d0a0a117 	ldw	r2,-32124(gp)
8113b8c4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113b8c8:	d0a0a117 	ldw	r2,-32124(gp)
8113b8cc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113b8d0:	d0a0a117 	ldw	r2,-32124(gp)
8113b8d4:	10000815 	stw	zero,32(r2)
8113b8d8:	e0bff717 	ldw	r2,-36(fp)
8113b8dc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b8e0:	e0bffa17 	ldw	r2,-24(fp)
8113b8e4:	1001703a 	wrctl	status,r2
8113b8e8:	00000106 	br	8113b8f0 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113b8ec:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113b8f0:	e037883a 	mov	sp,fp
8113b8f4:	dfc00117 	ldw	ra,4(sp)
8113b8f8:	df000017 	ldw	fp,0(sp)
8113b8fc:	dec00204 	addi	sp,sp,8
8113b900:	f800283a 	ret

8113b904 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113b904:	defff604 	addi	sp,sp,-40
8113b908:	de00012e 	bgeu	sp,et,8113b910 <OSSemPendAbort+0xc>
8113b90c:	003b68fa 	trap	3
8113b910:	dfc00915 	stw	ra,36(sp)
8113b914:	df000815 	stw	fp,32(sp)
8113b918:	df000804 	addi	fp,sp,32
8113b91c:	e13ffd15 	stw	r4,-12(fp)
8113b920:	2805883a 	mov	r2,r5
8113b924:	e1bfff15 	stw	r6,-4(fp)
8113b928:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b92c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113b930:	e0bfff17 	ldw	r2,-4(fp)
8113b934:	1000021e 	bne	r2,zero,8113b940 <OSSemPendAbort+0x3c>
        return (0);
8113b938:	0005883a 	mov	r2,zero
8113b93c:	00004906 	br	8113ba64 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113b940:	e0bffd17 	ldw	r2,-12(fp)
8113b944:	1000051e 	bne	r2,zero,8113b95c <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113b948:	e0bfff17 	ldw	r2,-4(fp)
8113b94c:	00c00104 	movi	r3,4
8113b950:	10c00005 	stb	r3,0(r2)
        return (0);
8113b954:	0005883a 	mov	r2,zero
8113b958:	00004206 	br	8113ba64 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113b95c:	e0bffd17 	ldw	r2,-12(fp)
8113b960:	10800003 	ldbu	r2,0(r2)
8113b964:	10803fcc 	andi	r2,r2,255
8113b968:	108000e0 	cmpeqi	r2,r2,3
8113b96c:	1000051e 	bne	r2,zero,8113b984 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113b970:	e0bfff17 	ldw	r2,-4(fp)
8113b974:	00c00044 	movi	r3,1
8113b978:	10c00005 	stb	r3,0(r2)
        return (0);
8113b97c:	0005883a 	mov	r2,zero
8113b980:	00003806 	br	8113ba64 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b984:	0005303a 	rdctl	r2,status
8113b988:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b98c:	e0fffc17 	ldw	r3,-16(fp)
8113b990:	00bfff84 	movi	r2,-2
8113b994:	1884703a 	and	r2,r3,r2
8113b998:	1001703a 	wrctl	status,r2
  
  return context;
8113b99c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b9a0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113b9a4:	e0bffd17 	ldw	r2,-12(fp)
8113b9a8:	10800283 	ldbu	r2,10(r2)
8113b9ac:	10803fcc 	andi	r2,r2,255
8113b9b0:	10002526 	beq	r2,zero,8113ba48 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113b9b4:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113b9b8:	e0bffe03 	ldbu	r2,-8(fp)
8113b9bc:	10800060 	cmpeqi	r2,r2,1
8113b9c0:	10000e26 	beq	r2,zero,8113b9fc <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113b9c4:	00000806 	br	8113b9e8 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113b9c8:	01c00084 	movi	r7,2
8113b9cc:	01800044 	movi	r6,1
8113b9d0:	000b883a 	mov	r5,zero
8113b9d4:	e13ffd17 	ldw	r4,-12(fp)
8113b9d8:	1135d840 	call	81135d84 <OS_EventTaskRdy>
                     nbr_tasks++;
8113b9dc:	e0bff803 	ldbu	r2,-32(fp)
8113b9e0:	10800044 	addi	r2,r2,1
8113b9e4:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113b9e8:	e0bffd17 	ldw	r2,-12(fp)
8113b9ec:	10800283 	ldbu	r2,10(r2)
8113b9f0:	10803fcc 	andi	r2,r2,255
8113b9f4:	103ff41e 	bne	r2,zero,8113b9c8 <__reset+0xfb11b9c8>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113b9f8:	00000906 	br	8113ba20 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113b9fc:	01c00084 	movi	r7,2
8113ba00:	01800044 	movi	r6,1
8113ba04:	000b883a 	mov	r5,zero
8113ba08:	e13ffd17 	ldw	r4,-12(fp)
8113ba0c:	1135d840 	call	81135d84 <OS_EventTaskRdy>
                 nbr_tasks++;
8113ba10:	e0bff803 	ldbu	r2,-32(fp)
8113ba14:	10800044 	addi	r2,r2,1
8113ba18:	e0bff805 	stb	r2,-32(fp)
                 break;
8113ba1c:	0001883a 	nop
8113ba20:	e0bff917 	ldw	r2,-28(fp)
8113ba24:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ba28:	e0bffa17 	ldw	r2,-24(fp)
8113ba2c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113ba30:	11368400 	call	81136840 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113ba34:	e0bfff17 	ldw	r2,-4(fp)
8113ba38:	00c00384 	movi	r3,14
8113ba3c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113ba40:	e0bff803 	ldbu	r2,-32(fp)
8113ba44:	00000706 	br	8113ba64 <OSSemPendAbort+0x160>
8113ba48:	e0bff917 	ldw	r2,-28(fp)
8113ba4c:	e0bffb15 	stw	r2,-20(fp)
8113ba50:	e0bffb17 	ldw	r2,-20(fp)
8113ba54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ba58:	e0bfff17 	ldw	r2,-4(fp)
8113ba5c:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8113ba60:	0005883a 	mov	r2,zero
}
8113ba64:	e037883a 	mov	sp,fp
8113ba68:	dfc00117 	ldw	ra,4(sp)
8113ba6c:	df000017 	ldw	fp,0(sp)
8113ba70:	dec00204 	addi	sp,sp,8
8113ba74:	f800283a 	ret

8113ba78 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8113ba78:	defff804 	addi	sp,sp,-32
8113ba7c:	de00012e 	bgeu	sp,et,8113ba84 <OSSemPost+0xc>
8113ba80:	003b68fa 	trap	3
8113ba84:	dfc00715 	stw	ra,28(sp)
8113ba88:	df000615 	stw	fp,24(sp)
8113ba8c:	df000604 	addi	fp,sp,24
8113ba90:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ba94:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ba98:	e0bfff17 	ldw	r2,-4(fp)
8113ba9c:	1000021e 	bne	r2,zero,8113baa8 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113baa0:	00800104 	movi	r2,4
8113baa4:	00003506 	br	8113bb7c <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113baa8:	e0bfff17 	ldw	r2,-4(fp)
8113baac:	10800003 	ldbu	r2,0(r2)
8113bab0:	10803fcc 	andi	r2,r2,255
8113bab4:	108000e0 	cmpeqi	r2,r2,3
8113bab8:	1000021e 	bne	r2,zero,8113bac4 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8113babc:	00800044 	movi	r2,1
8113bac0:	00002e06 	br	8113bb7c <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bac4:	0005303a 	rdctl	r2,status
8113bac8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bacc:	e0fffe17 	ldw	r3,-8(fp)
8113bad0:	00bfff84 	movi	r2,-2
8113bad4:	1884703a 	and	r2,r3,r2
8113bad8:	1001703a 	wrctl	status,r2
  
  return context;
8113badc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113bae0:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113bae4:	e0bfff17 	ldw	r2,-4(fp)
8113bae8:	10800283 	ldbu	r2,10(r2)
8113baec:	10803fcc 	andi	r2,r2,255
8113baf0:	10000c26 	beq	r2,zero,8113bb24 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113baf4:	000f883a 	mov	r7,zero
8113baf8:	01800044 	movi	r6,1
8113bafc:	000b883a 	mov	r5,zero
8113bb00:	e13fff17 	ldw	r4,-4(fp)
8113bb04:	1135d840 	call	81135d84 <OS_EventTaskRdy>
8113bb08:	e0bffa17 	ldw	r2,-24(fp)
8113bb0c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bb10:	e0bffb17 	ldw	r2,-20(fp)
8113bb14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113bb18:	11368400 	call	81136840 <OS_Sched>
        return (OS_ERR_NONE);
8113bb1c:	0005883a 	mov	r2,zero
8113bb20:	00001606 	br	8113bb7c <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113bb24:	e0bfff17 	ldw	r2,-4(fp)
8113bb28:	1080020b 	ldhu	r2,8(r2)
8113bb2c:	10ffffcc 	andi	r3,r2,65535
8113bb30:	00bfffd4 	movui	r2,65535
8113bb34:	18800c26 	beq	r3,r2,8113bb68 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8113bb38:	e0bfff17 	ldw	r2,-4(fp)
8113bb3c:	1080020b 	ldhu	r2,8(r2)
8113bb40:	10800044 	addi	r2,r2,1
8113bb44:	1007883a 	mov	r3,r2
8113bb48:	e0bfff17 	ldw	r2,-4(fp)
8113bb4c:	10c0020d 	sth	r3,8(r2)
8113bb50:	e0bffa17 	ldw	r2,-24(fp)
8113bb54:	e0bffc15 	stw	r2,-16(fp)
8113bb58:	e0bffc17 	ldw	r2,-16(fp)
8113bb5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113bb60:	0005883a 	mov	r2,zero
8113bb64:	00000506 	br	8113bb7c <OSSemPost+0x104>
8113bb68:	e0bffa17 	ldw	r2,-24(fp)
8113bb6c:	e0bffd15 	stw	r2,-12(fp)
8113bb70:	e0bffd17 	ldw	r2,-12(fp)
8113bb74:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113bb78:	00800c84 	movi	r2,50
}
8113bb7c:	e037883a 	mov	sp,fp
8113bb80:	dfc00117 	ldw	ra,4(sp)
8113bb84:	df000017 	ldw	fp,0(sp)
8113bb88:	dec00204 	addi	sp,sp,8
8113bb8c:	f800283a 	ret

8113bb90 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113bb90:	defff704 	addi	sp,sp,-36
8113bb94:	de00012e 	bgeu	sp,et,8113bb9c <OSSemQuery+0xc>
8113bb98:	003b68fa 	trap	3
8113bb9c:	df000815 	stw	fp,32(sp)
8113bba0:	df000804 	addi	fp,sp,32
8113bba4:	e13ffe15 	stw	r4,-8(fp)
8113bba8:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113bbac:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113bbb0:	e0bffe17 	ldw	r2,-8(fp)
8113bbb4:	1000021e 	bne	r2,zero,8113bbc0 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113bbb8:	00800104 	movi	r2,4
8113bbbc:	00003606 	br	8113bc98 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113bbc0:	e0bfff17 	ldw	r2,-4(fp)
8113bbc4:	1000021e 	bne	r2,zero,8113bbd0 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113bbc8:	00800244 	movi	r2,9
8113bbcc:	00003206 	br	8113bc98 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113bbd0:	e0bffe17 	ldw	r2,-8(fp)
8113bbd4:	10800003 	ldbu	r2,0(r2)
8113bbd8:	10803fcc 	andi	r2,r2,255
8113bbdc:	108000e0 	cmpeqi	r2,r2,3
8113bbe0:	1000021e 	bne	r2,zero,8113bbec <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113bbe4:	00800044 	movi	r2,1
8113bbe8:	00002b06 	br	8113bc98 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bbec:	0005303a 	rdctl	r2,status
8113bbf0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bbf4:	e0fffd17 	ldw	r3,-12(fp)
8113bbf8:	00bfff84 	movi	r2,-2
8113bbfc:	1884703a 	and	r2,r3,r2
8113bc00:	1001703a 	wrctl	status,r2
  
  return context;
8113bc04:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113bc08:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113bc0c:	e0bffe17 	ldw	r2,-8(fp)
8113bc10:	10c00283 	ldbu	r3,10(r2)
8113bc14:	e0bfff17 	ldw	r2,-4(fp)
8113bc18:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113bc1c:	e0bffe17 	ldw	r2,-8(fp)
8113bc20:	108002c4 	addi	r2,r2,11
8113bc24:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113bc28:	e0bfff17 	ldw	r2,-4(fp)
8113bc2c:	10800084 	addi	r2,r2,2
8113bc30:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113bc34:	e03ffa05 	stb	zero,-24(fp)
8113bc38:	00000b06 	br	8113bc68 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113bc3c:	e0bff917 	ldw	r2,-28(fp)
8113bc40:	10c00044 	addi	r3,r2,1
8113bc44:	e0fff915 	stw	r3,-28(fp)
8113bc48:	e0fff817 	ldw	r3,-32(fp)
8113bc4c:	19000044 	addi	r4,r3,1
8113bc50:	e13ff815 	stw	r4,-32(fp)
8113bc54:	18c00003 	ldbu	r3,0(r3)
8113bc58:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113bc5c:	e0bffa03 	ldbu	r2,-24(fp)
8113bc60:	10800044 	addi	r2,r2,1
8113bc64:	e0bffa05 	stb	r2,-24(fp)
8113bc68:	e0bffa03 	ldbu	r2,-24(fp)
8113bc6c:	108001b0 	cmpltui	r2,r2,6
8113bc70:	103ff21e 	bne	r2,zero,8113bc3c <__reset+0xfb11bc3c>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113bc74:	e0bffe17 	ldw	r2,-8(fp)
8113bc78:	10c0020b 	ldhu	r3,8(r2)
8113bc7c:	e0bfff17 	ldw	r2,-4(fp)
8113bc80:	10c0000d 	sth	r3,0(r2)
8113bc84:	e0bffb17 	ldw	r2,-20(fp)
8113bc88:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bc8c:	e0bffc17 	ldw	r2,-16(fp)
8113bc90:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113bc94:	0005883a 	mov	r2,zero
}
8113bc98:	e037883a 	mov	sp,fp
8113bc9c:	df000017 	ldw	fp,0(sp)
8113bca0:	dec00104 	addi	sp,sp,4
8113bca4:	f800283a 	ret

8113bca8 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113bca8:	defff904 	addi	sp,sp,-28
8113bcac:	de00012e 	bgeu	sp,et,8113bcb4 <OSSemSet+0xc>
8113bcb0:	003b68fa 	trap	3
8113bcb4:	df000615 	stw	fp,24(sp)
8113bcb8:	df000604 	addi	fp,sp,24
8113bcbc:	e13ffd15 	stw	r4,-12(fp)
8113bcc0:	2805883a 	mov	r2,r5
8113bcc4:	e1bfff15 	stw	r6,-4(fp)
8113bcc8:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113bccc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113bcd0:	e0bfff17 	ldw	r2,-4(fp)
8113bcd4:	10003126 	beq	r2,zero,8113bd9c <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113bcd8:	e0bffd17 	ldw	r2,-12(fp)
8113bcdc:	1000041e 	bne	r2,zero,8113bcf0 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113bce0:	e0bfff17 	ldw	r2,-4(fp)
8113bce4:	00c00104 	movi	r3,4
8113bce8:	10c00005 	stb	r3,0(r2)
        return;
8113bcec:	00002c06 	br	8113bda0 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113bcf0:	e0bffd17 	ldw	r2,-12(fp)
8113bcf4:	10800003 	ldbu	r2,0(r2)
8113bcf8:	10803fcc 	andi	r2,r2,255
8113bcfc:	108000e0 	cmpeqi	r2,r2,3
8113bd00:	1000041e 	bne	r2,zero,8113bd14 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113bd04:	e0bfff17 	ldw	r2,-4(fp)
8113bd08:	00c00044 	movi	r3,1
8113bd0c:	10c00005 	stb	r3,0(r2)
        return;
8113bd10:	00002306 	br	8113bda0 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bd14:	0005303a 	rdctl	r2,status
8113bd18:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bd1c:	e0fffc17 	ldw	r3,-16(fp)
8113bd20:	00bfff84 	movi	r2,-2
8113bd24:	1884703a 	and	r2,r3,r2
8113bd28:	1001703a 	wrctl	status,r2
  
  return context;
8113bd2c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bd30:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113bd34:	e0bfff17 	ldw	r2,-4(fp)
8113bd38:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113bd3c:	e0bffd17 	ldw	r2,-12(fp)
8113bd40:	1080020b 	ldhu	r2,8(r2)
8113bd44:	10bfffcc 	andi	r2,r2,65535
8113bd48:	10000426 	beq	r2,zero,8113bd5c <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113bd4c:	e0bffd17 	ldw	r2,-12(fp)
8113bd50:	e0fffe0b 	ldhu	r3,-8(fp)
8113bd54:	10c0020d 	sth	r3,8(r2)
8113bd58:	00000b06 	br	8113bd88 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113bd5c:	e0bffd17 	ldw	r2,-12(fp)
8113bd60:	10800283 	ldbu	r2,10(r2)
8113bd64:	10803fcc 	andi	r2,r2,255
8113bd68:	1000041e 	bne	r2,zero,8113bd7c <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113bd6c:	e0bffd17 	ldw	r2,-12(fp)
8113bd70:	e0fffe0b 	ldhu	r3,-8(fp)
8113bd74:	10c0020d 	sth	r3,8(r2)
8113bd78:	00000306 	br	8113bd88 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113bd7c:	e0bfff17 	ldw	r2,-4(fp)
8113bd80:	00c01244 	movi	r3,73
8113bd84:	10c00005 	stb	r3,0(r2)
8113bd88:	e0bffa17 	ldw	r2,-24(fp)
8113bd8c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bd90:	e0bffb17 	ldw	r2,-20(fp)
8113bd94:	1001703a 	wrctl	status,r2
8113bd98:	00000106 	br	8113bda0 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113bd9c:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113bda0:	e037883a 	mov	sp,fp
8113bda4:	df000017 	ldw	fp,0(sp)
8113bda8:	dec00104 	addi	sp,sp,4
8113bdac:	f800283a 	ret

8113bdb0 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113bdb0:	defff104 	addi	sp,sp,-60
8113bdb4:	de00012e 	bgeu	sp,et,8113bdbc <OSTaskChangePrio+0xc>
8113bdb8:	003b68fa 	trap	3
8113bdbc:	dfc00e15 	stw	ra,56(sp)
8113bdc0:	df000d15 	stw	fp,52(sp)
8113bdc4:	df000d04 	addi	fp,sp,52
8113bdc8:	2007883a 	mov	r3,r4
8113bdcc:	2805883a 	mov	r2,r5
8113bdd0:	e0fffe05 	stb	r3,-8(fp)
8113bdd4:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113bdd8:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113bddc:	e0bffe03 	ldbu	r2,-8(fp)
8113bde0:	10800ab0 	cmpltui	r2,r2,42
8113bde4:	1000051e 	bne	r2,zero,8113bdfc <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113bde8:	e0bffe03 	ldbu	r2,-8(fp)
8113bdec:	10803fe0 	cmpeqi	r2,r2,255
8113bdf0:	1000021e 	bne	r2,zero,8113bdfc <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113bdf4:	00800a84 	movi	r2,42
8113bdf8:	00012606 	br	8113c294 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113bdfc:	e0bfff03 	ldbu	r2,-4(fp)
8113be00:	10800ab0 	cmpltui	r2,r2,42
8113be04:	1000021e 	bne	r2,zero,8113be10 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113be08:	00800a84 	movi	r2,42
8113be0c:	00012106 	br	8113c294 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113be10:	0005303a 	rdctl	r2,status
8113be14:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113be18:	e0fffd17 	ldw	r3,-12(fp)
8113be1c:	00bfff84 	movi	r2,-2
8113be20:	1884703a 	and	r2,r3,r2
8113be24:	1001703a 	wrctl	status,r2
  
  return context;
8113be28:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113be2c:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113be30:	e0ffff03 	ldbu	r3,-4(fp)
8113be34:	00a045f4 	movhi	r2,33047
8113be38:	10a46104 	addi	r2,r2,-28284
8113be3c:	18c7883a 	add	r3,r3,r3
8113be40:	18c7883a 	add	r3,r3,r3
8113be44:	10c5883a 	add	r2,r2,r3
8113be48:	10800017 	ldw	r2,0(r2)
8113be4c:	10000626 	beq	r2,zero,8113be68 <OSTaskChangePrio+0xb8>
8113be50:	e0bff517 	ldw	r2,-44(fp)
8113be54:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113be58:	e0bff617 	ldw	r2,-40(fp)
8113be5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113be60:	00800a04 	movi	r2,40
8113be64:	00010b06 	br	8113c294 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113be68:	e0bffe03 	ldbu	r2,-8(fp)
8113be6c:	10803fd8 	cmpnei	r2,r2,255
8113be70:	1000031e 	bne	r2,zero,8113be80 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113be74:	d0a0a117 	ldw	r2,-32124(gp)
8113be78:	10800c83 	ldbu	r2,50(r2)
8113be7c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113be80:	e0fffe03 	ldbu	r3,-8(fp)
8113be84:	00a045f4 	movhi	r2,33047
8113be88:	10a46104 	addi	r2,r2,-28284
8113be8c:	18c7883a 	add	r3,r3,r3
8113be90:	18c7883a 	add	r3,r3,r3
8113be94:	10c5883a 	add	r2,r2,r3
8113be98:	10800017 	ldw	r2,0(r2)
8113be9c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113bea0:	e0bff817 	ldw	r2,-32(fp)
8113bea4:	1000061e 	bne	r2,zero,8113bec0 <OSTaskChangePrio+0x110>
8113bea8:	e0bff517 	ldw	r2,-44(fp)
8113beac:	e0bff715 	stw	r2,-36(fp)
8113beb0:	e0bff717 	ldw	r2,-36(fp)
8113beb4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113beb8:	00800a44 	movi	r2,41
8113bebc:	0000f506 	br	8113c294 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113bec0:	e0bff817 	ldw	r2,-32(fp)
8113bec4:	10800058 	cmpnei	r2,r2,1
8113bec8:	1000061e 	bne	r2,zero,8113bee4 <OSTaskChangePrio+0x134>
8113becc:	e0bff517 	ldw	r2,-44(fp)
8113bed0:	e0bff915 	stw	r2,-28(fp)
8113bed4:	e0bff917 	ldw	r2,-28(fp)
8113bed8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113bedc:	008010c4 	movi	r2,67
8113bee0:	0000ec06 	br	8113c294 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113bee4:	e0bfff03 	ldbu	r2,-4(fp)
8113bee8:	1004d0fa 	srli	r2,r2,3
8113beec:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113bef0:	e0bfff03 	ldbu	r2,-4(fp)
8113bef4:	108001cc 	andi	r2,r2,7
8113bef8:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113befc:	e0bffb03 	ldbu	r2,-20(fp)
8113bf00:	00c00044 	movi	r3,1
8113bf04:	1884983a 	sll	r2,r3,r2
8113bf08:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113bf0c:	e0bffb43 	ldbu	r2,-19(fp)
8113bf10:	00c00044 	movi	r3,1
8113bf14:	1884983a 	sll	r2,r3,r2
8113bf18:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113bf1c:	e0fffe03 	ldbu	r3,-8(fp)
8113bf20:	00a045f4 	movhi	r2,33047
8113bf24:	10a46104 	addi	r2,r2,-28284
8113bf28:	18c7883a 	add	r3,r3,r3
8113bf2c:	18c7883a 	add	r3,r3,r3
8113bf30:	10c5883a 	add	r2,r2,r3
8113bf34:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113bf38:	e0ffff03 	ldbu	r3,-4(fp)
8113bf3c:	00a045f4 	movhi	r2,33047
8113bf40:	10a46104 	addi	r2,r2,-28284
8113bf44:	18c7883a 	add	r3,r3,r3
8113bf48:	18c7883a 	add	r3,r3,r3
8113bf4c:	10c5883a 	add	r2,r2,r3
8113bf50:	e0fff817 	ldw	r3,-32(fp)
8113bf54:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113bf58:	e0bff817 	ldw	r2,-32(fp)
8113bf5c:	10800d03 	ldbu	r2,52(r2)
8113bf60:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113bf64:	e0bff817 	ldw	r2,-32(fp)
8113bf68:	10800d83 	ldbu	r2,54(r2)
8113bf6c:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113bf70:	e0bff817 	ldw	r2,-32(fp)
8113bf74:	10800d43 	ldbu	r2,53(r2)
8113bf78:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113bf7c:	e0fffc03 	ldbu	r3,-16(fp)
8113bf80:	d0a09d44 	addi	r2,gp,-32139
8113bf84:	1885883a 	add	r2,r3,r2
8113bf88:	10c00003 	ldbu	r3,0(r2)
8113bf8c:	e0bffc83 	ldbu	r2,-14(fp)
8113bf90:	1884703a 	and	r2,r3,r2
8113bf94:	10803fcc 	andi	r2,r2,255
8113bf98:	10002826 	beq	r2,zero,8113c03c <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113bf9c:	e0fffc03 	ldbu	r3,-16(fp)
8113bfa0:	e13ffc03 	ldbu	r4,-16(fp)
8113bfa4:	d0a09d44 	addi	r2,gp,-32139
8113bfa8:	2085883a 	add	r2,r4,r2
8113bfac:	10800003 	ldbu	r2,0(r2)
8113bfb0:	1009883a 	mov	r4,r2
8113bfb4:	e0bffc83 	ldbu	r2,-14(fp)
8113bfb8:	0084303a 	nor	r2,zero,r2
8113bfbc:	2084703a 	and	r2,r4,r2
8113bfc0:	1009883a 	mov	r4,r2
8113bfc4:	d0a09d44 	addi	r2,gp,-32139
8113bfc8:	1885883a 	add	r2,r3,r2
8113bfcc:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113bfd0:	e0fffc03 	ldbu	r3,-16(fp)
8113bfd4:	d0a09d44 	addi	r2,gp,-32139
8113bfd8:	1885883a 	add	r2,r3,r2
8113bfdc:	10800003 	ldbu	r2,0(r2)
8113bfe0:	10803fcc 	andi	r2,r2,255
8113bfe4:	1000061e 	bne	r2,zero,8113c000 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113bfe8:	e0bffc43 	ldbu	r2,-15(fp)
8113bfec:	0084303a 	nor	r2,zero,r2
8113bff0:	1007883a 	mov	r3,r2
8113bff4:	d0a09d03 	ldbu	r2,-32140(gp)
8113bff8:	1884703a 	and	r2,r3,r2
8113bffc:	d0a09d05 	stb	r2,-32140(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113c000:	d0e09d03 	ldbu	r3,-32140(gp)
8113c004:	e0bffb83 	ldbu	r2,-18(fp)
8113c008:	1884b03a 	or	r2,r3,r2
8113c00c:	d0a09d05 	stb	r2,-32140(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113c010:	e0fffb03 	ldbu	r3,-20(fp)
8113c014:	e13ffb03 	ldbu	r4,-20(fp)
8113c018:	d0a09d44 	addi	r2,gp,-32139
8113c01c:	2085883a 	add	r2,r4,r2
8113c020:	11000003 	ldbu	r4,0(r2)
8113c024:	e0bffbc3 	ldbu	r2,-17(fp)
8113c028:	2084b03a 	or	r2,r4,r2
8113c02c:	1009883a 	mov	r4,r2
8113c030:	d0a09d44 	addi	r2,gp,-32139
8113c034:	1885883a 	add	r2,r3,r2
8113c038:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113c03c:	e0bff817 	ldw	r2,-32(fp)
8113c040:	10800717 	ldw	r2,28(r2)
8113c044:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113c048:	e0bff317 	ldw	r2,-52(fp)
8113c04c:	10003326 	beq	r2,zero,8113c11c <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113c050:	e0bffc03 	ldbu	r2,-16(fp)
8113c054:	e0fffc03 	ldbu	r3,-16(fp)
8113c058:	e13ff317 	ldw	r4,-52(fp)
8113c05c:	20c7883a 	add	r3,r4,r3
8113c060:	18c002c4 	addi	r3,r3,11
8113c064:	18c00003 	ldbu	r3,0(r3)
8113c068:	1809883a 	mov	r4,r3
8113c06c:	e0fffc83 	ldbu	r3,-14(fp)
8113c070:	00c6303a 	nor	r3,zero,r3
8113c074:	20c6703a 	and	r3,r4,r3
8113c078:	1809883a 	mov	r4,r3
8113c07c:	e0fff317 	ldw	r3,-52(fp)
8113c080:	1885883a 	add	r2,r3,r2
8113c084:	108002c4 	addi	r2,r2,11
8113c088:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113c08c:	e0bffc03 	ldbu	r2,-16(fp)
8113c090:	e0fff317 	ldw	r3,-52(fp)
8113c094:	1885883a 	add	r2,r3,r2
8113c098:	108002c4 	addi	r2,r2,11
8113c09c:	10800003 	ldbu	r2,0(r2)
8113c0a0:	10803fcc 	andi	r2,r2,255
8113c0a4:	1000091e 	bne	r2,zero,8113c0cc <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113c0a8:	e0bff317 	ldw	r2,-52(fp)
8113c0ac:	10800283 	ldbu	r2,10(r2)
8113c0b0:	1007883a 	mov	r3,r2
8113c0b4:	e0bffc43 	ldbu	r2,-15(fp)
8113c0b8:	0084303a 	nor	r2,zero,r2
8113c0bc:	1884703a 	and	r2,r3,r2
8113c0c0:	1007883a 	mov	r3,r2
8113c0c4:	e0bff317 	ldw	r2,-52(fp)
8113c0c8:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113c0cc:	e0bff317 	ldw	r2,-52(fp)
8113c0d0:	10c00283 	ldbu	r3,10(r2)
8113c0d4:	e0bffb83 	ldbu	r2,-18(fp)
8113c0d8:	1884b03a 	or	r2,r3,r2
8113c0dc:	1007883a 	mov	r3,r2
8113c0e0:	e0bff317 	ldw	r2,-52(fp)
8113c0e4:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113c0e8:	e0bffb03 	ldbu	r2,-20(fp)
8113c0ec:	e0fffb03 	ldbu	r3,-20(fp)
8113c0f0:	e13ff317 	ldw	r4,-52(fp)
8113c0f4:	20c7883a 	add	r3,r4,r3
8113c0f8:	18c002c4 	addi	r3,r3,11
8113c0fc:	19000003 	ldbu	r4,0(r3)
8113c100:	e0fffbc3 	ldbu	r3,-17(fp)
8113c104:	20c6b03a 	or	r3,r4,r3
8113c108:	1809883a 	mov	r4,r3
8113c10c:	e0fff317 	ldw	r3,-52(fp)
8113c110:	1885883a 	add	r2,r3,r2
8113c114:	108002c4 	addi	r2,r2,11
8113c118:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113c11c:	e0bff817 	ldw	r2,-32(fp)
8113c120:	10800817 	ldw	r2,32(r2)
8113c124:	10004226 	beq	r2,zero,8113c230 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113c128:	e0bff817 	ldw	r2,-32(fp)
8113c12c:	10800817 	ldw	r2,32(r2)
8113c130:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113c134:	e0bff417 	ldw	r2,-48(fp)
8113c138:	10800017 	ldw	r2,0(r2)
8113c13c:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113c140:	00003906 	br	8113c228 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113c144:	e0bffc03 	ldbu	r2,-16(fp)
8113c148:	e0fffc03 	ldbu	r3,-16(fp)
8113c14c:	e13ff317 	ldw	r4,-52(fp)
8113c150:	20c7883a 	add	r3,r4,r3
8113c154:	18c002c4 	addi	r3,r3,11
8113c158:	18c00003 	ldbu	r3,0(r3)
8113c15c:	1809883a 	mov	r4,r3
8113c160:	e0fffc83 	ldbu	r3,-14(fp)
8113c164:	00c6303a 	nor	r3,zero,r3
8113c168:	20c6703a 	and	r3,r4,r3
8113c16c:	1809883a 	mov	r4,r3
8113c170:	e0fff317 	ldw	r3,-52(fp)
8113c174:	1885883a 	add	r2,r3,r2
8113c178:	108002c4 	addi	r2,r2,11
8113c17c:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113c180:	e0bffc03 	ldbu	r2,-16(fp)
8113c184:	e0fff317 	ldw	r3,-52(fp)
8113c188:	1885883a 	add	r2,r3,r2
8113c18c:	108002c4 	addi	r2,r2,11
8113c190:	10800003 	ldbu	r2,0(r2)
8113c194:	10803fcc 	andi	r2,r2,255
8113c198:	1000091e 	bne	r2,zero,8113c1c0 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113c19c:	e0bff317 	ldw	r2,-52(fp)
8113c1a0:	10800283 	ldbu	r2,10(r2)
8113c1a4:	1007883a 	mov	r3,r2
8113c1a8:	e0bffc43 	ldbu	r2,-15(fp)
8113c1ac:	0084303a 	nor	r2,zero,r2
8113c1b0:	1884703a 	and	r2,r3,r2
8113c1b4:	1007883a 	mov	r3,r2
8113c1b8:	e0bff317 	ldw	r2,-52(fp)
8113c1bc:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113c1c0:	e0bff317 	ldw	r2,-52(fp)
8113c1c4:	10c00283 	ldbu	r3,10(r2)
8113c1c8:	e0bffb83 	ldbu	r2,-18(fp)
8113c1cc:	1884b03a 	or	r2,r3,r2
8113c1d0:	1007883a 	mov	r3,r2
8113c1d4:	e0bff317 	ldw	r2,-52(fp)
8113c1d8:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113c1dc:	e0bffb03 	ldbu	r2,-20(fp)
8113c1e0:	e0fffb03 	ldbu	r3,-20(fp)
8113c1e4:	e13ff317 	ldw	r4,-52(fp)
8113c1e8:	20c7883a 	add	r3,r4,r3
8113c1ec:	18c002c4 	addi	r3,r3,11
8113c1f0:	19000003 	ldbu	r4,0(r3)
8113c1f4:	e0fffbc3 	ldbu	r3,-17(fp)
8113c1f8:	20c6b03a 	or	r3,r4,r3
8113c1fc:	1809883a 	mov	r4,r3
8113c200:	e0fff317 	ldw	r3,-52(fp)
8113c204:	1885883a 	add	r2,r3,r2
8113c208:	108002c4 	addi	r2,r2,11
8113c20c:	11000005 	stb	r4,0(r2)
            pevents++;
8113c210:	e0bff417 	ldw	r2,-48(fp)
8113c214:	10800104 	addi	r2,r2,4
8113c218:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113c21c:	e0bff417 	ldw	r2,-48(fp)
8113c220:	10800017 	ldw	r2,0(r2)
8113c224:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113c228:	e0bff317 	ldw	r2,-52(fp)
8113c22c:	103fc51e 	bne	r2,zero,8113c144 <__reset+0xfb11c144>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113c230:	e0bff817 	ldw	r2,-32(fp)
8113c234:	e0ffff03 	ldbu	r3,-4(fp)
8113c238:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113c23c:	e0bff817 	ldw	r2,-32(fp)
8113c240:	e0fffb03 	ldbu	r3,-20(fp)
8113c244:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113c248:	e0bff817 	ldw	r2,-32(fp)
8113c24c:	e0fffb43 	ldbu	r3,-19(fp)
8113c250:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113c254:	e0bff817 	ldw	r2,-32(fp)
8113c258:	e0fffb83 	ldbu	r3,-18(fp)
8113c25c:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113c260:	e0bff817 	ldw	r2,-32(fp)
8113c264:	e0fffbc3 	ldbu	r3,-17(fp)
8113c268:	10c00d45 	stb	r3,53(r2)
8113c26c:	e0bff517 	ldw	r2,-44(fp)
8113c270:	e0bffa15 	stw	r2,-24(fp)
8113c274:	e0bffa17 	ldw	r2,-24(fp)
8113c278:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113c27c:	d0a09003 	ldbu	r2,-32192(gp)
8113c280:	10803fcc 	andi	r2,r2,255
8113c284:	10800058 	cmpnei	r2,r2,1
8113c288:	1000011e 	bne	r2,zero,8113c290 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113c28c:	11368400 	call	81136840 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113c290:	0005883a 	mov	r2,zero
}
8113c294:	e037883a 	mov	sp,fp
8113c298:	dfc00117 	ldw	ra,4(sp)
8113c29c:	df000017 	ldw	fp,0(sp)
8113c2a0:	dec00204 	addi	sp,sp,8
8113c2a4:	f800283a 	ret

8113c2a8 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8113c2a8:	deffee04 	addi	sp,sp,-72
8113c2ac:	de00012e 	bgeu	sp,et,8113c2b4 <OSTaskCreate+0xc>
8113c2b0:	003b68fa 	trap	3
8113c2b4:	dfc01115 	stw	ra,68(sp)
8113c2b8:	df001015 	stw	fp,64(sp)
8113c2bc:	df001004 	addi	fp,sp,64
8113c2c0:	e13ffc15 	stw	r4,-16(fp)
8113c2c4:	e17ffd15 	stw	r5,-12(fp)
8113c2c8:	e1bffe15 	stw	r6,-8(fp)
8113c2cc:	3805883a 	mov	r2,r7
8113c2d0:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113c2d4:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113c2d8:	e0bfff03 	ldbu	r2,-4(fp)
8113c2dc:	10800af0 	cmpltui	r2,r2,43
8113c2e0:	1000021e 	bne	r2,zero,8113c2ec <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113c2e4:	00800a84 	movi	r2,42
8113c2e8:	00005706 	br	8113c448 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c2ec:	0005303a 	rdctl	r2,status
8113c2f0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c2f4:	e0fffb17 	ldw	r3,-20(fp)
8113c2f8:	00bfff84 	movi	r2,-2
8113c2fc:	1884703a 	and	r2,r3,r2
8113c300:	1001703a 	wrctl	status,r2
  
  return context;
8113c304:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113c308:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113c30c:	d0a0a003 	ldbu	r2,-32128(gp)
8113c310:	10803fcc 	andi	r2,r2,255
8113c314:	10000626 	beq	r2,zero,8113c330 <OSTaskCreate+0x88>
8113c318:	e0bff317 	ldw	r2,-52(fp)
8113c31c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c320:	e0bff417 	ldw	r2,-48(fp)
8113c324:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113c328:	00800f04 	movi	r2,60
8113c32c:	00004606 	br	8113c448 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113c330:	e0ffff03 	ldbu	r3,-4(fp)
8113c334:	00a045f4 	movhi	r2,33047
8113c338:	10a46104 	addi	r2,r2,-28284
8113c33c:	18c7883a 	add	r3,r3,r3
8113c340:	18c7883a 	add	r3,r3,r3
8113c344:	10c5883a 	add	r2,r2,r3
8113c348:	10800017 	ldw	r2,0(r2)
8113c34c:	1000391e 	bne	r2,zero,8113c434 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113c350:	e0ffff03 	ldbu	r3,-4(fp)
8113c354:	00a045f4 	movhi	r2,33047
8113c358:	10a46104 	addi	r2,r2,-28284
8113c35c:	18c7883a 	add	r3,r3,r3
8113c360:	18c7883a 	add	r3,r3,r3
8113c364:	10c5883a 	add	r2,r2,r3
8113c368:	00c00044 	movi	r3,1
8113c36c:	10c00015 	stw	r3,0(r2)
8113c370:	e0bff317 	ldw	r2,-52(fp)
8113c374:	e0bff515 	stw	r2,-44(fp)
8113c378:	e0bff517 	ldw	r2,-44(fp)
8113c37c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8113c380:	000f883a 	mov	r7,zero
8113c384:	e1bffe17 	ldw	r6,-8(fp)
8113c388:	e17ffd17 	ldw	r5,-12(fp)
8113c38c:	e13ffc17 	ldw	r4,-16(fp)
8113c390:	11479500 	call	81147950 <OSTaskStkInit>
8113c394:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8113c398:	e0bfff03 	ldbu	r2,-4(fp)
8113c39c:	d8000215 	stw	zero,8(sp)
8113c3a0:	d8000115 	stw	zero,4(sp)
8113c3a4:	d8000015 	stw	zero,0(sp)
8113c3a8:	000f883a 	mov	r7,zero
8113c3ac:	000d883a 	mov	r6,zero
8113c3b0:	e17ff717 	ldw	r5,-36(fp)
8113c3b4:	1009883a 	mov	r4,r2
8113c3b8:	1136c880 	call	81136c88 <OS_TCBInit>
8113c3bc:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8113c3c0:	e0bff803 	ldbu	r2,-32(fp)
8113c3c4:	1000061e 	bne	r2,zero,8113c3e0 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8113c3c8:	d0a09003 	ldbu	r2,-32192(gp)
8113c3cc:	10803fcc 	andi	r2,r2,255
8113c3d0:	10800058 	cmpnei	r2,r2,1
8113c3d4:	1000151e 	bne	r2,zero,8113c42c <OSTaskCreate+0x184>
                OS_Sched();
8113c3d8:	11368400 	call	81136840 <OS_Sched>
8113c3dc:	00001306 	br	8113c42c <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c3e0:	0005303a 	rdctl	r2,status
8113c3e4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c3e8:	e0fffa17 	ldw	r3,-24(fp)
8113c3ec:	00bfff84 	movi	r2,-2
8113c3f0:	1884703a 	and	r2,r3,r2
8113c3f4:	1001703a 	wrctl	status,r2
  
  return context;
8113c3f8:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113c3fc:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8113c400:	e0ffff03 	ldbu	r3,-4(fp)
8113c404:	00a045f4 	movhi	r2,33047
8113c408:	10a46104 	addi	r2,r2,-28284
8113c40c:	18c7883a 	add	r3,r3,r3
8113c410:	18c7883a 	add	r3,r3,r3
8113c414:	10c5883a 	add	r2,r2,r3
8113c418:	10000015 	stw	zero,0(r2)
8113c41c:	e0bff317 	ldw	r2,-52(fp)
8113c420:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c424:	e0bff617 	ldw	r2,-40(fp)
8113c428:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113c42c:	e0bff803 	ldbu	r2,-32(fp)
8113c430:	00000506 	br	8113c448 <OSTaskCreate+0x1a0>
8113c434:	e0bff317 	ldw	r2,-52(fp)
8113c438:	e0bff915 	stw	r2,-28(fp)
8113c43c:	e0bff917 	ldw	r2,-28(fp)
8113c440:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113c444:	00800a04 	movi	r2,40
}
8113c448:	e037883a 	mov	sp,fp
8113c44c:	dfc00117 	ldw	ra,4(sp)
8113c450:	df000017 	ldw	fp,0(sp)
8113c454:	dec00204 	addi	sp,sp,8
8113c458:	f800283a 	ret

8113c45c <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113c45c:	deffec04 	addi	sp,sp,-80
8113c460:	de00012e 	bgeu	sp,et,8113c468 <OSTaskCreateExt+0xc>
8113c464:	003b68fa 	trap	3
8113c468:	dfc01315 	stw	ra,76(sp)
8113c46c:	df001215 	stw	fp,72(sp)
8113c470:	df001204 	addi	fp,sp,72
8113c474:	e13ffa15 	stw	r4,-24(fp)
8113c478:	e17ffb15 	stw	r5,-20(fp)
8113c47c:	e1bffc15 	stw	r6,-16(fp)
8113c480:	3809883a 	mov	r4,r7
8113c484:	e0c00217 	ldw	r3,8(fp)
8113c488:	e0800617 	ldw	r2,24(fp)
8113c48c:	e13ffd05 	stb	r4,-12(fp)
8113c490:	e0fffe0d 	sth	r3,-8(fp)
8113c494:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113c498:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113c49c:	e0bffd03 	ldbu	r2,-12(fp)
8113c4a0:	10800af0 	cmpltui	r2,r2,43
8113c4a4:	1000021e 	bne	r2,zero,8113c4b0 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113c4a8:	00800a84 	movi	r2,42
8113c4ac:	00006106 	br	8113c634 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c4b0:	0005303a 	rdctl	r2,status
8113c4b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c4b8:	e0fff917 	ldw	r3,-28(fp)
8113c4bc:	00bfff84 	movi	r2,-2
8113c4c0:	1884703a 	and	r2,r3,r2
8113c4c4:	1001703a 	wrctl	status,r2
  
  return context;
8113c4c8:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113c4cc:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113c4d0:	d0a0a003 	ldbu	r2,-32128(gp)
8113c4d4:	10803fcc 	andi	r2,r2,255
8113c4d8:	10000626 	beq	r2,zero,8113c4f4 <OSTaskCreateExt+0x98>
8113c4dc:	e0bff117 	ldw	r2,-60(fp)
8113c4e0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c4e4:	e0bff217 	ldw	r2,-56(fp)
8113c4e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113c4ec:	00800f04 	movi	r2,60
8113c4f0:	00005006 	br	8113c634 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113c4f4:	e0fffd03 	ldbu	r3,-12(fp)
8113c4f8:	00a045f4 	movhi	r2,33047
8113c4fc:	10a46104 	addi	r2,r2,-28284
8113c500:	18c7883a 	add	r3,r3,r3
8113c504:	18c7883a 	add	r3,r3,r3
8113c508:	10c5883a 	add	r2,r2,r3
8113c50c:	10800017 	ldw	r2,0(r2)
8113c510:	1000431e 	bne	r2,zero,8113c620 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113c514:	e0fffd03 	ldbu	r3,-12(fp)
8113c518:	00a045f4 	movhi	r2,33047
8113c51c:	10a46104 	addi	r2,r2,-28284
8113c520:	18c7883a 	add	r3,r3,r3
8113c524:	18c7883a 	add	r3,r3,r3
8113c528:	10c5883a 	add	r2,r2,r3
8113c52c:	00c00044 	movi	r3,1
8113c530:	10c00015 	stw	r3,0(r2)
8113c534:	e0bff117 	ldw	r2,-60(fp)
8113c538:	e0bff315 	stw	r2,-52(fp)
8113c53c:	e0bff317 	ldw	r2,-52(fp)
8113c540:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113c544:	e0bfff0b 	ldhu	r2,-4(fp)
8113c548:	100d883a 	mov	r6,r2
8113c54c:	e1400417 	ldw	r5,16(fp)
8113c550:	e1000317 	ldw	r4,12(fp)
8113c554:	113d5040 	call	8113d504 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113c558:	e0bfff0b 	ldhu	r2,-4(fp)
8113c55c:	100f883a 	mov	r7,r2
8113c560:	e1bffc17 	ldw	r6,-16(fp)
8113c564:	e17ffb17 	ldw	r5,-20(fp)
8113c568:	e13ffa17 	ldw	r4,-24(fp)
8113c56c:	11479500 	call	81147950 <OSTaskStkInit>
8113c570:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113c574:	e0fffd03 	ldbu	r3,-12(fp)
8113c578:	e13ffe0b 	ldhu	r4,-8(fp)
8113c57c:	e0bfff0b 	ldhu	r2,-4(fp)
8113c580:	d8800215 	stw	r2,8(sp)
8113c584:	e0800517 	ldw	r2,20(fp)
8113c588:	d8800115 	stw	r2,4(sp)
8113c58c:	e0800417 	ldw	r2,16(fp)
8113c590:	d8800015 	stw	r2,0(sp)
8113c594:	200f883a 	mov	r7,r4
8113c598:	e1800317 	ldw	r6,12(fp)
8113c59c:	e17ff517 	ldw	r5,-44(fp)
8113c5a0:	1809883a 	mov	r4,r3
8113c5a4:	1136c880 	call	81136c88 <OS_TCBInit>
8113c5a8:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113c5ac:	e0bff603 	ldbu	r2,-40(fp)
8113c5b0:	1000061e 	bne	r2,zero,8113c5cc <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113c5b4:	d0a09003 	ldbu	r2,-32192(gp)
8113c5b8:	10803fcc 	andi	r2,r2,255
8113c5bc:	10800058 	cmpnei	r2,r2,1
8113c5c0:	1000151e 	bne	r2,zero,8113c618 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113c5c4:	11368400 	call	81136840 <OS_Sched>
8113c5c8:	00001306 	br	8113c618 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c5cc:	0005303a 	rdctl	r2,status
8113c5d0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c5d4:	e0fff817 	ldw	r3,-32(fp)
8113c5d8:	00bfff84 	movi	r2,-2
8113c5dc:	1884703a 	and	r2,r3,r2
8113c5e0:	1001703a 	wrctl	status,r2
  
  return context;
8113c5e4:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113c5e8:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113c5ec:	e0fffd03 	ldbu	r3,-12(fp)
8113c5f0:	00a045f4 	movhi	r2,33047
8113c5f4:	10a46104 	addi	r2,r2,-28284
8113c5f8:	18c7883a 	add	r3,r3,r3
8113c5fc:	18c7883a 	add	r3,r3,r3
8113c600:	10c5883a 	add	r2,r2,r3
8113c604:	10000015 	stw	zero,0(r2)
8113c608:	e0bff117 	ldw	r2,-60(fp)
8113c60c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c610:	e0bff417 	ldw	r2,-48(fp)
8113c614:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113c618:	e0bff603 	ldbu	r2,-40(fp)
8113c61c:	00000506 	br	8113c634 <OSTaskCreateExt+0x1d8>
8113c620:	e0bff117 	ldw	r2,-60(fp)
8113c624:	e0bff715 	stw	r2,-36(fp)
8113c628:	e0bff717 	ldw	r2,-36(fp)
8113c62c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113c630:	00800a04 	movi	r2,40
}
8113c634:	e037883a 	mov	sp,fp
8113c638:	dfc00117 	ldw	ra,4(sp)
8113c63c:	df000017 	ldw	fp,0(sp)
8113c640:	dec00204 	addi	sp,sp,8
8113c644:	f800283a 	ret

8113c648 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113c648:	defff404 	addi	sp,sp,-48
8113c64c:	de00012e 	bgeu	sp,et,8113c654 <OSTaskDel+0xc>
8113c650:	003b68fa 	trap	3
8113c654:	dfc00b15 	stw	ra,44(sp)
8113c658:	df000a15 	stw	fp,40(sp)
8113c65c:	df000a04 	addi	fp,sp,40
8113c660:	2005883a 	mov	r2,r4
8113c664:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113c668:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113c66c:	d0a0a003 	ldbu	r2,-32128(gp)
8113c670:	10803fcc 	andi	r2,r2,255
8113c674:	10000226 	beq	r2,zero,8113c680 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113c678:	00801004 	movi	r2,64
8113c67c:	0000c006 	br	8113c980 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113c680:	e0bfff03 	ldbu	r2,-4(fp)
8113c684:	10800a98 	cmpnei	r2,r2,42
8113c688:	1000021e 	bne	r2,zero,8113c694 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113c68c:	00800f84 	movi	r2,62
8113c690:	0000bb06 	br	8113c980 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113c694:	e0bfff03 	ldbu	r2,-4(fp)
8113c698:	10800ab0 	cmpltui	r2,r2,42
8113c69c:	1000051e 	bne	r2,zero,8113c6b4 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113c6a0:	e0bfff03 	ldbu	r2,-4(fp)
8113c6a4:	10803fe0 	cmpeqi	r2,r2,255
8113c6a8:	1000021e 	bne	r2,zero,8113c6b4 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113c6ac:	00800a84 	movi	r2,42
8113c6b0:	0000b306 	br	8113c980 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c6b4:	0005303a 	rdctl	r2,status
8113c6b8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c6bc:	e0fffe17 	ldw	r3,-8(fp)
8113c6c0:	00bfff84 	movi	r2,-2
8113c6c4:	1884703a 	and	r2,r3,r2
8113c6c8:	1001703a 	wrctl	status,r2
  
  return context;
8113c6cc:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113c6d0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113c6d4:	e0bfff03 	ldbu	r2,-4(fp)
8113c6d8:	10803fd8 	cmpnei	r2,r2,255
8113c6dc:	1000031e 	bne	r2,zero,8113c6ec <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113c6e0:	d0a0a117 	ldw	r2,-32124(gp)
8113c6e4:	10800c83 	ldbu	r2,50(r2)
8113c6e8:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113c6ec:	e0ffff03 	ldbu	r3,-4(fp)
8113c6f0:	00a045f4 	movhi	r2,33047
8113c6f4:	10a46104 	addi	r2,r2,-28284
8113c6f8:	18c7883a 	add	r3,r3,r3
8113c6fc:	18c7883a 	add	r3,r3,r3
8113c700:	10c5883a 	add	r2,r2,r3
8113c704:	10800017 	ldw	r2,0(r2)
8113c708:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113c70c:	e0bff817 	ldw	r2,-32(fp)
8113c710:	1000061e 	bne	r2,zero,8113c72c <OSTaskDel+0xe4>
8113c714:	e0bff617 	ldw	r2,-40(fp)
8113c718:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c71c:	e0bff717 	ldw	r2,-36(fp)
8113c720:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113c724:	008010c4 	movi	r2,67
8113c728:	00009506 	br	8113c980 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113c72c:	e0bff817 	ldw	r2,-32(fp)
8113c730:	10800058 	cmpnei	r2,r2,1
8113c734:	1000061e 	bne	r2,zero,8113c750 <OSTaskDel+0x108>
8113c738:	e0bff617 	ldw	r2,-40(fp)
8113c73c:	e0bff915 	stw	r2,-28(fp)
8113c740:	e0bff917 	ldw	r2,-28(fp)
8113c744:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113c748:	00800f44 	movi	r2,61
8113c74c:	00008c06 	br	8113c980 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113c750:	e0bff817 	ldw	r2,-32(fp)
8113c754:	10800d03 	ldbu	r2,52(r2)
8113c758:	10c03fcc 	andi	r3,r2,255
8113c75c:	e0bff817 	ldw	r2,-32(fp)
8113c760:	10800d03 	ldbu	r2,52(r2)
8113c764:	11003fcc 	andi	r4,r2,255
8113c768:	d0a09d44 	addi	r2,gp,-32139
8113c76c:	2085883a 	add	r2,r4,r2
8113c770:	10800003 	ldbu	r2,0(r2)
8113c774:	1009883a 	mov	r4,r2
8113c778:	e0bff817 	ldw	r2,-32(fp)
8113c77c:	10800d43 	ldbu	r2,53(r2)
8113c780:	0084303a 	nor	r2,zero,r2
8113c784:	2084703a 	and	r2,r4,r2
8113c788:	1009883a 	mov	r4,r2
8113c78c:	d0a09d44 	addi	r2,gp,-32139
8113c790:	1885883a 	add	r2,r3,r2
8113c794:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113c798:	e0bff817 	ldw	r2,-32(fp)
8113c79c:	10800d03 	ldbu	r2,52(r2)
8113c7a0:	10c03fcc 	andi	r3,r2,255
8113c7a4:	d0a09d44 	addi	r2,gp,-32139
8113c7a8:	1885883a 	add	r2,r3,r2
8113c7ac:	10800003 	ldbu	r2,0(r2)
8113c7b0:	10803fcc 	andi	r2,r2,255
8113c7b4:	1000071e 	bne	r2,zero,8113c7d4 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113c7b8:	e0bff817 	ldw	r2,-32(fp)
8113c7bc:	10800d83 	ldbu	r2,54(r2)
8113c7c0:	0084303a 	nor	r2,zero,r2
8113c7c4:	1007883a 	mov	r3,r2
8113c7c8:	d0a09d03 	ldbu	r2,-32140(gp)
8113c7cc:	1884703a 	and	r2,r3,r2
8113c7d0:	d0a09d05 	stb	r2,-32140(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113c7d4:	e0bff817 	ldw	r2,-32(fp)
8113c7d8:	10800717 	ldw	r2,28(r2)
8113c7dc:	10000526 	beq	r2,zero,8113c7f4 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113c7e0:	e0bff817 	ldw	r2,-32(fp)
8113c7e4:	10800717 	ldw	r2,28(r2)
8113c7e8:	100b883a 	mov	r5,r2
8113c7ec:	e13ff817 	ldw	r4,-32(fp)
8113c7f0:	11361940 	call	81136194 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113c7f4:	e0bff817 	ldw	r2,-32(fp)
8113c7f8:	10800817 	ldw	r2,32(r2)
8113c7fc:	10000526 	beq	r2,zero,8113c814 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113c800:	e0bff817 	ldw	r2,-32(fp)
8113c804:	10800817 	ldw	r2,32(r2)
8113c808:	100b883a 	mov	r5,r2
8113c80c:	e13ff817 	ldw	r4,-32(fp)
8113c810:	11362540 	call	81136254 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113c814:	e0bff817 	ldw	r2,-32(fp)
8113c818:	10800a17 	ldw	r2,40(r2)
8113c81c:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113c820:	e0bffb17 	ldw	r2,-20(fp)
8113c824:	10000226 	beq	r2,zero,8113c830 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113c828:	e13ffb17 	ldw	r4,-20(fp)
8113c82c:	113882c0 	call	8113882c <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113c830:	e0bff817 	ldw	r2,-32(fp)
8113c834:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113c838:	e0bff817 	ldw	r2,-32(fp)
8113c83c:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113c840:	e0bff817 	ldw	r2,-32(fp)
8113c844:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113c848:	d0a08e03 	ldbu	r2,-32200(gp)
8113c84c:	10803fcc 	andi	r2,r2,255
8113c850:	10803fe0 	cmpeqi	r2,r2,255
8113c854:	1000031e 	bne	r2,zero,8113c864 <OSTaskDel+0x21c>
        OSLockNesting++;
8113c858:	d0a08e03 	ldbu	r2,-32200(gp)
8113c85c:	10800044 	addi	r2,r2,1
8113c860:	d0a08e05 	stb	r2,-32200(gp)
8113c864:	e0bff617 	ldw	r2,-40(fp)
8113c868:	e0bffd15 	stw	r2,-12(fp)
8113c86c:	e0bffd17 	ldw	r2,-12(fp)
8113c870:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113c874:	1135d5c0 	call	81135d5c <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c878:	0005303a 	rdctl	r2,status
8113c87c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c880:	e0fffa17 	ldw	r3,-24(fp)
8113c884:	00bfff84 	movi	r2,-2
8113c888:	1884703a 	and	r2,r3,r2
8113c88c:	1001703a 	wrctl	status,r2
  
  return context;
8113c890:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113c894:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113c898:	d0a08e03 	ldbu	r2,-32200(gp)
8113c89c:	10803fcc 	andi	r2,r2,255
8113c8a0:	10000326 	beq	r2,zero,8113c8b0 <OSTaskDel+0x268>
        OSLockNesting--;
8113c8a4:	d0a08e03 	ldbu	r2,-32200(gp)
8113c8a8:	10bfffc4 	addi	r2,r2,-1
8113c8ac:	d0a08e05 	stb	r2,-32200(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113c8b0:	e13ff817 	ldw	r4,-32(fp)
8113c8b4:	1147ae00 	call	81147ae0 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113c8b8:	d0a09943 	ldbu	r2,-32155(gp)
8113c8bc:	10bfffc4 	addi	r2,r2,-1
8113c8c0:	d0a09945 	stb	r2,-32155(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113c8c4:	e0ffff03 	ldbu	r3,-4(fp)
8113c8c8:	00a045f4 	movhi	r2,33047
8113c8cc:	10a46104 	addi	r2,r2,-28284
8113c8d0:	18c7883a 	add	r3,r3,r3
8113c8d4:	18c7883a 	add	r3,r3,r3
8113c8d8:	10c5883a 	add	r2,r2,r3
8113c8dc:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113c8e0:	e0bff817 	ldw	r2,-32(fp)
8113c8e4:	10800617 	ldw	r2,24(r2)
8113c8e8:	1000071e 	bne	r2,zero,8113c908 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113c8ec:	e0bff817 	ldw	r2,-32(fp)
8113c8f0:	10800517 	ldw	r2,20(r2)
8113c8f4:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113c8f8:	e0bff817 	ldw	r2,-32(fp)
8113c8fc:	10800517 	ldw	r2,20(r2)
8113c900:	d0a09315 	stw	r2,-32180(gp)
8113c904:	00000a06 	br	8113c930 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113c908:	e0bff817 	ldw	r2,-32(fp)
8113c90c:	10800617 	ldw	r2,24(r2)
8113c910:	e0fff817 	ldw	r3,-32(fp)
8113c914:	18c00517 	ldw	r3,20(r3)
8113c918:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113c91c:	e0bff817 	ldw	r2,-32(fp)
8113c920:	10800517 	ldw	r2,20(r2)
8113c924:	e0fff817 	ldw	r3,-32(fp)
8113c928:	18c00617 	ldw	r3,24(r3)
8113c92c:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113c930:	d0e09817 	ldw	r3,-32160(gp)
8113c934:	e0bff817 	ldw	r2,-32(fp)
8113c938:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113c93c:	e0bff817 	ldw	r2,-32(fp)
8113c940:	d0a09815 	stw	r2,-32160(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113c944:	e0bff817 	ldw	r2,-32(fp)
8113c948:	00c00fc4 	movi	r3,63
8113c94c:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113c950:	e0bff817 	ldw	r2,-32(fp)
8113c954:	10001345 	stb	zero,77(r2)
8113c958:	e0bff617 	ldw	r2,-40(fp)
8113c95c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c960:	e0bffc17 	ldw	r2,-16(fp)
8113c964:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113c968:	d0a09003 	ldbu	r2,-32192(gp)
8113c96c:	10803fcc 	andi	r2,r2,255
8113c970:	10800058 	cmpnei	r2,r2,1
8113c974:	1000011e 	bne	r2,zero,8113c97c <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113c978:	11368400 	call	81136840 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113c97c:	0005883a 	mov	r2,zero
}
8113c980:	e037883a 	mov	sp,fp
8113c984:	dfc00117 	ldw	ra,4(sp)
8113c988:	df000017 	ldw	fp,0(sp)
8113c98c:	dec00204 	addi	sp,sp,8
8113c990:	f800283a 	ret

8113c994 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113c994:	defff504 	addi	sp,sp,-44
8113c998:	de00012e 	bgeu	sp,et,8113c9a0 <OSTaskDelReq+0xc>
8113c99c:	003b68fa 	trap	3
8113c9a0:	df000a15 	stw	fp,40(sp)
8113c9a4:	df000a04 	addi	fp,sp,40
8113c9a8:	2005883a 	mov	r2,r4
8113c9ac:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c9b0:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113c9b4:	e0bfff03 	ldbu	r2,-4(fp)
8113c9b8:	10800a98 	cmpnei	r2,r2,42
8113c9bc:	1000021e 	bne	r2,zero,8113c9c8 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113c9c0:	00800f84 	movi	r2,62
8113c9c4:	00004506 	br	8113cadc <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113c9c8:	e0bfff03 	ldbu	r2,-4(fp)
8113c9cc:	10800ab0 	cmpltui	r2,r2,42
8113c9d0:	1000051e 	bne	r2,zero,8113c9e8 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113c9d4:	e0bfff03 	ldbu	r2,-4(fp)
8113c9d8:	10803fe0 	cmpeqi	r2,r2,255
8113c9dc:	1000021e 	bne	r2,zero,8113c9e8 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113c9e0:	00800a84 	movi	r2,42
8113c9e4:	00003d06 	br	8113cadc <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113c9e8:	e0bfff03 	ldbu	r2,-4(fp)
8113c9ec:	10803fd8 	cmpnei	r2,r2,255
8113c9f0:	1000111e 	bne	r2,zero,8113ca38 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c9f4:	0005303a 	rdctl	r2,status
8113c9f8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c9fc:	e0fff917 	ldw	r3,-28(fp)
8113ca00:	00bfff84 	movi	r2,-2
8113ca04:	1884703a 	and	r2,r3,r2
8113ca08:	1001703a 	wrctl	status,r2
  
  return context;
8113ca0c:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113ca10:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113ca14:	d0a0a117 	ldw	r2,-32124(gp)
8113ca18:	10800dc3 	ldbu	r2,55(r2)
8113ca1c:	e0bff805 	stb	r2,-32(fp)
8113ca20:	e0bff617 	ldw	r2,-40(fp)
8113ca24:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ca28:	e0bffe17 	ldw	r2,-8(fp)
8113ca2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113ca30:	e0bff803 	ldbu	r2,-32(fp)
8113ca34:	00002906 	br	8113cadc <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ca38:	0005303a 	rdctl	r2,status
8113ca3c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ca40:	e0fff717 	ldw	r3,-36(fp)
8113ca44:	00bfff84 	movi	r2,-2
8113ca48:	1884703a 	and	r2,r3,r2
8113ca4c:	1001703a 	wrctl	status,r2
  
  return context;
8113ca50:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113ca54:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113ca58:	e0ffff03 	ldbu	r3,-4(fp)
8113ca5c:	00a045f4 	movhi	r2,33047
8113ca60:	10a46104 	addi	r2,r2,-28284
8113ca64:	18c7883a 	add	r3,r3,r3
8113ca68:	18c7883a 	add	r3,r3,r3
8113ca6c:	10c5883a 	add	r2,r2,r3
8113ca70:	10800017 	ldw	r2,0(r2)
8113ca74:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113ca78:	e0bffb17 	ldw	r2,-20(fp)
8113ca7c:	1000061e 	bne	r2,zero,8113ca98 <OSTaskDelReq+0x104>
8113ca80:	e0bff617 	ldw	r2,-40(fp)
8113ca84:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ca88:	e0bffa17 	ldw	r2,-24(fp)
8113ca8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113ca90:	008010c4 	movi	r2,67
8113ca94:	00001106 	br	8113cadc <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113ca98:	e0bffb17 	ldw	r2,-20(fp)
8113ca9c:	10800058 	cmpnei	r2,r2,1
8113caa0:	1000061e 	bne	r2,zero,8113cabc <OSTaskDelReq+0x128>
8113caa4:	e0bff617 	ldw	r2,-40(fp)
8113caa8:	e0bffc15 	stw	r2,-16(fp)
8113caac:	e0bffc17 	ldw	r2,-16(fp)
8113cab0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113cab4:	00800f44 	movi	r2,61
8113cab8:	00000806 	br	8113cadc <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113cabc:	e0bffb17 	ldw	r2,-20(fp)
8113cac0:	00c00fc4 	movi	r3,63
8113cac4:	10c00dc5 	stb	r3,55(r2)
8113cac8:	e0bff617 	ldw	r2,-40(fp)
8113cacc:	e0bffd15 	stw	r2,-12(fp)
8113cad0:	e0bffd17 	ldw	r2,-12(fp)
8113cad4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113cad8:	0005883a 	mov	r2,zero
}
8113cadc:	e037883a 	mov	sp,fp
8113cae0:	df000017 	ldw	fp,0(sp)
8113cae4:	dec00104 	addi	sp,sp,4
8113cae8:	f800283a 	ret

8113caec <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113caec:	defff404 	addi	sp,sp,-48
8113caf0:	de00012e 	bgeu	sp,et,8113caf8 <OSTaskNameGet+0xc>
8113caf4:	003b68fa 	trap	3
8113caf8:	dfc00b15 	stw	ra,44(sp)
8113cafc:	df000a15 	stw	fp,40(sp)
8113cb00:	df000a04 	addi	fp,sp,40
8113cb04:	2005883a 	mov	r2,r4
8113cb08:	e17ffe15 	stw	r5,-8(fp)
8113cb0c:	e1bfff15 	stw	r6,-4(fp)
8113cb10:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113cb14:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113cb18:	e0bfff17 	ldw	r2,-4(fp)
8113cb1c:	1000021e 	bne	r2,zero,8113cb28 <OSTaskNameGet+0x3c>
        return (0);
8113cb20:	0005883a 	mov	r2,zero
8113cb24:	00005406 	br	8113cc78 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113cb28:	e0bffd03 	ldbu	r2,-12(fp)
8113cb2c:	10800af0 	cmpltui	r2,r2,43
8113cb30:	1000081e 	bne	r2,zero,8113cb54 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113cb34:	e0bffd03 	ldbu	r2,-12(fp)
8113cb38:	10803fe0 	cmpeqi	r2,r2,255
8113cb3c:	1000051e 	bne	r2,zero,8113cb54 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113cb40:	e0bfff17 	ldw	r2,-4(fp)
8113cb44:	00c00a84 	movi	r3,42
8113cb48:	10c00005 	stb	r3,0(r2)
            return (0);
8113cb4c:	0005883a 	mov	r2,zero
8113cb50:	00004906 	br	8113cc78 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113cb54:	e0bffe17 	ldw	r2,-8(fp)
8113cb58:	1000051e 	bne	r2,zero,8113cb70 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113cb5c:	e0bfff17 	ldw	r2,-4(fp)
8113cb60:	00c00304 	movi	r3,12
8113cb64:	10c00005 	stb	r3,0(r2)
        return (0);
8113cb68:	0005883a 	mov	r2,zero
8113cb6c:	00004206 	br	8113cc78 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113cb70:	d0a0a003 	ldbu	r2,-32128(gp)
8113cb74:	10803fcc 	andi	r2,r2,255
8113cb78:	10000526 	beq	r2,zero,8113cb90 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113cb7c:	e0bfff17 	ldw	r2,-4(fp)
8113cb80:	00c00444 	movi	r3,17
8113cb84:	10c00005 	stb	r3,0(r2)
        return (0);
8113cb88:	0005883a 	mov	r2,zero
8113cb8c:	00003a06 	br	8113cc78 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cb90:	0005303a 	rdctl	r2,status
8113cb94:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cb98:	e0fffc17 	ldw	r3,-16(fp)
8113cb9c:	00bfff84 	movi	r2,-2
8113cba0:	1884703a 	and	r2,r3,r2
8113cba4:	1001703a 	wrctl	status,r2
  
  return context;
8113cba8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cbac:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113cbb0:	e0bffd03 	ldbu	r2,-12(fp)
8113cbb4:	10803fd8 	cmpnei	r2,r2,255
8113cbb8:	1000031e 	bne	r2,zero,8113cbc8 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113cbbc:	d0a0a117 	ldw	r2,-32124(gp)
8113cbc0:	10800c83 	ldbu	r2,50(r2)
8113cbc4:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113cbc8:	e0fffd03 	ldbu	r3,-12(fp)
8113cbcc:	00a045f4 	movhi	r2,33047
8113cbd0:	10a46104 	addi	r2,r2,-28284
8113cbd4:	18c7883a 	add	r3,r3,r3
8113cbd8:	18c7883a 	add	r3,r3,r3
8113cbdc:	10c5883a 	add	r2,r2,r3
8113cbe0:	10800017 	ldw	r2,0(r2)
8113cbe4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113cbe8:	e0bff817 	ldw	r2,-32(fp)
8113cbec:	1000091e 	bne	r2,zero,8113cc14 <OSTaskNameGet+0x128>
8113cbf0:	e0bff617 	ldw	r2,-40(fp)
8113cbf4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cbf8:	e0bff717 	ldw	r2,-36(fp)
8113cbfc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113cc00:	e0bfff17 	ldw	r2,-4(fp)
8113cc04:	00c010c4 	movi	r3,67
8113cc08:	10c00005 	stb	r3,0(r2)
        return (0);
8113cc0c:	0005883a 	mov	r2,zero
8113cc10:	00001906 	br	8113cc78 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113cc14:	e0bff817 	ldw	r2,-32(fp)
8113cc18:	10800058 	cmpnei	r2,r2,1
8113cc1c:	1000091e 	bne	r2,zero,8113cc44 <OSTaskNameGet+0x158>
8113cc20:	e0bff617 	ldw	r2,-40(fp)
8113cc24:	e0bff915 	stw	r2,-28(fp)
8113cc28:	e0bff917 	ldw	r2,-28(fp)
8113cc2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113cc30:	e0bfff17 	ldw	r2,-4(fp)
8113cc34:	00c010c4 	movi	r3,67
8113cc38:	10c00005 	stb	r3,0(r2)
        return (0);
8113cc3c:	0005883a 	mov	r2,zero
8113cc40:	00000d06 	br	8113cc78 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113cc44:	e0bff817 	ldw	r2,-32(fp)
8113cc48:	10801304 	addi	r2,r2,76
8113cc4c:	100b883a 	mov	r5,r2
8113cc50:	e13ffe17 	ldw	r4,-8(fp)
8113cc54:	11369940 	call	81136994 <OS_StrCopy>
8113cc58:	e0bffb05 	stb	r2,-20(fp)
8113cc5c:	e0bff617 	ldw	r2,-40(fp)
8113cc60:	e0bffa15 	stw	r2,-24(fp)
8113cc64:	e0bffa17 	ldw	r2,-24(fp)
8113cc68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113cc6c:	e0bfff17 	ldw	r2,-4(fp)
8113cc70:	10000005 	stb	zero,0(r2)
    return (len);
8113cc74:	e0bffb03 	ldbu	r2,-20(fp)
}
8113cc78:	e037883a 	mov	sp,fp
8113cc7c:	dfc00117 	ldw	ra,4(sp)
8113cc80:	df000017 	ldw	fp,0(sp)
8113cc84:	dec00204 	addi	sp,sp,8
8113cc88:	f800283a 	ret

8113cc8c <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113cc8c:	defff304 	addi	sp,sp,-52
8113cc90:	de00012e 	bgeu	sp,et,8113cc98 <OSTaskNameSet+0xc>
8113cc94:	003b68fa 	trap	3
8113cc98:	dfc00c15 	stw	ra,48(sp)
8113cc9c:	df000b15 	stw	fp,44(sp)
8113cca0:	df000b04 	addi	fp,sp,44
8113cca4:	2005883a 	mov	r2,r4
8113cca8:	e17ffe15 	stw	r5,-8(fp)
8113ccac:	e1bfff15 	stw	r6,-4(fp)
8113ccb0:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113ccb4:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113ccb8:	e0bfff17 	ldw	r2,-4(fp)
8113ccbc:	10005c26 	beq	r2,zero,8113ce30 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113ccc0:	e0bffd03 	ldbu	r2,-12(fp)
8113ccc4:	10800af0 	cmpltui	r2,r2,43
8113ccc8:	1000071e 	bne	r2,zero,8113cce8 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113cccc:	e0bffd03 	ldbu	r2,-12(fp)
8113ccd0:	10803fe0 	cmpeqi	r2,r2,255
8113ccd4:	1000041e 	bne	r2,zero,8113cce8 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113ccd8:	e0bfff17 	ldw	r2,-4(fp)
8113ccdc:	00c00a84 	movi	r3,42
8113cce0:	10c00005 	stb	r3,0(r2)
            return;
8113cce4:	00005306 	br	8113ce34 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113cce8:	e0bffe17 	ldw	r2,-8(fp)
8113ccec:	1000041e 	bne	r2,zero,8113cd00 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113ccf0:	e0bfff17 	ldw	r2,-4(fp)
8113ccf4:	00c00304 	movi	r3,12
8113ccf8:	10c00005 	stb	r3,0(r2)
        return;
8113ccfc:	00004d06 	br	8113ce34 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113cd00:	d0a0a003 	ldbu	r2,-32128(gp)
8113cd04:	10803fcc 	andi	r2,r2,255
8113cd08:	10000426 	beq	r2,zero,8113cd1c <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113cd0c:	e0bfff17 	ldw	r2,-4(fp)
8113cd10:	00c00484 	movi	r3,18
8113cd14:	10c00005 	stb	r3,0(r2)
        return;
8113cd18:	00004606 	br	8113ce34 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cd1c:	0005303a 	rdctl	r2,status
8113cd20:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cd24:	e0fffc17 	ldw	r3,-16(fp)
8113cd28:	00bfff84 	movi	r2,-2
8113cd2c:	1884703a 	and	r2,r3,r2
8113cd30:	1001703a 	wrctl	status,r2
  
  return context;
8113cd34:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cd38:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113cd3c:	e0bffd03 	ldbu	r2,-12(fp)
8113cd40:	10803fd8 	cmpnei	r2,r2,255
8113cd44:	1000031e 	bne	r2,zero,8113cd54 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113cd48:	d0a0a117 	ldw	r2,-32124(gp)
8113cd4c:	10800c83 	ldbu	r2,50(r2)
8113cd50:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113cd54:	e0fffd03 	ldbu	r3,-12(fp)
8113cd58:	00a045f4 	movhi	r2,33047
8113cd5c:	10a46104 	addi	r2,r2,-28284
8113cd60:	18c7883a 	add	r3,r3,r3
8113cd64:	18c7883a 	add	r3,r3,r3
8113cd68:	10c5883a 	add	r2,r2,r3
8113cd6c:	10800017 	ldw	r2,0(r2)
8113cd70:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113cd74:	e0bff717 	ldw	r2,-36(fp)
8113cd78:	1000081e 	bne	r2,zero,8113cd9c <OSTaskNameSet+0x110>
8113cd7c:	e0bff517 	ldw	r2,-44(fp)
8113cd80:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cd84:	e0bff617 	ldw	r2,-40(fp)
8113cd88:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113cd8c:	e0bfff17 	ldw	r2,-4(fp)
8113cd90:	00c010c4 	movi	r3,67
8113cd94:	10c00005 	stb	r3,0(r2)
        return;
8113cd98:	00002606 	br	8113ce34 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113cd9c:	e0bff717 	ldw	r2,-36(fp)
8113cda0:	10800058 	cmpnei	r2,r2,1
8113cda4:	1000081e 	bne	r2,zero,8113cdc8 <OSTaskNameSet+0x13c>
8113cda8:	e0bff517 	ldw	r2,-44(fp)
8113cdac:	e0bff815 	stw	r2,-32(fp)
8113cdb0:	e0bff817 	ldw	r2,-32(fp)
8113cdb4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113cdb8:	e0bfff17 	ldw	r2,-4(fp)
8113cdbc:	00c010c4 	movi	r3,67
8113cdc0:	10c00005 	stb	r3,0(r2)
        return;
8113cdc4:	00001b06 	br	8113ce34 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113cdc8:	e13ffe17 	ldw	r4,-8(fp)
8113cdcc:	1136a100 	call	81136a10 <OS_StrLen>
8113cdd0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113cdd4:	e0bffa03 	ldbu	r2,-24(fp)
8113cdd8:	10800830 	cmpltui	r2,r2,32
8113cddc:	1000081e 	bne	r2,zero,8113ce00 <OSTaskNameSet+0x174>
8113cde0:	e0bff517 	ldw	r2,-44(fp)
8113cde4:	e0bff915 	stw	r2,-28(fp)
8113cde8:	e0bff917 	ldw	r2,-28(fp)
8113cdec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113cdf0:	e0bfff17 	ldw	r2,-4(fp)
8113cdf4:	00c01044 	movi	r3,65
8113cdf8:	10c00005 	stb	r3,0(r2)
        return;
8113cdfc:	00000d06 	br	8113ce34 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113ce00:	e0bff717 	ldw	r2,-36(fp)
8113ce04:	10801304 	addi	r2,r2,76
8113ce08:	e17ffe17 	ldw	r5,-8(fp)
8113ce0c:	1009883a 	mov	r4,r2
8113ce10:	11369940 	call	81136994 <OS_StrCopy>
8113ce14:	e0bff517 	ldw	r2,-44(fp)
8113ce18:	e0bffb15 	stw	r2,-20(fp)
8113ce1c:	e0bffb17 	ldw	r2,-20(fp)
8113ce20:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ce24:	e0bfff17 	ldw	r2,-4(fp)
8113ce28:	10000005 	stb	zero,0(r2)
8113ce2c:	00000106 	br	8113ce34 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113ce30:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113ce34:	e037883a 	mov	sp,fp
8113ce38:	dfc00117 	ldw	ra,4(sp)
8113ce3c:	df000017 	ldw	fp,0(sp)
8113ce40:	dec00204 	addi	sp,sp,8
8113ce44:	f800283a 	ret

8113ce48 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113ce48:	defff404 	addi	sp,sp,-48
8113ce4c:	de00012e 	bgeu	sp,et,8113ce54 <OSTaskResume+0xc>
8113ce50:	003b68fa 	trap	3
8113ce54:	dfc00b15 	stw	ra,44(sp)
8113ce58:	df000a15 	stw	fp,40(sp)
8113ce5c:	df000a04 	addi	fp,sp,40
8113ce60:	2005883a 	mov	r2,r4
8113ce64:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113ce68:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113ce6c:	e0bfff03 	ldbu	r2,-4(fp)
8113ce70:	10800ab0 	cmpltui	r2,r2,42
8113ce74:	1000021e 	bne	r2,zero,8113ce80 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113ce78:	00800a84 	movi	r2,42
8113ce7c:	00006406 	br	8113d010 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ce80:	0005303a 	rdctl	r2,status
8113ce84:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ce88:	e0fffe17 	ldw	r3,-8(fp)
8113ce8c:	00bfff84 	movi	r2,-2
8113ce90:	1884703a 	and	r2,r3,r2
8113ce94:	1001703a 	wrctl	status,r2
  
  return context;
8113ce98:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113ce9c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113cea0:	e0ffff03 	ldbu	r3,-4(fp)
8113cea4:	00a045f4 	movhi	r2,33047
8113cea8:	10a46104 	addi	r2,r2,-28284
8113ceac:	18c7883a 	add	r3,r3,r3
8113ceb0:	18c7883a 	add	r3,r3,r3
8113ceb4:	10c5883a 	add	r2,r2,r3
8113ceb8:	10800017 	ldw	r2,0(r2)
8113cebc:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113cec0:	e0bff817 	ldw	r2,-32(fp)
8113cec4:	1000061e 	bne	r2,zero,8113cee0 <OSTaskResume+0x98>
8113cec8:	e0bff617 	ldw	r2,-40(fp)
8113cecc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ced0:	e0bff717 	ldw	r2,-36(fp)
8113ced4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113ced8:	00801184 	movi	r2,70
8113cedc:	00004c06 	br	8113d010 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113cee0:	e0bff817 	ldw	r2,-32(fp)
8113cee4:	10800058 	cmpnei	r2,r2,1
8113cee8:	1000061e 	bne	r2,zero,8113cf04 <OSTaskResume+0xbc>
8113ceec:	e0bff617 	ldw	r2,-40(fp)
8113cef0:	e0bff915 	stw	r2,-28(fp)
8113cef4:	e0bff917 	ldw	r2,-28(fp)
8113cef8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113cefc:	008010c4 	movi	r2,67
8113cf00:	00004306 	br	8113d010 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113cf04:	e0bff817 	ldw	r2,-32(fp)
8113cf08:	10800c03 	ldbu	r2,48(r2)
8113cf0c:	10803fcc 	andi	r2,r2,255
8113cf10:	1080020c 	andi	r2,r2,8
8113cf14:	10003926 	beq	r2,zero,8113cffc <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113cf18:	e0bff817 	ldw	r2,-32(fp)
8113cf1c:	10c00c03 	ldbu	r3,48(r2)
8113cf20:	00bffdc4 	movi	r2,-9
8113cf24:	1884703a 	and	r2,r3,r2
8113cf28:	1007883a 	mov	r3,r2
8113cf2c:	e0bff817 	ldw	r2,-32(fp)
8113cf30:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113cf34:	e0bff817 	ldw	r2,-32(fp)
8113cf38:	10800c03 	ldbu	r2,48(r2)
8113cf3c:	10803fcc 	andi	r2,r2,255
8113cf40:	1000281e 	bne	r2,zero,8113cfe4 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113cf44:	e0bff817 	ldw	r2,-32(fp)
8113cf48:	10800b8b 	ldhu	r2,46(r2)
8113cf4c:	10bfffcc 	andi	r2,r2,65535
8113cf50:	10001f1e 	bne	r2,zero,8113cfd0 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113cf54:	e0bff817 	ldw	r2,-32(fp)
8113cf58:	10c00d83 	ldbu	r3,54(r2)
8113cf5c:	d0a09d03 	ldbu	r2,-32140(gp)
8113cf60:	1884b03a 	or	r2,r3,r2
8113cf64:	d0a09d05 	stb	r2,-32140(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113cf68:	e0bff817 	ldw	r2,-32(fp)
8113cf6c:	10800d03 	ldbu	r2,52(r2)
8113cf70:	10c03fcc 	andi	r3,r2,255
8113cf74:	e0bff817 	ldw	r2,-32(fp)
8113cf78:	10800d03 	ldbu	r2,52(r2)
8113cf7c:	11003fcc 	andi	r4,r2,255
8113cf80:	d0a09d44 	addi	r2,gp,-32139
8113cf84:	2085883a 	add	r2,r4,r2
8113cf88:	11000003 	ldbu	r4,0(r2)
8113cf8c:	e0bff817 	ldw	r2,-32(fp)
8113cf90:	10800d43 	ldbu	r2,53(r2)
8113cf94:	2084b03a 	or	r2,r4,r2
8113cf98:	1009883a 	mov	r4,r2
8113cf9c:	d0a09d44 	addi	r2,gp,-32139
8113cfa0:	1885883a 	add	r2,r3,r2
8113cfa4:	11000005 	stb	r4,0(r2)
8113cfa8:	e0bff617 	ldw	r2,-40(fp)
8113cfac:	e0bffa15 	stw	r2,-24(fp)
8113cfb0:	e0bffa17 	ldw	r2,-24(fp)
8113cfb4:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113cfb8:	d0a09003 	ldbu	r2,-32192(gp)
8113cfbc:	10803fcc 	andi	r2,r2,255
8113cfc0:	10800058 	cmpnei	r2,r2,1
8113cfc4:	10000b1e 	bne	r2,zero,8113cff4 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113cfc8:	11368400 	call	81136840 <OS_Sched>
8113cfcc:	00000906 	br	8113cff4 <OSTaskResume+0x1ac>
8113cfd0:	e0bff617 	ldw	r2,-40(fp)
8113cfd4:	e0bffb15 	stw	r2,-20(fp)
8113cfd8:	e0bffb17 	ldw	r2,-20(fp)
8113cfdc:	1001703a 	wrctl	status,r2
8113cfe0:	00000406 	br	8113cff4 <OSTaskResume+0x1ac>
8113cfe4:	e0bff617 	ldw	r2,-40(fp)
8113cfe8:	e0bffc15 	stw	r2,-16(fp)
8113cfec:	e0bffc17 	ldw	r2,-16(fp)
8113cff0:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113cff4:	0005883a 	mov	r2,zero
8113cff8:	00000506 	br	8113d010 <OSTaskResume+0x1c8>
8113cffc:	e0bff617 	ldw	r2,-40(fp)
8113d000:	e0bffd15 	stw	r2,-12(fp)
8113d004:	e0bffd17 	ldw	r2,-12(fp)
8113d008:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113d00c:	00801104 	movi	r2,68
}
8113d010:	e037883a 	mov	sp,fp
8113d014:	dfc00117 	ldw	ra,4(sp)
8113d018:	df000017 	ldw	fp,0(sp)
8113d01c:	dec00204 	addi	sp,sp,8
8113d020:	f800283a 	ret

8113d024 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113d024:	defff304 	addi	sp,sp,-52
8113d028:	de00012e 	bgeu	sp,et,8113d030 <OSTaskStkChk+0xc>
8113d02c:	003b68fa 	trap	3
8113d030:	df000c15 	stw	fp,48(sp)
8113d034:	df000c04 	addi	fp,sp,48
8113d038:	2005883a 	mov	r2,r4
8113d03c:	e17fff15 	stw	r5,-4(fp)
8113d040:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113d044:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113d048:	e0bffe03 	ldbu	r2,-8(fp)
8113d04c:	10800af0 	cmpltui	r2,r2,43
8113d050:	1000051e 	bne	r2,zero,8113d068 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113d054:	e0bffe03 	ldbu	r2,-8(fp)
8113d058:	10803fe0 	cmpeqi	r2,r2,255
8113d05c:	1000021e 	bne	r2,zero,8113d068 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113d060:	00800a84 	movi	r2,42
8113d064:	00005d06 	br	8113d1dc <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113d068:	e0bfff17 	ldw	r2,-4(fp)
8113d06c:	1000021e 	bne	r2,zero,8113d078 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113d070:	00800244 	movi	r2,9
8113d074:	00005906 	br	8113d1dc <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113d078:	e0bfff17 	ldw	r2,-4(fp)
8113d07c:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113d080:	e0bfff17 	ldw	r2,-4(fp)
8113d084:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d088:	0005303a 	rdctl	r2,status
8113d08c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d090:	e0fffd17 	ldw	r3,-12(fp)
8113d094:	00bfff84 	movi	r2,-2
8113d098:	1884703a 	and	r2,r3,r2
8113d09c:	1001703a 	wrctl	status,r2
  
  return context;
8113d0a0:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113d0a4:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113d0a8:	e0bffe03 	ldbu	r2,-8(fp)
8113d0ac:	10803fd8 	cmpnei	r2,r2,255
8113d0b0:	1000031e 	bne	r2,zero,8113d0c0 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113d0b4:	d0a0a117 	ldw	r2,-32124(gp)
8113d0b8:	10800c83 	ldbu	r2,50(r2)
8113d0bc:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113d0c0:	e0fffe03 	ldbu	r3,-8(fp)
8113d0c4:	00a045f4 	movhi	r2,33047
8113d0c8:	10a46104 	addi	r2,r2,-28284
8113d0cc:	18c7883a 	add	r3,r3,r3
8113d0d0:	18c7883a 	add	r3,r3,r3
8113d0d4:	10c5883a 	add	r2,r2,r3
8113d0d8:	10800017 	ldw	r2,0(r2)
8113d0dc:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113d0e0:	e0bff817 	ldw	r2,-32(fp)
8113d0e4:	1000061e 	bne	r2,zero,8113d100 <OSTaskStkChk+0xdc>
8113d0e8:	e0bff617 	ldw	r2,-40(fp)
8113d0ec:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d0f0:	e0bff717 	ldw	r2,-36(fp)
8113d0f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113d0f8:	008010c4 	movi	r2,67
8113d0fc:	00003706 	br	8113d1dc <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113d100:	e0bff817 	ldw	r2,-32(fp)
8113d104:	10800058 	cmpnei	r2,r2,1
8113d108:	1000061e 	bne	r2,zero,8113d124 <OSTaskStkChk+0x100>
8113d10c:	e0bff617 	ldw	r2,-40(fp)
8113d110:	e0bff915 	stw	r2,-28(fp)
8113d114:	e0bff917 	ldw	r2,-28(fp)
8113d118:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113d11c:	008010c4 	movi	r2,67
8113d120:	00002e06 	br	8113d1dc <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113d124:	e0bff817 	ldw	r2,-32(fp)
8113d128:	1080040b 	ldhu	r2,16(r2)
8113d12c:	10bfffcc 	andi	r2,r2,65535
8113d130:	1080004c 	andi	r2,r2,1
8113d134:	1000061e 	bne	r2,zero,8113d150 <OSTaskStkChk+0x12c>
8113d138:	e0bff617 	ldw	r2,-40(fp)
8113d13c:	e0bffa15 	stw	r2,-24(fp)
8113d140:	e0bffa17 	ldw	r2,-24(fp)
8113d144:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113d148:	00801144 	movi	r2,69
8113d14c:	00002306 	br	8113d1dc <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113d150:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113d154:	e0bff817 	ldw	r2,-32(fp)
8113d158:	10800317 	ldw	r2,12(r2)
8113d15c:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113d160:	e0bff817 	ldw	r2,-32(fp)
8113d164:	10800217 	ldw	r2,8(r2)
8113d168:	e0bff415 	stw	r2,-48(fp)
8113d16c:	e0bff617 	ldw	r2,-40(fp)
8113d170:	e0bffb15 	stw	r2,-20(fp)
8113d174:	e0bffb17 	ldw	r2,-20(fp)
8113d178:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113d17c:	00000306 	br	8113d18c <OSTaskStkChk+0x168>
        nfree++;
8113d180:	e0bff517 	ldw	r2,-44(fp)
8113d184:	10800044 	addi	r2,r2,1
8113d188:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113d18c:	e0bff417 	ldw	r2,-48(fp)
8113d190:	10c00104 	addi	r3,r2,4
8113d194:	e0fff415 	stw	r3,-48(fp)
8113d198:	10800017 	ldw	r2,0(r2)
8113d19c:	103ff826 	beq	r2,zero,8113d180 <__reset+0xfb11d180>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113d1a0:	e0bff517 	ldw	r2,-44(fp)
8113d1a4:	1085883a 	add	r2,r2,r2
8113d1a8:	1085883a 	add	r2,r2,r2
8113d1ac:	1007883a 	mov	r3,r2
8113d1b0:	e0bfff17 	ldw	r2,-4(fp)
8113d1b4:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113d1b8:	e0fffc17 	ldw	r3,-16(fp)
8113d1bc:	e0bff517 	ldw	r2,-44(fp)
8113d1c0:	1885c83a 	sub	r2,r3,r2
8113d1c4:	1085883a 	add	r2,r2,r2
8113d1c8:	1085883a 	add	r2,r2,r2
8113d1cc:	1007883a 	mov	r3,r2
8113d1d0:	e0bfff17 	ldw	r2,-4(fp)
8113d1d4:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113d1d8:	0005883a 	mov	r2,zero
}
8113d1dc:	e037883a 	mov	sp,fp
8113d1e0:	df000017 	ldw	fp,0(sp)
8113d1e4:	dec00104 	addi	sp,sp,4
8113d1e8:	f800283a 	ret

8113d1ec <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113d1ec:	defff504 	addi	sp,sp,-44
8113d1f0:	de00012e 	bgeu	sp,et,8113d1f8 <OSTaskSuspend+0xc>
8113d1f4:	003b68fa 	trap	3
8113d1f8:	dfc00a15 	stw	ra,40(sp)
8113d1fc:	df000915 	stw	fp,36(sp)
8113d200:	df000904 	addi	fp,sp,36
8113d204:	2005883a 	mov	r2,r4
8113d208:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d20c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113d210:	e0bfff03 	ldbu	r2,-4(fp)
8113d214:	10800a98 	cmpnei	r2,r2,42
8113d218:	1000021e 	bne	r2,zero,8113d224 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113d21c:	008011c4 	movi	r2,71
8113d220:	00006806 	br	8113d3c4 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113d224:	e0bfff03 	ldbu	r2,-4(fp)
8113d228:	10800ab0 	cmpltui	r2,r2,42
8113d22c:	1000051e 	bne	r2,zero,8113d244 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8113d230:	e0bfff03 	ldbu	r2,-4(fp)
8113d234:	10803fe0 	cmpeqi	r2,r2,255
8113d238:	1000021e 	bne	r2,zero,8113d244 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8113d23c:	00800a84 	movi	r2,42
8113d240:	00006006 	br	8113d3c4 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d244:	0005303a 	rdctl	r2,status
8113d248:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d24c:	e0fffe17 	ldw	r3,-8(fp)
8113d250:	00bfff84 	movi	r2,-2
8113d254:	1884703a 	and	r2,r3,r2
8113d258:	1001703a 	wrctl	status,r2
  
  return context;
8113d25c:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113d260:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8113d264:	e0bfff03 	ldbu	r2,-4(fp)
8113d268:	10803fd8 	cmpnei	r2,r2,255
8113d26c:	1000061e 	bne	r2,zero,8113d288 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113d270:	d0a0a117 	ldw	r2,-32124(gp)
8113d274:	10800c83 	ldbu	r2,50(r2)
8113d278:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8113d27c:	00800044 	movi	r2,1
8113d280:	e0bff705 	stb	r2,-36(fp)
8113d284:	00000906 	br	8113d2ac <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8113d288:	d0a0a117 	ldw	r2,-32124(gp)
8113d28c:	10800c83 	ldbu	r2,50(r2)
8113d290:	10c03fcc 	andi	r3,r2,255
8113d294:	e0bfff03 	ldbu	r2,-4(fp)
8113d298:	1880031e 	bne	r3,r2,8113d2a8 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8113d29c:	00800044 	movi	r2,1
8113d2a0:	e0bff705 	stb	r2,-36(fp)
8113d2a4:	00000106 	br	8113d2ac <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8113d2a8:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113d2ac:	e0ffff03 	ldbu	r3,-4(fp)
8113d2b0:	00a045f4 	movhi	r2,33047
8113d2b4:	10a46104 	addi	r2,r2,-28284
8113d2b8:	18c7883a 	add	r3,r3,r3
8113d2bc:	18c7883a 	add	r3,r3,r3
8113d2c0:	10c5883a 	add	r2,r2,r3
8113d2c4:	10800017 	ldw	r2,0(r2)
8113d2c8:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8113d2cc:	e0bffa17 	ldw	r2,-24(fp)
8113d2d0:	1000061e 	bne	r2,zero,8113d2ec <OSTaskSuspend+0x100>
8113d2d4:	e0bff817 	ldw	r2,-32(fp)
8113d2d8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d2dc:	e0bff917 	ldw	r2,-28(fp)
8113d2e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113d2e4:	00801204 	movi	r2,72
8113d2e8:	00003606 	br	8113d3c4 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8113d2ec:	e0bffa17 	ldw	r2,-24(fp)
8113d2f0:	10800058 	cmpnei	r2,r2,1
8113d2f4:	1000061e 	bne	r2,zero,8113d310 <OSTaskSuspend+0x124>
8113d2f8:	e0bff817 	ldw	r2,-32(fp)
8113d2fc:	e0bffb15 	stw	r2,-20(fp)
8113d300:	e0bffb17 	ldw	r2,-20(fp)
8113d304:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113d308:	008010c4 	movi	r2,67
8113d30c:	00002d06 	br	8113d3c4 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8113d310:	e0bffa17 	ldw	r2,-24(fp)
8113d314:	10800d03 	ldbu	r2,52(r2)
8113d318:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8113d31c:	e0fffd03 	ldbu	r3,-12(fp)
8113d320:	e13ffd03 	ldbu	r4,-12(fp)
8113d324:	d0a09d44 	addi	r2,gp,-32139
8113d328:	2085883a 	add	r2,r4,r2
8113d32c:	10800003 	ldbu	r2,0(r2)
8113d330:	1009883a 	mov	r4,r2
8113d334:	e0bffa17 	ldw	r2,-24(fp)
8113d338:	10800d43 	ldbu	r2,53(r2)
8113d33c:	0084303a 	nor	r2,zero,r2
8113d340:	2084703a 	and	r2,r4,r2
8113d344:	1009883a 	mov	r4,r2
8113d348:	d0a09d44 	addi	r2,gp,-32139
8113d34c:	1885883a 	add	r2,r3,r2
8113d350:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113d354:	e0fffd03 	ldbu	r3,-12(fp)
8113d358:	d0a09d44 	addi	r2,gp,-32139
8113d35c:	1885883a 	add	r2,r3,r2
8113d360:	10800003 	ldbu	r2,0(r2)
8113d364:	10803fcc 	andi	r2,r2,255
8113d368:	1000071e 	bne	r2,zero,8113d388 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113d36c:	e0bffa17 	ldw	r2,-24(fp)
8113d370:	10800d83 	ldbu	r2,54(r2)
8113d374:	0084303a 	nor	r2,zero,r2
8113d378:	1007883a 	mov	r3,r2
8113d37c:	d0a09d03 	ldbu	r2,-32140(gp)
8113d380:	1884703a 	and	r2,r3,r2
8113d384:	d0a09d05 	stb	r2,-32140(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8113d388:	e0bffa17 	ldw	r2,-24(fp)
8113d38c:	10800c03 	ldbu	r2,48(r2)
8113d390:	10800214 	ori	r2,r2,8
8113d394:	1007883a 	mov	r3,r2
8113d398:	e0bffa17 	ldw	r2,-24(fp)
8113d39c:	10c00c05 	stb	r3,48(r2)
8113d3a0:	e0bff817 	ldw	r2,-32(fp)
8113d3a4:	e0bffc15 	stw	r2,-16(fp)
8113d3a8:	e0bffc17 	ldw	r2,-16(fp)
8113d3ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113d3b0:	e0bff703 	ldbu	r2,-36(fp)
8113d3b4:	10800058 	cmpnei	r2,r2,1
8113d3b8:	1000011e 	bne	r2,zero,8113d3c0 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8113d3bc:	11368400 	call	81136840 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113d3c0:	0005883a 	mov	r2,zero
}
8113d3c4:	e037883a 	mov	sp,fp
8113d3c8:	dfc00117 	ldw	ra,4(sp)
8113d3cc:	df000017 	ldw	fp,0(sp)
8113d3d0:	dec00204 	addi	sp,sp,8
8113d3d4:	f800283a 	ret

8113d3d8 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113d3d8:	defff604 	addi	sp,sp,-40
8113d3dc:	de00012e 	bgeu	sp,et,8113d3e4 <OSTaskQuery+0xc>
8113d3e0:	003b68fa 	trap	3
8113d3e4:	dfc00915 	stw	ra,36(sp)
8113d3e8:	df000815 	stw	fp,32(sp)
8113d3ec:	df000804 	addi	fp,sp,32
8113d3f0:	2005883a 	mov	r2,r4
8113d3f4:	e17fff15 	stw	r5,-4(fp)
8113d3f8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d3fc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8113d400:	e0bffe03 	ldbu	r2,-8(fp)
8113d404:	10800af0 	cmpltui	r2,r2,43
8113d408:	1000051e 	bne	r2,zero,8113d420 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8113d40c:	e0bffe03 	ldbu	r2,-8(fp)
8113d410:	10803fe0 	cmpeqi	r2,r2,255
8113d414:	1000021e 	bne	r2,zero,8113d420 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113d418:	00800a84 	movi	r2,42
8113d41c:	00003406 	br	8113d4f0 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8113d420:	e0bfff17 	ldw	r2,-4(fp)
8113d424:	1000021e 	bne	r2,zero,8113d430 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113d428:	00800244 	movi	r2,9
8113d42c:	00003006 	br	8113d4f0 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d430:	0005303a 	rdctl	r2,status
8113d434:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d438:	e0fffd17 	ldw	r3,-12(fp)
8113d43c:	00bfff84 	movi	r2,-2
8113d440:	1884703a 	and	r2,r3,r2
8113d444:	1001703a 	wrctl	status,r2
  
  return context;
8113d448:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d44c:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113d450:	e0bffe03 	ldbu	r2,-8(fp)
8113d454:	10803fd8 	cmpnei	r2,r2,255
8113d458:	1000031e 	bne	r2,zero,8113d468 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8113d45c:	d0a0a117 	ldw	r2,-32124(gp)
8113d460:	10800c83 	ldbu	r2,50(r2)
8113d464:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113d468:	e0fffe03 	ldbu	r3,-8(fp)
8113d46c:	00a045f4 	movhi	r2,33047
8113d470:	10a46104 	addi	r2,r2,-28284
8113d474:	18c7883a 	add	r3,r3,r3
8113d478:	18c7883a 	add	r3,r3,r3
8113d47c:	10c5883a 	add	r2,r2,r3
8113d480:	10800017 	ldw	r2,0(r2)
8113d484:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8113d488:	e0bffa17 	ldw	r2,-24(fp)
8113d48c:	1000061e 	bne	r2,zero,8113d4a8 <OSTaskQuery+0xd0>
8113d490:	e0bff817 	ldw	r2,-32(fp)
8113d494:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d498:	e0bff917 	ldw	r2,-28(fp)
8113d49c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113d4a0:	00800a44 	movi	r2,41
8113d4a4:	00001206 	br	8113d4f0 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8113d4a8:	e0bffa17 	ldw	r2,-24(fp)
8113d4ac:	10800058 	cmpnei	r2,r2,1
8113d4b0:	1000061e 	bne	r2,zero,8113d4cc <OSTaskQuery+0xf4>
8113d4b4:	e0bff817 	ldw	r2,-32(fp)
8113d4b8:	e0bffb15 	stw	r2,-20(fp)
8113d4bc:	e0bffb17 	ldw	r2,-20(fp)
8113d4c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113d4c4:	008010c4 	movi	r2,67
8113d4c8:	00000906 	br	8113d4f0 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8113d4cc:	01801b04 	movi	r6,108
8113d4d0:	e17ffa17 	ldw	r5,-24(fp)
8113d4d4:	e13fff17 	ldw	r4,-4(fp)
8113d4d8:	11367d00 	call	811367d0 <OS_MemCopy>
8113d4dc:	e0bff817 	ldw	r2,-32(fp)
8113d4e0:	e0bffc15 	stw	r2,-16(fp)
8113d4e4:	e0bffc17 	ldw	r2,-16(fp)
8113d4e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d4ec:	0005883a 	mov	r2,zero
}
8113d4f0:	e037883a 	mov	sp,fp
8113d4f4:	dfc00117 	ldw	ra,4(sp)
8113d4f8:	df000017 	ldw	fp,0(sp)
8113d4fc:	dec00204 	addi	sp,sp,8
8113d500:	f800283a 	ret

8113d504 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113d504:	defffc04 	addi	sp,sp,-16
8113d508:	de00012e 	bgeu	sp,et,8113d510 <OS_TaskStkClr+0xc>
8113d50c:	003b68fa 	trap	3
8113d510:	df000315 	stw	fp,12(sp)
8113d514:	df000304 	addi	fp,sp,12
8113d518:	e13ffd15 	stw	r4,-12(fp)
8113d51c:	e17ffe15 	stw	r5,-8(fp)
8113d520:	3005883a 	mov	r2,r6
8113d524:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113d528:	e0bfff0b 	ldhu	r2,-4(fp)
8113d52c:	1080004c 	andi	r2,r2,1
8113d530:	10000d26 	beq	r2,zero,8113d568 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8113d534:	e0bfff0b 	ldhu	r2,-4(fp)
8113d538:	1080008c 	andi	r2,r2,2
8113d53c:	10000a26 	beq	r2,zero,8113d568 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113d540:	00000706 	br	8113d560 <OS_TaskStkClr+0x5c>
                size--;
8113d544:	e0bffe17 	ldw	r2,-8(fp)
8113d548:	10bfffc4 	addi	r2,r2,-1
8113d54c:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113d550:	e0bffd17 	ldw	r2,-12(fp)
8113d554:	10c00104 	addi	r3,r2,4
8113d558:	e0fffd15 	stw	r3,-12(fp)
8113d55c:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113d560:	e0bffe17 	ldw	r2,-8(fp)
8113d564:	103ff71e 	bne	r2,zero,8113d544 <__reset+0xfb11d544>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8113d568:	0001883a 	nop
8113d56c:	e037883a 	mov	sp,fp
8113d570:	df000017 	ldw	fp,0(sp)
8113d574:	dec00104 	addi	sp,sp,4
8113d578:	f800283a 	ret

8113d57c <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8113d57c:	defff904 	addi	sp,sp,-28
8113d580:	de00012e 	bgeu	sp,et,8113d588 <OSTimeDly+0xc>
8113d584:	003b68fa 	trap	3
8113d588:	dfc00615 	stw	ra,24(sp)
8113d58c:	df000515 	stw	fp,20(sp)
8113d590:	df000504 	addi	fp,sp,20
8113d594:	2005883a 	mov	r2,r4
8113d598:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d59c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113d5a0:	d0a0a003 	ldbu	r2,-32128(gp)
8113d5a4:	10803fcc 	andi	r2,r2,255
8113d5a8:	1000311e 	bne	r2,zero,8113d670 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8113d5ac:	e0bfff0b 	ldhu	r2,-4(fp)
8113d5b0:	10003026 	beq	r2,zero,8113d674 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d5b4:	0005303a 	rdctl	r2,status
8113d5b8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d5bc:	e0fffe17 	ldw	r3,-8(fp)
8113d5c0:	00bfff84 	movi	r2,-2
8113d5c4:	1884703a 	and	r2,r3,r2
8113d5c8:	1001703a 	wrctl	status,r2
  
  return context;
8113d5cc:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113d5d0:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113d5d4:	d0a0a117 	ldw	r2,-32124(gp)
8113d5d8:	10800d03 	ldbu	r2,52(r2)
8113d5dc:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113d5e0:	e0fffd03 	ldbu	r3,-12(fp)
8113d5e4:	e13ffd03 	ldbu	r4,-12(fp)
8113d5e8:	d0a09d44 	addi	r2,gp,-32139
8113d5ec:	2085883a 	add	r2,r4,r2
8113d5f0:	10800003 	ldbu	r2,0(r2)
8113d5f4:	1009883a 	mov	r4,r2
8113d5f8:	d0a0a117 	ldw	r2,-32124(gp)
8113d5fc:	10800d43 	ldbu	r2,53(r2)
8113d600:	0084303a 	nor	r2,zero,r2
8113d604:	2084703a 	and	r2,r4,r2
8113d608:	1009883a 	mov	r4,r2
8113d60c:	d0a09d44 	addi	r2,gp,-32139
8113d610:	1885883a 	add	r2,r3,r2
8113d614:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8113d618:	e0fffd03 	ldbu	r3,-12(fp)
8113d61c:	d0a09d44 	addi	r2,gp,-32139
8113d620:	1885883a 	add	r2,r3,r2
8113d624:	10800003 	ldbu	r2,0(r2)
8113d628:	10803fcc 	andi	r2,r2,255
8113d62c:	1000071e 	bne	r2,zero,8113d64c <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113d630:	d0a0a117 	ldw	r2,-32124(gp)
8113d634:	10800d83 	ldbu	r2,54(r2)
8113d638:	0084303a 	nor	r2,zero,r2
8113d63c:	1007883a 	mov	r3,r2
8113d640:	d0a09d03 	ldbu	r2,-32140(gp)
8113d644:	1884703a 	and	r2,r3,r2
8113d648:	d0a09d05 	stb	r2,-32140(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8113d64c:	d0a0a117 	ldw	r2,-32124(gp)
8113d650:	e0ffff0b 	ldhu	r3,-4(fp)
8113d654:	10c00b8d 	sth	r3,46(r2)
8113d658:	e0bffb17 	ldw	r2,-20(fp)
8113d65c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d660:	e0bffc17 	ldw	r2,-16(fp)
8113d664:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8113d668:	11368400 	call	81136840 <OS_Sched>
8113d66c:	00000106 	br	8113d674 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113d670:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8113d674:	e037883a 	mov	sp,fp
8113d678:	dfc00117 	ldw	ra,4(sp)
8113d67c:	df000017 	ldw	fp,0(sp)
8113d680:	dec00204 	addi	sp,sp,8
8113d684:	f800283a 	ret

8113d688 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8113d688:	defff804 	addi	sp,sp,-32
8113d68c:	de00012e 	bgeu	sp,et,8113d694 <OSTimeDlyHMSM+0xc>
8113d690:	003b68fa 	trap	3
8113d694:	dfc00715 	stw	ra,28(sp)
8113d698:	df000615 	stw	fp,24(sp)
8113d69c:	df000604 	addi	fp,sp,24
8113d6a0:	2015883a 	mov	r10,r4
8113d6a4:	2809883a 	mov	r4,r5
8113d6a8:	3007883a 	mov	r3,r6
8113d6ac:	3805883a 	mov	r2,r7
8113d6b0:	e2bffc05 	stb	r10,-16(fp)
8113d6b4:	e13ffd05 	stb	r4,-12(fp)
8113d6b8:	e0fffe05 	stb	r3,-8(fp)
8113d6bc:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113d6c0:	d0a0a003 	ldbu	r2,-32128(gp)
8113d6c4:	10803fcc 	andi	r2,r2,255
8113d6c8:	10000226 	beq	r2,zero,8113d6d4 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8113d6cc:	00801544 	movi	r2,85
8113d6d0:	00004106 	br	8113d7d8 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113d6d4:	e0bffc03 	ldbu	r2,-16(fp)
8113d6d8:	1000081e 	bne	r2,zero,8113d6fc <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8113d6dc:	e0bffd03 	ldbu	r2,-12(fp)
8113d6e0:	1000061e 	bne	r2,zero,8113d6fc <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113d6e4:	e0bffe03 	ldbu	r2,-8(fp)
8113d6e8:	1000041e 	bne	r2,zero,8113d6fc <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8113d6ec:	e0bfff0b 	ldhu	r2,-4(fp)
8113d6f0:	1000021e 	bne	r2,zero,8113d6fc <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113d6f4:	00801504 	movi	r2,84
8113d6f8:	00003706 	br	8113d7d8 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8113d6fc:	e0bffd03 	ldbu	r2,-12(fp)
8113d700:	10800f30 	cmpltui	r2,r2,60
8113d704:	1000021e 	bne	r2,zero,8113d710 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8113d708:	00801444 	movi	r2,81
8113d70c:	00003206 	br	8113d7d8 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8113d710:	e0bffe03 	ldbu	r2,-8(fp)
8113d714:	10800f30 	cmpltui	r2,r2,60
8113d718:	1000021e 	bne	r2,zero,8113d724 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8113d71c:	00801484 	movi	r2,82
8113d720:	00002d06 	br	8113d7d8 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8113d724:	e0bfff0b 	ldhu	r2,-4(fp)
8113d728:	1080fa30 	cmpltui	r2,r2,1000
8113d72c:	1000021e 	bne	r2,zero,8113d738 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8113d730:	008014c4 	movi	r2,83
8113d734:	00002806 	br	8113d7d8 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113d738:	e0bffc03 	ldbu	r2,-16(fp)
8113d73c:	10c38424 	muli	r3,r2,3600
8113d740:	e0bffd03 	ldbu	r2,-12(fp)
8113d744:	10800f24 	muli	r2,r2,60
8113d748:	1887883a 	add	r3,r3,r2
8113d74c:	e0bffe03 	ldbu	r2,-8(fp)
8113d750:	1885883a 	add	r2,r3,r2
8113d754:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8113d758:	e0bfff0b 	ldhu	r2,-4(fp)
8113d75c:	10c0fa24 	muli	r3,r2,1000
8113d760:	008418b4 	movhi	r2,4194
8113d764:	109374c4 	addi	r2,r2,19923
8113d768:	188a383a 	mulxuu	r5,r3,r2
8113d76c:	1885383a 	mul	r2,r3,r2
8113d770:	1011883a 	mov	r8,r2
8113d774:	2813883a 	mov	r9,r5
8113d778:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113d77c:	2085883a 	add	r2,r4,r2
8113d780:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113d784:	e0bffb17 	ldw	r2,-20(fp)
8113d788:	1004d43a 	srli	r2,r2,16
8113d78c:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113d790:	e0bffb17 	ldw	r2,-20(fp)
8113d794:	10bfffcc 	andi	r2,r2,65535
8113d798:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8113d79c:	e0bffb17 	ldw	r2,-20(fp)
8113d7a0:	10bfffcc 	andi	r2,r2,65535
8113d7a4:	1009883a 	mov	r4,r2
8113d7a8:	113d57c0 	call	8113d57c <OSTimeDly>
    while (loops > 0) {
8113d7ac:	00000706 	br	8113d7cc <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113d7b0:	01200014 	movui	r4,32768
8113d7b4:	113d57c0 	call	8113d57c <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8113d7b8:	01200014 	movui	r4,32768
8113d7bc:	113d57c0 	call	8113d57c <OSTimeDly>
        loops--;
8113d7c0:	e0bffa0b 	ldhu	r2,-24(fp)
8113d7c4:	10bfffc4 	addi	r2,r2,-1
8113d7c8:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8113d7cc:	e0bffa0b 	ldhu	r2,-24(fp)
8113d7d0:	103ff71e 	bne	r2,zero,8113d7b0 <__reset+0xfb11d7b0>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113d7d4:	0005883a 	mov	r2,zero
}
8113d7d8:	e037883a 	mov	sp,fp
8113d7dc:	dfc00117 	ldw	ra,4(sp)
8113d7e0:	df000017 	ldw	fp,0(sp)
8113d7e4:	dec00204 	addi	sp,sp,8
8113d7e8:	f800283a 	ret

8113d7ec <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8113d7ec:	defff504 	addi	sp,sp,-44
8113d7f0:	de00012e 	bgeu	sp,et,8113d7f8 <OSTimeDlyResume+0xc>
8113d7f4:	003b68fa 	trap	3
8113d7f8:	dfc00a15 	stw	ra,40(sp)
8113d7fc:	df000915 	stw	fp,36(sp)
8113d800:	df000904 	addi	fp,sp,36
8113d804:	2005883a 	mov	r2,r4
8113d808:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d80c:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8113d810:	e0bfff03 	ldbu	r2,-4(fp)
8113d814:	10800ab0 	cmpltui	r2,r2,42
8113d818:	1000021e 	bne	r2,zero,8113d824 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113d81c:	00800a84 	movi	r2,42
8113d820:	00006406 	br	8113d9b4 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d824:	0005303a 	rdctl	r2,status
8113d828:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d82c:	e0fffe17 	ldw	r3,-8(fp)
8113d830:	00bfff84 	movi	r2,-2
8113d834:	1884703a 	and	r2,r3,r2
8113d838:	1001703a 	wrctl	status,r2
  
  return context;
8113d83c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113d840:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8113d844:	e0ffff03 	ldbu	r3,-4(fp)
8113d848:	00a045f4 	movhi	r2,33047
8113d84c:	10a46104 	addi	r2,r2,-28284
8113d850:	18c7883a 	add	r3,r3,r3
8113d854:	18c7883a 	add	r3,r3,r3
8113d858:	10c5883a 	add	r2,r2,r3
8113d85c:	10800017 	ldw	r2,0(r2)
8113d860:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8113d864:	e0bff917 	ldw	r2,-28(fp)
8113d868:	1000061e 	bne	r2,zero,8113d884 <OSTimeDlyResume+0x98>
8113d86c:	e0bff717 	ldw	r2,-36(fp)
8113d870:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d874:	e0bff817 	ldw	r2,-32(fp)
8113d878:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113d87c:	008010c4 	movi	r2,67
8113d880:	00004c06 	br	8113d9b4 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113d884:	e0bff917 	ldw	r2,-28(fp)
8113d888:	10800058 	cmpnei	r2,r2,1
8113d88c:	1000061e 	bne	r2,zero,8113d8a8 <OSTimeDlyResume+0xbc>
8113d890:	e0bff717 	ldw	r2,-36(fp)
8113d894:	e0bffa15 	stw	r2,-24(fp)
8113d898:	e0bffa17 	ldw	r2,-24(fp)
8113d89c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113d8a0:	008010c4 	movi	r2,67
8113d8a4:	00004306 	br	8113d9b4 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8113d8a8:	e0bff917 	ldw	r2,-28(fp)
8113d8ac:	10800b8b 	ldhu	r2,46(r2)
8113d8b0:	10bfffcc 	andi	r2,r2,65535
8113d8b4:	1000061e 	bne	r2,zero,8113d8d0 <OSTimeDlyResume+0xe4>
8113d8b8:	e0bff717 	ldw	r2,-36(fp)
8113d8bc:	e0bffb15 	stw	r2,-20(fp)
8113d8c0:	e0bffb17 	ldw	r2,-20(fp)
8113d8c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8113d8c8:	00801404 	movi	r2,80
8113d8cc:	00003906 	br	8113d9b4 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113d8d0:	e0bff917 	ldw	r2,-28(fp)
8113d8d4:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113d8d8:	e0bff917 	ldw	r2,-28(fp)
8113d8dc:	10800c03 	ldbu	r2,48(r2)
8113d8e0:	10803fcc 	andi	r2,r2,255
8113d8e4:	10800dcc 	andi	r2,r2,55
8113d8e8:	10000b26 	beq	r2,zero,8113d918 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8113d8ec:	e0bff917 	ldw	r2,-28(fp)
8113d8f0:	10c00c03 	ldbu	r3,48(r2)
8113d8f4:	00bff204 	movi	r2,-56
8113d8f8:	1884703a 	and	r2,r3,r2
8113d8fc:	1007883a 	mov	r3,r2
8113d900:	e0bff917 	ldw	r2,-28(fp)
8113d904:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8113d908:	e0bff917 	ldw	r2,-28(fp)
8113d90c:	00c00044 	movi	r3,1
8113d910:	10c00c45 	stb	r3,49(r2)
8113d914:	00000206 	br	8113d920 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8113d918:	e0bff917 	ldw	r2,-28(fp)
8113d91c:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8113d920:	e0bff917 	ldw	r2,-28(fp)
8113d924:	10800c03 	ldbu	r2,48(r2)
8113d928:	10803fcc 	andi	r2,r2,255
8113d92c:	1080020c 	andi	r2,r2,8
8113d930:	10001b1e 	bne	r2,zero,8113d9a0 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8113d934:	e0bff917 	ldw	r2,-28(fp)
8113d938:	10c00d83 	ldbu	r3,54(r2)
8113d93c:	d0a09d03 	ldbu	r2,-32140(gp)
8113d940:	1884b03a 	or	r2,r3,r2
8113d944:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113d948:	e0bff917 	ldw	r2,-28(fp)
8113d94c:	10800d03 	ldbu	r2,52(r2)
8113d950:	10c03fcc 	andi	r3,r2,255
8113d954:	e0bff917 	ldw	r2,-28(fp)
8113d958:	10800d03 	ldbu	r2,52(r2)
8113d95c:	11003fcc 	andi	r4,r2,255
8113d960:	d0a09d44 	addi	r2,gp,-32139
8113d964:	2085883a 	add	r2,r4,r2
8113d968:	11000003 	ldbu	r4,0(r2)
8113d96c:	e0bff917 	ldw	r2,-28(fp)
8113d970:	10800d43 	ldbu	r2,53(r2)
8113d974:	2084b03a 	or	r2,r4,r2
8113d978:	1009883a 	mov	r4,r2
8113d97c:	d0a09d44 	addi	r2,gp,-32139
8113d980:	1885883a 	add	r2,r3,r2
8113d984:	11000005 	stb	r4,0(r2)
8113d988:	e0bff717 	ldw	r2,-36(fp)
8113d98c:	e0bffc15 	stw	r2,-16(fp)
8113d990:	e0bffc17 	ldw	r2,-16(fp)
8113d994:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8113d998:	11368400 	call	81136840 <OS_Sched>
8113d99c:	00000406 	br	8113d9b0 <OSTimeDlyResume+0x1c4>
8113d9a0:	e0bff717 	ldw	r2,-36(fp)
8113d9a4:	e0bffd15 	stw	r2,-12(fp)
8113d9a8:	e0bffd17 	ldw	r2,-12(fp)
8113d9ac:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113d9b0:	0005883a 	mov	r2,zero
}
8113d9b4:	e037883a 	mov	sp,fp
8113d9b8:	dfc00117 	ldw	ra,4(sp)
8113d9bc:	df000017 	ldw	fp,0(sp)
8113d9c0:	dec00204 	addi	sp,sp,8
8113d9c4:	f800283a 	ret

8113d9c8 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8113d9c8:	defffb04 	addi	sp,sp,-20
8113d9cc:	de00012e 	bgeu	sp,et,8113d9d4 <OSTimeGet+0xc>
8113d9d0:	003b68fa 	trap	3
8113d9d4:	df000415 	stw	fp,16(sp)
8113d9d8:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d9dc:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d9e0:	0005303a 	rdctl	r2,status
8113d9e4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d9e8:	e0fffe17 	ldw	r3,-8(fp)
8113d9ec:	00bfff84 	movi	r2,-2
8113d9f0:	1884703a 	and	r2,r3,r2
8113d9f4:	1001703a 	wrctl	status,r2
  
  return context;
8113d9f8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113d9fc:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8113da00:	d0a0a317 	ldw	r2,-32116(gp)
8113da04:	e0bffd15 	stw	r2,-12(fp)
8113da08:	e0bffc17 	ldw	r2,-16(fp)
8113da0c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113da10:	e0bfff17 	ldw	r2,-4(fp)
8113da14:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8113da18:	e0bffd17 	ldw	r2,-12(fp)
}
8113da1c:	e037883a 	mov	sp,fp
8113da20:	df000017 	ldw	fp,0(sp)
8113da24:	dec00104 	addi	sp,sp,4
8113da28:	f800283a 	ret

8113da2c <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
8113da2c:	defffb04 	addi	sp,sp,-20
8113da30:	de00012e 	bgeu	sp,et,8113da38 <OSTimeSet+0xc>
8113da34:	003b68fa 	trap	3
8113da38:	df000415 	stw	fp,16(sp)
8113da3c:	df000404 	addi	fp,sp,16
8113da40:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113da44:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113da48:	0005303a 	rdctl	r2,status
8113da4c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113da50:	e0fffd17 	ldw	r3,-12(fp)
8113da54:	00bfff84 	movi	r2,-2
8113da58:	1884703a 	and	r2,r3,r2
8113da5c:	1001703a 	wrctl	status,r2
  
  return context;
8113da60:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
8113da64:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8113da68:	e0bfff17 	ldw	r2,-4(fp)
8113da6c:	d0a0a315 	stw	r2,-32116(gp)
8113da70:	e0bffc17 	ldw	r2,-16(fp)
8113da74:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113da78:	e0bffe17 	ldw	r2,-8(fp)
8113da7c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113da80:	0001883a 	nop
8113da84:	e037883a 	mov	sp,fp
8113da88:	df000017 	ldw	fp,0(sp)
8113da8c:	dec00104 	addi	sp,sp,4
8113da90:	f800283a 	ret

8113da94 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8113da94:	defff804 	addi	sp,sp,-32
8113da98:	de00012e 	bgeu	sp,et,8113daa0 <OSTmrCreate+0xc>
8113da9c:	003b68fa 	trap	3
8113daa0:	dfc00715 	stw	ra,28(sp)
8113daa4:	df000615 	stw	fp,24(sp)
8113daa8:	df000604 	addi	fp,sp,24
8113daac:	e13ffc15 	stw	r4,-16(fp)
8113dab0:	e17ffd15 	stw	r5,-12(fp)
8113dab4:	3005883a 	mov	r2,r6
8113dab8:	e1ffff15 	stw	r7,-4(fp)
8113dabc:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113dac0:	e0800417 	ldw	r2,16(fp)
8113dac4:	1000021e 	bne	r2,zero,8113dad0 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8113dac8:	0005883a 	mov	r2,zero
8113dacc:	00005d06 	br	8113dc44 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8113dad0:	e0bffe03 	ldbu	r2,-8(fp)
8113dad4:	10c00060 	cmpeqi	r3,r2,1
8113dad8:	1800091e 	bne	r3,zero,8113db00 <OSTmrCreate+0x6c>
8113dadc:	108000a0 	cmpeqi	r2,r2,2
8113dae0:	10000e26 	beq	r2,zero,8113db1c <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8113dae4:	e0bffd17 	ldw	r2,-12(fp)
8113dae8:	1000111e 	bne	r2,zero,8113db30 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
8113daec:	e0800417 	ldw	r2,16(fp)
8113daf0:	00ffe0c4 	movi	r3,-125
8113daf4:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113daf8:	0005883a 	mov	r2,zero
8113dafc:	00005106 	br	8113dc44 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
8113db00:	e0bffc17 	ldw	r2,-16(fp)
8113db04:	10000c1e 	bne	r2,zero,8113db38 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8113db08:	e0800417 	ldw	r2,16(fp)
8113db0c:	00ffe084 	movi	r3,-126
8113db10:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113db14:	0005883a 	mov	r2,zero
8113db18:	00004a06 	br	8113dc44 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
8113db1c:	e0800417 	ldw	r2,16(fp)
8113db20:	00ffe104 	movi	r3,-124
8113db24:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8113db28:	0005883a 	mov	r2,zero
8113db2c:	00004506 	br	8113dc44 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8113db30:	0001883a 	nop
8113db34:	00000106 	br	8113db3c <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8113db38:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113db3c:	d0a0a003 	ldbu	r2,-32128(gp)
8113db40:	10803fcc 	andi	r2,r2,255
8113db44:	10000526 	beq	r2,zero,8113db5c <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8113db48:	e0800417 	ldw	r2,16(fp)
8113db4c:	00ffe2c4 	movi	r3,-117
8113db50:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113db54:	0005883a 	mov	r2,zero
8113db58:	00003a06 	br	8113dc44 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8113db5c:	113ea4c0 	call	8113ea4c <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8113db60:	113e4ec0 	call	8113e4ec <OSTmr_Alloc>
8113db64:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8113db68:	e0bffa17 	ldw	r2,-24(fp)
8113db6c:	1000061e 	bne	r2,zero,8113db88 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8113db70:	113ea900 	call	8113ea90 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
8113db74:	e0800417 	ldw	r2,16(fp)
8113db78:	00ffe184 	movi	r3,-122
8113db7c:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113db80:	0005883a 	mov	r2,zero
8113db84:	00002f06 	br	8113dc44 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8113db88:	e0bffa17 	ldw	r2,-24(fp)
8113db8c:	00c00044 	movi	r3,1
8113db90:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
8113db94:	e0bffa17 	ldw	r2,-24(fp)
8113db98:	e0fffc17 	ldw	r3,-16(fp)
8113db9c:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8113dba0:	e0bffa17 	ldw	r2,-24(fp)
8113dba4:	e0fffd17 	ldw	r3,-12(fp)
8113dba8:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8113dbac:	e0bffa17 	ldw	r2,-24(fp)
8113dbb0:	e0fffe03 	ldbu	r3,-8(fp)
8113dbb4:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8113dbb8:	e0bffa17 	ldw	r2,-24(fp)
8113dbbc:	e0ffff17 	ldw	r3,-4(fp)
8113dbc0:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
8113dbc4:	e0bffa17 	ldw	r2,-24(fp)
8113dbc8:	e0c00217 	ldw	r3,8(fp)
8113dbcc:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
8113dbd0:	e0800317 	ldw	r2,12(fp)
8113dbd4:	10001726 	beq	r2,zero,8113dc34 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8113dbd8:	e1000317 	ldw	r4,12(fp)
8113dbdc:	1136a100 	call	81136a10 <OS_StrLen>
8113dbe0:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8113dbe4:	e0bffb03 	ldbu	r2,-20(fp)
8113dbe8:	10800428 	cmpgeui	r2,r2,16
8113dbec:	1000061e 	bne	r2,zero,8113dc08 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8113dbf0:	e0bffa17 	ldw	r2,-24(fp)
8113dbf4:	10800804 	addi	r2,r2,32
8113dbf8:	e1400317 	ldw	r5,12(fp)
8113dbfc:	1009883a 	mov	r4,r2
8113dc00:	11369940 	call	81136994 <OS_StrCopy>
8113dc04:	00000b06 	br	8113dc34 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8113dc08:	e0bffa17 	ldw	r2,-24(fp)
8113dc0c:	00c008c4 	movi	r3,35
8113dc10:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8113dc14:	e0bffa17 	ldw	r2,-24(fp)
8113dc18:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
8113dc1c:	e0800417 	ldw	r2,16(fp)
8113dc20:	00ffe304 	movi	r3,-116
8113dc24:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8113dc28:	113ea900 	call	8113ea90 <OSTmr_Unlock>
            return (ptmr);
8113dc2c:	e0bffa17 	ldw	r2,-24(fp)
8113dc30:	00000406 	br	8113dc44 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8113dc34:	113ea900 	call	8113ea90 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8113dc38:	e0800417 	ldw	r2,16(fp)
8113dc3c:	10000005 	stb	zero,0(r2)
    return (ptmr);
8113dc40:	e0bffa17 	ldw	r2,-24(fp)
}
8113dc44:	e037883a 	mov	sp,fp
8113dc48:	dfc00117 	ldw	ra,4(sp)
8113dc4c:	df000017 	ldw	fp,0(sp)
8113dc50:	dec00204 	addi	sp,sp,8
8113dc54:	f800283a 	ret

8113dc58 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8113dc58:	defffc04 	addi	sp,sp,-16
8113dc5c:	de00012e 	bgeu	sp,et,8113dc64 <OSTmrDel+0xc>
8113dc60:	003b68fa 	trap	3
8113dc64:	dfc00315 	stw	ra,12(sp)
8113dc68:	df000215 	stw	fp,8(sp)
8113dc6c:	df000204 	addi	fp,sp,8
8113dc70:	e13ffe15 	stw	r4,-8(fp)
8113dc74:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113dc78:	e0bfff17 	ldw	r2,-4(fp)
8113dc7c:	1000021e 	bne	r2,zero,8113dc88 <OSTmrDel+0x30>
        return (OS_FALSE);
8113dc80:	0005883a 	mov	r2,zero
8113dc84:	00003f06 	br	8113dd84 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113dc88:	e0bffe17 	ldw	r2,-8(fp)
8113dc8c:	1000051e 	bne	r2,zero,8113dca4 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113dc90:	e0bfff17 	ldw	r2,-4(fp)
8113dc94:	00ffe284 	movi	r3,-118
8113dc98:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113dc9c:	0005883a 	mov	r2,zero
8113dca0:	00003806 	br	8113dd84 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113dca4:	e0bffe17 	ldw	r2,-8(fp)
8113dca8:	10800003 	ldbu	r2,0(r2)
8113dcac:	10803fcc 	andi	r2,r2,255
8113dcb0:	10801920 	cmpeqi	r2,r2,100
8113dcb4:	1000051e 	bne	r2,zero,8113dccc <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113dcb8:	e0bfff17 	ldw	r2,-4(fp)
8113dcbc:	00ffe244 	movi	r3,-119
8113dcc0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113dcc4:	0005883a 	mov	r2,zero
8113dcc8:	00002e06 	br	8113dd84 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113dccc:	d0a0a003 	ldbu	r2,-32128(gp)
8113dcd0:	10803fcc 	andi	r2,r2,255
8113dcd4:	10000526 	beq	r2,zero,8113dcec <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113dcd8:	e0bfff17 	ldw	r2,-4(fp)
8113dcdc:	00ffe2c4 	movi	r3,-117
8113dce0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113dce4:	0005883a 	mov	r2,zero
8113dce8:	00002606 	br	8113dd84 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
8113dcec:	113ea4c0 	call	8113ea4c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113dcf0:	e0bffe17 	ldw	r2,-8(fp)
8113dcf4:	10800c43 	ldbu	r2,49(r2)
8113dcf8:	10803fcc 	andi	r2,r2,255
8113dcfc:	10c000c8 	cmpgei	r3,r2,3
8113dd00:	1800031e 	bne	r3,zero,8113dd10 <OSTmrDel+0xb8>
8113dd04:	00800d16 	blt	zero,r2,8113dd3c <OSTmrDel+0xe4>
8113dd08:	10001326 	beq	r2,zero,8113dd58 <OSTmrDel+0x100>
8113dd0c:	00001806 	br	8113dd70 <OSTmrDel+0x118>
8113dd10:	108000e0 	cmpeqi	r2,r2,3
8113dd14:	10001626 	beq	r2,zero,8113dd70 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8113dd18:	e13ffe17 	ldw	r4,-8(fp)
8113dd1c:	113e9500 	call	8113e950 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113dd20:	e13ffe17 	ldw	r4,-8(fp)
8113dd24:	113e5600 	call	8113e560 <OSTmr_Free>
             OSTmr_Unlock();
8113dd28:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113dd2c:	e0bfff17 	ldw	r2,-4(fp)
8113dd30:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113dd34:	00800044 	movi	r2,1
8113dd38:	00001206 	br	8113dd84 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113dd3c:	e13ffe17 	ldw	r4,-8(fp)
8113dd40:	113e5600 	call	8113e560 <OSTmr_Free>
             OSTmr_Unlock();
8113dd44:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113dd48:	e0bfff17 	ldw	r2,-4(fp)
8113dd4c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113dd50:	00800044 	movi	r2,1
8113dd54:	00000b06 	br	8113dd84 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8113dd58:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113dd5c:	e0bfff17 	ldw	r2,-4(fp)
8113dd60:	00ffe1c4 	movi	r3,-121
8113dd64:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113dd68:	0005883a 	mov	r2,zero
8113dd6c:	00000506 	br	8113dd84 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8113dd70:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113dd74:	e0bfff17 	ldw	r2,-4(fp)
8113dd78:	00ffe344 	movi	r3,-115
8113dd7c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113dd80:	0005883a 	mov	r2,zero
    }
}
8113dd84:	e037883a 	mov	sp,fp
8113dd88:	dfc00117 	ldw	ra,4(sp)
8113dd8c:	df000017 	ldw	fp,0(sp)
8113dd90:	dec00204 	addi	sp,sp,8
8113dd94:	f800283a 	ret

8113dd98 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8113dd98:	defffa04 	addi	sp,sp,-24
8113dd9c:	de00012e 	bgeu	sp,et,8113dda4 <OSTmrNameGet+0xc>
8113dda0:	003b68fa 	trap	3
8113dda4:	dfc00515 	stw	ra,20(sp)
8113dda8:	df000415 	stw	fp,16(sp)
8113ddac:	df000404 	addi	fp,sp,16
8113ddb0:	e13ffd15 	stw	r4,-12(fp)
8113ddb4:	e17ffe15 	stw	r5,-8(fp)
8113ddb8:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113ddbc:	e0bfff17 	ldw	r2,-4(fp)
8113ddc0:	1000021e 	bne	r2,zero,8113ddcc <OSTmrNameGet+0x34>
        return (0);
8113ddc4:	0005883a 	mov	r2,zero
8113ddc8:	00003e06 	br	8113dec4 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
8113ddcc:	e0bffe17 	ldw	r2,-8(fp)
8113ddd0:	1000051e 	bne	r2,zero,8113dde8 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8113ddd4:	e0bfff17 	ldw	r2,-4(fp)
8113ddd8:	00ffe204 	movi	r3,-120
8113dddc:	10c00005 	stb	r3,0(r2)
        return (0);
8113dde0:	0005883a 	mov	r2,zero
8113dde4:	00003706 	br	8113dec4 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113dde8:	e0bffd17 	ldw	r2,-12(fp)
8113ddec:	1000051e 	bne	r2,zero,8113de04 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8113ddf0:	e0bfff17 	ldw	r2,-4(fp)
8113ddf4:	00ffe284 	movi	r3,-118
8113ddf8:	10c00005 	stb	r3,0(r2)
        return (0);
8113ddfc:	0005883a 	mov	r2,zero
8113de00:	00003006 	br	8113dec4 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113de04:	e0bffd17 	ldw	r2,-12(fp)
8113de08:	10800003 	ldbu	r2,0(r2)
8113de0c:	10803fcc 	andi	r2,r2,255
8113de10:	10801920 	cmpeqi	r2,r2,100
8113de14:	1000051e 	bne	r2,zero,8113de2c <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113de18:	e0bfff17 	ldw	r2,-4(fp)
8113de1c:	00ffe244 	movi	r3,-119
8113de20:	10c00005 	stb	r3,0(r2)
        return (0);
8113de24:	0005883a 	mov	r2,zero
8113de28:	00002606 	br	8113dec4 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113de2c:	d0a0a003 	ldbu	r2,-32128(gp)
8113de30:	10803fcc 	andi	r2,r2,255
8113de34:	10000526 	beq	r2,zero,8113de4c <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8113de38:	e0bfff17 	ldw	r2,-4(fp)
8113de3c:	00c00444 	movi	r3,17
8113de40:	10c00005 	stb	r3,0(r2)
        return (0);
8113de44:	0005883a 	mov	r2,zero
8113de48:	00001e06 	br	8113dec4 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
8113de4c:	113ea4c0 	call	8113ea4c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113de50:	e0bffd17 	ldw	r2,-12(fp)
8113de54:	10800c43 	ldbu	r2,49(r2)
8113de58:	10803fcc 	andi	r2,r2,255
8113de5c:	10000e26 	beq	r2,zero,8113de98 <OSTmrNameGet+0x100>
8113de60:	10001316 	blt	r2,zero,8113deb0 <OSTmrNameGet+0x118>
8113de64:	10800108 	cmpgei	r2,r2,4
8113de68:	1000111e 	bne	r2,zero,8113deb0 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
8113de6c:	e0bffd17 	ldw	r2,-12(fp)
8113de70:	10800804 	addi	r2,r2,32
8113de74:	100b883a 	mov	r5,r2
8113de78:	e13ffe17 	ldw	r4,-8(fp)
8113de7c:	11369940 	call	81136994 <OS_StrCopy>
8113de80:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
8113de84:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113de88:	e0bfff17 	ldw	r2,-4(fp)
8113de8c:	10000005 	stb	zero,0(r2)
             return (len);
8113de90:	e0bffc03 	ldbu	r2,-16(fp)
8113de94:	00000b06 	br	8113dec4 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8113de98:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113de9c:	e0bfff17 	ldw	r2,-4(fp)
8113dea0:	00ffe1c4 	movi	r3,-121
8113dea4:	10c00005 	stb	r3,0(r2)
             return (0);
8113dea8:	0005883a 	mov	r2,zero
8113deac:	00000506 	br	8113dec4 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8113deb0:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113deb4:	e0bfff17 	ldw	r2,-4(fp)
8113deb8:	00ffe344 	movi	r3,-115
8113debc:	10c00005 	stb	r3,0(r2)
             return (0);
8113dec0:	0005883a 	mov	r2,zero
    }
}
8113dec4:	e037883a 	mov	sp,fp
8113dec8:	dfc00117 	ldw	ra,4(sp)
8113decc:	df000017 	ldw	fp,0(sp)
8113ded0:	dec00204 	addi	sp,sp,8
8113ded4:	f800283a 	ret

8113ded8 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8113ded8:	defffb04 	addi	sp,sp,-20
8113dedc:	de00012e 	bgeu	sp,et,8113dee4 <OSTmrRemainGet+0xc>
8113dee0:	003b68fa 	trap	3
8113dee4:	dfc00415 	stw	ra,16(sp)
8113dee8:	df000315 	stw	fp,12(sp)
8113deec:	df000304 	addi	fp,sp,12
8113def0:	e13ffe15 	stw	r4,-8(fp)
8113def4:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113def8:	e0bfff17 	ldw	r2,-4(fp)
8113defc:	1000021e 	bne	r2,zero,8113df08 <OSTmrRemainGet+0x30>
        return (0);
8113df00:	0005883a 	mov	r2,zero
8113df04:	00005d06 	br	8113e07c <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8113df08:	e0bffe17 	ldw	r2,-8(fp)
8113df0c:	1000051e 	bne	r2,zero,8113df24 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113df10:	e0bfff17 	ldw	r2,-4(fp)
8113df14:	00ffe284 	movi	r3,-118
8113df18:	10c00005 	stb	r3,0(r2)
        return (0);
8113df1c:	0005883a 	mov	r2,zero
8113df20:	00005606 	br	8113e07c <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113df24:	e0bffe17 	ldw	r2,-8(fp)
8113df28:	10800003 	ldbu	r2,0(r2)
8113df2c:	10803fcc 	andi	r2,r2,255
8113df30:	10801920 	cmpeqi	r2,r2,100
8113df34:	1000051e 	bne	r2,zero,8113df4c <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113df38:	e0bfff17 	ldw	r2,-4(fp)
8113df3c:	00ffe244 	movi	r3,-119
8113df40:	10c00005 	stb	r3,0(r2)
        return (0);
8113df44:	0005883a 	mov	r2,zero
8113df48:	00004c06 	br	8113e07c <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113df4c:	d0a0a003 	ldbu	r2,-32128(gp)
8113df50:	10803fcc 	andi	r2,r2,255
8113df54:	10000526 	beq	r2,zero,8113df6c <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113df58:	e0bfff17 	ldw	r2,-4(fp)
8113df5c:	00ffe2c4 	movi	r3,-117
8113df60:	10c00005 	stb	r3,0(r2)
        return (0);
8113df64:	0005883a 	mov	r2,zero
8113df68:	00004406 	br	8113e07c <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
8113df6c:	113ea4c0 	call	8113ea4c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113df70:	e0bffe17 	ldw	r2,-8(fp)
8113df74:	10800c43 	ldbu	r2,49(r2)
8113df78:	10803fcc 	andi	r2,r2,255
8113df7c:	10c00060 	cmpeqi	r3,r2,1
8113df80:	1800121e 	bne	r3,zero,8113dfcc <OSTmrRemainGet+0xf4>
8113df84:	10c00088 	cmpgei	r3,r2,2
8113df88:	1800021e 	bne	r3,zero,8113df94 <OSTmrRemainGet+0xbc>
8113df8c:	10003026 	beq	r2,zero,8113e050 <OSTmrRemainGet+0x178>
8113df90:	00003506 	br	8113e068 <OSTmrRemainGet+0x190>
8113df94:	10c000a0 	cmpeqi	r3,r2,2
8113df98:	1800281e 	bne	r3,zero,8113e03c <OSTmrRemainGet+0x164>
8113df9c:	108000e0 	cmpeqi	r2,r2,3
8113dfa0:	10003126 	beq	r2,zero,8113e068 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8113dfa4:	e0bffe17 	ldw	r2,-8(fp)
8113dfa8:	10c00517 	ldw	r3,20(r2)
8113dfac:	d0a0a217 	ldw	r2,-32120(gp)
8113dfb0:	1885c83a 	sub	r2,r3,r2
8113dfb4:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8113dfb8:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
8113dfbc:	e0bfff17 	ldw	r2,-4(fp)
8113dfc0:	10000005 	stb	zero,0(r2)
             return (remain);
8113dfc4:	e0bffd17 	ldw	r2,-12(fp)
8113dfc8:	00002c06 	br	8113e07c <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
8113dfcc:	e0bffe17 	ldw	r2,-8(fp)
8113dfd0:	10800c03 	ldbu	r2,48(r2)
8113dfd4:	10803fcc 	andi	r2,r2,255
8113dfd8:	108000a0 	cmpeqi	r2,r2,2
8113dfdc:	10000e26 	beq	r2,zero,8113e018 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8113dfe0:	e0bffe17 	ldw	r2,-8(fp)
8113dfe4:	10800617 	ldw	r2,24(r2)
8113dfe8:	1000041e 	bne	r2,zero,8113dffc <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
8113dfec:	e0bffe17 	ldw	r2,-8(fp)
8113dff0:	10800717 	ldw	r2,28(r2)
8113dff4:	e0bffd15 	stw	r2,-12(fp)
8113dff8:	00000306 	br	8113e008 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
8113dffc:	e0bffe17 	ldw	r2,-8(fp)
8113e000:	10800617 	ldw	r2,24(r2)
8113e004:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8113e008:	113ea900 	call	8113ea90 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113e00c:	e0bfff17 	ldw	r2,-4(fp)
8113e010:	10000005 	stb	zero,0(r2)
                      break;
8113e014:	00000706 	br	8113e034 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8113e018:	e0bffe17 	ldw	r2,-8(fp)
8113e01c:	10800617 	ldw	r2,24(r2)
8113e020:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8113e024:	113ea900 	call	8113ea90 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113e028:	e0bfff17 	ldw	r2,-4(fp)
8113e02c:	10000005 	stb	zero,0(r2)
                      break;
8113e030:	0001883a 	nop
             }
             return (remain);
8113e034:	e0bffd17 	ldw	r2,-12(fp)
8113e038:	00001006 	br	8113e07c <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
8113e03c:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113e040:	e0bfff17 	ldw	r2,-4(fp)
8113e044:	10000005 	stb	zero,0(r2)
             return (0);
8113e048:	0005883a 	mov	r2,zero
8113e04c:	00000b06 	br	8113e07c <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8113e050:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113e054:	e0bfff17 	ldw	r2,-4(fp)
8113e058:	00ffe1c4 	movi	r3,-121
8113e05c:	10c00005 	stb	r3,0(r2)
             return (0);
8113e060:	0005883a 	mov	r2,zero
8113e064:	00000506 	br	8113e07c <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8113e068:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113e06c:	e0bfff17 	ldw	r2,-4(fp)
8113e070:	00ffe344 	movi	r3,-115
8113e074:	10c00005 	stb	r3,0(r2)
             return (0);
8113e078:	0005883a 	mov	r2,zero
    }
}
8113e07c:	e037883a 	mov	sp,fp
8113e080:	dfc00117 	ldw	ra,4(sp)
8113e084:	df000017 	ldw	fp,0(sp)
8113e088:	dec00204 	addi	sp,sp,8
8113e08c:	f800283a 	ret

8113e090 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8113e090:	defffb04 	addi	sp,sp,-20
8113e094:	de00012e 	bgeu	sp,et,8113e09c <OSTmrStateGet+0xc>
8113e098:	003b68fa 	trap	3
8113e09c:	dfc00415 	stw	ra,16(sp)
8113e0a0:	df000315 	stw	fp,12(sp)
8113e0a4:	df000304 	addi	fp,sp,12
8113e0a8:	e13ffe15 	stw	r4,-8(fp)
8113e0ac:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113e0b0:	e0bfff17 	ldw	r2,-4(fp)
8113e0b4:	1000021e 	bne	r2,zero,8113e0c0 <OSTmrStateGet+0x30>
        return (0);
8113e0b8:	0005883a 	mov	r2,zero
8113e0bc:	00002a06 	br	8113e168 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8113e0c0:	e0bffe17 	ldw	r2,-8(fp)
8113e0c4:	1000051e 	bne	r2,zero,8113e0dc <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113e0c8:	e0bfff17 	ldw	r2,-4(fp)
8113e0cc:	00ffe284 	movi	r3,-118
8113e0d0:	10c00005 	stb	r3,0(r2)
        return (0);
8113e0d4:	0005883a 	mov	r2,zero
8113e0d8:	00002306 	br	8113e168 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113e0dc:	e0bffe17 	ldw	r2,-8(fp)
8113e0e0:	10800003 	ldbu	r2,0(r2)
8113e0e4:	10803fcc 	andi	r2,r2,255
8113e0e8:	10801920 	cmpeqi	r2,r2,100
8113e0ec:	1000051e 	bne	r2,zero,8113e104 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113e0f0:	e0bfff17 	ldw	r2,-4(fp)
8113e0f4:	00ffe244 	movi	r3,-119
8113e0f8:	10c00005 	stb	r3,0(r2)
        return (0);
8113e0fc:	0005883a 	mov	r2,zero
8113e100:	00001906 	br	8113e168 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113e104:	d0a0a003 	ldbu	r2,-32128(gp)
8113e108:	10803fcc 	andi	r2,r2,255
8113e10c:	10000526 	beq	r2,zero,8113e124 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113e110:	e0bfff17 	ldw	r2,-4(fp)
8113e114:	00ffe2c4 	movi	r3,-117
8113e118:	10c00005 	stb	r3,0(r2)
        return (0);
8113e11c:	0005883a 	mov	r2,zero
8113e120:	00001106 	br	8113e168 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8113e124:	113ea4c0 	call	8113ea4c <OSTmr_Lock>
    state = ptmr->OSTmrState;
8113e128:	e0bffe17 	ldw	r2,-8(fp)
8113e12c:	10800c43 	ldbu	r2,49(r2)
8113e130:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8113e134:	e0bffd03 	ldbu	r2,-12(fp)
8113e138:	1005883a 	mov	r2,r2
8113e13c:	10800128 	cmpgeui	r2,r2,4
8113e140:	1000031e 	bne	r2,zero,8113e150 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8113e144:	e0bfff17 	ldw	r2,-4(fp)
8113e148:	10000005 	stb	zero,0(r2)
             break;
8113e14c:	00000406 	br	8113e160 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8113e150:	e0bfff17 	ldw	r2,-4(fp)
8113e154:	00ffe344 	movi	r3,-115
8113e158:	10c00005 	stb	r3,0(r2)
             break;
8113e15c:	0001883a 	nop
    }
    OSTmr_Unlock();
8113e160:	113ea900 	call	8113ea90 <OSTmr_Unlock>
    return (state);
8113e164:	e0bffd03 	ldbu	r2,-12(fp)
}
8113e168:	e037883a 	mov	sp,fp
8113e16c:	dfc00117 	ldw	ra,4(sp)
8113e170:	df000017 	ldw	fp,0(sp)
8113e174:	dec00204 	addi	sp,sp,8
8113e178:	f800283a 	ret

8113e17c <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8113e17c:	defffc04 	addi	sp,sp,-16
8113e180:	de00012e 	bgeu	sp,et,8113e188 <OSTmrStart+0xc>
8113e184:	003b68fa 	trap	3
8113e188:	dfc00315 	stw	ra,12(sp)
8113e18c:	df000215 	stw	fp,8(sp)
8113e190:	df000204 	addi	fp,sp,8
8113e194:	e13ffe15 	stw	r4,-8(fp)
8113e198:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113e19c:	e0bfff17 	ldw	r2,-4(fp)
8113e1a0:	1000021e 	bne	r2,zero,8113e1ac <OSTmrStart+0x30>
        return (OS_FALSE);
8113e1a4:	0005883a 	mov	r2,zero
8113e1a8:	00004106 	br	8113e2b0 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8113e1ac:	e0bffe17 	ldw	r2,-8(fp)
8113e1b0:	1000051e 	bne	r2,zero,8113e1c8 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113e1b4:	e0bfff17 	ldw	r2,-4(fp)
8113e1b8:	00ffe284 	movi	r3,-118
8113e1bc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e1c0:	0005883a 	mov	r2,zero
8113e1c4:	00003a06 	br	8113e2b0 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113e1c8:	e0bffe17 	ldw	r2,-8(fp)
8113e1cc:	10800003 	ldbu	r2,0(r2)
8113e1d0:	10803fcc 	andi	r2,r2,255
8113e1d4:	10801920 	cmpeqi	r2,r2,100
8113e1d8:	1000051e 	bne	r2,zero,8113e1f0 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113e1dc:	e0bfff17 	ldw	r2,-4(fp)
8113e1e0:	00ffe244 	movi	r3,-119
8113e1e4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e1e8:	0005883a 	mov	r2,zero
8113e1ec:	00003006 	br	8113e2b0 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113e1f0:	d0a0a003 	ldbu	r2,-32128(gp)
8113e1f4:	10803fcc 	andi	r2,r2,255
8113e1f8:	10000526 	beq	r2,zero,8113e210 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113e1fc:	e0bfff17 	ldw	r2,-4(fp)
8113e200:	00ffe2c4 	movi	r3,-117
8113e204:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e208:	0005883a 	mov	r2,zero
8113e20c:	00002806 	br	8113e2b0 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8113e210:	113ea4c0 	call	8113ea4c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113e214:	e0bffe17 	ldw	r2,-8(fp)
8113e218:	10800c43 	ldbu	r2,49(r2)
8113e21c:	10803fcc 	andi	r2,r2,255
8113e220:	10c000c8 	cmpgei	r3,r2,3
8113e224:	1800031e 	bne	r3,zero,8113e234 <OSTmrStart+0xb8>
8113e228:	00800e16 	blt	zero,r2,8113e264 <OSTmrStart+0xe8>
8113e22c:	10001526 	beq	r2,zero,8113e284 <OSTmrStart+0x108>
8113e230:	00001a06 	br	8113e29c <OSTmrStart+0x120>
8113e234:	108000e0 	cmpeqi	r2,r2,3
8113e238:	10001826 	beq	r2,zero,8113e29c <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8113e23c:	e13ffe17 	ldw	r4,-8(fp)
8113e240:	113e9500 	call	8113e950 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113e244:	000b883a 	mov	r5,zero
8113e248:	e13ffe17 	ldw	r4,-8(fp)
8113e24c:	113e8000 	call	8113e800 <OSTmr_Link>
             OSTmr_Unlock();
8113e250:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113e254:	e0bfff17 	ldw	r2,-4(fp)
8113e258:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113e25c:	00800044 	movi	r2,1
8113e260:	00001306 	br	8113e2b0 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113e264:	000b883a 	mov	r5,zero
8113e268:	e13ffe17 	ldw	r4,-8(fp)
8113e26c:	113e8000 	call	8113e800 <OSTmr_Link>
             OSTmr_Unlock();
8113e270:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113e274:	e0bfff17 	ldw	r2,-4(fp)
8113e278:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113e27c:	00800044 	movi	r2,1
8113e280:	00000b06 	br	8113e2b0 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8113e284:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113e288:	e0bfff17 	ldw	r2,-4(fp)
8113e28c:	00ffe1c4 	movi	r3,-121
8113e290:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113e294:	0005883a 	mov	r2,zero
8113e298:	00000506 	br	8113e2b0 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8113e29c:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113e2a0:	e0bfff17 	ldw	r2,-4(fp)
8113e2a4:	00ffe344 	movi	r3,-115
8113e2a8:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113e2ac:	0005883a 	mov	r2,zero
    }
}
8113e2b0:	e037883a 	mov	sp,fp
8113e2b4:	dfc00117 	ldw	ra,4(sp)
8113e2b8:	df000017 	ldw	fp,0(sp)
8113e2bc:	dec00204 	addi	sp,sp,8
8113e2c0:	f800283a 	ret

8113e2c4 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113e2c4:	defff904 	addi	sp,sp,-28
8113e2c8:	de00012e 	bgeu	sp,et,8113e2d0 <OSTmrStop+0xc>
8113e2cc:	003b68fa 	trap	3
8113e2d0:	dfc00615 	stw	ra,24(sp)
8113e2d4:	df000515 	stw	fp,20(sp)
8113e2d8:	df000504 	addi	fp,sp,20
8113e2dc:	e13ffc15 	stw	r4,-16(fp)
8113e2e0:	2805883a 	mov	r2,r5
8113e2e4:	e1bffe15 	stw	r6,-8(fp)
8113e2e8:	e1ffff15 	stw	r7,-4(fp)
8113e2ec:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8113e2f0:	e0bfff17 	ldw	r2,-4(fp)
8113e2f4:	1000021e 	bne	r2,zero,8113e300 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113e2f8:	0005883a 	mov	r2,zero
8113e2fc:	00006606 	br	8113e498 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8113e300:	e0bffc17 	ldw	r2,-16(fp)
8113e304:	1000051e 	bne	r2,zero,8113e31c <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113e308:	e0bfff17 	ldw	r2,-4(fp)
8113e30c:	00ffe284 	movi	r3,-118
8113e310:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e314:	0005883a 	mov	r2,zero
8113e318:	00005f06 	br	8113e498 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8113e31c:	e0bffc17 	ldw	r2,-16(fp)
8113e320:	10800003 	ldbu	r2,0(r2)
8113e324:	10803fcc 	andi	r2,r2,255
8113e328:	10801920 	cmpeqi	r2,r2,100
8113e32c:	1000051e 	bne	r2,zero,8113e344 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113e330:	e0bfff17 	ldw	r2,-4(fp)
8113e334:	00ffe244 	movi	r3,-119
8113e338:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e33c:	0005883a 	mov	r2,zero
8113e340:	00005506 	br	8113e498 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8113e344:	d0a0a003 	ldbu	r2,-32128(gp)
8113e348:	10803fcc 	andi	r2,r2,255
8113e34c:	10000526 	beq	r2,zero,8113e364 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113e350:	e0bfff17 	ldw	r2,-4(fp)
8113e354:	00ffe2c4 	movi	r3,-117
8113e358:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e35c:	0005883a 	mov	r2,zero
8113e360:	00004d06 	br	8113e498 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8113e364:	113ea4c0 	call	8113ea4c <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113e368:	e0bffc17 	ldw	r2,-16(fp)
8113e36c:	10800c43 	ldbu	r2,49(r2)
8113e370:	10803fcc 	andi	r2,r2,255
8113e374:	10c000c8 	cmpgei	r3,r2,3
8113e378:	1800031e 	bne	r3,zero,8113e388 <OSTmrStop+0xc4>
8113e37c:	00803516 	blt	zero,r2,8113e454 <OSTmrStop+0x190>
8113e380:	10003a26 	beq	r2,zero,8113e46c <OSTmrStop+0x1a8>
8113e384:	00003f06 	br	8113e484 <OSTmrStop+0x1c0>
8113e388:	108000e0 	cmpeqi	r2,r2,3
8113e38c:	10003d26 	beq	r2,zero,8113e484 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113e390:	e13ffc17 	ldw	r4,-16(fp)
8113e394:	113e9500 	call	8113e950 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8113e398:	e0bfff17 	ldw	r2,-4(fp)
8113e39c:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113e3a0:	e0bffd03 	ldbu	r2,-12(fp)
8113e3a4:	10c000e0 	cmpeqi	r3,r2,3
8113e3a8:	1800041e 	bne	r3,zero,8113e3bc <OSTmrStop+0xf8>
8113e3ac:	10c00120 	cmpeqi	r3,r2,4
8113e3b0:	1800121e 	bne	r3,zero,8113e3fc <OSTmrStop+0x138>
8113e3b4:	10002326 	beq	r2,zero,8113e444 <OSTmrStop+0x180>
8113e3b8:	00001e06 	br	8113e434 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113e3bc:	e0bffc17 	ldw	r2,-16(fp)
8113e3c0:	10800117 	ldw	r2,4(r2)
8113e3c4:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113e3c8:	e0bffb17 	ldw	r2,-20(fp)
8113e3cc:	10000726 	beq	r2,zero,8113e3ec <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113e3d0:	e0bffc17 	ldw	r2,-16(fp)
8113e3d4:	10c00217 	ldw	r3,8(r2)
8113e3d8:	e0bffb17 	ldw	r2,-20(fp)
8113e3dc:	180b883a 	mov	r5,r3
8113e3e0:	e13ffc17 	ldw	r4,-16(fp)
8113e3e4:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113e3e8:	00001706 	br	8113e448 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113e3ec:	e0bfff17 	ldw	r2,-4(fp)
8113e3f0:	00ffe3c4 	movi	r3,-113
8113e3f4:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113e3f8:	00001306 	br	8113e448 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113e3fc:	e0bffc17 	ldw	r2,-16(fp)
8113e400:	10800117 	ldw	r2,4(r2)
8113e404:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113e408:	e0bffb17 	ldw	r2,-20(fp)
8113e40c:	10000526 	beq	r2,zero,8113e424 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8113e410:	e0bffb17 	ldw	r2,-20(fp)
8113e414:	e17ffe17 	ldw	r5,-8(fp)
8113e418:	e13ffc17 	ldw	r4,-16(fp)
8113e41c:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113e420:	00000906 	br	8113e448 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113e424:	e0bfff17 	ldw	r2,-4(fp)
8113e428:	00ffe3c4 	movi	r3,-113
8113e42c:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113e430:	00000506 	br	8113e448 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8113e434:	e0bfff17 	ldw	r2,-4(fp)
8113e438:	00ffe104 	movi	r3,-124
8113e43c:	10c00005 	stb	r3,0(r2)
                     break;
8113e440:	00000106 	br	8113e448 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8113e444:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113e448:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             return (OS_TRUE);
8113e44c:	00800044 	movi	r2,1
8113e450:	00001106 	br	8113e498 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8113e454:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8113e458:	e0bfff17 	ldw	r2,-4(fp)
8113e45c:	00ffe384 	movi	r3,-114
8113e460:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8113e464:	00800044 	movi	r2,1
8113e468:	00000b06 	br	8113e498 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8113e46c:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113e470:	e0bfff17 	ldw	r2,-4(fp)
8113e474:	00ffe1c4 	movi	r3,-121
8113e478:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113e47c:	0005883a 	mov	r2,zero
8113e480:	00000506 	br	8113e498 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8113e484:	113ea900 	call	8113ea90 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113e488:	e0bfff17 	ldw	r2,-4(fp)
8113e48c:	00ffe344 	movi	r3,-115
8113e490:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113e494:	0005883a 	mov	r2,zero
    }
}
8113e498:	e037883a 	mov	sp,fp
8113e49c:	dfc00117 	ldw	ra,4(sp)
8113e4a0:	df000017 	ldw	fp,0(sp)
8113e4a4:	dec00204 	addi	sp,sp,8
8113e4a8:	f800283a 	ret

8113e4ac <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8113e4ac:	defffd04 	addi	sp,sp,-12
8113e4b0:	de00012e 	bgeu	sp,et,8113e4b8 <OSTmrSignal+0xc>
8113e4b4:	003b68fa 	trap	3
8113e4b8:	dfc00215 	stw	ra,8(sp)
8113e4bc:	df000115 	stw	fp,4(sp)
8113e4c0:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113e4c4:	d0a08f17 	ldw	r2,-32196(gp)
8113e4c8:	1009883a 	mov	r4,r2
8113e4cc:	113ba780 	call	8113ba78 <OSSemPost>
8113e4d0:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113e4d4:	e0bfff03 	ldbu	r2,-4(fp)
}
8113e4d8:	e037883a 	mov	sp,fp
8113e4dc:	dfc00117 	ldw	ra,4(sp)
8113e4e0:	df000017 	ldw	fp,0(sp)
8113e4e4:	dec00204 	addi	sp,sp,8
8113e4e8:	f800283a 	ret

8113e4ec <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8113e4ec:	defffe04 	addi	sp,sp,-8
8113e4f0:	de00012e 	bgeu	sp,et,8113e4f8 <OSTmr_Alloc+0xc>
8113e4f4:	003b68fa 	trap	3
8113e4f8:	df000115 	stw	fp,4(sp)
8113e4fc:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8113e500:	d0a08d17 	ldw	r2,-32204(gp)
8113e504:	1000021e 	bne	r2,zero,8113e510 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113e508:	0005883a 	mov	r2,zero
8113e50c:	00001006 	br	8113e550 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8113e510:	d0a08d17 	ldw	r2,-32204(gp)
8113e514:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113e518:	e0bfff17 	ldw	r2,-4(fp)
8113e51c:	10800317 	ldw	r2,12(r2)
8113e520:	d0a08d15 	stw	r2,-32204(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113e524:	e0bfff17 	ldw	r2,-4(fp)
8113e528:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8113e52c:	e0bfff17 	ldw	r2,-4(fp)
8113e530:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8113e534:	d0a0920b 	ldhu	r2,-32184(gp)
8113e538:	10800044 	addi	r2,r2,1
8113e53c:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFree--;
8113e540:	d0a0960b 	ldhu	r2,-32168(gp)
8113e544:	10bfffc4 	addi	r2,r2,-1
8113e548:	d0a0960d 	sth	r2,-32168(gp)
    return (ptmr);
8113e54c:	e0bfff17 	ldw	r2,-4(fp)
}
8113e550:	e037883a 	mov	sp,fp
8113e554:	df000017 	ldw	fp,0(sp)
8113e558:	dec00104 	addi	sp,sp,4
8113e55c:	f800283a 	ret

8113e560 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113e560:	defffe04 	addi	sp,sp,-8
8113e564:	de00012e 	bgeu	sp,et,8113e56c <OSTmr_Free+0xc>
8113e568:	003b68fa 	trap	3
8113e56c:	df000115 	stw	fp,4(sp)
8113e570:	df000104 	addi	fp,sp,4
8113e574:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8113e578:	e0bfff17 	ldw	r2,-4(fp)
8113e57c:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113e580:	e0bfff17 	ldw	r2,-4(fp)
8113e584:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8113e588:	e0bfff17 	ldw	r2,-4(fp)
8113e58c:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113e590:	e0bfff17 	ldw	r2,-4(fp)
8113e594:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8113e598:	e0bfff17 	ldw	r2,-4(fp)
8113e59c:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113e5a0:	e0bfff17 	ldw	r2,-4(fp)
8113e5a4:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8113e5a8:	e0bfff17 	ldw	r2,-4(fp)
8113e5ac:	00c00fc4 	movi	r3,63
8113e5b0:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113e5b4:	e0bfff17 	ldw	r2,-4(fp)
8113e5b8:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8113e5bc:	e0bfff17 	ldw	r2,-4(fp)
8113e5c0:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113e5c4:	d0e08d17 	ldw	r3,-32204(gp)
8113e5c8:	e0bfff17 	ldw	r2,-4(fp)
8113e5cc:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113e5d0:	e0bfff17 	ldw	r2,-4(fp)
8113e5d4:	d0a08d15 	stw	r2,-32204(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8113e5d8:	d0a0920b 	ldhu	r2,-32184(gp)
8113e5dc:	10bfffc4 	addi	r2,r2,-1
8113e5e0:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFree++;
8113e5e4:	d0a0960b 	ldhu	r2,-32168(gp)
8113e5e8:	10800044 	addi	r2,r2,1
8113e5ec:	d0a0960d 	sth	r2,-32168(gp)
}
8113e5f0:	0001883a 	nop
8113e5f4:	e037883a 	mov	sp,fp
8113e5f8:	df000017 	ldw	fp,0(sp)
8113e5fc:	dec00104 	addi	sp,sp,4
8113e600:	f800283a 	ret

8113e604 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113e604:	defffa04 	addi	sp,sp,-24
8113e608:	de00012e 	bgeu	sp,et,8113e610 <OSTmr_Init+0xc>
8113e60c:	003b68fa 	trap	3
8113e610:	dfc00515 	stw	ra,20(sp)
8113e614:	df000415 	stw	fp,16(sp)
8113e618:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8113e61c:	01406804 	movi	r5,416
8113e620:	012045b4 	movhi	r4,33046
8113e624:	210e7f04 	addi	r4,r4,14844
8113e628:	11367740 	call	81136774 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8113e62c:	01400404 	movi	r5,16
8113e630:	012045b4 	movhi	r4,33046
8113e634:	210c6b04 	addi	r4,r4,12716
8113e638:	11367740 	call	81136774 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8113e63c:	00a045b4 	movhi	r2,33046
8113e640:	108e7f04 	addi	r2,r2,14844
8113e644:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8113e648:	00a045b4 	movhi	r2,33046
8113e64c:	108e8c04 	addi	r2,r2,14896
8113e650:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113e654:	e03ffc0d 	sth	zero,-16(fp)
8113e658:	00001606 	br	8113e6b4 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8113e65c:	e0bffd17 	ldw	r2,-12(fp)
8113e660:	00c01904 	movi	r3,100
8113e664:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8113e668:	e0bffd17 	ldw	r2,-12(fp)
8113e66c:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113e670:	e0bffd17 	ldw	r2,-12(fp)
8113e674:	e0fffe17 	ldw	r3,-8(fp)
8113e678:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8113e67c:	e0bffd17 	ldw	r2,-12(fp)
8113e680:	00c00fc4 	movi	r3,63
8113e684:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113e688:	e0bffd17 	ldw	r2,-12(fp)
8113e68c:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113e690:	e0bffd17 	ldw	r2,-12(fp)
8113e694:	10800d04 	addi	r2,r2,52
8113e698:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8113e69c:	e0bffe17 	ldw	r2,-8(fp)
8113e6a0:	10800d04 	addi	r2,r2,52
8113e6a4:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113e6a8:	e0bffc0b 	ldhu	r2,-16(fp)
8113e6ac:	10800044 	addi	r2,r2,1
8113e6b0:	e0bffc0d 	sth	r2,-16(fp)
8113e6b4:	e0bffc0b 	ldhu	r2,-16(fp)
8113e6b8:	108001f0 	cmpltui	r2,r2,7
8113e6bc:	103fe71e 	bne	r2,zero,8113e65c <__reset+0xfb11e65c>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113e6c0:	e0bffd17 	ldw	r2,-12(fp)
8113e6c4:	00c01904 	movi	r3,100
8113e6c8:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8113e6cc:	e0bffd17 	ldw	r2,-12(fp)
8113e6d0:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8113e6d4:	e0bffd17 	ldw	r2,-12(fp)
8113e6d8:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8113e6dc:	e0bffd17 	ldw	r2,-12(fp)
8113e6e0:	00c00fc4 	movi	r3,63
8113e6e4:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113e6e8:	e0bffd17 	ldw	r2,-12(fp)
8113e6ec:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8113e6f0:	d020a215 	stw	zero,-32120(gp)
    OSTmrUsed           = 0;
8113e6f4:	d020920d 	sth	zero,-32184(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8113e6f8:	00800204 	movi	r2,8
8113e6fc:	d0a0960d 	sth	r2,-32168(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8113e700:	00a045b4 	movhi	r2,33046
8113e704:	108e7f04 	addi	r2,r2,14844
8113e708:	d0a08d15 	stw	r2,-32204(gp)
    OSTmrSem            = OSSemCreate(1);
8113e70c:	01000044 	movi	r4,1
8113e710:	113b3c80 	call	8113b3c8 <OSSemCreate>
8113e714:	d0a0a415 	stw	r2,-32112(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8113e718:	0009883a 	mov	r4,zero
8113e71c:	113b3c80 	call	8113b3c8 <OSSemCreate>
8113e720:	d0a08f15 	stw	r2,-32196(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8113e724:	d0a0a417 	ldw	r2,-32112(gp)
8113e728:	e0ffff04 	addi	r3,fp,-4
8113e72c:	180d883a 	mov	r6,r3
8113e730:	01604574 	movhi	r5,33045
8113e734:	29753604 	addi	r5,r5,-11048
8113e738:	1009883a 	mov	r4,r2
8113e73c:	1134fd00 	call	81134fd0 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8113e740:	d0a08f17 	ldw	r2,-32196(gp)
8113e744:	e0ffff04 	addi	r3,fp,-4
8113e748:	180d883a 	mov	r6,r3
8113e74c:	01604574 	movhi	r5,33045
8113e750:	29753b04 	addi	r5,r5,-11028
8113e754:	1009883a 	mov	r4,r2
8113e758:	1134fd00 	call	81134fd0 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8113e75c:	113e7780 	call	8113e778 <OSTmr_InitTask>
}
8113e760:	0001883a 	nop
8113e764:	e037883a 	mov	sp,fp
8113e768:	dfc00117 	ldw	ra,4(sp)
8113e76c:	df000017 	ldw	fp,0(sp)
8113e770:	dec00204 	addi	sp,sp,8
8113e774:	f800283a 	ret

8113e778 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8113e778:	defff804 	addi	sp,sp,-32
8113e77c:	de00012e 	bgeu	sp,et,8113e784 <OSTmr_InitTask+0xc>
8113e780:	003b68fa 	trap	3
8113e784:	dfc00715 	stw	ra,28(sp)
8113e788:	df000615 	stw	fp,24(sp)
8113e78c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113e790:	008000c4 	movi	r2,3
8113e794:	d8800415 	stw	r2,16(sp)
8113e798:	d8000315 	stw	zero,12(sp)
8113e79c:	00808004 	movi	r2,512
8113e7a0:	d8800215 	stw	r2,8(sp)
8113e7a4:	00a045b4 	movhi	r2,33046
8113e7a8:	1096b304 	addi	r2,r2,23244
8113e7ac:	d8800115 	stw	r2,4(sp)
8113e7b0:	00bfff54 	movui	r2,65533
8113e7b4:	d8800015 	stw	r2,0(sp)
8113e7b8:	01c00744 	movi	r7,29
8113e7bc:	01a045b4 	movhi	r6,33046
8113e7c0:	3198b204 	addi	r6,r6,25288
8113e7c4:	000b883a 	mov	r5,zero
8113e7c8:	01204534 	movhi	r4,33044
8113e7cc:	213ab304 	addi	r4,r4,-5428
8113e7d0:	113c45c0 	call	8113c45c <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8113e7d4:	e1bfff04 	addi	r6,fp,-4
8113e7d8:	01604574 	movhi	r5,33045
8113e7dc:	29754004 	addi	r5,r5,-11008
8113e7e0:	01000744 	movi	r4,29
8113e7e4:	113cc8c0 	call	8113cc8c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8113e7e8:	0001883a 	nop
8113e7ec:	e037883a 	mov	sp,fp
8113e7f0:	dfc00117 	ldw	ra,4(sp)
8113e7f4:	df000017 	ldw	fp,0(sp)
8113e7f8:	dec00204 	addi	sp,sp,8
8113e7fc:	f800283a 	ret

8113e800 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8113e800:	defffa04 	addi	sp,sp,-24
8113e804:	de00012e 	bgeu	sp,et,8113e80c <OSTmr_Link+0xc>
8113e808:	003b68fa 	trap	3
8113e80c:	df000515 	stw	fp,20(sp)
8113e810:	df000504 	addi	fp,sp,20
8113e814:	e13ffe15 	stw	r4,-8(fp)
8113e818:	2805883a 	mov	r2,r5
8113e81c:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8113e820:	e0bffe17 	ldw	r2,-8(fp)
8113e824:	00c000c4 	movi	r3,3
8113e828:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8113e82c:	e0bfff03 	ldbu	r2,-4(fp)
8113e830:	10800058 	cmpnei	r2,r2,1
8113e834:	1000071e 	bne	r2,zero,8113e854 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113e838:	e0bffe17 	ldw	r2,-8(fp)
8113e83c:	10c00717 	ldw	r3,28(r2)
8113e840:	d0a0a217 	ldw	r2,-32120(gp)
8113e844:	1887883a 	add	r3,r3,r2
8113e848:	e0bffe17 	ldw	r2,-8(fp)
8113e84c:	10c00515 	stw	r3,20(r2)
8113e850:	00001006 	br	8113e894 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8113e854:	e0bffe17 	ldw	r2,-8(fp)
8113e858:	10800617 	ldw	r2,24(r2)
8113e85c:	1000071e 	bne	r2,zero,8113e87c <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113e860:	e0bffe17 	ldw	r2,-8(fp)
8113e864:	10c00717 	ldw	r3,28(r2)
8113e868:	d0a0a217 	ldw	r2,-32120(gp)
8113e86c:	1887883a 	add	r3,r3,r2
8113e870:	e0bffe17 	ldw	r2,-8(fp)
8113e874:	10c00515 	stw	r3,20(r2)
8113e878:	00000606 	br	8113e894 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8113e87c:	e0bffe17 	ldw	r2,-8(fp)
8113e880:	10c00617 	ldw	r3,24(r2)
8113e884:	d0a0a217 	ldw	r2,-32120(gp)
8113e888:	1887883a 	add	r3,r3,r2
8113e88c:	e0bffe17 	ldw	r2,-8(fp)
8113e890:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113e894:	e0bffe17 	ldw	r2,-8(fp)
8113e898:	10800517 	ldw	r2,20(r2)
8113e89c:	1080004c 	andi	r2,r2,1
8113e8a0:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113e8a4:	e0bffb0b 	ldhu	r2,-20(fp)
8113e8a8:	100690fa 	slli	r3,r2,3
8113e8ac:	00a045b4 	movhi	r2,33046
8113e8b0:	108c6b04 	addi	r2,r2,12716
8113e8b4:	1885883a 	add	r2,r3,r2
8113e8b8:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8113e8bc:	e0bffc17 	ldw	r2,-16(fp)
8113e8c0:	10800017 	ldw	r2,0(r2)
8113e8c4:	1000091e 	bne	r2,zero,8113e8ec <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8113e8c8:	e0bffc17 	ldw	r2,-16(fp)
8113e8cc:	e0fffe17 	ldw	r3,-8(fp)
8113e8d0:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8113e8d4:	e0bffe17 	ldw	r2,-8(fp)
8113e8d8:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8113e8dc:	e0bffc17 	ldw	r2,-16(fp)
8113e8e0:	00c00044 	movi	r3,1
8113e8e4:	10c0010d 	sth	r3,4(r2)
8113e8e8:	00001206 	br	8113e934 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8113e8ec:	e0bffc17 	ldw	r2,-16(fp)
8113e8f0:	10800017 	ldw	r2,0(r2)
8113e8f4:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8113e8f8:	e0bffc17 	ldw	r2,-16(fp)
8113e8fc:	e0fffe17 	ldw	r3,-8(fp)
8113e900:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8113e904:	e0bffe17 	ldw	r2,-8(fp)
8113e908:	e0fffd17 	ldw	r3,-12(fp)
8113e90c:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8113e910:	e0bffd17 	ldw	r2,-12(fp)
8113e914:	e0fffe17 	ldw	r3,-8(fp)
8113e918:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8113e91c:	e0bffc17 	ldw	r2,-16(fp)
8113e920:	1080010b 	ldhu	r2,4(r2)
8113e924:	10800044 	addi	r2,r2,1
8113e928:	1007883a 	mov	r3,r2
8113e92c:	e0bffc17 	ldw	r2,-16(fp)
8113e930:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8113e934:	e0bffe17 	ldw	r2,-8(fp)
8113e938:	10000415 	stw	zero,16(r2)
}
8113e93c:	0001883a 	nop
8113e940:	e037883a 	mov	sp,fp
8113e944:	df000017 	ldw	fp,0(sp)
8113e948:	dec00104 	addi	sp,sp,4
8113e94c:	f800283a 	ret

8113e950 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113e950:	defffa04 	addi	sp,sp,-24
8113e954:	de00012e 	bgeu	sp,et,8113e95c <OSTmr_Unlink+0xc>
8113e958:	003b68fa 	trap	3
8113e95c:	df000515 	stw	fp,20(sp)
8113e960:	df000504 	addi	fp,sp,20
8113e964:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113e968:	e0bfff17 	ldw	r2,-4(fp)
8113e96c:	10800517 	ldw	r2,20(r2)
8113e970:	1080004c 	andi	r2,r2,1
8113e974:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113e978:	e0bffb0b 	ldhu	r2,-20(fp)
8113e97c:	100690fa 	slli	r3,r2,3
8113e980:	00a045b4 	movhi	r2,33046
8113e984:	108c6b04 	addi	r2,r2,12716
8113e988:	1885883a 	add	r2,r3,r2
8113e98c:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113e990:	e0bffc17 	ldw	r2,-16(fp)
8113e994:	10c00017 	ldw	r3,0(r2)
8113e998:	e0bfff17 	ldw	r2,-4(fp)
8113e99c:	18800b1e 	bne	r3,r2,8113e9cc <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113e9a0:	e0bfff17 	ldw	r2,-4(fp)
8113e9a4:	10800317 	ldw	r2,12(r2)
8113e9a8:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8113e9ac:	e0bffc17 	ldw	r2,-16(fp)
8113e9b0:	e0fffd17 	ldw	r3,-12(fp)
8113e9b4:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8113e9b8:	e0bffd17 	ldw	r2,-12(fp)
8113e9bc:	10001126 	beq	r2,zero,8113ea04 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113e9c0:	e0bffd17 	ldw	r2,-12(fp)
8113e9c4:	10000415 	stw	zero,16(r2)
8113e9c8:	00000e06 	br	8113ea04 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8113e9cc:	e0bfff17 	ldw	r2,-4(fp)
8113e9d0:	10800417 	ldw	r2,16(r2)
8113e9d4:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8113e9d8:	e0bfff17 	ldw	r2,-4(fp)
8113e9dc:	10800317 	ldw	r2,12(r2)
8113e9e0:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8113e9e4:	e0bffd17 	ldw	r2,-12(fp)
8113e9e8:	e0fffe17 	ldw	r3,-8(fp)
8113e9ec:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8113e9f0:	e0bffe17 	ldw	r2,-8(fp)
8113e9f4:	10000326 	beq	r2,zero,8113ea04 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8113e9f8:	e0bffe17 	ldw	r2,-8(fp)
8113e9fc:	e0fffd17 	ldw	r3,-12(fp)
8113ea00:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8113ea04:	e0bfff17 	ldw	r2,-4(fp)
8113ea08:	00c00044 	movi	r3,1
8113ea0c:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8113ea10:	e0bfff17 	ldw	r2,-4(fp)
8113ea14:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8113ea18:	e0bfff17 	ldw	r2,-4(fp)
8113ea1c:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8113ea20:	e0bffc17 	ldw	r2,-16(fp)
8113ea24:	1080010b 	ldhu	r2,4(r2)
8113ea28:	10bfffc4 	addi	r2,r2,-1
8113ea2c:	1007883a 	mov	r3,r2
8113ea30:	e0bffc17 	ldw	r2,-16(fp)
8113ea34:	10c0010d 	sth	r3,4(r2)
}
8113ea38:	0001883a 	nop
8113ea3c:	e037883a 	mov	sp,fp
8113ea40:	df000017 	ldw	fp,0(sp)
8113ea44:	dec00104 	addi	sp,sp,4
8113ea48:	f800283a 	ret

8113ea4c <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8113ea4c:	defffd04 	addi	sp,sp,-12
8113ea50:	de00012e 	bgeu	sp,et,8113ea58 <OSTmr_Lock+0xc>
8113ea54:	003b68fa 	trap	3
8113ea58:	dfc00215 	stw	ra,8(sp)
8113ea5c:	df000115 	stw	fp,4(sp)
8113ea60:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8113ea64:	d0a0a417 	ldw	r2,-32112(gp)
8113ea68:	e1bfff04 	addi	r6,fp,-4
8113ea6c:	000b883a 	mov	r5,zero
8113ea70:	1009883a 	mov	r4,r2
8113ea74:	113b6f00 	call	8113b6f0 <OSSemPend>
    (void)err;
}
8113ea78:	0001883a 	nop
8113ea7c:	e037883a 	mov	sp,fp
8113ea80:	dfc00117 	ldw	ra,4(sp)
8113ea84:	df000017 	ldw	fp,0(sp)
8113ea88:	dec00204 	addi	sp,sp,8
8113ea8c:	f800283a 	ret

8113ea90 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113ea90:	defffe04 	addi	sp,sp,-8
8113ea94:	de00012e 	bgeu	sp,et,8113ea9c <OSTmr_Unlock+0xc>
8113ea98:	003b68fa 	trap	3
8113ea9c:	dfc00115 	stw	ra,4(sp)
8113eaa0:	df000015 	stw	fp,0(sp)
8113eaa4:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8113eaa8:	d0a0a417 	ldw	r2,-32112(gp)
8113eaac:	1009883a 	mov	r4,r2
8113eab0:	113ba780 	call	8113ba78 <OSSemPost>
}
8113eab4:	0001883a 	nop
8113eab8:	e037883a 	mov	sp,fp
8113eabc:	dfc00117 	ldw	ra,4(sp)
8113eac0:	df000017 	ldw	fp,0(sp)
8113eac4:	dec00204 	addi	sp,sp,8
8113eac8:	f800283a 	ret

8113eacc <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8113eacc:	defff704 	addi	sp,sp,-36
8113ead0:	de00012e 	bgeu	sp,et,8113ead8 <OSTmr_Task+0xc>
8113ead4:	003b68fa 	trap	3
8113ead8:	dfc00815 	stw	ra,32(sp)
8113eadc:	df000715 	stw	fp,28(sp)
8113eae0:	df000704 	addi	fp,sp,28
8113eae4:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8113eae8:	d0a08f17 	ldw	r2,-32196(gp)
8113eaec:	e0fffe04 	addi	r3,fp,-8
8113eaf0:	180d883a 	mov	r6,r3
8113eaf4:	000b883a 	mov	r5,zero
8113eaf8:	1009883a 	mov	r4,r2
8113eafc:	113b6f00 	call	8113b6f0 <OSSemPend>
        OSTmr_Lock();
8113eb00:	113ea4c0 	call	8113ea4c <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8113eb04:	d0a0a217 	ldw	r2,-32120(gp)
8113eb08:	10800044 	addi	r2,r2,1
8113eb0c:	d0a0a215 	stw	r2,-32120(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8113eb10:	d0a0a217 	ldw	r2,-32120(gp)
8113eb14:	1080004c 	andi	r2,r2,1
8113eb18:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8113eb1c:	e0bffa0b 	ldhu	r2,-24(fp)
8113eb20:	100690fa 	slli	r3,r2,3
8113eb24:	00a045b4 	movhi	r2,33046
8113eb28:	108c6b04 	addi	r2,r2,12716
8113eb2c:	1885883a 	add	r2,r3,r2
8113eb30:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8113eb34:	e0bffb17 	ldw	r2,-20(fp)
8113eb38:	10800017 	ldw	r2,0(r2)
8113eb3c:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8113eb40:	00002206 	br	8113ebcc <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8113eb44:	e0bff917 	ldw	r2,-28(fp)
8113eb48:	10800317 	ldw	r2,12(r2)
8113eb4c:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8113eb50:	e0bff917 	ldw	r2,-28(fp)
8113eb54:	10c00517 	ldw	r3,20(r2)
8113eb58:	d0a0a217 	ldw	r2,-32120(gp)
8113eb5c:	1880191e 	bne	r3,r2,8113ebc4 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8113eb60:	e0bff917 	ldw	r2,-28(fp)
8113eb64:	10800117 	ldw	r2,4(r2)
8113eb68:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8113eb6c:	e0bffd17 	ldw	r2,-12(fp)
8113eb70:	10000626 	beq	r2,zero,8113eb8c <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8113eb74:	e0bff917 	ldw	r2,-28(fp)
8113eb78:	10c00217 	ldw	r3,8(r2)
8113eb7c:	e0bffd17 	ldw	r2,-12(fp)
8113eb80:	180b883a 	mov	r5,r3
8113eb84:	e13ff917 	ldw	r4,-28(fp)
8113eb88:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8113eb8c:	e13ff917 	ldw	r4,-28(fp)
8113eb90:	113e9500 	call	8113e950 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8113eb94:	e0bff917 	ldw	r2,-28(fp)
8113eb98:	10800c03 	ldbu	r2,48(r2)
8113eb9c:	10803fcc 	andi	r2,r2,255
8113eba0:	10800098 	cmpnei	r2,r2,2
8113eba4:	1000041e 	bne	r2,zero,8113ebb8 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8113eba8:	01400044 	movi	r5,1
8113ebac:	e13ff917 	ldw	r4,-28(fp)
8113ebb0:	113e8000 	call	8113e800 <OSTmr_Link>
8113ebb4:	00000306 	br	8113ebc4 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113ebb8:	e0bff917 	ldw	r2,-28(fp)
8113ebbc:	00c00084 	movi	r3,2
8113ebc0:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8113ebc4:	e0bffc17 	ldw	r2,-16(fp)
8113ebc8:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8113ebcc:	e0bff917 	ldw	r2,-28(fp)
8113ebd0:	103fdc1e 	bne	r2,zero,8113eb44 <__reset+0xfb11eb44>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8113ebd4:	113ea900 	call	8113ea90 <OSTmr_Unlock>
    }
8113ebd8:	003fc306 	br	8113eae8 <__reset+0xfb11eae8>

8113ebdc <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
8113ebdc:	defffd04 	addi	sp,sp,-12
8113ebe0:	de00012e 	bgeu	sp,et,8113ebe8 <alt_dev_reg+0xc>
8113ebe4:	003b68fa 	trap	3
8113ebe8:	dfc00215 	stw	ra,8(sp)
8113ebec:	df000115 	stw	fp,4(sp)
8113ebf0:	df000104 	addi	fp,sp,4
8113ebf4:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8113ebf8:	d1600d04 	addi	r5,gp,-32716
8113ebfc:	e13fff17 	ldw	r4,-4(fp)
8113ec00:	1146e7c0 	call	81146e7c <alt_dev_llist_insert>
}
8113ec04:	e037883a 	mov	sp,fp
8113ec08:	dfc00117 	ldw	ra,4(sp)
8113ec0c:	df000017 	ldw	fp,0(sp)
8113ec10:	dec00204 	addi	sp,sp,8
8113ec14:	f800283a 	ret

8113ec18 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8113ec18:	defffd04 	addi	sp,sp,-12
8113ec1c:	de00012e 	bgeu	sp,et,8113ec24 <alt_irq_init+0xc>
8113ec20:	003b68fa 	trap	3
8113ec24:	dfc00215 	stw	ra,8(sp)
8113ec28:	df000115 	stw	fp,4(sp)
8113ec2c:	df000104 	addi	fp,sp,4
8113ec30:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8113ec34:	11478440 	call	81147844 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8113ec38:	00800044 	movi	r2,1
8113ec3c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8113ec40:	0001883a 	nop
8113ec44:	e037883a 	mov	sp,fp
8113ec48:	dfc00117 	ldw	ra,4(sp)
8113ec4c:	df000017 	ldw	fp,0(sp)
8113ec50:	dec00204 	addi	sp,sp,8
8113ec54:	f800283a 	ret

8113ec58 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8113ec58:	defffe04 	addi	sp,sp,-8
8113ec5c:	de00012e 	bgeu	sp,et,8113ec64 <alt_sys_init+0xc>
8113ec60:	003b68fa 	trap	3
8113ec64:	dfc00115 	stw	ra,4(sp)
8113ec68:	df000015 	stw	fp,0(sp)
8113ec6c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8113ec70:	01c0fa04 	movi	r7,1000
8113ec74:	01800304 	movi	r6,12
8113ec78:	000b883a 	mov	r5,zero
8113ec7c:	01200034 	movhi	r4,32768
8113ec80:	21022004 	addi	r4,r4,2176
8113ec84:	1143fb00 	call	81143fb0 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8113ec88:	018002c4 	movi	r6,11
8113ec8c:	000b883a 	mov	r5,zero
8113ec90:	01204574 	movhi	r4,33045
8113ec94:	2138dc04 	addi	r4,r4,-7312
8113ec98:	114329c0 	call	8114329c <altera_avalon_jtag_uart_init>
8113ec9c:	01204574 	movhi	r4,33045
8113eca0:	2138d204 	addi	r4,r4,-7352
8113eca4:	113ebdc0 	call	8113ebdc <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8113eca8:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
8113ecac:	018003c4 	movi	r6,15
8113ecb0:	000b883a 	mov	r5,zero
8113ecb4:	01204574 	movhi	r4,33045
8113ecb8:	213cf704 	addi	r4,r4,-3108
8113ecbc:	114415c0 	call	8114415c <altera_avalon_uart_init>
8113ecc0:	01204574 	movhi	r4,33045
8113ecc4:	213ced04 	addi	r4,r4,-3148
8113ecc8:	113ebdc0 	call	8113ebdc <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
8113eccc:	00a04574 	movhi	r2,33045
8113ecd0:	10bd2104 	addi	r2,r2,-2940
8113ecd4:	10c00717 	ldw	r3,28(r2)
8113ecd8:	00a04574 	movhi	r2,33045
8113ecdc:	10bd2104 	addi	r2,r2,-2940
8113ece0:	10800817 	ldw	r2,32(r2)
8113ece4:	100d883a 	mov	r6,r2
8113ece8:	180b883a 	mov	r5,r3
8113ecec:	01204574 	movhi	r4,33045
8113ecf0:	213d2104 	addi	r4,r4,-2940
8113ecf4:	11469e40 	call	811469e4 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8113ecf8:	00a04574 	movhi	r2,33045
8113ecfc:	10bd3a04 	addi	r2,r2,-2840
8113ed00:	10c00717 	ldw	r3,28(r2)
8113ed04:	00a04574 	movhi	r2,33045
8113ed08:	10bd3a04 	addi	r2,r2,-2840
8113ed0c:	10800817 	ldw	r2,32(r2)
8113ed10:	100d883a 	mov	r6,r2
8113ed14:	180b883a 	mov	r5,r3
8113ed18:	01204574 	movhi	r4,33045
8113ed1c:	213d3a04 	addi	r4,r4,-2840
8113ed20:	11469e40 	call	811469e4 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8113ed24:	01204574 	movhi	r4,33045
8113ed28:	213d5304 	addi	r4,r4,-2740
8113ed2c:	113ebdc0 	call	8113ebdc <alt_dev_reg>
}
8113ed30:	0001883a 	nop
8113ed34:	e037883a 	mov	sp,fp
8113ed38:	dfc00117 	ldw	ra,4(sp)
8113ed3c:	df000017 	ldw	fp,0(sp)
8113ed40:	dec00204 	addi	sp,sp,8
8113ed44:	f800283a 	ret

8113ed48 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8113ed48:	defffa04 	addi	sp,sp,-24
8113ed4c:	de00012e 	bgeu	sp,et,8113ed54 <Write_Sector_Data+0xc>
8113ed50:	003b68fa 	trap	3
8113ed54:	dfc00515 	stw	ra,20(sp)
8113ed58:	df000415 	stw	fp,16(sp)
8113ed5c:	df000404 	addi	fp,sp,16
8113ed60:	e13ffe15 	stw	r4,-8(fp)
8113ed64:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113ed68:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
8113ed6c:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
8113ed70:	10001e26 	beq	r2,zero,8113edec <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8113ed74:	00803fc4 	movi	r2,255
8113ed78:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113ed7c:	d0a0ae17 	ldw	r2,-32072(gp)
8113ed80:	e13ffe17 	ldw	r4,-8(fp)
8113ed84:	e0ffff17 	ldw	r3,-4(fp)
8113ed88:	20c7883a 	add	r3,r4,r3
8113ed8c:	1806927a 	slli	r3,r3,9
8113ed90:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8113ed94:	d0a0ad17 	ldw	r2,-32076(gp)
8113ed98:	00c00604 	movi	r3,24
8113ed9c:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113eda0:	d0a0aa17 	ldw	r2,-32088(gp)
8113eda4:	1080002b 	ldhuio	r2,0(r2)
8113eda8:	10bfffcc 	andi	r2,r2,65535
8113edac:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8113edb0:	e0bffd0b 	ldhu	r2,-12(fp)
8113edb4:	10bfffcc 	andi	r2,r2,65535
8113edb8:	1080010c 	andi	r2,r2,4
8113edbc:	103ff81e 	bne	r2,zero,8113eda0 <__reset+0xfb11eda0>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8113edc0:	e0bffd0b 	ldhu	r2,-12(fp)
8113edc4:	10bfffcc 	andi	r2,r2,65535
8113edc8:	1080040c 	andi	r2,r2,16
8113edcc:	1000071e 	bne	r2,zero,8113edec <Write_Sector_Data+0xa4>
        {
            result = true;
8113edd0:	00800044 	movi	r2,1
8113edd4:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113edd8:	d020b315 	stw	zero,-32052(gp)
            current_sector_index = sector_index+partition_offset;
8113eddc:	e0fffe17 	ldw	r3,-8(fp)
8113ede0:	e0bfff17 	ldw	r2,-4(fp)
8113ede4:	1885883a 	add	r2,r3,r2
8113ede8:	d0a0b415 	stw	r2,-32048(gp)
        }
    }
    return result;
8113edec:	e0bffc17 	ldw	r2,-16(fp)
}
8113edf0:	e037883a 	mov	sp,fp
8113edf4:	dfc00117 	ldw	ra,4(sp)
8113edf8:	df000017 	ldw	fp,0(sp)
8113edfc:	dec00204 	addi	sp,sp,8
8113ee00:	f800283a 	ret

8113ee04 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8113ee04:	defffd04 	addi	sp,sp,-12
8113ee08:	de00012e 	bgeu	sp,et,8113ee10 <Save_Modified_Sector+0xc>
8113ee0c:	003b68fa 	trap	3
8113ee10:	dfc00215 	stw	ra,8(sp)
8113ee14:	df000115 	stw	fp,4(sp)
8113ee18:	df000104 	addi	fp,sp,4
    bool result = true;
8113ee1c:	00800044 	movi	r2,1
8113ee20:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8113ee24:	d0a0b317 	ldw	r2,-32052(gp)
8113ee28:	10000526 	beq	r2,zero,8113ee40 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
8113ee2c:	d0a0b417 	ldw	r2,-32048(gp)
8113ee30:	000b883a 	mov	r5,zero
8113ee34:	1009883a 	mov	r4,r2
8113ee38:	113ed480 	call	8113ed48 <Write_Sector_Data>
8113ee3c:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8113ee40:	e0bfff17 	ldw	r2,-4(fp)
}
8113ee44:	e037883a 	mov	sp,fp
8113ee48:	dfc00117 	ldw	ra,4(sp)
8113ee4c:	df000017 	ldw	fp,0(sp)
8113ee50:	dec00204 	addi	sp,sp,8
8113ee54:	f800283a 	ret

8113ee58 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8113ee58:	defffa04 	addi	sp,sp,-24
8113ee5c:	de00012e 	bgeu	sp,et,8113ee64 <Read_Sector_Data+0xc>
8113ee60:	003b68fa 	trap	3
8113ee64:	dfc00515 	stw	ra,20(sp)
8113ee68:	df000415 	stw	fp,16(sp)
8113ee6c:	df000404 	addi	fp,sp,16
8113ee70:	e13ffe15 	stw	r4,-8(fp)
8113ee74:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8113ee78:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
8113ee7c:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
8113ee80:	10002726 	beq	r2,zero,8113ef20 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
8113ee84:	00803fc4 	movi	r2,255
8113ee88:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
8113ee8c:	d0a0b317 	ldw	r2,-32052(gp)
8113ee90:	10000726 	beq	r2,zero,8113eeb0 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8113ee94:	d0a0b417 	ldw	r2,-32048(gp)
8113ee98:	000b883a 	mov	r5,zero
8113ee9c:	1009883a 	mov	r4,r2
8113eea0:	113ed480 	call	8113ed48 <Write_Sector_Data>
8113eea4:	1000021e 	bne	r2,zero,8113eeb0 <Read_Sector_Data+0x58>
            {
                return false;
8113eea8:	0005883a 	mov	r2,zero
8113eeac:	00001d06 	br	8113ef24 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113eeb0:	d0a0ae17 	ldw	r2,-32072(gp)
8113eeb4:	e13ffe17 	ldw	r4,-8(fp)
8113eeb8:	e0ffff17 	ldw	r3,-4(fp)
8113eebc:	20c7883a 	add	r3,r4,r3
8113eec0:	1806927a 	slli	r3,r3,9
8113eec4:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8113eec8:	d0a0ad17 	ldw	r2,-32076(gp)
8113eecc:	00c00444 	movi	r3,17
8113eed0:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113eed4:	d0a0aa17 	ldw	r2,-32088(gp)
8113eed8:	1080002b 	ldhuio	r2,0(r2)
8113eedc:	10bfffcc 	andi	r2,r2,65535
8113eee0:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8113eee4:	e0bffd0b 	ldhu	r2,-12(fp)
8113eee8:	10bfffcc 	andi	r2,r2,65535
8113eeec:	1080010c 	andi	r2,r2,4
8113eef0:	103ff81e 	bne	r2,zero,8113eed4 <__reset+0xfb11eed4>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8113eef4:	e0bffd0b 	ldhu	r2,-12(fp)
8113eef8:	10bfffcc 	andi	r2,r2,65535
8113eefc:	1080040c 	andi	r2,r2,16
8113ef00:	1000071e 	bne	r2,zero,8113ef20 <Read_Sector_Data+0xc8>
		{
			result = true;
8113ef04:	00800044 	movi	r2,1
8113ef08:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113ef0c:	d020b315 	stw	zero,-32052(gp)
            current_sector_index = sector_index+partition_offset;
8113ef10:	e0fffe17 	ldw	r3,-8(fp)
8113ef14:	e0bfff17 	ldw	r2,-4(fp)
8113ef18:	1885883a 	add	r2,r3,r2
8113ef1c:	d0a0b415 	stw	r2,-32048(gp)
		}
	}
	return result;
8113ef20:	e0bffc17 	ldw	r2,-16(fp)
}
8113ef24:	e037883a 	mov	sp,fp
8113ef28:	dfc00117 	ldw	ra,4(sp)
8113ef2c:	df000017 	ldw	fp,0(sp)
8113ef30:	dec00204 	addi	sp,sp,8
8113ef34:	f800283a 	ret

8113ef38 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8113ef38:	defffb04 	addi	sp,sp,-20
8113ef3c:	de00012e 	bgeu	sp,et,8113ef44 <get_cluster_flag+0xc>
8113ef40:	003b68fa 	trap	3
8113ef44:	dfc00415 	stw	ra,16(sp)
8113ef48:	df000315 	stw	fp,12(sp)
8113ef4c:	df000304 	addi	fp,sp,12
8113ef50:	e13ffe15 	stw	r4,-8(fp)
8113ef54:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8113ef58:	e0bffe17 	ldw	r2,-8(fp)
8113ef5c:	1004d23a 	srli	r2,r2,8
8113ef60:	d0e0b017 	ldw	r3,-32064(gp)
8113ef64:	10c5883a 	add	r2,r2,r3
8113ef68:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113ef6c:	00a045f4 	movhi	r2,33047
8113ef70:	10a49104 	addi	r2,r2,-28092
8113ef74:	10801117 	ldw	r2,68(r2)
8113ef78:	e0fffd17 	ldw	r3,-12(fp)
8113ef7c:	1885883a 	add	r2,r3,r2
8113ef80:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
8113ef84:	d0a0b417 	ldw	r2,-32048(gp)
8113ef88:	e0fffd17 	ldw	r3,-12(fp)
8113ef8c:	18800726 	beq	r3,r2,8113efac <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113ef90:	e0bffd17 	ldw	r2,-12(fp)
8113ef94:	000b883a 	mov	r5,zero
8113ef98:	1009883a 	mov	r4,r2
8113ef9c:	113ee580 	call	8113ee58 <Read_Sector_Data>
8113efa0:	1000021e 	bne	r2,zero,8113efac <get_cluster_flag+0x74>
        {
            return false;
8113efa4:	0005883a 	mov	r2,zero
8113efa8:	00000d06 	br	8113efe0 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
8113efac:	e0bffe17 	ldw	r2,-8(fp)
8113efb0:	10803fcc 	andi	r2,r2,255
8113efb4:	1085883a 	add	r2,r2,r2
8113efb8:	1007883a 	mov	r3,r2
8113efbc:	d0a0b217 	ldw	r2,-32056(gp)
8113efc0:	10800a17 	ldw	r2,40(r2)
8113efc4:	1885883a 	add	r2,r3,r2
8113efc8:	1080002b 	ldhuio	r2,0(r2)
8113efcc:	10bfffcc 	andi	r2,r2,65535
8113efd0:	1007883a 	mov	r3,r2
8113efd4:	e0bfff17 	ldw	r2,-4(fp)
8113efd8:	10c0000d 	sth	r3,0(r2)
    return true;
8113efdc:	00800044 	movi	r2,1
}
8113efe0:	e037883a 	mov	sp,fp
8113efe4:	dfc00117 	ldw	ra,4(sp)
8113efe8:	df000017 	ldw	fp,0(sp)
8113efec:	dec00204 	addi	sp,sp,8
8113eff0:	f800283a 	ret

8113eff4 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8113eff4:	defffa04 	addi	sp,sp,-24
8113eff8:	de00012e 	bgeu	sp,et,8113f000 <mark_cluster+0xc>
8113effc:	003b68fa 	trap	3
8113f000:	dfc00515 	stw	ra,20(sp)
8113f004:	df000415 	stw	fp,16(sp)
8113f008:	df000404 	addi	fp,sp,16
8113f00c:	e13ffd15 	stw	r4,-12(fp)
8113f010:	2805883a 	mov	r2,r5
8113f014:	e1bfff15 	stw	r6,-4(fp)
8113f018:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
8113f01c:	e0bffd17 	ldw	r2,-12(fp)
8113f020:	1004d23a 	srli	r2,r2,8
8113f024:	d0e0b017 	ldw	r3,-32064(gp)
8113f028:	10c5883a 	add	r2,r2,r3
8113f02c:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8113f030:	e0bfff17 	ldw	r2,-4(fp)
8113f034:	10000726 	beq	r2,zero,8113f054 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113f038:	00a045f4 	movhi	r2,33047
8113f03c:	10a49104 	addi	r2,r2,-28092
8113f040:	10801117 	ldw	r2,68(r2)
8113f044:	e0fffc17 	ldw	r3,-16(fp)
8113f048:	1885883a 	add	r2,r3,r2
8113f04c:	e0bffc15 	stw	r2,-16(fp)
8113f050:	00000606 	br	8113f06c <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8113f054:	00a045f4 	movhi	r2,33047
8113f058:	10a49104 	addi	r2,r2,-28092
8113f05c:	10801217 	ldw	r2,72(r2)
8113f060:	e0fffc17 	ldw	r3,-16(fp)
8113f064:	1885883a 	add	r2,r3,r2
8113f068:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
8113f06c:	d0a0b417 	ldw	r2,-32048(gp)
8113f070:	e0fffc17 	ldw	r3,-16(fp)
8113f074:	18800726 	beq	r3,r2,8113f094 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113f078:	e0bffc17 	ldw	r2,-16(fp)
8113f07c:	000b883a 	mov	r5,zero
8113f080:	1009883a 	mov	r4,r2
8113f084:	113ee580 	call	8113ee58 <Read_Sector_Data>
8113f088:	1000021e 	bne	r2,zero,8113f094 <mark_cluster+0xa0>
        {
            return false;
8113f08c:	0005883a 	mov	r2,zero
8113f090:	00000d06 	br	8113f0c8 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8113f094:	e0bffd17 	ldw	r2,-12(fp)
8113f098:	10803fcc 	andi	r2,r2,255
8113f09c:	1085883a 	add	r2,r2,r2
8113f0a0:	1007883a 	mov	r3,r2
8113f0a4:	d0a0b217 	ldw	r2,-32056(gp)
8113f0a8:	10800a17 	ldw	r2,40(r2)
8113f0ac:	1885883a 	add	r2,r3,r2
8113f0b0:	1007883a 	mov	r3,r2
8113f0b4:	e0bffe0f 	ldh	r2,-8(fp)
8113f0b8:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
8113f0bc:	00800044 	movi	r2,1
8113f0c0:	d0a0b315 	stw	r2,-32052(gp)
    return true;
8113f0c4:	00800044 	movi	r2,1
}
8113f0c8:	e037883a 	mov	sp,fp
8113f0cc:	dfc00117 	ldw	ra,4(sp)
8113f0d0:	df000017 	ldw	fp,0(sp)
8113f0d4:	dec00204 	addi	sp,sp,8
8113f0d8:	f800283a 	ret

8113f0dc <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
8113f0dc:	defff704 	addi	sp,sp,-36
8113f0e0:	de00012e 	bgeu	sp,et,8113f0e8 <Check_for_Master_Boot_Record+0xc>
8113f0e4:	003b68fa 	trap	3
8113f0e8:	dfc00815 	stw	ra,32(sp)
8113f0ec:	df000715 	stw	fp,28(sp)
8113f0f0:	df000704 	addi	fp,sp,28
	bool result = false;
8113f0f4:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8113f0f8:	000b883a 	mov	r5,zero
8113f0fc:	0009883a 	mov	r4,zero
8113f100:	113ee580 	call	8113ee58 <Read_Sector_Data>
8113f104:	10005a26 	beq	r2,zero,8113f270 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8113f108:	d0a0b217 	ldw	r2,-32056(gp)
8113f10c:	10800a17 	ldw	r2,40(r2)
8113f110:	10807f84 	addi	r2,r2,510
8113f114:	1080002b 	ldhuio	r2,0(r2)
8113f118:	10bfffcc 	andi	r2,r2,65535
8113f11c:	10bfffcc 	andi	r2,r2,65535
8113f120:	10a0001c 	xori	r2,r2,32768
8113f124:	10a00004 	addi	r2,r2,-32768
8113f128:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
8113f12c:	e0bffb17 	ldw	r2,-20(fp)
8113f130:	10ffffcc 	andi	r3,r2,65535
8113f134:	00aa9554 	movui	r2,43605
8113f138:	18804d1e 	bne	r3,r2,8113f270 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113f13c:	e03ffa15 	stw	zero,-24(fp)
8113f140:	00004806 	br	8113f264 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8113f144:	e0bffa17 	ldw	r2,-24(fp)
8113f148:	1004913a 	slli	r2,r2,4
8113f14c:	10806f84 	addi	r2,r2,446
8113f150:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8113f154:	d0a0b217 	ldw	r2,-32056(gp)
8113f158:	10c00a17 	ldw	r3,40(r2)
8113f15c:	e0bffc17 	ldw	r2,-16(fp)
8113f160:	1885883a 	add	r2,r3,r2
8113f164:	10800104 	addi	r2,r2,4
8113f168:	10800023 	ldbuio	r2,0(r2)
8113f16c:	10803fcc 	andi	r2,r2,255
8113f170:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8113f174:	e0bffd07 	ldb	r2,-12(fp)
8113f178:	10800060 	cmpeqi	r2,r2,1
8113f17c:	1000091e 	bne	r2,zero,8113f1a4 <Check_for_Master_Boot_Record+0xc8>
8113f180:	e0bffd07 	ldb	r2,-12(fp)
8113f184:	10800120 	cmpeqi	r2,r2,4
8113f188:	1000061e 	bne	r2,zero,8113f1a4 <Check_for_Master_Boot_Record+0xc8>
8113f18c:	e0bffd07 	ldb	r2,-12(fp)
8113f190:	108001a0 	cmpeqi	r2,r2,6
8113f194:	1000031e 	bne	r2,zero,8113f1a4 <Check_for_Master_Boot_Record+0xc8>
8113f198:	e0bffd07 	ldb	r2,-12(fp)
8113f19c:	10800398 	cmpnei	r2,r2,14
8113f1a0:	10002d1e 	bne	r2,zero,8113f258 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8113f1a4:	d0a0b217 	ldw	r2,-32056(gp)
8113f1a8:	10c00a17 	ldw	r3,40(r2)
8113f1ac:	e0bffc17 	ldw	r2,-16(fp)
8113f1b0:	1885883a 	add	r2,r3,r2
8113f1b4:	10800284 	addi	r2,r2,10
8113f1b8:	1080002b 	ldhuio	r2,0(r2)
8113f1bc:	10bfffcc 	andi	r2,r2,65535
8113f1c0:	1006943a 	slli	r3,r2,16
8113f1c4:	d0a0b217 	ldw	r2,-32056(gp)
8113f1c8:	11000a17 	ldw	r4,40(r2)
8113f1cc:	e0bffc17 	ldw	r2,-16(fp)
8113f1d0:	2085883a 	add	r2,r4,r2
8113f1d4:	10800204 	addi	r2,r2,8
8113f1d8:	1080002b 	ldhuio	r2,0(r2)
8113f1dc:	10bfffcc 	andi	r2,r2,65535
8113f1e0:	10bfffcc 	andi	r2,r2,65535
8113f1e4:	1884b03a 	or	r2,r3,r2
8113f1e8:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
8113f1ec:	d0a0b217 	ldw	r2,-32056(gp)
8113f1f0:	10c00a17 	ldw	r3,40(r2)
8113f1f4:	e0bffc17 	ldw	r2,-16(fp)
8113f1f8:	1885883a 	add	r2,r3,r2
8113f1fc:	10800384 	addi	r2,r2,14
8113f200:	1080002b 	ldhuio	r2,0(r2)
8113f204:	10bfffcc 	andi	r2,r2,65535
8113f208:	1006943a 	slli	r3,r2,16
8113f20c:	d0a0b217 	ldw	r2,-32056(gp)
8113f210:	11000a17 	ldw	r4,40(r2)
8113f214:	e0bffc17 	ldw	r2,-16(fp)
8113f218:	2085883a 	add	r2,r4,r2
8113f21c:	10800304 	addi	r2,r2,12
8113f220:	1080002b 	ldhuio	r2,0(r2)
8113f224:	10bfffcc 	andi	r2,r2,65535
8113f228:	10bfffcc 	andi	r2,r2,65535
8113f22c:	1884b03a 	or	r2,r3,r2
8113f230:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8113f234:	e0bfff17 	ldw	r2,-4(fp)
8113f238:	0080070e 	bge	zero,r2,8113f258 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8113f23c:	00800044 	movi	r2,1
8113f240:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8113f244:	e0bfff17 	ldw	r2,-4(fp)
8113f248:	d0a0b115 	stw	r2,-32060(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8113f24c:	e0bffe17 	ldw	r2,-8(fp)
8113f250:	d0a0b015 	stw	r2,-32064(gp)
						break;
8113f254:	00000606 	br	8113f270 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113f258:	e0bffa17 	ldw	r2,-24(fp)
8113f25c:	10800044 	addi	r2,r2,1
8113f260:	e0bffa15 	stw	r2,-24(fp)
8113f264:	e0bffa17 	ldw	r2,-24(fp)
8113f268:	10800110 	cmplti	r2,r2,4
8113f26c:	103fb51e 	bne	r2,zero,8113f144 <__reset+0xfb11f144>
				}
			}
		}
	}

	return result;
8113f270:	e0bff917 	ldw	r2,-28(fp)
}
8113f274:	e037883a 	mov	sp,fp
8113f278:	dfc00117 	ldw	ra,4(sp)
8113f27c:	df000017 	ldw	fp,0(sp)
8113f280:	dec00204 	addi	sp,sp,8
8113f284:	f800283a 	ret

8113f288 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8113f288:	defff804 	addi	sp,sp,-32
8113f28c:	de00012e 	bgeu	sp,et,8113f294 <Read_File_Record_At_Offset+0xc>
8113f290:	003b68fa 	trap	3
8113f294:	dfc00715 	stw	ra,28(sp)
8113f298:	df000615 	stw	fp,24(sp)
8113f29c:	df000604 	addi	fp,sp,24
8113f2a0:	e13ffc15 	stw	r4,-16(fp)
8113f2a4:	e17ffd15 	stw	r5,-12(fp)
8113f2a8:	e1bffe15 	stw	r6,-8(fp)
8113f2ac:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8113f2b0:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113f2b4:	e0bffc17 	ldw	r2,-16(fp)
8113f2b8:	108007cc 	andi	r2,r2,31
8113f2bc:	10008d1e 	bne	r2,zero,8113f4f4 <Read_File_Record_At_Offset+0x26c>
8113f2c0:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
8113f2c4:	10008b26 	beq	r2,zero,8113f4f4 <Read_File_Record_At_Offset+0x26c>
8113f2c8:	d0a0a917 	ldw	r2,-32092(gp)
8113f2cc:	10008926 	beq	r2,zero,8113f4f4 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113f2d0:	e03ffb15 	stw	zero,-20(fp)
8113f2d4:	00001106 	br	8113f31c <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8113f2d8:	e0fffc17 	ldw	r3,-16(fp)
8113f2dc:	e0bffb17 	ldw	r2,-20(fp)
8113f2e0:	1885883a 	add	r2,r3,r2
8113f2e4:	1007883a 	mov	r3,r2
8113f2e8:	d0a0b217 	ldw	r2,-32056(gp)
8113f2ec:	10800a17 	ldw	r2,40(r2)
8113f2f0:	1885883a 	add	r2,r3,r2
8113f2f4:	10800023 	ldbuio	r2,0(r2)
8113f2f8:	10803fcc 	andi	r2,r2,255
8113f2fc:	1009883a 	mov	r4,r2
8113f300:	e0fffd17 	ldw	r3,-12(fp)
8113f304:	e0bffb17 	ldw	r2,-20(fp)
8113f308:	1885883a 	add	r2,r3,r2
8113f30c:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113f310:	e0bffb17 	ldw	r2,-20(fp)
8113f314:	10800044 	addi	r2,r2,1
8113f318:	e0bffb15 	stw	r2,-20(fp)
8113f31c:	e0bffb17 	ldw	r2,-20(fp)
8113f320:	10800210 	cmplti	r2,r2,8
8113f324:	103fec1e 	bne	r2,zero,8113f2d8 <__reset+0xfb11f2d8>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113f328:	e03ffb15 	stw	zero,-20(fp)
8113f32c:	00001306 	br	8113f37c <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8113f330:	e0fffc17 	ldw	r3,-16(fp)
8113f334:	e0bffb17 	ldw	r2,-20(fp)
8113f338:	1885883a 	add	r2,r3,r2
8113f33c:	1007883a 	mov	r3,r2
8113f340:	d0a0b217 	ldw	r2,-32056(gp)
8113f344:	10800a17 	ldw	r2,40(r2)
8113f348:	1885883a 	add	r2,r3,r2
8113f34c:	10800204 	addi	r2,r2,8
8113f350:	10800023 	ldbuio	r2,0(r2)
8113f354:	10803fcc 	andi	r2,r2,255
8113f358:	1009883a 	mov	r4,r2
8113f35c:	e0fffd17 	ldw	r3,-12(fp)
8113f360:	e0bffb17 	ldw	r2,-20(fp)
8113f364:	1885883a 	add	r2,r3,r2
8113f368:	10800204 	addi	r2,r2,8
8113f36c:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113f370:	e0bffb17 	ldw	r2,-20(fp)
8113f374:	10800044 	addi	r2,r2,1
8113f378:	e0bffb15 	stw	r2,-20(fp)
8113f37c:	e0bffb17 	ldw	r2,-20(fp)
8113f380:	108000d0 	cmplti	r2,r2,3
8113f384:	103fea1e 	bne	r2,zero,8113f330 <__reset+0xfb11f330>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8113f388:	d0a0b217 	ldw	r2,-32056(gp)
8113f38c:	10c00a17 	ldw	r3,40(r2)
8113f390:	e0bffc17 	ldw	r2,-16(fp)
8113f394:	1885883a 	add	r2,r3,r2
8113f398:	108002c4 	addi	r2,r2,11
8113f39c:	10800023 	ldbuio	r2,0(r2)
8113f3a0:	10803fcc 	andi	r2,r2,255
8113f3a4:	1007883a 	mov	r3,r2
8113f3a8:	e0bffd17 	ldw	r2,-12(fp)
8113f3ac:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8113f3b0:	d0a0b217 	ldw	r2,-32056(gp)
8113f3b4:	10c00a17 	ldw	r3,40(r2)
8113f3b8:	e0bffc17 	ldw	r2,-16(fp)
8113f3bc:	1885883a 	add	r2,r3,r2
8113f3c0:	10800384 	addi	r2,r2,14
8113f3c4:	1080002b 	ldhuio	r2,0(r2)
8113f3c8:	10bfffcc 	andi	r2,r2,65535
8113f3cc:	1007883a 	mov	r3,r2
8113f3d0:	e0bffd17 	ldw	r2,-12(fp)
8113f3d4:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8113f3d8:	d0a0b217 	ldw	r2,-32056(gp)
8113f3dc:	10c00a17 	ldw	r3,40(r2)
8113f3e0:	e0bffc17 	ldw	r2,-16(fp)
8113f3e4:	1885883a 	add	r2,r3,r2
8113f3e8:	10800404 	addi	r2,r2,16
8113f3ec:	1080002b 	ldhuio	r2,0(r2)
8113f3f0:	10bfffcc 	andi	r2,r2,65535
8113f3f4:	1007883a 	mov	r3,r2
8113f3f8:	e0bffd17 	ldw	r2,-12(fp)
8113f3fc:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8113f400:	d0a0b217 	ldw	r2,-32056(gp)
8113f404:	10c00a17 	ldw	r3,40(r2)
8113f408:	e0bffc17 	ldw	r2,-16(fp)
8113f40c:	1885883a 	add	r2,r3,r2
8113f410:	10800484 	addi	r2,r2,18
8113f414:	1080002b 	ldhuio	r2,0(r2)
8113f418:	10bfffcc 	andi	r2,r2,65535
8113f41c:	1007883a 	mov	r3,r2
8113f420:	e0bffd17 	ldw	r2,-12(fp)
8113f424:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8113f428:	d0a0b217 	ldw	r2,-32056(gp)
8113f42c:	10c00a17 	ldw	r3,40(r2)
8113f430:	e0bffc17 	ldw	r2,-16(fp)
8113f434:	1885883a 	add	r2,r3,r2
8113f438:	10800584 	addi	r2,r2,22
8113f43c:	1080002b 	ldhuio	r2,0(r2)
8113f440:	10bfffcc 	andi	r2,r2,65535
8113f444:	1007883a 	mov	r3,r2
8113f448:	e0bffd17 	ldw	r2,-12(fp)
8113f44c:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8113f450:	d0a0b217 	ldw	r2,-32056(gp)
8113f454:	10c00a17 	ldw	r3,40(r2)
8113f458:	e0bffc17 	ldw	r2,-16(fp)
8113f45c:	1885883a 	add	r2,r3,r2
8113f460:	10800604 	addi	r2,r2,24
8113f464:	1080002b 	ldhuio	r2,0(r2)
8113f468:	10bfffcc 	andi	r2,r2,65535
8113f46c:	1007883a 	mov	r3,r2
8113f470:	e0bffd17 	ldw	r2,-12(fp)
8113f474:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
8113f478:	d0a0b217 	ldw	r2,-32056(gp)
8113f47c:	10c00a17 	ldw	r3,40(r2)
8113f480:	e0bffc17 	ldw	r2,-16(fp)
8113f484:	1885883a 	add	r2,r3,r2
8113f488:	10800684 	addi	r2,r2,26
8113f48c:	1080002b 	ldhuio	r2,0(r2)
8113f490:	10bfffcc 	andi	r2,r2,65535
8113f494:	1007883a 	mov	r3,r2
8113f498:	e0bffd17 	ldw	r2,-12(fp)
8113f49c:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8113f4a0:	d0a0b217 	ldw	r2,-32056(gp)
8113f4a4:	10c00a17 	ldw	r3,40(r2)
8113f4a8:	e0bffc17 	ldw	r2,-16(fp)
8113f4ac:	1885883a 	add	r2,r3,r2
8113f4b0:	10800704 	addi	r2,r2,28
8113f4b4:	10800037 	ldwio	r2,0(r2)
8113f4b8:	1007883a 	mov	r3,r2
8113f4bc:	e0bffd17 	ldw	r2,-12(fp)
8113f4c0:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8113f4c4:	e0bffd17 	ldw	r2,-12(fp)
8113f4c8:	e0fffe17 	ldw	r3,-8(fp)
8113f4cc:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8113f4d0:	e0bffd17 	ldw	r2,-12(fp)
8113f4d4:	e0ffff17 	ldw	r3,-4(fp)
8113f4d8:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
8113f4dc:	e0bffc17 	ldw	r2,-16(fp)
8113f4e0:	1007883a 	mov	r3,r2
8113f4e4:	e0bffd17 	ldw	r2,-12(fp)
8113f4e8:	10c00c0d 	sth	r3,48(r2)
		result = true;
8113f4ec:	00800044 	movi	r2,1
8113f4f0:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8113f4f4:	e0bffa17 	ldw	r2,-24(fp)
}
8113f4f8:	e037883a 	mov	sp,fp
8113f4fc:	dfc00117 	ldw	ra,4(sp)
8113f500:	df000017 	ldw	fp,0(sp)
8113f504:	dec00204 	addi	sp,sp,8
8113f508:	f800283a 	ret

8113f50c <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
8113f50c:	defff904 	addi	sp,sp,-28
8113f510:	de00012e 	bgeu	sp,et,8113f518 <Write_File_Record_At_Offset+0xc>
8113f514:	003b68fa 	trap	3
8113f518:	dfc00615 	stw	ra,24(sp)
8113f51c:	df000515 	stw	fp,20(sp)
8113f520:	df000504 	addi	fp,sp,20
8113f524:	e13ffe15 	stw	r4,-8(fp)
8113f528:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113f52c:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113f530:	e0bffe17 	ldw	r2,-8(fp)
8113f534:	108007cc 	andi	r2,r2,31
8113f538:	1000931e 	bne	r2,zero,8113f788 <Write_File_Record_At_Offset+0x27c>
8113f53c:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
8113f540:	10009126 	beq	r2,zero,8113f788 <Write_File_Record_At_Offset+0x27c>
8113f544:	d0a0a917 	ldw	r2,-32092(gp)
8113f548:	10008f26 	beq	r2,zero,8113f788 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113f54c:	e03ffc15 	stw	zero,-16(fp)
8113f550:	00001f06 	br	8113f5d0 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8113f554:	e0bffc17 	ldw	r2,-16(fp)
8113f558:	10800044 	addi	r2,r2,1
8113f55c:	e0ffff17 	ldw	r3,-4(fp)
8113f560:	1885883a 	add	r2,r3,r2
8113f564:	10800003 	ldbu	r2,0(r2)
8113f568:	10803fcc 	andi	r2,r2,255
8113f56c:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8113f570:	e0bffd0f 	ldh	r2,-12(fp)
8113f574:	1004923a 	slli	r2,r2,8
8113f578:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8113f57c:	e0ffff17 	ldw	r3,-4(fp)
8113f580:	e0bffc17 	ldw	r2,-16(fp)
8113f584:	1885883a 	add	r2,r3,r2
8113f588:	10800003 	ldbu	r2,0(r2)
8113f58c:	10c03fcc 	andi	r3,r2,255
8113f590:	e0bffd0b 	ldhu	r2,-12(fp)
8113f594:	1884b03a 	or	r2,r3,r2
8113f598:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8113f59c:	e0fffe17 	ldw	r3,-8(fp)
8113f5a0:	e0bffc17 	ldw	r2,-16(fp)
8113f5a4:	1885883a 	add	r2,r3,r2
8113f5a8:	1007883a 	mov	r3,r2
8113f5ac:	d0a0b217 	ldw	r2,-32056(gp)
8113f5b0:	10800a17 	ldw	r2,40(r2)
8113f5b4:	1885883a 	add	r2,r3,r2
8113f5b8:	1007883a 	mov	r3,r2
8113f5bc:	e0bffd0f 	ldh	r2,-12(fp)
8113f5c0:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113f5c4:	e0bffc17 	ldw	r2,-16(fp)
8113f5c8:	10800084 	addi	r2,r2,2
8113f5cc:	e0bffc15 	stw	r2,-16(fp)
8113f5d0:	e0bffc17 	ldw	r2,-16(fp)
8113f5d4:	10800210 	cmplti	r2,r2,8
8113f5d8:	103fde1e 	bne	r2,zero,8113f554 <__reset+0xfb11f554>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113f5dc:	e03ffc15 	stw	zero,-16(fp)
8113f5e0:	00001306 	br	8113f630 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8113f5e4:	e0fffe17 	ldw	r3,-8(fp)
8113f5e8:	e0bffc17 	ldw	r2,-16(fp)
8113f5ec:	1885883a 	add	r2,r3,r2
8113f5f0:	1007883a 	mov	r3,r2
8113f5f4:	d0a0b217 	ldw	r2,-32056(gp)
8113f5f8:	10800a17 	ldw	r2,40(r2)
8113f5fc:	1885883a 	add	r2,r3,r2
8113f600:	10800204 	addi	r2,r2,8
8113f604:	1009883a 	mov	r4,r2
8113f608:	e0ffff17 	ldw	r3,-4(fp)
8113f60c:	e0bffc17 	ldw	r2,-16(fp)
8113f610:	1885883a 	add	r2,r3,r2
8113f614:	10800204 	addi	r2,r2,8
8113f618:	10800003 	ldbu	r2,0(r2)
8113f61c:	10803fcc 	andi	r2,r2,255
8113f620:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113f624:	e0bffc17 	ldw	r2,-16(fp)
8113f628:	10800044 	addi	r2,r2,1
8113f62c:	e0bffc15 	stw	r2,-16(fp)
8113f630:	e0bffc17 	ldw	r2,-16(fp)
8113f634:	108000d0 	cmplti	r2,r2,3
8113f638:	103fea1e 	bne	r2,zero,8113f5e4 <__reset+0xfb11f5e4>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8113f63c:	d0a0b217 	ldw	r2,-32056(gp)
8113f640:	10c00a17 	ldw	r3,40(r2)
8113f644:	e0bffe17 	ldw	r2,-8(fp)
8113f648:	1885883a 	add	r2,r3,r2
8113f64c:	108002c4 	addi	r2,r2,11
8113f650:	1007883a 	mov	r3,r2
8113f654:	e0bfff17 	ldw	r2,-4(fp)
8113f658:	108002c3 	ldbu	r2,11(r2)
8113f65c:	10803fcc 	andi	r2,r2,255
8113f660:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
8113f664:	d0a0b217 	ldw	r2,-32056(gp)
8113f668:	10c00a17 	ldw	r3,40(r2)
8113f66c:	e0bffe17 	ldw	r2,-8(fp)
8113f670:	1885883a 	add	r2,r3,r2
8113f674:	10800384 	addi	r2,r2,14
8113f678:	1007883a 	mov	r3,r2
8113f67c:	e0bfff17 	ldw	r2,-4(fp)
8113f680:	1080030b 	ldhu	r2,12(r2)
8113f684:	10bfffcc 	andi	r2,r2,65535
8113f688:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8113f68c:	d0a0b217 	ldw	r2,-32056(gp)
8113f690:	10c00a17 	ldw	r3,40(r2)
8113f694:	e0bffe17 	ldw	r2,-8(fp)
8113f698:	1885883a 	add	r2,r3,r2
8113f69c:	10800404 	addi	r2,r2,16
8113f6a0:	1007883a 	mov	r3,r2
8113f6a4:	e0bfff17 	ldw	r2,-4(fp)
8113f6a8:	1080038b 	ldhu	r2,14(r2)
8113f6ac:	10bfffcc 	andi	r2,r2,65535
8113f6b0:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
8113f6b4:	d0a0b217 	ldw	r2,-32056(gp)
8113f6b8:	10c00a17 	ldw	r3,40(r2)
8113f6bc:	e0bffe17 	ldw	r2,-8(fp)
8113f6c0:	1885883a 	add	r2,r3,r2
8113f6c4:	10800484 	addi	r2,r2,18
8113f6c8:	1007883a 	mov	r3,r2
8113f6cc:	e0bfff17 	ldw	r2,-4(fp)
8113f6d0:	1080040b 	ldhu	r2,16(r2)
8113f6d4:	10bfffcc 	andi	r2,r2,65535
8113f6d8:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
8113f6dc:	d0a0b217 	ldw	r2,-32056(gp)
8113f6e0:	10c00a17 	ldw	r3,40(r2)
8113f6e4:	e0bffe17 	ldw	r2,-8(fp)
8113f6e8:	1885883a 	add	r2,r3,r2
8113f6ec:	10800584 	addi	r2,r2,22
8113f6f0:	1007883a 	mov	r3,r2
8113f6f4:	e0bfff17 	ldw	r2,-4(fp)
8113f6f8:	1080048b 	ldhu	r2,18(r2)
8113f6fc:	10bfffcc 	andi	r2,r2,65535
8113f700:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
8113f704:	d0a0b217 	ldw	r2,-32056(gp)
8113f708:	10c00a17 	ldw	r3,40(r2)
8113f70c:	e0bffe17 	ldw	r2,-8(fp)
8113f710:	1885883a 	add	r2,r3,r2
8113f714:	10800604 	addi	r2,r2,24
8113f718:	1007883a 	mov	r3,r2
8113f71c:	e0bfff17 	ldw	r2,-4(fp)
8113f720:	1080050b 	ldhu	r2,20(r2)
8113f724:	10bfffcc 	andi	r2,r2,65535
8113f728:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
8113f72c:	d0a0b217 	ldw	r2,-32056(gp)
8113f730:	10c00a17 	ldw	r3,40(r2)
8113f734:	e0bffe17 	ldw	r2,-8(fp)
8113f738:	1885883a 	add	r2,r3,r2
8113f73c:	10800684 	addi	r2,r2,26
8113f740:	1007883a 	mov	r3,r2
8113f744:	e0bfff17 	ldw	r2,-4(fp)
8113f748:	1080058b 	ldhu	r2,22(r2)
8113f74c:	10bfffcc 	andi	r2,r2,65535
8113f750:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
8113f754:	d0a0b217 	ldw	r2,-32056(gp)
8113f758:	10c00a17 	ldw	r3,40(r2)
8113f75c:	e0bffe17 	ldw	r2,-8(fp)
8113f760:	1885883a 	add	r2,r3,r2
8113f764:	10800704 	addi	r2,r2,28
8113f768:	1007883a 	mov	r3,r2
8113f76c:	e0bfff17 	ldw	r2,-4(fp)
8113f770:	10800617 	ldw	r2,24(r2)
8113f774:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
8113f778:	00800044 	movi	r2,1
8113f77c:	d0a0b315 	stw	r2,-32052(gp)
        result = true;
8113f780:	00800044 	movi	r2,1
8113f784:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
8113f788:	e0bffb17 	ldw	r2,-20(fp)
}
8113f78c:	e037883a 	mov	sp,fp
8113f790:	dfc00117 	ldw	ra,4(sp)
8113f794:	df000017 	ldw	fp,0(sp)
8113f798:	dec00204 	addi	sp,sp,8
8113f79c:	f800283a 	ret

8113f7a0 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8113f7a0:	defff904 	addi	sp,sp,-28
8113f7a4:	de00012e 	bgeu	sp,et,8113f7ac <Check_for_DOS_FAT+0xc>
8113f7a8:	003b68fa 	trap	3
8113f7ac:	dfc00615 	stw	ra,24(sp)
8113f7b0:	df000515 	stw	fp,20(sp)
8113f7b4:	df000504 	addi	fp,sp,20
8113f7b8:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8113f7bc:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8113f7c0:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
8113f7c4:	e17fff17 	ldw	r5,-4(fp)
8113f7c8:	0009883a 	mov	r4,zero
8113f7cc:	113ee580 	call	8113ee58 <Read_Sector_Data>
8113f7d0:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
8113f7d4:	d0a0b217 	ldw	r2,-32056(gp)
8113f7d8:	10800a17 	ldw	r2,40(r2)
8113f7dc:	10807f84 	addi	r2,r2,510
8113f7e0:	1080002b 	ldhuio	r2,0(r2)
8113f7e4:	10bfffcc 	andi	r2,r2,65535
8113f7e8:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
8113f7ec:	e0bffe0f 	ldh	r2,-8(fp)
8113f7f0:	10ffffcc 	andi	r3,r2,65535
8113f7f4:	00aa9554 	movui	r2,43605
8113f7f8:	1881841e 	bne	r3,r2,8113fe0c <Check_for_DOS_FAT+0x66c>
8113f7fc:	e0bffb17 	ldw	r2,-20(fp)
8113f800:	10018226 	beq	r2,zero,8113fe0c <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
8113f804:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
8113f808:	d0a0b217 	ldw	r2,-32056(gp)
8113f80c:	10800a17 	ldw	r2,40(r2)
8113f810:	10800023 	ldbuio	r2,0(r2)
8113f814:	10803fcc 	andi	r2,r2,255
8113f818:	1007883a 	mov	r3,r2
8113f81c:	00a045f4 	movhi	r2,33047
8113f820:	10a49104 	addi	r2,r2,-28092
8113f824:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
8113f828:	d0a0b217 	ldw	r2,-32056(gp)
8113f82c:	10800a17 	ldw	r2,40(r2)
8113f830:	10800044 	addi	r2,r2,1
8113f834:	10800023 	ldbuio	r2,0(r2)
8113f838:	10803fcc 	andi	r2,r2,255
8113f83c:	1007883a 	mov	r3,r2
8113f840:	00a045f4 	movhi	r2,33047
8113f844:	10a49104 	addi	r2,r2,-28092
8113f848:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8113f84c:	d0a0b217 	ldw	r2,-32056(gp)
8113f850:	10800a17 	ldw	r2,40(r2)
8113f854:	10800084 	addi	r2,r2,2
8113f858:	10800023 	ldbuio	r2,0(r2)
8113f85c:	10803fcc 	andi	r2,r2,255
8113f860:	1007883a 	mov	r3,r2
8113f864:	00a045f4 	movhi	r2,33047
8113f868:	10a49104 	addi	r2,r2,-28092
8113f86c:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8113f870:	e03ffc15 	stw	zero,-16(fp)
8113f874:	00001106 	br	8113f8bc <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
8113f878:	d0a0b217 	ldw	r2,-32056(gp)
8113f87c:	10c00a17 	ldw	r3,40(r2)
8113f880:	e0bffc17 	ldw	r2,-16(fp)
8113f884:	1885883a 	add	r2,r3,r2
8113f888:	108000c4 	addi	r2,r2,3
8113f88c:	10800023 	ldbuio	r2,0(r2)
8113f890:	10803fcc 	andi	r2,r2,255
8113f894:	1009883a 	mov	r4,r2
8113f898:	00a045f4 	movhi	r2,33047
8113f89c:	10a49104 	addi	r2,r2,-28092
8113f8a0:	e0fffc17 	ldw	r3,-16(fp)
8113f8a4:	10c5883a 	add	r2,r2,r3
8113f8a8:	108000c4 	addi	r2,r2,3
8113f8ac:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8113f8b0:	e0bffc17 	ldw	r2,-16(fp)
8113f8b4:	10800044 	addi	r2,r2,1
8113f8b8:	e0bffc15 	stw	r2,-16(fp)
8113f8bc:	e0bffc17 	ldw	r2,-16(fp)
8113f8c0:	10800210 	cmplti	r2,r2,8
8113f8c4:	103fec1e 	bne	r2,zero,8113f878 <__reset+0xfb11f878>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8113f8c8:	d0a0b217 	ldw	r2,-32056(gp)
8113f8cc:	10800a17 	ldw	r2,40(r2)
8113f8d0:	10800304 	addi	r2,r2,12
8113f8d4:	10800023 	ldbuio	r2,0(r2)
8113f8d8:	10803fcc 	andi	r2,r2,255
8113f8dc:	1004923a 	slli	r2,r2,8
8113f8e0:	1007883a 	mov	r3,r2
8113f8e4:	d0a0b217 	ldw	r2,-32056(gp)
8113f8e8:	10800a17 	ldw	r2,40(r2)
8113f8ec:	108002c4 	addi	r2,r2,11
8113f8f0:	10800023 	ldbuio	r2,0(r2)
8113f8f4:	10803fcc 	andi	r2,r2,255
8113f8f8:	10803fcc 	andi	r2,r2,255
8113f8fc:	1080201c 	xori	r2,r2,128
8113f900:	10bfe004 	addi	r2,r2,-128
8113f904:	1884b03a 	or	r2,r3,r2
8113f908:	1007883a 	mov	r3,r2
8113f90c:	00a045f4 	movhi	r2,33047
8113f910:	10a49104 	addi	r2,r2,-28092
8113f914:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8113f918:	d0a0b217 	ldw	r2,-32056(gp)
8113f91c:	10800a17 	ldw	r2,40(r2)
8113f920:	10800344 	addi	r2,r2,13
8113f924:	10800023 	ldbuio	r2,0(r2)
8113f928:	10803fcc 	andi	r2,r2,255
8113f92c:	1007883a 	mov	r3,r2
8113f930:	00a045f4 	movhi	r2,33047
8113f934:	10a49104 	addi	r2,r2,-28092
8113f938:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8113f93c:	d0a0b217 	ldw	r2,-32056(gp)
8113f940:	10800a17 	ldw	r2,40(r2)
8113f944:	10800384 	addi	r2,r2,14
8113f948:	1080002b 	ldhuio	r2,0(r2)
8113f94c:	10bfffcc 	andi	r2,r2,65535
8113f950:	1007883a 	mov	r3,r2
8113f954:	00a045f4 	movhi	r2,33047
8113f958:	10a49104 	addi	r2,r2,-28092
8113f95c:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8113f960:	d0a0b217 	ldw	r2,-32056(gp)
8113f964:	10800a17 	ldw	r2,40(r2)
8113f968:	10800404 	addi	r2,r2,16
8113f96c:	10800023 	ldbuio	r2,0(r2)
8113f970:	10803fcc 	andi	r2,r2,255
8113f974:	1007883a 	mov	r3,r2
8113f978:	00a045f4 	movhi	r2,33047
8113f97c:	10a49104 	addi	r2,r2,-28092
8113f980:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
8113f984:	d0a0b217 	ldw	r2,-32056(gp)
8113f988:	10800a17 	ldw	r2,40(r2)
8113f98c:	10800484 	addi	r2,r2,18
8113f990:	10800023 	ldbuio	r2,0(r2)
8113f994:	10803fcc 	andi	r2,r2,255
8113f998:	1004923a 	slli	r2,r2,8
8113f99c:	1007883a 	mov	r3,r2
8113f9a0:	d0a0b217 	ldw	r2,-32056(gp)
8113f9a4:	10800a17 	ldw	r2,40(r2)
8113f9a8:	10800444 	addi	r2,r2,17
8113f9ac:	10800023 	ldbuio	r2,0(r2)
8113f9b0:	10803fcc 	andi	r2,r2,255
8113f9b4:	10803fcc 	andi	r2,r2,255
8113f9b8:	1884b03a 	or	r2,r3,r2
8113f9bc:	1007883a 	mov	r3,r2
8113f9c0:	00a045f4 	movhi	r2,33047
8113f9c4:	10a49104 	addi	r2,r2,-28092
8113f9c8:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8113f9cc:	d0a0b217 	ldw	r2,-32056(gp)
8113f9d0:	10800a17 	ldw	r2,40(r2)
8113f9d4:	10800504 	addi	r2,r2,20
8113f9d8:	10800023 	ldbuio	r2,0(r2)
8113f9dc:	10803fcc 	andi	r2,r2,255
8113f9e0:	1004923a 	slli	r2,r2,8
8113f9e4:	1007883a 	mov	r3,r2
8113f9e8:	d0a0b217 	ldw	r2,-32056(gp)
8113f9ec:	10800a17 	ldw	r2,40(r2)
8113f9f0:	108004c4 	addi	r2,r2,19
8113f9f4:	10800023 	ldbuio	r2,0(r2)
8113f9f8:	10803fcc 	andi	r2,r2,255
8113f9fc:	10803fcc 	andi	r2,r2,255
8113fa00:	1884b03a 	or	r2,r3,r2
8113fa04:	1007883a 	mov	r3,r2
8113fa08:	00a045f4 	movhi	r2,33047
8113fa0c:	10a49104 	addi	r2,r2,-28092
8113fa10:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
8113fa14:	d0a0b217 	ldw	r2,-32056(gp)
8113fa18:	10800a17 	ldw	r2,40(r2)
8113fa1c:	10800544 	addi	r2,r2,21
8113fa20:	10800023 	ldbuio	r2,0(r2)
8113fa24:	10803fcc 	andi	r2,r2,255
8113fa28:	1007883a 	mov	r3,r2
8113fa2c:	00a045f4 	movhi	r2,33047
8113fa30:	10a49104 	addi	r2,r2,-28092
8113fa34:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8113fa38:	d0a0b217 	ldw	r2,-32056(gp)
8113fa3c:	10800a17 	ldw	r2,40(r2)
8113fa40:	10800584 	addi	r2,r2,22
8113fa44:	1080002b 	ldhuio	r2,0(r2)
8113fa48:	10bfffcc 	andi	r2,r2,65535
8113fa4c:	1007883a 	mov	r3,r2
8113fa50:	00a045f4 	movhi	r2,33047
8113fa54:	10a49104 	addi	r2,r2,-28092
8113fa58:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8113fa5c:	d0a0b217 	ldw	r2,-32056(gp)
8113fa60:	10800a17 	ldw	r2,40(r2)
8113fa64:	10800604 	addi	r2,r2,24
8113fa68:	1080002b 	ldhuio	r2,0(r2)
8113fa6c:	10bfffcc 	andi	r2,r2,65535
8113fa70:	1007883a 	mov	r3,r2
8113fa74:	00a045f4 	movhi	r2,33047
8113fa78:	10a49104 	addi	r2,r2,-28092
8113fa7c:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8113fa80:	d0a0b217 	ldw	r2,-32056(gp)
8113fa84:	10800a17 	ldw	r2,40(r2)
8113fa88:	10800684 	addi	r2,r2,26
8113fa8c:	1080002b 	ldhuio	r2,0(r2)
8113fa90:	10bfffcc 	andi	r2,r2,65535
8113fa94:	1007883a 	mov	r3,r2
8113fa98:	00a045f4 	movhi	r2,33047
8113fa9c:	10a49104 	addi	r2,r2,-28092
8113faa0:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
8113faa4:	d0a0b217 	ldw	r2,-32056(gp)
8113faa8:	10800a17 	ldw	r2,40(r2)
8113faac:	10800704 	addi	r2,r2,28
8113fab0:	10800037 	ldwio	r2,0(r2)
8113fab4:	1007883a 	mov	r3,r2
8113fab8:	00a045f4 	movhi	r2,33047
8113fabc:	10a49104 	addi	r2,r2,-28092
8113fac0:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
8113fac4:	d0a0b217 	ldw	r2,-32056(gp)
8113fac8:	10800a17 	ldw	r2,40(r2)
8113facc:	10800804 	addi	r2,r2,32
8113fad0:	10800037 	ldwio	r2,0(r2)
8113fad4:	1007883a 	mov	r3,r2
8113fad8:	00a045f4 	movhi	r2,33047
8113fadc:	10a49104 	addi	r2,r2,-28092
8113fae0:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
8113fae4:	d0a0b217 	ldw	r2,-32056(gp)
8113fae8:	10800a17 	ldw	r2,40(r2)
8113faec:	10800904 	addi	r2,r2,36
8113faf0:	10800023 	ldbuio	r2,0(r2)
8113faf4:	10803fcc 	andi	r2,r2,255
8113faf8:	1007883a 	mov	r3,r2
8113fafc:	00a045f4 	movhi	r2,33047
8113fb00:	10a49104 	addi	r2,r2,-28092
8113fb04:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8113fb08:	d0a0b217 	ldw	r2,-32056(gp)
8113fb0c:	10800a17 	ldw	r2,40(r2)
8113fb10:	10800944 	addi	r2,r2,37
8113fb14:	10800023 	ldbuio	r2,0(r2)
8113fb18:	10803fcc 	andi	r2,r2,255
8113fb1c:	1007883a 	mov	r3,r2
8113fb20:	00a045f4 	movhi	r2,33047
8113fb24:	10a49104 	addi	r2,r2,-28092
8113fb28:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
8113fb2c:	d0a0b217 	ldw	r2,-32056(gp)
8113fb30:	10800a17 	ldw	r2,40(r2)
8113fb34:	10800984 	addi	r2,r2,38
8113fb38:	10800023 	ldbuio	r2,0(r2)
8113fb3c:	10803fcc 	andi	r2,r2,255
8113fb40:	1007883a 	mov	r3,r2
8113fb44:	00a045f4 	movhi	r2,33047
8113fb48:	10a49104 	addi	r2,r2,-28092
8113fb4c:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8113fb50:	00a045f4 	movhi	r2,33047
8113fb54:	10a49104 	addi	r2,r2,-28092
8113fb58:	1080040b 	ldhu	r2,16(r2)
8113fb5c:	10ffffcc 	andi	r3,r2,65535
8113fb60:	00a045f4 	movhi	r2,33047
8113fb64:	10a49104 	addi	r2,r2,-28092
8113fb68:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8113fb6c:	00a045f4 	movhi	r2,33047
8113fb70:	10a49104 	addi	r2,r2,-28092
8113fb74:	10c01117 	ldw	r3,68(r2)
8113fb78:	00a045f4 	movhi	r2,33047
8113fb7c:	10a49104 	addi	r2,r2,-28092
8113fb80:	1080068b 	ldhu	r2,26(r2)
8113fb84:	10bfffcc 	andi	r2,r2,65535
8113fb88:	1887883a 	add	r3,r3,r2
8113fb8c:	00a045f4 	movhi	r2,33047
8113fb90:	10a49104 	addi	r2,r2,-28092
8113fb94:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8113fb98:	00a045f4 	movhi	r2,33047
8113fb9c:	10a49104 	addi	r2,r2,-28092
8113fba0:	10c01217 	ldw	r3,72(r2)
8113fba4:	00a045f4 	movhi	r2,33047
8113fba8:	10a49104 	addi	r2,r2,-28092
8113fbac:	1080068b 	ldhu	r2,26(r2)
8113fbb0:	10bfffcc 	andi	r2,r2,65535
8113fbb4:	1887883a 	add	r3,r3,r2
8113fbb8:	00a045f4 	movhi	r2,33047
8113fbbc:	10a49104 	addi	r2,r2,-28092
8113fbc0:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
8113fbc4:	00a045f4 	movhi	r2,33047
8113fbc8:	10a49104 	addi	r2,r2,-28092
8113fbcc:	10c01317 	ldw	r3,76(r2)
8113fbd0:	00a045f4 	movhi	r2,33047
8113fbd4:	10a49104 	addi	r2,r2,-28092
8113fbd8:	1080050b 	ldhu	r2,20(r2)
8113fbdc:	10bfffcc 	andi	r2,r2,65535
8113fbe0:	1008917a 	slli	r4,r2,5
8113fbe4:	00a045f4 	movhi	r2,33047
8113fbe8:	10a49104 	addi	r2,r2,-28092
8113fbec:	1080030b 	ldhu	r2,12(r2)
8113fbf0:	10bfffcc 	andi	r2,r2,65535
8113fbf4:	2085283a 	div	r2,r4,r2
8113fbf8:	1887883a 	add	r3,r3,r2
8113fbfc:	00a045f4 	movhi	r2,33047
8113fc00:	10a49104 	addi	r2,r2,-28092
8113fc04:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8113fc08:	00a045f4 	movhi	r2,33047
8113fc0c:	10a49104 	addi	r2,r2,-28092
8113fc10:	1080058b 	ldhu	r2,22(r2)
8113fc14:	10bfffcc 	andi	r2,r2,65535
8113fc18:	10000b26 	beq	r2,zero,8113fc48 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
8113fc1c:	00a045f4 	movhi	r2,33047
8113fc20:	10a49104 	addi	r2,r2,-28092
8113fc24:	1080058b 	ldhu	r2,22(r2)
8113fc28:	10ffffcc 	andi	r3,r2,65535
8113fc2c:	00a045f4 	movhi	r2,33047
8113fc30:	10a49104 	addi	r2,r2,-28092
8113fc34:	10800383 	ldbu	r2,14(r2)
8113fc38:	10803fcc 	andi	r2,r2,255
8113fc3c:	1885283a 	div	r2,r3,r2
8113fc40:	e0bffd15 	stw	r2,-12(fp)
8113fc44:	00000906 	br	8113fc6c <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8113fc48:	00a045f4 	movhi	r2,33047
8113fc4c:	10a49104 	addi	r2,r2,-28092
8113fc50:	10c00917 	ldw	r3,36(r2)
8113fc54:	00a045f4 	movhi	r2,33047
8113fc58:	10a49104 	addi	r2,r2,-28092
8113fc5c:	10800383 	ldbu	r2,14(r2)
8113fc60:	10803fcc 	andi	r2,r2,255
8113fc64:	1885203a 	divu	r2,r3,r2
8113fc68:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
8113fc6c:	e0bffd17 	ldw	r2,-12(fp)
8113fc70:	1083fdc8 	cmpgei	r2,r2,4087
8113fc74:	1000051e 	bne	r2,zero,8113fc8c <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8113fc78:	00a045f4 	movhi	r2,33047
8113fc7c:	10a49104 	addi	r2,r2,-28092
8113fc80:	00c00304 	movi	r3,12
8113fc84:	10c01085 	stb	r3,66(r2)
8113fc88:	00000c06 	br	8113fcbc <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
8113fc8c:	e0bffd17 	ldw	r2,-12(fp)
8113fc90:	00fffb54 	movui	r3,65517
8113fc94:	18800516 	blt	r3,r2,8113fcac <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8113fc98:	00a045f4 	movhi	r2,33047
8113fc9c:	10a49104 	addi	r2,r2,-28092
8113fca0:	00c00404 	movi	r3,16
8113fca4:	10c01085 	stb	r3,66(r2)
8113fca8:	00000406 	br	8113fcbc <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
8113fcac:	00a045f4 	movhi	r2,33047
8113fcb0:	10a49104 	addi	r2,r2,-28092
8113fcb4:	00c00804 	movi	r3,32
8113fcb8:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
8113fcbc:	e03ffc15 	stw	zero,-16(fp)
8113fcc0:	00001106 	br	8113fd08 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8113fcc4:	d0a0b217 	ldw	r2,-32056(gp)
8113fcc8:	10c00a17 	ldw	r3,40(r2)
8113fccc:	e0bffc17 	ldw	r2,-16(fp)
8113fcd0:	1885883a 	add	r2,r3,r2
8113fcd4:	108009c4 	addi	r2,r2,39
8113fcd8:	10800023 	ldbuio	r2,0(r2)
8113fcdc:	10803fcc 	andi	r2,r2,255
8113fce0:	1009883a 	mov	r4,r2
8113fce4:	00a045f4 	movhi	r2,33047
8113fce8:	10a49104 	addi	r2,r2,-28092
8113fcec:	e0fffc17 	ldw	r3,-16(fp)
8113fcf0:	10c5883a 	add	r2,r2,r3
8113fcf4:	10800ac4 	addi	r2,r2,43
8113fcf8:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
8113fcfc:	e0bffc17 	ldw	r2,-16(fp)
8113fd00:	10800044 	addi	r2,r2,1
8113fd04:	e0bffc15 	stw	r2,-16(fp)
8113fd08:	e0bffc17 	ldw	r2,-16(fp)
8113fd0c:	10800110 	cmplti	r2,r2,4
8113fd10:	103fec1e 	bne	r2,zero,8113fcc4 <__reset+0xfb11fcc4>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113fd14:	e03ffc15 	stw	zero,-16(fp)
8113fd18:	00001106 	br	8113fd60 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
8113fd1c:	d0a0b217 	ldw	r2,-32056(gp)
8113fd20:	10c00a17 	ldw	r3,40(r2)
8113fd24:	e0bffc17 	ldw	r2,-16(fp)
8113fd28:	1885883a 	add	r2,r3,r2
8113fd2c:	10800ac4 	addi	r2,r2,43
8113fd30:	10800023 	ldbuio	r2,0(r2)
8113fd34:	10803fcc 	andi	r2,r2,255
8113fd38:	1009883a 	mov	r4,r2
8113fd3c:	00a045f4 	movhi	r2,33047
8113fd40:	10a49104 	addi	r2,r2,-28092
8113fd44:	e0fffc17 	ldw	r3,-16(fp)
8113fd48:	10c5883a 	add	r2,r2,r3
8113fd4c:	10800bc4 	addi	r2,r2,47
8113fd50:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113fd54:	e0bffc17 	ldw	r2,-16(fp)
8113fd58:	10800044 	addi	r2,r2,1
8113fd5c:	e0bffc15 	stw	r2,-16(fp)
8113fd60:	e0bffc17 	ldw	r2,-16(fp)
8113fd64:	108002d0 	cmplti	r2,r2,11
8113fd68:	103fec1e 	bne	r2,zero,8113fd1c <__reset+0xfb11fd1c>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113fd6c:	e03ffc15 	stw	zero,-16(fp)
8113fd70:	00001106 	br	8113fdb8 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8113fd74:	d0a0b217 	ldw	r2,-32056(gp)
8113fd78:	10c00a17 	ldw	r3,40(r2)
8113fd7c:	e0bffc17 	ldw	r2,-16(fp)
8113fd80:	1885883a 	add	r2,r3,r2
8113fd84:	10800d84 	addi	r2,r2,54
8113fd88:	10800023 	ldbuio	r2,0(r2)
8113fd8c:	10803fcc 	andi	r2,r2,255
8113fd90:	1009883a 	mov	r4,r2
8113fd94:	00a045f4 	movhi	r2,33047
8113fd98:	10a49104 	addi	r2,r2,-28092
8113fd9c:	e0fffc17 	ldw	r3,-16(fp)
8113fda0:	10c5883a 	add	r2,r2,r3
8113fda4:	10800e84 	addi	r2,r2,58
8113fda8:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113fdac:	e0bffc17 	ldw	r2,-16(fp)
8113fdb0:	10800044 	addi	r2,r2,1
8113fdb4:	e0bffc15 	stw	r2,-16(fp)
8113fdb8:	e0bffc17 	ldw	r2,-16(fp)
8113fdbc:	10800210 	cmplti	r2,r2,8
8113fdc0:	103fec1e 	bne	r2,zero,8113fd74 <__reset+0xfb11fd74>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113fdc4:	e03ffc15 	stw	zero,-16(fp)
8113fdc8:	00000a06 	br	8113fdf4 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
8113fdcc:	00a045f4 	movhi	r2,33047
8113fdd0:	10a4a604 	addi	r2,r2,-28008
8113fdd4:	e0fffc17 	ldw	r3,-16(fp)
8113fdd8:	180691ba 	slli	r3,r3,6
8113fddc:	10c5883a 	add	r2,r2,r3
8113fde0:	10800f04 	addi	r2,r2,60
8113fde4:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113fde8:	e0bffc17 	ldw	r2,-16(fp)
8113fdec:	10800044 	addi	r2,r2,1
8113fdf0:	e0bffc15 	stw	r2,-16(fp)
8113fdf4:	e0bffc17 	ldw	r2,-16(fp)
8113fdf8:	10800510 	cmplti	r2,r2,20
8113fdfc:	103ff31e 	bne	r2,zero,8113fdcc <__reset+0xfb11fdcc>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8113fe00:	00800044 	movi	r2,1
8113fe04:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8113fe08:	00000106 	br	8113fe10 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
8113fe0c:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8113fe10:	e0bffb17 	ldw	r2,-20(fp)
}
8113fe14:	e037883a 	mov	sp,fp
8113fe18:	dfc00117 	ldw	ra,4(sp)
8113fe1c:	df000017 	ldw	fp,0(sp)
8113fe20:	dec00204 	addi	sp,sp,8
8113fe24:	f800283a 	ret

8113fe28 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8113fe28:	defffc04 	addi	sp,sp,-16
8113fe2c:	de00012e 	bgeu	sp,et,8113fe34 <Look_for_FAT16+0xc>
8113fe30:	003b68fa 	trap	3
8113fe34:	dfc00315 	stw	ra,12(sp)
8113fe38:	df000215 	stw	fp,8(sp)
8113fe3c:	df000204 	addi	fp,sp,8
	bool result = false;
8113fe40:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8113fe44:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
8113fe48:	10002e26 	beq	r2,zero,8113ff04 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
8113fe4c:	d0a0ac17 	ldw	r2,-32080(gp)
8113fe50:	1080000b 	ldhu	r2,0(r2)
8113fe54:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8113fe58:	d020b015 	stw	zero,-32064(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
8113fe5c:	d020b115 	stw	zero,-32060(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8113fe60:	e0bfff0f 	ldh	r2,-4(fp)
8113fe64:	10002716 	blt	r2,zero,8113ff04 <Look_for_FAT16+0xdc>
8113fe68:	e0bfff0b 	ldhu	r2,-4(fp)
8113fe6c:	10bfffcc 	andi	r2,r2,65535
8113fe70:	1083000c 	andi	r2,r2,3072
8113fe74:	10830020 	cmpeqi	r2,r2,3072
8113fe78:	1000221e 	bne	r2,zero,8113ff04 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
8113fe7c:	e0bfff0b 	ldhu	r2,-4(fp)
8113fe80:	10bfffcc 	andi	r2,r2,65535
8113fe84:	1083000c 	andi	r2,r2,3072
8113fe88:	10810018 	cmpnei	r2,r2,1024
8113fe8c:	1000031e 	bne	r2,zero,8113fe9c <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8113fe90:	0009883a 	mov	r4,zero
8113fe94:	113f7a00 	call	8113f7a0 <Check_for_DOS_FAT>
8113fe98:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
8113fe9c:	e0bfff0b 	ldhu	r2,-4(fp)
8113fea0:	10bfffcc 	andi	r2,r2,65535
8113fea4:	1083000c 	andi	r2,r2,3072
8113fea8:	1000061e 	bne	r2,zero,8113fec4 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
8113feac:	113f0dc0 	call	8113f0dc <Check_for_Master_Boot_Record>
8113feb0:	10000426 	beq	r2,zero,8113fec4 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8113feb4:	d0a0b017 	ldw	r2,-32064(gp)
8113feb8:	1009883a 	mov	r4,r2
8113febc:	113f7a00 	call	8113f7a0 <Check_for_DOS_FAT>
8113fec0:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8113fec4:	e0bffe17 	ldw	r2,-8(fp)
8113fec8:	10800058 	cmpnei	r2,r2,1
8113fecc:	10000d1e 	bne	r2,zero,8113ff04 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8113fed0:	00a045f4 	movhi	r2,33047
8113fed4:	10a49104 	addi	r2,r2,-28092
8113fed8:	10801083 	ldbu	r2,66(r2)
8113fedc:	10803fcc 	andi	r2,r2,255
8113fee0:	10800420 	cmpeqi	r2,r2,16
8113fee4:	1000021e 	bne	r2,zero,8113fef0 <Look_for_FAT16+0xc8>
				{
					result = false;
8113fee8:	e03ffe15 	stw	zero,-8(fp)
8113feec:	00000506 	br	8113ff04 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8113fef0:	00a045f4 	movhi	r2,33047
8113fef4:	10a49104 	addi	r2,r2,-28092
8113fef8:	1080058b 	ldhu	r2,22(r2)
8113fefc:	10bfffcc 	andi	r2,r2,65535
8113ff00:	d0a0b115 	stw	r2,-32060(gp)
				}
			}
		}
	}
	return result;
8113ff04:	e0bffe17 	ldw	r2,-8(fp)
}
8113ff08:	e037883a 	mov	sp,fp
8113ff0c:	dfc00117 	ldw	ra,4(sp)
8113ff10:	df000017 	ldw	fp,0(sp)
8113ff14:	dec00204 	addi	sp,sp,8
8113ff18:	f800283a 	ret

8113ff1c <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
8113ff1c:	defffb04 	addi	sp,sp,-20
8113ff20:	de00012e 	bgeu	sp,et,8113ff28 <filename_to_upper_case+0xc>
8113ff24:	003b68fa 	trap	3
8113ff28:	dfc00415 	stw	ra,16(sp)
8113ff2c:	df000315 	stw	fp,12(sp)
8113ff30:	df000304 	addi	fp,sp,12
8113ff34:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8113ff38:	e13fff17 	ldw	r4,-4(fp)
8113ff3c:	111f1b80 	call	8111f1b8 <strlen>
8113ff40:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8113ff44:	e03ffd15 	stw	zero,-12(fp)
8113ff48:	00001e06 	br	8113ffc4 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
8113ff4c:	e0bffd17 	ldw	r2,-12(fp)
8113ff50:	e0ffff17 	ldw	r3,-4(fp)
8113ff54:	1885883a 	add	r2,r3,r2
8113ff58:	10800003 	ldbu	r2,0(r2)
8113ff5c:	10803fcc 	andi	r2,r2,255
8113ff60:	1080201c 	xori	r2,r2,128
8113ff64:	10bfe004 	addi	r2,r2,-128
8113ff68:	10801850 	cmplti	r2,r2,97
8113ff6c:	1000121e 	bne	r2,zero,8113ffb8 <filename_to_upper_case+0x9c>
8113ff70:	e0bffd17 	ldw	r2,-12(fp)
8113ff74:	e0ffff17 	ldw	r3,-4(fp)
8113ff78:	1885883a 	add	r2,r3,r2
8113ff7c:	10800003 	ldbu	r2,0(r2)
8113ff80:	10803fcc 	andi	r2,r2,255
8113ff84:	1080201c 	xori	r2,r2,128
8113ff88:	10bfe004 	addi	r2,r2,-128
8113ff8c:	10801ec8 	cmpgei	r2,r2,123
8113ff90:	1000091e 	bne	r2,zero,8113ffb8 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8113ff94:	e0bffd17 	ldw	r2,-12(fp)
8113ff98:	e0ffff17 	ldw	r3,-4(fp)
8113ff9c:	1885883a 	add	r2,r3,r2
8113ffa0:	e0fffd17 	ldw	r3,-12(fp)
8113ffa4:	e13fff17 	ldw	r4,-4(fp)
8113ffa8:	20c7883a 	add	r3,r4,r3
8113ffac:	18c00003 	ldbu	r3,0(r3)
8113ffb0:	18fff804 	addi	r3,r3,-32
8113ffb4:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8113ffb8:	e0bffd17 	ldw	r2,-12(fp)
8113ffbc:	10800044 	addi	r2,r2,1
8113ffc0:	e0bffd15 	stw	r2,-12(fp)
8113ffc4:	e0fffd17 	ldw	r3,-12(fp)
8113ffc8:	e0bffe17 	ldw	r2,-8(fp)
8113ffcc:	18bfdf16 	blt	r3,r2,8113ff4c <__reset+0xfb11ff4c>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8113ffd0:	0001883a 	nop
8113ffd4:	e037883a 	mov	sp,fp
8113ffd8:	dfc00117 	ldw	ra,4(sp)
8113ffdc:	df000017 	ldw	fp,0(sp)
8113ffe0:	dec00204 	addi	sp,sp,8
8113ffe4:	f800283a 	ret

8113ffe8 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8113ffe8:	defff804 	addi	sp,sp,-32
8113ffec:	de00012e 	bgeu	sp,et,8113fff4 <check_file_name_for_FAT16_compliance+0xc>
8113fff0:	003b68fa 	trap	3
8113fff4:	dfc00715 	stw	ra,28(sp)
8113fff8:	df000615 	stw	fp,24(sp)
8113fffc:	df000604 	addi	fp,sp,24
81140000:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
81140004:	e13fff17 	ldw	r4,-4(fp)
81140008:	111f1b80 	call	8111f1b8 <strlen>
8114000c:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
81140010:	00bfffc4 	movi	r2,-1
81140014:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
81140018:	00bfffc4 	movi	r2,-1
8114001c:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81140020:	00800044 	movi	r2,1
81140024:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
81140028:	e03ffa15 	stw	zero,-24(fp)
8114002c:	00006d06 	br	811401e4 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
81140030:	e0bffa17 	ldw	r2,-24(fp)
81140034:	e0ffff17 	ldw	r3,-4(fp)
81140038:	1885883a 	add	r2,r3,r2
8114003c:	10800003 	ldbu	r2,0(r2)
81140040:	10803fcc 	andi	r2,r2,255
81140044:	1080201c 	xori	r2,r2,128
81140048:	10bfe004 	addi	r2,r2,-128
8114004c:	10800820 	cmpeqi	r2,r2,32
81140050:	10003e1e 	bne	r2,zero,8114014c <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81140054:	e0bffa17 	ldw	r2,-24(fp)
81140058:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
8114005c:	e0bffb17 	ldw	r2,-20(fp)
81140060:	1880121e 	bne	r3,r2,811400ac <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81140064:	e0bffa17 	ldw	r2,-24(fp)
81140068:	e0ffff17 	ldw	r3,-4(fp)
8114006c:	1885883a 	add	r2,r3,r2
81140070:	10800003 	ldbu	r2,0(r2)
81140074:	10803fcc 	andi	r2,r2,255
81140078:	1080201c 	xori	r2,r2,128
8114007c:	10bfe004 	addi	r2,r2,-128
81140080:	10801720 	cmpeqi	r2,r2,92
81140084:	1000311e 	bne	r2,zero,8114014c <check_file_name_for_FAT16_compliance+0x164>
81140088:	e0bffa17 	ldw	r2,-24(fp)
8114008c:	e0ffff17 	ldw	r3,-4(fp)
81140090:	1885883a 	add	r2,r3,r2
81140094:	10800003 	ldbu	r2,0(r2)
81140098:	10803fcc 	andi	r2,r2,255
8114009c:	1080201c 	xori	r2,r2,128
811400a0:	10bfe004 	addi	r2,r2,-128
811400a4:	10800be0 	cmpeqi	r2,r2,47
811400a8:	1000281e 	bne	r2,zero,8114014c <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811400ac:	e0fffa17 	ldw	r3,-24(fp)
811400b0:	e0bffc17 	ldw	r2,-16(fp)
811400b4:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811400b8:	10800258 	cmpnei	r2,r2,9
811400bc:	1000091e 	bne	r2,zero,811400e4 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811400c0:	e0bffa17 	ldw	r2,-24(fp)
811400c4:	e0ffff17 	ldw	r3,-4(fp)
811400c8:	1885883a 	add	r2,r3,r2
811400cc:	10800003 	ldbu	r2,0(r2)
811400d0:	10803fcc 	andi	r2,r2,255
811400d4:	1080201c 	xori	r2,r2,128
811400d8:	10bfe004 	addi	r2,r2,-128
811400dc:	10800b98 	cmpnei	r2,r2,46
811400e0:	10001a1e 	bne	r2,zero,8114014c <check_file_name_for_FAT16_compliance+0x164>
811400e4:	e0fffb17 	ldw	r3,-20(fp)
811400e8:	e0bffc17 	ldw	r2,-16(fp)
811400ec:	18801926 	beq	r3,r2,81140154 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
811400f0:	e0fffa17 	ldw	r3,-24(fp)
811400f4:	e0bffc17 	ldw	r2,-16(fp)
811400f8:	1885c83a 	sub	r2,r3,r2
811400fc:	10800110 	cmplti	r2,r2,4
81140100:	1000141e 	bne	r2,zero,81140154 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81140104:	e0bffa17 	ldw	r2,-24(fp)
81140108:	e0ffff17 	ldw	r3,-4(fp)
8114010c:	1885883a 	add	r2,r3,r2
81140110:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81140114:	10803fcc 	andi	r2,r2,255
81140118:	1080201c 	xori	r2,r2,128
8114011c:	10bfe004 	addi	r2,r2,-128
81140120:	10801720 	cmpeqi	r2,r2,92
81140124:	10000b1e 	bne	r2,zero,81140154 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81140128:	e0bffa17 	ldw	r2,-24(fp)
8114012c:	e0ffff17 	ldw	r3,-4(fp)
81140130:	1885883a 	add	r2,r3,r2
81140134:	10800003 	ldbu	r2,0(r2)
81140138:	10803fcc 	andi	r2,r2,255
8114013c:	1080201c 	xori	r2,r2,128
81140140:	10bfe004 	addi	r2,r2,-128
81140144:	10800be0 	cmpeqi	r2,r2,47
81140148:	1000021e 	bne	r2,zero,81140154 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
8114014c:	e03ffd15 	stw	zero,-12(fp)
            break;
81140150:	00002706 	br	811401f0 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
81140154:	e0bffa17 	ldw	r2,-24(fp)
81140158:	e0ffff17 	ldw	r3,-4(fp)
8114015c:	1885883a 	add	r2,r3,r2
81140160:	10800003 	ldbu	r2,0(r2)
81140164:	10803fcc 	andi	r2,r2,255
81140168:	1080201c 	xori	r2,r2,128
8114016c:	10bfe004 	addi	r2,r2,-128
81140170:	10801720 	cmpeqi	r2,r2,92
81140174:	1000091e 	bne	r2,zero,8114019c <check_file_name_for_FAT16_compliance+0x1b4>
81140178:	e0bffa17 	ldw	r2,-24(fp)
8114017c:	e0ffff17 	ldw	r3,-4(fp)
81140180:	1885883a 	add	r2,r3,r2
81140184:	10800003 	ldbu	r2,0(r2)
81140188:	10803fcc 	andi	r2,r2,255
8114018c:	1080201c 	xori	r2,r2,128
81140190:	10bfe004 	addi	r2,r2,-128
81140194:	10800bd8 	cmpnei	r2,r2,47
81140198:	1000041e 	bne	r2,zero,811401ac <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
8114019c:	e0bffa17 	ldw	r2,-24(fp)
811401a0:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
811401a4:	e0bffa17 	ldw	r2,-24(fp)
811401a8:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
811401ac:	e0bffa17 	ldw	r2,-24(fp)
811401b0:	e0ffff17 	ldw	r3,-4(fp)
811401b4:	1885883a 	add	r2,r3,r2
811401b8:	10800003 	ldbu	r2,0(r2)
811401bc:	10803fcc 	andi	r2,r2,255
811401c0:	1080201c 	xori	r2,r2,128
811401c4:	10bfe004 	addi	r2,r2,-128
811401c8:	10800b98 	cmpnei	r2,r2,46
811401cc:	1000021e 	bne	r2,zero,811401d8 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
811401d0:	e0bffa17 	ldw	r2,-24(fp)
811401d4:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
811401d8:	e0bffa17 	ldw	r2,-24(fp)
811401dc:	10800044 	addi	r2,r2,1
811401e0:	e0bffa15 	stw	r2,-24(fp)
811401e4:	e0fffa17 	ldw	r3,-24(fp)
811401e8:	e0bffe17 	ldw	r2,-8(fp)
811401ec:	18bf9016 	blt	r3,r2,81140030 <__reset+0xfb120030>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
811401f0:	e0bffe17 	ldw	r2,-8(fp)
811401f4:	10bfffc4 	addi	r2,r2,-1
811401f8:	e0ffff17 	ldw	r3,-4(fp)
811401fc:	1885883a 	add	r2,r3,r2
81140200:	10800003 	ldbu	r2,0(r2)
81140204:	10803fcc 	andi	r2,r2,255
81140208:	1080201c 	xori	r2,r2,128
8114020c:	10bfe004 	addi	r2,r2,-128
81140210:	10801720 	cmpeqi	r2,r2,92
81140214:	10000a1e 	bne	r2,zero,81140240 <check_file_name_for_FAT16_compliance+0x258>
81140218:	e0bffe17 	ldw	r2,-8(fp)
8114021c:	10bfffc4 	addi	r2,r2,-1
81140220:	e0ffff17 	ldw	r3,-4(fp)
81140224:	1885883a 	add	r2,r3,r2
81140228:	10800003 	ldbu	r2,0(r2)
8114022c:	10803fcc 	andi	r2,r2,255
81140230:	1080201c 	xori	r2,r2,128
81140234:	10bfe004 	addi	r2,r2,-128
81140238:	10800bd8 	cmpnei	r2,r2,47
8114023c:	1000011e 	bne	r2,zero,81140244 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
81140240:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
81140244:	e0bffd17 	ldw	r2,-12(fp)
}
81140248:	e037883a 	mov	sp,fp
8114024c:	dfc00117 	ldw	ra,4(sp)
81140250:	df000017 	ldw	fp,0(sp)
81140254:	dec00204 	addi	sp,sp,8
81140258:	f800283a 	ret

8114025c <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8114025c:	defffb04 	addi	sp,sp,-20
81140260:	de00012e 	bgeu	sp,et,81140268 <get_dir_divider_location+0xc>
81140264:	003b68fa 	trap	3
81140268:	dfc00415 	stw	ra,16(sp)
8114026c:	df000315 	stw	fp,12(sp)
81140270:	df000304 	addi	fp,sp,12
81140274:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
81140278:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8114027c:	e13fff17 	ldw	r4,-4(fp)
81140280:	111f1b80 	call	8111f1b8 <strlen>
81140284:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
81140288:	e03ffd15 	stw	zero,-12(fp)
8114028c:	00001506 	br	811402e4 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
81140290:	e0bffd17 	ldw	r2,-12(fp)
81140294:	e0ffff17 	ldw	r3,-4(fp)
81140298:	1885883a 	add	r2,r3,r2
8114029c:	10800003 	ldbu	r2,0(r2)
811402a0:	10803fcc 	andi	r2,r2,255
811402a4:	1080201c 	xori	r2,r2,128
811402a8:	10bfe004 	addi	r2,r2,-128
811402ac:	10801720 	cmpeqi	r2,r2,92
811402b0:	10000f1e 	bne	r2,zero,811402f0 <get_dir_divider_location+0x94>
811402b4:	e0bffd17 	ldw	r2,-12(fp)
811402b8:	e0ffff17 	ldw	r3,-4(fp)
811402bc:	1885883a 	add	r2,r3,r2
811402c0:	10800003 	ldbu	r2,0(r2)
811402c4:	10803fcc 	andi	r2,r2,255
811402c8:	1080201c 	xori	r2,r2,128
811402cc:	10bfe004 	addi	r2,r2,-128
811402d0:	10800be0 	cmpeqi	r2,r2,47
811402d4:	1000061e 	bne	r2,zero,811402f0 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
811402d8:	e0bffd17 	ldw	r2,-12(fp)
811402dc:	10800044 	addi	r2,r2,1
811402e0:	e0bffd15 	stw	r2,-12(fp)
811402e4:	e0fffd17 	ldw	r3,-12(fp)
811402e8:	e0bffe17 	ldw	r2,-8(fp)
811402ec:	18bfe816 	blt	r3,r2,81140290 <__reset+0xfb120290>
        {
            break;
        }
    }
    
    if (index == length)
811402f0:	e0fffd17 	ldw	r3,-12(fp)
811402f4:	e0bffe17 	ldw	r2,-8(fp)
811402f8:	1880021e 	bne	r3,r2,81140304 <get_dir_divider_location+0xa8>
    {
        index = -1;
811402fc:	00bfffc4 	movi	r2,-1
81140300:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
81140304:	e0bffd17 	ldw	r2,-12(fp)
}
81140308:	e037883a 	mov	sp,fp
8114030c:	dfc00117 	ldw	ra,4(sp)
81140310:	df000017 	ldw	fp,0(sp)
81140314:	dec00204 	addi	sp,sp,8
81140318:	f800283a 	ret

8114031c <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
8114031c:	defffa04 	addi	sp,sp,-24
81140320:	de00012e 	bgeu	sp,et,81140328 <match_file_record_to_name_ext+0xc>
81140324:	003b68fa 	trap	3
81140328:	df000515 	stw	fp,20(sp)
8114032c:	df000504 	addi	fp,sp,20
81140330:	e13ffd15 	stw	r4,-12(fp)
81140334:	e17ffe15 	stw	r5,-8(fp)
81140338:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8114033c:	00800044 	movi	r2,1
81140340:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
81140344:	e03ffc15 	stw	zero,-16(fp)
81140348:	00004606 	br	81140464 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8114034c:	e0fffd17 	ldw	r3,-12(fp)
81140350:	e0bffc17 	ldw	r2,-16(fp)
81140354:	1885883a 	add	r2,r3,r2
81140358:	10800003 	ldbu	r2,0(r2)
8114035c:	10803fcc 	andi	r2,r2,255
81140360:	10801870 	cmpltui	r2,r2,97
81140364:	1000101e 	bne	r2,zero,811403a8 <match_file_record_to_name_ext+0x8c>
81140368:	e0fffd17 	ldw	r3,-12(fp)
8114036c:	e0bffc17 	ldw	r2,-16(fp)
81140370:	1885883a 	add	r2,r3,r2
81140374:	10800003 	ldbu	r2,0(r2)
81140378:	10803fcc 	andi	r2,r2,255
8114037c:	10801ee8 	cmpgeui	r2,r2,123
81140380:	1000091e 	bne	r2,zero,811403a8 <match_file_record_to_name_ext+0x8c>
81140384:	e0fffd17 	ldw	r3,-12(fp)
81140388:	e0bffc17 	ldw	r2,-16(fp)
8114038c:	1885883a 	add	r2,r3,r2
81140390:	10800003 	ldbu	r2,0(r2)
81140394:	10bff804 	addi	r2,r2,-32
81140398:	10c03fcc 	andi	r3,r2,255
8114039c:	18c0201c 	xori	r3,r3,128
811403a0:	18ffe004 	addi	r3,r3,-128
811403a4:	00000706 	br	811403c4 <match_file_record_to_name_ext+0xa8>
811403a8:	e0fffd17 	ldw	r3,-12(fp)
811403ac:	e0bffc17 	ldw	r2,-16(fp)
811403b0:	1885883a 	add	r2,r3,r2
811403b4:	10800003 	ldbu	r2,0(r2)
811403b8:	10c03fcc 	andi	r3,r2,255
811403bc:	18c0201c 	xori	r3,r3,128
811403c0:	18ffe004 	addi	r3,r3,-128
811403c4:	e0bffc17 	ldw	r2,-16(fp)
811403c8:	e13ffe17 	ldw	r4,-8(fp)
811403cc:	2085883a 	add	r2,r4,r2
811403d0:	10800003 	ldbu	r2,0(r2)
811403d4:	10803fcc 	andi	r2,r2,255
811403d8:	1080201c 	xori	r2,r2,128
811403dc:	10bfe004 	addi	r2,r2,-128
811403e0:	10801850 	cmplti	r2,r2,97
811403e4:	1000121e 	bne	r2,zero,81140430 <match_file_record_to_name_ext+0x114>
811403e8:	e0bffc17 	ldw	r2,-16(fp)
811403ec:	e13ffe17 	ldw	r4,-8(fp)
811403f0:	2085883a 	add	r2,r4,r2
811403f4:	10800003 	ldbu	r2,0(r2)
811403f8:	10803fcc 	andi	r2,r2,255
811403fc:	1080201c 	xori	r2,r2,128
81140400:	10bfe004 	addi	r2,r2,-128
81140404:	10801ec8 	cmpgei	r2,r2,123
81140408:	1000091e 	bne	r2,zero,81140430 <match_file_record_to_name_ext+0x114>
8114040c:	e0bffc17 	ldw	r2,-16(fp)
81140410:	e13ffe17 	ldw	r4,-8(fp)
81140414:	2085883a 	add	r2,r4,r2
81140418:	10800003 	ldbu	r2,0(r2)
8114041c:	10bff804 	addi	r2,r2,-32
81140420:	10803fcc 	andi	r2,r2,255
81140424:	1080201c 	xori	r2,r2,128
81140428:	10bfe004 	addi	r2,r2,-128
8114042c:	00000706 	br	8114044c <match_file_record_to_name_ext+0x130>
81140430:	e0bffc17 	ldw	r2,-16(fp)
81140434:	e13ffe17 	ldw	r4,-8(fp)
81140438:	2085883a 	add	r2,r4,r2
8114043c:	10800003 	ldbu	r2,0(r2)
81140440:	10803fcc 	andi	r2,r2,255
81140444:	1080201c 	xori	r2,r2,128
81140448:	10bfe004 	addi	r2,r2,-128
8114044c:	18800226 	beq	r3,r2,81140458 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
81140450:	e03ffb15 	stw	zero,-20(fp)
			break;
81140454:	00000606 	br	81140470 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81140458:	e0bffc17 	ldw	r2,-16(fp)
8114045c:	10800044 	addi	r2,r2,1
81140460:	e0bffc15 	stw	r2,-16(fp)
81140464:	e0bffc17 	ldw	r2,-16(fp)
81140468:	10800210 	cmplti	r2,r2,8
8114046c:	103fb71e 	bne	r2,zero,8114034c <__reset+0xfb12034c>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81140470:	e03ffc15 	stw	zero,-16(fp)
81140474:	00004a06 	br	811405a0 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
81140478:	e0fffd17 	ldw	r3,-12(fp)
8114047c:	e0bffc17 	ldw	r2,-16(fp)
81140480:	1885883a 	add	r2,r3,r2
81140484:	10800204 	addi	r2,r2,8
81140488:	10800003 	ldbu	r2,0(r2)
8114048c:	10803fcc 	andi	r2,r2,255
81140490:	10801870 	cmpltui	r2,r2,97
81140494:	1000121e 	bne	r2,zero,811404e0 <match_file_record_to_name_ext+0x1c4>
81140498:	e0fffd17 	ldw	r3,-12(fp)
8114049c:	e0bffc17 	ldw	r2,-16(fp)
811404a0:	1885883a 	add	r2,r3,r2
811404a4:	10800204 	addi	r2,r2,8
811404a8:	10800003 	ldbu	r2,0(r2)
811404ac:	10803fcc 	andi	r2,r2,255
811404b0:	10801ee8 	cmpgeui	r2,r2,123
811404b4:	10000a1e 	bne	r2,zero,811404e0 <match_file_record_to_name_ext+0x1c4>
811404b8:	e0fffd17 	ldw	r3,-12(fp)
811404bc:	e0bffc17 	ldw	r2,-16(fp)
811404c0:	1885883a 	add	r2,r3,r2
811404c4:	10800204 	addi	r2,r2,8
811404c8:	10800003 	ldbu	r2,0(r2)
811404cc:	10bff804 	addi	r2,r2,-32
811404d0:	10c03fcc 	andi	r3,r2,255
811404d4:	18c0201c 	xori	r3,r3,128
811404d8:	18ffe004 	addi	r3,r3,-128
811404dc:	00000806 	br	81140500 <match_file_record_to_name_ext+0x1e4>
811404e0:	e0fffd17 	ldw	r3,-12(fp)
811404e4:	e0bffc17 	ldw	r2,-16(fp)
811404e8:	1885883a 	add	r2,r3,r2
811404ec:	10800204 	addi	r2,r2,8
811404f0:	10800003 	ldbu	r2,0(r2)
811404f4:	10c03fcc 	andi	r3,r2,255
811404f8:	18c0201c 	xori	r3,r3,128
811404fc:	18ffe004 	addi	r3,r3,-128
81140500:	e0bffc17 	ldw	r2,-16(fp)
81140504:	e13fff17 	ldw	r4,-4(fp)
81140508:	2085883a 	add	r2,r4,r2
8114050c:	10800003 	ldbu	r2,0(r2)
81140510:	10803fcc 	andi	r2,r2,255
81140514:	1080201c 	xori	r2,r2,128
81140518:	10bfe004 	addi	r2,r2,-128
8114051c:	10801850 	cmplti	r2,r2,97
81140520:	1000121e 	bne	r2,zero,8114056c <match_file_record_to_name_ext+0x250>
81140524:	e0bffc17 	ldw	r2,-16(fp)
81140528:	e13fff17 	ldw	r4,-4(fp)
8114052c:	2085883a 	add	r2,r4,r2
81140530:	10800003 	ldbu	r2,0(r2)
81140534:	10803fcc 	andi	r2,r2,255
81140538:	1080201c 	xori	r2,r2,128
8114053c:	10bfe004 	addi	r2,r2,-128
81140540:	10801ec8 	cmpgei	r2,r2,123
81140544:	1000091e 	bne	r2,zero,8114056c <match_file_record_to_name_ext+0x250>
81140548:	e0bffc17 	ldw	r2,-16(fp)
8114054c:	e13fff17 	ldw	r4,-4(fp)
81140550:	2085883a 	add	r2,r4,r2
81140554:	10800003 	ldbu	r2,0(r2)
81140558:	10bff804 	addi	r2,r2,-32
8114055c:	10803fcc 	andi	r2,r2,255
81140560:	1080201c 	xori	r2,r2,128
81140564:	10bfe004 	addi	r2,r2,-128
81140568:	00000706 	br	81140588 <match_file_record_to_name_ext+0x26c>
8114056c:	e0bffc17 	ldw	r2,-16(fp)
81140570:	e13fff17 	ldw	r4,-4(fp)
81140574:	2085883a 	add	r2,r4,r2
81140578:	10800003 	ldbu	r2,0(r2)
8114057c:	10803fcc 	andi	r2,r2,255
81140580:	1080201c 	xori	r2,r2,128
81140584:	10bfe004 	addi	r2,r2,-128
81140588:	18800226 	beq	r3,r2,81140594 <match_file_record_to_name_ext+0x278>
        {
            match = false;
8114058c:	e03ffb15 	stw	zero,-20(fp)
			break;
81140590:	00000606 	br	811405ac <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81140594:	e0bffc17 	ldw	r2,-16(fp)
81140598:	10800044 	addi	r2,r2,1
8114059c:	e0bffc15 	stw	r2,-16(fp)
811405a0:	e0bffc17 	ldw	r2,-16(fp)
811405a4:	108000d0 	cmplti	r2,r2,3
811405a8:	103fb31e 	bne	r2,zero,81140478 <__reset+0xfb120478>
        {
            match = false;
			break;
        }
    }
	return match;
811405ac:	e0bffb17 	ldw	r2,-20(fp)
}
811405b0:	e037883a 	mov	sp,fp
811405b4:	df000017 	ldw	fp,0(sp)
811405b8:	dec00104 	addi	sp,sp,4
811405bc:	f800283a 	ret

811405c0 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
811405c0:	deffe704 	addi	sp,sp,-100
811405c4:	de00012e 	bgeu	sp,et,811405cc <get_home_directory_cluster_for_file+0xc>
811405c8:	003b68fa 	trap	3
811405cc:	dfc01815 	stw	ra,96(sp)
811405d0:	df001715 	stw	fp,92(sp)
811405d4:	df001704 	addi	fp,sp,92
811405d8:	e13ffd15 	stw	r4,-12(fp)
811405dc:	e17ffe15 	stw	r5,-8(fp)
811405e0:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
811405e4:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
811405e8:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
811405ec:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
811405f0:	e13ffd17 	ldw	r4,-12(fp)
811405f4:	114025c0 	call	8114025c <get_dir_divider_location>
811405f8:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
811405fc:	00012f06 	br	81140abc <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81140600:	00800804 	movi	r2,32
81140604:	e0bff905 	stb	r2,-28(fp)
81140608:	00800804 	movi	r2,32
8114060c:	e0bff945 	stb	r2,-27(fp)
81140610:	00800804 	movi	r2,32
81140614:	e0bff985 	stb	r2,-26(fp)
81140618:	00800804 	movi	r2,32
8114061c:	e0bff9c5 	stb	r2,-25(fp)
81140620:	00800804 	movi	r2,32
81140624:	e0bffa05 	stb	r2,-24(fp)
81140628:	00800804 	movi	r2,32
8114062c:	e0bffa45 	stb	r2,-23(fp)
81140630:	00800804 	movi	r2,32
81140634:	e0bffa85 	stb	r2,-22(fp)
81140638:	00800804 	movi	r2,32
8114063c:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81140640:	00800804 	movi	r2,32
81140644:	e0bffb05 	stb	r2,-20(fp)
81140648:	00800804 	movi	r2,32
8114064c:	e0bffb45 	stb	r2,-19(fp)
81140650:	00800804 	movi	r2,32
81140654:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81140658:	00bfffc4 	movi	r2,-1
8114065c:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81140660:	e0bfea17 	ldw	r2,-88(fp)
81140664:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81140668:	e03fec15 	stw	zero,-80(fp)
8114066c:	00002d06 	br	81140724 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81140670:	e0ffec17 	ldw	r3,-80(fp)
81140674:	e0bfed17 	ldw	r2,-76(fp)
81140678:	1885883a 	add	r2,r3,r2
8114067c:	1007883a 	mov	r3,r2
81140680:	e0bffd17 	ldw	r2,-12(fp)
81140684:	10c5883a 	add	r2,r2,r3
81140688:	10800003 	ldbu	r2,0(r2)
8114068c:	10803fcc 	andi	r2,r2,255
81140690:	1080201c 	xori	r2,r2,128
81140694:	10bfe004 	addi	r2,r2,-128
81140698:	10800b98 	cmpnei	r2,r2,46
8114069c:	1000031e 	bne	r2,zero,811406ac <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
811406a0:	e0bfec17 	ldw	r2,-80(fp)
811406a4:	e0bfee15 	stw	r2,-72(fp)
811406a8:	00001b06 	br	81140718 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
811406ac:	e0bfee17 	ldw	r2,-72(fp)
811406b0:	10000c0e 	bge	r2,zero,811406e4 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
811406b4:	e0ffec17 	ldw	r3,-80(fp)
811406b8:	e0bfed17 	ldw	r2,-76(fp)
811406bc:	1885883a 	add	r2,r3,r2
811406c0:	1007883a 	mov	r3,r2
811406c4:	e0bffd17 	ldw	r2,-12(fp)
811406c8:	10c5883a 	add	r2,r2,r3
811406cc:	10c00003 	ldbu	r3,0(r2)
811406d0:	e13ff904 	addi	r4,fp,-28
811406d4:	e0bfec17 	ldw	r2,-80(fp)
811406d8:	2085883a 	add	r2,r4,r2
811406dc:	10c00005 	stb	r3,0(r2)
811406e0:	00000d06 	br	81140718 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
811406e4:	e0ffec17 	ldw	r3,-80(fp)
811406e8:	e0bfee17 	ldw	r2,-72(fp)
811406ec:	1885c83a 	sub	r2,r3,r2
811406f0:	e13fec17 	ldw	r4,-80(fp)
811406f4:	e0ffed17 	ldw	r3,-76(fp)
811406f8:	20c7883a 	add	r3,r4,r3
811406fc:	1809883a 	mov	r4,r3
81140700:	e0fffd17 	ldw	r3,-12(fp)
81140704:	1907883a 	add	r3,r3,r4
81140708:	18c00003 	ldbu	r3,0(r3)
8114070c:	e13ffb04 	addi	r4,fp,-20
81140710:	2085883a 	add	r2,r4,r2
81140714:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81140718:	e0bfec17 	ldw	r2,-80(fp)
8114071c:	10800044 	addi	r2,r2,1
81140720:	e0bfec15 	stw	r2,-80(fp)
81140724:	e0ffec17 	ldw	r3,-80(fp)
81140728:	e0bfeb17 	ldw	r2,-84(fp)
8114072c:	18bfd016 	blt	r3,r2,81140670 <__reset+0xfb120670>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81140730:	e0bfea17 	ldw	r2,-88(fp)
81140734:	10005c1e 	bne	r2,zero,811408a8 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81140738:	00a045f4 	movhi	r2,33047
8114073c:	10a49104 	addi	r2,r2,-28092
81140740:	1080050b 	ldhu	r2,20(r2)
81140744:	10bfffcc 	andi	r2,r2,65535
81140748:	1006917a 	slli	r3,r2,5
8114074c:	00a045f4 	movhi	r2,33047
81140750:	10a49104 	addi	r2,r2,-28092
81140754:	1080030b 	ldhu	r2,12(r2)
81140758:	10bfffcc 	andi	r2,r2,65535
8114075c:	1885283a 	div	r2,r3,r2
81140760:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81140764:	e03ff015 	stw	zero,-64(fp)
81140768:	00003b06 	br	81140858 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8114076c:	00a045f4 	movhi	r2,33047
81140770:	10a49104 	addi	r2,r2,-28092
81140774:	10c01317 	ldw	r3,76(r2)
81140778:	e0bff017 	ldw	r2,-64(fp)
8114077c:	1885883a 	add	r2,r3,r2
81140780:	1007883a 	mov	r3,r2
81140784:	d0a0b017 	ldw	r2,-32064(gp)
81140788:	100b883a 	mov	r5,r2
8114078c:	1809883a 	mov	r4,r3
81140790:	113ee580 	call	8113ee58 <Read_Sector_Data>
81140794:	10003426 	beq	r2,zero,81140868 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81140798:	e03ff115 	stw	zero,-60(fp)
8114079c:	00002506 	br	81140834 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
811407a0:	e0bff117 	ldw	r2,-60(fp)
811407a4:	1004917a 	slli	r2,r2,5
811407a8:	e0fff017 	ldw	r3,-64(fp)
811407ac:	180f883a 	mov	r7,r3
811407b0:	000d883a 	mov	r6,zero
811407b4:	e17fff17 	ldw	r5,-4(fp)
811407b8:	1009883a 	mov	r4,r2
811407bc:	113f2880 	call	8113f288 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
811407c0:	e0bfff17 	ldw	r2,-4(fp)
811407c4:	10800003 	ldbu	r2,0(r2)
811407c8:	10803fcc 	andi	r2,r2,255
811407cc:	10803960 	cmpeqi	r2,r2,229
811407d0:	1000151e 	bne	r2,zero,81140828 <get_home_directory_cluster_for_file+0x268>
811407d4:	e0bfff17 	ldw	r2,-4(fp)
811407d8:	10800003 	ldbu	r2,0(r2)
811407dc:	10803fcc 	andi	r2,r2,255
811407e0:	10001126 	beq	r2,zero,81140828 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
811407e4:	e0fffb04 	addi	r3,fp,-20
811407e8:	e0bff904 	addi	r2,fp,-28
811407ec:	180d883a 	mov	r6,r3
811407f0:	100b883a 	mov	r5,r2
811407f4:	e13fff17 	ldw	r4,-4(fp)
811407f8:	114031c0 	call	8114031c <match_file_record_to_name_ext>
811407fc:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81140800:	e0bff817 	ldw	r2,-32(fp)
81140804:	10000826 	beq	r2,zero,81140828 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81140808:	e0bfff17 	ldw	r2,-4(fp)
8114080c:	1080058b 	ldhu	r2,22(r2)
81140810:	10bfffcc 	andi	r2,r2,65535
81140814:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81140818:	e0bfff17 	ldw	r2,-4(fp)
8114081c:	00c00044 	movi	r3,1
81140820:	10c00a15 	stw	r3,40(r2)
                                break;
81140824:	00000606 	br	81140840 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81140828:	e0bff117 	ldw	r2,-60(fp)
8114082c:	10800044 	addi	r2,r2,1
81140830:	e0bff115 	stw	r2,-60(fp)
81140834:	e0bff117 	ldw	r2,-60(fp)
81140838:	10800410 	cmplti	r2,r2,16
8114083c:	103fd81e 	bne	r2,zero,811407a0 <__reset+0xfb1207a0>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81140840:	e0ffef17 	ldw	r3,-68(fp)
81140844:	e0bfea17 	ldw	r2,-88(fp)
81140848:	1880091e 	bne	r3,r2,81140870 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8114084c:	e0bff017 	ldw	r2,-64(fp)
81140850:	10800044 	addi	r2,r2,1
81140854:	e0bff015 	stw	r2,-64(fp)
81140858:	e0fff017 	ldw	r3,-64(fp)
8114085c:	e0bff717 	ldw	r2,-36(fp)
81140860:	18bfc216 	blt	r3,r2,8114076c <__reset+0xfb12076c>
81140864:	00000306 	br	81140874 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81140868:	0001883a 	nop
8114086c:	00000106 	br	81140874 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81140870:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81140874:	e0ffef17 	ldw	r3,-68(fp)
81140878:	e0bfea17 	ldw	r2,-88(fp)
8114087c:	18800826 	beq	r3,r2,811408a0 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81140880:	e0bfef17 	ldw	r2,-68(fp)
81140884:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81140888:	e0ffed17 	ldw	r3,-76(fp)
8114088c:	e0bfeb17 	ldw	r2,-84(fp)
81140890:	1885883a 	add	r2,r3,r2
81140894:	10800044 	addi	r2,r2,1
81140898:	e0bfed15 	stw	r2,-76(fp)
8114089c:	00007d06 	br	81140a94 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
811408a0:	0005883a 	mov	r2,zero
811408a4:	00009106 	br	81140aec <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
811408a8:	e0bfea17 	ldw	r2,-88(fp)
811408ac:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811408b0:	e0bff417 	ldw	r2,-48(fp)
811408b4:	10ffff84 	addi	r3,r2,-2
811408b8:	00a045f4 	movhi	r2,33047
811408bc:	10a49104 	addi	r2,r2,-28092
811408c0:	10800383 	ldbu	r2,14(r2)
811408c4:	10803fcc 	andi	r2,r2,255
811408c8:	1885383a 	mul	r2,r3,r2
811408cc:	1007883a 	mov	r3,r2
811408d0:	00a045f4 	movhi	r2,33047
811408d4:	10a49104 	addi	r2,r2,-28092
811408d8:	10801417 	ldw	r2,80(r2)
811408dc:	1885883a 	add	r2,r3,r2
811408e0:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811408e4:	e03ff215 	stw	zero,-56(fp)
811408e8:	00003606 	br	811409c4 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811408ec:	e0fff217 	ldw	r3,-56(fp)
811408f0:	e0bff517 	ldw	r2,-44(fp)
811408f4:	1885883a 	add	r2,r3,r2
811408f8:	d0e0b017 	ldw	r3,-32064(gp)
811408fc:	180b883a 	mov	r5,r3
81140900:	1009883a 	mov	r4,r2
81140904:	113ee580 	call	8113ee58 <Read_Sector_Data>
81140908:	10003526 	beq	r2,zero,811409e0 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8114090c:	e03ff315 	stw	zero,-52(fp)
81140910:	00002306 	br	811409a0 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81140914:	e0bff317 	ldw	r2,-52(fp)
81140918:	1004917a 	slli	r2,r2,5
8114091c:	e0fff417 	ldw	r3,-48(fp)
81140920:	e13ff217 	ldw	r4,-56(fp)
81140924:	200f883a 	mov	r7,r4
81140928:	180d883a 	mov	r6,r3
8114092c:	e17fff17 	ldw	r5,-4(fp)
81140930:	1009883a 	mov	r4,r2
81140934:	113f2880 	call	8113f288 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81140938:	e0bfff17 	ldw	r2,-4(fp)
8114093c:	10800003 	ldbu	r2,0(r2)
81140940:	10803fcc 	andi	r2,r2,255
81140944:	10803960 	cmpeqi	r2,r2,229
81140948:	1000121e 	bne	r2,zero,81140994 <get_home_directory_cluster_for_file+0x3d4>
8114094c:	e0bfff17 	ldw	r2,-4(fp)
81140950:	10800003 	ldbu	r2,0(r2)
81140954:	10803fcc 	andi	r2,r2,255
81140958:	10000e26 	beq	r2,zero,81140994 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8114095c:	e0fffb04 	addi	r3,fp,-20
81140960:	e0bff904 	addi	r2,fp,-28
81140964:	180d883a 	mov	r6,r3
81140968:	100b883a 	mov	r5,r2
8114096c:	e13fff17 	ldw	r4,-4(fp)
81140970:	114031c0 	call	8114031c <match_file_record_to_name_ext>
81140974:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81140978:	e0bff617 	ldw	r2,-40(fp)
8114097c:	10000526 	beq	r2,zero,81140994 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81140980:	e0bfff17 	ldw	r2,-4(fp)
81140984:	1080058b 	ldhu	r2,22(r2)
81140988:	10bfffcc 	andi	r2,r2,65535
8114098c:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81140990:	00000606 	br	811409ac <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81140994:	e0bff317 	ldw	r2,-52(fp)
81140998:	10800044 	addi	r2,r2,1
8114099c:	e0bff315 	stw	r2,-52(fp)
811409a0:	e0bff317 	ldw	r2,-52(fp)
811409a4:	10800410 	cmplti	r2,r2,16
811409a8:	103fda1e 	bne	r2,zero,81140914 <__reset+0xfb120914>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
811409ac:	e0ffef17 	ldw	r3,-68(fp)
811409b0:	e0bfea17 	ldw	r2,-88(fp)
811409b4:	18800c1e 	bne	r3,r2,811409e8 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811409b8:	e0bff217 	ldw	r2,-56(fp)
811409bc:	10800044 	addi	r2,r2,1
811409c0:	e0bff215 	stw	r2,-56(fp)
811409c4:	00a045f4 	movhi	r2,33047
811409c8:	10a49104 	addi	r2,r2,-28092
811409cc:	10800383 	ldbu	r2,14(r2)
811409d0:	10803fcc 	andi	r2,r2,255
811409d4:	e0fff217 	ldw	r3,-56(fp)
811409d8:	18bfc416 	blt	r3,r2,811408ec <__reset+0xfb1208ec>
811409dc:	00000306 	br	811409ec <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
811409e0:	0001883a 	nop
811409e4:	00000106 	br	811409ec <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
811409e8:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
811409ec:	e0ffef17 	ldw	r3,-68(fp)
811409f0:	e0bfea17 	ldw	r2,-88(fp)
811409f4:	1880141e 	bne	r3,r2,81140a48 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
811409f8:	e0bfef17 	ldw	r2,-68(fp)
811409fc:	e0fffc04 	addi	r3,fp,-16
81140a00:	180b883a 	mov	r5,r3
81140a04:	1009883a 	mov	r4,r2
81140a08:	113ef380 	call	8113ef38 <get_cluster_flag>
81140a0c:	10000c26 	beq	r2,zero,81140a40 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81140a10:	e0bffc0b 	ldhu	r2,-16(fp)
81140a14:	10bfffcc 	andi	r2,r2,65535
81140a18:	10fffe0c 	andi	r3,r2,65528
81140a1c:	00bffe14 	movui	r2,65528
81140a20:	1880021e 	bne	r3,r2,81140a2c <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81140a24:	0005883a 	mov	r2,zero
81140a28:	00003006 	br	81140aec <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81140a2c:	e0bffc0b 	ldhu	r2,-16(fp)
81140a30:	10bfffcc 	andi	r2,r2,65535
81140a34:	10bffe0c 	andi	r2,r2,65528
81140a38:	e0bfef15 	stw	r2,-68(fp)
81140a3c:	00000206 	br	81140a48 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81140a40:	0005883a 	mov	r2,zero
81140a44:	00002906 	br	81140aec <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81140a48:	e0bff417 	ldw	r2,-48(fp)
81140a4c:	00fffdd4 	movui	r3,65527
81140a50:	18800316 	blt	r3,r2,81140a60 <get_home_directory_cluster_for_file+0x4a0>
81140a54:	e0ffef17 	ldw	r3,-68(fp)
81140a58:	e0bfea17 	ldw	r2,-88(fp)
81140a5c:	18bf9426 	beq	r3,r2,811408b0 <__reset+0xfb1208b0>
            if (new_cluster != home_dir_cluster)
81140a60:	e0ffef17 	ldw	r3,-68(fp)
81140a64:	e0bfea17 	ldw	r2,-88(fp)
81140a68:	18800826 	beq	r3,r2,81140a8c <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81140a6c:	e0bfef17 	ldw	r2,-68(fp)
81140a70:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81140a74:	e0ffed17 	ldw	r3,-76(fp)
81140a78:	e0bfeb17 	ldw	r2,-84(fp)
81140a7c:	1885883a 	add	r2,r3,r2
81140a80:	10800044 	addi	r2,r2,1
81140a84:	e0bfed15 	stw	r2,-76(fp)
81140a88:	00000206 	br	81140a94 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81140a8c:	0005883a 	mov	r2,zero
81140a90:	00001606 	br	81140aec <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81140a94:	e0bfed17 	ldw	r2,-76(fp)
81140a98:	e0fffd17 	ldw	r3,-12(fp)
81140a9c:	1885883a 	add	r2,r3,r2
81140aa0:	1009883a 	mov	r4,r2
81140aa4:	114025c0 	call	8114025c <get_dir_divider_location>
81140aa8:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81140aac:	e0bfeb17 	ldw	r2,-84(fp)
81140ab0:	1000020e 	bge	r2,zero,81140abc <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81140ab4:	00800044 	movi	r2,1
81140ab8:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81140abc:	e0bfeb17 	ldw	r2,-84(fp)
81140ac0:	00becf16 	blt	zero,r2,81140600 <__reset+0xfb120600>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81140ac4:	e0bffe17 	ldw	r2,-8(fp)
81140ac8:	e0ffea17 	ldw	r3,-88(fp)
81140acc:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81140ad0:	e0bfea17 	ldw	r2,-88(fp)
81140ad4:	1000041e 	bne	r2,zero,81140ae8 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81140ad8:	e0bfff17 	ldw	r2,-4(fp)
81140adc:	10000a15 	stw	zero,40(r2)
		result = true;
81140ae0:	00800044 	movi	r2,1
81140ae4:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
81140ae8:	e0bfe917 	ldw	r2,-92(fp)
}
81140aec:	e037883a 	mov	sp,fp
81140af0:	dfc00117 	ldw	ra,4(sp)
81140af4:	df000017 	ldw	fp,0(sp)
81140af8:	dec00204 	addi	sp,sp,8
81140afc:	f800283a 	ret

81140b00 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81140b00:	deffe804 	addi	sp,sp,-96
81140b04:	de00012e 	bgeu	sp,et,81140b0c <find_file_in_directory+0xc>
81140b08:	003b68fa 	trap	3
81140b0c:	dfc01715 	stw	ra,92(sp)
81140b10:	df001615 	stw	fp,88(sp)
81140b14:	df001604 	addi	fp,sp,88
81140b18:	e13ffd15 	stw	r4,-12(fp)
81140b1c:	e17ffe15 	stw	r5,-8(fp)
81140b20:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81140b24:	e13ffe17 	ldw	r4,-8(fp)
81140b28:	114025c0 	call	8114025c <get_dir_divider_location>
81140b2c:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81140b30:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81140b34:	00800804 	movi	r2,32
81140b38:	e0bff905 	stb	r2,-28(fp)
81140b3c:	00800804 	movi	r2,32
81140b40:	e0bff945 	stb	r2,-27(fp)
81140b44:	00800804 	movi	r2,32
81140b48:	e0bff985 	stb	r2,-26(fp)
81140b4c:	00800804 	movi	r2,32
81140b50:	e0bff9c5 	stb	r2,-25(fp)
81140b54:	00800804 	movi	r2,32
81140b58:	e0bffa05 	stb	r2,-24(fp)
81140b5c:	00800804 	movi	r2,32
81140b60:	e0bffa45 	stb	r2,-23(fp)
81140b64:	00800804 	movi	r2,32
81140b68:	e0bffa85 	stb	r2,-22(fp)
81140b6c:	00800804 	movi	r2,32
81140b70:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81140b74:	00800804 	movi	r2,32
81140b78:	e0bffb05 	stb	r2,-20(fp)
81140b7c:	00800804 	movi	r2,32
81140b80:	e0bffb45 	stb	r2,-19(fp)
81140b84:	00800804 	movi	r2,32
81140b88:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81140b8c:	00bfffc4 	movi	r2,-1
81140b90:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81140b94:	e0bffd17 	ldw	r2,-12(fp)
81140b98:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81140b9c:	e13ffe17 	ldw	r4,-8(fp)
81140ba0:	111f1b80 	call	8111f1b8 <strlen>
81140ba4:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81140ba8:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81140bac:	00000b06 	br	81140bdc <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81140bb0:	e0ffeb17 	ldw	r3,-84(fp)
81140bb4:	e0bfea17 	ldw	r2,-88(fp)
81140bb8:	1885883a 	add	r2,r3,r2
81140bbc:	10800044 	addi	r2,r2,1
81140bc0:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81140bc4:	e0bfeb17 	ldw	r2,-84(fp)
81140bc8:	e0fffe17 	ldw	r3,-8(fp)
81140bcc:	1885883a 	add	r2,r3,r2
81140bd0:	1009883a 	mov	r4,r2
81140bd4:	114025c0 	call	8114025c <get_dir_divider_location>
81140bd8:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81140bdc:	e0bfea17 	ldw	r2,-88(fp)
81140be0:	00bff316 	blt	zero,r2,81140bb0 <__reset+0xfb120bb0>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81140be4:	e0bfeb17 	ldw	r2,-84(fp)
81140be8:	e0bfee15 	stw	r2,-72(fp)
81140bec:	00002706 	br	81140c8c <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
81140bf0:	e0bfee17 	ldw	r2,-72(fp)
81140bf4:	e0fffe17 	ldw	r3,-8(fp)
81140bf8:	1885883a 	add	r2,r3,r2
81140bfc:	10800003 	ldbu	r2,0(r2)
81140c00:	10803fcc 	andi	r2,r2,255
81140c04:	1080201c 	xori	r2,r2,128
81140c08:	10bfe004 	addi	r2,r2,-128
81140c0c:	10800b98 	cmpnei	r2,r2,46
81140c10:	1000031e 	bne	r2,zero,81140c20 <find_file_in_directory+0x120>
        {
            ext_index = index;
81140c14:	e0bfee17 	ldw	r2,-72(fp)
81140c18:	e0bfec15 	stw	r2,-80(fp)
81140c1c:	00001806 	br	81140c80 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81140c20:	e0bfec17 	ldw	r2,-80(fp)
81140c24:	10000b0e 	bge	r2,zero,81140c54 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81140c28:	e0ffee17 	ldw	r3,-72(fp)
81140c2c:	e0bfeb17 	ldw	r2,-84(fp)
81140c30:	1885c83a 	sub	r2,r3,r2
81140c34:	e0ffee17 	ldw	r3,-72(fp)
81140c38:	e13ffe17 	ldw	r4,-8(fp)
81140c3c:	20c7883a 	add	r3,r4,r3
81140c40:	18c00003 	ldbu	r3,0(r3)
81140c44:	e13ff904 	addi	r4,fp,-28
81140c48:	2085883a 	add	r2,r4,r2
81140c4c:	10c00005 	stb	r3,0(r2)
81140c50:	00000b06 	br	81140c80 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81140c54:	e0ffee17 	ldw	r3,-72(fp)
81140c58:	e0bfec17 	ldw	r2,-80(fp)
81140c5c:	1885c83a 	sub	r2,r3,r2
81140c60:	10bfffc4 	addi	r2,r2,-1
81140c64:	e0ffee17 	ldw	r3,-72(fp)
81140c68:	e13ffe17 	ldw	r4,-8(fp)
81140c6c:	20c7883a 	add	r3,r4,r3
81140c70:	18c00003 	ldbu	r3,0(r3)
81140c74:	e13ffb04 	addi	r4,fp,-20
81140c78:	2085883a 	add	r2,r4,r2
81140c7c:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81140c80:	e0bfee17 	ldw	r2,-72(fp)
81140c84:	10800044 	addi	r2,r2,1
81140c88:	e0bfee15 	stw	r2,-72(fp)
81140c8c:	e0ffee17 	ldw	r3,-72(fp)
81140c90:	e0bff417 	ldw	r2,-48(fp)
81140c94:	18bfd616 	blt	r3,r2,81140bf0 <__reset+0xfb120bf0>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
81140c98:	e0bffd17 	ldw	r2,-12(fp)
81140c9c:	1000461e 	bne	r2,zero,81140db8 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81140ca0:	00a045f4 	movhi	r2,33047
81140ca4:	10a49104 	addi	r2,r2,-28092
81140ca8:	1080050b 	ldhu	r2,20(r2)
81140cac:	10bfffcc 	andi	r2,r2,65535
81140cb0:	1006917a 	slli	r3,r2,5
81140cb4:	00a045f4 	movhi	r2,33047
81140cb8:	10a49104 	addi	r2,r2,-28092
81140cbc:	1080030b 	ldhu	r2,12(r2)
81140cc0:	10bfffcc 	andi	r2,r2,65535
81140cc4:	1885283a 	div	r2,r3,r2
81140cc8:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81140ccc:	e03ff015 	stw	zero,-64(fp)
81140cd0:	00003506 	br	81140da8 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81140cd4:	00a045f4 	movhi	r2,33047
81140cd8:	10a49104 	addi	r2,r2,-28092
81140cdc:	10c01317 	ldw	r3,76(r2)
81140ce0:	e0bff017 	ldw	r2,-64(fp)
81140ce4:	1885883a 	add	r2,r3,r2
81140ce8:	1007883a 	mov	r3,r2
81140cec:	d0a0b017 	ldw	r2,-32064(gp)
81140cf0:	100b883a 	mov	r5,r2
81140cf4:	1809883a 	mov	r4,r3
81140cf8:	113ee580 	call	8113ee58 <Read_Sector_Data>
81140cfc:	10009626 	beq	r2,zero,81140f58 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81140d00:	e03ff115 	stw	zero,-60(fp)
81140d04:	00002006 	br	81140d88 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81140d08:	e0bff117 	ldw	r2,-60(fp)
81140d0c:	1004917a 	slli	r2,r2,5
81140d10:	e0fff017 	ldw	r3,-64(fp)
81140d14:	180f883a 	mov	r7,r3
81140d18:	000d883a 	mov	r6,zero
81140d1c:	e17fff17 	ldw	r5,-4(fp)
81140d20:	1009883a 	mov	r4,r2
81140d24:	113f2880 	call	8113f288 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81140d28:	e0bfff17 	ldw	r2,-4(fp)
81140d2c:	10800003 	ldbu	r2,0(r2)
81140d30:	10803fcc 	andi	r2,r2,255
81140d34:	10803960 	cmpeqi	r2,r2,229
81140d38:	1000101e 	bne	r2,zero,81140d7c <find_file_in_directory+0x27c>
81140d3c:	e0bfff17 	ldw	r2,-4(fp)
81140d40:	10800003 	ldbu	r2,0(r2)
81140d44:	10803fcc 	andi	r2,r2,255
81140d48:	10000c26 	beq	r2,zero,81140d7c <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81140d4c:	e0fffb04 	addi	r3,fp,-20
81140d50:	e0bff904 	addi	r2,fp,-28
81140d54:	180d883a 	mov	r6,r3
81140d58:	100b883a 	mov	r5,r2
81140d5c:	e13fff17 	ldw	r4,-4(fp)
81140d60:	114031c0 	call	8114031c <match_file_record_to_name_ext>
81140d64:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81140d68:	e0bff817 	ldw	r2,-32(fp)
81140d6c:	10000326 	beq	r2,zero,81140d7c <find_file_in_directory+0x27c>
                        {
                            result = true;
81140d70:	00800044 	movi	r2,1
81140d74:	e0bfef15 	stw	r2,-68(fp)
                            break;
81140d78:	00000606 	br	81140d94 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81140d7c:	e0bff117 	ldw	r2,-60(fp)
81140d80:	10800044 	addi	r2,r2,1
81140d84:	e0bff115 	stw	r2,-60(fp)
81140d88:	e0bff117 	ldw	r2,-60(fp)
81140d8c:	10800410 	cmplti	r2,r2,16
81140d90:	103fdd1e 	bne	r2,zero,81140d08 <__reset+0xfb120d08>
            }
            else
            {
                break;
            }
            if (result)
81140d94:	e0bfef17 	ldw	r2,-68(fp)
81140d98:	1000711e 	bne	r2,zero,81140f60 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81140d9c:	e0bff017 	ldw	r2,-64(fp)
81140da0:	10800044 	addi	r2,r2,1
81140da4:	e0bff015 	stw	r2,-64(fp)
81140da8:	e0fff017 	ldw	r3,-64(fp)
81140dac:	e0bff717 	ldw	r2,-36(fp)
81140db0:	18bfc816 	blt	r3,r2,81140cd4 <__reset+0xfb120cd4>
81140db4:	00006b06 	br	81140f64 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81140db8:	e0bfed17 	ldw	r2,-76(fp)
81140dbc:	10ffff84 	addi	r3,r2,-2
81140dc0:	00a045f4 	movhi	r2,33047
81140dc4:	10a49104 	addi	r2,r2,-28092
81140dc8:	10800383 	ldbu	r2,14(r2)
81140dcc:	10803fcc 	andi	r2,r2,255
81140dd0:	1885383a 	mul	r2,r3,r2
81140dd4:	1007883a 	mov	r3,r2
81140dd8:	00a045f4 	movhi	r2,33047
81140ddc:	10a49104 	addi	r2,r2,-28092
81140de0:	10801417 	ldw	r2,80(r2)
81140de4:	1885883a 	add	r2,r3,r2
81140de8:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81140dec:	e03ff215 	stw	zero,-56(fp)
81140df0:	00003306 	br	81140ec0 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81140df4:	e0fff217 	ldw	r3,-56(fp)
81140df8:	e0bff517 	ldw	r2,-44(fp)
81140dfc:	1885883a 	add	r2,r3,r2
81140e00:	d0e0b017 	ldw	r3,-32064(gp)
81140e04:	180b883a 	mov	r5,r3
81140e08:	1009883a 	mov	r4,r2
81140e0c:	113ee580 	call	8113ee58 <Read_Sector_Data>
81140e10:	10003226 	beq	r2,zero,81140edc <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81140e14:	e03ff315 	stw	zero,-52(fp)
81140e18:	00002106 	br	81140ea0 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81140e1c:	e0bff317 	ldw	r2,-52(fp)
81140e20:	1004917a 	slli	r2,r2,5
81140e24:	e0ffed17 	ldw	r3,-76(fp)
81140e28:	e13ff217 	ldw	r4,-56(fp)
81140e2c:	200f883a 	mov	r7,r4
81140e30:	180d883a 	mov	r6,r3
81140e34:	e17fff17 	ldw	r5,-4(fp)
81140e38:	1009883a 	mov	r4,r2
81140e3c:	113f2880 	call	8113f288 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81140e40:	e0bfff17 	ldw	r2,-4(fp)
81140e44:	10800003 	ldbu	r2,0(r2)
81140e48:	10803fcc 	andi	r2,r2,255
81140e4c:	10803960 	cmpeqi	r2,r2,229
81140e50:	1000101e 	bne	r2,zero,81140e94 <find_file_in_directory+0x394>
81140e54:	e0bfff17 	ldw	r2,-4(fp)
81140e58:	10800003 	ldbu	r2,0(r2)
81140e5c:	10803fcc 	andi	r2,r2,255
81140e60:	10000c26 	beq	r2,zero,81140e94 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81140e64:	e0fffb04 	addi	r3,fp,-20
81140e68:	e0bff904 	addi	r2,fp,-28
81140e6c:	180d883a 	mov	r6,r3
81140e70:	100b883a 	mov	r5,r2
81140e74:	e13fff17 	ldw	r4,-4(fp)
81140e78:	114031c0 	call	8114031c <match_file_record_to_name_ext>
81140e7c:	e0bff615 	stw	r2,-40(fp)

                            if (match)
81140e80:	e0bff617 	ldw	r2,-40(fp)
81140e84:	10000326 	beq	r2,zero,81140e94 <find_file_in_directory+0x394>
                            {                               
                                result = true;
81140e88:	00800044 	movi	r2,1
81140e8c:	e0bfef15 	stw	r2,-68(fp)
                                break;
81140e90:	00000606 	br	81140eac <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81140e94:	e0bff317 	ldw	r2,-52(fp)
81140e98:	10800044 	addi	r2,r2,1
81140e9c:	e0bff315 	stw	r2,-52(fp)
81140ea0:	e0bff317 	ldw	r2,-52(fp)
81140ea4:	10800410 	cmplti	r2,r2,16
81140ea8:	103fdc1e 	bne	r2,zero,81140e1c <__reset+0xfb120e1c>
                }
                else
                {
                    break;
                }
                if (result)
81140eac:	e0bfef17 	ldw	r2,-68(fp)
81140eb0:	10000c1e 	bne	r2,zero,81140ee4 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81140eb4:	e0bff217 	ldw	r2,-56(fp)
81140eb8:	10800044 	addi	r2,r2,1
81140ebc:	e0bff215 	stw	r2,-56(fp)
81140ec0:	00a045f4 	movhi	r2,33047
81140ec4:	10a49104 	addi	r2,r2,-28092
81140ec8:	10800383 	ldbu	r2,14(r2)
81140ecc:	10803fcc 	andi	r2,r2,255
81140ed0:	e0fff217 	ldw	r3,-56(fp)
81140ed4:	18bfc716 	blt	r3,r2,81140df4 <__reset+0xfb120df4>
81140ed8:	00000306 	br	81140ee8 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81140edc:	0001883a 	nop
81140ee0:	00000106 	br	81140ee8 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
81140ee4:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81140ee8:	e0bfef17 	ldw	r2,-68(fp)
81140eec:	1000141e 	bne	r2,zero,81140f40 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
81140ef0:	e0bfed17 	ldw	r2,-76(fp)
81140ef4:	e0fffc04 	addi	r3,fp,-16
81140ef8:	180b883a 	mov	r5,r3
81140efc:	1009883a 	mov	r4,r2
81140f00:	113ef380 	call	8113ef38 <get_cluster_flag>
81140f04:	10000c26 	beq	r2,zero,81140f38 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81140f08:	e0bffc0b 	ldhu	r2,-16(fp)
81140f0c:	10bfffcc 	andi	r2,r2,65535
81140f10:	10fffe0c 	andi	r3,r2,65528
81140f14:	00bffe14 	movui	r2,65528
81140f18:	1880021e 	bne	r3,r2,81140f24 <find_file_in_directory+0x424>
					{
						return false;
81140f1c:	0005883a 	mov	r2,zero
81140f20:	00001106 	br	81140f68 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81140f24:	e0bffc0b 	ldhu	r2,-16(fp)
81140f28:	10bfffcc 	andi	r2,r2,65535
81140f2c:	10bffe0c 	andi	r2,r2,65528
81140f30:	e0bfed15 	stw	r2,-76(fp)
81140f34:	00000206 	br	81140f40 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
81140f38:	0005883a 	mov	r2,zero
81140f3c:	00000a06 	br	81140f68 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81140f40:	e0bfed17 	ldw	r2,-76(fp)
81140f44:	00fffdd4 	movui	r3,65527
81140f48:	18800616 	blt	r3,r2,81140f64 <find_file_in_directory+0x464>
81140f4c:	e0bfef17 	ldw	r2,-68(fp)
81140f50:	103f9926 	beq	r2,zero,81140db8 <__reset+0xfb120db8>
81140f54:	00000306 	br	81140f64 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
81140f58:	0001883a 	nop
81140f5c:	00000106 	br	81140f64 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
81140f60:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
81140f64:	e0bfef17 	ldw	r2,-68(fp)
}
81140f68:	e037883a 	mov	sp,fp
81140f6c:	dfc00117 	ldw	ra,4(sp)
81140f70:	df000017 	ldw	fp,0(sp)
81140f74:	dec00204 	addi	sp,sp,8
81140f78:	f800283a 	ret

81140f7c <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81140f7c:	defff504 	addi	sp,sp,-44
81140f80:	de00012e 	bgeu	sp,et,81140f88 <find_first_empty_cluster+0xc>
81140f84:	003b68fa 	trap	3
81140f88:	dfc00a15 	stw	ra,40(sp)
81140f8c:	df000915 	stw	fp,36(sp)
81140f90:	df000904 	addi	fp,sp,36
81140f94:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
81140f98:	00a045f4 	movhi	r2,33047
81140f9c:	10a49104 	addi	r2,r2,-28092
81140fa0:	10801117 	ldw	r2,68(r2)
81140fa4:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
81140fa8:	00800084 	movi	r2,2
81140fac:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
81140fb0:	00bfffc4 	movi	r2,-1
81140fb4:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
81140fb8:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
81140fbc:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
81140fc0:	00a045f4 	movhi	r2,33047
81140fc4:	10a49104 	addi	r2,r2,-28092
81140fc8:	10801417 	ldw	r2,80(r2)
81140fcc:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
81140fd0:	00a045f4 	movhi	r2,33047
81140fd4:	10a49104 	addi	r2,r2,-28092
81140fd8:	1080058b 	ldhu	r2,22(r2)
81140fdc:	10bfffcc 	andi	r2,r2,65535
81140fe0:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
81140fe4:	00a045f4 	movhi	r2,33047
81140fe8:	10a49104 	addi	r2,r2,-28092
81140fec:	10800917 	ldw	r2,36(r2)
81140ff0:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
81140ff4:	e0bffd17 	ldw	r2,-12(fp)
81140ff8:	e0fffe17 	ldw	r3,-8(fp)
81140ffc:	18800b2e 	bgeu	r3,r2,8114102c <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81141000:	e0fffd17 	ldw	r3,-12(fp)
81141004:	e0bffc17 	ldw	r2,-16(fp)
81141008:	1887c83a 	sub	r3,r3,r2
8114100c:	00a045f4 	movhi	r2,33047
81141010:	10a49104 	addi	r2,r2,-28092
81141014:	10800383 	ldbu	r2,14(r2)
81141018:	10803fcc 	andi	r2,r2,255
8114101c:	1885203a 	divu	r2,r3,r2
81141020:	10800044 	addi	r2,r2,1
81141024:	e0bffb15 	stw	r2,-20(fp)
81141028:	00002a06 	br	811410d4 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8114102c:	e0fffe17 	ldw	r3,-8(fp)
81141030:	e0bffc17 	ldw	r2,-16(fp)
81141034:	1887c83a 	sub	r3,r3,r2
81141038:	00a045f4 	movhi	r2,33047
8114103c:	10a49104 	addi	r2,r2,-28092
81141040:	10800383 	ldbu	r2,14(r2)
81141044:	10803fcc 	andi	r2,r2,255
81141048:	1885203a 	divu	r2,r3,r2
8114104c:	10800044 	addi	r2,r2,1
81141050:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81141054:	00001f06 	br	811410d4 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
81141058:	e0bff717 	ldw	r2,-36(fp)
8114105c:	d0e0b017 	ldw	r3,-32064(gp)
81141060:	180b883a 	mov	r5,r3
81141064:	1009883a 	mov	r4,r2
81141068:	113ee580 	call	8113ee58 <Read_Sector_Data>
8114106c:	10001426 	beq	r2,zero,811410c0 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
81141070:	e0bff817 	ldw	r2,-32(fp)
81141074:	10803fcc 	andi	r2,r2,255
81141078:	1085883a 	add	r2,r2,r2
8114107c:	1007883a 	mov	r3,r2
81141080:	d0a0b217 	ldw	r2,-32056(gp)
81141084:	10800a17 	ldw	r2,40(r2)
81141088:	1885883a 	add	r2,r3,r2
8114108c:	1080002b 	ldhuio	r2,0(r2)
81141090:	10bfffcc 	andi	r2,r2,65535
81141094:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
81141098:	e0bff90f 	ldh	r2,-28(fp)
8114109c:	10000726 	beq	r2,zero,811410bc <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
811410a0:	e0bff817 	ldw	r2,-32(fp)
811410a4:	10800044 	addi	r2,r2,1
811410a8:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
811410ac:	e0bff817 	ldw	r2,-32(fp)
811410b0:	10803fcc 	andi	r2,r2,255
811410b4:	103fee1e 	bne	r2,zero,81141070 <__reset+0xfb121070>
811410b8:	00000106 	br	811410c0 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
811410bc:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
811410c0:	e0bff90f 	ldh	r2,-28(fp)
811410c4:	10000926 	beq	r2,zero,811410ec <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
811410c8:	e0bff717 	ldw	r2,-36(fp)
811410cc:	10800044 	addi	r2,r2,1
811410d0:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811410d4:	00a045f4 	movhi	r2,33047
811410d8:	10a49104 	addi	r2,r2,-28092
811410dc:	10c01217 	ldw	r3,72(r2)
811410e0:	e0bff717 	ldw	r2,-36(fp)
811410e4:	18bfdc1e 	bne	r3,r2,81141058 <__reset+0xfb121058>
811410e8:	00000106 	br	811410f0 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
811410ec:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
811410f0:	e0bff90f 	ldh	r2,-28(fp)
811410f4:	1000081e 	bne	r2,zero,81141118 <find_first_empty_cluster+0x19c>
811410f8:	e0bff90f 	ldh	r2,-28(fp)
811410fc:	e0fffb17 	ldw	r3,-20(fp)
81141100:	18800536 	bltu	r3,r2,81141118 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
81141104:	e0bfff17 	ldw	r2,-4(fp)
81141108:	e0fff817 	ldw	r3,-32(fp)
8114110c:	10c00015 	stw	r3,0(r2)
		result = true;
81141110:	00800044 	movi	r2,1
81141114:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
81141118:	e0bffa17 	ldw	r2,-24(fp)
}
8114111c:	e037883a 	mov	sp,fp
81141120:	dfc00117 	ldw	ra,4(sp)
81141124:	df000017 	ldw	fp,0(sp)
81141128:	dec00204 	addi	sp,sp,8
8114112c:	f800283a 	ret

81141130 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
81141130:	defff604 	addi	sp,sp,-40
81141134:	de00012e 	bgeu	sp,et,8114113c <find_first_empty_record_in_a_subdirectory+0xc>
81141138:	003b68fa 	trap	3
8114113c:	dfc00915 	stw	ra,36(sp)
81141140:	df000815 	stw	fp,32(sp)
81141144:	df000804 	addi	fp,sp,32
81141148:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
8114114c:	00bfffc4 	movi	r2,-1
81141150:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
81141154:	e0bfff17 	ldw	r2,-4(fp)
81141158:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8114115c:	e0bff917 	ldw	r2,-28(fp)
81141160:	10ffff84 	addi	r3,r2,-2
81141164:	00a045f4 	movhi	r2,33047
81141168:	10a49104 	addi	r2,r2,-28092
8114116c:	10800383 	ldbu	r2,14(r2)
81141170:	10803fcc 	andi	r2,r2,255
81141174:	1885383a 	mul	r2,r3,r2
81141178:	1007883a 	mov	r3,r2
8114117c:	00a045f4 	movhi	r2,33047
81141180:	10a49104 	addi	r2,r2,-28092
81141184:	10801417 	ldw	r2,80(r2)
81141188:	1885883a 	add	r2,r3,r2
8114118c:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81141190:	e03ffa15 	stw	zero,-24(fp)
81141194:	00002c06 	br	81141248 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81141198:	e0fffa17 	ldw	r3,-24(fp)
8114119c:	e0bffc17 	ldw	r2,-16(fp)
811411a0:	1885883a 	add	r2,r3,r2
811411a4:	d0e0b017 	ldw	r3,-32064(gp)
811411a8:	180b883a 	mov	r5,r3
811411ac:	1009883a 	mov	r4,r2
811411b0:	113ee580 	call	8113ee58 <Read_Sector_Data>
811411b4:	10002b26 	beq	r2,zero,81141264 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811411b8:	e03ffb15 	stw	zero,-20(fp)
811411bc:	00001c06 	br	81141230 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811411c0:	e0bffb17 	ldw	r2,-20(fp)
811411c4:	1004917a 	slli	r2,r2,5
811411c8:	1007883a 	mov	r3,r2
811411cc:	d0a0b217 	ldw	r2,-32056(gp)
811411d0:	10800a17 	ldw	r2,40(r2)
811411d4:	1885883a 	add	r2,r3,r2
811411d8:	10800023 	ldbuio	r2,0(r2)
811411dc:	10803fcc 	andi	r2,r2,255
811411e0:	10803fcc 	andi	r2,r2,255
811411e4:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
811411e8:	e0bffd0b 	ldhu	r2,-12(fp)
811411ec:	10803960 	cmpeqi	r2,r2,229
811411f0:	1000021e 	bne	r2,zero,811411fc <find_first_empty_record_in_a_subdirectory+0xcc>
811411f4:	e0bffd0b 	ldhu	r2,-12(fp)
811411f8:	10000a1e 	bne	r2,zero,81141224 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
811411fc:	e0bffa17 	ldw	r2,-24(fp)
81141200:	1006913a 	slli	r3,r2,4
81141204:	e0bffb17 	ldw	r2,-20(fp)
81141208:	1885883a 	add	r2,r3,r2
8114120c:	1006943a 	slli	r3,r2,16
81141210:	e0bff917 	ldw	r2,-28(fp)
81141214:	1884b03a 	or	r2,r3,r2
81141218:	e0bff815 	stw	r2,-32(fp)
                        return result;
8114121c:	e0bff817 	ldw	r2,-32(fp)
81141220:	00005306 	br	81141370 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81141224:	e0bffb17 	ldw	r2,-20(fp)
81141228:	10800044 	addi	r2,r2,1
8114122c:	e0bffb15 	stw	r2,-20(fp)
81141230:	e0bffb17 	ldw	r2,-20(fp)
81141234:	10800410 	cmplti	r2,r2,16
81141238:	103fe11e 	bne	r2,zero,811411c0 <__reset+0xfb1211c0>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114123c:	e0bffa17 	ldw	r2,-24(fp)
81141240:	10800044 	addi	r2,r2,1
81141244:	e0bffa15 	stw	r2,-24(fp)
81141248:	00a045f4 	movhi	r2,33047
8114124c:	10a49104 	addi	r2,r2,-28092
81141250:	10800383 	ldbu	r2,14(r2)
81141254:	10803fcc 	andi	r2,r2,255
81141258:	e0fffa17 	ldw	r3,-24(fp)
8114125c:	18bfce16 	blt	r3,r2,81141198 <__reset+0xfb121198>
81141260:	00000106 	br	81141268 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
81141264:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
81141268:	e0bff817 	ldw	r2,-32(fp)
8114126c:	1000390e 	bge	r2,zero,81141354 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
81141270:	e0bff917 	ldw	r2,-28(fp)
81141274:	e0fffd84 	addi	r3,fp,-10
81141278:	180b883a 	mov	r5,r3
8114127c:	1009883a 	mov	r4,r2
81141280:	113ef380 	call	8113ef38 <get_cluster_flag>
81141284:	10003126 	beq	r2,zero,8114134c <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81141288:	e0bffd8b 	ldhu	r2,-10(fp)
8114128c:	10bfffcc 	andi	r2,r2,65535
81141290:	10fffe0c 	andi	r3,r2,65528
81141294:	00bffe14 	movui	r2,65528
81141298:	18802e1e 	bne	r3,r2,81141354 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8114129c:	e0bffe04 	addi	r2,fp,-8
811412a0:	1009883a 	mov	r4,r2
811412a4:	1140f7c0 	call	81140f7c <find_first_empty_cluster>
811412a8:	10002326 	beq	r2,zero,81141338 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811412ac:	e0bff917 	ldw	r2,-28(fp)
811412b0:	e0fffe17 	ldw	r3,-8(fp)
811412b4:	18ffffcc 	andi	r3,r3,65535
811412b8:	18e0001c 	xori	r3,r3,32768
811412bc:	18e00004 	addi	r3,r3,-32768
811412c0:	01800044 	movi	r6,1
811412c4:	180b883a 	mov	r5,r3
811412c8:	1009883a 	mov	r4,r2
811412cc:	113eff40 	call	8113eff4 <mark_cluster>
811412d0:	10001926 	beq	r2,zero,81141338 <find_first_empty_record_in_a_subdirectory+0x208>
811412d4:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811412d8:	01800044 	movi	r6,1
811412dc:	017fffc4 	movi	r5,-1
811412e0:	1009883a 	mov	r4,r2
811412e4:	113eff40 	call	8113eff4 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811412e8:	10001326 	beq	r2,zero,81141338 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811412ec:	e0bff917 	ldw	r2,-28(fp)
811412f0:	e0fffe17 	ldw	r3,-8(fp)
811412f4:	18ffffcc 	andi	r3,r3,65535
811412f8:	18e0001c 	xori	r3,r3,32768
811412fc:	18e00004 	addi	r3,r3,-32768
81141300:	000d883a 	mov	r6,zero
81141304:	180b883a 	mov	r5,r3
81141308:	1009883a 	mov	r4,r2
8114130c:	113eff40 	call	8113eff4 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81141310:	10000926 	beq	r2,zero,81141338 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81141314:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
81141318:	000d883a 	mov	r6,zero
8114131c:	017fffc4 	movi	r5,-1
81141320:	1009883a 	mov	r4,r2
81141324:	113eff40 	call	8113eff4 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81141328:	10000326 	beq	r2,zero,81141338 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
8114132c:	113ee040 	call	8113ee04 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
81141330:	e0bffe17 	ldw	r2,-8(fp)
81141334:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
81141338:	e0bffd8b 	ldhu	r2,-10(fp)
8114133c:	10bfffcc 	andi	r2,r2,65535
81141340:	10bffe0c 	andi	r2,r2,65528
81141344:	e0bff915 	stw	r2,-28(fp)
81141348:	00000206 	br	81141354 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8114134c:	00bfffc4 	movi	r2,-1
81141350:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
81141354:	e0bff917 	ldw	r2,-28(fp)
81141358:	00fffdd4 	movui	r3,65527
8114135c:	18800316 	blt	r3,r2,8114136c <find_first_empty_record_in_a_subdirectory+0x23c>
81141360:	e0bff817 	ldw	r2,-32(fp)
81141364:	10bfffe0 	cmpeqi	r2,r2,-1
81141368:	103f7c1e 	bne	r2,zero,8114115c <__reset+0xfb12115c>
    return result; 
8114136c:	e0bff817 	ldw	r2,-32(fp)
}
81141370:	e037883a 	mov	sp,fp
81141374:	dfc00117 	ldw	ra,4(sp)
81141378:	df000017 	ldw	fp,0(sp)
8114137c:	dec00204 	addi	sp,sp,8
81141380:	f800283a 	ret

81141384 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
81141384:	defff904 	addi	sp,sp,-28
81141388:	de00012e 	bgeu	sp,et,81141390 <find_first_empty_record_in_root_directory+0xc>
8114138c:	003b68fa 	trap	3
81141390:	dfc00615 	stw	ra,24(sp)
81141394:	df000515 	stw	fp,20(sp)
81141398:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8114139c:	00a045f4 	movhi	r2,33047
811413a0:	10a49104 	addi	r2,r2,-28092
811413a4:	1080050b 	ldhu	r2,20(r2)
811413a8:	10bfffcc 	andi	r2,r2,65535
811413ac:	1006917a 	slli	r3,r2,5
811413b0:	00a045f4 	movhi	r2,33047
811413b4:	10a49104 	addi	r2,r2,-28092
811413b8:	1080030b 	ldhu	r2,12(r2)
811413bc:	10bfffcc 	andi	r2,r2,65535
811413c0:	1885283a 	div	r2,r3,r2
811413c4:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
811413c8:	00bfffc4 	movi	r2,-1
811413cc:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811413d0:	e03ffb15 	stw	zero,-20(fp)
811413d4:	00002d06 	br	8114148c <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811413d8:	00a045f4 	movhi	r2,33047
811413dc:	10a49104 	addi	r2,r2,-28092
811413e0:	10c01317 	ldw	r3,76(r2)
811413e4:	e0bffb17 	ldw	r2,-20(fp)
811413e8:	1885883a 	add	r2,r3,r2
811413ec:	1007883a 	mov	r3,r2
811413f0:	d0a0b017 	ldw	r2,-32064(gp)
811413f4:	100b883a 	mov	r5,r2
811413f8:	1809883a 	mov	r4,r3
811413fc:	113ee580 	call	8113ee58 <Read_Sector_Data>
81141400:	10002626 	beq	r2,zero,8114149c <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81141404:	e03ffc15 	stw	zero,-16(fp)
81141408:	00001a06 	br	81141474 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8114140c:	e0bffc17 	ldw	r2,-16(fp)
81141410:	1004917a 	slli	r2,r2,5
81141414:	1007883a 	mov	r3,r2
81141418:	d0a0b217 	ldw	r2,-32056(gp)
8114141c:	10800a17 	ldw	r2,40(r2)
81141420:	1885883a 	add	r2,r3,r2
81141424:	10800023 	ldbuio	r2,0(r2)
81141428:	10803fcc 	andi	r2,r2,255
8114142c:	10803fcc 	andi	r2,r2,255
81141430:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
81141434:	e0bfff0b 	ldhu	r2,-4(fp)
81141438:	10803960 	cmpeqi	r2,r2,229
8114143c:	1000021e 	bne	r2,zero,81141448 <find_first_empty_record_in_root_directory+0xc4>
81141440:	e0bfff0b 	ldhu	r2,-4(fp)
81141444:	1000081e 	bne	r2,zero,81141468 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81141448:	e0bffb17 	ldw	r2,-20(fp)
8114144c:	1006913a 	slli	r3,r2,4
81141450:	e0bffc17 	ldw	r2,-16(fp)
81141454:	1885883a 	add	r2,r3,r2
81141458:	1004943a 	slli	r2,r2,16
8114145c:	e0bffe15 	stw	r2,-8(fp)
                    return result;
81141460:	e0bffe17 	ldw	r2,-8(fp)
81141464:	00000f06 	br	811414a4 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81141468:	e0bffc17 	ldw	r2,-16(fp)
8114146c:	10800044 	addi	r2,r2,1
81141470:	e0bffc15 	stw	r2,-16(fp)
81141474:	e0bffc17 	ldw	r2,-16(fp)
81141478:	10800410 	cmplti	r2,r2,16
8114147c:	103fe31e 	bne	r2,zero,8114140c <__reset+0xfb12140c>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81141480:	e0bffb17 	ldw	r2,-20(fp)
81141484:	10800044 	addi	r2,r2,1
81141488:	e0bffb15 	stw	r2,-20(fp)
8114148c:	e0fffb17 	ldw	r3,-20(fp)
81141490:	e0bffd17 	ldw	r2,-12(fp)
81141494:	18bfd016 	blt	r3,r2,811413d8 <__reset+0xfb1213d8>
81141498:	00000106 	br	811414a0 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8114149c:	0001883a 	nop
        }
    }
    return result;
811414a0:	e0bffe17 	ldw	r2,-8(fp)
}
811414a4:	e037883a 	mov	sp,fp
811414a8:	dfc00117 	ldw	ra,4(sp)
811414ac:	df000017 	ldw	fp,0(sp)
811414b0:	dec00204 	addi	sp,sp,8
811414b4:	f800283a 	ret

811414b8 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
811414b8:	defffa04 	addi	sp,sp,-24
811414bc:	de00012e 	bgeu	sp,et,811414c4 <convert_filename_to_name_extension+0xc>
811414c0:	003b68fa 	trap	3
811414c4:	df000515 	stw	fp,20(sp)
811414c8:	df000504 	addi	fp,sp,20
811414cc:	e13ffd15 	stw	r4,-12(fp)
811414d0:	e17ffe15 	stw	r5,-8(fp)
811414d4:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
811414d8:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
811414dc:	e03ffb15 	stw	zero,-20(fp)
811414e0:	00002506 	br	81141578 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
811414e4:	e0bffc17 	ldw	r2,-16(fp)
811414e8:	e0fffd17 	ldw	r3,-12(fp)
811414ec:	1885883a 	add	r2,r3,r2
811414f0:	10800003 	ldbu	r2,0(r2)
811414f4:	10803fcc 	andi	r2,r2,255
811414f8:	1080201c 	xori	r2,r2,128
811414fc:	10bfe004 	addi	r2,r2,-128
81141500:	10800ba0 	cmpeqi	r2,r2,46
81141504:	1000141e 	bne	r2,zero,81141558 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81141508:	e0bffb17 	ldw	r2,-20(fp)
8114150c:	e0fffe17 	ldw	r3,-8(fp)
81141510:	1885883a 	add	r2,r3,r2
81141514:	e0fffc17 	ldw	r3,-16(fp)
81141518:	e13ffd17 	ldw	r4,-12(fp)
8114151c:	20c7883a 	add	r3,r4,r3
81141520:	18c00003 	ldbu	r3,0(r3)
81141524:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81141528:	e0bffc17 	ldw	r2,-16(fp)
8114152c:	e0fffd17 	ldw	r3,-12(fp)
81141530:	1885883a 	add	r2,r3,r2
81141534:	10800003 	ldbu	r2,0(r2)
81141538:	10803fcc 	andi	r2,r2,255
8114153c:	1080201c 	xori	r2,r2,128
81141540:	10bfe004 	addi	r2,r2,-128
81141544:	10000926 	beq	r2,zero,8114156c <convert_filename_to_name_extension+0xb4>
81141548:	e0bffc17 	ldw	r2,-16(fp)
8114154c:	10800044 	addi	r2,r2,1
81141550:	e0bffc15 	stw	r2,-16(fp)
81141554:	00000506 	br	8114156c <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81141558:	e0bffb17 	ldw	r2,-20(fp)
8114155c:	e0fffe17 	ldw	r3,-8(fp)
81141560:	1885883a 	add	r2,r3,r2
81141564:	00c00804 	movi	r3,32
81141568:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
8114156c:	e0bffb17 	ldw	r2,-20(fp)
81141570:	10800044 	addi	r2,r2,1
81141574:	e0bffb15 	stw	r2,-20(fp)
81141578:	e0bffb17 	ldw	r2,-20(fp)
8114157c:	10800210 	cmplti	r2,r2,8
81141580:	103fd81e 	bne	r2,zero,811414e4 <__reset+0xfb1214e4>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
81141584:	e0bffc17 	ldw	r2,-16(fp)
81141588:	e0fffd17 	ldw	r3,-12(fp)
8114158c:	1885883a 	add	r2,r3,r2
81141590:	10800003 	ldbu	r2,0(r2)
81141594:	10803fcc 	andi	r2,r2,255
81141598:	1080201c 	xori	r2,r2,128
8114159c:	10bfe004 	addi	r2,r2,-128
811415a0:	10800b98 	cmpnei	r2,r2,46
811415a4:	1000031e 	bne	r2,zero,811415b4 <convert_filename_to_name_extension+0xfc>
811415a8:	e0bffc17 	ldw	r2,-16(fp)
811415ac:	10800044 	addi	r2,r2,1
811415b0:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
811415b4:	e03ffb15 	stw	zero,-20(fp)
811415b8:	00001c06 	br	8114162c <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
811415bc:	e0bffc17 	ldw	r2,-16(fp)
811415c0:	e0fffd17 	ldw	r3,-12(fp)
811415c4:	1885883a 	add	r2,r3,r2
811415c8:	10800003 	ldbu	r2,0(r2)
811415cc:	10803fcc 	andi	r2,r2,255
811415d0:	1080201c 	xori	r2,r2,128
811415d4:	10bfe004 	addi	r2,r2,-128
811415d8:	10000c26 	beq	r2,zero,8114160c <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
811415dc:	e0bffb17 	ldw	r2,-20(fp)
811415e0:	e0ffff17 	ldw	r3,-4(fp)
811415e4:	1885883a 	add	r2,r3,r2
811415e8:	e0fffc17 	ldw	r3,-16(fp)
811415ec:	e13ffd17 	ldw	r4,-12(fp)
811415f0:	20c7883a 	add	r3,r4,r3
811415f4:	18c00003 	ldbu	r3,0(r3)
811415f8:	10c00005 	stb	r3,0(r2)
            local++;
811415fc:	e0bffc17 	ldw	r2,-16(fp)
81141600:	10800044 	addi	r2,r2,1
81141604:	e0bffc15 	stw	r2,-16(fp)
81141608:	00000506 	br	81141620 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
8114160c:	e0bffb17 	ldw	r2,-20(fp)
81141610:	e0ffff17 	ldw	r3,-4(fp)
81141614:	1885883a 	add	r2,r3,r2
81141618:	00c00804 	movi	r3,32
8114161c:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81141620:	e0bffb17 	ldw	r2,-20(fp)
81141624:	10800044 	addi	r2,r2,1
81141628:	e0bffb15 	stw	r2,-20(fp)
8114162c:	e0bffb17 	ldw	r2,-20(fp)
81141630:	108000d0 	cmplti	r2,r2,3
81141634:	103fe11e 	bne	r2,zero,811415bc <__reset+0xfb1215bc>
        {
            extension[counter] = ' ';
        }
    }

}
81141638:	0001883a 	nop
8114163c:	e037883a 	mov	sp,fp
81141640:	df000017 	ldw	fp,0(sp)
81141644:	dec00104 	addi	sp,sp,4
81141648:	f800283a 	ret

8114164c <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
8114164c:	defff504 	addi	sp,sp,-44
81141650:	de00012e 	bgeu	sp,et,81141658 <create_file+0xc>
81141654:	003b68fa 	trap	3
81141658:	dfc00a15 	stw	ra,40(sp)
8114165c:	df000915 	stw	fp,36(sp)
81141660:	df000904 	addi	fp,sp,36
81141664:	e13ffd15 	stw	r4,-12(fp)
81141668:	e17ffe15 	stw	r5,-8(fp)
8114166c:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81141670:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81141674:	e0bffc04 	addi	r2,fp,-16
81141678:	1009883a 	mov	r4,r2
8114167c:	1140f7c0 	call	81140f7c <find_first_empty_cluster>
81141680:	1000a026 	beq	r2,zero,81141904 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81141684:	e0bfff17 	ldw	r2,-4(fp)
81141688:	10800a17 	ldw	r2,40(r2)
8114168c:	1000031e 	bne	r2,zero,8114169c <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81141690:	11413840 	call	81141384 <find_first_empty_record_in_root_directory>
81141694:	e0bff815 	stw	r2,-32(fp)
81141698:	00000606 	br	811416b4 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
8114169c:	e0bfff17 	ldw	r2,-4(fp)
811416a0:	1080058b 	ldhu	r2,22(r2)
811416a4:	10bfffcc 	andi	r2,r2,65535
811416a8:	1009883a 	mov	r4,r2
811416ac:	11411300 	call	81141130 <find_first_empty_record_in_a_subdirectory>
811416b0:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
811416b4:	e0bff817 	ldw	r2,-32(fp)
811416b8:	10009216 	blt	r2,zero,81141904 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
811416bc:	e13ffd17 	ldw	r4,-12(fp)
811416c0:	114025c0 	call	8114025c <get_dir_divider_location>
811416c4:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
811416c8:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
811416cc:	00000b06 	br	811416fc <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
811416d0:	e0fffa17 	ldw	r3,-24(fp)
811416d4:	e0bff917 	ldw	r2,-28(fp)
811416d8:	1885883a 	add	r2,r3,r2
811416dc:	10800044 	addi	r2,r2,1
811416e0:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
811416e4:	e0bffa17 	ldw	r2,-24(fp)
811416e8:	e0fffd17 	ldw	r3,-12(fp)
811416ec:	1885883a 	add	r2,r3,r2
811416f0:	1009883a 	mov	r4,r2
811416f4:	114025c0 	call	8114025c <get_dir_divider_location>
811416f8:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
811416fc:	e0bff917 	ldw	r2,-28(fp)
81141700:	00bff316 	blt	zero,r2,811416d0 <__reset+0xfb1216d0>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81141704:	e0bffa17 	ldw	r2,-24(fp)
81141708:	e0fffd17 	ldw	r3,-12(fp)
8114170c:	1887883a 	add	r3,r3,r2
81141710:	e13ffe17 	ldw	r4,-8(fp)
81141714:	e0bffe17 	ldw	r2,-8(fp)
81141718:	10800204 	addi	r2,r2,8
8114171c:	100d883a 	mov	r6,r2
81141720:	200b883a 	mov	r5,r4
81141724:	1809883a 	mov	r4,r3
81141728:	11414b80 	call	811414b8 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
8114172c:	e0bffe17 	ldw	r2,-8(fp)
81141730:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81141734:	e0bffe17 	ldw	r2,-8(fp)
81141738:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
8114173c:	e0bffe17 	ldw	r2,-8(fp)
81141740:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81141744:	e0bffe17 	ldw	r2,-8(fp)
81141748:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
8114174c:	e0bffe17 	ldw	r2,-8(fp)
81141750:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81141754:	e0bffe17 	ldw	r2,-8(fp)
81141758:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
8114175c:	e0bffc17 	ldw	r2,-16(fp)
81141760:	1007883a 	mov	r3,r2
81141764:	e0bffe17 	ldw	r2,-8(fp)
81141768:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
8114176c:	e0bffe17 	ldw	r2,-8(fp)
81141770:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81141774:	e0fffc17 	ldw	r3,-16(fp)
81141778:	e0bffe17 	ldw	r2,-8(fp)
8114177c:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81141780:	e0bffe17 	ldw	r2,-8(fp)
81141784:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81141788:	e0bffe17 	ldw	r2,-8(fp)
8114178c:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81141790:	e0bff817 	ldw	r2,-32(fp)
81141794:	10ffffcc 	andi	r3,r2,65535
81141798:	e0bffe17 	ldw	r2,-8(fp)
8114179c:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
811417a0:	e0bff817 	ldw	r2,-32(fp)
811417a4:	1004d43a 	srli	r2,r2,16
811417a8:	1000010e 	bge	r2,zero,811417b0 <create_file+0x164>
811417ac:	108003c4 	addi	r2,r2,15
811417b0:	1005d13a 	srai	r2,r2,4
811417b4:	1007883a 	mov	r3,r2
811417b8:	e0bffe17 	ldw	r2,-8(fp)
811417bc:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
811417c0:	e0bff817 	ldw	r2,-32(fp)
811417c4:	1004d43a 	srli	r2,r2,16
811417c8:	1007883a 	mov	r3,r2
811417cc:	00a00034 	movhi	r2,32768
811417d0:	108003c4 	addi	r2,r2,15
811417d4:	1884703a 	and	r2,r3,r2
811417d8:	1000040e 	bge	r2,zero,811417ec <create_file+0x1a0>
811417dc:	10bfffc4 	addi	r2,r2,-1
811417e0:	00fffc04 	movi	r3,-16
811417e4:	10c4b03a 	or	r2,r2,r3
811417e8:	10800044 	addi	r2,r2,1
811417ec:	1004917a 	slli	r2,r2,5
811417f0:	1007883a 	mov	r3,r2
811417f4:	e0bffe17 	ldw	r2,-8(fp)
811417f8:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
811417fc:	e0bfff17 	ldw	r2,-4(fp)
81141800:	1080058b 	ldhu	r2,22(r2)
81141804:	10ffffcc 	andi	r3,r2,65535
81141808:	e0bffe17 	ldw	r2,-8(fp)
8114180c:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81141810:	e0bffe17 	ldw	r2,-8(fp)
81141814:	00c00044 	movi	r3,1
81141818:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
8114181c:	e0bffe17 	ldw	r2,-8(fp)
81141820:	00c00044 	movi	r3,1
81141824:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81141828:	e0bffe17 	ldw	r2,-8(fp)
8114182c:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81141830:	1000071e 	bne	r2,zero,81141850 <create_file+0x204>
81141834:	00a045f4 	movhi	r2,33047
81141838:	10a49104 	addi	r2,r2,-28092
8114183c:	10c01317 	ldw	r3,76(r2)
81141840:	e0bffe17 	ldw	r2,-8(fp)
81141844:	10800b17 	ldw	r2,44(r2)
81141848:	1885883a 	add	r2,r3,r2
8114184c:	00000f06 	br	8114188c <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81141850:	00a045f4 	movhi	r2,33047
81141854:	10a49104 	addi	r2,r2,-28092
81141858:	10c01417 	ldw	r3,80(r2)
8114185c:	e0bffe17 	ldw	r2,-8(fp)
81141860:	10800a17 	ldw	r2,40(r2)
81141864:	113fff84 	addi	r4,r2,-2
81141868:	00a045f4 	movhi	r2,33047
8114186c:	10a49104 	addi	r2,r2,-28092
81141870:	10800383 	ldbu	r2,14(r2)
81141874:	10803fcc 	andi	r2,r2,255
81141878:	2085383a 	mul	r2,r4,r2
8114187c:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81141880:	e0bffe17 	ldw	r2,-8(fp)
81141884:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81141888:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8114188c:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81141890:	e0bffb17 	ldw	r2,-20(fp)
81141894:	d0e0b017 	ldw	r3,-32064(gp)
81141898:	180b883a 	mov	r5,r3
8114189c:	1009883a 	mov	r4,r2
811418a0:	113ee580 	call	8113ee58 <Read_Sector_Data>
811418a4:	10001726 	beq	r2,zero,81141904 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
811418a8:	e0bffe17 	ldw	r2,-8(fp)
811418ac:	10800c0b 	ldhu	r2,48(r2)
811418b0:	10bfffcc 	andi	r2,r2,65535
811418b4:	10a0001c 	xori	r2,r2,32768
811418b8:	10a00004 	addi	r2,r2,-32768
811418bc:	e17ffe17 	ldw	r5,-8(fp)
811418c0:	1009883a 	mov	r4,r2
811418c4:	113f50c0 	call	8113f50c <Write_File_Record_At_Offset>
811418c8:	10000e26 	beq	r2,zero,81141904 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
811418cc:	113ee040 	call	8113ee04 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
811418d0:	e0bffc17 	ldw	r2,-16(fp)
811418d4:	01800044 	movi	r6,1
811418d8:	017fffc4 	movi	r5,-1
811418dc:	1009883a 	mov	r4,r2
811418e0:	113eff40 	call	8113eff4 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
811418e4:	e0bffc17 	ldw	r2,-16(fp)
811418e8:	000d883a 	mov	r6,zero
811418ec:	017fffc4 	movi	r5,-1
811418f0:	1009883a 	mov	r4,r2
811418f4:	113eff40 	call	8113eff4 <mark_cluster>
811418f8:	10000226 	beq	r2,zero,81141904 <create_file+0x2b8>
                    {
                        result = true;
811418fc:	00800044 	movi	r2,1
81141900:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81141904:	e0bff717 	ldw	r2,-36(fp)
}
81141908:	e037883a 	mov	sp,fp
8114190c:	dfc00117 	ldw	ra,4(sp)
81141910:	df000017 	ldw	fp,0(sp)
81141914:	dec00204 	addi	sp,sp,8
81141918:	f800283a 	ret

8114191c <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
8114191c:	defffb04 	addi	sp,sp,-20
81141920:	de00012e 	bgeu	sp,et,81141928 <copy_file_record_name_to_string+0xc>
81141924:	003b68fa 	trap	3
81141928:	df000415 	stw	fp,16(sp)
8114192c:	df000404 	addi	fp,sp,16
81141930:	e13ffe15 	stw	r4,-8(fp)
81141934:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81141938:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8114193c:	e03ffc15 	stw	zero,-16(fp)
81141940:	00001506 	br	81141998 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81141944:	e0fffe17 	ldw	r3,-8(fp)
81141948:	e0bffc17 	ldw	r2,-16(fp)
8114194c:	1885883a 	add	r2,r3,r2
81141950:	10800003 	ldbu	r2,0(r2)
81141954:	10803fcc 	andi	r2,r2,255
81141958:	10800820 	cmpeqi	r2,r2,32
8114195c:	10000b1e 	bne	r2,zero,8114198c <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81141960:	e0bffd17 	ldw	r2,-12(fp)
81141964:	e0ffff17 	ldw	r3,-4(fp)
81141968:	1885883a 	add	r2,r3,r2
8114196c:	e13ffe17 	ldw	r4,-8(fp)
81141970:	e0fffc17 	ldw	r3,-16(fp)
81141974:	20c7883a 	add	r3,r4,r3
81141978:	18c00003 	ldbu	r3,0(r3)
8114197c:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81141980:	e0bffd17 	ldw	r2,-12(fp)
81141984:	10800044 	addi	r2,r2,1
81141988:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8114198c:	e0bffc17 	ldw	r2,-16(fp)
81141990:	10800044 	addi	r2,r2,1
81141994:	e0bffc15 	stw	r2,-16(fp)
81141998:	e0bffc17 	ldw	r2,-16(fp)
8114199c:	10800210 	cmplti	r2,r2,8
811419a0:	103fe81e 	bne	r2,zero,81141944 <__reset+0xfb121944>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
811419a4:	e0bffe17 	ldw	r2,-8(fp)
811419a8:	10800203 	ldbu	r2,8(r2)
811419ac:	10803fcc 	andi	r2,r2,255
811419b0:	10800820 	cmpeqi	r2,r2,32
811419b4:	1000241e 	bne	r2,zero,81141a48 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
811419b8:	e0bffd17 	ldw	r2,-12(fp)
811419bc:	e0ffff17 	ldw	r3,-4(fp)
811419c0:	1885883a 	add	r2,r3,r2
811419c4:	00c00b84 	movi	r3,46
811419c8:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
811419cc:	e0bffd17 	ldw	r2,-12(fp)
811419d0:	10800044 	addi	r2,r2,1
811419d4:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
811419d8:	e03ffc15 	stw	zero,-16(fp)
811419dc:	00001706 	br	81141a3c <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
811419e0:	e0fffe17 	ldw	r3,-8(fp)
811419e4:	e0bffc17 	ldw	r2,-16(fp)
811419e8:	1885883a 	add	r2,r3,r2
811419ec:	10800204 	addi	r2,r2,8
811419f0:	10800003 	ldbu	r2,0(r2)
811419f4:	10803fcc 	andi	r2,r2,255
811419f8:	10800820 	cmpeqi	r2,r2,32
811419fc:	10000c1e 	bne	r2,zero,81141a30 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81141a00:	e0bffd17 	ldw	r2,-12(fp)
81141a04:	e0ffff17 	ldw	r3,-4(fp)
81141a08:	1885883a 	add	r2,r3,r2
81141a0c:	e13ffe17 	ldw	r4,-8(fp)
81141a10:	e0fffc17 	ldw	r3,-16(fp)
81141a14:	20c7883a 	add	r3,r4,r3
81141a18:	18c00204 	addi	r3,r3,8
81141a1c:	18c00003 	ldbu	r3,0(r3)
81141a20:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81141a24:	e0bffd17 	ldw	r2,-12(fp)
81141a28:	10800044 	addi	r2,r2,1
81141a2c:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81141a30:	e0bffc17 	ldw	r2,-16(fp)
81141a34:	10800044 	addi	r2,r2,1
81141a38:	e0bffc15 	stw	r2,-16(fp)
81141a3c:	e0bffc17 	ldw	r2,-16(fp)
81141a40:	108000d0 	cmplti	r2,r2,3
81141a44:	103fe61e 	bne	r2,zero,811419e0 <__reset+0xfb1219e0>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81141a48:	e0bffd17 	ldw	r2,-12(fp)
81141a4c:	e0ffff17 	ldw	r3,-4(fp)
81141a50:	1885883a 	add	r2,r3,r2
81141a54:	10000005 	stb	zero,0(r2)
}
81141a58:	0001883a 	nop
81141a5c:	e037883a 	mov	sp,fp
81141a60:	df000017 	ldw	fp,0(sp)
81141a64:	dec00104 	addi	sp,sp,4
81141a68:	f800283a 	ret

81141a6c <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81141a6c:	defffc04 	addi	sp,sp,-16
81141a70:	de00012e 	bgeu	sp,et,81141a78 <alt_up_sd_card_open_dev+0xc>
81141a74:	003b68fa 	trap	3
81141a78:	dfc00315 	stw	ra,12(sp)
81141a7c:	df000215 	stw	fp,8(sp)
81141a80:	df000204 	addi	fp,sp,8
81141a84:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81141a88:	d1600d04 	addi	r5,gp,-32716
81141a8c:	e13fff17 	ldw	r4,-4(fp)
81141a90:	1146f280 	call	81146f28 <alt_find_dev>
81141a94:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81141a98:	e0bffe17 	ldw	r2,-8(fp)
81141a9c:	10001e26 	beq	r2,zero,81141b18 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81141aa0:	e0bffe17 	ldw	r2,-8(fp)
81141aa4:	10800a17 	ldw	r2,40(r2)
81141aa8:	10808d04 	addi	r2,r2,564
81141aac:	d0a0aa15 	stw	r2,-32088(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81141ab0:	e0bffe17 	ldw	r2,-8(fp)
81141ab4:	10800a17 	ldw	r2,40(r2)
81141ab8:	10808904 	addi	r2,r2,548
81141abc:	d0a0ab15 	stw	r2,-32084(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81141ac0:	e0bffe17 	ldw	r2,-8(fp)
81141ac4:	10800a17 	ldw	r2,40(r2)
81141ac8:	10808404 	addi	r2,r2,528
81141acc:	d0a0ac15 	stw	r2,-32080(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81141ad0:	e0bffe17 	ldw	r2,-8(fp)
81141ad4:	10800a17 	ldw	r2,40(r2)
81141ad8:	10808c04 	addi	r2,r2,560
81141adc:	d0a0ad15 	stw	r2,-32076(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81141ae0:	e0bffe17 	ldw	r2,-8(fp)
81141ae4:	10800a17 	ldw	r2,40(r2)
81141ae8:	10808b04 	addi	r2,r2,556
81141aec:	d0a0ae15 	stw	r2,-32072(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81141af0:	e0bffe17 	ldw	r2,-8(fp)
81141af4:	10800a17 	ldw	r2,40(r2)
81141af8:	d0a0af15 	stw	r2,-32068(gp)
		device_pointer = dev;
81141afc:	e0bffe17 	ldw	r2,-8(fp)
81141b00:	d0a0b215 	stw	r2,-32056(gp)
		initialized = false;
81141b04:	d020a815 	stw	zero,-32096(gp)
		is_sd_card_formated_as_FAT16 = false;
81141b08:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
81141b0c:	00a045f4 	movhi	r2,33047
81141b10:	10a48c04 	addi	r2,r2,-28112
81141b14:	10000415 	stw	zero,16(r2)
	}
	return dev;
81141b18:	e0bffe17 	ldw	r2,-8(fp)
}
81141b1c:	e037883a 	mov	sp,fp
81141b20:	dfc00117 	ldw	ra,4(sp)
81141b24:	df000017 	ldw	fp,0(sp)
81141b28:	dec00204 	addi	sp,sp,8
81141b2c:	f800283a 	ret

81141b30 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81141b30:	defffd04 	addi	sp,sp,-12
81141b34:	de00012e 	bgeu	sp,et,81141b3c <alt_up_sd_card_is_Present+0xc>
81141b38:	003b68fa 	trap	3
81141b3c:	df000215 	stw	fp,8(sp)
81141b40:	df000204 	addi	fp,sp,8
    bool result = false;
81141b44:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81141b48:	d0a0b217 	ldw	r2,-32056(gp)
81141b4c:	10000826 	beq	r2,zero,81141b70 <alt_up_sd_card_is_Present+0x40>
81141b50:	d0a0aa17 	ldw	r2,-32088(gp)
81141b54:	1080002b 	ldhuio	r2,0(r2)
81141b58:	10bfffcc 	andi	r2,r2,65535
81141b5c:	1080008c 	andi	r2,r2,2
81141b60:	10000326 	beq	r2,zero,81141b70 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81141b64:	00800044 	movi	r2,1
81141b68:	e0bffe15 	stw	r2,-8(fp)
81141b6c:	00001e06 	br	81141be8 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81141b70:	d0a0a817 	ldw	r2,-32096(gp)
81141b74:	10800058 	cmpnei	r2,r2,1
81141b78:	10001b1e 	bne	r2,zero,81141be8 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81141b7c:	d020a815 	stw	zero,-32096(gp)
		search_data.valid = false;
81141b80:	00a045f4 	movhi	r2,33047
81141b84:	10a48c04 	addi	r2,r2,-28112
81141b88:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81141b8c:	d020a915 	stw	zero,-32092(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81141b90:	e03fff15 	stw	zero,-4(fp)
81141b94:	00001106 	br	81141bdc <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81141b98:	00a045f4 	movhi	r2,33047
81141b9c:	10a4a604 	addi	r2,r2,-28008
81141ba0:	e0ffff17 	ldw	r3,-4(fp)
81141ba4:	180691ba 	slli	r3,r3,6
81141ba8:	10c5883a 	add	r2,r2,r3
81141bac:	10800f04 	addi	r2,r2,60
81141bb0:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81141bb4:	00a045f4 	movhi	r2,33047
81141bb8:	10a4a604 	addi	r2,r2,-28008
81141bbc:	e0ffff17 	ldw	r3,-4(fp)
81141bc0:	180691ba 	slli	r3,r3,6
81141bc4:	10c5883a 	add	r2,r2,r3
81141bc8:	10800e04 	addi	r2,r2,56
81141bcc:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81141bd0:	e0bfff17 	ldw	r2,-4(fp)
81141bd4:	10800044 	addi	r2,r2,1
81141bd8:	e0bfff15 	stw	r2,-4(fp)
81141bdc:	e0bfff17 	ldw	r2,-4(fp)
81141be0:	10800510 	cmplti	r2,r2,20
81141be4:	103fec1e 	bne	r2,zero,81141b98 <__reset+0xfb121b98>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81141be8:	e0bffe17 	ldw	r2,-8(fp)
}
81141bec:	e037883a 	mov	sp,fp
81141bf0:	df000017 	ldw	fp,0(sp)
81141bf4:	dec00104 	addi	sp,sp,4
81141bf8:	f800283a 	ret

81141bfc <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81141bfc:	defffd04 	addi	sp,sp,-12
81141c00:	de00012e 	bgeu	sp,et,81141c08 <alt_up_sd_card_is_FAT16+0xc>
81141c04:	003b68fa 	trap	3
81141c08:	dfc00215 	stw	ra,8(sp)
81141c0c:	df000115 	stw	fp,4(sp)
81141c10:	df000104 	addi	fp,sp,4
	bool result = false;
81141c14:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81141c18:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
81141c1c:	10000c26 	beq	r2,zero,81141c50 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81141c20:	d0a0a817 	ldw	r2,-32096(gp)
81141c24:	1000071e 	bne	r2,zero,81141c44 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81141c28:	113fe280 	call	8113fe28 <Look_for_FAT16>
81141c2c:	d0a0a915 	stw	r2,-32092(gp)
			initialized = is_sd_card_formated_as_FAT16;
81141c30:	d0a0a917 	ldw	r2,-32092(gp)
81141c34:	d0a0a815 	stw	r2,-32096(gp)
			search_data.valid = false;
81141c38:	00a045f4 	movhi	r2,33047
81141c3c:	10a48c04 	addi	r2,r2,-28112
81141c40:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81141c44:	d0a0a917 	ldw	r2,-32092(gp)
81141c48:	e0bfff15 	stw	r2,-4(fp)
81141c4c:	00000206 	br	81141c58 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81141c50:	d020a815 	stw	zero,-32096(gp)
		is_sd_card_formated_as_FAT16 = false;
81141c54:	d020a915 	stw	zero,-32092(gp)
	}

	return result;
81141c58:	e0bfff17 	ldw	r2,-4(fp)
}
81141c5c:	e037883a 	mov	sp,fp
81141c60:	dfc00117 	ldw	ra,4(sp)
81141c64:	df000017 	ldw	fp,0(sp)
81141c68:	dec00204 	addi	sp,sp,8
81141c6c:	f800283a 	ret

81141c70 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81141c70:	deffea04 	addi	sp,sp,-88
81141c74:	de00012e 	bgeu	sp,et,81141c7c <alt_up_sd_card_find_first+0xc>
81141c78:	003b68fa 	trap	3
81141c7c:	dfc01515 	stw	ra,84(sp)
81141c80:	df001415 	stw	fp,80(sp)
81141c84:	df001404 	addi	fp,sp,80
81141c88:	e13ffe15 	stw	r4,-8(fp)
81141c8c:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81141c90:	00800084 	movi	r2,2
81141c94:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81141c98:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
81141c9c:	10002426 	beq	r2,zero,81141d30 <alt_up_sd_card_find_first+0xc0>
81141ca0:	d0a0a917 	ldw	r2,-32092(gp)
81141ca4:	10002226 	beq	r2,zero,81141d30 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
81141ca8:	e0ffee04 	addi	r3,fp,-72
81141cac:	e0bfed04 	addi	r2,fp,-76
81141cb0:	180d883a 	mov	r6,r3
81141cb4:	100b883a 	mov	r5,r2
81141cb8:	e13ffe17 	ldw	r4,-8(fp)
81141cbc:	11405c00 	call	811405c0 <get_home_directory_cluster_for_file>
81141cc0:	10001926 	beq	r2,zero,81141d28 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
81141cc4:	e0bfed17 	ldw	r2,-76(fp)
81141cc8:	1007883a 	mov	r3,r2
81141ccc:	00a045f4 	movhi	r2,33047
81141cd0:	10a48c04 	addi	r2,r2,-28112
81141cd4:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
81141cd8:	e0bfed17 	ldw	r2,-76(fp)
81141cdc:	1007883a 	mov	r3,r2
81141ce0:	00a045f4 	movhi	r2,33047
81141ce4:	10a48c04 	addi	r2,r2,-28112
81141ce8:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81141cec:	00a045f4 	movhi	r2,33047
81141cf0:	10a48c04 	addi	r2,r2,-28112
81141cf4:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81141cf8:	00a045f4 	movhi	r2,33047
81141cfc:	10a48c04 	addi	r2,r2,-28112
81141d00:	00ffffc4 	movi	r3,-1
81141d04:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81141d08:	00a045f4 	movhi	r2,33047
81141d0c:	10a48c04 	addi	r2,r2,-28112
81141d10:	00c00044 	movi	r3,1
81141d14:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81141d18:	e13fff17 	ldw	r4,-4(fp)
81141d1c:	1141d480 	call	81141d48 <alt_up_sd_card_find_next>
81141d20:	e0bfec0d 	sth	r2,-80(fp)
81141d24:	00000206 	br	81141d30 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81141d28:	00800044 	movi	r2,1
81141d2c:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81141d30:	e0bfec0b 	ldhu	r2,-80(fp)
}
81141d34:	e037883a 	mov	sp,fp
81141d38:	dfc00117 	ldw	ra,4(sp)
81141d3c:	df000017 	ldw	fp,0(sp)
81141d40:	dec00204 	addi	sp,sp,8
81141d44:	f800283a 	ret

81141d48 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81141d48:	deffe404 	addi	sp,sp,-112
81141d4c:	de00012e 	bgeu	sp,et,81141d54 <alt_up_sd_card_find_next+0xc>
81141d50:	003b68fa 	trap	3
81141d54:	dfc01b15 	stw	ra,108(sp)
81141d58:	df001a15 	stw	fp,104(sp)
81141d5c:	df001a04 	addi	fp,sp,104
81141d60:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81141d64:	00800084 	movi	r2,2
81141d68:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81141d6c:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
81141d70:	1000df26 	beq	r2,zero,811420f0 <alt_up_sd_card_find_next+0x3a8>
81141d74:	d0a0a917 	ldw	r2,-32092(gp)
81141d78:	1000dd26 	beq	r2,zero,811420f0 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81141d7c:	00a045f4 	movhi	r2,33047
81141d80:	10a48c04 	addi	r2,r2,-28112
81141d84:	10800417 	ldw	r2,16(r2)
81141d88:	1000d726 	beq	r2,zero,811420e8 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81141d8c:	00a045f4 	movhi	r2,33047
81141d90:	10a48c04 	addi	r2,r2,-28112
81141d94:	10800117 	ldw	r2,4(r2)
81141d98:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81141d9c:	e0bfe717 	ldw	r2,-100(fp)
81141da0:	1000561e 	bne	r2,zero,81141efc <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81141da4:	00a045f4 	movhi	r2,33047
81141da8:	10a49104 	addi	r2,r2,-28092
81141dac:	1080050b 	ldhu	r2,20(r2)
81141db0:	10bfffcc 	andi	r2,r2,65535
81141db4:	1006917a 	slli	r3,r2,5
81141db8:	00a045f4 	movhi	r2,33047
81141dbc:	10a49104 	addi	r2,r2,-28092
81141dc0:	1080030b 	ldhu	r2,12(r2)
81141dc4:	10bfffcc 	andi	r2,r2,65535
81141dc8:	1885283a 	div	r2,r3,r2
81141dcc:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
81141dd0:	00a045f4 	movhi	r2,33047
81141dd4:	10a48c04 	addi	r2,r2,-28112
81141dd8:	10800217 	ldw	r2,8(r2)
81141ddc:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81141de0:	00a045f4 	movhi	r2,33047
81141de4:	10a48c04 	addi	r2,r2,-28112
81141de8:	1080030b 	ldhu	r2,12(r2)
81141dec:	10bfffcc 	andi	r2,r2,65535
81141df0:	10a0001c 	xori	r2,r2,32768
81141df4:	10a00004 	addi	r2,r2,-32768
81141df8:	10800044 	addi	r2,r2,1
81141dfc:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81141e00:	00003606 	br	81141edc <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81141e04:	00a045f4 	movhi	r2,33047
81141e08:	10a49104 	addi	r2,r2,-28092
81141e0c:	10c01317 	ldw	r3,76(r2)
81141e10:	e0bfe817 	ldw	r2,-96(fp)
81141e14:	1885883a 	add	r2,r3,r2
81141e18:	1007883a 	mov	r3,r2
81141e1c:	d0a0b017 	ldw	r2,-32064(gp)
81141e20:	100b883a 	mov	r5,r2
81141e24:	1809883a 	mov	r4,r3
81141e28:	113ee580 	call	8113ee58 <Read_Sector_Data>
81141e2c:	10002f26 	beq	r2,zero,81141eec <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81141e30:	00002306 	br	81141ec0 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81141e34:	e0bfe917 	ldw	r2,-92(fp)
81141e38:	1004917a 	slli	r2,r2,5
81141e3c:	e13fe817 	ldw	r4,-96(fp)
81141e40:	e0ffef04 	addi	r3,fp,-68
81141e44:	200f883a 	mov	r7,r4
81141e48:	000d883a 	mov	r6,zero
81141e4c:	180b883a 	mov	r5,r3
81141e50:	1009883a 	mov	r4,r2
81141e54:	113f2880 	call	8113f288 <Read_File_Record_At_Offset>
81141e58:	10001626 	beq	r2,zero,81141eb4 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81141e5c:	e0bfef03 	ldbu	r2,-68(fp)
81141e60:	10803fcc 	andi	r2,r2,255
81141e64:	10001326 	beq	r2,zero,81141eb4 <alt_up_sd_card_find_next+0x16c>
81141e68:	e0bfef03 	ldbu	r2,-68(fp)
81141e6c:	10803fcc 	andi	r2,r2,255
81141e70:	10803960 	cmpeqi	r2,r2,229
81141e74:	10000f1e 	bne	r2,zero,81141eb4 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
81141e78:	e0bfe917 	ldw	r2,-92(fp)
81141e7c:	1007883a 	mov	r3,r2
81141e80:	00a045f4 	movhi	r2,33047
81141e84:	10a48c04 	addi	r2,r2,-28112
81141e88:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81141e8c:	e0ffe817 	ldw	r3,-96(fp)
81141e90:	00a045f4 	movhi	r2,33047
81141e94:	10a48c04 	addi	r2,r2,-28112
81141e98:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81141e9c:	e0bfef04 	addi	r2,fp,-68
81141ea0:	e17fff17 	ldw	r5,-4(fp)
81141ea4:	1009883a 	mov	r4,r2
81141ea8:	114191c0 	call	8114191c <copy_file_record_name_to_string>
									return 0;
81141eac:	0005883a 	mov	r2,zero
81141eb0:	00009006 	br	811420f4 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81141eb4:	e0bfe917 	ldw	r2,-92(fp)
81141eb8:	10800044 	addi	r2,r2,1
81141ebc:	e0bfe915 	stw	r2,-92(fp)
81141ec0:	e0bfe917 	ldw	r2,-92(fp)
81141ec4:	10800410 	cmplti	r2,r2,16
81141ec8:	103fda1e 	bne	r2,zero,81141e34 <__reset+0xfb121e34>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
81141ecc:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81141ed0:	e0bfe817 	ldw	r2,-96(fp)
81141ed4:	10800044 	addi	r2,r2,1
81141ed8:	e0bfe815 	stw	r2,-96(fp)
81141edc:	e0ffe817 	ldw	r3,-96(fp)
81141ee0:	e0bfec17 	ldw	r2,-80(fp)
81141ee4:	18bfc716 	blt	r3,r2,81141e04 <__reset+0xfb121e04>
81141ee8:	00000106 	br	81141ef0 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81141eec:	0001883a 	nop
					}
				}
				result = -1;
81141ef0:	00bfffc4 	movi	r2,-1
81141ef4:	e0bfe60d 	sth	r2,-104(fp)
81141ef8:	00007d06 	br	811420f0 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81141efc:	00a045f4 	movhi	r2,33047
81141f00:	10a48c04 	addi	r2,r2,-28112
81141f04:	1080030b 	ldhu	r2,12(r2)
81141f08:	10bfffcc 	andi	r2,r2,65535
81141f0c:	10a0001c 	xori	r2,r2,32768
81141f10:	10a00004 	addi	r2,r2,-32768
81141f14:	10800044 	addi	r2,r2,1
81141f18:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81141f1c:	e0bfe717 	ldw	r2,-100(fp)
81141f20:	10ffff84 	addi	r3,r2,-2
81141f24:	00a045f4 	movhi	r2,33047
81141f28:	10a49104 	addi	r2,r2,-28092
81141f2c:	10800383 	ldbu	r2,14(r2)
81141f30:	10803fcc 	andi	r2,r2,255
81141f34:	1885383a 	mul	r2,r3,r2
81141f38:	1007883a 	mov	r3,r2
81141f3c:	00a045f4 	movhi	r2,33047
81141f40:	10a49104 	addi	r2,r2,-28092
81141f44:	10801417 	ldw	r2,80(r2)
81141f48:	1885883a 	add	r2,r3,r2
81141f4c:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81141f50:	00a045f4 	movhi	r2,33047
81141f54:	10a48c04 	addi	r2,r2,-28112
81141f58:	10800217 	ldw	r2,8(r2)
81141f5c:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81141f60:	00003806 	br	81142044 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81141f64:	e0ffeb17 	ldw	r3,-84(fp)
81141f68:	e0bfed17 	ldw	r2,-76(fp)
81141f6c:	1885883a 	add	r2,r3,r2
81141f70:	d0e0b017 	ldw	r3,-32064(gp)
81141f74:	180b883a 	mov	r5,r3
81141f78:	1009883a 	mov	r4,r2
81141f7c:	113ee580 	call	8113ee58 <Read_Sector_Data>
81141f80:	10003726 	beq	r2,zero,81142060 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81141f84:	00002806 	br	81142028 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
81141f88:	e0bfea17 	ldw	r2,-88(fp)
81141f8c:	1004917a 	slli	r2,r2,5
81141f90:	e13fe717 	ldw	r4,-100(fp)
81141f94:	e17feb17 	ldw	r5,-84(fp)
81141f98:	e0ffef04 	addi	r3,fp,-68
81141f9c:	280f883a 	mov	r7,r5
81141fa0:	200d883a 	mov	r6,r4
81141fa4:	180b883a 	mov	r5,r3
81141fa8:	1009883a 	mov	r4,r2
81141fac:	113f2880 	call	8113f288 <Read_File_Record_At_Offset>
81141fb0:	10001a26 	beq	r2,zero,8114201c <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81141fb4:	e0bfef03 	ldbu	r2,-68(fp)
81141fb8:	10803fcc 	andi	r2,r2,255
81141fbc:	10001726 	beq	r2,zero,8114201c <alt_up_sd_card_find_next+0x2d4>
81141fc0:	e0bfef03 	ldbu	r2,-68(fp)
81141fc4:	10803fcc 	andi	r2,r2,255
81141fc8:	10803960 	cmpeqi	r2,r2,229
81141fcc:	1000131e 	bne	r2,zero,8114201c <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
81141fd0:	e0ffe717 	ldw	r3,-100(fp)
81141fd4:	00a045f4 	movhi	r2,33047
81141fd8:	10a48c04 	addi	r2,r2,-28112
81141fdc:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
81141fe0:	e0bfea17 	ldw	r2,-88(fp)
81141fe4:	1007883a 	mov	r3,r2
81141fe8:	00a045f4 	movhi	r2,33047
81141fec:	10a48c04 	addi	r2,r2,-28112
81141ff0:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
81141ff4:	e0ffeb17 	ldw	r3,-84(fp)
81141ff8:	00a045f4 	movhi	r2,33047
81141ffc:	10a48c04 	addi	r2,r2,-28112
81142000:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81142004:	e0bfef04 	addi	r2,fp,-68
81142008:	e17fff17 	ldw	r5,-4(fp)
8114200c:	1009883a 	mov	r4,r2
81142010:	114191c0 	call	8114191c <copy_file_record_name_to_string>
										return 0;
81142014:	0005883a 	mov	r2,zero
81142018:	00003606 	br	811420f4 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
8114201c:	e0bfea17 	ldw	r2,-88(fp)
81142020:	10800044 	addi	r2,r2,1
81142024:	e0bfea15 	stw	r2,-88(fp)
81142028:	e0bfea17 	ldw	r2,-88(fp)
8114202c:	10800410 	cmplti	r2,r2,16
81142030:	103fd51e 	bne	r2,zero,81141f88 <__reset+0xfb121f88>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81142034:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81142038:	e0bfeb17 	ldw	r2,-84(fp)
8114203c:	10800044 	addi	r2,r2,1
81142040:	e0bfeb15 	stw	r2,-84(fp)
81142044:	00a045f4 	movhi	r2,33047
81142048:	10a49104 	addi	r2,r2,-28092
8114204c:	10800383 	ldbu	r2,14(r2)
81142050:	10803fcc 	andi	r2,r2,255
81142054:	e0ffeb17 	ldw	r3,-84(fp)
81142058:	18bfc216 	blt	r3,r2,81141f64 <__reset+0xfb121f64>
8114205c:	00000106 	br	81142064 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81142060:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81142064:	00a045f4 	movhi	r2,33047
81142068:	10a49104 	addi	r2,r2,-28092
8114206c:	10800383 	ldbu	r2,14(r2)
81142070:	10803fcc 	andi	r2,r2,255
81142074:	e0ffeb17 	ldw	r3,-84(fp)
81142078:	18801716 	blt	r3,r2,811420d8 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
8114207c:	e0bfe717 	ldw	r2,-100(fp)
81142080:	e0ffee04 	addi	r3,fp,-72
81142084:	180b883a 	mov	r5,r3
81142088:	1009883a 	mov	r4,r2
8114208c:	113ef380 	call	8113ef38 <get_cluster_flag>
81142090:	10000f26 	beq	r2,zero,811420d0 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81142094:	e0bfee0b 	ldhu	r2,-72(fp)
81142098:	10bfffcc 	andi	r2,r2,65535
8114209c:	10fffe0c 	andi	r3,r2,65528
811420a0:	00bffe14 	movui	r2,65528
811420a4:	1880051e 	bne	r3,r2,811420bc <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
811420a8:	00bfffc4 	movi	r2,-1
811420ac:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
811420b0:	00a045f4 	movhi	r2,33047
811420b4:	10a48c04 	addi	r2,r2,-28112
811420b8:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
811420bc:	e0bfee0b 	ldhu	r2,-72(fp)
811420c0:	10bfffcc 	andi	r2,r2,65535
811420c4:	10bffe0c 	andi	r2,r2,65528
811420c8:	e0bfe715 	stw	r2,-100(fp)
811420cc:	00000206 	br	811420d8 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
811420d0:	00bfffc4 	movi	r2,-1
811420d4:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
811420d8:	e0bfe717 	ldw	r2,-100(fp)
811420dc:	00fffdd4 	movui	r3,65527
811420e0:	18bf8e0e 	bge	r3,r2,81141f1c <__reset+0xfb121f1c>
811420e4:	00000206 	br	811420f0 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
811420e8:	008000c4 	movi	r2,3
811420ec:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
811420f0:	e0bfe60b 	ldhu	r2,-104(fp)
}
811420f4:	e037883a 	mov	sp,fp
811420f8:	dfc00117 	ldw	ra,4(sp)
811420fc:	df000017 	ldw	fp,0(sp)
81142100:	dec00204 	addi	sp,sp,8
81142104:	f800283a 	ret

81142108 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81142108:	deffe904 	addi	sp,sp,-92
8114210c:	de00012e 	bgeu	sp,et,81142114 <alt_up_sd_card_fopen+0xc>
81142110:	003b68fa 	trap	3
81142114:	dfc01615 	stw	ra,88(sp)
81142118:	df001515 	stw	fp,84(sp)
8114211c:	df001504 	addi	fp,sp,84
81142120:	e13ffe15 	stw	r4,-8(fp)
81142124:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81142128:	00bfffc4 	movi	r2,-1
8114212c:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81142130:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
81142134:	1000cf26 	beq	r2,zero,81142474 <alt_up_sd_card_fopen+0x36c>
81142138:	d0a0a917 	ldw	r2,-32092(gp)
8114213c:	1000cd26 	beq	r2,zero,81142474 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81142140:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81142144:	e13ffe17 	ldw	r4,-8(fp)
81142148:	113ff1c0 	call	8113ff1c <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
8114214c:	e13ffe17 	ldw	r4,-8(fp)
81142150:	113ffe80 	call	8113ffe8 <check_file_name_for_FAT16_compliance>
81142154:	1000c726 	beq	r2,zero,81142474 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
81142158:	e0ffee04 	addi	r3,fp,-72
8114215c:	e0bfed04 	addi	r2,fp,-76
81142160:	180d883a 	mov	r6,r3
81142164:	100b883a 	mov	r5,r2
81142168:	e13ffe17 	ldw	r4,-8(fp)
8114216c:	11405c00 	call	811405c0 <get_home_directory_cluster_for_file>
81142170:	1000021e 	bne	r2,zero,8114217c <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81142174:	e0bfeb0b 	ldhu	r2,-84(fp)
81142178:	0000bf06 	br	81142478 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8114217c:	e03fec15 	stw	zero,-80(fp)
81142180:	00000e06 	br	811421bc <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
81142184:	00a045f4 	movhi	r2,33047
81142188:	10a4a604 	addi	r2,r2,-28008
8114218c:	e0ffec17 	ldw	r3,-80(fp)
81142190:	180691ba 	slli	r3,r3,6
81142194:	10c5883a 	add	r2,r2,r3
81142198:	10800f04 	addi	r2,r2,60
8114219c:	10800017 	ldw	r2,0(r2)
811421a0:	1000031e 	bne	r2,zero,811421b0 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
811421a4:	e0bfec17 	ldw	r2,-80(fp)
811421a8:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
811421ac:	00000606 	br	811421c8 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811421b0:	e0bfec17 	ldw	r2,-80(fp)
811421b4:	10800044 	addi	r2,r2,1
811421b8:	e0bfec15 	stw	r2,-80(fp)
811421bc:	e0bfec17 	ldw	r2,-80(fp)
811421c0:	10800510 	cmplti	r2,r2,20
811421c4:	103fef1e 	bne	r2,zero,81142184 <__reset+0xfb122184>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
811421c8:	e0bfeb0f 	ldh	r2,-84(fp)
811421cc:	1000a916 	blt	r2,zero,81142474 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
811421d0:	e0bfed17 	ldw	r2,-76(fp)
811421d4:	1009883a 	mov	r4,r2
811421d8:	e0bfeb0f 	ldh	r2,-84(fp)
811421dc:	100691ba 	slli	r3,r2,6
811421e0:	00a045f4 	movhi	r2,33047
811421e4:	10a4a604 	addi	r2,r2,-28008
811421e8:	1885883a 	add	r2,r3,r2
811421ec:	100d883a 	mov	r6,r2
811421f0:	e17ffe17 	ldw	r5,-8(fp)
811421f4:	1140b000 	call	81140b00 <find_file_in_directory>
811421f8:	10007b26 	beq	r2,zero,811423e8 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
811421fc:	e0bfff17 	ldw	r2,-4(fp)
81142200:	10000226 	beq	r2,zero,8114220c <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
81142204:	00bfffc4 	movi	r2,-1
81142208:	00009b06 	br	81142478 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
8114220c:	e13feb0f 	ldh	r4,-84(fp)
81142210:	e0ffeb0f 	ldh	r3,-84(fp)
81142214:	00a045f4 	movhi	r2,33047
81142218:	10a4a604 	addi	r2,r2,-28008
8114221c:	180691ba 	slli	r3,r3,6
81142220:	10c5883a 	add	r2,r2,r3
81142224:	10800584 	addi	r2,r2,22
81142228:	1080000b 	ldhu	r2,0(r2)
8114222c:	10ffffcc 	andi	r3,r2,65535
81142230:	00a045f4 	movhi	r2,33047
81142234:	10a4a604 	addi	r2,r2,-28008
81142238:	200891ba 	slli	r4,r4,6
8114223c:	1105883a 	add	r2,r2,r4
81142240:	10800704 	addi	r2,r2,28
81142244:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
81142248:	e0ffeb0f 	ldh	r3,-84(fp)
8114224c:	00a045f4 	movhi	r2,33047
81142250:	10a4a604 	addi	r2,r2,-28008
81142254:	180691ba 	slli	r3,r3,6
81142258:	10c5883a 	add	r2,r2,r3
8114225c:	10800804 	addi	r2,r2,32
81142260:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
81142264:	e0ffeb0f 	ldh	r3,-84(fp)
81142268:	00a045f4 	movhi	r2,33047
8114226c:	10a4a604 	addi	r2,r2,-28008
81142270:	180691ba 	slli	r3,r3,6
81142274:	10c5883a 	add	r2,r2,r3
81142278:	10800904 	addi	r2,r2,36
8114227c:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
81142280:	e0ffeb0f 	ldh	r3,-84(fp)
81142284:	00a045f4 	movhi	r2,33047
81142288:	10a4a604 	addi	r2,r2,-28008
8114228c:	180691ba 	slli	r3,r3,6
81142290:	10c5883a 	add	r2,r2,r3
81142294:	10800f04 	addi	r2,r2,60
81142298:	00c00044 	movi	r3,1
8114229c:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
811422a0:	e0ffeb0f 	ldh	r3,-84(fp)
811422a4:	00a045f4 	movhi	r2,33047
811422a8:	10a4a604 	addi	r2,r2,-28008
811422ac:	180691ba 	slli	r3,r3,6
811422b0:	10c5883a 	add	r2,r2,r3
811422b4:	10800e04 	addi	r2,r2,56
811422b8:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811422bc:	e03fec15 	stw	zero,-80(fp)
811422c0:	00004506 	br	811423d8 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
811422c4:	e0ffeb0f 	ldh	r3,-84(fp)
811422c8:	e0bfec17 	ldw	r2,-80(fp)
811422cc:	18803f26 	beq	r3,r2,811423cc <alt_up_sd_card_fopen+0x2c4>
811422d0:	00a045f4 	movhi	r2,33047
811422d4:	10a4a604 	addi	r2,r2,-28008
811422d8:	e0ffec17 	ldw	r3,-80(fp)
811422dc:	180691ba 	slli	r3,r3,6
811422e0:	10c5883a 	add	r2,r2,r3
811422e4:	10800f04 	addi	r2,r2,60
811422e8:	10800017 	ldw	r2,0(r2)
811422ec:	10800058 	cmpnei	r2,r2,1
811422f0:	1000361e 	bne	r2,zero,811423cc <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811422f4:	e0ffeb0f 	ldh	r3,-84(fp)
811422f8:	00a045f4 	movhi	r2,33047
811422fc:	10a4a604 	addi	r2,r2,-28008
81142300:	180691ba 	slli	r3,r3,6
81142304:	10c5883a 	add	r2,r2,r3
81142308:	10800a04 	addi	r2,r2,40
8114230c:	10c00017 	ldw	r3,0(r2)
81142310:	00a045f4 	movhi	r2,33047
81142314:	10a4a604 	addi	r2,r2,-28008
81142318:	e13fec17 	ldw	r4,-80(fp)
8114231c:	200891ba 	slli	r4,r4,6
81142320:	1105883a 	add	r2,r2,r4
81142324:	10800a04 	addi	r2,r2,40
81142328:	10800017 	ldw	r2,0(r2)
8114232c:	1880271e 	bne	r3,r2,811423cc <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81142330:	e0ffeb0f 	ldh	r3,-84(fp)
81142334:	00a045f4 	movhi	r2,33047
81142338:	10a4a604 	addi	r2,r2,-28008
8114233c:	180691ba 	slli	r3,r3,6
81142340:	10c5883a 	add	r2,r2,r3
81142344:	10800b04 	addi	r2,r2,44
81142348:	10c00017 	ldw	r3,0(r2)
8114234c:	00a045f4 	movhi	r2,33047
81142350:	10a4a604 	addi	r2,r2,-28008
81142354:	e13fec17 	ldw	r4,-80(fp)
81142358:	200891ba 	slli	r4,r4,6
8114235c:	1105883a 	add	r2,r2,r4
81142360:	10800b04 	addi	r2,r2,44
81142364:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81142368:	1880181e 	bne	r3,r2,811423cc <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
8114236c:	e0ffeb0f 	ldh	r3,-84(fp)
81142370:	00a045f4 	movhi	r2,33047
81142374:	10a4a604 	addi	r2,r2,-28008
81142378:	180691ba 	slli	r3,r3,6
8114237c:	10c5883a 	add	r2,r2,r3
81142380:	10800c04 	addi	r2,r2,48
81142384:	1100000b 	ldhu	r4,0(r2)
81142388:	00a045f4 	movhi	r2,33047
8114238c:	10a4a604 	addi	r2,r2,-28008
81142390:	e0ffec17 	ldw	r3,-80(fp)
81142394:	180691ba 	slli	r3,r3,6
81142398:	10c5883a 	add	r2,r2,r3
8114239c:	10800c04 	addi	r2,r2,48
811423a0:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
811423a4:	20ffffcc 	andi	r3,r4,65535
811423a8:	18e0001c 	xori	r3,r3,32768
811423ac:	18e00004 	addi	r3,r3,-32768
811423b0:	10bfffcc 	andi	r2,r2,65535
811423b4:	10a0001c 	xori	r2,r2,32768
811423b8:	10a00004 	addi	r2,r2,-32768
811423bc:	1880031e 	bne	r3,r2,811423cc <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
811423c0:	00bfff84 	movi	r2,-2
811423c4:	e0bfeb0d 	sth	r2,-84(fp)
								break;
811423c8:	00002a06 	br	81142474 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811423cc:	e0bfec17 	ldw	r2,-80(fp)
811423d0:	10800044 	addi	r2,r2,1
811423d4:	e0bfec15 	stw	r2,-80(fp)
811423d8:	e0bfec17 	ldw	r2,-80(fp)
811423dc:	10800510 	cmplti	r2,r2,20
811423e0:	103fb81e 	bne	r2,zero,811422c4 <__reset+0xfb1222c4>
811423e4:	00002306 	br	81142474 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
811423e8:	e0bfff17 	ldw	r2,-4(fp)
811423ec:	10001f26 	beq	r2,zero,8114246c <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
811423f0:	e0bfeb0f 	ldh	r2,-84(fp)
811423f4:	100691ba 	slli	r3,r2,6
811423f8:	00a045f4 	movhi	r2,33047
811423fc:	10a4a604 	addi	r2,r2,-28008
81142400:	1885883a 	add	r2,r3,r2
81142404:	e0ffee04 	addi	r3,fp,-72
81142408:	180d883a 	mov	r6,r3
8114240c:	100b883a 	mov	r5,r2
81142410:	e13ffe17 	ldw	r4,-8(fp)
81142414:	114164c0 	call	8114164c <create_file>
81142418:	10001126 	beq	r2,zero,81142460 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
8114241c:	e0ffeb0f 	ldh	r3,-84(fp)
81142420:	00a045f4 	movhi	r2,33047
81142424:	10a4a604 	addi	r2,r2,-28008
81142428:	180691ba 	slli	r3,r3,6
8114242c:	10c5883a 	add	r2,r2,r3
81142430:	10800f04 	addi	r2,r2,60
81142434:	00c00044 	movi	r3,1
81142438:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
8114243c:	e0ffeb0f 	ldh	r3,-84(fp)
81142440:	00a045f4 	movhi	r2,33047
81142444:	10a4a604 	addi	r2,r2,-28008
81142448:	180691ba 	slli	r3,r3,6
8114244c:	10c5883a 	add	r2,r2,r3
81142450:	10800e04 	addi	r2,r2,56
81142454:	00c00044 	movi	r3,1
81142458:	10c00015 	stw	r3,0(r2)
8114245c:	00000506 	br	81142474 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81142460:	00bfffc4 	movi	r2,-1
81142464:	e0bfeb0d 	sth	r2,-84(fp)
81142468:	00000206 	br	81142474 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
8114246c:	00bfffc4 	movi	r2,-1
81142470:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81142474:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81142478:	e037883a 	mov	sp,fp
8114247c:	dfc00117 	ldw	ra,4(sp)
81142480:	df000017 	ldw	fp,0(sp)
81142484:	dec00204 	addi	sp,sp,8
81142488:	f800283a 	ret

8114248c <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8114248c:	defffd04 	addi	sp,sp,-12
81142490:	de00012e 	bgeu	sp,et,81142498 <alt_up_sd_card_set_attributes+0xc>
81142494:	003b68fa 	trap	3
81142498:	df000215 	stw	fp,8(sp)
8114249c:	df000204 	addi	fp,sp,8
811424a0:	2007883a 	mov	r3,r4
811424a4:	2805883a 	mov	r2,r5
811424a8:	e0fffe0d 	sth	r3,-8(fp)
811424ac:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811424b0:	e0bffe0f 	ldh	r2,-8(fp)
811424b4:	10001416 	blt	r2,zero,81142508 <alt_up_sd_card_set_attributes+0x7c>
811424b8:	e0bffe0f 	ldh	r2,-8(fp)
811424bc:	10800508 	cmpgei	r2,r2,20
811424c0:	1000111e 	bne	r2,zero,81142508 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
811424c4:	e0fffe0f 	ldh	r3,-8(fp)
811424c8:	00a045f4 	movhi	r2,33047
811424cc:	10a4a604 	addi	r2,r2,-28008
811424d0:	180691ba 	slli	r3,r3,6
811424d4:	10c5883a 	add	r2,r2,r3
811424d8:	10800f04 	addi	r2,r2,60
811424dc:	10800017 	ldw	r2,0(r2)
811424e0:	10000926 	beq	r2,zero,81142508 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
811424e4:	e0fffe0f 	ldh	r3,-8(fp)
811424e8:	e0bfff0b 	ldhu	r2,-4(fp)
811424ec:	1009883a 	mov	r4,r2
811424f0:	00a045f4 	movhi	r2,33047
811424f4:	10a4a604 	addi	r2,r2,-28008
811424f8:	180691ba 	slli	r3,r3,6
811424fc:	10c5883a 	add	r2,r2,r3
81142500:	108002c4 	addi	r2,r2,11
81142504:	11000005 	stb	r4,0(r2)
        }
    }
}
81142508:	0001883a 	nop
8114250c:	e037883a 	mov	sp,fp
81142510:	df000017 	ldw	fp,0(sp)
81142514:	dec00104 	addi	sp,sp,4
81142518:	f800283a 	ret

8114251c <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8114251c:	defffd04 	addi	sp,sp,-12
81142520:	de00012e 	bgeu	sp,et,81142528 <alt_up_sd_card_get_attributes+0xc>
81142524:	003b68fa 	trap	3
81142528:	df000215 	stw	fp,8(sp)
8114252c:	df000204 	addi	fp,sp,8
81142530:	2005883a 	mov	r2,r4
81142534:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81142538:	00bfffc4 	movi	r2,-1
8114253c:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81142540:	e0bfff0f 	ldh	r2,-4(fp)
81142544:	10001416 	blt	r2,zero,81142598 <alt_up_sd_card_get_attributes+0x7c>
81142548:	e0bfff0f 	ldh	r2,-4(fp)
8114254c:	10800508 	cmpgei	r2,r2,20
81142550:	1000111e 	bne	r2,zero,81142598 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81142554:	e0ffff0f 	ldh	r3,-4(fp)
81142558:	00a045f4 	movhi	r2,33047
8114255c:	10a4a604 	addi	r2,r2,-28008
81142560:	180691ba 	slli	r3,r3,6
81142564:	10c5883a 	add	r2,r2,r3
81142568:	10800f04 	addi	r2,r2,60
8114256c:	10800017 	ldw	r2,0(r2)
81142570:	10000926 	beq	r2,zero,81142598 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81142574:	e0ffff0f 	ldh	r3,-4(fp)
81142578:	00a045f4 	movhi	r2,33047
8114257c:	10a4a604 	addi	r2,r2,-28008
81142580:	180691ba 	slli	r3,r3,6
81142584:	10c5883a 	add	r2,r2,r3
81142588:	108002c4 	addi	r2,r2,11
8114258c:	10800003 	ldbu	r2,0(r2)
81142590:	10803fcc 	andi	r2,r2,255
81142594:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81142598:	e0bffe0b 	ldhu	r2,-8(fp)
}
8114259c:	e037883a 	mov	sp,fp
811425a0:	df000017 	ldw	fp,0(sp)
811425a4:	dec00104 	addi	sp,sp,4
811425a8:	f800283a 	ret

811425ac <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
811425ac:	defffa04 	addi	sp,sp,-24
811425b0:	de00012e 	bgeu	sp,et,811425b8 <alt_up_sd_card_read+0xc>
811425b4:	003b68fa 	trap	3
811425b8:	dfc00515 	stw	ra,20(sp)
811425bc:	df000415 	stw	fp,16(sp)
811425c0:	df000404 	addi	fp,sp,16
811425c4:	2005883a 	mov	r2,r4
811425c8:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
811425cc:	00bfffc4 	movi	r2,-1
811425d0:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811425d4:	e0bfff0f 	ldh	r2,-4(fp)
811425d8:	1000ce16 	blt	r2,zero,81142914 <alt_up_sd_card_read+0x368>
811425dc:	e0bfff0f 	ldh	r2,-4(fp)
811425e0:	10800508 	cmpgei	r2,r2,20
811425e4:	1000cb1e 	bne	r2,zero,81142914 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
811425e8:	e0ffff0f 	ldh	r3,-4(fp)
811425ec:	00a045f4 	movhi	r2,33047
811425f0:	10a4a604 	addi	r2,r2,-28008
811425f4:	180691ba 	slli	r3,r3,6
811425f8:	10c5883a 	add	r2,r2,r3
811425fc:	10800f04 	addi	r2,r2,60
81142600:	10800017 	ldw	r2,0(r2)
81142604:	1000c326 	beq	r2,zero,81142914 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81142608:	e0ffff0f 	ldh	r3,-4(fp)
8114260c:	00a045f4 	movhi	r2,33047
81142610:	10a4a604 	addi	r2,r2,-28008
81142614:	180691ba 	slli	r3,r3,6
81142618:	10c5883a 	add	r2,r2,r3
8114261c:	10800904 	addi	r2,r2,36
81142620:	10c00017 	ldw	r3,0(r2)
81142624:	e13fff0f 	ldh	r4,-4(fp)
81142628:	00a045f4 	movhi	r2,33047
8114262c:	10a4a604 	addi	r2,r2,-28008
81142630:	200891ba 	slli	r4,r4,6
81142634:	1105883a 	add	r2,r2,r4
81142638:	10800604 	addi	r2,r2,24
8114263c:	10800017 	ldw	r2,0(r2)
81142640:	1880b42e 	bgeu	r3,r2,81142914 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81142644:	00a045f4 	movhi	r2,33047
81142648:	10a49104 	addi	r2,r2,-28092
8114264c:	10c01417 	ldw	r3,80(r2)
81142650:	e13fff0f 	ldh	r4,-4(fp)
81142654:	00a045f4 	movhi	r2,33047
81142658:	10a4a604 	addi	r2,r2,-28008
8114265c:	200891ba 	slli	r4,r4,6
81142660:	1105883a 	add	r2,r2,r4
81142664:	10800704 	addi	r2,r2,28
81142668:	10800017 	ldw	r2,0(r2)
8114266c:	113fff84 	addi	r4,r2,-2
81142670:	00a045f4 	movhi	r2,33047
81142674:	10a49104 	addi	r2,r2,-28092
81142678:	10800383 	ldbu	r2,14(r2)
8114267c:	10803fcc 	andi	r2,r2,255
81142680:	2085383a 	mul	r2,r4,r2
81142684:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81142688:	e13fff0f 	ldh	r4,-4(fp)
8114268c:	00a045f4 	movhi	r2,33047
81142690:	10a4a604 	addi	r2,r2,-28008
81142694:	200891ba 	slli	r4,r4,6
81142698:	1105883a 	add	r2,r2,r4
8114269c:	10800804 	addi	r2,r2,32
811426a0:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811426a4:	1885883a 	add	r2,r3,r2
811426a8:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
811426ac:	e0ffff0f 	ldh	r3,-4(fp)
811426b0:	00a045f4 	movhi	r2,33047
811426b4:	10a4a604 	addi	r2,r2,-28008
811426b8:	180691ba 	slli	r3,r3,6
811426bc:	10c5883a 	add	r2,r2,r3
811426c0:	10800904 	addi	r2,r2,36
811426c4:	10800017 	ldw	r2,0(r2)
811426c8:	10006826 	beq	r2,zero,8114286c <alt_up_sd_card_read+0x2c0>
811426cc:	e0ffff0f 	ldh	r3,-4(fp)
811426d0:	00a045f4 	movhi	r2,33047
811426d4:	10a4a604 	addi	r2,r2,-28008
811426d8:	180691ba 	slli	r3,r3,6
811426dc:	10c5883a 	add	r2,r2,r3
811426e0:	10800904 	addi	r2,r2,36
811426e4:	10800017 	ldw	r2,0(r2)
811426e8:	10807fcc 	andi	r2,r2,511
811426ec:	10005f1e 	bne	r2,zero,8114286c <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
811426f0:	e0ffff0f 	ldh	r3,-4(fp)
811426f4:	00a045f4 	movhi	r2,33047
811426f8:	10a4a604 	addi	r2,r2,-28008
811426fc:	180691ba 	slli	r3,r3,6
81142700:	10c5883a 	add	r2,r2,r3
81142704:	10800804 	addi	r2,r2,32
81142708:	10c00017 	ldw	r3,0(r2)
8114270c:	00a045f4 	movhi	r2,33047
81142710:	10a49104 	addi	r2,r2,-28092
81142714:	10800383 	ldbu	r2,14(r2)
81142718:	10803fcc 	andi	r2,r2,255
8114271c:	10bfffc4 	addi	r2,r2,-1
81142720:	1880401e 	bne	r3,r2,81142824 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81142724:	e0ffff0f 	ldh	r3,-4(fp)
81142728:	00a045f4 	movhi	r2,33047
8114272c:	10a4a604 	addi	r2,r2,-28008
81142730:	180691ba 	slli	r3,r3,6
81142734:	10c5883a 	add	r2,r2,r3
81142738:	10800704 	addi	r2,r2,28
8114273c:	10800017 	ldw	r2,0(r2)
81142740:	e0fffe04 	addi	r3,fp,-8
81142744:	180b883a 	mov	r5,r3
81142748:	1009883a 	mov	r4,r2
8114274c:	113ef380 	call	8113ef38 <get_cluster_flag>
81142750:	10003226 	beq	r2,zero,8114281c <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81142754:	e0bffe0b 	ldhu	r2,-8(fp)
81142758:	10bfffcc 	andi	r2,r2,65535
8114275c:	10fffe0c 	andi	r3,r2,65528
81142760:	00bffe14 	movui	r2,65528
81142764:	1880021e 	bne	r3,r2,81142770 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81142768:	00bfffc4 	movi	r2,-1
8114276c:	00006a06 	br	81142918 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81142770:	e13fff0f 	ldh	r4,-4(fp)
81142774:	e0bffe0b 	ldhu	r2,-8(fp)
81142778:	10ffffcc 	andi	r3,r2,65535
8114277c:	00a045f4 	movhi	r2,33047
81142780:	10a4a604 	addi	r2,r2,-28008
81142784:	200891ba 	slli	r4,r4,6
81142788:	1105883a 	add	r2,r2,r4
8114278c:	10800704 	addi	r2,r2,28
81142790:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81142794:	e0ffff0f 	ldh	r3,-4(fp)
81142798:	00a045f4 	movhi	r2,33047
8114279c:	10a4a604 	addi	r2,r2,-28008
811427a0:	180691ba 	slli	r3,r3,6
811427a4:	10c5883a 	add	r2,r2,r3
811427a8:	10800804 	addi	r2,r2,32
811427ac:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811427b0:	00a045f4 	movhi	r2,33047
811427b4:	10a49104 	addi	r2,r2,-28092
811427b8:	10c01417 	ldw	r3,80(r2)
811427bc:	e13fff0f 	ldh	r4,-4(fp)
811427c0:	00a045f4 	movhi	r2,33047
811427c4:	10a4a604 	addi	r2,r2,-28008
811427c8:	200891ba 	slli	r4,r4,6
811427cc:	1105883a 	add	r2,r2,r4
811427d0:	10800704 	addi	r2,r2,28
811427d4:	10800017 	ldw	r2,0(r2)
811427d8:	113fff84 	addi	r4,r2,-2
811427dc:	00a045f4 	movhi	r2,33047
811427e0:	10a49104 	addi	r2,r2,-28092
811427e4:	10800383 	ldbu	r2,14(r2)
811427e8:	10803fcc 	andi	r2,r2,255
811427ec:	2085383a 	mul	r2,r4,r2
811427f0:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
811427f4:	e13fff0f 	ldh	r4,-4(fp)
811427f8:	00a045f4 	movhi	r2,33047
811427fc:	10a4a604 	addi	r2,r2,-28008
81142800:	200891ba 	slli	r4,r4,6
81142804:	1105883a 	add	r2,r2,r4
81142808:	10800804 	addi	r2,r2,32
8114280c:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81142810:	1885883a 	add	r2,r3,r2
81142814:	e0bffd15 	stw	r2,-12(fp)
81142818:	00001406 	br	8114286c <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
8114281c:	00bfff84 	movi	r2,-2
81142820:	00003d06 	br	81142918 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81142824:	e13fff0f 	ldh	r4,-4(fp)
81142828:	e0ffff0f 	ldh	r3,-4(fp)
8114282c:	00a045f4 	movhi	r2,33047
81142830:	10a4a604 	addi	r2,r2,-28008
81142834:	180691ba 	slli	r3,r3,6
81142838:	10c5883a 	add	r2,r2,r3
8114283c:	10800804 	addi	r2,r2,32
81142840:	10800017 	ldw	r2,0(r2)
81142844:	10c00044 	addi	r3,r2,1
81142848:	00a045f4 	movhi	r2,33047
8114284c:	10a4a604 	addi	r2,r2,-28008
81142850:	200891ba 	slli	r4,r4,6
81142854:	1105883a 	add	r2,r2,r4
81142858:	10800804 	addi	r2,r2,32
8114285c:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81142860:	e0bffd17 	ldw	r2,-12(fp)
81142864:	10800044 	addi	r2,r2,1
81142868:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
8114286c:	d0e0b017 	ldw	r3,-32064(gp)
81142870:	e0bffd17 	ldw	r2,-12(fp)
81142874:	1885883a 	add	r2,r3,r2
81142878:	1007883a 	mov	r3,r2
8114287c:	d0a0b417 	ldw	r2,-32048(gp)
81142880:	18800726 	beq	r3,r2,811428a0 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81142884:	d0a0b017 	ldw	r2,-32064(gp)
81142888:	100b883a 	mov	r5,r2
8114288c:	e13ffd17 	ldw	r4,-12(fp)
81142890:	113ee580 	call	8113ee58 <Read_Sector_Data>
81142894:	1000021e 	bne	r2,zero,811428a0 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81142898:	00bfff84 	movi	r2,-2
8114289c:	00001e06 	br	81142918 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
811428a0:	d0e0af17 	ldw	r3,-32068(gp)
811428a4:	e13fff0f 	ldh	r4,-4(fp)
811428a8:	00a045f4 	movhi	r2,33047
811428ac:	10a4a604 	addi	r2,r2,-28008
811428b0:	200891ba 	slli	r4,r4,6
811428b4:	1105883a 	add	r2,r2,r4
811428b8:	10800904 	addi	r2,r2,36
811428bc:	10800017 	ldw	r2,0(r2)
811428c0:	10807fcc 	andi	r2,r2,511
811428c4:	1885883a 	add	r2,r3,r2
811428c8:	10800023 	ldbuio	r2,0(r2)
811428cc:	10803fcc 	andi	r2,r2,255
811428d0:	10803fcc 	andi	r2,r2,255
811428d4:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
811428d8:	e13fff0f 	ldh	r4,-4(fp)
811428dc:	e0ffff0f 	ldh	r3,-4(fp)
811428e0:	00a045f4 	movhi	r2,33047
811428e4:	10a4a604 	addi	r2,r2,-28008
811428e8:	180691ba 	slli	r3,r3,6
811428ec:	10c5883a 	add	r2,r2,r3
811428f0:	10800904 	addi	r2,r2,36
811428f4:	10800017 	ldw	r2,0(r2)
811428f8:	10c00044 	addi	r3,r2,1
811428fc:	00a045f4 	movhi	r2,33047
81142900:	10a4a604 	addi	r2,r2,-28008
81142904:	200891ba 	slli	r4,r4,6
81142908:	1105883a 	add	r2,r2,r4
8114290c:	10800904 	addi	r2,r2,36
81142910:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81142914:	e0bffc0b 	ldhu	r2,-16(fp)
}
81142918:	e037883a 	mov	sp,fp
8114291c:	dfc00117 	ldw	ra,4(sp)
81142920:	df000017 	ldw	fp,0(sp)
81142924:	dec00204 	addi	sp,sp,8
81142928:	f800283a 	ret

8114292c <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
8114292c:	defff804 	addi	sp,sp,-32
81142930:	de00012e 	bgeu	sp,et,81142938 <alt_up_sd_card_write+0xc>
81142934:	003b68fa 	trap	3
81142938:	dfc00715 	stw	ra,28(sp)
8114293c:	df000615 	stw	fp,24(sp)
81142940:	df000604 	addi	fp,sp,24
81142944:	2007883a 	mov	r3,r4
81142948:	2805883a 	mov	r2,r5
8114294c:	e0fffe0d 	sth	r3,-8(fp)
81142950:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81142954:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81142958:	e0bffe0f 	ldh	r2,-8(fp)
8114295c:	10017716 	blt	r2,zero,81142f3c <alt_up_sd_card_write+0x610>
81142960:	e0bffe0f 	ldh	r2,-8(fp)
81142964:	10800508 	cmpgei	r2,r2,20
81142968:	1001741e 	bne	r2,zero,81142f3c <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
8114296c:	e0fffe0f 	ldh	r3,-8(fp)
81142970:	00a045f4 	movhi	r2,33047
81142974:	10a4a604 	addi	r2,r2,-28008
81142978:	180691ba 	slli	r3,r3,6
8114297c:	10c5883a 	add	r2,r2,r3
81142980:	10800f04 	addi	r2,r2,60
81142984:	10800017 	ldw	r2,0(r2)
81142988:	10016c26 	beq	r2,zero,81142f3c <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114298c:	00a045f4 	movhi	r2,33047
81142990:	10a49104 	addi	r2,r2,-28092
81142994:	10c01417 	ldw	r3,80(r2)
81142998:	e13ffe0f 	ldh	r4,-8(fp)
8114299c:	00a045f4 	movhi	r2,33047
811429a0:	10a4a604 	addi	r2,r2,-28008
811429a4:	200891ba 	slli	r4,r4,6
811429a8:	1105883a 	add	r2,r2,r4
811429ac:	10800704 	addi	r2,r2,28
811429b0:	10800017 	ldw	r2,0(r2)
811429b4:	113fff84 	addi	r4,r2,-2
811429b8:	00a045f4 	movhi	r2,33047
811429bc:	10a49104 	addi	r2,r2,-28092
811429c0:	10800383 	ldbu	r2,14(r2)
811429c4:	10803fcc 	andi	r2,r2,255
811429c8:	2085383a 	mul	r2,r4,r2
811429cc:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
811429d0:	e13ffe0f 	ldh	r4,-8(fp)
811429d4:	00a045f4 	movhi	r2,33047
811429d8:	10a4a604 	addi	r2,r2,-28008
811429dc:	200891ba 	slli	r4,r4,6
811429e0:	1105883a 	add	r2,r2,r4
811429e4:	10800804 	addi	r2,r2,32
811429e8:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811429ec:	1885883a 	add	r2,r3,r2
811429f0:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
811429f4:	e0fffe0f 	ldh	r3,-8(fp)
811429f8:	00a045f4 	movhi	r2,33047
811429fc:	10a4a604 	addi	r2,r2,-28008
81142a00:	180691ba 	slli	r3,r3,6
81142a04:	10c5883a 	add	r2,r2,r3
81142a08:	10800904 	addi	r2,r2,36
81142a0c:	10c00017 	ldw	r3,0(r2)
81142a10:	00a045f4 	movhi	r2,33047
81142a14:	10a49104 	addi	r2,r2,-28092
81142a18:	1080030b 	ldhu	r2,12(r2)
81142a1c:	10bfffcc 	andi	r2,r2,65535
81142a20:	1889203a 	divu	r4,r3,r2
81142a24:	2085383a 	mul	r2,r4,r2
81142a28:	1885c83a 	sub	r2,r3,r2
81142a2c:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81142a30:	e0fffe0f 	ldh	r3,-8(fp)
81142a34:	00a045f4 	movhi	r2,33047
81142a38:	10a4a604 	addi	r2,r2,-28008
81142a3c:	180691ba 	slli	r3,r3,6
81142a40:	10c5883a 	add	r2,r2,r3
81142a44:	10800904 	addi	r2,r2,36
81142a48:	10c00017 	ldw	r3,0(r2)
81142a4c:	e13ffe0f 	ldh	r4,-8(fp)
81142a50:	00a045f4 	movhi	r2,33047
81142a54:	10a4a604 	addi	r2,r2,-28008
81142a58:	200891ba 	slli	r4,r4,6
81142a5c:	1105883a 	add	r2,r2,r4
81142a60:	10800604 	addi	r2,r2,24
81142a64:	10800017 	ldw	r2,0(r2)
81142a68:	1880672e 	bgeu	r3,r2,81142c08 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81142a6c:	e0fffe0f 	ldh	r3,-8(fp)
81142a70:	00a045f4 	movhi	r2,33047
81142a74:	10a4a604 	addi	r2,r2,-28008
81142a78:	180691ba 	slli	r3,r3,6
81142a7c:	10c5883a 	add	r2,r2,r3
81142a80:	10800904 	addi	r2,r2,36
81142a84:	10800017 	ldw	r2,0(r2)
81142a88:	1000e126 	beq	r2,zero,81142e10 <alt_up_sd_card_write+0x4e4>
81142a8c:	e0bffc0f 	ldh	r2,-16(fp)
81142a90:	1000df1e 	bne	r2,zero,81142e10 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81142a94:	e0fffe0f 	ldh	r3,-8(fp)
81142a98:	00a045f4 	movhi	r2,33047
81142a9c:	10a4a604 	addi	r2,r2,-28008
81142aa0:	180691ba 	slli	r3,r3,6
81142aa4:	10c5883a 	add	r2,r2,r3
81142aa8:	10800804 	addi	r2,r2,32
81142aac:	10c00017 	ldw	r3,0(r2)
81142ab0:	00a045f4 	movhi	r2,33047
81142ab4:	10a49104 	addi	r2,r2,-28092
81142ab8:	10800383 	ldbu	r2,14(r2)
81142abc:	10803fcc 	andi	r2,r2,255
81142ac0:	10bfffc4 	addi	r2,r2,-1
81142ac4:	18803d1e 	bne	r3,r2,81142bbc <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81142ac8:	e0fffe0f 	ldh	r3,-8(fp)
81142acc:	00a045f4 	movhi	r2,33047
81142ad0:	10a4a604 	addi	r2,r2,-28008
81142ad4:	180691ba 	slli	r3,r3,6
81142ad8:	10c5883a 	add	r2,r2,r3
81142adc:	10800704 	addi	r2,r2,28
81142ae0:	10800017 	ldw	r2,0(r2)
81142ae4:	e0fffc84 	addi	r3,fp,-14
81142ae8:	180b883a 	mov	r5,r3
81142aec:	1009883a 	mov	r4,r2
81142af0:	113ef380 	call	8113ef38 <get_cluster_flag>
81142af4:	10002f26 	beq	r2,zero,81142bb4 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81142af8:	e0bffc8b 	ldhu	r2,-14(fp)
81142afc:	10bfffcc 	andi	r2,r2,65535
81142b00:	10bffe28 	cmpgeui	r2,r2,65528
81142b04:	1000c21e 	bne	r2,zero,81142e10 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81142b08:	e13ffe0f 	ldh	r4,-8(fp)
81142b0c:	e0bffc8b 	ldhu	r2,-14(fp)
81142b10:	10ffffcc 	andi	r3,r2,65535
81142b14:	00a045f4 	movhi	r2,33047
81142b18:	10a4a604 	addi	r2,r2,-28008
81142b1c:	200891ba 	slli	r4,r4,6
81142b20:	1105883a 	add	r2,r2,r4
81142b24:	10800704 	addi	r2,r2,28
81142b28:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81142b2c:	e0fffe0f 	ldh	r3,-8(fp)
81142b30:	00a045f4 	movhi	r2,33047
81142b34:	10a4a604 	addi	r2,r2,-28008
81142b38:	180691ba 	slli	r3,r3,6
81142b3c:	10c5883a 	add	r2,r2,r3
81142b40:	10800804 	addi	r2,r2,32
81142b44:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81142b48:	00a045f4 	movhi	r2,33047
81142b4c:	10a49104 	addi	r2,r2,-28092
81142b50:	10c01417 	ldw	r3,80(r2)
81142b54:	e13ffe0f 	ldh	r4,-8(fp)
81142b58:	00a045f4 	movhi	r2,33047
81142b5c:	10a4a604 	addi	r2,r2,-28008
81142b60:	200891ba 	slli	r4,r4,6
81142b64:	1105883a 	add	r2,r2,r4
81142b68:	10800704 	addi	r2,r2,28
81142b6c:	10800017 	ldw	r2,0(r2)
81142b70:	113fff84 	addi	r4,r2,-2
81142b74:	00a045f4 	movhi	r2,33047
81142b78:	10a49104 	addi	r2,r2,-28092
81142b7c:	10800383 	ldbu	r2,14(r2)
81142b80:	10803fcc 	andi	r2,r2,255
81142b84:	2085383a 	mul	r2,r4,r2
81142b88:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81142b8c:	e13ffe0f 	ldh	r4,-8(fp)
81142b90:	00a045f4 	movhi	r2,33047
81142b94:	10a4a604 	addi	r2,r2,-28008
81142b98:	200891ba 	slli	r4,r4,6
81142b9c:	1105883a 	add	r2,r2,r4
81142ba0:	10800804 	addi	r2,r2,32
81142ba4:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81142ba8:	1885883a 	add	r2,r3,r2
81142bac:	e0bffb15 	stw	r2,-20(fp)
81142bb0:	00009706 	br	81142e10 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81142bb4:	0005883a 	mov	r2,zero
81142bb8:	0000e106 	br	81142f40 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81142bbc:	e13ffe0f 	ldh	r4,-8(fp)
81142bc0:	e0fffe0f 	ldh	r3,-8(fp)
81142bc4:	00a045f4 	movhi	r2,33047
81142bc8:	10a4a604 	addi	r2,r2,-28008
81142bcc:	180691ba 	slli	r3,r3,6
81142bd0:	10c5883a 	add	r2,r2,r3
81142bd4:	10800804 	addi	r2,r2,32
81142bd8:	10800017 	ldw	r2,0(r2)
81142bdc:	10c00044 	addi	r3,r2,1
81142be0:	00a045f4 	movhi	r2,33047
81142be4:	10a4a604 	addi	r2,r2,-28008
81142be8:	200891ba 	slli	r4,r4,6
81142bec:	1105883a 	add	r2,r2,r4
81142bf0:	10800804 	addi	r2,r2,32
81142bf4:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81142bf8:	e0bffb17 	ldw	r2,-20(fp)
81142bfc:	10800044 	addi	r2,r2,1
81142c00:	e0bffb15 	stw	r2,-20(fp)
81142c04:	00008206 	br	81142e10 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81142c08:	e0fffe0f 	ldh	r3,-8(fp)
81142c0c:	00a045f4 	movhi	r2,33047
81142c10:	10a4a604 	addi	r2,r2,-28008
81142c14:	180691ba 	slli	r3,r3,6
81142c18:	10c5883a 	add	r2,r2,r3
81142c1c:	10800904 	addi	r2,r2,36
81142c20:	10800017 	ldw	r2,0(r2)
81142c24:	10007a26 	beq	r2,zero,81142e10 <alt_up_sd_card_write+0x4e4>
81142c28:	e0bffc0f 	ldh	r2,-16(fp)
81142c2c:	1000781e 	bne	r2,zero,81142e10 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81142c30:	e0fffe0f 	ldh	r3,-8(fp)
81142c34:	00a045f4 	movhi	r2,33047
81142c38:	10a4a604 	addi	r2,r2,-28008
81142c3c:	180691ba 	slli	r3,r3,6
81142c40:	10c5883a 	add	r2,r2,r3
81142c44:	10800804 	addi	r2,r2,32
81142c48:	10c00017 	ldw	r3,0(r2)
81142c4c:	00a045f4 	movhi	r2,33047
81142c50:	10a49104 	addi	r2,r2,-28092
81142c54:	10800383 	ldbu	r2,14(r2)
81142c58:	10803fcc 	andi	r2,r2,255
81142c5c:	10bfffc4 	addi	r2,r2,-1
81142c60:	18803e1e 	bne	r3,r2,81142d5c <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81142c64:	e0bffd04 	addi	r2,fp,-12
81142c68:	1009883a 	mov	r4,r2
81142c6c:	1140f7c0 	call	81140f7c <find_first_empty_cluster>
81142c70:	10003826 	beq	r2,zero,81142d54 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81142c74:	e0fffe0f 	ldh	r3,-8(fp)
81142c78:	00a045f4 	movhi	r2,33047
81142c7c:	10a4a604 	addi	r2,r2,-28008
81142c80:	180691ba 	slli	r3,r3,6
81142c84:	10c5883a 	add	r2,r2,r3
81142c88:	10800704 	addi	r2,r2,28
81142c8c:	10800017 	ldw	r2,0(r2)
81142c90:	e0fffd17 	ldw	r3,-12(fp)
81142c94:	18ffffcc 	andi	r3,r3,65535
81142c98:	18e0001c 	xori	r3,r3,32768
81142c9c:	18e00004 	addi	r3,r3,-32768
81142ca0:	01800044 	movi	r6,1
81142ca4:	180b883a 	mov	r5,r3
81142ca8:	1009883a 	mov	r4,r2
81142cac:	113eff40 	call	8113eff4 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
81142cb0:	e0bffd17 	ldw	r2,-12(fp)
81142cb4:	01800044 	movi	r6,1
81142cb8:	017fffc4 	movi	r5,-1
81142cbc:	1009883a 	mov	r4,r2
81142cc0:	113eff40 	call	8113eff4 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
81142cc4:	e0fffe0f 	ldh	r3,-8(fp)
81142cc8:	00a045f4 	movhi	r2,33047
81142ccc:	10a4a604 	addi	r2,r2,-28008
81142cd0:	180691ba 	slli	r3,r3,6
81142cd4:	10c5883a 	add	r2,r2,r3
81142cd8:	10800704 	addi	r2,r2,28
81142cdc:	10800017 	ldw	r2,0(r2)
81142ce0:	e0fffd17 	ldw	r3,-12(fp)
81142ce4:	18ffffcc 	andi	r3,r3,65535
81142ce8:	18e0001c 	xori	r3,r3,32768
81142cec:	18e00004 	addi	r3,r3,-32768
81142cf0:	000d883a 	mov	r6,zero
81142cf4:	180b883a 	mov	r5,r3
81142cf8:	1009883a 	mov	r4,r2
81142cfc:	113eff40 	call	8113eff4 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81142d00:	e0bffd17 	ldw	r2,-12(fp)
81142d04:	000d883a 	mov	r6,zero
81142d08:	017fffc4 	movi	r5,-1
81142d0c:	1009883a 	mov	r4,r2
81142d10:	113eff40 	call	8113eff4 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
81142d14:	e13ffe0f 	ldh	r4,-8(fp)
81142d18:	e0fffd17 	ldw	r3,-12(fp)
81142d1c:	00a045f4 	movhi	r2,33047
81142d20:	10a4a604 	addi	r2,r2,-28008
81142d24:	200891ba 	slli	r4,r4,6
81142d28:	1105883a 	add	r2,r2,r4
81142d2c:	10800704 	addi	r2,r2,28
81142d30:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81142d34:	e0fffe0f 	ldh	r3,-8(fp)
81142d38:	00a045f4 	movhi	r2,33047
81142d3c:	10a4a604 	addi	r2,r2,-28008
81142d40:	180691ba 	slli	r3,r3,6
81142d44:	10c5883a 	add	r2,r2,r3
81142d48:	10800804 	addi	r2,r2,32
81142d4c:	10000015 	stw	zero,0(r2)
81142d50:	00001506 	br	81142da8 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81142d54:	0005883a 	mov	r2,zero
81142d58:	00007906 	br	81142f40 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81142d5c:	e13ffe0f 	ldh	r4,-8(fp)
81142d60:	e0fffe0f 	ldh	r3,-8(fp)
81142d64:	00a045f4 	movhi	r2,33047
81142d68:	10a4a604 	addi	r2,r2,-28008
81142d6c:	180691ba 	slli	r3,r3,6
81142d70:	10c5883a 	add	r2,r2,r3
81142d74:	10800904 	addi	r2,r2,36
81142d78:	10c00017 	ldw	r3,0(r2)
81142d7c:	00a045f4 	movhi	r2,33047
81142d80:	10a49104 	addi	r2,r2,-28092
81142d84:	1080030b 	ldhu	r2,12(r2)
81142d88:	10bfffcc 	andi	r2,r2,65535
81142d8c:	1887203a 	divu	r3,r3,r2
81142d90:	00a045f4 	movhi	r2,33047
81142d94:	10a4a604 	addi	r2,r2,-28008
81142d98:	200891ba 	slli	r4,r4,6
81142d9c:	1105883a 	add	r2,r2,r4
81142da0:	10800804 	addi	r2,r2,32
81142da4:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81142da8:	00a045f4 	movhi	r2,33047
81142dac:	10a49104 	addi	r2,r2,-28092
81142db0:	10c01417 	ldw	r3,80(r2)
81142db4:	e13ffe0f 	ldh	r4,-8(fp)
81142db8:	00a045f4 	movhi	r2,33047
81142dbc:	10a4a604 	addi	r2,r2,-28008
81142dc0:	200891ba 	slli	r4,r4,6
81142dc4:	1105883a 	add	r2,r2,r4
81142dc8:	10800704 	addi	r2,r2,28
81142dcc:	10800017 	ldw	r2,0(r2)
81142dd0:	113fff84 	addi	r4,r2,-2
81142dd4:	00a045f4 	movhi	r2,33047
81142dd8:	10a49104 	addi	r2,r2,-28092
81142ddc:	10800383 	ldbu	r2,14(r2)
81142de0:	10803fcc 	andi	r2,r2,255
81142de4:	2085383a 	mul	r2,r4,r2
81142de8:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81142dec:	e13ffe0f 	ldh	r4,-8(fp)
81142df0:	00a045f4 	movhi	r2,33047
81142df4:	10a4a604 	addi	r2,r2,-28008
81142df8:	200891ba 	slli	r4,r4,6
81142dfc:	1105883a 	add	r2,r2,r4
81142e00:	10800804 	addi	r2,r2,32
81142e04:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81142e08:	1885883a 	add	r2,r3,r2
81142e0c:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81142e10:	d0e0b017 	ldw	r3,-32064(gp)
81142e14:	e0bffb17 	ldw	r2,-20(fp)
81142e18:	1885883a 	add	r2,r3,r2
81142e1c:	1007883a 	mov	r3,r2
81142e20:	d0a0b417 	ldw	r2,-32048(gp)
81142e24:	18800726 	beq	r3,r2,81142e44 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81142e28:	d0a0b017 	ldw	r2,-32064(gp)
81142e2c:	100b883a 	mov	r5,r2
81142e30:	e13ffb17 	ldw	r4,-20(fp)
81142e34:	113ee580 	call	8113ee58 <Read_Sector_Data>
81142e38:	1000021e 	bne	r2,zero,81142e44 <alt_up_sd_card_write+0x518>
                {
					return false;
81142e3c:	0005883a 	mov	r2,zero
81142e40:	00003f06 	br	81142f40 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81142e44:	d0e0af17 	ldw	r3,-32068(gp)
81142e48:	e0bffc0f 	ldh	r2,-16(fp)
81142e4c:	1885883a 	add	r2,r3,r2
81142e50:	e0ffff07 	ldb	r3,-4(fp)
81142e54:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81142e58:	e13ffe0f 	ldh	r4,-8(fp)
81142e5c:	e0fffe0f 	ldh	r3,-8(fp)
81142e60:	00a045f4 	movhi	r2,33047
81142e64:	10a4a604 	addi	r2,r2,-28008
81142e68:	180691ba 	slli	r3,r3,6
81142e6c:	10c5883a 	add	r2,r2,r3
81142e70:	10800904 	addi	r2,r2,36
81142e74:	10800017 	ldw	r2,0(r2)
81142e78:	10c00044 	addi	r3,r2,1
81142e7c:	00a045f4 	movhi	r2,33047
81142e80:	10a4a604 	addi	r2,r2,-28008
81142e84:	200891ba 	slli	r4,r4,6
81142e88:	1105883a 	add	r2,r2,r4
81142e8c:	10800904 	addi	r2,r2,36
81142e90:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81142e94:	e0fffe0f 	ldh	r3,-8(fp)
81142e98:	00a045f4 	movhi	r2,33047
81142e9c:	10a4a604 	addi	r2,r2,-28008
81142ea0:	180691ba 	slli	r3,r3,6
81142ea4:	10c5883a 	add	r2,r2,r3
81142ea8:	10800904 	addi	r2,r2,36
81142eac:	10c00017 	ldw	r3,0(r2)
81142eb0:	e13ffe0f 	ldh	r4,-8(fp)
81142eb4:	00a045f4 	movhi	r2,33047
81142eb8:	10a4a604 	addi	r2,r2,-28008
81142ebc:	200891ba 	slli	r4,r4,6
81142ec0:	1105883a 	add	r2,r2,r4
81142ec4:	10800604 	addi	r2,r2,24
81142ec8:	10800017 	ldw	r2,0(r2)
81142ecc:	18801736 	bltu	r3,r2,81142f2c <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
81142ed0:	e13ffe0f 	ldh	r4,-8(fp)
81142ed4:	e0fffe0f 	ldh	r3,-8(fp)
81142ed8:	00a045f4 	movhi	r2,33047
81142edc:	10a4a604 	addi	r2,r2,-28008
81142ee0:	180691ba 	slli	r3,r3,6
81142ee4:	10c5883a 	add	r2,r2,r3
81142ee8:	10800604 	addi	r2,r2,24
81142eec:	10800017 	ldw	r2,0(r2)
81142ef0:	10c00044 	addi	r3,r2,1
81142ef4:	00a045f4 	movhi	r2,33047
81142ef8:	10a4a604 	addi	r2,r2,-28008
81142efc:	200891ba 	slli	r4,r4,6
81142f00:	1105883a 	add	r2,r2,r4
81142f04:	10800604 	addi	r2,r2,24
81142f08:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81142f0c:	e0fffe0f 	ldh	r3,-8(fp)
81142f10:	00a045f4 	movhi	r2,33047
81142f14:	10a4a604 	addi	r2,r2,-28008
81142f18:	180691ba 	slli	r3,r3,6
81142f1c:	10c5883a 	add	r2,r2,r3
81142f20:	10800e04 	addi	r2,r2,56
81142f24:	00c00044 	movi	r3,1
81142f28:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81142f2c:	00800044 	movi	r2,1
81142f30:	d0a0b315 	stw	r2,-32052(gp)
			result = true;
81142f34:	00800044 	movi	r2,1
81142f38:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81142f3c:	e0bffa17 	ldw	r2,-24(fp)
}
81142f40:	e037883a 	mov	sp,fp
81142f44:	dfc00117 	ldw	ra,4(sp)
81142f48:	df000017 	ldw	fp,0(sp)
81142f4c:	dec00204 	addi	sp,sp,8
81142f50:	f800283a 	ret

81142f54 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81142f54:	defffb04 	addi	sp,sp,-20
81142f58:	de00012e 	bgeu	sp,et,81142f60 <alt_up_sd_card_fclose+0xc>
81142f5c:	003b68fa 	trap	3
81142f60:	dfc00415 	stw	ra,16(sp)
81142f64:	df000315 	stw	fp,12(sp)
81142f68:	df000304 	addi	fp,sp,12
81142f6c:	2005883a 	mov	r2,r4
81142f70:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81142f74:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81142f78:	1141b300 	call	81141b30 <alt_up_sd_card_is_Present>
81142f7c:	10006026 	beq	r2,zero,81143100 <alt_up_sd_card_fclose+0x1ac>
81142f80:	d0a0a917 	ldw	r2,-32092(gp)
81142f84:	10005e26 	beq	r2,zero,81143100 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81142f88:	e0ffff0f 	ldh	r3,-4(fp)
81142f8c:	00a045f4 	movhi	r2,33047
81142f90:	10a4a604 	addi	r2,r2,-28008
81142f94:	180691ba 	slli	r3,r3,6
81142f98:	10c5883a 	add	r2,r2,r3
81142f9c:	10800f04 	addi	r2,r2,60
81142fa0:	10800017 	ldw	r2,0(r2)
81142fa4:	10005626 	beq	r2,zero,81143100 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81142fa8:	e0ffff0f 	ldh	r3,-4(fp)
81142fac:	00a045f4 	movhi	r2,33047
81142fb0:	10a4a604 	addi	r2,r2,-28008
81142fb4:	180691ba 	slli	r3,r3,6
81142fb8:	10c5883a 	add	r2,r2,r3
81142fbc:	10800e04 	addi	r2,r2,56
81142fc0:	10800017 	ldw	r2,0(r2)
81142fc4:	10004526 	beq	r2,zero,811430dc <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
81142fc8:	e0ffff0f 	ldh	r3,-4(fp)
81142fcc:	00a045f4 	movhi	r2,33047
81142fd0:	10a4a604 	addi	r2,r2,-28008
81142fd4:	180691ba 	slli	r3,r3,6
81142fd8:	10c5883a 	add	r2,r2,r3
81142fdc:	10800b04 	addi	r2,r2,44
81142fe0:	10800017 	ldw	r2,0(r2)
81142fe4:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81142fe8:	e0ffff0f 	ldh	r3,-4(fp)
81142fec:	00a045f4 	movhi	r2,33047
81142ff0:	10a4a604 	addi	r2,r2,-28008
81142ff4:	180691ba 	slli	r3,r3,6
81142ff8:	10c5883a 	add	r2,r2,r3
81142ffc:	10800a04 	addi	r2,r2,40
81143000:	10800017 	ldw	r2,0(r2)
81143004:	1000071e 	bne	r2,zero,81143024 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81143008:	00a045f4 	movhi	r2,33047
8114300c:	10a49104 	addi	r2,r2,-28092
81143010:	10801317 	ldw	r2,76(r2)
81143014:	e0fffe17 	ldw	r3,-8(fp)
81143018:	1885883a 	add	r2,r3,r2
8114301c:	e0bffe15 	stw	r2,-8(fp)
81143020:	00001406 	br	81143074 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81143024:	00a045f4 	movhi	r2,33047
81143028:	10a49104 	addi	r2,r2,-28092
8114302c:	10c01417 	ldw	r3,80(r2)
81143030:	e0bffe17 	ldw	r2,-8(fp)
81143034:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
81143038:	e13fff0f 	ldh	r4,-4(fp)
8114303c:	00a045f4 	movhi	r2,33047
81143040:	10a4a604 	addi	r2,r2,-28008
81143044:	200891ba 	slli	r4,r4,6
81143048:	1105883a 	add	r2,r2,r4
8114304c:	10800a04 	addi	r2,r2,40
81143050:	10800017 	ldw	r2,0(r2)
81143054:	113fff84 	addi	r4,r2,-2
81143058:	00a045f4 	movhi	r2,33047
8114305c:	10a49104 	addi	r2,r2,-28092
81143060:	10800383 	ldbu	r2,14(r2)
81143064:	10803fcc 	andi	r2,r2,255
81143068:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8114306c:	1885883a 	add	r2,r3,r2
81143070:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81143074:	e0bffe17 	ldw	r2,-8(fp)
81143078:	d0e0b017 	ldw	r3,-32064(gp)
8114307c:	180b883a 	mov	r5,r3
81143080:	1009883a 	mov	r4,r2
81143084:	113ee580 	call	8113ee58 <Read_Sector_Data>
81143088:	10001426 	beq	r2,zero,811430dc <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
8114308c:	e0ffff0f 	ldh	r3,-4(fp)
81143090:	00a045f4 	movhi	r2,33047
81143094:	10a4a604 	addi	r2,r2,-28008
81143098:	180691ba 	slli	r3,r3,6
8114309c:	10c5883a 	add	r2,r2,r3
811430a0:	10800c04 	addi	r2,r2,48
811430a4:	1080000b 	ldhu	r2,0(r2)
811430a8:	113fffcc 	andi	r4,r2,65535
811430ac:	2120001c 	xori	r4,r4,32768
811430b0:	21200004 	addi	r4,r4,-32768
811430b4:	e0bfff0f 	ldh	r2,-4(fp)
811430b8:	100691ba 	slli	r3,r2,6
811430bc:	00a045f4 	movhi	r2,33047
811430c0:	10a4a604 	addi	r2,r2,-28008
811430c4:	1885883a 	add	r2,r3,r2
811430c8:	100b883a 	mov	r5,r2
811430cc:	113f50c0 	call	8113f50c <Write_File_Record_At_Offset>
811430d0:	10000226 	beq	r2,zero,811430dc <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
811430d4:	113ee040 	call	8113ee04 <Save_Modified_Sector>
811430d8:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
811430dc:	e0ffff0f 	ldh	r3,-4(fp)
811430e0:	00a045f4 	movhi	r2,33047
811430e4:	10a4a604 	addi	r2,r2,-28008
811430e8:	180691ba 	slli	r3,r3,6
811430ec:	10c5883a 	add	r2,r2,r3
811430f0:	10800f04 	addi	r2,r2,60
811430f4:	10000015 	stw	zero,0(r2)
			result = true;
811430f8:	00800044 	movi	r2,1
811430fc:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81143100:	e0bffd17 	ldw	r2,-12(fp)
}
81143104:	e037883a 	mov	sp,fp
81143108:	dfc00117 	ldw	ra,4(sp)
8114310c:	df000017 	ldw	fp,0(sp)
81143110:	dec00204 	addi	sp,sp,8
81143114:	f800283a 	ret

81143118 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81143118:	defffa04 	addi	sp,sp,-24
8114311c:	de00012e 	bgeu	sp,et,81143124 <altera_avalon_jtag_uart_read_fd+0xc>
81143120:	003b68fa 	trap	3
81143124:	dfc00515 	stw	ra,20(sp)
81143128:	df000415 	stw	fp,16(sp)
8114312c:	df000404 	addi	fp,sp,16
81143130:	e13ffd15 	stw	r4,-12(fp)
81143134:	e17ffe15 	stw	r5,-8(fp)
81143138:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8114313c:	e0bffd17 	ldw	r2,-12(fp)
81143140:	10800017 	ldw	r2,0(r2)
81143144:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
81143148:	e0bffc17 	ldw	r2,-16(fp)
8114314c:	10c00a04 	addi	r3,r2,40
81143150:	e0bffd17 	ldw	r2,-12(fp)
81143154:	10800217 	ldw	r2,8(r2)
81143158:	100f883a 	mov	r7,r2
8114315c:	e1bfff17 	ldw	r6,-4(fp)
81143160:	e17ffe17 	ldw	r5,-8(fp)
81143164:	1809883a 	mov	r4,r3
81143168:	114399c0 	call	8114399c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
8114316c:	e037883a 	mov	sp,fp
81143170:	dfc00117 	ldw	ra,4(sp)
81143174:	df000017 	ldw	fp,0(sp)
81143178:	dec00204 	addi	sp,sp,8
8114317c:	f800283a 	ret

81143180 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81143180:	defffa04 	addi	sp,sp,-24
81143184:	de00012e 	bgeu	sp,et,8114318c <altera_avalon_jtag_uart_write_fd+0xc>
81143188:	003b68fa 	trap	3
8114318c:	dfc00515 	stw	ra,20(sp)
81143190:	df000415 	stw	fp,16(sp)
81143194:	df000404 	addi	fp,sp,16
81143198:	e13ffd15 	stw	r4,-12(fp)
8114319c:	e17ffe15 	stw	r5,-8(fp)
811431a0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811431a4:	e0bffd17 	ldw	r2,-12(fp)
811431a8:	10800017 	ldw	r2,0(r2)
811431ac:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
811431b0:	e0bffc17 	ldw	r2,-16(fp)
811431b4:	10c00a04 	addi	r3,r2,40
811431b8:	e0bffd17 	ldw	r2,-12(fp)
811431bc:	10800217 	ldw	r2,8(r2)
811431c0:	100f883a 	mov	r7,r2
811431c4:	e1bfff17 	ldw	r6,-4(fp)
811431c8:	e17ffe17 	ldw	r5,-8(fp)
811431cc:	1809883a 	mov	r4,r3
811431d0:	1143c600 	call	81143c60 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
811431d4:	e037883a 	mov	sp,fp
811431d8:	dfc00117 	ldw	ra,4(sp)
811431dc:	df000017 	ldw	fp,0(sp)
811431e0:	dec00204 	addi	sp,sp,8
811431e4:	f800283a 	ret

811431e8 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
811431e8:	defffc04 	addi	sp,sp,-16
811431ec:	de00012e 	bgeu	sp,et,811431f4 <altera_avalon_jtag_uart_close_fd+0xc>
811431f0:	003b68fa 	trap	3
811431f4:	dfc00315 	stw	ra,12(sp)
811431f8:	df000215 	stw	fp,8(sp)
811431fc:	df000204 	addi	fp,sp,8
81143200:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81143204:	e0bfff17 	ldw	r2,-4(fp)
81143208:	10800017 	ldw	r2,0(r2)
8114320c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81143210:	e0bffe17 	ldw	r2,-8(fp)
81143214:	10c00a04 	addi	r3,r2,40
81143218:	e0bfff17 	ldw	r2,-4(fp)
8114321c:	10800217 	ldw	r2,8(r2)
81143220:	100b883a 	mov	r5,r2
81143224:	1809883a 	mov	r4,r3
81143228:	11438340 	call	81143834 <altera_avalon_jtag_uart_close>
}
8114322c:	e037883a 	mov	sp,fp
81143230:	dfc00117 	ldw	ra,4(sp)
81143234:	df000017 	ldw	fp,0(sp)
81143238:	dec00204 	addi	sp,sp,8
8114323c:	f800283a 	ret

81143240 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81143240:	defffa04 	addi	sp,sp,-24
81143244:	de00012e 	bgeu	sp,et,8114324c <altera_avalon_jtag_uart_ioctl_fd+0xc>
81143248:	003b68fa 	trap	3
8114324c:	dfc00515 	stw	ra,20(sp)
81143250:	df000415 	stw	fp,16(sp)
81143254:	df000404 	addi	fp,sp,16
81143258:	e13ffd15 	stw	r4,-12(fp)
8114325c:	e17ffe15 	stw	r5,-8(fp)
81143260:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81143264:	e0bffd17 	ldw	r2,-12(fp)
81143268:	10800017 	ldw	r2,0(r2)
8114326c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81143270:	e0bffc17 	ldw	r2,-16(fp)
81143274:	10800a04 	addi	r2,r2,40
81143278:	e1bfff17 	ldw	r6,-4(fp)
8114327c:	e17ffe17 	ldw	r5,-8(fp)
81143280:	1009883a 	mov	r4,r2
81143284:	11438a40 	call	811438a4 <altera_avalon_jtag_uart_ioctl>
}
81143288:	e037883a 	mov	sp,fp
8114328c:	dfc00117 	ldw	ra,4(sp)
81143290:	df000017 	ldw	fp,0(sp)
81143294:	dec00204 	addi	sp,sp,8
81143298:	f800283a 	ret

8114329c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
8114329c:	deffef04 	addi	sp,sp,-68
811432a0:	de00012e 	bgeu	sp,et,811432a8 <altera_avalon_jtag_uart_init+0xc>
811432a4:	003b68fa 	trap	3
811432a8:	dfc01015 	stw	ra,64(sp)
811432ac:	df000f15 	stw	fp,60(sp)
811432b0:	dc400e15 	stw	r17,56(sp)
811432b4:	dc000d15 	stw	r16,52(sp)
811432b8:	df000f04 	addi	fp,sp,60
811432bc:	e13ff715 	stw	r4,-36(fp)
811432c0:	e17ff815 	stw	r5,-32(fp)
811432c4:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
811432c8:	e0bff717 	ldw	r2,-36(fp)
811432cc:	10800c04 	addi	r2,r2,48
811432d0:	e0bff215 	stw	r2,-56(fp)
811432d4:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811432d8:	e0bff60b 	ldhu	r2,-40(fp)
811432dc:	e0fff684 	addi	r3,fp,-38
811432e0:	180b883a 	mov	r5,r3
811432e4:	1009883a 	mov	r4,r2
811432e8:	113746c0 	call	8113746c <OSFlagCreate>
811432ec:	1007883a 	mov	r3,r2
811432f0:	e0bff217 	ldw	r2,-56(fp)
811432f4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
811432f8:	e0bff717 	ldw	r2,-36(fp)
811432fc:	10800a04 	addi	r2,r2,40
81143300:	e0bff315 	stw	r2,-52(fp)
81143304:	00800044 	movi	r2,1
81143308:	e0bff58d 	sth	r2,-42(fp)
8114330c:	e0bff58b 	ldhu	r2,-42(fp)
81143310:	1009883a 	mov	r4,r2
81143314:	113b3c80 	call	8113b3c8 <OSSemCreate>
81143318:	1007883a 	mov	r3,r2
8114331c:	e0bff317 	ldw	r2,-52(fp)
81143320:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81143324:	e0bff717 	ldw	r2,-36(fp)
81143328:	10800b04 	addi	r2,r2,44
8114332c:	e0bff415 	stw	r2,-48(fp)
81143330:	00800044 	movi	r2,1
81143334:	e0bff50d 	sth	r2,-44(fp)
81143338:	e0bff50b 	ldhu	r2,-44(fp)
8114333c:	1009883a 	mov	r4,r2
81143340:	113b3c80 	call	8113b3c8 <OSSemCreate>
81143344:	1007883a 	mov	r3,r2
81143348:	e0bff417 	ldw	r2,-48(fp)
8114334c:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81143350:	e0bff717 	ldw	r2,-36(fp)
81143354:	00c00044 	movi	r3,1
81143358:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
8114335c:	e0bff717 	ldw	r2,-36(fp)
81143360:	10800017 	ldw	r2,0(r2)
81143364:	10800104 	addi	r2,r2,4
81143368:	1007883a 	mov	r3,r2
8114336c:	e0bff717 	ldw	r2,-36(fp)
81143370:	10800817 	ldw	r2,32(r2)
81143374:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81143378:	e0bff817 	ldw	r2,-32(fp)
8114337c:	e0fff917 	ldw	r3,-28(fp)
81143380:	d8000015 	stw	zero,0(sp)
81143384:	e1fff717 	ldw	r7,-36(fp)
81143388:	01a04534 	movhi	r6,33044
8114338c:	318d1b04 	addi	r6,r6,13420
81143390:	180b883a 	mov	r5,r3
81143394:	1009883a 	mov	r4,r2
81143398:	11471b40 	call	811471b4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
8114339c:	e0bff717 	ldw	r2,-36(fp)
811433a0:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
811433a4:	e0bff717 	ldw	r2,-36(fp)
811433a8:	10800204 	addi	r2,r2,8
811433ac:	d0e08717 	ldw	r3,-32228(gp)
811433b0:	e1fff717 	ldw	r7,-36(fp)
811433b4:	01a04534 	movhi	r6,33044
811433b8:	318dca04 	addi	r6,r6,14120
811433bc:	180b883a 	mov	r5,r3
811433c0:	1009883a 	mov	r4,r2
811433c4:	1146d040 	call	81146d04 <alt_alarm_start>
811433c8:	1000040e 	bge	r2,zero,811433dc <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
811433cc:	e0fff717 	ldw	r3,-36(fp)
811433d0:	00a00034 	movhi	r2,32768
811433d4:	10bfffc4 	addi	r2,r2,-1
811433d8:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
811433dc:	d0a08083 	ldbu	r2,-32254(gp)
811433e0:	10803fcc 	andi	r2,r2,255
811433e4:	10800058 	cmpnei	r2,r2,1
811433e8:	10000f1e 	bne	r2,zero,81143428 <altera_avalon_jtag_uart_init+0x18c>
811433ec:	d0e08717 	ldw	r3,-32228(gp)
811433f0:	00b33374 	movhi	r2,52429
811433f4:	10b33344 	addi	r2,r2,-13107
811433f8:	1888383a 	mulxuu	r4,r3,r2
811433fc:	1885383a 	mul	r2,r3,r2
81143400:	1021883a 	mov	r16,r2
81143404:	2023883a 	mov	r17,r4
81143408:	8804d0fa 	srli	r2,r17,3
8114340c:	e1fff717 	ldw	r7,-36(fp)
81143410:	01a044f4 	movhi	r6,33043
81143414:	318ee704 	addi	r6,r6,15260
81143418:	100b883a 	mov	r5,r2
8114341c:	012045b4 	movhi	r4,33046
81143420:	210c6504 	addi	r4,r4,12692
81143424:	1146d040 	call	81146d04 <alt_alarm_start>
81143428:	d0a08103 	ldbu	r2,-32252(gp)
8114342c:	10803fcc 	andi	r2,r2,255
81143430:	10800058 	cmpnei	r2,r2,1
81143434:	1000051e 	bne	r2,zero,8114344c <altera_avalon_jtag_uart_init+0x1b0>
81143438:	e0bff717 	ldw	r2,-36(fp)
8114343c:	10800017 	ldw	r2,0(r2)
81143440:	100b883a 	mov	r5,r2
81143444:	e13ff717 	ldw	r4,-36(fp)
81143448:	1133d340 	call	81133d34 <alt_log_jtag_uart_startup_info>
}
8114344c:	0001883a 	nop
81143450:	e6fffe04 	addi	sp,fp,-8
81143454:	dfc00317 	ldw	ra,12(sp)
81143458:	df000217 	ldw	fp,8(sp)
8114345c:	dc400117 	ldw	r17,4(sp)
81143460:	dc000017 	ldw	r16,0(sp)
81143464:	dec00404 	addi	sp,sp,16
81143468:	f800283a 	ret

8114346c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
8114346c:	defff204 	addi	sp,sp,-56
81143470:	de00012e 	bgeu	sp,et,81143478 <altera_avalon_jtag_uart_irq+0xc>
81143474:	003b68fa 	trap	3
81143478:	dfc00d15 	stw	ra,52(sp)
8114347c:	df000c15 	stw	fp,48(sp)
81143480:	df000c04 	addi	fp,sp,48
81143484:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81143488:	e0bfff17 	ldw	r2,-4(fp)
8114348c:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81143490:	e0bff617 	ldw	r2,-40(fp)
81143494:	10800017 	ldw	r2,0(r2)
81143498:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
8114349c:	e0bff717 	ldw	r2,-36(fp)
811434a0:	e17ff617 	ldw	r5,-40(fp)
811434a4:	1009883a 	mov	r4,r2
811434a8:	1133d880 	call	81133d88 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811434ac:	e0bff717 	ldw	r2,-36(fp)
811434b0:	10800104 	addi	r2,r2,4
811434b4:	10800037 	ldwio	r2,0(r2)
811434b8:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
811434bc:	e0bff817 	ldw	r2,-32(fp)
811434c0:	1080c00c 	andi	r2,r2,768
811434c4:	10009126 	beq	r2,zero,8114370c <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
811434c8:	e0bff817 	ldw	r2,-32(fp)
811434cc:	1080400c 	andi	r2,r2,256
811434d0:	10004726 	beq	r2,zero,811435f0 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
811434d4:	00800074 	movhi	r2,1
811434d8:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811434dc:	e0bff617 	ldw	r2,-40(fp)
811434e0:	10800d17 	ldw	r2,52(r2)
811434e4:	10800044 	addi	r2,r2,1
811434e8:	1081ffcc 	andi	r2,r2,2047
811434ec:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
811434f0:	e0bff617 	ldw	r2,-40(fp)
811434f4:	10c00e17 	ldw	r3,56(r2)
811434f8:	e0bff917 	ldw	r2,-28(fp)
811434fc:	18802726 	beq	r3,r2,8114359c <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81143500:	e0bff717 	ldw	r2,-36(fp)
81143504:	10800037 	ldwio	r2,0(r2)
81143508:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
8114350c:	e0bff417 	ldw	r2,-48(fp)
81143510:	10a0000c 	andi	r2,r2,32768
81143514:	10002326 	beq	r2,zero,811435a4 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81143518:	e0bff617 	ldw	r2,-40(fp)
8114351c:	10800d17 	ldw	r2,52(r2)
81143520:	e0fff417 	ldw	r3,-48(fp)
81143524:	1809883a 	mov	r4,r3
81143528:	e0fff617 	ldw	r3,-40(fp)
8114352c:	1885883a 	add	r2,r3,r2
81143530:	10801104 	addi	r2,r2,68
81143534:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81143538:	e0bff617 	ldw	r2,-40(fp)
8114353c:	10800d17 	ldw	r2,52(r2)
81143540:	10800044 	addi	r2,r2,1
81143544:	10c1ffcc 	andi	r3,r2,2047
81143548:	e0bff617 	ldw	r2,-40(fp)
8114354c:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81143550:	e0bff617 	ldw	r2,-40(fp)
81143554:	10800c17 	ldw	r2,48(r2)
81143558:	e0bffb15 	stw	r2,-20(fp)
8114355c:	00800044 	movi	r2,1
81143560:	e0bffc0d 	sth	r2,-16(fp)
81143564:	00800044 	movi	r2,1
81143568:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114356c:	d0a09003 	ldbu	r2,-32192(gp)
81143570:	10803fcc 	andi	r2,r2,255
81143574:	103fd926 	beq	r2,zero,811434dc <__reset+0xfb1234dc>
  {
    OSFlagPost (group, flags, opt, &err);
81143578:	e0bffc0b 	ldhu	r2,-16(fp)
8114357c:	e0fffc83 	ldbu	r3,-14(fp)
81143580:	e13ffdc4 	addi	r4,fp,-9
81143584:	200f883a 	mov	r7,r4
81143588:	180d883a 	mov	r6,r3
8114358c:	100b883a 	mov	r5,r2
81143590:	e13ffb17 	ldw	r4,-20(fp)
81143594:	11380780 	call	81138078 <OSFlagPost>
      }
81143598:	003fd006 	br	811434dc <__reset+0xfb1234dc>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
8114359c:	0001883a 	nop
811435a0:	00000106 	br	811435a8 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
811435a4:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
811435a8:	e0bff417 	ldw	r2,-48(fp)
811435ac:	10bfffec 	andhi	r2,r2,65535
811435b0:	10000f26 	beq	r2,zero,811435f0 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811435b4:	e0bff617 	ldw	r2,-40(fp)
811435b8:	10c00817 	ldw	r3,32(r2)
811435bc:	00bfff84 	movi	r2,-2
811435c0:	1886703a 	and	r3,r3,r2
811435c4:	e0bff617 	ldw	r2,-40(fp)
811435c8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
811435cc:	e0bff717 	ldw	r2,-36(fp)
811435d0:	10800104 	addi	r2,r2,4
811435d4:	1007883a 	mov	r3,r2
811435d8:	e0bff617 	ldw	r2,-40(fp)
811435dc:	10800817 	ldw	r2,32(r2)
811435e0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811435e4:	e0bff717 	ldw	r2,-36(fp)
811435e8:	10800104 	addi	r2,r2,4
811435ec:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
811435f0:	e0bff817 	ldw	r2,-32(fp)
811435f4:	1080800c 	andi	r2,r2,512
811435f8:	103fac26 	beq	r2,zero,811434ac <__reset+0xfb1234ac>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
811435fc:	e0bff817 	ldw	r2,-32(fp)
81143600:	1004d43a 	srli	r2,r2,16
81143604:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81143608:	00002606 	br	811436a4 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
8114360c:	e0bff717 	ldw	r2,-36(fp)
81143610:	e0fff617 	ldw	r3,-40(fp)
81143614:	18c01017 	ldw	r3,64(r3)
81143618:	e13ff617 	ldw	r4,-40(fp)
8114361c:	20c7883a 	add	r3,r4,r3
81143620:	18c21104 	addi	r3,r3,2116
81143624:	18c00003 	ldbu	r3,0(r3)
81143628:	18c03fcc 	andi	r3,r3,255
8114362c:	18c0201c 	xori	r3,r3,128
81143630:	18ffe004 	addi	r3,r3,-128
81143634:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81143638:	e0bff617 	ldw	r2,-40(fp)
8114363c:	10801017 	ldw	r2,64(r2)
81143640:	10800044 	addi	r2,r2,1
81143644:	10c1ffcc 	andi	r3,r2,2047
81143648:	e0bff617 	ldw	r2,-40(fp)
8114364c:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81143650:	e0bff617 	ldw	r2,-40(fp)
81143654:	10800c17 	ldw	r2,48(r2)
81143658:	e0bffa15 	stw	r2,-24(fp)
8114365c:	00800084 	movi	r2,2
81143660:	e0bffd0d 	sth	r2,-12(fp)
81143664:	00800044 	movi	r2,1
81143668:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114366c:	d0a09003 	ldbu	r2,-32192(gp)
81143670:	10803fcc 	andi	r2,r2,255
81143674:	10000826 	beq	r2,zero,81143698 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81143678:	e0bffd0b 	ldhu	r2,-12(fp)
8114367c:	e0fffd83 	ldbu	r3,-10(fp)
81143680:	e13ffe04 	addi	r4,fp,-8
81143684:	200f883a 	mov	r7,r4
81143688:	180d883a 	mov	r6,r3
8114368c:	100b883a 	mov	r5,r2
81143690:	e13ffa17 	ldw	r4,-24(fp)
81143694:	11380780 	call	81138078 <OSFlagPost>

        space--;
81143698:	e0bff517 	ldw	r2,-44(fp)
8114369c:	10bfffc4 	addi	r2,r2,-1
811436a0:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
811436a4:	e0bff517 	ldw	r2,-44(fp)
811436a8:	10000526 	beq	r2,zero,811436c0 <altera_avalon_jtag_uart_irq+0x254>
811436ac:	e0bff617 	ldw	r2,-40(fp)
811436b0:	10c01017 	ldw	r3,64(r2)
811436b4:	e0bff617 	ldw	r2,-40(fp)
811436b8:	10800f17 	ldw	r2,60(r2)
811436bc:	18bfd31e 	bne	r3,r2,8114360c <__reset+0xfb12360c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
811436c0:	e0bff517 	ldw	r2,-44(fp)
811436c4:	103f7926 	beq	r2,zero,811434ac <__reset+0xfb1234ac>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811436c8:	e0bff617 	ldw	r2,-40(fp)
811436cc:	10c00817 	ldw	r3,32(r2)
811436d0:	00bfff44 	movi	r2,-3
811436d4:	1886703a 	and	r3,r3,r2
811436d8:	e0bff617 	ldw	r2,-40(fp)
811436dc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811436e0:	e0bff617 	ldw	r2,-40(fp)
811436e4:	10800017 	ldw	r2,0(r2)
811436e8:	10800104 	addi	r2,r2,4
811436ec:	1007883a 	mov	r3,r2
811436f0:	e0bff617 	ldw	r2,-40(fp)
811436f4:	10800817 	ldw	r2,32(r2)
811436f8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811436fc:	e0bff717 	ldw	r2,-36(fp)
81143700:	10800104 	addi	r2,r2,4
81143704:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81143708:	003f6806 	br	811434ac <__reset+0xfb1234ac>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
8114370c:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81143710:	0001883a 	nop
81143714:	e037883a 	mov	sp,fp
81143718:	dfc00117 	ldw	ra,4(sp)
8114371c:	df000017 	ldw	fp,0(sp)
81143720:	dec00204 	addi	sp,sp,8
81143724:	f800283a 	ret

81143728 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81143728:	defff904 	addi	sp,sp,-28
8114372c:	de00012e 	bgeu	sp,et,81143734 <altera_avalon_jtag_uart_timeout+0xc>
81143730:	003b68fa 	trap	3
81143734:	dfc00615 	stw	ra,24(sp)
81143738:	df000515 	stw	fp,20(sp)
8114373c:	df000504 	addi	fp,sp,20
81143740:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81143744:	e0bfff17 	ldw	r2,-4(fp)
81143748:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
8114374c:	e0bffb17 	ldw	r2,-20(fp)
81143750:	10800017 	ldw	r2,0(r2)
81143754:	10800104 	addi	r2,r2,4
81143758:	10800037 	ldwio	r2,0(r2)
8114375c:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81143760:	e0bffc17 	ldw	r2,-16(fp)
81143764:	1081000c 	andi	r2,r2,1024
81143768:	10000b26 	beq	r2,zero,81143798 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
8114376c:	e0bffb17 	ldw	r2,-20(fp)
81143770:	10800017 	ldw	r2,0(r2)
81143774:	10800104 	addi	r2,r2,4
81143778:	1007883a 	mov	r3,r2
8114377c:	e0bffb17 	ldw	r2,-20(fp)
81143780:	10800817 	ldw	r2,32(r2)
81143784:	10810014 	ori	r2,r2,1024
81143788:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
8114378c:	e0bffb17 	ldw	r2,-20(fp)
81143790:	10000915 	stw	zero,36(r2)
81143794:	00002106 	br	8114381c <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81143798:	e0bffb17 	ldw	r2,-20(fp)
8114379c:	10c00917 	ldw	r3,36(r2)
811437a0:	00a00034 	movhi	r2,32768
811437a4:	10bfff04 	addi	r2,r2,-4
811437a8:	10c01c36 	bltu	r2,r3,8114381c <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
811437ac:	e0bffb17 	ldw	r2,-20(fp)
811437b0:	10800917 	ldw	r2,36(r2)
811437b4:	10c00044 	addi	r3,r2,1
811437b8:	e0bffb17 	ldw	r2,-20(fp)
811437bc:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
811437c0:	e0bffb17 	ldw	r2,-20(fp)
811437c4:	10c00917 	ldw	r3,36(r2)
811437c8:	e0bffb17 	ldw	r2,-20(fp)
811437cc:	10800117 	ldw	r2,4(r2)
811437d0:	18801236 	bltu	r3,r2,8114381c <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
811437d4:	e0bffb17 	ldw	r2,-20(fp)
811437d8:	10800c17 	ldw	r2,48(r2)
811437dc:	e0bffd15 	stw	r2,-12(fp)
811437e0:	00800104 	movi	r2,4
811437e4:	e0bffe0d 	sth	r2,-8(fp)
811437e8:	00800044 	movi	r2,1
811437ec:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811437f0:	d0a09003 	ldbu	r2,-32192(gp)
811437f4:	10803fcc 	andi	r2,r2,255
811437f8:	10000826 	beq	r2,zero,8114381c <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
811437fc:	e0bffe0b 	ldhu	r2,-8(fp)
81143800:	e0fffe83 	ldbu	r3,-6(fp)
81143804:	e13ffec4 	addi	r4,fp,-5
81143808:	200f883a 	mov	r7,r4
8114380c:	180d883a 	mov	r6,r3
81143810:	100b883a 	mov	r5,r2
81143814:	e13ffd17 	ldw	r4,-12(fp)
81143818:	11380780 	call	81138078 <OSFlagPost>
8114381c:	d0a08717 	ldw	r2,-32228(gp)
    }
  }

  return alt_ticks_per_second();
}
81143820:	e037883a 	mov	sp,fp
81143824:	dfc00117 	ldw	ra,4(sp)
81143828:	df000017 	ldw	fp,0(sp)
8114382c:	dec00204 	addi	sp,sp,8
81143830:	f800283a 	ret

81143834 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81143834:	defffd04 	addi	sp,sp,-12
81143838:	de00012e 	bgeu	sp,et,81143840 <altera_avalon_jtag_uart_close+0xc>
8114383c:	003b68fa 	trap	3
81143840:	df000215 	stw	fp,8(sp)
81143844:	df000204 	addi	fp,sp,8
81143848:	e13ffe15 	stw	r4,-8(fp)
8114384c:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81143850:	00000506 	br	81143868 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81143854:	e0bfff17 	ldw	r2,-4(fp)
81143858:	1090000c 	andi	r2,r2,16384
8114385c:	10000226 	beq	r2,zero,81143868 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81143860:	00bffd44 	movi	r2,-11
81143864:	00000b06 	br	81143894 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81143868:	e0bffe17 	ldw	r2,-8(fp)
8114386c:	10c01017 	ldw	r3,64(r2)
81143870:	e0bffe17 	ldw	r2,-8(fp)
81143874:	10800f17 	ldw	r2,60(r2)
81143878:	18800526 	beq	r3,r2,81143890 <altera_avalon_jtag_uart_close+0x5c>
8114387c:	e0bffe17 	ldw	r2,-8(fp)
81143880:	10c00917 	ldw	r3,36(r2)
81143884:	e0bffe17 	ldw	r2,-8(fp)
81143888:	10800117 	ldw	r2,4(r2)
8114388c:	18bff136 	bltu	r3,r2,81143854 <__reset+0xfb123854>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81143890:	0005883a 	mov	r2,zero
}
81143894:	e037883a 	mov	sp,fp
81143898:	df000017 	ldw	fp,0(sp)
8114389c:	dec00104 	addi	sp,sp,4
811438a0:	f800283a 	ret

811438a4 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
811438a4:	defffa04 	addi	sp,sp,-24
811438a8:	de00012e 	bgeu	sp,et,811438b0 <altera_avalon_jtag_uart_ioctl+0xc>
811438ac:	003b68fa 	trap	3
811438b0:	df000515 	stw	fp,20(sp)
811438b4:	df000504 	addi	fp,sp,20
811438b8:	e13ffd15 	stw	r4,-12(fp)
811438bc:	e17ffe15 	stw	r5,-8(fp)
811438c0:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
811438c4:	00bff9c4 	movi	r2,-25
811438c8:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
811438cc:	e0bffe17 	ldw	r2,-8(fp)
811438d0:	10da8060 	cmpeqi	r3,r2,27137
811438d4:	1800031e 	bne	r3,zero,811438e4 <altera_avalon_jtag_uart_ioctl+0x40>
811438d8:	109a80a0 	cmpeqi	r2,r2,27138
811438dc:	1000181e 	bne	r2,zero,81143940 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
811438e0:	00002906 	br	81143988 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
811438e4:	e0bffd17 	ldw	r2,-12(fp)
811438e8:	10c00117 	ldw	r3,4(r2)
811438ec:	00a00034 	movhi	r2,32768
811438f0:	10bfffc4 	addi	r2,r2,-1
811438f4:	18802126 	beq	r3,r2,8114397c <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
811438f8:	e0bfff17 	ldw	r2,-4(fp)
811438fc:	10800017 	ldw	r2,0(r2)
81143900:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81143904:	e0bffc17 	ldw	r2,-16(fp)
81143908:	10800090 	cmplti	r2,r2,2
8114390c:	1000061e 	bne	r2,zero,81143928 <altera_avalon_jtag_uart_ioctl+0x84>
81143910:	e0fffc17 	ldw	r3,-16(fp)
81143914:	00a00034 	movhi	r2,32768
81143918:	10bfffc4 	addi	r2,r2,-1
8114391c:	18800226 	beq	r3,r2,81143928 <altera_avalon_jtag_uart_ioctl+0x84>
81143920:	e0bffc17 	ldw	r2,-16(fp)
81143924:	00000206 	br	81143930 <altera_avalon_jtag_uart_ioctl+0x8c>
81143928:	00a00034 	movhi	r2,32768
8114392c:	10bfff84 	addi	r2,r2,-2
81143930:	e0fffd17 	ldw	r3,-12(fp)
81143934:	18800115 	stw	r2,4(r3)
      rc = 0;
81143938:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
8114393c:	00000f06 	br	8114397c <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81143940:	e0bffd17 	ldw	r2,-12(fp)
81143944:	10c00117 	ldw	r3,4(r2)
81143948:	00a00034 	movhi	r2,32768
8114394c:	10bfffc4 	addi	r2,r2,-1
81143950:	18800c26 	beq	r3,r2,81143984 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81143954:	e0bffd17 	ldw	r2,-12(fp)
81143958:	10c00917 	ldw	r3,36(r2)
8114395c:	e0bffd17 	ldw	r2,-12(fp)
81143960:	10800117 	ldw	r2,4(r2)
81143964:	1885803a 	cmpltu	r2,r3,r2
81143968:	10c03fcc 	andi	r3,r2,255
8114396c:	e0bfff17 	ldw	r2,-4(fp)
81143970:	10c00015 	stw	r3,0(r2)
      rc = 0;
81143974:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81143978:	00000206 	br	81143984 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
8114397c:	0001883a 	nop
81143980:	00000106 	br	81143988 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81143984:	0001883a 	nop

  default:
    break;
  }

  return rc;
81143988:	e0bffb17 	ldw	r2,-20(fp)
}
8114398c:	e037883a 	mov	sp,fp
81143990:	df000017 	ldw	fp,0(sp)
81143994:	dec00104 	addi	sp,sp,4
81143998:	f800283a 	ret

8114399c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
8114399c:	deffed04 	addi	sp,sp,-76
811439a0:	de00012e 	bgeu	sp,et,811439a8 <altera_avalon_jtag_uart_read+0xc>
811439a4:	003b68fa 	trap	3
811439a8:	dfc01215 	stw	ra,72(sp)
811439ac:	df001115 	stw	fp,68(sp)
811439b0:	df001104 	addi	fp,sp,68
811439b4:	e13ffc15 	stw	r4,-16(fp)
811439b8:	e17ffd15 	stw	r5,-12(fp)
811439bc:	e1bffe15 	stw	r6,-8(fp)
811439c0:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
811439c4:	e0bffd17 	ldw	r2,-12(fp)
811439c8:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
811439cc:	e0bffc17 	ldw	r2,-16(fp)
811439d0:	10800a17 	ldw	r2,40(r2)
811439d4:	e0bff815 	stw	r2,-32(fp)
811439d8:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811439dc:	e0bff90b 	ldhu	r2,-28(fp)
811439e0:	e0fffb04 	addi	r3,fp,-20
811439e4:	180d883a 	mov	r6,r3
811439e8:	100b883a 	mov	r5,r2
811439ec:	e13ff817 	ldw	r4,-32(fp)
811439f0:	113b6f00 	call	8113b6f0 <OSSemPend>

  while (space > 0)
811439f4:	00006106 	br	81143b7c <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
811439f8:	e0bffc17 	ldw	r2,-16(fp)
811439fc:	10800d17 	ldw	r2,52(r2)
81143a00:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81143a04:	e0bffc17 	ldw	r2,-16(fp)
81143a08:	10800e17 	ldw	r2,56(r2)
81143a0c:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81143a10:	e0fff317 	ldw	r3,-52(fp)
81143a14:	e0bff417 	ldw	r2,-48(fp)
81143a18:	18800536 	bltu	r3,r2,81143a30 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81143a1c:	e0fff317 	ldw	r3,-52(fp)
81143a20:	e0bff417 	ldw	r2,-48(fp)
81143a24:	1885c83a 	sub	r2,r3,r2
81143a28:	e0bff115 	stw	r2,-60(fp)
81143a2c:	00000406 	br	81143a40 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81143a30:	00c20004 	movi	r3,2048
81143a34:	e0bff417 	ldw	r2,-48(fp)
81143a38:	1885c83a 	sub	r2,r3,r2
81143a3c:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81143a40:	e0bff117 	ldw	r2,-60(fp)
81143a44:	10001e26 	beq	r2,zero,81143ac0 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81143a48:	e0fffe17 	ldw	r3,-8(fp)
81143a4c:	e0bff117 	ldw	r2,-60(fp)
81143a50:	1880022e 	bgeu	r3,r2,81143a5c <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81143a54:	e0bffe17 	ldw	r2,-8(fp)
81143a58:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81143a5c:	e0bffc17 	ldw	r2,-16(fp)
81143a60:	10c01104 	addi	r3,r2,68
81143a64:	e0bff417 	ldw	r2,-48(fp)
81143a68:	1885883a 	add	r2,r3,r2
81143a6c:	e1bff117 	ldw	r6,-60(fp)
81143a70:	100b883a 	mov	r5,r2
81143a74:	e13ff017 	ldw	r4,-64(fp)
81143a78:	111e6c40 	call	8111e6c4 <memcpy>
      ptr   += n;
81143a7c:	e0fff017 	ldw	r3,-64(fp)
81143a80:	e0bff117 	ldw	r2,-60(fp)
81143a84:	1885883a 	add	r2,r3,r2
81143a88:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81143a8c:	e0fffe17 	ldw	r3,-8(fp)
81143a90:	e0bff117 	ldw	r2,-60(fp)
81143a94:	1885c83a 	sub	r2,r3,r2
81143a98:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81143a9c:	e0fff417 	ldw	r3,-48(fp)
81143aa0:	e0bff117 	ldw	r2,-60(fp)
81143aa4:	1885883a 	add	r2,r3,r2
81143aa8:	10c1ffcc 	andi	r3,r2,2047
81143aac:	e0bffc17 	ldw	r2,-16(fp)
81143ab0:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81143ab4:	e0bffe17 	ldw	r2,-8(fp)
81143ab8:	00bfcf16 	blt	zero,r2,811439f8 <__reset+0xfb1239f8>
81143abc:	00000106 	br	81143ac4 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81143ac0:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81143ac4:	e0fff017 	ldw	r3,-64(fp)
81143ac8:	e0bffd17 	ldw	r2,-12(fp)
81143acc:	18802e1e 	bne	r3,r2,81143b88 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81143ad0:	e0bfff17 	ldw	r2,-4(fp)
81143ad4:	1090000c 	andi	r2,r2,16384
81143ad8:	10002d1e 	bne	r2,zero,81143b90 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81143adc:	d0a09003 	ldbu	r2,-32192(gp)
81143ae0:	10803fcc 	andi	r2,r2,255
81143ae4:	10800058 	cmpnei	r2,r2,1
81143ae8:	1000161e 	bne	r2,zero,81143b44 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81143aec:	e0bffc17 	ldw	r2,-16(fp)
81143af0:	10800c17 	ldw	r2,48(r2)
81143af4:	e0bff215 	stw	r2,-56(fp)
81143af8:	00800144 	movi	r2,5
81143afc:	e0bff98d 	sth	r2,-26(fp)
81143b00:	00bfe0c4 	movi	r2,-125
81143b04:	e0bffa05 	stb	r2,-24(fp)
81143b08:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81143b0c:	d0a09003 	ldbu	r2,-32192(gp)
81143b10:	10803fcc 	andi	r2,r2,255
81143b14:	10001526 	beq	r2,zero,81143b6c <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81143b18:	e0fff98b 	ldhu	r3,-26(fp)
81143b1c:	e13ffa03 	ldbu	r4,-24(fp)
81143b20:	e17ffa8b 	ldhu	r5,-22(fp)
81143b24:	e0bffb44 	addi	r2,fp,-19
81143b28:	d8800015 	stw	r2,0(sp)
81143b2c:	280f883a 	mov	r7,r5
81143b30:	200d883a 	mov	r6,r4
81143b34:	180b883a 	mov	r5,r3
81143b38:	e13ff217 	ldw	r4,-56(fp)
81143b3c:	1137a500 	call	81137a50 <OSFlagPend>
81143b40:	00000a06 	br	81143b6c <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81143b44:	0001883a 	nop
81143b48:	e0bffc17 	ldw	r2,-16(fp)
81143b4c:	10c00d17 	ldw	r3,52(r2)
81143b50:	e0bff317 	ldw	r2,-52(fp)
81143b54:	1880051e 	bne	r3,r2,81143b6c <altera_avalon_jtag_uart_read+0x1d0>
81143b58:	e0bffc17 	ldw	r2,-16(fp)
81143b5c:	10c00917 	ldw	r3,36(r2)
81143b60:	e0bffc17 	ldw	r2,-16(fp)
81143b64:	10800117 	ldw	r2,4(r2)
81143b68:	18bff736 	bltu	r3,r2,81143b48 <__reset+0xfb123b48>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81143b6c:	e0bffc17 	ldw	r2,-16(fp)
81143b70:	10c00d17 	ldw	r3,52(r2)
81143b74:	e0bff317 	ldw	r2,-52(fp)
81143b78:	18800726 	beq	r3,r2,81143b98 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81143b7c:	e0bffe17 	ldw	r2,-8(fp)
81143b80:	00bf9d16 	blt	zero,r2,811439f8 <__reset+0xfb1239f8>
81143b84:	00000506 	br	81143b9c <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81143b88:	0001883a 	nop
81143b8c:	00000306 	br	81143b9c <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81143b90:	0001883a 	nop
81143b94:	00000106 	br	81143b9c <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81143b98:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81143b9c:	e0bffc17 	ldw	r2,-16(fp)
81143ba0:	10800a17 	ldw	r2,40(r2)
81143ba4:	1009883a 	mov	r4,r2
81143ba8:	113ba780 	call	8113ba78 <OSSemPost>

  if (ptr != buffer)
81143bac:	e0fff017 	ldw	r3,-64(fp)
81143bb0:	e0bffd17 	ldw	r2,-12(fp)
81143bb4:	18801826 	beq	r3,r2,81143c18 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143bb8:	0005303a 	rdctl	r2,status
81143bbc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143bc0:	e0fff717 	ldw	r3,-36(fp)
81143bc4:	00bfff84 	movi	r2,-2
81143bc8:	1884703a 	and	r2,r3,r2
81143bcc:	1001703a 	wrctl	status,r2
  
  return context;
81143bd0:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81143bd4:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81143bd8:	e0bffc17 	ldw	r2,-16(fp)
81143bdc:	10800817 	ldw	r2,32(r2)
81143be0:	10c00054 	ori	r3,r2,1
81143be4:	e0bffc17 	ldw	r2,-16(fp)
81143be8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81143bec:	e0bffc17 	ldw	r2,-16(fp)
81143bf0:	10800017 	ldw	r2,0(r2)
81143bf4:	10800104 	addi	r2,r2,4
81143bf8:	1007883a 	mov	r3,r2
81143bfc:	e0bffc17 	ldw	r2,-16(fp)
81143c00:	10800817 	ldw	r2,32(r2)
81143c04:	18800035 	stwio	r2,0(r3)
81143c08:	e0bff617 	ldw	r2,-40(fp)
81143c0c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143c10:	e0bff517 	ldw	r2,-44(fp)
81143c14:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81143c18:	e0fff017 	ldw	r3,-64(fp)
81143c1c:	e0bffd17 	ldw	r2,-12(fp)
81143c20:	18800426 	beq	r3,r2,81143c34 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81143c24:	e0fff017 	ldw	r3,-64(fp)
81143c28:	e0bffd17 	ldw	r2,-12(fp)
81143c2c:	1885c83a 	sub	r2,r3,r2
81143c30:	00000606 	br	81143c4c <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81143c34:	e0bfff17 	ldw	r2,-4(fp)
81143c38:	1090000c 	andi	r2,r2,16384
81143c3c:	10000226 	beq	r2,zero,81143c48 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81143c40:	00bffd44 	movi	r2,-11
81143c44:	00000106 	br	81143c4c <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81143c48:	00bffec4 	movi	r2,-5
}
81143c4c:	e037883a 	mov	sp,fp
81143c50:	dfc00117 	ldw	ra,4(sp)
81143c54:	df000017 	ldw	fp,0(sp)
81143c58:	dec00204 	addi	sp,sp,8
81143c5c:	f800283a 	ret

81143c60 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81143c60:	deffed04 	addi	sp,sp,-76
81143c64:	de00012e 	bgeu	sp,et,81143c6c <altera_avalon_jtag_uart_write+0xc>
81143c68:	003b68fa 	trap	3
81143c6c:	dfc01215 	stw	ra,72(sp)
81143c70:	df001115 	stw	fp,68(sp)
81143c74:	df001104 	addi	fp,sp,68
81143c78:	e13ffc15 	stw	r4,-16(fp)
81143c7c:	e17ffd15 	stw	r5,-12(fp)
81143c80:	e1bffe15 	stw	r6,-8(fp)
81143c84:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81143c88:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81143c8c:	e0bffd17 	ldw	r2,-12(fp)
81143c90:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81143c94:	e0bffc17 	ldw	r2,-16(fp)
81143c98:	10800b17 	ldw	r2,44(r2)
81143c9c:	e0bff815 	stw	r2,-32(fp)
81143ca0:	e03ff90d 	sth	zero,-28(fp)
81143ca4:	e0bff90b 	ldhu	r2,-28(fp)
81143ca8:	e0fffb44 	addi	r3,fp,-19
81143cac:	180d883a 	mov	r6,r3
81143cb0:	100b883a 	mov	r5,r2
81143cb4:	e13ff817 	ldw	r4,-32(fp)
81143cb8:	113b6f00 	call	8113b6f0 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81143cbc:	00003706 	br	81143d9c <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81143cc0:	e0bffc17 	ldw	r2,-16(fp)
81143cc4:	10800f17 	ldw	r2,60(r2)
81143cc8:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81143ccc:	e0bffc17 	ldw	r2,-16(fp)
81143cd0:	10801017 	ldw	r2,64(r2)
81143cd4:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81143cd8:	e0fff417 	ldw	r3,-48(fp)
81143cdc:	e0bff017 	ldw	r2,-64(fp)
81143ce0:	1880062e 	bgeu	r3,r2,81143cfc <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81143ce4:	e0fff017 	ldw	r3,-64(fp)
81143ce8:	e0bff417 	ldw	r2,-48(fp)
81143cec:	1885c83a 	sub	r2,r3,r2
81143cf0:	10bfffc4 	addi	r2,r2,-1
81143cf4:	e0bff115 	stw	r2,-60(fp)
81143cf8:	00000b06 	br	81143d28 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81143cfc:	e0bff017 	ldw	r2,-64(fp)
81143d00:	10000526 	beq	r2,zero,81143d18 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81143d04:	00c20004 	movi	r3,2048
81143d08:	e0bff417 	ldw	r2,-48(fp)
81143d0c:	1885c83a 	sub	r2,r3,r2
81143d10:	e0bff115 	stw	r2,-60(fp)
81143d14:	00000406 	br	81143d28 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81143d18:	00c1ffc4 	movi	r3,2047
81143d1c:	e0bff417 	ldw	r2,-48(fp)
81143d20:	1885c83a 	sub	r2,r3,r2
81143d24:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81143d28:	e0bff117 	ldw	r2,-60(fp)
81143d2c:	10001e26 	beq	r2,zero,81143da8 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81143d30:	e0fffe17 	ldw	r3,-8(fp)
81143d34:	e0bff117 	ldw	r2,-60(fp)
81143d38:	1880022e 	bgeu	r3,r2,81143d44 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81143d3c:	e0bffe17 	ldw	r2,-8(fp)
81143d40:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81143d44:	e0bffc17 	ldw	r2,-16(fp)
81143d48:	10c21104 	addi	r3,r2,2116
81143d4c:	e0bff417 	ldw	r2,-48(fp)
81143d50:	1885883a 	add	r2,r3,r2
81143d54:	e1bff117 	ldw	r6,-60(fp)
81143d58:	e17ffd17 	ldw	r5,-12(fp)
81143d5c:	1009883a 	mov	r4,r2
81143d60:	111e6c40 	call	8111e6c4 <memcpy>
      ptr   += n;
81143d64:	e0fffd17 	ldw	r3,-12(fp)
81143d68:	e0bff117 	ldw	r2,-60(fp)
81143d6c:	1885883a 	add	r2,r3,r2
81143d70:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81143d74:	e0fffe17 	ldw	r3,-8(fp)
81143d78:	e0bff117 	ldw	r2,-60(fp)
81143d7c:	1885c83a 	sub	r2,r3,r2
81143d80:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81143d84:	e0fff417 	ldw	r3,-48(fp)
81143d88:	e0bff117 	ldw	r2,-60(fp)
81143d8c:	1885883a 	add	r2,r3,r2
81143d90:	10c1ffcc 	andi	r3,r2,2047
81143d94:	e0bffc17 	ldw	r2,-16(fp)
81143d98:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81143d9c:	e0bffe17 	ldw	r2,-8(fp)
81143da0:	00bfc716 	blt	zero,r2,81143cc0 <__reset+0xfb123cc0>
81143da4:	00000106 	br	81143dac <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
81143da8:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143dac:	0005303a 	rdctl	r2,status
81143db0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143db4:	e0fff717 	ldw	r3,-36(fp)
81143db8:	00bfff84 	movi	r2,-2
81143dbc:	1884703a 	and	r2,r3,r2
81143dc0:	1001703a 	wrctl	status,r2
  
  return context;
81143dc4:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
81143dc8:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81143dcc:	e0bffc17 	ldw	r2,-16(fp)
81143dd0:	10800817 	ldw	r2,32(r2)
81143dd4:	10c00094 	ori	r3,r2,2
81143dd8:	e0bffc17 	ldw	r2,-16(fp)
81143ddc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81143de0:	e0bffc17 	ldw	r2,-16(fp)
81143de4:	10800017 	ldw	r2,0(r2)
81143de8:	10800104 	addi	r2,r2,4
81143dec:	1007883a 	mov	r3,r2
81143df0:	e0bffc17 	ldw	r2,-16(fp)
81143df4:	10800817 	ldw	r2,32(r2)
81143df8:	18800035 	stwio	r2,0(r3)
81143dfc:	e0bff617 	ldw	r2,-40(fp)
81143e00:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143e04:	e0bff317 	ldw	r2,-52(fp)
81143e08:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81143e0c:	e0bffe17 	ldw	r2,-8(fp)
81143e10:	00802a0e 	bge	zero,r2,81143ebc <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
81143e14:	e0bfff17 	ldw	r2,-4(fp)
81143e18:	1090000c 	andi	r2,r2,16384
81143e1c:	10002a1e 	bne	r2,zero,81143ec8 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81143e20:	d0a09003 	ldbu	r2,-32192(gp)
81143e24:	10803fcc 	andi	r2,r2,255
81143e28:	10800058 	cmpnei	r2,r2,1
81143e2c:	1000161e 	bne	r2,zero,81143e88 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81143e30:	e0bffc17 	ldw	r2,-16(fp)
81143e34:	10800c17 	ldw	r2,48(r2)
81143e38:	e0bff515 	stw	r2,-44(fp)
81143e3c:	00800184 	movi	r2,6
81143e40:	e0bff98d 	sth	r2,-26(fp)
81143e44:	00bfe0c4 	movi	r2,-125
81143e48:	e0bffa05 	stb	r2,-24(fp)
81143e4c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81143e50:	d0a09003 	ldbu	r2,-32192(gp)
81143e54:	10803fcc 	andi	r2,r2,255
81143e58:	10001526 	beq	r2,zero,81143eb0 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81143e5c:	e0fff98b 	ldhu	r3,-26(fp)
81143e60:	e13ffa03 	ldbu	r4,-24(fp)
81143e64:	e17ffa8b 	ldhu	r5,-22(fp)
81143e68:	e0bffb04 	addi	r2,fp,-20
81143e6c:	d8800015 	stw	r2,0(sp)
81143e70:	280f883a 	mov	r7,r5
81143e74:	200d883a 	mov	r6,r4
81143e78:	180b883a 	mov	r5,r3
81143e7c:	e13ff517 	ldw	r4,-44(fp)
81143e80:	1137a500 	call	81137a50 <OSFlagPend>
81143e84:	00000a06 	br	81143eb0 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81143e88:	0001883a 	nop
81143e8c:	e0bffc17 	ldw	r2,-16(fp)
81143e90:	10c01017 	ldw	r3,64(r2)
81143e94:	e0bff017 	ldw	r2,-64(fp)
81143e98:	1880051e 	bne	r3,r2,81143eb0 <altera_avalon_jtag_uart_write+0x250>
81143e9c:	e0bffc17 	ldw	r2,-16(fp)
81143ea0:	10c00917 	ldw	r3,36(r2)
81143ea4:	e0bffc17 	ldw	r2,-16(fp)
81143ea8:	10800117 	ldw	r2,4(r2)
81143eac:	18bff736 	bltu	r3,r2,81143e8c <__reset+0xfb123e8c>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
81143eb0:	e0bffc17 	ldw	r2,-16(fp)
81143eb4:	10800917 	ldw	r2,36(r2)
81143eb8:	1000051e 	bne	r2,zero,81143ed0 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81143ebc:	e0bffe17 	ldw	r2,-8(fp)
81143ec0:	00bfb616 	blt	zero,r2,81143d9c <__reset+0xfb123d9c>
81143ec4:	00000306 	br	81143ed4 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
81143ec8:	0001883a 	nop
81143ecc:	00000106 	br	81143ed4 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
81143ed0:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
81143ed4:	e0bffc17 	ldw	r2,-16(fp)
81143ed8:	10800b17 	ldw	r2,44(r2)
81143edc:	1009883a 	mov	r4,r2
81143ee0:	113ba780 	call	8113ba78 <OSSemPost>

  if (ptr != start)
81143ee4:	e0fffd17 	ldw	r3,-12(fp)
81143ee8:	e0bff217 	ldw	r2,-56(fp)
81143eec:	18800426 	beq	r3,r2,81143f00 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
81143ef0:	e0fffd17 	ldw	r3,-12(fp)
81143ef4:	e0bff217 	ldw	r2,-56(fp)
81143ef8:	1885c83a 	sub	r2,r3,r2
81143efc:	00000606 	br	81143f18 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81143f00:	e0bfff17 	ldw	r2,-4(fp)
81143f04:	1090000c 	andi	r2,r2,16384
81143f08:	10000226 	beq	r2,zero,81143f14 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81143f0c:	00bffd44 	movi	r2,-11
81143f10:	00000106 	br	81143f18 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
81143f14:	00bffec4 	movi	r2,-5
}
81143f18:	e037883a 	mov	sp,fp
81143f1c:	dfc00117 	ldw	ra,4(sp)
81143f20:	df000017 	ldw	fp,0(sp)
81143f24:	dec00204 	addi	sp,sp,8
81143f28:	f800283a 	ret

81143f2c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81143f2c:	defffa04 	addi	sp,sp,-24
81143f30:	de00012e 	bgeu	sp,et,81143f38 <alt_avalon_timer_sc_irq+0xc>
81143f34:	003b68fa 	trap	3
81143f38:	dfc00515 	stw	ra,20(sp)
81143f3c:	df000415 	stw	fp,16(sp)
81143f40:	df000404 	addi	fp,sp,16
81143f44:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81143f48:	0007883a 	mov	r3,zero
81143f4c:	e0bfff17 	ldw	r2,-4(fp)
81143f50:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81143f54:	e0bfff17 	ldw	r2,-4(fp)
81143f58:	10800104 	addi	r2,r2,4
81143f5c:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81143f60:	1133f2c0 	call	81133f2c <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143f64:	0005303a 	rdctl	r2,status
81143f68:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143f6c:	e0fffd17 	ldw	r3,-12(fp)
81143f70:	00bfff84 	movi	r2,-2
81143f74:	1884703a 	and	r2,r3,r2
81143f78:	1001703a 	wrctl	status,r2
  
  return context;
81143f7c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81143f80:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81143f84:	11347dc0 	call	811347dc <alt_tick>
81143f88:	e0bffc17 	ldw	r2,-16(fp)
81143f8c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143f90:	e0bffe17 	ldw	r2,-8(fp)
81143f94:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
81143f98:	0001883a 	nop
81143f9c:	e037883a 	mov	sp,fp
81143fa0:	dfc00117 	ldw	ra,4(sp)
81143fa4:	df000017 	ldw	fp,0(sp)
81143fa8:	dec00204 	addi	sp,sp,8
81143fac:	f800283a 	ret

81143fb0 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
81143fb0:	defff804 	addi	sp,sp,-32
81143fb4:	de00012e 	bgeu	sp,et,81143fbc <alt_avalon_timer_sc_init+0xc>
81143fb8:	003b68fa 	trap	3
81143fbc:	dfc00715 	stw	ra,28(sp)
81143fc0:	df000615 	stw	fp,24(sp)
81143fc4:	df000604 	addi	fp,sp,24
81143fc8:	e13ffc15 	stw	r4,-16(fp)
81143fcc:	e17ffd15 	stw	r5,-12(fp)
81143fd0:	e1bffe15 	stw	r6,-8(fp)
81143fd4:	e1ffff15 	stw	r7,-4(fp)
81143fd8:	e0bfff17 	ldw	r2,-4(fp)
81143fdc:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
81143fe0:	d0a08717 	ldw	r2,-32228(gp)
81143fe4:	1000021e 	bne	r2,zero,81143ff0 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81143fe8:	e0bffb17 	ldw	r2,-20(fp)
81143fec:	d0a08715 	stw	r2,-32228(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
81143ff0:	e0bffc17 	ldw	r2,-16(fp)
81143ff4:	10800104 	addi	r2,r2,4
81143ff8:	00c001c4 	movi	r3,7
81143ffc:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81144000:	d8000015 	stw	zero,0(sp)
81144004:	e1fffc17 	ldw	r7,-16(fp)
81144008:	01a04534 	movhi	r6,33044
8114400c:	318fcb04 	addi	r6,r6,16172
81144010:	e17ffe17 	ldw	r5,-8(fp)
81144014:	e13ffd17 	ldw	r4,-12(fp)
81144018:	11471b40 	call	811471b4 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
8114401c:	0001883a 	nop
81144020:	e037883a 	mov	sp,fp
81144024:	dfc00117 	ldw	ra,4(sp)
81144028:	df000017 	ldw	fp,0(sp)
8114402c:	dec00204 	addi	sp,sp,8
81144030:	f800283a 	ret

81144034 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81144034:	defffa04 	addi	sp,sp,-24
81144038:	de00012e 	bgeu	sp,et,81144040 <altera_avalon_uart_read_fd+0xc>
8114403c:	003b68fa 	trap	3
81144040:	dfc00515 	stw	ra,20(sp)
81144044:	df000415 	stw	fp,16(sp)
81144048:	df000404 	addi	fp,sp,16
8114404c:	e13ffd15 	stw	r4,-12(fp)
81144050:	e17ffe15 	stw	r5,-8(fp)
81144054:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81144058:	e0bffd17 	ldw	r2,-12(fp)
8114405c:	10800017 	ldw	r2,0(r2)
81144060:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81144064:	e0bffc17 	ldw	r2,-16(fp)
81144068:	10c00a04 	addi	r3,r2,40
8114406c:	e0bffd17 	ldw	r2,-12(fp)
81144070:	10800217 	ldw	r2,8(r2)
81144074:	100f883a 	mov	r7,r2
81144078:	e1bfff17 	ldw	r6,-4(fp)
8114407c:	e17ffe17 	ldw	r5,-8(fp)
81144080:	1809883a 	mov	r4,r3
81144084:	11446f40 	call	811446f4 <altera_avalon_uart_read>
      fd->fd_flags);
}
81144088:	e037883a 	mov	sp,fp
8114408c:	dfc00117 	ldw	ra,4(sp)
81144090:	df000017 	ldw	fp,0(sp)
81144094:	dec00204 	addi	sp,sp,8
81144098:	f800283a 	ret

8114409c <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8114409c:	defffa04 	addi	sp,sp,-24
811440a0:	de00012e 	bgeu	sp,et,811440a8 <altera_avalon_uart_write_fd+0xc>
811440a4:	003b68fa 	trap	3
811440a8:	dfc00515 	stw	ra,20(sp)
811440ac:	df000415 	stw	fp,16(sp)
811440b0:	df000404 	addi	fp,sp,16
811440b4:	e13ffd15 	stw	r4,-12(fp)
811440b8:	e17ffe15 	stw	r5,-8(fp)
811440bc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811440c0:	e0bffd17 	ldw	r2,-12(fp)
811440c4:	10800017 	ldw	r2,0(r2)
811440c8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811440cc:	e0bffc17 	ldw	r2,-16(fp)
811440d0:	10c00a04 	addi	r3,r2,40
811440d4:	e0bffd17 	ldw	r2,-12(fp)
811440d8:	10800217 	ldw	r2,8(r2)
811440dc:	100f883a 	mov	r7,r2
811440e0:	e1bfff17 	ldw	r6,-4(fp)
811440e4:	e17ffe17 	ldw	r5,-8(fp)
811440e8:	1809883a 	mov	r4,r3
811440ec:	11449a80 	call	811449a8 <altera_avalon_uart_write>
      fd->fd_flags);
}
811440f0:	e037883a 	mov	sp,fp
811440f4:	dfc00117 	ldw	ra,4(sp)
811440f8:	df000017 	ldw	fp,0(sp)
811440fc:	dec00204 	addi	sp,sp,8
81144100:	f800283a 	ret

81144104 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81144104:	defffc04 	addi	sp,sp,-16
81144108:	de00012e 	bgeu	sp,et,81144110 <altera_avalon_uart_close_fd+0xc>
8114410c:	003b68fa 	trap	3
81144110:	dfc00315 	stw	ra,12(sp)
81144114:	df000215 	stw	fp,8(sp)
81144118:	df000204 	addi	fp,sp,8
8114411c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81144120:	e0bfff17 	ldw	r2,-4(fp)
81144124:	10800017 	ldw	r2,0(r2)
81144128:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
8114412c:	e0bffe17 	ldw	r2,-8(fp)
81144130:	10c00a04 	addi	r3,r2,40
81144134:	e0bfff17 	ldw	r2,-4(fp)
81144138:	10800217 	ldw	r2,8(r2)
8114413c:	100b883a 	mov	r5,r2
81144140:	1809883a 	mov	r4,r3
81144144:	11446540 	call	81144654 <altera_avalon_uart_close>
}
81144148:	e037883a 	mov	sp,fp
8114414c:	dfc00117 	ldw	ra,4(sp)
81144150:	df000017 	ldw	fp,0(sp)
81144154:	dec00204 	addi	sp,sp,8
81144158:	f800283a 	ret

8114415c <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
8114415c:	defff304 	addi	sp,sp,-52
81144160:	de00012e 	bgeu	sp,et,81144168 <altera_avalon_uart_init+0xc>
81144164:	003b68fa 	trap	3
81144168:	dfc00c15 	stw	ra,48(sp)
8114416c:	df000b15 	stw	fp,44(sp)
81144170:	df000b04 	addi	fp,sp,44
81144174:	e13ffd15 	stw	r4,-12(fp)
81144178:	e17ffe15 	stw	r5,-8(fp)
8114417c:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81144180:	e0bffd17 	ldw	r2,-12(fp)
81144184:	10800017 	ldw	r2,0(r2)
81144188:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8114418c:	e0bffd17 	ldw	r2,-12(fp)
81144190:	10800704 	addi	r2,r2,28
81144194:	e0bffa15 	stw	r2,-24(fp)
81144198:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
8114419c:	e0bffb0b 	ldhu	r2,-20(fp)
811441a0:	e0fffc84 	addi	r3,fp,-14
811441a4:	180b883a 	mov	r5,r3
811441a8:	1009883a 	mov	r4,r2
811441ac:	113746c0 	call	8113746c <OSFlagCreate>
811441b0:	1007883a 	mov	r3,r2
811441b4:	e0bffa17 	ldw	r2,-24(fp)
811441b8:	10c00015 	stw	r3,0(r2)
  return err;
811441bc:	e0bffc83 	ldbu	r2,-14(fp)
811441c0:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811441c4:	1000241e 	bne	r2,zero,81144258 <altera_avalon_uart_init+0xfc>
811441c8:	e0bffd17 	ldw	r2,-12(fp)
811441cc:	10800804 	addi	r2,r2,32
811441d0:	e0bff715 	stw	r2,-36(fp)
811441d4:	00800044 	movi	r2,1
811441d8:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811441dc:	e0bffb8b 	ldhu	r2,-18(fp)
811441e0:	1009883a 	mov	r4,r2
811441e4:	113b3c80 	call	8113b3c8 <OSSemCreate>
811441e8:	1007883a 	mov	r3,r2
811441ec:	e0bff717 	ldw	r2,-36(fp)
811441f0:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811441f4:	e0bff717 	ldw	r2,-36(fp)
811441f8:	10800017 	ldw	r2,0(r2)
811441fc:	10000226 	beq	r2,zero,81144208 <altera_avalon_uart_init+0xac>
81144200:	0005883a 	mov	r2,zero
81144204:	00000106 	br	8114420c <altera_avalon_uart_init+0xb0>
81144208:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8114420c:	1000121e 	bne	r2,zero,81144258 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81144210:	e0bffd17 	ldw	r2,-12(fp)
81144214:	10800904 	addi	r2,r2,36
81144218:	e0bff815 	stw	r2,-32(fp)
8114421c:	00800044 	movi	r2,1
81144220:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81144224:	e0bffc0b 	ldhu	r2,-16(fp)
81144228:	1009883a 	mov	r4,r2
8114422c:	113b3c80 	call	8113b3c8 <OSSemCreate>
81144230:	1007883a 	mov	r3,r2
81144234:	e0bff817 	ldw	r2,-32(fp)
81144238:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114423c:	e0bff817 	ldw	r2,-32(fp)
81144240:	10800017 	ldw	r2,0(r2)
81144244:	10000226 	beq	r2,zero,81144250 <altera_avalon_uart_init+0xf4>
81144248:	0005883a 	mov	r2,zero
8114424c:	00000106 	br	81144254 <altera_avalon_uart_init+0xf8>
81144250:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81144254:	10000226 	beq	r2,zero,81144260 <altera_avalon_uart_init+0x104>
81144258:	00800044 	movi	r2,1
8114425c:	00000106 	br	81144264 <altera_avalon_uart_init+0x108>
81144260:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81144264:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81144268:	e0bff917 	ldw	r2,-28(fp)
8114426c:	10000f1e 	bne	r2,zero,811442ac <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81144270:	e0bffd17 	ldw	r2,-12(fp)
81144274:	00c32004 	movi	r3,3200
81144278:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
8114427c:	e0bff617 	ldw	r2,-40(fp)
81144280:	10800304 	addi	r2,r2,12
81144284:	e0fffd17 	ldw	r3,-12(fp)
81144288:	18c00117 	ldw	r3,4(r3)
8114428c:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81144290:	d8000015 	stw	zero,0(sp)
81144294:	e1fffd17 	ldw	r7,-12(fp)
81144298:	01a04534 	movhi	r6,33044
8114429c:	3190b104 	addi	r6,r6,17092
811442a0:	e17fff17 	ldw	r5,-4(fp)
811442a4:	e13ffe17 	ldw	r4,-8(fp)
811442a8:	11471b40 	call	811471b4 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
811442ac:	0001883a 	nop
811442b0:	e037883a 	mov	sp,fp
811442b4:	dfc00117 	ldw	ra,4(sp)
811442b8:	df000017 	ldw	fp,0(sp)
811442bc:	dec00204 	addi	sp,sp,8
811442c0:	f800283a 	ret

811442c4 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
811442c4:	defffa04 	addi	sp,sp,-24
811442c8:	de00012e 	bgeu	sp,et,811442d0 <altera_avalon_uart_irq+0xc>
811442cc:	003b68fa 	trap	3
811442d0:	dfc00515 	stw	ra,20(sp)
811442d4:	df000415 	stw	fp,16(sp)
811442d8:	df000404 	addi	fp,sp,16
811442dc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
811442e0:	e0bfff17 	ldw	r2,-4(fp)
811442e4:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
811442e8:	e0bffc17 	ldw	r2,-16(fp)
811442ec:	10800017 	ldw	r2,0(r2)
811442f0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
811442f4:	e0bffd17 	ldw	r2,-12(fp)
811442f8:	10800204 	addi	r2,r2,8
811442fc:	10800037 	ldwio	r2,0(r2)
81144300:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
81144304:	e0bffd17 	ldw	r2,-12(fp)
81144308:	10800204 	addi	r2,r2,8
8114430c:	0007883a 	mov	r3,zero
81144310:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
81144314:	e0bffd17 	ldw	r2,-12(fp)
81144318:	10800204 	addi	r2,r2,8
8114431c:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81144320:	e0bffe17 	ldw	r2,-8(fp)
81144324:	1080200c 	andi	r2,r2,128
81144328:	10000326 	beq	r2,zero,81144338 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
8114432c:	e17ffe17 	ldw	r5,-8(fp)
81144330:	e13ffc17 	ldw	r4,-16(fp)
81144334:	11443680 	call	81144368 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81144338:	e0bffe17 	ldw	r2,-8(fp)
8114433c:	1081100c 	andi	r2,r2,1088
81144340:	10000326 	beq	r2,zero,81144350 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81144344:	e17ffe17 	ldw	r5,-8(fp)
81144348:	e13ffc17 	ldw	r4,-16(fp)
8114434c:	11444a80 	call	811444a8 <altera_avalon_uart_txirq>
  }
  

}
81144350:	0001883a 	nop
81144354:	e037883a 	mov	sp,fp
81144358:	dfc00117 	ldw	ra,4(sp)
8114435c:	df000017 	ldw	fp,0(sp)
81144360:	dec00204 	addi	sp,sp,8
81144364:	f800283a 	ret

81144368 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81144368:	defff904 	addi	sp,sp,-28
8114436c:	de00012e 	bgeu	sp,et,81144374 <altera_avalon_uart_rxirq+0xc>
81144370:	003b68fa 	trap	3
81144374:	dfc00615 	stw	ra,24(sp)
81144378:	df000515 	stw	fp,20(sp)
8114437c:	df000504 	addi	fp,sp,20
81144380:	e13ffe15 	stw	r4,-8(fp)
81144384:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81144388:	e0bfff17 	ldw	r2,-4(fp)
8114438c:	108000cc 	andi	r2,r2,3
81144390:	10003f1e 	bne	r2,zero,81144490 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81144394:	e0bffe17 	ldw	r2,-8(fp)
81144398:	10c00317 	ldw	r3,12(r2)
8114439c:	e0bffe17 	ldw	r2,-8(fp)
811443a0:	10800217 	ldw	r2,8(r2)
811443a4:	1880121e 	bne	r3,r2,811443f0 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
811443a8:	e0bffe17 	ldw	r2,-8(fp)
811443ac:	10800717 	ldw	r2,28(r2)
811443b0:	e0bffc15 	stw	r2,-16(fp)
811443b4:	00800044 	movi	r2,1
811443b8:	e0bffd0d 	sth	r2,-12(fp)
811443bc:	00800044 	movi	r2,1
811443c0:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811443c4:	d0a09003 	ldbu	r2,-32192(gp)
811443c8:	10803fcc 	andi	r2,r2,255
811443cc:	10000826 	beq	r2,zero,811443f0 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811443d0:	e0bffd0b 	ldhu	r2,-12(fp)
811443d4:	e0fffd83 	ldbu	r3,-10(fp)
811443d8:	e13ffdc4 	addi	r4,fp,-9
811443dc:	200f883a 	mov	r7,r4
811443e0:	180d883a 	mov	r6,r3
811443e4:	100b883a 	mov	r5,r2
811443e8:	e13ffc17 	ldw	r4,-16(fp)
811443ec:	11380780 	call	81138078 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811443f0:	e0bffe17 	ldw	r2,-8(fp)
811443f4:	10800317 	ldw	r2,12(r2)
811443f8:	10800044 	addi	r2,r2,1
811443fc:	10800fcc 	andi	r2,r2,63
81144400:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81144404:	e0bffe17 	ldw	r2,-8(fp)
81144408:	10800317 	ldw	r2,12(r2)
8114440c:	e0fffe17 	ldw	r3,-8(fp)
81144410:	18c00017 	ldw	r3,0(r3)
81144414:	18c00037 	ldwio	r3,0(r3)
81144418:	1809883a 	mov	r4,r3
8114441c:	e0fffe17 	ldw	r3,-8(fp)
81144420:	1885883a 	add	r2,r3,r2
81144424:	10800a04 	addi	r2,r2,40
81144428:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
8114442c:	e0bffe17 	ldw	r2,-8(fp)
81144430:	e0fffb17 	ldw	r3,-20(fp)
81144434:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81144438:	e0bffe17 	ldw	r2,-8(fp)
8114443c:	10800317 	ldw	r2,12(r2)
81144440:	10800044 	addi	r2,r2,1
81144444:	10800fcc 	andi	r2,r2,63
81144448:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
8114444c:	e0bffe17 	ldw	r2,-8(fp)
81144450:	10c00217 	ldw	r3,8(r2)
81144454:	e0bffb17 	ldw	r2,-20(fp)
81144458:	18800e1e 	bne	r3,r2,81144494 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8114445c:	e0bffe17 	ldw	r2,-8(fp)
81144460:	10c00117 	ldw	r3,4(r2)
81144464:	00bfdfc4 	movi	r2,-129
81144468:	1886703a 	and	r3,r3,r2
8114446c:	e0bffe17 	ldw	r2,-8(fp)
81144470:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81144474:	e0bffe17 	ldw	r2,-8(fp)
81144478:	10800017 	ldw	r2,0(r2)
8114447c:	10800304 	addi	r2,r2,12
81144480:	e0fffe17 	ldw	r3,-8(fp)
81144484:	18c00117 	ldw	r3,4(r3)
81144488:	10c00035 	stwio	r3,0(r2)
8114448c:	00000106 	br	81144494 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81144490:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81144494:	e037883a 	mov	sp,fp
81144498:	dfc00117 	ldw	ra,4(sp)
8114449c:	df000017 	ldw	fp,0(sp)
811444a0:	dec00204 	addi	sp,sp,8
811444a4:	f800283a 	ret

811444a8 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
811444a8:	defffa04 	addi	sp,sp,-24
811444ac:	de00012e 	bgeu	sp,et,811444b4 <altera_avalon_uart_txirq+0xc>
811444b0:	003b68fa 	trap	3
811444b4:	dfc00515 	stw	ra,20(sp)
811444b8:	df000415 	stw	fp,16(sp)
811444bc:	df000404 	addi	fp,sp,16
811444c0:	e13ffe15 	stw	r4,-8(fp)
811444c4:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
811444c8:	e0bffe17 	ldw	r2,-8(fp)
811444cc:	10c00417 	ldw	r3,16(r2)
811444d0:	e0bffe17 	ldw	r2,-8(fp)
811444d4:	10800517 	ldw	r2,20(r2)
811444d8:	18804726 	beq	r3,r2,811445f8 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811444dc:	e0bffe17 	ldw	r2,-8(fp)
811444e0:	10800617 	ldw	r2,24(r2)
811444e4:	1080008c 	andi	r2,r2,2
811444e8:	10000326 	beq	r2,zero,811444f8 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811444ec:	e0bfff17 	ldw	r2,-4(fp)
811444f0:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811444f4:	10003226 	beq	r2,zero,811445c0 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
811444f8:	e0bffe17 	ldw	r2,-8(fp)
811444fc:	10c00417 	ldw	r3,16(r2)
81144500:	e0bffe17 	ldw	r2,-8(fp)
81144504:	10800517 	ldw	r2,20(r2)
81144508:	10800044 	addi	r2,r2,1
8114450c:	10800fcc 	andi	r2,r2,63
81144510:	1880121e 	bne	r3,r2,8114455c <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
81144514:	e0bffe17 	ldw	r2,-8(fp)
81144518:	10800717 	ldw	r2,28(r2)
8114451c:	e0bffc15 	stw	r2,-16(fp)
81144520:	00800084 	movi	r2,2
81144524:	e0bffd0d 	sth	r2,-12(fp)
81144528:	00800044 	movi	r2,1
8114452c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81144530:	d0a09003 	ldbu	r2,-32192(gp)
81144534:	10803fcc 	andi	r2,r2,255
81144538:	10000826 	beq	r2,zero,8114455c <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
8114453c:	e0bffd0b 	ldhu	r2,-12(fp)
81144540:	e0fffd83 	ldbu	r3,-10(fp)
81144544:	e13ffdc4 	addi	r4,fp,-9
81144548:	200f883a 	mov	r7,r4
8114454c:	180d883a 	mov	r6,r3
81144550:	100b883a 	mov	r5,r2
81144554:	e13ffc17 	ldw	r4,-16(fp)
81144558:	11380780 	call	81138078 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
8114455c:	e0bffe17 	ldw	r2,-8(fp)
81144560:	10800017 	ldw	r2,0(r2)
81144564:	10800104 	addi	r2,r2,4
81144568:	e0fffe17 	ldw	r3,-8(fp)
8114456c:	18c00417 	ldw	r3,16(r3)
81144570:	e13ffe17 	ldw	r4,-8(fp)
81144574:	20c7883a 	add	r3,r4,r3
81144578:	18c01a04 	addi	r3,r3,104
8114457c:	18c00003 	ldbu	r3,0(r3)
81144580:	18c03fcc 	andi	r3,r3,255
81144584:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81144588:	e0bffe17 	ldw	r2,-8(fp)
8114458c:	10800417 	ldw	r2,16(r2)
81144590:	10800044 	addi	r2,r2,1
81144594:	e0fffe17 	ldw	r3,-8(fp)
81144598:	18800415 	stw	r2,16(r3)
8114459c:	10c00fcc 	andi	r3,r2,63
811445a0:	e0bffe17 	ldw	r2,-8(fp)
811445a4:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811445a8:	e0bffe17 	ldw	r2,-8(fp)
811445ac:	10800117 	ldw	r2,4(r2)
811445b0:	10c01014 	ori	r3,r2,64
811445b4:	e0bffe17 	ldw	r2,-8(fp)
811445b8:	10c00115 	stw	r3,4(r2)
811445bc:	00000e06 	br	811445f8 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
811445c0:	e0bffe17 	ldw	r2,-8(fp)
811445c4:	10800017 	ldw	r2,0(r2)
811445c8:	10800204 	addi	r2,r2,8
811445cc:	10800037 	ldwio	r2,0(r2)
811445d0:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811445d4:	e0bfff17 	ldw	r2,-4(fp)
811445d8:	1082000c 	andi	r2,r2,2048
811445dc:	1000061e 	bne	r2,zero,811445f8 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811445e0:	e0bffe17 	ldw	r2,-8(fp)
811445e4:	10c00117 	ldw	r3,4(r2)
811445e8:	00bfefc4 	movi	r2,-65
811445ec:	1886703a 	and	r3,r3,r2
811445f0:	e0bffe17 	ldw	r2,-8(fp)
811445f4:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
811445f8:	e0bffe17 	ldw	r2,-8(fp)
811445fc:	10c00417 	ldw	r3,16(r2)
81144600:	e0bffe17 	ldw	r2,-8(fp)
81144604:	10800517 	ldw	r2,20(r2)
81144608:	1880061e 	bne	r3,r2,81144624 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8114460c:	e0bffe17 	ldw	r2,-8(fp)
81144610:	10c00117 	ldw	r3,4(r2)
81144614:	00beefc4 	movi	r2,-1089
81144618:	1886703a 	and	r3,r3,r2
8114461c:	e0bffe17 	ldw	r2,-8(fp)
81144620:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81144624:	e0bffe17 	ldw	r2,-8(fp)
81144628:	10800017 	ldw	r2,0(r2)
8114462c:	10800304 	addi	r2,r2,12
81144630:	e0fffe17 	ldw	r3,-8(fp)
81144634:	18c00117 	ldw	r3,4(r3)
81144638:	10c00035 	stwio	r3,0(r2)
}
8114463c:	0001883a 	nop
81144640:	e037883a 	mov	sp,fp
81144644:	dfc00117 	ldw	ra,4(sp)
81144648:	df000017 	ldw	fp,0(sp)
8114464c:	dec00204 	addi	sp,sp,8
81144650:	f800283a 	ret

81144654 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81144654:	defffd04 	addi	sp,sp,-12
81144658:	de00012e 	bgeu	sp,et,81144660 <altera_avalon_uart_close+0xc>
8114465c:	003b68fa 	trap	3
81144660:	df000215 	stw	fp,8(sp)
81144664:	df000204 	addi	fp,sp,8
81144668:	e13ffe15 	stw	r4,-8(fp)
8114466c:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81144670:	00000506 	br	81144688 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81144674:	e0bfff17 	ldw	r2,-4(fp)
81144678:	1090000c 	andi	r2,r2,16384
8114467c:	10000226 	beq	r2,zero,81144688 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81144680:	00bffd44 	movi	r2,-11
81144684:	00000606 	br	811446a0 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81144688:	e0bffe17 	ldw	r2,-8(fp)
8114468c:	10c00417 	ldw	r3,16(r2)
81144690:	e0bffe17 	ldw	r2,-8(fp)
81144694:	10800517 	ldw	r2,20(r2)
81144698:	18bff61e 	bne	r3,r2,81144674 <__reset+0xfb124674>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
8114469c:	0005883a 	mov	r2,zero
}
811446a0:	e037883a 	mov	sp,fp
811446a4:	df000017 	ldw	fp,0(sp)
811446a8:	dec00104 	addi	sp,sp,4
811446ac:	f800283a 	ret

811446b0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811446b0:	defffe04 	addi	sp,sp,-8
811446b4:	de00012e 	bgeu	sp,et,811446bc <alt_get_errno+0xc>
811446b8:	003b68fa 	trap	3
811446bc:	dfc00115 	stw	ra,4(sp)
811446c0:	df000015 	stw	fp,0(sp)
811446c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811446c8:	d0a01017 	ldw	r2,-32704(gp)
811446cc:	10000326 	beq	r2,zero,811446dc <alt_get_errno+0x2c>
811446d0:	d0a01017 	ldw	r2,-32704(gp)
811446d4:	103ee83a 	callr	r2
811446d8:	00000106 	br	811446e0 <alt_get_errno+0x30>
811446dc:	d0a07704 	addi	r2,gp,-32292
}
811446e0:	e037883a 	mov	sp,fp
811446e4:	dfc00117 	ldw	ra,4(sp)
811446e8:	df000017 	ldw	fp,0(sp)
811446ec:	dec00204 	addi	sp,sp,8
811446f0:	f800283a 	ret

811446f4 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
811446f4:	deffec04 	addi	sp,sp,-80
811446f8:	de00012e 	bgeu	sp,et,81144700 <altera_avalon_uart_read+0xc>
811446fc:	003b68fa 	trap	3
81144700:	dfc01315 	stw	ra,76(sp)
81144704:	df001215 	stw	fp,72(sp)
81144708:	df001204 	addi	fp,sp,72
8114470c:	e13ffc15 	stw	r4,-16(fp)
81144710:	e17ffd15 	stw	r5,-12(fp)
81144714:	e1bffe15 	stw	r6,-8(fp)
81144718:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
8114471c:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81144720:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81144724:	e0bfff17 	ldw	r2,-4(fp)
81144728:	1090000c 	andi	r2,r2,16384
8114472c:	1005003a 	cmpeq	r2,r2,zero
81144730:	10803fcc 	andi	r2,r2,255
81144734:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81144738:	e0bffc17 	ldw	r2,-16(fp)
8114473c:	10800817 	ldw	r2,32(r2)
81144740:	e0bff815 	stw	r2,-32(fp)
81144744:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81144748:	e0bff90b 	ldhu	r2,-28(fp)
8114474c:	e0fffb44 	addi	r3,fp,-19
81144750:	180d883a 	mov	r6,r3
81144754:	100b883a 	mov	r5,r2
81144758:	e13ff817 	ldw	r4,-32(fp)
8114475c:	113b6f00 	call	8113b6f0 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81144760:	00001306 	br	811447b0 <altera_avalon_uart_read+0xbc>
    {
      count++;
81144764:	e0bff017 	ldw	r2,-64(fp)
81144768:	10800044 	addi	r2,r2,1
8114476c:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81144770:	e0bffd17 	ldw	r2,-12(fp)
81144774:	10c00044 	addi	r3,r2,1
81144778:	e0fffd15 	stw	r3,-12(fp)
8114477c:	e0fffc17 	ldw	r3,-16(fp)
81144780:	18c00217 	ldw	r3,8(r3)
81144784:	e13ffc17 	ldw	r4,-16(fp)
81144788:	20c7883a 	add	r3,r4,r3
8114478c:	18c00a04 	addi	r3,r3,40
81144790:	18c00003 	ldbu	r3,0(r3)
81144794:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81144798:	e0bffc17 	ldw	r2,-16(fp)
8114479c:	10800217 	ldw	r2,8(r2)
811447a0:	10800044 	addi	r2,r2,1
811447a4:	10c00fcc 	andi	r3,r2,63
811447a8:	e0bffc17 	ldw	r2,-16(fp)
811447ac:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
811447b0:	e0fff017 	ldw	r3,-64(fp)
811447b4:	e0bffe17 	ldw	r2,-8(fp)
811447b8:	1880050e 	bge	r3,r2,811447d0 <altera_avalon_uart_read+0xdc>
811447bc:	e0bffc17 	ldw	r2,-16(fp)
811447c0:	10c00217 	ldw	r3,8(r2)
811447c4:	e0bffc17 	ldw	r2,-16(fp)
811447c8:	10800317 	ldw	r2,12(r2)
811447cc:	18bfe51e 	bne	r3,r2,81144764 <__reset+0xfb124764>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
811447d0:	e0bff017 	ldw	r2,-64(fp)
811447d4:	10003a1e 	bne	r2,zero,811448c0 <altera_avalon_uart_read+0x1cc>
811447d8:	e0bffc17 	ldw	r2,-16(fp)
811447dc:	10c00217 	ldw	r3,8(r2)
811447e0:	e0bffc17 	ldw	r2,-16(fp)
811447e4:	10800317 	ldw	r2,12(r2)
811447e8:	1880351e 	bne	r3,r2,811448c0 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
811447ec:	e0bff117 	ldw	r2,-60(fp)
811447f0:	1000071e 	bne	r2,zero,81144810 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
811447f4:	11446b00 	call	811446b0 <alt_get_errno>
811447f8:	1007883a 	mov	r3,r2
811447fc:	008002c4 	movi	r2,11
81144800:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81144804:	00800044 	movi	r2,1
81144808:	e0bfef05 	stb	r2,-68(fp)
        break;
8114480c:	00003006 	br	811448d0 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144810:	0005303a 	rdctl	r2,status
81144814:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144818:	e0fff517 	ldw	r3,-44(fp)
8114481c:	00bfff84 	movi	r2,-2
81144820:	1884703a 	and	r2,r3,r2
81144824:	1001703a 	wrctl	status,r2
  
  return context;
81144828:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
8114482c:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81144830:	e0bffc17 	ldw	r2,-16(fp)
81144834:	10800117 	ldw	r2,4(r2)
81144838:	10c02014 	ori	r3,r2,128
8114483c:	e0bffc17 	ldw	r2,-16(fp)
81144840:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81144844:	e0bffc17 	ldw	r2,-16(fp)
81144848:	10800017 	ldw	r2,0(r2)
8114484c:	10800304 	addi	r2,r2,12
81144850:	e0fffc17 	ldw	r3,-16(fp)
81144854:	18c00117 	ldw	r3,4(r3)
81144858:	10c00035 	stwio	r3,0(r2)
8114485c:	e0bff417 	ldw	r2,-48(fp)
81144860:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144864:	e0bff617 	ldw	r2,-40(fp)
81144868:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
8114486c:	e0bffc17 	ldw	r2,-16(fp)
81144870:	10800717 	ldw	r2,28(r2)
81144874:	e0bff215 	stw	r2,-56(fp)
81144878:	00800044 	movi	r2,1
8114487c:	e0bff98d 	sth	r2,-26(fp)
81144880:	00bfe0c4 	movi	r2,-125
81144884:	e0bffa05 	stb	r2,-24(fp)
81144888:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8114488c:	d0a09003 	ldbu	r2,-32192(gp)
81144890:	10803fcc 	andi	r2,r2,255
81144894:	10000a26 	beq	r2,zero,811448c0 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81144898:	e0fff98b 	ldhu	r3,-26(fp)
8114489c:	e13ffa03 	ldbu	r4,-24(fp)
811448a0:	e17ffa8b 	ldhu	r5,-22(fp)
811448a4:	e0bffb04 	addi	r2,fp,-20
811448a8:	d8800015 	stw	r2,0(sp)
811448ac:	280f883a 	mov	r7,r5
811448b0:	200d883a 	mov	r6,r4
811448b4:	180b883a 	mov	r5,r3
811448b8:	e13ff217 	ldw	r4,-56(fp)
811448bc:	1137a500 	call	81137a50 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
811448c0:	e0bff017 	ldw	r2,-64(fp)
811448c4:	1000021e 	bne	r2,zero,811448d0 <altera_avalon_uart_read+0x1dc>
811448c8:	e0bffe17 	ldw	r2,-8(fp)
811448cc:	103fb81e 	bne	r2,zero,811447b0 <__reset+0xfb1247b0>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
811448d0:	e0bffc17 	ldw	r2,-16(fp)
811448d4:	10800817 	ldw	r2,32(r2)
811448d8:	1009883a 	mov	r4,r2
811448dc:	113ba780 	call	8113ba78 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811448e0:	0005303a 	rdctl	r2,status
811448e4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811448e8:	e0fff717 	ldw	r3,-36(fp)
811448ec:	00bfff84 	movi	r2,-2
811448f0:	1884703a 	and	r2,r3,r2
811448f4:	1001703a 	wrctl	status,r2
  
  return context;
811448f8:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
811448fc:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81144900:	e0bffc17 	ldw	r2,-16(fp)
81144904:	10800117 	ldw	r2,4(r2)
81144908:	10c02014 	ori	r3,r2,128
8114490c:	e0bffc17 	ldw	r2,-16(fp)
81144910:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81144914:	e0bffc17 	ldw	r2,-16(fp)
81144918:	10800017 	ldw	r2,0(r2)
8114491c:	10800304 	addi	r2,r2,12
81144920:	e0fffc17 	ldw	r3,-16(fp)
81144924:	18c00117 	ldw	r3,4(r3)
81144928:	10c00035 	stwio	r3,0(r2)
8114492c:	e0bff417 	ldw	r2,-48(fp)
81144930:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144934:	e0bff317 	ldw	r2,-52(fp)
81144938:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
8114493c:	e0bfef03 	ldbu	r2,-68(fp)
81144940:	10000226 	beq	r2,zero,8114494c <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81144944:	00bffd44 	movi	r2,-11
81144948:	00000106 	br	81144950 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
8114494c:	e0bff017 	ldw	r2,-64(fp)
  }
}
81144950:	e037883a 	mov	sp,fp
81144954:	dfc00117 	ldw	ra,4(sp)
81144958:	df000017 	ldw	fp,0(sp)
8114495c:	dec00204 	addi	sp,sp,8
81144960:	f800283a 	ret

81144964 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81144964:	defffe04 	addi	sp,sp,-8
81144968:	de00012e 	bgeu	sp,et,81144970 <alt_get_errno+0xc>
8114496c:	003b68fa 	trap	3
81144970:	dfc00115 	stw	ra,4(sp)
81144974:	df000015 	stw	fp,0(sp)
81144978:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114497c:	d0a01017 	ldw	r2,-32704(gp)
81144980:	10000326 	beq	r2,zero,81144990 <alt_get_errno+0x2c>
81144984:	d0a01017 	ldw	r2,-32704(gp)
81144988:	103ee83a 	callr	r2
8114498c:	00000106 	br	81144994 <alt_get_errno+0x30>
81144990:	d0a07704 	addi	r2,gp,-32292
}
81144994:	e037883a 	mov	sp,fp
81144998:	dfc00117 	ldw	ra,4(sp)
8114499c:	df000017 	ldw	fp,0(sp)
811449a0:	dec00204 	addi	sp,sp,8
811449a4:	f800283a 	ret

811449a8 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
811449a8:	deffec04 	addi	sp,sp,-80
811449ac:	de00012e 	bgeu	sp,et,811449b4 <altera_avalon_uart_write+0xc>
811449b0:	003b68fa 	trap	3
811449b4:	dfc01315 	stw	ra,76(sp)
811449b8:	df001215 	stw	fp,72(sp)
811449bc:	df001204 	addi	fp,sp,72
811449c0:	e13ffc15 	stw	r4,-16(fp)
811449c4:	e17ffd15 	stw	r5,-12(fp)
811449c8:	e1bffe15 	stw	r6,-8(fp)
811449cc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
811449d0:	e0bffe17 	ldw	r2,-8(fp)
811449d4:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
811449d8:	e0bfff17 	ldw	r2,-4(fp)
811449dc:	1090000c 	andi	r2,r2,16384
811449e0:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
811449e4:	e0bffc17 	ldw	r2,-16(fp)
811449e8:	10800917 	ldw	r2,36(r2)
811449ec:	e0bff815 	stw	r2,-32(fp)
811449f0:	e03ff90d 	sth	zero,-28(fp)
811449f4:	e0bff90b 	ldhu	r2,-28(fp)
811449f8:	e0fffb44 	addi	r3,fp,-19
811449fc:	180d883a 	mov	r6,r3
81144a00:	100b883a 	mov	r5,r2
81144a04:	e13ff817 	ldw	r4,-32(fp)
81144a08:	113b6f00 	call	8113b6f0 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81144a0c:	00005106 	br	81144b54 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81144a10:	e0bffc17 	ldw	r2,-16(fp)
81144a14:	10800517 	ldw	r2,20(r2)
81144a18:	10800044 	addi	r2,r2,1
81144a1c:	10800fcc 	andi	r2,r2,63
81144a20:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81144a24:	e0bffc17 	ldw	r2,-16(fp)
81144a28:	10c00417 	ldw	r3,16(r2)
81144a2c:	e0bff217 	ldw	r2,-56(fp)
81144a30:	1880371e 	bne	r3,r2,81144b10 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81144a34:	e0bff017 	ldw	r2,-64(fp)
81144a38:	10000526 	beq	r2,zero,81144a50 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81144a3c:	11449640 	call	81144964 <alt_get_errno>
81144a40:	1007883a 	mov	r3,r2
81144a44:	008002c4 	movi	r2,11
81144a48:	18800015 	stw	r2,0(r3)
        break;
81144a4c:	00004306 	br	81144b5c <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144a50:	0005303a 	rdctl	r2,status
81144a54:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144a58:	e0fff517 	ldw	r3,-44(fp)
81144a5c:	00bfff84 	movi	r2,-2
81144a60:	1884703a 	and	r2,r3,r2
81144a64:	1001703a 	wrctl	status,r2
  
  return context;
81144a68:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81144a6c:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81144a70:	e0bffc17 	ldw	r2,-16(fp)
81144a74:	10800117 	ldw	r2,4(r2)
81144a78:	10c11014 	ori	r3,r2,1088
81144a7c:	e0bffc17 	ldw	r2,-16(fp)
81144a80:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81144a84:	e0bffc17 	ldw	r2,-16(fp)
81144a88:	10800017 	ldw	r2,0(r2)
81144a8c:	10800304 	addi	r2,r2,12
81144a90:	e0fffc17 	ldw	r3,-16(fp)
81144a94:	18c00117 	ldw	r3,4(r3)
81144a98:	10c00035 	stwio	r3,0(r2)
81144a9c:	e0bff417 	ldw	r2,-48(fp)
81144aa0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144aa4:	e0bff117 	ldw	r2,-60(fp)
81144aa8:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81144aac:	e0bffc17 	ldw	r2,-16(fp)
81144ab0:	10800717 	ldw	r2,28(r2)
81144ab4:	e0bff315 	stw	r2,-52(fp)
81144ab8:	00800084 	movi	r2,2
81144abc:	e0bff98d 	sth	r2,-26(fp)
81144ac0:	00bfe0c4 	movi	r2,-125
81144ac4:	e0bffa05 	stb	r2,-24(fp)
81144ac8:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81144acc:	d0a09003 	ldbu	r2,-32192(gp)
81144ad0:	10803fcc 	andi	r2,r2,255
81144ad4:	10000a26 	beq	r2,zero,81144b00 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81144ad8:	e0fff98b 	ldhu	r3,-26(fp)
81144adc:	e13ffa03 	ldbu	r4,-24(fp)
81144ae0:	e17ffa8b 	ldhu	r5,-22(fp)
81144ae4:	e0bffb04 	addi	r2,fp,-20
81144ae8:	d8800015 	stw	r2,0(sp)
81144aec:	280f883a 	mov	r7,r5
81144af0:	200d883a 	mov	r6,r4
81144af4:	180b883a 	mov	r5,r3
81144af8:	e13ff317 	ldw	r4,-52(fp)
81144afc:	1137a500 	call	81137a50 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81144b00:	e0bffc17 	ldw	r2,-16(fp)
81144b04:	10c00417 	ldw	r3,16(r2)
81144b08:	e0bff217 	ldw	r2,-56(fp)
81144b0c:	18bfe726 	beq	r3,r2,81144aac <__reset+0xfb124aac>
      }
    }

    count--;
81144b10:	e0bfef17 	ldw	r2,-68(fp)
81144b14:	10bfffc4 	addi	r2,r2,-1
81144b18:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81144b1c:	e0bffc17 	ldw	r2,-16(fp)
81144b20:	10c00517 	ldw	r3,20(r2)
81144b24:	e0bffd17 	ldw	r2,-12(fp)
81144b28:	11000044 	addi	r4,r2,1
81144b2c:	e13ffd15 	stw	r4,-12(fp)
81144b30:	10800003 	ldbu	r2,0(r2)
81144b34:	1009883a 	mov	r4,r2
81144b38:	e0bffc17 	ldw	r2,-16(fp)
81144b3c:	10c5883a 	add	r2,r2,r3
81144b40:	10801a04 	addi	r2,r2,104
81144b44:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81144b48:	e0bffc17 	ldw	r2,-16(fp)
81144b4c:	e0fff217 	ldw	r3,-56(fp)
81144b50:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81144b54:	e0bfef17 	ldw	r2,-68(fp)
81144b58:	103fad1e 	bne	r2,zero,81144a10 <__reset+0xfb124a10>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81144b5c:	e0bffc17 	ldw	r2,-16(fp)
81144b60:	10800917 	ldw	r2,36(r2)
81144b64:	1009883a 	mov	r4,r2
81144b68:	113ba780 	call	8113ba78 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144b6c:	0005303a 	rdctl	r2,status
81144b70:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144b74:	e0fff717 	ldw	r3,-36(fp)
81144b78:	00bfff84 	movi	r2,-2
81144b7c:	1884703a 	and	r2,r3,r2
81144b80:	1001703a 	wrctl	status,r2
  
  return context;
81144b84:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81144b88:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81144b8c:	e0bffc17 	ldw	r2,-16(fp)
81144b90:	10800117 	ldw	r2,4(r2)
81144b94:	10c11014 	ori	r3,r2,1088
81144b98:	e0bffc17 	ldw	r2,-16(fp)
81144b9c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81144ba0:	e0bffc17 	ldw	r2,-16(fp)
81144ba4:	10800017 	ldw	r2,0(r2)
81144ba8:	10800304 	addi	r2,r2,12
81144bac:	e0fffc17 	ldw	r3,-16(fp)
81144bb0:	18c00117 	ldw	r3,4(r3)
81144bb4:	10c00035 	stwio	r3,0(r2)
81144bb8:	e0bff417 	ldw	r2,-48(fp)
81144bbc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144bc0:	e0bff617 	ldw	r2,-40(fp)
81144bc4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81144bc8:	e0fffe17 	ldw	r3,-8(fp)
81144bcc:	e0bfef17 	ldw	r2,-68(fp)
81144bd0:	1885c83a 	sub	r2,r3,r2
}
81144bd4:	e037883a 	mov	sp,fp
81144bd8:	dfc00117 	ldw	ra,4(sp)
81144bdc:	df000017 	ldw	fp,0(sp)
81144be0:	dec00204 	addi	sp,sp,8
81144be4:	f800283a 	ret

81144be8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81144be8:	defffe04 	addi	sp,sp,-8
81144bec:	de00012e 	bgeu	sp,et,81144bf4 <alt_get_errno+0xc>
81144bf0:	003b68fa 	trap	3
81144bf4:	dfc00115 	stw	ra,4(sp)
81144bf8:	df000015 	stw	fp,0(sp)
81144bfc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81144c00:	d0a01017 	ldw	r2,-32704(gp)
81144c04:	10000326 	beq	r2,zero,81144c14 <alt_get_errno+0x2c>
81144c08:	d0a01017 	ldw	r2,-32704(gp)
81144c0c:	103ee83a 	callr	r2
81144c10:	00000106 	br	81144c18 <alt_get_errno+0x30>
81144c14:	d0a07704 	addi	r2,gp,-32292
}
81144c18:	e037883a 	mov	sp,fp
81144c1c:	dfc00117 	ldw	ra,4(sp)
81144c20:	df000017 	ldw	fp,0(sp)
81144c24:	dec00204 	addi	sp,sp,8
81144c28:	f800283a 	ret

81144c2c <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81144c2c:	defffc04 	addi	sp,sp,-16
81144c30:	de00012e 	bgeu	sp,et,81144c38 <alt_msgdma_write_standard_descriptor+0xc>
81144c34:	003b68fa 	trap	3
81144c38:	df000315 	stw	fp,12(sp)
81144c3c:	df000304 	addi	fp,sp,12
81144c40:	e13ffd15 	stw	r4,-12(fp)
81144c44:	e17ffe15 	stw	r5,-8(fp)
81144c48:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81144c4c:	e0bffd17 	ldw	r2,-12(fp)
81144c50:	10800037 	ldwio	r2,0(r2)
81144c54:	1080010c 	andi	r2,r2,4
81144c58:	10000226 	beq	r2,zero,81144c64 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81144c5c:	00bff904 	movi	r2,-28
81144c60:	00001506 	br	81144cb8 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81144c64:	e0bfff17 	ldw	r2,-4(fp)
81144c68:	10800017 	ldw	r2,0(r2)
81144c6c:	1007883a 	mov	r3,r2
81144c70:	e0bffe17 	ldw	r2,-8(fp)
81144c74:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81144c78:	e0bffe17 	ldw	r2,-8(fp)
81144c7c:	10800104 	addi	r2,r2,4
81144c80:	e0ffff17 	ldw	r3,-4(fp)
81144c84:	18c00117 	ldw	r3,4(r3)
81144c88:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81144c8c:	e0bffe17 	ldw	r2,-8(fp)
81144c90:	10800204 	addi	r2,r2,8
81144c94:	e0ffff17 	ldw	r3,-4(fp)
81144c98:	18c00217 	ldw	r3,8(r3)
81144c9c:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81144ca0:	e0bffe17 	ldw	r2,-8(fp)
81144ca4:	10800304 	addi	r2,r2,12
81144ca8:	e0ffff17 	ldw	r3,-4(fp)
81144cac:	18c00317 	ldw	r3,12(r3)
81144cb0:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81144cb4:	0005883a 	mov	r2,zero
}
81144cb8:	e037883a 	mov	sp,fp
81144cbc:	df000017 	ldw	fp,0(sp)
81144cc0:	dec00104 	addi	sp,sp,4
81144cc4:	f800283a 	ret

81144cc8 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81144cc8:	defffc04 	addi	sp,sp,-16
81144ccc:	de00012e 	bgeu	sp,et,81144cd4 <alt_msgdma_write_extended_descriptor+0xc>
81144cd0:	003b68fa 	trap	3
81144cd4:	df000315 	stw	fp,12(sp)
81144cd8:	df000304 	addi	fp,sp,12
81144cdc:	e13ffd15 	stw	r4,-12(fp)
81144ce0:	e17ffe15 	stw	r5,-8(fp)
81144ce4:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81144ce8:	e0bffd17 	ldw	r2,-12(fp)
81144cec:	10800037 	ldwio	r2,0(r2)
81144cf0:	1080010c 	andi	r2,r2,4
81144cf4:	10000226 	beq	r2,zero,81144d00 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81144cf8:	00bff904 	movi	r2,-28
81144cfc:	00003b06 	br	81144dec <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81144d00:	e0bfff17 	ldw	r2,-4(fp)
81144d04:	10800017 	ldw	r2,0(r2)
81144d08:	1007883a 	mov	r3,r2
81144d0c:	e0bffe17 	ldw	r2,-8(fp)
81144d10:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81144d14:	e0bffe17 	ldw	r2,-8(fp)
81144d18:	10800104 	addi	r2,r2,4
81144d1c:	e0ffff17 	ldw	r3,-4(fp)
81144d20:	18c00117 	ldw	r3,4(r3)
81144d24:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81144d28:	e0bffe17 	ldw	r2,-8(fp)
81144d2c:	10800204 	addi	r2,r2,8
81144d30:	e0ffff17 	ldw	r3,-4(fp)
81144d34:	18c00217 	ldw	r3,8(r3)
81144d38:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81144d3c:	e0bffe17 	ldw	r2,-8(fp)
81144d40:	10800304 	addi	r2,r2,12
81144d44:	e0ffff17 	ldw	r3,-4(fp)
81144d48:	18c0030b 	ldhu	r3,12(r3)
81144d4c:	18ffffcc 	andi	r3,r3,65535
81144d50:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81144d54:	e0bffe17 	ldw	r2,-8(fp)
81144d58:	10800384 	addi	r2,r2,14
81144d5c:	e0ffff17 	ldw	r3,-4(fp)
81144d60:	18c00383 	ldbu	r3,14(r3)
81144d64:	18c03fcc 	andi	r3,r3,255
81144d68:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81144d6c:	e0bffe17 	ldw	r2,-8(fp)
81144d70:	108003c4 	addi	r2,r2,15
81144d74:	e0ffff17 	ldw	r3,-4(fp)
81144d78:	18c003c3 	ldbu	r3,15(r3)
81144d7c:	18c03fcc 	andi	r3,r3,255
81144d80:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81144d84:	e0bffe17 	ldw	r2,-8(fp)
81144d88:	10800404 	addi	r2,r2,16
81144d8c:	e0ffff17 	ldw	r3,-4(fp)
81144d90:	18c0040b 	ldhu	r3,16(r3)
81144d94:	18ffffcc 	andi	r3,r3,65535
81144d98:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81144d9c:	e0bffe17 	ldw	r2,-8(fp)
81144da0:	10800484 	addi	r2,r2,18
81144da4:	e0ffff17 	ldw	r3,-4(fp)
81144da8:	18c0048b 	ldhu	r3,18(r3)
81144dac:	18ffffcc 	andi	r3,r3,65535
81144db0:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81144db4:	e0bffe17 	ldw	r2,-8(fp)
81144db8:	10800504 	addi	r2,r2,20
81144dbc:	0007883a 	mov	r3,zero
81144dc0:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
81144dc4:	e0bffe17 	ldw	r2,-8(fp)
81144dc8:	10800604 	addi	r2,r2,24
81144dcc:	0007883a 	mov	r3,zero
81144dd0:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
81144dd4:	e0bffe17 	ldw	r2,-8(fp)
81144dd8:	10800704 	addi	r2,r2,28
81144ddc:	e0ffff17 	ldw	r3,-4(fp)
81144de0:	18c00717 	ldw	r3,28(r3)
81144de4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
81144de8:	0005883a 	mov	r2,zero
}
81144dec:	e037883a 	mov	sp,fp
81144df0:	df000017 	ldw	fp,0(sp)
81144df4:	dec00104 	addi	sp,sp,4
81144df8:	f800283a 	ret

81144dfc <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81144dfc:	defff804 	addi	sp,sp,-32
81144e00:	de00012e 	bgeu	sp,et,81144e08 <alt_msgdma_irq+0xc>
81144e04:	003b68fa 	trap	3
81144e08:	dfc00715 	stw	ra,28(sp)
81144e0c:	df000615 	stw	fp,24(sp)
81144e10:	df000604 	addi	fp,sp,24
81144e14:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81144e18:	e0bfff17 	ldw	r2,-4(fp)
81144e1c:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81144e20:	e0bffa17 	ldw	r2,-24(fp)
81144e24:	10801783 	ldbu	r2,94(r2)
81144e28:	10803fcc 	andi	r2,r2,255
81144e2c:	10001126 	beq	r2,zero,81144e74 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81144e30:	e0bffa17 	ldw	r2,-24(fp)
81144e34:	10800617 	ldw	r2,24(r2)
81144e38:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81144e3c:	1007883a 	mov	r3,r2
81144e40:	00bffdc4 	movi	r2,-9
81144e44:	1884703a 	and	r2,r3,r2
81144e48:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81144e4c:	e0bffa17 	ldw	r2,-24(fp)
81144e50:	10800617 	ldw	r2,24(r2)
81144e54:	e0fffb17 	ldw	r3,-20(fp)
81144e58:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81144e5c:	e0bffa17 	ldw	r2,-24(fp)
81144e60:	10800617 	ldw	r2,24(r2)
81144e64:	10800404 	addi	r2,r2,16
81144e68:	00c00044 	movi	r3,1
81144e6c:	10c00035 	stwio	r3,0(r2)
81144e70:	00001106 	br	81144eb8 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81144e74:	e0bffa17 	ldw	r2,-24(fp)
81144e78:	10800317 	ldw	r2,12(r2)
81144e7c:	10800104 	addi	r2,r2,4
81144e80:	10800037 	ldwio	r2,0(r2)
81144e84:	1007883a 	mov	r3,r2
81144e88:	00bffbc4 	movi	r2,-17
81144e8c:	1884703a 	and	r2,r3,r2
81144e90:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81144e94:	e0bffa17 	ldw	r2,-24(fp)
81144e98:	10800317 	ldw	r2,12(r2)
81144e9c:	10800104 	addi	r2,r2,4
81144ea0:	e0fffb17 	ldw	r3,-20(fp)
81144ea4:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81144ea8:	e0bffa17 	ldw	r2,-24(fp)
81144eac:	10800317 	ldw	r2,12(r2)
81144eb0:	00c08004 	movi	r3,512
81144eb4:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
81144eb8:	e0bffa17 	ldw	r2,-24(fp)
81144ebc:	10800b17 	ldw	r2,44(r2)
81144ec0:	10001226 	beq	r2,zero,81144f0c <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144ec4:	0005303a 	rdctl	r2,status
81144ec8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144ecc:	e0fffd17 	ldw	r3,-12(fp)
81144ed0:	00bfff84 	movi	r2,-2
81144ed4:	1884703a 	and	r2,r3,r2
81144ed8:	1001703a 	wrctl	status,r2
  
  return context;
81144edc:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81144ee0:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
81144ee4:	e0bffa17 	ldw	r2,-24(fp)
81144ee8:	10800b17 	ldw	r2,44(r2)
81144eec:	e0fffa17 	ldw	r3,-24(fp)
81144ef0:	18c00c17 	ldw	r3,48(r3)
81144ef4:	1809883a 	mov	r4,r3
81144ef8:	103ee83a 	callr	r2
81144efc:	e0bffc17 	ldw	r2,-16(fp)
81144f00:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144f04:	e0bffe17 	ldw	r2,-8(fp)
81144f08:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81144f0c:	e0bffa17 	ldw	r2,-24(fp)
81144f10:	10801783 	ldbu	r2,94(r2)
81144f14:	10803fcc 	andi	r2,r2,255
81144f18:	10000a26 	beq	r2,zero,81144f44 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81144f1c:	e0bffa17 	ldw	r2,-24(fp)
81144f20:	10800617 	ldw	r2,24(r2)
81144f24:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81144f28:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81144f2c:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81144f30:	e0bffa17 	ldw	r2,-24(fp)
81144f34:	10800617 	ldw	r2,24(r2)
81144f38:	e0fffb17 	ldw	r3,-20(fp)
81144f3c:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81144f40:	00000c06 	br	81144f74 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81144f44:	e0bffa17 	ldw	r2,-24(fp)
81144f48:	10800317 	ldw	r2,12(r2)
81144f4c:	10800104 	addi	r2,r2,4
81144f50:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81144f54:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81144f58:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81144f5c:	e0bffa17 	ldw	r2,-24(fp)
81144f60:	10800317 	ldw	r2,12(r2)
81144f64:	10800104 	addi	r2,r2,4
81144f68:	e0fffb17 	ldw	r3,-20(fp)
81144f6c:	10c00035 	stwio	r3,0(r2)
    }

    return;
81144f70:	0001883a 	nop
}
81144f74:	e037883a 	mov	sp,fp
81144f78:	dfc00117 	ldw	ra,4(sp)
81144f7c:	df000017 	ldw	fp,0(sp)
81144f80:	dec00204 	addi	sp,sp,8
81144f84:	f800283a 	ret

81144f88 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81144f88:	defffb04 	addi	sp,sp,-20
81144f8c:	de00012e 	bgeu	sp,et,81144f94 <alt_msgdma_construct_standard_descriptor+0xc>
81144f90:	003b68fa 	trap	3
81144f94:	df000415 	stw	fp,16(sp)
81144f98:	df000404 	addi	fp,sp,16
81144f9c:	e13ffc15 	stw	r4,-16(fp)
81144fa0:	e17ffd15 	stw	r5,-12(fp)
81144fa4:	e1bffe15 	stw	r6,-8(fp)
81144fa8:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81144fac:	e0bffc17 	ldw	r2,-16(fp)
81144fb0:	10c01217 	ldw	r3,72(r2)
81144fb4:	e0800117 	ldw	r2,4(fp)
81144fb8:	18800436 	bltu	r3,r2,81144fcc <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81144fbc:	e0bffc17 	ldw	r2,-16(fp)
81144fc0:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81144fc4:	10803fcc 	andi	r2,r2,255
81144fc8:	10000226 	beq	r2,zero,81144fd4 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81144fcc:	00bffa84 	movi	r2,-22
81144fd0:	00000e06 	br	8114500c <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
81144fd4:	e0bffd17 	ldw	r2,-12(fp)
81144fd8:	e0fffe17 	ldw	r3,-8(fp)
81144fdc:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81144fe0:	e0bffd17 	ldw	r2,-12(fp)
81144fe4:	e0ffff17 	ldw	r3,-4(fp)
81144fe8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81144fec:	e0bffd17 	ldw	r2,-12(fp)
81144ff0:	e0c00117 	ldw	r3,4(fp)
81144ff4:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81144ff8:	e0800217 	ldw	r2,8(fp)
81144ffc:	10e00034 	orhi	r3,r2,32768
81145000:	e0bffd17 	ldw	r2,-12(fp)
81145004:	10c00315 	stw	r3,12(r2)
    
    return 0;
81145008:	0005883a 	mov	r2,zero
}
8114500c:	e037883a 	mov	sp,fp
81145010:	df000017 	ldw	fp,0(sp)
81145014:	dec00104 	addi	sp,sp,4
81145018:	f800283a 	ret

8114501c <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114501c:	defff604 	addi	sp,sp,-40
81145020:	de00012e 	bgeu	sp,et,81145028 <alt_msgdma_construct_extended_descriptor+0xc>
81145024:	003b68fa 	trap	3
81145028:	df000915 	stw	fp,36(sp)
8114502c:	df000904 	addi	fp,sp,36
81145030:	e13ff715 	stw	r4,-36(fp)
81145034:	e17ff815 	stw	r5,-32(fp)
81145038:	e1bff915 	stw	r6,-28(fp)
8114503c:	e1fffa15 	stw	r7,-24(fp)
81145040:	e1800317 	ldw	r6,12(fp)
81145044:	e1400417 	ldw	r5,16(fp)
81145048:	e1000517 	ldw	r4,20(fp)
8114504c:	e0c00617 	ldw	r3,24(fp)
81145050:	e0800717 	ldw	r2,28(fp)
81145054:	e1bffb0d 	sth	r6,-20(fp)
81145058:	e17ffc05 	stb	r5,-16(fp)
8114505c:	e13ffd05 	stb	r4,-12(fp)
81145060:	e0fffe0d 	sth	r3,-8(fp)
81145064:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81145068:	e0bff717 	ldw	r2,-36(fp)
8114506c:	10c01217 	ldw	r3,72(r2)
81145070:	e0800117 	ldw	r2,4(fp)
81145074:	18801936 	bltu	r3,r2,811450dc <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81145078:	e13ff717 	ldw	r4,-36(fp)
8114507c:	20801317 	ldw	r2,76(r4)
81145080:	20c01417 	ldw	r3,80(r4)
81145084:	e13ffe0b 	ldhu	r4,-8(fp)
81145088:	213fffcc 	andi	r4,r4,65535
8114508c:	2015883a 	mov	r10,r4
81145090:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81145094:	1ac01136 	bltu	r3,r11,811450dc <alt_msgdma_construct_extended_descriptor+0xc0>
81145098:	58c0011e 	bne	r11,r3,811450a0 <alt_msgdma_construct_extended_descriptor+0x84>
8114509c:	12800f36 	bltu	r2,r10,811450dc <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811450a0:	e13ff717 	ldw	r4,-36(fp)
811450a4:	20801317 	ldw	r2,76(r4)
811450a8:	20c01417 	ldw	r3,80(r4)
811450ac:	e13fff0b 	ldhu	r4,-4(fp)
811450b0:	213fffcc 	andi	r4,r4,65535
811450b4:	2011883a 	mov	r8,r4
811450b8:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
811450bc:	1a400736 	bltu	r3,r9,811450dc <alt_msgdma_construct_extended_descriptor+0xc0>
811450c0:	48c0011e 	bne	r9,r3,811450c8 <alt_msgdma_construct_extended_descriptor+0xac>
811450c4:	12000536 	bltu	r2,r8,811450dc <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811450c8:	e0bff717 	ldw	r2,-36(fp)
811450cc:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811450d0:	10803fcc 	andi	r2,r2,255
811450d4:	10800060 	cmpeqi	r2,r2,1
811450d8:	1000021e 	bne	r2,zero,811450e4 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
811450dc:	00bffa84 	movi	r2,-22
811450e0:	00002106 	br	81145168 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
811450e4:	e0bff817 	ldw	r2,-32(fp)
811450e8:	e0fff917 	ldw	r3,-28(fp)
811450ec:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
811450f0:	e0bff817 	ldw	r2,-32(fp)
811450f4:	e0fffa17 	ldw	r3,-24(fp)
811450f8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811450fc:	e0bff817 	ldw	r2,-32(fp)
81145100:	e0c00117 	ldw	r3,4(fp)
81145104:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81145108:	e0bff817 	ldw	r2,-32(fp)
8114510c:	e0fffb0b 	ldhu	r3,-20(fp)
81145110:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
81145114:	e0bff817 	ldw	r2,-32(fp)
81145118:	e0fffc03 	ldbu	r3,-16(fp)
8114511c:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81145120:	e0bff817 	ldw	r2,-32(fp)
81145124:	e0fffd03 	ldbu	r3,-12(fp)
81145128:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
8114512c:	e0bff817 	ldw	r2,-32(fp)
81145130:	e0fffe0b 	ldhu	r3,-8(fp)
81145134:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
81145138:	e0bff817 	ldw	r2,-32(fp)
8114513c:	e0ffff0b 	ldhu	r3,-4(fp)
81145140:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81145144:	e0bff817 	ldw	r2,-32(fp)
81145148:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
8114514c:	e0bff817 	ldw	r2,-32(fp)
81145150:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81145154:	e0800217 	ldw	r2,8(fp)
81145158:	10e00034 	orhi	r3,r2,32768
8114515c:	e0bff817 	ldw	r2,-32(fp)
81145160:	10c00715 	stw	r3,28(r2)

  return 0 ;
81145164:	0005883a 	mov	r2,zero

}
81145168:	e037883a 	mov	sp,fp
8114516c:	df000017 	ldw	fp,0(sp)
81145170:	dec00104 	addi	sp,sp,4
81145174:	f800283a 	ret

81145178 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81145178:	deffee04 	addi	sp,sp,-72
8114517c:	de00012e 	bgeu	sp,et,81145184 <alt_msgdma_descriptor_async_transfer+0xc>
81145180:	003b68fa 	trap	3
81145184:	dfc01115 	stw	ra,68(sp)
81145188:	df001015 	stw	fp,64(sp)
8114518c:	df001004 	addi	fp,sp,64
81145190:	e13ffd15 	stw	r4,-12(fp)
81145194:	e17ffe15 	stw	r5,-8(fp)
81145198:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
8114519c:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
811451a0:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
811451a4:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811451a8:	e0bffd17 	ldw	r2,-12(fp)
811451ac:	10800317 	ldw	r2,12(r2)
811451b0:	10800204 	addi	r2,r2,8
811451b4:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811451b8:	10bfffcc 	andi	r2,r2,65535
811451bc:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811451c0:	e0bffd17 	ldw	r2,-12(fp)
811451c4:	10800317 	ldw	r2,12(r2)
811451c8:	10800204 	addi	r2,r2,8
811451cc:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811451d0:	1004d43a 	srli	r2,r2,16
811451d4:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811451d8:	e0bffd17 	ldw	r2,-12(fp)
811451dc:	10800917 	ldw	r2,36(r2)
811451e0:	e0fff417 	ldw	r3,-48(fp)
811451e4:	1880042e 	bgeu	r3,r2,811451f8 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811451e8:	e0bffd17 	ldw	r2,-12(fp)
811451ec:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811451f0:	e0fff317 	ldw	r3,-52(fp)
811451f4:	18800236 	bltu	r3,r2,81145200 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
811451f8:	00bff904 	movi	r2,-28
811451fc:	0000a906 	br	811454a4 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81145200:	e0bffd17 	ldw	r2,-12(fp)
81145204:	10801817 	ldw	r2,96(r2)
81145208:	e0bff615 	stw	r2,-40(fp)
8114520c:	e03ffc0d 	sth	zero,-16(fp)
81145210:	e0bffc0b 	ldhu	r2,-16(fp)
81145214:	e0fffc84 	addi	r3,fp,-14
81145218:	180d883a 	mov	r6,r3
8114521c:	100b883a 	mov	r5,r2
81145220:	e13ff617 	ldw	r4,-40(fp)
81145224:	113b6f00 	call	8113b6f0 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81145228:	00800804 	movi	r2,32
8114522c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145230:	0005303a 	rdctl	r2,status
81145234:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145238:	e0fff717 	ldw	r3,-36(fp)
8114523c:	00bfff84 	movi	r2,-2
81145240:	1884703a 	and	r2,r3,r2
81145244:	1001703a 	wrctl	status,r2
  
  return context;
81145248:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114524c:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81145250:	e0bffd17 	ldw	r2,-12(fp)
81145254:	10800317 	ldw	r2,12(r2)
81145258:	10800104 	addi	r2,r2,4
8114525c:	e0fff117 	ldw	r3,-60(fp)
81145260:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81145264:	e0bffd17 	ldw	r2,-12(fp)
81145268:	10800317 	ldw	r2,12(r2)
8114526c:	e0fffd17 	ldw	r3,-12(fp)
81145270:	18c00317 	ldw	r3,12(r3)
81145274:	18c00037 	ldwio	r3,0(r3)
81145278:	10c00035 	stwio	r3,0(r2)
8114527c:	e0bff217 	ldw	r2,-56(fp)
81145280:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145284:	e0bffb17 	ldw	r2,-20(fp)
81145288:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8114528c:	e0bffe17 	ldw	r2,-8(fp)
81145290:	10001e26 	beq	r2,zero,8114530c <alt_msgdma_descriptor_async_transfer+0x194>
81145294:	e0bfff17 	ldw	r2,-4(fp)
81145298:	10001c1e 	bne	r2,zero,8114530c <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114529c:	00001106 	br	811452e4 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811452a0:	01000044 	movi	r4,1
811452a4:	1132e780 	call	81132e78 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811452a8:	e0bff00b 	ldhu	r2,-64(fp)
811452ac:	1084e230 	cmpltui	r2,r2,5000
811452b0:	1000091e 	bne	r2,zero,811452d8 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
811452b4:	01204574 	movhi	r4,33045
811452b8:	21356804 	addi	r4,r4,-10848
811452bc:	11475cc0 	call	811475cc <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811452c0:	e0bffd17 	ldw	r2,-12(fp)
811452c4:	10801817 	ldw	r2,96(r2)
811452c8:	1009883a 	mov	r4,r2
811452cc:	113ba780 	call	8113ba78 <OSSemPost>
				
                return -ETIME;
811452d0:	00bff084 	movi	r2,-62
811452d4:	00007306 	br	811454a4 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811452d8:	e0bff00b 	ldhu	r2,-64(fp)
811452dc:	10800044 	addi	r2,r2,1
811452e0:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811452e4:	e0bffd17 	ldw	r2,-12(fp)
811452e8:	10c00317 	ldw	r3,12(r2)
811452ec:	e0bffd17 	ldw	r2,-12(fp)
811452f0:	10800417 	ldw	r2,16(r2)
811452f4:	e1bffe17 	ldw	r6,-8(fp)
811452f8:	100b883a 	mov	r5,r2
811452fc:	1809883a 	mov	r4,r3
81145300:	1144c2c0 	call	81144c2c <alt_msgdma_write_standard_descriptor>
81145304:	103fe61e 	bne	r2,zero,811452a0 <__reset+0xfb1252a0>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81145308:	00002706 	br	811453a8 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114530c:	e0bffe17 	ldw	r2,-8(fp)
81145310:	10001f1e 	bne	r2,zero,81145390 <alt_msgdma_descriptor_async_transfer+0x218>
81145314:	e0bfff17 	ldw	r2,-4(fp)
81145318:	10001d26 	beq	r2,zero,81145390 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
8114531c:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81145320:	00001106 	br	81145368 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81145324:	01000044 	movi	r4,1
81145328:	1132e780 	call	81132e78 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114532c:	e0bff00b 	ldhu	r2,-64(fp)
81145330:	1084e230 	cmpltui	r2,r2,5000
81145334:	1000091e 	bne	r2,zero,8114535c <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
81145338:	01204574 	movhi	r4,33045
8114533c:	21357e04 	addi	r4,r4,-10760
81145340:	11475cc0 	call	811475cc <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81145344:	e0bffd17 	ldw	r2,-12(fp)
81145348:	10801817 	ldw	r2,96(r2)
8114534c:	1009883a 	mov	r4,r2
81145350:	113ba780 	call	8113ba78 <OSSemPost>
				
                return -ETIME;
81145354:	00bff084 	movi	r2,-62
81145358:	00005206 	br	811454a4 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8114535c:	e0bff00b 	ldhu	r2,-64(fp)
81145360:	10800044 	addi	r2,r2,1
81145364:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81145368:	e0bffd17 	ldw	r2,-12(fp)
8114536c:	10c00317 	ldw	r3,12(r2)
81145370:	e0bffd17 	ldw	r2,-12(fp)
81145374:	10800417 	ldw	r2,16(r2)
81145378:	e1bfff17 	ldw	r6,-4(fp)
8114537c:	100b883a 	mov	r5,r2
81145380:	1809883a 	mov	r4,r3
81145384:	1144cc80 	call	81144cc8 <alt_msgdma_write_extended_descriptor>
81145388:	103fe61e 	bne	r2,zero,81145324 <__reset+0xfb125324>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114538c:	00000606 	br	811453a8 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81145390:	e0bffd17 	ldw	r2,-12(fp)
81145394:	10801817 	ldw	r2,96(r2)
81145398:	1009883a 	mov	r4,r2
8114539c:	113ba780 	call	8113ba78 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
811453a0:	00bfffc4 	movi	r2,-1
811453a4:	00003f06 	br	811454a4 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
811453a8:	e0bffd17 	ldw	r2,-12(fp)
811453ac:	10800b17 	ldw	r2,44(r2)
811453b0:	10001c26 	beq	r2,zero,81145424 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
811453b4:	e0bffd17 	ldw	r2,-12(fp)
811453b8:	10c00d17 	ldw	r3,52(r2)
811453bc:	e0bff117 	ldw	r2,-60(fp)
811453c0:	1884b03a 	or	r2,r3,r2
811453c4:	10800514 	ori	r2,r2,20
811453c8:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
811453cc:	e0fff117 	ldw	r3,-60(fp)
811453d0:	00bff7c4 	movi	r2,-33
811453d4:	1884703a 	and	r2,r3,r2
811453d8:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811453dc:	0005303a 	rdctl	r2,status
811453e0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811453e4:	e0fff917 	ldw	r3,-28(fp)
811453e8:	00bfff84 	movi	r2,-2
811453ec:	1884703a 	and	r2,r3,r2
811453f0:	1001703a 	wrctl	status,r2
  
  return context;
811453f4:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
811453f8:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811453fc:	e0bffd17 	ldw	r2,-12(fp)
81145400:	10800317 	ldw	r2,12(r2)
81145404:	10800104 	addi	r2,r2,4
81145408:	e0fff117 	ldw	r3,-60(fp)
8114540c:	10c00035 	stwio	r3,0(r2)
81145410:	e0bff217 	ldw	r2,-56(fp)
81145414:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145418:	e0bff517 	ldw	r2,-44(fp)
8114541c:	1001703a 	wrctl	status,r2
81145420:	00001b06 	br	81145490 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
81145424:	e0bffd17 	ldw	r2,-12(fp)
81145428:	10c00d17 	ldw	r3,52(r2)
8114542c:	e0bff117 	ldw	r2,-60(fp)
81145430:	1884b03a 	or	r2,r3,r2
81145434:	10800114 	ori	r2,r2,4
81145438:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
8114543c:	e0fff117 	ldw	r3,-60(fp)
81145440:	00bff3c4 	movi	r2,-49
81145444:	1884703a 	and	r2,r3,r2
81145448:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114544c:	0005303a 	rdctl	r2,status
81145450:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145454:	e0fffa17 	ldw	r3,-24(fp)
81145458:	00bfff84 	movi	r2,-2
8114545c:	1884703a 	and	r2,r3,r2
81145460:	1001703a 	wrctl	status,r2
  
  return context;
81145464:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81145468:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114546c:	e0bffd17 	ldw	r2,-12(fp)
81145470:	10800317 	ldw	r2,12(r2)
81145474:	10800104 	addi	r2,r2,4
81145478:	e0fff117 	ldw	r3,-60(fp)
8114547c:	10c00035 	stwio	r3,0(r2)
81145480:	e0bff217 	ldw	r2,-56(fp)
81145484:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145488:	e0bff817 	ldw	r2,-32(fp)
8114548c:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81145490:	e0bffd17 	ldw	r2,-12(fp)
81145494:	10801817 	ldw	r2,96(r2)
81145498:	1009883a 	mov	r4,r2
8114549c:	113ba780 	call	8113ba78 <OSSemPost>
    
    return 0;
811454a0:	0005883a 	mov	r2,zero
}
811454a4:	e037883a 	mov	sp,fp
811454a8:	dfc00117 	ldw	ra,4(sp)
811454ac:	df000017 	ldw	fp,0(sp)
811454b0:	dec00204 	addi	sp,sp,8
811454b4:	f800283a 	ret

811454b8 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
811454b8:	deffee04 	addi	sp,sp,-72
811454bc:	de00012e 	bgeu	sp,et,811454c4 <alt_msgdma_descriptor_sync_transfer+0xc>
811454c0:	003b68fa 	trap	3
811454c4:	dfc01115 	stw	ra,68(sp)
811454c8:	df001015 	stw	fp,64(sp)
811454cc:	df001004 	addi	fp,sp,64
811454d0:	e13ffd15 	stw	r4,-12(fp)
811454d4:	e17ffe15 	stw	r5,-8(fp)
811454d8:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
811454dc:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
811454e0:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
811454e4:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
811454e8:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811454ec:	e0bffd17 	ldw	r2,-12(fp)
811454f0:	10800317 	ldw	r2,12(r2)
811454f4:	10800204 	addi	r2,r2,8
811454f8:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811454fc:	10bfffcc 	andi	r2,r2,65535
81145500:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81145504:	e0bffd17 	ldw	r2,-12(fp)
81145508:	10800317 	ldw	r2,12(r2)
8114550c:	10800204 	addi	r2,r2,8
81145510:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81145514:	1004d43a 	srli	r2,r2,16
81145518:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
8114551c:	00807804 	movi	r2,480
81145520:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81145524:	00001906 	br	8114558c <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
81145528:	01000044 	movi	r4,1
8114552c:	1132e780 	call	81132e78 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81145530:	e0bff10b 	ldhu	r2,-60(fp)
81145534:	1084e230 	cmpltui	r2,r2,5000
81145538:	1000051e 	bne	r2,zero,81145550 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
8114553c:	01204574 	movhi	r4,33045
81145540:	21359404 	addi	r4,r4,-10672
81145544:	11475cc0 	call	811475cc <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81145548:	00bff084 	movi	r2,-62
8114554c:	0000d706 	br	811458ac <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81145550:	e0bff10b 	ldhu	r2,-60(fp)
81145554:	10800044 	addi	r2,r2,1
81145558:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114555c:	e0bffd17 	ldw	r2,-12(fp)
81145560:	10800317 	ldw	r2,12(r2)
81145564:	10800204 	addi	r2,r2,8
81145568:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
8114556c:	10bfffcc 	andi	r2,r2,65535
81145570:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81145574:	e0bffd17 	ldw	r2,-12(fp)
81145578:	10800317 	ldw	r2,12(r2)
8114557c:	10800204 	addi	r2,r2,8
81145580:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81145584:	1004d43a 	srli	r2,r2,16
81145588:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114558c:	e0bffd17 	ldw	r2,-12(fp)
81145590:	10800917 	ldw	r2,36(r2)
81145594:	e0fff317 	ldw	r3,-52(fp)
81145598:	18bfe32e 	bgeu	r3,r2,81145528 <__reset+0xfb125528>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8114559c:	e0bffd17 	ldw	r2,-12(fp)
811455a0:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811455a4:	e0fff217 	ldw	r3,-56(fp)
811455a8:	18bfdf2e 	bgeu	r3,r2,81145528 <__reset+0xfb125528>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
811455ac:	e0bffd17 	ldw	r2,-12(fp)
811455b0:	10801817 	ldw	r2,96(r2)
811455b4:	e0bff815 	stw	r2,-32(fp)
811455b8:	e03ffc0d 	sth	zero,-16(fp)
811455bc:	e0bffc0b 	ldhu	r2,-16(fp)
811455c0:	e0fffc84 	addi	r3,fp,-14
811455c4:	180d883a 	mov	r6,r3
811455c8:	100b883a 	mov	r5,r2
811455cc:	e13ff817 	ldw	r4,-32(fp)
811455d0:	113b6f00 	call	8113b6f0 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811455d4:	0005303a 	rdctl	r2,status
811455d8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811455dc:	e0fffb17 	ldw	r3,-20(fp)
811455e0:	00bfff84 	movi	r2,-2
811455e4:	1884703a 	and	r2,r3,r2
811455e8:	1001703a 	wrctl	status,r2
  
  return context;
811455ec:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
811455f0:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811455f4:	e0bffd17 	ldw	r2,-12(fp)
811455f8:	10800317 	ldw	r2,12(r2)
811455fc:	10800104 	addi	r2,r2,4
81145600:	00c00804 	movi	r3,32
81145604:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81145608:	e0bffd17 	ldw	r2,-12(fp)
8114560c:	10800317 	ldw	r2,12(r2)
81145610:	e0fffd17 	ldw	r3,-12(fp)
81145614:	18c00317 	ldw	r3,12(r3)
81145618:	18c00037 	ldwio	r3,0(r3)
8114561c:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81145620:	e0bffe17 	ldw	r2,-8(fp)
81145624:	10001f26 	beq	r2,zero,811456a4 <alt_msgdma_descriptor_sync_transfer+0x1ec>
81145628:	e0bfff17 	ldw	r2,-4(fp)
8114562c:	10001d1e 	bne	r2,zero,811456a4 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81145630:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81145634:	00001106 	br	8114567c <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81145638:	01000044 	movi	r4,1
8114563c:	1132e780 	call	81132e78 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81145640:	e0bff10b 	ldhu	r2,-60(fp)
81145644:	1084e230 	cmpltui	r2,r2,5000
81145648:	1000091e 	bne	r2,zero,81145670 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
8114564c:	01204574 	movhi	r4,33045
81145650:	2135a804 	addi	r4,r4,-10592
81145654:	11475cc0 	call	811475cc <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81145658:	e0bffd17 	ldw	r2,-12(fp)
8114565c:	10801817 	ldw	r2,96(r2)
81145660:	1009883a 	mov	r4,r2
81145664:	113ba780 	call	8113ba78 <OSSemPost>
				
                return -ETIME;
81145668:	00bff084 	movi	r2,-62
8114566c:	00008f06 	br	811458ac <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81145670:	e0bff10b 	ldhu	r2,-60(fp)
81145674:	10800044 	addi	r2,r2,1
81145678:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114567c:	e0bffd17 	ldw	r2,-12(fp)
81145680:	10c00317 	ldw	r3,12(r2)
81145684:	e0bffd17 	ldw	r2,-12(fp)
81145688:	10800417 	ldw	r2,16(r2)
8114568c:	e1bffe17 	ldw	r6,-8(fp)
81145690:	100b883a 	mov	r5,r2
81145694:	1809883a 	mov	r4,r3
81145698:	1144c2c0 	call	81144c2c <alt_msgdma_write_standard_descriptor>
8114569c:	103fe61e 	bne	r2,zero,81145638 <__reset+0xfb125638>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
811456a0:	00002706 	br	81145740 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811456a4:	e0bffe17 	ldw	r2,-8(fp)
811456a8:	10001f1e 	bne	r2,zero,81145728 <alt_msgdma_descriptor_sync_transfer+0x270>
811456ac:	e0bfff17 	ldw	r2,-4(fp)
811456b0:	10001d26 	beq	r2,zero,81145728 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
811456b4:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811456b8:	00001106 	br	81145700 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811456bc:	01000044 	movi	r4,1
811456c0:	1132e780 	call	81132e78 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811456c4:	e0bff10b 	ldhu	r2,-60(fp)
811456c8:	1084e230 	cmpltui	r2,r2,5000
811456cc:	1000091e 	bne	r2,zero,811456f4 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
811456d0:	01204574 	movhi	r4,33045
811456d4:	2135b904 	addi	r4,r4,-10524
811456d8:	11475cc0 	call	811475cc <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811456dc:	e0bffd17 	ldw	r2,-12(fp)
811456e0:	10801817 	ldw	r2,96(r2)
811456e4:	1009883a 	mov	r4,r2
811456e8:	113ba780 	call	8113ba78 <OSSemPost>
				
                return -ETIME;
811456ec:	00bff084 	movi	r2,-62
811456f0:	00006e06 	br	811458ac <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
811456f4:	e0bff10b 	ldhu	r2,-60(fp)
811456f8:	10800044 	addi	r2,r2,1
811456fc:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81145700:	e0bffd17 	ldw	r2,-12(fp)
81145704:	10c00317 	ldw	r3,12(r2)
81145708:	e0bffd17 	ldw	r2,-12(fp)
8114570c:	10800417 	ldw	r2,16(r2)
81145710:	e1bfff17 	ldw	r6,-4(fp)
81145714:	100b883a 	mov	r5,r2
81145718:	1809883a 	mov	r4,r3
8114571c:	1144cc80 	call	81144cc8 <alt_msgdma_write_extended_descriptor>
81145720:	103fe61e 	bne	r2,zero,811456bc <__reset+0xfb1256bc>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81145724:	00000606 	br	81145740 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81145728:	e0bffd17 	ldw	r2,-12(fp)
8114572c:	10801817 	ldw	r2,96(r2)
81145730:	1009883a 	mov	r4,r2
81145734:	113ba780 	call	8113ba78 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81145738:	00bfffc4 	movi	r2,-1
8114573c:	00005b06 	br	811458ac <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81145740:	e0bffd17 	ldw	r2,-12(fp)
81145744:	10800317 	ldw	r2,12(r2)
81145748:	10800104 	addi	r2,r2,4
8114574c:	e0fffd17 	ldw	r3,-12(fp)
81145750:	19000d17 	ldw	r4,52(r3)
81145754:	00fff2c4 	movi	r3,-53
81145758:	20c6703a 	and	r3,r4,r3
8114575c:	18c00114 	ori	r3,r3,4
81145760:	10c00035 	stwio	r3,0(r2)
81145764:	e0bff517 	ldw	r2,-44(fp)
81145768:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114576c:	e0bff717 	ldw	r2,-36(fp)
81145770:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81145774:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81145778:	e0bffd17 	ldw	r2,-12(fp)
8114577c:	10800317 	ldw	r2,12(r2)
81145780:	10800037 	ldwio	r2,0(r2)
81145784:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81145788:	00001506 	br	811457e0 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
8114578c:	01000044 	movi	r4,1
81145790:	1132e780 	call	81132e78 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81145794:	e0bff10b 	ldhu	r2,-60(fp)
81145798:	1084e230 	cmpltui	r2,r2,5000
8114579c:	1000091e 	bne	r2,zero,811457c4 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
811457a0:	01204574 	movhi	r4,33045
811457a4:	2135ca04 	addi	r4,r4,-10456
811457a8:	11475cc0 	call	811475cc <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
811457ac:	e0bffd17 	ldw	r2,-12(fp)
811457b0:	10801817 	ldw	r2,96(r2)
811457b4:	1009883a 	mov	r4,r2
811457b8:	113ba780 	call	8113ba78 <OSSemPost>
			
            return -ETIME;
811457bc:	00bff084 	movi	r2,-62
811457c0:	00003a06 	br	811458ac <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
811457c4:	e0bff10b 	ldhu	r2,-60(fp)
811457c8:	10800044 	addi	r2,r2,1
811457cc:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
811457d0:	e0bffd17 	ldw	r2,-12(fp)
811457d4:	10800317 	ldw	r2,12(r2)
811457d8:	10800037 	ldwio	r2,0(r2)
811457dc:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
811457e0:	e0fff017 	ldw	r3,-64(fp)
811457e4:	e0bff617 	ldw	r2,-40(fp)
811457e8:	1884703a 	and	r2,r3,r2
811457ec:	1000031e 	bne	r2,zero,811457fc <alt_msgdma_descriptor_sync_transfer+0x344>
811457f0:	e0bff017 	ldw	r2,-64(fp)
811457f4:	1080004c 	andi	r2,r2,1
811457f8:	103fe41e 	bne	r2,zero,8114578c <__reset+0xfb12578c>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
811457fc:	e0fff017 	ldw	r3,-64(fp)
81145800:	e0bff617 	ldw	r2,-40(fp)
81145804:	1884703a 	and	r2,r3,r2
81145808:	10000626 	beq	r2,zero,81145824 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8114580c:	e0bffd17 	ldw	r2,-12(fp)
81145810:	10801817 	ldw	r2,96(r2)
81145814:	1009883a 	mov	r4,r2
81145818:	113ba780 	call	8113ba78 <OSSemPost>
		
        return error;
8114581c:	e0bff617 	ldw	r2,-40(fp)
81145820:	00002206 	br	811458ac <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81145824:	e0bffd17 	ldw	r2,-12(fp)
81145828:	10800317 	ldw	r2,12(r2)
8114582c:	10800104 	addi	r2,r2,4
81145830:	10800037 	ldwio	r2,0(r2)
81145834:	10800814 	ori	r2,r2,32
81145838:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114583c:	0005303a 	rdctl	r2,status
81145840:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145844:	e0fffa17 	ldw	r3,-24(fp)
81145848:	00bfff84 	movi	r2,-2
8114584c:	1884703a 	and	r2,r3,r2
81145850:	1001703a 	wrctl	status,r2
  
  return context;
81145854:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81145858:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114585c:	e0bffd17 	ldw	r2,-12(fp)
81145860:	10800317 	ldw	r2,12(r2)
81145864:	10800104 	addi	r2,r2,4
81145868:	e0fff417 	ldw	r3,-48(fp)
8114586c:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81145870:	e0bffd17 	ldw	r2,-12(fp)
81145874:	10800317 	ldw	r2,12(r2)
81145878:	e0fffd17 	ldw	r3,-12(fp)
8114587c:	18c00317 	ldw	r3,12(r3)
81145880:	18c00037 	ldwio	r3,0(r3)
81145884:	10c00035 	stwio	r3,0(r2)
81145888:	e0bff517 	ldw	r2,-44(fp)
8114588c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145890:	e0bff917 	ldw	r2,-28(fp)
81145894:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81145898:	e0bffd17 	ldw	r2,-12(fp)
8114589c:	10801817 	ldw	r2,96(r2)
811458a0:	1009883a 	mov	r4,r2
811458a4:	113ba780 	call	8113ba78 <OSSemPost>
    
    return 0;
811458a8:	0005883a 	mov	r2,zero

}
811458ac:	e037883a 	mov	sp,fp
811458b0:	dfc00117 	ldw	ra,4(sp)
811458b4:	df000017 	ldw	fp,0(sp)
811458b8:	dec00204 	addi	sp,sp,8
811458bc:	f800283a 	ret

811458c0 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
811458c0:	defff804 	addi	sp,sp,-32
811458c4:	de00012e 	bgeu	sp,et,811458cc <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
811458c8:	003b68fa 	trap	3
811458cc:	dfc00715 	stw	ra,28(sp)
811458d0:	df000615 	stw	fp,24(sp)
811458d4:	df000604 	addi	fp,sp,24
811458d8:	e13ffc15 	stw	r4,-16(fp)
811458dc:	e17ffd15 	stw	r5,-12(fp)
811458e0:	e1bffe15 	stw	r6,-8(fp)
811458e4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
811458e8:	e0800217 	ldw	r2,8(fp)
811458ec:	d8800115 	stw	r2,4(sp)
811458f0:	e0bfff17 	ldw	r2,-4(fp)
811458f4:	d8800015 	stw	r2,0(sp)
811458f8:	e1fffe17 	ldw	r7,-8(fp)
811458fc:	000d883a 	mov	r6,zero
81145900:	e17ffd17 	ldw	r5,-12(fp)
81145904:	e13ffc17 	ldw	r4,-16(fp)
81145908:	1144f880 	call	81144f88 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114590c:	e037883a 	mov	sp,fp
81145910:	dfc00117 	ldw	ra,4(sp)
81145914:	df000017 	ldw	fp,0(sp)
81145918:	dec00204 	addi	sp,sp,8
8114591c:	f800283a 	ret

81145920 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81145920:	defff804 	addi	sp,sp,-32
81145924:	de00012e 	bgeu	sp,et,8114592c <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81145928:	003b68fa 	trap	3
8114592c:	dfc00715 	stw	ra,28(sp)
81145930:	df000615 	stw	fp,24(sp)
81145934:	df000604 	addi	fp,sp,24
81145938:	e13ffc15 	stw	r4,-16(fp)
8114593c:	e17ffd15 	stw	r5,-12(fp)
81145940:	e1bffe15 	stw	r6,-8(fp)
81145944:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81145948:	e0800217 	ldw	r2,8(fp)
8114594c:	d8800115 	stw	r2,4(sp)
81145950:	e0bfff17 	ldw	r2,-4(fp)
81145954:	d8800015 	stw	r2,0(sp)
81145958:	000f883a 	mov	r7,zero
8114595c:	e1bffe17 	ldw	r6,-8(fp)
81145960:	e17ffd17 	ldw	r5,-12(fp)
81145964:	e13ffc17 	ldw	r4,-16(fp)
81145968:	1144f880 	call	81144f88 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
8114596c:	e037883a 	mov	sp,fp
81145970:	dfc00117 	ldw	ra,4(sp)
81145974:	df000017 	ldw	fp,0(sp)
81145978:	dec00204 	addi	sp,sp,8
8114597c:	f800283a 	ret

81145980 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81145980:	defff804 	addi	sp,sp,-32
81145984:	de00012e 	bgeu	sp,et,8114598c <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81145988:	003b68fa 	trap	3
8114598c:	dfc00715 	stw	ra,28(sp)
81145990:	df000615 	stw	fp,24(sp)
81145994:	df000604 	addi	fp,sp,24
81145998:	e13ffc15 	stw	r4,-16(fp)
8114599c:	e17ffd15 	stw	r5,-12(fp)
811459a0:	e1bffe15 	stw	r6,-8(fp)
811459a4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
811459a8:	e0800317 	ldw	r2,12(fp)
811459ac:	d8800115 	stw	r2,4(sp)
811459b0:	e0800217 	ldw	r2,8(fp)
811459b4:	d8800015 	stw	r2,0(sp)
811459b8:	e1ffff17 	ldw	r7,-4(fp)
811459bc:	e1bffe17 	ldw	r6,-8(fp)
811459c0:	e17ffd17 	ldw	r5,-12(fp)
811459c4:	e13ffc17 	ldw	r4,-16(fp)
811459c8:	1144f880 	call	81144f88 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
811459cc:	e037883a 	mov	sp,fp
811459d0:	dfc00117 	ldw	ra,4(sp)
811459d4:	df000017 	ldw	fp,0(sp)
811459d8:	dec00204 	addi	sp,sp,8
811459dc:	f800283a 	ret

811459e0 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
811459e0:	defff004 	addi	sp,sp,-64
811459e4:	de00012e 	bgeu	sp,et,811459ec <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
811459e8:	003b68fa 	trap	3
811459ec:	dfc00f15 	stw	ra,60(sp)
811459f0:	df000e15 	stw	fp,56(sp)
811459f4:	df000e04 	addi	fp,sp,56
811459f8:	e13ff915 	stw	r4,-28(fp)
811459fc:	e17ffa15 	stw	r5,-24(fp)
81145a00:	e1bffb15 	stw	r6,-20(fp)
81145a04:	e1fffc15 	stw	r7,-16(fp)
81145a08:	e1000317 	ldw	r4,12(fp)
81145a0c:	e0c00417 	ldw	r3,16(fp)
81145a10:	e0800517 	ldw	r2,20(fp)
81145a14:	e13ffd0d 	sth	r4,-12(fp)
81145a18:	e0fffe05 	stb	r3,-8(fp)
81145a1c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81145a20:	e0bffd0b 	ldhu	r2,-12(fp)
81145a24:	e0fffe03 	ldbu	r3,-8(fp)
81145a28:	e13fff0b 	ldhu	r4,-4(fp)
81145a2c:	d9000615 	stw	r4,24(sp)
81145a30:	d8000515 	stw	zero,20(sp)
81145a34:	d8c00415 	stw	r3,16(sp)
81145a38:	d8000315 	stw	zero,12(sp)
81145a3c:	d8800215 	stw	r2,8(sp)
81145a40:	e0800217 	ldw	r2,8(fp)
81145a44:	d8800115 	stw	r2,4(sp)
81145a48:	e0bffc17 	ldw	r2,-16(fp)
81145a4c:	d8800015 	stw	r2,0(sp)
81145a50:	e1fffb17 	ldw	r7,-20(fp)
81145a54:	000d883a 	mov	r6,zero
81145a58:	e17ffa17 	ldw	r5,-24(fp)
81145a5c:	e13ff917 	ldw	r4,-28(fp)
81145a60:	114501c0 	call	8114501c <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81145a64:	e037883a 	mov	sp,fp
81145a68:	dfc00117 	ldw	ra,4(sp)
81145a6c:	df000017 	ldw	fp,0(sp)
81145a70:	dec00204 	addi	sp,sp,8
81145a74:	f800283a 	ret

81145a78 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81145a78:	defff004 	addi	sp,sp,-64
81145a7c:	de00012e 	bgeu	sp,et,81145a84 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81145a80:	003b68fa 	trap	3
81145a84:	dfc00f15 	stw	ra,60(sp)
81145a88:	df000e15 	stw	fp,56(sp)
81145a8c:	df000e04 	addi	fp,sp,56
81145a90:	e13ff915 	stw	r4,-28(fp)
81145a94:	e17ffa15 	stw	r5,-24(fp)
81145a98:	e1bffb15 	stw	r6,-20(fp)
81145a9c:	e1fffc15 	stw	r7,-16(fp)
81145aa0:	e1000317 	ldw	r4,12(fp)
81145aa4:	e0c00417 	ldw	r3,16(fp)
81145aa8:	e0800517 	ldw	r2,20(fp)
81145aac:	e13ffd0d 	sth	r4,-12(fp)
81145ab0:	e0fffe05 	stb	r3,-8(fp)
81145ab4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81145ab8:	e0bffd0b 	ldhu	r2,-12(fp)
81145abc:	e0fffe03 	ldbu	r3,-8(fp)
81145ac0:	e13fff0b 	ldhu	r4,-4(fp)
81145ac4:	d8000615 	stw	zero,24(sp)
81145ac8:	d9000515 	stw	r4,20(sp)
81145acc:	d8000415 	stw	zero,16(sp)
81145ad0:	d8c00315 	stw	r3,12(sp)
81145ad4:	d8800215 	stw	r2,8(sp)
81145ad8:	e0800217 	ldw	r2,8(fp)
81145adc:	d8800115 	stw	r2,4(sp)
81145ae0:	e0bffc17 	ldw	r2,-16(fp)
81145ae4:	d8800015 	stw	r2,0(sp)
81145ae8:	000f883a 	mov	r7,zero
81145aec:	e1bffb17 	ldw	r6,-20(fp)
81145af0:	e17ffa17 	ldw	r5,-24(fp)
81145af4:	e13ff917 	ldw	r4,-28(fp)
81145af8:	114501c0 	call	8114501c <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81145afc:	e037883a 	mov	sp,fp
81145b00:	dfc00117 	ldw	ra,4(sp)
81145b04:	df000017 	ldw	fp,0(sp)
81145b08:	dec00204 	addi	sp,sp,8
81145b0c:	f800283a 	ret

81145b10 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81145b10:	deffee04 	addi	sp,sp,-72
81145b14:	de00012e 	bgeu	sp,et,81145b1c <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81145b18:	003b68fa 	trap	3
81145b1c:	dfc01115 	stw	ra,68(sp)
81145b20:	df001015 	stw	fp,64(sp)
81145b24:	df001004 	addi	fp,sp,64
81145b28:	e13ff715 	stw	r4,-36(fp)
81145b2c:	e17ff815 	stw	r5,-32(fp)
81145b30:	e1bff915 	stw	r6,-28(fp)
81145b34:	e1fffa15 	stw	r7,-24(fp)
81145b38:	e1800417 	ldw	r6,16(fp)
81145b3c:	e1400517 	ldw	r5,20(fp)
81145b40:	e1000617 	ldw	r4,24(fp)
81145b44:	e0c00717 	ldw	r3,28(fp)
81145b48:	e0800817 	ldw	r2,32(fp)
81145b4c:	e1bffb0d 	sth	r6,-20(fp)
81145b50:	e17ffc05 	stb	r5,-16(fp)
81145b54:	e13ffd05 	stb	r4,-12(fp)
81145b58:	e0fffe0d 	sth	r3,-8(fp)
81145b5c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81145b60:	e0bffb0b 	ldhu	r2,-20(fp)
81145b64:	e0fffc03 	ldbu	r3,-16(fp)
81145b68:	e13ffd03 	ldbu	r4,-12(fp)
81145b6c:	e17ffe0b 	ldhu	r5,-8(fp)
81145b70:	e1bfff0b 	ldhu	r6,-4(fp)
81145b74:	d9800615 	stw	r6,24(sp)
81145b78:	d9400515 	stw	r5,20(sp)
81145b7c:	d9000415 	stw	r4,16(sp)
81145b80:	d8c00315 	stw	r3,12(sp)
81145b84:	d8800215 	stw	r2,8(sp)
81145b88:	e0800317 	ldw	r2,12(fp)
81145b8c:	d8800115 	stw	r2,4(sp)
81145b90:	e0800217 	ldw	r2,8(fp)
81145b94:	d8800015 	stw	r2,0(sp)
81145b98:	e1fffa17 	ldw	r7,-24(fp)
81145b9c:	e1bff917 	ldw	r6,-28(fp)
81145ba0:	e17ff817 	ldw	r5,-32(fp)
81145ba4:	e13ff717 	ldw	r4,-36(fp)
81145ba8:	114501c0 	call	8114501c <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81145bac:	e037883a 	mov	sp,fp
81145bb0:	dfc00117 	ldw	ra,4(sp)
81145bb4:	df000017 	ldw	fp,0(sp)
81145bb8:	dec00204 	addi	sp,sp,8
81145bbc:	f800283a 	ret

81145bc0 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81145bc0:	defffb04 	addi	sp,sp,-20
81145bc4:	de00012e 	bgeu	sp,et,81145bcc <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81145bc8:	003b68fa 	trap	3
81145bcc:	df000415 	stw	fp,16(sp)
81145bd0:	df000404 	addi	fp,sp,16
81145bd4:	e13ffc15 	stw	r4,-16(fp)
81145bd8:	e17ffd15 	stw	r5,-12(fp)
81145bdc:	e1bffe15 	stw	r6,-8(fp)
81145be0:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81145be4:	e0bffc17 	ldw	r2,-16(fp)
81145be8:	10c01217 	ldw	r3,72(r2)
81145bec:	e0800117 	ldw	r2,4(fp)
81145bf0:	18800436 	bltu	r3,r2,81145c04 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
81145bf4:	e0bffc17 	ldw	r2,-16(fp)
81145bf8:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81145bfc:	10803fcc 	andi	r2,r2,255
81145c00:	10000226 	beq	r2,zero,81145c0c <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81145c04:	00bffa84 	movi	r2,-22
81145c08:	00001406 	br	81145c5c <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81145c0c:	e0bffd17 	ldw	r2,-12(fp)
81145c10:	e0fffe17 	ldw	r3,-8(fp)
81145c14:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81145c18:	e0bffd17 	ldw	r2,-12(fp)
81145c1c:	e0ffff17 	ldw	r3,-4(fp)
81145c20:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81145c24:	e0bffd17 	ldw	r2,-12(fp)
81145c28:	e0c00117 	ldw	r3,4(fp)
81145c2c:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81145c30:	e0fffd17 	ldw	r3,-12(fp)
81145c34:	e0bffd17 	ldw	r2,-12(fp)
81145c38:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81145c3c:	e0c00217 	ldw	r3,8(fp)
81145c40:	00900034 	movhi	r2,16384
81145c44:	10bfffc4 	addi	r2,r2,-1
81145c48:	1884703a 	and	r2,r3,r2
81145c4c:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81145c50:	e0bffd17 	ldw	r2,-12(fp)
81145c54:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81145c58:	0005883a 	mov	r2,zero
}
81145c5c:	e037883a 	mov	sp,fp
81145c60:	df000017 	ldw	fp,0(sp)
81145c64:	dec00104 	addi	sp,sp,4
81145c68:	f800283a 	ret

81145c6c <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81145c6c:	defff404 	addi	sp,sp,-48
81145c70:	de00012e 	bgeu	sp,et,81145c78 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81145c74:	003b68fa 	trap	3
81145c78:	df000b15 	stw	fp,44(sp)
81145c7c:	df000b04 	addi	fp,sp,44
81145c80:	e13ff715 	stw	r4,-36(fp)
81145c84:	e17ff815 	stw	r5,-32(fp)
81145c88:	e1bff915 	stw	r6,-28(fp)
81145c8c:	e1fffa15 	stw	r7,-24(fp)
81145c90:	e1800517 	ldw	r6,20(fp)
81145c94:	e1400617 	ldw	r5,24(fp)
81145c98:	e1000717 	ldw	r4,28(fp)
81145c9c:	e0c00817 	ldw	r3,32(fp)
81145ca0:	e0800917 	ldw	r2,36(fp)
81145ca4:	e1bffb0d 	sth	r6,-20(fp)
81145ca8:	e17ffc05 	stb	r5,-16(fp)
81145cac:	e13ffd05 	stb	r4,-12(fp)
81145cb0:	e0fffe0d 	sth	r3,-8(fp)
81145cb4:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81145cb8:	e0bff717 	ldw	r2,-36(fp)
81145cbc:	10c01217 	ldw	r3,72(r2)
81145cc0:	e0800317 	ldw	r2,12(fp)
81145cc4:	18801936 	bltu	r3,r2,81145d2c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81145cc8:	e13ff717 	ldw	r4,-36(fp)
81145ccc:	20801317 	ldw	r2,76(r4)
81145cd0:	20c01417 	ldw	r3,80(r4)
81145cd4:	e13ffe0b 	ldhu	r4,-8(fp)
81145cd8:	213fffcc 	andi	r4,r4,65535
81145cdc:	2015883a 	mov	r10,r4
81145ce0:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81145ce4:	1ac01136 	bltu	r3,r11,81145d2c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81145ce8:	58c0011e 	bne	r11,r3,81145cf0 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81145cec:	12800f36 	bltu	r2,r10,81145d2c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81145cf0:	e13ff717 	ldw	r4,-36(fp)
81145cf4:	20801317 	ldw	r2,76(r4)
81145cf8:	20c01417 	ldw	r3,80(r4)
81145cfc:	e13fff0b 	ldhu	r4,-4(fp)
81145d00:	213fffcc 	andi	r4,r4,65535
81145d04:	2011883a 	mov	r8,r4
81145d08:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81145d0c:	1a400736 	bltu	r3,r9,81145d2c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81145d10:	48c0011e 	bne	r9,r3,81145d18 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
81145d14:	12000536 	bltu	r2,r8,81145d2c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81145d18:	e0bff717 	ldw	r2,-36(fp)
81145d1c:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81145d20:	10803fcc 	andi	r2,r2,255
81145d24:	10800060 	cmpeqi	r2,r2,1
81145d28:	1000021e 	bne	r2,zero,81145d34 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81145d2c:	00bffa84 	movi	r2,-22
81145d30:	00003106 	br	81145df8 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
81145d34:	e0bff817 	ldw	r2,-32(fp)
81145d38:	e0fff917 	ldw	r3,-28(fp)
81145d3c:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81145d40:	e0bff817 	ldw	r2,-32(fp)
81145d44:	e0fffa17 	ldw	r3,-24(fp)
81145d48:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81145d4c:	e0bff817 	ldw	r2,-32(fp)
81145d50:	e0c00117 	ldw	r3,4(fp)
81145d54:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81145d58:	e0bff817 	ldw	r2,-32(fp)
81145d5c:	e0c00217 	ldw	r3,8(fp)
81145d60:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81145d64:	e0bff817 	ldw	r2,-32(fp)
81145d68:	e0c00317 	ldw	r3,12(fp)
81145d6c:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81145d70:	e0bff817 	ldw	r2,-32(fp)
81145d74:	e0fffb0b 	ldhu	r3,-20(fp)
81145d78:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81145d7c:	e0bff817 	ldw	r2,-32(fp)
81145d80:	e0fffc03 	ldbu	r3,-16(fp)
81145d84:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
81145d88:	e0bff817 	ldw	r2,-32(fp)
81145d8c:	e0fffd03 	ldbu	r3,-12(fp)
81145d90:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
81145d94:	e0bff817 	ldw	r2,-32(fp)
81145d98:	e0fffe0b 	ldhu	r3,-8(fp)
81145d9c:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
81145da0:	e0bff817 	ldw	r2,-32(fp)
81145da4:	e0ffff0b 	ldhu	r3,-4(fp)
81145da8:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
81145dac:	e0bff817 	ldw	r2,-32(fp)
81145db0:	1019883a 	mov	r12,r2
81145db4:	001b883a 	mov	r13,zero
81145db8:	e33ff515 	stw	r12,-44(fp)
81145dbc:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
81145dc0:	e0fff517 	ldw	r3,-44(fp)
81145dc4:	e0bff817 	ldw	r2,-32(fp)
81145dc8:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
81145dcc:	e0fff617 	ldw	r3,-40(fp)
81145dd0:	e0bff817 	ldw	r2,-32(fp)
81145dd4:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81145dd8:	e0c00417 	ldw	r3,16(fp)
81145ddc:	00900034 	movhi	r2,16384
81145de0:	10bfffc4 	addi	r2,r2,-1
81145de4:	1884703a 	and	r2,r3,r2
81145de8:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
81145dec:	e0bff817 	ldw	r2,-32(fp)
81145df0:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
81145df4:	0005883a 	mov	r2,zero
}
81145df8:	e037883a 	mov	sp,fp
81145dfc:	df000017 	ldw	fp,0(sp)
81145e00:	dec00104 	addi	sp,sp,4
81145e04:	f800283a 	ret

81145e08 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
81145e08:	defff804 	addi	sp,sp,-32
81145e0c:	de00012e 	bgeu	sp,et,81145e14 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81145e10:	003b68fa 	trap	3
81145e14:	dfc00715 	stw	ra,28(sp)
81145e18:	df000615 	stw	fp,24(sp)
81145e1c:	df000604 	addi	fp,sp,24
81145e20:	e13ffc15 	stw	r4,-16(fp)
81145e24:	e17ffd15 	stw	r5,-12(fp)
81145e28:	e1bffe15 	stw	r6,-8(fp)
81145e2c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81145e30:	e0800317 	ldw	r2,12(fp)
81145e34:	d8800115 	stw	r2,4(sp)
81145e38:	e0800217 	ldw	r2,8(fp)
81145e3c:	d8800015 	stw	r2,0(sp)
81145e40:	e1ffff17 	ldw	r7,-4(fp)
81145e44:	e1bffe17 	ldw	r6,-8(fp)
81145e48:	e17ffd17 	ldw	r5,-12(fp)
81145e4c:	e13ffc17 	ldw	r4,-16(fp)
81145e50:	1145bc00 	call	81145bc0 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81145e54:	e037883a 	mov	sp,fp
81145e58:	dfc00117 	ldw	ra,4(sp)
81145e5c:	df000017 	ldw	fp,0(sp)
81145e60:	dec00204 	addi	sp,sp,8
81145e64:	f800283a 	ret

81145e68 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81145e68:	defff804 	addi	sp,sp,-32
81145e6c:	de00012e 	bgeu	sp,et,81145e74 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81145e70:	003b68fa 	trap	3
81145e74:	dfc00715 	stw	ra,28(sp)
81145e78:	df000615 	stw	fp,24(sp)
81145e7c:	df000604 	addi	fp,sp,24
81145e80:	e13ffc15 	stw	r4,-16(fp)
81145e84:	e17ffd15 	stw	r5,-12(fp)
81145e88:	e1bffe15 	stw	r6,-8(fp)
81145e8c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81145e90:	e0800217 	ldw	r2,8(fp)
81145e94:	d8800115 	stw	r2,4(sp)
81145e98:	e0bfff17 	ldw	r2,-4(fp)
81145e9c:	d8800015 	stw	r2,0(sp)
81145ea0:	e1fffe17 	ldw	r7,-8(fp)
81145ea4:	000d883a 	mov	r6,zero
81145ea8:	e17ffd17 	ldw	r5,-12(fp)
81145eac:	e13ffc17 	ldw	r4,-16(fp)
81145eb0:	1145bc00 	call	81145bc0 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
81145eb4:	e037883a 	mov	sp,fp
81145eb8:	dfc00117 	ldw	ra,4(sp)
81145ebc:	df000017 	ldw	fp,0(sp)
81145ec0:	dec00204 	addi	sp,sp,8
81145ec4:	f800283a 	ret

81145ec8 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
81145ec8:	defff804 	addi	sp,sp,-32
81145ecc:	de00012e 	bgeu	sp,et,81145ed4 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
81145ed0:	003b68fa 	trap	3
81145ed4:	dfc00715 	stw	ra,28(sp)
81145ed8:	df000615 	stw	fp,24(sp)
81145edc:	df000604 	addi	fp,sp,24
81145ee0:	e13ffc15 	stw	r4,-16(fp)
81145ee4:	e17ffd15 	stw	r5,-12(fp)
81145ee8:	e1bffe15 	stw	r6,-8(fp)
81145eec:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81145ef0:	e0800217 	ldw	r2,8(fp)
81145ef4:	d8800115 	stw	r2,4(sp)
81145ef8:	e0bfff17 	ldw	r2,-4(fp)
81145efc:	d8800015 	stw	r2,0(sp)
81145f00:	000f883a 	mov	r7,zero
81145f04:	e1bffe17 	ldw	r6,-8(fp)
81145f08:	e17ffd17 	ldw	r5,-12(fp)
81145f0c:	e13ffc17 	ldw	r4,-16(fp)
81145f10:	1145bc00 	call	81145bc0 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
81145f14:	e037883a 	mov	sp,fp
81145f18:	dfc00117 	ldw	ra,4(sp)
81145f1c:	df000017 	ldw	fp,0(sp)
81145f20:	dec00204 	addi	sp,sp,8
81145f24:	f800283a 	ret

81145f28 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
81145f28:	deffee04 	addi	sp,sp,-72
81145f2c:	de00012e 	bgeu	sp,et,81145f34 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81145f30:	003b68fa 	trap	3
81145f34:	dfc01115 	stw	ra,68(sp)
81145f38:	df001015 	stw	fp,64(sp)
81145f3c:	df001004 	addi	fp,sp,64
81145f40:	e13ff915 	stw	r4,-28(fp)
81145f44:	e17ffa15 	stw	r5,-24(fp)
81145f48:	e1bffb15 	stw	r6,-20(fp)
81145f4c:	e1fffc15 	stw	r7,-16(fp)
81145f50:	e1000417 	ldw	r4,16(fp)
81145f54:	e0c00517 	ldw	r3,20(fp)
81145f58:	e0800617 	ldw	r2,24(fp)
81145f5c:	e13ffd0d 	sth	r4,-12(fp)
81145f60:	e0fffe05 	stb	r3,-8(fp)
81145f64:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
81145f68:	e0bffd0b 	ldhu	r2,-12(fp)
81145f6c:	e0fffe03 	ldbu	r3,-8(fp)
81145f70:	e13fff0b 	ldhu	r4,-4(fp)
81145f74:	d9000815 	stw	r4,32(sp)
81145f78:	d8000715 	stw	zero,28(sp)
81145f7c:	d8c00615 	stw	r3,24(sp)
81145f80:	d8000515 	stw	zero,20(sp)
81145f84:	d8800415 	stw	r2,16(sp)
81145f88:	e0800317 	ldw	r2,12(fp)
81145f8c:	d8800315 	stw	r2,12(sp)
81145f90:	e0800217 	ldw	r2,8(fp)
81145f94:	d8800215 	stw	r2,8(sp)
81145f98:	e0bffc17 	ldw	r2,-16(fp)
81145f9c:	d8800115 	stw	r2,4(sp)
81145fa0:	e0bffb17 	ldw	r2,-20(fp)
81145fa4:	d8800015 	stw	r2,0(sp)
81145fa8:	000f883a 	mov	r7,zero
81145fac:	000d883a 	mov	r6,zero
81145fb0:	e17ffa17 	ldw	r5,-24(fp)
81145fb4:	e13ff917 	ldw	r4,-28(fp)
81145fb8:	1145c6c0 	call	81145c6c <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
81145fbc:	e037883a 	mov	sp,fp
81145fc0:	dfc00117 	ldw	ra,4(sp)
81145fc4:	df000017 	ldw	fp,0(sp)
81145fc8:	dec00204 	addi	sp,sp,8
81145fcc:	f800283a 	ret

81145fd0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81145fd0:	deffee04 	addi	sp,sp,-72
81145fd4:	de00012e 	bgeu	sp,et,81145fdc <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81145fd8:	003b68fa 	trap	3
81145fdc:	dfc01115 	stw	ra,68(sp)
81145fe0:	df001015 	stw	fp,64(sp)
81145fe4:	df001004 	addi	fp,sp,64
81145fe8:	e13ff915 	stw	r4,-28(fp)
81145fec:	e17ffa15 	stw	r5,-24(fp)
81145ff0:	e1bffb15 	stw	r6,-20(fp)
81145ff4:	e1fffc15 	stw	r7,-16(fp)
81145ff8:	e1000417 	ldw	r4,16(fp)
81145ffc:	e0c00517 	ldw	r3,20(fp)
81146000:	e0800617 	ldw	r2,24(fp)
81146004:	e13ffd0d 	sth	r4,-12(fp)
81146008:	e0fffe05 	stb	r3,-8(fp)
8114600c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81146010:	e0bffd0b 	ldhu	r2,-12(fp)
81146014:	e0fffe03 	ldbu	r3,-8(fp)
81146018:	e13fff0b 	ldhu	r4,-4(fp)
8114601c:	d8000815 	stw	zero,32(sp)
81146020:	d9000715 	stw	r4,28(sp)
81146024:	d8000615 	stw	zero,24(sp)
81146028:	d8c00515 	stw	r3,20(sp)
8114602c:	d8800415 	stw	r2,16(sp)
81146030:	e0800317 	ldw	r2,12(fp)
81146034:	d8800315 	stw	r2,12(sp)
81146038:	e0800217 	ldw	r2,8(fp)
8114603c:	d8800215 	stw	r2,8(sp)
81146040:	d8000115 	stw	zero,4(sp)
81146044:	d8000015 	stw	zero,0(sp)
81146048:	e1fffc17 	ldw	r7,-16(fp)
8114604c:	e1bffb17 	ldw	r6,-20(fp)
81146050:	e17ffa17 	ldw	r5,-24(fp)
81146054:	e13ff917 	ldw	r4,-28(fp)
81146058:	1145c6c0 	call	81145c6c <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
8114605c:	e037883a 	mov	sp,fp
81146060:	dfc00117 	ldw	ra,4(sp)
81146064:	df000017 	ldw	fp,0(sp)
81146068:	dec00204 	addi	sp,sp,8
8114606c:	f800283a 	ret

81146070 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81146070:	deffec04 	addi	sp,sp,-80
81146074:	de00012e 	bgeu	sp,et,8114607c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
81146078:	003b68fa 	trap	3
8114607c:	dfc01315 	stw	ra,76(sp)
81146080:	df001215 	stw	fp,72(sp)
81146084:	df001204 	addi	fp,sp,72
81146088:	e13ff715 	stw	r4,-36(fp)
8114608c:	e17ff815 	stw	r5,-32(fp)
81146090:	e1bff915 	stw	r6,-28(fp)
81146094:	e1fffa15 	stw	r7,-24(fp)
81146098:	e1800617 	ldw	r6,24(fp)
8114609c:	e1400717 	ldw	r5,28(fp)
811460a0:	e1000817 	ldw	r4,32(fp)
811460a4:	e0c00917 	ldw	r3,36(fp)
811460a8:	e0800a17 	ldw	r2,40(fp)
811460ac:	e1bffb0d 	sth	r6,-20(fp)
811460b0:	e17ffc05 	stb	r5,-16(fp)
811460b4:	e13ffd05 	stb	r4,-12(fp)
811460b8:	e0fffe0d 	sth	r3,-8(fp)
811460bc:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
811460c0:	e0bffb0b 	ldhu	r2,-20(fp)
811460c4:	e0fffc03 	ldbu	r3,-16(fp)
811460c8:	e13ffd03 	ldbu	r4,-12(fp)
811460cc:	e17ffe0b 	ldhu	r5,-8(fp)
811460d0:	e1bfff0b 	ldhu	r6,-4(fp)
811460d4:	d9800815 	stw	r6,32(sp)
811460d8:	d9400715 	stw	r5,28(sp)
811460dc:	d9000615 	stw	r4,24(sp)
811460e0:	d8c00515 	stw	r3,20(sp)
811460e4:	d8800415 	stw	r2,16(sp)
811460e8:	e0800517 	ldw	r2,20(fp)
811460ec:	d8800315 	stw	r2,12(sp)
811460f0:	e0800417 	ldw	r2,16(fp)
811460f4:	d8800215 	stw	r2,8(sp)
811460f8:	e0800317 	ldw	r2,12(fp)
811460fc:	d8800115 	stw	r2,4(sp)
81146100:	e0800217 	ldw	r2,8(fp)
81146104:	d8800015 	stw	r2,0(sp)
81146108:	e1fffa17 	ldw	r7,-24(fp)
8114610c:	e1bff917 	ldw	r6,-28(fp)
81146110:	e17ff817 	ldw	r5,-32(fp)
81146114:	e13ff717 	ldw	r4,-36(fp)
81146118:	1145c6c0 	call	81145c6c <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
8114611c:	e037883a 	mov	sp,fp
81146120:	dfc00117 	ldw	ra,4(sp)
81146124:	df000017 	ldw	fp,0(sp)
81146128:	dec00204 	addi	sp,sp,8
8114612c:	f800283a 	ret

81146130 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81146130:	defffc04 	addi	sp,sp,-16
81146134:	de00012e 	bgeu	sp,et,8114613c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
81146138:	003b68fa 	trap	3
8114613c:	df000315 	stw	fp,12(sp)
81146140:	df000304 	addi	fp,sp,12
81146144:	e13ffe15 	stw	r4,-8(fp)
81146148:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
8114614c:	e0bfff17 	ldw	r2,-4(fp)
81146150:	1000021e 	bne	r2,zero,8114615c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81146154:	00bffa84 	movi	r2,-22
81146158:	00002f06 	br	81146218 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
8114615c:	e0bfff17 	ldw	r2,-4(fp)
81146160:	10c00317 	ldw	r3,12(r2)
81146164:	e0bfff17 	ldw	r2,-4(fp)
81146168:	18800226 	beq	r3,r2,81146174 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114616c:	00bffa84 	movi	r2,-22
81146170:	00002906 	br	81146218 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81146174:	e0bffe17 	ldw	r2,-8(fp)
81146178:	10800017 	ldw	r2,0(r2)
8114617c:	1000051e 	bne	r2,zero,81146194 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81146180:	e0bffe17 	ldw	r2,-8(fp)
81146184:	e0ffff17 	ldw	r3,-4(fp)
81146188:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
8114618c:	0005883a 	mov	r2,zero
81146190:	00002106 	br	81146218 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
81146194:	e0bffe17 	ldw	r2,-8(fp)
81146198:	10c00017 	ldw	r3,0(r2)
8114619c:	e0bfff17 	ldw	r2,-4(fp)
811461a0:	1880021e 	bne	r3,r2,811461ac <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811461a4:	00bffa84 	movi	r2,-22
811461a8:	00001b06 	br	81146218 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811461ac:	e0bffe17 	ldw	r2,-8(fp)
811461b0:	10800017 	ldw	r2,0(r2)
811461b4:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
811461b8:	00000906 	br	811461e0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
811461bc:	e0bffd17 	ldw	r2,-12(fp)
811461c0:	10c00317 	ldw	r3,12(r2)
811461c4:	e0bfff17 	ldw	r2,-4(fp)
811461c8:	1880021e 	bne	r3,r2,811461d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811461cc:	00bffa84 	movi	r2,-22
811461d0:	00001106 	br	81146218 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811461d4:	e0bffd17 	ldw	r2,-12(fp)
811461d8:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
811461dc:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
811461e0:	e0bffd17 	ldw	r2,-12(fp)
811461e4:	10800317 	ldw	r2,12(r2)
811461e8:	e0fffe17 	ldw	r3,-8(fp)
811461ec:	18c00017 	ldw	r3,0(r3)
811461f0:	10fff21e 	bne	r2,r3,811461bc <__reset+0xfb1261bc>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
811461f4:	e0ffff17 	ldw	r3,-4(fp)
811461f8:	e0bffd17 	ldw	r2,-12(fp)
811461fc:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81146200:	e0bffe17 	ldw	r2,-8(fp)
81146204:	10800017 	ldw	r2,0(r2)
81146208:	1007883a 	mov	r3,r2
8114620c:	e0bfff17 	ldw	r2,-4(fp)
81146210:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
81146214:	0005883a 	mov	r2,zero
}
81146218:	e037883a 	mov	sp,fp
8114621c:	df000017 	ldw	fp,0(sp)
81146220:	dec00104 	addi	sp,sp,4
81146224:	f800283a 	ret

81146228 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
81146228:	defff804 	addi	sp,sp,-32
8114622c:	de00012e 	bgeu	sp,et,81146234 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81146230:	003b68fa 	trap	3
81146234:	df000715 	stw	fp,28(sp)
81146238:	df000704 	addi	fp,sp,28
8114623c:	e13ffe15 	stw	r4,-8(fp)
81146240:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
81146244:	e13fff17 	ldw	r4,-4(fp)
81146248:	2000021e 	bne	r4,zero,81146254 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114624c:	00bffa84 	movi	r2,-22
81146250:	00005906 	br	811463b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
81146254:	e13fff17 	ldw	r4,-4(fp)
81146258:	2015883a 	mov	r10,r4
8114625c:	0017883a 	mov	r11,zero
81146260:	e2bffc15 	stw	r10,-16(fp)
81146264:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81146268:	e13fff17 	ldw	r4,-4(fp)
8114626c:	21400317 	ldw	r5,12(r4)
81146270:	e13ffc17 	ldw	r4,-16(fp)
81146274:	29000626 	beq	r5,r4,81146290 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
81146278:	e13fff17 	ldw	r4,-4(fp)
8114627c:	21400b17 	ldw	r5,44(r4)
81146280:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81146284:	29000226 	beq	r5,r4,81146290 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81146288:	00bffa84 	movi	r2,-22
8114628c:	00004a06 	br	811463b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81146290:	e13ffe17 	ldw	r4,-8(fp)
81146294:	21000017 	ldw	r4,0(r4)
81146298:	2000051e 	bne	r4,zero,811462b0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8114629c:	e0bffe17 	ldw	r2,-8(fp)
811462a0:	e0ffff17 	ldw	r3,-4(fp)
811462a4:	10c00015 	stw	r3,0(r2)
		return 0;
811462a8:	0005883a 	mov	r2,zero
811462ac:	00004206 	br	811463b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
811462b0:	e13ffe17 	ldw	r4,-8(fp)
811462b4:	21400017 	ldw	r5,0(r4)
811462b8:	e13fff17 	ldw	r4,-4(fp)
811462bc:	2900021e 	bne	r5,r4,811462c8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811462c0:	00bffa84 	movi	r2,-22
811462c4:	00003c06 	br	811463b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811462c8:	e13ffe17 	ldw	r4,-8(fp)
811462cc:	21000017 	ldw	r4,0(r4)
811462d0:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
811462d4:	e13ffe17 	ldw	r4,-8(fp)
811462d8:	21000017 	ldw	r4,0(r4)
811462dc:	2011883a 	mov	r8,r4
811462e0:	0013883a 	mov	r9,zero
811462e4:	e23ffa15 	stw	r8,-24(fp)
811462e8:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811462ec:	00001806 	br	81146350 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
811462f0:	e13fff17 	ldw	r4,-4(fp)
811462f4:	200d883a 	mov	r6,r4
811462f8:	000f883a 	mov	r7,zero
811462fc:	e1bffc15 	stw	r6,-16(fp)
81146300:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
81146304:	e13ff917 	ldw	r4,-28(fp)
81146308:	21400317 	ldw	r5,12(r4)
8114630c:	e13ffc17 	ldw	r4,-16(fp)
81146310:	2900061e 	bne	r5,r4,8114632c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
81146314:	e13ff917 	ldw	r4,-28(fp)
81146318:	21400b17 	ldw	r5,44(r4)
8114631c:	e13ffd17 	ldw	r4,-12(fp)
81146320:	2900021e 	bne	r5,r4,8114632c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81146324:	00bffa84 	movi	r2,-22
81146328:	00002306 	br	811463b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114632c:	e13ff917 	ldw	r4,-28(fp)
81146330:	21000317 	ldw	r4,12(r4)
81146334:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81146338:	e13ff917 	ldw	r4,-28(fp)
8114633c:	21000b17 	ldw	r4,44(r4)
81146340:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81146344:	e13ffc17 	ldw	r4,-16(fp)
81146348:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114634c:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81146350:	e13ff917 	ldw	r4,-28(fp)
81146354:	21400317 	ldw	r5,12(r4)
81146358:	e13ffa17 	ldw	r4,-24(fp)
8114635c:	29000426 	beq	r5,r4,81146370 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81146360:	e13ff917 	ldw	r4,-28(fp)
81146364:	21400b17 	ldw	r5,44(r4)
81146368:	e13ffb17 	ldw	r4,-20(fp)
8114636c:	293fe01e 	bne	r5,r4,811462f0 <__reset+0xfb1262f0>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81146370:	e13fff17 	ldw	r4,-4(fp)
81146374:	2005883a 	mov	r2,r4
81146378:	0007883a 	mov	r3,zero
8114637c:	e0bffc15 	stw	r2,-16(fp)
81146380:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
81146384:	e0fffc17 	ldw	r3,-16(fp)
81146388:	e0bff917 	ldw	r2,-28(fp)
8114638c:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81146390:	e0fffd17 	ldw	r3,-12(fp)
81146394:	e0bff917 	ldw	r2,-28(fp)
81146398:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8114639c:	e0fffa17 	ldw	r3,-24(fp)
811463a0:	e0bfff17 	ldw	r2,-4(fp)
811463a4:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
811463a8:	e0fffb17 	ldw	r3,-20(fp)
811463ac:	e0bfff17 	ldw	r2,-4(fp)
811463b0:	10c00b15 	stw	r3,44(r2)
	return 0;
811463b4:	0005883a 	mov	r2,zero
}
811463b8:	e037883a 	mov	sp,fp
811463bc:	df000017 	ldw	fp,0(sp)
811463c0:	dec00104 	addi	sp,sp,4
811463c4:	f800283a 	ret

811463c8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
811463c8:	defffc04 	addi	sp,sp,-16
811463cc:	de00012e 	bgeu	sp,et,811463d4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
811463d0:	003b68fa 	trap	3
811463d4:	df000315 	stw	fp,12(sp)
811463d8:	df000304 	addi	fp,sp,12
811463dc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
811463e0:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
811463e4:	e0bfff17 	ldw	r2,-4(fp)
811463e8:	1000021e 	bne	r2,zero,811463f4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
811463ec:	00bffa84 	movi	r2,-22
811463f0:	00001906 	br	81146458 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
811463f4:	e0bfff17 	ldw	r2,-4(fp)
811463f8:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811463fc:	00000a06 	br	81146428 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
81146400:	e0bffd17 	ldw	r2,-12(fp)
81146404:	10800717 	ldw	r2,28(r2)
81146408:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114640c:	e0bffe17 	ldw	r2,-8(fp)
81146410:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81146414:	e0bffd17 	ldw	r2,-12(fp)
81146418:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114641c:	e0bffd17 	ldw	r2,-12(fp)
81146420:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
81146424:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81146428:	e0bffd17 	ldw	r2,-12(fp)
8114642c:	10c00317 	ldw	r3,12(r2)
81146430:	e0bfff17 	ldw	r2,-4(fp)
81146434:	18bff21e 	bne	r3,r2,81146400 <__reset+0xfb126400>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
81146438:	e0bffd17 	ldw	r2,-12(fp)
8114643c:	10800717 	ldw	r2,28(r2)
81146440:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81146444:	e0bffe17 	ldw	r2,-8(fp)
81146448:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114644c:	e0bffd17 	ldw	r2,-12(fp)
81146450:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
81146454:	0005883a 	mov	r2,zero
}
81146458:	e037883a 	mov	sp,fp
8114645c:	df000017 	ldw	fp,0(sp)
81146460:	dec00104 	addi	sp,sp,4
81146464:	f800283a 	ret

81146468 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
81146468:	defff804 	addi	sp,sp,-32
8114646c:	de00012e 	bgeu	sp,et,81146474 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81146470:	003b68fa 	trap	3
81146474:	df000715 	stw	fp,28(sp)
81146478:	df000704 	addi	fp,sp,28
8114647c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81146480:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
81146484:	e13fff17 	ldw	r4,-4(fp)
81146488:	2000021e 	bne	r4,zero,81146494 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114648c:	00bffa84 	movi	r2,-22
81146490:	00002806 	br	81146534 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81146494:	e13fff17 	ldw	r4,-4(fp)
81146498:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8114649c:	e13fff17 	ldw	r4,-4(fp)
811464a0:	2005883a 	mov	r2,r4
811464a4:	0007883a 	mov	r3,zero
811464a8:	e0bffb15 	stw	r2,-20(fp)
811464ac:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811464b0:	00001006 	br	811464f4 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
811464b4:	e0bff917 	ldw	r2,-28(fp)
811464b8:	10800f17 	ldw	r2,60(r2)
811464bc:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811464c0:	e0bffa17 	ldw	r2,-24(fp)
811464c4:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811464c8:	e0bff917 	ldw	r2,-28(fp)
811464cc:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811464d0:	e0bff917 	ldw	r2,-28(fp)
811464d4:	10800317 	ldw	r2,12(r2)
811464d8:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
811464dc:	e0bff917 	ldw	r2,-28(fp)
811464e0:	10800b17 	ldw	r2,44(r2)
811464e4:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
811464e8:	e0bffd17 	ldw	r2,-12(fp)
811464ec:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
811464f0:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811464f4:	e0bff917 	ldw	r2,-28(fp)
811464f8:	10c00317 	ldw	r3,12(r2)
811464fc:	e0bffb17 	ldw	r2,-20(fp)
81146500:	18800426 	beq	r3,r2,81146514 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81146504:	e0bff917 	ldw	r2,-28(fp)
81146508:	10c00b17 	ldw	r3,44(r2)
8114650c:	e0bffc17 	ldw	r2,-16(fp)
81146510:	18bfe81e 	bne	r3,r2,811464b4 <__reset+0xfb1264b4>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
81146514:	e0bff917 	ldw	r2,-28(fp)
81146518:	10800f17 	ldw	r2,60(r2)
8114651c:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81146520:	e0bffa17 	ldw	r2,-24(fp)
81146524:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81146528:	e0bff917 	ldw	r2,-28(fp)
8114652c:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
81146530:	0005883a 	mov	r2,zero
}
81146534:	e037883a 	mov	sp,fp
81146538:	df000017 	ldw	fp,0(sp)
8114653c:	dec00104 	addi	sp,sp,4
81146540:	f800283a 	ret

81146544 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81146544:	deffeb04 	addi	sp,sp,-84
81146548:	de00012e 	bgeu	sp,et,81146550 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8114654c:	003b68fa 	trap	3
81146550:	dfc01415 	stw	ra,80(sp)
81146554:	df001315 	stw	fp,76(sp)
81146558:	df001304 	addi	fp,sp,76
8114655c:	e13ffb15 	stw	r4,-20(fp)
81146560:	e17ffc15 	stw	r5,-16(fp)
81146564:	e1bffd15 	stw	r6,-12(fp)
81146568:	3807883a 	mov	r3,r7
8114656c:	e0800217 	ldw	r2,8(fp)
81146570:	e0fffe05 	stb	r3,-8(fp)
81146574:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
81146578:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8114657c:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81146580:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
81146584:	e0bffc17 	ldw	r2,-16(fp)
81146588:	e0bff815 	stw	r2,-32(fp)
8114658c:	e0bffd17 	ldw	r2,-12(fp)
81146590:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
81146594:	e0bffb17 	ldw	r2,-20(fp)
81146598:	10801817 	ldw	r2,96(r2)
8114659c:	e0bff615 	stw	r2,-40(fp)
811465a0:	e03ff70d 	sth	zero,-36(fp)
811465a4:	e0bff70b 	ldhu	r2,-36(fp)
811465a8:	e0fffa04 	addi	r3,fp,-24
811465ac:	180d883a 	mov	r6,r3
811465b0:	100b883a 	mov	r5,r2
811465b4:	e13ff617 	ldw	r4,-40(fp)
811465b8:	113b6f00 	call	8113b6f0 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
811465bc:	e0bffb17 	ldw	r2,-20(fp)
811465c0:	10800617 	ldw	r2,24(r2)
811465c4:	10800037 	ldwio	r2,0(r2)
811465c8:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
811465cc:	e0bfed17 	ldw	r2,-76(fp)
811465d0:	1080004c 	andi	r2,r2,1
811465d4:	10000626 	beq	r2,zero,811465f0 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
811465d8:	e0bffb17 	ldw	r2,-20(fp)
811465dc:	10801817 	ldw	r2,96(r2)
811465e0:	1009883a 	mov	r4,r2
811465e4:	113ba780 	call	8113ba78 <OSSemPost>
		return -EBUSY;
811465e8:	00bffc04 	movi	r2,-16
811465ec:	00009606 	br	81146848 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811465f0:	00800804 	movi	r2,32
811465f4:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811465f8:	0005303a 	rdctl	r2,status
811465fc:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146600:	e0fff217 	ldw	r3,-56(fp)
81146604:	00bfff84 	movi	r2,-2
81146608:	1884703a 	and	r2,r3,r2
8114660c:	1001703a 	wrctl	status,r2
  
  return context;
81146610:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81146614:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81146618:	e0bffb17 	ldw	r2,-20(fp)
8114661c:	10800317 	ldw	r2,12(r2)
81146620:	10800104 	addi	r2,r2,4
81146624:	e0ffee17 	ldw	r3,-72(fp)
81146628:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
8114662c:	e0bffb17 	ldw	r2,-20(fp)
81146630:	10800317 	ldw	r2,12(r2)
81146634:	e0fffb17 	ldw	r3,-20(fp)
81146638:	18c00317 	ldw	r3,12(r3)
8114663c:	18c00037 	ldwio	r3,0(r3)
81146640:	10c00035 	stwio	r3,0(r2)
81146644:	e0bfef17 	ldw	r2,-68(fp)
81146648:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114664c:	e0bff017 	ldw	r2,-64(fp)
81146650:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
81146654:	e0bffb17 	ldw	r2,-20(fp)
81146658:	10800b17 	ldw	r2,44(r2)
8114665c:	10002326 	beq	r2,zero,811466ec <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81146660:	e0bffb17 	ldw	r2,-20(fp)
81146664:	10c00d17 	ldw	r3,52(r2)
81146668:	e0bfee17 	ldw	r2,-72(fp)
8114666c:	1884b03a 	or	r2,r3,r2
81146670:	10800514 	ori	r2,r2,20
81146674:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81146678:	e0ffee17 	ldw	r3,-72(fp)
8114667c:	00bff7c4 	movi	r2,-33
81146680:	1884703a 	and	r2,r3,r2
81146684:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81146688:	e0bfed17 	ldw	r2,-76(fp)
8114668c:	10800214 	ori	r2,r2,8
81146690:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146694:	0005303a 	rdctl	r2,status
81146698:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114669c:	e0fff417 	ldw	r3,-48(fp)
811466a0:	00bfff84 	movi	r2,-2
811466a4:	1884703a 	and	r2,r3,r2
811466a8:	1001703a 	wrctl	status,r2
  
  return context;
811466ac:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
811466b0:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811466b4:	e0bffb17 	ldw	r2,-20(fp)
811466b8:	10800317 	ldw	r2,12(r2)
811466bc:	10800104 	addi	r2,r2,4
811466c0:	e0ffee17 	ldw	r3,-72(fp)
811466c4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811466c8:	e0bffb17 	ldw	r2,-20(fp)
811466cc:	10800617 	ldw	r2,24(r2)
811466d0:	e0ffed17 	ldw	r3,-76(fp)
811466d4:	10c00035 	stwio	r3,0(r2)
811466d8:	e0bfef17 	ldw	r2,-68(fp)
811466dc:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811466e0:	e0bff117 	ldw	r2,-60(fp)
811466e4:	1001703a 	wrctl	status,r2
811466e8:	00002306 	br	81146778 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
811466ec:	e0bffb17 	ldw	r2,-20(fp)
811466f0:	10c00d17 	ldw	r3,52(r2)
811466f4:	e0bfee17 	ldw	r2,-72(fp)
811466f8:	1884b03a 	or	r2,r3,r2
811466fc:	10800114 	ori	r2,r2,4
81146700:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
81146704:	e0ffee17 	ldw	r3,-72(fp)
81146708:	00bff3c4 	movi	r2,-49
8114670c:	1884703a 	and	r2,r3,r2
81146710:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
81146714:	e0ffed17 	ldw	r3,-76(fp)
81146718:	00bffdc4 	movi	r2,-9
8114671c:	1884703a 	and	r2,r3,r2
81146720:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146724:	0005303a 	rdctl	r2,status
81146728:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114672c:	e0fff517 	ldw	r3,-44(fp)
81146730:	00bfff84 	movi	r2,-2
81146734:	1884703a 	and	r2,r3,r2
81146738:	1001703a 	wrctl	status,r2
  
  return context;
8114673c:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81146740:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81146744:	e0bffb17 	ldw	r2,-20(fp)
81146748:	10800317 	ldw	r2,12(r2)
8114674c:	10800104 	addi	r2,r2,4
81146750:	e0ffee17 	ldw	r3,-72(fp)
81146754:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81146758:	e0bffb17 	ldw	r2,-20(fp)
8114675c:	10800617 	ldw	r2,24(r2)
81146760:	e0ffed17 	ldw	r3,-76(fp)
81146764:	10c00035 	stwio	r3,0(r2)
81146768:	e0bfef17 	ldw	r2,-68(fp)
8114676c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146770:	e0bff317 	ldw	r2,-52(fp)
81146774:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81146778:	e0bffb17 	ldw	r2,-20(fp)
8114677c:	10800617 	ldw	r2,24(r2)
81146780:	10800104 	addi	r2,r2,4
81146784:	e0fff817 	ldw	r3,-32(fp)
81146788:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8114678c:	e0bffb17 	ldw	r2,-20(fp)
81146790:	10800617 	ldw	r2,24(r2)
81146794:	10800204 	addi	r2,r2,8
81146798:	e0fff917 	ldw	r3,-28(fp)
8114679c:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
811467a0:	e0bffe03 	ldbu	r2,-8(fp)
811467a4:	10000426 	beq	r2,zero,811467b8 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
811467a8:	e0bfed17 	ldw	r2,-76(fp)
811467ac:	10800414 	ori	r2,r2,16
811467b0:	e0bfed15 	stw	r2,-76(fp)
811467b4:	00000406 	br	811467c8 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
811467b8:	e0ffed17 	ldw	r3,-76(fp)
811467bc:	00bffbc4 	movi	r2,-17
811467c0:	1884703a 	and	r2,r3,r2
811467c4:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
811467c8:	e0bfff03 	ldbu	r2,-4(fp)
811467cc:	10000e26 	beq	r2,zero,81146808 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
811467d0:	e0bfed17 	ldw	r2,-76(fp)
811467d4:	10800094 	ori	r2,r2,2
811467d8:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
811467dc:	e0bffb17 	ldw	r2,-20(fp)
811467e0:	10800617 	ldw	r2,24(r2)
811467e4:	10800304 	addi	r2,r2,12
811467e8:	10800037 	ldwio	r2,0(r2)
811467ec:	10000a1e 	bne	r2,zero,81146818 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
811467f0:	e0bffb17 	ldw	r2,-20(fp)
811467f4:	10800617 	ldw	r2,24(r2)
811467f8:	10800304 	addi	r2,r2,12
811467fc:	00c03fc4 	movi	r3,255
81146800:	10c00035 	stwio	r3,0(r2)
81146804:	00000406 	br	81146818 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81146808:	e0ffed17 	ldw	r3,-76(fp)
8114680c:	00bfff44 	movi	r2,-3
81146810:	1884703a 	and	r2,r3,r2
81146814:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
81146818:	e0bfed17 	ldw	r2,-76(fp)
8114681c:	10800054 	ori	r2,r2,1
81146820:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81146824:	e0bffb17 	ldw	r2,-20(fp)
81146828:	10800617 	ldw	r2,24(r2)
8114682c:	e0ffed17 	ldw	r3,-76(fp)
81146830:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
81146834:	e0bffb17 	ldw	r2,-20(fp)
81146838:	10801817 	ldw	r2,96(r2)
8114683c:	1009883a 	mov	r4,r2
81146840:	113ba780 	call	8113ba78 <OSSemPost>
	 
	 return 0;
81146844:	0005883a 	mov	r2,zero
}
81146848:	e037883a 	mov	sp,fp
8114684c:	dfc00117 	ldw	ra,4(sp)
81146850:	df000017 	ldw	fp,0(sp)
81146854:	dec00204 	addi	sp,sp,8
81146858:	f800283a 	ret

8114685c <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8114685c:	defff704 	addi	sp,sp,-36
81146860:	de00012e 	bgeu	sp,et,81146868 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
81146864:	003b68fa 	trap	3
81146868:	dfc00815 	stw	ra,32(sp)
8114686c:	df000715 	stw	fp,28(sp)
81146870:	dc400615 	stw	r17,24(sp)
81146874:	dc000515 	stw	r16,20(sp)
81146878:	df000704 	addi	fp,sp,28
8114687c:	e13ffa15 	stw	r4,-24(fp)
81146880:	e17ffb15 	stw	r5,-20(fp)
81146884:	3007883a 	mov	r3,r6
81146888:	3805883a 	mov	r2,r7
8114688c:	e0fffc05 	stb	r3,-16(fp)
81146890:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81146894:	e13ffb17 	ldw	r4,-20(fp)
81146898:	11463c80 	call	811463c8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8114689c:	10000226 	beq	r2,zero,811468a8 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
811468a0:	00bffa84 	movi	r2,-22
811468a4:	00000b06 	br	811468d4 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
811468a8:	e0bffb17 	ldw	r2,-20(fp)
811468ac:	1021883a 	mov	r16,r2
811468b0:	0023883a 	mov	r17,zero
811468b4:	e0fffc03 	ldbu	r3,-16(fp)
811468b8:	e0bffd03 	ldbu	r2,-12(fp)
811468bc:	d8800015 	stw	r2,0(sp)
811468c0:	180f883a 	mov	r7,r3
811468c4:	800b883a 	mov	r5,r16
811468c8:	880d883a 	mov	r6,r17
811468cc:	e13ffa17 	ldw	r4,-24(fp)
811468d0:	11465440 	call	81146544 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
811468d4:	e6fffe04 	addi	sp,fp,-8
811468d8:	dfc00317 	ldw	ra,12(sp)
811468dc:	df000217 	ldw	fp,8(sp)
811468e0:	dc400117 	ldw	r17,4(sp)
811468e4:	dc000017 	ldw	r16,0(sp)
811468e8:	dec00404 	addi	sp,sp,16
811468ec:	f800283a 	ret

811468f0 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
811468f0:	defff704 	addi	sp,sp,-36
811468f4:	de00012e 	bgeu	sp,et,811468fc <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
811468f8:	003b68fa 	trap	3
811468fc:	dfc00815 	stw	ra,32(sp)
81146900:	df000715 	stw	fp,28(sp)
81146904:	dc400615 	stw	r17,24(sp)
81146908:	dc000515 	stw	r16,20(sp)
8114690c:	df000704 	addi	fp,sp,28
81146910:	e13ffa15 	stw	r4,-24(fp)
81146914:	e17ffb15 	stw	r5,-20(fp)
81146918:	3007883a 	mov	r3,r6
8114691c:	3805883a 	mov	r2,r7
81146920:	e0fffc05 	stb	r3,-16(fp)
81146924:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81146928:	e13ffb17 	ldw	r4,-20(fp)
8114692c:	11464680 	call	81146468 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81146930:	10000226 	beq	r2,zero,8114693c <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81146934:	00bffa84 	movi	r2,-22
81146938:	00000b06 	br	81146968 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8114693c:	e0bffb17 	ldw	r2,-20(fp)
81146940:	1021883a 	mov	r16,r2
81146944:	0023883a 	mov	r17,zero
81146948:	e0fffc03 	ldbu	r3,-16(fp)
8114694c:	e0bffd03 	ldbu	r2,-12(fp)
81146950:	d8800015 	stw	r2,0(sp)
81146954:	180f883a 	mov	r7,r3
81146958:	800b883a 	mov	r5,r16
8114695c:	880d883a 	mov	r6,r17
81146960:	e13ffa17 	ldw	r4,-24(fp)
81146964:	11465440 	call	81146544 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81146968:	e6fffe04 	addi	sp,fp,-8
8114696c:	dfc00317 	ldw	ra,12(sp)
81146970:	df000217 	ldw	fp,8(sp)
81146974:	dc400117 	ldw	r17,4(sp)
81146978:	dc000017 	ldw	r16,0(sp)
8114697c:	dec00404 	addi	sp,sp,16
81146980:	f800283a 	ret

81146984 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81146984:	defffc04 	addi	sp,sp,-16
81146988:	de00012e 	bgeu	sp,et,81146990 <alt_msgdma_open+0xc>
8114698c:	003b68fa 	trap	3
81146990:	dfc00315 	stw	ra,12(sp)
81146994:	df000215 	stw	fp,8(sp)
81146998:	df000204 	addi	fp,sp,8
8114699c:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
811469a0:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
811469a4:	d1603504 	addi	r5,gp,-32556
811469a8:	e13fff17 	ldw	r4,-4(fp)
811469ac:	1146f280 	call	81146f28 <alt_find_dev>
811469b0:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
811469b4:	e0bffe17 	ldw	r2,-8(fp)
811469b8:	1000041e 	bne	r2,zero,811469cc <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
811469bc:	1144be80 	call	81144be8 <alt_get_errno>
811469c0:	1007883a 	mov	r3,r2
811469c4:	008004c4 	movi	r2,19
811469c8:	18800015 	stw	r2,0(r3)
    }

    return dev;
811469cc:	e0bffe17 	ldw	r2,-8(fp)
}
811469d0:	e037883a 	mov	sp,fp
811469d4:	dfc00117 	ldw	ra,4(sp)
811469d8:	df000017 	ldw	fp,0(sp)
811469dc:	dec00204 	addi	sp,sp,8
811469e0:	f800283a 	ret

811469e4 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
811469e4:	defff604 	addi	sp,sp,-40
811469e8:	de00012e 	bgeu	sp,et,811469f0 <alt_msgdma_init+0xc>
811469ec:	003b68fa 	trap	3
811469f0:	dfc00915 	stw	ra,36(sp)
811469f4:	df000815 	stw	fp,32(sp)
811469f8:	df000804 	addi	fp,sp,32
811469fc:	e13ffd15 	stw	r4,-12(fp)
81146a00:	e17ffe15 	stw	r5,-8(fp)
81146a04:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81146a08:	e0bffd17 	ldw	r2,-12(fp)
81146a0c:	10801783 	ldbu	r2,94(r2)
81146a10:	10803fcc 	andi	r2,r2,255
81146a14:	10000b26 	beq	r2,zero,81146a44 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81146a18:	e0bffd17 	ldw	r2,-12(fp)
81146a1c:	10800617 	ldw	r2,24(r2)
81146a20:	00c00104 	movi	r3,4
81146a24:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
81146a28:	0001883a 	nop
81146a2c:	e0bffd17 	ldw	r2,-12(fp)
81146a30:	10800617 	ldw	r2,24(r2)
81146a34:	10800037 	ldwio	r2,0(r2)
81146a38:	1080010c 	andi	r2,r2,4
81146a3c:	1005d0ba 	srai	r2,r2,2
81146a40:	103ffa1e 	bne	r2,zero,81146a2c <__reset+0xfb126a2c>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81146a44:	e0bffd17 	ldw	r2,-12(fp)
81146a48:	10800317 	ldw	r2,12(r2)
81146a4c:	10800104 	addi	r2,r2,4
81146a50:	00c00084 	movi	r3,2
81146a54:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81146a58:	0001883a 	nop
81146a5c:	e0bffd17 	ldw	r2,-12(fp)
81146a60:	10800317 	ldw	r2,12(r2)
81146a64:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81146a68:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81146a6c:	103ffb1e 	bne	r2,zero,81146a5c <__reset+0xfb126a5c>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81146a70:	e0bffd17 	ldw	r2,-12(fp)
81146a74:	10800317 	ldw	r2,12(r2)
81146a78:	10800104 	addi	r2,r2,4
81146a7c:	10800037 	ldwio	r2,0(r2)
81146a80:	1007883a 	mov	r3,r2
81146a84:	00bffbc4 	movi	r2,-17
81146a88:	1884703a 	and	r2,r3,r2
81146a8c:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81146a90:	e0bff917 	ldw	r2,-28(fp)
81146a94:	10800814 	ori	r2,r2,32
81146a98:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81146a9c:	e0bffd17 	ldw	r2,-12(fp)
81146aa0:	10800317 	ldw	r2,12(r2)
81146aa4:	10800104 	addi	r2,r2,4
81146aa8:	e0fff917 	ldw	r3,-28(fp)
81146aac:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81146ab0:	e0bffd17 	ldw	r2,-12(fp)
81146ab4:	10800317 	ldw	r2,12(r2)
81146ab8:	e0fffd17 	ldw	r3,-12(fp)
81146abc:	18c00317 	ldw	r3,12(r3)
81146ac0:	18c00037 	ldwio	r3,0(r3)
81146ac4:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81146ac8:	e0bffd17 	ldw	r2,-12(fp)
81146acc:	10801783 	ldbu	r2,94(r2)
81146ad0:	10803fcc 	andi	r2,r2,255
81146ad4:	10000826 	beq	r2,zero,81146af8 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
81146ad8:	e0bffd17 	ldw	r2,-12(fp)
81146adc:	10800617 	ldw	r2,24(r2)
81146ae0:	10800404 	addi	r2,r2,16
81146ae4:	e0fffd17 	ldw	r3,-12(fp)
81146ae8:	18c00617 	ldw	r3,24(r3)
81146aec:	18c00404 	addi	r3,r3,16
81146af0:	18c00037 	ldwio	r3,0(r3)
81146af4:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81146af8:	d1603504 	addi	r5,gp,-32556
81146afc:	e13ffd17 	ldw	r4,-12(fp)
81146b00:	1146e7c0 	call	81146e7c <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
81146b04:	e0bffd17 	ldw	r2,-12(fp)
81146b08:	10801804 	addi	r2,r2,96
81146b0c:	e0bffb15 	stw	r2,-20(fp)
81146b10:	00800044 	movi	r2,1
81146b14:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81146b18:	e0bffc0b 	ldhu	r2,-16(fp)
81146b1c:	1009883a 	mov	r4,r2
81146b20:	113b3c80 	call	8113b3c8 <OSSemCreate>
81146b24:	1007883a 	mov	r3,r2
81146b28:	e0bffb17 	ldw	r2,-20(fp)
81146b2c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81146b30:	e0bffb17 	ldw	r2,-20(fp)
81146b34:	10800017 	ldw	r2,0(r2)
81146b38:	10000226 	beq	r2,zero,81146b44 <alt_msgdma_init+0x160>
81146b3c:	0005883a 	mov	r2,zero
81146b40:	00000106 	br	81146b48 <alt_msgdma_init+0x164>
81146b44:	00bfffc4 	movi	r2,-1
81146b48:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81146b4c:	e0bffa17 	ldw	r2,-24(fp)
81146b50:	1000081e 	bne	r2,zero,81146b74 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81146b54:	d8000015 	stw	zero,0(sp)
81146b58:	e1fffd17 	ldw	r7,-12(fp)
81146b5c:	01a04534 	movhi	r6,33044
81146b60:	31937f04 	addi	r6,r6,19964
81146b64:	e17fff17 	ldw	r5,-4(fp)
81146b68:	e13ffe17 	ldw	r4,-8(fp)
81146b6c:	11471b40 	call	811471b4 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81146b70:	00000406 	br	81146b84 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81146b74:	01204574 	movhi	r4,33045
81146b78:	2135dc04 	addi	r4,r4,-10384
81146b7c:	11475cc0 	call	811475cc <alt_printf>
    }
    
    return;
81146b80:	0001883a 	nop

}
81146b84:	e037883a 	mov	sp,fp
81146b88:	dfc00117 	ldw	ra,4(sp)
81146b8c:	df000017 	ldw	fp,0(sp)
81146b90:	dec00204 	addi	sp,sp,8
81146b94:	f800283a 	ret

81146b98 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81146b98:	defffb04 	addi	sp,sp,-20
81146b9c:	de00012e 	bgeu	sp,et,81146ba4 <alt_msgdma_register_callback+0xc>
81146ba0:	003b68fa 	trap	3
81146ba4:	df000415 	stw	fp,16(sp)
81146ba8:	df000404 	addi	fp,sp,16
81146bac:	e13ffc15 	stw	r4,-16(fp)
81146bb0:	e17ffd15 	stw	r5,-12(fp)
81146bb4:	e1bffe15 	stw	r6,-8(fp)
81146bb8:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81146bbc:	e0bffc17 	ldw	r2,-16(fp)
81146bc0:	e0fffd17 	ldw	r3,-12(fp)
81146bc4:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81146bc8:	e0bffc17 	ldw	r2,-16(fp)
81146bcc:	e0ffff17 	ldw	r3,-4(fp)
81146bd0:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81146bd4:	e0bffc17 	ldw	r2,-16(fp)
81146bd8:	e0fffe17 	ldw	r3,-8(fp)
81146bdc:	10c00d15 	stw	r3,52(r2)

    return ;
81146be0:	0001883a 	nop
}
81146be4:	e037883a 	mov	sp,fp
81146be8:	df000017 	ldw	fp,0(sp)
81146bec:	dec00104 	addi	sp,sp,4
81146bf0:	f800283a 	ret

81146bf4 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81146bf4:	defffc04 	addi	sp,sp,-16
81146bf8:	de00012e 	bgeu	sp,et,81146c00 <alt_msgdma_standard_descriptor_async_transfer+0xc>
81146bfc:	003b68fa 	trap	3
81146c00:	dfc00315 	stw	ra,12(sp)
81146c04:	df000215 	stw	fp,8(sp)
81146c08:	df000204 	addi	fp,sp,8
81146c0c:	e13ffe15 	stw	r4,-8(fp)
81146c10:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
81146c14:	000d883a 	mov	r6,zero
81146c18:	e17fff17 	ldw	r5,-4(fp)
81146c1c:	e13ffe17 	ldw	r4,-8(fp)
81146c20:	11451780 	call	81145178 <alt_msgdma_descriptor_async_transfer>

}
81146c24:	e037883a 	mov	sp,fp
81146c28:	dfc00117 	ldw	ra,4(sp)
81146c2c:	df000017 	ldw	fp,0(sp)
81146c30:	dec00204 	addi	sp,sp,8
81146c34:	f800283a 	ret

81146c38 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81146c38:	defffc04 	addi	sp,sp,-16
81146c3c:	de00012e 	bgeu	sp,et,81146c44 <alt_msgdma_extended_descriptor_async_transfer+0xc>
81146c40:	003b68fa 	trap	3
81146c44:	dfc00315 	stw	ra,12(sp)
81146c48:	df000215 	stw	fp,8(sp)
81146c4c:	df000204 	addi	fp,sp,8
81146c50:	e13ffe15 	stw	r4,-8(fp)
81146c54:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81146c58:	e1bfff17 	ldw	r6,-4(fp)
81146c5c:	000b883a 	mov	r5,zero
81146c60:	e13ffe17 	ldw	r4,-8(fp)
81146c64:	11451780 	call	81145178 <alt_msgdma_descriptor_async_transfer>
}
81146c68:	e037883a 	mov	sp,fp
81146c6c:	dfc00117 	ldw	ra,4(sp)
81146c70:	df000017 	ldw	fp,0(sp)
81146c74:	dec00204 	addi	sp,sp,8
81146c78:	f800283a 	ret

81146c7c <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81146c7c:	defffc04 	addi	sp,sp,-16
81146c80:	de00012e 	bgeu	sp,et,81146c88 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
81146c84:	003b68fa 	trap	3
81146c88:	dfc00315 	stw	ra,12(sp)
81146c8c:	df000215 	stw	fp,8(sp)
81146c90:	df000204 	addi	fp,sp,8
81146c94:	e13ffe15 	stw	r4,-8(fp)
81146c98:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
81146c9c:	000d883a 	mov	r6,zero
81146ca0:	e17fff17 	ldw	r5,-4(fp)
81146ca4:	e13ffe17 	ldw	r4,-8(fp)
81146ca8:	11454b80 	call	811454b8 <alt_msgdma_descriptor_sync_transfer>
}
81146cac:	e037883a 	mov	sp,fp
81146cb0:	dfc00117 	ldw	ra,4(sp)
81146cb4:	df000017 	ldw	fp,0(sp)
81146cb8:	dec00204 	addi	sp,sp,8
81146cbc:	f800283a 	ret

81146cc0 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81146cc0:	defffc04 	addi	sp,sp,-16
81146cc4:	de00012e 	bgeu	sp,et,81146ccc <alt_msgdma_extended_descriptor_sync_transfer+0xc>
81146cc8:	003b68fa 	trap	3
81146ccc:	dfc00315 	stw	ra,12(sp)
81146cd0:	df000215 	stw	fp,8(sp)
81146cd4:	df000204 	addi	fp,sp,8
81146cd8:	e13ffe15 	stw	r4,-8(fp)
81146cdc:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
81146ce0:	e1bfff17 	ldw	r6,-4(fp)
81146ce4:	000b883a 	mov	r5,zero
81146ce8:	e13ffe17 	ldw	r4,-8(fp)
81146cec:	11454b80 	call	811454b8 <alt_msgdma_descriptor_sync_transfer>
}
81146cf0:	e037883a 	mov	sp,fp
81146cf4:	dfc00117 	ldw	ra,4(sp)
81146cf8:	df000017 	ldw	fp,0(sp)
81146cfc:	dec00204 	addi	sp,sp,8
81146d00:	f800283a 	ret

81146d04 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
81146d04:	defff504 	addi	sp,sp,-44
81146d08:	de00012e 	bgeu	sp,et,81146d10 <alt_alarm_start+0xc>
81146d0c:	003b68fa 	trap	3
81146d10:	df000a15 	stw	fp,40(sp)
81146d14:	df000a04 	addi	fp,sp,40
81146d18:	e13ffc15 	stw	r4,-16(fp)
81146d1c:	e17ffd15 	stw	r5,-12(fp)
81146d20:	e1bffe15 	stw	r6,-8(fp)
81146d24:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
81146d28:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81146d2c:	d0a08717 	ldw	r2,-32228(gp)
  
  if (alt_ticks_per_second ())
81146d30:	10003c26 	beq	r2,zero,81146e24 <alt_alarm_start+0x120>
  {
    if (alarm)
81146d34:	e0bffc17 	ldw	r2,-16(fp)
81146d38:	10003826 	beq	r2,zero,81146e1c <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81146d3c:	e0bffc17 	ldw	r2,-16(fp)
81146d40:	e0fffe17 	ldw	r3,-8(fp)
81146d44:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
81146d48:	e0bffc17 	ldw	r2,-16(fp)
81146d4c:	e0ffff17 	ldw	r3,-4(fp)
81146d50:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146d54:	0005303a 	rdctl	r2,status
81146d58:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146d5c:	e0fff917 	ldw	r3,-28(fp)
81146d60:	00bfff84 	movi	r2,-2
81146d64:	1884703a 	and	r2,r3,r2
81146d68:	1001703a 	wrctl	status,r2
  
  return context;
81146d6c:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81146d70:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81146d74:	d0a08817 	ldw	r2,-32224(gp)
      
      current_nticks = alt_nticks();
81146d78:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81146d7c:	e0fffd17 	ldw	r3,-12(fp)
81146d80:	e0bff617 	ldw	r2,-40(fp)
81146d84:	1885883a 	add	r2,r3,r2
81146d88:	10c00044 	addi	r3,r2,1
81146d8c:	e0bffc17 	ldw	r2,-16(fp)
81146d90:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
81146d94:	e0bffc17 	ldw	r2,-16(fp)
81146d98:	10c00217 	ldw	r3,8(r2)
81146d9c:	e0bff617 	ldw	r2,-40(fp)
81146da0:	1880042e 	bgeu	r3,r2,81146db4 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
81146da4:	e0bffc17 	ldw	r2,-16(fp)
81146da8:	00c00044 	movi	r3,1
81146dac:	10c00405 	stb	r3,16(r2)
81146db0:	00000206 	br	81146dbc <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
81146db4:	e0bffc17 	ldw	r2,-16(fp)
81146db8:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
81146dbc:	e0bffc17 	ldw	r2,-16(fp)
81146dc0:	d0e01404 	addi	r3,gp,-32688
81146dc4:	e0fffa15 	stw	r3,-24(fp)
81146dc8:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81146dcc:	e0bffb17 	ldw	r2,-20(fp)
81146dd0:	e0fffa17 	ldw	r3,-24(fp)
81146dd4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81146dd8:	e0bffa17 	ldw	r2,-24(fp)
81146ddc:	10c00017 	ldw	r3,0(r2)
81146de0:	e0bffb17 	ldw	r2,-20(fp)
81146de4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81146de8:	e0bffa17 	ldw	r2,-24(fp)
81146dec:	10800017 	ldw	r2,0(r2)
81146df0:	e0fffb17 	ldw	r3,-20(fp)
81146df4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81146df8:	e0bffa17 	ldw	r2,-24(fp)
81146dfc:	e0fffb17 	ldw	r3,-20(fp)
81146e00:	10c00015 	stw	r3,0(r2)
81146e04:	e0bff817 	ldw	r2,-32(fp)
81146e08:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146e0c:	e0bff717 	ldw	r2,-36(fp)
81146e10:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
81146e14:	0005883a 	mov	r2,zero
81146e18:	00000306 	br	81146e28 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81146e1c:	00bffa84 	movi	r2,-22
81146e20:	00000106 	br	81146e28 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
81146e24:	00bfde84 	movi	r2,-134
  }
}
81146e28:	e037883a 	mov	sp,fp
81146e2c:	df000017 	ldw	fp,0(sp)
81146e30:	dec00104 	addi	sp,sp,4
81146e34:	f800283a 	ret

81146e38 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81146e38:	defffe04 	addi	sp,sp,-8
81146e3c:	de00012e 	bgeu	sp,et,81146e44 <alt_get_errno+0xc>
81146e40:	003b68fa 	trap	3
81146e44:	dfc00115 	stw	ra,4(sp)
81146e48:	df000015 	stw	fp,0(sp)
81146e4c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81146e50:	d0a01017 	ldw	r2,-32704(gp)
81146e54:	10000326 	beq	r2,zero,81146e64 <alt_get_errno+0x2c>
81146e58:	d0a01017 	ldw	r2,-32704(gp)
81146e5c:	103ee83a 	callr	r2
81146e60:	00000106 	br	81146e68 <alt_get_errno+0x30>
81146e64:	d0a07704 	addi	r2,gp,-32292
}
81146e68:	e037883a 	mov	sp,fp
81146e6c:	dfc00117 	ldw	ra,4(sp)
81146e70:	df000017 	ldw	fp,0(sp)
81146e74:	dec00204 	addi	sp,sp,8
81146e78:	f800283a 	ret

81146e7c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81146e7c:	defffa04 	addi	sp,sp,-24
81146e80:	de00012e 	bgeu	sp,et,81146e88 <alt_dev_llist_insert+0xc>
81146e84:	003b68fa 	trap	3
81146e88:	dfc00515 	stw	ra,20(sp)
81146e8c:	df000415 	stw	fp,16(sp)
81146e90:	df000404 	addi	fp,sp,16
81146e94:	e13ffe15 	stw	r4,-8(fp)
81146e98:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
81146e9c:	e0bffe17 	ldw	r2,-8(fp)
81146ea0:	10000326 	beq	r2,zero,81146eb0 <alt_dev_llist_insert+0x34>
81146ea4:	e0bffe17 	ldw	r2,-8(fp)
81146ea8:	10800217 	ldw	r2,8(r2)
81146eac:	1000061e 	bne	r2,zero,81146ec8 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
81146eb0:	1146e380 	call	81146e38 <alt_get_errno>
81146eb4:	1007883a 	mov	r3,r2
81146eb8:	00800584 	movi	r2,22
81146ebc:	18800015 	stw	r2,0(r3)
    return -EINVAL;
81146ec0:	00bffa84 	movi	r2,-22
81146ec4:	00001306 	br	81146f14 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
81146ec8:	e0bffe17 	ldw	r2,-8(fp)
81146ecc:	e0ffff17 	ldw	r3,-4(fp)
81146ed0:	e0fffc15 	stw	r3,-16(fp)
81146ed4:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81146ed8:	e0bffd17 	ldw	r2,-12(fp)
81146edc:	e0fffc17 	ldw	r3,-16(fp)
81146ee0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81146ee4:	e0bffc17 	ldw	r2,-16(fp)
81146ee8:	10c00017 	ldw	r3,0(r2)
81146eec:	e0bffd17 	ldw	r2,-12(fp)
81146ef0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81146ef4:	e0bffc17 	ldw	r2,-16(fp)
81146ef8:	10800017 	ldw	r2,0(r2)
81146efc:	e0fffd17 	ldw	r3,-12(fp)
81146f00:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81146f04:	e0bffc17 	ldw	r2,-16(fp)
81146f08:	e0fffd17 	ldw	r3,-12(fp)
81146f0c:	10c00015 	stw	r3,0(r2)

  return 0;  
81146f10:	0005883a 	mov	r2,zero
}
81146f14:	e037883a 	mov	sp,fp
81146f18:	dfc00117 	ldw	ra,4(sp)
81146f1c:	df000017 	ldw	fp,0(sp)
81146f20:	dec00204 	addi	sp,sp,8
81146f24:	f800283a 	ret

81146f28 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
81146f28:	defffa04 	addi	sp,sp,-24
81146f2c:	de00012e 	bgeu	sp,et,81146f34 <alt_find_dev+0xc>
81146f30:	003b68fa 	trap	3
81146f34:	dfc00515 	stw	ra,20(sp)
81146f38:	df000415 	stw	fp,16(sp)
81146f3c:	df000404 	addi	fp,sp,16
81146f40:	e13ffe15 	stw	r4,-8(fp)
81146f44:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
81146f48:	e0bfff17 	ldw	r2,-4(fp)
81146f4c:	10800017 	ldw	r2,0(r2)
81146f50:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
81146f54:	e13ffe17 	ldw	r4,-8(fp)
81146f58:	111f1b80 	call	8111f1b8 <strlen>
81146f5c:	10800044 	addi	r2,r2,1
81146f60:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81146f64:	00000d06 	br	81146f9c <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
81146f68:	e0bffc17 	ldw	r2,-16(fp)
81146f6c:	10800217 	ldw	r2,8(r2)
81146f70:	e0fffd17 	ldw	r3,-12(fp)
81146f74:	180d883a 	mov	r6,r3
81146f78:	e17ffe17 	ldw	r5,-8(fp)
81146f7c:	1009883a 	mov	r4,r2
81146f80:	1147d3c0 	call	81147d3c <memcmp>
81146f84:	1000021e 	bne	r2,zero,81146f90 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
81146f88:	e0bffc17 	ldw	r2,-16(fp)
81146f8c:	00000706 	br	81146fac <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81146f90:	e0bffc17 	ldw	r2,-16(fp)
81146f94:	10800017 	ldw	r2,0(r2)
81146f98:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81146f9c:	e0fffc17 	ldw	r3,-16(fp)
81146fa0:	e0bfff17 	ldw	r2,-4(fp)
81146fa4:	18bff01e 	bne	r3,r2,81146f68 <__reset+0xfb126f68>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
81146fa8:	0005883a 	mov	r2,zero
}
81146fac:	e037883a 	mov	sp,fp
81146fb0:	dfc00117 	ldw	ra,4(sp)
81146fb4:	df000017 	ldw	fp,0(sp)
81146fb8:	dec00204 	addi	sp,sp,8
81146fbc:	f800283a 	ret

81146fc0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
81146fc0:	defffb04 	addi	sp,sp,-20
81146fc4:	de00012e 	bgeu	sp,et,81146fcc <alt_find_file+0xc>
81146fc8:	003b68fa 	trap	3
81146fcc:	dfc00415 	stw	ra,16(sp)
81146fd0:	df000315 	stw	fp,12(sp)
81146fd4:	df000304 	addi	fp,sp,12
81146fd8:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
81146fdc:	d0a00b17 	ldw	r2,-32724(gp)
81146fe0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81146fe4:	00003106 	br	811470ac <alt_find_file+0xec>
  {
    len = strlen(next->name);
81146fe8:	e0bffd17 	ldw	r2,-12(fp)
81146fec:	10800217 	ldw	r2,8(r2)
81146ff0:	1009883a 	mov	r4,r2
81146ff4:	111f1b80 	call	8111f1b8 <strlen>
81146ff8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81146ffc:	e0bffd17 	ldw	r2,-12(fp)
81147000:	10c00217 	ldw	r3,8(r2)
81147004:	e0bffe17 	ldw	r2,-8(fp)
81147008:	10bfffc4 	addi	r2,r2,-1
8114700c:	1885883a 	add	r2,r3,r2
81147010:	10800003 	ldbu	r2,0(r2)
81147014:	10803fcc 	andi	r2,r2,255
81147018:	1080201c 	xori	r2,r2,128
8114701c:	10bfe004 	addi	r2,r2,-128
81147020:	10800bd8 	cmpnei	r2,r2,47
81147024:	1000031e 	bne	r2,zero,81147034 <alt_find_file+0x74>
    {
      len -= 1;
81147028:	e0bffe17 	ldw	r2,-8(fp)
8114702c:	10bfffc4 	addi	r2,r2,-1
81147030:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81147034:	e0bffe17 	ldw	r2,-8(fp)
81147038:	e0ffff17 	ldw	r3,-4(fp)
8114703c:	1885883a 	add	r2,r3,r2
81147040:	10800003 	ldbu	r2,0(r2)
81147044:	10803fcc 	andi	r2,r2,255
81147048:	1080201c 	xori	r2,r2,128
8114704c:	10bfe004 	addi	r2,r2,-128
81147050:	10800be0 	cmpeqi	r2,r2,47
81147054:	1000081e 	bne	r2,zero,81147078 <alt_find_file+0xb8>
81147058:	e0bffe17 	ldw	r2,-8(fp)
8114705c:	e0ffff17 	ldw	r3,-4(fp)
81147060:	1885883a 	add	r2,r3,r2
81147064:	10800003 	ldbu	r2,0(r2)
81147068:	10803fcc 	andi	r2,r2,255
8114706c:	1080201c 	xori	r2,r2,128
81147070:	10bfe004 	addi	r2,r2,-128
81147074:	10000a1e 	bne	r2,zero,811470a0 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
81147078:	e0bffd17 	ldw	r2,-12(fp)
8114707c:	10800217 	ldw	r2,8(r2)
81147080:	e0fffe17 	ldw	r3,-8(fp)
81147084:	180d883a 	mov	r6,r3
81147088:	e17fff17 	ldw	r5,-4(fp)
8114708c:	1009883a 	mov	r4,r2
81147090:	1147d3c0 	call	81147d3c <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81147094:	1000021e 	bne	r2,zero,811470a0 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
81147098:	e0bffd17 	ldw	r2,-12(fp)
8114709c:	00000706 	br	811470bc <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
811470a0:	e0bffd17 	ldw	r2,-12(fp)
811470a4:	10800017 	ldw	r2,0(r2)
811470a8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
811470ac:	e0fffd17 	ldw	r3,-12(fp)
811470b0:	d0a00b04 	addi	r2,gp,-32724
811470b4:	18bfcc1e 	bne	r3,r2,81146fe8 <__reset+0xfb126fe8>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
811470b8:	0005883a 	mov	r2,zero
}
811470bc:	e037883a 	mov	sp,fp
811470c0:	dfc00117 	ldw	ra,4(sp)
811470c4:	df000017 	ldw	fp,0(sp)
811470c8:	dec00204 	addi	sp,sp,8
811470cc:	f800283a 	ret

811470d0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
811470d0:	defff904 	addi	sp,sp,-28
811470d4:	de00012e 	bgeu	sp,et,811470dc <alt_get_fd+0xc>
811470d8:	003b68fa 	trap	3
811470dc:	dfc00615 	stw	ra,24(sp)
811470e0:	df000515 	stw	fp,20(sp)
811470e4:	df000504 	addi	fp,sp,20
811470e8:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
811470ec:	00bffa04 	movi	r2,-24
811470f0:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
811470f4:	d0a07e17 	ldw	r2,-32264(gp)
811470f8:	e0bffd15 	stw	r2,-12(fp)
811470fc:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81147100:	e0bffe0b 	ldhu	r2,-8(fp)
81147104:	e0fffe84 	addi	r3,fp,-6
81147108:	180d883a 	mov	r6,r3
8114710c:	100b883a 	mov	r5,r2
81147110:	e13ffd17 	ldw	r4,-12(fp)
81147114:	113b6f00 	call	8113b6f0 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81147118:	e03ffb15 	stw	zero,-20(fp)
8114711c:	00001906 	br	81147184 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81147120:	00a04574 	movhi	r2,33045
81147124:	10b84b04 	addi	r2,r2,-7892
81147128:	e0fffb17 	ldw	r3,-20(fp)
8114712c:	18c00324 	muli	r3,r3,12
81147130:	10c5883a 	add	r2,r2,r3
81147134:	10800017 	ldw	r2,0(r2)
81147138:	10000f1e 	bne	r2,zero,81147178 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8114713c:	00a04574 	movhi	r2,33045
81147140:	10b84b04 	addi	r2,r2,-7892
81147144:	e0fffb17 	ldw	r3,-20(fp)
81147148:	18c00324 	muli	r3,r3,12
8114714c:	10c5883a 	add	r2,r2,r3
81147150:	e0ffff17 	ldw	r3,-4(fp)
81147154:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
81147158:	d0e00f17 	ldw	r3,-32708(gp)
8114715c:	e0bffb17 	ldw	r2,-20(fp)
81147160:	1880020e 	bge	r3,r2,8114716c <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
81147164:	e0bffb17 	ldw	r2,-20(fp)
81147168:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8114716c:	e0bffb17 	ldw	r2,-20(fp)
81147170:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
81147174:	00000606 	br	81147190 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81147178:	e0bffb17 	ldw	r2,-20(fp)
8114717c:	10800044 	addi	r2,r2,1
81147180:	e0bffb15 	stw	r2,-20(fp)
81147184:	e0bffb17 	ldw	r2,-20(fp)
81147188:	10800810 	cmplti	r2,r2,32
8114718c:	103fe41e 	bne	r2,zero,81147120 <__reset+0xfb127120>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81147190:	d0a07e17 	ldw	r2,-32264(gp)
81147194:	1009883a 	mov	r4,r2
81147198:	113ba780 	call	8113ba78 <OSSemPost>

  return rc;
8114719c:	e0bffc17 	ldw	r2,-16(fp)
}
811471a0:	e037883a 	mov	sp,fp
811471a4:	dfc00117 	ldw	ra,4(sp)
811471a8:	df000017 	ldw	fp,0(sp)
811471ac:	dec00204 	addi	sp,sp,8
811471b0:	f800283a 	ret

811471b4 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
811471b4:	defff904 	addi	sp,sp,-28
811471b8:	de00012e 	bgeu	sp,et,811471c0 <alt_ic_isr_register+0xc>
811471bc:	003b68fa 	trap	3
811471c0:	dfc00615 	stw	ra,24(sp)
811471c4:	df000515 	stw	fp,20(sp)
811471c8:	df000504 	addi	fp,sp,20
811471cc:	e13ffc15 	stw	r4,-16(fp)
811471d0:	e17ffd15 	stw	r5,-12(fp)
811471d4:	e1bffe15 	stw	r6,-8(fp)
811471d8:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
811471dc:	e0800217 	ldw	r2,8(fp)
811471e0:	d8800015 	stw	r2,0(sp)
811471e4:	e1ffff17 	ldw	r7,-4(fp)
811471e8:	e1bffe17 	ldw	r6,-8(fp)
811471ec:	e17ffd17 	ldw	r5,-12(fp)
811471f0:	e13ffc17 	ldw	r4,-16(fp)
811471f4:	11473840 	call	81147384 <alt_iic_isr_register>
}  
811471f8:	e037883a 	mov	sp,fp
811471fc:	dfc00117 	ldw	ra,4(sp)
81147200:	df000017 	ldw	fp,0(sp)
81147204:	dec00204 	addi	sp,sp,8
81147208:	f800283a 	ret

8114720c <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8114720c:	defff904 	addi	sp,sp,-28
81147210:	de00012e 	bgeu	sp,et,81147218 <alt_ic_irq_enable+0xc>
81147214:	003b68fa 	trap	3
81147218:	df000615 	stw	fp,24(sp)
8114721c:	df000604 	addi	fp,sp,24
81147220:	e13ffe15 	stw	r4,-8(fp)
81147224:	e17fff15 	stw	r5,-4(fp)
81147228:	e0bfff17 	ldw	r2,-4(fp)
8114722c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147230:	0005303a 	rdctl	r2,status
81147234:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147238:	e0fffb17 	ldw	r3,-20(fp)
8114723c:	00bfff84 	movi	r2,-2
81147240:	1884703a 	and	r2,r3,r2
81147244:	1001703a 	wrctl	status,r2
  
  return context;
81147248:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114724c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
81147250:	00c00044 	movi	r3,1
81147254:	e0bffa17 	ldw	r2,-24(fp)
81147258:	1884983a 	sll	r2,r3,r2
8114725c:	1007883a 	mov	r3,r2
81147260:	d0a07f17 	ldw	r2,-32260(gp)
81147264:	1884b03a 	or	r2,r3,r2
81147268:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114726c:	d0a07f17 	ldw	r2,-32260(gp)
81147270:	100170fa 	wrctl	ienable,r2
81147274:	e0bffc17 	ldw	r2,-16(fp)
81147278:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114727c:	e0bffd17 	ldw	r2,-12(fp)
81147280:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81147284:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
81147288:	0001883a 	nop
}
8114728c:	e037883a 	mov	sp,fp
81147290:	df000017 	ldw	fp,0(sp)
81147294:	dec00104 	addi	sp,sp,4
81147298:	f800283a 	ret

8114729c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8114729c:	defff904 	addi	sp,sp,-28
811472a0:	de00012e 	bgeu	sp,et,811472a8 <alt_ic_irq_disable+0xc>
811472a4:	003b68fa 	trap	3
811472a8:	df000615 	stw	fp,24(sp)
811472ac:	df000604 	addi	fp,sp,24
811472b0:	e13ffe15 	stw	r4,-8(fp)
811472b4:	e17fff15 	stw	r5,-4(fp)
811472b8:	e0bfff17 	ldw	r2,-4(fp)
811472bc:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811472c0:	0005303a 	rdctl	r2,status
811472c4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811472c8:	e0fffb17 	ldw	r3,-20(fp)
811472cc:	00bfff84 	movi	r2,-2
811472d0:	1884703a 	and	r2,r3,r2
811472d4:	1001703a 	wrctl	status,r2
  
  return context;
811472d8:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811472dc:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
811472e0:	00c00044 	movi	r3,1
811472e4:	e0bffa17 	ldw	r2,-24(fp)
811472e8:	1884983a 	sll	r2,r3,r2
811472ec:	0084303a 	nor	r2,zero,r2
811472f0:	1007883a 	mov	r3,r2
811472f4:	d0a07f17 	ldw	r2,-32260(gp)
811472f8:	1884703a 	and	r2,r3,r2
811472fc:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81147300:	d0a07f17 	ldw	r2,-32260(gp)
81147304:	100170fa 	wrctl	ienable,r2
81147308:	e0bffc17 	ldw	r2,-16(fp)
8114730c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147310:	e0bffd17 	ldw	r2,-12(fp)
81147314:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81147318:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8114731c:	0001883a 	nop
}
81147320:	e037883a 	mov	sp,fp
81147324:	df000017 	ldw	fp,0(sp)
81147328:	dec00104 	addi	sp,sp,4
8114732c:	f800283a 	ret

81147330 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81147330:	defffc04 	addi	sp,sp,-16
81147334:	de00012e 	bgeu	sp,et,8114733c <alt_ic_irq_enabled+0xc>
81147338:	003b68fa 	trap	3
8114733c:	df000315 	stw	fp,12(sp)
81147340:	df000304 	addi	fp,sp,12
81147344:	e13ffe15 	stw	r4,-8(fp)
81147348:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8114734c:	000530fa 	rdctl	r2,ienable
81147350:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
81147354:	00c00044 	movi	r3,1
81147358:	e0bfff17 	ldw	r2,-4(fp)
8114735c:	1884983a 	sll	r2,r3,r2
81147360:	1007883a 	mov	r3,r2
81147364:	e0bffd17 	ldw	r2,-12(fp)
81147368:	1884703a 	and	r2,r3,r2
8114736c:	1004c03a 	cmpne	r2,r2,zero
81147370:	10803fcc 	andi	r2,r2,255
}
81147374:	e037883a 	mov	sp,fp
81147378:	df000017 	ldw	fp,0(sp)
8114737c:	dec00104 	addi	sp,sp,4
81147380:	f800283a 	ret

81147384 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81147384:	defff504 	addi	sp,sp,-44
81147388:	de00012e 	bgeu	sp,et,81147390 <alt_iic_isr_register+0xc>
8114738c:	003b68fa 	trap	3
81147390:	dfc00a15 	stw	ra,40(sp)
81147394:	df000915 	stw	fp,36(sp)
81147398:	df000904 	addi	fp,sp,36
8114739c:	e13ffc15 	stw	r4,-16(fp)
811473a0:	e17ffd15 	stw	r5,-12(fp)
811473a4:	e1bffe15 	stw	r6,-8(fp)
811473a8:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
811473ac:	00bffa84 	movi	r2,-22
811473b0:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
811473b4:	e0bffd17 	ldw	r2,-12(fp)
811473b8:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
811473bc:	e0bff817 	ldw	r2,-32(fp)
811473c0:	10800808 	cmpgei	r2,r2,32
811473c4:	1000271e 	bne	r2,zero,81147464 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811473c8:	0005303a 	rdctl	r2,status
811473cc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811473d0:	e0fffb17 	ldw	r3,-20(fp)
811473d4:	00bfff84 	movi	r2,-2
811473d8:	1884703a 	and	r2,r3,r2
811473dc:	1001703a 	wrctl	status,r2
  
  return context;
811473e0:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
811473e4:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
811473e8:	00a045f4 	movhi	r2,33047
811473ec:	10a5e604 	addi	r2,r2,-26728
811473f0:	e0fff817 	ldw	r3,-32(fp)
811473f4:	180690fa 	slli	r3,r3,3
811473f8:	10c5883a 	add	r2,r2,r3
811473fc:	e0fffe17 	ldw	r3,-8(fp)
81147400:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
81147404:	00a045f4 	movhi	r2,33047
81147408:	10a5e604 	addi	r2,r2,-26728
8114740c:	e0fff817 	ldw	r3,-32(fp)
81147410:	180690fa 	slli	r3,r3,3
81147414:	10c5883a 	add	r2,r2,r3
81147418:	10800104 	addi	r2,r2,4
8114741c:	e0ffff17 	ldw	r3,-4(fp)
81147420:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
81147424:	e0bffe17 	ldw	r2,-8(fp)
81147428:	10000526 	beq	r2,zero,81147440 <alt_iic_isr_register+0xbc>
8114742c:	e0bff817 	ldw	r2,-32(fp)
81147430:	100b883a 	mov	r5,r2
81147434:	e13ffc17 	ldw	r4,-16(fp)
81147438:	114720c0 	call	8114720c <alt_ic_irq_enable>
8114743c:	00000406 	br	81147450 <alt_iic_isr_register+0xcc>
81147440:	e0bff817 	ldw	r2,-32(fp)
81147444:	100b883a 	mov	r5,r2
81147448:	e13ffc17 	ldw	r4,-16(fp)
8114744c:	114729c0 	call	8114729c <alt_ic_irq_disable>
81147450:	e0bff715 	stw	r2,-36(fp)
81147454:	e0bffa17 	ldw	r2,-24(fp)
81147458:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114745c:	e0bff917 	ldw	r2,-28(fp)
81147460:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
81147464:	e0bff717 	ldw	r2,-36(fp)
}
81147468:	e037883a 	mov	sp,fp
8114746c:	dfc00117 	ldw	ra,4(sp)
81147470:	df000017 	ldw	fp,0(sp)
81147474:	dec00204 	addi	sp,sp,8
81147478:	f800283a 	ret

8114747c <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8114747c:	defff904 	addi	sp,sp,-28
81147480:	de00012e 	bgeu	sp,et,81147488 <alt_open_fd+0xc>
81147484:	003b68fa 	trap	3
81147488:	dfc00615 	stw	ra,24(sp)
8114748c:	df000515 	stw	fp,20(sp)
81147490:	df000504 	addi	fp,sp,20
81147494:	e13ffc15 	stw	r4,-16(fp)
81147498:	e17ffd15 	stw	r5,-12(fp)
8114749c:	e1bffe15 	stw	r6,-8(fp)
811474a0:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
811474a4:	e1bfff17 	ldw	r6,-4(fp)
811474a8:	e17ffe17 	ldw	r5,-8(fp)
811474ac:	e13ffd17 	ldw	r4,-12(fp)
811474b0:	113432c0 	call	8113432c <open>
811474b4:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
811474b8:	e0bffb17 	ldw	r2,-20(fp)
811474bc:	10001c16 	blt	r2,zero,81147530 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
811474c0:	00a04574 	movhi	r2,33045
811474c4:	10b84b04 	addi	r2,r2,-7892
811474c8:	e0fffb17 	ldw	r3,-20(fp)
811474cc:	18c00324 	muli	r3,r3,12
811474d0:	10c5883a 	add	r2,r2,r3
811474d4:	10c00017 	ldw	r3,0(r2)
811474d8:	e0bffc17 	ldw	r2,-16(fp)
811474dc:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
811474e0:	00a04574 	movhi	r2,33045
811474e4:	10b84b04 	addi	r2,r2,-7892
811474e8:	e0fffb17 	ldw	r3,-20(fp)
811474ec:	18c00324 	muli	r3,r3,12
811474f0:	10c5883a 	add	r2,r2,r3
811474f4:	10800104 	addi	r2,r2,4
811474f8:	10c00017 	ldw	r3,0(r2)
811474fc:	e0bffc17 	ldw	r2,-16(fp)
81147500:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
81147504:	00a04574 	movhi	r2,33045
81147508:	10b84b04 	addi	r2,r2,-7892
8114750c:	e0fffb17 	ldw	r3,-20(fp)
81147510:	18c00324 	muli	r3,r3,12
81147514:	10c5883a 	add	r2,r2,r3
81147518:	10800204 	addi	r2,r2,8
8114751c:	10c00017 	ldw	r3,0(r2)
81147520:	e0bffc17 	ldw	r2,-16(fp)
81147524:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
81147528:	e13ffb17 	ldw	r4,-20(fp)
8114752c:	11345d00 	call	811345d0 <alt_release_fd>
  }
} 
81147530:	0001883a 	nop
81147534:	e037883a 	mov	sp,fp
81147538:	dfc00117 	ldw	ra,4(sp)
8114753c:	df000017 	ldw	fp,0(sp)
81147540:	dec00204 	addi	sp,sp,8
81147544:	f800283a 	ret

81147548 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
81147548:	defffb04 	addi	sp,sp,-20
8114754c:	de00012e 	bgeu	sp,et,81147554 <alt_io_redirect+0xc>
81147550:	003b68fa 	trap	3
81147554:	dfc00415 	stw	ra,16(sp)
81147558:	df000315 	stw	fp,12(sp)
8114755c:	df000304 	addi	fp,sp,12
81147560:	e13ffd15 	stw	r4,-12(fp)
81147564:	e17ffe15 	stw	r5,-8(fp)
81147568:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8114756c:	01c07fc4 	movi	r7,511
81147570:	01800044 	movi	r6,1
81147574:	e17ffd17 	ldw	r5,-12(fp)
81147578:	01204574 	movhi	r4,33045
8114757c:	21384e04 	addi	r4,r4,-7880
81147580:	114747c0 	call	8114747c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
81147584:	01c07fc4 	movi	r7,511
81147588:	000d883a 	mov	r6,zero
8114758c:	e17ffe17 	ldw	r5,-8(fp)
81147590:	01204574 	movhi	r4,33045
81147594:	21384b04 	addi	r4,r4,-7892
81147598:	114747c0 	call	8114747c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8114759c:	01c07fc4 	movi	r7,511
811475a0:	01800044 	movi	r6,1
811475a4:	e17fff17 	ldw	r5,-4(fp)
811475a8:	01204574 	movhi	r4,33045
811475ac:	21385104 	addi	r4,r4,-7868
811475b0:	114747c0 	call	8114747c <alt_open_fd>
}  
811475b4:	0001883a 	nop
811475b8:	e037883a 	mov	sp,fp
811475bc:	dfc00117 	ldw	ra,4(sp)
811475c0:	df000017 	ldw	fp,0(sp)
811475c4:	dec00204 	addi	sp,sp,8
811475c8:	f800283a 	ret

811475cc <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
811475cc:	defff204 	addi	sp,sp,-56
811475d0:	de00012e 	bgeu	sp,et,811475d8 <alt_printf+0xc>
811475d4:	003b68fa 	trap	3
811475d8:	dfc00a15 	stw	ra,40(sp)
811475dc:	df000915 	stw	fp,36(sp)
811475e0:	df000904 	addi	fp,sp,36
811475e4:	e13fff15 	stw	r4,-4(fp)
811475e8:	e1400215 	stw	r5,8(fp)
811475ec:	e1800315 	stw	r6,12(fp)
811475f0:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
811475f4:	e0800204 	addi	r2,fp,8
811475f8:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
811475fc:	e0bfff17 	ldw	r2,-4(fp)
81147600:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
81147604:	00006f06 	br	811477c4 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
81147608:	e0bff807 	ldb	r2,-32(fp)
8114760c:	10800960 	cmpeqi	r2,r2,37
81147610:	1000041e 	bne	r2,zero,81147624 <alt_printf+0x58>
        {
            alt_putchar(c);
81147614:	e0bff807 	ldb	r2,-32(fp)
81147618:	1009883a 	mov	r4,r2
8114761c:	11478000 	call	81147800 <alt_putchar>
81147620:	00006806 	br	811477c4 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
81147624:	e0bff717 	ldw	r2,-36(fp)
81147628:	10c00044 	addi	r3,r2,1
8114762c:	e0fff715 	stw	r3,-36(fp)
81147630:	10800003 	ldbu	r2,0(r2)
81147634:	e0bff805 	stb	r2,-32(fp)
81147638:	e0bff807 	ldb	r2,-32(fp)
8114763c:	10006926 	beq	r2,zero,811477e4 <alt_printf+0x218>
            {
                if (c == '%')
81147640:	e0bff807 	ldb	r2,-32(fp)
81147644:	10800958 	cmpnei	r2,r2,37
81147648:	1000041e 	bne	r2,zero,8114765c <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114764c:	e0bff807 	ldb	r2,-32(fp)
81147650:	1009883a 	mov	r4,r2
81147654:	11478000 	call	81147800 <alt_putchar>
81147658:	00005a06 	br	811477c4 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114765c:	e0bff807 	ldb	r2,-32(fp)
81147660:	108018d8 	cmpnei	r2,r2,99
81147664:	1000081e 	bne	r2,zero,81147688 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81147668:	e0bffe17 	ldw	r2,-8(fp)
8114766c:	10c00104 	addi	r3,r2,4
81147670:	e0fffe15 	stw	r3,-8(fp)
81147674:	10800017 	ldw	r2,0(r2)
81147678:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114767c:	e13ffd17 	ldw	r4,-12(fp)
81147680:	11478000 	call	81147800 <alt_putchar>
81147684:	00004f06 	br	811477c4 <alt_printf+0x1f8>
                }
                else if (c == 'x')
81147688:	e0bff807 	ldb	r2,-32(fp)
8114768c:	10801e18 	cmpnei	r2,r2,120
81147690:	1000341e 	bne	r2,zero,81147764 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
81147694:	e0bffe17 	ldw	r2,-8(fp)
81147698:	10c00104 	addi	r3,r2,4
8114769c:	e0fffe15 	stw	r3,-8(fp)
811476a0:	10800017 	ldw	r2,0(r2)
811476a4:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
811476a8:	e0bffb17 	ldw	r2,-20(fp)
811476ac:	1000031e 	bne	r2,zero,811476bc <alt_printf+0xf0>
                    {
                        alt_putchar('0');
811476b0:	01000c04 	movi	r4,48
811476b4:	11478000 	call	81147800 <alt_putchar>
                        continue;
811476b8:	00004206 	br	811477c4 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
811476bc:	00800704 	movi	r2,28
811476c0:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
811476c4:	00000306 	br	811476d4 <alt_printf+0x108>
                        digit_shift -= 4;
811476c8:	e0bff917 	ldw	r2,-28(fp)
811476cc:	10bfff04 	addi	r2,r2,-4
811476d0:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
811476d4:	00c003c4 	movi	r3,15
811476d8:	e0bff917 	ldw	r2,-28(fp)
811476dc:	1884983a 	sll	r2,r3,r2
811476e0:	1007883a 	mov	r3,r2
811476e4:	e0bffb17 	ldw	r2,-20(fp)
811476e8:	1884703a 	and	r2,r3,r2
811476ec:	103ff626 	beq	r2,zero,811476c8 <__reset+0xfb1276c8>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
811476f0:	00001906 	br	81147758 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
811476f4:	00c003c4 	movi	r3,15
811476f8:	e0bff917 	ldw	r2,-28(fp)
811476fc:	1884983a 	sll	r2,r3,r2
81147700:	1007883a 	mov	r3,r2
81147704:	e0bffb17 	ldw	r2,-20(fp)
81147708:	1886703a 	and	r3,r3,r2
8114770c:	e0bff917 	ldw	r2,-28(fp)
81147710:	1884d83a 	srl	r2,r3,r2
81147714:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
81147718:	e0bffc17 	ldw	r2,-16(fp)
8114771c:	108002a8 	cmpgeui	r2,r2,10
81147720:	1000041e 	bne	r2,zero,81147734 <alt_printf+0x168>
                            c = '0' + digit;
81147724:	e0bffc17 	ldw	r2,-16(fp)
81147728:	10800c04 	addi	r2,r2,48
8114772c:	e0bff805 	stb	r2,-32(fp)
81147730:	00000306 	br	81147740 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
81147734:	e0bffc17 	ldw	r2,-16(fp)
81147738:	108015c4 	addi	r2,r2,87
8114773c:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81147740:	e0bff807 	ldb	r2,-32(fp)
81147744:	1009883a 	mov	r4,r2
81147748:	11478000 	call	81147800 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114774c:	e0bff917 	ldw	r2,-28(fp)
81147750:	10bfff04 	addi	r2,r2,-4
81147754:	e0bff915 	stw	r2,-28(fp)
81147758:	e0bff917 	ldw	r2,-28(fp)
8114775c:	103fe50e 	bge	r2,zero,811476f4 <__reset+0xfb1276f4>
81147760:	00001806 	br	811477c4 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
81147764:	e0bff807 	ldb	r2,-32(fp)
81147768:	10801cd8 	cmpnei	r2,r2,115
8114776c:	1000151e 	bne	r2,zero,811477c4 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81147770:	e0bffe17 	ldw	r2,-8(fp)
81147774:	10c00104 	addi	r3,r2,4
81147778:	e0fffe15 	stw	r3,-8(fp)
8114777c:	10800017 	ldw	r2,0(r2)
81147780:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
81147784:	00000906 	br	811477ac <alt_printf+0x1e0>
                      alt_putchar(*s++);
81147788:	e0bffa17 	ldw	r2,-24(fp)
8114778c:	10c00044 	addi	r3,r2,1
81147790:	e0fffa15 	stw	r3,-24(fp)
81147794:	10800003 	ldbu	r2,0(r2)
81147798:	10803fcc 	andi	r2,r2,255
8114779c:	1080201c 	xori	r2,r2,128
811477a0:	10bfe004 	addi	r2,r2,-128
811477a4:	1009883a 	mov	r4,r2
811477a8:	11478000 	call	81147800 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
811477ac:	e0bffa17 	ldw	r2,-24(fp)
811477b0:	10800003 	ldbu	r2,0(r2)
811477b4:	10803fcc 	andi	r2,r2,255
811477b8:	1080201c 	xori	r2,r2,128
811477bc:	10bfe004 	addi	r2,r2,-128
811477c0:	103ff11e 	bne	r2,zero,81147788 <__reset+0xfb127788>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
811477c4:	e0bff717 	ldw	r2,-36(fp)
811477c8:	10c00044 	addi	r3,r2,1
811477cc:	e0fff715 	stw	r3,-36(fp)
811477d0:	10800003 	ldbu	r2,0(r2)
811477d4:	e0bff805 	stb	r2,-32(fp)
811477d8:	e0bff807 	ldb	r2,-32(fp)
811477dc:	103f8a1e 	bne	r2,zero,81147608 <__reset+0xfb127608>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
811477e0:	00000106 	br	811477e8 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
811477e4:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
811477e8:	0001883a 	nop
811477ec:	e037883a 	mov	sp,fp
811477f0:	dfc00117 	ldw	ra,4(sp)
811477f4:	df000017 	ldw	fp,0(sp)
811477f8:	dec00504 	addi	sp,sp,20
811477fc:	f800283a 	ret

81147800 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81147800:	defffd04 	addi	sp,sp,-12
81147804:	de00012e 	bgeu	sp,et,8114780c <alt_putchar+0xc>
81147808:	003b68fa 	trap	3
8114780c:	dfc00215 	stw	ra,8(sp)
81147810:	df000115 	stw	fp,4(sp)
81147814:	df000104 	addi	fp,sp,4
81147818:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114781c:	d0a00517 	ldw	r2,-32748(gp)
81147820:	10800217 	ldw	r2,8(r2)
81147824:	100b883a 	mov	r5,r2
81147828:	e13fff17 	ldw	r4,-4(fp)
8114782c:	111eac80 	call	8111eac8 <putc>
#endif
#endif
}
81147830:	e037883a 	mov	sp,fp
81147834:	dfc00117 	ldw	ra,4(sp)
81147838:	df000017 	ldw	fp,0(sp)
8114783c:	dec00204 	addi	sp,sp,8
81147840:	f800283a 	ret

81147844 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
81147844:	deffff04 	addi	sp,sp,-4
81147848:	de00012e 	bgeu	sp,et,81147850 <altera_nios2_gen2_irq_init+0xc>
8114784c:	003b68fa 	trap	3
81147850:	df000015 	stw	fp,0(sp)
81147854:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81147858:	000170fa 	wrctl	ienable,zero
}
8114785c:	0001883a 	nop
81147860:	e037883a 	mov	sp,fp
81147864:	df000017 	ldw	fp,0(sp)
81147868:	dec00104 	addi	sp,sp,4
8114786c:	f800283a 	ret

81147870 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81147870:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
81147874:	de002436 	bltu	sp,et,81147908 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81147878:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114787c:	d120a117 	ldw	r4,-32124(gp)

      stw ra,  0(sp)
81147880:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
81147884:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81147888:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114788c:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81147890:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
81147894:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81147898:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114789c:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
811478a0:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
811478a4:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
811478a8:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
811478ac:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
811478b0:	1147b0c0 	call	81147b0c <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
811478b4:	d1209b17 	ldw	r4,-32148(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
811478b8:	d1609287 	ldb	r5,-32182(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
811478bc:	d120a115 	stw	r4,-32124(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
811478c0:	d16092c5 	stb	r5,-32181(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
811478c4:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
811478c8:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
811478cc:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
811478d0:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
811478d4:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
811478d8:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
811478dc:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
811478e0:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
811478e4:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
811478e8:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
811478ec:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
811478f0:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
811478f4:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
811478f8:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
811478fc:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81147900:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
81147904:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81147908:	003da0fa 	break	3

8114790c <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114790c:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81147910:	047fff84 	movi	r17,-2
      and   r18, r18, r17
81147914:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81147918:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114791c:	1147b0c0 	call	81147b0c <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81147920:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
81147924:	d4a09005 	stb	r18,-32192(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81147928:	003fe206 	br	811478b4 <__reset+0xfb1278b4>

8114792c <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114792c:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81147930:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
81147934:	10800054 	ori	r2,r2,1
      wrctl status, r2
81147938:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114793c:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81147940:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
81147944:	dec00204 	addi	sp,sp,8

      callr r2
81147948:	103ee83a 	callr	r2

      nop
8114794c:	0001883a 	nop

81147950 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81147950:	defff704 	addi	sp,sp,-36
81147954:	de00012e 	bgeu	sp,et,8114795c <OSTaskStkInit+0xc>
81147958:	003b68fa 	trap	3
8114795c:	dfc00815 	stw	ra,32(sp)
81147960:	df000715 	stw	fp,28(sp)
81147964:	df000704 	addi	fp,sp,28
81147968:	e13ffc15 	stw	r4,-16(fp)
8114796c:	e17ffd15 	stw	r5,-12(fp)
81147970:	e1bffe15 	stw	r6,-8(fp)
81147974:	3805883a 	mov	r2,r7
81147978:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114797c:	e0fffe17 	ldw	r3,-8(fp)
81147980:	00bfff04 	movi	r2,-4
81147984:	1884703a 	and	r2,r3,r2
81147988:	10bef704 	addi	r2,r2,-1060
8114798c:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81147990:	01810904 	movi	r6,1060
81147994:	000b883a 	mov	r5,zero
81147998:	e13ff917 	ldw	r4,-28(fp)
8114799c:	111e8140 	call	8111e814 <memset>
811479a0:	e0bff917 	ldw	r2,-28(fp)
811479a4:	10c0bb04 	addi	r3,r2,748
811479a8:	e0bff917 	ldw	r2,-28(fp)
811479ac:	10c00115 	stw	r3,4(r2)
811479b0:	e0bff917 	ldw	r2,-28(fp)
811479b4:	10c0d504 	addi	r3,r2,852
811479b8:	e0bff917 	ldw	r2,-28(fp)
811479bc:	10c00215 	stw	r3,8(r2)
811479c0:	e0bff917 	ldw	r2,-28(fp)
811479c4:	10c0ef04 	addi	r3,r2,956
811479c8:	e0bff917 	ldw	r2,-28(fp)
811479cc:	10c00315 	stw	r3,12(r2)
811479d0:	e0fff917 	ldw	r3,-28(fp)
811479d4:	00a04574 	movhi	r2,33045
811479d8:	10b5e404 	addi	r2,r2,-10352
811479dc:	18800d15 	stw	r2,52(r3)
811479e0:	e0bff917 	ldw	r2,-28(fp)
811479e4:	00c00044 	movi	r3,1
811479e8:	10c02915 	stw	r3,164(r2)
811479ec:	10002a15 	stw	zero,168(r2)
811479f0:	e0bff917 	ldw	r2,-28(fp)
811479f4:	00ccc384 	movi	r3,13070
811479f8:	10c02b0d 	sth	r3,172(r2)
811479fc:	e0bff917 	ldw	r2,-28(fp)
81147a00:	00eaf344 	movi	r3,-21555
81147a04:	10c02b8d 	sth	r3,174(r2)
81147a08:	e0bff917 	ldw	r2,-28(fp)
81147a0c:	00c48d04 	movi	r3,4660
81147a10:	10c02c0d 	sth	r3,176(r2)
81147a14:	e0bff917 	ldw	r2,-28(fp)
81147a18:	00f99b44 	movi	r3,-6547
81147a1c:	10c02c8d 	sth	r3,178(r2)
81147a20:	e0bff917 	ldw	r2,-28(fp)
81147a24:	00f7bb04 	movi	r3,-8468
81147a28:	10c02d0d 	sth	r3,180(r2)
81147a2c:	e0bff917 	ldw	r2,-28(fp)
81147a30:	00c00144 	movi	r3,5
81147a34:	10c02d8d 	sth	r3,182(r2)
81147a38:	e0bff917 	ldw	r2,-28(fp)
81147a3c:	00c002c4 	movi	r3,11
81147a40:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
81147a44:	e0bff917 	ldw	r2,-28(fp)
81147a48:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
81147a4c:	e0bffa17 	ldw	r2,-24(fp)
81147a50:	10bff304 	addi	r2,r2,-52
81147a54:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81147a58:	e0bffb17 	ldw	r2,-20(fp)
81147a5c:	10800c04 	addi	r2,r2,48
81147a60:	e0fffc17 	ldw	r3,-16(fp)
81147a64:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81147a68:	e0bffb17 	ldw	r2,-20(fp)
81147a6c:	10800b04 	addi	r2,r2,44
81147a70:	e0fffd17 	ldw	r3,-12(fp)
81147a74:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81147a78:	e0bffb17 	ldw	r2,-20(fp)
81147a7c:	10800a04 	addi	r2,r2,40
81147a80:	e0fff917 	ldw	r3,-28(fp)
81147a84:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81147a88:	00a04534 	movhi	r2,33044
81147a8c:	109e4b04 	addi	r2,r2,31020
81147a90:	10c00104 	addi	r3,r2,4
81147a94:	e0bffb17 	ldw	r2,-20(fp)
81147a98:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
81147a9c:	e0bffb17 	ldw	r2,-20(fp)
}
81147aa0:	e037883a 	mov	sp,fp
81147aa4:	dfc00117 	ldw	ra,4(sp)
81147aa8:	df000017 	ldw	fp,0(sp)
81147aac:	dec00204 	addi	sp,sp,8
81147ab0:	f800283a 	ret

81147ab4 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
81147ab4:	defffe04 	addi	sp,sp,-8
81147ab8:	de00012e 	bgeu	sp,et,81147ac0 <OSTaskCreateHook+0xc>
81147abc:	003b68fa 	trap	3
81147ac0:	df000115 	stw	fp,4(sp)
81147ac4:	df000104 	addi	fp,sp,4
81147ac8:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
81147acc:	0001883a 	nop
81147ad0:	e037883a 	mov	sp,fp
81147ad4:	df000017 	ldw	fp,0(sp)
81147ad8:	dec00104 	addi	sp,sp,4
81147adc:	f800283a 	ret

81147ae0 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
81147ae0:	defffe04 	addi	sp,sp,-8
81147ae4:	de00012e 	bgeu	sp,et,81147aec <OSTaskDelHook+0xc>
81147ae8:	003b68fa 	trap	3
81147aec:	df000115 	stw	fp,4(sp)
81147af0:	df000104 	addi	fp,sp,4
81147af4:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
81147af8:	0001883a 	nop
81147afc:	e037883a 	mov	sp,fp
81147b00:	df000017 	ldw	fp,0(sp)
81147b04:	dec00104 	addi	sp,sp,4
81147b08:	f800283a 	ret

81147b0c <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
81147b0c:	deffff04 	addi	sp,sp,-4
81147b10:	de00012e 	bgeu	sp,et,81147b18 <OSTaskSwHook+0xc>
81147b14:	003b68fa 	trap	3
81147b18:	df000015 	stw	fp,0(sp)
81147b1c:	d839883a 	mov	fp,sp
}
81147b20:	0001883a 	nop
81147b24:	e037883a 	mov	sp,fp
81147b28:	df000017 	ldw	fp,0(sp)
81147b2c:	dec00104 	addi	sp,sp,4
81147b30:	f800283a 	ret

81147b34 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
81147b34:	deffff04 	addi	sp,sp,-4
81147b38:	de00012e 	bgeu	sp,et,81147b40 <OSTaskStatHook+0xc>
81147b3c:	003b68fa 	trap	3
81147b40:	df000015 	stw	fp,0(sp)
81147b44:	d839883a 	mov	fp,sp
}
81147b48:	0001883a 	nop
81147b4c:	e037883a 	mov	sp,fp
81147b50:	df000017 	ldw	fp,0(sp)
81147b54:	dec00104 	addi	sp,sp,4
81147b58:	f800283a 	ret

81147b5c <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81147b5c:	defffe04 	addi	sp,sp,-8
81147b60:	de00012e 	bgeu	sp,et,81147b68 <OSTimeTickHook+0xc>
81147b64:	003b68fa 	trap	3
81147b68:	dfc00115 	stw	ra,4(sp)
81147b6c:	df000015 	stw	fp,0(sp)
81147b70:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
81147b74:	d0a0b50b 	ldhu	r2,-32044(gp)
81147b78:	10800044 	addi	r2,r2,1
81147b7c:	d0a0b50d 	sth	r2,-32044(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81147b80:	d0a0b50b 	ldhu	r2,-32044(gp)
81147b84:	10bfffcc 	andi	r2,r2,65535
81147b88:	10807d30 	cmpltui	r2,r2,500
81147b8c:	1000021e 	bne	r2,zero,81147b98 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81147b90:	d020b50d 	sth	zero,-32044(gp)
        OSTmrSignal();
81147b94:	113e4ac0 	call	8113e4ac <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
81147b98:	0001883a 	nop
81147b9c:	e037883a 	mov	sp,fp
81147ba0:	dfc00117 	ldw	ra,4(sp)
81147ba4:	df000017 	ldw	fp,0(sp)
81147ba8:	dec00204 	addi	sp,sp,8
81147bac:	f800283a 	ret

81147bb0 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
81147bb0:	deffff04 	addi	sp,sp,-4
81147bb4:	de00012e 	bgeu	sp,et,81147bbc <OSInitHookBegin+0xc>
81147bb8:	003b68fa 	trap	3
81147bbc:	df000015 	stw	fp,0(sp)
81147bc0:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
81147bc4:	d020b50d 	sth	zero,-32044(gp)
#endif
}
81147bc8:	0001883a 	nop
81147bcc:	e037883a 	mov	sp,fp
81147bd0:	df000017 	ldw	fp,0(sp)
81147bd4:	dec00104 	addi	sp,sp,4
81147bd8:	f800283a 	ret

81147bdc <OSInitHookEnd>:

void OSInitHookEnd(void)
{
81147bdc:	deffff04 	addi	sp,sp,-4
81147be0:	de00012e 	bgeu	sp,et,81147be8 <OSInitHookEnd+0xc>
81147be4:	003b68fa 	trap	3
81147be8:	df000015 	stw	fp,0(sp)
81147bec:	d839883a 	mov	fp,sp
}
81147bf0:	0001883a 	nop
81147bf4:	e037883a 	mov	sp,fp
81147bf8:	df000017 	ldw	fp,0(sp)
81147bfc:	dec00104 	addi	sp,sp,4
81147c00:	f800283a 	ret

81147c04 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
81147c04:	deffff04 	addi	sp,sp,-4
81147c08:	de00012e 	bgeu	sp,et,81147c10 <OSTaskIdleHook+0xc>
81147c0c:	003b68fa 	trap	3
81147c10:	df000015 	stw	fp,0(sp)
81147c14:	d839883a 	mov	fp,sp
}
81147c18:	0001883a 	nop
81147c1c:	e037883a 	mov	sp,fp
81147c20:	df000017 	ldw	fp,0(sp)
81147c24:	dec00104 	addi	sp,sp,4
81147c28:	f800283a 	ret

81147c2c <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
81147c2c:	defffe04 	addi	sp,sp,-8
81147c30:	de00012e 	bgeu	sp,et,81147c38 <OSTCBInitHook+0xc>
81147c34:	003b68fa 	trap	3
81147c38:	df000115 	stw	fp,4(sp)
81147c3c:	df000104 	addi	fp,sp,4
81147c40:	e13fff15 	stw	r4,-4(fp)
}
81147c44:	0001883a 	nop
81147c48:	e037883a 	mov	sp,fp
81147c4c:	df000017 	ldw	fp,0(sp)
81147c50:	dec00104 	addi	sp,sp,4
81147c54:	f800283a 	ret

81147c58 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
81147c58:	defffe04 	addi	sp,sp,-8
81147c5c:	de00012e 	bgeu	sp,et,81147c64 <alt_exception_cause_generated_bad_addr+0xc>
81147c60:	003b68fa 	trap	3
81147c64:	df000115 	stw	fp,4(sp)
81147c68:	df000104 	addi	fp,sp,4
81147c6c:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
81147c70:	e0bfff17 	ldw	r2,-4(fp)
81147c74:	10bffe84 	addi	r2,r2,-6
81147c78:	10c00428 	cmpgeui	r3,r2,16
81147c7c:	18001a1e 	bne	r3,zero,81147ce8 <alt_exception_cause_generated_bad_addr+0x90>
81147c80:	100690ba 	slli	r3,r2,2
81147c84:	00a04534 	movhi	r2,33044
81147c88:	109f2604 	addi	r2,r2,31896
81147c8c:	1885883a 	add	r2,r3,r2
81147c90:	10800017 	ldw	r2,0(r2)
81147c94:	1000683a 	jmp	r2
81147c98:	81147cd8 	cmpnei	r4,r16,20979
81147c9c:	81147cd8 	cmpnei	r4,r16,20979
81147ca0:	81147ce8 	cmpgeui	r4,r16,20979
81147ca4:	81147ce8 	cmpgeui	r4,r16,20979
81147ca8:	81147ce8 	cmpgeui	r4,r16,20979
81147cac:	81147cd8 	cmpnei	r4,r16,20979
81147cb0:	81147ce0 	cmpeqi	r4,r16,20979
81147cb4:	81147ce8 	cmpgeui	r4,r16,20979
81147cb8:	81147cd8 	cmpnei	r4,r16,20979
81147cbc:	81147cd8 	cmpnei	r4,r16,20979
81147cc0:	81147ce8 	cmpgeui	r4,r16,20979
81147cc4:	81147cd8 	cmpnei	r4,r16,20979
81147cc8:	81147ce0 	cmpeqi	r4,r16,20979
81147ccc:	81147ce8 	cmpgeui	r4,r16,20979
81147cd0:	81147ce8 	cmpgeui	r4,r16,20979
81147cd4:	81147cd8 	cmpnei	r4,r16,20979
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
81147cd8:	00800044 	movi	r2,1
81147cdc:	00000306 	br	81147cec <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
81147ce0:	0005883a 	mov	r2,zero
81147ce4:	00000106 	br	81147cec <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
81147ce8:	0005883a 	mov	r2,zero
  }
}
81147cec:	e037883a 	mov	sp,fp
81147cf0:	df000017 	ldw	fp,0(sp)
81147cf4:	dec00104 	addi	sp,sp,4
81147cf8:	f800283a 	ret

81147cfc <exit>:
81147cfc:	defffe04 	addi	sp,sp,-8
81147d00:	000b883a 	mov	r5,zero
81147d04:	de00012e 	bgeu	sp,et,81147d0c <exit+0x10>
81147d08:	003b68fa 	trap	3
81147d0c:	dc000015 	stw	r16,0(sp)
81147d10:	dfc00115 	stw	ra,4(sp)
81147d14:	2021883a 	mov	r16,r4
81147d18:	1147ea40 	call	81147ea4 <__call_exitprocs>
81147d1c:	00a04574 	movhi	r2,33045
81147d20:	10bd6204 	addi	r2,r2,-2680
81147d24:	11000017 	ldw	r4,0(r2)
81147d28:	20800f17 	ldw	r2,60(r4)
81147d2c:	10000126 	beq	r2,zero,81147d34 <exit+0x38>
81147d30:	103ee83a 	callr	r2
81147d34:	8009883a 	mov	r4,r16
81147d38:	114802c0 	call	8114802c <_exit>

81147d3c <memcmp>:
81147d3c:	01c000c4 	movi	r7,3
81147d40:	3980192e 	bgeu	r7,r6,81147da8 <memcmp+0x6c>
81147d44:	2144b03a 	or	r2,r4,r5
81147d48:	11c4703a 	and	r2,r2,r7
81147d4c:	10000f26 	beq	r2,zero,81147d8c <memcmp+0x50>
81147d50:	20800003 	ldbu	r2,0(r4)
81147d54:	28c00003 	ldbu	r3,0(r5)
81147d58:	10c0151e 	bne	r2,r3,81147db0 <memcmp+0x74>
81147d5c:	31bfff84 	addi	r6,r6,-2
81147d60:	01ffffc4 	movi	r7,-1
81147d64:	00000406 	br	81147d78 <memcmp+0x3c>
81147d68:	20800003 	ldbu	r2,0(r4)
81147d6c:	28c00003 	ldbu	r3,0(r5)
81147d70:	31bfffc4 	addi	r6,r6,-1
81147d74:	10c00e1e 	bne	r2,r3,81147db0 <memcmp+0x74>
81147d78:	21000044 	addi	r4,r4,1
81147d7c:	29400044 	addi	r5,r5,1
81147d80:	31fff91e 	bne	r6,r7,81147d68 <__reset+0xfb127d68>
81147d84:	0005883a 	mov	r2,zero
81147d88:	f800283a 	ret
81147d8c:	20c00017 	ldw	r3,0(r4)
81147d90:	28800017 	ldw	r2,0(r5)
81147d94:	18bfee1e 	bne	r3,r2,81147d50 <__reset+0xfb127d50>
81147d98:	31bfff04 	addi	r6,r6,-4
81147d9c:	21000104 	addi	r4,r4,4
81147da0:	29400104 	addi	r5,r5,4
81147da4:	39bff936 	bltu	r7,r6,81147d8c <__reset+0xfb127d8c>
81147da8:	303fe91e 	bne	r6,zero,81147d50 <__reset+0xfb127d50>
81147dac:	003ff506 	br	81147d84 <__reset+0xfb127d84>
81147db0:	10c5c83a 	sub	r2,r2,r3
81147db4:	f800283a 	ret

81147db8 <strncpy>:
81147db8:	2906b03a 	or	r3,r5,r4
81147dbc:	18c000cc 	andi	r3,r3,3
81147dc0:	2005883a 	mov	r2,r4
81147dc4:	18002c1e 	bne	r3,zero,81147e78 <strncpy+0xc0>
81147dc8:	010000c4 	movi	r4,3
81147dcc:	21802a2e 	bgeu	r4,r6,81147e78 <strncpy+0xc0>
81147dd0:	033fbff4 	movhi	r12,65279
81147dd4:	02e02074 	movhi	r11,32897
81147dd8:	633fbfc4 	addi	r12,r12,-257
81147ddc:	5ae02004 	addi	r11,r11,-32640
81147de0:	100f883a 	mov	r7,r2
81147de4:	2a000017 	ldw	r8,0(r5)
81147de8:	3815883a 	mov	r10,r7
81147dec:	4313883a 	add	r9,r8,r12
81147df0:	0206303a 	nor	r3,zero,r8
81147df4:	48c6703a 	and	r3,r9,r3
81147df8:	1ac6703a 	and	r3,r3,r11
81147dfc:	1800261e 	bne	r3,zero,81147e98 <strncpy+0xe0>
81147e00:	39c00104 	addi	r7,r7,4
81147e04:	52000015 	stw	r8,0(r10)
81147e08:	31bfff04 	addi	r6,r6,-4
81147e0c:	3811883a 	mov	r8,r7
81147e10:	29400104 	addi	r5,r5,4
81147e14:	21bff336 	bltu	r4,r6,81147de4 <__reset+0xfb127de4>
81147e18:	30001e26 	beq	r6,zero,81147e94 <strncpy+0xdc>
81147e1c:	29c00003 	ldbu	r7,0(r5)
81147e20:	31bfffc4 	addi	r6,r6,-1
81147e24:	40c00044 	addi	r3,r8,1
81147e28:	41c00005 	stb	r7,0(r8)
81147e2c:	39c03fcc 	andi	r7,r7,255
81147e30:	39c0201c 	xori	r7,r7,128
81147e34:	39ffe004 	addi	r7,r7,-128
81147e38:	29400044 	addi	r5,r5,1
81147e3c:	38001026 	beq	r7,zero,81147e80 <strncpy+0xc8>
81147e40:	1811883a 	mov	r8,r3
81147e44:	00000906 	br	81147e6c <strncpy+0xb4>
81147e48:	29c00003 	ldbu	r7,0(r5)
81147e4c:	31bfffc4 	addi	r6,r6,-1
81147e50:	29400044 	addi	r5,r5,1
81147e54:	41c00005 	stb	r7,0(r8)
81147e58:	39c03fcc 	andi	r7,r7,255
81147e5c:	39c0201c 	xori	r7,r7,128
81147e60:	39ffe004 	addi	r7,r7,-128
81147e64:	1811883a 	mov	r8,r3
81147e68:	38000526 	beq	r7,zero,81147e80 <strncpy+0xc8>
81147e6c:	18c00044 	addi	r3,r3,1
81147e70:	303ff51e 	bne	r6,zero,81147e48 <__reset+0xfb127e48>
81147e74:	f800283a 	ret
81147e78:	1011883a 	mov	r8,r2
81147e7c:	003fe606 	br	81147e18 <__reset+0xfb127e18>
81147e80:	30000726 	beq	r6,zero,81147ea0 <strncpy+0xe8>
81147e84:	198d883a 	add	r6,r3,r6
81147e88:	18000005 	stb	zero,0(r3)
81147e8c:	18c00044 	addi	r3,r3,1
81147e90:	19bffd1e 	bne	r3,r6,81147e88 <__reset+0xfb127e88>
81147e94:	f800283a 	ret
81147e98:	3811883a 	mov	r8,r7
81147e9c:	003fdf06 	br	81147e1c <__reset+0xfb127e1c>
81147ea0:	f800283a 	ret

81147ea4 <__call_exitprocs>:
81147ea4:	defff504 	addi	sp,sp,-44
81147ea8:	de00012e 	bgeu	sp,et,81147eb0 <__call_exitprocs+0xc>
81147eac:	003b68fa 	trap	3
81147eb0:	df000915 	stw	fp,36(sp)
81147eb4:	dd400615 	stw	r21,24(sp)
81147eb8:	dc800315 	stw	r18,12(sp)
81147ebc:	dfc00a15 	stw	ra,40(sp)
81147ec0:	ddc00815 	stw	r23,32(sp)
81147ec4:	dd800715 	stw	r22,28(sp)
81147ec8:	dd000515 	stw	r20,20(sp)
81147ecc:	dcc00415 	stw	r19,16(sp)
81147ed0:	dc400215 	stw	r17,8(sp)
81147ed4:	dc000115 	stw	r16,4(sp)
81147ed8:	d9000015 	stw	r4,0(sp)
81147edc:	2839883a 	mov	fp,r5
81147ee0:	04800044 	movi	r18,1
81147ee4:	057fffc4 	movi	r21,-1
81147ee8:	00a04574 	movhi	r2,33045
81147eec:	10bd6204 	addi	r2,r2,-2680
81147ef0:	12000017 	ldw	r8,0(r2)
81147ef4:	45005217 	ldw	r20,328(r8)
81147ef8:	44c05204 	addi	r19,r8,328
81147efc:	a0001c26 	beq	r20,zero,81147f70 <__call_exitprocs+0xcc>
81147f00:	a0800117 	ldw	r2,4(r20)
81147f04:	15ffffc4 	addi	r23,r2,-1
81147f08:	b8000d16 	blt	r23,zero,81147f40 <__call_exitprocs+0x9c>
81147f0c:	14000044 	addi	r16,r2,1
81147f10:	8421883a 	add	r16,r16,r16
81147f14:	8421883a 	add	r16,r16,r16
81147f18:	84402004 	addi	r17,r16,128
81147f1c:	a463883a 	add	r17,r20,r17
81147f20:	a421883a 	add	r16,r20,r16
81147f24:	e0001e26 	beq	fp,zero,81147fa0 <__call_exitprocs+0xfc>
81147f28:	80804017 	ldw	r2,256(r16)
81147f2c:	e0801c26 	beq	fp,r2,81147fa0 <__call_exitprocs+0xfc>
81147f30:	bdffffc4 	addi	r23,r23,-1
81147f34:	843fff04 	addi	r16,r16,-4
81147f38:	8c7fff04 	addi	r17,r17,-4
81147f3c:	bd7ff91e 	bne	r23,r21,81147f24 <__reset+0xfb127f24>
81147f40:	00800034 	movhi	r2,0
81147f44:	10800004 	addi	r2,r2,0
81147f48:	10000926 	beq	r2,zero,81147f70 <__call_exitprocs+0xcc>
81147f4c:	a0800117 	ldw	r2,4(r20)
81147f50:	1000301e 	bne	r2,zero,81148014 <__call_exitprocs+0x170>
81147f54:	a0800017 	ldw	r2,0(r20)
81147f58:	10003226 	beq	r2,zero,81148024 <__call_exitprocs+0x180>
81147f5c:	a009883a 	mov	r4,r20
81147f60:	98800015 	stw	r2,0(r19)
81147f64:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
81147f68:	9d000017 	ldw	r20,0(r19)
81147f6c:	a03fe41e 	bne	r20,zero,81147f00 <__reset+0xfb127f00>
81147f70:	dfc00a17 	ldw	ra,40(sp)
81147f74:	df000917 	ldw	fp,36(sp)
81147f78:	ddc00817 	ldw	r23,32(sp)
81147f7c:	dd800717 	ldw	r22,28(sp)
81147f80:	dd400617 	ldw	r21,24(sp)
81147f84:	dd000517 	ldw	r20,20(sp)
81147f88:	dcc00417 	ldw	r19,16(sp)
81147f8c:	dc800317 	ldw	r18,12(sp)
81147f90:	dc400217 	ldw	r17,8(sp)
81147f94:	dc000117 	ldw	r16,4(sp)
81147f98:	dec00b04 	addi	sp,sp,44
81147f9c:	f800283a 	ret
81147fa0:	a0800117 	ldw	r2,4(r20)
81147fa4:	80c00017 	ldw	r3,0(r16)
81147fa8:	10bfffc4 	addi	r2,r2,-1
81147fac:	15c01426 	beq	r2,r23,81148000 <__call_exitprocs+0x15c>
81147fb0:	80000015 	stw	zero,0(r16)
81147fb4:	183fde26 	beq	r3,zero,81147f30 <__reset+0xfb127f30>
81147fb8:	95c8983a 	sll	r4,r18,r23
81147fbc:	a0806217 	ldw	r2,392(r20)
81147fc0:	a5800117 	ldw	r22,4(r20)
81147fc4:	2084703a 	and	r2,r4,r2
81147fc8:	10000b26 	beq	r2,zero,81147ff8 <__call_exitprocs+0x154>
81147fcc:	a0806317 	ldw	r2,396(r20)
81147fd0:	2088703a 	and	r4,r4,r2
81147fd4:	20000c1e 	bne	r4,zero,81148008 <__call_exitprocs+0x164>
81147fd8:	89400017 	ldw	r5,0(r17)
81147fdc:	d9000017 	ldw	r4,0(sp)
81147fe0:	183ee83a 	callr	r3
81147fe4:	a0800117 	ldw	r2,4(r20)
81147fe8:	15bfbf1e 	bne	r2,r22,81147ee8 <__reset+0xfb127ee8>
81147fec:	98800017 	ldw	r2,0(r19)
81147ff0:	153fcf26 	beq	r2,r20,81147f30 <__reset+0xfb127f30>
81147ff4:	003fbc06 	br	81147ee8 <__reset+0xfb127ee8>
81147ff8:	183ee83a 	callr	r3
81147ffc:	003ff906 	br	81147fe4 <__reset+0xfb127fe4>
81148000:	a5c00115 	stw	r23,4(r20)
81148004:	003feb06 	br	81147fb4 <__reset+0xfb127fb4>
81148008:	89000017 	ldw	r4,0(r17)
8114800c:	183ee83a 	callr	r3
81148010:	003ff406 	br	81147fe4 <__reset+0xfb127fe4>
81148014:	a0800017 	ldw	r2,0(r20)
81148018:	a027883a 	mov	r19,r20
8114801c:	1029883a 	mov	r20,r2
81148020:	003fb606 	br	81147efc <__reset+0xfb127efc>
81148024:	0005883a 	mov	r2,zero
81148028:	003ffb06 	br	81148018 <__reset+0xfb128018>

8114802c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114802c:	defffc04 	addi	sp,sp,-16
81148030:	de00012e 	bgeu	sp,et,81148038 <_exit+0xc>
81148034:	003b68fa 	trap	3
81148038:	dfc00315 	stw	ra,12(sp)
8114803c:	df000215 	stw	fp,8(sp)
81148040:	df000204 	addi	fp,sp,8
81148044:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
81148048:	d0a01217 	ldw	r2,-32696(gp)
8114804c:	10800058 	cmpnei	r2,r2,1
81148050:	1000031e 	bne	r2,zero,81148060 <_exit+0x34>
81148054:	01204574 	movhi	r4,33045
81148058:	2135e504 	addi	r4,r4,-10348
8114805c:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
81148060:	d0a01217 	ldw	r2,-32696(gp)
81148064:	10800058 	cmpnei	r2,r2,1
81148068:	1000041e 	bne	r2,zero,8114807c <_exit+0x50>
8114806c:	e17fff17 	ldw	r5,-4(fp)
81148070:	01204574 	movhi	r4,33045
81148074:	2135f004 	addi	r4,r4,-10304
81148078:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114807c:	d0a01217 	ldw	r2,-32696(gp)
81148080:	10800058 	cmpnei	r2,r2,1
81148084:	1000031e 	bne	r2,zero,81148094 <_exit+0x68>
81148088:	01204574 	movhi	r4,33045
8114808c:	2135fb04 	addi	r4,r4,-10260
81148090:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
  ALT_OS_STOP();
81148094:	d0209005 	stb	zero,-32192(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
81148098:	d0a01217 	ldw	r2,-32696(gp)
8114809c:	10800058 	cmpnei	r2,r2,1
811480a0:	1000031e 	bne	r2,zero,811480b0 <_exit+0x84>
811480a4:	01204574 	movhi	r4,33045
811480a8:	21360504 	addi	r4,r4,-10220
811480ac:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
811480b0:	e0bfff17 	ldw	r2,-4(fp)
811480b4:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
811480b8:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
811480bc:	10000226 	beq	r2,zero,811480c8 <_exit+0x9c>
    ALT_SIM_FAIL();
811480c0:	002af070 	cmpltui	zero,zero,43969
811480c4:	00000106 	br	811480cc <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
811480c8:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
811480cc:	d0a01217 	ldw	r2,-32696(gp)
811480d0:	10800058 	cmpnei	r2,r2,1
811480d4:	1000031e 	bne	r2,zero,811480e4 <_exit+0xb8>
811480d8:	01204574 	movhi	r4,33045
811480dc:	21360f04 	addi	r4,r4,-10180
811480e0:	1133b3c0 	call	81133b3c <alt_log_printf_proc>
  while (1);
811480e4:	003fff06 	br	811480e4 <__reset+0xfb1280e4>
