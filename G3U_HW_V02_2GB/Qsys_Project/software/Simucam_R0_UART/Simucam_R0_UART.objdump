
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0004e000 memsz 0x00067f28 flags rwx
    LOAD off    0x00050000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00050000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00046994  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000563c  81146bf0  81146bf0  00047bf0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  8114c22c  8114c22c  0004d22c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00019f28  8114e020  8114e020  0004f020  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  81167f48  81167f48  00050000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00050000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00050000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  00050028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0006f7b4  00000000  00000000  00051d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0001654a  00000000  00000000  000c1534  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00021f3b  00000000  00000000  000d7a7e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009554  00000000  00000000  000f99bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000c5c0  00000000  00000000  00102f10  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  0010f4d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013639c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  001363e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00144695  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0014469b  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  001446a7  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  001446a8  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  001446a9  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  001446ad  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  001446b1  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  001446b5  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  001446c0  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  001446ca  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  001446d4  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  001446e5  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     002827ef  00000000  00000000  00144724  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
81146bf0 l    d  .rodata	00000000 .rodata
8114c22c l    d  .rwdata	00000000 .rwdata
8114e020 l    d  .bss	00000000 .bss
81167f48 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
8110474c l     F .text	00000050 uliCommReadReg
811046f8 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81104f8c l     F .text	00000050 uliDpktReadReg
81104f38 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
8114e03c l     O .bss	00000004 viCh1HoldContext
8114e040 l     O .bss	00000004 viCh2HoldContext
8114e044 l     O .bss	00000004 viCh3HoldContext
8114e048 l     O .bss	00000004 viCh4HoldContext
8114e04c l     O .bss	00000004 viCh5HoldContext
8114e050 l     O .bss	00000004 viCh6HoldContext
8114e054 l     O .bss	00000004 viCh7HoldContext
8114e058 l     O .bss	00000004 viCh8HoldContext
811060a8 l     F .text	00000054 vFeebWriteReg
811060fc l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
8114e05c l     O .bss	00000004 viCh1HoldContext
8114e060 l     O .bss	00000004 viCh2HoldContext
8114e064 l     O .bss	00000004 viCh3HoldContext
8114e068 l     O .bss	00000004 viCh4HoldContext
8114e06c l     O .bss	00000004 viCh5HoldContext
8114e070 l     O .bss	00000004 viCh6HoldContext
8114e074 l     O .bss	00000004 viCh7HoldContext
8114e078 l     O .bss	00000004 viCh8HoldContext
81108e14 l     F .text	00000054 vRmapWriteReg
81108e68 l     F .text	00000050 uliRmapReadReg
81108eb8 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
811097ec l     F .text	00000050 uliSpwcReadReg
81109798 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8114df48 l     O .rwdata	00000001 ucIoValue
811099ec l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110a2dc l     F .text	0000013c msgdma_write_extended_descriptor
8110a418 l     F .text	00000164 msgdma_construct_extended_descriptor
8110a57c l     F .text	00000318 msgdma_descriptor_async_transfer
8110a894 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110b410 l     F .text	00000054 vRstcWriteReg
8110b464 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8114e080 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
8114e088 l     O .bss	00000004 pxNFee.5497
8114e08c l     O .bss	00000004 incrementador.5501
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
8114e090 l     O .bss	00000004 xRAckLocal.5481
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
8114e094 l     O .bss	00000004 bDmaBack.5483
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8114e098 l     O .bss	00000004 xSAckLocal.5466
00000000 l    df *ABS*	00000000 parser_comm_task.c
8114e210 l     O .bss	0000004c PreParsedLocal.5555
8114e25c l     O .bss	00000054 xTcPusL.5554
00000000 l    df *ABS*	00000000 receiver_uart_task.c
8114e2b0 l     O .bss	0000004c xPreParsedReader.5547
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8114e2fc l     O .bss	00000054 xPusLocal.5740
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81149bcb l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8114b66d l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
8114c22c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
8111d77c l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114b83a l     O .rodata	00000010 zeroes.4389
8114b84a l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8114b85a l     O .rodata	00000010 zeroes.4404
811223f4 l     F .text	000000c4 __sbprintf
8114b86a l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8114b882 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
811240dc l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
81125c2c l     F .text	00000008 __fp_unlock
81125c40 l     F .text	000001a4 __sinit.part.1
81125de4 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
8114ca78 l     O .rwdata	00000020 lc_ctype_charset
8114ca58 l     O .rwdata	00000020 lc_message_charset
8114ca98 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8114b8c0 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
81128c54 l     F .text	0000006c sulp
8114ba08 l     O .rodata	00000014 fpi.2737
8114ba1c l     O .rodata	00000028 tinytens
8114b9f4 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114ba54 l     O .rodata	00000010 blanks.4332
8114ba44 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112c2c4 l     F .text	00000104 __sprint_r.part.0
8114ba74 l     O .rodata	00000010 blanks.4348
8114ba64 l     O .rodata	00000010 zeroes.4349
8112d860 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8112dd14 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81131ab0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81131bf4 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81131c28 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81131eac l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
81131fa4 l       .text	00000000 tx_next_char
81131fcc l       .text	00000000 end_tx
81131fac l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
81132aa8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81132d24 l     F .text	00000044 alt_get_errno
81132d68 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81132f90 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
8114df90 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81133530 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
8114df9c l     O .rwdata	00000004 lockid
8114e158 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
8114dfa0 l     O .rwdata	00000004 lockid
8114e160 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
81134fbc l     F .text	00000050 OS_InitMisc
8113500c l     F .text	00000074 OS_InitRdyList
81135190 l     F .text	000000ec OS_InitTCBList
81134ed4 l     F .text	000000e8 OS_InitEventList
81135080 l     F .text	00000088 OS_InitTaskIdle
81135108 l     F .text	00000088 OS_InitTaskStat
81135420 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
81137238 l     F .text	000000fc OS_FlagTaskRdy
81136fe8 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
81138b24 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8113d554 l     F .text	00000044 OSTmr_Lock
8113cff4 l     F .text	00000074 OSTmr_Alloc
8113d598 l     F .text	0000003c OSTmr_Unlock
8113d458 l     F .text	000000fc OSTmr_Unlink
8113d068 l     F .text	000000a4 OSTmr_Free
8113d308 l     F .text	00000150 OSTmr_Link
8113d280 l     F .text	00000088 OSTmr_InitTask
8113d5d4 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
8113d6e4 l     F .text	0000003c alt_dev_reg
8114cd14 l     O .rwdata	0000106c jtag_uart_0
8114dd80 l     O .rwdata	000000d0 rs232_uart
8114de50 l     O .rwdata	00000064 dma_DDR_M1
8114deb4 l     O .rwdata	00000064 dma_DDR_M2
8114df18 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81141f74 l     F .text	000002bc altera_avalon_jtag_uart_irq
81142230 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81142a34 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
81142dcc l     F .text	000000a4 altera_avalon_uart_irq
81142e70 l     F .text	00000140 altera_avalon_uart_rxirq
81142fb0 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
811431b8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
8114346c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
811436f0 l     F .text	00000044 alt_get_errno
81143734 l     F .text	0000009c alt_msgdma_write_standard_descriptor
811437d0 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81143904 l     F .text	0000018c alt_msgdma_irq
81143a90 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81143b24 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
81143c80 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81143fc0 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
811446c8 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81144774 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
81145940 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
81145f84 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
8114e208 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8114e20c g     O .bss	00000004 alt_instruction_exception_handler
811064e4 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
8114e878 g     O .bss	00001000 vFeeTask0_stk
811177e0 g     F .text	0000004c vFailDeleteInitialization
8114e1dc g     O .bss	00000004 aux_status_register
8114f878 g     O .bss	00001000 vInAckHandlerTask_stk
811456fc g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
8110682c g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110bad4 g     F .text	0000004c vSyncInitIrq
811138bc g     F .text	00000284 vCheckRetransmission128
811282d8 g     F .text	0000007c _mprec_log10
8110bcdc g     F .text	00000040 bSyncSetMbt
81118da4 g     F .text	00000054 vFailRequestDMAFromIRQ
81109bd0 g     F .text	00000108 I2C_Read
8114dfee g     O .rwdata	00000002 OSTaskNameSize
8114e0a0 g     O .bss	00000004 xWaitSyncQFee
81150878 g     O .bss	00000260 xBuffer64
811283cc g     F .text	0000008c __any_on
81126da0 g     F .text	0000005c _isatty_r
8114b8cc g     O .rodata	00000028 __mprec_tinytens
811067d4 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
81132bc8 g     F .text	0000015c alt_main
8111d6a0 g     F .text	000000c8 _puts_r
8110561c g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
8114e168 g     O .bss	00000004 OSTmrFreeList
81167e48 g     O .bss	00000100 alt_irq
81126f10 g     F .text	00000068 _lseek_r
81119e74 g     F .text	00000030 vChangeDefaultAutoResetSync
81137a98 g     F .text	000000d4 OS_MemInit
81118d50 g     F .text	00000054 vFailRequestDMA
811162c4 g     F .text	000009d4 vLoadDefaultETHConf
8110ee80 g     F .text	0000014c bCheckInAck64
81150ad8 g     O .bss	00000150 xPus
8113c534 g     F .text	00000068 OSTimeSet
81112500 g     F .text	0000008c vPusType250run
81125fe4 g     F .text	000000ac __sflags
81118724 g     F .text	00000068 vCoudlNotCreateNFee2Task
81118b10 g     F .text	0000004c vCouldNotGetMutexMebPus
81130c10 g     F .text	00000088 .hidden __eqdf2
81112bcc g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
81119d60 g     F .text	00000034 vLoadDefaultSyncSource
81117278 g     F .text	0000004c vFailCreateMutexDMA
8113dbe4 g     F .text	000001ac Check_for_Master_Boot_Record
8116185c g     O .bss	00000010 OSTmrWheelTbl
811068cc g     F .text	00000050 uliRmapCh3WriteCmdAddress
81144488 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
81150c28 g     O .bss	00000010 xFeeQueueTBL3
81133c20 g     F .text	00000594 OSEventPendMulti
8114e0a4 g     O .bss	00000004 xNfeeSchedule
81167f48 g       *ABS*	00000000 __alt_heap_start
811465bc g     F .text	0000002c OSTaskCreateHook
81141a5c g     F .text	000001c4 alt_up_sd_card_fclose
8114e0a8 g     O .bss	00000004 xSemCountBuffer64
811044b0 g     F .text	0000016c bCommSetGlobalIrqEn
81106cd0 g     F .text	00000088 bRmapGetIrqControl
8111d4e4 g     F .text	00000044 printf
8114e07d g     O .bss	00000001 SspdConfigControl
8110c0f8 g     F .text	00000054 bSyncCtrReset
8114dfc6 g     O .rwdata	00000002 OSMboxEn
8111a9d0 g     F .text	000000a4 aatoh
81134218 g     F .text	00000054 OSIntEnter
8112e980 g     F .text	000000a4 _wcrtomb_r
81105528 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
81117748 g     F .text	0000004c vFailReceiverCreate
8114e0ac g     O .bss	00000004 xQMaskDataCtrl
81105038 g     F .text	00000084 vFeebCh2HandleIrq
8111dc08 g     F .text	00000064 __sseek
81125f94 g     F .text	00000010 __sinit
8110ad50 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
81123d5c g     F .text	00000148 __swbuf_r
81114094 g     F .text	00000470 bResourcesInitRTOS
81109338 g     F .text	000000f4 bSpwcGetLinkError
8114dfd6 g     O .rwdata	00000002 OSQEn
8110620c g     F .text	00000040 vRmapCh4HandleIrq
81126e2c g     F .text	00000084 _setlocale_r
81150c38 g     O .bss	00000010 SyncTBL2
8114df4c g     O .rwdata	00000004 LedsPainelControl
8114e378 g     O .bss	00000100 cDebugBuffer
81125dec g     F .text	00000070 __sfmoreglue
8112c2ac g     F .text	00000018 ungetc
811338dc g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114663c g     F .text	00000028 OSTaskStatHook
81112a28 g     F .text	00000088 vSendCmdQToNFeeCTRL
81119dd0 g     F .text	00000030 vChangeDefaultSyncSource
8114e16c g     O .bss	00000001 OSLockNesting
8114e170 g     O .bss	00000004 OSTmrSemSignal
81119128 g     F .text	00000178 vNFeeStructureInit
8114e0b0 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
81128cc0 g     F .text	00001600 _strtod_r
8114e0b4 g     O .bss	00000004 xSemCountSenderACK
8111ab0c g     F .text	00000448 .hidden __divsf3
8114e200 g     O .bss	00000004 current_sector_modified
8114e014 g     O .rwdata	00000002 OSDataSize
8114e174 g     O .bss	00000001 OSRunning
81109614 g     F .text	00000184 bSpwcInitCh
81132890 g     F .text	00000064 alt_log_jtag_uart_isr_proc
81150c48 g     O .bss	00001000 senderTask_stk
811077c4 g     F .text	00000094 bRmapGetMemConfigStat
8114e0b8 g     O .bss	00000004 fp
81151c48 g     O .bss	00000030 xNfeeScheduleTBL
8110ed38 g     F .text	00000148 bCheckInAck128
811272a0 g     F .text	0000015c memmove
811466b8 g     F .text	0000002c OSInitHookBegin
8110c594 g     F .text	00000074 bSyncCtrCh8OutEnable
8110de68 g     F .text	0000006c bEnableDbBuffer
8114e00c g     O .rwdata	00000002 OSTmrSize
81125f7c g     F .text	00000018 _cleanup
8111a29c g     F .text	00000040 siCloseFile
81105f24 g     F .text	00000184 bFeebInitCh
811273fc g     F .text	000000b0 _Balloc
81119e00 g     F .text	00000038 vLoadDefaultAutoResetSync
81106de0 g     F .text	000000d8 bRmapSetCodecConfig
81140638 g     F .text	000000cc alt_up_sd_card_is_Present
811443c8 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8114e028 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
8113d90c g     F .text	00000054 Save_Modified_Sector
8110577c g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
8114e178 g     O .bss	00000004 OSIdleCtr
8114e134 g     O .bss	00000001 alt_log_write_on_flag
8110983c g     F .text	0000003c bEnableIsoDrivers
81130c98 g     F .text	000000dc .hidden __gtdf2
8114634c g     F .text	0000002c altera_nios2_gen2_irq_init
81146434 g       .text	00000000 OSStartTsk
8110be50 g     F .text	00000070 bSyncSetNCycles
81135790 g     F .text	000002dc OS_TCBInit
8114e137 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
811199e8 g     F .text	00000078 vInitSimucamBasicHW
81151c78 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110c4ac g     F .text	00000074 bSyncCtrCh6OutEnable
81109f4c g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
8114e1f8 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
8114e17c g     O .bss	00000002 OSTmrUsed
8114e0bc g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
81106c28 g     F .text	000000a8 bRmapSetIrqControl
81152c78 g     O .bss	00001000 vDataControlTask_stk
81105140 g     F .text	00000084 vFeebCh4HandleIrq
8114e012 g     O .rwdata	00000002 OSTmrWheelTblSize
81119690 g     F .text	0000002c cFeeSpwChannelDisable
8114dfb2 g     O .rwdata	00000002 OSEventSize
8114e17e g     O .bss	00000001 OSPrioHighRdy
8111c680 g     F .text	00000064 _fstat_r
811465e8 g     F .text	0000002c OSTaskDelHook
8114e110 g     O .bss	00000004 errno
8110c888 g     F .text	0000003c uliSyncGetCtr
81123cec g     F .text	0000001c __svfscanf
8111db7c g     F .text	00000008 __seofread
81146414 g       .text	00000000 OSStartHighRdy
81119088 g     F .text	00000028 vEvtChangeFeeControllerMode
8110e080 g     F .text	00000968 vPrintConsoleNFee
8110fc88 g     F .text	000000c8 bSendCmdQToNFeeInst
811062cc g     F .text	00000040 vRmapCh7HandleIrq
8113af64 g     F .text	000001ec OSTaskCreateExt
81161830 g     O .bss	00000011 alt_log_write_buf
811049c8 g     F .text	0000012c bDpktGetPacketConfig
81106a5c g     F .text	00000050 uliRmapCh8WriteCmdAddress
81117b04 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112adf0 g     F .text	00001244 ___svfiprintf_internal_r
8111175c g     F .text	00000364 bPreParserV2
81136b18 g     F .text	00000068 OSFlagPendGetFlagsRdy
8114dff2 g     O .rwdata	00000002 OSTaskStatStkSize
81135c64 g     F .text	00000310 OSFlagAccept
81139240 g     F .text	000000c0 OSQFlush
81138cbc g     F .text	00000148 OSQAccept
8114e148 g     O .bss	00000004 alt_argv
81155f44 g       *ABS*	00000000 _gp
81117410 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
811333f4 g     F .text	0000013c usleep
81140c10 g     F .text	00000384 alt_up_sd_card_fopen
8111a108 g     F .text	00000030 bSDcardIsPresent
81111ac0 g     F .text	00000178 vSenderComTask
81140778 g     F .text	000000d8 alt_up_sd_card_find_first
8113adb0 g     F .text	000001b4 OSTaskCreate
81117ca4 g     F .text	00000068 vFailSendNack
8114e1ec g     O .bss	00000004 command_argument_register
8113a8b8 g     F .text	000004f8 OSTaskChangePrio
811120c4 g     F .text	000000ac vPusMebInTaskConfigMode
8111841c g     F .text	00000088 vCouldNotSendTMPusCommand
8114e164 g     O .bss	00000004 alt_heapsem
8110a1e4 g     F .text	00000080 bSetBoardLeds
81135a6c g     F .text	000001f8 OSDebugInit
8113b150 g     F .text	0000034c OSTaskDel
81137b6c g     F .text	000001ac OSMutexAccept
81153c78 g     O .bss	000002b4 xSimMeb
811198cc g     F .text	00000040 vSetTimeCode
81144f70 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
8114e0c0 g     O .bss	00000004 xSemCountPreParsed
8114caf8 g     O .rwdata	00000180 alt_fd_list
811056cc g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
8114cc94 g     O .rwdata	0000001d alt_log_msg_alt_main
8116186c g     O .bss	00000840 OSFlagTbl
8110656c g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
81117578 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
8110696c g     F .text	00000050 uliRmapCh5WriteCmdAddress
81119cb8 g     F .text	0000003c vLoadDefaultRTValue
81134c9c g     F .text	000000c0 OS_EventTaskRemove
81153f2c g     O .bss	00001000 vFeeTask5_stk
8114e136 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
8113fe8c g     F .text	00000134 find_first_empty_record_in_root_directory
81145a30 g     F .text	00000098 alt_find_dev
8111d1cc g     F .text	00000150 memcpy
8112e64c g     F .text	00000264 __hexnan
81104dc4 g     F .text	00000174 bDpktInitCh
81154f2c g     O .bss	00000160 xBuffer32
8114dfdc g     O .rwdata	00000002 OSRdyTblSize
811620ac g     O .bss	000001a0 OSTmrTbl
81125c34 g     F .text	0000000c _cleanup_r
811317ec g     F .text	000000e4 .hidden __floatsidf
81115eec g     F .text	000001a8 vSendPusTM64
8110bc4c g     F .text	0000004c ucSyncStatusErrorCode
81112b38 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111978c g     F .text	00000034 cFeeRMAPLogDisable
81110048 g     F .text	00000df0 vParserCommTask
81146050 g     F .text	00000084 alt_io_redirect
81119720 g     F .text	00000034 cFeeRMAPEchoingDisable
81130d74 g     F .text	000000f4 .hidden __ltdf2
81118a5c g     F .text	0000004c vFailSendPUStoMebTask
8110677c g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
811059a8 g     F .text	000000d4 bFeebSetIrqControl
81118214 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
8114e0c4 g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
811453f8 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81145740 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110c1a0 g     F .text	00000054 bSyncCtrErrInj
811456a0 g     F .text	0000005c alt_msgdma_register_callback
81116c98 g     F .text	00000330 vShowEthConfig
81119a60 g     F .text	00000030 bLogWriteSDCard
81117894 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
8111d768 g     F .text	00000014 puts
8111a31c g     F .text	00000270 bInitSync
81146760 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110b95c g     F .text	0000014c vSyncHandleIrq
811339b0 g     F .text	00000128 OSEventNameGet
81105390 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8114dfc0 g     O .rwdata	00000002 OSFlagMax
8112702c g     F .text	000000e0 mbrtowc
8113fa84 g     F .text	000001b4 find_first_empty_cluster
81112c54 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110c438 g     F .text	00000074 bSyncCtrCh5OutEnable
8114e084 g     O .bss	00000001 vucN
81128a2c g     F .text	00000074 __fpclassifyd
8110bbac g     F .text	00000054 bSyncStatusExtnIrq
81123d08 g     F .text	00000054 _vfscanf_r
811381ec g     F .text	000005a4 OSMutexPend
8112822c g     F .text	000000ac __ratio
81140574 g     F .text	000000c4 alt_up_sd_card_open_dev
811184a4 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
8113426c g     F .text	00000100 OSIntExit
8110bd1c g     F .text	00000040 bSyncSetBt
8112d844 g     F .text	0000001c __vfiprintf_internal
81118b5c g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
8114dffa g     O .rwdata	00000002 OSTCBSize
8110534c g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
8114e17f g     O .bss	00000001 OSPrioCur
811424a4 g     F .text	000002c4 altera_avalon_jtag_uart_read
81144c38 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8111d4ac g     F .text	00000038 _printf_r
8112f7b4 g     F .text	00000064 .hidden __udivsi3
81131ef0 g     F .text	000000ac isatty
8114e07c g     O .bss	00000001 LedsBoardControl
8114e0c8 g     O .bss	00000004 xSemCountReceivedACK
8114dfe0 g     O .rwdata	00000002 OSStkWidth
81126dfc g     F .text	00000030 iswspace
8114b91c g     O .rodata	000000c8 __mprec_tens
8114dfd4 g     O .rwdata	00000002 OSPtrSize
811188c4 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
81126eb0 g     F .text	0000000c __locale_charset
8110c350 g     F .text	00000074 bSyncCtrCh3OutEnable
8112f9a4 g     F .text	000000c8 .hidden __lesf2
8114dfb4 g     O .rwdata	00000002 OSEventTblSize
8112eb80 g     F .text	0000007c .hidden __fixunsdfsi
81146378 g       .text	00000000 OSCtxSw
81109cd8 g     F .text	00000160 I2C_MultipleRead
81132a34 g     F .text	00000074 alt_log_system_clock
8114e11c g     O .bss	00000004 __malloc_top_pad
8114e180 g     O .bss	00000004 OSTCBList
8113cfb4 g     F .text	00000040 OSTmrSignal
8114e12c g     O .bss	00000004 alt_fd_list_lock
8112a91c g     F .text	0000001c strtoul
8114df64 g     O .rwdata	00000004 __mb_cur_max
81126ee0 g     F .text	0000000c _localeconv_r
8112a938 g     F .text	000002e0 _strtoull_r
8110b3a0 g     F .text	00000070 vRstcHoldDeviceReset
81127820 g     F .text	00000044 __i2b
81126744 g     F .text	000004c4 __sfvwrite_r
8113ed64 g     F .text	000000c0 get_dir_divider_location
81106418 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
8116224c g     O .bss	00000c30 OSMemTbl
8114e184 g     O .bss	00000001 OSTickStepState
81132644 g     F .text	00000060 alt_log_printf_proc
81104d00 g     F .text	000000c4 bDpktGetPixelDelay
8115508c g     O .bss	00001800 vReceiverUartTask_stk
8111d974 g     F .text	0000005c _sbrk_r
8114e0cc g     O .bss	00000004 xSemTimeoutChecker
8113ea24 g     F .text	000000cc filename_to_upper_case
8114e138 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
8114dfd8 g     O .rwdata	00000002 OSQMax
81140f94 g     F .text	00000090 alt_up_sd_card_set_attributes
81137ee8 g     F .text	00000304 OSMutexDel
81162e7c g     O .bss	00001000 OSTaskStatStk
8111a138 g     F .text	00000030 bSDcardFAT16Check
811376b4 g     F .text	000000f8 OSMemNameGet
81117218 g     F .text	00000060 vFailCreateMutexSResources
8113dd90 g     F .text	00000284 Read_File_Record_At_Offset
8115688c g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8114dfb8 g     O .rwdata	00000002 OSFlagEn
81128458 g     F .text	00000068 _read_r
8114dffe g     O .rwdata	00000002 OSTimeTickHookEn
81137334 g     F .text	000000ac OS_FlagUnlink
81139708 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
8114df80 g     O .rwdata	00000004 alt_max_fd
81117fc0 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
811352d8 g     F .text	00000070 OS_MemCopy
81135348 g     F .text	000000d8 OS_Sched
8113f608 g     F .text	0000047c find_file_in_directory
8112d9f0 g     F .text	000000f8 _fclose_r
811375bc g     F .text	000000f8 OSMemGet
8113b794 g     F .text	000001bc OSTaskNameSet
81125bfc g     F .text	00000030 fflush
8114e118 g     O .bss	00000004 __malloc_max_sbrked_mem
8114e188 g     O .bss	00000004 OSCtxSwCtr
81146664 g     F .text	00000054 OSTimeTickHook
811568cc g     O .bss	00001000 vOutAckHandlerTask_stk
81131d24 g     F .text	00000188 alt_irq_register
8114dfc2 g     O .rwdata	00000002 OSFlagNameSize
8111bc9c g     F .text	00000118 .hidden __extendsfdf2
81134d5c g     F .text	00000108 OS_EventTaskRemoveMulti
811185e4 g     F .text	00000070 vFailCreateNFEESyncQueue
81140704 g     F .text	00000074 alt_up_sd_card_is_FAT16
81109a68 g     F .text	00000088 I2C_TestAdress
8112fa6c g     F .text	000008b4 .hidden __adddf3
81161844 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
8112f870 g     F .text	00000078 .hidden __nesf2
811063d4 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
81134b44 g     F .text	00000158 OS_EventTaskWaitMulti
811578cc g     O .bss	00000010 SyncTBL4
81127fc4 g     F .text	00000114 __b2d
81144970 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
8114dfda g     O .rwdata	00000002 OSQSize
8112f17c g     F .text	00000540 .hidden __umoddi3
81132aec g     F .text	000000dc lseek
8113a1f8 g     F .text	00000214 OSSemPend
81118aa8 g     F .text	00000068 vCouldNotGetCmdQueueMeb
81106f44 g     F .text	00000160 bRmapGetCodecStatus
8110942c g     F .text	000000d0 bSpwcGetLinkStatus
81105d04 g     F .text	00000088 bFeebGetWindowing
8114df54 g     O .rwdata	00000004 _global_impure_ptr
8110b910 g     F .text	0000004c bSSDisplayUpdate
8113f0c8 g     F .text	00000540 get_home_directory_cluster_for_file
811284c0 g     F .text	0000056c _realloc_r
8114dfc4 g     O .rwdata	00000002 OSLowestPrio
81167f48 g       *ABS*	00000000 __bss_end
81145e8c g     F .text	000000f8 alt_iic_isr_register
81146734 g     F .text	0000002c OSTCBInitHook
8114e00a g     O .rwdata	00000002 OSTmrCfgTicksPerSec
811332e4 g     F .text	00000110 alt_tick
81106aac g     F .text	0000017c vRmapInitIrq
81117510 g     F .text	00000068 vFailGetMutexSenderTask
8110b2c0 g     F .text	0000006c vRstcSimucamReset
8110df38 g     F .text	000000a4 bSendRequestNFeeCtrl
8114ba84 g     O .rodata	00000100 __hexdig
811454ec g     F .text	000001b4 alt_msgdma_init
8112ebfc g     F .text	00000580 .hidden __udivdi3
81111444 g     F .text	0000017c setPreAckSenderFreePos
8112dc68 g     F .text	00000024 _fputwc_r
8114dfac g     O .rwdata	00000002 OSEventEn
8114b8f4 g     O .rodata	00000028 __mprec_bigtens
811275fc g     F .text	0000010c __s2b
8114e006 g     O .rwdata	00000002 OSTmrCfgNameSize
811578dc g     O .bss	00000010 xFeeQueueTBL4
8110bddc g     F .text	00000074 bSyncSetPolarity
81113b40 g     F .text	0000028c vCheckRetransmission64
811318d0 g     F .text	000000b0 .hidden __floatunsidf
8114e13c g     O .bss	00000004 alt_system_clock_in_sec
8113283c g     F .text	00000054 alt_log_jtag_uart_startup_info
81117a9c g     F .text	00000068 vFailFoundBufferRetransmission
81127cfc g     F .text	00000060 __mcmp
8114e204 g     O .bss	00000004 current_sector_index
81142c64 g     F .text	00000168 altera_avalon_uart_init
811457c8 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
8110409c g     F .text	00000414 bSdmaDmaM2Transfer
8111990c g     F .text	00000034 vResetTimeCode
81119664 g     F .text	0000002c cFeeSpwChannelEnable
81125fb4 g     F .text	00000018 __fp_lock_all
81118ee4 g     F .text	0000004c vFailSendMsgDataCTRL
81145e38 g     F .text	00000054 alt_ic_irq_enabled
81109af0 g     F .text	000000e0 I2C_Write
8110661c g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
8114e18c g     O .bss	00000002 OSTmrFree
81137150 g     F .text	000000e8 OS_FlagInit
81133240 g     F .text	000000a4 alt_alarm_stop
8111dfdc g     F .text	0000001c strtol
8114e135 g     O .bss	00000001 alt_log_sys_clk_on_flag
8113c760 g     F .text	00000140 OSTmrDel
8113dafc g     F .text	000000e8 mark_cluster
8114dfe8 g     O .rwdata	00000002 OSTaskIdleStkSize
8114e130 g     O .bss	00000004 alt_irq_active
81139e18 g     F .text	000000b8 OSSemAccept
8111c218 g     F .text	0000044c _fseeko_r
811149a4 g     F .text	00000260 vFillMemmoryPattern
8111dd58 g     F .text	00000044 strnlen
811378c8 g     F .text	000000e0 OSMemPut
811373e0 g     F .text	000001dc OSMemCreate
8114e190 g     O .bss	00000004 OSIdleCtrMax
81116094 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
8113208c g     F .text	000005b8 alt_log_private_printf
8114cad0 g     O .rwdata	00000028 alt_dev_null
81144580 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110bd9c g     F .text	00000040 bSyncSetOst
8114dffc g     O .rwdata	00000002 OSTicksPerSec
8114cc78 g     O .rwdata	00000019 alt_log_msg_bss
8113ffc0 g     F .text	00000194 convert_filename_to_name_extension
81107858 g     F .text	00000c4c bRmapSetRmapMemHKArea
81111c38 g     F .text	00000330 vSimMebTask
81109e38 g     F .text	00000094 i2c_start
81146378 g       .text	00000000 OSIntCtxSw
81118df8 g     F .text	00000054 vFailSendMsgSync
8110c3c4 g     F .text	00000074 bSyncCtrCh4OutEnable
81145364 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
81131bcc g     F .text	00000028 alt_dcache_flush_all
81127708 g     F .text	00000068 __hi0bits
8111258c g     F .text	00000114 vPusType251run
811069bc g     F .text	00000050 uliRmapCh6WriteCmdAddress
81119cf4 g     F .text	0000003c vChangeRTValue
8114e1d8 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81113738 g     F .text	00000184 vCheck
811190d8 g     F .text	00000050 vNFeeNotInUse
8113176c g     F .text	00000080 .hidden __fixdfsi
81105e14 g     F .text	00000088 bFeebStopCh
8110f69c g     F .text	000003f8 vNFeeControlTask
811578ec g     O .bss	00001000 vInitialTask_stk
8114e0d0 g     O .bss	00000002 usiIdCMD
811588ec g     O .bss	00000010 SyncTBL3
8110c0a4 g     F .text	00000054 bSyncCtrStart
8113fc38 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8112a2c0 g     F .text	00000018 strtod
81105e9c g     F .text	00000088 bFeebClrCh
8114e194 g     O .bss	00000004 OSTCBFreeList
81106724 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113a40c g     F .text	00000174 OSSemPendAbort
811176b0 g     F .text	0000004c vFailGetMacRTC
8110691c g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
81117f28 g     F .text	0000004c vFailCreateTimerRetransmisison
81117a34 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
81114f5c g     F .text	000002f0 bSendUART128v2
81119b28 g     F .text	000000ec vSimucamStructureInit
8114df78 g     O .rwdata	00000008 alt_dev_list
8111c148 g     F .text	0000004c _fputc_r
81133574 g     F .text	0000010c write
8111d528 g     F .text	000000a8 _putc_r
8114e1fc g     O .bss	00000004 device_pointer
8114e000 g     O .rwdata	00000002 OSVersionNbr
8112f8e8 g     F .text	000000bc .hidden __gtsf2
81118fc8 g     F .text	0000004c vFailFlushMEBQueue
81110e38 g     F .text	00000118 getPreParsedPacket
8110de08 g     F .text	00000060 bEnableSPWChannel
81131c6c g     F .text	000000b8 fstat
81119974 g     F .text	00000040 vChangeIdNFEEMaster
8111c11c g     F .text	0000002c fprintf
81119754 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105724 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
81118074 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111a6b0 g     F .text	00000058 _reg_write
811199b4 g     F .text	00000034 vChangeDefaultIdNFEEMaster
81130d74 g     F .text	000000f4 .hidden __ledf2
8110624c g     F .text	00000040 vRmapCh5HandleIrq
8110dd0c g     F .text	0000004c bDisableRmapIRQ
811588fc g     O .bss	00001000 vStackMonitor_stk
811183b4 g     F .text	00000068 vCouldNotSendLog
8113c9e0 g     F .text	000001b8 OSTmrRemainGet
8114dfa8 g     O .rwdata	00000004 OSEndiannessTest
8110b4b4 g     F .text	00000058 v_spi_start
81127a64 g     F .text	00000148 __pow5mult
8110687c g     F .text	00000050 uliRmapCh2WriteCmdAddress
8112c3e0 g     F .text	00001464 ___vfiprintf_internal_r
8114e128 g     O .bss	00000004 __nlocale_changed
8112f818 g     F .text	00000058 .hidden __umodsi3
8110c1f4 g     F .text	00000074 bSyncCtrSyncOutEnable
8111a168 g     F .text	000000f8 bInitializeSDCard
81117e44 g     F .text	0000004c vFailParserCommTaskCreate
8111834c g     F .text	00000068 vCouldNotSendReset
8111da14 g     F .text	00000038 _scanf_r
81117edc g     F .text	0000004c vFailOutAckHandlerTaskCreate
8114dfba g     O .rwdata	00000002 OSFlagGrpSize
81112170 g     F .text	0000008c vPusType250conf
811598fc g     O .bss	00000058 xInUseRetrans
8110bb5c g     F .text	00000050 bSyncIrqFlagSync
811449d0 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8113cb98 g     F .text	000000ec OSTmrStateGet
81167f48 g       *ABS*	00000000 end
81105248 g     F .text	00000084 vFeebCh6HandleIrq
81114c04 g     F .text	00000260 vPrintMemmoryPattern
81117bd4 g     F .text	00000068 vNoContentInPreParsedBuffer
8111c664 g     F .text	0000001c fseeko
81110f50 g     F .text	00000168 bSendMessagePUStoMebTask
81118574 g     F .text	00000070 vFailCreateNFEEQueue
8111bfcc g     F .text	0000000c _atoi_r
811434b0 g     F .text	00000240 altera_avalon_uart_write
81131fd0 g     F .text	00000054 alt_log_txchar
8111c1fc g     F .text	0000001c fseek
81114ecc g     F .text	00000090 vCCDChangeValues
81141da4 g     F .text	000001d0 altera_avalon_jtag_uart_init
811355d8 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
81117310 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
81142ab8 g     F .text	00000084 alt_avalon_timer_sc_init
81105c5c g     F .text	000000a8 bFeebSetWindowing
81142ba4 g     F .text	00000068 altera_avalon_uart_write_fd
8111bf5c g     F .text	00000064 .hidden __clzsi2
81142c0c g     F .text	00000058 altera_avalon_uart_close_fd
81159954 g     O .bss	00000020 xMebQTBL
81142768 g     F .text	000002cc altera_avalon_jtag_uart_write
8113d10c g     F .text	00000174 OSTmr_Init
81159974 g     O .bss	00000348 xBuffer128
81125fa4 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
811271bc g     F .text	000000e4 memchr
8113527c g     F .text	0000005c OS_MemClr
811201d8 g     F .text	00002200 ___vfprintf_internal_r
81146458 g     F .text	00000164 OSTaskStkInit
8111da4c g     F .text	00000060 _sprintf_r
811074f0 g     F .text	000002d4 bRmapGetMemConfigArea
8114e0d2 g     O .bss	00000001 SemCount32
8112642c g     F .text	00000318 _free_r
811460d4 g     F .text	00000234 alt_printf
81115e9c g     F .text	00000050 vTimeoutCheck
8111a760 g     F .text	000001fc _print_codec_status
81126ebc g     F .text	00000010 __locale_mb_cur_max
8113488c g     F .text	000001a0 OS_EventTaskRdy
81106d58 g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
811469ac g     F .text	00000188 __call_exitprocs
8110fb5c g     F .text	0000012c vPerformActionNFCRunning
8114e198 g     O .bss	00000001 OSCPUUsage
811187f4 g     F .text	00000068 vCoudlNotCreateNFee4Task
8114e124 g     O .bss	00000004 __mlocale_changed
8110fa94 g     F .text	000000c8 vPerformActionNFCConfig
8110c14c g     F .text	00000054 bSyncCtrOneShot
8114df5c g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110c8c4 g     F .text	0000003c uliSyncReadStatus
8114e150 g     O .bss	00000004 _alt_tick_rate
81139300 g     F .text	00000294 OSQPend
8112a3e0 g     F .text	000002e8 _strtoll_r
81159cbc g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8113c084 g     F .text	0000010c OSTimeDly
81112454 g     F .text	000000ac vPusMebInTaskRunningMode
8110bb20 g     F .text	0000003c vSyncIrqFlagClrSync
81127bac g     F .text	00000150 __lshift
8110fd50 g     F .text	000002f8 vOutAckHandlerTask
81144428 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8114e154 g     O .bss	00000004 _alt_nticks
81132fd4 g     F .text	00000104 read
8113d760 g     F .text	000000f0 alt_sys_init
8111b358 g     F .text	0000012c .hidden __floatsisf
81106390 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112ac18 g     F .text	000001d8 __ssprint_r
8111d444 g     F .text	00000068 _open_r
8111a628 g     F .text	00000088 bTestSimucamCriticalHW
81105bb0 g     F .text	000000ac bFeebGetBuffersStatus
81116fc8 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
8114e199 g     O .bss	00000001 OSTaskCtr
81131f9c g       .text	00000000 tx_log_str
81111f68 g     F .text	0000015c vPusMebTask
81115e4c g     F .text	00000050 siPosStr
81112ab0 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
8112e8b0 g     F .text	000000d0 strncmp
8110c900 g     F .text	0000005c bSyncWriteReg
811066cc g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
8113c190 g     F .text	00000164 OSTimeDlyHMSM
81127864 g     F .text	00000200 __multiply
8114233c g     F .text	00000070 altera_avalon_jtag_uart_close
8110b684 g     F .text	00000058 v_spi_end
8111a2dc g     F .text	00000040 cGetNextChar
811468c0 g     F .text	000000ec strncpy
8114e350 g     O .bss	00000028 __malloc_current_mallinfo
8114dfae g     O .rwdata	00000002 OSEventMax
8112f870 g     F .text	00000078 .hidden __eqsf2
811280d8 g     F .text	00000154 __d2b
8113a580 g     F .text	00000118 OSSemPost
81105418 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
81119d30 g     F .text	00000030 vChangeDefaultRTValue
8110530c g     F .text	00000040 vFeebCh8HandleIrq
8114e1d4 g     O .bss	00000004 initialized
81115cfc g     F .text	00000100 vSendLog
81134400 g     F .text	000000e4 OSSchedUnlock
8110b6dc g     F .text	00000164 RTCC_SPI_R_MAC
8114df8c g     O .rwdata	00000004 alt_log_boot_on_flag
81141c20 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112a6c8 g     F .text	00000254 _strtoul_r
81159cfc g     O .bss	00000010 xFeeQueueTBL5
81145bd8 g     F .text	000000e4 alt_get_fd
8114e19c g     O .bss	00000004 OSMemFreeList
8113455c g     F .text	000000b8 OSStatInit
8111a5f4 g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
811678e0 g     O .bss	00000014 search_data
81109120 g     F .text	00000134 bSpwcSetLink
81131980 g     F .text	00000130 alt_busy_sleep
81136f1c g     F .text	000000cc OSFlagQuery
8110c268 g     F .text	00000074 bSyncCtrCh1OutEnable
8114dfe4 g     O .rwdata	00000002 OSTaskCreateExtEn
8111a95c g     F .text	00000074 _split_codec_status
81124080 g     F .text	0000005c _close_r
81117c3c g     F .text	00000068 vCouldNotSendEthConfUART
8110f118 g     F .text	00000584 vInitialTask
81132744 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
81144910 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81146844 g     F .text	0000007c memcmp
81134864 g     F .text	00000028 OS_Dummy
81141cf0 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
81167f48 g       *ABS*	00000000 __alt_stack_base
81141d48 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
8110545c g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8111c6e4 g     F .text	000000d4 _fwrite_r
81112e4c g     F .text	000000a4 vReleaseSyncMessages
81144a30 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
8110556c g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
81123f24 g     F .text	0000015c __swsetup_r
81163e7c g     O .bss	00000300 OSQTbl
81118c2c g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
81161814 g     O .bss	0000001c xConfEth
81130320 g     F .text	000008f0 .hidden __divdf3
81119d94 g     F .text	0000003c vChangeSyncSource
81125e5c g     F .text	00000120 __sfp
811678f4 g     O .bss	00000054 boot_sector_data
81118bc4 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
8110958c g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
81128354 g     F .text	00000078 __copybits
8114c650 g     O .rwdata	00000408 __malloc_av_
81125fb0 g     F .text	00000004 __sinit_lock_release
8114e020 g     O .bss	00000004 uliInitialState
81109ecc g     F .text	00000080 i2c_stop
8111aa74 g     F .text	00000064 Verif_Error
8111aad8 g     F .text	00000034 toInt
8111745c g     F .text	0000004c vFailSendPreAckSenderSemaphore
8114e1a0 g     O .bss	00000004 OSTCBHighRdy
8111b57c g     F .text	00000720 .hidden __muldf3
8111db20 g     F .text	0000005c __sread
811262c4 g     F .text	0000003c fread
8114e1a4 g     O .bss	00000004 OSQFreeList
81145ac8 g     F .text	00000110 alt_find_file
81145984 g     F .text	000000ac alt_dev_llist_insert
811337b4 g     F .text	00000128 __malloc_lock
8111c0ec g     F .text	00000030 _fprintf_r
81133144 g     F .text	000000fc sbrk
811195e0 g     F .text	0000002c vFeeSpwRMAPLoadDefault
811179cc g     F .text	00000068 vFailGetCountSemaphorexBuffer64
8111dff8 g     F .text	000021e0 ___svfprintf_internal_r
8111623c g     F .text	00000088 vTMPusTestConnection
8114e0d4 g     O .bss	00000004 xMebQ
81133ad8 g     F .text	00000148 OSEventNameSet
81125b98 g     F .text	00000064 _fflush_r
8112d924 g     F .text	000000cc _calloc_r
8114e1a8 g     O .bss	00000001 OSRdyGrp
81118e98 g     F .text	0000004c vFailSendMsgFeeCTRL
8110bc98 g     F .text	00000044 ucSyncStatusCycleNumber
81106eb8 g     F .text	0000008c bRmapGetCodecConfig
8113cc84 g     F .text	00000148 OSTmrStart
811051c4 g     F .text	00000084 vFeebCh5HandleIrq
8111c0d4 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8114e020 g       *ABS*	00000000 __bss_start
8111d31c g     F .text	00000128 memset
81111308 g     F .text	0000013c setPreParsedFreePos
8110da08 g     F .text	00000174 vQCmdFEEinStandBy
8114548c g     F .text	00000060 alt_msgdma_open
81119eec g     F .text	0000021c pattern_createPattern
81114818 g     F .text	0000018c main
811175e0 g     F .text	00000068 vFailGetMutexReceiverTask
81159d0c g     O .bss	00001000 vNFeeControlTask_stk
81106528 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
81119c4c g     F .text	0000003c vChangeEPValue
81106674 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
8114e14c g     O .bss	00000004 alt_envp
81118f30 g     F .text	0000004c vFailFlushQueue
8114e114 g     O .bss	00000004 __malloc_max_total_mem
81144d30 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111706c g     F .text	0000005c ucCrc8wInit
81117f74 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
81141c88 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110a084 g     F .text	00000160 i2c_read
8115ad0c g     O .bss	00000010 SyncTBL5
81123ea4 g     F .text	00000018 __swbuf
8114bd84 g     O .rodata	00000100 OSUnMapTbl
8112f9a4 g     F .text	000000c8 .hidden __ltsf2
81141024 g     F .text	00000090 alt_up_sd_card_get_attributes
81126090 g     F .text	00000234 _fread_r
811174a8 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
81109878 g     F .text	0000003c bDisableIsoDrivers
8114dfde g     O .rwdata	00000002 OSSemEn
8113d850 g     F .text	000000bc Write_Sector_Data
81141434 g     F .text	00000628 alt_up_sd_card_write
8114e0d8 g     O .bss	00000004 xFeeQ
81136b80 g     F .text	0000039c OSFlagPost
8111dc6c g     F .text	00000008 __sclose
8111827c g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
8112dae8 g     F .text	00000014 fclose
81134a2c g     F .text	00000118 OS_EventTaskWait
81118144 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
8111dd9c g     F .text	00000240 _strtol_r
8111bdb4 g     F .text	000001a8 .hidden __truncdfsf2
8115ad1c g     O .bss	00000010 xFeeQueueTBL2
811356bc g     F .text	000000d4 OS_TaskStatStkChk
8113b49c g     F .text	00000158 OSTaskDelReq
81104af4 g     F .text	000000c4 bDpktGetPacketHeader
8110614c g     F .text	00000040 vRmapCh1HandleIrq
811242e4 g     F .text	00001690 _dtoa_r
8114504c g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
8111c9b8 g     F .text	00000814 _malloc_r
8115ad2c g     O .bss	00000010 SyncTBL0
8112eaec g     F .text	00000030 __ascii_wctomb
81137d18 g     F .text	000001d0 OSMutexCreate
811180dc g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
8110efcc g     F .text	0000014c bCheckInAck32
8114df84 g     O .rwdata	00000004 alt_errno
81144b78 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
811344e4 g     F .text	00000078 OSStart
81109254 g     F .text	000000e4 bSpwcGetLink
8110add8 g     F .text	000004e8 POWER_SPI_RW
8112c034 g     F .text	000000dc __submore
811326a4 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
8113374c g     F .text	00000068 __env_unlock
811186bc g     F .text	00000068 vCoudlNotCreateNFee1Task
81126c08 g     F .text	000000cc _fwalk
8113b950 g     F .text	000001dc OSTaskResume
811379a8 g     F .text	000000f0 OSMemQuery
8114dff0 g     O .rwdata	00000002 OSTaskStatEn
81167f48 g       *ABS*	00000000 __alt_stack_limit
8114e038 g     O .bss	00000004 ECommSpwCh
81119e38 g     F .text	0000003c vChangeAutoResetSync
81127158 g     F .text	00000064 _mbtowc_r
8110e9e8 g     F .text	00000350 vInAckHandlerTaskV2
8114dfca g     O .rwdata	00000002 OSMemMax
81139878 g     F .text	00000178 OSQPostFront
8111d5d0 g     F .text	000000d0 putc
8112f6bc g     F .text	00000084 .hidden __divsi3
8114e1a9 g     O .bss	00000006 OSRdyTbl
8114dfa4 g     O .rwdata	00000002 OSDebugEn
8114cce8 g     O .rwdata	0000002a alt_log_msg_cache
81126300 g     F .text	0000012c _malloc_trim_r
81108c70 g     F .text	000001a4 bRmapInitCh
8114e108 g     O .bss	00000008 xSdHandle
8111af54 g     F .text	00000404 .hidden __mulsf3
8114dfbc g     O .rwdata	00000002 OSFlagNodeSize
8114e024 g     O .bss	00000004 pnt_memory
81119ea4 g     F .text	00000048 vSyncReset
8110bd5c g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
8114e1e0 g     O .bss	00000004 status_register
8114e004 g     O .rwdata	00000002 OSTmrCfgMax
8110c6f0 g     F .text	00000074 bSyncIrqFlagClrError
81117d0c g     F .text	00000068 vFailSetPreAckSenderBuffer
81128b78 g     F .text	000000dc strcmp
8114e1e8 g     O .bss	00000004 command_register
81138e04 g     F .text	000001b4 OSQCreate
8113b5f4 g     F .text	000001a0 OSTaskNameGet
8115ad3c g     O .bss	00001000 vFeeTask4_stk
8115bd3c g     O .bss	00000018 xReceivedACK
811399f0 g     F .text	00000214 OSQPostOpt
81134614 g     F .text	00000228 OSTimeTick
8114dfec g     O .rwdata	00000002 OSTaskMax
81139ed0 g     F .text	000000e0 OSSemCreate
8114e010 g     O .rwdata	00000002 OSTmrWheelSize
8111850c g     F .text	00000068 vFailCreateScheduleQueue
8111a708 g     F .text	00000058 _reg_read
811389b0 g     F .text	00000174 OSMutexQuery
8110dfdc g     F .text	000000a4 bSendGiveBackNFeeCtrl
81130c10 g     F .text	00000088 .hidden __nedf2
8114dfe6 g     O .rwdata	00000002 OSTaskDelEn
81119c14 g     F .text	00000038 vLoadDefaultEPValue
8115bd54 g     O .bss	00001000 vFeeTask1_stk
8110c520 g     F .text	00000074 bSyncCtrCh7OutEnable
8113a698 g     F .text	00000118 OSSemQuery
81138fb8 g     F .text	00000288 OSQDel
81139594 g     F .text	00000174 OSQPendAbort
8114e0dc g     O .bss	00000004 xMutexPreParsed
8113d720 g     F .text	00000040 alt_irq_init
811330d8 g     F .text	0000006c alt_release_fd
8113da40 g     F .text	000000bc get_cluster_flag
8110c764 g     F .text	00000074 bSyncIrqFlagClrBlank
81145784 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110baa8 g     F .text	0000002c vSyncClearCounter
8114ccb4 g     O .rwdata	00000031 alt_log_msg_stackpointer
8111daac g     F .text	00000074 sprintf
8114b46c g     O .rodata	00000100 .hidden __clz_tab
8113e014 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
81117648 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
8114e120 g     O .bss	00000004 _PathLocale
8110c830 g     F .text	00000058 bSyncIrqFlagBlank
8110ac90 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113cdcc g     F .text	000001e8 OSTmrStop
81115dfc g     F .text	00000050 usiGetIdCMD
8110c95c g     F .text	00000058 uliSyncReadReg
8112a2d8 g     F .text	00000108 strtof
811050bc g     F .text	00000084 vFeebCh3HandleIrq
8112f8e8 g     F .text	000000bc .hidden __gesf2
8111dc74 g     F .text	0000004c strcspn
81123ebc g     F .text	00000068 _write_r
8110b32c g     F .text	00000074 vRstcReleaseDeviceReset
81117e90 g     F .text	0000004c vFailInAckHandlerTaskCreate
8113436c g     F .text	00000094 OSSchedLock
8111878c g     F .text	00000068 vCoudlNotCreateNFee3Task
81126eec g     F .text	00000018 setlocale
81144ad8 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8116417c g     O .bss	00000800 OSTmrTaskStk
8111d9d0 g     F .text	00000044 scanf
811189fc g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
81135f74 g     F .text	00000110 OSFlagCreate
8113e2a8 g     F .text	00000688 Check_for_DOS_FAT
81112cdc g     F .text	00000064 vMebInit
81140154 g     F .text	000002d0 create_file
81128b70 g     F .text	00000008 nanf
8114df58 g     O .rwdata	00000004 _impure_ptr
8114e1e4 g     O .bss	00000004 CSD_register_w0
8114e144 g     O .bss	00000004 alt_argc
81117964 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
81125974 g     F .text	00000224 __sflush_r
81126f78 g     F .text	000000b4 _mbrtowc_r
811094fc g     F .text	00000090 bSpwcGetTimecode
81126ed8 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
8114e030 g     O .bss	00000004 ESdmaBufferSide
8114dfb6 g     O .rwdata	00000002 OSEventMultiEn
8111c1f8 g     F .text	00000004 _fseek_r
8115cd54 g     O .bss	00001800 vParserCommTask_stk
811171a8 g     F .text	00000070 printErrorTask
81119c88 g     F .text	00000030 vChangeDefaultEPValue
81113dcc g     F .text	000002c8 vCheckRetransmission32
8113c59c g     F .text	000001c4 OSTmrCreate
81112ef0 g     F .text	000007dc vStackMonitor
8111d798 g     F .text	000001dc __srefill_r
811098b4 g     F .text	0000003c bEnableLvdsBoard
8114e0e0 g     O .bss	00000004 xMutexBuffer32
8110618c g     F .text	00000040 vRmapCh2HandleIrq
81136084 g     F .text	00000250 OSFlagDel
8114e1b0 g     O .bss	00000004 OSEventFreeList
8110992c g     F .text	000000c0 bSetPreEmphasys
8110d898 g     F .text	00000170 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112710c g     F .text	0000004c __ascii_mbtowc
8110c02c g     F .text	00000078 bSyncCtrExtnIrq
81127f60 g     F .text	00000064 __ulp
811197c0 g     F .text	0000010c vNFeeControlInit
81112d40 g     F .text	0000010c vSwapMemmory
81136558 g     F .text	000005c0 OSFlagPend
8114e002 g     O .rwdata	00000002 OSTmrEn
81125fcc g     F .text	00000018 __fp_unlock_all
8115e554 g     O .bss	00000010 xDma
8111c194 g     F .text	00000064 fputc
8110dd58 g     F .text	00000050 bEnableRmapIRQ
81115544 g     F .text	000002f8 bSendUART32v2
811115c0 g     F .text	0000019c setPreAckReceiverFreePos
8110bfec g     F .text	00000040 bSyncErrInj
8114df70 g     O .rwdata	00000008 alt_fs_list
8115e564 g     O .bss	00001000 vSimMebTask_stk
81118994 g     F .text	00000068 vCoudlNotCreateMebTask
8113eaf0 g     F .text	00000274 check_file_name_for_FAT16_compliance
8115f564 g     O .bss	00001000 vFeeTask3_stk
8113c8a0 g     F .text	00000140 OSTmrNameGet
8114e478 g     O .bss	00000400 xSZData
8110db7c g     F .text	00000190 vQCmdFEEinFullPattern
8113549c g     F .text	0000007c OS_StrCopy
8114e1f0 g     O .bss	00000004 buffer_memory
81117b6c g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
81119a90 g     F .text	00000098 vLogWriteNUC
8114dfcc g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110c67c g     F .text	00000074 bSyncIrqEnableBlank
811466e4 g     F .text	00000028 OSInitHookEnd
811192a0 g     F .text	00000340 vUpdateMemMapFEE
81117ddc g     F .text	00000068 vFailSetPreAckReceiverBuffer
811057d4 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
8114dff8 g     O .rwdata	00000002 OSTCBPrioTblMax
81126f04 g     F .text	0000000c localeconv
8111892c g     F .text	00000068 vCoudlNotCreateDataControllerTask
8114e0e4 g     O .bss	00000004 xTimerRetransmission
811110b8 g     F .text	00000250 vReceiverUartTask
8114e140 g     O .bss	00000004 alt_log_sys_clk_count
8114dff4 g     O .rwdata	00000002 OSTaskStatStkChkEn
811328f4 g     F .text	00000140 alt_log_write
81160564 g     O .bss	00001000 vFeeTask2_stk
8114e0e8 g     O .bss	00000004 xMutexBuffer128
81104fdc g     F .text	0000005c vFeebCh1HandleIrq
8111a58c g     F .text	00000038 bStartSync
811052cc g     F .text	00000040 vFeebCh7HandleIrq
8111a5c4 g     F .text	00000030 bStopSync
81145cbc g     F .text	00000058 alt_ic_isr_register
8114dfc8 g     O .rwdata	00000002 OSMemEn
811061cc g     F .text	00000040 vRmapCh3HandleIrq
8114df44 g     O .rwdata	00000004 alt_stack_limit_value
811126a0 g     F .text	00000388 vPusType252run
81118e4c g     F .text	0000004c vFailSendMsgMasterSyncMeb
8111c7b8 g     F .text	0000003c fwrite
8114e1f4 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8114dfd2 g     O .rwdata	00000002 OSMutexEn
81118c94 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
8114e020 g       *ABS*	00000000 _edata
81142b3c g     F .text	00000068 altera_avalon_uart_read_fd
81119940 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81167f48 g       *ABS*	00000000 _end
81167948 g     O .bss	00000500 active_files
8114e1b4 g     O .bss	00000001 OSIntNesting
811176fc g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
811196bc g     F .text	0000002c cFeeRMAPDump
8114e0ec g     O .bss	00000004 xSemCountBuffer32
8112dafc g     F .text	0000016c __fputwc
8114e0f0 g     O .bss	00000004 xQMaskFeeCtrl
8111960c g     F .text	0000002c vFeeSpwRMAPChangeConfig
81123c7c g     F .text	00000070 vfscanf
81140424 g     F .text	00000150 copy_file_record_name_to_string
811423ac g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8113c2f4 g     F .text	000001dc OSTimeDlyResume
8113e930 g     F .text	000000f4 Look_for_FAT16
8110dda8 g     F .text	00000060 bDisableSPWChannel
81136404 g     F .text	00000154 OSFlagNameSet
8110ded4 g     F .text	00000064 bDisAndClrDbBuffer
8114e0f4 g     O .bss	00000004 xMutexBuffer64
811070a4 g     F .text	00000160 bRmapGetCodecError
8113bb2c g     F .text	000001c8 OSTaskStkChk
81145da4 g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	0000040c bSdmaDmaM1Transfer
8114dfce g     O .rwdata	00000002 OSMemSize
81112250 g     F .text	00000204 vPusType252conf
8111782c g     F .text	00000068 vFailSetCountSemaphorexBuffer32
8111db84 g     F .text	00000084 __swrite
8114df60 g     O .rwdata	00000004 __malloc_trim_threshold
81126ecc g     F .text	0000000c __locale_msgcharset
81161564 g     O .bss	00000010 xFeeQueueTBL1
8114e1b8 g     O .bss	00000004 OSTCBCur
811181ac g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110ad94 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
81146804 g     F .text	00000040 exit
81138790 g     F .text	00000220 OSMutexPost
8110c7d8 g     F .text	00000058 bSyncIrqFlagError
81140850 g     F .text	000003c0 alt_up_sd_card_find_next
8114dfd0 g     O .rwdata	00000002 OSMemTblSize
81126cd4 g     F .text	000000cc _fwalk_reent
81144ed0 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111b484 g     F .text	000000f8 .hidden __floatunsisf
81127d5c g     F .text	00000204 __mdiff
81118654 g     F .text	00000068 vCoudlNotCreateNFee0Task
8110582c g     F .text	0000017c vFeebInitIrq
8110479c g     F .text	0000022c bDpktSetPacketConfig
81117794 g     F .text	0000004c vFailSenderCreate
8112f740 g     F .text	00000074 .hidden __modsi3
8111885c g     F .text	00000068 vCoudlNotCreateNFee5Task
8110bf38 g     F .text	0000003c uliSyncGetPer
8110628c g     F .text	00000040 vRmapCh6HandleIrq
8114e0f8 g     O .bss	00000004 xMutexSenderACK
8111800c g     F .text	00000068 vFailGetBlockingSemTimeoutTask
8114df50 g     O .rwdata	00000004 __ctype_ptr__
81117d74 g     F .text	00000068 vFailSetPreParsedBuffer
8113d960 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
81125fa8 g     F .text	00000004 __sfp_lock_release
81105a7c g     F .text	000000ac bFeebGetIrqControl
811182e4 g     F .text	00000068 vCouldNotSendTurnOff
811341b4 g     F .text	00000064 OSInit
8110a264 g     F .text	00000078 bSetPainelLeds
81144618 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8114e1bc g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107204 g     F .text	000002ec bRmapSetMemConfigArea
8113bee0 g     F .text	0000012c OSTaskQuery
8110c608 g     F .text	00000074 bSyncIrqEnableError
8114e0fc g     O .bss	00000004 xMutexPus
81139d68 g     F .text	000000b0 OS_QInit
81128aa0 g     F .text	000000d0 __sccl
8111bfc0 g     F .text	0000000c atoi
8110ca54 g     F .text	00000e44 vFeeTask
81135518 g     F .text	0000005c OS_StrLen
81119014 g     F .text	0000004c vFailFlushNFEEQueue
811055c4 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
811170c8 g     F .text	000000e0 vDataControllerInit
811377ac g     F .text	0000011c OSMemNameSet
8114b56c g     O .rodata	00000101 _ctype_
8110befc g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
811178fc g     F .text	00000068 vFailSetCountSemaphorexBuffer128
8114dfea g     O .rwdata	00000002 OSTaskProfileEn
81119060 g     F .text	00000028 vEvtChangeMebMode
811444e8 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8114e100 g     O .bss	00000004 xTxUARTMutex
8114e1c0 g     O .bss	00000004 OSTime
8114df68 g     O .rwdata	00000004 __mbtowc
8114315c g     F .text	0000005c altera_avalon_uart_close
8114e1c4 g     O .bss	00000004 OSTmrSem
811121fc g     F .text	00000054 vPusType251conf
8116497c g     O .bss	00001000 OSTaskIdleStk
8111bfd8 g     F .text	000000fc _fopen_r
8114e09c g     O .bss	00000004 pdata
81146b34 g     F .text	000000bc _exit
8114580c g     F .text	00000134 alt_alarm_start
811362d4 g     F .text	00000130 OSFlagNameGet
8113c4d0 g     F .text	00000064 OSTimeGet
8114e034 g     O .bss	00000004 ESdmaChBufferId
811410b4 g     F .text	00000380 alt_up_sd_card_read
8110645c g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8111c7f4 g     F .text	000001c4 __smakebuf_r
8114e104 g     O .bss	00000001 SemCount64
8111524c g     F .text	000002f8 bSendUART64v2
81118f7c g     F .text	0000004c vFailFlushQueueData
81105674 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
8114e018 g     O .rwdata	00000008 alt_msgdma_list
8111dcc0 g     F .text	00000098 strlen
8110b5d0 g     F .text	000000b4 uc_spi_get_byte
811064a0 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
81118cfc g     F .text	00000054 vFailSendMsgAccessDMA
81146614 g     F .text	00000028 OSTaskSwHook
81132e34 g     F .text	0000015c open
811084a4 g     F .text	000007cc bRmapGetRmapMemHKArea
8116597c g     O .bss	00000d00 OSEventTbl
81119638 g     F .text	0000002c vFeeSpwRMAPChangeDefault
81130c98 g     F .text	000000dc .hidden __gedf2
81161574 g     O .bss	00000020 xSenderACK
81146308 g     F .text	00000044 alt_putchar
8116667c g     O .bss	000011b8 OSTCBTbl
8112de14 g     F .text	00000838 __gethex
8113a7b0 g     F .text	00000108 OSSemSet
811136cc g     F .text	0000006c vTimeoutCheckerTaskv2
811196e8 g     F .text	00000038 cFeeRMAPEchoingEnable
8114df6c g     O .rwdata	00000004 __wctomb
81114504 g     F .text	00000314 vVariablesInitialization
8112c3c8 g     F .text	00000018 __sprint_r
81105b28 g     F .text	00000088 bFeebGetIrqFlags
8114e02c g     O .bss	00000004 pxDmaM2Dev
811172c4 g     F .text	0000004c vFailCreateSemaphoreResources
8114df88 g     O .rwdata	00000004 alt_priority_mask
811098f0 g     F .text	0000003c bDisableLvdsBoard
81139fb0 g     F .text	00000248 OSSemDel
8114e1c8 g     O .bss	00000004 OSFlagFreeList
8110b50c g     F .text	000000c4 v_spi_send_byte
8110b840 g     F .text	000000d0 bSSDisplayConfig
81145d14 g     F .text	00000090 alt_ic_irq_enable
8114dfb0 g     O .rwdata	00000002 OSEventNameSize
811223d8 g     F .text	0000001c __vfprintf_internal
8114e1cc g     O .bss	00000001 OSStatRdy
8110c2dc g     F .text	00000074 bSyncCtrCh2OutEnable
81167834 g     O .bss	000000ac OSTCBPrioTbl
811431fc g     F .text	00000270 altera_avalon_uart_read
8112eb1c g     F .text	00000064 _wctomb_r
81133680 g     F .text	000000cc __env_lock
8114dff6 g     O .rwdata	00000002 OSTaskSwHookEn
811053d4 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81130e68 g     F .text	00000904 .hidden __subdf3
81161594 g     O .bss	00000260 xPreParsed
8110bf74 g     F .text	0000003c uliSyncGetOst
8114e105 g     O .bss	00000001 SemCount128
8110630c g     F .text	00000040 vRmapCh8HandleIrq
811054a0 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
8111583c g     F .text	00000290 vSendEthConf
8110461c g     F .text	000000dc bCommInitCh
81127770 g     F .text	000000b0 __lo0bits
811224b8 g     F .text	000017c4 __svfscanf_r
8114df94 g     O .rwdata	00000008 alt_alarm_list
8112c110 g     F .text	0000019c _ungetc_r
8114dfbe g     O .rwdata	00000002 OSFlagWidth
8110634c g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
8112ea24 g     F .text	000000c8 wcrtomb
81104bb8 g     F .text	00000148 bDpktSetPixelDelay
81114e64 g     F .text	00000068 vCCDLoadDefaultValues
81131af4 g     F .text	000000d8 close
8110bfb0 g     F .text	0000003c uliSyncGetGeneral
811190b0 g     F .text	00000028 vEvtChangeDataControllerMode
8114e15c g     O .bss	00000004 alt_envsem
81132024 g     F .text	00000068 alt_log_repchar
8114e1d0 g     O .bss	00000004 OSIdleCtrRun
8113483c g     F .text	00000028 OSVersion
8114e008 g     O .rwdata	00000002 OSTmrCfgWheelSize
8113c00c g     F .text	00000078 OS_TaskStkClr
8111a260 g     F .text	0000003c siOpenFile
8110c9b4 g     F .text	000000a0 vDataControlTask
8114dfe2 g     O .rwdata	00000002 OSTaskCreateEn
811065c4 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81106a0c g     F .text	00000050 uliRmapCh7WriteCmdAddress
81105d8c g     F .text	00000088 bFeebStartCh
81115acc g     F .text	00000118 vSendTurnOff
811173c4 g     F .text	0000004c vFailSendPreParsedSemaphore
8113ee24 g     F .text	000002a4 match_file_record_to_name_ext
81134e64 g     F .text	00000070 OS_EventWaitListInit
8112dc8c g     F .text	00000088 fputwc
811617f4 g     O .bss	00000010 xFeeQueueTBL0
8111735c g     F .text	00000068 vFailSendxSemCommInit
8114670c g     F .text	00000028 OSTaskIdleHook
81115be4 g     F .text	00000118 vSendReset
81125fac g     F .text	00000004 __sinit_lock_acquire
811274d4 g     F .text	00000128 __multadd
81161804 g     O .bss	00000010 SyncTBL1
811054e4 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110bc00 g     F .text	0000004c ucSyncStatusState
8113bcf4 g     F .text	000001ec OSTaskSuspend
811274ac g     F .text	00000028 _Bfree
8110bec0 g     F .text	0000003c uliSyncGetMbt
81135574 g     F .text	00000064 OS_TaskIdle
8114e00e g     O .rwdata	00000002 OSTmrTblSize
81139c04 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	11342180 	call	81134218 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045b4 	movhi	r2,33046
81100150:	109f9204 	addi	r2,r2,32328
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045b4 	movhi	r2,33046
81100168:	109f9204 	addi	r2,r2,32328
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	113426c0 	call	8113426c <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b217 	ldw	r2,-32056(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b217 	ldw	r2,-32056(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	2137e304 	addi	r4,r4,-8308
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	21333a04 	addi	r4,r4,-13080
81100274:	1131f9c0 	call	81131f9c <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	2137e304 	addi	r4,r4,-8308
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	21332d04 	addi	r4,r4,-13132
81100290:	1131f9c0 	call	81131f9c <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d697d114 	ori	gp,gp,24388
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	2137e304 	addi	r4,r4,-8308
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	21331e04 	addi	r4,r4,-13192
811002bc:	1131f9c0 	call	81131f9c <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	10b80814 	ori	r2,r2,57376

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18dfd214 	ori	r3,r3,32584

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	2137e304 	addi	r4,r4,-8308
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	21332504 	addi	r4,r4,-13164
811002fc:	1131f9c0 	call	81131f9c <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	1132bc80 	call	81132bc8 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18f8de04 	addi	r3,r3,-7304
81100330:	00a04534 	movhi	r2,33044
81100334:	109afc04 	addi	r2,r2,27632
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a05d17 	ldw	r2,-32396(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	2978de04 	addi	r5,r5,-7304
8110035c:	1009883a 	mov	r4,r2
81100360:	111c11c0 	call	8111c11c <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18f8de04 	addi	r3,r3,-7304
811003cc:	00a04534 	movhi	r2,33044
811003d0:	109b0504 	addi	r2,r2,27668
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	111d1cc0 	call	8111d1cc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a05d17 	ldw	r2,-32396(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	2978de04 	addi	r5,r5,-7304
811003f8:	1009883a 	mov	r4,r2
811003fc:	111c11c0 	call	8111c11c <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18f8de04 	addi	r3,r3,-7304
81100410:	00a04534 	movhi	r2,33044
81100414:	109b1104 	addi	r2,r2,27716
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a05d17 	ldw	r2,-32396(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	2978de04 	addi	r5,r5,-7304
8110043c:	1009883a 	mov	r4,r2
81100440:	111c11c0 	call	8111c11c <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	11333f40 	call	811333f4 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	1109bd00 	call	81109bd0 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604534 	movhi	r5,33044
811004b0:	295b1704 	addi	r5,r5,27740
811004b4:	01204574 	movhi	r4,33045
811004b8:	2138de04 	addi	r4,r4,-7304
811004bc:	111daac0 	call	8111daac <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a05d17 	ldw	r2,-32396(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	2978de04 	addi	r5,r5,-7304
811004cc:	1009883a 	mov	r4,r2
811004d0:	111c11c0 	call	8111c11c <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18f8de04 	addi	r3,r3,-7304
811004e0:	00a04534 	movhi	r2,33044
811004e4:	109b1c04 	addi	r2,r2,27760
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	111d1cc0 	call	8111d1cc <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a05d17 	ldw	r2,-32396(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	2978de04 	addi	r5,r5,-7304
8110050c:	1009883a 	mov	r4,r2
81100510:	111c11c0 	call	8111c11c <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18f8de04 	addi	r3,r3,-7304
81100544:	00a04534 	movhi	r2,33044
81100548:	109b2204 	addi	r2,r2,27784
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a05d17 	ldw	r2,-32396(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	2978de04 	addi	r5,r5,-7304
81100570:	1009883a 	mov	r4,r2
81100574:	111c11c0 	call	8111c11c <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18f8de04 	addi	r3,r3,-7304
81100584:	00a04534 	movhi	r2,33044
81100588:	109b2b04 	addi	r2,r2,27820
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a05d17 	ldw	r2,-32396(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	2978de04 	addi	r5,r5,-7304
811005b0:	1009883a 	mov	r4,r2
811005b4:	111c11c0 	call	8111c11c <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18f8de04 	addi	r3,r3,-7304
811005c0:	00a04534 	movhi	r2,33044
811005c4:	109b3304 	addi	r2,r2,27852
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a05d17 	ldw	r2,-32396(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	2978de04 	addi	r5,r5,-7304
811005ec:	1009883a 	mov	r4,r2
811005f0:	111c11c0 	call	8111c11c <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	11333f40 	call	811333f4 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	1109af00 	call	81109af0 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18f8de04 	addi	r3,r3,-7304
81100650:	00a04534 	movhi	r2,33044
81100654:	109b3904 	addi	r2,r2,27876
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a05d17 	ldw	r2,-32396(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	2978de04 	addi	r5,r5,-7304
8110067c:	1009883a 	mov	r4,r2
81100680:	111c11c0 	call	8111c11c <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	1109bd00 	call	81109bd0 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18f8de04 	addi	r3,r3,-7304
811006cc:	00a04534 	movhi	r2,33044
811006d0:	109b3f04 	addi	r2,r2,27900
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	111d1cc0 	call	8111d1cc <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a05d17 	ldw	r2,-32396(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	2978de04 	addi	r5,r5,-7304
811006f8:	1009883a 	mov	r4,r2
811006fc:	111c11c0 	call	8111c11c <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604534 	movhi	r5,33044
81100730:	295b4804 	addi	r5,r5,27936
81100734:	01204574 	movhi	r4,33045
81100738:	2138de04 	addi	r4,r4,-7304
8110073c:	111daac0 	call	8111daac <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a05d17 	ldw	r2,-32396(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	2978de04 	addi	r5,r5,-7304
8110074c:	1009883a 	mov	r4,r2
81100750:	111c11c0 	call	8111c11c <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18f8de04 	addi	r3,r3,-7304
81100764:	00a04534 	movhi	r2,33044
81100768:	109b5704 	addi	r2,r2,27996
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a05d17 	ldw	r2,-32396(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	2978de04 	addi	r5,r5,-7304
81100790:	1009883a 	mov	r4,r2
81100794:	111c11c0 	call	8111c11c <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18f8de04 	addi	r3,r3,-7304
811007a4:	00a04534 	movhi	r2,33044
811007a8:	109b6004 	addi	r2,r2,28032
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a05d17 	ldw	r2,-32396(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	2978de04 	addi	r5,r5,-7304
811007d0:	1009883a 	mov	r4,r2
811007d4:	111c11c0 	call	8111c11c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10b8de04 	addi	r2,r2,-7304
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a05d17 	ldw	r2,-32396(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	2978de04 	addi	r5,r5,-7304
811007f8:	1009883a 	mov	r4,r2
811007fc:	111c11c0 	call	8111c11c <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18f8de04 	addi	r3,r3,-7304
81100840:	00a04534 	movhi	r2,33044
81100844:	109b6804 	addi	r2,r2,28064
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a05d17 	ldw	r2,-32396(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	2978de04 	addi	r5,r5,-7304
8110086c:	1009883a 	mov	r4,r2
81100870:	111c11c0 	call	8111c11c <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18f8de04 	addi	r3,r3,-7304
811008dc:	00a04534 	movhi	r2,33044
811008e0:	109b7104 	addi	r2,r2,28100
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	111d1cc0 	call	8111d1cc <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a05d17 	ldw	r2,-32396(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	2978de04 	addi	r5,r5,-7304
81100908:	1009883a 	mov	r4,r2
8110090c:	111c11c0 	call	8111c11c <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	1109cd80 	call	81109cd8 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604534 	movhi	r5,33044
81100984:	295b7d04 	addi	r5,r5,28148
81100988:	01204574 	movhi	r4,33045
8110098c:	2138de04 	addi	r4,r4,-7304
81100990:	111daac0 	call	8111daac <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a05d17 	ldw	r2,-32396(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	2978de04 	addi	r5,r5,-7304
811009a0:	1009883a 	mov	r4,r2
811009a4:	111c11c0 	call	8111c11c <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18f8de04 	addi	r3,r3,-7304
811009c0:	00a04534 	movhi	r2,33044
811009c4:	109b8904 	addi	r2,r2,28196
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	111d1cc0 	call	8111d1cc <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a05d17 	ldw	r2,-32396(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	2978de04 	addi	r5,r5,-7304
811009ec:	1009883a 	mov	r4,r2
811009f0:	111c11c0 	call	8111c11c <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18f8de04 	addi	r3,r3,-7304
81100a0c:	00a04534 	movhi	r2,33044
81100a10:	109b9504 	addi	r2,r2,28244
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a05d17 	ldw	r2,-32396(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	2978de04 	addi	r5,r5,-7304
81100a38:	1009883a 	mov	r4,r2
81100a3c:	111c11c0 	call	8111c11c <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18f8de04 	addi	r3,r3,-7304
81100a58:	00a04534 	movhi	r2,33044
81100a5c:	109b9d04 	addi	r2,r2,28276
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	111d1cc0 	call	8111d1cc <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a05d17 	ldw	r2,-32396(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	2978de04 	addi	r5,r5,-7304
81100a84:	1009883a 	mov	r4,r2
81100a88:	111c11c0 	call	8111c11c <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18f8de04 	addi	r3,r3,-7304
81100aa4:	00a04534 	movhi	r2,33044
81100aa8:	109ba704 	addi	r2,r2,28316
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	111d1cc0 	call	8111d1cc <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a05d17 	ldw	r2,-32396(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	2978de04 	addi	r5,r5,-7304
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	111c11c0 	call	8111c11c <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18f8de04 	addi	r3,r3,-7304
81100af0:	00a04534 	movhi	r2,33044
81100af4:	109bb204 	addi	r2,r2,28360
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	111d1cc0 	call	8111d1cc <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a05d17 	ldw	r2,-32396(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	2978de04 	addi	r5,r5,-7304
81100b1c:	1009883a 	mov	r4,r2
81100b20:	111c11c0 	call	8111c11c <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18f8de04 	addi	r3,r3,-7304
81100b3c:	00a04534 	movhi	r2,33044
81100b40:	109bbe04 	addi	r2,r2,28408
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a05d17 	ldw	r2,-32396(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	2978de04 	addi	r5,r5,-7304
81100b68:	1009883a 	mov	r4,r2
81100b6c:	111c11c0 	call	8111c11c <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18f8de04 	addi	r3,r3,-7304
81100b88:	00a04534 	movhi	r2,33044
81100b8c:	109bc404 	addi	r2,r2,28432
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a05d17 	ldw	r2,-32396(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	2978de04 	addi	r5,r5,-7304
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	111c11c0 	call	8111c11c <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18f8de04 	addi	r3,r3,-7304
81100bd4:	00a04534 	movhi	r2,33044
81100bd8:	109bcc04 	addi	r2,r2,28464
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	111d1cc0 	call	8111d1cc <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a05d17 	ldw	r2,-32396(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	2978de04 	addi	r5,r5,-7304
81100c00:	1009883a 	mov	r4,r2
81100c04:	111c11c0 	call	8111c11c <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18f8de04 	addi	r3,r3,-7304
81100c20:	00a04534 	movhi	r2,33044
81100c24:	109bd904 	addi	r2,r2,28516
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a05d17 	ldw	r2,-32396(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	2978de04 	addi	r5,r5,-7304
81100c4c:	1009883a 	mov	r4,r2
81100c50:	111c11c0 	call	8111c11c <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18f8de04 	addi	r3,r3,-7304
81100c6c:	00a04534 	movhi	r2,33044
81100c70:	109bdf04 	addi	r2,r2,28540
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a05d17 	ldw	r2,-32396(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	2978de04 	addi	r5,r5,-7304
81100c98:	1009883a 	mov	r4,r2
81100c9c:	111c11c0 	call	8111c11c <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18f8de04 	addi	r3,r3,-7304
81100cb8:	00a04534 	movhi	r2,33044
81100cbc:	109be404 	addi	r2,r2,28560
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a05d17 	ldw	r2,-32396(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	2978de04 	addi	r5,r5,-7304
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	111c11c0 	call	8111c11c <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18f8de04 	addi	r3,r3,-7304
81100d04:	00a04534 	movhi	r2,33044
81100d08:	109beb04 	addi	r2,r2,28588
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	111d1cc0 	call	8111d1cc <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a05d17 	ldw	r2,-32396(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	2978de04 	addi	r5,r5,-7304
81100d30:	1009883a 	mov	r4,r2
81100d34:	111c11c0 	call	8111c11c <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18f8de04 	addi	r3,r3,-7304
81100d50:	00a04534 	movhi	r2,33044
81100d54:	109bf904 	addi	r2,r2,28644
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	111d1cc0 	call	8111d1cc <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a05d17 	ldw	r2,-32396(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	2978de04 	addi	r5,r5,-7304
81100d7c:	1009883a 	mov	r4,r2
81100d80:	111c11c0 	call	8111c11c <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18f8de04 	addi	r3,r3,-7304
81100d9c:	00a04534 	movhi	r2,33044
81100da0:	109c0b04 	addi	r2,r2,28716
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a05d17 	ldw	r2,-32396(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	2978de04 	addi	r5,r5,-7304
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	111c11c0 	call	8111c11c <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18f8de04 	addi	r3,r3,-7304
81100de8:	00a04534 	movhi	r2,33044
81100dec:	109c1304 	addi	r2,r2,28748
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	111d1cc0 	call	8111d1cc <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a05d17 	ldw	r2,-32396(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	2978de04 	addi	r5,r5,-7304
81100e14:	1009883a 	mov	r4,r2
81100e18:	111c11c0 	call	8111c11c <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18f8de04 	addi	r3,r3,-7304
81100e34:	00a04534 	movhi	r2,33044
81100e38:	109c1d04 	addi	r2,r2,28788
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	111d1cc0 	call	8111d1cc <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a05d17 	ldw	r2,-32396(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	2978de04 	addi	r5,r5,-7304
81100e60:	1009883a 	mov	r4,r2
81100e64:	111c11c0 	call	8111c11c <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18f8de04 	addi	r3,r3,-7304
81100e80:	00a04534 	movhi	r2,33044
81100e84:	109c2a04 	addi	r2,r2,28840
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	111d1cc0 	call	8111d1cc <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a05d17 	ldw	r2,-32396(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	2978de04 	addi	r5,r5,-7304
81100eac:	1009883a 	mov	r4,r2
81100eb0:	111c11c0 	call	8111c11c <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18f8de04 	addi	r3,r3,-7304
81100ecc:	00a04534 	movhi	r2,33044
81100ed0:	109c3404 	addi	r2,r2,28880
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	111d1cc0 	call	8111d1cc <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a05d17 	ldw	r2,-32396(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	2978de04 	addi	r5,r5,-7304
81100ef8:	1009883a 	mov	r4,r2
81100efc:	111c11c0 	call	8111c11c <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18f8de04 	addi	r3,r3,-7304
81100f18:	00a04534 	movhi	r2,33044
81100f1c:	109c3f04 	addi	r2,r2,28924
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	111d1cc0 	call	8111d1cc <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a05d17 	ldw	r2,-32396(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	2978de04 	addi	r5,r5,-7304
81100f44:	1009883a 	mov	r4,r2
81100f48:	111c11c0 	call	8111c11c <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18f8de04 	addi	r3,r3,-7304
81100f64:	00a04534 	movhi	r2,33044
81100f68:	109c5004 	addi	r2,r2,28992
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	111d1cc0 	call	8111d1cc <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a05d17 	ldw	r2,-32396(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	2978de04 	addi	r5,r5,-7304
81100f90:	1009883a 	mov	r4,r2
81100f94:	111c11c0 	call	8111c11c <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18f8de04 	addi	r3,r3,-7304
81100fb0:	00a04534 	movhi	r2,33044
81100fb4:	109c5b04 	addi	r2,r2,29036
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	111d1cc0 	call	8111d1cc <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a05d17 	ldw	r2,-32396(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	2978de04 	addi	r5,r5,-7304
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	111c11c0 	call	8111c11c <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18f8de04 	addi	r3,r3,-7304
81100ffc:	00a04534 	movhi	r2,33044
81101000:	109c6804 	addi	r2,r2,29088
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	111d1cc0 	call	8111d1cc <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a05d17 	ldw	r2,-32396(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	2978de04 	addi	r5,r5,-7304
81101028:	1009883a 	mov	r4,r2
8110102c:	111c11c0 	call	8111c11c <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18f8de04 	addi	r3,r3,-7304
81101048:	00a04534 	movhi	r2,33044
8110104c:	109c7604 	addi	r2,r2,29144
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	111d1cc0 	call	8111d1cc <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a05d17 	ldw	r2,-32396(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	2978de04 	addi	r5,r5,-7304
81101074:	1009883a 	mov	r4,r2
81101078:	111c11c0 	call	8111c11c <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18f8de04 	addi	r3,r3,-7304
81101094:	00a04534 	movhi	r2,33044
81101098:	109c8304 	addi	r2,r2,29196
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	111d1cc0 	call	8111d1cc <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a05d17 	ldw	r2,-32396(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	2978de04 	addi	r5,r5,-7304
811010c0:	1009883a 	mov	r4,r2
811010c4:	111c11c0 	call	8111c11c <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18f8de04 	addi	r3,r3,-7304
811010e0:	00a04534 	movhi	r2,33044
811010e4:	109c9004 	addi	r2,r2,29248
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a05d17 	ldw	r2,-32396(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	2978de04 	addi	r5,r5,-7304
8110110c:	1009883a 	mov	r4,r2
81101110:	111c11c0 	call	8111c11c <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10b8de04 	addi	r2,r2,-7304
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a05d17 	ldw	r2,-32396(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	2978de04 	addi	r5,r5,-7304
81101194:	1009883a 	mov	r4,r2
81101198:	111c11c0 	call	8111c11c <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18f8de04 	addi	r3,r3,-7304
811011b4:	00a04534 	movhi	r2,33044
811011b8:	109c9404 	addi	r2,r2,29264
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a05d17 	ldw	r2,-32396(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	2978de04 	addi	r5,r5,-7304
811011e0:	1009883a 	mov	r4,r2
811011e4:	111c11c0 	call	8111c11c <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18f8de04 	addi	r3,r3,-7304
81101200:	00a04534 	movhi	r2,33044
81101204:	109c9c04 	addi	r2,r2,29296
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	111d1cc0 	call	8111d1cc <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a05d17 	ldw	r2,-32396(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	2978de04 	addi	r5,r5,-7304
8110122c:	1009883a 	mov	r4,r2
81101230:	111c11c0 	call	8111c11c <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18f8de04 	addi	r3,r3,-7304
8110124c:	00a04534 	movhi	r2,33044
81101250:	109caa04 	addi	r2,r2,29352
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a05d17 	ldw	r2,-32396(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	2978de04 	addi	r5,r5,-7304
81101278:	1009883a 	mov	r4,r2
8110127c:	111c11c0 	call	8111c11c <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18f8de04 	addi	r3,r3,-7304
81101298:	00a04534 	movhi	r2,33044
8110129c:	109cb204 	addi	r2,r2,29384
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a05d17 	ldw	r2,-32396(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	2978de04 	addi	r5,r5,-7304
811012c4:	1009883a 	mov	r4,r2
811012c8:	111c11c0 	call	8111c11c <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18f8de04 	addi	r3,r3,-7304
811012e4:	00a04534 	movhi	r2,33044
811012e8:	109cba04 	addi	r2,r2,29416
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	111d1cc0 	call	8111d1cc <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a05d17 	ldw	r2,-32396(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	2978de04 	addi	r5,r5,-7304
81101310:	1009883a 	mov	r4,r2
81101314:	111c11c0 	call	8111c11c <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18f8de04 	addi	r3,r3,-7304
81101330:	00a04534 	movhi	r2,33044
81101334:	109cc404 	addi	r2,r2,29456
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a05d17 	ldw	r2,-32396(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	2978de04 	addi	r5,r5,-7304
8110135c:	1009883a 	mov	r4,r2
81101360:	111c11c0 	call	8111c11c <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18f8de04 	addi	r3,r3,-7304
8110137c:	00a04534 	movhi	r2,33044
81101380:	109ccb04 	addi	r2,r2,29484
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	111d1cc0 	call	8111d1cc <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a05d17 	ldw	r2,-32396(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	2978de04 	addi	r5,r5,-7304
811013a8:	1009883a 	mov	r4,r2
811013ac:	111c11c0 	call	8111c11c <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18f8de04 	addi	r3,r3,-7304
811013c8:	00a04534 	movhi	r2,33044
811013cc:	109cd504 	addi	r2,r2,29524
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a05d17 	ldw	r2,-32396(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	2978de04 	addi	r5,r5,-7304
811013f4:	1009883a 	mov	r4,r2
811013f8:	111c11c0 	call	8111c11c <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10b8de04 	addi	r2,r2,-7304
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a05d17 	ldw	r2,-32396(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	2978de04 	addi	r5,r5,-7304
81101420:	1009883a 	mov	r4,r2
81101424:	111c11c0 	call	8111c11c <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18f8de04 	addi	r3,r3,-7304
81101454:	00a04534 	movhi	r2,33044
81101458:	109cdf04 	addi	r2,r2,29564
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a05d17 	ldw	r2,-32396(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	2978de04 	addi	r5,r5,-7304
81101480:	1009883a 	mov	r4,r2
81101484:	111c11c0 	call	8111c11c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10b8de04 	addi	r2,r2,-7304
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a05d17 	ldw	r2,-32396(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	2978de04 	addi	r5,r5,-7304
811014a8:	1009883a 	mov	r4,r2
811014ac:	111c11c0 	call	8111c11c <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18f8de04 	addi	r3,r3,-7304
81101538:	00a04534 	movhi	r2,33044
8110153c:	109ce504 	addi	r2,r2,29588
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	111d1cc0 	call	8111d1cc <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a05d17 	ldw	r2,-32396(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	2978de04 	addi	r5,r5,-7304
81101564:	1009883a 	mov	r4,r2
81101568:	111c11c0 	call	8111c11c <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18f8de04 	addi	r3,r3,-7304
811015b4:	00a04534 	movhi	r2,33044
811015b8:	109cf404 	addi	r2,r2,29648
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a05d17 	ldw	r2,-32396(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	2978de04 	addi	r5,r5,-7304
811015e0:	1009883a 	mov	r4,r2
811015e4:	111c11c0 	call	8111c11c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18f8de04 	addi	r3,r3,-7304
81101648:	00a04534 	movhi	r2,33044
8110164c:	109b0504 	addi	r2,r2,27668
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	111d1cc0 	call	8111d1cc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a05d17 	ldw	r2,-32396(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	2978de04 	addi	r5,r5,-7304
81101674:	1009883a 	mov	r4,r2
81101678:	111c11c0 	call	8111c11c <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604534 	movhi	r5,33044
81101694:	295cfe04 	addi	r5,r5,29688
81101698:	01204574 	movhi	r4,33045
8110169c:	2138de04 	addi	r4,r4,-7304
811016a0:	111daac0 	call	8111daac <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a05d17 	ldw	r2,-32396(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	2978de04 	addi	r5,r5,-7304
811016b0:	1009883a 	mov	r4,r2
811016b4:	111c11c0 	call	8111c11c <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08417 	ldw	r2,-32240(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10b91e04 	addi	r2,r2,-7048
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10b91e04 	addi	r2,r2,-7048
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10b91e04 	addi	r2,r2,-7048
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10b91e04 	addi	r2,r2,-7048
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10b91e04 	addi	r2,r2,-7048
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10b91e04 	addi	r2,r2,-7048
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10b91e04 	addi	r2,r2,-7048
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18f8de04 	addi	r3,r3,-7304
81101868:	00a04534 	movhi	r2,33044
8110186c:	109d0404 	addi	r2,r2,29712
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a05d17 	ldw	r2,-32396(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	2978de04 	addi	r5,r5,-7304
81101894:	1009883a 	mov	r4,r2
81101898:	111c11c0 	call	8111c11c <fprintf>
8110189c:	d0a08417 	ldw	r2,-32240(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	29791e04 	addi	r5,r5,-7048
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	111d1cc0 	call	8111d1cc <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604534 	movhi	r5,33044
81101990:	295d0904 	addi	r5,r5,29732
81101994:	01204574 	movhi	r4,33045
81101998:	2138de04 	addi	r4,r4,-7304
8110199c:	111daac0 	call	8111daac <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a05d17 	ldw	r2,-32396(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	2978de04 	addi	r5,r5,-7304
811019ac:	1009883a 	mov	r4,r2
811019b0:	111c11c0 	call	8111c11c <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	1131bcc0 	call	81131bcc <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10b8de04 	addi	r2,r2,-7304
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a05d17 	ldw	r2,-32396(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	2978de04 	addi	r5,r5,-7304
811019e4:	1009883a 	mov	r4,r2
811019e8:	111c11c0 	call	8111c11c <fprintf>
811019ec:	d0e08417 	ldw	r3,-32240(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111b3580 	call	8111b358 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08317 	ldw	r2,-32244(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111b4840 	call	8111b484 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111ab0c0 	call	8111ab0c <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	111bc9c0 	call	8111bc9c <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604534 	movhi	r5,33044
81101a54:	295d0b04 	addi	r5,r5,29740
81101a58:	01204574 	movhi	r4,33045
81101a5c:	2138de04 	addi	r4,r4,-7304
81101a60:	111daac0 	call	8111daac <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a05d17 	ldw	r2,-32396(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	2978de04 	addi	r5,r5,-7304
81101a70:	1009883a 	mov	r4,r2
81101a74:	111c11c0 	call	8111c11c <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18f8de04 	addi	r3,r3,-7304
81101a84:	00a04534 	movhi	r2,33044
81101a88:	109d1704 	addi	r2,r2,29788
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a05d17 	ldw	r2,-32396(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	2978de04 	addi	r5,r5,-7304
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	111c11c0 	call	8111c11c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10b8de04 	addi	r2,r2,-7304
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a05d17 	ldw	r2,-32396(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	2978de04 	addi	r5,r5,-7304
81101ad8:	1009883a 	mov	r4,r2
81101adc:	111c11c0 	call	8111c11c <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18f8de04 	addi	r3,r3,-7304
81101b30:	00a04534 	movhi	r2,33044
81101b34:	109d1d04 	addi	r2,r2,29812
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a05d17 	ldw	r2,-32396(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	2978de04 	addi	r5,r5,-7304
81101b5c:	1009883a 	mov	r4,r2
81101b60:	111c11c0 	call	8111c11c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18f8de04 	addi	r3,r3,-7304
81101bc4:	00a04534 	movhi	r2,33044
81101bc8:	109b0504 	addi	r2,r2,27668
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	111d1cc0 	call	8111d1cc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a05d17 	ldw	r2,-32396(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	2978de04 	addi	r5,r5,-7304
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	111c11c0 	call	8111c11c <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604534 	movhi	r5,33044
81101c10:	295d2704 	addi	r5,r5,29852
81101c14:	01204574 	movhi	r4,33045
81101c18:	2138de04 	addi	r4,r4,-7304
81101c1c:	111daac0 	call	8111daac <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a05d17 	ldw	r2,-32396(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	2978de04 	addi	r5,r5,-7304
81101c2c:	1009883a 	mov	r4,r2
81101c30:	111c11c0 	call	8111c11c <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18f8de04 	addi	r3,r3,-7304
81101cd0:	00a04534 	movhi	r2,33044
81101cd4:	109d2d04 	addi	r2,r2,29876
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a05d17 	ldw	r2,-32396(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	2978de04 	addi	r5,r5,-7304
81101cfc:	1009883a 	mov	r4,r2
81101d00:	111c11c0 	call	8111c11c <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08417 	ldw	r2,-32240(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10b91e04 	addi	r2,r2,-7048
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10b91e04 	addi	r2,r2,-7048
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604534 	movhi	r5,33044
81101df4:	295d3404 	addi	r5,r5,29904
81101df8:	01204574 	movhi	r4,33045
81101dfc:	2138de04 	addi	r4,r4,-7304
81101e00:	111daac0 	call	8111daac <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a05d17 	ldw	r2,-32396(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	2978de04 	addi	r5,r5,-7304
81101e10:	1009883a 	mov	r4,r2
81101e14:	111c11c0 	call	8111c11c <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604534 	movhi	r5,33044
81101e98:	295d0904 	addi	r5,r5,29732
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	2138de04 	addi	r4,r4,-7304
81101ea4:	111daac0 	call	8111daac <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a05d17 	ldw	r2,-32396(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	2978de04 	addi	r5,r5,-7304
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	111c11c0 	call	8111c11c <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10b8de04 	addi	r2,r2,-7304
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a05d17 	ldw	r2,-32396(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	2978de04 	addi	r5,r5,-7304
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	111c11c0 	call	8111c11c <fprintf>
81101ef8:	d0e08417 	ldw	r3,-32240(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111b3580 	call	8111b358 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08317 	ldw	r2,-32244(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111b4840 	call	8111b484 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111ab0c0 	call	8111ab0c <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	111bc9c0 	call	8111bc9c <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604534 	movhi	r5,33044
81101f60:	295d4204 	addi	r5,r5,29960
81101f64:	01204574 	movhi	r4,33045
81101f68:	2138de04 	addi	r4,r4,-7304
81101f6c:	111daac0 	call	8111daac <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a05d17 	ldw	r2,-32396(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	2978de04 	addi	r5,r5,-7304
81101f7c:	1009883a 	mov	r4,r2
81101f80:	111c11c0 	call	8111c11c <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18f8de04 	addi	r3,r3,-7304
81101f90:	00a04534 	movhi	r2,33044
81101f94:	109d4e04 	addi	r2,r2,30008
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a05d17 	ldw	r2,-32396(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	2978de04 	addi	r5,r5,-7304
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	111c11c0 	call	8111c11c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10b8de04 	addi	r2,r2,-7304
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a05d17 	ldw	r2,-32396(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	2978de04 	addi	r5,r5,-7304
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	111c11c0 	call	8111c11c <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18f8de04 	addi	r3,r3,-7304
8110204c:	00a04534 	movhi	r2,33044
81102050:	109d5404 	addi	r2,r2,30032
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a05d17 	ldw	r2,-32396(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	2978de04 	addi	r5,r5,-7304
81102078:	1009883a 	mov	r4,r2
8110207c:	111c11c0 	call	8111c11c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18f8de04 	addi	r3,r3,-7304
811020e0:	00a04534 	movhi	r2,33044
811020e4:	109b0504 	addi	r2,r2,27668
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	111d1cc0 	call	8111d1cc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a05d17 	ldw	r2,-32396(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	2978de04 	addi	r5,r5,-7304
8110210c:	1009883a 	mov	r4,r2
81102110:	111c11c0 	call	8111c11c <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604534 	movhi	r5,33044
8110212c:	295cfe04 	addi	r5,r5,29688
81102130:	01204574 	movhi	r4,33045
81102134:	2138de04 	addi	r4,r4,-7304
81102138:	111daac0 	call	8111daac <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a05d17 	ldw	r2,-32396(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	2978de04 	addi	r5,r5,-7304
81102148:	1009883a 	mov	r4,r2
8110214c:	111c11c0 	call	8111c11c <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08417 	ldw	r2,-32240(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18f8de04 	addi	r3,r3,-7304
811021ac:	00a04534 	movhi	r2,33044
811021b0:	109d6004 	addi	r2,r2,30080
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a05d17 	ldw	r2,-32396(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	2978de04 	addi	r5,r5,-7304
811021d8:	1009883a 	mov	r4,r2
811021dc:	111c11c0 	call	8111c11c <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604534 	movhi	r5,33044
811021f0:	295d6604 	addi	r5,r5,30104
811021f4:	01204574 	movhi	r4,33045
811021f8:	2138de04 	addi	r4,r4,-7304
811021fc:	111daac0 	call	8111daac <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a05d17 	ldw	r2,-32396(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	2978de04 	addi	r5,r5,-7304
8110220c:	1009883a 	mov	r4,r2
81102210:	111c11c0 	call	8111c11c <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08417 	ldw	r2,-32240(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604534 	movhi	r5,33044
81102274:	295d6804 	addi	r5,r5,30112
81102278:	01204574 	movhi	r4,33045
8110227c:	2138de04 	addi	r4,r4,-7304
81102280:	111daac0 	call	8111daac <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a05d17 	ldw	r2,-32396(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	2978de04 	addi	r5,r5,-7304
81102290:	1009883a 	mov	r4,r2
81102294:	111c11c0 	call	8111c11c <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	1131bcc0 	call	81131bcc <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604534 	movhi	r5,33044
811022fc:	295d6b04 	addi	r5,r5,30124
81102300:	01204574 	movhi	r4,33045
81102304:	2138de04 	addi	r4,r4,-7304
81102308:	111daac0 	call	8111daac <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a05d17 	ldw	r2,-32396(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	2978de04 	addi	r5,r5,-7304
81102318:	1009883a 	mov	r4,r2
8110231c:	111c11c0 	call	8111c11c <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08417 	ldw	r3,-32240(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111b3580 	call	8111b358 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08317 	ldw	r2,-32244(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111b4840 	call	8111b484 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111ab0c0 	call	8111ab0c <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	111bc9c0 	call	8111bc9c <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604534 	movhi	r5,33044
81102394:	295d6e04 	addi	r5,r5,30136
81102398:	01204574 	movhi	r4,33045
8110239c:	2138de04 	addi	r4,r4,-7304
811023a0:	111daac0 	call	8111daac <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a05d17 	ldw	r2,-32396(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	2978de04 	addi	r5,r5,-7304
811023b0:	1009883a 	mov	r4,r2
811023b4:	111c11c0 	call	8111c11c <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604534 	movhi	r5,33044
811023c4:	295d7a04 	addi	r5,r5,30184
811023c8:	01204574 	movhi	r4,33045
811023cc:	2138de04 	addi	r4,r4,-7304
811023d0:	111daac0 	call	8111daac <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a05d17 	ldw	r2,-32396(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	2978de04 	addi	r5,r5,-7304
811023e0:	1009883a 	mov	r4,r2
811023e4:	111c11c0 	call	8111c11c <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18f8de04 	addi	r3,r3,-7304
811023f4:	00a04534 	movhi	r2,33044
811023f8:	109d1704 	addi	r2,r2,29788
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a05d17 	ldw	r2,-32396(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	2978de04 	addi	r5,r5,-7304
81102420:	1009883a 	mov	r4,r2
81102424:	111c11c0 	call	8111c11c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10b8de04 	addi	r2,r2,-7304
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a05d17 	ldw	r2,-32396(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	2978de04 	addi	r5,r5,-7304
81102448:	1009883a 	mov	r4,r2
8110244c:	111c11c0 	call	8111c11c <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18f8de04 	addi	r3,r3,-7304
811024b8:	00a04534 	movhi	r2,33044
811024bc:	109d8404 	addi	r2,r2,30224
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a05d17 	ldw	r2,-32396(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	2978de04 	addi	r5,r5,-7304
811024e4:	1009883a 	mov	r4,r2
811024e8:	111c11c0 	call	8111c11c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18f8de04 	addi	r3,r3,-7304
8110254c:	00a04534 	movhi	r2,33044
81102550:	109b0504 	addi	r2,r2,27668
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	111d1cc0 	call	8111d1cc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a05d17 	ldw	r2,-32396(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	2978de04 	addi	r5,r5,-7304
81102578:	1009883a 	mov	r4,r2
8110257c:	111c11c0 	call	8111c11c <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604534 	movhi	r5,33044
81102598:	295cfe04 	addi	r5,r5,29688
8110259c:	01204574 	movhi	r4,33045
811025a0:	2138de04 	addi	r4,r4,-7304
811025a4:	111daac0 	call	8111daac <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a05d17 	ldw	r2,-32396(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	2978de04 	addi	r5,r5,-7304
811025b4:	1009883a 	mov	r4,r2
811025b8:	111c11c0 	call	8111c11c <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18f8de04 	addi	r3,r3,-7304
81102610:	00a04534 	movhi	r2,33044
81102614:	109d9004 	addi	r2,r2,30272
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a05d17 	ldw	r2,-32396(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	2978de04 	addi	r5,r5,-7304
8110263c:	1009883a 	mov	r4,r2
81102640:	111c11c0 	call	8111c11c <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604534 	movhi	r5,33044
81102654:	295d6604 	addi	r5,r5,30104
81102658:	01204574 	movhi	r4,33045
8110265c:	2138de04 	addi	r4,r4,-7304
81102660:	111daac0 	call	8111daac <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a05d17 	ldw	r2,-32396(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	2978de04 	addi	r5,r5,-7304
81102670:	1009883a 	mov	r4,r2
81102674:	111c11c0 	call	8111c11c <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08417 	ldw	r2,-32240(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604534 	movhi	r5,33044
811026c8:	295d9604 	addi	r5,r5,30296
811026cc:	01204574 	movhi	r4,33045
811026d0:	2138de04 	addi	r4,r4,-7304
811026d4:	111daac0 	call	8111daac <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a05d17 	ldw	r2,-32396(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	2978de04 	addi	r5,r5,-7304
811026e4:	1009883a 	mov	r4,r2
811026e8:	111c11c0 	call	8111c11c <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604534 	movhi	r5,33044
81102710:	295d6804 	addi	r5,r5,30112
81102714:	01204574 	movhi	r4,33045
81102718:	2138de04 	addi	r4,r4,-7304
8110271c:	111daac0 	call	8111daac <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a05d17 	ldw	r2,-32396(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	2978de04 	addi	r5,r5,-7304
8110272c:	1009883a 	mov	r4,r2
81102730:	111c11c0 	call	8111c11c <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604534 	movhi	r5,33044
81102794:	295d6b04 	addi	r5,r5,30124
81102798:	01204574 	movhi	r4,33045
8110279c:	2138de04 	addi	r4,r4,-7304
811027a0:	111daac0 	call	8111daac <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a05d17 	ldw	r2,-32396(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	2978de04 	addi	r5,r5,-7304
811027b0:	1009883a 	mov	r4,r2
811027b4:	111c11c0 	call	8111c11c <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08417 	ldw	r3,-32240(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111b3580 	call	8111b358 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08317 	ldw	r2,-32244(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111b4840 	call	8111b484 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111ab0c0 	call	8111ab0c <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	111bc9c0 	call	8111bc9c <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604534 	movhi	r5,33044
8110282c:	295d9e04 	addi	r5,r5,30328
81102830:	01204574 	movhi	r4,33045
81102834:	2138de04 	addi	r4,r4,-7304
81102838:	111daac0 	call	8111daac <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a05d17 	ldw	r2,-32396(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	2978de04 	addi	r5,r5,-7304
81102848:	1009883a 	mov	r4,r2
8110284c:	111c11c0 	call	8111c11c <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604534 	movhi	r5,33044
8110285c:	295daa04 	addi	r5,r5,30376
81102860:	01204574 	movhi	r4,33045
81102864:	2138de04 	addi	r4,r4,-7304
81102868:	111daac0 	call	8111daac <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a05d17 	ldw	r2,-32396(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	2978de04 	addi	r5,r5,-7304
81102878:	1009883a 	mov	r4,r2
8110287c:	111c11c0 	call	8111c11c <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18f8de04 	addi	r3,r3,-7304
8110288c:	00a04534 	movhi	r2,33044
81102890:	109d4e04 	addi	r2,r2,30008
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	111d1cc0 	call	8111d1cc <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a05d17 	ldw	r2,-32396(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	2978de04 	addi	r5,r5,-7304
811028b8:	1009883a 	mov	r4,r2
811028bc:	111c11c0 	call	8111c11c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10b8de04 	addi	r2,r2,-7304
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a05d17 	ldw	r2,-32396(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	2978de04 	addi	r5,r5,-7304
811028e0:	1009883a 	mov	r4,r2
811028e4:	111c11c0 	call	8111c11c <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	114548c0 	call	8114548c <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	11333f40 	call	811333f4 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	11333f40 	call	811333f4 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	11333f40 	call	811333f4 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	11333f40 	call	811333f4 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	11444880 	call	81144488 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	11456fc0 	call	811456fc <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	11333f40 	call	811333f4 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	11333f40 	call	811333f4 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	11444880 	call	81144488 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	11456fc0 	call	811456fc <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	11444880 	call	81144488 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	11456fc0 	call	811456fc <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	11333f40 	call	811333f4 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	11333f40 	call	811333f4 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110add80 	call	8110add8 <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110add80 	call	8110add8 <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604534 	movhi	r5,33044
811030d0:	295db404 	addi	r5,r5,30416
811030d4:	01204574 	movhi	r4,33045
811030d8:	2138de04 	addi	r4,r4,-7304
811030dc:	111daac0 	call	8111daac <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a05d17 	ldw	r2,-32396(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	2978de04 	addi	r5,r5,-7304
811030ec:	1009883a 	mov	r4,r2
811030f0:	111c11c0 	call	8111c11c <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604534 	movhi	r5,33044
8110311c:	295dba04 	addi	r5,r5,30440
81103120:	01204574 	movhi	r4,33045
81103124:	2138de04 	addi	r4,r4,-7304
81103128:	111daac0 	call	8111daac <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a05d17 	ldw	r2,-32396(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	2978de04 	addi	r5,r5,-7304
81103138:	1009883a 	mov	r4,r2
8110313c:	111c11c0 	call	8111c11c <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604534 	movhi	r5,33044
8110315c:	295dc604 	addi	r5,r5,30488
81103160:	01204574 	movhi	r4,33045
81103164:	2138de04 	addi	r4,r4,-7304
81103168:	111daac0 	call	8111daac <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a05d17 	ldw	r2,-32396(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	2978de04 	addi	r5,r5,-7304
81103178:	1009883a 	mov	r4,r2
8110317c:	111c11c0 	call	8111c11c <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18f8de04 	addi	r3,r3,-7304
811031c0:	00a04534 	movhi	r2,33044
811031c4:	109dcc04 	addi	r2,r2,30512
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	111d1cc0 	call	8111d1cc <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a05d17 	ldw	r2,-32396(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	2978de04 	addi	r5,r5,-7304
811031ec:	1009883a 	mov	r4,r2
811031f0:	111c11c0 	call	8111c11c <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	1109bd00 	call	81109bd0 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	1109bd00 	call	81109bd0 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04534 	movhi	r2,33044
811034f0:	109e0304 	addi	r2,r2,30732
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	111d1cc0 	call	8111d1cc <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111b4840 	call	8111b484 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111ab0c0 	call	8111ab0c <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111af540 	call	8111af54 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	111bc9c0 	call	8111bc9c <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604534 	movhi	r5,33044
81103658:	295dd104 	addi	r5,r5,30532
8110365c:	01204574 	movhi	r4,33045
81103660:	2138de04 	addi	r4,r4,-7304
81103664:	111daac0 	call	8111daac <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a05d17 	ldw	r2,-32396(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	2978de04 	addi	r5,r5,-7304
81103674:	1009883a 	mov	r4,r2
81103678:	111c11c0 	call	8111c11c <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	111bc9c0 	call	8111bc9c <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111b57c0 	call	8111b57c <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	111bc9c0 	call	8111bc9c <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111b57c0 	call	8111b57c <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	111bdb40 	call	8111bdb4 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111ab0c0 	call	8111ab0c <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111af540 	call	8111af54 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	111bc9c0 	call	8111bc9c <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	111bc9c0 	call	8111bc9c <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	111bc9c0 	call	8111bc9c <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604534 	movhi	r5,33044
811037f0:	295dda04 	addi	r5,r5,30568
811037f4:	01204574 	movhi	r4,33045
811037f8:	2138de04 	addi	r4,r4,-7304
811037fc:	111daac0 	call	8111daac <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a05d17 	ldw	r2,-32396(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	2978de04 	addi	r5,r5,-7304
8110380c:	1009883a 	mov	r4,r2
81103810:	111c11c0 	call	8111c11c <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	111bc9c0 	call	8111bc9c <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111b57c0 	call	8111b57c <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	111bc9c0 	call	8111bc9c <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111b57c0 	call	8111b57c <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	111bdb40 	call	8111bdb4 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111ab0c0 	call	8111ab0c <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111af540 	call	8111af54 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	111bc9c0 	call	8111bc9c <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	111bc9c0 	call	8111bc9c <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	111bc9c0 	call	8111bc9c <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604534 	movhi	r5,33044
81103988:	295dea04 	addi	r5,r5,30632
8110398c:	01204574 	movhi	r4,33045
81103990:	2138de04 	addi	r4,r4,-7304
81103994:	111daac0 	call	8111daac <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a05d17 	ldw	r2,-32396(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	2978de04 	addi	r5,r5,-7304
811039a4:	1009883a 	mov	r4,r2
811039a8:	111c11c0 	call	8111c11c <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111af540 	call	8111af54 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	111bc9c0 	call	8111bc9c <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604534 	movhi	r5,33044
81103a30:	295dfa04 	addi	r5,r5,30696
81103a34:	01204574 	movhi	r4,33045
81103a38:	2138de04 	addi	r4,r4,-7304
81103a3c:	111daac0 	call	8111daac <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a05d17 	ldw	r2,-32396(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	2978de04 	addi	r5,r5,-7304
81103a4c:	1009883a 	mov	r4,r2
81103a50:	111c11c0 	call	8111c11c <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	10b8de04 	addi	r2,r2,-7304
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a05d17 	ldw	r2,-32396(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	2978de04 	addi	r5,r5,-7304
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	111c11c0 	call	8111c11c <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	10b8de04 	addi	r2,r2,-7304
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a05d17 	ldw	r2,-32396(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	2978de04 	addi	r5,r5,-7304
81103af8:	1009883a 	mov	r4,r2
81103afc:	111c11c0 	call	8111c11c <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204534 	movhi	r4,33044
81103b58:	211ec304 	addi	r4,r4,31500
81103b5c:	114548c0 	call	8114548c <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	11333f40 	call	811333f4 <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204534 	movhi	r4,33044
81103c08:	211ec804 	addi	r4,r4,31520
81103c0c:	114548c0 	call	8114548c <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	11333f40 	call	811333f4 <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe904 	addi	sp,sp,-92
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01615 	stw	ra,88(sp)
81103ca0:	df001515 	stw	fp,84(sp)
81103ca4:	dc001415 	stw	r16,80(sp)
81103ca8:	df001504 	addi	fp,sp,84
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103cfc:	e0bffe03 	ldbu	r2,-8(fp)
81103d00:	10c00228 	cmpgeui	r3,r2,8
81103d04:	18009c1e 	bne	r3,zero,81103f78 <bSdmaDmaM1Transfer+0x2e8>
81103d08:	100690ba 	slli	r3,r2,2
81103d0c:	00a04434 	movhi	r2,33040
81103d10:	108f4804 	addi	r2,r2,15648
81103d14:	1885883a 	add	r2,r3,r2
81103d18:	10800017 	ldw	r2,0(r2)
81103d1c:	1000683a 	jmp	r2
81103d20:	81103d40 	call	881103d4 <__reset+0x20f03d4>
81103d24:	81103d80 	call	881103d8 <__reset+0x20f03d8>
81103d28:	81103dc8 	cmpgei	r4,r16,16631
81103d2c:	81103e10 	cmplti	r4,r16,16632
81103d30:	81103e58 	cmpnei	r4,r16,16633
81103d34:	81103ea0 	cmpeqi	r4,r16,16634
81103d38:	81103ee8 	cmpgeui	r4,r16,16635
81103d3c:	81103f30 	cmpltui	r4,r16,16636
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d40:	e0bffd03 	ldbu	r2,-12(fp)
81103d44:	10000626 	beq	r2,zero,81103d60 <bSdmaDmaM1Transfer+0xd0>
81103d48:	10800060 	cmpeqi	r2,r2,1
81103d4c:	10000926 	beq	r2,zero,81103d74 <bSdmaDmaM1Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d50:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d54:	00800044 	movi	r2,1
81103d58:	e0bff715 	stw	r2,-36(fp)
			break;
81103d5c:	00000706 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d60:	00800074 	movhi	r2,1
81103d64:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d68:	00800044 	movi	r2,1
81103d6c:	e0bff715 	stw	r2,-36(fp)
			break;
81103d70:	00000206 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		default:
			bStatus = FALSE;
81103d74:	e03ff415 	stw	zero,-48(fp)
			break;
81103d78:	0001883a 	nop
		}
		break;
81103d7c:	00008006 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d80:	e0bffd03 	ldbu	r2,-12(fp)
81103d84:	10000726 	beq	r2,zero,81103da4 <bSdmaDmaM1Transfer+0x114>
81103d88:	10800060 	cmpeqi	r2,r2,1
81103d8c:	10000b26 	beq	r2,zero,81103dbc <bSdmaDmaM1Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103d90:	00880004 	movi	r2,8192
81103d94:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103d98:	00800044 	movi	r2,1
81103d9c:	e0bff715 	stw	r2,-36(fp)
			break;
81103da0:	00000806 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103da4:	00800074 	movhi	r2,1
81103da8:	10880004 	addi	r2,r2,8192
81103dac:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff715 	stw	r2,-36(fp)
			break;
81103db8:	00000206 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		default:
			bStatus = FALSE;
81103dbc:	e03ff415 	stw	zero,-48(fp)
			break;
81103dc0:	0001883a 	nop
		}
		break;
81103dc4:	00006e06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103dc8:	e0bffd03 	ldbu	r2,-12(fp)
81103dcc:	10000726 	beq	r2,zero,81103dec <bSdmaDmaM1Transfer+0x15c>
81103dd0:	10800060 	cmpeqi	r2,r2,1
81103dd4:	10000b26 	beq	r2,zero,81103e04 <bSdmaDmaM1Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103dd8:	00900004 	movi	r2,16384
81103ddc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103de0:	00800044 	movi	r2,1
81103de4:	e0bff715 	stw	r2,-36(fp)
			break;
81103de8:	00000806 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103dec:	00800074 	movhi	r2,1
81103df0:	10900004 	addi	r2,r2,16384
81103df4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103df8:	00800044 	movi	r2,1
81103dfc:	e0bff715 	stw	r2,-36(fp)
			break;
81103e00:	00000206 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		default:
			bStatus = FALSE;
81103e04:	e03ff415 	stw	zero,-48(fp)
			break;
81103e08:	0001883a 	nop
		}
		break;
81103e0c:	00005c06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e10:	e0bffd03 	ldbu	r2,-12(fp)
81103e14:	10000726 	beq	r2,zero,81103e34 <bSdmaDmaM1Transfer+0x1a4>
81103e18:	10800060 	cmpeqi	r2,r2,1
81103e1c:	10000b26 	beq	r2,zero,81103e4c <bSdmaDmaM1Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e20:	00980004 	movi	r2,24576
81103e24:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e30:	00000806 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e34:	00800074 	movhi	r2,1
81103e38:	10980004 	addi	r2,r2,24576
81103e3c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e40:	00800044 	movi	r2,1
81103e44:	e0bff715 	stw	r2,-36(fp)
			break;
81103e48:	00000206 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		default:
			bStatus = FALSE;
81103e4c:	e03ff415 	stw	zero,-48(fp)
			break;
81103e50:	0001883a 	nop
		}
		break;
81103e54:	00004a06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e58:	e0bffd03 	ldbu	r2,-12(fp)
81103e5c:	10000726 	beq	r2,zero,81103e7c <bSdmaDmaM1Transfer+0x1ec>
81103e60:	10800060 	cmpeqi	r2,r2,1
81103e64:	10000b26 	beq	r2,zero,81103e94 <bSdmaDmaM1Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e68:	00a00014 	movui	r2,32768
81103e6c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e70:	00800044 	movi	r2,1
81103e74:	e0bff715 	stw	r2,-36(fp)
			break;
81103e78:	00000806 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103e7c:	008000b4 	movhi	r2,2
81103e80:	10a00004 	addi	r2,r2,-32768
81103e84:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103e88:	00800044 	movi	r2,1
81103e8c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e90:	00000206 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		default:
			bStatus = FALSE;
81103e94:	e03ff415 	stw	zero,-48(fp)
			break;
81103e98:	0001883a 	nop
		}
		break;
81103e9c:	00003806 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ea0:	e0bffd03 	ldbu	r2,-12(fp)
81103ea4:	10000726 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea8:	10800060 	cmpeqi	r2,r2,1
81103eac:	10000b26 	beq	r2,zero,81103edc <bSdmaDmaM1Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103eb0:	00a80014 	movui	r2,40960
81103eb4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103eb8:	00800044 	movi	r2,1
81103ebc:	e0bff715 	stw	r2,-36(fp)
			break;
81103ec0:	00000806 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a80004 	addi	r2,r2,-24576
81103ecc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff715 	stw	r2,-36(fp)
			break;
81103ed8:	00000206 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		default:
			bStatus = FALSE;
81103edc:	e03ff415 	stw	zero,-48(fp)
			break;
81103ee0:	0001883a 	nop
		}
		break;
81103ee4:	00002606 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103ee8:	e0bffd03 	ldbu	r2,-12(fp)
81103eec:	10000726 	beq	r2,zero,81103f0c <bSdmaDmaM1Transfer+0x27c>
81103ef0:	10800060 	cmpeqi	r2,r2,1
81103ef4:	10000b26 	beq	r2,zero,81103f24 <bSdmaDmaM1Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103ef8:	00b00014 	movui	r2,49152
81103efc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f00:	00800044 	movi	r2,1
81103f04:	e0bff715 	stw	r2,-36(fp)
			break;
81103f08:	00000806 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f0c:	008000b4 	movhi	r2,2
81103f10:	10b00004 	addi	r2,r2,-16384
81103f14:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f18:	00800044 	movi	r2,1
81103f1c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f20:	00000206 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		default:
			bStatus = FALSE;
81103f24:	e03ff415 	stw	zero,-48(fp)
			break;
81103f28:	0001883a 	nop
		}
		break;
81103f2c:	00001406 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f30:	e0bffd03 	ldbu	r2,-12(fp)
81103f34:	10000726 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x2c4>
81103f38:	10800060 	cmpeqi	r2,r2,1
81103f3c:	10000b26 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f40:	00b80014 	movui	r2,57344
81103f44:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f48:	00800044 	movi	r2,1
81103f4c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f50:	00000806 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f54:	008000b4 	movhi	r2,2
81103f58:	10b80004 	addi	r2,r2,-8192
81103f5c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f60:	00800044 	movi	r2,1
81103f64:	e0bff715 	stw	r2,-36(fp)
			break;
81103f68:	00000206 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		default:
			bStatus = FALSE;
81103f6c:	e03ff415 	stw	zero,-48(fp)
			break;
81103f70:	0001883a 	nop
		}
		break;
81103f74:	00000206 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	default:
		bStatus = FALSE;
81103f78:	e03ff415 	stw	zero,-48(fp)
		break;
81103f7c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103f80:	e0bffb17 	ldw	r2,-20(fp)
81103f84:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103f88:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103f8c:	e0bff417 	ldw	r2,-48(fp)
81103f90:	10003b26 	beq	r2,zero,81104080 <bSdmaDmaM1Transfer+0x3f0>
		if (pxDmaM1Dev == NULL) {
81103f94:	d0a03917 	ldw	r2,-32540(gp)
81103f98:	1000021e 	bne	r2,zero,81103fa4 <bSdmaDmaM1Transfer+0x314>
			bStatus = FALSE;
81103f9c:	e03ff415 	stw	zero,-48(fp)
81103fa0:	00003706 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103fa4:	e03ff50d 	sth	zero,-44(fp)
81103fa8:	00003206 	br	81104074 <bSdmaDmaM1Transfer+0x3e4>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103fac:	01000044 	movi	r4,1
81103fb0:	11319800 	call	81131980 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103fb4:	d0a03917 	ldw	r2,-32540(gp)
81103fb8:	10800317 	ldw	r2,12(r2)
81103fbc:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103fc0:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103fc4:	103ff91e 	bne	r2,zero,81103fac <__reset+0xfb0e3fac>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103fc8:	d2203917 	ldw	r8,-32540(gp)
81103fcc:	e17ff817 	ldw	r5,-32(fp)
81103fd0:	e1bff617 	ldw	r6,-40(fp)
81103fd4:	e0bff917 	ldw	r2,-28(fp)
81103fd8:	e0fff717 	ldw	r3,-36(fp)
81103fdc:	01000044 	movi	r4,1
81103fe0:	d9000815 	stw	r4,32(sp)
81103fe4:	01000044 	movi	r4,1
81103fe8:	d9000715 	stw	r4,28(sp)
81103fec:	01000044 	movi	r4,1
81103ff0:	d9000615 	stw	r4,24(sp)
81103ff4:	01000044 	movi	r4,1
81103ff8:	d9000515 	stw	r4,20(sp)
81103ffc:	01000044 	movi	r4,1
81104000:	d9000415 	stw	r4,16(sp)
81104004:	d8c00315 	stw	r3,12(sp)
81104008:	d8800215 	stw	r2,8(sp)
8110400c:	e0bffa17 	ldw	r2,-24(fp)
81104010:	d8800115 	stw	r2,4(sp)
81104014:	00802204 	movi	r2,136
81104018:	d8800015 	stw	r2,0(sp)
8110401c:	300f883a 	mov	r7,r6
81104020:	280d883a 	mov	r6,r5
81104024:	800b883a 	mov	r5,r16
81104028:	4009883a 	mov	r4,r8
8110402c:	110ac900 	call	8110ac90 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104030:	10000226 	beq	r2,zero,8110403c <bSdmaDmaM1Transfer+0x3ac>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104034:	e03ff415 	stw	zero,-48(fp)
					break;
81104038:	00001106 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
8110403c:	d0a03917 	ldw	r2,-32540(gp)
81104040:	800b883a 	mov	r5,r16
81104044:	1009883a 	mov	r4,r2
81104048:	110ad940 	call	8110ad94 <iMsgdmaExtendedDescriptorSyncTransfer>
8110404c:	10000226 	beq	r2,zero,81104058 <bSdmaDmaM1Transfer+0x3c8>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104050:	e03ff415 	stw	zero,-48(fp)
						break;
81104054:	00000a06 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104058:	e0bff817 	ldw	r2,-32(fp)
8110405c:	10802204 	addi	r2,r2,136
81104060:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104064:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104068:	e0bff50b 	ldhu	r2,-44(fp)
8110406c:	10800044 	addi	r2,r2,1
81104070:	e0bff50d 	sth	r2,-44(fp)
81104074:	e0fff50b 	ldhu	r3,-44(fp)
81104078:	e0bffc0b 	ldhu	r2,-16(fp)
8110407c:	18bfcd36 	bltu	r3,r2,81103fb4 <__reset+0xfb0e3fb4>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104080:	e0bff417 	ldw	r2,-48(fp)
}
81104084:	e6ffff04 	addi	sp,fp,-4
81104088:	dfc00217 	ldw	ra,8(sp)
8110408c:	df000117 	ldw	fp,4(sp)
81104090:	dc000017 	ldw	r16,0(sp)
81104094:	dec00304 	addi	sp,sp,12
81104098:	f800283a 	ret

8110409c <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
8110409c:	deffe904 	addi	sp,sp,-92
811040a0:	de00012e 	bgeu	sp,et,811040a8 <bSdmaDmaM2Transfer+0xc>
811040a4:	003b68fa 	trap	3
811040a8:	dfc01615 	stw	ra,88(sp)
811040ac:	df001515 	stw	fp,84(sp)
811040b0:	dc001415 	stw	r16,80(sp)
811040b4:	df001504 	addi	fp,sp,84
811040b8:	e13ffb15 	stw	r4,-20(fp)
811040bc:	2809883a 	mov	r4,r5
811040c0:	3007883a 	mov	r3,r6
811040c4:	3805883a 	mov	r2,r7
811040c8:	e13ffc0d 	sth	r4,-16(fp)
811040cc:	e0fffd05 	stb	r3,-12(fp)
811040d0:	e0bffe05 	stb	r2,-8(fp)
811040d4:	defff004 	addi	sp,sp,-64
811040d8:	d8800904 	addi	r2,sp,36
811040dc:	108007c4 	addi	r2,r2,31
811040e0:	1004d17a 	srli	r2,r2,5
811040e4:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
811040e8:	00800044 	movi	r2,1
811040ec:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
811040f0:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
811040f4:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
811040f8:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
811040fc:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104100:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104104:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104108:	e0bffe03 	ldbu	r2,-8(fp)
8110410c:	10c00228 	cmpgeui	r3,r2,8
81104110:	18009c1e 	bne	r3,zero,81104384 <bSdmaDmaM2Transfer+0x2e8>
81104114:	100690ba 	slli	r3,r2,2
81104118:	00a04434 	movhi	r2,33040
8110411c:	10904b04 	addi	r2,r2,16684
81104120:	1885883a 	add	r2,r3,r2
81104124:	10800017 	ldw	r2,0(r2)
81104128:	1000683a 	jmp	r2
8110412c:	8110414c 	andi	r4,r16,16645
81104130:	8110418c 	andi	r4,r16,16646
81104134:	811041d4 	ori	r4,r16,16647
81104138:	8110421c 	xori	r4,r16,16648
8110413c:	81104264 	muli	r4,r16,16649
81104140:	811042ac 	andhi	r4,r16,16650
81104144:	811042f4 	orhi	r4,r16,16651
81104148:	8110433c 	xorhi	r4,r16,16652
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
8110414c:	e0bffd03 	ldbu	r2,-12(fp)
81104150:	10000626 	beq	r2,zero,8110416c <bSdmaDmaM2Transfer+0xd0>
81104154:	10800060 	cmpeqi	r2,r2,1
81104158:	10000926 	beq	r2,zero,81104180 <bSdmaDmaM2Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
8110415c:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104160:	00800044 	movi	r2,1
81104164:	e0bff715 	stw	r2,-36(fp)
			break;
81104168:	00000706 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
8110416c:	00800074 	movhi	r2,1
81104170:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81104174:	00800044 	movi	r2,1
81104178:	e0bff715 	stw	r2,-36(fp)
			break;
8110417c:	00000206 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		default:
			bStatus = FALSE;
81104180:	e03ff415 	stw	zero,-48(fp)
			break;
81104184:	0001883a 	nop
		}
		break;
81104188:	00008006 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
8110418c:	e0bffd03 	ldbu	r2,-12(fp)
81104190:	10000726 	beq	r2,zero,811041b0 <bSdmaDmaM2Transfer+0x114>
81104194:	10800060 	cmpeqi	r2,r2,1
81104198:	10000b26 	beq	r2,zero,811041c8 <bSdmaDmaM2Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
8110419c:	00880004 	movi	r2,8192
811041a0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811041a4:	00800044 	movi	r2,1
811041a8:	e0bff715 	stw	r2,-36(fp)
			break;
811041ac:	00000806 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811041b0:	00800074 	movhi	r2,1
811041b4:	10880004 	addi	r2,r2,8192
811041b8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811041bc:	00800044 	movi	r2,1
811041c0:	e0bff715 	stw	r2,-36(fp)
			break;
811041c4:	00000206 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		default:
			bStatus = FALSE;
811041c8:	e03ff415 	stw	zero,-48(fp)
			break;
811041cc:	0001883a 	nop
		}
		break;
811041d0:	00006e06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811041d4:	e0bffd03 	ldbu	r2,-12(fp)
811041d8:	10000726 	beq	r2,zero,811041f8 <bSdmaDmaM2Transfer+0x15c>
811041dc:	10800060 	cmpeqi	r2,r2,1
811041e0:	10000b26 	beq	r2,zero,81104210 <bSdmaDmaM2Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
811041e4:	00900004 	movi	r2,16384
811041e8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
811041ec:	00800044 	movi	r2,1
811041f0:	e0bff715 	stw	r2,-36(fp)
			break;
811041f4:	00000806 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
811041f8:	00800074 	movhi	r2,1
811041fc:	10900004 	addi	r2,r2,16384
81104200:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104204:	00800044 	movi	r2,1
81104208:	e0bff715 	stw	r2,-36(fp)
			break;
8110420c:	00000206 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		default:
			bStatus = FALSE;
81104210:	e03ff415 	stw	zero,-48(fp)
			break;
81104214:	0001883a 	nop
		}
		break;
81104218:	00005c06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
8110421c:	e0bffd03 	ldbu	r2,-12(fp)
81104220:	10000726 	beq	r2,zero,81104240 <bSdmaDmaM2Transfer+0x1a4>
81104224:	10800060 	cmpeqi	r2,r2,1
81104228:	10000b26 	beq	r2,zero,81104258 <bSdmaDmaM2Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
8110422c:	00980004 	movi	r2,24576
81104230:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104234:	00800044 	movi	r2,1
81104238:	e0bff715 	stw	r2,-36(fp)
			break;
8110423c:	00000806 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104240:	00800074 	movhi	r2,1
81104244:	10980004 	addi	r2,r2,24576
81104248:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
8110424c:	00800044 	movi	r2,1
81104250:	e0bff715 	stw	r2,-36(fp)
			break;
81104254:	00000206 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		default:
			bStatus = FALSE;
81104258:	e03ff415 	stw	zero,-48(fp)
			break;
8110425c:	0001883a 	nop
		}
		break;
81104260:	00004a06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104264:	e0bffd03 	ldbu	r2,-12(fp)
81104268:	10000726 	beq	r2,zero,81104288 <bSdmaDmaM2Transfer+0x1ec>
8110426c:	10800060 	cmpeqi	r2,r2,1
81104270:	10000b26 	beq	r2,zero,811042a0 <bSdmaDmaM2Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104274:	00a00014 	movui	r2,32768
81104278:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
8110427c:	00800044 	movi	r2,1
81104280:	e0bff715 	stw	r2,-36(fp)
			break;
81104284:	00000806 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104288:	008000b4 	movhi	r2,2
8110428c:	10a00004 	addi	r2,r2,-32768
81104290:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104294:	00800044 	movi	r2,1
81104298:	e0bff715 	stw	r2,-36(fp)
			break;
8110429c:	00000206 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		default:
			bStatus = FALSE;
811042a0:	e03ff415 	stw	zero,-48(fp)
			break;
811042a4:	0001883a 	nop
		}
		break;
811042a8:	00003806 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811042ac:	e0bffd03 	ldbu	r2,-12(fp)
811042b0:	10000726 	beq	r2,zero,811042d0 <bSdmaDmaM2Transfer+0x234>
811042b4:	10800060 	cmpeqi	r2,r2,1
811042b8:	10000b26 	beq	r2,zero,811042e8 <bSdmaDmaM2Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811042bc:	00a80014 	movui	r2,40960
811042c0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811042c4:	00800044 	movi	r2,1
811042c8:	e0bff715 	stw	r2,-36(fp)
			break;
811042cc:	00000806 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811042d0:	008000b4 	movhi	r2,2
811042d4:	10a80004 	addi	r2,r2,-24576
811042d8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
811042dc:	00800044 	movi	r2,1
811042e0:	e0bff715 	stw	r2,-36(fp)
			break;
811042e4:	00000206 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		default:
			bStatus = FALSE;
811042e8:	e03ff415 	stw	zero,-48(fp)
			break;
811042ec:	0001883a 	nop
		}
		break;
811042f0:	00002606 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811042f4:	e0bffd03 	ldbu	r2,-12(fp)
811042f8:	10000726 	beq	r2,zero,81104318 <bSdmaDmaM2Transfer+0x27c>
811042fc:	10800060 	cmpeqi	r2,r2,1
81104300:	10000b26 	beq	r2,zero,81104330 <bSdmaDmaM2Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104304:	00b00014 	movui	r2,49152
81104308:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
8110430c:	00800044 	movi	r2,1
81104310:	e0bff715 	stw	r2,-36(fp)
			break;
81104314:	00000806 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104318:	008000b4 	movhi	r2,2
8110431c:	10b00004 	addi	r2,r2,-16384
81104320:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104324:	00800044 	movi	r2,1
81104328:	e0bff715 	stw	r2,-36(fp)
			break;
8110432c:	00000206 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		default:
			bStatus = FALSE;
81104330:	e03ff415 	stw	zero,-48(fp)
			break;
81104334:	0001883a 	nop
		}
		break;
81104338:	00001406 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110433c:	e0bffd03 	ldbu	r2,-12(fp)
81104340:	10000726 	beq	r2,zero,81104360 <bSdmaDmaM2Transfer+0x2c4>
81104344:	10800060 	cmpeqi	r2,r2,1
81104348:	10000b26 	beq	r2,zero,81104378 <bSdmaDmaM2Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110434c:	00b80014 	movui	r2,57344
81104350:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104354:	00800044 	movi	r2,1
81104358:	e0bff715 	stw	r2,-36(fp)
			break;
8110435c:	00000806 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104360:	008000b4 	movhi	r2,2
81104364:	10b80004 	addi	r2,r2,-8192
81104368:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
8110436c:	00800044 	movi	r2,1
81104370:	e0bff715 	stw	r2,-36(fp)
			break;
81104374:	00000206 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		default:
			bStatus = FALSE;
81104378:	e03ff415 	stw	zero,-48(fp)
			break;
8110437c:	0001883a 	nop
		}
		break;
81104380:	00000206 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	default:
		bStatus = FALSE;
81104384:	e03ff415 	stw	zero,-48(fp)
		break;
81104388:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
8110438c:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104390:	00a00034 	movhi	r2,32768
81104394:	1885883a 	add	r2,r3,r2
81104398:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
8110439c:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
811043a0:	e0bff417 	ldw	r2,-48(fp)
811043a4:	10003b26 	beq	r2,zero,81104494 <bSdmaDmaM2Transfer+0x3f8>
		if (pxDmaM2Dev == NULL) {
811043a8:	d0a03a17 	ldw	r2,-32536(gp)
811043ac:	1000021e 	bne	r2,zero,811043b8 <bSdmaDmaM2Transfer+0x31c>
			bStatus = FALSE;
811043b0:	e03ff415 	stw	zero,-48(fp)
811043b4:	00003706 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811043b8:	e03ff50d 	sth	zero,-44(fp)
811043bc:	00003206 	br	81104488 <bSdmaDmaM2Transfer+0x3ec>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811043c0:	01000044 	movi	r4,1
811043c4:	11319800 	call	81131980 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811043c8:	d0a03a17 	ldw	r2,-32536(gp)
811043cc:	10800317 	ldw	r2,12(r2)
811043d0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811043d4:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
811043d8:	103ff91e 	bne	r2,zero,811043c0 <__reset+0xfb0e43c0>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811043dc:	d2203a17 	ldw	r8,-32536(gp)
811043e0:	e17ff817 	ldw	r5,-32(fp)
811043e4:	e1bff617 	ldw	r6,-40(fp)
811043e8:	e0bff917 	ldw	r2,-28(fp)
811043ec:	e0fff717 	ldw	r3,-36(fp)
811043f0:	01000044 	movi	r4,1
811043f4:	d9000815 	stw	r4,32(sp)
811043f8:	01000044 	movi	r4,1
811043fc:	d9000715 	stw	r4,28(sp)
81104400:	01000044 	movi	r4,1
81104404:	d9000615 	stw	r4,24(sp)
81104408:	01000044 	movi	r4,1
8110440c:	d9000515 	stw	r4,20(sp)
81104410:	01000044 	movi	r4,1
81104414:	d9000415 	stw	r4,16(sp)
81104418:	d8c00315 	stw	r3,12(sp)
8110441c:	d8800215 	stw	r2,8(sp)
81104420:	e0bffa17 	ldw	r2,-24(fp)
81104424:	d8800115 	stw	r2,4(sp)
81104428:	00802204 	movi	r2,136
8110442c:	d8800015 	stw	r2,0(sp)
81104430:	300f883a 	mov	r7,r6
81104434:	280d883a 	mov	r6,r5
81104438:	800b883a 	mov	r5,r16
8110443c:	4009883a 	mov	r4,r8
81104440:	110ac900 	call	8110ac90 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104444:	10000226 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x3b4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104448:	e03ff415 	stw	zero,-48(fp)
					break;
8110444c:	00001106 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104450:	d0a03a17 	ldw	r2,-32536(gp)
81104454:	800b883a 	mov	r5,r16
81104458:	1009883a 	mov	r4,r2
8110445c:	110ad940 	call	8110ad94 <iMsgdmaExtendedDescriptorSyncTransfer>
81104460:	10000226 	beq	r2,zero,8110446c <bSdmaDmaM2Transfer+0x3d0>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104464:	e03ff415 	stw	zero,-48(fp)
						break;
81104468:	00000a06 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
8110446c:	e0bff817 	ldw	r2,-32(fp)
81104470:	10802204 	addi	r2,r2,136
81104474:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104478:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
8110447c:	e0bff50b 	ldhu	r2,-44(fp)
81104480:	10800044 	addi	r2,r2,1
81104484:	e0bff50d 	sth	r2,-44(fp)
81104488:	e0fff50b 	ldhu	r3,-44(fp)
8110448c:	e0bffc0b 	ldhu	r2,-16(fp)
81104490:	18bfcd36 	bltu	r3,r2,811043c8 <__reset+0xfb0e43c8>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104494:	e0bff417 	ldw	r2,-48(fp)
}
81104498:	e6ffff04 	addi	sp,fp,-4
8110449c:	dfc00217 	ldw	ra,8(sp)
811044a0:	df000117 	ldw	fp,4(sp)
811044a4:	dc000017 	ldw	r16,0(sp)
811044a8:	dec00304 	addi	sp,sp,12
811044ac:	f800283a 	ret

811044b0 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
811044b0:	defff904 	addi	sp,sp,-28
811044b4:	de00012e 	bgeu	sp,et,811044bc <bCommSetGlobalIrqEn+0xc>
811044b8:	003b68fa 	trap	3
811044bc:	dfc00615 	stw	ra,24(sp)
811044c0:	df000515 	stw	fp,20(sp)
811044c4:	df000504 	addi	fp,sp,20
811044c8:	e13ffe15 	stw	r4,-8(fp)
811044cc:	2805883a 	mov	r2,r5
811044d0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811044d4:	00800044 	movi	r2,1
811044d8:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
811044dc:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
811044e0:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
811044e4:	e0bfff03 	ldbu	r2,-4(fp)
811044e8:	10c00228 	cmpgeui	r3,r2,8
811044ec:	18002e1e 	bne	r3,zero,811045a8 <bCommSetGlobalIrqEn+0xf8>
811044f0:	100690ba 	slli	r3,r2,2
811044f4:	00a04434 	movhi	r2,33040
811044f8:	10914204 	addi	r2,r2,17672
811044fc:	1885883a 	add	r2,r3,r2
81104500:	10800017 	ldw	r2,0(r2)
81104504:	1000683a 	jmp	r2
81104508:	81104528 	cmpgeui	r4,r16,16660
8110450c:	81104538 	rdprs	r4,r16,16660
81104510:	81104548 	cmpgei	r4,r16,16661
81104514:	81104558 	cmpnei	r4,r16,16661
81104518:	81104568 	cmpgeui	r4,r16,16661
8110451c:	81104578 	rdprs	r4,r16,16661
81104520:	81104588 	cmpgei	r4,r16,16662
81104524:	81104598 	cmpnei	r4,r16,16662
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104528:	00a04834 	movhi	r2,33056
8110452c:	108b0004 	addi	r2,r2,11264
81104530:	e0bffd15 	stw	r2,-12(fp)
		break;
81104534:	00001e06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104538:	00a04834 	movhi	r2,33056
8110453c:	108a0004 	addi	r2,r2,10240
81104540:	e0bffd15 	stw	r2,-12(fp)
		break;
81104544:	00001a06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104548:	00a04834 	movhi	r2,33056
8110454c:	10890004 	addi	r2,r2,9216
81104550:	e0bffd15 	stw	r2,-12(fp)
		break;
81104554:	00001606 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104558:	00a04834 	movhi	r2,33056
8110455c:	10880004 	addi	r2,r2,8192
81104560:	e0bffd15 	stw	r2,-12(fp)
		break;
81104564:	00001206 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104568:	00a04834 	movhi	r2,33056
8110456c:	10870004 	addi	r2,r2,7168
81104570:	e0bffd15 	stw	r2,-12(fp)
		break;
81104574:	00000e06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104578:	00a04834 	movhi	r2,33056
8110457c:	10860004 	addi	r2,r2,6144
81104580:	e0bffd15 	stw	r2,-12(fp)
		break;
81104584:	00000a06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104588:	00a04834 	movhi	r2,33056
8110458c:	10850004 	addi	r2,r2,5120
81104590:	e0bffd15 	stw	r2,-12(fp)
		break;
81104594:	00000606 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104598:	00a04834 	movhi	r2,33056
8110459c:	10840004 	addi	r2,r2,4096
811045a0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045a4:	00000206 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
811045a8:	e03ffb15 	stw	zero,-20(fp)
		break;
811045ac:	0001883a 	nop
	}

	if (bStatus) {
811045b0:	e0bffb17 	ldw	r2,-20(fp)
811045b4:	10001326 	beq	r2,zero,81104604 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
811045b8:	01400444 	movi	r5,17
811045bc:	e13ffd17 	ldw	r4,-12(fp)
811045c0:	110474c0 	call	8110474c <uliCommReadReg>
811045c4:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
811045c8:	e0bffe17 	ldw	r2,-8(fp)
811045cc:	10000426 	beq	r2,zero,811045e0 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
811045d0:	e0bffc17 	ldw	r2,-16(fp)
811045d4:	10800074 	orhi	r2,r2,1
811045d8:	e0bffc15 	stw	r2,-16(fp)
811045dc:	00000506 	br	811045f4 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
811045e0:	e0fffc17 	ldw	r3,-16(fp)
811045e4:	00bffff4 	movhi	r2,65535
811045e8:	10bfffc4 	addi	r2,r2,-1
811045ec:	1884703a 	and	r2,r3,r2
811045f0:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
811045f4:	e1bffc17 	ldw	r6,-16(fp)
811045f8:	01400444 	movi	r5,17
811045fc:	e13ffd17 	ldw	r4,-12(fp)
81104600:	11046f80 	call	811046f8 <vCommWriteReg>
	}

	return bStatus;
81104604:	e0bffb17 	ldw	r2,-20(fp)
}
81104608:	e037883a 	mov	sp,fp
8110460c:	dfc00117 	ldw	ra,4(sp)
81104610:	df000017 	ldw	fp,0(sp)
81104614:	dec00204 	addi	sp,sp,8
81104618:	f800283a 	ret

8110461c <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
8110461c:	defffb04 	addi	sp,sp,-20
81104620:	de00012e 	bgeu	sp,et,81104628 <bCommInitCh+0xc>
81104624:	003b68fa 	trap	3
81104628:	dfc00415 	stw	ra,16(sp)
8110462c:	df000315 	stw	fp,12(sp)
81104630:	df000304 	addi	fp,sp,12
81104634:	e13ffe15 	stw	r4,-8(fp)
81104638:	2805883a 	mov	r2,r5
8110463c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104640:	00800044 	movi	r2,1
81104644:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
81104648:	e0bffe17 	ldw	r2,-8(fp)
8110464c:	10805604 	addi	r2,r2,344
81104650:	e0ffff03 	ldbu	r3,-4(fp)
81104654:	180b883a 	mov	r5,r3
81104658:	1009883a 	mov	r4,r2
8110465c:	11096140 	call	81109614 <bSpwcInitCh>
81104660:	1000011e 	bne	r2,zero,81104668 <bCommInitCh+0x4c>
		bStatus = FALSE;
81104664:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
81104668:	e0bfff03 	ldbu	r2,-4(fp)
8110466c:	1009883a 	mov	r4,r2
81104670:	110582c0 	call	8110582c <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104674:	e0bffe17 	ldw	r2,-8(fp)
81104678:	10800904 	addi	r2,r2,36
8110467c:	e0ffff03 	ldbu	r3,-4(fp)
81104680:	180b883a 	mov	r5,r3
81104684:	1009883a 	mov	r4,r2
81104688:	1105f240 	call	81105f24 <bFeebInitCh>
8110468c:	1000011e 	bne	r2,zero,81104694 <bCommInitCh+0x78>
		bStatus = FALSE;
81104690:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104694:	e0bffe17 	ldw	r2,-8(fp)
81104698:	10801004 	addi	r2,r2,64
8110469c:	e0ffff03 	ldbu	r3,-4(fp)
811046a0:	180b883a 	mov	r5,r3
811046a4:	1009883a 	mov	r4,r2
811046a8:	1108c700 	call	81108c70 <bRmapInitCh>
811046ac:	1000011e 	bne	r2,zero,811046b4 <bCommInitCh+0x98>
		bStatus = FALSE;
811046b0:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
811046b4:	e0bfff03 	ldbu	r2,-4(fp)
811046b8:	1009883a 	mov	r4,r2
811046bc:	1106aac0 	call	81106aac <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
811046c0:	e0bffe17 	ldw	r2,-8(fp)
811046c4:	10800104 	addi	r2,r2,4
811046c8:	e0ffff03 	ldbu	r3,-4(fp)
811046cc:	180b883a 	mov	r5,r3
811046d0:	1009883a 	mov	r4,r2
811046d4:	1104dc40 	call	81104dc4 <bDpktInitCh>
811046d8:	1000011e 	bne	r2,zero,811046e0 <bCommInitCh+0xc4>
		bStatus = FALSE;
811046dc:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
811046e0:	e0bffd17 	ldw	r2,-12(fp)
}
811046e4:	e037883a 	mov	sp,fp
811046e8:	dfc00117 	ldw	ra,4(sp)
811046ec:	df000017 	ldw	fp,0(sp)
811046f0:	dec00204 	addi	sp,sp,8
811046f4:	f800283a 	ret

811046f8 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811046f8:	defffc04 	addi	sp,sp,-16
811046fc:	de00012e 	bgeu	sp,et,81104704 <vCommWriteReg+0xc>
81104700:	003b68fa 	trap	3
81104704:	df000315 	stw	fp,12(sp)
81104708:	df000304 	addi	fp,sp,12
8110470c:	e13ffd15 	stw	r4,-12(fp)
81104710:	e17ffe15 	stw	r5,-8(fp)
81104714:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104718:	e0bffe17 	ldw	r2,-8(fp)
8110471c:	1085883a 	add	r2,r2,r2
81104720:	1085883a 	add	r2,r2,r2
81104724:	1007883a 	mov	r3,r2
81104728:	e0bffd17 	ldw	r2,-12(fp)
8110472c:	10c5883a 	add	r2,r2,r3
81104730:	e0ffff17 	ldw	r3,-4(fp)
81104734:	10c00015 	stw	r3,0(r2)
}
81104738:	0001883a 	nop
8110473c:	e037883a 	mov	sp,fp
81104740:	df000017 	ldw	fp,0(sp)
81104744:	dec00104 	addi	sp,sp,4
81104748:	f800283a 	ret

8110474c <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110474c:	defffc04 	addi	sp,sp,-16
81104750:	de00012e 	bgeu	sp,et,81104758 <uliCommReadReg+0xc>
81104754:	003b68fa 	trap	3
81104758:	df000315 	stw	fp,12(sp)
8110475c:	df000304 	addi	fp,sp,12
81104760:	e13ffe15 	stw	r4,-8(fp)
81104764:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104768:	e0bfff17 	ldw	r2,-4(fp)
8110476c:	1085883a 	add	r2,r2,r2
81104770:	1085883a 	add	r2,r2,r2
81104774:	1007883a 	mov	r3,r2
81104778:	e0bffe17 	ldw	r2,-8(fp)
8110477c:	10c5883a 	add	r2,r2,r3
81104780:	10800017 	ldw	r2,0(r2)
81104784:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104788:	e0bffd17 	ldw	r2,-12(fp)
}
8110478c:	e037883a 	mov	sp,fp
81104790:	df000017 	ldw	fp,0(sp)
81104794:	dec00104 	addi	sp,sp,4
81104798:	f800283a 	ret

8110479c <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
8110479c:	defffb04 	addi	sp,sp,-20
811047a0:	de00012e 	bgeu	sp,et,811047a8 <bDpktSetPacketConfig+0xc>
811047a4:	003b68fa 	trap	3
811047a8:	dfc00415 	stw	ra,16(sp)
811047ac:	df000315 	stw	fp,12(sp)
811047b0:	df000304 	addi	fp,sp,12
811047b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811047b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811047bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811047c0:	e0bfff17 	ldw	r2,-4(fp)
811047c4:	10007a26 	beq	r2,zero,811049b0 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811047c8:	e0bfff17 	ldw	r2,-4(fp)
811047cc:	10800017 	ldw	r2,0(r2)
811047d0:	01400204 	movi	r5,8
811047d4:	1009883a 	mov	r4,r2
811047d8:	1104f8c0 	call	81104f8c <uliDpktReadReg>
811047dc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
811047e0:	e0bffe17 	ldw	r2,-8(fp)
811047e4:	10bfffec 	andhi	r2,r2,65535
811047e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
811047ec:	e0bfff17 	ldw	r2,-4(fp)
811047f0:	1080010b 	ldhu	r2,4(r2)
811047f4:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
811047f8:	e0fffe17 	ldw	r3,-8(fp)
811047fc:	1884b03a 	or	r2,r3,r2
81104800:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104804:	e0bffe17 	ldw	r2,-8(fp)
81104808:	10bfffcc 	andi	r2,r2,65535
8110480c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81104810:	e0bfff17 	ldw	r2,-4(fp)
81104814:	1080018b 	ldhu	r2,6(r2)
81104818:	10bfffcc 	andi	r2,r2,65535
8110481c:	1004943a 	slli	r2,r2,16
81104820:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81104824:	e0bffe17 	ldw	r2,-8(fp)
81104828:	10c4b03a 	or	r2,r2,r3
8110482c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
81104830:	e0bfff17 	ldw	r2,-4(fp)
81104834:	10800017 	ldw	r2,0(r2)
81104838:	e1bffe17 	ldw	r6,-8(fp)
8110483c:	01400204 	movi	r5,8
81104840:	1009883a 	mov	r4,r2
81104844:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104848:	e0bfff17 	ldw	r2,-4(fp)
8110484c:	10800017 	ldw	r2,0(r2)
81104850:	01400244 	movi	r5,9
81104854:	1009883a 	mov	r4,r2
81104858:	1104f8c0 	call	81104f8c <uliDpktReadReg>
8110485c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104860:	e0bffe17 	ldw	r2,-8(fp)
81104864:	10bfffec 	andhi	r2,r2,65535
81104868:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
8110486c:	e0bfff17 	ldw	r2,-4(fp)
81104870:	1080020b 	ldhu	r2,8(r2)
81104874:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104878:	e0fffe17 	ldw	r3,-8(fp)
8110487c:	1884b03a 	or	r2,r3,r2
81104880:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104884:	e0bffe17 	ldw	r2,-8(fp)
81104888:	10bfffcc 	andi	r2,r2,65535
8110488c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104890:	e0bfff17 	ldw	r2,-4(fp)
81104894:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104898:	10bfffcc 	andi	r2,r2,65535
8110489c:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
811048a0:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
811048a4:	e0bffe17 	ldw	r2,-8(fp)
811048a8:	10c4b03a 	or	r2,r2,r3
811048ac:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
811048b0:	e0bfff17 	ldw	r2,-4(fp)
811048b4:	10800017 	ldw	r2,0(r2)
811048b8:	e1bffe17 	ldw	r6,-8(fp)
811048bc:	01400244 	movi	r5,9
811048c0:	1009883a 	mov	r4,r2
811048c4:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048c8:	e0bfff17 	ldw	r2,-4(fp)
811048cc:	10800017 	ldw	r2,0(r2)
811048d0:	01400284 	movi	r5,10
811048d4:	1009883a 	mov	r4,r2
811048d8:	1104f8c0 	call	81104f8c <uliDpktReadReg>
811048dc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
811048e0:	e0bffe17 	ldw	r2,-8(fp)
811048e4:	10bfffec 	andhi	r2,r2,65535
811048e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
811048ec:	e0bfff17 	ldw	r2,-4(fp)
811048f0:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
811048f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
811048f8:	e0fffe17 	ldw	r3,-8(fp)
811048fc:	1884b03a 	or	r2,r3,r2
81104900:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104904:	e0bfff17 	ldw	r2,-4(fp)
81104908:	10800017 	ldw	r2,0(r2)
8110490c:	e1bffe17 	ldw	r6,-8(fp)
81104910:	01400284 	movi	r5,10
81104914:	1009883a 	mov	r4,r2
81104918:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110491c:	e0bfff17 	ldw	r2,-4(fp)
81104920:	10800017 	ldw	r2,0(r2)
81104924:	014002c4 	movi	r5,11
81104928:	1009883a 	mov	r4,r2
8110492c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104930:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104934:	e0fffe17 	ldw	r3,-8(fp)
81104938:	00bfc004 	movi	r2,-256
8110493c:	1884703a 	and	r2,r3,r2
81104940:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104944:	e0bfff17 	ldw	r2,-4(fp)
81104948:	10800383 	ldbu	r2,14(r2)
8110494c:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81104950:	e0fffe17 	ldw	r3,-8(fp)
81104954:	1884b03a 	or	r2,r3,r2
81104958:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
8110495c:	e0fffe17 	ldw	r3,-8(fp)
81104960:	00bffff4 	movhi	r2,65535
81104964:	10803fc4 	addi	r2,r2,255
81104968:	1884703a 	and	r2,r3,r2
8110496c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104970:	e0bfff17 	ldw	r2,-4(fp)
81104974:	108003c3 	ldbu	r2,15(r2)
81104978:	10803fcc 	andi	r2,r2,255
8110497c:	1004923a 	slli	r2,r2,8
81104980:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104984:	e0fffe17 	ldw	r3,-8(fp)
81104988:	1884b03a 	or	r2,r3,r2
8110498c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104990:	e0bfff17 	ldw	r2,-4(fp)
81104994:	10800017 	ldw	r2,0(r2)
81104998:	e1bffe17 	ldw	r6,-8(fp)
8110499c:	014002c4 	movi	r5,11
811049a0:	1009883a 	mov	r4,r2
811049a4:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
811049a8:	00800044 	movi	r2,1
811049ac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811049b0:	e0bffd17 	ldw	r2,-12(fp)
}
811049b4:	e037883a 	mov	sp,fp
811049b8:	dfc00117 	ldw	ra,4(sp)
811049bc:	df000017 	ldw	fp,0(sp)
811049c0:	dec00204 	addi	sp,sp,8
811049c4:	f800283a 	ret

811049c8 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
811049c8:	defffb04 	addi	sp,sp,-20
811049cc:	de00012e 	bgeu	sp,et,811049d4 <bDpktGetPacketConfig+0xc>
811049d0:	003b68fa 	trap	3
811049d4:	dfc00415 	stw	ra,16(sp)
811049d8:	df000315 	stw	fp,12(sp)
811049dc:	df000304 	addi	fp,sp,12
811049e0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811049e4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811049e8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811049ec:	e0bfff17 	ldw	r2,-4(fp)
811049f0:	10003a26 	beq	r2,zero,81104adc <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049f4:	e0bfff17 	ldw	r2,-4(fp)
811049f8:	10800017 	ldw	r2,0(r2)
811049fc:	01400204 	movi	r5,8
81104a00:	1009883a 	mov	r4,r2
81104a04:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a08:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104a0c:	e0bffe17 	ldw	r2,-8(fp)
81104a10:	1007883a 	mov	r3,r2
81104a14:	e0bfff17 	ldw	r2,-4(fp)
81104a18:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104a1c:	e0bffe17 	ldw	r2,-8(fp)
81104a20:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104a24:	1007883a 	mov	r3,r2
81104a28:	e0bfff17 	ldw	r2,-4(fp)
81104a2c:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a30:	e0bfff17 	ldw	r2,-4(fp)
81104a34:	10800017 	ldw	r2,0(r2)
81104a38:	01400244 	movi	r5,9
81104a3c:	1009883a 	mov	r4,r2
81104a40:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a44:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104a48:	e0bffe17 	ldw	r2,-8(fp)
81104a4c:	1007883a 	mov	r3,r2
81104a50:	e0bfff17 	ldw	r2,-4(fp)
81104a54:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104a58:	e0bffe17 	ldw	r2,-8(fp)
81104a5c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104a60:	1007883a 	mov	r3,r2
81104a64:	e0bfff17 	ldw	r2,-4(fp)
81104a68:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a6c:	e0bfff17 	ldw	r2,-4(fp)
81104a70:	10800017 	ldw	r2,0(r2)
81104a74:	01400284 	movi	r5,10
81104a78:	1009883a 	mov	r4,r2
81104a7c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a80:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104a84:	e0bffe17 	ldw	r2,-8(fp)
81104a88:	1007883a 	mov	r3,r2
81104a8c:	e0bfff17 	ldw	r2,-4(fp)
81104a90:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a94:	e0bfff17 	ldw	r2,-4(fp)
81104a98:	10800017 	ldw	r2,0(r2)
81104a9c:	014002c4 	movi	r5,11
81104aa0:	1009883a 	mov	r4,r2
81104aa4:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104aa8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104aac:	e0bffe17 	ldw	r2,-8(fp)
81104ab0:	1007883a 	mov	r3,r2
81104ab4:	e0bfff17 	ldw	r2,-4(fp)
81104ab8:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104abc:	e0bffe17 	ldw	r2,-8(fp)
81104ac0:	10bfc00c 	andi	r2,r2,65280
81104ac4:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104ac8:	1007883a 	mov	r3,r2
81104acc:	e0bfff17 	ldw	r2,-4(fp)
81104ad0:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104ad4:	00800044 	movi	r2,1
81104ad8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104adc:	e0bffd17 	ldw	r2,-12(fp)
}
81104ae0:	e037883a 	mov	sp,fp
81104ae4:	dfc00117 	ldw	ra,4(sp)
81104ae8:	df000017 	ldw	fp,0(sp)
81104aec:	dec00204 	addi	sp,sp,8
81104af0:	f800283a 	ret

81104af4 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104af4:	defffb04 	addi	sp,sp,-20
81104af8:	de00012e 	bgeu	sp,et,81104b00 <bDpktGetPacketHeader+0xc>
81104afc:	003b68fa 	trap	3
81104b00:	dfc00415 	stw	ra,16(sp)
81104b04:	df000315 	stw	fp,12(sp)
81104b08:	df000304 	addi	fp,sp,12
81104b0c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b10:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b14:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104b18:	e0bfff17 	ldw	r2,-4(fp)
81104b1c:	10002026 	beq	r2,zero,81104ba0 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b20:	e0bfff17 	ldw	r2,-4(fp)
81104b24:	10800017 	ldw	r2,0(r2)
81104b28:	01400304 	movi	r5,12
81104b2c:	1009883a 	mov	r4,r2
81104b30:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104b34:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104b38:	e0bffe17 	ldw	r2,-8(fp)
81104b3c:	1007883a 	mov	r3,r2
81104b40:	e0bfff17 	ldw	r2,-4(fp)
81104b44:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104b48:	e0bffe17 	ldw	r2,-8(fp)
81104b4c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104b50:	1007883a 	mov	r3,r2
81104b54:	e0bfff17 	ldw	r2,-4(fp)
81104b58:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b5c:	e0bfff17 	ldw	r2,-4(fp)
81104b60:	10800017 	ldw	r2,0(r2)
81104b64:	01400344 	movi	r5,13
81104b68:	1009883a 	mov	r4,r2
81104b6c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104b70:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104b74:	e0bffe17 	ldw	r2,-8(fp)
81104b78:	1007883a 	mov	r3,r2
81104b7c:	e0bfff17 	ldw	r2,-4(fp)
81104b80:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104b84:	e0bffe17 	ldw	r2,-8(fp)
81104b88:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104b8c:	1007883a 	mov	r3,r2
81104b90:	e0bfff17 	ldw	r2,-4(fp)
81104b94:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104b98:	00800044 	movi	r2,1
81104b9c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ba0:	e0bffd17 	ldw	r2,-12(fp)
}
81104ba4:	e037883a 	mov	sp,fp
81104ba8:	dfc00117 	ldw	ra,4(sp)
81104bac:	df000017 	ldw	fp,0(sp)
81104bb0:	dec00204 	addi	sp,sp,8
81104bb4:	f800283a 	ret

81104bb8 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104bb8:	defffb04 	addi	sp,sp,-20
81104bbc:	de00012e 	bgeu	sp,et,81104bc4 <bDpktSetPixelDelay+0xc>
81104bc0:	003b68fa 	trap	3
81104bc4:	dfc00415 	stw	ra,16(sp)
81104bc8:	df000315 	stw	fp,12(sp)
81104bcc:	df000304 	addi	fp,sp,12
81104bd0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104bd4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104bd8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bdc:	e0bfff17 	ldw	r2,-4(fp)
81104be0:	10004126 	beq	r2,zero,81104ce8 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104be4:	e0bfff17 	ldw	r2,-4(fp)
81104be8:	10800017 	ldw	r2,0(r2)
81104bec:	01400384 	movi	r5,14
81104bf0:	1009883a 	mov	r4,r2
81104bf4:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104bf8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104bfc:	e0bffe17 	ldw	r2,-8(fp)
81104c00:	10bfffec 	andhi	r2,r2,65535
81104c04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104c08:	e0bfff17 	ldw	r2,-4(fp)
81104c0c:	1080060b 	ldhu	r2,24(r2)
81104c10:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104c14:	e0fffe17 	ldw	r3,-8(fp)
81104c18:	1884b03a 	or	r2,r3,r2
81104c1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104c20:	e0bfff17 	ldw	r2,-4(fp)
81104c24:	10800017 	ldw	r2,0(r2)
81104c28:	e1bffe17 	ldw	r6,-8(fp)
81104c2c:	01400384 	movi	r5,14
81104c30:	1009883a 	mov	r4,r2
81104c34:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c38:	e0bfff17 	ldw	r2,-4(fp)
81104c3c:	10800017 	ldw	r2,0(r2)
81104c40:	014003c4 	movi	r5,15
81104c44:	1009883a 	mov	r4,r2
81104c48:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104c4c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104c50:	e0bffe17 	ldw	r2,-8(fp)
81104c54:	10bfffec 	andhi	r2,r2,65535
81104c58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104c5c:	e0bfff17 	ldw	r2,-4(fp)
81104c60:	1080068b 	ldhu	r2,26(r2)
81104c64:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104c68:	e0fffe17 	ldw	r3,-8(fp)
81104c6c:	1884b03a 	or	r2,r3,r2
81104c70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104c74:	e0bfff17 	ldw	r2,-4(fp)
81104c78:	10800017 	ldw	r2,0(r2)
81104c7c:	e1bffe17 	ldw	r6,-8(fp)
81104c80:	014003c4 	movi	r5,15
81104c84:	1009883a 	mov	r4,r2
81104c88:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c8c:	e0bfff17 	ldw	r2,-4(fp)
81104c90:	10800017 	ldw	r2,0(r2)
81104c94:	01400404 	movi	r5,16
81104c98:	1009883a 	mov	r4,r2
81104c9c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104ca0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104ca4:	e0bffe17 	ldw	r2,-8(fp)
81104ca8:	10bfffec 	andhi	r2,r2,65535
81104cac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104cb0:	e0bfff17 	ldw	r2,-4(fp)
81104cb4:	1080070b 	ldhu	r2,28(r2)
81104cb8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104cbc:	e0fffe17 	ldw	r3,-8(fp)
81104cc0:	1884b03a 	or	r2,r3,r2
81104cc4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104cc8:	e0bfff17 	ldw	r2,-4(fp)
81104ccc:	10800017 	ldw	r2,0(r2)
81104cd0:	e1bffe17 	ldw	r6,-8(fp)
81104cd4:	01400404 	movi	r5,16
81104cd8:	1009883a 	mov	r4,r2
81104cdc:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104ce0:	00800044 	movi	r2,1
81104ce4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ce8:	e0bffd17 	ldw	r2,-12(fp)
}
81104cec:	e037883a 	mov	sp,fp
81104cf0:	dfc00117 	ldw	ra,4(sp)
81104cf4:	df000017 	ldw	fp,0(sp)
81104cf8:	dec00204 	addi	sp,sp,8
81104cfc:	f800283a 	ret

81104d00 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104d00:	defffb04 	addi	sp,sp,-20
81104d04:	de00012e 	bgeu	sp,et,81104d0c <bDpktGetPixelDelay+0xc>
81104d08:	003b68fa 	trap	3
81104d0c:	dfc00415 	stw	ra,16(sp)
81104d10:	df000315 	stw	fp,12(sp)
81104d14:	df000304 	addi	fp,sp,12
81104d18:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d1c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d20:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104d24:	e0bfff17 	ldw	r2,-4(fp)
81104d28:	10002026 	beq	r2,zero,81104dac <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d2c:	e0bfff17 	ldw	r2,-4(fp)
81104d30:	10800017 	ldw	r2,0(r2)
81104d34:	01400384 	movi	r5,14
81104d38:	1009883a 	mov	r4,r2
81104d3c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d40:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104d44:	e0bffe17 	ldw	r2,-8(fp)
81104d48:	1007883a 	mov	r3,r2
81104d4c:	e0bfff17 	ldw	r2,-4(fp)
81104d50:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d54:	e0bfff17 	ldw	r2,-4(fp)
81104d58:	10800017 	ldw	r2,0(r2)
81104d5c:	014003c4 	movi	r5,15
81104d60:	1009883a 	mov	r4,r2
81104d64:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d68:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104d6c:	e0bffe17 	ldw	r2,-8(fp)
81104d70:	1007883a 	mov	r3,r2
81104d74:	e0bfff17 	ldw	r2,-4(fp)
81104d78:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d7c:	e0bfff17 	ldw	r2,-4(fp)
81104d80:	10800017 	ldw	r2,0(r2)
81104d84:	01400404 	movi	r5,16
81104d88:	1009883a 	mov	r4,r2
81104d8c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d90:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104d94:	e0bffe17 	ldw	r2,-8(fp)
81104d98:	1007883a 	mov	r3,r2
81104d9c:	e0bfff17 	ldw	r2,-4(fp)
81104da0:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104da4:	00800044 	movi	r2,1
81104da8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104dac:	e0bffd17 	ldw	r2,-12(fp)
}
81104db0:	e037883a 	mov	sp,fp
81104db4:	dfc00117 	ldw	ra,4(sp)
81104db8:	df000017 	ldw	fp,0(sp)
81104dbc:	dec00204 	addi	sp,sp,8
81104dc0:	f800283a 	ret

81104dc4 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104dc4:	defffb04 	addi	sp,sp,-20
81104dc8:	de00012e 	bgeu	sp,et,81104dd0 <bDpktInitCh+0xc>
81104dcc:	003b68fa 	trap	3
81104dd0:	dfc00415 	stw	ra,16(sp)
81104dd4:	df000315 	stw	fp,12(sp)
81104dd8:	df000304 	addi	fp,sp,12
81104ddc:	e13ffe15 	stw	r4,-8(fp)
81104de0:	2805883a 	mov	r2,r5
81104de4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104de8:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104dec:	e0bffe17 	ldw	r2,-8(fp)
81104df0:	10004b26 	beq	r2,zero,81104f20 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104df4:	00800044 	movi	r2,1
81104df8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104dfc:	e0bfff03 	ldbu	r2,-4(fp)
81104e00:	10c00228 	cmpgeui	r3,r2,8
81104e04:	1800361e 	bne	r3,zero,81104ee0 <bDpktInitCh+0x11c>
81104e08:	100690ba 	slli	r3,r2,2
81104e0c:	00a04434 	movhi	r2,33040
81104e10:	10938804 	addi	r2,r2,20000
81104e14:	1885883a 	add	r2,r3,r2
81104e18:	10800017 	ldw	r2,0(r2)
81104e1c:	1000683a 	jmp	r2
81104e20:	81104e40 	call	881104e4 <__reset+0x20f04e4>
81104e24:	81104e54 	ori	r4,r16,16697
81104e28:	81104e68 	cmpgeui	r4,r16,16697
81104e2c:	81104e7c 	xorhi	r4,r16,16697
81104e30:	81104e90 	cmplti	r4,r16,16698
81104e34:	81104ea4 	muli	r4,r16,16698
81104e38:	81104eb8 	rdprs	r4,r16,16698
81104e3c:	81104ecc 	andi	r4,r16,16699
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104e40:	e0fffe17 	ldw	r3,-8(fp)
81104e44:	00a04834 	movhi	r2,33056
81104e48:	108b0004 	addi	r2,r2,11264
81104e4c:	18800015 	stw	r2,0(r3)
			break;
81104e50:	00002506 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104e54:	e0fffe17 	ldw	r3,-8(fp)
81104e58:	00a04834 	movhi	r2,33056
81104e5c:	108a0004 	addi	r2,r2,10240
81104e60:	18800015 	stw	r2,0(r3)
			break;
81104e64:	00002006 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104e68:	e0fffe17 	ldw	r3,-8(fp)
81104e6c:	00a04834 	movhi	r2,33056
81104e70:	10890004 	addi	r2,r2,9216
81104e74:	18800015 	stw	r2,0(r3)
			break;
81104e78:	00001b06 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104e7c:	e0fffe17 	ldw	r3,-8(fp)
81104e80:	00a04834 	movhi	r2,33056
81104e84:	10880004 	addi	r2,r2,8192
81104e88:	18800015 	stw	r2,0(r3)
			break;
81104e8c:	00001606 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104e90:	e0fffe17 	ldw	r3,-8(fp)
81104e94:	00a04834 	movhi	r2,33056
81104e98:	10870004 	addi	r2,r2,7168
81104e9c:	18800015 	stw	r2,0(r3)
			break;
81104ea0:	00001106 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104ea4:	e0fffe17 	ldw	r3,-8(fp)
81104ea8:	00a04834 	movhi	r2,33056
81104eac:	10860004 	addi	r2,r2,6144
81104eb0:	18800015 	stw	r2,0(r3)
			break;
81104eb4:	00000c06 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104eb8:	e0fffe17 	ldw	r3,-8(fp)
81104ebc:	00a04834 	movhi	r2,33056
81104ec0:	10850004 	addi	r2,r2,5120
81104ec4:	18800015 	stw	r2,0(r3)
			break;
81104ec8:	00000706 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104ecc:	e0fffe17 	ldw	r3,-8(fp)
81104ed0:	00a04834 	movhi	r2,33056
81104ed4:	10840004 	addi	r2,r2,4096
81104ed8:	18800015 	stw	r2,0(r3)
			break;
81104edc:	00000206 	br	81104ee8 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104ee0:	e03ffd15 	stw	zero,-12(fp)
			break;
81104ee4:	0001883a 	nop
		}

		if (bStatus) {
81104ee8:	e0bffd17 	ldw	r2,-12(fp)
81104eec:	10000c26 	beq	r2,zero,81104f20 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104ef0:	e13ffe17 	ldw	r4,-8(fp)
81104ef4:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
81104ef8:	1000011e 	bne	r2,zero,81104f00 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104efc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104f00:	e13ffe17 	ldw	r4,-8(fp)
81104f04:	1104af40 	call	81104af4 <bDpktGetPacketHeader>
81104f08:	1000011e 	bne	r2,zero,81104f10 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104f0c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104f10:	e13ffe17 	ldw	r4,-8(fp)
81104f14:	1104d000 	call	81104d00 <bDpktGetPixelDelay>
81104f18:	1000011e 	bne	r2,zero,81104f20 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104f1c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104f20:	e0bffd17 	ldw	r2,-12(fp)
}
81104f24:	e037883a 	mov	sp,fp
81104f28:	dfc00117 	ldw	ra,4(sp)
81104f2c:	df000017 	ldw	fp,0(sp)
81104f30:	dec00204 	addi	sp,sp,8
81104f34:	f800283a 	ret

81104f38 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104f38:	defffc04 	addi	sp,sp,-16
81104f3c:	de00012e 	bgeu	sp,et,81104f44 <vDpktWriteReg+0xc>
81104f40:	003b68fa 	trap	3
81104f44:	df000315 	stw	fp,12(sp)
81104f48:	df000304 	addi	fp,sp,12
81104f4c:	e13ffd15 	stw	r4,-12(fp)
81104f50:	e17ffe15 	stw	r5,-8(fp)
81104f54:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104f58:	e0bffe17 	ldw	r2,-8(fp)
81104f5c:	1085883a 	add	r2,r2,r2
81104f60:	1085883a 	add	r2,r2,r2
81104f64:	1007883a 	mov	r3,r2
81104f68:	e0bffd17 	ldw	r2,-12(fp)
81104f6c:	10c5883a 	add	r2,r2,r3
81104f70:	e0ffff17 	ldw	r3,-4(fp)
81104f74:	10c00015 	stw	r3,0(r2)
}
81104f78:	0001883a 	nop
81104f7c:	e037883a 	mov	sp,fp
81104f80:	df000017 	ldw	fp,0(sp)
81104f84:	dec00104 	addi	sp,sp,4
81104f88:	f800283a 	ret

81104f8c <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81104f8c:	defffc04 	addi	sp,sp,-16
81104f90:	de00012e 	bgeu	sp,et,81104f98 <uliDpktReadReg+0xc>
81104f94:	003b68fa 	trap	3
81104f98:	df000315 	stw	fp,12(sp)
81104f9c:	df000304 	addi	fp,sp,12
81104fa0:	e13ffe15 	stw	r4,-8(fp)
81104fa4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104fa8:	e0bfff17 	ldw	r2,-4(fp)
81104fac:	1085883a 	add	r2,r2,r2
81104fb0:	1085883a 	add	r2,r2,r2
81104fb4:	1007883a 	mov	r3,r2
81104fb8:	e0bffe17 	ldw	r2,-8(fp)
81104fbc:	10c5883a 	add	r2,r2,r3
81104fc0:	10800017 	ldw	r2,0(r2)
81104fc4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104fc8:	e0bffd17 	ldw	r2,-12(fp)
}
81104fcc:	e037883a 	mov	sp,fp
81104fd0:	df000017 	ldw	fp,0(sp)
81104fd4:	dec00104 	addi	sp,sp,4
81104fd8:	f800283a 	ret

81104fdc <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81104fdc:	defffb04 	addi	sp,sp,-20
81104fe0:	de00012e 	bgeu	sp,et,81104fe8 <vFeebCh1HandleIrq+0xc>
81104fe4:	003b68fa 	trap	3
81104fe8:	dfc00415 	stw	ra,16(sp)
81104fec:	df000315 	stw	fp,12(sp)
81104ff0:	df000304 	addi	fp,sp,12
81104ff4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104ff8:	e0bfff17 	ldw	r2,-4(fp)
81104ffc:	e0bffd15 	stw	r2,-12(fp)
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 0 );
//	}

#ifdef DEBUG_ON
	fprintf(fp,"Interrupcao fee buffer\n");
81105000:	d0a05d17 	ldw	r2,-32396(gp)
81105004:	100f883a 	mov	r7,r2
81105008:	018005c4 	movi	r6,23
8110500c:	01400044 	movi	r5,1
81105010:	01204534 	movhi	r4,33044
81105014:	211ecd04 	addi	r4,r4,31540
81105018:	111c7b80 	call	8111c7b8 <fwrite>

	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */


	vFeebCh1IrqFlagClrBufferEmpty();
8110501c:	110534c0 	call	8110534c <vFeebCh1IrqFlagClrBufferEmpty>
}
81105020:	0001883a 	nop
81105024:	e037883a 	mov	sp,fp
81105028:	dfc00117 	ldw	ra,4(sp)
8110502c:	df000017 	ldw	fp,0(sp)
81105030:	dec00204 	addi	sp,sp,8
81105034:	f800283a 	ret

81105038 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81105038:	defffa04 	addi	sp,sp,-24
8110503c:	de00012e 	bgeu	sp,et,81105044 <vFeebCh2HandleIrq+0xc>
81105040:	003b68fa 	trap	3
81105044:	dfc00515 	stw	ra,20(sp)
81105048:	df000415 	stw	fp,16(sp)
8110504c:	df000404 	addi	fp,sp,16
81105050:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105054:	e0bfff17 	ldw	r2,-4(fp)
81105058:	e0bffc15 	stw	r2,-16(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110505c:	00800404 	movi	r2,16
81105060:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105064:	00bfe004 	movi	r2,-128
81105068:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
8110506c:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 1;
81105070:	00800044 	movi	r2,1
81105074:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105078:	d0a05817 	ldw	r2,-32416(gp)
8110507c:	e0fffe17 	ldw	r3,-8(fp)
81105080:	180b883a 	mov	r5,r3
81105084:	1009883a 	mov	r4,r2
81105088:	11397080 	call	81139708 <OSQPost>
8110508c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105090:	e0bffd03 	ldbu	r2,-12(fp)
81105094:	10000226 	beq	r2,zero,811050a0 <vFeebCh2HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 1 );
81105098:	01000044 	movi	r4,1
8110509c:	1118da40 	call	81118da4 <vFailRequestDMAFromIRQ>
	}

	vFeebCh2IrqFlagClrBufferEmpty();
811050a0:	11053900 	call	81105390 <vFeebCh2IrqFlagClrBufferEmpty>
}
811050a4:	0001883a 	nop
811050a8:	e037883a 	mov	sp,fp
811050ac:	dfc00117 	ldw	ra,4(sp)
811050b0:	df000017 	ldw	fp,0(sp)
811050b4:	dec00204 	addi	sp,sp,8
811050b8:	f800283a 	ret

811050bc <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
811050bc:	defffa04 	addi	sp,sp,-24
811050c0:	de00012e 	bgeu	sp,et,811050c8 <vFeebCh3HandleIrq+0xc>
811050c4:	003b68fa 	trap	3
811050c8:	dfc00515 	stw	ra,20(sp)
811050cc:	df000415 	stw	fp,16(sp)
811050d0:	df000404 	addi	fp,sp,16
811050d4:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811050d8:	e0bfff17 	ldw	r2,-4(fp)
811050dc:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811050e0:	00800404 	movi	r2,16
811050e4:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811050e8:	00bfe004 	movi	r2,-128
811050ec:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811050f0:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
811050f4:	00800084 	movi	r2,2
811050f8:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811050fc:	d0a05817 	ldw	r2,-32416(gp)
81105100:	e0fffe17 	ldw	r3,-8(fp)
81105104:	180b883a 	mov	r5,r3
81105108:	1009883a 	mov	r4,r2
8110510c:	11397080 	call	81139708 <OSQPost>
81105110:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105114:	e0bffd03 	ldbu	r2,-12(fp)
81105118:	10000226 	beq	r2,zero,81105124 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
8110511c:	01000084 	movi	r4,2
81105120:	1118da40 	call	81118da4 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
81105124:	11053d40 	call	811053d4 <vFeebCh3IrqFlagClrBufferEmpty>
}
81105128:	0001883a 	nop
8110512c:	e037883a 	mov	sp,fp
81105130:	dfc00117 	ldw	ra,4(sp)
81105134:	df000017 	ldw	fp,0(sp)
81105138:	dec00204 	addi	sp,sp,8
8110513c:	f800283a 	ret

81105140 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81105140:	defffa04 	addi	sp,sp,-24
81105144:	de00012e 	bgeu	sp,et,8110514c <vFeebCh4HandleIrq+0xc>
81105148:	003b68fa 	trap	3
8110514c:	dfc00515 	stw	ra,20(sp)
81105150:	df000415 	stw	fp,16(sp)
81105154:	df000404 	addi	fp,sp,16
81105158:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110515c:	e0bfff17 	ldw	r2,-4(fp)
81105160:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105164:	00800404 	movi	r2,16
81105168:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110516c:	00bfe004 	movi	r2,-128
81105170:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105174:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
81105178:	008000c4 	movi	r2,3
8110517c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105180:	d0a05817 	ldw	r2,-32416(gp)
81105184:	e0fffe17 	ldw	r3,-8(fp)
81105188:	180b883a 	mov	r5,r3
8110518c:	1009883a 	mov	r4,r2
81105190:	11397080 	call	81139708 <OSQPost>
81105194:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105198:	e0bffd03 	ldbu	r2,-12(fp)
8110519c:	10000226 	beq	r2,zero,811051a8 <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
811051a0:	010000c4 	movi	r4,3
811051a4:	1118da40 	call	81118da4 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
811051a8:	11054180 	call	81105418 <vFeebCh4IrqFlagClrBufferEmpty>
}
811051ac:	0001883a 	nop
811051b0:	e037883a 	mov	sp,fp
811051b4:	dfc00117 	ldw	ra,4(sp)
811051b8:	df000017 	ldw	fp,0(sp)
811051bc:	dec00204 	addi	sp,sp,8
811051c0:	f800283a 	ret

811051c4 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
811051c4:	defffa04 	addi	sp,sp,-24
811051c8:	de00012e 	bgeu	sp,et,811051d0 <vFeebCh5HandleIrq+0xc>
811051cc:	003b68fa 	trap	3
811051d0:	dfc00515 	stw	ra,20(sp)
811051d4:	df000415 	stw	fp,16(sp)
811051d8:	df000404 	addi	fp,sp,16
811051dc:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051e0:	e0bfff17 	ldw	r2,-4(fp)
811051e4:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811051e8:	00800404 	movi	r2,16
811051ec:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811051f0:	00bfe004 	movi	r2,-128
811051f4:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811051f8:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
811051fc:	00800104 	movi	r2,4
81105200:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105204:	d0a05817 	ldw	r2,-32416(gp)
81105208:	e0fffe17 	ldw	r3,-8(fp)
8110520c:	180b883a 	mov	r5,r3
81105210:	1009883a 	mov	r4,r2
81105214:	11397080 	call	81139708 <OSQPost>
81105218:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110521c:	e0bffd03 	ldbu	r2,-12(fp)
81105220:	10000226 	beq	r2,zero,8110522c <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
81105224:	01000104 	movi	r4,4
81105228:	1118da40 	call	81118da4 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
8110522c:	110545c0 	call	8110545c <vFeebCh5IrqFlagClrBufferEmpty>
}
81105230:	0001883a 	nop
81105234:	e037883a 	mov	sp,fp
81105238:	dfc00117 	ldw	ra,4(sp)
8110523c:	df000017 	ldw	fp,0(sp)
81105240:	dec00204 	addi	sp,sp,8
81105244:	f800283a 	ret

81105248 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81105248:	defffa04 	addi	sp,sp,-24
8110524c:	de00012e 	bgeu	sp,et,81105254 <vFeebCh6HandleIrq+0xc>
81105250:	003b68fa 	trap	3
81105254:	dfc00515 	stw	ra,20(sp)
81105258:	df000415 	stw	fp,16(sp)
8110525c:	df000404 	addi	fp,sp,16
81105260:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105264:	e0bfff17 	ldw	r2,-4(fp)
81105268:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110526c:	00800404 	movi	r2,16
81105270:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105274:	00bfe004 	movi	r2,-128
81105278:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
8110527c:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
81105280:	00800144 	movi	r2,5
81105284:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105288:	d0a05817 	ldw	r2,-32416(gp)
8110528c:	e0fffe17 	ldw	r3,-8(fp)
81105290:	180b883a 	mov	r5,r3
81105294:	1009883a 	mov	r4,r2
81105298:	11397080 	call	81139708 <OSQPost>
8110529c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811052a0:	e0bffd03 	ldbu	r2,-12(fp)
811052a4:	10000226 	beq	r2,zero,811052b0 <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
811052a8:	01000144 	movi	r4,5
811052ac:	1118da40 	call	81118da4 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
811052b0:	11054a00 	call	811054a0 <vFeebCh6IrqFlagClrBufferEmpty>
}
811052b4:	0001883a 	nop
811052b8:	e037883a 	mov	sp,fp
811052bc:	dfc00117 	ldw	ra,4(sp)
811052c0:	df000017 	ldw	fp,0(sp)
811052c4:	dec00204 	addi	sp,sp,8
811052c8:	f800283a 	ret

811052cc <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811052cc:	defffc04 	addi	sp,sp,-16
811052d0:	de00012e 	bgeu	sp,et,811052d8 <vFeebCh7HandleIrq+0xc>
811052d4:	003b68fa 	trap	3
811052d8:	dfc00315 	stw	ra,12(sp)
811052dc:	df000215 	stw	fp,8(sp)
811052e0:	df000204 	addi	fp,sp,8
811052e4:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811052e8:	e0bfff17 	ldw	r2,-4(fp)
811052ec:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
811052f0:	11054e40 	call	811054e4 <vFeebCh7IrqFlagClrBufferEmpty>
}
811052f4:	0001883a 	nop
811052f8:	e037883a 	mov	sp,fp
811052fc:	dfc00117 	ldw	ra,4(sp)
81105300:	df000017 	ldw	fp,0(sp)
81105304:	dec00204 	addi	sp,sp,8
81105308:	f800283a 	ret

8110530c <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
8110530c:	defffc04 	addi	sp,sp,-16
81105310:	de00012e 	bgeu	sp,et,81105318 <vFeebCh8HandleIrq+0xc>
81105314:	003b68fa 	trap	3
81105318:	dfc00315 	stw	ra,12(sp)
8110531c:	df000215 	stw	fp,8(sp)
81105320:	df000204 	addi	fp,sp,8
81105324:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105328:	e0bfff17 	ldw	r2,-4(fp)
8110532c:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
81105330:	11055280 	call	81105528 <vFeebCh8IrqFlagClrBufferEmpty>
}
81105334:	0001883a 	nop
81105338:	e037883a 	mov	sp,fp
8110533c:	dfc00117 	ldw	ra,4(sp)
81105340:	df000017 	ldw	fp,0(sp)
81105344:	dec00204 	addi	sp,sp,8
81105348:	f800283a 	ret

8110534c <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
8110534c:	defffe04 	addi	sp,sp,-8
81105350:	de00012e 	bgeu	sp,et,81105358 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105354:	003b68fa 	trap	3
81105358:	dfc00115 	stw	ra,4(sp)
8110535c:	df000015 	stw	fp,0(sp)
81105360:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105364:	01804004 	movi	r6,256
81105368:	014004c4 	movi	r5,19
8110536c:	01204834 	movhi	r4,33056
81105370:	210b0004 	addi	r4,r4,11264
81105374:	11060a80 	call	811060a8 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105378:	0001883a 	nop
8110537c:	e037883a 	mov	sp,fp
81105380:	dfc00117 	ldw	ra,4(sp)
81105384:	df000017 	ldw	fp,0(sp)
81105388:	dec00204 	addi	sp,sp,8
8110538c:	f800283a 	ret

81105390 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
81105390:	defffe04 	addi	sp,sp,-8
81105394:	de00012e 	bgeu	sp,et,8110539c <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81105398:	003b68fa 	trap	3
8110539c:	dfc00115 	stw	ra,4(sp)
811053a0:	df000015 	stw	fp,0(sp)
811053a4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811053a8:	01804004 	movi	r6,256
811053ac:	014004c4 	movi	r5,19
811053b0:	01204834 	movhi	r4,33056
811053b4:	210a0004 	addi	r4,r4,10240
811053b8:	11060a80 	call	811060a8 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811053bc:	0001883a 	nop
811053c0:	e037883a 	mov	sp,fp
811053c4:	dfc00117 	ldw	ra,4(sp)
811053c8:	df000017 	ldw	fp,0(sp)
811053cc:	dec00204 	addi	sp,sp,8
811053d0:	f800283a 	ret

811053d4 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
811053d4:	defffe04 	addi	sp,sp,-8
811053d8:	de00012e 	bgeu	sp,et,811053e0 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
811053dc:	003b68fa 	trap	3
811053e0:	dfc00115 	stw	ra,4(sp)
811053e4:	df000015 	stw	fp,0(sp)
811053e8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811053ec:	01804004 	movi	r6,256
811053f0:	014004c4 	movi	r5,19
811053f4:	01204834 	movhi	r4,33056
811053f8:	21090004 	addi	r4,r4,9216
811053fc:	11060a80 	call	811060a8 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105400:	0001883a 	nop
81105404:	e037883a 	mov	sp,fp
81105408:	dfc00117 	ldw	ra,4(sp)
8110540c:	df000017 	ldw	fp,0(sp)
81105410:	dec00204 	addi	sp,sp,8
81105414:	f800283a 	ret

81105418 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81105418:	defffe04 	addi	sp,sp,-8
8110541c:	de00012e 	bgeu	sp,et,81105424 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
81105420:	003b68fa 	trap	3
81105424:	dfc00115 	stw	ra,4(sp)
81105428:	df000015 	stw	fp,0(sp)
8110542c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105430:	01804004 	movi	r6,256
81105434:	014004c4 	movi	r5,19
81105438:	01204834 	movhi	r4,33056
8110543c:	21080004 	addi	r4,r4,8192
81105440:	11060a80 	call	811060a8 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105444:	0001883a 	nop
81105448:	e037883a 	mov	sp,fp
8110544c:	dfc00117 	ldw	ra,4(sp)
81105450:	df000017 	ldw	fp,0(sp)
81105454:	dec00204 	addi	sp,sp,8
81105458:	f800283a 	ret

8110545c <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
8110545c:	defffe04 	addi	sp,sp,-8
81105460:	de00012e 	bgeu	sp,et,81105468 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105464:	003b68fa 	trap	3
81105468:	dfc00115 	stw	ra,4(sp)
8110546c:	df000015 	stw	fp,0(sp)
81105470:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105474:	01804004 	movi	r6,256
81105478:	014004c4 	movi	r5,19
8110547c:	01204834 	movhi	r4,33056
81105480:	21070004 	addi	r4,r4,7168
81105484:	11060a80 	call	811060a8 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105488:	0001883a 	nop
8110548c:	e037883a 	mov	sp,fp
81105490:	dfc00117 	ldw	ra,4(sp)
81105494:	df000017 	ldw	fp,0(sp)
81105498:	dec00204 	addi	sp,sp,8
8110549c:	f800283a 	ret

811054a0 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
811054a0:	defffe04 	addi	sp,sp,-8
811054a4:	de00012e 	bgeu	sp,et,811054ac <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811054a8:	003b68fa 	trap	3
811054ac:	dfc00115 	stw	ra,4(sp)
811054b0:	df000015 	stw	fp,0(sp)
811054b4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811054b8:	01804004 	movi	r6,256
811054bc:	014004c4 	movi	r5,19
811054c0:	01204834 	movhi	r4,33056
811054c4:	21060004 	addi	r4,r4,6144
811054c8:	11060a80 	call	811060a8 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054cc:	0001883a 	nop
811054d0:	e037883a 	mov	sp,fp
811054d4:	dfc00117 	ldw	ra,4(sp)
811054d8:	df000017 	ldw	fp,0(sp)
811054dc:	dec00204 	addi	sp,sp,8
811054e0:	f800283a 	ret

811054e4 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
811054e4:	defffe04 	addi	sp,sp,-8
811054e8:	de00012e 	bgeu	sp,et,811054f0 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
811054ec:	003b68fa 	trap	3
811054f0:	dfc00115 	stw	ra,4(sp)
811054f4:	df000015 	stw	fp,0(sp)
811054f8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811054fc:	01804004 	movi	r6,256
81105500:	014004c4 	movi	r5,19
81105504:	01204834 	movhi	r4,33056
81105508:	21050004 	addi	r4,r4,5120
8110550c:	11060a80 	call	811060a8 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105510:	0001883a 	nop
81105514:	e037883a 	mov	sp,fp
81105518:	dfc00117 	ldw	ra,4(sp)
8110551c:	df000017 	ldw	fp,0(sp)
81105520:	dec00204 	addi	sp,sp,8
81105524:	f800283a 	ret

81105528 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81105528:	defffe04 	addi	sp,sp,-8
8110552c:	de00012e 	bgeu	sp,et,81105534 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
81105530:	003b68fa 	trap	3
81105534:	dfc00115 	stw	ra,4(sp)
81105538:	df000015 	stw	fp,0(sp)
8110553c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105540:	01804004 	movi	r6,256
81105544:	014004c4 	movi	r5,19
81105548:	01204834 	movhi	r4,33056
8110554c:	21040004 	addi	r4,r4,4096
81105550:	11060a80 	call	811060a8 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105554:	0001883a 	nop
81105558:	e037883a 	mov	sp,fp
8110555c:	dfc00117 	ldw	ra,4(sp)
81105560:	df000017 	ldw	fp,0(sp)
81105564:	dec00204 	addi	sp,sp,8
81105568:	f800283a 	ret

8110556c <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
8110556c:	defffd04 	addi	sp,sp,-12
81105570:	de00012e 	bgeu	sp,et,81105578 <bFeebCh1IrqFlagBufferEmpty+0xc>
81105574:	003b68fa 	trap	3
81105578:	dfc00215 	stw	ra,8(sp)
8110557c:	df000115 	stw	fp,4(sp)
81105580:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105584:	01400484 	movi	r5,18
81105588:	01204834 	movhi	r4,33056
8110558c:	210b0004 	addi	r4,r4,11264
81105590:	11060fc0 	call	811060fc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105594:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105598:	10000326 	beq	r2,zero,811055a8 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110559c:	00800044 	movi	r2,1
811055a0:	e0bfff15 	stw	r2,-4(fp)
811055a4:	00000106 	br	811055ac <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811055a8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811055ac:	e0bfff17 	ldw	r2,-4(fp)
}
811055b0:	e037883a 	mov	sp,fp
811055b4:	dfc00117 	ldw	ra,4(sp)
811055b8:	df000017 	ldw	fp,0(sp)
811055bc:	dec00204 	addi	sp,sp,8
811055c0:	f800283a 	ret

811055c4 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
811055c4:	defffd04 	addi	sp,sp,-12
811055c8:	de00012e 	bgeu	sp,et,811055d0 <bFeebCh2IrqFlagBufferEmpty+0xc>
811055cc:	003b68fa 	trap	3
811055d0:	dfc00215 	stw	ra,8(sp)
811055d4:	df000115 	stw	fp,4(sp)
811055d8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811055dc:	01400484 	movi	r5,18
811055e0:	01204834 	movhi	r4,33056
811055e4:	210a0004 	addi	r4,r4,10240
811055e8:	11060fc0 	call	811060fc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055ec:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811055f0:	10000326 	beq	r2,zero,81105600 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811055f4:	00800044 	movi	r2,1
811055f8:	e0bfff15 	stw	r2,-4(fp)
811055fc:	00000106 	br	81105604 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105600:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105604:	e0bfff17 	ldw	r2,-4(fp)
}
81105608:	e037883a 	mov	sp,fp
8110560c:	dfc00117 	ldw	ra,4(sp)
81105610:	df000017 	ldw	fp,0(sp)
81105614:	dec00204 	addi	sp,sp,8
81105618:	f800283a 	ret

8110561c <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
8110561c:	defffd04 	addi	sp,sp,-12
81105620:	de00012e 	bgeu	sp,et,81105628 <bFeebCh3IrqFlagBufferEmpty+0xc>
81105624:	003b68fa 	trap	3
81105628:	dfc00215 	stw	ra,8(sp)
8110562c:	df000115 	stw	fp,4(sp)
81105630:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105634:	01400484 	movi	r5,18
81105638:	01204834 	movhi	r4,33056
8110563c:	21090004 	addi	r4,r4,9216
81105640:	11060fc0 	call	811060fc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105644:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105648:	10000326 	beq	r2,zero,81105658 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110564c:	00800044 	movi	r2,1
81105650:	e0bfff15 	stw	r2,-4(fp)
81105654:	00000106 	br	8110565c <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105658:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110565c:	e0bfff17 	ldw	r2,-4(fp)
}
81105660:	e037883a 	mov	sp,fp
81105664:	dfc00117 	ldw	ra,4(sp)
81105668:	df000017 	ldw	fp,0(sp)
8110566c:	dec00204 	addi	sp,sp,8
81105670:	f800283a 	ret

81105674 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105674:	defffd04 	addi	sp,sp,-12
81105678:	de00012e 	bgeu	sp,et,81105680 <bFeebCh4IrqFlagBufferEmpty+0xc>
8110567c:	003b68fa 	trap	3
81105680:	dfc00215 	stw	ra,8(sp)
81105684:	df000115 	stw	fp,4(sp)
81105688:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110568c:	01400484 	movi	r5,18
81105690:	01204834 	movhi	r4,33056
81105694:	21080004 	addi	r4,r4,8192
81105698:	11060fc0 	call	811060fc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110569c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811056a0:	10000326 	beq	r2,zero,811056b0 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811056a4:	00800044 	movi	r2,1
811056a8:	e0bfff15 	stw	r2,-4(fp)
811056ac:	00000106 	br	811056b4 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811056b0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811056b4:	e0bfff17 	ldw	r2,-4(fp)
}
811056b8:	e037883a 	mov	sp,fp
811056bc:	dfc00117 	ldw	ra,4(sp)
811056c0:	df000017 	ldw	fp,0(sp)
811056c4:	dec00204 	addi	sp,sp,8
811056c8:	f800283a 	ret

811056cc <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
811056cc:	defffd04 	addi	sp,sp,-12
811056d0:	de00012e 	bgeu	sp,et,811056d8 <bFeebCh5IrqFlagBufferEmpty+0xc>
811056d4:	003b68fa 	trap	3
811056d8:	dfc00215 	stw	ra,8(sp)
811056dc:	df000115 	stw	fp,4(sp)
811056e0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811056e4:	01400484 	movi	r5,18
811056e8:	01204834 	movhi	r4,33056
811056ec:	21070004 	addi	r4,r4,7168
811056f0:	11060fc0 	call	811060fc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811056f4:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811056f8:	10000326 	beq	r2,zero,81105708 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811056fc:	00800044 	movi	r2,1
81105700:	e0bfff15 	stw	r2,-4(fp)
81105704:	00000106 	br	8110570c <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105708:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110570c:	e0bfff17 	ldw	r2,-4(fp)
}
81105710:	e037883a 	mov	sp,fp
81105714:	dfc00117 	ldw	ra,4(sp)
81105718:	df000017 	ldw	fp,0(sp)
8110571c:	dec00204 	addi	sp,sp,8
81105720:	f800283a 	ret

81105724 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105724:	defffd04 	addi	sp,sp,-12
81105728:	de00012e 	bgeu	sp,et,81105730 <bFeebCh6IrqFlagBufferEmpty+0xc>
8110572c:	003b68fa 	trap	3
81105730:	dfc00215 	stw	ra,8(sp)
81105734:	df000115 	stw	fp,4(sp)
81105738:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110573c:	01400484 	movi	r5,18
81105740:	01204834 	movhi	r4,33056
81105744:	21060004 	addi	r4,r4,6144
81105748:	11060fc0 	call	811060fc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110574c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105750:	10000326 	beq	r2,zero,81105760 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105754:	00800044 	movi	r2,1
81105758:	e0bfff15 	stw	r2,-4(fp)
8110575c:	00000106 	br	81105764 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105760:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105764:	e0bfff17 	ldw	r2,-4(fp)
}
81105768:	e037883a 	mov	sp,fp
8110576c:	dfc00117 	ldw	ra,4(sp)
81105770:	df000017 	ldw	fp,0(sp)
81105774:	dec00204 	addi	sp,sp,8
81105778:	f800283a 	ret

8110577c <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
8110577c:	defffd04 	addi	sp,sp,-12
81105780:	de00012e 	bgeu	sp,et,81105788 <bFeebCh7IrqFlagBufferEmpty+0xc>
81105784:	003b68fa 	trap	3
81105788:	dfc00215 	stw	ra,8(sp)
8110578c:	df000115 	stw	fp,4(sp)
81105790:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105794:	01400484 	movi	r5,18
81105798:	01204834 	movhi	r4,33056
8110579c:	21050004 	addi	r4,r4,5120
811057a0:	11060fc0 	call	811060fc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057a4:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057a8:	10000326 	beq	r2,zero,811057b8 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057ac:	00800044 	movi	r2,1
811057b0:	e0bfff15 	stw	r2,-4(fp)
811057b4:	00000106 	br	811057bc <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057b8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057bc:	e0bfff17 	ldw	r2,-4(fp)
}
811057c0:	e037883a 	mov	sp,fp
811057c4:	dfc00117 	ldw	ra,4(sp)
811057c8:	df000017 	ldw	fp,0(sp)
811057cc:	dec00204 	addi	sp,sp,8
811057d0:	f800283a 	ret

811057d4 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
811057d4:	defffd04 	addi	sp,sp,-12
811057d8:	de00012e 	bgeu	sp,et,811057e0 <bFeebCh8IrqFlagBufferEmpty+0xc>
811057dc:	003b68fa 	trap	3
811057e0:	dfc00215 	stw	ra,8(sp)
811057e4:	df000115 	stw	fp,4(sp)
811057e8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811057ec:	01400484 	movi	r5,18
811057f0:	01204834 	movhi	r4,33056
811057f4:	21040004 	addi	r4,r4,4096
811057f8:	11060fc0 	call	811060fc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057fc:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105800:	10000326 	beq	r2,zero,81105810 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105804:	00800044 	movi	r2,1
81105808:	e0bfff15 	stw	r2,-4(fp)
8110580c:	00000106 	br	81105814 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105810:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105814:	e0bfff17 	ldw	r2,-4(fp)
}
81105818:	e037883a 	mov	sp,fp
8110581c:	dfc00117 	ldw	ra,4(sp)
81105820:	df000017 	ldw	fp,0(sp)
81105824:	dec00204 	addi	sp,sp,8
81105828:	f800283a 	ret

8110582c <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
8110582c:	defffc04 	addi	sp,sp,-16
81105830:	de00012e 	bgeu	sp,et,81105838 <vFeebInitIrq+0xc>
81105834:	003b68fa 	trap	3
81105838:	dfc00315 	stw	ra,12(sp)
8110583c:	df000215 	stw	fp,8(sp)
81105840:	df000204 	addi	fp,sp,8
81105844:	2005883a 	mov	r2,r4
81105848:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
8110584c:	e0bfff03 	ldbu	r2,-4(fp)
81105850:	10c00228 	cmpgeui	r3,r2,8
81105854:	18004e1e 	bne	r3,zero,81105990 <vFeebInitIrq+0x164>
81105858:	100690ba 	slli	r3,r2,2
8110585c:	00a04434 	movhi	r2,33040
81105860:	10961c04 	addi	r2,r2,22640
81105864:	1885883a 	add	r2,r3,r2
81105868:	10800017 	ldw	r2,0(r2)
8110586c:	1000683a 	jmp	r2
81105870:	81105890 	cmplti	r4,r16,16738
81105874:	811058b0 	cmpltui	r4,r16,16738
81105878:	811058d0 	cmplti	r4,r16,16739
8110587c:	811058f0 	cmpltui	r4,r16,16739
81105880:	81105910 	cmplti	r4,r16,16740
81105884:	81105930 	cmpltui	r4,r16,16740
81105888:	81105950 	cmplti	r4,r16,16741
8110588c:	81105970 	cmpltui	r4,r16,16741
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81105890:	d0a03e04 	addi	r2,gp,-32520
81105894:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81105898:	01a04434 	movhi	r6,33040
8110589c:	3193f704 	addi	r6,r6,20444
811058a0:	e17ffe17 	ldw	r5,-8(fp)
811058a4:	01000584 	movi	r4,22
811058a8:	1131d240 	call	81131d24 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
811058ac:	00003806 	br	81105990 <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811058b0:	d0a03f04 	addi	r2,gp,-32516
811058b4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
811058b8:	01a04434 	movhi	r6,33040
811058bc:	31940e04 	addi	r6,r6,20536
811058c0:	e17ffe17 	ldw	r5,-8(fp)
811058c4:	01000504 	movi	r4,20
811058c8:	1131d240 	call	81131d24 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
811058cc:	00003006 	br	81105990 <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811058d0:	d0a04004 	addi	r2,gp,-32512
811058d4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
811058d8:	01a04434 	movhi	r6,33040
811058dc:	31942f04 	addi	r6,r6,20668
811058e0:	e17ffe17 	ldw	r5,-8(fp)
811058e4:	01000484 	movi	r4,18
811058e8:	1131d240 	call	81131d24 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
811058ec:	00002806 	br	81105990 <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811058f0:	d0a04104 	addi	r2,gp,-32508
811058f4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
811058f8:	01a04434 	movhi	r6,33040
811058fc:	31945004 	addi	r6,r6,20800
81105900:	e17ffe17 	ldw	r5,-8(fp)
81105904:	01000404 	movi	r4,16
81105908:	1131d240 	call	81131d24 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
8110590c:	00002006 	br	81105990 <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81105910:	d0a04204 	addi	r2,gp,-32504
81105914:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81105918:	01a04434 	movhi	r6,33040
8110591c:	31947104 	addi	r6,r6,20932
81105920:	e17ffe17 	ldw	r5,-8(fp)
81105924:	01000204 	movi	r4,8
81105928:	1131d240 	call	81131d24 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
8110592c:	00001806 	br	81105990 <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81105930:	d0a04304 	addi	r2,gp,-32500
81105934:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81105938:	01a04434 	movhi	r6,33040
8110593c:	31949204 	addi	r6,r6,21064
81105940:	e17ffe17 	ldw	r5,-8(fp)
81105944:	01000184 	movi	r4,6
81105948:	1131d240 	call	81131d24 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
8110594c:	00001006 	br	81105990 <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81105950:	d0a04404 	addi	r2,gp,-32496
81105954:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81105958:	01a04434 	movhi	r6,33040
8110595c:	3194b304 	addi	r6,r6,21196
81105960:	e17ffe17 	ldw	r5,-8(fp)
81105964:	01000144 	movi	r4,5
81105968:	1131d240 	call	81131d24 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
8110596c:	00000806 	br	81105990 <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81105970:	d0a04504 	addi	r2,gp,-32492
81105974:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81105978:	01a04434 	movhi	r6,33040
8110597c:	3194c304 	addi	r6,r6,21260
81105980:	e17ffe17 	ldw	r5,-8(fp)
81105984:	01000084 	movi	r4,2
81105988:	1131d240 	call	81131d24 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
8110598c:	0001883a 	nop
	}
}
81105990:	0001883a 	nop
81105994:	e037883a 	mov	sp,fp
81105998:	dfc00117 	ldw	ra,4(sp)
8110599c:	df000017 	ldw	fp,0(sp)
811059a0:	dec00204 	addi	sp,sp,8
811059a4:	f800283a 	ret

811059a8 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
811059a8:	defffb04 	addi	sp,sp,-20
811059ac:	de00012e 	bgeu	sp,et,811059b4 <bFeebSetIrqControl+0xc>
811059b0:	003b68fa 	trap	3
811059b4:	dfc00415 	stw	ra,16(sp)
811059b8:	df000315 	stw	fp,12(sp)
811059bc:	df000304 	addi	fp,sp,12
811059c0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811059c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811059c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811059cc:	e0bfff17 	ldw	r2,-4(fp)
811059d0:	10002426 	beq	r2,zero,81105a64 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811059d4:	e0bfff17 	ldw	r2,-4(fp)
811059d8:	10800017 	ldw	r2,0(r2)
811059dc:	01400444 	movi	r5,17
811059e0:	1009883a 	mov	r4,r2
811059e4:	11060fc0 	call	811060fc <uliFeebReadReg>
811059e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
811059ec:	e0bfff17 	ldw	r2,-4(fp)
811059f0:	10800217 	ldw	r2,8(r2)
811059f4:	10000426 	beq	r2,zero,81105a08 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
811059f8:	e0bffe17 	ldw	r2,-8(fp)
811059fc:	10808014 	ori	r2,r2,512
81105a00:	e0bffe15 	stw	r2,-8(fp)
81105a04:	00000406 	br	81105a18 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
81105a08:	e0fffe17 	ldw	r3,-8(fp)
81105a0c:	00bf7fc4 	movi	r2,-513
81105a10:	1884703a 	and	r2,r3,r2
81105a14:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81105a18:	e0bfff17 	ldw	r2,-4(fp)
81105a1c:	10800317 	ldw	r2,12(r2)
81105a20:	10000426 	beq	r2,zero,81105a34 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81105a24:	e0bffe17 	ldw	r2,-8(fp)
81105a28:	10804014 	ori	r2,r2,256
81105a2c:	e0bffe15 	stw	r2,-8(fp)
81105a30:	00000406 	br	81105a44 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81105a34:	e0fffe17 	ldw	r3,-8(fp)
81105a38:	00bfbfc4 	movi	r2,-257
81105a3c:	1884703a 	and	r2,r3,r2
81105a40:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81105a44:	e0bfff17 	ldw	r2,-4(fp)
81105a48:	10800017 	ldw	r2,0(r2)
81105a4c:	e1bffe17 	ldw	r6,-8(fp)
81105a50:	01400444 	movi	r5,17
81105a54:	1009883a 	mov	r4,r2
81105a58:	11060a80 	call	811060a8 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81105a5c:	00800044 	movi	r2,1
81105a60:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105a64:	e0bffd17 	ldw	r2,-12(fp)
}
81105a68:	e037883a 	mov	sp,fp
81105a6c:	dfc00117 	ldw	ra,4(sp)
81105a70:	df000017 	ldw	fp,0(sp)
81105a74:	dec00204 	addi	sp,sp,8
81105a78:	f800283a 	ret

81105a7c <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81105a7c:	defffb04 	addi	sp,sp,-20
81105a80:	de00012e 	bgeu	sp,et,81105a88 <bFeebGetIrqControl+0xc>
81105a84:	003b68fa 	trap	3
81105a88:	dfc00415 	stw	ra,16(sp)
81105a8c:	df000315 	stw	fp,12(sp)
81105a90:	df000304 	addi	fp,sp,12
81105a94:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105a98:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105a9c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105aa0:	e0bfff17 	ldw	r2,-4(fp)
81105aa4:	10001a26 	beq	r2,zero,81105b10 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105aa8:	e0bfff17 	ldw	r2,-4(fp)
81105aac:	10800017 	ldw	r2,0(r2)
81105ab0:	01400444 	movi	r5,17
81105ab4:	1009883a 	mov	r4,r2
81105ab8:	11060fc0 	call	811060fc <uliFeebReadReg>
81105abc:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
81105ac0:	e0bffe17 	ldw	r2,-8(fp)
81105ac4:	1080800c 	andi	r2,r2,512
81105ac8:	10000426 	beq	r2,zero,81105adc <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81105acc:	e0bfff17 	ldw	r2,-4(fp)
81105ad0:	00c00044 	movi	r3,1
81105ad4:	10c00215 	stw	r3,8(r2)
81105ad8:	00000206 	br	81105ae4 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81105adc:	e0bfff17 	ldw	r2,-4(fp)
81105ae0:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81105ae4:	e0bffe17 	ldw	r2,-8(fp)
81105ae8:	1080400c 	andi	r2,r2,256
81105aec:	10000426 	beq	r2,zero,81105b00 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81105af0:	e0bfff17 	ldw	r2,-4(fp)
81105af4:	00c00044 	movi	r3,1
81105af8:	10c00315 	stw	r3,12(r2)
81105afc:	00000206 	br	81105b08 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81105b00:	e0bfff17 	ldw	r2,-4(fp)
81105b04:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81105b08:	00800044 	movi	r2,1
81105b0c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105b10:	e0bffd17 	ldw	r2,-12(fp)
}
81105b14:	e037883a 	mov	sp,fp
81105b18:	dfc00117 	ldw	ra,4(sp)
81105b1c:	df000017 	ldw	fp,0(sp)
81105b20:	dec00204 	addi	sp,sp,8
81105b24:	f800283a 	ret

81105b28 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81105b28:	defffb04 	addi	sp,sp,-20
81105b2c:	de00012e 	bgeu	sp,et,81105b34 <bFeebGetIrqFlags+0xc>
81105b30:	003b68fa 	trap	3
81105b34:	dfc00415 	stw	ra,16(sp)
81105b38:	df000315 	stw	fp,12(sp)
81105b3c:	df000304 	addi	fp,sp,12
81105b40:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105b44:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105b48:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105b4c:	e0bfff17 	ldw	r2,-4(fp)
81105b50:	10001126 	beq	r2,zero,81105b98 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105b54:	e0bfff17 	ldw	r2,-4(fp)
81105b58:	10800017 	ldw	r2,0(r2)
81105b5c:	01400484 	movi	r5,18
81105b60:	1009883a 	mov	r4,r2
81105b64:	11060fc0 	call	811060fc <uliFeebReadReg>
81105b68:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105b6c:	e0bffe17 	ldw	r2,-8(fp)
81105b70:	1080400c 	andi	r2,r2,256
81105b74:	10000426 	beq	r2,zero,81105b88 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81105b78:	e0bfff17 	ldw	r2,-4(fp)
81105b7c:	00c00044 	movi	r3,1
81105b80:	10c00415 	stw	r3,16(r2)
81105b84:	00000206 	br	81105b90 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81105b88:	e0bfff17 	ldw	r2,-4(fp)
81105b8c:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81105b90:	00800044 	movi	r2,1
81105b94:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105b98:	e0bffd17 	ldw	r2,-12(fp)
}
81105b9c:	e037883a 	mov	sp,fp
81105ba0:	dfc00117 	ldw	ra,4(sp)
81105ba4:	df000017 	ldw	fp,0(sp)
81105ba8:	dec00204 	addi	sp,sp,8
81105bac:	f800283a 	ret

81105bb0 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
81105bb0:	defffb04 	addi	sp,sp,-20
81105bb4:	de00012e 	bgeu	sp,et,81105bbc <bFeebGetBuffersStatus+0xc>
81105bb8:	003b68fa 	trap	3
81105bbc:	dfc00415 	stw	ra,16(sp)
81105bc0:	df000315 	stw	fp,12(sp)
81105bc4:	df000304 	addi	fp,sp,12
81105bc8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105bcc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105bd0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105bd4:	e0bfff17 	ldw	r2,-4(fp)
81105bd8:	10001a26 	beq	r2,zero,81105c44 <bFeebGetBuffersStatus+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105bdc:	e0bfff17 	ldw	r2,-4(fp)
81105be0:	10800017 	ldw	r2,0(r2)
81105be4:	014000c4 	movi	r5,3
81105be8:	1009883a 	mov	r4,r2
81105bec:	11060fc0 	call	811060fc <uliFeebReadReg>
81105bf0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81105bf4:	e0bffe17 	ldw	r2,-8(fp)
81105bf8:	1080008c 	andi	r2,r2,2
81105bfc:	10000426 	beq	r2,zero,81105c10 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81105c00:	e0bfff17 	ldw	r2,-4(fp)
81105c04:	00c00044 	movi	r3,1
81105c08:	10c00515 	stw	r3,20(r2)
81105c0c:	00000206 	br	81105c18 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81105c10:	e0bfff17 	ldw	r2,-4(fp)
81105c14:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81105c18:	e0bffe17 	ldw	r2,-8(fp)
81105c1c:	1080004c 	andi	r2,r2,1
81105c20:	10000426 	beq	r2,zero,81105c34 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81105c24:	e0bfff17 	ldw	r2,-4(fp)
81105c28:	00c00044 	movi	r3,1
81105c2c:	10c00615 	stw	r3,24(r2)
81105c30:	00000206 	br	81105c3c <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81105c34:	e0bfff17 	ldw	r2,-4(fp)
81105c38:	10000615 	stw	zero,24(r2)
		}

		bStatus = TRUE;
81105c3c:	00800044 	movi	r2,1
81105c40:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105c44:	e0bffd17 	ldw	r2,-12(fp)
}
81105c48:	e037883a 	mov	sp,fp
81105c4c:	dfc00117 	ldw	ra,4(sp)
81105c50:	df000017 	ldw	fp,0(sp)
81105c54:	dec00204 	addi	sp,sp,8
81105c58:	f800283a 	ret

81105c5c <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81105c5c:	defffb04 	addi	sp,sp,-20
81105c60:	de00012e 	bgeu	sp,et,81105c68 <bFeebSetWindowing+0xc>
81105c64:	003b68fa 	trap	3
81105c68:	dfc00415 	stw	ra,16(sp)
81105c6c:	df000315 	stw	fp,12(sp)
81105c70:	df000304 	addi	fp,sp,12
81105c74:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105c78:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105c7c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105c80:	e0bfff17 	ldw	r2,-4(fp)
81105c84:	10001926 	beq	r2,zero,81105cec <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105c88:	e0bfff17 	ldw	r2,-4(fp)
81105c8c:	10800017 	ldw	r2,0(r2)
81105c90:	01400084 	movi	r5,2
81105c94:	1009883a 	mov	r4,r2
81105c98:	11060fc0 	call	811060fc <uliFeebReadReg>
81105c9c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81105ca0:	e0bfff17 	ldw	r2,-4(fp)
81105ca4:	10800117 	ldw	r2,4(r2)
81105ca8:	10000426 	beq	r2,zero,81105cbc <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81105cac:	e0bffe17 	ldw	r2,-8(fp)
81105cb0:	10800214 	ori	r2,r2,8
81105cb4:	e0bffe15 	stw	r2,-8(fp)
81105cb8:	00000406 	br	81105ccc <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81105cbc:	e0fffe17 	ldw	r3,-8(fp)
81105cc0:	00bffdc4 	movi	r2,-9
81105cc4:	1884703a 	and	r2,r3,r2
81105cc8:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105ccc:	e0bfff17 	ldw	r2,-4(fp)
81105cd0:	10800017 	ldw	r2,0(r2)
81105cd4:	e1bffe17 	ldw	r6,-8(fp)
81105cd8:	01400084 	movi	r5,2
81105cdc:	1009883a 	mov	r4,r2
81105ce0:	11060a80 	call	811060a8 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105ce4:	00800044 	movi	r2,1
81105ce8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105cec:	e0bffd17 	ldw	r2,-12(fp)
}
81105cf0:	e037883a 	mov	sp,fp
81105cf4:	dfc00117 	ldw	ra,4(sp)
81105cf8:	df000017 	ldw	fp,0(sp)
81105cfc:	dec00204 	addi	sp,sp,8
81105d00:	f800283a 	ret

81105d04 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81105d04:	defffb04 	addi	sp,sp,-20
81105d08:	de00012e 	bgeu	sp,et,81105d10 <bFeebGetWindowing+0xc>
81105d0c:	003b68fa 	trap	3
81105d10:	dfc00415 	stw	ra,16(sp)
81105d14:	df000315 	stw	fp,12(sp)
81105d18:	df000304 	addi	fp,sp,12
81105d1c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105d20:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105d24:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105d28:	e0bfff17 	ldw	r2,-4(fp)
81105d2c:	10001126 	beq	r2,zero,81105d74 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105d30:	e0bfff17 	ldw	r2,-4(fp)
81105d34:	10800017 	ldw	r2,0(r2)
81105d38:	01400084 	movi	r5,2
81105d3c:	1009883a 	mov	r4,r2
81105d40:	11060fc0 	call	811060fc <uliFeebReadReg>
81105d44:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81105d48:	e0bffe17 	ldw	r2,-8(fp)
81105d4c:	1080020c 	andi	r2,r2,8
81105d50:	10000426 	beq	r2,zero,81105d64 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81105d54:	e0bfff17 	ldw	r2,-4(fp)
81105d58:	00c00044 	movi	r3,1
81105d5c:	10c00115 	stw	r3,4(r2)
81105d60:	00000206 	br	81105d6c <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81105d64:	e0bfff17 	ldw	r2,-4(fp)
81105d68:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81105d6c:	00800044 	movi	r2,1
81105d70:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105d74:	e0bffd17 	ldw	r2,-12(fp)
}
81105d78:	e037883a 	mov	sp,fp
81105d7c:	dfc00117 	ldw	ra,4(sp)
81105d80:	df000017 	ldw	fp,0(sp)
81105d84:	dec00204 	addi	sp,sp,8
81105d88:	f800283a 	ret

81105d8c <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81105d8c:	defffb04 	addi	sp,sp,-20
81105d90:	de00012e 	bgeu	sp,et,81105d98 <bFeebStartCh+0xc>
81105d94:	003b68fa 	trap	3
81105d98:	dfc00415 	stw	ra,16(sp)
81105d9c:	df000315 	stw	fp,12(sp)
81105da0:	df000304 	addi	fp,sp,12
81105da4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105da8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105dac:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105db0:	e0bfff17 	ldw	r2,-4(fp)
81105db4:	10001126 	beq	r2,zero,81105dfc <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105db8:	e0bfff17 	ldw	r2,-4(fp)
81105dbc:	10800017 	ldw	r2,0(r2)
81105dc0:	01400084 	movi	r5,2
81105dc4:	1009883a 	mov	r4,r2
81105dc8:	11060fc0 	call	811060fc <uliFeebReadReg>
81105dcc:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
81105dd0:	e0bffe17 	ldw	r2,-8(fp)
81105dd4:	10800114 	ori	r2,r2,4
81105dd8:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105ddc:	e0bfff17 	ldw	r2,-4(fp)
81105de0:	10800017 	ldw	r2,0(r2)
81105de4:	e1bffe17 	ldw	r6,-8(fp)
81105de8:	01400084 	movi	r5,2
81105dec:	1009883a 	mov	r4,r2
81105df0:	11060a80 	call	811060a8 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105df4:	00800044 	movi	r2,1
81105df8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105dfc:	e0bffd17 	ldw	r2,-12(fp)
}
81105e00:	e037883a 	mov	sp,fp
81105e04:	dfc00117 	ldw	ra,4(sp)
81105e08:	df000017 	ldw	fp,0(sp)
81105e0c:	dec00204 	addi	sp,sp,8
81105e10:	f800283a 	ret

81105e14 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81105e14:	defffb04 	addi	sp,sp,-20
81105e18:	de00012e 	bgeu	sp,et,81105e20 <bFeebStopCh+0xc>
81105e1c:	003b68fa 	trap	3
81105e20:	dfc00415 	stw	ra,16(sp)
81105e24:	df000315 	stw	fp,12(sp)
81105e28:	df000304 	addi	fp,sp,12
81105e2c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105e30:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105e34:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105e38:	e0bfff17 	ldw	r2,-4(fp)
81105e3c:	10001126 	beq	r2,zero,81105e84 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105e40:	e0bfff17 	ldw	r2,-4(fp)
81105e44:	10800017 	ldw	r2,0(r2)
81105e48:	01400084 	movi	r5,2
81105e4c:	1009883a 	mov	r4,r2
81105e50:	11060fc0 	call	811060fc <uliFeebReadReg>
81105e54:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81105e58:	e0bffe17 	ldw	r2,-8(fp)
81105e5c:	10800094 	ori	r2,r2,2
81105e60:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105e64:	e0bfff17 	ldw	r2,-4(fp)
81105e68:	10800017 	ldw	r2,0(r2)
81105e6c:	e1bffe17 	ldw	r6,-8(fp)
81105e70:	01400084 	movi	r5,2
81105e74:	1009883a 	mov	r4,r2
81105e78:	11060a80 	call	811060a8 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105e7c:	00800044 	movi	r2,1
81105e80:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105e84:	e0bffd17 	ldw	r2,-12(fp)
}
81105e88:	e037883a 	mov	sp,fp
81105e8c:	dfc00117 	ldw	ra,4(sp)
81105e90:	df000017 	ldw	fp,0(sp)
81105e94:	dec00204 	addi	sp,sp,8
81105e98:	f800283a 	ret

81105e9c <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81105e9c:	defffb04 	addi	sp,sp,-20
81105ea0:	de00012e 	bgeu	sp,et,81105ea8 <bFeebClrCh+0xc>
81105ea4:	003b68fa 	trap	3
81105ea8:	dfc00415 	stw	ra,16(sp)
81105eac:	df000315 	stw	fp,12(sp)
81105eb0:	df000304 	addi	fp,sp,12
81105eb4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105eb8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105ebc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105ec0:	e0bfff17 	ldw	r2,-4(fp)
81105ec4:	10001126 	beq	r2,zero,81105f0c <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105ec8:	e0bfff17 	ldw	r2,-4(fp)
81105ecc:	10800017 	ldw	r2,0(r2)
81105ed0:	01400084 	movi	r5,2
81105ed4:	1009883a 	mov	r4,r2
81105ed8:	11060fc0 	call	811060fc <uliFeebReadReg>
81105edc:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81105ee0:	e0bffe17 	ldw	r2,-8(fp)
81105ee4:	10800054 	ori	r2,r2,1
81105ee8:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105eec:	e0bfff17 	ldw	r2,-4(fp)
81105ef0:	10800017 	ldw	r2,0(r2)
81105ef4:	e1bffe17 	ldw	r6,-8(fp)
81105ef8:	01400084 	movi	r5,2
81105efc:	1009883a 	mov	r4,r2
81105f00:	11060a80 	call	811060a8 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105f04:	00800044 	movi	r2,1
81105f08:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105f0c:	e0bffd17 	ldw	r2,-12(fp)
}
81105f10:	e037883a 	mov	sp,fp
81105f14:	dfc00117 	ldw	ra,4(sp)
81105f18:	df000017 	ldw	fp,0(sp)
81105f1c:	dec00204 	addi	sp,sp,8
81105f20:	f800283a 	ret

81105f24 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81105f24:	defffb04 	addi	sp,sp,-20
81105f28:	de00012e 	bgeu	sp,et,81105f30 <bFeebInitCh+0xc>
81105f2c:	003b68fa 	trap	3
81105f30:	dfc00415 	stw	ra,16(sp)
81105f34:	df000315 	stw	fp,12(sp)
81105f38:	df000304 	addi	fp,sp,12
81105f3c:	e13ffe15 	stw	r4,-8(fp)
81105f40:	2805883a 	mov	r2,r5
81105f44:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105f48:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81105f4c:	e0bffe17 	ldw	r2,-8(fp)
81105f50:	10004f26 	beq	r2,zero,81106090 <bFeebInitCh+0x16c>
		bStatus = TRUE;
81105f54:	00800044 	movi	r2,1
81105f58:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81105f5c:	e0bfff03 	ldbu	r2,-4(fp)
81105f60:	10c00228 	cmpgeui	r3,r2,8
81105f64:	1800361e 	bne	r3,zero,81106040 <bFeebInitCh+0x11c>
81105f68:	100690ba 	slli	r3,r2,2
81105f6c:	00a04434 	movhi	r2,33040
81105f70:	1097e004 	addi	r2,r2,24448
81105f74:	1885883a 	add	r2,r3,r2
81105f78:	10800017 	ldw	r2,0(r2)
81105f7c:	1000683a 	jmp	r2
81105f80:	81105fa0 	cmpeqi	r4,r16,16766
81105f84:	81105fb4 	orhi	r4,r16,16766
81105f88:	81105fc8 	cmpgei	r4,r16,16767
81105f8c:	81105fdc 	xori	r4,r16,16767
81105f90:	81105ff0 	cmpltui	r4,r16,16767
81105f94:	81106004 	addi	r4,r16,16768
81105f98:	81106018 	cmpnei	r4,r16,16768
81105f9c:	8110602c 	andhi	r4,r16,16768
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105fa0:	e0fffe17 	ldw	r3,-8(fp)
81105fa4:	00a04834 	movhi	r2,33056
81105fa8:	108b0004 	addi	r2,r2,11264
81105fac:	18800015 	stw	r2,0(r3)
			break;
81105fb0:	00002506 	br	81106048 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81105fb4:	e0fffe17 	ldw	r3,-8(fp)
81105fb8:	00a04834 	movhi	r2,33056
81105fbc:	108a0004 	addi	r2,r2,10240
81105fc0:	18800015 	stw	r2,0(r3)
			break;
81105fc4:	00002006 	br	81106048 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81105fc8:	e0fffe17 	ldw	r3,-8(fp)
81105fcc:	00a04834 	movhi	r2,33056
81105fd0:	10890004 	addi	r2,r2,9216
81105fd4:	18800015 	stw	r2,0(r3)
			break;
81105fd8:	00001b06 	br	81106048 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81105fdc:	e0fffe17 	ldw	r3,-8(fp)
81105fe0:	00a04834 	movhi	r2,33056
81105fe4:	10880004 	addi	r2,r2,8192
81105fe8:	18800015 	stw	r2,0(r3)
			break;
81105fec:	00001606 	br	81106048 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81105ff0:	e0fffe17 	ldw	r3,-8(fp)
81105ff4:	00a04834 	movhi	r2,33056
81105ff8:	10870004 	addi	r2,r2,7168
81105ffc:	18800015 	stw	r2,0(r3)
			break;
81106000:	00001106 	br	81106048 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106004:	e0fffe17 	ldw	r3,-8(fp)
81106008:	00a04834 	movhi	r2,33056
8110600c:	10860004 	addi	r2,r2,6144
81106010:	18800015 	stw	r2,0(r3)
			break;
81106014:	00000c06 	br	81106048 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106018:	e0fffe17 	ldw	r3,-8(fp)
8110601c:	00a04834 	movhi	r2,33056
81106020:	10850004 	addi	r2,r2,5120
81106024:	18800015 	stw	r2,0(r3)
			break;
81106028:	00000706 	br	81106048 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110602c:	e0fffe17 	ldw	r3,-8(fp)
81106030:	00a04834 	movhi	r2,33056
81106034:	10840004 	addi	r2,r2,4096
81106038:	18800015 	stw	r2,0(r3)
			break;
8110603c:	00000206 	br	81106048 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106040:	e03ffd15 	stw	zero,-12(fp)
			break;
81106044:	0001883a 	nop
		}

		if (bStatus) {
81106048:	e0bffd17 	ldw	r2,-12(fp)
8110604c:	10001026 	beq	r2,zero,81106090 <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106050:	e13ffe17 	ldw	r4,-8(fp)
81106054:	1105a7c0 	call	81105a7c <bFeebGetIrqControl>
81106058:	1000011e 	bne	r2,zero,81106060 <bFeebInitCh+0x13c>
				bStatus = FALSE;
8110605c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106060:	e13ffe17 	ldw	r4,-8(fp)
81106064:	1105b280 	call	81105b28 <bFeebGetIrqFlags>
81106068:	1000011e 	bne	r2,zero,81106070 <bFeebInitCh+0x14c>
				bStatus = FALSE;
8110606c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106070:	e13ffe17 	ldw	r4,-8(fp)
81106074:	1105bb00 	call	81105bb0 <bFeebGetBuffersStatus>
81106078:	1000011e 	bne	r2,zero,81106080 <bFeebInitCh+0x15c>
				bStatus = FALSE;
8110607c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106080:	e13ffe17 	ldw	r4,-8(fp)
81106084:	1105d040 	call	81105d04 <bFeebGetWindowing>
81106088:	1000011e 	bne	r2,zero,81106090 <bFeebInitCh+0x16c>
				bStatus = FALSE;
8110608c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106090:	e0bffd17 	ldw	r2,-12(fp)
}
81106094:	e037883a 	mov	sp,fp
81106098:	dfc00117 	ldw	ra,4(sp)
8110609c:	df000017 	ldw	fp,0(sp)
811060a0:	dec00204 	addi	sp,sp,8
811060a4:	f800283a 	ret

811060a8 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811060a8:	defffc04 	addi	sp,sp,-16
811060ac:	de00012e 	bgeu	sp,et,811060b4 <vFeebWriteReg+0xc>
811060b0:	003b68fa 	trap	3
811060b4:	df000315 	stw	fp,12(sp)
811060b8:	df000304 	addi	fp,sp,12
811060bc:	e13ffd15 	stw	r4,-12(fp)
811060c0:	e17ffe15 	stw	r5,-8(fp)
811060c4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811060c8:	e0bffe17 	ldw	r2,-8(fp)
811060cc:	1085883a 	add	r2,r2,r2
811060d0:	1085883a 	add	r2,r2,r2
811060d4:	1007883a 	mov	r3,r2
811060d8:	e0bffd17 	ldw	r2,-12(fp)
811060dc:	10c5883a 	add	r2,r2,r3
811060e0:	e0ffff17 	ldw	r3,-4(fp)
811060e4:	10c00015 	stw	r3,0(r2)
}
811060e8:	0001883a 	nop
811060ec:	e037883a 	mov	sp,fp
811060f0:	df000017 	ldw	fp,0(sp)
811060f4:	dec00104 	addi	sp,sp,4
811060f8:	f800283a 	ret

811060fc <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811060fc:	defffc04 	addi	sp,sp,-16
81106100:	de00012e 	bgeu	sp,et,81106108 <uliFeebReadReg+0xc>
81106104:	003b68fa 	trap	3
81106108:	df000315 	stw	fp,12(sp)
8110610c:	df000304 	addi	fp,sp,12
81106110:	e13ffe15 	stw	r4,-8(fp)
81106114:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81106118:	e0bfff17 	ldw	r2,-4(fp)
8110611c:	1085883a 	add	r2,r2,r2
81106120:	1085883a 	add	r2,r2,r2
81106124:	1007883a 	mov	r3,r2
81106128:	e0bffe17 	ldw	r2,-8(fp)
8110612c:	10c5883a 	add	r2,r2,r3
81106130:	10800017 	ldw	r2,0(r2)
81106134:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81106138:	e0bffd17 	ldw	r2,-12(fp)
}
8110613c:	e037883a 	mov	sp,fp
81106140:	df000017 	ldw	fp,0(sp)
81106144:	dec00104 	addi	sp,sp,4
81106148:	f800283a 	ret

8110614c <vRmapCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRmapCh1HandleIrq(void* pvContext) {
8110614c:	defffc04 	addi	sp,sp,-16
81106150:	de00012e 	bgeu	sp,et,81106158 <vRmapCh1HandleIrq+0xc>
81106154:	003b68fa 	trap	3
81106158:	dfc00315 	stw	ra,12(sp)
8110615c:	df000215 	stw	fp,8(sp)
81106160:	df000204 	addi	fp,sp,8
81106164:	e13fff15 	stw	r4,-4(fp)



	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106168:	e0bfff17 	ldw	r2,-4(fp)
8110616c:	e0bffe15 	stw	r2,-8(fp)





	vRmapCh1IrqFlagClrWriteCmd();
81106170:	110634c0 	call	8110634c <vRmapCh1IrqFlagClrWriteCmd>
}
81106174:	0001883a 	nop
81106178:	e037883a 	mov	sp,fp
8110617c:	dfc00117 	ldw	ra,4(sp)
81106180:	df000017 	ldw	fp,0(sp)
81106184:	dec00204 	addi	sp,sp,8
81106188:	f800283a 	ret

8110618c <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
8110618c:	defffc04 	addi	sp,sp,-16
81106190:	de00012e 	bgeu	sp,et,81106198 <vRmapCh2HandleIrq+0xc>
81106194:	003b68fa 	trap	3
81106198:	dfc00315 	stw	ra,12(sp)
8110619c:	df000215 	stw	fp,8(sp)
811061a0:	df000204 	addi	fp,sp,8
811061a4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811061a8:	e0bfff17 	ldw	r2,-4(fp)
811061ac:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
811061b0:	11063900 	call	81106390 <vRmapCh2IrqFlagClrWriteCmd>
}
811061b4:	0001883a 	nop
811061b8:	e037883a 	mov	sp,fp
811061bc:	dfc00117 	ldw	ra,4(sp)
811061c0:	df000017 	ldw	fp,0(sp)
811061c4:	dec00204 	addi	sp,sp,8
811061c8:	f800283a 	ret

811061cc <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
811061cc:	defffc04 	addi	sp,sp,-16
811061d0:	de00012e 	bgeu	sp,et,811061d8 <vRmapCh3HandleIrq+0xc>
811061d4:	003b68fa 	trap	3
811061d8:	dfc00315 	stw	ra,12(sp)
811061dc:	df000215 	stw	fp,8(sp)
811061e0:	df000204 	addi	fp,sp,8
811061e4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811061e8:	e0bfff17 	ldw	r2,-4(fp)
811061ec:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
811061f0:	11063d40 	call	811063d4 <vRmapCh3IrqFlagClrWriteCmd>
}
811061f4:	0001883a 	nop
811061f8:	e037883a 	mov	sp,fp
811061fc:	dfc00117 	ldw	ra,4(sp)
81106200:	df000017 	ldw	fp,0(sp)
81106204:	dec00204 	addi	sp,sp,8
81106208:	f800283a 	ret

8110620c <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
8110620c:	defffc04 	addi	sp,sp,-16
81106210:	de00012e 	bgeu	sp,et,81106218 <vRmapCh4HandleIrq+0xc>
81106214:	003b68fa 	trap	3
81106218:	dfc00315 	stw	ra,12(sp)
8110621c:	df000215 	stw	fp,8(sp)
81106220:	df000204 	addi	fp,sp,8
81106224:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106228:	e0bfff17 	ldw	r2,-4(fp)
8110622c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81106230:	11064180 	call	81106418 <vRmapCh4IrqFlagClrWriteCmd>
}
81106234:	0001883a 	nop
81106238:	e037883a 	mov	sp,fp
8110623c:	dfc00117 	ldw	ra,4(sp)
81106240:	df000017 	ldw	fp,0(sp)
81106244:	dec00204 	addi	sp,sp,8
81106248:	f800283a 	ret

8110624c <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
8110624c:	defffc04 	addi	sp,sp,-16
81106250:	de00012e 	bgeu	sp,et,81106258 <vRmapCh5HandleIrq+0xc>
81106254:	003b68fa 	trap	3
81106258:	dfc00315 	stw	ra,12(sp)
8110625c:	df000215 	stw	fp,8(sp)
81106260:	df000204 	addi	fp,sp,8
81106264:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106268:	e0bfff17 	ldw	r2,-4(fp)
8110626c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106270:	110645c0 	call	8110645c <vRmapCh5IrqFlagClrWriteCmd>
}
81106274:	0001883a 	nop
81106278:	e037883a 	mov	sp,fp
8110627c:	dfc00117 	ldw	ra,4(sp)
81106280:	df000017 	ldw	fp,0(sp)
81106284:	dec00204 	addi	sp,sp,8
81106288:	f800283a 	ret

8110628c <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
8110628c:	defffc04 	addi	sp,sp,-16
81106290:	de00012e 	bgeu	sp,et,81106298 <vRmapCh6HandleIrq+0xc>
81106294:	003b68fa 	trap	3
81106298:	dfc00315 	stw	ra,12(sp)
8110629c:	df000215 	stw	fp,8(sp)
811062a0:	df000204 	addi	fp,sp,8
811062a4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811062a8:	e0bfff17 	ldw	r2,-4(fp)
811062ac:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
811062b0:	11064a00 	call	811064a0 <vRmapCh6IrqFlagClrWriteCmd>
}
811062b4:	0001883a 	nop
811062b8:	e037883a 	mov	sp,fp
811062bc:	dfc00117 	ldw	ra,4(sp)
811062c0:	df000017 	ldw	fp,0(sp)
811062c4:	dec00204 	addi	sp,sp,8
811062c8:	f800283a 	ret

811062cc <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
811062cc:	defffc04 	addi	sp,sp,-16
811062d0:	de00012e 	bgeu	sp,et,811062d8 <vRmapCh7HandleIrq+0xc>
811062d4:	003b68fa 	trap	3
811062d8:	dfc00315 	stw	ra,12(sp)
811062dc:	df000215 	stw	fp,8(sp)
811062e0:	df000204 	addi	fp,sp,8
811062e4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811062e8:	e0bfff17 	ldw	r2,-4(fp)
811062ec:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
811062f0:	11064e40 	call	811064e4 <vRmapCh7IrqFlagClrWriteCmd>
}
811062f4:	0001883a 	nop
811062f8:	e037883a 	mov	sp,fp
811062fc:	dfc00117 	ldw	ra,4(sp)
81106300:	df000017 	ldw	fp,0(sp)
81106304:	dec00204 	addi	sp,sp,8
81106308:	f800283a 	ret

8110630c <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
8110630c:	defffc04 	addi	sp,sp,-16
81106310:	de00012e 	bgeu	sp,et,81106318 <vRmapCh8HandleIrq+0xc>
81106314:	003b68fa 	trap	3
81106318:	dfc00315 	stw	ra,12(sp)
8110631c:	df000215 	stw	fp,8(sp)
81106320:	df000204 	addi	fp,sp,8
81106324:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106328:	e0bfff17 	ldw	r2,-4(fp)
8110632c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106330:	11065280 	call	81106528 <vRmapCh8IrqFlagClrWriteCmd>
}
81106334:	0001883a 	nop
81106338:	e037883a 	mov	sp,fp
8110633c:	dfc00117 	ldw	ra,4(sp)
81106340:	df000017 	ldw	fp,0(sp)
81106344:	dec00204 	addi	sp,sp,8
81106348:	f800283a 	ret

8110634c <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
8110634c:	defffe04 	addi	sp,sp,-8
81106350:	de00012e 	bgeu	sp,et,81106358 <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106354:	003b68fa 	trap	3
81106358:	dfc00115 	stw	ra,4(sp)
8110635c:	df000015 	stw	fp,0(sp)
81106360:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106364:	01800044 	movi	r6,1
81106368:	014004c4 	movi	r5,19
8110636c:	01204834 	movhi	r4,33056
81106370:	210b0004 	addi	r4,r4,11264
81106374:	1108e140 	call	81108e14 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106378:	0001883a 	nop
8110637c:	e037883a 	mov	sp,fp
81106380:	dfc00117 	ldw	ra,4(sp)
81106384:	df000017 	ldw	fp,0(sp)
81106388:	dec00204 	addi	sp,sp,8
8110638c:	f800283a 	ret

81106390 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81106390:	defffe04 	addi	sp,sp,-8
81106394:	de00012e 	bgeu	sp,et,8110639c <vRmapCh2IrqFlagClrWriteCmd+0xc>
81106398:	003b68fa 	trap	3
8110639c:	dfc00115 	stw	ra,4(sp)
811063a0:	df000015 	stw	fp,0(sp)
811063a4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811063a8:	01800044 	movi	r6,1
811063ac:	014004c4 	movi	r5,19
811063b0:	01204834 	movhi	r4,33056
811063b4:	210a0004 	addi	r4,r4,10240
811063b8:	1108e140 	call	81108e14 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811063bc:	0001883a 	nop
811063c0:	e037883a 	mov	sp,fp
811063c4:	dfc00117 	ldw	ra,4(sp)
811063c8:	df000017 	ldw	fp,0(sp)
811063cc:	dec00204 	addi	sp,sp,8
811063d0:	f800283a 	ret

811063d4 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
811063d4:	defffe04 	addi	sp,sp,-8
811063d8:	de00012e 	bgeu	sp,et,811063e0 <vRmapCh3IrqFlagClrWriteCmd+0xc>
811063dc:	003b68fa 	trap	3
811063e0:	dfc00115 	stw	ra,4(sp)
811063e4:	df000015 	stw	fp,0(sp)
811063e8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811063ec:	01800044 	movi	r6,1
811063f0:	014004c4 	movi	r5,19
811063f4:	01204834 	movhi	r4,33056
811063f8:	21090004 	addi	r4,r4,9216
811063fc:	1108e140 	call	81108e14 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106400:	0001883a 	nop
81106404:	e037883a 	mov	sp,fp
81106408:	dfc00117 	ldw	ra,4(sp)
8110640c:	df000017 	ldw	fp,0(sp)
81106410:	dec00204 	addi	sp,sp,8
81106414:	f800283a 	ret

81106418 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81106418:	defffe04 	addi	sp,sp,-8
8110641c:	de00012e 	bgeu	sp,et,81106424 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81106420:	003b68fa 	trap	3
81106424:	dfc00115 	stw	ra,4(sp)
81106428:	df000015 	stw	fp,0(sp)
8110642c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106430:	01800044 	movi	r6,1
81106434:	014004c4 	movi	r5,19
81106438:	01204834 	movhi	r4,33056
8110643c:	21080004 	addi	r4,r4,8192
81106440:	1108e140 	call	81108e14 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106444:	0001883a 	nop
81106448:	e037883a 	mov	sp,fp
8110644c:	dfc00117 	ldw	ra,4(sp)
81106450:	df000017 	ldw	fp,0(sp)
81106454:	dec00204 	addi	sp,sp,8
81106458:	f800283a 	ret

8110645c <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
8110645c:	defffe04 	addi	sp,sp,-8
81106460:	de00012e 	bgeu	sp,et,81106468 <vRmapCh5IrqFlagClrWriteCmd+0xc>
81106464:	003b68fa 	trap	3
81106468:	dfc00115 	stw	ra,4(sp)
8110646c:	df000015 	stw	fp,0(sp)
81106470:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106474:	01800044 	movi	r6,1
81106478:	014004c4 	movi	r5,19
8110647c:	01204834 	movhi	r4,33056
81106480:	21070004 	addi	r4,r4,7168
81106484:	1108e140 	call	81108e14 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106488:	0001883a 	nop
8110648c:	e037883a 	mov	sp,fp
81106490:	dfc00117 	ldw	ra,4(sp)
81106494:	df000017 	ldw	fp,0(sp)
81106498:	dec00204 	addi	sp,sp,8
8110649c:	f800283a 	ret

811064a0 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
811064a0:	defffe04 	addi	sp,sp,-8
811064a4:	de00012e 	bgeu	sp,et,811064ac <vRmapCh6IrqFlagClrWriteCmd+0xc>
811064a8:	003b68fa 	trap	3
811064ac:	dfc00115 	stw	ra,4(sp)
811064b0:	df000015 	stw	fp,0(sp)
811064b4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811064b8:	01800044 	movi	r6,1
811064bc:	014004c4 	movi	r5,19
811064c0:	01204834 	movhi	r4,33056
811064c4:	21060004 	addi	r4,r4,6144
811064c8:	1108e140 	call	81108e14 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811064cc:	0001883a 	nop
811064d0:	e037883a 	mov	sp,fp
811064d4:	dfc00117 	ldw	ra,4(sp)
811064d8:	df000017 	ldw	fp,0(sp)
811064dc:	dec00204 	addi	sp,sp,8
811064e0:	f800283a 	ret

811064e4 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
811064e4:	defffe04 	addi	sp,sp,-8
811064e8:	de00012e 	bgeu	sp,et,811064f0 <vRmapCh7IrqFlagClrWriteCmd+0xc>
811064ec:	003b68fa 	trap	3
811064f0:	dfc00115 	stw	ra,4(sp)
811064f4:	df000015 	stw	fp,0(sp)
811064f8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811064fc:	01800044 	movi	r6,1
81106500:	014004c4 	movi	r5,19
81106504:	01204834 	movhi	r4,33056
81106508:	21050004 	addi	r4,r4,5120
8110650c:	1108e140 	call	81108e14 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106510:	0001883a 	nop
81106514:	e037883a 	mov	sp,fp
81106518:	dfc00117 	ldw	ra,4(sp)
8110651c:	df000017 	ldw	fp,0(sp)
81106520:	dec00204 	addi	sp,sp,8
81106524:	f800283a 	ret

81106528 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
81106528:	defffe04 	addi	sp,sp,-8
8110652c:	de00012e 	bgeu	sp,et,81106534 <vRmapCh8IrqFlagClrWriteCmd+0xc>
81106530:	003b68fa 	trap	3
81106534:	dfc00115 	stw	ra,4(sp)
81106538:	df000015 	stw	fp,0(sp)
8110653c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106540:	01800044 	movi	r6,1
81106544:	014004c4 	movi	r5,19
81106548:	01204834 	movhi	r4,33056
8110654c:	21040004 	addi	r4,r4,4096
81106550:	1108e140 	call	81108e14 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106554:	0001883a 	nop
81106558:	e037883a 	mov	sp,fp
8110655c:	dfc00117 	ldw	ra,4(sp)
81106560:	df000017 	ldw	fp,0(sp)
81106564:	dec00204 	addi	sp,sp,8
81106568:	f800283a 	ret

8110656c <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
8110656c:	defffd04 	addi	sp,sp,-12
81106570:	de00012e 	bgeu	sp,et,81106578 <bRmapCh1IrqFlagWriteCmd+0xc>
81106574:	003b68fa 	trap	3
81106578:	dfc00215 	stw	ra,8(sp)
8110657c:	df000115 	stw	fp,4(sp)
81106580:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106584:	01400484 	movi	r5,18
81106588:	01204834 	movhi	r4,33056
8110658c:	210b0004 	addi	r4,r4,11264
81106590:	1108e680 	call	81108e68 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106594:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106598:	10000326 	beq	r2,zero,811065a8 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110659c:	00800044 	movi	r2,1
811065a0:	e0bfff15 	stw	r2,-4(fp)
811065a4:	00000106 	br	811065ac <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811065a8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811065ac:	e0bfff17 	ldw	r2,-4(fp)
}
811065b0:	e037883a 	mov	sp,fp
811065b4:	dfc00117 	ldw	ra,4(sp)
811065b8:	df000017 	ldw	fp,0(sp)
811065bc:	dec00204 	addi	sp,sp,8
811065c0:	f800283a 	ret

811065c4 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
811065c4:	defffd04 	addi	sp,sp,-12
811065c8:	de00012e 	bgeu	sp,et,811065d0 <bRmapCh2IrqFlagWriteCmd+0xc>
811065cc:	003b68fa 	trap	3
811065d0:	dfc00215 	stw	ra,8(sp)
811065d4:	df000115 	stw	fp,4(sp)
811065d8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811065dc:	01400484 	movi	r5,18
811065e0:	01204834 	movhi	r4,33056
811065e4:	210a0004 	addi	r4,r4,10240
811065e8:	1108e680 	call	81108e68 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811065ec:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811065f0:	10000326 	beq	r2,zero,81106600 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811065f4:	00800044 	movi	r2,1
811065f8:	e0bfff15 	stw	r2,-4(fp)
811065fc:	00000106 	br	81106604 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106600:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106604:	e0bfff17 	ldw	r2,-4(fp)
}
81106608:	e037883a 	mov	sp,fp
8110660c:	dfc00117 	ldw	ra,4(sp)
81106610:	df000017 	ldw	fp,0(sp)
81106614:	dec00204 	addi	sp,sp,8
81106618:	f800283a 	ret

8110661c <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
8110661c:	defffd04 	addi	sp,sp,-12
81106620:	de00012e 	bgeu	sp,et,81106628 <bRmapCh3IrqFlagWriteCmd+0xc>
81106624:	003b68fa 	trap	3
81106628:	dfc00215 	stw	ra,8(sp)
8110662c:	df000115 	stw	fp,4(sp)
81106630:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106634:	01400484 	movi	r5,18
81106638:	01204834 	movhi	r4,33056
8110663c:	21090004 	addi	r4,r4,9216
81106640:	1108e680 	call	81108e68 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106644:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106648:	10000326 	beq	r2,zero,81106658 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110664c:	00800044 	movi	r2,1
81106650:	e0bfff15 	stw	r2,-4(fp)
81106654:	00000106 	br	8110665c <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106658:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110665c:	e0bfff17 	ldw	r2,-4(fp)
}
81106660:	e037883a 	mov	sp,fp
81106664:	dfc00117 	ldw	ra,4(sp)
81106668:	df000017 	ldw	fp,0(sp)
8110666c:	dec00204 	addi	sp,sp,8
81106670:	f800283a 	ret

81106674 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81106674:	defffd04 	addi	sp,sp,-12
81106678:	de00012e 	bgeu	sp,et,81106680 <bRmapCh4IrqFlagWriteCmd+0xc>
8110667c:	003b68fa 	trap	3
81106680:	dfc00215 	stw	ra,8(sp)
81106684:	df000115 	stw	fp,4(sp)
81106688:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110668c:	01400484 	movi	r5,18
81106690:	01204834 	movhi	r4,33056
81106694:	21080004 	addi	r4,r4,8192
81106698:	1108e680 	call	81108e68 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110669c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811066a0:	10000326 	beq	r2,zero,811066b0 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811066a4:	00800044 	movi	r2,1
811066a8:	e0bfff15 	stw	r2,-4(fp)
811066ac:	00000106 	br	811066b4 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811066b0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811066b4:	e0bfff17 	ldw	r2,-4(fp)
}
811066b8:	e037883a 	mov	sp,fp
811066bc:	dfc00117 	ldw	ra,4(sp)
811066c0:	df000017 	ldw	fp,0(sp)
811066c4:	dec00204 	addi	sp,sp,8
811066c8:	f800283a 	ret

811066cc <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
811066cc:	defffd04 	addi	sp,sp,-12
811066d0:	de00012e 	bgeu	sp,et,811066d8 <bRmapCh5IrqFlagWriteCmd+0xc>
811066d4:	003b68fa 	trap	3
811066d8:	dfc00215 	stw	ra,8(sp)
811066dc:	df000115 	stw	fp,4(sp)
811066e0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811066e4:	01400484 	movi	r5,18
811066e8:	01204834 	movhi	r4,33056
811066ec:	21070004 	addi	r4,r4,7168
811066f0:	1108e680 	call	81108e68 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811066f4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811066f8:	10000326 	beq	r2,zero,81106708 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811066fc:	00800044 	movi	r2,1
81106700:	e0bfff15 	stw	r2,-4(fp)
81106704:	00000106 	br	8110670c <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106708:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110670c:	e0bfff17 	ldw	r2,-4(fp)
}
81106710:	e037883a 	mov	sp,fp
81106714:	dfc00117 	ldw	ra,4(sp)
81106718:	df000017 	ldw	fp,0(sp)
8110671c:	dec00204 	addi	sp,sp,8
81106720:	f800283a 	ret

81106724 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
81106724:	defffd04 	addi	sp,sp,-12
81106728:	de00012e 	bgeu	sp,et,81106730 <bRmapCh6IrqFlagWriteCmd+0xc>
8110672c:	003b68fa 	trap	3
81106730:	dfc00215 	stw	ra,8(sp)
81106734:	df000115 	stw	fp,4(sp)
81106738:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110673c:	01400484 	movi	r5,18
81106740:	01204834 	movhi	r4,33056
81106744:	21060004 	addi	r4,r4,6144
81106748:	1108e680 	call	81108e68 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110674c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106750:	10000326 	beq	r2,zero,81106760 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106754:	00800044 	movi	r2,1
81106758:	e0bfff15 	stw	r2,-4(fp)
8110675c:	00000106 	br	81106764 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106760:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106764:	e0bfff17 	ldw	r2,-4(fp)
}
81106768:	e037883a 	mov	sp,fp
8110676c:	dfc00117 	ldw	ra,4(sp)
81106770:	df000017 	ldw	fp,0(sp)
81106774:	dec00204 	addi	sp,sp,8
81106778:	f800283a 	ret

8110677c <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
8110677c:	defffd04 	addi	sp,sp,-12
81106780:	de00012e 	bgeu	sp,et,81106788 <bRmapCh7IrqFlagWriteCmd+0xc>
81106784:	003b68fa 	trap	3
81106788:	dfc00215 	stw	ra,8(sp)
8110678c:	df000115 	stw	fp,4(sp)
81106790:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106794:	01400484 	movi	r5,18
81106798:	01204834 	movhi	r4,33056
8110679c:	21050004 	addi	r4,r4,5120
811067a0:	1108e680 	call	81108e68 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811067a4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811067a8:	10000326 	beq	r2,zero,811067b8 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811067ac:	00800044 	movi	r2,1
811067b0:	e0bfff15 	stw	r2,-4(fp)
811067b4:	00000106 	br	811067bc <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811067b8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811067bc:	e0bfff17 	ldw	r2,-4(fp)
}
811067c0:	e037883a 	mov	sp,fp
811067c4:	dfc00117 	ldw	ra,4(sp)
811067c8:	df000017 	ldw	fp,0(sp)
811067cc:	dec00204 	addi	sp,sp,8
811067d0:	f800283a 	ret

811067d4 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
811067d4:	defffd04 	addi	sp,sp,-12
811067d8:	de00012e 	bgeu	sp,et,811067e0 <bRmapCh8IrqFlagWriteCmd+0xc>
811067dc:	003b68fa 	trap	3
811067e0:	dfc00215 	stw	ra,8(sp)
811067e4:	df000115 	stw	fp,4(sp)
811067e8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811067ec:	01400484 	movi	r5,18
811067f0:	01204834 	movhi	r4,33056
811067f4:	21040004 	addi	r4,r4,4096
811067f8:	1108e680 	call	81108e68 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811067fc:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106800:	10000326 	beq	r2,zero,81106810 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106804:	00800044 	movi	r2,1
81106808:	e0bfff15 	stw	r2,-4(fp)
8110680c:	00000106 	br	81106814 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106810:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106814:	e0bfff17 	ldw	r2,-4(fp)
}
81106818:	e037883a 	mov	sp,fp
8110681c:	dfc00117 	ldw	ra,4(sp)
81106820:	df000017 	ldw	fp,0(sp)
81106824:	dec00204 	addi	sp,sp,8
81106828:	f800283a 	ret

8110682c <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
8110682c:	defffd04 	addi	sp,sp,-12
81106830:	de00012e 	bgeu	sp,et,81106838 <uliRmapCh1WriteCmdAddress+0xc>
81106834:	003b68fa 	trap	3
81106838:	dfc00215 	stw	ra,8(sp)
8110683c:	df000115 	stw	fp,4(sp)
81106840:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106844:	01400184 	movi	r5,6
81106848:	01204834 	movhi	r4,33056
8110684c:	210b0004 	addi	r4,r4,11264
81106850:	1108e680 	call	81108e68 <uliRmapReadReg>
81106854:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106858:	e13fff17 	ldw	r4,-4(fp)
8110685c:	1108eb80 	call	81108eb8 <uliConvRmapCfgAddr>
81106860:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106864:	e0bfff17 	ldw	r2,-4(fp)
}
81106868:	e037883a 	mov	sp,fp
8110686c:	dfc00117 	ldw	ra,4(sp)
81106870:	df000017 	ldw	fp,0(sp)
81106874:	dec00204 	addi	sp,sp,8
81106878:	f800283a 	ret

8110687c <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
8110687c:	defffd04 	addi	sp,sp,-12
81106880:	de00012e 	bgeu	sp,et,81106888 <uliRmapCh2WriteCmdAddress+0xc>
81106884:	003b68fa 	trap	3
81106888:	dfc00215 	stw	ra,8(sp)
8110688c:	df000115 	stw	fp,4(sp)
81106890:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106894:	01400184 	movi	r5,6
81106898:	01204834 	movhi	r4,33056
8110689c:	210a0004 	addi	r4,r4,10240
811068a0:	1108e680 	call	81108e68 <uliRmapReadReg>
811068a4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811068a8:	e13fff17 	ldw	r4,-4(fp)
811068ac:	1108eb80 	call	81108eb8 <uliConvRmapCfgAddr>
811068b0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811068b4:	e0bfff17 	ldw	r2,-4(fp)
}
811068b8:	e037883a 	mov	sp,fp
811068bc:	dfc00117 	ldw	ra,4(sp)
811068c0:	df000017 	ldw	fp,0(sp)
811068c4:	dec00204 	addi	sp,sp,8
811068c8:	f800283a 	ret

811068cc <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
811068cc:	defffd04 	addi	sp,sp,-12
811068d0:	de00012e 	bgeu	sp,et,811068d8 <uliRmapCh3WriteCmdAddress+0xc>
811068d4:	003b68fa 	trap	3
811068d8:	dfc00215 	stw	ra,8(sp)
811068dc:	df000115 	stw	fp,4(sp)
811068e0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811068e4:	01400184 	movi	r5,6
811068e8:	01204834 	movhi	r4,33056
811068ec:	21090004 	addi	r4,r4,9216
811068f0:	1108e680 	call	81108e68 <uliRmapReadReg>
811068f4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811068f8:	e13fff17 	ldw	r4,-4(fp)
811068fc:	1108eb80 	call	81108eb8 <uliConvRmapCfgAddr>
81106900:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106904:	e0bfff17 	ldw	r2,-4(fp)
}
81106908:	e037883a 	mov	sp,fp
8110690c:	dfc00117 	ldw	ra,4(sp)
81106910:	df000017 	ldw	fp,0(sp)
81106914:	dec00204 	addi	sp,sp,8
81106918:	f800283a 	ret

8110691c <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
8110691c:	defffd04 	addi	sp,sp,-12
81106920:	de00012e 	bgeu	sp,et,81106928 <uliRmapCh4WriteCmdAddress+0xc>
81106924:	003b68fa 	trap	3
81106928:	dfc00215 	stw	ra,8(sp)
8110692c:	df000115 	stw	fp,4(sp)
81106930:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106934:	01400184 	movi	r5,6
81106938:	01204834 	movhi	r4,33056
8110693c:	21080004 	addi	r4,r4,8192
81106940:	1108e680 	call	81108e68 <uliRmapReadReg>
81106944:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106948:	e13fff17 	ldw	r4,-4(fp)
8110694c:	1108eb80 	call	81108eb8 <uliConvRmapCfgAddr>
81106950:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106954:	e0bfff17 	ldw	r2,-4(fp)
}
81106958:	e037883a 	mov	sp,fp
8110695c:	dfc00117 	ldw	ra,4(sp)
81106960:	df000017 	ldw	fp,0(sp)
81106964:	dec00204 	addi	sp,sp,8
81106968:	f800283a 	ret

8110696c <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
8110696c:	defffd04 	addi	sp,sp,-12
81106970:	de00012e 	bgeu	sp,et,81106978 <uliRmapCh5WriteCmdAddress+0xc>
81106974:	003b68fa 	trap	3
81106978:	dfc00215 	stw	ra,8(sp)
8110697c:	df000115 	stw	fp,4(sp)
81106980:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106984:	01400184 	movi	r5,6
81106988:	01204834 	movhi	r4,33056
8110698c:	21070004 	addi	r4,r4,7168
81106990:	1108e680 	call	81108e68 <uliRmapReadReg>
81106994:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106998:	e13fff17 	ldw	r4,-4(fp)
8110699c:	1108eb80 	call	81108eb8 <uliConvRmapCfgAddr>
811069a0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811069a4:	e0bfff17 	ldw	r2,-4(fp)
}
811069a8:	e037883a 	mov	sp,fp
811069ac:	dfc00117 	ldw	ra,4(sp)
811069b0:	df000017 	ldw	fp,0(sp)
811069b4:	dec00204 	addi	sp,sp,8
811069b8:	f800283a 	ret

811069bc <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
811069bc:	defffd04 	addi	sp,sp,-12
811069c0:	de00012e 	bgeu	sp,et,811069c8 <uliRmapCh6WriteCmdAddress+0xc>
811069c4:	003b68fa 	trap	3
811069c8:	dfc00215 	stw	ra,8(sp)
811069cc:	df000115 	stw	fp,4(sp)
811069d0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811069d4:	01400184 	movi	r5,6
811069d8:	01204834 	movhi	r4,33056
811069dc:	21060004 	addi	r4,r4,6144
811069e0:	1108e680 	call	81108e68 <uliRmapReadReg>
811069e4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811069e8:	e13fff17 	ldw	r4,-4(fp)
811069ec:	1108eb80 	call	81108eb8 <uliConvRmapCfgAddr>
811069f0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811069f4:	e0bfff17 	ldw	r2,-4(fp)
}
811069f8:	e037883a 	mov	sp,fp
811069fc:	dfc00117 	ldw	ra,4(sp)
81106a00:	df000017 	ldw	fp,0(sp)
81106a04:	dec00204 	addi	sp,sp,8
81106a08:	f800283a 	ret

81106a0c <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81106a0c:	defffd04 	addi	sp,sp,-12
81106a10:	de00012e 	bgeu	sp,et,81106a18 <uliRmapCh7WriteCmdAddress+0xc>
81106a14:	003b68fa 	trap	3
81106a18:	dfc00215 	stw	ra,8(sp)
81106a1c:	df000115 	stw	fp,4(sp)
81106a20:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106a24:	01400184 	movi	r5,6
81106a28:	01204834 	movhi	r4,33056
81106a2c:	21050004 	addi	r4,r4,5120
81106a30:	1108e680 	call	81108e68 <uliRmapReadReg>
81106a34:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106a38:	e13fff17 	ldw	r4,-4(fp)
81106a3c:	1108eb80 	call	81108eb8 <uliConvRmapCfgAddr>
81106a40:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106a44:	e0bfff17 	ldw	r2,-4(fp)
}
81106a48:	e037883a 	mov	sp,fp
81106a4c:	dfc00117 	ldw	ra,4(sp)
81106a50:	df000017 	ldw	fp,0(sp)
81106a54:	dec00204 	addi	sp,sp,8
81106a58:	f800283a 	ret

81106a5c <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81106a5c:	defffd04 	addi	sp,sp,-12
81106a60:	de00012e 	bgeu	sp,et,81106a68 <uliRmapCh8WriteCmdAddress+0xc>
81106a64:	003b68fa 	trap	3
81106a68:	dfc00215 	stw	ra,8(sp)
81106a6c:	df000115 	stw	fp,4(sp)
81106a70:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106a74:	01400184 	movi	r5,6
81106a78:	01204834 	movhi	r4,33056
81106a7c:	21040004 	addi	r4,r4,4096
81106a80:	1108e680 	call	81108e68 <uliRmapReadReg>
81106a84:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106a88:	e13fff17 	ldw	r4,-4(fp)
81106a8c:	1108eb80 	call	81108eb8 <uliConvRmapCfgAddr>
81106a90:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106a94:	e0bfff17 	ldw	r2,-4(fp)
}
81106a98:	e037883a 	mov	sp,fp
81106a9c:	dfc00117 	ldw	ra,4(sp)
81106aa0:	df000017 	ldw	fp,0(sp)
81106aa4:	dec00204 	addi	sp,sp,8
81106aa8:	f800283a 	ret

81106aac <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81106aac:	defffc04 	addi	sp,sp,-16
81106ab0:	de00012e 	bgeu	sp,et,81106ab8 <vRmapInitIrq+0xc>
81106ab4:	003b68fa 	trap	3
81106ab8:	dfc00315 	stw	ra,12(sp)
81106abc:	df000215 	stw	fp,8(sp)
81106ac0:	df000204 	addi	fp,sp,8
81106ac4:	2005883a 	mov	r2,r4
81106ac8:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81106acc:	e0bfff03 	ldbu	r2,-4(fp)
81106ad0:	10c00228 	cmpgeui	r3,r2,8
81106ad4:	18004e1e 	bne	r3,zero,81106c10 <vRmapInitIrq+0x164>
81106ad8:	100690ba 	slli	r3,r2,2
81106adc:	00a04434 	movhi	r2,33040
81106ae0:	109abc04 	addi	r2,r2,27376
81106ae4:	1885883a 	add	r2,r3,r2
81106ae8:	10800017 	ldw	r2,0(r2)
81106aec:	1000683a 	jmp	r2
81106af0:	81106b10 	cmplti	r4,r16,16812
81106af4:	81106b30 	cmpltui	r4,r16,16812
81106af8:	81106b50 	cmplti	r4,r16,16813
81106afc:	81106b70 	cmpltui	r4,r16,16813
81106b00:	81106b90 	cmplti	r4,r16,16814
81106b04:	81106bb0 	cmpltui	r4,r16,16814
81106b08:	81106bd0 	cmplti	r4,r16,16815
81106b0c:	81106bf0 	cmpltui	r4,r16,16815
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81106b10:	d0a04604 	addi	r2,gp,-32488
81106b14:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
81106b18:	01a04434 	movhi	r6,33040
81106b1c:	31985304 	addi	r6,r6,24908
81106b20:	e17ffe17 	ldw	r5,-8(fp)
81106b24:	010005c4 	movi	r4,23
81106b28:	1131d240 	call	81131d24 <alt_irq_register>
		break;
81106b2c:	00003806 	br	81106c10 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81106b30:	d0a04704 	addi	r2,gp,-32484
81106b34:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
81106b38:	01a04434 	movhi	r6,33040
81106b3c:	31986304 	addi	r6,r6,24972
81106b40:	e17ffe17 	ldw	r5,-8(fp)
81106b44:	01000544 	movi	r4,21
81106b48:	1131d240 	call	81131d24 <alt_irq_register>
		break;
81106b4c:	00003006 	br	81106c10 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81106b50:	d0a04804 	addi	r2,gp,-32480
81106b54:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
81106b58:	01a04434 	movhi	r6,33040
81106b5c:	31987304 	addi	r6,r6,25036
81106b60:	e17ffe17 	ldw	r5,-8(fp)
81106b64:	010004c4 	movi	r4,19
81106b68:	1131d240 	call	81131d24 <alt_irq_register>
		break;
81106b6c:	00002806 	br	81106c10 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81106b70:	d0a04904 	addi	r2,gp,-32476
81106b74:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81106b78:	01a04434 	movhi	r6,33040
81106b7c:	31988304 	addi	r6,r6,25100
81106b80:	e17ffe17 	ldw	r5,-8(fp)
81106b84:	01000444 	movi	r4,17
81106b88:	1131d240 	call	81131d24 <alt_irq_register>
		break;
81106b8c:	00002006 	br	81106c10 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81106b90:	d0a04a04 	addi	r2,gp,-32472
81106b94:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81106b98:	01a04434 	movhi	r6,33040
81106b9c:	31989304 	addi	r6,r6,25164
81106ba0:	e17ffe17 	ldw	r5,-8(fp)
81106ba4:	01000244 	movi	r4,9
81106ba8:	1131d240 	call	81131d24 <alt_irq_register>
		break;
81106bac:	00001806 	br	81106c10 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81106bb0:	d0a04b04 	addi	r2,gp,-32468
81106bb4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81106bb8:	01a04434 	movhi	r6,33040
81106bbc:	3198a304 	addi	r6,r6,25228
81106bc0:	e17ffe17 	ldw	r5,-8(fp)
81106bc4:	010001c4 	movi	r4,7
81106bc8:	1131d240 	call	81131d24 <alt_irq_register>
		break;
81106bcc:	00001006 	br	81106c10 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81106bd0:	d0a04c04 	addi	r2,gp,-32464
81106bd4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81106bd8:	01a04434 	movhi	r6,33040
81106bdc:	3198b304 	addi	r6,r6,25292
81106be0:	e17ffe17 	ldw	r5,-8(fp)
81106be4:	01000104 	movi	r4,4
81106be8:	1131d240 	call	81131d24 <alt_irq_register>
		break;
81106bec:	00000806 	br	81106c10 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81106bf0:	d0a04d04 	addi	r2,gp,-32460
81106bf4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81106bf8:	01a04434 	movhi	r6,33040
81106bfc:	3198c304 	addi	r6,r6,25356
81106c00:	e17ffe17 	ldw	r5,-8(fp)
81106c04:	010000c4 	movi	r4,3
81106c08:	1131d240 	call	81131d24 <alt_irq_register>
		break;
81106c0c:	0001883a 	nop
	}
}
81106c10:	0001883a 	nop
81106c14:	e037883a 	mov	sp,fp
81106c18:	dfc00117 	ldw	ra,4(sp)
81106c1c:	df000017 	ldw	fp,0(sp)
81106c20:	dec00204 	addi	sp,sp,8
81106c24:	f800283a 	ret

81106c28 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
81106c28:	defffb04 	addi	sp,sp,-20
81106c2c:	de00012e 	bgeu	sp,et,81106c34 <bRmapSetIrqControl+0xc>
81106c30:	003b68fa 	trap	3
81106c34:	dfc00415 	stw	ra,16(sp)
81106c38:	df000315 	stw	fp,12(sp)
81106c3c:	df000304 	addi	fp,sp,12
81106c40:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106c44:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106c48:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106c4c:	e0bfff17 	ldw	r2,-4(fp)
81106c50:	10001926 	beq	r2,zero,81106cb8 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106c54:	e0bfff17 	ldw	r2,-4(fp)
81106c58:	10800017 	ldw	r2,0(r2)
81106c5c:	01400444 	movi	r5,17
81106c60:	1009883a 	mov	r4,r2
81106c64:	1108e680 	call	81108e68 <uliRmapReadReg>
81106c68:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81106c6c:	e0bfff17 	ldw	r2,-4(fp)
81106c70:	10801017 	ldw	r2,64(r2)
81106c74:	10000426 	beq	r2,zero,81106c88 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81106c78:	e0bffe17 	ldw	r2,-8(fp)
81106c7c:	10800054 	ori	r2,r2,1
81106c80:	e0bffe15 	stw	r2,-8(fp)
81106c84:	00000406 	br	81106c98 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81106c88:	e0fffe17 	ldw	r3,-8(fp)
81106c8c:	00bfff84 	movi	r2,-2
81106c90:	1884703a 	and	r2,r3,r2
81106c94:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106c98:	e0bfff17 	ldw	r2,-4(fp)
81106c9c:	10800017 	ldw	r2,0(r2)
81106ca0:	e1bffe17 	ldw	r6,-8(fp)
81106ca4:	01400444 	movi	r5,17
81106ca8:	1009883a 	mov	r4,r2
81106cac:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81106cb0:	00800044 	movi	r2,1
81106cb4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106cb8:	e0bffd17 	ldw	r2,-12(fp)
}
81106cbc:	e037883a 	mov	sp,fp
81106cc0:	dfc00117 	ldw	ra,4(sp)
81106cc4:	df000017 	ldw	fp,0(sp)
81106cc8:	dec00204 	addi	sp,sp,8
81106ccc:	f800283a 	ret

81106cd0 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81106cd0:	defffb04 	addi	sp,sp,-20
81106cd4:	de00012e 	bgeu	sp,et,81106cdc <bRmapGetIrqControl+0xc>
81106cd8:	003b68fa 	trap	3
81106cdc:	dfc00415 	stw	ra,16(sp)
81106ce0:	df000315 	stw	fp,12(sp)
81106ce4:	df000304 	addi	fp,sp,12
81106ce8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106cec:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106cf0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106cf4:	e0bfff17 	ldw	r2,-4(fp)
81106cf8:	10001126 	beq	r2,zero,81106d40 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106cfc:	e0bfff17 	ldw	r2,-4(fp)
81106d00:	10800017 	ldw	r2,0(r2)
81106d04:	01400444 	movi	r5,17
81106d08:	1009883a 	mov	r4,r2
81106d0c:	1108e680 	call	81108e68 <uliRmapReadReg>
81106d10:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81106d14:	e0bffe17 	ldw	r2,-8(fp)
81106d18:	1080004c 	andi	r2,r2,1
81106d1c:	10000426 	beq	r2,zero,81106d30 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81106d20:	e0bfff17 	ldw	r2,-4(fp)
81106d24:	00c00044 	movi	r3,1
81106d28:	10c01015 	stw	r3,64(r2)
81106d2c:	00000206 	br	81106d38 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81106d30:	e0bfff17 	ldw	r2,-4(fp)
81106d34:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
81106d38:	00800044 	movi	r2,1
81106d3c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106d40:	e0bffd17 	ldw	r2,-12(fp)
}
81106d44:	e037883a 	mov	sp,fp
81106d48:	dfc00117 	ldw	ra,4(sp)
81106d4c:	df000017 	ldw	fp,0(sp)
81106d50:	dec00204 	addi	sp,sp,8
81106d54:	f800283a 	ret

81106d58 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81106d58:	defffb04 	addi	sp,sp,-20
81106d5c:	de00012e 	bgeu	sp,et,81106d64 <bRmapGetIrqFlags+0xc>
81106d60:	003b68fa 	trap	3
81106d64:	dfc00415 	stw	ra,16(sp)
81106d68:	df000315 	stw	fp,12(sp)
81106d6c:	df000304 	addi	fp,sp,12
81106d70:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106d74:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106d78:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106d7c:	e0bfff17 	ldw	r2,-4(fp)
81106d80:	10001126 	beq	r2,zero,81106dc8 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106d84:	e0bfff17 	ldw	r2,-4(fp)
81106d88:	10800017 	ldw	r2,0(r2)
81106d8c:	01400484 	movi	r5,18
81106d90:	1009883a 	mov	r4,r2
81106d94:	1108e680 	call	81108e68 <uliRmapReadReg>
81106d98:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106d9c:	e0bffe17 	ldw	r2,-8(fp)
81106da0:	1080004c 	andi	r2,r2,1
81106da4:	10000426 	beq	r2,zero,81106db8 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81106da8:	e0bfff17 	ldw	r2,-4(fp)
81106dac:	00c00044 	movi	r3,1
81106db0:	10c01115 	stw	r3,68(r2)
81106db4:	00000206 	br	81106dc0 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81106db8:	e0bfff17 	ldw	r2,-4(fp)
81106dbc:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81106dc0:	00800044 	movi	r2,1
81106dc4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106dc8:	e0bffd17 	ldw	r2,-12(fp)
}
81106dcc:	e037883a 	mov	sp,fp
81106dd0:	dfc00117 	ldw	ra,4(sp)
81106dd4:	df000017 	ldw	fp,0(sp)
81106dd8:	dec00204 	addi	sp,sp,8
81106ddc:	f800283a 	ret

81106de0 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81106de0:	defffb04 	addi	sp,sp,-20
81106de4:	de00012e 	bgeu	sp,et,81106dec <bRmapSetCodecConfig+0xc>
81106de8:	003b68fa 	trap	3
81106dec:	dfc00415 	stw	ra,16(sp)
81106df0:	df000315 	stw	fp,12(sp)
81106df4:	df000304 	addi	fp,sp,12
81106df8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106dfc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106e00:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106e04:	e0bfff17 	ldw	r2,-4(fp)
81106e08:	10002526 	beq	r2,zero,81106ea0 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106e0c:	e0bfff17 	ldw	r2,-4(fp)
81106e10:	10800017 	ldw	r2,0(r2)
81106e14:	01400104 	movi	r5,4
81106e18:	1009883a 	mov	r4,r2
81106e1c:	1108e680 	call	81108e68 <uliRmapReadReg>
81106e20:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81106e24:	e0fffe17 	ldw	r3,-8(fp)
81106e28:	00bfc004 	movi	r2,-256
81106e2c:	1884703a 	and	r2,r3,r2
81106e30:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81106e34:	e0bfff17 	ldw	r2,-4(fp)
81106e38:	10800143 	ldbu	r2,5(r2)
81106e3c:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81106e40:	e0fffe17 	ldw	r3,-8(fp)
81106e44:	1884b03a 	or	r2,r3,r2
81106e48:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81106e4c:	e0fffe17 	ldw	r3,-8(fp)
81106e50:	00bffff4 	movhi	r2,65535
81106e54:	10803fc4 	addi	r2,r2,255
81106e58:	1884703a 	and	r2,r3,r2
81106e5c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81106e60:	e0bfff17 	ldw	r2,-4(fp)
81106e64:	10800103 	ldbu	r2,4(r2)
81106e68:	10803fcc 	andi	r2,r2,255
81106e6c:	1004923a 	slli	r2,r2,8
81106e70:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81106e74:	e0fffe17 	ldw	r3,-8(fp)
81106e78:	1884b03a 	or	r2,r3,r2
81106e7c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81106e80:	e0bfff17 	ldw	r2,-4(fp)
81106e84:	10800017 	ldw	r2,0(r2)
81106e88:	e1bffe17 	ldw	r6,-8(fp)
81106e8c:	01400104 	movi	r5,4
81106e90:	1009883a 	mov	r4,r2
81106e94:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81106e98:	00800044 	movi	r2,1
81106e9c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106ea0:	e0bffd17 	ldw	r2,-12(fp)
}
81106ea4:	e037883a 	mov	sp,fp
81106ea8:	dfc00117 	ldw	ra,4(sp)
81106eac:	df000017 	ldw	fp,0(sp)
81106eb0:	dec00204 	addi	sp,sp,8
81106eb4:	f800283a 	ret

81106eb8 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81106eb8:	defffb04 	addi	sp,sp,-20
81106ebc:	de00012e 	bgeu	sp,et,81106ec4 <bRmapGetCodecConfig+0xc>
81106ec0:	003b68fa 	trap	3
81106ec4:	dfc00415 	stw	ra,16(sp)
81106ec8:	df000315 	stw	fp,12(sp)
81106ecc:	df000304 	addi	fp,sp,12
81106ed0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106ed4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106ed8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106edc:	e0bfff17 	ldw	r2,-4(fp)
81106ee0:	10001226 	beq	r2,zero,81106f2c <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106ee4:	e0bfff17 	ldw	r2,-4(fp)
81106ee8:	10800017 	ldw	r2,0(r2)
81106eec:	01400104 	movi	r5,4
81106ef0:	1009883a 	mov	r4,r2
81106ef4:	1108e680 	call	81108e68 <uliRmapReadReg>
81106ef8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81106efc:	e0bffe17 	ldw	r2,-8(fp)
81106f00:	1007883a 	mov	r3,r2
81106f04:	e0bfff17 	ldw	r2,-4(fp)
81106f08:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81106f0c:	e0bffe17 	ldw	r2,-8(fp)
81106f10:	10bfc00c 	andi	r2,r2,65280
81106f14:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81106f18:	1007883a 	mov	r3,r2
81106f1c:	e0bfff17 	ldw	r2,-4(fp)
81106f20:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81106f24:	00800044 	movi	r2,1
81106f28:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106f2c:	e0bffd17 	ldw	r2,-12(fp)
}
81106f30:	e037883a 	mov	sp,fp
81106f34:	dfc00117 	ldw	ra,4(sp)
81106f38:	df000017 	ldw	fp,0(sp)
81106f3c:	dec00204 	addi	sp,sp,8
81106f40:	f800283a 	ret

81106f44 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81106f44:	defffb04 	addi	sp,sp,-20
81106f48:	de00012e 	bgeu	sp,et,81106f50 <bRmapGetCodecStatus+0xc>
81106f4c:	003b68fa 	trap	3
81106f50:	dfc00415 	stw	ra,16(sp)
81106f54:	df000315 	stw	fp,12(sp)
81106f58:	df000304 	addi	fp,sp,12
81106f5c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106f60:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106f64:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106f68:	e0bfff17 	ldw	r2,-4(fp)
81106f6c:	10004726 	beq	r2,zero,8110708c <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106f70:	e0bfff17 	ldw	r2,-4(fp)
81106f74:	10800017 	ldw	r2,0(r2)
81106f78:	01400144 	movi	r5,5
81106f7c:	1009883a 	mov	r4,r2
81106f80:	1108e680 	call	81108e68 <uliRmapReadReg>
81106f84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81106f88:	e0bffe17 	ldw	r2,-8(fp)
81106f8c:	1080004c 	andi	r2,r2,1
81106f90:	10000426 	beq	r2,zero,81106fa4 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81106f94:	e0bfff17 	ldw	r2,-4(fp)
81106f98:	00c00044 	movi	r3,1
81106f9c:	10c00215 	stw	r3,8(r2)
81106fa0:	00000206 	br	81106fac <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81106fa4:	e0bfff17 	ldw	r2,-4(fp)
81106fa8:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81106fac:	e0bffe17 	ldw	r2,-8(fp)
81106fb0:	1080008c 	andi	r2,r2,2
81106fb4:	10000426 	beq	r2,zero,81106fc8 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81106fb8:	e0bfff17 	ldw	r2,-4(fp)
81106fbc:	00c00044 	movi	r3,1
81106fc0:	10c00315 	stw	r3,12(r2)
81106fc4:	00000206 	br	81106fd0 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81106fc8:	e0bfff17 	ldw	r2,-4(fp)
81106fcc:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81106fd0:	e0bffe17 	ldw	r2,-8(fp)
81106fd4:	1080010c 	andi	r2,r2,4
81106fd8:	10000426 	beq	r2,zero,81106fec <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81106fdc:	e0bfff17 	ldw	r2,-4(fp)
81106fe0:	00c00044 	movi	r3,1
81106fe4:	10c00415 	stw	r3,16(r2)
81106fe8:	00000206 	br	81106ff4 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81106fec:	e0bfff17 	ldw	r2,-4(fp)
81106ff0:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81106ff4:	e0bffe17 	ldw	r2,-8(fp)
81106ff8:	1080020c 	andi	r2,r2,8
81106ffc:	10000426 	beq	r2,zero,81107010 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107000:	e0bfff17 	ldw	r2,-4(fp)
81107004:	00c00044 	movi	r3,1
81107008:	10c00515 	stw	r3,20(r2)
8110700c:	00000206 	br	81107018 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107010:	e0bfff17 	ldw	r2,-4(fp)
81107014:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107018:	e0bffe17 	ldw	r2,-8(fp)
8110701c:	1080040c 	andi	r2,r2,16
81107020:	10000426 	beq	r2,zero,81107034 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107024:	e0bfff17 	ldw	r2,-4(fp)
81107028:	00c00044 	movi	r3,1
8110702c:	10c00615 	stw	r3,24(r2)
81107030:	00000206 	br	8110703c <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107034:	e0bfff17 	ldw	r2,-4(fp)
81107038:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
8110703c:	e0bffe17 	ldw	r2,-8(fp)
81107040:	1080080c 	andi	r2,r2,32
81107044:	10000426 	beq	r2,zero,81107058 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107048:	e0bfff17 	ldw	r2,-4(fp)
8110704c:	00c00044 	movi	r3,1
81107050:	10c00715 	stw	r3,28(r2)
81107054:	00000206 	br	81107060 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107058:	e0bfff17 	ldw	r2,-4(fp)
8110705c:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81107060:	e0bffe17 	ldw	r2,-8(fp)
81107064:	1080100c 	andi	r2,r2,64
81107068:	10000426 	beq	r2,zero,8110707c <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
8110706c:	e0bfff17 	ldw	r2,-4(fp)
81107070:	00c00044 	movi	r3,1
81107074:	10c00815 	stw	r3,32(r2)
81107078:	00000206 	br	81107084 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
8110707c:	e0bfff17 	ldw	r2,-4(fp)
81107080:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107084:	00800044 	movi	r2,1
81107088:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110708c:	e0bffd17 	ldw	r2,-12(fp)
}
81107090:	e037883a 	mov	sp,fp
81107094:	dfc00117 	ldw	ra,4(sp)
81107098:	df000017 	ldw	fp,0(sp)
8110709c:	dec00204 	addi	sp,sp,8
811070a0:	f800283a 	ret

811070a4 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
811070a4:	defffb04 	addi	sp,sp,-20
811070a8:	de00012e 	bgeu	sp,et,811070b0 <bRmapGetCodecError+0xc>
811070ac:	003b68fa 	trap	3
811070b0:	dfc00415 	stw	ra,16(sp)
811070b4:	df000315 	stw	fp,12(sp)
811070b8:	df000304 	addi	fp,sp,12
811070bc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811070c0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811070c4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811070c8:	e0bfff17 	ldw	r2,-4(fp)
811070cc:	10004726 	beq	r2,zero,811071ec <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811070d0:	e0bfff17 	ldw	r2,-4(fp)
811070d4:	10800017 	ldw	r2,0(r2)
811070d8:	01400144 	movi	r5,5
811070dc:	1009883a 	mov	r4,r2
811070e0:	1108e680 	call	81108e68 <uliRmapReadReg>
811070e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
811070e8:	e0bffe17 	ldw	r2,-8(fp)
811070ec:	1080006c 	andhi	r2,r2,1
811070f0:	10000426 	beq	r2,zero,81107104 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
811070f4:	e0bfff17 	ldw	r2,-4(fp)
811070f8:	00c00044 	movi	r3,1
811070fc:	10c00915 	stw	r3,36(r2)
81107100:	00000206 	br	8110710c <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107104:	e0bfff17 	ldw	r2,-4(fp)
81107108:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
8110710c:	e0bffe17 	ldw	r2,-8(fp)
81107110:	108000ac 	andhi	r2,r2,2
81107114:	10000426 	beq	r2,zero,81107128 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107118:	e0bfff17 	ldw	r2,-4(fp)
8110711c:	00c00044 	movi	r3,1
81107120:	10c00a15 	stw	r3,40(r2)
81107124:	00000206 	br	81107130 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107128:	e0bfff17 	ldw	r2,-4(fp)
8110712c:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81107130:	e0bffe17 	ldw	r2,-8(fp)
81107134:	1080012c 	andhi	r2,r2,4
81107138:	10000426 	beq	r2,zero,8110714c <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
8110713c:	e0bfff17 	ldw	r2,-4(fp)
81107140:	00c00044 	movi	r3,1
81107144:	10c00b15 	stw	r3,44(r2)
81107148:	00000206 	br	81107154 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
8110714c:	e0bfff17 	ldw	r2,-4(fp)
81107150:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107154:	e0bffe17 	ldw	r2,-8(fp)
81107158:	1080022c 	andhi	r2,r2,8
8110715c:	10000426 	beq	r2,zero,81107170 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81107160:	e0bfff17 	ldw	r2,-4(fp)
81107164:	00c00044 	movi	r3,1
81107168:	10c00c15 	stw	r3,48(r2)
8110716c:	00000206 	br	81107178 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81107170:	e0bfff17 	ldw	r2,-4(fp)
81107174:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107178:	e0bffe17 	ldw	r2,-8(fp)
8110717c:	1080042c 	andhi	r2,r2,16
81107180:	10000426 	beq	r2,zero,81107194 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107184:	e0bfff17 	ldw	r2,-4(fp)
81107188:	00c00044 	movi	r3,1
8110718c:	10c00d15 	stw	r3,52(r2)
81107190:	00000206 	br	8110719c <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107194:	e0bfff17 	ldw	r2,-4(fp)
81107198:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
8110719c:	e0bffe17 	ldw	r2,-8(fp)
811071a0:	1080082c 	andhi	r2,r2,32
811071a4:	10000426 	beq	r2,zero,811071b8 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
811071a8:	e0bfff17 	ldw	r2,-4(fp)
811071ac:	00c00044 	movi	r3,1
811071b0:	10c00e15 	stw	r3,56(r2)
811071b4:	00000206 	br	811071c0 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
811071b8:	e0bfff17 	ldw	r2,-4(fp)
811071bc:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
811071c0:	e0bffe17 	ldw	r2,-8(fp)
811071c4:	1080102c 	andhi	r2,r2,64
811071c8:	10000426 	beq	r2,zero,811071dc <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
811071cc:	e0bfff17 	ldw	r2,-4(fp)
811071d0:	00c00044 	movi	r3,1
811071d4:	10c00f15 	stw	r3,60(r2)
811071d8:	00000206 	br	811071e4 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
811071dc:	e0bfff17 	ldw	r2,-4(fp)
811071e0:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
811071e4:	00800044 	movi	r2,1
811071e8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811071ec:	e0bffd17 	ldw	r2,-12(fp)
}
811071f0:	e037883a 	mov	sp,fp
811071f4:	dfc00117 	ldw	ra,4(sp)
811071f8:	df000017 	ldw	fp,0(sp)
811071fc:	dec00204 	addi	sp,sp,8
81107200:	f800283a 	ret

81107204 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107204:	defffb04 	addi	sp,sp,-20
81107208:	de00012e 	bgeu	sp,et,81107210 <bRmapSetMemConfigArea+0xc>
8110720c:	003b68fa 	trap	3
81107210:	dfc00415 	stw	ra,16(sp)
81107214:	df000315 	stw	fp,12(sp)
81107218:	df000304 	addi	fp,sp,12
8110721c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107220:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107224:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107228:	e0bfff17 	ldw	r2,-4(fp)
8110722c:	1000aa26 	beq	r2,zero,811074d8 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81107230:	e0bfff17 	ldw	r2,-4(fp)
81107234:	10801217 	ldw	r2,72(r2)
81107238:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110723c:	e0bfff17 	ldw	r2,-4(fp)
81107240:	10800017 	ldw	r2,0(r2)
81107244:	e1bffe17 	ldw	r6,-8(fp)
81107248:	01401004 	movi	r5,64
8110724c:	1009883a 	mov	r4,r2
81107250:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107254:	e0bfff17 	ldw	r2,-4(fp)
81107258:	10801317 	ldw	r2,76(r2)
8110725c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107260:	e0bfff17 	ldw	r2,-4(fp)
81107264:	10800017 	ldw	r2,0(r2)
81107268:	e1bffe17 	ldw	r6,-8(fp)
8110726c:	01401044 	movi	r5,65
81107270:	1009883a 	mov	r4,r2
81107274:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81107278:	e0bfff17 	ldw	r2,-4(fp)
8110727c:	10801417 	ldw	r2,80(r2)
81107280:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107284:	e0bfff17 	ldw	r2,-4(fp)
81107288:	10800017 	ldw	r2,0(r2)
8110728c:	e1bffe17 	ldw	r6,-8(fp)
81107290:	01401084 	movi	r5,66
81107294:	1009883a 	mov	r4,r2
81107298:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
8110729c:	e0bfff17 	ldw	r2,-4(fp)
811072a0:	10801517 	ldw	r2,84(r2)
811072a4:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811072a8:	e0bfff17 	ldw	r2,-4(fp)
811072ac:	10800017 	ldw	r2,0(r2)
811072b0:	e1bffe17 	ldw	r6,-8(fp)
811072b4:	014010c4 	movi	r5,67
811072b8:	1009883a 	mov	r4,r2
811072bc:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811072c0:	e0bfff17 	ldw	r2,-4(fp)
811072c4:	10802217 	ldw	r2,136(r2)
811072c8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811072cc:	e0bfff17 	ldw	r2,-4(fp)
811072d0:	10800017 	ldw	r2,0(r2)
811072d4:	e1bffe17 	ldw	r6,-8(fp)
811072d8:	01401104 	movi	r5,68
811072dc:	1009883a 	mov	r4,r2
811072e0:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
811072e4:	e0bfff17 	ldw	r2,-4(fp)
811072e8:	10801717 	ldw	r2,92(r2)
811072ec:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811072f0:	e0bfff17 	ldw	r2,-4(fp)
811072f4:	10800017 	ldw	r2,0(r2)
811072f8:	e1bffe17 	ldw	r6,-8(fp)
811072fc:	01401144 	movi	r5,69
81107300:	1009883a 	mov	r4,r2
81107304:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107308:	e0bfff17 	ldw	r2,-4(fp)
8110730c:	10801817 	ldw	r2,96(r2)
81107310:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107314:	e0bfff17 	ldw	r2,-4(fp)
81107318:	10800017 	ldw	r2,0(r2)
8110731c:	e1bffe17 	ldw	r6,-8(fp)
81107320:	01401184 	movi	r5,70
81107324:	1009883a 	mov	r4,r2
81107328:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
8110732c:	e0bfff17 	ldw	r2,-4(fp)
81107330:	10801917 	ldw	r2,100(r2)
81107334:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107338:	e0bfff17 	ldw	r2,-4(fp)
8110733c:	10800017 	ldw	r2,0(r2)
81107340:	e1bffe17 	ldw	r6,-8(fp)
81107344:	014011c4 	movi	r5,71
81107348:	1009883a 	mov	r4,r2
8110734c:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107350:	e0bfff17 	ldw	r2,-4(fp)
81107354:	10801a17 	ldw	r2,104(r2)
81107358:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110735c:	e0bfff17 	ldw	r2,-4(fp)
81107360:	10800017 	ldw	r2,0(r2)
81107364:	e1bffe17 	ldw	r6,-8(fp)
81107368:	01401204 	movi	r5,72
8110736c:	1009883a 	mov	r4,r2
81107370:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81107374:	e0bfff17 	ldw	r2,-4(fp)
81107378:	10801b17 	ldw	r2,108(r2)
8110737c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107380:	e0bfff17 	ldw	r2,-4(fp)
81107384:	10800017 	ldw	r2,0(r2)
81107388:	e1bffe17 	ldw	r6,-8(fp)
8110738c:	01401244 	movi	r5,73
81107390:	1009883a 	mov	r4,r2
81107394:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107398:	e0bfff17 	ldw	r2,-4(fp)
8110739c:	10800017 	ldw	r2,0(r2)
811073a0:	01401284 	movi	r5,74
811073a4:	1009883a 	mov	r4,r2
811073a8:	1108e680 	call	81108e68 <uliRmapReadReg>
811073ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
811073b0:	e0bfff17 	ldw	r2,-4(fp)
811073b4:	10801c17 	ldw	r2,112(r2)
811073b8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811073bc:	e0bfff17 	ldw	r2,-4(fp)
811073c0:	10800017 	ldw	r2,0(r2)
811073c4:	e1bffe17 	ldw	r6,-8(fp)
811073c8:	01401284 	movi	r5,74
811073cc:	1009883a 	mov	r4,r2
811073d0:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
811073d4:	e0bfff17 	ldw	r2,-4(fp)
811073d8:	10801d17 	ldw	r2,116(r2)
811073dc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811073e0:	e0bfff17 	ldw	r2,-4(fp)
811073e4:	10800017 	ldw	r2,0(r2)
811073e8:	e1bffe17 	ldw	r6,-8(fp)
811073ec:	014012c4 	movi	r5,75
811073f0:	1009883a 	mov	r4,r2
811073f4:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
811073f8:	e0bfff17 	ldw	r2,-4(fp)
811073fc:	10801e17 	ldw	r2,120(r2)
81107400:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81107404:	e0bfff17 	ldw	r2,-4(fp)
81107408:	10800017 	ldw	r2,0(r2)
8110740c:	e1bffe17 	ldw	r6,-8(fp)
81107410:	01401304 	movi	r5,76
81107414:	1009883a 	mov	r4,r2
81107418:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
8110741c:	e0bfff17 	ldw	r2,-4(fp)
81107420:	10801f17 	ldw	r2,124(r2)
81107424:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81107428:	e0bfff17 	ldw	r2,-4(fp)
8110742c:	10800017 	ldw	r2,0(r2)
81107430:	e1bffe17 	ldw	r6,-8(fp)
81107434:	01401344 	movi	r5,77
81107438:	1009883a 	mov	r4,r2
8110743c:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81107440:	e0bfff17 	ldw	r2,-4(fp)
81107444:	10802017 	ldw	r2,128(r2)
81107448:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
8110744c:	e0bfff17 	ldw	r2,-4(fp)
81107450:	10800017 	ldw	r2,0(r2)
81107454:	e1bffe17 	ldw	r6,-8(fp)
81107458:	01401384 	movi	r5,78
8110745c:	1009883a 	mov	r4,r2
81107460:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107464:	e0bfff17 	ldw	r2,-4(fp)
81107468:	10802217 	ldw	r2,136(r2)
8110746c:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107470:	e0bfff17 	ldw	r2,-4(fp)
81107474:	10800017 	ldw	r2,0(r2)
81107478:	e1bffe17 	ldw	r6,-8(fp)
8110747c:	014013c4 	movi	r5,79
81107480:	1009883a 	mov	r4,r2
81107484:	1108e140 	call	81108e14 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107488:	e0bfff17 	ldw	r2,-4(fp)
8110748c:	10802217 	ldw	r2,136(r2)
81107490:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81107494:	e0bfff17 	ldw	r2,-4(fp)
81107498:	10800017 	ldw	r2,0(r2)
8110749c:	e1bffe17 	ldw	r6,-8(fp)
811074a0:	01401404 	movi	r5,80
811074a4:	1009883a 	mov	r4,r2
811074a8:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
811074ac:	e0bfff17 	ldw	r2,-4(fp)
811074b0:	10802317 	ldw	r2,140(r2)
811074b4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
811074b8:	e0bfff17 	ldw	r2,-4(fp)
811074bc:	10800017 	ldw	r2,0(r2)
811074c0:	e1bffe17 	ldw	r6,-8(fp)
811074c4:	01401444 	movi	r5,81
811074c8:	1009883a 	mov	r4,r2
811074cc:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
811074d0:	00800044 	movi	r2,1
811074d4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811074d8:	e0bffd17 	ldw	r2,-12(fp)
}
811074dc:	e037883a 	mov	sp,fp
811074e0:	dfc00117 	ldw	ra,4(sp)
811074e4:	df000017 	ldw	fp,0(sp)
811074e8:	dec00204 	addi	sp,sp,8
811074ec:	f800283a 	ret

811074f0 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
811074f0:	defffb04 	addi	sp,sp,-20
811074f4:	de00012e 	bgeu	sp,et,811074fc <bRmapGetMemConfigArea+0xc>
811074f8:	003b68fa 	trap	3
811074fc:	dfc00415 	stw	ra,16(sp)
81107500:	df000315 	stw	fp,12(sp)
81107504:	df000304 	addi	fp,sp,12
81107508:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110750c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107510:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107514:	e0bfff17 	ldw	r2,-4(fp)
81107518:	1000a426 	beq	r2,zero,811077ac <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110751c:	e0bfff17 	ldw	r2,-4(fp)
81107520:	10800017 	ldw	r2,0(r2)
81107524:	01401004 	movi	r5,64
81107528:	1009883a 	mov	r4,r2
8110752c:	1108e680 	call	81108e68 <uliRmapReadReg>
81107530:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
81107534:	e0bfff17 	ldw	r2,-4(fp)
81107538:	e0fffe17 	ldw	r3,-8(fp)
8110753c:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107540:	e0bfff17 	ldw	r2,-4(fp)
81107544:	10800017 	ldw	r2,0(r2)
81107548:	01401044 	movi	r5,65
8110754c:	1009883a 	mov	r4,r2
81107550:	1108e680 	call	81108e68 <uliRmapReadReg>
81107554:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
81107558:	e0bfff17 	ldw	r2,-4(fp)
8110755c:	e0fffe17 	ldw	r3,-8(fp)
81107560:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107564:	e0bfff17 	ldw	r2,-4(fp)
81107568:	10800017 	ldw	r2,0(r2)
8110756c:	01401084 	movi	r5,66
81107570:	1009883a 	mov	r4,r2
81107574:	1108e680 	call	81108e68 <uliRmapReadReg>
81107578:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
8110757c:	e0bfff17 	ldw	r2,-4(fp)
81107580:	e0fffe17 	ldw	r3,-8(fp)
81107584:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107588:	e0bfff17 	ldw	r2,-4(fp)
8110758c:	10800017 	ldw	r2,0(r2)
81107590:	014010c4 	movi	r5,67
81107594:	1009883a 	mov	r4,r2
81107598:	1108e680 	call	81108e68 <uliRmapReadReg>
8110759c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
811075a0:	e0bfff17 	ldw	r2,-4(fp)
811075a4:	e0fffe17 	ldw	r3,-8(fp)
811075a8:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075ac:	e0bfff17 	ldw	r2,-4(fp)
811075b0:	10800017 	ldw	r2,0(r2)
811075b4:	01401104 	movi	r5,68
811075b8:	1009883a 	mov	r4,r2
811075bc:	1108e680 	call	81108e68 <uliRmapReadReg>
811075c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811075c4:	e0bfff17 	ldw	r2,-4(fp)
811075c8:	e0fffe17 	ldw	r3,-8(fp)
811075cc:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075d0:	e0bfff17 	ldw	r2,-4(fp)
811075d4:	10800017 	ldw	r2,0(r2)
811075d8:	01401144 	movi	r5,69
811075dc:	1009883a 	mov	r4,r2
811075e0:	1108e680 	call	81108e68 <uliRmapReadReg>
811075e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
811075e8:	e0bfff17 	ldw	r2,-4(fp)
811075ec:	e0fffe17 	ldw	r3,-8(fp)
811075f0:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075f4:	e0bfff17 	ldw	r2,-4(fp)
811075f8:	10800017 	ldw	r2,0(r2)
811075fc:	01401184 	movi	r5,70
81107600:	1009883a 	mov	r4,r2
81107604:	1108e680 	call	81108e68 <uliRmapReadReg>
81107608:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
8110760c:	e0bfff17 	ldw	r2,-4(fp)
81107610:	e0fffe17 	ldw	r3,-8(fp)
81107614:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107618:	e0bfff17 	ldw	r2,-4(fp)
8110761c:	10800017 	ldw	r2,0(r2)
81107620:	014011c4 	movi	r5,71
81107624:	1009883a 	mov	r4,r2
81107628:	1108e680 	call	81108e68 <uliRmapReadReg>
8110762c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
81107630:	e0bfff17 	ldw	r2,-4(fp)
81107634:	e0fffe17 	ldw	r3,-8(fp)
81107638:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110763c:	e0bfff17 	ldw	r2,-4(fp)
81107640:	10800017 	ldw	r2,0(r2)
81107644:	01401204 	movi	r5,72
81107648:	1009883a 	mov	r4,r2
8110764c:	1108e680 	call	81108e68 <uliRmapReadReg>
81107650:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
81107654:	e0bfff17 	ldw	r2,-4(fp)
81107658:	e0fffe17 	ldw	r3,-8(fp)
8110765c:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107660:	e0bfff17 	ldw	r2,-4(fp)
81107664:	10800017 	ldw	r2,0(r2)
81107668:	01401244 	movi	r5,73
8110766c:	1009883a 	mov	r4,r2
81107670:	1108e680 	call	81108e68 <uliRmapReadReg>
81107674:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
81107678:	e0bfff17 	ldw	r2,-4(fp)
8110767c:	e0fffe17 	ldw	r3,-8(fp)
81107680:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107684:	e0bfff17 	ldw	r2,-4(fp)
81107688:	10800017 	ldw	r2,0(r2)
8110768c:	01401284 	movi	r5,74
81107690:	1009883a 	mov	r4,r2
81107694:	1108e680 	call	81108e68 <uliRmapReadReg>
81107698:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
8110769c:	e0bfff17 	ldw	r2,-4(fp)
811076a0:	e0fffe17 	ldw	r3,-8(fp)
811076a4:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076a8:	e0bfff17 	ldw	r2,-4(fp)
811076ac:	10800017 	ldw	r2,0(r2)
811076b0:	014012c4 	movi	r5,75
811076b4:	1009883a 	mov	r4,r2
811076b8:	1108e680 	call	81108e68 <uliRmapReadReg>
811076bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
811076c0:	e0bfff17 	ldw	r2,-4(fp)
811076c4:	e0fffe17 	ldw	r3,-8(fp)
811076c8:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076cc:	e0bfff17 	ldw	r2,-4(fp)
811076d0:	10800017 	ldw	r2,0(r2)
811076d4:	01401304 	movi	r5,76
811076d8:	1009883a 	mov	r4,r2
811076dc:	1108e680 	call	81108e68 <uliRmapReadReg>
811076e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
811076e4:	e0bfff17 	ldw	r2,-4(fp)
811076e8:	e0fffe17 	ldw	r3,-8(fp)
811076ec:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076f0:	e0bfff17 	ldw	r2,-4(fp)
811076f4:	10800017 	ldw	r2,0(r2)
811076f8:	01401344 	movi	r5,77
811076fc:	1009883a 	mov	r4,r2
81107700:	1108e680 	call	81108e68 <uliRmapReadReg>
81107704:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81107708:	e0bfff17 	ldw	r2,-4(fp)
8110770c:	e0fffe17 	ldw	r3,-8(fp)
81107710:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107714:	e0bfff17 	ldw	r2,-4(fp)
81107718:	10800017 	ldw	r2,0(r2)
8110771c:	01401384 	movi	r5,78
81107720:	1009883a 	mov	r4,r2
81107724:	1108e680 	call	81108e68 <uliRmapReadReg>
81107728:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
8110772c:	e0bfff17 	ldw	r2,-4(fp)
81107730:	e0fffe17 	ldw	r3,-8(fp)
81107734:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107738:	e0bfff17 	ldw	r2,-4(fp)
8110773c:	10800017 	ldw	r2,0(r2)
81107740:	014013c4 	movi	r5,79
81107744:	1009883a 	mov	r4,r2
81107748:	1108e680 	call	81108e68 <uliRmapReadReg>
8110774c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107750:	e0bfff17 	ldw	r2,-4(fp)
81107754:	e0fffe17 	ldw	r3,-8(fp)
81107758:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110775c:	e0bfff17 	ldw	r2,-4(fp)
81107760:	10800017 	ldw	r2,0(r2)
81107764:	01401404 	movi	r5,80
81107768:	1009883a 	mov	r4,r2
8110776c:	1108e680 	call	81108e68 <uliRmapReadReg>
81107770:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107774:	e0bfff17 	ldw	r2,-4(fp)
81107778:	e0fffe17 	ldw	r3,-8(fp)
8110777c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107780:	e0bfff17 	ldw	r2,-4(fp)
81107784:	10800017 	ldw	r2,0(r2)
81107788:	01401444 	movi	r5,81
8110778c:	1009883a 	mov	r4,r2
81107790:	1108e680 	call	81108e68 <uliRmapReadReg>
81107794:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81107798:	e0bfff17 	ldw	r2,-4(fp)
8110779c:	e0fffe17 	ldw	r3,-8(fp)
811077a0:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
811077a4:	00800044 	movi	r2,1
811077a8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811077ac:	e0bffd17 	ldw	r2,-12(fp)
}
811077b0:	e037883a 	mov	sp,fp
811077b4:	dfc00117 	ldw	ra,4(sp)
811077b8:	df000017 	ldw	fp,0(sp)
811077bc:	dec00204 	addi	sp,sp,8
811077c0:	f800283a 	ret

811077c4 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
811077c4:	defffb04 	addi	sp,sp,-20
811077c8:	de00012e 	bgeu	sp,et,811077d0 <bRmapGetMemConfigStat+0xc>
811077cc:	003b68fa 	trap	3
811077d0:	dfc00415 	stw	ra,16(sp)
811077d4:	df000315 	stw	fp,12(sp)
811077d8:	df000304 	addi	fp,sp,12
811077dc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811077e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811077e4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811077e8:	e0bfff17 	ldw	r2,-4(fp)
811077ec:	10001426 	beq	r2,zero,81107840 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077f0:	e0bfff17 	ldw	r2,-4(fp)
811077f4:	10800017 	ldw	r2,0(r2)
811077f8:	014001c4 	movi	r5,7
811077fc:	1009883a 	mov	r4,r2
81107800:	1108e680 	call	81108e68 <uliRmapReadReg>
81107804:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81107808:	e0bfff17 	ldw	r2,-4(fp)
8110780c:	e0fffe17 	ldw	r3,-8(fp)
81107810:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107814:	e0bfff17 	ldw	r2,-4(fp)
81107818:	10800017 	ldw	r2,0(r2)
8110781c:	01400184 	movi	r5,6
81107820:	1009883a 	mov	r4,r2
81107824:	1108e680 	call	81108e68 <uliRmapReadReg>
81107828:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
8110782c:	e0bfff17 	ldw	r2,-4(fp)
81107830:	e0fffe17 	ldw	r3,-8(fp)
81107834:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
81107838:	00800044 	movi	r2,1
8110783c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107840:	e0bffd17 	ldw	r2,-12(fp)
}
81107844:	e037883a 	mov	sp,fp
81107848:	dfc00117 	ldw	ra,4(sp)
8110784c:	df000017 	ldw	fp,0(sp)
81107850:	dec00204 	addi	sp,sp,8
81107854:	f800283a 	ret

81107858 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81107858:	defffb04 	addi	sp,sp,-20
8110785c:	de00012e 	bgeu	sp,et,81107864 <bRmapSetRmapMemHKArea+0xc>
81107860:	003b68fa 	trap	3
81107864:	dfc00415 	stw	ra,16(sp)
81107868:	df000315 	stw	fp,12(sp)
8110786c:	df000304 	addi	fp,sp,12
81107870:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107874:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107878:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110787c:	e0bfff17 	ldw	r2,-4(fp)
81107880:	10030226 	beq	r2,zero,8110848c <bRmapSetRmapMemHKArea+0xc34>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107884:	e0bfff17 	ldw	r2,-4(fp)
81107888:	10800017 	ldw	r2,0(r2)
8110788c:	01402804 	movi	r5,160
81107890:	1009883a 	mov	r4,r2
81107894:	1108e680 	call	81108e68 <uliRmapReadReg>
81107898:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
8110789c:	e0bffe17 	ldw	r2,-8(fp)
811078a0:	10bfffec 	andhi	r2,r2,65535
811078a4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
811078a8:	e0bfff17 	ldw	r2,-4(fp)
811078ac:	1080260b 	ldhu	r2,152(r2)
811078b0:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
811078b4:	e0fffe17 	ldw	r3,-8(fp)
811078b8:	1884b03a 	or	r2,r3,r2
811078bc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
811078c0:	e0bffe17 	ldw	r2,-8(fp)
811078c4:	10bfffcc 	andi	r2,r2,65535
811078c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
811078cc:	e0bfff17 	ldw	r2,-4(fp)
811078d0:	10800017 	ldw	r2,0(r2)
811078d4:	e1bffe17 	ldw	r6,-8(fp)
811078d8:	01402804 	movi	r5,160
811078dc:	1009883a 	mov	r4,r2
811078e0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078e4:	e0bfff17 	ldw	r2,-4(fp)
811078e8:	10800017 	ldw	r2,0(r2)
811078ec:	01402844 	movi	r5,161
811078f0:	1009883a 	mov	r4,r2
811078f4:	1108e680 	call	81108e68 <uliRmapReadReg>
811078f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
811078fc:	e0bffe17 	ldw	r2,-8(fp)
81107900:	10bfffec 	andhi	r2,r2,65535
81107904:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
81107908:	e0bfff17 	ldw	r2,-4(fp)
8110790c:	1080270b 	ldhu	r2,156(r2)
81107910:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
81107914:	e0fffe17 	ldw	r3,-8(fp)
81107918:	1884b03a 	or	r2,r3,r2
8110791c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
81107920:	e0bffe17 	ldw	r2,-8(fp)
81107924:	10bfffcc 	andi	r2,r2,65535
81107928:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
8110792c:	e0bfff17 	ldw	r2,-4(fp)
81107930:	10800017 	ldw	r2,0(r2)
81107934:	e1bffe17 	ldw	r6,-8(fp)
81107938:	01402844 	movi	r5,161
8110793c:	1009883a 	mov	r4,r2
81107940:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107944:	e0bfff17 	ldw	r2,-4(fp)
81107948:	10800017 	ldw	r2,0(r2)
8110794c:	01402884 	movi	r5,162
81107950:	1009883a 	mov	r4,r2
81107954:	1108e680 	call	81108e68 <uliRmapReadReg>
81107958:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
8110795c:	e0bffe17 	ldw	r2,-8(fp)
81107960:	10bfffec 	andhi	r2,r2,65535
81107964:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81107968:	e0bfff17 	ldw	r2,-4(fp)
8110796c:	1080280b 	ldhu	r2,160(r2)
81107970:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81107974:	e0fffe17 	ldw	r3,-8(fp)
81107978:	1884b03a 	or	r2,r3,r2
8110797c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81107980:	e0bffe17 	ldw	r2,-8(fp)
81107984:	10bfffcc 	andi	r2,r2,65535
81107988:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
8110798c:	e0bfff17 	ldw	r2,-4(fp)
81107990:	10800017 	ldw	r2,0(r2)
81107994:	e1bffe17 	ldw	r6,-8(fp)
81107998:	01402884 	movi	r5,162
8110799c:	1009883a 	mov	r4,r2
811079a0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079a4:	e0bfff17 	ldw	r2,-4(fp)
811079a8:	10800017 	ldw	r2,0(r2)
811079ac:	014028c4 	movi	r5,163
811079b0:	1009883a 	mov	r4,r2
811079b4:	1108e680 	call	81108e68 <uliRmapReadReg>
811079b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
811079bc:	e0bffe17 	ldw	r2,-8(fp)
811079c0:	10bfffec 	andhi	r2,r2,65535
811079c4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
811079c8:	e0bfff17 	ldw	r2,-4(fp)
811079cc:	1080290b 	ldhu	r2,164(r2)
811079d0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
811079d4:	e0fffe17 	ldw	r3,-8(fp)
811079d8:	1884b03a 	or	r2,r3,r2
811079dc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
811079e0:	e0bffe17 	ldw	r2,-8(fp)
811079e4:	10bfffcc 	andi	r2,r2,65535
811079e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
811079ec:	e0bfff17 	ldw	r2,-4(fp)
811079f0:	10800017 	ldw	r2,0(r2)
811079f4:	e1bffe17 	ldw	r6,-8(fp)
811079f8:	014028c4 	movi	r5,163
811079fc:	1009883a 	mov	r4,r2
81107a00:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a04:	e0bfff17 	ldw	r2,-4(fp)
81107a08:	10800017 	ldw	r2,0(r2)
81107a0c:	01402904 	movi	r5,164
81107a10:	1009883a 	mov	r4,r2
81107a14:	1108e680 	call	81108e68 <uliRmapReadReg>
81107a18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81107a1c:	e0bffe17 	ldw	r2,-8(fp)
81107a20:	10bfffec 	andhi	r2,r2,65535
81107a24:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
81107a28:	e0bfff17 	ldw	r2,-4(fp)
81107a2c:	10802a0b 	ldhu	r2,168(r2)
81107a30:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81107a34:	e0fffe17 	ldw	r3,-8(fp)
81107a38:	1884b03a 	or	r2,r3,r2
81107a3c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81107a40:	e0bffe17 	ldw	r2,-8(fp)
81107a44:	10bfffcc 	andi	r2,r2,65535
81107a48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81107a4c:	e0bfff17 	ldw	r2,-4(fp)
81107a50:	10800017 	ldw	r2,0(r2)
81107a54:	e1bffe17 	ldw	r6,-8(fp)
81107a58:	01402904 	movi	r5,164
81107a5c:	1009883a 	mov	r4,r2
81107a60:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a64:	e0bfff17 	ldw	r2,-4(fp)
81107a68:	10800017 	ldw	r2,0(r2)
81107a6c:	01402944 	movi	r5,165
81107a70:	1009883a 	mov	r4,r2
81107a74:	1108e680 	call	81108e68 <uliRmapReadReg>
81107a78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81107a7c:	e0bffe17 	ldw	r2,-8(fp)
81107a80:	10bfffec 	andhi	r2,r2,65535
81107a84:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81107a88:	e0bfff17 	ldw	r2,-4(fp)
81107a8c:	10802b0b 	ldhu	r2,172(r2)
81107a90:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
81107a94:	e0fffe17 	ldw	r3,-8(fp)
81107a98:	1884b03a 	or	r2,r3,r2
81107a9c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
81107aa0:	e0bffe17 	ldw	r2,-8(fp)
81107aa4:	10bfffcc 	andi	r2,r2,65535
81107aa8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81107aac:	e0bfff17 	ldw	r2,-4(fp)
81107ab0:	10800017 	ldw	r2,0(r2)
81107ab4:	e1bffe17 	ldw	r6,-8(fp)
81107ab8:	01402944 	movi	r5,165
81107abc:	1009883a 	mov	r4,r2
81107ac0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ac4:	e0bfff17 	ldw	r2,-4(fp)
81107ac8:	10800017 	ldw	r2,0(r2)
81107acc:	01402984 	movi	r5,166
81107ad0:	1009883a 	mov	r4,r2
81107ad4:	1108e680 	call	81108e68 <uliRmapReadReg>
81107ad8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81107adc:	e0bffe17 	ldw	r2,-8(fp)
81107ae0:	10bfffec 	andhi	r2,r2,65535
81107ae4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81107ae8:	e0bfff17 	ldw	r2,-4(fp)
81107aec:	10802c0b 	ldhu	r2,176(r2)
81107af0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81107af4:	e0fffe17 	ldw	r3,-8(fp)
81107af8:	1884b03a 	or	r2,r3,r2
81107afc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81107b00:	e0bffe17 	ldw	r2,-8(fp)
81107b04:	10bfffcc 	andi	r2,r2,65535
81107b08:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81107b0c:	e0bfff17 	ldw	r2,-4(fp)
81107b10:	10800017 	ldw	r2,0(r2)
81107b14:	e1bffe17 	ldw	r6,-8(fp)
81107b18:	01402984 	movi	r5,166
81107b1c:	1009883a 	mov	r4,r2
81107b20:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b24:	e0bfff17 	ldw	r2,-4(fp)
81107b28:	10800017 	ldw	r2,0(r2)
81107b2c:	014029c4 	movi	r5,167
81107b30:	1009883a 	mov	r4,r2
81107b34:	1108e680 	call	81108e68 <uliRmapReadReg>
81107b38:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81107b3c:	e0bffe17 	ldw	r2,-8(fp)
81107b40:	10bfffec 	andhi	r2,r2,65535
81107b44:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
81107b48:	e0bfff17 	ldw	r2,-4(fp)
81107b4c:	10802d0b 	ldhu	r2,180(r2)
81107b50:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
81107b54:	e0fffe17 	ldw	r3,-8(fp)
81107b58:	1884b03a 	or	r2,r3,r2
81107b5c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
81107b60:	e0bffe17 	ldw	r2,-8(fp)
81107b64:	10bfffcc 	andi	r2,r2,65535
81107b68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81107b6c:	e0bfff17 	ldw	r2,-4(fp)
81107b70:	10800017 	ldw	r2,0(r2)
81107b74:	e1bffe17 	ldw	r6,-8(fp)
81107b78:	014029c4 	movi	r5,167
81107b7c:	1009883a 	mov	r4,r2
81107b80:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b84:	e0bfff17 	ldw	r2,-4(fp)
81107b88:	10800017 	ldw	r2,0(r2)
81107b8c:	01402a04 	movi	r5,168
81107b90:	1009883a 	mov	r4,r2
81107b94:	1108e680 	call	81108e68 <uliRmapReadReg>
81107b98:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81107b9c:	e0bffe17 	ldw	r2,-8(fp)
81107ba0:	10bfffec 	andhi	r2,r2,65535
81107ba4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81107ba8:	e0bfff17 	ldw	r2,-4(fp)
81107bac:	10802e0b 	ldhu	r2,184(r2)
81107bb0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81107bb4:	e0fffe17 	ldw	r3,-8(fp)
81107bb8:	1884b03a 	or	r2,r3,r2
81107bbc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81107bc0:	e0bffe17 	ldw	r2,-8(fp)
81107bc4:	10bfffcc 	andi	r2,r2,65535
81107bc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81107bcc:	e0bfff17 	ldw	r2,-4(fp)
81107bd0:	10800017 	ldw	r2,0(r2)
81107bd4:	e1bffe17 	ldw	r6,-8(fp)
81107bd8:	01402a04 	movi	r5,168
81107bdc:	1009883a 	mov	r4,r2
81107be0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107be4:	e0bfff17 	ldw	r2,-4(fp)
81107be8:	10800017 	ldw	r2,0(r2)
81107bec:	01402a44 	movi	r5,169
81107bf0:	1009883a 	mov	r4,r2
81107bf4:	1108e680 	call	81108e68 <uliRmapReadReg>
81107bf8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
81107bfc:	e0bffe17 	ldw	r2,-8(fp)
81107c00:	10bfffec 	andhi	r2,r2,65535
81107c04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81107c08:	e0bfff17 	ldw	r2,-4(fp)
81107c0c:	10802f0b 	ldhu	r2,188(r2)
81107c10:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81107c14:	e0fffe17 	ldw	r3,-8(fp)
81107c18:	1884b03a 	or	r2,r3,r2
81107c1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
81107c20:	e0bffe17 	ldw	r2,-8(fp)
81107c24:	10bfffcc 	andi	r2,r2,65535
81107c28:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81107c2c:	e0bfff17 	ldw	r2,-4(fp)
81107c30:	10800017 	ldw	r2,0(r2)
81107c34:	e1bffe17 	ldw	r6,-8(fp)
81107c38:	01402a44 	movi	r5,169
81107c3c:	1009883a 	mov	r4,r2
81107c40:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c44:	e0bfff17 	ldw	r2,-4(fp)
81107c48:	10800017 	ldw	r2,0(r2)
81107c4c:	01402a84 	movi	r5,170
81107c50:	1009883a 	mov	r4,r2
81107c54:	1108e680 	call	81108e68 <uliRmapReadReg>
81107c58:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81107c5c:	e0bffe17 	ldw	r2,-8(fp)
81107c60:	10bfffec 	andhi	r2,r2,65535
81107c64:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81107c68:	e0bfff17 	ldw	r2,-4(fp)
81107c6c:	1080300b 	ldhu	r2,192(r2)
81107c70:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81107c74:	e0fffe17 	ldw	r3,-8(fp)
81107c78:	1884b03a 	or	r2,r3,r2
81107c7c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81107c80:	e0bffe17 	ldw	r2,-8(fp)
81107c84:	10bfffcc 	andi	r2,r2,65535
81107c88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81107c8c:	e0bfff17 	ldw	r2,-4(fp)
81107c90:	10800017 	ldw	r2,0(r2)
81107c94:	e1bffe17 	ldw	r6,-8(fp)
81107c98:	01402a84 	movi	r5,170
81107c9c:	1009883a 	mov	r4,r2
81107ca0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ca4:	e0bfff17 	ldw	r2,-4(fp)
81107ca8:	10800017 	ldw	r2,0(r2)
81107cac:	01402ac4 	movi	r5,171
81107cb0:	1009883a 	mov	r4,r2
81107cb4:	1108e680 	call	81108e68 <uliRmapReadReg>
81107cb8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81107cbc:	e0bffe17 	ldw	r2,-8(fp)
81107cc0:	10bfffec 	andhi	r2,r2,65535
81107cc4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81107cc8:	e0bfff17 	ldw	r2,-4(fp)
81107ccc:	1080310b 	ldhu	r2,196(r2)
81107cd0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81107cd4:	e0fffe17 	ldw	r3,-8(fp)
81107cd8:	1884b03a 	or	r2,r3,r2
81107cdc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81107ce0:	e0bffe17 	ldw	r2,-8(fp)
81107ce4:	10bfffcc 	andi	r2,r2,65535
81107ce8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81107cec:	e0bfff17 	ldw	r2,-4(fp)
81107cf0:	10800017 	ldw	r2,0(r2)
81107cf4:	e1bffe17 	ldw	r6,-8(fp)
81107cf8:	01402ac4 	movi	r5,171
81107cfc:	1009883a 	mov	r4,r2
81107d00:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d04:	e0bfff17 	ldw	r2,-4(fp)
81107d08:	10800017 	ldw	r2,0(r2)
81107d0c:	01402b04 	movi	r5,172
81107d10:	1009883a 	mov	r4,r2
81107d14:	1108e680 	call	81108e68 <uliRmapReadReg>
81107d18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81107d1c:	e0bffe17 	ldw	r2,-8(fp)
81107d20:	10bfffec 	andhi	r2,r2,65535
81107d24:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81107d28:	e0bfff17 	ldw	r2,-4(fp)
81107d2c:	1080320b 	ldhu	r2,200(r2)
81107d30:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81107d34:	e0fffe17 	ldw	r3,-8(fp)
81107d38:	1884b03a 	or	r2,r3,r2
81107d3c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81107d40:	e0bffe17 	ldw	r2,-8(fp)
81107d44:	10bfffcc 	andi	r2,r2,65535
81107d48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81107d4c:	e0bfff17 	ldw	r2,-4(fp)
81107d50:	10800017 	ldw	r2,0(r2)
81107d54:	e1bffe17 	ldw	r6,-8(fp)
81107d58:	01402b04 	movi	r5,172
81107d5c:	1009883a 	mov	r4,r2
81107d60:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d64:	e0bfff17 	ldw	r2,-4(fp)
81107d68:	10800017 	ldw	r2,0(r2)
81107d6c:	01402b44 	movi	r5,173
81107d70:	1009883a 	mov	r4,r2
81107d74:	1108e680 	call	81108e68 <uliRmapReadReg>
81107d78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81107d7c:	e0bffe17 	ldw	r2,-8(fp)
81107d80:	10bfffec 	andhi	r2,r2,65535
81107d84:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81107d88:	e0bfff17 	ldw	r2,-4(fp)
81107d8c:	1080330b 	ldhu	r2,204(r2)
81107d90:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81107d94:	e0fffe17 	ldw	r3,-8(fp)
81107d98:	1884b03a 	or	r2,r3,r2
81107d9c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81107da0:	e0bffe17 	ldw	r2,-8(fp)
81107da4:	10bfffcc 	andi	r2,r2,65535
81107da8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81107dac:	e0bfff17 	ldw	r2,-4(fp)
81107db0:	10800017 	ldw	r2,0(r2)
81107db4:	e1bffe17 	ldw	r6,-8(fp)
81107db8:	01402b44 	movi	r5,173
81107dbc:	1009883a 	mov	r4,r2
81107dc0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107dc4:	e0bfff17 	ldw	r2,-4(fp)
81107dc8:	10800017 	ldw	r2,0(r2)
81107dcc:	01402b84 	movi	r5,174
81107dd0:	1009883a 	mov	r4,r2
81107dd4:	1108e680 	call	81108e68 <uliRmapReadReg>
81107dd8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81107ddc:	e0bffe17 	ldw	r2,-8(fp)
81107de0:	10bfffec 	andhi	r2,r2,65535
81107de4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81107de8:	e0bfff17 	ldw	r2,-4(fp)
81107dec:	1080340b 	ldhu	r2,208(r2)
81107df0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81107df4:	e0fffe17 	ldw	r3,-8(fp)
81107df8:	1884b03a 	or	r2,r3,r2
81107dfc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81107e00:	e0bffe17 	ldw	r2,-8(fp)
81107e04:	10bfffcc 	andi	r2,r2,65535
81107e08:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81107e0c:	e0bfff17 	ldw	r2,-4(fp)
81107e10:	10800017 	ldw	r2,0(r2)
81107e14:	e1bffe17 	ldw	r6,-8(fp)
81107e18:	01402b84 	movi	r5,174
81107e1c:	1009883a 	mov	r4,r2
81107e20:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e24:	e0bfff17 	ldw	r2,-4(fp)
81107e28:	10800017 	ldw	r2,0(r2)
81107e2c:	01402bc4 	movi	r5,175
81107e30:	1009883a 	mov	r4,r2
81107e34:	1108e680 	call	81108e68 <uliRmapReadReg>
81107e38:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81107e3c:	e0bffe17 	ldw	r2,-8(fp)
81107e40:	10bfffec 	andhi	r2,r2,65535
81107e44:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81107e48:	e0bfff17 	ldw	r2,-4(fp)
81107e4c:	1080350b 	ldhu	r2,212(r2)
81107e50:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81107e54:	e0fffe17 	ldw	r3,-8(fp)
81107e58:	1884b03a 	or	r2,r3,r2
81107e5c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81107e60:	e0bffe17 	ldw	r2,-8(fp)
81107e64:	10bfffcc 	andi	r2,r2,65535
81107e68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81107e6c:	e0bfff17 	ldw	r2,-4(fp)
81107e70:	10800017 	ldw	r2,0(r2)
81107e74:	e1bffe17 	ldw	r6,-8(fp)
81107e78:	01402bc4 	movi	r5,175
81107e7c:	1009883a 	mov	r4,r2
81107e80:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e84:	e0bfff17 	ldw	r2,-4(fp)
81107e88:	10800017 	ldw	r2,0(r2)
81107e8c:	01402c04 	movi	r5,176
81107e90:	1009883a 	mov	r4,r2
81107e94:	1108e680 	call	81108e68 <uliRmapReadReg>
81107e98:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81107e9c:	e0bffe17 	ldw	r2,-8(fp)
81107ea0:	10bfffec 	andhi	r2,r2,65535
81107ea4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81107ea8:	e0bfff17 	ldw	r2,-4(fp)
81107eac:	1080360b 	ldhu	r2,216(r2)
81107eb0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81107eb4:	e0fffe17 	ldw	r3,-8(fp)
81107eb8:	1884b03a 	or	r2,r3,r2
81107ebc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81107ec0:	e0bffe17 	ldw	r2,-8(fp)
81107ec4:	10bfffcc 	andi	r2,r2,65535
81107ec8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81107ecc:	e0bfff17 	ldw	r2,-4(fp)
81107ed0:	10800017 	ldw	r2,0(r2)
81107ed4:	e1bffe17 	ldw	r6,-8(fp)
81107ed8:	01402c04 	movi	r5,176
81107edc:	1009883a 	mov	r4,r2
81107ee0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ee4:	e0bfff17 	ldw	r2,-4(fp)
81107ee8:	10800017 	ldw	r2,0(r2)
81107eec:	01402c44 	movi	r5,177
81107ef0:	1009883a 	mov	r4,r2
81107ef4:	1108e680 	call	81108e68 <uliRmapReadReg>
81107ef8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81107efc:	e0bffe17 	ldw	r2,-8(fp)
81107f00:	10bfffec 	andhi	r2,r2,65535
81107f04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81107f08:	e0bfff17 	ldw	r2,-4(fp)
81107f0c:	1080370b 	ldhu	r2,220(r2)
81107f10:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81107f14:	e0fffe17 	ldw	r3,-8(fp)
81107f18:	1884b03a 	or	r2,r3,r2
81107f1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81107f20:	e0bffe17 	ldw	r2,-8(fp)
81107f24:	10bfffcc 	andi	r2,r2,65535
81107f28:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81107f2c:	e0bfff17 	ldw	r2,-4(fp)
81107f30:	10800017 	ldw	r2,0(r2)
81107f34:	e1bffe17 	ldw	r6,-8(fp)
81107f38:	01402c44 	movi	r5,177
81107f3c:	1009883a 	mov	r4,r2
81107f40:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f44:	e0bfff17 	ldw	r2,-4(fp)
81107f48:	10800017 	ldw	r2,0(r2)
81107f4c:	01402c84 	movi	r5,178
81107f50:	1009883a 	mov	r4,r2
81107f54:	1108e680 	call	81108e68 <uliRmapReadReg>
81107f58:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81107f5c:	e0bffe17 	ldw	r2,-8(fp)
81107f60:	10bfffec 	andhi	r2,r2,65535
81107f64:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81107f68:	e0bfff17 	ldw	r2,-4(fp)
81107f6c:	1080380b 	ldhu	r2,224(r2)
81107f70:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81107f74:	e0fffe17 	ldw	r3,-8(fp)
81107f78:	1884b03a 	or	r2,r3,r2
81107f7c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81107f80:	e0bffe17 	ldw	r2,-8(fp)
81107f84:	10bfffcc 	andi	r2,r2,65535
81107f88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81107f8c:	e0bfff17 	ldw	r2,-4(fp)
81107f90:	10800017 	ldw	r2,0(r2)
81107f94:	e1bffe17 	ldw	r6,-8(fp)
81107f98:	01402c84 	movi	r5,178
81107f9c:	1009883a 	mov	r4,r2
81107fa0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107fa4:	e0bfff17 	ldw	r2,-4(fp)
81107fa8:	10800017 	ldw	r2,0(r2)
81107fac:	01402cc4 	movi	r5,179
81107fb0:	1009883a 	mov	r4,r2
81107fb4:	1108e680 	call	81108e68 <uliRmapReadReg>
81107fb8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81107fbc:	e0bffe17 	ldw	r2,-8(fp)
81107fc0:	10bfffec 	andhi	r2,r2,65535
81107fc4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81107fc8:	e0bfff17 	ldw	r2,-4(fp)
81107fcc:	1080390b 	ldhu	r2,228(r2)
81107fd0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81107fd4:	e0fffe17 	ldw	r3,-8(fp)
81107fd8:	1884b03a 	or	r2,r3,r2
81107fdc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81107fe0:	e0bffe17 	ldw	r2,-8(fp)
81107fe4:	10bfffcc 	andi	r2,r2,65535
81107fe8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81107fec:	e0bfff17 	ldw	r2,-4(fp)
81107ff0:	10800017 	ldw	r2,0(r2)
81107ff4:	e1bffe17 	ldw	r6,-8(fp)
81107ff8:	01402cc4 	movi	r5,179
81107ffc:	1009883a 	mov	r4,r2
81108000:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108004:	e0bfff17 	ldw	r2,-4(fp)
81108008:	10800017 	ldw	r2,0(r2)
8110800c:	01402d04 	movi	r5,180
81108010:	1009883a 	mov	r4,r2
81108014:	1108e680 	call	81108e68 <uliRmapReadReg>
81108018:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
8110801c:	e0bffe17 	ldw	r2,-8(fp)
81108020:	10bfffec 	andhi	r2,r2,65535
81108024:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81108028:	e0bfff17 	ldw	r2,-4(fp)
8110802c:	10803a0b 	ldhu	r2,232(r2)
81108030:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81108034:	e0fffe17 	ldw	r3,-8(fp)
81108038:	1884b03a 	or	r2,r3,r2
8110803c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81108040:	e0bffe17 	ldw	r2,-8(fp)
81108044:	10bfffcc 	andi	r2,r2,65535
81108048:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
8110804c:	e0bfff17 	ldw	r2,-4(fp)
81108050:	10800017 	ldw	r2,0(r2)
81108054:	e1bffe17 	ldw	r6,-8(fp)
81108058:	01402d04 	movi	r5,180
8110805c:	1009883a 	mov	r4,r2
81108060:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108064:	e0bfff17 	ldw	r2,-4(fp)
81108068:	10800017 	ldw	r2,0(r2)
8110806c:	01402d44 	movi	r5,181
81108070:	1009883a 	mov	r4,r2
81108074:	1108e680 	call	81108e68 <uliRmapReadReg>
81108078:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
8110807c:	e0bffe17 	ldw	r2,-8(fp)
81108080:	10bfffec 	andhi	r2,r2,65535
81108084:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81108088:	e0bfff17 	ldw	r2,-4(fp)
8110808c:	10803b0b 	ldhu	r2,236(r2)
81108090:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108094:	e0fffe17 	ldw	r3,-8(fp)
81108098:	1884b03a 	or	r2,r3,r2
8110809c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
811080a0:	e0bffe17 	ldw	r2,-8(fp)
811080a4:	10bfffcc 	andi	r2,r2,65535
811080a8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
811080ac:	e0bfff17 	ldw	r2,-4(fp)
811080b0:	10800017 	ldw	r2,0(r2)
811080b4:	e1bffe17 	ldw	r6,-8(fp)
811080b8:	01402d44 	movi	r5,181
811080bc:	1009883a 	mov	r4,r2
811080c0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080c4:	e0bfff17 	ldw	r2,-4(fp)
811080c8:	10800017 	ldw	r2,0(r2)
811080cc:	01402d84 	movi	r5,182
811080d0:	1009883a 	mov	r4,r2
811080d4:	1108e680 	call	81108e68 <uliRmapReadReg>
811080d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
811080dc:	e0bffe17 	ldw	r2,-8(fp)
811080e0:	10bfffec 	andhi	r2,r2,65535
811080e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
811080e8:	e0bfff17 	ldw	r2,-4(fp)
811080ec:	10803c0b 	ldhu	r2,240(r2)
811080f0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
811080f4:	e0fffe17 	ldw	r3,-8(fp)
811080f8:	1884b03a 	or	r2,r3,r2
811080fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81108100:	e0bffe17 	ldw	r2,-8(fp)
81108104:	10bfffcc 	andi	r2,r2,65535
81108108:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
8110810c:	e0bfff17 	ldw	r2,-4(fp)
81108110:	10800017 	ldw	r2,0(r2)
81108114:	e1bffe17 	ldw	r6,-8(fp)
81108118:	01402d84 	movi	r5,182
8110811c:	1009883a 	mov	r4,r2
81108120:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108124:	e0bfff17 	ldw	r2,-4(fp)
81108128:	10800017 	ldw	r2,0(r2)
8110812c:	01402dc4 	movi	r5,183
81108130:	1009883a 	mov	r4,r2
81108134:	1108e680 	call	81108e68 <uliRmapReadReg>
81108138:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
8110813c:	e0bffe17 	ldw	r2,-8(fp)
81108140:	10bfffec 	andhi	r2,r2,65535
81108144:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81108148:	e0bfff17 	ldw	r2,-4(fp)
8110814c:	10803d0b 	ldhu	r2,244(r2)
81108150:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81108154:	e0fffe17 	ldw	r3,-8(fp)
81108158:	1884b03a 	or	r2,r3,r2
8110815c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81108160:	e0bffe17 	ldw	r2,-8(fp)
81108164:	10bfffcc 	andi	r2,r2,65535
81108168:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
8110816c:	e0bfff17 	ldw	r2,-4(fp)
81108170:	10800017 	ldw	r2,0(r2)
81108174:	e1bffe17 	ldw	r6,-8(fp)
81108178:	01402dc4 	movi	r5,183
8110817c:	1009883a 	mov	r4,r2
81108180:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108184:	e0bfff17 	ldw	r2,-4(fp)
81108188:	10800017 	ldw	r2,0(r2)
8110818c:	01402e04 	movi	r5,184
81108190:	1009883a 	mov	r4,r2
81108194:	1108e680 	call	81108e68 <uliRmapReadReg>
81108198:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
8110819c:	e0bffe17 	ldw	r2,-8(fp)
811081a0:	10bfffec 	andhi	r2,r2,65535
811081a4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
811081a8:	e0bfff17 	ldw	r2,-4(fp)
811081ac:	10803e0b 	ldhu	r2,248(r2)
811081b0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
811081b4:	e0fffe17 	ldw	r3,-8(fp)
811081b8:	1884b03a 	or	r2,r3,r2
811081bc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
811081c0:	e0bffe17 	ldw	r2,-8(fp)
811081c4:	10bfffcc 	andi	r2,r2,65535
811081c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
811081cc:	e0bfff17 	ldw	r2,-4(fp)
811081d0:	10800017 	ldw	r2,0(r2)
811081d4:	e1bffe17 	ldw	r6,-8(fp)
811081d8:	01402e04 	movi	r5,184
811081dc:	1009883a 	mov	r4,r2
811081e0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081e4:	e0bfff17 	ldw	r2,-4(fp)
811081e8:	10800017 	ldw	r2,0(r2)
811081ec:	01402e44 	movi	r5,185
811081f0:	1009883a 	mov	r4,r2
811081f4:	1108e680 	call	81108e68 <uliRmapReadReg>
811081f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
811081fc:	e0bffe17 	ldw	r2,-8(fp)
81108200:	10bfffec 	andhi	r2,r2,65535
81108204:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
81108208:	e0bfff17 	ldw	r2,-4(fp)
8110820c:	10803f0b 	ldhu	r2,252(r2)
81108210:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
81108214:	e0fffe17 	ldw	r3,-8(fp)
81108218:	1884b03a 	or	r2,r3,r2
8110821c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81108220:	e0bffe17 	ldw	r2,-8(fp)
81108224:	10bfffcc 	andi	r2,r2,65535
81108228:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
8110822c:	e0bfff17 	ldw	r2,-4(fp)
81108230:	10800017 	ldw	r2,0(r2)
81108234:	e1bffe17 	ldw	r6,-8(fp)
81108238:	01402e44 	movi	r5,185
8110823c:	1009883a 	mov	r4,r2
81108240:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108244:	e0bfff17 	ldw	r2,-4(fp)
81108248:	10800017 	ldw	r2,0(r2)
8110824c:	01402e84 	movi	r5,186
81108250:	1009883a 	mov	r4,r2
81108254:	1108e680 	call	81108e68 <uliRmapReadReg>
81108258:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
8110825c:	e0bffe17 	ldw	r2,-8(fp)
81108260:	10bfffec 	andhi	r2,r2,65535
81108264:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81108268:	e0bfff17 	ldw	r2,-4(fp)
8110826c:	1080400b 	ldhu	r2,256(r2)
81108270:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81108274:	e0fffe17 	ldw	r3,-8(fp)
81108278:	1884b03a 	or	r2,r3,r2
8110827c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81108280:	e0bffe17 	ldw	r2,-8(fp)
81108284:	10bfffcc 	andi	r2,r2,65535
81108288:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
8110828c:	e0bfff17 	ldw	r2,-4(fp)
81108290:	10800017 	ldw	r2,0(r2)
81108294:	e1bffe17 	ldw	r6,-8(fp)
81108298:	01402e84 	movi	r5,186
8110829c:	1009883a 	mov	r4,r2
811082a0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082a4:	e0bfff17 	ldw	r2,-4(fp)
811082a8:	10800017 	ldw	r2,0(r2)
811082ac:	01402ec4 	movi	r5,187
811082b0:	1009883a 	mov	r4,r2
811082b4:	1108e680 	call	81108e68 <uliRmapReadReg>
811082b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
811082bc:	e0bffe17 	ldw	r2,-8(fp)
811082c0:	10bfffec 	andhi	r2,r2,65535
811082c4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
811082c8:	e0bfff17 	ldw	r2,-4(fp)
811082cc:	1080410b 	ldhu	r2,260(r2)
811082d0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
811082d4:	e0fffe17 	ldw	r3,-8(fp)
811082d8:	1884b03a 	or	r2,r3,r2
811082dc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
811082e0:	e0bffe17 	ldw	r2,-8(fp)
811082e4:	10bfffcc 	andi	r2,r2,65535
811082e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
811082ec:	e0bfff17 	ldw	r2,-4(fp)
811082f0:	10800017 	ldw	r2,0(r2)
811082f4:	e1bffe17 	ldw	r6,-8(fp)
811082f8:	01402ec4 	movi	r5,187
811082fc:	1009883a 	mov	r4,r2
81108300:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108304:	e0bfff17 	ldw	r2,-4(fp)
81108308:	10800017 	ldw	r2,0(r2)
8110830c:	01402f04 	movi	r5,188
81108310:	1009883a 	mov	r4,r2
81108314:	1108e680 	call	81108e68 <uliRmapReadReg>
81108318:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
8110831c:	e0bffe17 	ldw	r2,-8(fp)
81108320:	10bfffec 	andhi	r2,r2,65535
81108324:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81108328:	e0bfff17 	ldw	r2,-4(fp)
8110832c:	1080420b 	ldhu	r2,264(r2)
81108330:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81108334:	e0fffe17 	ldw	r3,-8(fp)
81108338:	1884b03a 	or	r2,r3,r2
8110833c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81108340:	e0bffe17 	ldw	r2,-8(fp)
81108344:	10bfffcc 	andi	r2,r2,65535
81108348:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
8110834c:	e0bfff17 	ldw	r2,-4(fp)
81108350:	10800017 	ldw	r2,0(r2)
81108354:	e1bffe17 	ldw	r6,-8(fp)
81108358:	01402f04 	movi	r5,188
8110835c:	1009883a 	mov	r4,r2
81108360:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108364:	e0bfff17 	ldw	r2,-4(fp)
81108368:	10800017 	ldw	r2,0(r2)
8110836c:	01402f44 	movi	r5,189
81108370:	1009883a 	mov	r4,r2
81108374:	1108e680 	call	81108e68 <uliRmapReadReg>
81108378:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
8110837c:	e0bffe17 	ldw	r2,-8(fp)
81108380:	10bfffec 	andhi	r2,r2,65535
81108384:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
81108388:	e0bfff17 	ldw	r2,-4(fp)
8110838c:	1080430b 	ldhu	r2,268(r2)
81108390:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
81108394:	e0fffe17 	ldw	r3,-8(fp)
81108398:	1884b03a 	or	r2,r3,r2
8110839c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
811083a0:	e0bffe17 	ldw	r2,-8(fp)
811083a4:	10bfffcc 	andi	r2,r2,65535
811083a8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
811083ac:	e0bfff17 	ldw	r2,-4(fp)
811083b0:	10800017 	ldw	r2,0(r2)
811083b4:	e1bffe17 	ldw	r6,-8(fp)
811083b8:	01402f44 	movi	r5,189
811083bc:	1009883a 	mov	r4,r2
811083c0:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083c4:	e0bfff17 	ldw	r2,-4(fp)
811083c8:	10800017 	ldw	r2,0(r2)
811083cc:	01402f84 	movi	r5,190
811083d0:	1009883a 	mov	r4,r2
811083d4:	1108e680 	call	81108e68 <uliRmapReadReg>
811083d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
811083dc:	e0bffe17 	ldw	r2,-8(fp)
811083e0:	10bfffec 	andhi	r2,r2,65535
811083e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
811083e8:	e0bfff17 	ldw	r2,-4(fp)
811083ec:	1080440b 	ldhu	r2,272(r2)
811083f0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
811083f4:	e0fffe17 	ldw	r3,-8(fp)
811083f8:	1884b03a 	or	r2,r3,r2
811083fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81108400:	e0bffe17 	ldw	r2,-8(fp)
81108404:	10bfffcc 	andi	r2,r2,65535
81108408:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
8110840c:	e0bfff17 	ldw	r2,-4(fp)
81108410:	10800017 	ldw	r2,0(r2)
81108414:	e1bffe17 	ldw	r6,-8(fp)
81108418:	01402f84 	movi	r5,190
8110841c:	1009883a 	mov	r4,r2
81108420:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108424:	e0bfff17 	ldw	r2,-4(fp)
81108428:	10800017 	ldw	r2,0(r2)
8110842c:	01402fc4 	movi	r5,191
81108430:	1009883a 	mov	r4,r2
81108434:	1108e680 	call	81108e68 <uliRmapReadReg>
81108438:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
8110843c:	e0bffe17 	ldw	r2,-8(fp)
81108440:	10bfffec 	andhi	r2,r2,65535
81108444:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
81108448:	e0bfff17 	ldw	r2,-4(fp)
8110844c:	1080450b 	ldhu	r2,276(r2)
81108450:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
81108454:	e0fffe17 	ldw	r3,-8(fp)
81108458:	1884b03a 	or	r2,r3,r2
8110845c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
81108460:	e0bffe17 	ldw	r2,-8(fp)
81108464:	10bfffcc 	andi	r2,r2,65535
81108468:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
8110846c:	e0bfff17 	ldw	r2,-4(fp)
81108470:	10800017 	ldw	r2,0(r2)
81108474:	e1bffe17 	ldw	r6,-8(fp)
81108478:	01402fc4 	movi	r5,191
8110847c:	1009883a 	mov	r4,r2
81108480:	1108e140 	call	81108e14 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108484:	00800044 	movi	r2,1
81108488:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110848c:	e0bffd17 	ldw	r2,-12(fp)
}
81108490:	e037883a 	mov	sp,fp
81108494:	dfc00117 	ldw	ra,4(sp)
81108498:	df000017 	ldw	fp,0(sp)
8110849c:	dec00204 	addi	sp,sp,8
811084a0:	f800283a 	ret

811084a4 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811084a4:	defffb04 	addi	sp,sp,-20
811084a8:	de00012e 	bgeu	sp,et,811084b0 <bRmapGetRmapMemHKArea+0xc>
811084ac:	003b68fa 	trap	3
811084b0:	dfc00415 	stw	ra,16(sp)
811084b4:	df000315 	stw	fp,12(sp)
811084b8:	df000304 	addi	fp,sp,12
811084bc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811084c0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811084c4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811084c8:	e0bfff17 	ldw	r2,-4(fp)
811084cc:	1001e226 	beq	r2,zero,81108c58 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084d0:	e0bfff17 	ldw	r2,-4(fp)
811084d4:	10800017 	ldw	r2,0(r2)
811084d8:	01402804 	movi	r5,160
811084dc:	1009883a 	mov	r4,r2
811084e0:	1108e680 	call	81108e68 <uliRmapReadReg>
811084e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
811084e8:	e0bffe17 	ldw	r2,-8(fp)
811084ec:	1007883a 	mov	r3,r2
811084f0:	e0bfff17 	ldw	r2,-4(fp)
811084f4:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
811084f8:	e0bffe17 	ldw	r2,-8(fp)
811084fc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81108500:	1007883a 	mov	r3,r2
81108504:	e0bfff17 	ldw	r2,-4(fp)
81108508:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110850c:	e0bfff17 	ldw	r2,-4(fp)
81108510:	10800017 	ldw	r2,0(r2)
81108514:	01402844 	movi	r5,161
81108518:	1009883a 	mov	r4,r2
8110851c:	1108e680 	call	81108e68 <uliRmapReadReg>
81108520:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81108524:	e0bffe17 	ldw	r2,-8(fp)
81108528:	1007883a 	mov	r3,r2
8110852c:	e0bfff17 	ldw	r2,-4(fp)
81108530:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
81108534:	e0bffe17 	ldw	r2,-8(fp)
81108538:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
8110853c:	1007883a 	mov	r3,r2
81108540:	e0bfff17 	ldw	r2,-4(fp)
81108544:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108548:	e0bfff17 	ldw	r2,-4(fp)
8110854c:	10800017 	ldw	r2,0(r2)
81108550:	01402884 	movi	r5,162
81108554:	1009883a 	mov	r4,r2
81108558:	1108e680 	call	81108e68 <uliRmapReadReg>
8110855c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
81108560:	e0bffe17 	ldw	r2,-8(fp)
81108564:	1007883a 	mov	r3,r2
81108568:	e0bfff17 	ldw	r2,-4(fp)
8110856c:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81108570:	e0bffe17 	ldw	r2,-8(fp)
81108574:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
81108578:	1007883a 	mov	r3,r2
8110857c:	e0bfff17 	ldw	r2,-4(fp)
81108580:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108584:	e0bfff17 	ldw	r2,-4(fp)
81108588:	10800017 	ldw	r2,0(r2)
8110858c:	014028c4 	movi	r5,163
81108590:	1009883a 	mov	r4,r2
81108594:	1108e680 	call	81108e68 <uliRmapReadReg>
81108598:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
8110859c:	e0bffe17 	ldw	r2,-8(fp)
811085a0:	1007883a 	mov	r3,r2
811085a4:	e0bfff17 	ldw	r2,-4(fp)
811085a8:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
811085ac:	e0bffe17 	ldw	r2,-8(fp)
811085b0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
811085b4:	1007883a 	mov	r3,r2
811085b8:	e0bfff17 	ldw	r2,-4(fp)
811085bc:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085c0:	e0bfff17 	ldw	r2,-4(fp)
811085c4:	10800017 	ldw	r2,0(r2)
811085c8:	01402904 	movi	r5,164
811085cc:	1009883a 	mov	r4,r2
811085d0:	1108e680 	call	81108e68 <uliRmapReadReg>
811085d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
811085d8:	e0bffe17 	ldw	r2,-8(fp)
811085dc:	1007883a 	mov	r3,r2
811085e0:	e0bfff17 	ldw	r2,-4(fp)
811085e4:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
811085e8:	e0bffe17 	ldw	r2,-8(fp)
811085ec:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
811085f0:	1007883a 	mov	r3,r2
811085f4:	e0bfff17 	ldw	r2,-4(fp)
811085f8:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085fc:	e0bfff17 	ldw	r2,-4(fp)
81108600:	10800017 	ldw	r2,0(r2)
81108604:	01402944 	movi	r5,165
81108608:	1009883a 	mov	r4,r2
8110860c:	1108e680 	call	81108e68 <uliRmapReadReg>
81108610:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81108614:	e0bffe17 	ldw	r2,-8(fp)
81108618:	1007883a 	mov	r3,r2
8110861c:	e0bfff17 	ldw	r2,-4(fp)
81108620:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81108624:	e0bffe17 	ldw	r2,-8(fp)
81108628:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
8110862c:	1007883a 	mov	r3,r2
81108630:	e0bfff17 	ldw	r2,-4(fp)
81108634:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108638:	e0bfff17 	ldw	r2,-4(fp)
8110863c:	10800017 	ldw	r2,0(r2)
81108640:	01402984 	movi	r5,166
81108644:	1009883a 	mov	r4,r2
81108648:	1108e680 	call	81108e68 <uliRmapReadReg>
8110864c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
81108650:	e0bffe17 	ldw	r2,-8(fp)
81108654:	1007883a 	mov	r3,r2
81108658:	e0bfff17 	ldw	r2,-4(fp)
8110865c:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
81108660:	e0bffe17 	ldw	r2,-8(fp)
81108664:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
81108668:	1007883a 	mov	r3,r2
8110866c:	e0bfff17 	ldw	r2,-4(fp)
81108670:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108674:	e0bfff17 	ldw	r2,-4(fp)
81108678:	10800017 	ldw	r2,0(r2)
8110867c:	014029c4 	movi	r5,167
81108680:	1009883a 	mov	r4,r2
81108684:	1108e680 	call	81108e68 <uliRmapReadReg>
81108688:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
8110868c:	e0bffe17 	ldw	r2,-8(fp)
81108690:	1007883a 	mov	r3,r2
81108694:	e0bfff17 	ldw	r2,-4(fp)
81108698:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
8110869c:	e0bffe17 	ldw	r2,-8(fp)
811086a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
811086a4:	1007883a 	mov	r3,r2
811086a8:	e0bfff17 	ldw	r2,-4(fp)
811086ac:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086b0:	e0bfff17 	ldw	r2,-4(fp)
811086b4:	10800017 	ldw	r2,0(r2)
811086b8:	01402a04 	movi	r5,168
811086bc:	1009883a 	mov	r4,r2
811086c0:	1108e680 	call	81108e68 <uliRmapReadReg>
811086c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
811086c8:	e0bffe17 	ldw	r2,-8(fp)
811086cc:	1007883a 	mov	r3,r2
811086d0:	e0bfff17 	ldw	r2,-4(fp)
811086d4:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
811086d8:	e0bffe17 	ldw	r2,-8(fp)
811086dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
811086e0:	1007883a 	mov	r3,r2
811086e4:	e0bfff17 	ldw	r2,-4(fp)
811086e8:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086ec:	e0bfff17 	ldw	r2,-4(fp)
811086f0:	10800017 	ldw	r2,0(r2)
811086f4:	01402a44 	movi	r5,169
811086f8:	1009883a 	mov	r4,r2
811086fc:	1108e680 	call	81108e68 <uliRmapReadReg>
81108700:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81108704:	e0bffe17 	ldw	r2,-8(fp)
81108708:	1007883a 	mov	r3,r2
8110870c:	e0bfff17 	ldw	r2,-4(fp)
81108710:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81108714:	e0bffe17 	ldw	r2,-8(fp)
81108718:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
8110871c:	1007883a 	mov	r3,r2
81108720:	e0bfff17 	ldw	r2,-4(fp)
81108724:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108728:	e0bfff17 	ldw	r2,-4(fp)
8110872c:	10800017 	ldw	r2,0(r2)
81108730:	01402a84 	movi	r5,170
81108734:	1009883a 	mov	r4,r2
81108738:	1108e680 	call	81108e68 <uliRmapReadReg>
8110873c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
81108740:	e0bffe17 	ldw	r2,-8(fp)
81108744:	1007883a 	mov	r3,r2
81108748:	e0bfff17 	ldw	r2,-4(fp)
8110874c:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
81108750:	e0bffe17 	ldw	r2,-8(fp)
81108754:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
81108758:	1007883a 	mov	r3,r2
8110875c:	e0bfff17 	ldw	r2,-4(fp)
81108760:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108764:	e0bfff17 	ldw	r2,-4(fp)
81108768:	10800017 	ldw	r2,0(r2)
8110876c:	01402ac4 	movi	r5,171
81108770:	1009883a 	mov	r4,r2
81108774:	1108e680 	call	81108e68 <uliRmapReadReg>
81108778:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
8110877c:	e0bffe17 	ldw	r2,-8(fp)
81108780:	1007883a 	mov	r3,r2
81108784:	e0bfff17 	ldw	r2,-4(fp)
81108788:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
8110878c:	e0bffe17 	ldw	r2,-8(fp)
81108790:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81108794:	1007883a 	mov	r3,r2
81108798:	e0bfff17 	ldw	r2,-4(fp)
8110879c:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087a0:	e0bfff17 	ldw	r2,-4(fp)
811087a4:	10800017 	ldw	r2,0(r2)
811087a8:	01402b04 	movi	r5,172
811087ac:	1009883a 	mov	r4,r2
811087b0:	1108e680 	call	81108e68 <uliRmapReadReg>
811087b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
811087b8:	e0bffe17 	ldw	r2,-8(fp)
811087bc:	1007883a 	mov	r3,r2
811087c0:	e0bfff17 	ldw	r2,-4(fp)
811087c4:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
811087c8:	e0bffe17 	ldw	r2,-8(fp)
811087cc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
811087d0:	1007883a 	mov	r3,r2
811087d4:	e0bfff17 	ldw	r2,-4(fp)
811087d8:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087dc:	e0bfff17 	ldw	r2,-4(fp)
811087e0:	10800017 	ldw	r2,0(r2)
811087e4:	01402b44 	movi	r5,173
811087e8:	1009883a 	mov	r4,r2
811087ec:	1108e680 	call	81108e68 <uliRmapReadReg>
811087f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
811087f4:	e0bffe17 	ldw	r2,-8(fp)
811087f8:	1007883a 	mov	r3,r2
811087fc:	e0bfff17 	ldw	r2,-4(fp)
81108800:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81108804:	e0bffe17 	ldw	r2,-8(fp)
81108808:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
8110880c:	1007883a 	mov	r3,r2
81108810:	e0bfff17 	ldw	r2,-4(fp)
81108814:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108818:	e0bfff17 	ldw	r2,-4(fp)
8110881c:	10800017 	ldw	r2,0(r2)
81108820:	01402b84 	movi	r5,174
81108824:	1009883a 	mov	r4,r2
81108828:	1108e680 	call	81108e68 <uliRmapReadReg>
8110882c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
81108830:	e0bffe17 	ldw	r2,-8(fp)
81108834:	1007883a 	mov	r3,r2
81108838:	e0bfff17 	ldw	r2,-4(fp)
8110883c:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
81108840:	e0bffe17 	ldw	r2,-8(fp)
81108844:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
81108848:	1007883a 	mov	r3,r2
8110884c:	e0bfff17 	ldw	r2,-4(fp)
81108850:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108854:	e0bfff17 	ldw	r2,-4(fp)
81108858:	10800017 	ldw	r2,0(r2)
8110885c:	01402bc4 	movi	r5,175
81108860:	1009883a 	mov	r4,r2
81108864:	1108e680 	call	81108e68 <uliRmapReadReg>
81108868:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
8110886c:	e0bffe17 	ldw	r2,-8(fp)
81108870:	1007883a 	mov	r3,r2
81108874:	e0bfff17 	ldw	r2,-4(fp)
81108878:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
8110887c:	e0bffe17 	ldw	r2,-8(fp)
81108880:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81108884:	1007883a 	mov	r3,r2
81108888:	e0bfff17 	ldw	r2,-4(fp)
8110888c:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108890:	e0bfff17 	ldw	r2,-4(fp)
81108894:	10800017 	ldw	r2,0(r2)
81108898:	01402c04 	movi	r5,176
8110889c:	1009883a 	mov	r4,r2
811088a0:	1108e680 	call	81108e68 <uliRmapReadReg>
811088a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
811088a8:	e0bffe17 	ldw	r2,-8(fp)
811088ac:	1007883a 	mov	r3,r2
811088b0:	e0bfff17 	ldw	r2,-4(fp)
811088b4:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
811088b8:	e0bffe17 	ldw	r2,-8(fp)
811088bc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
811088c0:	1007883a 	mov	r3,r2
811088c4:	e0bfff17 	ldw	r2,-4(fp)
811088c8:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088cc:	e0bfff17 	ldw	r2,-4(fp)
811088d0:	10800017 	ldw	r2,0(r2)
811088d4:	01402c44 	movi	r5,177
811088d8:	1009883a 	mov	r4,r2
811088dc:	1108e680 	call	81108e68 <uliRmapReadReg>
811088e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
811088e4:	e0bffe17 	ldw	r2,-8(fp)
811088e8:	1007883a 	mov	r3,r2
811088ec:	e0bfff17 	ldw	r2,-4(fp)
811088f0:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
811088f4:	e0bffe17 	ldw	r2,-8(fp)
811088f8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
811088fc:	1007883a 	mov	r3,r2
81108900:	e0bfff17 	ldw	r2,-4(fp)
81108904:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108908:	e0bfff17 	ldw	r2,-4(fp)
8110890c:	10800017 	ldw	r2,0(r2)
81108910:	01402c84 	movi	r5,178
81108914:	1009883a 	mov	r4,r2
81108918:	1108e680 	call	81108e68 <uliRmapReadReg>
8110891c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
81108920:	e0bffe17 	ldw	r2,-8(fp)
81108924:	1007883a 	mov	r3,r2
81108928:	e0bfff17 	ldw	r2,-4(fp)
8110892c:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
81108930:	e0bffe17 	ldw	r2,-8(fp)
81108934:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
81108938:	1007883a 	mov	r3,r2
8110893c:	e0bfff17 	ldw	r2,-4(fp)
81108940:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108944:	e0bfff17 	ldw	r2,-4(fp)
81108948:	10800017 	ldw	r2,0(r2)
8110894c:	01402cc4 	movi	r5,179
81108950:	1009883a 	mov	r4,r2
81108954:	1108e680 	call	81108e68 <uliRmapReadReg>
81108958:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
8110895c:	e0bffe17 	ldw	r2,-8(fp)
81108960:	1007883a 	mov	r3,r2
81108964:	e0bfff17 	ldw	r2,-4(fp)
81108968:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
8110896c:	e0bffe17 	ldw	r2,-8(fp)
81108970:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81108974:	1007883a 	mov	r3,r2
81108978:	e0bfff17 	ldw	r2,-4(fp)
8110897c:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108980:	e0bfff17 	ldw	r2,-4(fp)
81108984:	10800017 	ldw	r2,0(r2)
81108988:	01402d04 	movi	r5,180
8110898c:	1009883a 	mov	r4,r2
81108990:	1108e680 	call	81108e68 <uliRmapReadReg>
81108994:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81108998:	e0bffe17 	ldw	r2,-8(fp)
8110899c:	1007883a 	mov	r3,r2
811089a0:	e0bfff17 	ldw	r2,-4(fp)
811089a4:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
811089a8:	e0bffe17 	ldw	r2,-8(fp)
811089ac:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
811089b0:	1007883a 	mov	r3,r2
811089b4:	e0bfff17 	ldw	r2,-4(fp)
811089b8:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089bc:	e0bfff17 	ldw	r2,-4(fp)
811089c0:	10800017 	ldw	r2,0(r2)
811089c4:	01402d44 	movi	r5,181
811089c8:	1009883a 	mov	r4,r2
811089cc:	1108e680 	call	81108e68 <uliRmapReadReg>
811089d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
811089d4:	e0bffe17 	ldw	r2,-8(fp)
811089d8:	1007883a 	mov	r3,r2
811089dc:	e0bfff17 	ldw	r2,-4(fp)
811089e0:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
811089e4:	e0bffe17 	ldw	r2,-8(fp)
811089e8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
811089ec:	1007883a 	mov	r3,r2
811089f0:	e0bfff17 	ldw	r2,-4(fp)
811089f4:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089f8:	e0bfff17 	ldw	r2,-4(fp)
811089fc:	10800017 	ldw	r2,0(r2)
81108a00:	01402d84 	movi	r5,182
81108a04:	1009883a 	mov	r4,r2
81108a08:	1108e680 	call	81108e68 <uliRmapReadReg>
81108a0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81108a10:	e0bffe17 	ldw	r2,-8(fp)
81108a14:	1007883a 	mov	r3,r2
81108a18:	e0bfff17 	ldw	r2,-4(fp)
81108a1c:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81108a20:	e0bffe17 	ldw	r2,-8(fp)
81108a24:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
81108a28:	1007883a 	mov	r3,r2
81108a2c:	e0bfff17 	ldw	r2,-4(fp)
81108a30:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a34:	e0bfff17 	ldw	r2,-4(fp)
81108a38:	10800017 	ldw	r2,0(r2)
81108a3c:	01402dc4 	movi	r5,183
81108a40:	1009883a 	mov	r4,r2
81108a44:	1108e680 	call	81108e68 <uliRmapReadReg>
81108a48:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81108a4c:	e0bffe17 	ldw	r2,-8(fp)
81108a50:	1007883a 	mov	r3,r2
81108a54:	e0bfff17 	ldw	r2,-4(fp)
81108a58:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81108a5c:	e0bffe17 	ldw	r2,-8(fp)
81108a60:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81108a64:	1007883a 	mov	r3,r2
81108a68:	e0bfff17 	ldw	r2,-4(fp)
81108a6c:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a70:	e0bfff17 	ldw	r2,-4(fp)
81108a74:	10800017 	ldw	r2,0(r2)
81108a78:	01402e04 	movi	r5,184
81108a7c:	1009883a 	mov	r4,r2
81108a80:	1108e680 	call	81108e68 <uliRmapReadReg>
81108a84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81108a88:	e0bffe17 	ldw	r2,-8(fp)
81108a8c:	1007883a 	mov	r3,r2
81108a90:	e0bfff17 	ldw	r2,-4(fp)
81108a94:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81108a98:	e0bffe17 	ldw	r2,-8(fp)
81108a9c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81108aa0:	1007883a 	mov	r3,r2
81108aa4:	e0bfff17 	ldw	r2,-4(fp)
81108aa8:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108aac:	e0bfff17 	ldw	r2,-4(fp)
81108ab0:	10800017 	ldw	r2,0(r2)
81108ab4:	01402e44 	movi	r5,185
81108ab8:	1009883a 	mov	r4,r2
81108abc:	1108e680 	call	81108e68 <uliRmapReadReg>
81108ac0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81108ac4:	e0bffe17 	ldw	r2,-8(fp)
81108ac8:	1007883a 	mov	r3,r2
81108acc:	e0bfff17 	ldw	r2,-4(fp)
81108ad0:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81108ad4:	e0bffe17 	ldw	r2,-8(fp)
81108ad8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81108adc:	1007883a 	mov	r3,r2
81108ae0:	e0bfff17 	ldw	r2,-4(fp)
81108ae4:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ae8:	e0bfff17 	ldw	r2,-4(fp)
81108aec:	10800017 	ldw	r2,0(r2)
81108af0:	01402e84 	movi	r5,186
81108af4:	1009883a 	mov	r4,r2
81108af8:	1108e680 	call	81108e68 <uliRmapReadReg>
81108afc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81108b00:	e0bffe17 	ldw	r2,-8(fp)
81108b04:	1007883a 	mov	r3,r2
81108b08:	e0bfff17 	ldw	r2,-4(fp)
81108b0c:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81108b10:	e0bffe17 	ldw	r2,-8(fp)
81108b14:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81108b18:	1007883a 	mov	r3,r2
81108b1c:	e0bfff17 	ldw	r2,-4(fp)
81108b20:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b24:	e0bfff17 	ldw	r2,-4(fp)
81108b28:	10800017 	ldw	r2,0(r2)
81108b2c:	01402ec4 	movi	r5,187
81108b30:	1009883a 	mov	r4,r2
81108b34:	1108e680 	call	81108e68 <uliRmapReadReg>
81108b38:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81108b3c:	e0bffe17 	ldw	r2,-8(fp)
81108b40:	1007883a 	mov	r3,r2
81108b44:	e0bfff17 	ldw	r2,-4(fp)
81108b48:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81108b4c:	e0bffe17 	ldw	r2,-8(fp)
81108b50:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81108b54:	1007883a 	mov	r3,r2
81108b58:	e0bfff17 	ldw	r2,-4(fp)
81108b5c:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b60:	e0bfff17 	ldw	r2,-4(fp)
81108b64:	10800017 	ldw	r2,0(r2)
81108b68:	01402f04 	movi	r5,188
81108b6c:	1009883a 	mov	r4,r2
81108b70:	1108e680 	call	81108e68 <uliRmapReadReg>
81108b74:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81108b78:	e0bffe17 	ldw	r2,-8(fp)
81108b7c:	1007883a 	mov	r3,r2
81108b80:	e0bfff17 	ldw	r2,-4(fp)
81108b84:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81108b88:	e0bffe17 	ldw	r2,-8(fp)
81108b8c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81108b90:	1007883a 	mov	r3,r2
81108b94:	e0bfff17 	ldw	r2,-4(fp)
81108b98:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b9c:	e0bfff17 	ldw	r2,-4(fp)
81108ba0:	10800017 	ldw	r2,0(r2)
81108ba4:	01402f44 	movi	r5,189
81108ba8:	1009883a 	mov	r4,r2
81108bac:	1108e680 	call	81108e68 <uliRmapReadReg>
81108bb0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81108bb4:	e0bffe17 	ldw	r2,-8(fp)
81108bb8:	1007883a 	mov	r3,r2
81108bbc:	e0bfff17 	ldw	r2,-4(fp)
81108bc0:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81108bc4:	e0bffe17 	ldw	r2,-8(fp)
81108bc8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81108bcc:	1007883a 	mov	r3,r2
81108bd0:	e0bfff17 	ldw	r2,-4(fp)
81108bd4:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bd8:	e0bfff17 	ldw	r2,-4(fp)
81108bdc:	10800017 	ldw	r2,0(r2)
81108be0:	01402f84 	movi	r5,190
81108be4:	1009883a 	mov	r4,r2
81108be8:	1108e680 	call	81108e68 <uliRmapReadReg>
81108bec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81108bf0:	e0bffe17 	ldw	r2,-8(fp)
81108bf4:	1007883a 	mov	r3,r2
81108bf8:	e0bfff17 	ldw	r2,-4(fp)
81108bfc:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81108c00:	e0bffe17 	ldw	r2,-8(fp)
81108c04:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81108c08:	1007883a 	mov	r3,r2
81108c0c:	e0bfff17 	ldw	r2,-4(fp)
81108c10:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c14:	e0bfff17 	ldw	r2,-4(fp)
81108c18:	10800017 	ldw	r2,0(r2)
81108c1c:	01402fc4 	movi	r5,191
81108c20:	1009883a 	mov	r4,r2
81108c24:	1108e680 	call	81108e68 <uliRmapReadReg>
81108c28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81108c2c:	e0bffe17 	ldw	r2,-8(fp)
81108c30:	1007883a 	mov	r3,r2
81108c34:	e0bfff17 	ldw	r2,-4(fp)
81108c38:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81108c3c:	e0bffe17 	ldw	r2,-8(fp)
81108c40:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81108c44:	1007883a 	mov	r3,r2
81108c48:	e0bfff17 	ldw	r2,-4(fp)
81108c4c:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81108c50:	00800044 	movi	r2,1
81108c54:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108c58:	e0bffd17 	ldw	r2,-12(fp)
}
81108c5c:	e037883a 	mov	sp,fp
81108c60:	dfc00117 	ldw	ra,4(sp)
81108c64:	df000017 	ldw	fp,0(sp)
81108c68:	dec00204 	addi	sp,sp,8
81108c6c:	f800283a 	ret

81108c70 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81108c70:	defffb04 	addi	sp,sp,-20
81108c74:	de00012e 	bgeu	sp,et,81108c7c <bRmapInitCh+0xc>
81108c78:	003b68fa 	trap	3
81108c7c:	dfc00415 	stw	ra,16(sp)
81108c80:	df000315 	stw	fp,12(sp)
81108c84:	df000304 	addi	fp,sp,12
81108c88:	e13ffe15 	stw	r4,-8(fp)
81108c8c:	2805883a 	mov	r2,r5
81108c90:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81108c94:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81108c98:	e0bffe17 	ldw	r2,-8(fp)
81108c9c:	10005726 	beq	r2,zero,81108dfc <bRmapInitCh+0x18c>
		bStatus = TRUE;
81108ca0:	00800044 	movi	r2,1
81108ca4:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81108ca8:	e0bfff03 	ldbu	r2,-4(fp)
81108cac:	10c00228 	cmpgeui	r3,r2,8
81108cb0:	1800361e 	bne	r3,zero,81108d8c <bRmapInitCh+0x11c>
81108cb4:	100690ba 	slli	r3,r2,2
81108cb8:	00a04474 	movhi	r2,33041
81108cbc:	10a33304 	addi	r2,r2,-29492
81108cc0:	1885883a 	add	r2,r3,r2
81108cc4:	10800017 	ldw	r2,0(r2)
81108cc8:	1000683a 	jmp	r2
81108ccc:	81108cec 	andhi	r4,r16,16947
81108cd0:	81108d00 	call	881108d0 <__reset+0x20f08d0>
81108cd4:	81108d14 	ori	r4,r16,16948
81108cd8:	81108d28 	cmpgeui	r4,r16,16948
81108cdc:	81108d3c 	xorhi	r4,r16,16948
81108ce0:	81108d50 	cmplti	r4,r16,16949
81108ce4:	81108d64 	muli	r4,r16,16949
81108ce8:	81108d78 	rdprs	r4,r16,16949
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81108cec:	e0fffe17 	ldw	r3,-8(fp)
81108cf0:	00a04834 	movhi	r2,33056
81108cf4:	108b0004 	addi	r2,r2,11264
81108cf8:	18800015 	stw	r2,0(r3)
			break;
81108cfc:	00002506 	br	81108d94 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81108d00:	e0fffe17 	ldw	r3,-8(fp)
81108d04:	00a04834 	movhi	r2,33056
81108d08:	108a0004 	addi	r2,r2,10240
81108d0c:	18800015 	stw	r2,0(r3)
			break;
81108d10:	00002006 	br	81108d94 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81108d14:	e0fffe17 	ldw	r3,-8(fp)
81108d18:	00a04834 	movhi	r2,33056
81108d1c:	10890004 	addi	r2,r2,9216
81108d20:	18800015 	stw	r2,0(r3)
			break;
81108d24:	00001b06 	br	81108d94 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81108d28:	e0fffe17 	ldw	r3,-8(fp)
81108d2c:	00a04834 	movhi	r2,33056
81108d30:	10880004 	addi	r2,r2,8192
81108d34:	18800015 	stw	r2,0(r3)
			break;
81108d38:	00001606 	br	81108d94 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81108d3c:	e0fffe17 	ldw	r3,-8(fp)
81108d40:	00a04834 	movhi	r2,33056
81108d44:	10870004 	addi	r2,r2,7168
81108d48:	18800015 	stw	r2,0(r3)
			break;
81108d4c:	00001106 	br	81108d94 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81108d50:	e0fffe17 	ldw	r3,-8(fp)
81108d54:	00a04834 	movhi	r2,33056
81108d58:	10860004 	addi	r2,r2,6144
81108d5c:	18800015 	stw	r2,0(r3)
			break;
81108d60:	00000c06 	br	81108d94 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81108d64:	e0fffe17 	ldw	r3,-8(fp)
81108d68:	00a04834 	movhi	r2,33056
81108d6c:	10850004 	addi	r2,r2,5120
81108d70:	18800015 	stw	r2,0(r3)
			break;
81108d74:	00000706 	br	81108d94 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81108d78:	e0fffe17 	ldw	r3,-8(fp)
81108d7c:	00a04834 	movhi	r2,33056
81108d80:	10840004 	addi	r2,r2,4096
81108d84:	18800015 	stw	r2,0(r3)
			break;
81108d88:	00000206 	br	81108d94 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81108d8c:	e03ffd15 	stw	zero,-12(fp)
			break;
81108d90:	0001883a 	nop
		}

		if (bStatus) {
81108d94:	e0bffd17 	ldw	r2,-12(fp)
81108d98:	10001826 	beq	r2,zero,81108dfc <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81108d9c:	e13ffe17 	ldw	r4,-8(fp)
81108da0:	1106cd00 	call	81106cd0 <bRmapGetIrqControl>
81108da4:	1000011e 	bne	r2,zero,81108dac <bRmapInitCh+0x13c>
				bStatus = FALSE;
81108da8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81108dac:	e13ffe17 	ldw	r4,-8(fp)
81108db0:	1106eb80 	call	81106eb8 <bRmapGetCodecConfig>
81108db4:	1000011e 	bne	r2,zero,81108dbc <bRmapInitCh+0x14c>
				bStatus = FALSE;
81108db8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81108dbc:	e13ffe17 	ldw	r4,-8(fp)
81108dc0:	1106f440 	call	81106f44 <bRmapGetCodecStatus>
81108dc4:	1000011e 	bne	r2,zero,81108dcc <bRmapInitCh+0x15c>
				bStatus = FALSE;
81108dc8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81108dcc:	e13ffe17 	ldw	r4,-8(fp)
81108dd0:	11074f00 	call	811074f0 <bRmapGetMemConfigArea>
81108dd4:	1000011e 	bne	r2,zero,81108ddc <bRmapInitCh+0x16c>
				bStatus = FALSE;
81108dd8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81108ddc:	e13ffe17 	ldw	r4,-8(fp)
81108de0:	11077c40 	call	811077c4 <bRmapGetMemConfigStat>
81108de4:	1000011e 	bne	r2,zero,81108dec <bRmapInitCh+0x17c>
				bStatus = FALSE;
81108de8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81108dec:	e13ffe17 	ldw	r4,-8(fp)
81108df0:	11084a40 	call	811084a4 <bRmapGetRmapMemHKArea>
81108df4:	1000011e 	bne	r2,zero,81108dfc <bRmapInitCh+0x18c>
				bStatus = FALSE;
81108df8:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81108dfc:	e0bffd17 	ldw	r2,-12(fp)
}
81108e00:	e037883a 	mov	sp,fp
81108e04:	dfc00117 	ldw	ra,4(sp)
81108e08:	df000017 	ldw	fp,0(sp)
81108e0c:	dec00204 	addi	sp,sp,8
81108e10:	f800283a 	ret

81108e14 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81108e14:	defffc04 	addi	sp,sp,-16
81108e18:	de00012e 	bgeu	sp,et,81108e20 <vRmapWriteReg+0xc>
81108e1c:	003b68fa 	trap	3
81108e20:	df000315 	stw	fp,12(sp)
81108e24:	df000304 	addi	fp,sp,12
81108e28:	e13ffd15 	stw	r4,-12(fp)
81108e2c:	e17ffe15 	stw	r5,-8(fp)
81108e30:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81108e34:	e0bffe17 	ldw	r2,-8(fp)
81108e38:	1085883a 	add	r2,r2,r2
81108e3c:	1085883a 	add	r2,r2,r2
81108e40:	1007883a 	mov	r3,r2
81108e44:	e0bffd17 	ldw	r2,-12(fp)
81108e48:	10c5883a 	add	r2,r2,r3
81108e4c:	e0ffff17 	ldw	r3,-4(fp)
81108e50:	10c00015 	stw	r3,0(r2)
}
81108e54:	0001883a 	nop
81108e58:	e037883a 	mov	sp,fp
81108e5c:	df000017 	ldw	fp,0(sp)
81108e60:	dec00104 	addi	sp,sp,4
81108e64:	f800283a 	ret

81108e68 <uliRmapReadReg>:

static alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81108e68:	defffc04 	addi	sp,sp,-16
81108e6c:	de00012e 	bgeu	sp,et,81108e74 <uliRmapReadReg+0xc>
81108e70:	003b68fa 	trap	3
81108e74:	df000315 	stw	fp,12(sp)
81108e78:	df000304 	addi	fp,sp,12
81108e7c:	e13ffe15 	stw	r4,-8(fp)
81108e80:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81108e84:	e0bfff17 	ldw	r2,-4(fp)
81108e88:	1085883a 	add	r2,r2,r2
81108e8c:	1085883a 	add	r2,r2,r2
81108e90:	1007883a 	mov	r3,r2
81108e94:	e0bffe17 	ldw	r2,-8(fp)
81108e98:	10c5883a 	add	r2,r2,r3
81108e9c:	10800017 	ldw	r2,0(r2)
81108ea0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81108ea4:	e0bffd17 	ldw	r2,-12(fp)
}
81108ea8:	e037883a 	mov	sp,fp
81108eac:	df000017 	ldw	fp,0(sp)
81108eb0:	dec00104 	addi	sp,sp,4
81108eb4:	f800283a 	ret

81108eb8 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81108eb8:	defffd04 	addi	sp,sp,-12
81108ebc:	de00012e 	bgeu	sp,et,81108ec4 <uliConvRmapCfgAddr+0xc>
81108ec0:	003b68fa 	trap	3
81108ec4:	df000215 	stw	fp,8(sp)
81108ec8:	df000204 	addi	fp,sp,8
81108ecc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81108ed0:	e0bfff17 	ldw	r2,-4(fp)
81108ed4:	10801368 	cmpgeui	r2,r2,77
81108ed8:	10008a1e 	bne	r2,zero,81109104 <uliConvRmapCfgAddr+0x24c>
81108edc:	e0bfff17 	ldw	r2,-4(fp)
81108ee0:	100690ba 	slli	r3,r2,2
81108ee4:	00a04474 	movhi	r2,33041
81108ee8:	10a3be04 	addi	r2,r2,-28936
81108eec:	1885883a 	add	r2,r3,r2
81108ef0:	10800017 	ldw	r2,0(r2)
81108ef4:	1000683a 	jmp	r2
81108ef8:	8110902c 	andhi	r4,r16,16960
81108efc:	81109104 	addi	r4,r16,16964
81108f00:	81109104 	addi	r4,r16,16964
81108f04:	81109104 	addi	r4,r16,16964
81108f08:	81109038 	rdprs	r4,r16,16960
81108f0c:	81109104 	addi	r4,r16,16964
81108f10:	81109104 	addi	r4,r16,16964
81108f14:	81109104 	addi	r4,r16,16964
81108f18:	81109044 	addi	r4,r16,16961
81108f1c:	81109104 	addi	r4,r16,16964
81108f20:	81109104 	addi	r4,r16,16964
81108f24:	81109104 	addi	r4,r16,16964
81108f28:	81109050 	cmplti	r4,r16,16961
81108f2c:	81109104 	addi	r4,r16,16964
81108f30:	81109104 	addi	r4,r16,16964
81108f34:	81109104 	addi	r4,r16,16964
81108f38:	8110905c 	xori	r4,r16,16961
81108f3c:	81109104 	addi	r4,r16,16964
81108f40:	81109104 	addi	r4,r16,16964
81108f44:	81109104 	addi	r4,r16,16964
81108f48:	81109068 	cmpgeui	r4,r16,16961
81108f4c:	81109104 	addi	r4,r16,16964
81108f50:	81109104 	addi	r4,r16,16964
81108f54:	81109104 	addi	r4,r16,16964
81108f58:	81109074 	orhi	r4,r16,16961
81108f5c:	81109104 	addi	r4,r16,16964
81108f60:	81109104 	addi	r4,r16,16964
81108f64:	81109104 	addi	r4,r16,16964
81108f68:	81109080 	call	88110908 <__reset+0x20f0908>
81108f6c:	81109104 	addi	r4,r16,16964
81108f70:	81109104 	addi	r4,r16,16964
81108f74:	81109104 	addi	r4,r16,16964
81108f78:	8110908c 	andi	r4,r16,16962
81108f7c:	81109104 	addi	r4,r16,16964
81108f80:	81109104 	addi	r4,r16,16964
81108f84:	81109104 	addi	r4,r16,16964
81108f88:	81109098 	cmpnei	r4,r16,16962
81108f8c:	81109104 	addi	r4,r16,16964
81108f90:	81109104 	addi	r4,r16,16964
81108f94:	81109104 	addi	r4,r16,16964
81108f98:	811090a4 	muli	r4,r16,16962
81108f9c:	81109104 	addi	r4,r16,16964
81108fa0:	81109104 	addi	r4,r16,16964
81108fa4:	81109104 	addi	r4,r16,16964
81108fa8:	811090b0 	cmpltui	r4,r16,16962
81108fac:	81109104 	addi	r4,r16,16964
81108fb0:	81109104 	addi	r4,r16,16964
81108fb4:	81109104 	addi	r4,r16,16964
81108fb8:	81109104 	addi	r4,r16,16964
81108fbc:	81109104 	addi	r4,r16,16964
81108fc0:	81109104 	addi	r4,r16,16964
81108fc4:	81109104 	addi	r4,r16,16964
81108fc8:	81109104 	addi	r4,r16,16964
81108fcc:	81109104 	addi	r4,r16,16964
81108fd0:	81109104 	addi	r4,r16,16964
81108fd4:	81109104 	addi	r4,r16,16964
81108fd8:	811090bc 	xorhi	r4,r16,16962
81108fdc:	81109104 	addi	r4,r16,16964
81108fe0:	81109104 	addi	r4,r16,16964
81108fe4:	81109104 	addi	r4,r16,16964
81108fe8:	811090c8 	cmpgei	r4,r16,16963
81108fec:	81109104 	addi	r4,r16,16964
81108ff0:	81109104 	addi	r4,r16,16964
81108ff4:	81109104 	addi	r4,r16,16964
81108ff8:	811090d4 	ori	r4,r16,16963
81108ffc:	81109104 	addi	r4,r16,16964
81109000:	81109104 	addi	r4,r16,16964
81109004:	81109104 	addi	r4,r16,16964
81109008:	811090e0 	cmpeqi	r4,r16,16963
8110900c:	81109104 	addi	r4,r16,16964
81109010:	81109104 	addi	r4,r16,16964
81109014:	81109104 	addi	r4,r16,16964
81109018:	811090ec 	andhi	r4,r16,16963
8110901c:	81109104 	addi	r4,r16,16964
81109020:	81109104 	addi	r4,r16,16964
81109024:	81109104 	addi	r4,r16,16964
81109028:	811090f8 	rdprs	r4,r16,16963
	case 0x00000000:
		uliValue = 0x00000040;
8110902c:	00801004 	movi	r2,64
81109030:	e0bffe15 	stw	r2,-8(fp)
		break;
81109034:	00003506 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
81109038:	00801044 	movi	r2,65
8110903c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109040:	00003206 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81109044:	00801084 	movi	r2,66
81109048:	e0bffe15 	stw	r2,-8(fp)
		break;
8110904c:	00002f06 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
81109050:	008010c4 	movi	r2,67
81109054:	e0bffe15 	stw	r2,-8(fp)
		break;
81109058:	00002c06 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110905c:	00801104 	movi	r2,68
81109060:	e0bffe15 	stw	r2,-8(fp)
		break;
81109064:	00002906 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
81109068:	00801144 	movi	r2,69
8110906c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109070:	00002606 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
81109074:	00801184 	movi	r2,70
81109078:	e0bffe15 	stw	r2,-8(fp)
		break;
8110907c:	00002306 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
81109080:	008011c4 	movi	r2,71
81109084:	e0bffe15 	stw	r2,-8(fp)
		break;
81109088:	00002006 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110908c:	00801204 	movi	r2,72
81109090:	e0bffe15 	stw	r2,-8(fp)
		break;
81109094:	00001d06 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
81109098:	00801244 	movi	r2,73
8110909c:	e0bffe15 	stw	r2,-8(fp)
		break;
811090a0:	00001a06 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
811090a4:	00801284 	movi	r2,74
811090a8:	e0bffe15 	stw	r2,-8(fp)
		break;
811090ac:	00001706 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
811090b0:	008012c4 	movi	r2,75
811090b4:	e0bffe15 	stw	r2,-8(fp)
		break;
811090b8:	00001406 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
811090bc:	00801304 	movi	r2,76
811090c0:	e0bffe15 	stw	r2,-8(fp)
		break;
811090c4:	00001106 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
811090c8:	00801344 	movi	r2,77
811090cc:	e0bffe15 	stw	r2,-8(fp)
		break;
811090d0:	00000e06 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
811090d4:	00801384 	movi	r2,78
811090d8:	e0bffe15 	stw	r2,-8(fp)
		break;
811090dc:	00000b06 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
811090e0:	008013c4 	movi	r2,79
811090e4:	e0bffe15 	stw	r2,-8(fp)
		break;
811090e8:	00000806 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
811090ec:	00801404 	movi	r2,80
811090f0:	e0bffe15 	stw	r2,-8(fp)
		break;
811090f4:	00000506 	br	8110910c <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
811090f8:	00801444 	movi	r2,81
811090fc:	e0bffe15 	stw	r2,-8(fp)
		break;
81109100:	00000206 	br	8110910c <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
81109104:	e03ffe15 	stw	zero,-8(fp)
		break;
81109108:	0001883a 	nop
	}

	return uliValue;
8110910c:	e0bffe17 	ldw	r2,-8(fp)
}
81109110:	e037883a 	mov	sp,fp
81109114:	df000017 	ldw	fp,0(sp)
81109118:	dec00104 	addi	sp,sp,4
8110911c:	f800283a 	ret

81109120 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
81109120:	defffb04 	addi	sp,sp,-20
81109124:	de00012e 	bgeu	sp,et,8110912c <bSpwcSetLink+0xc>
81109128:	003b68fa 	trap	3
8110912c:	dfc00415 	stw	ra,16(sp)
81109130:	df000315 	stw	fp,12(sp)
81109134:	df000304 	addi	fp,sp,12
81109138:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110913c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109140:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109144:	e0bfff17 	ldw	r2,-4(fp)
81109148:	10003c26 	beq	r2,zero,8110923c <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110914c:	e0bfff17 	ldw	r2,-4(fp)
81109150:	10800017 	ldw	r2,0(r2)
81109154:	000b883a 	mov	r5,zero
81109158:	1009883a 	mov	r4,r2
8110915c:	11097ec0 	call	811097ec <uliSpwcReadReg>
81109160:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
81109164:	e0bfff17 	ldw	r2,-4(fp)
81109168:	10800117 	ldw	r2,4(r2)
8110916c:	10000426 	beq	r2,zero,81109180 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
81109170:	e0bffe17 	ldw	r2,-8(fp)
81109174:	10800114 	ori	r2,r2,4
81109178:	e0bffe15 	stw	r2,-8(fp)
8110917c:	00000406 	br	81109190 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
81109180:	e0fffe17 	ldw	r3,-8(fp)
81109184:	00bffec4 	movi	r2,-5
81109188:	1884703a 	and	r2,r3,r2
8110918c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
81109190:	e0bfff17 	ldw	r2,-4(fp)
81109194:	10800217 	ldw	r2,8(r2)
81109198:	10000426 	beq	r2,zero,811091ac <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110919c:	e0bffe17 	ldw	r2,-8(fp)
811091a0:	10800094 	ori	r2,r2,2
811091a4:	e0bffe15 	stw	r2,-8(fp)
811091a8:	00000406 	br	811091bc <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
811091ac:	e0fffe17 	ldw	r3,-8(fp)
811091b0:	00bfff44 	movi	r2,-3
811091b4:	1884703a 	and	r2,r3,r2
811091b8:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
811091bc:	e0bfff17 	ldw	r2,-4(fp)
811091c0:	10800317 	ldw	r2,12(r2)
811091c4:	10000426 	beq	r2,zero,811091d8 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
811091c8:	e0bffe17 	ldw	r2,-8(fp)
811091cc:	10800054 	ori	r2,r2,1
811091d0:	e0bffe15 	stw	r2,-8(fp)
811091d4:	00000406 	br	811091e8 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
811091d8:	e0fffe17 	ldw	r3,-8(fp)
811091dc:	00bfff84 	movi	r2,-2
811091e0:	1884703a 	and	r2,r3,r2
811091e4:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
811091e8:	e0fffe17 	ldw	r3,-8(fp)
811091ec:	00804034 	movhi	r2,256
811091f0:	10bfffc4 	addi	r2,r2,-1
811091f4:	1884703a 	and	r2,r3,r2
811091f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
811091fc:	e0bfff17 	ldw	r2,-4(fp)
81109200:	10800403 	ldbu	r2,16(r2)
81109204:	10803fcc 	andi	r2,r2,255
81109208:	1004963a 	slli	r2,r2,24
8110920c:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
81109210:	e0bffe17 	ldw	r2,-8(fp)
81109214:	10c4b03a 	or	r2,r2,r3
81109218:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110921c:	e0bfff17 	ldw	r2,-4(fp)
81109220:	10800017 	ldw	r2,0(r2)
81109224:	e1bffe17 	ldw	r6,-8(fp)
81109228:	000b883a 	mov	r5,zero
8110922c:	1009883a 	mov	r4,r2
81109230:	11097980 	call	81109798 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
81109234:	00800044 	movi	r2,1
81109238:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110923c:	e0bffd17 	ldw	r2,-12(fp)
}
81109240:	e037883a 	mov	sp,fp
81109244:	dfc00117 	ldw	ra,4(sp)
81109248:	df000017 	ldw	fp,0(sp)
8110924c:	dec00204 	addi	sp,sp,8
81109250:	f800283a 	ret

81109254 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
81109254:	defffb04 	addi	sp,sp,-20
81109258:	de00012e 	bgeu	sp,et,81109260 <bSpwcGetLink+0xc>
8110925c:	003b68fa 	trap	3
81109260:	dfc00415 	stw	ra,16(sp)
81109264:	df000315 	stw	fp,12(sp)
81109268:	df000304 	addi	fp,sp,12
8110926c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109270:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109274:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109278:	e0bfff17 	ldw	r2,-4(fp)
8110927c:	10002826 	beq	r2,zero,81109320 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109280:	e0bfff17 	ldw	r2,-4(fp)
81109284:	10800017 	ldw	r2,0(r2)
81109288:	000b883a 	mov	r5,zero
8110928c:	1009883a 	mov	r4,r2
81109290:	11097ec0 	call	811097ec <uliSpwcReadReg>
81109294:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
81109298:	e0bffe17 	ldw	r2,-8(fp)
8110929c:	1080010c 	andi	r2,r2,4
811092a0:	10000426 	beq	r2,zero,811092b4 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
811092a4:	e0bfff17 	ldw	r2,-4(fp)
811092a8:	00c00044 	movi	r3,1
811092ac:	10c00115 	stw	r3,4(r2)
811092b0:	00000206 	br	811092bc <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
811092b4:	e0bfff17 	ldw	r2,-4(fp)
811092b8:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
811092bc:	e0bffe17 	ldw	r2,-8(fp)
811092c0:	1080008c 	andi	r2,r2,2
811092c4:	10000426 	beq	r2,zero,811092d8 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
811092c8:	e0bfff17 	ldw	r2,-4(fp)
811092cc:	00c00044 	movi	r3,1
811092d0:	10c00215 	stw	r3,8(r2)
811092d4:	00000206 	br	811092e0 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
811092d8:	e0bfff17 	ldw	r2,-4(fp)
811092dc:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
811092e0:	e0bffe17 	ldw	r2,-8(fp)
811092e4:	1080004c 	andi	r2,r2,1
811092e8:	10000426 	beq	r2,zero,811092fc <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
811092ec:	e0bfff17 	ldw	r2,-4(fp)
811092f0:	00c00044 	movi	r3,1
811092f4:	10c00315 	stw	r3,12(r2)
811092f8:	00000206 	br	81109304 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
811092fc:	e0bfff17 	ldw	r2,-4(fp)
81109300:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
81109304:	e0bffe17 	ldw	r2,-8(fp)
81109308:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110930c:	1007883a 	mov	r3,r2
81109310:	e0bfff17 	ldw	r2,-4(fp)
81109314:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
81109318:	00800044 	movi	r2,1
8110931c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109320:	e0bffd17 	ldw	r2,-12(fp)
}
81109324:	e037883a 	mov	sp,fp
81109328:	dfc00117 	ldw	ra,4(sp)
8110932c:	df000017 	ldw	fp,0(sp)
81109330:	dec00204 	addi	sp,sp,8
81109334:	f800283a 	ret

81109338 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
81109338:	defffb04 	addi	sp,sp,-20
8110933c:	de00012e 	bgeu	sp,et,81109344 <bSpwcGetLinkError+0xc>
81109340:	003b68fa 	trap	3
81109344:	dfc00415 	stw	ra,16(sp)
81109348:	df000315 	stw	fp,12(sp)
8110934c:	df000304 	addi	fp,sp,12
81109350:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109354:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109358:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110935c:	e0bfff17 	ldw	r2,-4(fp)
81109360:	10002c26 	beq	r2,zero,81109414 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109364:	e0bfff17 	ldw	r2,-4(fp)
81109368:	10800017 	ldw	r2,0(r2)
8110936c:	000b883a 	mov	r5,zero
81109370:	1009883a 	mov	r4,r2
81109374:	11097ec0 	call	811097ec <uliSpwcReadReg>
81109378:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110937c:	e0bffe17 	ldw	r2,-8(fp)
81109380:	1080006c 	andhi	r2,r2,1
81109384:	10000426 	beq	r2,zero,81109398 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
81109388:	e0bfff17 	ldw	r2,-4(fp)
8110938c:	00c00044 	movi	r3,1
81109390:	10c00515 	stw	r3,20(r2)
81109394:	00000206 	br	811093a0 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
81109398:	e0bfff17 	ldw	r2,-4(fp)
8110939c:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
811093a0:	e0bffe17 	ldw	r2,-8(fp)
811093a4:	108000ac 	andhi	r2,r2,2
811093a8:	10000426 	beq	r2,zero,811093bc <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
811093ac:	e0bfff17 	ldw	r2,-4(fp)
811093b0:	00c00044 	movi	r3,1
811093b4:	10c00615 	stw	r3,24(r2)
811093b8:	00000206 	br	811093c4 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
811093bc:	e0bfff17 	ldw	r2,-4(fp)
811093c0:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
811093c4:	e0bffe17 	ldw	r2,-8(fp)
811093c8:	1080012c 	andhi	r2,r2,4
811093cc:	10000426 	beq	r2,zero,811093e0 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
811093d0:	e0bfff17 	ldw	r2,-4(fp)
811093d4:	00c00044 	movi	r3,1
811093d8:	10c00715 	stw	r3,28(r2)
811093dc:	00000206 	br	811093e8 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
811093e0:	e0bfff17 	ldw	r2,-4(fp)
811093e4:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
811093e8:	e0bffe17 	ldw	r2,-8(fp)
811093ec:	1080022c 	andhi	r2,r2,8
811093f0:	10000426 	beq	r2,zero,81109404 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
811093f4:	e0bfff17 	ldw	r2,-4(fp)
811093f8:	00c00044 	movi	r3,1
811093fc:	10c00815 	stw	r3,32(r2)
81109400:	00000206 	br	8110940c <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81109404:	e0bfff17 	ldw	r2,-4(fp)
81109408:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110940c:	00800044 	movi	r2,1
81109410:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109414:	e0bffd17 	ldw	r2,-12(fp)
}
81109418:	e037883a 	mov	sp,fp
8110941c:	dfc00117 	ldw	ra,4(sp)
81109420:	df000017 	ldw	fp,0(sp)
81109424:	dec00204 	addi	sp,sp,8
81109428:	f800283a 	ret

8110942c <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110942c:	defffb04 	addi	sp,sp,-20
81109430:	de00012e 	bgeu	sp,et,81109438 <bSpwcGetLinkStatus+0xc>
81109434:	003b68fa 	trap	3
81109438:	dfc00415 	stw	ra,16(sp)
8110943c:	df000315 	stw	fp,12(sp)
81109440:	df000304 	addi	fp,sp,12
81109444:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109448:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110944c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109450:	e0bfff17 	ldw	r2,-4(fp)
81109454:	10002326 	beq	r2,zero,811094e4 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109458:	e0bfff17 	ldw	r2,-4(fp)
8110945c:	10800017 	ldw	r2,0(r2)
81109460:	000b883a 	mov	r5,zero
81109464:	1009883a 	mov	r4,r2
81109468:	11097ec0 	call	811097ec <uliSpwcReadReg>
8110946c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
81109470:	e0bffe17 	ldw	r2,-8(fp)
81109474:	1081000c 	andi	r2,r2,1024
81109478:	10000426 	beq	r2,zero,8110948c <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110947c:	e0bfff17 	ldw	r2,-4(fp)
81109480:	00c00044 	movi	r3,1
81109484:	10c00915 	stw	r3,36(r2)
81109488:	00000206 	br	81109494 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110948c:	e0bfff17 	ldw	r2,-4(fp)
81109490:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
81109494:	e0bffe17 	ldw	r2,-8(fp)
81109498:	1080800c 	andi	r2,r2,512
8110949c:	10000426 	beq	r2,zero,811094b0 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
811094a0:	e0bfff17 	ldw	r2,-4(fp)
811094a4:	00c00044 	movi	r3,1
811094a8:	10c00a15 	stw	r3,40(r2)
811094ac:	00000206 	br	811094b8 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
811094b0:	e0bfff17 	ldw	r2,-4(fp)
811094b4:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
811094b8:	e0bffe17 	ldw	r2,-8(fp)
811094bc:	1080400c 	andi	r2,r2,256
811094c0:	10000426 	beq	r2,zero,811094d4 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
811094c4:	e0bfff17 	ldw	r2,-4(fp)
811094c8:	00c00044 	movi	r3,1
811094cc:	10c00b15 	stw	r3,44(r2)
811094d0:	00000206 	br	811094dc <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
811094d4:	e0bfff17 	ldw	r2,-4(fp)
811094d8:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
811094dc:	00800044 	movi	r2,1
811094e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811094e4:	e0bffd17 	ldw	r2,-12(fp)
}
811094e8:	e037883a 	mov	sp,fp
811094ec:	dfc00117 	ldw	ra,4(sp)
811094f0:	df000017 	ldw	fp,0(sp)
811094f4:	dec00204 	addi	sp,sp,8
811094f8:	f800283a 	ret

811094fc <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
811094fc:	defffb04 	addi	sp,sp,-20
81109500:	de00012e 	bgeu	sp,et,81109508 <bSpwcGetTimecode+0xc>
81109504:	003b68fa 	trap	3
81109508:	dfc00415 	stw	ra,16(sp)
8110950c:	df000315 	stw	fp,12(sp)
81109510:	df000304 	addi	fp,sp,12
81109514:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109518:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110951c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109520:	e0bfff17 	ldw	r2,-4(fp)
81109524:	10001326 	beq	r2,zero,81109574 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109528:	e0bfff17 	ldw	r2,-4(fp)
8110952c:	10800017 	ldw	r2,0(r2)
81109530:	01400044 	movi	r5,1
81109534:	1009883a 	mov	r4,r2
81109538:	11097ec0 	call	811097ec <uliSpwcReadReg>
8110953c:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
81109540:	e0bffe17 	ldw	r2,-8(fp)
81109544:	1080300c 	andi	r2,r2,192
81109548:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110954c:	1007883a 	mov	r3,r2
81109550:	e0bfff17 	ldw	r2,-4(fp)
81109554:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
81109558:	e0bffe17 	ldw	r2,-8(fp)
8110955c:	10800fcc 	andi	r2,r2,63
81109560:	1007883a 	mov	r3,r2
81109564:	e0bfff17 	ldw	r2,-4(fp)
81109568:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110956c:	00800044 	movi	r2,1
81109570:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109574:	e0bffd17 	ldw	r2,-12(fp)
}
81109578:	e037883a 	mov	sp,fp
8110957c:	dfc00117 	ldw	ra,4(sp)
81109580:	df000017 	ldw	fp,0(sp)
81109584:	dec00204 	addi	sp,sp,8
81109588:	f800283a 	ret

8110958c <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110958c:	defffb04 	addi	sp,sp,-20
81109590:	de00012e 	bgeu	sp,et,81109598 <bSpwcClearTimecode+0xc>
81109594:	003b68fa 	trap	3
81109598:	dfc00415 	stw	ra,16(sp)
8110959c:	df000315 	stw	fp,12(sp)
811095a0:	df000304 	addi	fp,sp,12
811095a4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811095a8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811095ac:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811095b0:	e0bfff17 	ldw	r2,-4(fp)
811095b4:	10001126 	beq	r2,zero,811095fc <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811095b8:	e0bfff17 	ldw	r2,-4(fp)
811095bc:	10800017 	ldw	r2,0(r2)
811095c0:	01400044 	movi	r5,1
811095c4:	1009883a 	mov	r4,r2
811095c8:	11097ec0 	call	811097ec <uliSpwcReadReg>
811095cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
811095d0:	e0bffe17 	ldw	r2,-8(fp)
811095d4:	10804014 	ori	r2,r2,256
811095d8:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
811095dc:	e0bfff17 	ldw	r2,-4(fp)
811095e0:	10800017 	ldw	r2,0(r2)
811095e4:	e1bffe17 	ldw	r6,-8(fp)
811095e8:	01400044 	movi	r5,1
811095ec:	1009883a 	mov	r4,r2
811095f0:	11097980 	call	81109798 <vSpwcWriteReg>
		bStatus = TRUE;
811095f4:	00800044 	movi	r2,1
811095f8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811095fc:	e0bffd17 	ldw	r2,-12(fp)
}
81109600:	e037883a 	mov	sp,fp
81109604:	dfc00117 	ldw	ra,4(sp)
81109608:	df000017 	ldw	fp,0(sp)
8110960c:	dec00204 	addi	sp,sp,8
81109610:	f800283a 	ret

81109614 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81109614:	defffb04 	addi	sp,sp,-20
81109618:	de00012e 	bgeu	sp,et,81109620 <bSpwcInitCh+0xc>
8110961c:	003b68fa 	trap	3
81109620:	dfc00415 	stw	ra,16(sp)
81109624:	df000315 	stw	fp,12(sp)
81109628:	df000304 	addi	fp,sp,12
8110962c:	e13ffe15 	stw	r4,-8(fp)
81109630:	2805883a 	mov	r2,r5
81109634:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109638:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110963c:	e0bffe17 	ldw	r2,-8(fp)
81109640:	10004f26 	beq	r2,zero,81109780 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
81109644:	00800044 	movi	r2,1
81109648:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
8110964c:	e0bfff03 	ldbu	r2,-4(fp)
81109650:	10c00228 	cmpgeui	r3,r2,8
81109654:	1800361e 	bne	r3,zero,81109730 <bSpwcInitCh+0x11c>
81109658:	100690ba 	slli	r3,r2,2
8110965c:	00a04474 	movhi	r2,33041
81109660:	10a59c04 	addi	r2,r2,-27024
81109664:	1885883a 	add	r2,r3,r2
81109668:	10800017 	ldw	r2,0(r2)
8110966c:	1000683a 	jmp	r2
81109670:	81109690 	cmplti	r4,r16,16986
81109674:	811096a4 	muli	r4,r16,16986
81109678:	811096b8 	rdprs	r4,r16,16986
8110967c:	811096cc 	andi	r4,r16,16987
81109680:	811096e0 	cmpeqi	r4,r16,16987
81109684:	811096f4 	orhi	r4,r16,16987
81109688:	81109708 	cmpgei	r4,r16,16988
8110968c:	8110971c 	xori	r4,r16,16988
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109690:	e0fffe17 	ldw	r3,-8(fp)
81109694:	00a04834 	movhi	r2,33056
81109698:	108b0004 	addi	r2,r2,11264
8110969c:	18800015 	stw	r2,0(r3)
			break;
811096a0:	00002506 	br	81109738 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811096a4:	e0fffe17 	ldw	r3,-8(fp)
811096a8:	00a04834 	movhi	r2,33056
811096ac:	108a0004 	addi	r2,r2,10240
811096b0:	18800015 	stw	r2,0(r3)
			break;
811096b4:	00002006 	br	81109738 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811096b8:	e0fffe17 	ldw	r3,-8(fp)
811096bc:	00a04834 	movhi	r2,33056
811096c0:	10890004 	addi	r2,r2,9216
811096c4:	18800015 	stw	r2,0(r3)
			break;
811096c8:	00001b06 	br	81109738 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811096cc:	e0fffe17 	ldw	r3,-8(fp)
811096d0:	00a04834 	movhi	r2,33056
811096d4:	10880004 	addi	r2,r2,8192
811096d8:	18800015 	stw	r2,0(r3)
			break;
811096dc:	00001606 	br	81109738 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811096e0:	e0fffe17 	ldw	r3,-8(fp)
811096e4:	00a04834 	movhi	r2,33056
811096e8:	10870004 	addi	r2,r2,7168
811096ec:	18800015 	stw	r2,0(r3)
			break;
811096f0:	00001106 	br	81109738 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811096f4:	e0fffe17 	ldw	r3,-8(fp)
811096f8:	00a04834 	movhi	r2,33056
811096fc:	10860004 	addi	r2,r2,6144
81109700:	18800015 	stw	r2,0(r3)
			break;
81109704:	00000c06 	br	81109738 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109708:	e0fffe17 	ldw	r3,-8(fp)
8110970c:	00a04834 	movhi	r2,33056
81109710:	10850004 	addi	r2,r2,5120
81109714:	18800015 	stw	r2,0(r3)
			break;
81109718:	00000706 	br	81109738 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110971c:	e0fffe17 	ldw	r3,-8(fp)
81109720:	00a04834 	movhi	r2,33056
81109724:	10840004 	addi	r2,r2,4096
81109728:	18800015 	stw	r2,0(r3)
			break;
8110972c:	00000206 	br	81109738 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
81109730:	e03ffd15 	stw	zero,-12(fp)
			break;
81109734:	0001883a 	nop
		}

		if (bStatus) {
81109738:	e0bffd17 	ldw	r2,-12(fp)
8110973c:	10001026 	beq	r2,zero,81109780 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
81109740:	e13ffe17 	ldw	r4,-8(fp)
81109744:	11092540 	call	81109254 <bSpwcGetLink>
81109748:	1000011e 	bne	r2,zero,81109750 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
8110974c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
81109750:	e13ffe17 	ldw	r4,-8(fp)
81109754:	11093380 	call	81109338 <bSpwcGetLinkError>
81109758:	1000011e 	bne	r2,zero,81109760 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
8110975c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
81109760:	e13ffe17 	ldw	r4,-8(fp)
81109764:	110942c0 	call	8110942c <bSpwcGetLinkStatus>
81109768:	1000011e 	bne	r2,zero,81109770 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
8110976c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
81109770:	e13ffe17 	ldw	r4,-8(fp)
81109774:	11094fc0 	call	811094fc <bSpwcGetTimecode>
81109778:	1000011e 	bne	r2,zero,81109780 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
8110977c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109780:	e0bffd17 	ldw	r2,-12(fp)
}
81109784:	e037883a 	mov	sp,fp
81109788:	dfc00117 	ldw	ra,4(sp)
8110978c:	df000017 	ldw	fp,0(sp)
81109790:	dec00204 	addi	sp,sp,8
81109794:	f800283a 	ret

81109798 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109798:	defffc04 	addi	sp,sp,-16
8110979c:	de00012e 	bgeu	sp,et,811097a4 <vSpwcWriteReg+0xc>
811097a0:	003b68fa 	trap	3
811097a4:	df000315 	stw	fp,12(sp)
811097a8:	df000304 	addi	fp,sp,12
811097ac:	e13ffd15 	stw	r4,-12(fp)
811097b0:	e17ffe15 	stw	r5,-8(fp)
811097b4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811097b8:	e0bffe17 	ldw	r2,-8(fp)
811097bc:	1085883a 	add	r2,r2,r2
811097c0:	1085883a 	add	r2,r2,r2
811097c4:	1007883a 	mov	r3,r2
811097c8:	e0bffd17 	ldw	r2,-12(fp)
811097cc:	10c5883a 	add	r2,r2,r3
811097d0:	e0ffff17 	ldw	r3,-4(fp)
811097d4:	10c00015 	stw	r3,0(r2)
}
811097d8:	0001883a 	nop
811097dc:	e037883a 	mov	sp,fp
811097e0:	df000017 	ldw	fp,0(sp)
811097e4:	dec00104 	addi	sp,sp,4
811097e8:	f800283a 	ret

811097ec <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811097ec:	defffc04 	addi	sp,sp,-16
811097f0:	de00012e 	bgeu	sp,et,811097f8 <uliSpwcReadReg+0xc>
811097f4:	003b68fa 	trap	3
811097f8:	df000315 	stw	fp,12(sp)
811097fc:	df000304 	addi	fp,sp,12
81109800:	e13ffe15 	stw	r4,-8(fp)
81109804:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109808:	e0bfff17 	ldw	r2,-4(fp)
8110980c:	1085883a 	add	r2,r2,r2
81109810:	1085883a 	add	r2,r2,r2
81109814:	1007883a 	mov	r3,r2
81109818:	e0bffe17 	ldw	r2,-8(fp)
8110981c:	10c5883a 	add	r2,r2,r3
81109820:	10800017 	ldw	r2,0(r2)
81109824:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109828:	e0bffd17 	ldw	r2,-12(fp)
}
8110982c:	e037883a 	mov	sp,fp
81109830:	df000017 	ldw	fp,0(sp)
81109834:	dec00104 	addi	sp,sp,4
81109838:	f800283a 	ret

8110983c <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110983c:	defffe04 	addi	sp,sp,-8
81109840:	de00012e 	bgeu	sp,et,81109848 <bEnableIsoDrivers+0xc>
81109844:	003b68fa 	trap	3
81109848:	dfc00115 	stw	ra,4(sp)
8110984c:	df000015 	stw	fp,0(sp)
81109850:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
81109854:	01400204 	movi	r5,8
81109858:	01000044 	movi	r4,1
8110985c:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
  return  TRUE;
81109860:	00800044 	movi	r2,1
}
81109864:	e037883a 	mov	sp,fp
81109868:	dfc00117 	ldw	ra,4(sp)
8110986c:	df000017 	ldw	fp,0(sp)
81109870:	dec00204 	addi	sp,sp,8
81109874:	f800283a 	ret

81109878 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
81109878:	defffe04 	addi	sp,sp,-8
8110987c:	de00012e 	bgeu	sp,et,81109884 <bDisableIsoDrivers+0xc>
81109880:	003b68fa 	trap	3
81109884:	dfc00115 	stw	ra,4(sp)
81109888:	df000015 	stw	fp,0(sp)
8110988c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
81109890:	01400204 	movi	r5,8
81109894:	0009883a 	mov	r4,zero
81109898:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
  return  TRUE;
8110989c:	00800044 	movi	r2,1
}
811098a0:	e037883a 	mov	sp,fp
811098a4:	dfc00117 	ldw	ra,4(sp)
811098a8:	df000017 	ldw	fp,0(sp)
811098ac:	dec00204 	addi	sp,sp,8
811098b0:	f800283a 	ret

811098b4 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
811098b4:	defffe04 	addi	sp,sp,-8
811098b8:	de00012e 	bgeu	sp,et,811098c0 <bEnableLvdsBoard+0xc>
811098bc:	003b68fa 	trap	3
811098c0:	dfc00115 	stw	ra,4(sp)
811098c4:	df000015 	stw	fp,0(sp)
811098c8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
811098cc:	01400104 	movi	r5,4
811098d0:	01000044 	movi	r4,1
811098d4:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
  return  TRUE;
811098d8:	00800044 	movi	r2,1
}
811098dc:	e037883a 	mov	sp,fp
811098e0:	dfc00117 	ldw	ra,4(sp)
811098e4:	df000017 	ldw	fp,0(sp)
811098e8:	dec00204 	addi	sp,sp,8
811098ec:	f800283a 	ret

811098f0 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
811098f0:	defffe04 	addi	sp,sp,-8
811098f4:	de00012e 	bgeu	sp,et,811098fc <bDisableLvdsBoard+0xc>
811098f8:	003b68fa 	trap	3
811098fc:	dfc00115 	stw	ra,4(sp)
81109900:	df000015 	stw	fp,0(sp)
81109904:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
81109908:	01400104 	movi	r5,4
8110990c:	0009883a 	mov	r4,zero
81109910:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
  return  TRUE;
81109914:	00800044 	movi	r2,1
}
81109918:	e037883a 	mov	sp,fp
8110991c:	dfc00117 	ldw	ra,4(sp)
81109920:	df000017 	ldw	fp,0(sp)
81109924:	dec00204 	addi	sp,sp,8
81109928:	f800283a 	ret

8110992c <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110992c:	defffd04 	addi	sp,sp,-12
81109930:	de00012e 	bgeu	sp,et,81109938 <bSetPreEmphasys+0xc>
81109934:	003b68fa 	trap	3
81109938:	dfc00215 	stw	ra,8(sp)
8110993c:	df000115 	stw	fp,4(sp)
81109940:	df000104 	addi	fp,sp,4
81109944:	2005883a 	mov	r2,r4
81109948:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110994c:	e0bfff03 	ldbu	r2,-4(fp)
81109950:	10c00060 	cmpeqi	r3,r2,1
81109954:	18000d1e 	bne	r3,zero,8110998c <bSetPreEmphasys+0x60>
81109958:	10c00088 	cmpgei	r3,r2,2
8110995c:	1800021e 	bne	r3,zero,81109968 <bSetPreEmphasys+0x3c>
81109960:	10000626 	beq	r2,zero,8110997c <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81109964:	00001b06 	br	811099d4 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
81109968:	10c000a0 	cmpeqi	r3,r2,2
8110996c:	18000e1e 	bne	r3,zero,811099a8 <bSetPreEmphasys+0x7c>
81109970:	108000e0 	cmpeqi	r2,r2,3
81109974:	1000131e 	bne	r2,zero,811099c4 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81109978:	00001606 	br	811099d4 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110997c:	014000c4 	movi	r5,3
81109980:	0009883a 	mov	r4,zero
81109984:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
      break;
81109988:	00001206 	br	811099d4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110998c:	01400084 	movi	r5,2
81109990:	0009883a 	mov	r4,zero
81109994:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
81109998:	01400044 	movi	r5,1
8110999c:	01000044 	movi	r4,1
811099a0:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
      break;
811099a4:	00000b06 	br	811099d4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
811099a8:	01400044 	movi	r5,1
811099ac:	0009883a 	mov	r4,zero
811099b0:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
811099b4:	01400084 	movi	r5,2
811099b8:	01000044 	movi	r4,1
811099bc:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
      break;
811099c0:	00000406 	br	811099d4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
811099c4:	014000c4 	movi	r5,3
811099c8:	01000044 	movi	r4,1
811099cc:	11099ec0 	call	811099ec <bCtrlIoLvdsDrive>
      break;
811099d0:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
811099d4:	00800044 	movi	r2,1
}
811099d8:	e037883a 	mov	sp,fp
811099dc:	dfc00117 	ldw	ra,4(sp)
811099e0:	df000017 	ldw	fp,0(sp)
811099e4:	dec00204 	addi	sp,sp,8
811099e8:	f800283a 	ret

811099ec <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
811099ec:	defffd04 	addi	sp,sp,-12
811099f0:	de00012e 	bgeu	sp,et,811099f8 <bCtrlIoLvdsDrive+0xc>
811099f4:	003b68fa 	trap	3
811099f8:	df000215 	stw	fp,8(sp)
811099fc:	df000204 	addi	fp,sp,8
81109a00:	e13ffe15 	stw	r4,-8(fp)
81109a04:	2805883a 	mov	r2,r5
81109a08:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
81109a0c:	e0bffe17 	ldw	r2,-8(fp)
81109a10:	1000071e 	bne	r2,zero,81109a30 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
81109a14:	e0bfff03 	ldbu	r2,-4(fp)
81109a18:	0084303a 	nor	r2,zero,r2
81109a1c:	1007883a 	mov	r3,r2
81109a20:	d0a00103 	ldbu	r2,-32764(gp)
81109a24:	1884703a 	and	r2,r3,r2
81109a28:	d0a00105 	stb	r2,-32764(gp)
81109a2c:	00000406 	br	81109a40 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
81109a30:	d0e00103 	ldbu	r3,-32764(gp)
81109a34:	e0bfff03 	ldbu	r2,-4(fp)
81109a38:	1884b03a 	or	r2,r3,r2
81109a3c:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
81109a40:	d0a00103 	ldbu	r2,-32764(gp)
81109a44:	10c03fcc 	andi	r3,r2,255
81109a48:	00a00034 	movhi	r2,32768
81109a4c:	10822804 	addi	r2,r2,2208
81109a50:	10c00035 	stwio	r3,0(r2)
  return TRUE;
81109a54:	00800044 	movi	r2,1
}
81109a58:	e037883a 	mov	sp,fp
81109a5c:	df000017 	ldw	fp,0(sp)
81109a60:	dec00104 	addi	sp,sp,4
81109a64:	f800283a 	ret

81109a68 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
81109a68:	defffa04 	addi	sp,sp,-24
81109a6c:	de00012e 	bgeu	sp,et,81109a74 <I2C_TestAdress+0xc>
81109a70:	003b68fa 	trap	3
81109a74:	dfc00515 	stw	ra,20(sp)
81109a78:	df000415 	stw	fp,16(sp)
81109a7c:	df000404 	addi	fp,sp,16
81109a80:	e13ffd15 	stw	r4,-12(fp)
81109a84:	e17ffe15 	stw	r5,-8(fp)
81109a88:	3005883a 	mov	r2,r6
81109a8c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109a90:	00800044 	movi	r2,1
81109a94:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109a98:	e17ffe17 	ldw	r5,-8(fp)
81109a9c:	e13ffd17 	ldw	r4,-12(fp)
81109aa0:	1109e380 	call	81109e38 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109aa4:	e0bfff03 	ldbu	r2,-4(fp)
81109aa8:	10803fcc 	andi	r2,r2,255
81109aac:	100d883a 	mov	r6,r2
81109ab0:	e17ffe17 	ldw	r5,-8(fp)
81109ab4:	e13ffd17 	ldw	r4,-12(fp)
81109ab8:	1109f4c0 	call	81109f4c <i2c_write>
81109abc:	1000011e 	bne	r2,zero,81109ac4 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
81109ac0:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81109ac4:	e17ffe17 	ldw	r5,-8(fp)
81109ac8:	e13ffd17 	ldw	r4,-12(fp)
81109acc:	1109ecc0 	call	81109ecc <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81109ad0:	0106d604 	movi	r4,7000
81109ad4:	11333f40 	call	811333f4 <usleep>
    
    return bSuccess;
81109ad8:	e0bffc17 	ldw	r2,-16(fp)

}
81109adc:	e037883a 	mov	sp,fp
81109ae0:	dfc00117 	ldw	ra,4(sp)
81109ae4:	df000017 	ldw	fp,0(sp)
81109ae8:	dec00204 	addi	sp,sp,8
81109aec:	f800283a 	ret

81109af0 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
81109af0:	defff804 	addi	sp,sp,-32
81109af4:	de00012e 	bgeu	sp,et,81109afc <I2C_Write+0xc>
81109af8:	003b68fa 	trap	3
81109afc:	dfc00715 	stw	ra,28(sp)
81109b00:	df000615 	stw	fp,24(sp)
81109b04:	df000604 	addi	fp,sp,24
81109b08:	e13ffb15 	stw	r4,-20(fp)
81109b0c:	e17ffc15 	stw	r5,-16(fp)
81109b10:	3009883a 	mov	r4,r6
81109b14:	3807883a 	mov	r3,r7
81109b18:	e0800217 	ldw	r2,8(fp)
81109b1c:	e13ffd05 	stb	r4,-12(fp)
81109b20:	e0fffe05 	stb	r3,-8(fp)
81109b24:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109b28:	00800044 	movi	r2,1
81109b2c:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109b30:	e17ffc17 	ldw	r5,-16(fp)
81109b34:	e13ffb17 	ldw	r4,-20(fp)
81109b38:	1109e380 	call	81109e38 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109b3c:	e0bffd03 	ldbu	r2,-12(fp)
81109b40:	10803fcc 	andi	r2,r2,255
81109b44:	100d883a 	mov	r6,r2
81109b48:	e17ffc17 	ldw	r5,-16(fp)
81109b4c:	e13ffb17 	ldw	r4,-20(fp)
81109b50:	1109f4c0 	call	81109f4c <i2c_write>
81109b54:	1000011e 	bne	r2,zero,81109b5c <I2C_Write+0x6c>
        bSuccess = FALSE;
81109b58:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109b5c:	e0bffa17 	ldw	r2,-24(fp)
81109b60:	10000726 	beq	r2,zero,81109b80 <I2C_Write+0x90>
81109b64:	e0bffe03 	ldbu	r2,-8(fp)
81109b68:	100d883a 	mov	r6,r2
81109b6c:	e17ffc17 	ldw	r5,-16(fp)
81109b70:	e13ffb17 	ldw	r4,-20(fp)
81109b74:	1109f4c0 	call	81109f4c <i2c_write>
81109b78:	1000011e 	bne	r2,zero,81109b80 <I2C_Write+0x90>
        bSuccess = FALSE;
81109b7c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
81109b80:	e0bffa17 	ldw	r2,-24(fp)
81109b84:	10000726 	beq	r2,zero,81109ba4 <I2C_Write+0xb4>
81109b88:	e0bfff03 	ldbu	r2,-4(fp)
81109b8c:	100d883a 	mov	r6,r2
81109b90:	e17ffc17 	ldw	r5,-16(fp)
81109b94:	e13ffb17 	ldw	r4,-20(fp)
81109b98:	1109f4c0 	call	81109f4c <i2c_write>
81109b9c:	1000011e 	bne	r2,zero,81109ba4 <I2C_Write+0xb4>
        bSuccess = FALSE;
81109ba0:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81109ba4:	e17ffc17 	ldw	r5,-16(fp)
81109ba8:	e13ffb17 	ldw	r4,-20(fp)
81109bac:	1109ecc0 	call	81109ecc <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81109bb0:	0106d604 	movi	r4,7000
81109bb4:	11333f40 	call	811333f4 <usleep>
    
    return bSuccess;
81109bb8:	e0bffa17 	ldw	r2,-24(fp)

}
81109bbc:	e037883a 	mov	sp,fp
81109bc0:	dfc00117 	ldw	ra,4(sp)
81109bc4:	df000017 	ldw	fp,0(sp)
81109bc8:	dec00204 	addi	sp,sp,8
81109bcc:	f800283a 	ret

81109bd0 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
81109bd0:	defff904 	addi	sp,sp,-28
81109bd4:	de00012e 	bgeu	sp,et,81109bdc <I2C_Read+0xc>
81109bd8:	003b68fa 	trap	3
81109bdc:	dfc00615 	stw	ra,24(sp)
81109be0:	df000515 	stw	fp,20(sp)
81109be4:	df000504 	addi	fp,sp,20
81109be8:	e13ffc15 	stw	r4,-16(fp)
81109bec:	e17ffd15 	stw	r5,-12(fp)
81109bf0:	3007883a 	mov	r3,r6
81109bf4:	3805883a 	mov	r2,r7
81109bf8:	e0fffe05 	stb	r3,-8(fp)
81109bfc:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109c00:	00800044 	movi	r2,1
81109c04:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109c08:	e17ffd17 	ldw	r5,-12(fp)
81109c0c:	e13ffc17 	ldw	r4,-16(fp)
81109c10:	1109e380 	call	81109e38 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109c14:	e0bffe03 	ldbu	r2,-8(fp)
81109c18:	10803fcc 	andi	r2,r2,255
81109c1c:	100d883a 	mov	r6,r2
81109c20:	e17ffd17 	ldw	r5,-12(fp)
81109c24:	e13ffc17 	ldw	r4,-16(fp)
81109c28:	1109f4c0 	call	81109f4c <i2c_write>
81109c2c:	1000011e 	bne	r2,zero,81109c34 <I2C_Read+0x64>
        bSuccess = FALSE;
81109c30:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109c34:	e0bffb17 	ldw	r2,-20(fp)
81109c38:	10000726 	beq	r2,zero,81109c58 <I2C_Read+0x88>
81109c3c:	e0bfff03 	ldbu	r2,-4(fp)
81109c40:	100d883a 	mov	r6,r2
81109c44:	e17ffd17 	ldw	r5,-12(fp)
81109c48:	e13ffc17 	ldw	r4,-16(fp)
81109c4c:	1109f4c0 	call	81109f4c <i2c_write>
81109c50:	1000011e 	bne	r2,zero,81109c58 <I2C_Read+0x88>
        bSuccess = FALSE;
81109c54:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
81109c58:	e17ffd17 	ldw	r5,-12(fp)
81109c5c:	e13ffc17 	ldw	r4,-16(fp)
81109c60:	1109e380 	call	81109e38 <i2c_start>
    DeviceAddr |= 1; // Read
81109c64:	e0bffe03 	ldbu	r2,-8(fp)
81109c68:	10800054 	ori	r2,r2,1
81109c6c:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81109c70:	e0bffb17 	ldw	r2,-20(fp)
81109c74:	10000826 	beq	r2,zero,81109c98 <I2C_Read+0xc8>
81109c78:	e0bffe03 	ldbu	r2,-8(fp)
81109c7c:	10803fcc 	andi	r2,r2,255
81109c80:	100d883a 	mov	r6,r2
81109c84:	e17ffd17 	ldw	r5,-12(fp)
81109c88:	e13ffc17 	ldw	r4,-16(fp)
81109c8c:	1109f4c0 	call	81109f4c <i2c_write>
81109c90:	1000011e 	bne	r2,zero,81109c98 <I2C_Read+0xc8>
        bSuccess = FALSE;
81109c94:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109c98:	e0bffb17 	ldw	r2,-20(fp)
81109c9c:	10000526 	beq	r2,zero,81109cb4 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
81109ca0:	000f883a 	mov	r7,zero
81109ca4:	e1800217 	ldw	r6,8(fp)
81109ca8:	e17ffd17 	ldw	r5,-12(fp)
81109cac:	e13ffc17 	ldw	r4,-16(fp)
81109cb0:	110a0840 	call	8110a084 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81109cb4:	e17ffd17 	ldw	r5,-12(fp)
81109cb8:	e13ffc17 	ldw	r4,-16(fp)
81109cbc:	1109ecc0 	call	81109ecc <i2c_stop>
    
    return bSuccess;
81109cc0:	e0bffb17 	ldw	r2,-20(fp)
}
81109cc4:	e037883a 	mov	sp,fp
81109cc8:	dfc00117 	ldw	ra,4(sp)
81109ccc:	df000017 	ldw	fp,0(sp)
81109cd0:	dec00204 	addi	sp,sp,8
81109cd4:	f800283a 	ret

81109cd8 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
81109cd8:	defff604 	addi	sp,sp,-40
81109cdc:	de00012e 	bgeu	sp,et,81109ce4 <I2C_MultipleRead+0xc>
81109ce0:	003b68fa 	trap	3
81109ce4:	dfc00915 	stw	ra,36(sp)
81109ce8:	df000815 	stw	fp,32(sp)
81109cec:	df000804 	addi	fp,sp,32
81109cf0:	e13ffb15 	stw	r4,-20(fp)
81109cf4:	e17ffc15 	stw	r5,-16(fp)
81109cf8:	3007883a 	mov	r3,r6
81109cfc:	e1fffe15 	stw	r7,-8(fp)
81109d00:	e0800217 	ldw	r2,8(fp)
81109d04:	e0fffd05 	stb	r3,-12(fp)
81109d08:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
81109d0c:	00800044 	movi	r2,1
81109d10:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
81109d14:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109d18:	e17ffc17 	ldw	r5,-16(fp)
81109d1c:	e13ffb17 	ldw	r4,-20(fp)
81109d20:	1109e380 	call	81109e38 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109d24:	e0bffd03 	ldbu	r2,-12(fp)
81109d28:	10803fcc 	andi	r2,r2,255
81109d2c:	100d883a 	mov	r6,r2
81109d30:	e17ffc17 	ldw	r5,-16(fp)
81109d34:	e13ffb17 	ldw	r4,-20(fp)
81109d38:	1109f4c0 	call	81109f4c <i2c_write>
81109d3c:	1000011e 	bne	r2,zero,81109d44 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
81109d40:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109d44:	e0bff917 	ldw	r2,-28(fp)
81109d48:	10000726 	beq	r2,zero,81109d68 <I2C_MultipleRead+0x90>
81109d4c:	e0bffa03 	ldbu	r2,-24(fp)
81109d50:	100d883a 	mov	r6,r2
81109d54:	e17ffc17 	ldw	r5,-16(fp)
81109d58:	e13ffb17 	ldw	r4,-20(fp)
81109d5c:	1109f4c0 	call	81109f4c <i2c_write>
81109d60:	1000011e 	bne	r2,zero,81109d68 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
81109d64:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
81109d68:	e0bff917 	ldw	r2,-28(fp)
81109d6c:	10000326 	beq	r2,zero,81109d7c <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
81109d70:	e17ffc17 	ldw	r5,-16(fp)
81109d74:	e13ffb17 	ldw	r4,-20(fp)
81109d78:	1109e380 	call	81109e38 <i2c_start>
    DeviceAddr |= 1; // Read
81109d7c:	e0bffd03 	ldbu	r2,-12(fp)
81109d80:	10800054 	ori	r2,r2,1
81109d84:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81109d88:	e0bff917 	ldw	r2,-28(fp)
81109d8c:	10000826 	beq	r2,zero,81109db0 <I2C_MultipleRead+0xd8>
81109d90:	e0bffd03 	ldbu	r2,-12(fp)
81109d94:	10803fcc 	andi	r2,r2,255
81109d98:	100d883a 	mov	r6,r2
81109d9c:	e17ffc17 	ldw	r5,-16(fp)
81109da0:	e13ffb17 	ldw	r4,-20(fp)
81109da4:	1109f4c0 	call	81109f4c <i2c_write>
81109da8:	1000011e 	bne	r2,zero,81109db0 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
81109dac:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109db0:	e0bff917 	ldw	r2,-28(fp)
81109db4:	10001726 	beq	r2,zero,81109e14 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
81109db8:	e03ff815 	stw	zero,-32(fp)
81109dbc:	00001006 	br	81109e00 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81109dc0:	e0bff817 	ldw	r2,-32(fp)
81109dc4:	e0fffe17 	ldw	r3,-8(fp)
81109dc8:	1889883a 	add	r4,r3,r2
81109dcc:	e0bfff0b 	ldhu	r2,-4(fp)
81109dd0:	10ffffc4 	addi	r3,r2,-1
81109dd4:	e0bff817 	ldw	r2,-32(fp)
81109dd8:	1884c03a 	cmpne	r2,r3,r2
81109ddc:	10803fcc 	andi	r2,r2,255
81109de0:	100f883a 	mov	r7,r2
81109de4:	200d883a 	mov	r6,r4
81109de8:	e17ffc17 	ldw	r5,-16(fp)
81109dec:	e13ffb17 	ldw	r4,-20(fp)
81109df0:	110a0840 	call	8110a084 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81109df4:	e0bff817 	ldw	r2,-32(fp)
81109df8:	10800044 	addi	r2,r2,1
81109dfc:	e0bff815 	stw	r2,-32(fp)
81109e00:	e0bfff0b 	ldhu	r2,-4(fp)
81109e04:	e0fff817 	ldw	r3,-32(fp)
81109e08:	1880020e 	bge	r3,r2,81109e14 <I2C_MultipleRead+0x13c>
81109e0c:	e0bff917 	ldw	r2,-28(fp)
81109e10:	103feb1e 	bne	r2,zero,81109dc0 <__reset+0xfb0e9dc0>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81109e14:	e17ffc17 	ldw	r5,-16(fp)
81109e18:	e13ffb17 	ldw	r4,-20(fp)
81109e1c:	1109ecc0 	call	81109ecc <i2c_stop>
    
    return bSuccess;    
81109e20:	e0bff917 	ldw	r2,-28(fp)
    
}
81109e24:	e037883a 	mov	sp,fp
81109e28:	dfc00117 	ldw	ra,4(sp)
81109e2c:	df000017 	ldw	fp,0(sp)
81109e30:	dec00204 	addi	sp,sp,8
81109e34:	f800283a 	ret

81109e38 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
81109e38:	defffc04 	addi	sp,sp,-16
81109e3c:	de00012e 	bgeu	sp,et,81109e44 <i2c_start+0xc>
81109e40:	003b68fa 	trap	3
81109e44:	dfc00315 	stw	ra,12(sp)
81109e48:	df000215 	stw	fp,8(sp)
81109e4c:	df000204 	addi	fp,sp,8
81109e50:	e13ffe15 	stw	r4,-8(fp)
81109e54:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
81109e58:	e0bfff17 	ldw	r2,-4(fp)
81109e5c:	10800104 	addi	r2,r2,4
81109e60:	1007883a 	mov	r3,r2
81109e64:	00800044 	movi	r2,1
81109e68:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
81109e6c:	e0bfff17 	ldw	r2,-4(fp)
81109e70:	00c00044 	movi	r3,1
81109e74:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
81109e78:	e0bffe17 	ldw	r2,-8(fp)
81109e7c:	00c00044 	movi	r3,1
81109e80:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109e84:	01000044 	movi	r4,1
81109e88:	11333f40 	call	811333f4 <usleep>
     
    SDA_LOW(data_base); // data low
81109e8c:	e0bfff17 	ldw	r2,-4(fp)
81109e90:	0007883a 	mov	r3,zero
81109e94:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
81109e98:	01000044 	movi	r4,1
81109e9c:	11333f40 	call	811333f4 <usleep>
    SCL_LOW(clk_base); // clock low
81109ea0:	e0bffe17 	ldw	r2,-8(fp)
81109ea4:	0007883a 	mov	r3,zero
81109ea8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109eac:	01000044 	movi	r4,1
81109eb0:	11333f40 	call	811333f4 <usleep>
}
81109eb4:	0001883a 	nop
81109eb8:	e037883a 	mov	sp,fp
81109ebc:	dfc00117 	ldw	ra,4(sp)
81109ec0:	df000017 	ldw	fp,0(sp)
81109ec4:	dec00204 	addi	sp,sp,8
81109ec8:	f800283a 	ret

81109ecc <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81109ecc:	defffc04 	addi	sp,sp,-16
81109ed0:	de00012e 	bgeu	sp,et,81109ed8 <i2c_stop+0xc>
81109ed4:	003b68fa 	trap	3
81109ed8:	dfc00315 	stw	ra,12(sp)
81109edc:	df000215 	stw	fp,8(sp)
81109ee0:	df000204 	addi	fp,sp,8
81109ee4:	e13ffe15 	stw	r4,-8(fp)
81109ee8:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81109eec:	e0bfff17 	ldw	r2,-4(fp)
81109ef0:	10800104 	addi	r2,r2,4
81109ef4:	1007883a 	mov	r3,r2
81109ef8:	00800044 	movi	r2,1
81109efc:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81109f00:	e0bfff17 	ldw	r2,-4(fp)
81109f04:	0007883a 	mov	r3,zero
81109f08:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81109f0c:	e0bffe17 	ldw	r2,-8(fp)
81109f10:	00c00044 	movi	r3,1
81109f14:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
81109f18:	01000044 	movi	r4,1
81109f1c:	11333f40 	call	811333f4 <usleep>
    SDA_HIGH(data_base); // data high
81109f20:	e0bfff17 	ldw	r2,-4(fp)
81109f24:	00c00044 	movi	r3,1
81109f28:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81109f2c:	01000044 	movi	r4,1
81109f30:	11333f40 	call	811333f4 <usleep>
    

    
}
81109f34:	0001883a 	nop
81109f38:	e037883a 	mov	sp,fp
81109f3c:	dfc00117 	ldw	ra,4(sp)
81109f40:	df000017 	ldw	fp,0(sp)
81109f44:	dec00204 	addi	sp,sp,8
81109f48:	f800283a 	ret

81109f4c <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81109f4c:	defff804 	addi	sp,sp,-32
81109f50:	de00012e 	bgeu	sp,et,81109f58 <i2c_write+0xc>
81109f54:	003b68fa 	trap	3
81109f58:	dfc00715 	stw	ra,28(sp)
81109f5c:	df000615 	stw	fp,24(sp)
81109f60:	df000604 	addi	fp,sp,24
81109f64:	e13ffd15 	stw	r4,-12(fp)
81109f68:	e17ffe15 	stw	r5,-8(fp)
81109f6c:	3005883a 	mov	r2,r6
81109f70:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
81109f74:	00bfe004 	movi	r2,-128
81109f78:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
81109f7c:	e0bffe17 	ldw	r2,-8(fp)
81109f80:	10800104 	addi	r2,r2,4
81109f84:	1007883a 	mov	r3,r2
81109f88:	00800044 	movi	r2,1
81109f8c:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
81109f90:	e03ffb15 	stw	zero,-20(fp)
81109f94:	00001f06 	br	8110a014 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
81109f98:	e0bffd17 	ldw	r2,-12(fp)
81109f9c:	0007883a 	mov	r3,zero
81109fa0:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
81109fa4:	e0ffff03 	ldbu	r3,-4(fp)
81109fa8:	e0bffa03 	ldbu	r2,-24(fp)
81109fac:	1884703a 	and	r2,r3,r2
81109fb0:	10803fcc 	andi	r2,r2,255
81109fb4:	10000426 	beq	r2,zero,81109fc8 <i2c_write+0x7c>
            SDA_HIGH(data_base);
81109fb8:	e0bffe17 	ldw	r2,-8(fp)
81109fbc:	00c00044 	movi	r3,1
81109fc0:	10c00035 	stwio	r3,0(r2)
81109fc4:	00000306 	br	81109fd4 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
81109fc8:	e0bffe17 	ldw	r2,-8(fp)
81109fcc:	0007883a 	mov	r3,zero
81109fd0:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
81109fd4:	e0bffa03 	ldbu	r2,-24(fp)
81109fd8:	1004d07a 	srli	r2,r2,1
81109fdc:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
81109fe0:	e0bffd17 	ldw	r2,-12(fp)
81109fe4:	00c00044 	movi	r3,1
81109fe8:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109fec:	01000044 	movi	r4,1
81109ff0:	11333f40 	call	811333f4 <usleep>
        SCL_LOW(clk_base);
81109ff4:	e0bffd17 	ldw	r2,-12(fp)
81109ff8:	0007883a 	mov	r3,zero
81109ffc:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a000:	01000044 	movi	r4,1
8110a004:	11333f40 	call	811333f4 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110a008:	e0bffb17 	ldw	r2,-20(fp)
8110a00c:	10800044 	addi	r2,r2,1
8110a010:	e0bffb15 	stw	r2,-20(fp)
8110a014:	e0bffb17 	ldw	r2,-20(fp)
8110a018:	10800210 	cmplti	r2,r2,8
8110a01c:	103fde1e 	bne	r2,zero,81109f98 <__reset+0xfb0e9f98>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110a020:	e0bffe17 	ldw	r2,-8(fp)
8110a024:	10800104 	addi	r2,r2,4
8110a028:	0007883a 	mov	r3,zero
8110a02c:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110a030:	e0bffd17 	ldw	r2,-12(fp)
8110a034:	00c00044 	movi	r3,1
8110a038:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110a03c:	01000044 	movi	r4,1
8110a040:	11333f40 	call	811333f4 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110a044:	e0bffe17 	ldw	r2,-8(fp)
8110a048:	10800037 	ldwio	r2,0(r2)
8110a04c:	1005003a 	cmpeq	r2,r2,zero
8110a050:	10803fcc 	andi	r2,r2,255
8110a054:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110a058:	e0bffd17 	ldw	r2,-12(fp)
8110a05c:	0007883a 	mov	r3,zero
8110a060:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a064:	01000044 	movi	r4,1
8110a068:	11333f40 	call	811333f4 <usleep>
    return bAck;
8110a06c:	e0bffc17 	ldw	r2,-16(fp)
}    
8110a070:	e037883a 	mov	sp,fp
8110a074:	dfc00117 	ldw	ra,4(sp)
8110a078:	df000017 	ldw	fp,0(sp)
8110a07c:	dec00204 	addi	sp,sp,8
8110a080:	f800283a 	ret

8110a084 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110a084:	defff804 	addi	sp,sp,-32
8110a088:	de00012e 	bgeu	sp,et,8110a090 <i2c_read+0xc>
8110a08c:	003b68fa 	trap	3
8110a090:	dfc00715 	stw	ra,28(sp)
8110a094:	df000615 	stw	fp,24(sp)
8110a098:	df000604 	addi	fp,sp,24
8110a09c:	e13ffc15 	stw	r4,-16(fp)
8110a0a0:	e17ffd15 	stw	r5,-12(fp)
8110a0a4:	e1bffe15 	stw	r6,-8(fp)
8110a0a8:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110a0ac:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110a0b0:	e0bffd17 	ldw	r2,-12(fp)
8110a0b4:	10800104 	addi	r2,r2,4
8110a0b8:	0007883a 	mov	r3,zero
8110a0bc:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110a0c0:	e0bffc17 	ldw	r2,-16(fp)
8110a0c4:	0007883a 	mov	r3,zero
8110a0c8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a0cc:	01000044 	movi	r4,1
8110a0d0:	11333f40 	call	811333f4 <usleep>

    for(i=0;i<8;i++){
8110a0d4:	e03ffb15 	stw	zero,-20(fp)
8110a0d8:	00001606 	br	8110a134 <i2c_read+0xb0>
        Data <<= 1;
8110a0dc:	e0bffa03 	ldbu	r2,-24(fp)
8110a0e0:	1085883a 	add	r2,r2,r2
8110a0e4:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110a0e8:	e0bffc17 	ldw	r2,-16(fp)
8110a0ec:	00c00044 	movi	r3,1
8110a0f0:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a0f4:	01000044 	movi	r4,1
8110a0f8:	11333f40 	call	811333f4 <usleep>
        if (SDA_READ(data_base))  // read data   
8110a0fc:	e0bffd17 	ldw	r2,-12(fp)
8110a100:	10800037 	ldwio	r2,0(r2)
8110a104:	10000326 	beq	r2,zero,8110a114 <i2c_read+0x90>
            Data |= 0x01;
8110a108:	e0bffa03 	ldbu	r2,-24(fp)
8110a10c:	10800054 	ori	r2,r2,1
8110a110:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110a114:	e0bffc17 	ldw	r2,-16(fp)
8110a118:	0007883a 	mov	r3,zero
8110a11c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a120:	01000044 	movi	r4,1
8110a124:	11333f40 	call	811333f4 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110a128:	e0bffb17 	ldw	r2,-20(fp)
8110a12c:	10800044 	addi	r2,r2,1
8110a130:	e0bffb15 	stw	r2,-20(fp)
8110a134:	e0bffb17 	ldw	r2,-20(fp)
8110a138:	10800210 	cmplti	r2,r2,8
8110a13c:	103fe71e 	bne	r2,zero,8110a0dc <__reset+0xfb0ea0dc>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110a140:	e0bffc17 	ldw	r2,-16(fp)
8110a144:	0007883a 	mov	r3,zero
8110a148:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110a14c:	e0bffd17 	ldw	r2,-12(fp)
8110a150:	10800104 	addi	r2,r2,4
8110a154:	1007883a 	mov	r3,r2
8110a158:	00800044 	movi	r2,1
8110a15c:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110a160:	e0bfff17 	ldw	r2,-4(fp)
8110a164:	10000426 	beq	r2,zero,8110a178 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110a168:	e0bffd17 	ldw	r2,-12(fp)
8110a16c:	0007883a 	mov	r3,zero
8110a170:	10c00035 	stwio	r3,0(r2)
8110a174:	00000306 	br	8110a184 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110a178:	e0bffd17 	ldw	r2,-12(fp)
8110a17c:	00c00044 	movi	r3,1
8110a180:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110a184:	e0bffc17 	ldw	r2,-16(fp)
8110a188:	00c00044 	movi	r3,1
8110a18c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110a190:	01000044 	movi	r4,1
8110a194:	11333f40 	call	811333f4 <usleep>
    SCL_LOW(clk_base); // clock low
8110a198:	e0bffc17 	ldw	r2,-16(fp)
8110a19c:	0007883a 	mov	r3,zero
8110a1a0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a1a4:	01000044 	movi	r4,1
8110a1a8:	11333f40 	call	811333f4 <usleep>
    SDA_LOW(data_base);  // data low
8110a1ac:	e0bffd17 	ldw	r2,-12(fp)
8110a1b0:	0007883a 	mov	r3,zero
8110a1b4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110a1b8:	01000044 	movi	r4,1
8110a1bc:	11333f40 	call	811333f4 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110a1c0:	e0bffe17 	ldw	r2,-8(fp)
8110a1c4:	e0fffa03 	ldbu	r3,-24(fp)
8110a1c8:	10c00005 	stb	r3,0(r2)
}
8110a1cc:	0001883a 	nop
8110a1d0:	e037883a 	mov	sp,fp
8110a1d4:	dfc00117 	ldw	ra,4(sp)
8110a1d8:	df000017 	ldw	fp,0(sp)
8110a1dc:	dec00204 	addi	sp,sp,8
8110a1e0:	f800283a 	ret

8110a1e4 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110a1e4:	defffd04 	addi	sp,sp,-12
8110a1e8:	de00012e 	bgeu	sp,et,8110a1f0 <bSetBoardLeds+0xc>
8110a1ec:	003b68fa 	trap	3
8110a1f0:	df000215 	stw	fp,8(sp)
8110a1f4:	df000204 	addi	fp,sp,8
8110a1f8:	e13ffe15 	stw	r4,-8(fp)
8110a1fc:	2805883a 	mov	r2,r5
8110a200:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110a204:	e0bffe17 	ldw	r2,-8(fp)
8110a208:	10800058 	cmpnei	r2,r2,1
8110a20c:	1000071e 	bne	r2,zero,8110a22c <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110a210:	e0bfff03 	ldbu	r2,-4(fp)
8110a214:	0084303a 	nor	r2,zero,r2
8110a218:	1007883a 	mov	r3,r2
8110a21c:	d0a04e03 	ldbu	r2,-32456(gp)
8110a220:	1884703a 	and	r2,r3,r2
8110a224:	d0a04e05 	stb	r2,-32456(gp)
8110a228:	00000406 	br	8110a23c <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110a22c:	d0e04e03 	ldbu	r3,-32456(gp)
8110a230:	e0bfff03 	ldbu	r2,-4(fp)
8110a234:	1884b03a 	or	r2,r3,r2
8110a238:	d0a04e05 	stb	r2,-32456(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110a23c:	d0a04e03 	ldbu	r2,-32456(gp)
8110a240:	10c03fcc 	andi	r3,r2,255
8110a244:	00a00034 	movhi	r2,32768
8110a248:	10827404 	addi	r2,r2,2512
8110a24c:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110a250:	00800044 	movi	r2,1
}
8110a254:	e037883a 	mov	sp,fp
8110a258:	df000017 	ldw	fp,0(sp)
8110a25c:	dec00104 	addi	sp,sp,4
8110a260:	f800283a 	ret

8110a264 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110a264:	defffd04 	addi	sp,sp,-12
8110a268:	de00012e 	bgeu	sp,et,8110a270 <bSetPainelLeds+0xc>
8110a26c:	003b68fa 	trap	3
8110a270:	df000215 	stw	fp,8(sp)
8110a274:	df000204 	addi	fp,sp,8
8110a278:	e13ffe15 	stw	r4,-8(fp)
8110a27c:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110a280:	e0bffe17 	ldw	r2,-8(fp)
8110a284:	10800058 	cmpnei	r2,r2,1
8110a288:	1000051e 	bne	r2,zero,8110a2a0 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110a28c:	d0e00217 	ldw	r3,-32760(gp)
8110a290:	e0bfff17 	ldw	r2,-4(fp)
8110a294:	1884b03a 	or	r2,r3,r2
8110a298:	d0a00215 	stw	r2,-32760(gp)
8110a29c:	00000506 	br	8110a2b4 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110a2a0:	e0bfff17 	ldw	r2,-4(fp)
8110a2a4:	0086303a 	nor	r3,zero,r2
8110a2a8:	d0a00217 	ldw	r2,-32760(gp)
8110a2ac:	1884703a 	and	r2,r3,r2
8110a2b0:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110a2b4:	d0a00217 	ldw	r2,-32760(gp)
8110a2b8:	1007883a 	mov	r3,r2
8110a2bc:	00a00034 	movhi	r2,32768
8110a2c0:	10824004 	addi	r2,r2,2304
8110a2c4:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110a2c8:	00800044 	movi	r2,1
}
8110a2cc:	e037883a 	mov	sp,fp
8110a2d0:	df000017 	ldw	fp,0(sp)
8110a2d4:	dec00104 	addi	sp,sp,4
8110a2d8:	f800283a 	ret

8110a2dc <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110a2dc:	defffc04 	addi	sp,sp,-16
8110a2e0:	de00012e 	bgeu	sp,et,8110a2e8 <msgdma_write_extended_descriptor+0xc>
8110a2e4:	003b68fa 	trap	3
8110a2e8:	df000315 	stw	fp,12(sp)
8110a2ec:	df000304 	addi	fp,sp,12
8110a2f0:	e13ffd15 	stw	r4,-12(fp)
8110a2f4:	e17ffe15 	stw	r5,-8(fp)
8110a2f8:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110a2fc:	e0bffd17 	ldw	r2,-12(fp)
8110a300:	10800037 	ldwio	r2,0(r2)
8110a304:	1080010c 	andi	r2,r2,4
8110a308:	10000226 	beq	r2,zero,8110a314 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110a30c:	00bff904 	movi	r2,-28
8110a310:	00003d06 	br	8110a408 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110a314:	e0bfff17 	ldw	r2,-4(fp)
8110a318:	10800017 	ldw	r2,0(r2)
8110a31c:	1007883a 	mov	r3,r2
8110a320:	e0bffe17 	ldw	r2,-8(fp)
8110a324:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110a328:	e0bffe17 	ldw	r2,-8(fp)
8110a32c:	10800104 	addi	r2,r2,4
8110a330:	e0ffff17 	ldw	r3,-4(fp)
8110a334:	18c00117 	ldw	r3,4(r3)
8110a338:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110a33c:	e0bffe17 	ldw	r2,-8(fp)
8110a340:	10800204 	addi	r2,r2,8
8110a344:	e0ffff17 	ldw	r3,-4(fp)
8110a348:	18c00217 	ldw	r3,8(r3)
8110a34c:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110a350:	e0bffe17 	ldw	r2,-8(fp)
8110a354:	10800304 	addi	r2,r2,12
8110a358:	e0ffff17 	ldw	r3,-4(fp)
8110a35c:	18c0030b 	ldhu	r3,12(r3)
8110a360:	18ffffcc 	andi	r3,r3,65535
8110a364:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110a368:	e0bffe17 	ldw	r2,-8(fp)
8110a36c:	10800384 	addi	r2,r2,14
8110a370:	e0ffff17 	ldw	r3,-4(fp)
8110a374:	18c00383 	ldbu	r3,14(r3)
8110a378:	18c03fcc 	andi	r3,r3,255
8110a37c:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110a380:	e0bffe17 	ldw	r2,-8(fp)
8110a384:	108003c4 	addi	r2,r2,15
8110a388:	e0ffff17 	ldw	r3,-4(fp)
8110a38c:	18c003c3 	ldbu	r3,15(r3)
8110a390:	18c03fcc 	andi	r3,r3,255
8110a394:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110a398:	e0bffe17 	ldw	r2,-8(fp)
8110a39c:	10800404 	addi	r2,r2,16
8110a3a0:	e0ffff17 	ldw	r3,-4(fp)
8110a3a4:	18c0040b 	ldhu	r3,16(r3)
8110a3a8:	18ffffcc 	andi	r3,r3,65535
8110a3ac:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110a3b0:	e0bffe17 	ldw	r2,-8(fp)
8110a3b4:	10800484 	addi	r2,r2,18
8110a3b8:	e0ffff17 	ldw	r3,-4(fp)
8110a3bc:	18c0048b 	ldhu	r3,18(r3)
8110a3c0:	18ffffcc 	andi	r3,r3,65535
8110a3c4:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110a3c8:	e0bffe17 	ldw	r2,-8(fp)
8110a3cc:	10800504 	addi	r2,r2,20
8110a3d0:	e0ffff17 	ldw	r3,-4(fp)
8110a3d4:	18c00517 	ldw	r3,20(r3)
8110a3d8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110a3dc:	e0bffe17 	ldw	r2,-8(fp)
8110a3e0:	10800604 	addi	r2,r2,24
8110a3e4:	e0ffff17 	ldw	r3,-4(fp)
8110a3e8:	18c00617 	ldw	r3,24(r3)
8110a3ec:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110a3f0:	e0bffe17 	ldw	r2,-8(fp)
8110a3f4:	10800704 	addi	r2,r2,28
8110a3f8:	e0ffff17 	ldw	r3,-4(fp)
8110a3fc:	18c00717 	ldw	r3,28(r3)
8110a400:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110a404:	0005883a 	mov	r2,zero
}
8110a408:	e037883a 	mov	sp,fp
8110a40c:	df000017 	ldw	fp,0(sp)
8110a410:	dec00104 	addi	sp,sp,4
8110a414:	f800283a 	ret

8110a418 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110a418:	defff604 	addi	sp,sp,-40
8110a41c:	de00012e 	bgeu	sp,et,8110a424 <msgdma_construct_extended_descriptor+0xc>
8110a420:	003b68fa 	trap	3
8110a424:	df000915 	stw	fp,36(sp)
8110a428:	df000904 	addi	fp,sp,36
8110a42c:	e13ff715 	stw	r4,-36(fp)
8110a430:	e17ff815 	stw	r5,-32(fp)
8110a434:	e1bff915 	stw	r6,-28(fp)
8110a438:	e1fffa15 	stw	r7,-24(fp)
8110a43c:	e1800517 	ldw	r6,20(fp)
8110a440:	e1400617 	ldw	r5,24(fp)
8110a444:	e1000717 	ldw	r4,28(fp)
8110a448:	e0c00817 	ldw	r3,32(fp)
8110a44c:	e0800917 	ldw	r2,36(fp)
8110a450:	e1bffb0d 	sth	r6,-20(fp)
8110a454:	e17ffc05 	stb	r5,-16(fp)
8110a458:	e13ffd05 	stb	r4,-12(fp)
8110a45c:	e0fffe0d 	sth	r3,-8(fp)
8110a460:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110a464:	e0bff717 	ldw	r2,-36(fp)
8110a468:	10c01217 	ldw	r3,72(r2)
8110a46c:	e0800117 	ldw	r2,4(fp)
8110a470:	18801936 	bltu	r3,r2,8110a4d8 <msgdma_construct_extended_descriptor+0xc0>
8110a474:	e13ff717 	ldw	r4,-36(fp)
8110a478:	20801317 	ldw	r2,76(r4)
8110a47c:	20c01417 	ldw	r3,80(r4)
8110a480:	e13ffe0b 	ldhu	r4,-8(fp)
8110a484:	213fffcc 	andi	r4,r4,65535
8110a488:	2015883a 	mov	r10,r4
8110a48c:	0017883a 	mov	r11,zero
8110a490:	1ac01136 	bltu	r3,r11,8110a4d8 <msgdma_construct_extended_descriptor+0xc0>
8110a494:	58c0011e 	bne	r11,r3,8110a49c <msgdma_construct_extended_descriptor+0x84>
8110a498:	12800f36 	bltu	r2,r10,8110a4d8 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110a49c:	e13ff717 	ldw	r4,-36(fp)
8110a4a0:	20801317 	ldw	r2,76(r4)
8110a4a4:	20c01417 	ldw	r3,80(r4)
8110a4a8:	e13fff0b 	ldhu	r4,-4(fp)
8110a4ac:	213fffcc 	andi	r4,r4,65535
8110a4b0:	2011883a 	mov	r8,r4
8110a4b4:	0013883a 	mov	r9,zero
8110a4b8:	1a400736 	bltu	r3,r9,8110a4d8 <msgdma_construct_extended_descriptor+0xc0>
8110a4bc:	48c0011e 	bne	r9,r3,8110a4c4 <msgdma_construct_extended_descriptor+0xac>
8110a4c0:	12000536 	bltu	r2,r8,8110a4d8 <msgdma_construct_extended_descriptor+0xc0>
8110a4c4:	e0bff717 	ldw	r2,-36(fp)
8110a4c8:	10801703 	ldbu	r2,92(r2)
8110a4cc:	10803fcc 	andi	r2,r2,255
8110a4d0:	10800060 	cmpeqi	r2,r2,1
8110a4d4:	1000021e 	bne	r2,zero,8110a4e0 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110a4d8:	00bffa84 	movi	r2,-22
8110a4dc:	00002306 	br	8110a56c <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110a4e0:	e0bff817 	ldw	r2,-32(fp)
8110a4e4:	e0fff917 	ldw	r3,-28(fp)
8110a4e8:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110a4ec:	e0bff817 	ldw	r2,-32(fp)
8110a4f0:	e0fffa17 	ldw	r3,-24(fp)
8110a4f4:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110a4f8:	e0bff817 	ldw	r2,-32(fp)
8110a4fc:	e0c00117 	ldw	r3,4(fp)
8110a500:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110a504:	e0bff817 	ldw	r2,-32(fp)
8110a508:	e0fffb0b 	ldhu	r3,-20(fp)
8110a50c:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110a510:	e0bff817 	ldw	r2,-32(fp)
8110a514:	e0fffc03 	ldbu	r3,-16(fp)
8110a518:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110a51c:	e0bff817 	ldw	r2,-32(fp)
8110a520:	e0fffd03 	ldbu	r3,-12(fp)
8110a524:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110a528:	e0bff817 	ldw	r2,-32(fp)
8110a52c:	e0fffe0b 	ldhu	r3,-8(fp)
8110a530:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110a534:	e0bff817 	ldw	r2,-32(fp)
8110a538:	e0ffff0b 	ldhu	r3,-4(fp)
8110a53c:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110a540:	e0bff817 	ldw	r2,-32(fp)
8110a544:	e0c00317 	ldw	r3,12(fp)
8110a548:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110a54c:	e0bff817 	ldw	r2,-32(fp)
8110a550:	e0c00417 	ldw	r3,16(fp)
8110a554:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110a558:	e0800217 	ldw	r2,8(fp)
8110a55c:	10e00034 	orhi	r3,r2,32768
8110a560:	e0bff817 	ldw	r2,-32(fp)
8110a564:	10c00715 	stw	r3,28(r2)

	return 0;
8110a568:	0005883a 	mov	r2,zero

}
8110a56c:	e037883a 	mov	sp,fp
8110a570:	df000017 	ldw	fp,0(sp)
8110a574:	dec00104 	addi	sp,sp,4
8110a578:	f800283a 	ret

8110a57c <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a57c:	deffee04 	addi	sp,sp,-72
8110a580:	de00012e 	bgeu	sp,et,8110a588 <msgdma_descriptor_async_transfer+0xc>
8110a584:	003b68fa 	trap	3
8110a588:	dfc01115 	stw	ra,68(sp)
8110a58c:	df001015 	stw	fp,64(sp)
8110a590:	df001004 	addi	fp,sp,64
8110a594:	e13ffd15 	stw	r4,-12(fp)
8110a598:	e17ffe15 	stw	r5,-8(fp)
8110a59c:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a5a0:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110a5a4:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110a5a8:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a5ac:	e0bffd17 	ldw	r2,-12(fp)
8110a5b0:	10800317 	ldw	r2,12(r2)
8110a5b4:	10800204 	addi	r2,r2,8
8110a5b8:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a5bc:	10bfffcc 	andi	r2,r2,65535
8110a5c0:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a5c4:	e0bffd17 	ldw	r2,-12(fp)
8110a5c8:	10800317 	ldw	r2,12(r2)
8110a5cc:	10800204 	addi	r2,r2,8
8110a5d0:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a5d4:	1004d43a 	srli	r2,r2,16
8110a5d8:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a5dc:	e0bffd17 	ldw	r2,-12(fp)
8110a5e0:	10800917 	ldw	r2,36(r2)
8110a5e4:	e0fff417 	ldw	r3,-48(fp)
8110a5e8:	1880042e 	bgeu	r3,r2,8110a5fc <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a5ec:	e0bffd17 	ldw	r2,-12(fp)
8110a5f0:	10800917 	ldw	r2,36(r2)
8110a5f4:	e0fff317 	ldw	r3,-52(fp)
8110a5f8:	18800236 	bltu	r3,r2,8110a604 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110a5fc:	00bff904 	movi	r2,-28
8110a600:	00009f06 	br	8110a880 <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a604:	e0bffd17 	ldw	r2,-12(fp)
8110a608:	10801817 	ldw	r2,96(r2)
8110a60c:	e0bff615 	stw	r2,-40(fp)
8110a610:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110a614:	e0bffc0b 	ldhu	r2,-16(fp)
8110a618:	e0fffc84 	addi	r3,fp,-14
8110a61c:	180d883a 	mov	r6,r3
8110a620:	100b883a 	mov	r5,r2
8110a624:	e13ff617 	ldw	r4,-40(fp)
8110a628:	113a1f80 	call	8113a1f8 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110a62c:	00800804 	movi	r2,32
8110a630:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a634:	0005303a 	rdctl	r2,status
8110a638:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a63c:	e0fff717 	ldw	r3,-36(fp)
8110a640:	00bfff84 	movi	r2,-2
8110a644:	1884703a 	and	r2,r3,r2
8110a648:	1001703a 	wrctl	status,r2
  
  return context;
8110a64c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a650:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a654:	e0bffd17 	ldw	r2,-12(fp)
8110a658:	10800317 	ldw	r2,12(r2)
8110a65c:	10800104 	addi	r2,r2,4
8110a660:	e0fff117 	ldw	r3,-60(fp)
8110a664:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a668:	e0bffd17 	ldw	r2,-12(fp)
8110a66c:	10800317 	ldw	r2,12(r2)
8110a670:	e0fffd17 	ldw	r3,-12(fp)
8110a674:	18c00317 	ldw	r3,12(r3)
8110a678:	18c00037 	ldwio	r3,0(r3)
8110a67c:	10c00035 	stwio	r3,0(r2)
8110a680:	e0bff217 	ldw	r2,-56(fp)
8110a684:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a688:	e0bffb17 	ldw	r2,-20(fp)
8110a68c:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110a690:	e0bffe17 	ldw	r2,-8(fp)
8110a694:	10001026 	beq	r2,zero,8110a6d8 <msgdma_descriptor_async_transfer+0x15c>
8110a698:	e0bfff17 	ldw	r2,-4(fp)
8110a69c:	10000e1e 	bne	r2,zero,8110a6d8 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110a6a0:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110a6a4:	d0a05d17 	ldw	r2,-32396(gp)
8110a6a8:	100f883a 	mov	r7,r2
8110a6ac:	01800784 	movi	r6,30
8110a6b0:	01400044 	movi	r5,1
8110a6b4:	01204534 	movhi	r4,33044
8110a6b8:	211ed304 	addi	r4,r4,31564
8110a6bc:	111c7b80 	call	8111c7b8 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a6c0:	e0bffd17 	ldw	r2,-12(fp)
8110a6c4:	10801817 	ldw	r2,96(r2)
8110a6c8:	1009883a 	mov	r4,r2
8110a6cc:	113a5800 	call	8113a580 <OSSemPost>

		return -ETIME;
8110a6d0:	00bff084 	movi	r2,-62
8110a6d4:	00006a06 	br	8110a880 <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a6d8:	e0bffe17 	ldw	r2,-8(fp)
8110a6dc:	1000231e 	bne	r2,zero,8110a76c <msgdma_descriptor_async_transfer+0x1f0>
8110a6e0:	e0bfff17 	ldw	r2,-4(fp)
8110a6e4:	10002126 	beq	r2,zero,8110a76c <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110a6e8:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a6ec:	00001506 	br	8110a744 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110a6f0:	01000044 	movi	r4,1
8110a6f4:	11319800 	call	81131980 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a6f8:	e0bff00b 	ldhu	r2,-64(fp)
8110a6fc:	1084e230 	cmpltui	r2,r2,5000
8110a700:	10000d1e 	bne	r2,zero,8110a738 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110a704:	d0a05d17 	ldw	r2,-32396(gp)
8110a708:	100f883a 	mov	r7,r2
8110a70c:	01801544 	movi	r6,85
8110a710:	01400044 	movi	r5,1
8110a714:	01204534 	movhi	r4,33044
8110a718:	211edb04 	addi	r4,r4,31596
8110a71c:	111c7b80 	call	8111c7b8 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110a720:	e0bffd17 	ldw	r2,-12(fp)
8110a724:	10801817 	ldw	r2,96(r2)
8110a728:	1009883a 	mov	r4,r2
8110a72c:	113a5800 	call	8113a580 <OSSemPost>

				return -ETIME;
8110a730:	00bff084 	movi	r2,-62
8110a734:	00005206 	br	8110a880 <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110a738:	e0bff00b 	ldhu	r2,-64(fp)
8110a73c:	10800044 	addi	r2,r2,1
8110a740:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110a744:	e0bffd17 	ldw	r2,-12(fp)
8110a748:	10c00317 	ldw	r3,12(r2)
8110a74c:	e0bffd17 	ldw	r2,-12(fp)
8110a750:	10800417 	ldw	r2,16(r2)
8110a754:	e1bfff17 	ldw	r6,-4(fp)
8110a758:	100b883a 	mov	r5,r2
8110a75c:	1809883a 	mov	r4,r3
8110a760:	110a2dc0 	call	8110a2dc <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a764:	103fe21e 	bne	r2,zero,8110a6f0 <__reset+0xfb0ea6f0>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a768:	00000606 	br	8110a784 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a76c:	e0bffd17 	ldw	r2,-12(fp)
8110a770:	10801817 	ldw	r2,96(r2)
8110a774:	1009883a 	mov	r4,r2
8110a778:	113a5800 	call	8113a580 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110a77c:	00bfffc4 	movi	r2,-1
8110a780:	00003f06 	br	8110a880 <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110a784:	e0bffd17 	ldw	r2,-12(fp)
8110a788:	10800b17 	ldw	r2,44(r2)
8110a78c:	10001c26 	beq	r2,zero,8110a800 <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110a790:	e0bffd17 	ldw	r2,-12(fp)
8110a794:	10c00d17 	ldw	r3,52(r2)
8110a798:	e0bff117 	ldw	r2,-60(fp)
8110a79c:	1884b03a 	or	r2,r3,r2
8110a7a0:	10800514 	ori	r2,r2,20
8110a7a4:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110a7a8:	e0fff117 	ldw	r3,-60(fp)
8110a7ac:	00bff7c4 	movi	r2,-33
8110a7b0:	1884703a 	and	r2,r3,r2
8110a7b4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a7b8:	0005303a 	rdctl	r2,status
8110a7bc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a7c0:	e0fff917 	ldw	r3,-28(fp)
8110a7c4:	00bfff84 	movi	r2,-2
8110a7c8:	1884703a 	and	r2,r3,r2
8110a7cc:	1001703a 	wrctl	status,r2
  
  return context;
8110a7d0:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a7d4:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a7d8:	e0bffd17 	ldw	r2,-12(fp)
8110a7dc:	10800317 	ldw	r2,12(r2)
8110a7e0:	10800104 	addi	r2,r2,4
8110a7e4:	e0fff117 	ldw	r3,-60(fp)
8110a7e8:	10c00035 	stwio	r3,0(r2)
8110a7ec:	e0bff217 	ldw	r2,-56(fp)
8110a7f0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a7f4:	e0bff517 	ldw	r2,-44(fp)
8110a7f8:	1001703a 	wrctl	status,r2
8110a7fc:	00001b06 	br	8110a86c <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110a800:	e0bffd17 	ldw	r2,-12(fp)
8110a804:	10c00d17 	ldw	r3,52(r2)
8110a808:	e0bff117 	ldw	r2,-60(fp)
8110a80c:	1884b03a 	or	r2,r3,r2
8110a810:	10800114 	ori	r2,r2,4
8110a814:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110a818:	e0fff117 	ldw	r3,-60(fp)
8110a81c:	00bff3c4 	movi	r2,-49
8110a820:	1884703a 	and	r2,r3,r2
8110a824:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a828:	0005303a 	rdctl	r2,status
8110a82c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a830:	e0fffa17 	ldw	r3,-24(fp)
8110a834:	00bfff84 	movi	r2,-2
8110a838:	1884703a 	and	r2,r3,r2
8110a83c:	1001703a 	wrctl	status,r2
  
  return context;
8110a840:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a844:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a848:	e0bffd17 	ldw	r2,-12(fp)
8110a84c:	10800317 	ldw	r2,12(r2)
8110a850:	10800104 	addi	r2,r2,4
8110a854:	e0fff117 	ldw	r3,-60(fp)
8110a858:	10c00035 	stwio	r3,0(r2)
8110a85c:	e0bff217 	ldw	r2,-56(fp)
8110a860:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a864:	e0bff817 	ldw	r2,-32(fp)
8110a868:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110a86c:	e0bffd17 	ldw	r2,-12(fp)
8110a870:	10801817 	ldw	r2,96(r2)
8110a874:	1009883a 	mov	r4,r2
8110a878:	113a5800 	call	8113a580 <OSSemPost>

	return 0;
8110a87c:	0005883a 	mov	r2,zero
}
8110a880:	e037883a 	mov	sp,fp
8110a884:	dfc00117 	ldw	ra,4(sp)
8110a888:	df000017 	ldw	fp,0(sp)
8110a88c:	dec00204 	addi	sp,sp,8
8110a890:	f800283a 	ret

8110a894 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a894:	deffee04 	addi	sp,sp,-72
8110a898:	de00012e 	bgeu	sp,et,8110a8a0 <msgdma_descriptor_sync_transfer+0xc>
8110a89c:	003b68fa 	trap	3
8110a8a0:	dfc01115 	stw	ra,68(sp)
8110a8a4:	df001015 	stw	fp,64(sp)
8110a8a8:	df001004 	addi	fp,sp,64
8110a8ac:	e13ffd15 	stw	r4,-12(fp)
8110a8b0:	e17ffe15 	stw	r5,-8(fp)
8110a8b4:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a8b8:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110a8bc:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110a8c0:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110a8c4:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a8c8:	e0bffd17 	ldw	r2,-12(fp)
8110a8cc:	10800317 	ldw	r2,12(r2)
8110a8d0:	10800204 	addi	r2,r2,8
8110a8d4:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a8d8:	10bfffcc 	andi	r2,r2,65535
8110a8dc:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a8e0:	e0bffd17 	ldw	r2,-12(fp)
8110a8e4:	10800317 	ldw	r2,12(r2)
8110a8e8:	10800204 	addi	r2,r2,8
8110a8ec:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a8f0:	1004d43a 	srli	r2,r2,16
8110a8f4:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110a8f8:	00807804 	movi	r2,480
8110a8fc:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a900:	00001d06 	br	8110a978 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110a904:	01000044 	movi	r4,1
8110a908:	11319800 	call	81131980 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a90c:	e0bff10b 	ldhu	r2,-60(fp)
8110a910:	1084e230 	cmpltui	r2,r2,5000
8110a914:	1000091e 	bne	r2,zero,8110a93c <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
8110a918:	d0a05d17 	ldw	r2,-32396(gp)
8110a91c:	100f883a 	mov	r7,r2
8110a920:	01801304 	movi	r6,76
8110a924:	01400044 	movi	r5,1
8110a928:	01204534 	movhi	r4,33044
8110a92c:	211ef104 	addi	r4,r4,31684
8110a930:	111c7b80 	call	8111c7b8 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110a934:	00bff084 	movi	r2,-62
8110a938:	0000d006 	br	8110ac7c <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110a93c:	e0bff10b 	ldhu	r2,-60(fp)
8110a940:	10800044 	addi	r2,r2,1
8110a944:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a948:	e0bffd17 	ldw	r2,-12(fp)
8110a94c:	10800317 	ldw	r2,12(r2)
8110a950:	10800204 	addi	r2,r2,8
8110a954:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110a958:	10bfffcc 	andi	r2,r2,65535
8110a95c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a960:	e0bffd17 	ldw	r2,-12(fp)
8110a964:	10800317 	ldw	r2,12(r2)
8110a968:	10800204 	addi	r2,r2,8
8110a96c:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110a970:	1004d43a 	srli	r2,r2,16
8110a974:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a978:	e0bffd17 	ldw	r2,-12(fp)
8110a97c:	10800917 	ldw	r2,36(r2)
8110a980:	e0fff317 	ldw	r3,-52(fp)
8110a984:	18bfdf2e 	bgeu	r3,r2,8110a904 <__reset+0xfb0ea904>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a988:	e0bffd17 	ldw	r2,-12(fp)
8110a98c:	10800917 	ldw	r2,36(r2)
8110a990:	e0fff217 	ldw	r3,-56(fp)
8110a994:	18bfdb2e 	bgeu	r3,r2,8110a904 <__reset+0xfb0ea904>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a998:	e0bffd17 	ldw	r2,-12(fp)
8110a99c:	10801817 	ldw	r2,96(r2)
8110a9a0:	e0bff815 	stw	r2,-32(fp)
8110a9a4:	e03ffc0d 	sth	zero,-16(fp)
8110a9a8:	e0bffc0b 	ldhu	r2,-16(fp)
8110a9ac:	e0fffc84 	addi	r3,fp,-14
8110a9b0:	180d883a 	mov	r6,r3
8110a9b4:	100b883a 	mov	r5,r2
8110a9b8:	e13ff817 	ldw	r4,-32(fp)
8110a9bc:	113a1f80 	call	8113a1f8 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a9c0:	0005303a 	rdctl	r2,status
8110a9c4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a9c8:	e0fffb17 	ldw	r3,-20(fp)
8110a9cc:	00bfff84 	movi	r2,-2
8110a9d0:	1884703a 	and	r2,r3,r2
8110a9d4:	1001703a 	wrctl	status,r2
  
  return context;
8110a9d8:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a9dc:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110a9e0:	e0bffd17 	ldw	r2,-12(fp)
8110a9e4:	10800317 	ldw	r2,12(r2)
8110a9e8:	10800104 	addi	r2,r2,4
8110a9ec:	00c00804 	movi	r3,32
8110a9f0:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a9f4:	e0bffd17 	ldw	r2,-12(fp)
8110a9f8:	10800317 	ldw	r2,12(r2)
8110a9fc:	e0fffd17 	ldw	r3,-12(fp)
8110aa00:	18c00317 	ldw	r3,12(r3)
8110aa04:	18c00037 	ldwio	r3,0(r3)
8110aa08:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110aa0c:	e0bffe17 	ldw	r2,-8(fp)
8110aa10:	10001026 	beq	r2,zero,8110aa54 <msgdma_descriptor_sync_transfer+0x1c0>
8110aa14:	e0bfff17 	ldw	r2,-4(fp)
8110aa18:	10000e1e 	bne	r2,zero,8110aa54 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110aa1c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110aa20:	d0a05d17 	ldw	r2,-32396(gp)
8110aa24:	100f883a 	mov	r7,r2
8110aa28:	01800784 	movi	r6,30
8110aa2c:	01400044 	movi	r5,1
8110aa30:	01204534 	movhi	r4,33044
8110aa34:	211ed304 	addi	r4,r4,31564
8110aa38:	111c7b80 	call	8111c7b8 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110aa3c:	e0bffd17 	ldw	r2,-12(fp)
8110aa40:	10801817 	ldw	r2,96(r2)
8110aa44:	1009883a 	mov	r4,r2
8110aa48:	113a5800 	call	8113a580 <OSSemPost>

		return -ETIME;
8110aa4c:	00bff084 	movi	r2,-62
8110aa50:	00008a06 	br	8110ac7c <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110aa54:	e0bffe17 	ldw	r2,-8(fp)
8110aa58:	1000231e 	bne	r2,zero,8110aae8 <msgdma_descriptor_sync_transfer+0x254>
8110aa5c:	e0bfff17 	ldw	r2,-4(fp)
8110aa60:	10002126 	beq	r2,zero,8110aae8 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
8110aa64:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110aa68:	00001506 	br	8110aac0 <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110aa6c:	01000044 	movi	r4,1
8110aa70:	11319800 	call	81131980 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110aa74:	e0bff10b 	ldhu	r2,-60(fp)
8110aa78:	1084e230 	cmpltui	r2,r2,5000
8110aa7c:	10000d1e 	bne	r2,zero,8110aab4 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
8110aa80:	d0a05d17 	ldw	r2,-32396(gp)
8110aa84:	100f883a 	mov	r7,r2
8110aa88:	01801004 	movi	r6,64
8110aa8c:	01400044 	movi	r5,1
8110aa90:	01204534 	movhi	r4,33044
8110aa94:	211f0504 	addi	r4,r4,31764
8110aa98:	111c7b80 	call	8111c7b8 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110aa9c:	e0bffd17 	ldw	r2,-12(fp)
8110aaa0:	10801817 	ldw	r2,96(r2)
8110aaa4:	1009883a 	mov	r4,r2
8110aaa8:	113a5800 	call	8113a580 <OSSemPost>

				return -ETIME;
8110aaac:	00bff084 	movi	r2,-62
8110aab0:	00007206 	br	8110ac7c <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
8110aab4:	e0bff10b 	ldhu	r2,-60(fp)
8110aab8:	10800044 	addi	r2,r2,1
8110aabc:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110aac0:	e0bffd17 	ldw	r2,-12(fp)
8110aac4:	10c00317 	ldw	r3,12(r2)
8110aac8:	e0bffd17 	ldw	r2,-12(fp)
8110aacc:	10800417 	ldw	r2,16(r2)
8110aad0:	e1bfff17 	ldw	r6,-4(fp)
8110aad4:	100b883a 	mov	r5,r2
8110aad8:	1809883a 	mov	r4,r3
8110aadc:	110a2dc0 	call	8110a2dc <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110aae0:	103fe21e 	bne	r2,zero,8110aa6c <__reset+0xfb0eaa6c>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110aae4:	00000606 	br	8110ab00 <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110aae8:	e0bffd17 	ldw	r2,-12(fp)
8110aaec:	10801817 	ldw	r2,96(r2)
8110aaf0:	1009883a 	mov	r4,r2
8110aaf4:	113a5800 	call	8113a580 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110aaf8:	00bfffc4 	movi	r2,-1
8110aafc:	00005f06 	br	8110ac7c <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110ab00:	e0bffd17 	ldw	r2,-12(fp)
8110ab04:	10800317 	ldw	r2,12(r2)
8110ab08:	10800104 	addi	r2,r2,4
8110ab0c:	e0fffd17 	ldw	r3,-12(fp)
8110ab10:	19000d17 	ldw	r4,52(r3)
8110ab14:	00fff2c4 	movi	r3,-53
8110ab18:	20c6703a 	and	r3,r4,r3
8110ab1c:	18c00114 	ori	r3,r3,4
8110ab20:	10c00035 	stwio	r3,0(r2)
8110ab24:	e0bff517 	ldw	r2,-44(fp)
8110ab28:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110ab2c:	e0bff717 	ldw	r2,-36(fp)
8110ab30:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110ab34:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110ab38:	e0bffd17 	ldw	r2,-12(fp)
8110ab3c:	10800317 	ldw	r2,12(r2)
8110ab40:	10800037 	ldwio	r2,0(r2)
8110ab44:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110ab48:	00001906 	br	8110abb0 <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
8110ab4c:	01000044 	movi	r4,1
8110ab50:	11319800 	call	81131980 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110ab54:	e0bff10b 	ldhu	r2,-60(fp)
8110ab58:	1084e230 	cmpltui	r2,r2,5000
8110ab5c:	10000d1e 	bne	r2,zero,8110ab94 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
8110ab60:	d0a05d17 	ldw	r2,-32396(gp)
8110ab64:	100f883a 	mov	r7,r2
8110ab68:	01801184 	movi	r6,70
8110ab6c:	01400044 	movi	r5,1
8110ab70:	01204534 	movhi	r4,33044
8110ab74:	211f1604 	addi	r4,r4,31832
8110ab78:	111c7b80 	call	8111c7b8 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110ab7c:	e0bffd17 	ldw	r2,-12(fp)
8110ab80:	10801817 	ldw	r2,96(r2)
8110ab84:	1009883a 	mov	r4,r2
8110ab88:	113a5800 	call	8113a580 <OSSemPost>

			return -ETIME;
8110ab8c:	00bff084 	movi	r2,-62
8110ab90:	00003a06 	br	8110ac7c <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110ab94:	e0bff10b 	ldhu	r2,-60(fp)
8110ab98:	10800044 	addi	r2,r2,1
8110ab9c:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110aba0:	e0bffd17 	ldw	r2,-12(fp)
8110aba4:	10800317 	ldw	r2,12(r2)
8110aba8:	10800037 	ldwio	r2,0(r2)
8110abac:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110abb0:	e0fff017 	ldw	r3,-64(fp)
8110abb4:	e0bff617 	ldw	r2,-40(fp)
8110abb8:	1884703a 	and	r2,r3,r2
8110abbc:	1000031e 	bne	r2,zero,8110abcc <msgdma_descriptor_sync_transfer+0x338>
8110abc0:	e0bff017 	ldw	r2,-64(fp)
8110abc4:	1080004c 	andi	r2,r2,1
8110abc8:	103fe01e 	bne	r2,zero,8110ab4c <__reset+0xfb0eab4c>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110abcc:	e0fff017 	ldw	r3,-64(fp)
8110abd0:	e0bff617 	ldw	r2,-40(fp)
8110abd4:	1884703a 	and	r2,r3,r2
8110abd8:	10000626 	beq	r2,zero,8110abf4 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110abdc:	e0bffd17 	ldw	r2,-12(fp)
8110abe0:	10801817 	ldw	r2,96(r2)
8110abe4:	1009883a 	mov	r4,r2
8110abe8:	113a5800 	call	8113a580 <OSSemPost>

		return error;
8110abec:	e0bff617 	ldw	r2,-40(fp)
8110abf0:	00002206 	br	8110ac7c <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110abf4:	e0bffd17 	ldw	r2,-12(fp)
8110abf8:	10800317 	ldw	r2,12(r2)
8110abfc:	10800104 	addi	r2,r2,4
8110ac00:	10800037 	ldwio	r2,0(r2)
8110ac04:	10800814 	ori	r2,r2,32
8110ac08:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110ac0c:	0005303a 	rdctl	r2,status
8110ac10:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110ac14:	e0fffa17 	ldw	r3,-24(fp)
8110ac18:	00bfff84 	movi	r2,-2
8110ac1c:	1884703a 	and	r2,r3,r2
8110ac20:	1001703a 	wrctl	status,r2
  
  return context;
8110ac24:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110ac28:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110ac2c:	e0bffd17 	ldw	r2,-12(fp)
8110ac30:	10800317 	ldw	r2,12(r2)
8110ac34:	10800104 	addi	r2,r2,4
8110ac38:	e0fff417 	ldw	r3,-48(fp)
8110ac3c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110ac40:	e0bffd17 	ldw	r2,-12(fp)
8110ac44:	10800317 	ldw	r2,12(r2)
8110ac48:	e0fffd17 	ldw	r3,-12(fp)
8110ac4c:	18c00317 	ldw	r3,12(r3)
8110ac50:	18c00037 	ldwio	r3,0(r3)
8110ac54:	10c00035 	stwio	r3,0(r2)
8110ac58:	e0bff517 	ldw	r2,-44(fp)
8110ac5c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110ac60:	e0bff917 	ldw	r2,-28(fp)
8110ac64:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110ac68:	e0bffd17 	ldw	r2,-12(fp)
8110ac6c:	10801817 	ldw	r2,96(r2)
8110ac70:	1009883a 	mov	r4,r2
8110ac74:	113a5800 	call	8113a580 <OSSemPost>

	return 0;
8110ac78:	0005883a 	mov	r2,zero

}
8110ac7c:	e037883a 	mov	sp,fp
8110ac80:	dfc00117 	ldw	ra,4(sp)
8110ac84:	df000017 	ldw	fp,0(sp)
8110ac88:	dec00204 	addi	sp,sp,8
8110ac8c:	f800283a 	ret

8110ac90 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110ac90:	deffec04 	addi	sp,sp,-80
8110ac94:	de00012e 	bgeu	sp,et,8110ac9c <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110ac98:	003b68fa 	trap	3
8110ac9c:	dfc01315 	stw	ra,76(sp)
8110aca0:	df001215 	stw	fp,72(sp)
8110aca4:	df001204 	addi	fp,sp,72
8110aca8:	e13ff715 	stw	r4,-36(fp)
8110acac:	e17ff815 	stw	r5,-32(fp)
8110acb0:	e1bff915 	stw	r6,-28(fp)
8110acb4:	e1fffa15 	stw	r7,-24(fp)
8110acb8:	e1800617 	ldw	r6,24(fp)
8110acbc:	e1400717 	ldw	r5,28(fp)
8110acc0:	e1000817 	ldw	r4,32(fp)
8110acc4:	e0c00917 	ldw	r3,36(fp)
8110acc8:	e0800a17 	ldw	r2,40(fp)
8110accc:	e1bffb0d 	sth	r6,-20(fp)
8110acd0:	e17ffc05 	stb	r5,-16(fp)
8110acd4:	e13ffd05 	stb	r4,-12(fp)
8110acd8:	e0fffe0d 	sth	r3,-8(fp)
8110acdc:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110ace0:	e0bffb0b 	ldhu	r2,-20(fp)
8110ace4:	e0fffc03 	ldbu	r3,-16(fp)
8110ace8:	e13ffd03 	ldbu	r4,-12(fp)
8110acec:	e17ffe0b 	ldhu	r5,-8(fp)
8110acf0:	e1bfff0b 	ldhu	r6,-4(fp)
8110acf4:	d9800815 	stw	r6,32(sp)
8110acf8:	d9400715 	stw	r5,28(sp)
8110acfc:	d9000615 	stw	r4,24(sp)
8110ad00:	d8c00515 	stw	r3,20(sp)
8110ad04:	d8800415 	stw	r2,16(sp)
8110ad08:	e0800517 	ldw	r2,20(fp)
8110ad0c:	d8800315 	stw	r2,12(sp)
8110ad10:	e0800417 	ldw	r2,16(fp)
8110ad14:	d8800215 	stw	r2,8(sp)
8110ad18:	e0800317 	ldw	r2,12(fp)
8110ad1c:	d8800115 	stw	r2,4(sp)
8110ad20:	e0800217 	ldw	r2,8(fp)
8110ad24:	d8800015 	stw	r2,0(sp)
8110ad28:	e1fffa17 	ldw	r7,-24(fp)
8110ad2c:	e1bff917 	ldw	r6,-28(fp)
8110ad30:	e17ff817 	ldw	r5,-32(fp)
8110ad34:	e13ff717 	ldw	r4,-36(fp)
8110ad38:	110a4180 	call	8110a418 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110ad3c:	e037883a 	mov	sp,fp
8110ad40:	dfc00117 	ldw	ra,4(sp)
8110ad44:	df000017 	ldw	fp,0(sp)
8110ad48:	dec00204 	addi	sp,sp,8
8110ad4c:	f800283a 	ret

8110ad50 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110ad50:	defffc04 	addi	sp,sp,-16
8110ad54:	de00012e 	bgeu	sp,et,8110ad5c <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110ad58:	003b68fa 	trap	3
8110ad5c:	dfc00315 	stw	ra,12(sp)
8110ad60:	df000215 	stw	fp,8(sp)
8110ad64:	df000204 	addi	fp,sp,8
8110ad68:	e13ffe15 	stw	r4,-8(fp)
8110ad6c:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110ad70:	e1bfff17 	ldw	r6,-4(fp)
8110ad74:	000b883a 	mov	r5,zero
8110ad78:	e13ffe17 	ldw	r4,-8(fp)
8110ad7c:	110a57c0 	call	8110a57c <msgdma_descriptor_async_transfer>
}
8110ad80:	e037883a 	mov	sp,fp
8110ad84:	dfc00117 	ldw	ra,4(sp)
8110ad88:	df000017 	ldw	fp,0(sp)
8110ad8c:	dec00204 	addi	sp,sp,8
8110ad90:	f800283a 	ret

8110ad94 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110ad94:	defffc04 	addi	sp,sp,-16
8110ad98:	de00012e 	bgeu	sp,et,8110ada0 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110ad9c:	003b68fa 	trap	3
8110ada0:	dfc00315 	stw	ra,12(sp)
8110ada4:	df000215 	stw	fp,8(sp)
8110ada8:	df000204 	addi	fp,sp,8
8110adac:	e13ffe15 	stw	r4,-8(fp)
8110adb0:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110adb4:	e1bfff17 	ldw	r6,-4(fp)
8110adb8:	000b883a 	mov	r5,zero
8110adbc:	e13ffe17 	ldw	r4,-8(fp)
8110adc0:	110a8940 	call	8110a894 <msgdma_descriptor_sync_transfer>
}
8110adc4:	e037883a 	mov	sp,fp
8110adc8:	dfc00117 	ldw	ra,4(sp)
8110adcc:	df000017 	ldw	fp,0(sp)
8110add0:	dec00204 	addi	sp,sp,8
8110add4:	f800283a 	ret

8110add8 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110add8:	defff204 	addi	sp,sp,-56
8110addc:	de00012e 	bgeu	sp,et,8110ade4 <POWER_SPI_RW+0xc>
8110ade0:	003b68fa 	trap	3
8110ade4:	dfc00d15 	stw	ra,52(sp)
8110ade8:	df000c15 	stw	fp,48(sp)
8110adec:	df000c04 	addi	fp,sp,48
8110adf0:	2007883a 	mov	r3,r4
8110adf4:	2805883a 	mov	r2,r5
8110adf8:	e1bffe15 	stw	r6,-8(fp)
8110adfc:	e1ffff15 	stw	r7,-4(fp)
8110ae00:	e0fffc05 	stb	r3,-16(fp)
8110ae04:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110ae08:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110ae0c:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110ae10:	008003f4 	movhi	r2,15
8110ae14:	10909004 	addi	r2,r2,16960
8110ae18:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110ae1c:	00bfe004 	movi	r2,-128
8110ae20:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110ae24:	e0bffe17 	ldw	r2,-8(fp)
8110ae28:	10000226 	beq	r2,zero,8110ae34 <POWER_SPI_RW+0x5c>
8110ae2c:	00800804 	movi	r2,32
8110ae30:	00000106 	br	8110ae38 <POWER_SPI_RW+0x60>
8110ae34:	0005883a 	mov	r2,zero
8110ae38:	e0fff403 	ldbu	r3,-48(fp)
8110ae3c:	10c4b03a 	or	r2,r2,r3
8110ae40:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110ae44:	e0800217 	ldw	r2,8(fp)
8110ae48:	10000226 	beq	r2,zero,8110ae54 <POWER_SPI_RW+0x7c>
8110ae4c:	00800404 	movi	r2,16
8110ae50:	00000106 	br	8110ae58 <POWER_SPI_RW+0x80>
8110ae54:	0005883a 	mov	r2,zero
8110ae58:	e0fff403 	ldbu	r3,-48(fp)
8110ae5c:	10c4b03a 	or	r2,r2,r3
8110ae60:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110ae64:	e0bfff17 	ldw	r2,-4(fp)
8110ae68:	10000226 	beq	r2,zero,8110ae74 <POWER_SPI_RW+0x9c>
8110ae6c:	00800204 	movi	r2,8
8110ae70:	00000106 	br	8110ae78 <POWER_SPI_RW+0xa0>
8110ae74:	0005883a 	mov	r2,zero
8110ae78:	e0fff403 	ldbu	r3,-48(fp)
8110ae7c:	10c4b03a 	or	r2,r2,r3
8110ae80:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110ae84:	e0bffd03 	ldbu	r2,-12(fp)
8110ae88:	108001cc 	andi	r2,r2,7
8110ae8c:	1007883a 	mov	r3,r2
8110ae90:	e0bff403 	ldbu	r2,-48(fp)
8110ae94:	1884b03a 	or	r2,r3,r2
8110ae98:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110ae9c:	0007883a 	mov	r3,zero
8110aea0:	00a00034 	movhi	r2,32768
8110aea4:	10824404 	addi	r2,r2,2320
8110aea8:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110aeac:	0007883a 	mov	r3,zero
8110aeb0:	00a00034 	movhi	r2,32768
8110aeb4:	10824c04 	addi	r2,r2,2352
8110aeb8:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110aebc:	e0bffc03 	ldbu	r2,-16(fp)
8110aec0:	1000021e 	bne	r2,zero,8110aecc <POWER_SPI_RW+0xf4>
8110aec4:	00c00084 	movi	r3,2
8110aec8:	00000106 	br	8110aed0 <POWER_SPI_RW+0xf8>
8110aecc:	00c00044 	movi	r3,1
8110aed0:	00a00034 	movhi	r2,32768
8110aed4:	10824804 	addi	r2,r2,2336
8110aed8:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110aedc:	010003c4 	movi	r4,15
8110aee0:	11333f40 	call	811333f4 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110aee4:	00000306 	br	8110aef4 <POWER_SPI_RW+0x11c>
		nWait++;
8110aee8:	e0bff817 	ldw	r2,-32(fp)
8110aeec:	10800044 	addi	r2,r2,1
8110aef0:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110aef4:	00a00034 	movhi	r2,32768
8110aef8:	10825404 	addi	r2,r2,2384
8110aefc:	10800037 	ldwio	r2,0(r2)
8110af00:	1080004c 	andi	r2,r2,1
8110af04:	10000326 	beq	r2,zero,8110af14 <POWER_SPI_RW+0x13c>
8110af08:	e0fff817 	ldw	r3,-32(fp)
8110af0c:	e0bffa17 	ldw	r2,-24(fp)
8110af10:	18bff516 	blt	r3,r2,8110aee8 <__reset+0xfb0eaee8>
		nWait++;
	}

	if (SPI_SDO) {
8110af14:	00a00034 	movhi	r2,32768
8110af18:	10825404 	addi	r2,r2,2384
8110af1c:	10800037 	ldwio	r2,0(r2)
8110af20:	1080004c 	andi	r2,r2,1
8110af24:	10000626 	beq	r2,zero,8110af40 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110af28:	00c000c4 	movi	r3,3
8110af2c:	00a00034 	movhi	r2,32768
8110af30:	10824804 	addi	r2,r2,2336
8110af34:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110af38:	0005883a 	mov	r2,zero
8110af3c:	0000db06 	br	8110b2ac <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110af40:	e03ff715 	stw	zero,-36(fp)
8110af44:	00002406 	br	8110afd8 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110af48:	e0bff403 	ldbu	r2,-48(fp)
8110af4c:	10803fcc 	andi	r2,r2,255
8110af50:	1004d1fa 	srli	r2,r2,7
8110af54:	10c03fcc 	andi	r3,r2,255
8110af58:	00a00034 	movhi	r2,32768
8110af5c:	10825004 	addi	r2,r2,2368
8110af60:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110af64:	e0bff403 	ldbu	r2,-48(fp)
8110af68:	1085883a 	add	r2,r2,r2
8110af6c:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110af70:	e0bff517 	ldw	r2,-44(fp)
8110af74:	1085883a 	add	r2,r2,r2
8110af78:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110af7c:	00a00034 	movhi	r2,32768
8110af80:	10825404 	addi	r2,r2,2384
8110af84:	10800037 	ldwio	r2,0(r2)
8110af88:	1080004c 	andi	r2,r2,1
8110af8c:	1007883a 	mov	r3,r2
8110af90:	e0bff517 	ldw	r2,-44(fp)
8110af94:	10c4b03a 	or	r2,r2,r3
8110af98:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110af9c:	00c00044 	movi	r3,1
8110afa0:	00a00034 	movhi	r2,32768
8110afa4:	10824c04 	addi	r2,r2,2352
8110afa8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110afac:	010003c4 	movi	r4,15
8110afb0:	11333f40 	call	811333f4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110afb4:	0007883a 	mov	r3,zero
8110afb8:	00a00034 	movhi	r2,32768
8110afbc:	10824c04 	addi	r2,r2,2352
8110afc0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110afc4:	010003c4 	movi	r4,15
8110afc8:	11333f40 	call	811333f4 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110afcc:	e0bff717 	ldw	r2,-36(fp)
8110afd0:	10800044 	addi	r2,r2,1
8110afd4:	e0bff715 	stw	r2,-36(fp)
8110afd8:	e0bff717 	ldw	r2,-36(fp)
8110afdc:	10800090 	cmplti	r2,r2,2
8110afe0:	103fd91e 	bne	r2,zero,8110af48 <__reset+0xfb0eaf48>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110afe4:	e03ff715 	stw	zero,-36(fp)
8110afe8:	00002406 	br	8110b07c <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110afec:	e0bff403 	ldbu	r2,-48(fp)
8110aff0:	10803fcc 	andi	r2,r2,255
8110aff4:	1004d1fa 	srli	r2,r2,7
8110aff8:	10c03fcc 	andi	r3,r2,255
8110affc:	00a00034 	movhi	r2,32768
8110b000:	10825004 	addi	r2,r2,2368
8110b004:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110b008:	e0bff403 	ldbu	r2,-48(fp)
8110b00c:	1085883a 	add	r2,r2,r2
8110b010:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110b014:	e0bff517 	ldw	r2,-44(fp)
8110b018:	1085883a 	add	r2,r2,r2
8110b01c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110b020:	00a00034 	movhi	r2,32768
8110b024:	10825404 	addi	r2,r2,2384
8110b028:	10800037 	ldwio	r2,0(r2)
8110b02c:	1080004c 	andi	r2,r2,1
8110b030:	1007883a 	mov	r3,r2
8110b034:	e0bff517 	ldw	r2,-44(fp)
8110b038:	10c4b03a 	or	r2,r2,r3
8110b03c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b040:	00c00044 	movi	r3,1
8110b044:	00a00034 	movhi	r2,32768
8110b048:	10824c04 	addi	r2,r2,2352
8110b04c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b050:	010003c4 	movi	r4,15
8110b054:	11333f40 	call	811333f4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b058:	0007883a 	mov	r3,zero
8110b05c:	00a00034 	movhi	r2,32768
8110b060:	10824c04 	addi	r2,r2,2352
8110b064:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b068:	010003c4 	movi	r4,15
8110b06c:	11333f40 	call	811333f4 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110b070:	e0bff717 	ldw	r2,-36(fp)
8110b074:	10800044 	addi	r2,r2,1
8110b078:	e0bff715 	stw	r2,-36(fp)
8110b07c:	e0bff717 	ldw	r2,-36(fp)
8110b080:	10800210 	cmplti	r2,r2,8
8110b084:	103fd91e 	bne	r2,zero,8110afec <__reset+0xfb0eafec>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110b088:	e03ff715 	stw	zero,-36(fp)
8110b08c:	00001a06 	br	8110b0f8 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110b090:	e0bff517 	ldw	r2,-44(fp)
8110b094:	1085883a 	add	r2,r2,r2
8110b098:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110b09c:	00a00034 	movhi	r2,32768
8110b0a0:	10825404 	addi	r2,r2,2384
8110b0a4:	10800037 	ldwio	r2,0(r2)
8110b0a8:	1080004c 	andi	r2,r2,1
8110b0ac:	1007883a 	mov	r3,r2
8110b0b0:	e0bff517 	ldw	r2,-44(fp)
8110b0b4:	10c4b03a 	or	r2,r2,r3
8110b0b8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b0bc:	00c00044 	movi	r3,1
8110b0c0:	00a00034 	movhi	r2,32768
8110b0c4:	10824c04 	addi	r2,r2,2352
8110b0c8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b0cc:	010003c4 	movi	r4,15
8110b0d0:	11333f40 	call	811333f4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b0d4:	0007883a 	mov	r3,zero
8110b0d8:	00a00034 	movhi	r2,32768
8110b0dc:	10824c04 	addi	r2,r2,2352
8110b0e0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b0e4:	010003c4 	movi	r4,15
8110b0e8:	11333f40 	call	811333f4 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110b0ec:	e0bff717 	ldw	r2,-36(fp)
8110b0f0:	10800044 	addi	r2,r2,1
8110b0f4:	e0bff715 	stw	r2,-36(fp)
8110b0f8:	e0bff717 	ldw	r2,-36(fp)
8110b0fc:	10800210 	cmplti	r2,r2,8
8110b100:	103fe31e 	bne	r2,zero,8110b090 <__reset+0xfb0eb090>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110b104:	e03ff715 	stw	zero,-36(fp)
8110b108:	00001a06 	br	8110b174 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110b10c:	e0bff517 	ldw	r2,-44(fp)
8110b110:	1085883a 	add	r2,r2,r2
8110b114:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110b118:	00a00034 	movhi	r2,32768
8110b11c:	10825404 	addi	r2,r2,2384
8110b120:	10800037 	ldwio	r2,0(r2)
8110b124:	1080004c 	andi	r2,r2,1
8110b128:	1007883a 	mov	r3,r2
8110b12c:	e0bff517 	ldw	r2,-44(fp)
8110b130:	10c4b03a 	or	r2,r2,r3
8110b134:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b138:	00c00044 	movi	r3,1
8110b13c:	00a00034 	movhi	r2,32768
8110b140:	10824c04 	addi	r2,r2,2352
8110b144:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b148:	010003c4 	movi	r4,15
8110b14c:	11333f40 	call	811333f4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b150:	0007883a 	mov	r3,zero
8110b154:	00a00034 	movhi	r2,32768
8110b158:	10824c04 	addi	r2,r2,2352
8110b15c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b160:	010003c4 	movi	r4,15
8110b164:	11333f40 	call	811333f4 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110b168:	e0bff717 	ldw	r2,-36(fp)
8110b16c:	10800044 	addi	r2,r2,1
8110b170:	e0bff715 	stw	r2,-36(fp)
8110b174:	e0bff717 	ldw	r2,-36(fp)
8110b178:	10800210 	cmplti	r2,r2,8
8110b17c:	103fe31e 	bne	r2,zero,8110b10c <__reset+0xfb0eb10c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110b180:	e03ff715 	stw	zero,-36(fp)
8110b184:	00001a06 	br	8110b1f0 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110b188:	e0bff517 	ldw	r2,-44(fp)
8110b18c:	1085883a 	add	r2,r2,r2
8110b190:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110b194:	00a00034 	movhi	r2,32768
8110b198:	10825404 	addi	r2,r2,2384
8110b19c:	10800037 	ldwio	r2,0(r2)
8110b1a0:	1080004c 	andi	r2,r2,1
8110b1a4:	1007883a 	mov	r3,r2
8110b1a8:	e0bff517 	ldw	r2,-44(fp)
8110b1ac:	10c4b03a 	or	r2,r2,r3
8110b1b0:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b1b4:	00c00044 	movi	r3,1
8110b1b8:	00a00034 	movhi	r2,32768
8110b1bc:	10824c04 	addi	r2,r2,2352
8110b1c0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b1c4:	010003c4 	movi	r4,15
8110b1c8:	11333f40 	call	811333f4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b1cc:	0007883a 	mov	r3,zero
8110b1d0:	00a00034 	movhi	r2,32768
8110b1d4:	10824c04 	addi	r2,r2,2352
8110b1d8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b1dc:	010003c4 	movi	r4,15
8110b1e0:	11333f40 	call	811333f4 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110b1e4:	e0bff717 	ldw	r2,-36(fp)
8110b1e8:	10800044 	addi	r2,r2,1
8110b1ec:	e0bff715 	stw	r2,-36(fp)
8110b1f0:	e0bff717 	ldw	r2,-36(fp)
8110b1f4:	10800190 	cmplti	r2,r2,6
8110b1f8:	103fe31e 	bne	r2,zero,8110b188 <__reset+0xfb0eb188>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110b1fc:	00c00044 	movi	r3,1
8110b200:	00a00034 	movhi	r2,32768
8110b204:	10824c04 	addi	r2,r2,2352
8110b208:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110b20c:	010003c4 	movi	r4,15
8110b210:	11333f40 	call	811333f4 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110b214:	00c000c4 	movi	r3,3
8110b218:	00a00034 	movhi	r2,32768
8110b21c:	10824804 	addi	r2,r2,2336
8110b220:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110b224:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110b228:	00800044 	movi	r2,1
8110b22c:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110b230:	e03ff715 	stw	zero,-36(fp)
8110b234:	00000d06 	br	8110b26c <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110b238:	e0fff517 	ldw	r3,-44(fp)
8110b23c:	e0bff617 	ldw	r2,-40(fp)
8110b240:	1884703a 	and	r2,r3,r2
8110b244:	1000031e 	bne	r2,zero,8110b254 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110b248:	e0bff917 	ldw	r2,-28(fp)
8110b24c:	10800044 	addi	r2,r2,1
8110b250:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110b254:	e0bff617 	ldw	r2,-40(fp)
8110b258:	1085883a 	add	r2,r2,r2
8110b25c:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110b260:	e0bff717 	ldw	r2,-36(fp)
8110b264:	10800044 	addi	r2,r2,1
8110b268:	e0bff715 	stw	r2,-36(fp)
8110b26c:	e0bff717 	ldw	r2,-36(fp)
8110b270:	10800810 	cmplti	r2,r2,32
8110b274:	103ff01e 	bne	r2,zero,8110b238 <__reset+0xfb0eb238>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110b278:	e0bff917 	ldw	r2,-28(fp)
8110b27c:	1080004c 	andi	r2,r2,1
8110b280:	1005003a 	cmpeq	r2,r2,zero
8110b284:	10803fcc 	andi	r2,r2,255
8110b288:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110b28c:	e0bffb17 	ldw	r2,-20(fp)
8110b290:	1000021e 	bne	r2,zero,8110b29c <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110b294:	0005883a 	mov	r2,zero
8110b298:	00000406 	br	8110b2ac <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110b29c:	e0800317 	ldw	r2,12(fp)
8110b2a0:	e0fff517 	ldw	r3,-44(fp)
8110b2a4:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110b2a8:	e0bffb17 	ldw	r2,-20(fp)
}
8110b2ac:	e037883a 	mov	sp,fp
8110b2b0:	dfc00117 	ldw	ra,4(sp)
8110b2b4:	df000017 	ldw	fp,0(sp)
8110b2b8:	dec00204 	addi	sp,sp,8
8110b2bc:	f800283a 	ret

8110b2c0 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110b2c0:	defffc04 	addi	sp,sp,-16
8110b2c4:	de00012e 	bgeu	sp,et,8110b2cc <vRstcSimucamReset+0xc>
8110b2c8:	003b68fa 	trap	3
8110b2cc:	dfc00315 	stw	ra,12(sp)
8110b2d0:	df000215 	stw	fp,8(sp)
8110b2d4:	df000204 	addi	fp,sp,8
8110b2d8:	2005883a 	mov	r2,r4
8110b2dc:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110b2e0:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110b2e4:	e0bfff0b 	ldhu	r2,-4(fp)
8110b2e8:	e0fffe17 	ldw	r3,-8(fp)
8110b2ec:	1884b03a 	or	r2,r3,r2
8110b2f0:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110b2f4:	e0bffe17 	ldw	r2,-8(fp)
8110b2f8:	10800074 	orhi	r2,r2,1
8110b2fc:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b300:	e1bffe17 	ldw	r6,-8(fp)
8110b304:	000b883a 	mov	r5,zero
8110b308:	01200034 	movhi	r4,32768
8110b30c:	21020004 	addi	r4,r4,2048
8110b310:	110b4100 	call	8110b410 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110b314:	0001883a 	nop
8110b318:	e037883a 	mov	sp,fp
8110b31c:	dfc00117 	ldw	ra,4(sp)
8110b320:	df000017 	ldw	fp,0(sp)
8110b324:	dec00204 	addi	sp,sp,8
8110b328:	f800283a 	ret

8110b32c <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110b32c:	defffc04 	addi	sp,sp,-16
8110b330:	de00012e 	bgeu	sp,et,8110b338 <vRstcReleaseDeviceReset+0xc>
8110b334:	003b68fa 	trap	3
8110b338:	dfc00315 	stw	ra,12(sp)
8110b33c:	df000215 	stw	fp,8(sp)
8110b340:	df000204 	addi	fp,sp,8
8110b344:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110b348:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b34c:	01400044 	movi	r5,1
8110b350:	01200034 	movhi	r4,32768
8110b354:	21020004 	addi	r4,r4,2048
8110b358:	110b4640 	call	8110b464 <uliRstReadReg>
8110b35c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110b360:	e0bfff17 	ldw	r2,-4(fp)
8110b364:	0084303a 	nor	r2,zero,r2
8110b368:	e0fffe17 	ldw	r3,-8(fp)
8110b36c:	1884703a 	and	r2,r3,r2
8110b370:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b374:	e1bffe17 	ldw	r6,-8(fp)
8110b378:	01400044 	movi	r5,1
8110b37c:	01200034 	movhi	r4,32768
8110b380:	21020004 	addi	r4,r4,2048
8110b384:	110b4100 	call	8110b410 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b388:	0001883a 	nop
8110b38c:	e037883a 	mov	sp,fp
8110b390:	dfc00117 	ldw	ra,4(sp)
8110b394:	df000017 	ldw	fp,0(sp)
8110b398:	dec00204 	addi	sp,sp,8
8110b39c:	f800283a 	ret

8110b3a0 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110b3a0:	defffc04 	addi	sp,sp,-16
8110b3a4:	de00012e 	bgeu	sp,et,8110b3ac <vRstcHoldDeviceReset+0xc>
8110b3a8:	003b68fa 	trap	3
8110b3ac:	dfc00315 	stw	ra,12(sp)
8110b3b0:	df000215 	stw	fp,8(sp)
8110b3b4:	df000204 	addi	fp,sp,8
8110b3b8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110b3bc:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b3c0:	01400044 	movi	r5,1
8110b3c4:	01200034 	movhi	r4,32768
8110b3c8:	21020004 	addi	r4,r4,2048
8110b3cc:	110b4640 	call	8110b464 <uliRstReadReg>
8110b3d0:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110b3d4:	e0fffe17 	ldw	r3,-8(fp)
8110b3d8:	e0bfff17 	ldw	r2,-4(fp)
8110b3dc:	1884b03a 	or	r2,r3,r2
8110b3e0:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b3e4:	e1bffe17 	ldw	r6,-8(fp)
8110b3e8:	01400044 	movi	r5,1
8110b3ec:	01200034 	movhi	r4,32768
8110b3f0:	21020004 	addi	r4,r4,2048
8110b3f4:	110b4100 	call	8110b410 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b3f8:	0001883a 	nop
8110b3fc:	e037883a 	mov	sp,fp
8110b400:	dfc00117 	ldw	ra,4(sp)
8110b404:	df000017 	ldw	fp,0(sp)
8110b408:	dec00204 	addi	sp,sp,8
8110b40c:	f800283a 	ret

8110b410 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110b410:	defffc04 	addi	sp,sp,-16
8110b414:	de00012e 	bgeu	sp,et,8110b41c <vRstcWriteReg+0xc>
8110b418:	003b68fa 	trap	3
8110b41c:	df000315 	stw	fp,12(sp)
8110b420:	df000304 	addi	fp,sp,12
8110b424:	e13ffd15 	stw	r4,-12(fp)
8110b428:	e17ffe15 	stw	r5,-8(fp)
8110b42c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110b430:	e0bffe17 	ldw	r2,-8(fp)
8110b434:	1085883a 	add	r2,r2,r2
8110b438:	1085883a 	add	r2,r2,r2
8110b43c:	1007883a 	mov	r3,r2
8110b440:	e0bffd17 	ldw	r2,-12(fp)
8110b444:	10c5883a 	add	r2,r2,r3
8110b448:	e0ffff17 	ldw	r3,-4(fp)
8110b44c:	10c00015 	stw	r3,0(r2)
}
8110b450:	0001883a 	nop
8110b454:	e037883a 	mov	sp,fp
8110b458:	df000017 	ldw	fp,0(sp)
8110b45c:	dec00104 	addi	sp,sp,4
8110b460:	f800283a 	ret

8110b464 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110b464:	defffc04 	addi	sp,sp,-16
8110b468:	de00012e 	bgeu	sp,et,8110b470 <uliRstReadReg+0xc>
8110b46c:	003b68fa 	trap	3
8110b470:	df000315 	stw	fp,12(sp)
8110b474:	df000304 	addi	fp,sp,12
8110b478:	e13ffe15 	stw	r4,-8(fp)
8110b47c:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110b480:	e0bfff17 	ldw	r2,-4(fp)
8110b484:	1085883a 	add	r2,r2,r2
8110b488:	1085883a 	add	r2,r2,r2
8110b48c:	1007883a 	mov	r3,r2
8110b490:	e0bffe17 	ldw	r2,-8(fp)
8110b494:	10c5883a 	add	r2,r2,r3
8110b498:	10800017 	ldw	r2,0(r2)
8110b49c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110b4a0:	e0bffd17 	ldw	r2,-12(fp)
}
8110b4a4:	e037883a 	mov	sp,fp
8110b4a8:	df000017 	ldw	fp,0(sp)
8110b4ac:	dec00104 	addi	sp,sp,4
8110b4b0:	f800283a 	ret

8110b4b4 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110b4b4:	defffe04 	addi	sp,sp,-8
8110b4b8:	de00012e 	bgeu	sp,et,8110b4c0 <v_spi_start+0xc>
8110b4bc:	003b68fa 	trap	3
8110b4c0:	dfc00115 	stw	ra,4(sp)
8110b4c4:	df000015 	stw	fp,0(sp)
8110b4c8:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110b4cc:	0007883a 	mov	r3,zero
8110b4d0:	00a00034 	movhi	r2,32768
8110b4d4:	10823004 	addi	r2,r2,2240
8110b4d8:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110b4dc:	0007883a 	mov	r3,zero
8110b4e0:	00a00034 	movhi	r2,32768
8110b4e4:	10822c04 	addi	r2,r2,2224
8110b4e8:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b4ec:	01002584 	movi	r4,150
8110b4f0:	11333f40 	call	811333f4 <usleep>
}
8110b4f4:	0001883a 	nop
8110b4f8:	e037883a 	mov	sp,fp
8110b4fc:	dfc00117 	ldw	ra,4(sp)
8110b500:	df000017 	ldw	fp,0(sp)
8110b504:	dec00204 	addi	sp,sp,8
8110b508:	f800283a 	ret

8110b50c <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110b50c:	defffc04 	addi	sp,sp,-16
8110b510:	de00012e 	bgeu	sp,et,8110b518 <v_spi_send_byte+0xc>
8110b514:	003b68fa 	trap	3
8110b518:	dfc00315 	stw	ra,12(sp)
8110b51c:	df000215 	stw	fp,8(sp)
8110b520:	df000204 	addi	fp,sp,8
8110b524:	2005883a 	mov	r2,r4
8110b528:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110b52c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110b530:	00bfe004 	movi	r2,-128
8110b534:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110b538:	e03ffe05 	stb	zero,-8(fp)
8110b53c:	00001b06 	br	8110b5ac <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110b540:	e0ffff03 	ldbu	r3,-4(fp)
8110b544:	e0bffe43 	ldbu	r2,-7(fp)
8110b548:	1884703a 	and	r2,r3,r2
8110b54c:	10803fcc 	andi	r2,r2,255
8110b550:	1004c03a 	cmpne	r2,r2,zero
8110b554:	10c03fcc 	andi	r3,r2,255
8110b558:	00a00034 	movhi	r2,32768
8110b55c:	10823404 	addi	r2,r2,2256
8110b560:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110b564:	e0bffe43 	ldbu	r2,-7(fp)
8110b568:	1004d07a 	srli	r2,r2,1
8110b56c:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b570:	00c00044 	movi	r3,1
8110b574:	00a00034 	movhi	r2,32768
8110b578:	10823004 	addi	r2,r2,2240
8110b57c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b580:	01002584 	movi	r4,150
8110b584:	11333f40 	call	811333f4 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b588:	0007883a 	mov	r3,zero
8110b58c:	00a00034 	movhi	r2,32768
8110b590:	10823004 	addi	r2,r2,2240
8110b594:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b598:	01002584 	movi	r4,150
8110b59c:	11333f40 	call	811333f4 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110b5a0:	e0bffe03 	ldbu	r2,-8(fp)
8110b5a4:	10800044 	addi	r2,r2,1
8110b5a8:	e0bffe05 	stb	r2,-8(fp)
8110b5ac:	e0bffe03 	ldbu	r2,-8(fp)
8110b5b0:	10800230 	cmpltui	r2,r2,8
8110b5b4:	103fe21e 	bne	r2,zero,8110b540 <__reset+0xfb0eb540>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110b5b8:	0001883a 	nop
8110b5bc:	e037883a 	mov	sp,fp
8110b5c0:	dfc00117 	ldw	ra,4(sp)
8110b5c4:	df000017 	ldw	fp,0(sp)
8110b5c8:	dec00204 	addi	sp,sp,8
8110b5cc:	f800283a 	ret

8110b5d0 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110b5d0:	defffd04 	addi	sp,sp,-12
8110b5d4:	de00012e 	bgeu	sp,et,8110b5dc <uc_spi_get_byte+0xc>
8110b5d8:	003b68fa 	trap	3
8110b5dc:	dfc00215 	stw	ra,8(sp)
8110b5e0:	df000115 	stw	fp,4(sp)
8110b5e4:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110b5e8:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110b5ec:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110b5f0:	e03fff05 	stb	zero,-4(fp)
8110b5f4:	00001a06 	br	8110b660 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110b5f8:	e0bfff43 	ldbu	r2,-3(fp)
8110b5fc:	1085883a 	add	r2,r2,r2
8110b600:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110b604:	00a00034 	movhi	r2,32768
8110b608:	10823804 	addi	r2,r2,2272
8110b60c:	10800037 	ldwio	r2,0(r2)
8110b610:	1080004c 	andi	r2,r2,1
8110b614:	1007883a 	mov	r3,r2
8110b618:	e0bfff43 	ldbu	r2,-3(fp)
8110b61c:	1884b03a 	or	r2,r3,r2
8110b620:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b624:	00c00044 	movi	r3,1
8110b628:	00a00034 	movhi	r2,32768
8110b62c:	10823004 	addi	r2,r2,2240
8110b630:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b634:	01002584 	movi	r4,150
8110b638:	11333f40 	call	811333f4 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b63c:	0007883a 	mov	r3,zero
8110b640:	00a00034 	movhi	r2,32768
8110b644:	10823004 	addi	r2,r2,2240
8110b648:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b64c:	01002584 	movi	r4,150
8110b650:	11333f40 	call	811333f4 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110b654:	e0bfff03 	ldbu	r2,-4(fp)
8110b658:	10800044 	addi	r2,r2,1
8110b65c:	e0bfff05 	stb	r2,-4(fp)
8110b660:	e0bfff03 	ldbu	r2,-4(fp)
8110b664:	10800230 	cmpltui	r2,r2,8
8110b668:	103fe31e 	bne	r2,zero,8110b5f8 <__reset+0xfb0eb5f8>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110b66c:	e0bfff43 	ldbu	r2,-3(fp)
}
8110b670:	e037883a 	mov	sp,fp
8110b674:	dfc00117 	ldw	ra,4(sp)
8110b678:	df000017 	ldw	fp,0(sp)
8110b67c:	dec00204 	addi	sp,sp,8
8110b680:	f800283a 	ret

8110b684 <v_spi_end>:

void v_spi_end(void){
8110b684:	defffe04 	addi	sp,sp,-8
8110b688:	de00012e 	bgeu	sp,et,8110b690 <v_spi_end+0xc>
8110b68c:	003b68fa 	trap	3
8110b690:	dfc00115 	stw	ra,4(sp)
8110b694:	df000015 	stw	fp,0(sp)
8110b698:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110b69c:	0007883a 	mov	r3,zero
8110b6a0:	00a00034 	movhi	r2,32768
8110b6a4:	10823004 	addi	r2,r2,2240
8110b6a8:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b6ac:	01002584 	movi	r4,150
8110b6b0:	11333f40 	call	811333f4 <usleep>
    SPI_CS_N(1);
8110b6b4:	00c00044 	movi	r3,1
8110b6b8:	00a00034 	movhi	r2,32768
8110b6bc:	10822c04 	addi	r2,r2,2224
8110b6c0:	10c00035 	stwio	r3,0(r2)
}
8110b6c4:	0001883a 	nop
8110b6c8:	e037883a 	mov	sp,fp
8110b6cc:	dfc00117 	ldw	ra,4(sp)
8110b6d0:	df000017 	ldw	fp,0(sp)
8110b6d4:	dec00204 	addi	sp,sp,8
8110b6d8:	f800283a 	ret

8110b6dc <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110b6dc:	defff604 	addi	sp,sp,-40
8110b6e0:	de00012e 	bgeu	sp,et,8110b6e8 <RTCC_SPI_R_MAC+0xc>
8110b6e4:	003b68fa 	trap	3
8110b6e8:	dfc00915 	stw	ra,36(sp)
8110b6ec:	df000815 	stw	fp,32(sp)
8110b6f0:	df000804 	addi	fp,sp,32
8110b6f4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110b6f8:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110b6fc:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110b700:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110b704:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110b708:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110b70c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110b710:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110b714:	00800084 	movi	r2,2
8110b718:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110b71c:	00800cc4 	movi	r2,51
8110b720:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110b724:	110b4b40 	call	8110b4b4 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110b728:	e0bffec3 	ldbu	r2,-5(fp)
8110b72c:	1009883a 	mov	r4,r2
8110b730:	110b50c0 	call	8110b50c <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110b734:	e0bffe83 	ldbu	r2,-6(fp)
8110b738:	1009883a 	mov	r4,r2
8110b73c:	110b50c0 	call	8110b50c <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110b740:	110b5d00 	call	8110b5d0 <uc_spi_get_byte>
8110b744:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110b748:	110b5d00 	call	8110b5d0 <uc_spi_get_byte>
8110b74c:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110b750:	110b5d00 	call	8110b5d0 <uc_spi_get_byte>
8110b754:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110b758:	110b5d00 	call	8110b5d0 <uc_spi_get_byte>
8110b75c:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110b760:	110b5d00 	call	8110b5d0 <uc_spi_get_byte>
8110b764:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110b768:	110b5d00 	call	8110b5d0 <uc_spi_get_byte>
8110b76c:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110b770:	110b6840 	call	8110b684 <v_spi_end>

    bSuccess = TRUE;
8110b774:	00800044 	movi	r2,1
8110b778:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110b77c:	e0bfff17 	ldw	r2,-4(fp)
8110b780:	e0fffd03 	ldbu	r3,-12(fp)
8110b784:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110b788:	e0bfff17 	ldw	r2,-4(fp)
8110b78c:	10800044 	addi	r2,r2,1
8110b790:	e0fffd43 	ldbu	r3,-11(fp)
8110b794:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110b798:	e0bfff17 	ldw	r2,-4(fp)
8110b79c:	10800084 	addi	r2,r2,2
8110b7a0:	e0fffd83 	ldbu	r3,-10(fp)
8110b7a4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110b7a8:	e0bfff17 	ldw	r2,-4(fp)
8110b7ac:	108000c4 	addi	r2,r2,3
8110b7b0:	e0fffdc3 	ldbu	r3,-9(fp)
8110b7b4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110b7b8:	e0bfff17 	ldw	r2,-4(fp)
8110b7bc:	10800104 	addi	r2,r2,4
8110b7c0:	e0fffe03 	ldbu	r3,-8(fp)
8110b7c4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110b7c8:	e0bfff17 	ldw	r2,-4(fp)
8110b7cc:	10800144 	addi	r2,r2,5
8110b7d0:	e0fffe43 	ldbu	r3,-7(fp)
8110b7d4:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110b7d8:	e1bffd03 	ldbu	r6,-12(fp)
8110b7dc:	e1fffd43 	ldbu	r7,-11(fp)
8110b7e0:	e0bffd83 	ldbu	r2,-10(fp)
8110b7e4:	e0fffdc3 	ldbu	r3,-9(fp)
8110b7e8:	e13ffe03 	ldbu	r4,-8(fp)
8110b7ec:	e17ffe43 	ldbu	r5,-7(fp)
8110b7f0:	d9400315 	stw	r5,12(sp)
8110b7f4:	d9000215 	stw	r4,8(sp)
8110b7f8:	d8c00115 	stw	r3,4(sp)
8110b7fc:	d8800015 	stw	r2,0(sp)
8110b800:	01604534 	movhi	r5,33044
8110b804:	295f2804 	addi	r5,r5,31904
8110b808:	01204574 	movhi	r4,33045
8110b80c:	2138de04 	addi	r4,r4,-7304
8110b810:	111daac0 	call	8111daac <sprintf>
	debug(fp, cDebugBuffer);
8110b814:	d0a05d17 	ldw	r2,-32396(gp)
8110b818:	01604574 	movhi	r5,33045
8110b81c:	2978de04 	addi	r5,r5,-7304
8110b820:	1009883a 	mov	r4,r2
8110b824:	111c11c0 	call	8111c11c <fprintf>
#endif

    return bSuccess;
8110b828:	e0bffc17 	ldw	r2,-16(fp)
}
8110b82c:	e037883a 	mov	sp,fp
8110b830:	dfc00117 	ldw	ra,4(sp)
8110b834:	df000017 	ldw	fp,0(sp)
8110b838:	dec00204 	addi	sp,sp,8
8110b83c:	f800283a 	ret

8110b840 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110b840:	defffd04 	addi	sp,sp,-12
8110b844:	de00012e 	bgeu	sp,et,8110b84c <bSSDisplayConfig+0xc>
8110b848:	003b68fa 	trap	3
8110b84c:	df000215 	stw	fp,8(sp)
8110b850:	df000204 	addi	fp,sp,8
8110b854:	2005883a 	mov	r2,r4
8110b858:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110b85c:	e0bfff03 	ldbu	r2,-4(fp)
8110b860:	10c00168 	cmpgeui	r3,r2,5
8110b864:	18001c1e 	bne	r3,zero,8110b8d8 <bSSDisplayConfig+0x98>
8110b868:	100690ba 	slli	r3,r2,2
8110b86c:	00a04474 	movhi	r2,33041
8110b870:	10ae2004 	addi	r2,r2,-18304
8110b874:	1885883a 	add	r2,r3,r2
8110b878:	10800017 	ldw	r2,0(r2)
8110b87c:	1000683a 	jmp	r2
8110b880:	8110b894 	ori	r4,r16,17122
8110b884:	8110b8a0 	cmpeqi	r4,r16,17122
8110b888:	8110b8ac 	andhi	r4,r16,17122
8110b88c:	8110b8c0 	call	88110b8c <__reset+0x20f0b8c>
8110b890:	8110b8d0 	cmplti	r4,r16,17123
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110b894:	00800cc4 	movi	r2,51
8110b898:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b89c:	00001006 	br	8110b8e0 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110b8a0:	00801544 	movi	r2,85
8110b8a4:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b8a8:	00000d06 	br	8110b8e0 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110b8ac:	d0e04e43 	ldbu	r3,-32455(gp)
8110b8b0:	00bff744 	movi	r2,-35
8110b8b4:	1884703a 	and	r2,r3,r2
8110b8b8:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b8bc:	00000806 	br	8110b8e0 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110b8c0:	d0a04e43 	ldbu	r2,-32455(gp)
8110b8c4:	10800894 	ori	r2,r2,34
8110b8c8:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b8cc:	00000406 	br	8110b8e0 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110b8d0:	d0204e45 	stb	zero,-32455(gp)
	    break;
8110b8d4:	00000206 	br	8110b8e0 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110b8d8:	0005883a 	mov	r2,zero
8110b8dc:	00000806 	br	8110b900 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b8e0:	00a00034 	movhi	r2,32768
8110b8e4:	10828404 	addi	r2,r2,2576
8110b8e8:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110b8ec:	d0a04e43 	ldbu	r2,-32455(gp)
8110b8f0:	10c03fcc 	andi	r3,r2,255
8110b8f4:	e0bffe17 	ldw	r2,-8(fp)
8110b8f8:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b8fc:	00800044 	movi	r2,1
}
8110b900:	e037883a 	mov	sp,fp
8110b904:	df000017 	ldw	fp,0(sp)
8110b908:	dec00104 	addi	sp,sp,4
8110b90c:	f800283a 	ret

8110b910 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110b910:	defffd04 	addi	sp,sp,-12
8110b914:	de00012e 	bgeu	sp,et,8110b91c <bSSDisplayUpdate+0xc>
8110b918:	003b68fa 	trap	3
8110b91c:	df000215 	stw	fp,8(sp)
8110b920:	df000204 	addi	fp,sp,8
8110b924:	2005883a 	mov	r2,r4
8110b928:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b92c:	00a00034 	movhi	r2,32768
8110b930:	10828404 	addi	r2,r2,2576
8110b934:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110b938:	e0bffe17 	ldw	r2,-8(fp)
8110b93c:	10800104 	addi	r2,r2,4
8110b940:	e0ffff03 	ldbu	r3,-4(fp)
8110b944:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b948:	00800044 	movi	r2,1
}
8110b94c:	e037883a 	mov	sp,fp
8110b950:	df000017 	ldw	fp,0(sp)
8110b954:	dec00104 	addi	sp,sp,4
8110b958:	f800283a 	ret

8110b95c <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110b95c:	defff904 	addi	sp,sp,-28
8110b960:	de00012e 	bgeu	sp,et,8110b968 <vSyncHandleIrq+0xc>
8110b964:	003b68fa 	trap	3
8110b968:	dfc00615 	stw	ra,24(sp)
8110b96c:	df000515 	stw	fp,20(sp)
8110b970:	df000504 	addi	fp,sp,20
8110b974:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110b978:	e0bfff17 	ldw	r2,-4(fp)
8110b97c:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110b980:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110b984:	d0a05003 	ldbu	r2,-32448(gp)
8110b988:	108000cc 	andi	r2,r2,3
8110b98c:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 ) {
8110b990:	e0bffd03 	ldbu	r2,-12(fp)
8110b994:	10000e1e 	bne	r2,zero,8110b9d0 <vSyncHandleIrq+0x74>

		uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110b998:	00800044 	movi	r2,1
8110b99c:	e0bffec5 	stb	r2,-5(fp)
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110b9a0:	00bff804 	movi	r2,-32
8110b9a4:	e0bffe85 	stb	r2,-6(fp)

		/* Send Priority message to the Meb Task to indicate the Master Sync */
		error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110b9a8:	d0a06417 	ldw	r2,-32368(gp)
8110b9ac:	e0fffe17 	ldw	r3,-8(fp)
8110b9b0:	180b883a 	mov	r5,r3
8110b9b4:	1009883a 	mov	r4,r2
8110b9b8:	11398780 	call	81139878 <OSQPostFront>
8110b9bc:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110b9c0:	e0bffd43 	ldbu	r2,-11(fp)
8110b9c4:	10000426 	beq	r2,zero,8110b9d8 <vSyncHandleIrq+0x7c>
			vFailSendMsgMasterSyncMeb( );
8110b9c8:	1118e4c0 	call	81118e4c <vFailSendMsgMasterSyncMeb>
8110b9cc:	00000206 	br	8110b9d8 <vSyncHandleIrq+0x7c>
		}

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110b9d0:	00bff844 	movi	r2,-31
8110b9d4:	e0bffe85 	stb	r2,-6(fp)


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110b9d8:	e03ffb05 	stb	zero,-20(fp)
8110b9dc:	00001f06 	br	8110ba5c <vSyncHandleIrq+0x100>

		if ( xSimMeb.xFeeControl.xNfee[ucIL].xControl.bWatingSync == TRUE ) {
8110b9e0:	e0fffb03 	ldbu	r3,-20(fp)
8110b9e4:	00a04574 	movhi	r2,33045
8110b9e8:	108f1e04 	addi	r2,r2,15480
8110b9ec:	18c09524 	muli	r3,r3,596
8110b9f0:	10c5883a 	add	r2,r2,r3
8110b9f4:	10803a04 	addi	r2,r2,232
8110b9f8:	10800017 	ldw	r2,0(r2)
8110b9fc:	10800058 	cmpnei	r2,r2,1
8110ba00:	1000131e 	bne	r2,zero,8110ba50 <vSyncHandleIrq+0xf4>
			uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110ba04:	e0bffb03 	ldbu	r2,-20(fp)
8110ba08:	10800444 	addi	r2,r2,17
8110ba0c:	e0bffec5 	stb	r2,-5(fp)
			error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110ba10:	e0bffb03 	ldbu	r2,-20(fp)
8110ba14:	1085883a 	add	r2,r2,r2
8110ba18:	1087883a 	add	r3,r2,r2
8110ba1c:	d0a05704 	addi	r2,gp,-32420
8110ba20:	1885883a 	add	r2,r3,r2
8110ba24:	10800017 	ldw	r2,0(r2)
8110ba28:	e0fffe17 	ldw	r3,-8(fp)
8110ba2c:	180b883a 	mov	r5,r3
8110ba30:	1009883a 	mov	r4,r2
8110ba34:	11397080 	call	81139708 <OSQPost>
8110ba38:	e0bffd45 	stb	r2,-11(fp)
			if ( error_codel != OS_ERR_NONE ) {
8110ba3c:	e0bffd43 	ldbu	r2,-11(fp)
8110ba40:	10000326 	beq	r2,zero,8110ba50 <vSyncHandleIrq+0xf4>
				vFailSendMsgSync( ucIL );
8110ba44:	e0bffb03 	ldbu	r2,-20(fp)
8110ba48:	1009883a 	mov	r4,r2
8110ba4c:	1118df80 	call	81118df8 <vFailSendMsgSync>

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ba50:	e0bffb03 	ldbu	r2,-20(fp)
8110ba54:	10800044 	addi	r2,r2,1
8110ba58:	e0bffb05 	stb	r2,-20(fp)
8110ba5c:	e0bffb03 	ldbu	r2,-20(fp)
8110ba60:	103fdf26 	beq	r2,zero,8110b9e0 <__reset+0xfb0eb9e0>
				vFailSendMsgSync( ucIL );
			}
		}
	}

	vucN += 1;
8110ba64:	d0a05003 	ldbu	r2,-32448(gp)
8110ba68:	10800044 	addi	r2,r2,1
8110ba6c:	d0a05005 	stb	r2,-32448(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110ba70:	d0a05d17 	ldw	r2,-32396(gp)
8110ba74:	e0fffd03 	ldbu	r3,-12(fp)
8110ba78:	180d883a 	mov	r6,r3
8110ba7c:	01604534 	movhi	r5,33044
8110ba80:	295f3704 	addi	r5,r5,31964
8110ba84:	1009883a 	mov	r4,r2
8110ba88:	111c11c0 	call	8111c11c <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110ba8c:	110bb200 	call	8110bb20 <vSyncIrqFlagClrSync>
}
8110ba90:	0001883a 	nop
8110ba94:	e037883a 	mov	sp,fp
8110ba98:	dfc00117 	ldw	ra,4(sp)
8110ba9c:	df000017 	ldw	fp,0(sp)
8110baa0:	dec00204 	addi	sp,sp,8
8110baa4:	f800283a 	ret

8110baa8 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110baa8:	deffff04 	addi	sp,sp,-4
8110baac:	de00012e 	bgeu	sp,et,8110bab4 <vSyncClearCounter+0xc>
8110bab0:	003b68fa 	trap	3
8110bab4:	df000015 	stw	fp,0(sp)
8110bab8:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110babc:	d0205005 	stb	zero,-32448(gp)
}
8110bac0:	0001883a 	nop
8110bac4:	e037883a 	mov	sp,fp
8110bac8:	df000017 	ldw	fp,0(sp)
8110bacc:	dec00104 	addi	sp,sp,4
8110bad0:	f800283a 	ret

8110bad4 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110bad4:	defffd04 	addi	sp,sp,-12
8110bad8:	de00012e 	bgeu	sp,et,8110bae0 <vSyncInitIrq+0xc>
8110badc:	003b68fa 	trap	3
8110bae0:	dfc00215 	stw	ra,8(sp)
8110bae4:	df000115 	stw	fp,4(sp)
8110bae8:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110baec:	d0a04f04 	addi	r2,gp,-32452
8110baf0:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110baf4:	01a04474 	movhi	r6,33041
8110baf8:	31ae5704 	addi	r6,r6,-18084
8110bafc:	e17fff17 	ldw	r5,-4(fp)
8110bb00:	01000284 	movi	r4,10
8110bb04:	1131d240 	call	81131d24 <alt_irq_register>
}
8110bb08:	0001883a 	nop
8110bb0c:	e037883a 	mov	sp,fp
8110bb10:	dfc00117 	ldw	ra,4(sp)
8110bb14:	df000017 	ldw	fp,0(sp)
8110bb18:	dec00204 	addi	sp,sp,8
8110bb1c:	f800283a 	ret

8110bb20 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110bb20:	defffe04 	addi	sp,sp,-8
8110bb24:	de00012e 	bgeu	sp,et,8110bb2c <vSyncIrqFlagClrSync+0xc>
8110bb28:	003b68fa 	trap	3
8110bb2c:	dfc00115 	stw	ra,4(sp)
8110bb30:	df000015 	stw	fp,0(sp)
8110bb34:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110bb38:	01400044 	movi	r5,1
8110bb3c:	010002c4 	movi	r4,11
8110bb40:	110c9000 	call	8110c900 <bSyncWriteReg>
}
8110bb44:	0001883a 	nop
8110bb48:	e037883a 	mov	sp,fp
8110bb4c:	dfc00117 	ldw	ra,4(sp)
8110bb50:	df000017 	ldw	fp,0(sp)
8110bb54:	dec00204 	addi	sp,sp,8
8110bb58:	f800283a 	ret

8110bb5c <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110bb5c:	defffd04 	addi	sp,sp,-12
8110bb60:	de00012e 	bgeu	sp,et,8110bb68 <bSyncIrqFlagSync+0xc>
8110bb64:	003b68fa 	trap	3
8110bb68:	dfc00215 	stw	ra,8(sp)
8110bb6c:	df000115 	stw	fp,4(sp)
8110bb70:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110bb74:	01000304 	movi	r4,12
8110bb78:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bb7c:	1080004c 	andi	r2,r2,1
8110bb80:	10000326 	beq	r2,zero,8110bb90 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110bb84:	00800044 	movi	r2,1
8110bb88:	e0bfff15 	stw	r2,-4(fp)
8110bb8c:	00000106 	br	8110bb94 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110bb90:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110bb94:	e0bfff17 	ldw	r2,-4(fp)
}
8110bb98:	e037883a 	mov	sp,fp
8110bb9c:	dfc00117 	ldw	ra,4(sp)
8110bba0:	df000017 	ldw	fp,0(sp)
8110bba4:	dec00204 	addi	sp,sp,8
8110bba8:	f800283a 	ret

8110bbac <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110bbac:	defffc04 	addi	sp,sp,-16
8110bbb0:	de00012e 	bgeu	sp,et,8110bbb8 <bSyncStatusExtnIrq+0xc>
8110bbb4:	003b68fa 	trap	3
8110bbb8:	dfc00315 	stw	ra,12(sp)
8110bbbc:	df000215 	stw	fp,8(sp)
8110bbc0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bbc4:	0009883a 	mov	r4,zero
8110bbc8:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bbcc:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110bbd0:	e0bfff17 	ldw	r2,-4(fp)
8110bbd4:	1000030e 	bge	r2,zero,8110bbe4 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110bbd8:	00800044 	movi	r2,1
8110bbdc:	e0bffe15 	stw	r2,-8(fp)
8110bbe0:	00000106 	br	8110bbe8 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110bbe4:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110bbe8:	e0bffe17 	ldw	r2,-8(fp)
}
8110bbec:	e037883a 	mov	sp,fp
8110bbf0:	dfc00117 	ldw	ra,4(sp)
8110bbf4:	df000017 	ldw	fp,0(sp)
8110bbf8:	dec00204 	addi	sp,sp,8
8110bbfc:	f800283a 	ret

8110bc00 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110bc00:	defffc04 	addi	sp,sp,-16
8110bc04:	de00012e 	bgeu	sp,et,8110bc0c <ucSyncStatusState+0xc>
8110bc08:	003b68fa 	trap	3
8110bc0c:	dfc00315 	stw	ra,12(sp)
8110bc10:	df000215 	stw	fp,8(sp)
8110bc14:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bc18:	0009883a 	mov	r4,zero
8110bc1c:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bc20:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110bc24:	e0bffe17 	ldw	r2,-8(fp)
8110bc28:	10803fec 	andhi	r2,r2,255
8110bc2c:	1004d43a 	srli	r2,r2,16
8110bc30:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110bc34:	e0bfff03 	ldbu	r2,-4(fp)
}
8110bc38:	e037883a 	mov	sp,fp
8110bc3c:	dfc00117 	ldw	ra,4(sp)
8110bc40:	df000017 	ldw	fp,0(sp)
8110bc44:	dec00204 	addi	sp,sp,8
8110bc48:	f800283a 	ret

8110bc4c <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110bc4c:	defffc04 	addi	sp,sp,-16
8110bc50:	de00012e 	bgeu	sp,et,8110bc58 <ucSyncStatusErrorCode+0xc>
8110bc54:	003b68fa 	trap	3
8110bc58:	dfc00315 	stw	ra,12(sp)
8110bc5c:	df000215 	stw	fp,8(sp)
8110bc60:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bc64:	0009883a 	mov	r4,zero
8110bc68:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bc6c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110bc70:	e0bffe17 	ldw	r2,-8(fp)
8110bc74:	10bfc00c 	andi	r2,r2,65280
8110bc78:	1004d23a 	srli	r2,r2,8
8110bc7c:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110bc80:	e0bfff03 	ldbu	r2,-4(fp)
}
8110bc84:	e037883a 	mov	sp,fp
8110bc88:	dfc00117 	ldw	ra,4(sp)
8110bc8c:	df000017 	ldw	fp,0(sp)
8110bc90:	dec00204 	addi	sp,sp,8
8110bc94:	f800283a 	ret

8110bc98 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110bc98:	defffc04 	addi	sp,sp,-16
8110bc9c:	de00012e 	bgeu	sp,et,8110bca4 <ucSyncStatusCycleNumber+0xc>
8110bca0:	003b68fa 	trap	3
8110bca4:	dfc00315 	stw	ra,12(sp)
8110bca8:	df000215 	stw	fp,8(sp)
8110bcac:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bcb0:	0009883a 	mov	r4,zero
8110bcb4:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bcb8:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110bcbc:	e0bffe17 	ldw	r2,-8(fp)
8110bcc0:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110bcc4:	e0bfff03 	ldbu	r2,-4(fp)
}
8110bcc8:	e037883a 	mov	sp,fp
8110bccc:	dfc00117 	ldw	ra,4(sp)
8110bcd0:	df000017 	ldw	fp,0(sp)
8110bcd4:	dec00204 	addi	sp,sp,8
8110bcd8:	f800283a 	ret

8110bcdc <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110bcdc:	defffd04 	addi	sp,sp,-12
8110bce0:	de00012e 	bgeu	sp,et,8110bce8 <bSyncSetMbt+0xc>
8110bce4:	003b68fa 	trap	3
8110bce8:	dfc00215 	stw	ra,8(sp)
8110bcec:	df000115 	stw	fp,4(sp)
8110bcf0:	df000104 	addi	fp,sp,4
8110bcf4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110bcf8:	e17fff17 	ldw	r5,-4(fp)
8110bcfc:	01000104 	movi	r4,4
8110bd00:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110bd04:	00800044 	movi	r2,1
}
8110bd08:	e037883a 	mov	sp,fp
8110bd0c:	dfc00117 	ldw	ra,4(sp)
8110bd10:	df000017 	ldw	fp,0(sp)
8110bd14:	dec00204 	addi	sp,sp,8
8110bd18:	f800283a 	ret

8110bd1c <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110bd1c:	defffd04 	addi	sp,sp,-12
8110bd20:	de00012e 	bgeu	sp,et,8110bd28 <bSyncSetBt+0xc>
8110bd24:	003b68fa 	trap	3
8110bd28:	dfc00215 	stw	ra,8(sp)
8110bd2c:	df000115 	stw	fp,4(sp)
8110bd30:	df000104 	addi	fp,sp,4
8110bd34:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110bd38:	e17fff17 	ldw	r5,-4(fp)
8110bd3c:	01000144 	movi	r4,5
8110bd40:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110bd44:	00800044 	movi	r2,1
}
8110bd48:	e037883a 	mov	sp,fp
8110bd4c:	dfc00117 	ldw	ra,4(sp)
8110bd50:	df000017 	ldw	fp,0(sp)
8110bd54:	dec00204 	addi	sp,sp,8
8110bd58:	f800283a 	ret

8110bd5c <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110bd5c:	defffd04 	addi	sp,sp,-12
8110bd60:	de00012e 	bgeu	sp,et,8110bd68 <bSyncSetPer+0xc>
8110bd64:	003b68fa 	trap	3
8110bd68:	dfc00215 	stw	ra,8(sp)
8110bd6c:	df000115 	stw	fp,4(sp)
8110bd70:	df000104 	addi	fp,sp,4
8110bd74:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110bd78:	e17fff17 	ldw	r5,-4(fp)
8110bd7c:	01000184 	movi	r4,6
8110bd80:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110bd84:	00800044 	movi	r2,1
}
8110bd88:	e037883a 	mov	sp,fp
8110bd8c:	dfc00117 	ldw	ra,4(sp)
8110bd90:	df000017 	ldw	fp,0(sp)
8110bd94:	dec00204 	addi	sp,sp,8
8110bd98:	f800283a 	ret

8110bd9c <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110bd9c:	defffd04 	addi	sp,sp,-12
8110bda0:	de00012e 	bgeu	sp,et,8110bda8 <bSyncSetOst+0xc>
8110bda4:	003b68fa 	trap	3
8110bda8:	dfc00215 	stw	ra,8(sp)
8110bdac:	df000115 	stw	fp,4(sp)
8110bdb0:	df000104 	addi	fp,sp,4
8110bdb4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110bdb8:	e17fff17 	ldw	r5,-4(fp)
8110bdbc:	010001c4 	movi	r4,7
8110bdc0:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110bdc4:	00800044 	movi	r2,1
}
8110bdc8:	e037883a 	mov	sp,fp
8110bdcc:	dfc00117 	ldw	ra,4(sp)
8110bdd0:	df000017 	ldw	fp,0(sp)
8110bdd4:	dec00204 	addi	sp,sp,8
8110bdd8:	f800283a 	ret

8110bddc <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110bddc:	defffc04 	addi	sp,sp,-16
8110bde0:	de00012e 	bgeu	sp,et,8110bde8 <bSyncSetPolarity+0xc>
8110bde4:	003b68fa 	trap	3
8110bde8:	dfc00315 	stw	ra,12(sp)
8110bdec:	df000215 	stw	fp,8(sp)
8110bdf0:	df000204 	addi	fp,sp,8
8110bdf4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110bdf8:	01000204 	movi	r4,8
8110bdfc:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110be00:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110be04:	e0bfff17 	ldw	r2,-4(fp)
8110be08:	1000051e 	bne	r2,zero,8110be20 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110be0c:	e0fffe17 	ldw	r3,-8(fp)
8110be10:	00bfbfc4 	movi	r2,-257
8110be14:	1884703a 	and	r2,r3,r2
8110be18:	e0bffe15 	stw	r2,-8(fp)
8110be1c:	00000306 	br	8110be2c <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110be20:	e0bffe17 	ldw	r2,-8(fp)
8110be24:	10804014 	ori	r2,r2,256
8110be28:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110be2c:	e17ffe17 	ldw	r5,-8(fp)
8110be30:	01000204 	movi	r4,8
8110be34:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110be38:	00800044 	movi	r2,1
}
8110be3c:	e037883a 	mov	sp,fp
8110be40:	dfc00117 	ldw	ra,4(sp)
8110be44:	df000017 	ldw	fp,0(sp)
8110be48:	dec00204 	addi	sp,sp,8
8110be4c:	f800283a 	ret

8110be50 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110be50:	defffc04 	addi	sp,sp,-16
8110be54:	de00012e 	bgeu	sp,et,8110be5c <bSyncSetNCycles+0xc>
8110be58:	003b68fa 	trap	3
8110be5c:	dfc00315 	stw	ra,12(sp)
8110be60:	df000215 	stw	fp,8(sp)
8110be64:	df000204 	addi	fp,sp,8
8110be68:	2005883a 	mov	r2,r4
8110be6c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110be70:	01000204 	movi	r4,8
8110be74:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110be78:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110be7c:	e0fffe17 	ldw	r3,-8(fp)
8110be80:	00bfc004 	movi	r2,-256
8110be84:	1884703a 	and	r2,r3,r2
8110be88:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110be8c:	e0bfff03 	ldbu	r2,-4(fp)
8110be90:	e0fffe17 	ldw	r3,-8(fp)
8110be94:	1884b03a 	or	r2,r3,r2
8110be98:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110be9c:	e17ffe17 	ldw	r5,-8(fp)
8110bea0:	01000204 	movi	r4,8
8110bea4:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110bea8:	00800044 	movi	r2,1
}
8110beac:	e037883a 	mov	sp,fp
8110beb0:	dfc00117 	ldw	ra,4(sp)
8110beb4:	df000017 	ldw	fp,0(sp)
8110beb8:	dec00204 	addi	sp,sp,8
8110bebc:	f800283a 	ret

8110bec0 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110bec0:	defffd04 	addi	sp,sp,-12
8110bec4:	de00012e 	bgeu	sp,et,8110becc <uliSyncGetMbt+0xc>
8110bec8:	003b68fa 	trap	3
8110becc:	dfc00215 	stw	ra,8(sp)
8110bed0:	df000115 	stw	fp,4(sp)
8110bed4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110bed8:	01000104 	movi	r4,4
8110bedc:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bee0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bee4:	e0bfff17 	ldw	r2,-4(fp)
}
8110bee8:	e037883a 	mov	sp,fp
8110beec:	dfc00117 	ldw	ra,4(sp)
8110bef0:	df000017 	ldw	fp,0(sp)
8110bef4:	dec00204 	addi	sp,sp,8
8110bef8:	f800283a 	ret

8110befc <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110befc:	defffd04 	addi	sp,sp,-12
8110bf00:	de00012e 	bgeu	sp,et,8110bf08 <uliSyncGetBt+0xc>
8110bf04:	003b68fa 	trap	3
8110bf08:	dfc00215 	stw	ra,8(sp)
8110bf0c:	df000115 	stw	fp,4(sp)
8110bf10:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110bf14:	01000144 	movi	r4,5
8110bf18:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bf1c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bf20:	e0bfff17 	ldw	r2,-4(fp)
}
8110bf24:	e037883a 	mov	sp,fp
8110bf28:	dfc00117 	ldw	ra,4(sp)
8110bf2c:	df000017 	ldw	fp,0(sp)
8110bf30:	dec00204 	addi	sp,sp,8
8110bf34:	f800283a 	ret

8110bf38 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110bf38:	defffd04 	addi	sp,sp,-12
8110bf3c:	de00012e 	bgeu	sp,et,8110bf44 <uliSyncGetPer+0xc>
8110bf40:	003b68fa 	trap	3
8110bf44:	dfc00215 	stw	ra,8(sp)
8110bf48:	df000115 	stw	fp,4(sp)
8110bf4c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110bf50:	01000184 	movi	r4,6
8110bf54:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bf58:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bf5c:	e0bfff17 	ldw	r2,-4(fp)
}
8110bf60:	e037883a 	mov	sp,fp
8110bf64:	dfc00117 	ldw	ra,4(sp)
8110bf68:	df000017 	ldw	fp,0(sp)
8110bf6c:	dec00204 	addi	sp,sp,8
8110bf70:	f800283a 	ret

8110bf74 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110bf74:	defffd04 	addi	sp,sp,-12
8110bf78:	de00012e 	bgeu	sp,et,8110bf80 <uliSyncGetOst+0xc>
8110bf7c:	003b68fa 	trap	3
8110bf80:	dfc00215 	stw	ra,8(sp)
8110bf84:	df000115 	stw	fp,4(sp)
8110bf88:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110bf8c:	010001c4 	movi	r4,7
8110bf90:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bf94:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bf98:	e0bfff17 	ldw	r2,-4(fp)
}
8110bf9c:	e037883a 	mov	sp,fp
8110bfa0:	dfc00117 	ldw	ra,4(sp)
8110bfa4:	df000017 	ldw	fp,0(sp)
8110bfa8:	dec00204 	addi	sp,sp,8
8110bfac:	f800283a 	ret

8110bfb0 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110bfb0:	defffd04 	addi	sp,sp,-12
8110bfb4:	de00012e 	bgeu	sp,et,8110bfbc <uliSyncGetGeneral+0xc>
8110bfb8:	003b68fa 	trap	3
8110bfbc:	dfc00215 	stw	ra,8(sp)
8110bfc0:	df000115 	stw	fp,4(sp)
8110bfc4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110bfc8:	01000204 	movi	r4,8
8110bfcc:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110bfd0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bfd4:	e0bfff17 	ldw	r2,-4(fp)
}
8110bfd8:	e037883a 	mov	sp,fp
8110bfdc:	dfc00117 	ldw	ra,4(sp)
8110bfe0:	df000017 	ldw	fp,0(sp)
8110bfe4:	dec00204 	addi	sp,sp,8
8110bfe8:	f800283a 	ret

8110bfec <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110bfec:	defffd04 	addi	sp,sp,-12
8110bff0:	de00012e 	bgeu	sp,et,8110bff8 <bSyncErrInj+0xc>
8110bff4:	003b68fa 	trap	3
8110bff8:	dfc00215 	stw	ra,8(sp)
8110bffc:	df000115 	stw	fp,4(sp)
8110c000:	df000104 	addi	fp,sp,4
8110c004:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110c008:	e17fff17 	ldw	r5,-4(fp)
8110c00c:	01000244 	movi	r4,9
8110c010:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c014:	00800044 	movi	r2,1
}
8110c018:	e037883a 	mov	sp,fp
8110c01c:	dfc00117 	ldw	ra,4(sp)
8110c020:	df000017 	ldw	fp,0(sp)
8110c024:	dec00204 	addi	sp,sp,8
8110c028:	f800283a 	ret

8110c02c <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110c02c:	defffc04 	addi	sp,sp,-16
8110c030:	de00012e 	bgeu	sp,et,8110c038 <bSyncCtrExtnIrq+0xc>
8110c034:	003b68fa 	trap	3
8110c038:	dfc00315 	stw	ra,12(sp)
8110c03c:	df000215 	stw	fp,8(sp)
8110c040:	df000204 	addi	fp,sp,8
8110c044:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c048:	01000284 	movi	r4,10
8110c04c:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c050:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c054:	e0bfff17 	ldw	r2,-4(fp)
8110c058:	1000061e 	bne	r2,zero,8110c074 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110c05c:	e0fffe17 	ldw	r3,-8(fp)
8110c060:	00a00034 	movhi	r2,32768
8110c064:	10bfffc4 	addi	r2,r2,-1
8110c068:	1884703a 	and	r2,r3,r2
8110c06c:	e0bffe15 	stw	r2,-8(fp)
8110c070:	00000306 	br	8110c080 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110c074:	e0bffe17 	ldw	r2,-8(fp)
8110c078:	10a00034 	orhi	r2,r2,32768
8110c07c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c080:	e17ffe17 	ldw	r5,-8(fp)
8110c084:	01000284 	movi	r4,10
8110c088:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c08c:	00800044 	movi	r2,1
}
8110c090:	e037883a 	mov	sp,fp
8110c094:	dfc00117 	ldw	ra,4(sp)
8110c098:	df000017 	ldw	fp,0(sp)
8110c09c:	dec00204 	addi	sp,sp,8
8110c0a0:	f800283a 	ret

8110c0a4 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110c0a4:	defffd04 	addi	sp,sp,-12
8110c0a8:	de00012e 	bgeu	sp,et,8110c0b0 <bSyncCtrStart+0xc>
8110c0ac:	003b68fa 	trap	3
8110c0b0:	dfc00215 	stw	ra,8(sp)
8110c0b4:	df000115 	stw	fp,4(sp)
8110c0b8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c0bc:	01000284 	movi	r4,10
8110c0c0:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c0c4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110c0c8:	e0bfff17 	ldw	r2,-4(fp)
8110c0cc:	10800234 	orhi	r2,r2,8
8110c0d0:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c0d4:	e17fff17 	ldw	r5,-4(fp)
8110c0d8:	01000284 	movi	r4,10
8110c0dc:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c0e0:	00800044 	movi	r2,1
}
8110c0e4:	e037883a 	mov	sp,fp
8110c0e8:	dfc00117 	ldw	ra,4(sp)
8110c0ec:	df000017 	ldw	fp,0(sp)
8110c0f0:	dec00204 	addi	sp,sp,8
8110c0f4:	f800283a 	ret

8110c0f8 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110c0f8:	defffd04 	addi	sp,sp,-12
8110c0fc:	de00012e 	bgeu	sp,et,8110c104 <bSyncCtrReset+0xc>
8110c100:	003b68fa 	trap	3
8110c104:	dfc00215 	stw	ra,8(sp)
8110c108:	df000115 	stw	fp,4(sp)
8110c10c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c110:	01000284 	movi	r4,10
8110c114:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c118:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110c11c:	e0bfff17 	ldw	r2,-4(fp)
8110c120:	10800134 	orhi	r2,r2,4
8110c124:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c128:	e17fff17 	ldw	r5,-4(fp)
8110c12c:	01000284 	movi	r4,10
8110c130:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c134:	00800044 	movi	r2,1
}
8110c138:	e037883a 	mov	sp,fp
8110c13c:	dfc00117 	ldw	ra,4(sp)
8110c140:	df000017 	ldw	fp,0(sp)
8110c144:	dec00204 	addi	sp,sp,8
8110c148:	f800283a 	ret

8110c14c <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110c14c:	defffd04 	addi	sp,sp,-12
8110c150:	de00012e 	bgeu	sp,et,8110c158 <bSyncCtrOneShot+0xc>
8110c154:	003b68fa 	trap	3
8110c158:	dfc00215 	stw	ra,8(sp)
8110c15c:	df000115 	stw	fp,4(sp)
8110c160:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c164:	01000284 	movi	r4,10
8110c168:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c16c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110c170:	e0bfff17 	ldw	r2,-4(fp)
8110c174:	108000b4 	orhi	r2,r2,2
8110c178:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c17c:	e17fff17 	ldw	r5,-4(fp)
8110c180:	01000284 	movi	r4,10
8110c184:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c188:	00800044 	movi	r2,1
}
8110c18c:	e037883a 	mov	sp,fp
8110c190:	dfc00117 	ldw	ra,4(sp)
8110c194:	df000017 	ldw	fp,0(sp)
8110c198:	dec00204 	addi	sp,sp,8
8110c19c:	f800283a 	ret

8110c1a0 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110c1a0:	defffd04 	addi	sp,sp,-12
8110c1a4:	de00012e 	bgeu	sp,et,8110c1ac <bSyncCtrErrInj+0xc>
8110c1a8:	003b68fa 	trap	3
8110c1ac:	dfc00215 	stw	ra,8(sp)
8110c1b0:	df000115 	stw	fp,4(sp)
8110c1b4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c1b8:	01000284 	movi	r4,10
8110c1bc:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c1c0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110c1c4:	e0bfff17 	ldw	r2,-4(fp)
8110c1c8:	10800074 	orhi	r2,r2,1
8110c1cc:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c1d0:	e17fff17 	ldw	r5,-4(fp)
8110c1d4:	01000284 	movi	r4,10
8110c1d8:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c1dc:	00800044 	movi	r2,1
}
8110c1e0:	e037883a 	mov	sp,fp
8110c1e4:	dfc00117 	ldw	ra,4(sp)
8110c1e8:	df000017 	ldw	fp,0(sp)
8110c1ec:	dec00204 	addi	sp,sp,8
8110c1f0:	f800283a 	ret

8110c1f4 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110c1f4:	defffc04 	addi	sp,sp,-16
8110c1f8:	de00012e 	bgeu	sp,et,8110c200 <bSyncCtrSyncOutEnable+0xc>
8110c1fc:	003b68fa 	trap	3
8110c200:	dfc00315 	stw	ra,12(sp)
8110c204:	df000215 	stw	fp,8(sp)
8110c208:	df000204 	addi	fp,sp,8
8110c20c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c210:	01000284 	movi	r4,10
8110c214:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c218:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c21c:	e0bfff17 	ldw	r2,-4(fp)
8110c220:	1000051e 	bne	r2,zero,8110c238 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110c224:	e0fffe17 	ldw	r3,-8(fp)
8110c228:	00bfbfc4 	movi	r2,-257
8110c22c:	1884703a 	and	r2,r3,r2
8110c230:	e0bffe15 	stw	r2,-8(fp)
8110c234:	00000306 	br	8110c244 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110c238:	e0bffe17 	ldw	r2,-8(fp)
8110c23c:	10804014 	ori	r2,r2,256
8110c240:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c244:	e17ffe17 	ldw	r5,-8(fp)
8110c248:	01000284 	movi	r4,10
8110c24c:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c250:	00800044 	movi	r2,1
}
8110c254:	e037883a 	mov	sp,fp
8110c258:	dfc00117 	ldw	ra,4(sp)
8110c25c:	df000017 	ldw	fp,0(sp)
8110c260:	dec00204 	addi	sp,sp,8
8110c264:	f800283a 	ret

8110c268 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110c268:	defffc04 	addi	sp,sp,-16
8110c26c:	de00012e 	bgeu	sp,et,8110c274 <bSyncCtrCh1OutEnable+0xc>
8110c270:	003b68fa 	trap	3
8110c274:	dfc00315 	stw	ra,12(sp)
8110c278:	df000215 	stw	fp,8(sp)
8110c27c:	df000204 	addi	fp,sp,8
8110c280:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c284:	01000284 	movi	r4,10
8110c288:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c28c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c290:	e0bfff17 	ldw	r2,-4(fp)
8110c294:	1000051e 	bne	r2,zero,8110c2ac <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110c298:	e0fffe17 	ldw	r3,-8(fp)
8110c29c:	00bfff84 	movi	r2,-2
8110c2a0:	1884703a 	and	r2,r3,r2
8110c2a4:	e0bffe15 	stw	r2,-8(fp)
8110c2a8:	00000306 	br	8110c2b8 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110c2ac:	e0bffe17 	ldw	r2,-8(fp)
8110c2b0:	10800054 	ori	r2,r2,1
8110c2b4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c2b8:	e17ffe17 	ldw	r5,-8(fp)
8110c2bc:	01000284 	movi	r4,10
8110c2c0:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c2c4:	00800044 	movi	r2,1
}
8110c2c8:	e037883a 	mov	sp,fp
8110c2cc:	dfc00117 	ldw	ra,4(sp)
8110c2d0:	df000017 	ldw	fp,0(sp)
8110c2d4:	dec00204 	addi	sp,sp,8
8110c2d8:	f800283a 	ret

8110c2dc <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110c2dc:	defffc04 	addi	sp,sp,-16
8110c2e0:	de00012e 	bgeu	sp,et,8110c2e8 <bSyncCtrCh2OutEnable+0xc>
8110c2e4:	003b68fa 	trap	3
8110c2e8:	dfc00315 	stw	ra,12(sp)
8110c2ec:	df000215 	stw	fp,8(sp)
8110c2f0:	df000204 	addi	fp,sp,8
8110c2f4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c2f8:	01000284 	movi	r4,10
8110c2fc:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c300:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c304:	e0bfff17 	ldw	r2,-4(fp)
8110c308:	1000051e 	bne	r2,zero,8110c320 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110c30c:	e0fffe17 	ldw	r3,-8(fp)
8110c310:	00bfff44 	movi	r2,-3
8110c314:	1884703a 	and	r2,r3,r2
8110c318:	e0bffe15 	stw	r2,-8(fp)
8110c31c:	00000306 	br	8110c32c <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110c320:	e0bffe17 	ldw	r2,-8(fp)
8110c324:	10800094 	ori	r2,r2,2
8110c328:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c32c:	e17ffe17 	ldw	r5,-8(fp)
8110c330:	01000284 	movi	r4,10
8110c334:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c338:	00800044 	movi	r2,1
}
8110c33c:	e037883a 	mov	sp,fp
8110c340:	dfc00117 	ldw	ra,4(sp)
8110c344:	df000017 	ldw	fp,0(sp)
8110c348:	dec00204 	addi	sp,sp,8
8110c34c:	f800283a 	ret

8110c350 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110c350:	defffc04 	addi	sp,sp,-16
8110c354:	de00012e 	bgeu	sp,et,8110c35c <bSyncCtrCh3OutEnable+0xc>
8110c358:	003b68fa 	trap	3
8110c35c:	dfc00315 	stw	ra,12(sp)
8110c360:	df000215 	stw	fp,8(sp)
8110c364:	df000204 	addi	fp,sp,8
8110c368:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c36c:	01000284 	movi	r4,10
8110c370:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c374:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c378:	e0bfff17 	ldw	r2,-4(fp)
8110c37c:	1000051e 	bne	r2,zero,8110c394 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110c380:	e0fffe17 	ldw	r3,-8(fp)
8110c384:	00bffec4 	movi	r2,-5
8110c388:	1884703a 	and	r2,r3,r2
8110c38c:	e0bffe15 	stw	r2,-8(fp)
8110c390:	00000306 	br	8110c3a0 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110c394:	e0bffe17 	ldw	r2,-8(fp)
8110c398:	10800114 	ori	r2,r2,4
8110c39c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c3a0:	e17ffe17 	ldw	r5,-8(fp)
8110c3a4:	01000284 	movi	r4,10
8110c3a8:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c3ac:	00800044 	movi	r2,1
}
8110c3b0:	e037883a 	mov	sp,fp
8110c3b4:	dfc00117 	ldw	ra,4(sp)
8110c3b8:	df000017 	ldw	fp,0(sp)
8110c3bc:	dec00204 	addi	sp,sp,8
8110c3c0:	f800283a 	ret

8110c3c4 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110c3c4:	defffc04 	addi	sp,sp,-16
8110c3c8:	de00012e 	bgeu	sp,et,8110c3d0 <bSyncCtrCh4OutEnable+0xc>
8110c3cc:	003b68fa 	trap	3
8110c3d0:	dfc00315 	stw	ra,12(sp)
8110c3d4:	df000215 	stw	fp,8(sp)
8110c3d8:	df000204 	addi	fp,sp,8
8110c3dc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c3e0:	01000284 	movi	r4,10
8110c3e4:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c3e8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c3ec:	e0bfff17 	ldw	r2,-4(fp)
8110c3f0:	1000051e 	bne	r2,zero,8110c408 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110c3f4:	e0fffe17 	ldw	r3,-8(fp)
8110c3f8:	00bffdc4 	movi	r2,-9
8110c3fc:	1884703a 	and	r2,r3,r2
8110c400:	e0bffe15 	stw	r2,-8(fp)
8110c404:	00000306 	br	8110c414 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110c408:	e0bffe17 	ldw	r2,-8(fp)
8110c40c:	10800214 	ori	r2,r2,8
8110c410:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c414:	e17ffe17 	ldw	r5,-8(fp)
8110c418:	01000284 	movi	r4,10
8110c41c:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c420:	00800044 	movi	r2,1
}
8110c424:	e037883a 	mov	sp,fp
8110c428:	dfc00117 	ldw	ra,4(sp)
8110c42c:	df000017 	ldw	fp,0(sp)
8110c430:	dec00204 	addi	sp,sp,8
8110c434:	f800283a 	ret

8110c438 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110c438:	defffc04 	addi	sp,sp,-16
8110c43c:	de00012e 	bgeu	sp,et,8110c444 <bSyncCtrCh5OutEnable+0xc>
8110c440:	003b68fa 	trap	3
8110c444:	dfc00315 	stw	ra,12(sp)
8110c448:	df000215 	stw	fp,8(sp)
8110c44c:	df000204 	addi	fp,sp,8
8110c450:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c454:	01000284 	movi	r4,10
8110c458:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c45c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c460:	e0bfff17 	ldw	r2,-4(fp)
8110c464:	1000051e 	bne	r2,zero,8110c47c <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110c468:	e0fffe17 	ldw	r3,-8(fp)
8110c46c:	00bffbc4 	movi	r2,-17
8110c470:	1884703a 	and	r2,r3,r2
8110c474:	e0bffe15 	stw	r2,-8(fp)
8110c478:	00000306 	br	8110c488 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110c47c:	e0bffe17 	ldw	r2,-8(fp)
8110c480:	10800414 	ori	r2,r2,16
8110c484:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c488:	e17ffe17 	ldw	r5,-8(fp)
8110c48c:	01000284 	movi	r4,10
8110c490:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c494:	00800044 	movi	r2,1
}
8110c498:	e037883a 	mov	sp,fp
8110c49c:	dfc00117 	ldw	ra,4(sp)
8110c4a0:	df000017 	ldw	fp,0(sp)
8110c4a4:	dec00204 	addi	sp,sp,8
8110c4a8:	f800283a 	ret

8110c4ac <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110c4ac:	defffc04 	addi	sp,sp,-16
8110c4b0:	de00012e 	bgeu	sp,et,8110c4b8 <bSyncCtrCh6OutEnable+0xc>
8110c4b4:	003b68fa 	trap	3
8110c4b8:	dfc00315 	stw	ra,12(sp)
8110c4bc:	df000215 	stw	fp,8(sp)
8110c4c0:	df000204 	addi	fp,sp,8
8110c4c4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c4c8:	01000284 	movi	r4,10
8110c4cc:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c4d0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c4d4:	e0bfff17 	ldw	r2,-4(fp)
8110c4d8:	1000051e 	bne	r2,zero,8110c4f0 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110c4dc:	e0fffe17 	ldw	r3,-8(fp)
8110c4e0:	00bff7c4 	movi	r2,-33
8110c4e4:	1884703a 	and	r2,r3,r2
8110c4e8:	e0bffe15 	stw	r2,-8(fp)
8110c4ec:	00000306 	br	8110c4fc <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110c4f0:	e0bffe17 	ldw	r2,-8(fp)
8110c4f4:	10800814 	ori	r2,r2,32
8110c4f8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c4fc:	e17ffe17 	ldw	r5,-8(fp)
8110c500:	01000284 	movi	r4,10
8110c504:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c508:	00800044 	movi	r2,1
}
8110c50c:	e037883a 	mov	sp,fp
8110c510:	dfc00117 	ldw	ra,4(sp)
8110c514:	df000017 	ldw	fp,0(sp)
8110c518:	dec00204 	addi	sp,sp,8
8110c51c:	f800283a 	ret

8110c520 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110c520:	defffc04 	addi	sp,sp,-16
8110c524:	de00012e 	bgeu	sp,et,8110c52c <bSyncCtrCh7OutEnable+0xc>
8110c528:	003b68fa 	trap	3
8110c52c:	dfc00315 	stw	ra,12(sp)
8110c530:	df000215 	stw	fp,8(sp)
8110c534:	df000204 	addi	fp,sp,8
8110c538:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c53c:	01000284 	movi	r4,10
8110c540:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c544:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c548:	e0bfff17 	ldw	r2,-4(fp)
8110c54c:	1000051e 	bne	r2,zero,8110c564 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110c550:	e0fffe17 	ldw	r3,-8(fp)
8110c554:	00bfefc4 	movi	r2,-65
8110c558:	1884703a 	and	r2,r3,r2
8110c55c:	e0bffe15 	stw	r2,-8(fp)
8110c560:	00000306 	br	8110c570 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110c564:	e0bffe17 	ldw	r2,-8(fp)
8110c568:	10801014 	ori	r2,r2,64
8110c56c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c570:	e17ffe17 	ldw	r5,-8(fp)
8110c574:	01000284 	movi	r4,10
8110c578:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c57c:	00800044 	movi	r2,1
}
8110c580:	e037883a 	mov	sp,fp
8110c584:	dfc00117 	ldw	ra,4(sp)
8110c588:	df000017 	ldw	fp,0(sp)
8110c58c:	dec00204 	addi	sp,sp,8
8110c590:	f800283a 	ret

8110c594 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110c594:	defffc04 	addi	sp,sp,-16
8110c598:	de00012e 	bgeu	sp,et,8110c5a0 <bSyncCtrCh8OutEnable+0xc>
8110c59c:	003b68fa 	trap	3
8110c5a0:	dfc00315 	stw	ra,12(sp)
8110c5a4:	df000215 	stw	fp,8(sp)
8110c5a8:	df000204 	addi	fp,sp,8
8110c5ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c5b0:	01000284 	movi	r4,10
8110c5b4:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c5b8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c5bc:	e0bfff17 	ldw	r2,-4(fp)
8110c5c0:	1000051e 	bne	r2,zero,8110c5d8 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110c5c4:	e0fffe17 	ldw	r3,-8(fp)
8110c5c8:	00bfdfc4 	movi	r2,-129
8110c5cc:	1884703a 	and	r2,r3,r2
8110c5d0:	e0bffe15 	stw	r2,-8(fp)
8110c5d4:	00000306 	br	8110c5e4 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110c5d8:	e0bffe17 	ldw	r2,-8(fp)
8110c5dc:	10802014 	ori	r2,r2,128
8110c5e0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c5e4:	e17ffe17 	ldw	r5,-8(fp)
8110c5e8:	01000284 	movi	r4,10
8110c5ec:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c5f0:	00800044 	movi	r2,1
}
8110c5f4:	e037883a 	mov	sp,fp
8110c5f8:	dfc00117 	ldw	ra,4(sp)
8110c5fc:	df000017 	ldw	fp,0(sp)
8110c600:	dec00204 	addi	sp,sp,8
8110c604:	f800283a 	ret

8110c608 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110c608:	defffc04 	addi	sp,sp,-16
8110c60c:	de00012e 	bgeu	sp,et,8110c614 <bSyncIrqEnableError+0xc>
8110c610:	003b68fa 	trap	3
8110c614:	dfc00315 	stw	ra,12(sp)
8110c618:	df000215 	stw	fp,8(sp)
8110c61c:	df000204 	addi	fp,sp,8
8110c620:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c624:	01000044 	movi	r4,1
8110c628:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c62c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c630:	e0bfff17 	ldw	r2,-4(fp)
8110c634:	1000051e 	bne	r2,zero,8110c64c <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110c638:	e0fffe17 	ldw	r3,-8(fp)
8110c63c:	00bfff44 	movi	r2,-3
8110c640:	1884703a 	and	r2,r3,r2
8110c644:	e0bffe15 	stw	r2,-8(fp)
8110c648:	00000306 	br	8110c658 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110c64c:	e0bffe17 	ldw	r2,-8(fp)
8110c650:	10800094 	ori	r2,r2,2
8110c654:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c658:	e17ffe17 	ldw	r5,-8(fp)
8110c65c:	01000044 	movi	r4,1
8110c660:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c664:	00800044 	movi	r2,1
}
8110c668:	e037883a 	mov	sp,fp
8110c66c:	dfc00117 	ldw	ra,4(sp)
8110c670:	df000017 	ldw	fp,0(sp)
8110c674:	dec00204 	addi	sp,sp,8
8110c678:	f800283a 	ret

8110c67c <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110c67c:	defffc04 	addi	sp,sp,-16
8110c680:	de00012e 	bgeu	sp,et,8110c688 <bSyncIrqEnableBlank+0xc>
8110c684:	003b68fa 	trap	3
8110c688:	dfc00315 	stw	ra,12(sp)
8110c68c:	df000215 	stw	fp,8(sp)
8110c690:	df000204 	addi	fp,sp,8
8110c694:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c698:	01000044 	movi	r4,1
8110c69c:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c6a0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c6a4:	e0bfff17 	ldw	r2,-4(fp)
8110c6a8:	1000051e 	bne	r2,zero,8110c6c0 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110c6ac:	e0fffe17 	ldw	r3,-8(fp)
8110c6b0:	00bfff84 	movi	r2,-2
8110c6b4:	1884703a 	and	r2,r3,r2
8110c6b8:	e0bffe15 	stw	r2,-8(fp)
8110c6bc:	00000306 	br	8110c6cc <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110c6c0:	e0bffe17 	ldw	r2,-8(fp)
8110c6c4:	10800054 	ori	r2,r2,1
8110c6c8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c6cc:	e17ffe17 	ldw	r5,-8(fp)
8110c6d0:	01000044 	movi	r4,1
8110c6d4:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c6d8:	00800044 	movi	r2,1
}
8110c6dc:	e037883a 	mov	sp,fp
8110c6e0:	dfc00117 	ldw	ra,4(sp)
8110c6e4:	df000017 	ldw	fp,0(sp)
8110c6e8:	dec00204 	addi	sp,sp,8
8110c6ec:	f800283a 	ret

8110c6f0 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110c6f0:	defffc04 	addi	sp,sp,-16
8110c6f4:	de00012e 	bgeu	sp,et,8110c6fc <bSyncIrqFlagClrError+0xc>
8110c6f8:	003b68fa 	trap	3
8110c6fc:	dfc00315 	stw	ra,12(sp)
8110c700:	df000215 	stw	fp,8(sp)
8110c704:	df000204 	addi	fp,sp,8
8110c708:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c70c:	01000084 	movi	r4,2
8110c710:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c714:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c718:	e0bfff17 	ldw	r2,-4(fp)
8110c71c:	1000051e 	bne	r2,zero,8110c734 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c720:	e0fffe17 	ldw	r3,-8(fp)
8110c724:	00bfff44 	movi	r2,-3
8110c728:	1884703a 	and	r2,r3,r2
8110c72c:	e0bffe15 	stw	r2,-8(fp)
8110c730:	00000306 	br	8110c740 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c734:	e0bffe17 	ldw	r2,-8(fp)
8110c738:	10800094 	ori	r2,r2,2
8110c73c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c740:	e17ffe17 	ldw	r5,-8(fp)
8110c744:	01000084 	movi	r4,2
8110c748:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c74c:	00800044 	movi	r2,1
}
8110c750:	e037883a 	mov	sp,fp
8110c754:	dfc00117 	ldw	ra,4(sp)
8110c758:	df000017 	ldw	fp,0(sp)
8110c75c:	dec00204 	addi	sp,sp,8
8110c760:	f800283a 	ret

8110c764 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110c764:	defffc04 	addi	sp,sp,-16
8110c768:	de00012e 	bgeu	sp,et,8110c770 <bSyncIrqFlagClrBlank+0xc>
8110c76c:	003b68fa 	trap	3
8110c770:	dfc00315 	stw	ra,12(sp)
8110c774:	df000215 	stw	fp,8(sp)
8110c778:	df000204 	addi	fp,sp,8
8110c77c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c780:	01000084 	movi	r4,2
8110c784:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c788:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c78c:	e0bfff17 	ldw	r2,-4(fp)
8110c790:	1000051e 	bne	r2,zero,8110c7a8 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c794:	e0fffe17 	ldw	r3,-8(fp)
8110c798:	00bfff84 	movi	r2,-2
8110c79c:	1884703a 	and	r2,r3,r2
8110c7a0:	e0bffe15 	stw	r2,-8(fp)
8110c7a4:	00000306 	br	8110c7b4 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c7a8:	e0bffe17 	ldw	r2,-8(fp)
8110c7ac:	10800054 	ori	r2,r2,1
8110c7b0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c7b4:	e17ffe17 	ldw	r5,-8(fp)
8110c7b8:	01000084 	movi	r4,2
8110c7bc:	110c9000 	call	8110c900 <bSyncWriteReg>
	return TRUE;
8110c7c0:	00800044 	movi	r2,1
}
8110c7c4:	e037883a 	mov	sp,fp
8110c7c8:	dfc00117 	ldw	ra,4(sp)
8110c7cc:	df000017 	ldw	fp,0(sp)
8110c7d0:	dec00204 	addi	sp,sp,8
8110c7d4:	f800283a 	ret

8110c7d8 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110c7d8:	defffc04 	addi	sp,sp,-16
8110c7dc:	de00012e 	bgeu	sp,et,8110c7e4 <bSyncIrqFlagError+0xc>
8110c7e0:	003b68fa 	trap	3
8110c7e4:	dfc00315 	stw	ra,12(sp)
8110c7e8:	df000215 	stw	fp,8(sp)
8110c7ec:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c7f0:	010000c4 	movi	r4,3
8110c7f4:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c7f8:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110c7fc:	e0bfff17 	ldw	r2,-4(fp)
8110c800:	1080008c 	andi	r2,r2,2
8110c804:	10000326 	beq	r2,zero,8110c814 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110c808:	00800044 	movi	r2,1
8110c80c:	e0bffe15 	stw	r2,-8(fp)
8110c810:	00000106 	br	8110c818 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110c814:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c818:	e0bffe17 	ldw	r2,-8(fp)
}
8110c81c:	e037883a 	mov	sp,fp
8110c820:	dfc00117 	ldw	ra,4(sp)
8110c824:	df000017 	ldw	fp,0(sp)
8110c828:	dec00204 	addi	sp,sp,8
8110c82c:	f800283a 	ret

8110c830 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110c830:	defffc04 	addi	sp,sp,-16
8110c834:	de00012e 	bgeu	sp,et,8110c83c <bSyncIrqFlagBlank+0xc>
8110c838:	003b68fa 	trap	3
8110c83c:	dfc00315 	stw	ra,12(sp)
8110c840:	df000215 	stw	fp,8(sp)
8110c844:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c848:	010000c4 	movi	r4,3
8110c84c:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c850:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110c854:	e0bfff17 	ldw	r2,-4(fp)
8110c858:	1080004c 	andi	r2,r2,1
8110c85c:	10000326 	beq	r2,zero,8110c86c <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110c860:	00800044 	movi	r2,1
8110c864:	e0bffe15 	stw	r2,-8(fp)
8110c868:	00000106 	br	8110c870 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110c86c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c870:	e0bffe17 	ldw	r2,-8(fp)
}
8110c874:	e037883a 	mov	sp,fp
8110c878:	dfc00117 	ldw	ra,4(sp)
8110c87c:	df000017 	ldw	fp,0(sp)
8110c880:	dec00204 	addi	sp,sp,8
8110c884:	f800283a 	ret

8110c888 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110c888:	defffd04 	addi	sp,sp,-12
8110c88c:	de00012e 	bgeu	sp,et,8110c894 <uliSyncGetCtr+0xc>
8110c890:	003b68fa 	trap	3
8110c894:	dfc00215 	stw	ra,8(sp)
8110c898:	df000115 	stw	fp,4(sp)
8110c89c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c8a0:	01000284 	movi	r4,10
8110c8a4:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c8a8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c8ac:	e0bfff17 	ldw	r2,-4(fp)
}
8110c8b0:	e037883a 	mov	sp,fp
8110c8b4:	dfc00117 	ldw	ra,4(sp)
8110c8b8:	df000017 	ldw	fp,0(sp)
8110c8bc:	dec00204 	addi	sp,sp,8
8110c8c0:	f800283a 	ret

8110c8c4 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110c8c4:	defffd04 	addi	sp,sp,-12
8110c8c8:	de00012e 	bgeu	sp,et,8110c8d0 <uliSyncReadStatus+0xc>
8110c8cc:	003b68fa 	trap	3
8110c8d0:	dfc00215 	stw	ra,8(sp)
8110c8d4:	df000115 	stw	fp,4(sp)
8110c8d8:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c8dc:	0009883a 	mov	r4,zero
8110c8e0:	110c95c0 	call	8110c95c <uliSyncReadReg>
8110c8e4:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110c8e8:	e0bfff17 	ldw	r2,-4(fp)
}
8110c8ec:	e037883a 	mov	sp,fp
8110c8f0:	dfc00117 	ldw	ra,4(sp)
8110c8f4:	df000017 	ldw	fp,0(sp)
8110c8f8:	dec00204 	addi	sp,sp,8
8110c8fc:	f800283a 	ret

8110c900 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110c900:	defffc04 	addi	sp,sp,-16
8110c904:	de00012e 	bgeu	sp,et,8110c90c <bSyncWriteReg+0xc>
8110c908:	003b68fa 	trap	3
8110c90c:	df000315 	stw	fp,12(sp)
8110c910:	df000304 	addi	fp,sp,12
8110c914:	e13ffe15 	stw	r4,-8(fp)
8110c918:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c91c:	00a00034 	movhi	r2,32768
8110c920:	10810004 	addi	r2,r2,1024
8110c924:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110c928:	e0bffe17 	ldw	r2,-8(fp)
8110c92c:	1085883a 	add	r2,r2,r2
8110c930:	1085883a 	add	r2,r2,r2
8110c934:	1007883a 	mov	r3,r2
8110c938:	e0bffd17 	ldw	r2,-12(fp)
8110c93c:	10c5883a 	add	r2,r2,r3
8110c940:	e0ffff17 	ldw	r3,-4(fp)
8110c944:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110c948:	00800044 	movi	r2,1
}
8110c94c:	e037883a 	mov	sp,fp
8110c950:	df000017 	ldw	fp,0(sp)
8110c954:	dec00104 	addi	sp,sp,4
8110c958:	f800283a 	ret

8110c95c <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110c95c:	defffc04 	addi	sp,sp,-16
8110c960:	de00012e 	bgeu	sp,et,8110c968 <uliSyncReadReg+0xc>
8110c964:	003b68fa 	trap	3
8110c968:	df000315 	stw	fp,12(sp)
8110c96c:	df000304 	addi	fp,sp,12
8110c970:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c974:	00a00034 	movhi	r2,32768
8110c978:	10810004 	addi	r2,r2,1024
8110c97c:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110c980:	e0bfff17 	ldw	r2,-4(fp)
8110c984:	1085883a 	add	r2,r2,r2
8110c988:	1085883a 	add	r2,r2,r2
8110c98c:	1007883a 	mov	r3,r2
8110c990:	e0bffd17 	ldw	r2,-12(fp)
8110c994:	10c5883a 	add	r2,r2,r3
8110c998:	10800017 	ldw	r2,0(r2)
8110c99c:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110c9a0:	e0bffe17 	ldw	r2,-8(fp)
}
8110c9a4:	e037883a 	mov	sp,fp
8110c9a8:	df000017 	ldw	fp,0(sp)
8110c9ac:	dec00104 	addi	sp,sp,4
8110c9b0:	f800283a 	ret

8110c9b4 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110c9b4:	defff804 	addi	sp,sp,-32
8110c9b8:	de00012e 	bgeu	sp,et,8110c9c0 <vDataControlTask+0xc>
8110c9bc:	003b68fa 	trap	3
8110c9c0:	dfc00715 	stw	ra,28(sp)
8110c9c4:	df000615 	stw	fp,24(sp)
8110c9c8:	df000604 	addi	fp,sp,24
8110c9cc:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110c9d0:	e0bffd17 	ldw	r2,-12(fp)
8110c9d4:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110c9d8:	d0a05d17 	ldw	r2,-32396(gp)
8110c9dc:	100f883a 	mov	r7,r2
8110c9e0:	01800804 	movi	r6,32
8110c9e4:	01400044 	movi	r5,1
8110c9e8:	01204534 	movhi	r4,33044
8110c9ec:	211f3a04 	addi	r4,r4,31976
8110c9f0:	111c7b80 	call	8111c7b8 <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110c9f4:	e0bffa17 	ldw	r2,-24(fp)
8110c9f8:	00c00044 	movi	r3,1
8110c9fc:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110ca00:	d0a05a17 	ldw	r2,-32408(gp)
8110ca04:	1009883a 	mov	r4,r2
8110ca08:	11392400 	call	81139240 <OSQFlush>
8110ca0c:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110ca10:	e0bffc03 	ldbu	r2,-16(fp)
8110ca14:	10803fcc 	andi	r2,r2,255
8110ca18:	10000126 	beq	r2,zero,8110ca20 <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110ca1c:	1118f7c0 	call	81118f7c <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110ca20:	e0bffc04 	addi	r2,fp,-16
8110ca24:	100d883a 	mov	r6,r2
8110ca28:	000b883a 	mov	r5,zero
8110ca2c:	01204574 	movhi	r4,33045
8110ca30:	211a2304 	addi	r4,r4,26764
8110ca34:	11393000 	call	81139300 <OSQPend>
8110ca38:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110ca3c:	000f883a 	mov	r7,zero
8110ca40:	01800144 	movi	r6,5
8110ca44:	000b883a 	mov	r5,zero
8110ca48:	0009883a 	mov	r4,zero
8110ca4c:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
	}
8110ca50:	003ff306 	br	8110ca20 <__reset+0xfb0eca20>

8110ca54 <vFeeTask>:

#include "fee_task.h"



void vFeeTask(void *task_data) {
8110ca54:	defff604 	addi	sp,sp,-40
8110ca58:	de00012e 	bgeu	sp,et,8110ca60 <vFeeTask+0xc>
8110ca5c:	003b68fa 	trap	3
8110ca60:	dfc00915 	stw	ra,36(sp)
8110ca64:	df000815 	stw	fp,32(sp)
8110ca68:	df000804 	addi	fp,sp,32
8110ca6c:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110ca70:	e03ffa15 	stw	zero,-24(fp)
	TCcdMemMap *xCcdMapLocal;
	unsigned char ucReadout;
	alt_u16 usiLengthBlocks;


	pxNFee = ( TNFee * ) task_data;
8110ca74:	e0bfff17 	ldw	r2,-4(fp)
8110ca78:	d0a05115 	stw	r2,-32444(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110ca7c:	d0e05d17 	ldw	r3,-32396(gp)
8110ca80:	d0a05117 	ldw	r2,-32444(gp)
8110ca84:	10800003 	ldbu	r2,0(r2)
8110ca88:	10803fcc 	andi	r2,r2,255
8110ca8c:	100d883a 	mov	r6,r2
8110ca90:	01604534 	movhi	r5,33044
8110ca94:	295f4304 	addi	r5,r5,32012
8110ca98:	1809883a 	mov	r4,r3
8110ca9c:	111c11c0 	call	8111c11c <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110caa0:	d0a05117 	ldw	r2,-32444(gp)
8110caa4:	1009883a 	mov	r4,r2
8110caa8:	110e0800 	call	8110e080 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110caac:	d0a05117 	ldw	r2,-32444(gp)
8110cab0:	10802c17 	ldw	r2,176(r2)
8110cab4:	10c00328 	cmpgeui	r3,r2,12
8110cab8:	1803661e 	bne	r3,zero,8110d854 <vFeeTask+0xe00>
8110cabc:	100690ba 	slli	r3,r2,2
8110cac0:	00a04474 	movhi	r2,33041
8110cac4:	10b2b504 	addi	r2,r2,-13612
8110cac8:	1885883a 	add	r2,r3,r2
8110cacc:	10800017 	ldw	r2,0(r2)
8110cad0:	1000683a 	jmp	r2
8110cad4:	8110cb04 	addi	r4,r16,17196
8110cad8:	8110cce4 	muli	r4,r16,17203
8110cadc:	8110cd68 	cmpgeui	r4,r16,17205
8110cae0:	8110ce00 	call	88110ce0 <__reset+0x20f0ce0>
8110cae4:	8110d458 	cmpnei	r4,r16,17233
8110cae8:	8110cb8c 	andi	r4,r16,17198
8110caec:	8110cd78 	rdprs	r4,r16,17205
8110caf0:	8110d3fc 	xorhi	r4,r16,17231
8110caf4:	8110d854 	ori	r4,r16,17249
8110caf8:	8110d888 	cmpgei	r4,r16,17250
8110cafc:	8110ce84 	addi	r4,r16,17210
8110cb00:	8110d728 	cmpgeui	r4,r16,17244
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110cb04:	d0a05117 	ldw	r2,-32444(gp)
8110cb08:	10800003 	ldbu	r2,0(r2)
8110cb0c:	10803fcc 	andi	r2,r2,255
8110cb10:	1085883a 	add	r2,r2,r2
8110cb14:	1087883a 	add	r3,r2,r2
8110cb18:	d0a06504 	addi	r2,gp,-32364
8110cb1c:	1885883a 	add	r2,r3,r2
8110cb20:	10800017 	ldw	r2,0(r2)
8110cb24:	1009883a 	mov	r4,r2
8110cb28:	11392400 	call	81139240 <OSQFlush>
8110cb2c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110cb30:	e0bffd03 	ldbu	r2,-12(fp)
8110cb34:	10803fcc 	andi	r2,r2,255
8110cb38:	10000126 	beq	r2,zero,8110cb40 <vFeeTask+0xec>
					vFailFlushNFEEQueue();
8110cb3c:	11190140 	call	81119014 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110cb40:	d0a05117 	ldw	r2,-32444(gp)
8110cb44:	10800003 	ldbu	r2,0(r2)
8110cb48:	10803fcc 	andi	r2,r2,255
8110cb4c:	1085883a 	add	r2,r2,r2
8110cb50:	1087883a 	add	r3,r2,r2
8110cb54:	d0a05704 	addi	r2,gp,-32420
8110cb58:	1885883a 	add	r2,r3,r2
8110cb5c:	10800017 	ldw	r2,0(r2)
8110cb60:	1009883a 	mov	r4,r2
8110cb64:	11392400 	call	81139240 <OSQFlush>
8110cb68:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110cb6c:	e0bffd03 	ldbu	r2,-12(fp)
8110cb70:	10803fcc 	andi	r2,r2,255
8110cb74:	10000126 	beq	r2,zero,8110cb7c <vFeeTask+0x128>
					vFailFlushNFEEQueue();
8110cb78:	11190140 	call	81119014 <vFailFlushNFEEQueue>
				}				

				pxNFee->xControl.eMode = sToFeeConfig;
8110cb7c:	d0a05117 	ldw	r2,-32444(gp)
8110cb80:	00c00144 	movi	r3,5
8110cb84:	10c02c15 	stw	r3,176(r2)

				break;
8110cb88:	00034206 	br	8110d894 <vFeeTask+0xe40>
			case sToFeeConfig: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110cb8c:	d0e05d17 	ldw	r3,-32396(gp)
8110cb90:	d0a05117 	ldw	r2,-32444(gp)
8110cb94:	10800003 	ldbu	r2,0(r2)
8110cb98:	10803fcc 	andi	r2,r2,255
8110cb9c:	100d883a 	mov	r6,r2
8110cba0:	01604534 	movhi	r5,33044
8110cba4:	295f4a04 	addi	r5,r5,32040
8110cba8:	1809883a 	mov	r4,r3
8110cbac:	111c11c0 	call	8111c11c <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110cbb0:	d0a05117 	ldw	r2,-32444(gp)
8110cbb4:	10802217 	ldw	r2,136(r2)
8110cbb8:	10800058 	cmpnei	r2,r2,1
8110cbbc:	10000a1e 	bne	r2,zero,8110cbe8 <vFeeTask+0x194>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110cbc0:	e0fff803 	ldbu	r3,-32(fp)
8110cbc4:	00a045b4 	movhi	r2,33046
8110cbc8:	10b95504 	addi	r2,r2,-6828
8110cbcc:	180690fa 	slli	r3,r3,3
8110cbd0:	10c5883a 	add	r2,r2,r3
8110cbd4:	10800017 	ldw	r2,0(r2)
8110cbd8:	1009883a 	mov	r4,r2
8110cbdc:	11387900 	call	81138790 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110cbe0:	d0a05117 	ldw	r2,-32444(gp)
8110cbe4:	10002215 	stw	zero,136(r2)
				}

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110cbe8:	d0a05117 	ldw	r2,-32444(gp)
8110cbec:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110cbf0:	d0a05117 	ldw	r2,-32444(gp)
8110cbf4:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110cbf8:	d0a05117 	ldw	r2,-32444(gp)
8110cbfc:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110cc00:	d0a05117 	ldw	r2,-32444(gp)
8110cc04:	00c00044 	movi	r3,1
8110cc08:	10c02115 	stw	r3,132(r2)
				pxNFee->xControl.ucTimeCode = 0;
8110cc0c:	d0a05117 	ldw	r2,-32444(gp)
8110cc10:	10002a05 	stb	zero,168(r2)

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110cc14:	d0a05117 	ldw	r2,-32444(gp)
8110cc18:	10800003 	ldbu	r2,0(r2)
8110cc1c:	10803fcc 	andi	r2,r2,255
8110cc20:	1085883a 	add	r2,r2,r2
8110cc24:	1087883a 	add	r3,r2,r2
8110cc28:	d0a06504 	addi	r2,gp,-32364
8110cc2c:	1885883a 	add	r2,r3,r2
8110cc30:	10800017 	ldw	r2,0(r2)
8110cc34:	1009883a 	mov	r4,r2
8110cc38:	11392400 	call	81139240 <OSQFlush>
8110cc3c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110cc40:	e0bffd03 	ldbu	r2,-12(fp)
8110cc44:	10803fcc 	andi	r2,r2,255
8110cc48:	10000126 	beq	r2,zero,8110cc50 <vFeeTask+0x1fc>
					vFailFlushNFEEQueue();
8110cc4c:	11190140 	call	81119014 <vFailFlushNFEEQueue>
				}

				/* Clear the Queue that indicates when Sync Signals occours */
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110cc50:	d0a05117 	ldw	r2,-32444(gp)
8110cc54:	10800003 	ldbu	r2,0(r2)
8110cc58:	10803fcc 	andi	r2,r2,255
8110cc5c:	1085883a 	add	r2,r2,r2
8110cc60:	1087883a 	add	r3,r2,r2
8110cc64:	d0a05704 	addi	r2,gp,-32420
8110cc68:	1885883a 	add	r2,r3,r2
8110cc6c:	10800017 	ldw	r2,0(r2)
8110cc70:	1009883a 	mov	r4,r2
8110cc74:	11392400 	call	81139240 <OSQFlush>
8110cc78:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110cc7c:	e0bffd03 	ldbu	r2,-12(fp)
8110cc80:	10803fcc 	andi	r2,r2,255
8110cc84:	10000126 	beq	r2,zero,8110cc8c <vFeeTask+0x238>
					vFailFlushNFEEQueue();
8110cc88:	11190140 	call	81119014 <vFailFlushNFEEQueue>
				}

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110cc8c:	d0a05117 	ldw	r2,-32444(gp)
8110cc90:	10808804 	addi	r2,r2,544
8110cc94:	1009883a 	mov	r4,r2
8110cc98:	110dda80 	call	8110dda8 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110cc9c:	d0a05117 	ldw	r2,-32444(gp)
8110cca0:	10002615 	stw	zero,152(r2)


				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap);
8110cca4:	d0a05117 	ldw	r2,-32444(gp)
8110cca8:	10804204 	addi	r2,r2,264
8110ccac:	1009883a 	mov	r4,r2
8110ccb0:	110dd0c0 	call	8110dd0c <bDisableRmapIRQ>


				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110ccb4:	d0a05117 	ldw	r2,-32444(gp)
8110ccb8:	10803b04 	addi	r2,r2,236
8110ccbc:	1009883a 	mov	r4,r2
8110ccc0:	110ded40 	call	8110ded4 <bDisAndClrDbBuffer>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				bSpwcClearTimecode(&pxNFee->xChannel.xSpacewire);
8110ccc4:	d0a05117 	ldw	r2,-32444(gp)
8110ccc8:	10808804 	addi	r2,r2,544
8110cccc:	1009883a 	mov	r4,r2
8110ccd0:	110958c0 	call	8110958c <bSpwcClearTimecode>

				pxNFee->xControl.eMode = sFeeConfig;
8110ccd4:	d0a05117 	ldw	r2,-32444(gp)
8110ccd8:	00c00044 	movi	r3,1
8110ccdc:	10c02c15 	stw	r3,176(r2)
				break;
8110cce0:	0002ec06 	br	8110d894 <vFeeTask+0xe40>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110cce4:	d0a05117 	ldw	r2,-32444(gp)
8110cce8:	10800003 	ldbu	r2,0(r2)
8110ccec:	10803fcc 	andi	r2,r2,255
8110ccf0:	1085883a 	add	r2,r2,r2
8110ccf4:	1087883a 	add	r3,r2,r2
8110ccf8:	d0a06504 	addi	r2,gp,-32364
8110ccfc:	1885883a 	add	r2,r3,r2
8110cd00:	10800017 	ldw	r2,0(r2)
8110cd04:	e0fffd04 	addi	r3,fp,-12
8110cd08:	180d883a 	mov	r6,r3
8110cd0c:	000b883a 	mov	r5,zero
8110cd10:	1009883a 	mov	r4,r2
8110cd14:	11393000 	call	81139300 <OSQPend>
8110cd18:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110cd1c:	e0bffd03 	ldbu	r2,-12(fp)
8110cd20:	10803fcc 	andi	r2,r2,255
8110cd24:	1000061e 	bne	r2,zero,8110cd40 <vFeeTask+0x2ec>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110cd28:	d0a05117 	ldw	r2,-32444(gp)
8110cd2c:	e0fffe17 	ldw	r3,-8(fp)
8110cd30:	180b883a 	mov	r5,r3
8110cd34:	1009883a 	mov	r4,r2
8110cd38:	110d8980 	call	8110d898 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110cd3c:	0002d506 	br	8110d894 <vFeeTask+0xe40>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110cd40:	d0e05d17 	ldw	r3,-32396(gp)
8110cd44:	d0a05117 	ldw	r2,-32444(gp)
8110cd48:	10800003 	ldbu	r2,0(r2)
8110cd4c:	10803fcc 	andi	r2,r2,255
8110cd50:	100d883a 	mov	r6,r2
8110cd54:	01604534 	movhi	r5,33044
8110cd58:	295f5104 	addi	r5,r5,32068
8110cd5c:	1809883a 	mov	r4,r3
8110cd60:	111c11c0 	call	8111c11c <fprintf>
					#endif
				}

				break;
8110cd64:	0002cb06 	br	8110d894 <vFeeTask+0xe40>
			case sFeeOn: /* Real mode */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110cd68:	d0a05117 	ldw	r2,-32444(gp)
8110cd6c:	00c00184 	movi	r3,6
8110cd70:	10c02c15 	stw	r3,176(r2)
				break;
8110cd74:	0002c706 	br	8110d894 <vFeeTask+0xe40>
				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
			case sToFeeStandBy: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110cd78:	d0e05d17 	ldw	r3,-32396(gp)
8110cd7c:	d0a05117 	ldw	r2,-32444(gp)
8110cd80:	10800003 	ldbu	r2,0(r2)
8110cd84:	10803fcc 	andi	r2,r2,255
8110cd88:	100d883a 	mov	r6,r2
8110cd8c:	01604534 	movhi	r5,33044
8110cd90:	295f5d04 	addi	r5,r5,32116
8110cd94:	1809883a 	mov	r4,r3
8110cd98:	111c11c0 	call	8111c11c <fprintf>
				#endif

				incrementador = 0; // remover !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
8110cd9c:	d0205215 	stw	zero,-32440(gp)

				pxNFee->xControl.bSimulating = TRUE;
8110cda0:	d0a05117 	ldw	r2,-32444(gp)
8110cda4:	00c00044 	movi	r3,1
8110cda8:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110cdac:	d0a05117 	ldw	r2,-32444(gp)
8110cdb0:	10002315 	stw	zero,140(r2)

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110cdb4:	d0a05117 	ldw	r2,-32444(gp)
8110cdb8:	10803b04 	addi	r2,r2,236
8110cdbc:	1009883a 	mov	r4,r2
8110cdc0:	110ded40 	call	8110ded4 <bDisAndClrDbBuffer>


				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap);
8110cdc4:	d0a05117 	ldw	r2,-32444(gp)
8110cdc8:	10804204 	addi	r2,r2,264
8110cdcc:	1009883a 	mov	r4,r2
8110cdd0:	110dd580 	call	8110dd58 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110cdd4:	d0a05117 	ldw	r2,-32444(gp)
8110cdd8:	10808804 	addi	r2,r2,544
8110cddc:	1009883a 	mov	r4,r2
8110cde0:	110de080 	call	8110de08 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110cde4:	d0a05117 	ldw	r2,-32444(gp)
8110cde8:	00c00044 	movi	r3,1
8110cdec:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.eMode = sFeeStandBy;
8110cdf0:	d0a05117 	ldw	r2,-32444(gp)
8110cdf4:	00c000c4 	movi	r3,3
8110cdf8:	10c02c15 	stw	r3,176(r2)
				break;
8110cdfc:	0002a506 	br	8110d894 <vFeeTask+0xe40>

			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ce00:	d0a05117 	ldw	r2,-32444(gp)
8110ce04:	10800003 	ldbu	r2,0(r2)
8110ce08:	10803fcc 	andi	r2,r2,255
8110ce0c:	1085883a 	add	r2,r2,r2
8110ce10:	1087883a 	add	r3,r2,r2
8110ce14:	d0a06504 	addi	r2,gp,-32364
8110ce18:	1885883a 	add	r2,r3,r2
8110ce1c:	10800017 	ldw	r2,0(r2)
8110ce20:	e0fffd04 	addi	r3,fp,-12
8110ce24:	180d883a 	mov	r6,r3
8110ce28:	000b883a 	mov	r5,zero
8110ce2c:	1009883a 	mov	r4,r2
8110ce30:	11393000 	call	81139300 <OSQPend>
8110ce34:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ce38:	e0bffd03 	ldbu	r2,-12(fp)
8110ce3c:	10803fcc 	andi	r2,r2,255
8110ce40:	1000061e 	bne	r2,zero,8110ce5c <vFeeTask+0x408>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110ce44:	d0a05117 	ldw	r2,-32444(gp)
8110ce48:	e0fffe17 	ldw	r3,-8(fp)
8110ce4c:	180b883a 	mov	r5,r3
8110ce50:	1009883a 	mov	r4,r2
8110ce54:	110da080 	call	8110da08 <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ce58:	00028e06 	br	8110d894 <vFeeTask+0xe40>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ce5c:	d0e05d17 	ldw	r3,-32396(gp)
8110ce60:	d0a05117 	ldw	r2,-32444(gp)
8110ce64:	10800003 	ldbu	r2,0(r2)
8110ce68:	10803fcc 	andi	r2,r2,255
8110ce6c:	100d883a 	mov	r6,r2
8110ce70:	01604534 	movhi	r5,33044
8110ce74:	295f5104 	addi	r5,r5,32068
8110ce78:	1809883a 	mov	r4,r3
8110ce7c:	111c11c0 	call	8111c11c <fprintf>
					#endif
				}

				break;
8110ce80:	00028406 	br	8110d894 <vFeeTask+0xe40>
			case sSIMTestFullPattern:
#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  ENTROU NO SIM TEST FULL\n ");
8110ce84:	d0a05d17 	ldw	r2,-32396(gp)
8110ce88:	100f883a 	mov	r7,r2
8110ce8c:	01800944 	movi	r6,37
8110ce90:	01400044 	movi	r5,1
8110ce94:	01204534 	movhi	r4,33044
8110ce98:	211f6504 	addi	r4,r4,32148
8110ce9c:	111c7b80 	call	8111c7b8 <fwrite>
#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110cea0:	d0a05117 	ldw	r2,-32444(gp)
8110cea4:	00c00044 	movi	r3,1
8110cea8:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110ceac:	d0a05117 	ldw	r2,-32444(gp)
8110ceb0:	00c00044 	movi	r3,1
8110ceb4:	10c02715 	stw	r3,156(r2)

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110ceb8:	d0a05117 	ldw	r2,-32444(gp)
8110cebc:	10803b04 	addi	r2,r2,236
8110cec0:	1009883a 	mov	r4,r2
8110cec4:	110de680 	call	8110de68 <bEnableDbBuffer>

				/* Configurar o tamanho normal do double buffer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  */
				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110cec8:	d0a05117 	ldw	r2,-32444(gp)
8110cecc:	10808804 	addi	r2,r2,544
8110ced0:	1009883a 	mov	r4,r2
8110ced4:	11094fc0 	call	811094fc <bSpwcGetTimecode>
#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  TIME CODE SPW: %hhu \n ", pxNFee->xChannel.xSpacewire.xTimecode.ucCounter);
8110ced8:	d0e05d17 	ldw	r3,-32396(gp)
8110cedc:	d0a05117 	ldw	r2,-32444(gp)
8110cee0:	10809443 	ldbu	r2,593(r2)
8110cee4:	10803fcc 	andi	r2,r2,255
8110cee8:	100d883a 	mov	r6,r2
8110ceec:	01604534 	movhi	r5,33044
8110cef0:	295f6f04 	addi	r5,r5,32188
8110cef4:	1809883a 	mov	r4,r3
8110cef8:	111c11c0 	call	8111c11c <fprintf>
#endif
				tCodeNext = ( pxNFee->xChannel.xSpacewire.xTimecode.ucCounter + 1) % 4;
8110cefc:	d0a05117 	ldw	r2,-32444(gp)
8110cf00:	10809443 	ldbu	r2,593(r2)
8110cf04:	10803fcc 	andi	r2,r2,255
8110cf08:	10c00044 	addi	r3,r2,1
8110cf0c:	00a00034 	movhi	r2,32768
8110cf10:	108000c4 	addi	r2,r2,3
8110cf14:	1884703a 	and	r2,r3,r2
8110cf18:	1000040e 	bge	r2,zero,8110cf2c <vFeeTask+0x4d8>
8110cf1c:	10bfffc4 	addi	r2,r2,-1
8110cf20:	00ffff04 	movi	r3,-4
8110cf24:	10c4b03a 	or	r2,r2,r3
8110cf28:	10800044 	addi	r2,r2,1
8110cf2c:	e0bffb15 	stw	r2,-20(fp)
				if ( tCodeNext == 0 ) {
8110cf30:	e0bffb17 	ldw	r2,-20(fp)
8110cf34:	10000f1e 	bne	r2,zero,8110cf74 <vFeeTask+0x520>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110cf38:	d0a05117 	ldw	r2,-32444(gp)
8110cf3c:	10802917 	ldw	r2,164(r2)
8110cf40:	10800003 	ldbu	r2,0(r2)
8110cf44:	10803fcc 	andi	r2,r2,255
8110cf48:	10c00044 	addi	r3,r2,1
8110cf4c:	00a00034 	movhi	r2,32768
8110cf50:	10800044 	addi	r2,r2,1
8110cf54:	1884703a 	and	r2,r3,r2
8110cf58:	1000040e 	bge	r2,zero,8110cf6c <vFeeTask+0x518>
8110cf5c:	10bfffc4 	addi	r2,r2,-1
8110cf60:	00ffff84 	movi	r3,-2
8110cf64:	10c4b03a 	or	r2,r2,r3
8110cf68:	10800044 	addi	r2,r2,1
8110cf6c:	e0bff805 	stb	r2,-32(fp)
8110cf70:	00000406 	br	8110cf84 <vFeeTask+0x530>
				} else {
					ucMemUsing = (unsigned char) *pxNFee->xControl.pActualMem ; /* Select the of the data control (te future)*/
8110cf74:	d0a05117 	ldw	r2,-32444(gp)
8110cf78:	10802917 	ldw	r2,164(r2)
8110cf7c:	10800003 	ldbu	r2,0(r2)
8110cf80:	e0bff805 	stb	r2,-32(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110cf84:	d0e05117 	ldw	r3,-32444(gp)
8110cf88:	e0bffb17 	ldw	r2,-20(fp)
8110cf8c:	1885883a 	add	r2,r3,r2
8110cf90:	10802a44 	addi	r2,r2,169
8110cf94:	10800003 	ldbu	r2,0(r2)
8110cf98:	e0bffc05 	stb	r2,-16(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110cf9c:	d0a05117 	ldw	r2,-32444(gp)
8110cfa0:	10802e17 	ldw	r2,184(r2)
8110cfa4:	1000071e 	bne	r2,zero,8110cfc4 <vFeeTask+0x570>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110cfa8:	d0e05117 	ldw	r3,-32444(gp)
8110cfac:	e0bffc03 	ldbu	r2,-16(fp)
8110cfb0:	10800624 	muli	r2,r2,24
8110cfb4:	10800904 	addi	r2,r2,36
8110cfb8:	1885883a 	add	r2,r3,r2
8110cfbc:	e0bff915 	stw	r2,-28(fp)
8110cfc0:	00000606 	br	8110cfdc <vFeeTask+0x588>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110cfc4:	d0e05117 	ldw	r3,-32444(gp)
8110cfc8:	e0bffc03 	ldbu	r2,-16(fp)
8110cfcc:	10800624 	muli	r2,r2,24
8110cfd0:	10800c04 	addi	r2,r2,48
8110cfd4:	1885883a 	add	r2,r3,r2
8110cfd8:	e0bff915 	stw	r2,-28(fp)


				/* todo: resetar o tamanho do buffer size para o maximo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  JA PEGOU A REFERENCIA DE ENDERECO, VAI MANDAR MENSAGEM REQUISITANDO DMA\n ");
8110cfdc:	d0a05d17 	ldw	r2,-32396(gp)
8110cfe0:	100f883a 	mov	r7,r2
8110cfe4:	01801544 	movi	r6,85
8110cfe8:	01400044 	movi	r5,1
8110cfec:	01204534 	movhi	r4,33044
8110cff0:	211f7804 	addi	r4,r4,32224
8110cff4:	111c7b80 	call	8111c7b8 <fwrite>
#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110cff8:	d0a05117 	ldw	r2,-32444(gp)
8110cffc:	10800003 	ldbu	r2,0(r2)
8110d000:	10803fcc 	andi	r2,r2,255
8110d004:	100d883a 	mov	r6,r2
8110d008:	000b883a 	mov	r5,zero
8110d00c:	01002004 	movi	r4,128
8110d010:	110df380 	call	8110df38 <bSendRequestNFeeCtrl>

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  ENVIOU MENSAGEM PARA O CONTROLLER PEDINDO DMA. AGUARDANDO NO xFeeQ\n ");
8110d014:	d0a05d17 	ldw	r2,-32396(gp)
8110d018:	100f883a 	mov	r7,r2
8110d01c:	01801404 	movi	r6,80
8110d020:	01400044 	movi	r5,1
8110d024:	01204534 	movhi	r4,33044
8110d028:	211f8e04 	addi	r4,r4,32312
8110d02c:	111c7b80 	call	8111c7b8 <fwrite>
#endif

				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d030:	d0a05117 	ldw	r2,-32444(gp)
8110d034:	10800003 	ldbu	r2,0(r2)
8110d038:	10803fcc 	andi	r2,r2,255
8110d03c:	1085883a 	add	r2,r2,r2
8110d040:	1087883a 	add	r3,r2,r2
8110d044:	d0a06504 	addi	r2,gp,-32364
8110d048:	1885883a 	add	r2,r3,r2
8110d04c:	10800017 	ldw	r2,0(r2)
8110d050:	e0fffd04 	addi	r3,fp,-12
8110d054:	180d883a 	mov	r6,r3
8110d058:	000b883a 	mov	r5,zero
8110d05c:	1009883a 	mov	r4,r2
8110d060:	11393000 	call	81139300 <OSQPend>
8110d064:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d068:	e0bffd03 	ldbu	r2,-12(fp)
8110d06c:	10803fcc 	andi	r2,r2,255
8110d070:	1000c71e 	bne	r2,zero,8110d390 <vFeeTask+0x93c>

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  RECEBEU MENSAGEM\n ");
8110d074:	d0a05d17 	ldw	r2,-32396(gp)
8110d078:	100f883a 	mov	r7,r2
8110d07c:	01800784 	movi	r6,30
8110d080:	01400044 	movi	r5,1
8110d084:	01204534 	movhi	r4,33044
8110d088:	211fa304 	addi	r4,r4,32396
8110d08c:	111c7b80 	call	8111c7b8 <fwrite>
#endif

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110d090:	e0bffe83 	ldbu	r2,-6(fp)
8110d094:	10803fcc 	andi	r2,r2,255
8110d098:	108023d8 	cmpnei	r2,r2,143
8110d09c:	1000b61e 	bne	r2,zero,8110d378 <vFeeTask+0x924>
#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  ERA DE ACESSO AO DMA\n ");
8110d0a0:	d0a05d17 	ldw	r2,-32396(gp)
8110d0a4:	100f883a 	mov	r7,r2
8110d0a8:	01800884 	movi	r6,34
8110d0ac:	01400044 	movi	r5,1
8110d0b0:	01204534 	movhi	r4,33044
8110d0b4:	211fab04 	addi	r4,r4,32428
8110d0b8:	111c7b80 	call	8111c7b8 <fwrite>
#endif

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110d0bc:	e0fff803 	ldbu	r3,-32(fp)
8110d0c0:	00a045b4 	movhi	r2,33046
8110d0c4:	10b95504 	addi	r2,r2,-6828
8110d0c8:	180690fa 	slli	r3,r3,3
8110d0cc:	10c5883a 	add	r2,r2,r3
8110d0d0:	10800017 	ldw	r2,0(r2)
8110d0d4:	e0fffd04 	addi	r3,fp,-12
8110d0d8:	180d883a 	mov	r6,r3
8110d0dc:	000b883a 	mov	r5,zero
8110d0e0:	1009883a 	mov	r4,r2
8110d0e4:	11381ec0 	call	811381ec <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110d0e8:	e0bffd03 	ldbu	r2,-12(fp)
8110d0ec:	10803fcc 	andi	r2,r2,255
8110d0f0:	1000b01e 	bne	r2,zero,8110d3b4 <vFeeTask+0x960>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110d0f4:	d0a05117 	ldw	r2,-32444(gp)
8110d0f8:	00c00044 	movi	r3,1
8110d0fc:	10c02215 	stw	r3,136(r2)

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  PEGOU MUTEX\n ");
8110d100:	d0a05d17 	ldw	r2,-32396(gp)
8110d104:	100f883a 	mov	r7,r2
8110d108:	01800644 	movi	r6,25
8110d10c:	01400044 	movi	r5,1
8110d110:	01204534 	movhi	r4,33044
8110d114:	211fb404 	addi	r4,r4,32464
8110d118:	111c7b80 	call	8111c7b8 <fwrite>
#endif

						if (  ucMemUsing == 0  ) {
8110d11c:	e0bff803 	ldbu	r2,-32(fp)
8110d120:	10003f1e 	bne	r2,zero,8110d220 <vFeeTask+0x7cc>
							/* Initializing the addr */
	                    	xCcdMapLocal->ulBlockI = 0;
8110d124:	e0bff917 	ldw	r2,-28(fp)
8110d128:	10000115 	stw	zero,4(r2)
							xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110d12c:	e0bff917 	ldw	r2,-28(fp)
8110d130:	10c00017 	ldw	r3,0(r2)
8110d134:	e0bff917 	ldw	r2,-28(fp)
8110d138:	10c00215 	stw	r3,8(r2)
							bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d13c:	e0bff917 	ldw	r2,-28(fp)
8110d140:	10800217 	ldw	r2,8(r2)
8110d144:	1009883a 	mov	r4,r2
8110d148:	d0a05117 	ldw	r2,-32444(gp)
8110d14c:	10802e17 	ldw	r2,184(r2)
8110d150:	10c03fcc 	andi	r3,r2,255
8110d154:	d0a05117 	ldw	r2,-32444(gp)
8110d158:	10800003 	ldbu	r2,0(r2)
8110d15c:	10803fcc 	andi	r2,r2,255
8110d160:	100f883a 	mov	r7,r2
8110d164:	180d883a 	mov	r6,r3
8110d168:	01400404 	movi	r5,16
8110d16c:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
							//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d170:	e0bff917 	ldw	r2,-28(fp)
8110d174:	10800217 	ldw	r2,8(r2)
8110d178:	10c22004 	addi	r3,r2,2176
8110d17c:	e0bff917 	ldw	r2,-28(fp)
8110d180:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d184:	e0bff917 	ldw	r2,-28(fp)
8110d188:	10800117 	ldw	r2,4(r2)
8110d18c:	10c00404 	addi	r3,r2,16
8110d190:	e0bff917 	ldw	r2,-28(fp)
8110d194:	10c00115 	stw	r3,4(r2)
							bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d198:	e0bff917 	ldw	r2,-28(fp)
8110d19c:	10800217 	ldw	r2,8(r2)
8110d1a0:	1009883a 	mov	r4,r2
8110d1a4:	d0a05117 	ldw	r2,-32444(gp)
8110d1a8:	10802e17 	ldw	r2,184(r2)
8110d1ac:	10c03fcc 	andi	r3,r2,255
8110d1b0:	d0a05117 	ldw	r2,-32444(gp)
8110d1b4:	10800003 	ldbu	r2,0(r2)
8110d1b8:	10803fcc 	andi	r2,r2,255
8110d1bc:	100f883a 	mov	r7,r2
8110d1c0:	180d883a 	mov	r6,r3
8110d1c4:	01400404 	movi	r5,16
8110d1c8:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
							//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d1cc:	e0bff917 	ldw	r2,-28(fp)
8110d1d0:	10800217 	ldw	r2,8(r2)
8110d1d4:	10c22004 	addi	r3,r2,2176
8110d1d8:	e0bff917 	ldw	r2,-28(fp)
8110d1dc:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d1e0:	e0bff917 	ldw	r2,-28(fp)
8110d1e4:	10800117 	ldw	r2,4(r2)
8110d1e8:	10c00404 	addi	r3,r2,16
8110d1ec:	e0bff917 	ldw	r2,-28(fp)
8110d1f0:	10c00115 	stw	r3,4(r2)
	                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d1f4:	e0fff803 	ldbu	r3,-32(fp)
8110d1f8:	00a045b4 	movhi	r2,33046
8110d1fc:	10b95504 	addi	r2,r2,-6828
8110d200:	180690fa 	slli	r3,r3,3
8110d204:	10c5883a 	add	r2,r2,r3
8110d208:	10800017 	ldw	r2,0(r2)
8110d20c:	1009883a 	mov	r4,r2
8110d210:	11387900 	call	81138790 <OSMutexPost>
	                        pxNFee->xControl.bDMALocked = FALSE;
8110d214:	d0a05117 	ldw	r2,-32444(gp)
8110d218:	10002215 	stw	zero,136(r2)
8110d21c:	00003e06 	br	8110d318 <vFeeTask+0x8c4>
						} else {
							/* Initializing the addr */
	                    	xCcdMapLocal->ulBlockI = 0;
8110d220:	e0bff917 	ldw	r2,-28(fp)
8110d224:	10000115 	stw	zero,4(r2)
							xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110d228:	e0bff917 	ldw	r2,-28(fp)
8110d22c:	10c00017 	ldw	r3,0(r2)
8110d230:	e0bff917 	ldw	r2,-28(fp)
8110d234:	10c00215 	stw	r3,8(r2)
							bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d238:	e0bff917 	ldw	r2,-28(fp)
8110d23c:	10800217 	ldw	r2,8(r2)
8110d240:	1009883a 	mov	r4,r2
8110d244:	d0a05117 	ldw	r2,-32444(gp)
8110d248:	10802e17 	ldw	r2,184(r2)
8110d24c:	10c03fcc 	andi	r3,r2,255
8110d250:	d0a05117 	ldw	r2,-32444(gp)
8110d254:	10800003 	ldbu	r2,0(r2)
8110d258:	10803fcc 	andi	r2,r2,255
8110d25c:	100f883a 	mov	r7,r2
8110d260:	180d883a 	mov	r6,r3
8110d264:	01400404 	movi	r5,16
8110d268:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
							//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d26c:	e0bff917 	ldw	r2,-28(fp)
8110d270:	10800217 	ldw	r2,8(r2)
8110d274:	10c22004 	addi	r3,r2,2176
8110d278:	e0bff917 	ldw	r2,-28(fp)
8110d27c:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d280:	e0bff917 	ldw	r2,-28(fp)
8110d284:	10800117 	ldw	r2,4(r2)
8110d288:	10c00404 	addi	r3,r2,16
8110d28c:	e0bff917 	ldw	r2,-28(fp)
8110d290:	10c00115 	stw	r3,4(r2)
							bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d294:	e0bff917 	ldw	r2,-28(fp)
8110d298:	10800217 	ldw	r2,8(r2)
8110d29c:	1009883a 	mov	r4,r2
8110d2a0:	d0a05117 	ldw	r2,-32444(gp)
8110d2a4:	10802e17 	ldw	r2,184(r2)
8110d2a8:	10c03fcc 	andi	r3,r2,255
8110d2ac:	d0a05117 	ldw	r2,-32444(gp)
8110d2b0:	10800003 	ldbu	r2,0(r2)
8110d2b4:	10803fcc 	andi	r2,r2,255
8110d2b8:	100f883a 	mov	r7,r2
8110d2bc:	180d883a 	mov	r6,r3
8110d2c0:	01400404 	movi	r5,16
8110d2c4:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
							//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d2c8:	e0bff917 	ldw	r2,-28(fp)
8110d2cc:	10800217 	ldw	r2,8(r2)
8110d2d0:	10c22004 	addi	r3,r2,2176
8110d2d4:	e0bff917 	ldw	r2,-28(fp)
8110d2d8:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d2dc:	e0bff917 	ldw	r2,-28(fp)
8110d2e0:	10800117 	ldw	r2,4(r2)
8110d2e4:	10c00404 	addi	r3,r2,16
8110d2e8:	e0bff917 	ldw	r2,-28(fp)
8110d2ec:	10c00115 	stw	r3,4(r2)
	                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d2f0:	e0fff803 	ldbu	r3,-32(fp)
8110d2f4:	00a045b4 	movhi	r2,33046
8110d2f8:	10b95504 	addi	r2,r2,-6828
8110d2fc:	180690fa 	slli	r3,r3,3
8110d300:	10c5883a 	add	r2,r2,r3
8110d304:	10800017 	ldw	r2,0(r2)
8110d308:	1009883a 	mov	r4,r2
8110d30c:	11387900 	call	81138790 <OSMutexPost>
	                        pxNFee->xControl.bDMALocked = FALSE;
8110d310:	d0a05117 	ldw	r2,-32444(gp)
8110d314:	10002215 	stw	zero,136(r2)
						}

						incrementador = 2; // remover !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
8110d318:	00800084 	movi	r2,2
8110d31c:	d0a05215 	stw	r2,-32440(gp)

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  MANDOU OS COMANDOS VIA DMA\n ");
8110d320:	d0a05d17 	ldw	r2,-32396(gp)
8110d324:	100f883a 	mov	r7,r2
8110d328:	01800a04 	movi	r6,40
8110d32c:	01400044 	movi	r5,1
8110d330:	01204534 	movhi	r4,33044
8110d334:	211fbb04 	addi	r4,r4,32492
8110d338:	111c7b80 	call	8111c7b8 <fwrite>
#endif

	                        /* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110d33c:	d0a05117 	ldw	r2,-32444(gp)
8110d340:	10800003 	ldbu	r2,0(r2)
8110d344:	10803fcc 	andi	r2,r2,255
8110d348:	100d883a 	mov	r6,r2
8110d34c:	000b883a 	mov	r5,zero
8110d350:	01002044 	movi	r4,129
8110d354:	110dfdc0 	call	8110dfdc <bSendGiveBackNFeeCtrl>
#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  MSG PARA CONTROLER DEVOLVENDO DMA\n ");
8110d358:	d0a05d17 	ldw	r2,-32396(gp)
8110d35c:	100f883a 	mov	r7,r2
8110d360:	01800bc4 	movi	r6,47
8110d364:	01400044 	movi	r5,1
8110d368:	01204534 	movhi	r4,33044
8110d36c:	211fc604 	addi	r4,r4,32536
8110d370:	111c7b80 	call	8111c7b8 <fwrite>
8110d374:	00000f06 	br	8110d3b4 <vFeeTask+0x960>
#endif


	                    }
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110d378:	d0a05117 	ldw	r2,-32444(gp)
8110d37c:	e0fffe17 	ldw	r3,-8(fp)
8110d380:	180b883a 	mov	r5,r3
8110d384:	1009883a 	mov	r4,r2
8110d388:	110db7c0 	call	8110db7c <vQCmdFEEinFullPattern>
8110d38c:	00000906 	br	8110d3b4 <vFeeTask+0x960>
					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110d390:	d0e05d17 	ldw	r3,-32396(gp)
8110d394:	d0a05117 	ldw	r2,-32444(gp)
8110d398:	10800003 	ldbu	r2,0(r2)
8110d39c:	10803fcc 	andi	r2,r2,255
8110d3a0:	100d883a 	mov	r6,r2
8110d3a4:	01604534 	movhi	r5,33044
8110d3a8:	295f5104 	addi	r5,r5,32068
8110d3ac:	1809883a 	mov	r4,r3
8110d3b0:	111c11c0 	call	8111c11c <fprintf>
					#endif
				}

				if (pxNFee->xControl.bWatingSync==TRUE) {
8110d3b4:	d0a05117 	ldw	r2,-32444(gp)
8110d3b8:	10802817 	ldw	r2,160(r2)
8110d3bc:	10800058 	cmpnei	r2,r2,1
8110d3c0:	1000071e 	bne	r2,zero,8110d3e0 <vFeeTask+0x98c>
					pxNFee->xControl.eNextMode = sToTestFullPattern;
8110d3c4:	d0a05117 	ldw	r2,-32444(gp)
8110d3c8:	00c001c4 	movi	r3,7
8110d3cc:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eMode = sFeeWaitingSync;
8110d3d0:	d0a05117 	ldw	r2,-32444(gp)
8110d3d4:	00c002c4 	movi	r3,11
8110d3d8:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eMode = sToTestFullPattern;
				}



				break;
8110d3dc:	00012d06 	br	8110d894 <vFeeTask+0xe40>

				if (pxNFee->xControl.bWatingSync==TRUE) {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
					pxNFee->xControl.eMode = sFeeWaitingSync;
				} else {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
8110d3e0:	d0a05117 	ldw	r2,-32444(gp)
8110d3e4:	00c001c4 	movi	r3,7
8110d3e8:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eMode = sToTestFullPattern;
8110d3ec:	d0a05117 	ldw	r2,-32444(gp)
8110d3f0:	00c001c4 	movi	r3,7
8110d3f4:	10c02c15 	stw	r3,176(r2)
				}



				break;
8110d3f8:	00012606 	br	8110d894 <vFeeTask+0xe40>


			case sToTestFullPattern: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110d3fc:	d0e05d17 	ldw	r3,-32396(gp)
8110d400:	d0a05117 	ldw	r2,-32444(gp)
8110d404:	10800003 	ldbu	r2,0(r2)
8110d408:	10803fcc 	andi	r2,r2,255
8110d40c:	100d883a 	mov	r6,r2
8110d410:	01604534 	movhi	r5,33044
8110d414:	295fd204 	addi	r5,r5,32584
8110d418:	1809883a 	mov	r4,r3
8110d41c:	111c11c0 	call	8111c11c <fprintf>
				#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110d420:	d0a05117 	ldw	r2,-32444(gp)
8110d424:	00c00044 	movi	r3,1
8110d428:	10c02315 	stw	r3,140(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110d42c:	d0a05117 	ldw	r2,-32444(gp)
8110d430:	10800003 	ldbu	r2,0(r2)
8110d434:	10803fcc 	andi	r2,r2,255
8110d438:	100d883a 	mov	r6,r2
8110d43c:	000b883a 	mov	r5,zero
8110d440:	01002004 	movi	r4,128
8110d444:	110df380 	call	8110df38 <bSendRequestNFeeCtrl>
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110d448:	d0a05117 	ldw	r2,-32444(gp)
8110d44c:	00c00104 	movi	r3,4
8110d450:	10c02c15 	stw	r3,176(r2)


				break;
8110d454:	00010f06 	br	8110d894 <vFeeTask+0xe40>

#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  sFeeTestFullPattern\n ");
#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d458:	d0a05117 	ldw	r2,-32444(gp)
8110d45c:	10800003 	ldbu	r2,0(r2)
8110d460:	10803fcc 	andi	r2,r2,255
8110d464:	1085883a 	add	r2,r2,r2
8110d468:	1087883a 	add	r3,r2,r2
8110d46c:	d0a06504 	addi	r2,gp,-32364
8110d470:	1885883a 	add	r2,r3,r2
8110d474:	10800017 	ldw	r2,0(r2)
8110d478:	e0fffd04 	addi	r3,fp,-12
8110d47c:	180d883a 	mov	r6,r3
8110d480:	000b883a 	mov	r5,zero
8110d484:	1009883a 	mov	r4,r2
8110d488:	11393000 	call	81139300 <OSQPend>
8110d48c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d490:	e0bffd03 	ldbu	r2,-12(fp)
8110d494:	10803fcc 	andi	r2,r2,255
8110d498:	1000991e 	bne	r2,zero,8110d700 <vFeeTask+0xcac>
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  RECEBEU COMANDO\n ");
#endif

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110d49c:	e0bffe83 	ldbu	r2,-6(fp)
8110d4a0:	10803fcc 	andi	r2,r2,255
8110d4a4:	108023d8 	cmpnei	r2,r2,143
8110d4a8:	10008f1e 	bne	r2,zero,8110d6e8 <vFeeTask+0xc94>
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  ERA ACESSO AO DMA\n ");
#endif

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110d4ac:	e0fff803 	ldbu	r3,-32(fp)
8110d4b0:	00a045b4 	movhi	r2,33046
8110d4b4:	10b95504 	addi	r2,r2,-6828
8110d4b8:	180690fa 	slli	r3,r3,3
8110d4bc:	10c5883a 	add	r2,r2,r3
8110d4c0:	10800017 	ldw	r2,0(r2)
8110d4c4:	e0fffd04 	addi	r3,fp,-12
8110d4c8:	180d883a 	mov	r6,r3
8110d4cc:	000b883a 	mov	r5,zero
8110d4d0:	1009883a 	mov	r4,r2
8110d4d4:	11381ec0 	call	811381ec <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110d4d8:	e0bffd03 	ldbu	r2,-12(fp)
8110d4dc:	10803fcc 	andi	r2,r2,255
8110d4e0:	1000eb1e 	bne	r2,zero,8110d890 <vFeeTask+0xe3c>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110d4e4:	d0a05117 	ldw	r2,-32444(gp)
8110d4e8:	00c00044 	movi	r3,1
8110d4ec:	10c02215 	stw	r3,136(r2)
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  PEGOU MUTEX DO DMA\n ");
#endif

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI+SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110d4f0:	e0bff917 	ldw	r2,-28(fp)
8110d4f4:	10800117 	ldw	r2,4(r2)
8110d4f8:	10c00404 	addi	r3,r2,16
8110d4fc:	d0a05117 	ldw	r2,-32444(gp)
8110d500:	10800417 	ldw	r2,16(r2)
8110d504:	18801936 	bltu	r3,r2,8110d56c <vFeeTask+0xb18>

		                    		/* todo: Configurar o tamanho do buffer para um numero menor = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI */
		                    		/* todo: Nao esquece porra !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		                    		usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110d508:	d0a05117 	ldw	r2,-32444(gp)
8110d50c:	10800417 	ldw	r2,16(r2)
8110d510:	1007883a 	mov	r3,r2
8110d514:	e0bff917 	ldw	r2,-28(fp)
8110d518:	10800117 	ldw	r2,4(r2)
8110d51c:	1885c83a 	sub	r2,r3,r2
8110d520:	e0bffc8d 	sth	r2,-14(fp)
		                    		pxNFee->xControl.bWatingSync = TRUE;
8110d524:	d0a05117 	ldw	r2,-32444(gp)
8110d528:	00c00044 	movi	r3,1
8110d52c:	10c02815 	stw	r3,160(r2)
		                    		pxNFee->xControl.eMode = sSIMTestFullPattern;
8110d530:	d0a05117 	ldw	r2,-32444(gp)
8110d534:	00c00284 	movi	r3,10
8110d538:	10c02c15 	stw	r3,176(r2)
		                    		pxNFee->xControl.eNextMode = sSIMTestFullPattern;
8110d53c:	d0a05117 	ldw	r2,-32444(gp)
8110d540:	00c00284 	movi	r3,10
8110d544:	10c02d15 	stw	r3,180(r2)
		                    		pxNFee->xControl.bUsingDMA = FALSE;
8110d548:	d0a05117 	ldw	r2,-32444(gp)
8110d54c:	10002315 	stw	zero,140(r2)
		                    		pxNFee->xControl.eMode = sToFeeStandBy; /* todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
8110d550:	d0a05117 	ldw	r2,-32444(gp)
8110d554:	00c00184 	movi	r3,6
8110d558:	10c02c15 	stw	r3,176(r2)
		                    		pxNFee->xControl.eNextMode = sToFeeStandBy; /* todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
8110d55c:	d0a05117 	ldw	r2,-32444(gp)
8110d560:	00c00184 	movi	r3,6
8110d564:	10c02d15 	stw	r3,180(r2)
8110d568:	00000906 	br	8110d590 <vFeeTask+0xb3c>
		                    	} else {
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110d56c:	00800404 	movi	r2,16
8110d570:	e0bffc8d 	sth	r2,-14(fp)
		                    		bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110d574:	d0a05117 	ldw	r2,-32444(gp)
8110d578:	10800003 	ldbu	r2,0(r2)
8110d57c:	10803fcc 	andi	r2,r2,255
8110d580:	100d883a 	mov	r6,r2
8110d584:	000b883a 	mov	r5,zero
8110d588:	01002004 	movi	r4,128
8110d58c:	110df380 	call	8110df38 <bSendRequestNFeeCtrl>
		                    	}

		                    	if ( ucMemUsing == 0  ) {
8110d590:	e0bff803 	ldbu	r2,-32(fp)
8110d594:	10000e1e 	bne	r2,zero,8110d5d0 <vFeeTask+0xb7c>

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d598:	e0bff917 	ldw	r2,-28(fp)
8110d59c:	10800217 	ldw	r2,8(r2)
8110d5a0:	1009883a 	mov	r4,r2
8110d5a4:	d0a05117 	ldw	r2,-32444(gp)
8110d5a8:	10802e17 	ldw	r2,184(r2)
8110d5ac:	10c03fcc 	andi	r3,r2,255
8110d5b0:	d0a05117 	ldw	r2,-32444(gp)
8110d5b4:	10800003 	ldbu	r2,0(r2)
8110d5b8:	10803fcc 	andi	r2,r2,255
8110d5bc:	100f883a 	mov	r7,r2
8110d5c0:	180d883a 	mov	r6,r3
8110d5c4:	01400404 	movi	r5,16
8110d5c8:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110d5cc:	00000d06 	br	8110d604 <vFeeTask+0xbb0>
		                    	} else {

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d5d0:	e0bff917 	ldw	r2,-28(fp)
8110d5d4:	10800217 	ldw	r2,8(r2)
8110d5d8:	1009883a 	mov	r4,r2
8110d5dc:	d0a05117 	ldw	r2,-32444(gp)
8110d5e0:	10802e17 	ldw	r2,184(r2)
8110d5e4:	10c03fcc 	andi	r3,r2,255
8110d5e8:	d0a05117 	ldw	r2,-32444(gp)
8110d5ec:	10800003 	ldbu	r2,0(r2)
8110d5f0:	10803fcc 	andi	r2,r2,255
8110d5f4:	100f883a 	mov	r7,r2
8110d5f8:	180d883a 	mov	r6,r3
8110d5fc:	01400404 	movi	r5,16
8110d600:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
		                    	}


								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */

								xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d604:	e0bff917 	ldw	r2,-28(fp)
8110d608:	10800217 	ldw	r2,8(r2)
8110d60c:	10c22004 	addi	r3,r2,2176
8110d610:	e0bff917 	ldw	r2,-28(fp)
8110d614:	10c00215 	stw	r3,8(r2)
		                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d618:	e0fff803 	ldbu	r3,-32(fp)
8110d61c:	00a045b4 	movhi	r2,33046
8110d620:	10b95504 	addi	r2,r2,-6828
8110d624:	180690fa 	slli	r3,r3,3
8110d628:	10c5883a 	add	r2,r2,r3
8110d62c:	10800017 	ldw	r2,0(r2)
8110d630:	1009883a 	mov	r4,r2
8110d634:	11387900 	call	81138790 <OSMutexPost>
		                        pxNFee->xControl.bDMALocked = FALSE;
8110d638:	d0a05117 	ldw	r2,-32444(gp)
8110d63c:	10002215 	stw	zero,136(r2)
		                        //bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);

		                        incrementador++; // remover !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
8110d640:	d0a05217 	ldw	r2,-32440(gp)
8110d644:	10800044 	addi	r2,r2,1
8110d648:	d0a05215 	stw	r2,-32440(gp)
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  ENVIOU DADOS AO DMA\n ");
#endif
		                        /* Send message talling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110d64c:	d0a05117 	ldw	r2,-32444(gp)
8110d650:	10800003 	ldbu	r2,0(r2)
8110d654:	10803fcc 	andi	r2,r2,255
8110d658:	100d883a 	mov	r6,r2
8110d65c:	000b883a 	mov	r5,zero
8110d660:	01002044 	movi	r4,129
8110d664:	110dfdc0 	call	8110dfdc <bSendGiveBackNFeeCtrl>
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  DEVOLVEU AO CONTROLLER\n ");
#endif

#ifdef DEBUG_ON
	fprintf(fp,"\n    i: %u ",incrementador);
8110d668:	d0a05d17 	ldw	r2,-32396(gp)
8110d66c:	d0e05217 	ldw	r3,-32440(gp)
8110d670:	180d883a 	mov	r6,r3
8110d674:	01604534 	movhi	r5,33044
8110d678:	295fdc04 	addi	r5,r5,32624
8110d67c:	1009883a 	mov	r4,r2
8110d680:	111c11c0 	call	8111c11c <fprintf>
	fprintf(fp,"\nblock: %u ",xCcdMapLocal->ulBlockI);
8110d684:	d0e05d17 	ldw	r3,-32396(gp)
8110d688:	e0bff917 	ldw	r2,-28(fp)
8110d68c:	10800117 	ldw	r2,4(r2)
8110d690:	100d883a 	mov	r6,r2
8110d694:	01604534 	movhi	r5,33044
8110d698:	295fdf04 	addi	r5,r5,32636
8110d69c:	1809883a 	mov	r4,r3
8110d6a0:	111c11c0 	call	8111c11c <fprintf>
	fprintf(fp,"\n  max: %u ",pxNFee->xMemMap.xCommon.usiNTotalBlocks );
8110d6a4:	d0e05d17 	ldw	r3,-32396(gp)
8110d6a8:	d0a05117 	ldw	r2,-32444(gp)
8110d6ac:	10800417 	ldw	r2,16(r2)
8110d6b0:	100d883a 	mov	r6,r2
8110d6b4:	01604534 	movhi	r5,33044
8110d6b8:	295fe204 	addi	r5,r5,32648
8110d6bc:	1809883a 	mov	r4,r3
8110d6c0:	111c11c0 	call	8111c11c <fprintf>
	fprintf(fp,"\nbytes: %u \n",xCcdMapLocal->ulAddrI);
8110d6c4:	d0e05d17 	ldw	r3,-32396(gp)
8110d6c8:	e0bff917 	ldw	r2,-28(fp)
8110d6cc:	10800217 	ldw	r2,8(r2)
8110d6d0:	100d883a 	mov	r6,r2
8110d6d4:	01604534 	movhi	r5,33044
8110d6d8:	295fe504 	addi	r5,r5,32660
8110d6dc:	1809883a 	mov	r4,r3
8110d6e0:	111c11c0 	call	8111c11c <fprintf>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d6e4:	00006a06 	br	8110d890 <vFeeTask+0xe3c>
#endif


                   }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110d6e8:	d0a05117 	ldw	r2,-32444(gp)
8110d6ec:	e0fffe17 	ldw	r3,-8(fp)
8110d6f0:	180b883a 	mov	r5,r3
8110d6f4:	1009883a 	mov	r4,r2
8110d6f8:	110db7c0 	call	8110db7c <vQCmdFEEinFullPattern>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d6fc:	00006406 	br	8110d890 <vFeeTask+0xe3c>
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110d700:	d0e05d17 	ldw	r3,-32396(gp)
8110d704:	d0a05117 	ldw	r2,-32444(gp)
8110d708:	10800003 	ldbu	r2,0(r2)
8110d70c:	10803fcc 	andi	r2,r2,255
8110d710:	100d883a 	mov	r6,r2
8110d714:	01604534 	movhi	r5,33044
8110d718:	295f5104 	addi	r5,r5,32068
8110d71c:	1809883a 	mov	r4,r3
8110d720:	111c11c0 	call	8111c11c <fprintf>
					#endif
				}

				break;
8110d724:	00005a06 	br	8110d890 <vFeeTask+0xe3c>

			case sFeeWaitingSync:

				pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110d728:	d0a05117 	ldw	r2,-32444(gp)
8110d72c:	d0e05117 	ldw	r3,-32444(gp)
8110d730:	18c02d17 	ldw	r3,180(r3)
8110d734:	10c02c15 	stw	r3,176(r2)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xWaitSyncQFee[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d738:	d0a05117 	ldw	r2,-32444(gp)
8110d73c:	10800003 	ldbu	r2,0(r2)
8110d740:	10803fcc 	andi	r2,r2,255
8110d744:	1085883a 	add	r2,r2,r2
8110d748:	1087883a 	add	r3,r2,r2
8110d74c:	d0a05704 	addi	r2,gp,-32420
8110d750:	1885883a 	add	r2,r3,r2
8110d754:	10800017 	ldw	r2,0(r2)
8110d758:	e0fffd04 	addi	r3,fp,-12
8110d75c:	180d883a 	mov	r6,r3
8110d760:	000b883a 	mov	r5,zero
8110d764:	1009883a 	mov	r4,r2
8110d768:	11393000 	call	81139300 <OSQPend>
8110d76c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d770:	e0bffd03 	ldbu	r2,-12(fp)
8110d774:	10803fcc 	andi	r2,r2,255
8110d778:	10002a1e 	bne	r2,zero,8110d824 <vFeeTask+0xdd0>

					/* Write in the RMAP */
					bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d77c:	d0a05117 	ldw	r2,-32444(gp)
8110d780:	10804204 	addi	r2,r2,264
8110d784:	1009883a 	mov	r4,r2
8110d788:	11074f00 	call	811074f0 <bRmapGetMemConfigArea>

					/* UCL- NFEE ICD p. 49 */
					switch ( pxNFee->xControl.eNextMode ) {
8110d78c:	d0a05117 	ldw	r2,-32444(gp)
8110d790:	10802d17 	ldw	r2,180(r2)
8110d794:	10c002e8 	cmpgeui	r3,r2,11
8110d798:	18001c1e 	bne	r3,zero,8110d80c <vFeeTask+0xdb8>
8110d79c:	100690ba 	slli	r3,r2,2
8110d7a0:	00a04474 	movhi	r2,33041
8110d7a4:	10b5ed04 	addi	r2,r2,-10316
8110d7a8:	1885883a 	add	r2,r3,r2
8110d7ac:	10800017 	ldw	r2,0(r2)
8110d7b0:	1000683a 	jmp	r2
8110d7b4:	8110d80c 	andi	r4,r16,17248
8110d7b8:	8110d7e0 	cmpeqi	r4,r16,17247
8110d7bc:	8110d80c 	andi	r4,r16,17248
8110d7c0:	8110d7f0 	cmpltui	r4,r16,17247
8110d7c4:	8110d7fc 	xorhi	r4,r16,17247
8110d7c8:	8110d7e0 	cmpeqi	r4,r16,17247
8110d7cc:	8110d7f0 	cmpltui	r4,r16,17247
8110d7d0:	8110d7fc 	xorhi	r4,r16,17247
8110d7d4:	8110d80c 	andi	r4,r16,17248
8110d7d8:	8110d80c 	andi	r4,r16,17248
8110d7dc:	8110d7fc 	xorhi	r4,r16,17247
						case sToFeeConfig:
						case sFeeConfig:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /* Off-Mode */
8110d7e0:	d0a05117 	ldw	r2,-32444(gp)
8110d7e4:	00c00184 	movi	r3,6
8110d7e8:	10c06515 	stw	r3,404(r2)
							break;
8110d7ec:	00000806 	br	8110d810 <vFeeTask+0xdbc>
						case sFeeStandBy:
						case sToFeeStandBy:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00;
8110d7f0:	d0a05117 	ldw	r2,-32444(gp)
8110d7f4:	10006515 	stw	zero,404(r2)
							break;
8110d7f8:	00000506 	br	8110d810 <vFeeTask+0xdbc>
						case sSIMTestFullPattern:
						case sToTestFullPattern:
						case sFeeTestFullPattern:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02;
8110d7fc:	d0a05117 	ldw	r2,-32444(gp)
8110d800:	00c00084 	movi	r3,2
8110d804:	10c06515 	stw	r3,404(r2)
							break;
8110d808:	00000106 	br	8110d810 <vFeeTask+0xdbc>
						default:
							break;
8110d80c:	0001883a 	nop
					}

					bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d810:	d0a05117 	ldw	r2,-32444(gp)
8110d814:	10804204 	addi	r2,r2,264
8110d818:	1009883a 	mov	r4,r2
8110d81c:	11072040 	call	81107204 <bRmapSetMemConfigArea>
8110d820:	00000906 	br	8110d848 <vFeeTask+0xdf4>

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xWaitSyncQFee\n", pxNFee->ucId);
8110d824:	d0e05d17 	ldw	r3,-32396(gp)
8110d828:	d0a05117 	ldw	r2,-32444(gp)
8110d82c:	10800003 	ldbu	r2,0(r2)
8110d830:	10803fcc 	andi	r2,r2,255
8110d834:	100d883a 	mov	r6,r2
8110d838:	01604534 	movhi	r5,33044
8110d83c:	295fe904 	addi	r5,r5,32676
8110d840:	1809883a 	mov	r4,r3
8110d844:	111c11c0 	call	8111c11c <fprintf>
					#endif
				}

				pxNFee->xControl.bWatingSync = FALSE;
8110d848:	d0a05117 	ldw	r2,-32444(gp)
8110d84c:	10002815 	stw	zero,160(r2)
				break;
8110d850:	00001006 	br	8110d894 <vFeeTask+0xe40>
			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110d854:	d0a05117 	ldw	r2,-32444(gp)
8110d858:	00c00144 	movi	r3,5
8110d85c:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110d860:	d0e05d17 	ldw	r3,-32396(gp)
8110d864:	d0a05117 	ldw	r2,-32444(gp)
8110d868:	10800003 	ldbu	r2,0(r2)
8110d86c:	10803fcc 	andi	r2,r2,255
8110d870:	100d883a 	mov	r6,r2
8110d874:	01604534 	movhi	r5,33044
8110d878:	295ff704 	addi	r5,r5,32732
8110d87c:	1809883a 	mov	r4,r3
8110d880:	111c11c0 	call	8111c11c <fprintf>
				#endif
				break;
8110d884:	00000306 	br	8110d894 <vFeeTask+0xe40>
				break;
			case sSIMFeeStandBy:

				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
8110d888:	0001883a 	nop
8110d88c:	003c8706 	br	8110caac <__reset+0xfb0ecaac>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d890:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110d894:	003c8506 	br	8110caac <__reset+0xfb0ecaac>

8110d898 <vQCmdFEEinConfig>:

}


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110d898:	defffb04 	addi	sp,sp,-20
8110d89c:	de00012e 	bgeu	sp,et,8110d8a4 <vQCmdFEEinConfig+0xc>
8110d8a0:	003b68fa 	trap	3
8110d8a4:	dfc00415 	stw	ra,16(sp)
8110d8a8:	df000315 	stw	fp,12(sp)
8110d8ac:	df000304 	addi	fp,sp,12
8110d8b0:	e13ffe15 	stw	r4,-8(fp)
8110d8b4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110d8b8:	e0bfff17 	ldw	r2,-4(fp)
8110d8bc:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110d8c0:	e0bffdc3 	ldbu	r2,-9(fp)
8110d8c4:	10c03fcc 	andi	r3,r2,255
8110d8c8:	e0bffe17 	ldw	r2,-8(fp)
8110d8cc:	10800003 	ldbu	r2,0(r2)
8110d8d0:	10803fcc 	andi	r2,r2,255
8110d8d4:	10800444 	addi	r2,r2,17
8110d8d8:	1880451e 	bne	r3,r2,8110d9f0 <vQCmdFEEinConfig+0x158>

		switch (uiCmdFEEL.ucByte[2]) {
8110d8dc:	e0bffd83 	ldbu	r2,-10(fp)
8110d8e0:	10803fcc 	andi	r2,r2,255
8110d8e4:	10c00220 	cmpeqi	r3,r2,8
8110d8e8:	18002c1e 	bne	r3,zero,8110d99c <vQCmdFEEinConfig+0x104>
8110d8ec:	10c00248 	cmpgei	r3,r2,9
8110d8f0:	1800071e 	bne	r3,zero,8110d910 <vQCmdFEEinConfig+0x78>
8110d8f4:	10c000a0 	cmpeqi	r3,r2,2
8110d8f8:	18003c1e 	bne	r3,zero,8110d9ec <vQCmdFEEinConfig+0x154>
8110d8fc:	10c00120 	cmpeqi	r3,r2,4
8110d900:	1800131e 	bne	r3,zero,8110d950 <vQCmdFEEinConfig+0xb8>
8110d904:	10800060 	cmpeqi	r2,r2,1
8110d908:	1000071e 	bne	r2,zero,8110d928 <vQCmdFEEinConfig+0x90>
8110d90c:	00002d06 	br	8110d9c4 <vQCmdFEEinConfig+0x12c>
8110d910:	10c02920 	cmpeqi	r3,r2,164
8110d914:	1800181e 	bne	r3,zero,8110d978 <vQCmdFEEinConfig+0xe0>
8110d918:	10c02a20 	cmpeqi	r3,r2,168
8110d91c:	18001f1e 	bne	r3,zero,8110d99c <vQCmdFEEinConfig+0x104>
8110d920:	10802860 	cmpeqi	r2,r2,161
8110d924:	10002726 	beq	r2,zero,8110d9c4 <vQCmdFEEinConfig+0x12c>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110d928:	d0e05d17 	ldw	r3,-32396(gp)
8110d92c:	e0bffe17 	ldw	r2,-8(fp)
8110d930:	10800003 	ldbu	r2,0(r2)
8110d934:	10803fcc 	andi	r2,r2,255
8110d938:	100d883a 	mov	r6,r2
8110d93c:	01604574 	movhi	r5,33045
8110d940:	29600204 	addi	r5,r5,-32760
8110d944:	1809883a 	mov	r4,r3
8110d948:	111c11c0 	call	8111c11c <fprintf>
				#endif
				break;
8110d94c:	00002806 	br	8110d9f0 <vQCmdFEEinConfig+0x158>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d950:	e0bffe17 	ldw	r2,-8(fp)
8110d954:	00c00044 	movi	r3,1
8110d958:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d95c:	e0bffe17 	ldw	r2,-8(fp)
8110d960:	00c002c4 	movi	r3,11
8110d964:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d968:	e0bffe17 	ldw	r2,-8(fp)
8110d96c:	00c00184 	movi	r3,6
8110d970:	10c02d15 	stw	r3,180(r2)
				break;
8110d974:	00001e06 	br	8110d9f0 <vQCmdFEEinConfig+0x158>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d978:	e0bffe17 	ldw	r2,-8(fp)
8110d97c:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110d980:	e0bffe17 	ldw	r2,-8(fp)
8110d984:	00c00184 	movi	r3,6
8110d988:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d98c:	e0bffe17 	ldw	r2,-8(fp)
8110d990:	00c00184 	movi	r3,6
8110d994:	10c02d15 	stw	r3,180(r2)
				break;				
8110d998:	00001506 	br	8110d9f0 <vQCmdFEEinConfig+0x158>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110d99c:	d0e05d17 	ldw	r3,-32396(gp)
8110d9a0:	e0bffe17 	ldw	r2,-8(fp)
8110d9a4:	10800003 	ldbu	r2,0(r2)
8110d9a8:	10803fcc 	andi	r2,r2,255
8110d9ac:	100d883a 	mov	r6,r2
8110d9b0:	01604574 	movhi	r5,33045
8110d9b4:	29600d04 	addi	r5,r5,-32716
8110d9b8:	1809883a 	mov	r4,r3
8110d9bc:	111c11c0 	call	8111c11c <fprintf>
				#endif
				break;											
8110d9c0:	00000b06 	br	8110d9f0 <vQCmdFEEinConfig+0x158>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110d9c4:	d0e05d17 	ldw	r3,-32396(gp)
8110d9c8:	e0bffe17 	ldw	r2,-8(fp)
8110d9cc:	10800003 	ldbu	r2,0(r2)
8110d9d0:	10803fcc 	andi	r2,r2,255
8110d9d4:	100d883a 	mov	r6,r2
8110d9d8:	01604574 	movhi	r5,33045
8110d9dc:	29601e04 	addi	r5,r5,-32648
8110d9e0:	1809883a 	mov	r4,r3
8110d9e4:	111c11c0 	call	8111c11c <fprintf>
				#endif
				break;
8110d9e8:	00000106 	br	8110d9f0 <vQCmdFEEinConfig+0x158>
				break;
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110d9ec:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d9f0:	0001883a 	nop
8110d9f4:	e037883a 	mov	sp,fp
8110d9f8:	dfc00117 	ldw	ra,4(sp)
8110d9fc:	df000017 	ldw	fp,0(sp)
8110da00:	dec00204 	addi	sp,sp,8
8110da04:	f800283a 	ret

8110da08 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110da08:	defffb04 	addi	sp,sp,-20
8110da0c:	de00012e 	bgeu	sp,et,8110da14 <vQCmdFEEinStandBy+0xc>
8110da10:	003b68fa 	trap	3
8110da14:	dfc00415 	stw	ra,16(sp)
8110da18:	df000315 	stw	fp,12(sp)
8110da1c:	df000304 	addi	fp,sp,12
8110da20:	e13ffe15 	stw	r4,-8(fp)
8110da24:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110da28:	e0bfff17 	ldw	r2,-4(fp)
8110da2c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110da30:	e0bffdc3 	ldbu	r2,-9(fp)
8110da34:	10c03fcc 	andi	r3,r2,255
8110da38:	e0bffe17 	ldw	r2,-8(fp)
8110da3c:	10800003 	ldbu	r2,0(r2)
8110da40:	10803fcc 	andi	r2,r2,255
8110da44:	10800444 	addi	r2,r2,17
8110da48:	1880461e 	bne	r3,r2,8110db64 <vQCmdFEEinStandBy+0x15c>

		switch (uiCmdFEEL.ucByte[2]) {
8110da4c:	e0bffd83 	ldbu	r2,-10(fp)
8110da50:	10803fcc 	andi	r2,r2,255
8110da54:	10c00220 	cmpeqi	r3,r2,8
8110da58:	18002d1e 	bne	r3,zero,8110db10 <vQCmdFEEinStandBy+0x108>
8110da5c:	10c00248 	cmpgei	r3,r2,9
8110da60:	1800071e 	bne	r3,zero,8110da80 <vQCmdFEEinStandBy+0x78>
8110da64:	10c000a0 	cmpeqi	r3,r2,2
8110da68:	18003d1e 	bne	r3,zero,8110db60 <vQCmdFEEinStandBy+0x158>
8110da6c:	10c00120 	cmpeqi	r3,r2,4
8110da70:	18001d1e 	bne	r3,zero,8110dae8 <vQCmdFEEinStandBy+0xe0>
8110da74:	10800060 	cmpeqi	r2,r2,1
8110da78:	1000081e 	bne	r2,zero,8110da9c <vQCmdFEEinStandBy+0x94>
8110da7c:	00002e06 	br	8110db38 <vQCmdFEEinStandBy+0x130>
8110da80:	10c02920 	cmpeqi	r3,r2,164
8110da84:	1800181e 	bne	r3,zero,8110dae8 <vQCmdFEEinStandBy+0xe0>
8110da88:	10c02a20 	cmpeqi	r3,r2,168
8110da8c:	1800201e 	bne	r3,zero,8110db10 <vQCmdFEEinStandBy+0x108>
8110da90:	10802860 	cmpeqi	r2,r2,161
8110da94:	10000b1e 	bne	r2,zero,8110dac4 <vQCmdFEEinStandBy+0xbc>
8110da98:	00002706 	br	8110db38 <vQCmdFEEinStandBy+0x130>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110da9c:	e0bffe17 	ldw	r2,-8(fp)
8110daa0:	00c00044 	movi	r3,1
8110daa4:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110daa8:	e0bffe17 	ldw	r2,-8(fp)
8110daac:	00c002c4 	movi	r3,11
8110dab0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110dab4:	e0bffe17 	ldw	r2,-8(fp)
8110dab8:	00c00144 	movi	r3,5
8110dabc:	10c02d15 	stw	r3,180(r2)
				break;
8110dac0:	00002806 	br	8110db64 <vQCmdFEEinStandBy+0x15c>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110dac4:	e0bffe17 	ldw	r2,-8(fp)
8110dac8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110dacc:	e0bffe17 	ldw	r2,-8(fp)
8110dad0:	00c00144 	movi	r3,5
8110dad4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110dad8:	e0bffe17 	ldw	r2,-8(fp)
8110dadc:	00c00144 	movi	r3,5
8110dae0:	10c02d15 	stw	r3,180(r2)
				break;				
8110dae4:	00001f06 	br	8110db64 <vQCmdFEEinStandBy+0x15c>
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110dae8:	d0e05d17 	ldw	r3,-32396(gp)
8110daec:	e0bffe17 	ldw	r2,-8(fp)
8110daf0:	10800003 	ldbu	r2,0(r2)
8110daf4:	10803fcc 	andi	r2,r2,255
8110daf8:	100d883a 	mov	r6,r2
8110dafc:	01604574 	movhi	r5,33045
8110db00:	29602f04 	addi	r5,r5,-32580
8110db04:	1809883a 	mov	r4,r3
8110db08:	111c11c0 	call	8111c11c <fprintf>
				#endif
				break;
8110db0c:	00001506 	br	8110db64 <vQCmdFEEinStandBy+0x15c>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110db10:	e0bffe17 	ldw	r2,-8(fp)
8110db14:	00c00044 	movi	r3,1
8110db18:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sSIMTestFullPattern; /*sSIMTestFullPattern*/
8110db1c:	e0bffe17 	ldw	r2,-8(fp)
8110db20:	00c00284 	movi	r3,10
8110db24:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sSIMTestFullPattern;
8110db28:	e0bffe17 	ldw	r2,-8(fp)
8110db2c:	00c00284 	movi	r3,10
8110db30:	10c02d15 	stw	r3,180(r2)
				break;				
8110db34:	00000b06 	br	8110db64 <vQCmdFEEinStandBy+0x15c>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110db38:	d0e05d17 	ldw	r3,-32396(gp)
8110db3c:	e0bffe17 	ldw	r2,-8(fp)
8110db40:	10800003 	ldbu	r2,0(r2)
8110db44:	10803fcc 	andi	r2,r2,255
8110db48:	100d883a 	mov	r6,r2
8110db4c:	01604574 	movhi	r5,33045
8110db50:	29603a04 	addi	r5,r5,-32536
8110db54:	1809883a 	mov	r4,r3
8110db58:	111c11c0 	call	8111c11c <fprintf>
				#endif
				break;
8110db5c:	00000106 	br	8110db64 <vQCmdFEEinStandBy+0x15c>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110db60:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110db64:	0001883a 	nop
8110db68:	e037883a 	mov	sp,fp
8110db6c:	dfc00117 	ldw	ra,4(sp)
8110db70:	df000017 	ldw	fp,0(sp)
8110db74:	dec00204 	addi	sp,sp,8
8110db78:	f800283a 	ret

8110db7c <vQCmdFEEinFullPattern>:

void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110db7c:	defffb04 	addi	sp,sp,-20
8110db80:	de00012e 	bgeu	sp,et,8110db88 <vQCmdFEEinFullPattern+0xc>
8110db84:	003b68fa 	trap	3
8110db88:	dfc00415 	stw	ra,16(sp)
8110db8c:	df000315 	stw	fp,12(sp)
8110db90:	df000304 	addi	fp,sp,12
8110db94:	e13ffe15 	stw	r4,-8(fp)
8110db98:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110db9c:	e0bfff17 	ldw	r2,-4(fp)
8110dba0:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110dba4:	e0bffdc3 	ldbu	r2,-9(fp)
8110dba8:	10c03fcc 	andi	r3,r2,255
8110dbac:	e0bffe17 	ldw	r2,-8(fp)
8110dbb0:	10800003 	ldbu	r2,0(r2)
8110dbb4:	10803fcc 	andi	r2,r2,255
8110dbb8:	10800444 	addi	r2,r2,17
8110dbbc:	18804d1e 	bne	r3,r2,8110dcf4 <vQCmdFEEinFullPattern+0x178>

		switch (uiCmdFEEL.ucByte[2]) {
8110dbc0:	e0bffd83 	ldbu	r2,-10(fp)
8110dbc4:	10803fcc 	andi	r2,r2,255
8110dbc8:	10c00120 	cmpeqi	r3,r2,4
8110dbcc:	1800211e 	bne	r3,zero,8110dc54 <vQCmdFEEinFullPattern+0xd8>
8110dbd0:	10c00148 	cmpgei	r3,r2,5
8110dbd4:	1800051e 	bne	r3,zero,8110dbec <vQCmdFEEinFullPattern+0x70>
8110dbd8:	10c00060 	cmpeqi	r3,r2,1
8110dbdc:	18000a1e 	bne	r3,zero,8110dc08 <vQCmdFEEinFullPattern+0x8c>
8110dbe0:	108000a0 	cmpeqi	r2,r2,2
8110dbe4:	1000421e 	bne	r2,zero,8110dcf0 <vQCmdFEEinFullPattern+0x174>
8110dbe8:	00003706 	br	8110dcc8 <vQCmdFEEinFullPattern+0x14c>
8110dbec:	10c02860 	cmpeqi	r3,r2,161
8110dbf0:	18000f1e 	bne	r3,zero,8110dc30 <vQCmdFEEinFullPattern+0xb4>
8110dbf4:	10c02920 	cmpeqi	r3,r2,164
8110dbf8:	1800201e 	bne	r3,zero,8110dc7c <vQCmdFEEinFullPattern+0x100>
8110dbfc:	10800220 	cmpeqi	r2,r2,8
8110dc00:	1000271e 	bne	r2,zero,8110dca0 <vQCmdFEEinFullPattern+0x124>
8110dc04:	00003006 	br	8110dcc8 <vQCmdFEEinFullPattern+0x14c>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110dc08:	e0bffe17 	ldw	r2,-8(fp)
8110dc0c:	00c00044 	movi	r3,1
8110dc10:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110dc14:	e0bffe17 	ldw	r2,-8(fp)
8110dc18:	00c002c4 	movi	r3,11
8110dc1c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110dc20:	e0bffe17 	ldw	r2,-8(fp)
8110dc24:	00c00144 	movi	r3,5
8110dc28:	10c02d15 	stw	r3,180(r2)
				break;
8110dc2c:	00003106 	br	8110dcf4 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110dc30:	e0bffe17 	ldw	r2,-8(fp)
8110dc34:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110dc38:	e0bffe17 	ldw	r2,-8(fp)
8110dc3c:	00c00144 	movi	r3,5
8110dc40:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110dc44:	e0bffe17 	ldw	r2,-8(fp)
8110dc48:	00c00144 	movi	r3,5
8110dc4c:	10c02d15 	stw	r3,180(r2)
				break;				
8110dc50:	00002806 	br	8110dcf4 <vQCmdFEEinFullPattern+0x178>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110dc54:	e0bffe17 	ldw	r2,-8(fp)
8110dc58:	00c00044 	movi	r3,1
8110dc5c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110dc60:	e0bffe17 	ldw	r2,-8(fp)
8110dc64:	00c002c4 	movi	r3,11
8110dc68:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110dc6c:	e0bffe17 	ldw	r2,-8(fp)
8110dc70:	00c00184 	movi	r3,6
8110dc74:	10c02d15 	stw	r3,180(r2)
				break;
8110dc78:	00001e06 	br	8110dcf4 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110dc7c:	e0bffe17 	ldw	r2,-8(fp)
8110dc80:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110dc84:	e0bffe17 	ldw	r2,-8(fp)
8110dc88:	00c00184 	movi	r3,6
8110dc8c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110dc90:	e0bffe17 	ldw	r2,-8(fp)
8110dc94:	00c00184 	movi	r3,6
8110dc98:	10c02d15 	stw	r3,180(r2)
				break;				
8110dc9c:	00001506 	br	8110dcf4 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110dca0:	d0e05d17 	ldw	r3,-32396(gp)
8110dca4:	e0bffe17 	ldw	r2,-8(fp)
8110dca8:	10800003 	ldbu	r2,0(r2)
8110dcac:	10803fcc 	andi	r2,r2,255
8110dcb0:	100d883a 	mov	r6,r2
8110dcb4:	01604574 	movhi	r5,33045
8110dcb8:	29604b04 	addi	r5,r5,-32468
8110dcbc:	1809883a 	mov	r4,r3
8110dcc0:	111c11c0 	call	8111c11c <fprintf>
				#endif
				break;
8110dcc4:	00000b06 	br	8110dcf4 <vQCmdFEEinFullPattern+0x178>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110dcc8:	d0e05d17 	ldw	r3,-32396(gp)
8110dccc:	e0bffe17 	ldw	r2,-8(fp)
8110dcd0:	10800003 	ldbu	r2,0(r2)
8110dcd4:	10803fcc 	andi	r2,r2,255
8110dcd8:	100d883a 	mov	r6,r2
8110dcdc:	01604574 	movhi	r5,33045
8110dce0:	29601e04 	addi	r5,r5,-32648
8110dce4:	1809883a 	mov	r4,r3
8110dce8:	111c11c0 	call	8111c11c <fprintf>
				#endif
				break;
8110dcec:	00000106 	br	8110dcf4 <vQCmdFEEinFullPattern+0x178>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110dcf0:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110dcf4:	0001883a 	nop
8110dcf8:	e037883a 	mov	sp,fp
8110dcfc:	dfc00117 	ldw	ra,4(sp)
8110dd00:	df000017 	ldw	fp,0(sp)
8110dd04:	dec00204 	addi	sp,sp,8
8110dd08:	f800283a 	ret

8110dd0c <bDisableRmapIRQ>:

bool bDisableRmapIRQ( TRmapChannel *pxRmapCh ) {
8110dd0c:	defffd04 	addi	sp,sp,-12
8110dd10:	de00012e 	bgeu	sp,et,8110dd18 <bDisableRmapIRQ+0xc>
8110dd14:	003b68fa 	trap	3
8110dd18:	dfc00215 	stw	ra,8(sp)
8110dd1c:	df000115 	stw	fp,4(sp)
8110dd20:	df000104 	addi	fp,sp,4
8110dd24:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bRmapGetIrqControl(pxRmapCh);
8110dd28:	e13fff17 	ldw	r4,-4(fp)
8110dd2c:	1106cd00 	call	81106cd0 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8110dd30:	e0bfff17 	ldw	r2,-4(fp)
8110dd34:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110dd38:	e13fff17 	ldw	r4,-4(fp)
8110dd3c:	1106c280 	call	81106c28 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110dd40:	00800044 	movi	r2,1
}
8110dd44:	e037883a 	mov	sp,fp
8110dd48:	dfc00117 	ldw	ra,4(sp)
8110dd4c:	df000017 	ldw	fp,0(sp)
8110dd50:	dec00204 	addi	sp,sp,8
8110dd54:	f800283a 	ret

8110dd58 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh ) {
8110dd58:	defffd04 	addi	sp,sp,-12
8110dd5c:	de00012e 	bgeu	sp,et,8110dd64 <bEnableRmapIRQ+0xc>
8110dd60:	003b68fa 	trap	3
8110dd64:	dfc00215 	stw	ra,8(sp)
8110dd68:	df000115 	stw	fp,4(sp)
8110dd6c:	df000104 	addi	fp,sp,4
8110dd70:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bRmapGetIrqControl(pxRmapCh);
8110dd74:	e13fff17 	ldw	r4,-4(fp)
8110dd78:	1106cd00 	call	81106cd0 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8110dd7c:	e0bfff17 	ldw	r2,-4(fp)
8110dd80:	00c00044 	movi	r3,1
8110dd84:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110dd88:	e13fff17 	ldw	r4,-4(fp)
8110dd8c:	1106c280 	call	81106c28 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110dd90:	00800044 	movi	r2,1
}
8110dd94:	e037883a 	mov	sp,fp
8110dd98:	dfc00117 	ldw	ra,4(sp)
8110dd9c:	df000017 	ldw	fp,0(sp)
8110dda0:	dec00204 	addi	sp,sp,8
8110dda4:	f800283a 	ret

8110dda8 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
8110dda8:	defffd04 	addi	sp,sp,-12
8110ddac:	de00012e 	bgeu	sp,et,8110ddb4 <bDisableSPWChannel+0xc>
8110ddb0:	003b68fa 	trap	3
8110ddb4:	dfc00215 	stw	ra,8(sp)
8110ddb8:	df000115 	stw	fp,4(sp)
8110ddbc:	df000104 	addi	fp,sp,4
8110ddc0:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
8110ddc4:	e13fff17 	ldw	r4,-4(fp)
8110ddc8:	11092540 	call	81109254 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110ddcc:	e0bfff17 	ldw	r2,-4(fp)
8110ddd0:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
8110ddd4:	e0bfff17 	ldw	r2,-4(fp)
8110ddd8:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8110dddc:	e0bfff17 	ldw	r2,-4(fp)
8110dde0:	00c00044 	movi	r3,1
8110dde4:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8110dde8:	e13fff17 	ldw	r4,-4(fp)
8110ddec:	11091200 	call	81109120 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110ddf0:	00800044 	movi	r2,1
}
8110ddf4:	e037883a 	mov	sp,fp
8110ddf8:	dfc00117 	ldw	ra,4(sp)
8110ddfc:	df000017 	ldw	fp,0(sp)
8110de00:	dec00204 	addi	sp,sp,8
8110de04:	f800283a 	ret

8110de08 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
8110de08:	defffd04 	addi	sp,sp,-12
8110de0c:	de00012e 	bgeu	sp,et,8110de14 <bEnableSPWChannel+0xc>
8110de10:	003b68fa 	trap	3
8110de14:	dfc00215 	stw	ra,8(sp)
8110de18:	df000115 	stw	fp,4(sp)
8110de1c:	df000104 	addi	fp,sp,4
8110de20:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
8110de24:	e13fff17 	ldw	r4,-4(fp)
8110de28:	11092540 	call	81109254 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110de2c:	e0bfff17 	ldw	r2,-4(fp)
8110de30:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
8110de34:	e0bfff17 	ldw	r2,-4(fp)
8110de38:	00c00044 	movi	r3,1
8110de3c:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
8110de40:	e0bfff17 	ldw	r2,-4(fp)
8110de44:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
8110de48:	e13fff17 	ldw	r4,-4(fp)
8110de4c:	11091200 	call	81109120 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110de50:	00800044 	movi	r2,1
}
8110de54:	e037883a 	mov	sp,fp
8110de58:	dfc00117 	ldw	ra,4(sp)
8110de5c:	df000017 	ldw	fp,0(sp)
8110de60:	dec00204 	addi	sp,sp,8
8110de64:	f800283a 	ret

8110de68 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
8110de68:	defffd04 	addi	sp,sp,-12
8110de6c:	de00012e 	bgeu	sp,et,8110de74 <bEnableDbBuffer+0xc>
8110de70:	003b68fa 	trap	3
8110de74:	dfc00215 	stw	ra,8(sp)
8110de78:	df000115 	stw	fp,4(sp)
8110de7c:	df000104 	addi	fp,sp,4
8110de80:	e13fff15 	stw	r4,-4(fp)

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110de84:	e13fff17 	ldw	r4,-4(fp)
8110de88:	1105e9c0 	call	81105e9c <bFeebClrCh>

	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
8110de8c:	e13fff17 	ldw	r4,-4(fp)
8110de90:	1105d8c0 	call	81105d8c <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110de94:	e13fff17 	ldw	r4,-4(fp)
8110de98:	1105a7c0 	call	81105a7c <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8110de9c:	e0bfff17 	ldw	r2,-4(fp)
8110dea0:	00c00044 	movi	r3,1
8110dea4:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110dea8:	e0bfff17 	ldw	r2,-4(fp)
8110deac:	00c00044 	movi	r3,1
8110deb0:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110deb4:	e13fff17 	ldw	r4,-4(fp)
8110deb8:	11059a80 	call	811059a8 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110debc:	00800044 	movi	r2,1
}
8110dec0:	e037883a 	mov	sp,fp
8110dec4:	dfc00117 	ldw	ra,4(sp)
8110dec8:	df000017 	ldw	fp,0(sp)
8110decc:	dec00204 	addi	sp,sp,8
8110ded0:	f800283a 	ret

8110ded4 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8110ded4:	defffd04 	addi	sp,sp,-12
8110ded8:	de00012e 	bgeu	sp,et,8110dee0 <bDisAndClrDbBuffer+0xc>
8110dedc:	003b68fa 	trap	3
8110dee0:	dfc00215 	stw	ra,8(sp)
8110dee4:	df000115 	stw	fp,4(sp)
8110dee8:	df000104 	addi	fp,sp,4
8110deec:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110def0:	e13fff17 	ldw	r4,-4(fp)
8110def4:	1105a7c0 	call	81105a7c <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8110def8:	e0bfff17 	ldw	r2,-4(fp)
8110defc:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110df00:	e0bfff17 	ldw	r2,-4(fp)
8110df04:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110df08:	e13fff17 	ldw	r4,-4(fp)
8110df0c:	11059a80 	call	811059a8 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8110df10:	e13fff17 	ldw	r4,-4(fp)
8110df14:	1105e140 	call	81105e14 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110df18:	e13fff17 	ldw	r4,-4(fp)
8110df1c:	1105e9c0 	call	81105e9c <bFeebClrCh>

	/*todo: No treatment for now  */
	return TRUE;
8110df20:	00800044 	movi	r2,1
}
8110df24:	e037883a 	mov	sp,fp
8110df28:	dfc00117 	ldw	ra,4(sp)
8110df2c:	df000017 	ldw	fp,0(sp)
8110df30:	dec00204 	addi	sp,sp,8
8110df34:	f800283a 	ret

8110df38 <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110df38:	defff804 	addi	sp,sp,-32
8110df3c:	de00012e 	bgeu	sp,et,8110df44 <bSendRequestNFeeCtrl+0xc>
8110df40:	003b68fa 	trap	3
8110df44:	dfc00715 	stw	ra,28(sp)
8110df48:	df000615 	stw	fp,24(sp)
8110df4c:	df000604 	addi	fp,sp,24
8110df50:	2807883a 	mov	r3,r5
8110df54:	3005883a 	mov	r2,r6
8110df58:	e13ffd05 	stb	r4,-12(fp)
8110df5c:	e0fffe05 	stb	r3,-8(fp)
8110df60:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110df64:	00800404 	movi	r2,16
8110df68:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110df6c:	e0bffd03 	ldbu	r2,-12(fp)
8110df70:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110df74:	e0bffe03 	ldbu	r2,-8(fp)
8110df78:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110df7c:	e0bfff03 	ldbu	r2,-4(fp)
8110df80:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110df84:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110df88:	d0a05817 	ldw	r2,-32416(gp)
8110df8c:	e0fffc17 	ldw	r3,-16(fp)
8110df90:	180b883a 	mov	r5,r3
8110df94:	1009883a 	mov	r4,r2
8110df98:	11397080 	call	81139708 <OSQPost>
8110df9c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110dfa0:	e0bffb03 	ldbu	r2,-20(fp)
8110dfa4:	10000526 	beq	r2,zero,8110dfbc <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110dfa8:	e0bfff03 	ldbu	r2,-4(fp)
8110dfac:	1009883a 	mov	r4,r2
8110dfb0:	1118d500 	call	81118d50 <vFailRequestDMA>
		bSuccesL = FALSE;
8110dfb4:	e03ffa15 	stw	zero,-24(fp)
8110dfb8:	00000206 	br	8110dfc4 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110dfbc:	00800044 	movi	r2,1
8110dfc0:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110dfc4:	e0bffa17 	ldw	r2,-24(fp)
}
8110dfc8:	e037883a 	mov	sp,fp
8110dfcc:	dfc00117 	ldw	ra,4(sp)
8110dfd0:	df000017 	ldw	fp,0(sp)
8110dfd4:	dec00204 	addi	sp,sp,8
8110dfd8:	f800283a 	ret

8110dfdc <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110dfdc:	defff804 	addi	sp,sp,-32
8110dfe0:	de00012e 	bgeu	sp,et,8110dfe8 <bSendGiveBackNFeeCtrl+0xc>
8110dfe4:	003b68fa 	trap	3
8110dfe8:	dfc00715 	stw	ra,28(sp)
8110dfec:	df000615 	stw	fp,24(sp)
8110dff0:	df000604 	addi	fp,sp,24
8110dff4:	2807883a 	mov	r3,r5
8110dff8:	3005883a 	mov	r2,r6
8110dffc:	e13ffd05 	stb	r4,-12(fp)
8110e000:	e0fffe05 	stb	r3,-8(fp)
8110e004:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110e008:	00800404 	movi	r2,16
8110e00c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110e010:	e0bffd03 	ldbu	r2,-12(fp)
8110e014:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110e018:	e0bffe03 	ldbu	r2,-8(fp)
8110e01c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110e020:	e0bfff03 	ldbu	r2,-4(fp)
8110e024:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110e028:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8110e02c:	d0a06b17 	ldw	r2,-32340(gp)
8110e030:	e0fffc17 	ldw	r3,-16(fp)
8110e034:	180b883a 	mov	r5,r3
8110e038:	1009883a 	mov	r4,r2
8110e03c:	11397080 	call	81139708 <OSQPost>
8110e040:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110e044:	e0bffb03 	ldbu	r2,-20(fp)
8110e048:	10000526 	beq	r2,zero,8110e060 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110e04c:	e0bfff03 	ldbu	r2,-4(fp)
8110e050:	1009883a 	mov	r4,r2
8110e054:	1118d500 	call	81118d50 <vFailRequestDMA>
		bSuccesL = FALSE;
8110e058:	e03ffa15 	stw	zero,-24(fp)
8110e05c:	00000206 	br	8110e068 <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110e060:	00800044 	movi	r2,1
8110e064:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110e068:	e0bffa17 	ldw	r2,-24(fp)
}
8110e06c:	e037883a 	mov	sp,fp
8110e070:	dfc00117 	ldw	ra,4(sp)
8110e074:	df000017 	ldw	fp,0(sp)
8110e078:	dec00204 	addi	sp,sp,8
8110e07c:	f800283a 	ret

8110e080 <vPrintConsoleNFee>:


#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
8110e080:	defffa04 	addi	sp,sp,-24
8110e084:	de00012e 	bgeu	sp,et,8110e08c <vPrintConsoleNFee+0xc>
8110e088:	003b68fa 	trap	3
8110e08c:	dfc00515 	stw	ra,20(sp)
8110e090:	df000415 	stw	fp,16(sp)
8110e094:	df000404 	addi	fp,sp,16
8110e098:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
8110e09c:	e0bfff17 	ldw	r2,-4(fp)
8110e0a0:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
8110e0a4:	d0e05d17 	ldw	r3,-32396(gp)
8110e0a8:	e0bffe17 	ldw	r2,-8(fp)
8110e0ac:	10800003 	ldbu	r2,0(r2)
8110e0b0:	10803fcc 	andi	r2,r2,255
8110e0b4:	100d883a 	mov	r6,r2
8110e0b8:	01604574 	movhi	r5,33045
8110e0bc:	29605904 	addi	r5,r5,-32412
8110e0c0:	1809883a 	mov	r4,r3
8110e0c4:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"\n");
8110e0c8:	d0a05d17 	ldw	r2,-32396(gp)
8110e0cc:	100b883a 	mov	r5,r2
8110e0d0:	01000284 	movi	r4,10
8110e0d4:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
8110e0d8:	d0e05d17 	ldw	r3,-32396(gp)
8110e0dc:	e0bffe17 	ldw	r2,-8(fp)
8110e0e0:	10800003 	ldbu	r2,0(r2)
8110e0e4:	10803fcc 	andi	r2,r2,255
8110e0e8:	100d883a 	mov	r6,r2
8110e0ec:	01604574 	movhi	r5,33045
8110e0f0:	29606e04 	addi	r5,r5,-32328
8110e0f4:	1809883a 	mov	r4,r3
8110e0f8:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
8110e0fc:	d0e05d17 	ldw	r3,-32396(gp)
8110e100:	e0bffe17 	ldw	r2,-8(fp)
8110e104:	10802f0b 	ldhu	r2,188(r2)
8110e108:	10bfffcc 	andi	r2,r2,65535
8110e10c:	100d883a 	mov	r6,r2
8110e110:	01604574 	movhi	r5,33045
8110e114:	29607404 	addi	r5,r5,-32304
8110e118:	1809883a 	mov	r4,r3
8110e11c:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
8110e120:	d0e05d17 	ldw	r3,-32396(gp)
8110e124:	e0bffe17 	ldw	r2,-8(fp)
8110e128:	10802f8b 	ldhu	r2,190(r2)
8110e12c:	10bfffcc 	andi	r2,r2,65535
8110e130:	100d883a 	mov	r6,r2
8110e134:	01604574 	movhi	r5,33045
8110e138:	29607904 	addi	r5,r5,-32284
8110e13c:	1809883a 	mov	r4,r3
8110e140:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
8110e144:	d0e05d17 	ldw	r3,-32396(gp)
8110e148:	e0bffe17 	ldw	r2,-8(fp)
8110e14c:	1080300b 	ldhu	r2,192(r2)
8110e150:	10bfffcc 	andi	r2,r2,65535
8110e154:	100d883a 	mov	r6,r2
8110e158:	01604574 	movhi	r5,33045
8110e15c:	29607f04 	addi	r5,r5,-32260
8110e160:	1809883a 	mov	r4,r3
8110e164:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8110e168:	d0e05d17 	ldw	r3,-32396(gp)
8110e16c:	e0bffe17 	ldw	r2,-8(fp)
8110e170:	1080308b 	ldhu	r2,194(r2)
8110e174:	10bfffcc 	andi	r2,r2,65535
8110e178:	100d883a 	mov	r6,r2
8110e17c:	01604574 	movhi	r5,33045
8110e180:	29608304 	addi	r5,r5,-32244
8110e184:	1809883a 	mov	r4,r3
8110e188:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
8110e18c:	d0e05d17 	ldw	r3,-32396(gp)
8110e190:	e0bffe17 	ldw	r2,-8(fp)
8110e194:	1080310b 	ldhu	r2,196(r2)
8110e198:	10bfffcc 	andi	r2,r2,65535
8110e19c:	100d883a 	mov	r6,r2
8110e1a0:	01604574 	movhi	r5,33045
8110e1a4:	29608904 	addi	r5,r5,-32220
8110e1a8:	1809883a 	mov	r4,r3
8110e1ac:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"\n");
8110e1b0:	d0a05d17 	ldw	r2,-32396(gp)
8110e1b4:	100b883a 	mov	r5,r2
8110e1b8:	01000284 	movi	r4,10
8110e1bc:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
8110e1c0:	d0e05d17 	ldw	r3,-32396(gp)
8110e1c4:	e0bffe17 	ldw	r2,-8(fp)
8110e1c8:	10800003 	ldbu	r2,0(r2)
8110e1cc:	10803fcc 	andi	r2,r2,255
8110e1d0:	100d883a 	mov	r6,r2
8110e1d4:	01604574 	movhi	r5,33045
8110e1d8:	29608e04 	addi	r5,r5,-32200
8110e1dc:	1809883a 	mov	r4,r3
8110e1e0:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
8110e1e4:	d0e05d17 	ldw	r3,-32396(gp)
8110e1e8:	e0bffe17 	ldw	r2,-8(fp)
8110e1ec:	10802c17 	ldw	r2,176(r2)
8110e1f0:	100d883a 	mov	r6,r2
8110e1f4:	01604574 	movhi	r5,33045
8110e1f8:	29609404 	addi	r5,r5,-32176
8110e1fc:	1809883a 	mov	r4,r3
8110e200:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
8110e204:	d0e05d17 	ldw	r3,-32396(gp)
8110e208:	e0bffe17 	ldw	r2,-8(fp)
8110e20c:	10802117 	ldw	r2,132(r2)
8110e210:	100d883a 	mov	r6,r2
8110e214:	01604574 	movhi	r5,33045
8110e218:	29609a04 	addi	r5,r5,-32152
8110e21c:	1809883a 	mov	r4,r3
8110e220:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
8110e224:	d0e05d17 	ldw	r3,-32396(gp)
8110e228:	e0bffe17 	ldw	r2,-8(fp)
8110e22c:	10802317 	ldw	r2,140(r2)
8110e230:	100d883a 	mov	r6,r2
8110e234:	01604574 	movhi	r5,33045
8110e238:	2960a104 	addi	r5,r5,-32124
8110e23c:	1809883a 	mov	r4,r3
8110e240:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
8110e244:	d0e05d17 	ldw	r3,-32396(gp)
8110e248:	e0bffe17 	ldw	r2,-8(fp)
8110e24c:	10802417 	ldw	r2,144(r2)
8110e250:	100d883a 	mov	r6,r2
8110e254:	01604574 	movhi	r5,33045
8110e258:	2960a804 	addi	r5,r5,-32096
8110e25c:	1809883a 	mov	r4,r3
8110e260:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
8110e264:	d0e05d17 	ldw	r3,-32396(gp)
8110e268:	e0bffe17 	ldw	r2,-8(fp)
8110e26c:	10802517 	ldw	r2,148(r2)
8110e270:	100d883a 	mov	r6,r2
8110e274:	01604574 	movhi	r5,33045
8110e278:	2960af04 	addi	r5,r5,-32068
8110e27c:	1809883a 	mov	r4,r3
8110e280:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
8110e284:	d0e05d17 	ldw	r3,-32396(gp)
8110e288:	e0bffe17 	ldw	r2,-8(fp)
8110e28c:	10802617 	ldw	r2,152(r2)
8110e290:	100d883a 	mov	r6,r2
8110e294:	01604574 	movhi	r5,33045
8110e298:	2960b604 	addi	r5,r5,-32040
8110e29c:	1809883a 	mov	r4,r3
8110e2a0:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
8110e2a4:	d1205d17 	ldw	r4,-32396(gp)
8110e2a8:	e0bffe17 	ldw	r2,-8(fp)
8110e2ac:	10802a43 	ldbu	r2,169(r2)
8110e2b0:	11403fcc 	andi	r5,r2,255
8110e2b4:	e0bffe17 	ldw	r2,-8(fp)
8110e2b8:	10802a83 	ldbu	r2,170(r2)
8110e2bc:	11803fcc 	andi	r6,r2,255
8110e2c0:	e0bffe17 	ldw	r2,-8(fp)
8110e2c4:	10802ac3 	ldbu	r2,171(r2)
8110e2c8:	10803fcc 	andi	r2,r2,255
8110e2cc:	e0fffe17 	ldw	r3,-8(fp)
8110e2d0:	18c02b03 	ldbu	r3,172(r3)
8110e2d4:	18c03fcc 	andi	r3,r3,255
8110e2d8:	d8c00115 	stw	r3,4(sp)
8110e2dc:	d8800015 	stw	r2,0(sp)
8110e2e0:	300f883a 	mov	r7,r6
8110e2e4:	280d883a 	mov	r6,r5
8110e2e8:	01604574 	movhi	r5,33045
8110e2ec:	2960bd04 	addi	r5,r5,-32012
8110e2f0:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
8110e2f4:	d0e05d17 	ldw	r3,-32396(gp)
8110e2f8:	e0bffe17 	ldw	r2,-8(fp)
8110e2fc:	10802e17 	ldw	r2,184(r2)
8110e300:	100d883a 	mov	r6,r2
8110e304:	01604574 	movhi	r5,33045
8110e308:	2960ca04 	addi	r5,r5,-31960
8110e30c:	1809883a 	mov	r4,r3
8110e310:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"\n\n");
8110e314:	d0a05d17 	ldw	r2,-32396(gp)
8110e318:	100f883a 	mov	r7,r2
8110e31c:	01800084 	movi	r6,2
8110e320:	01400044 	movi	r5,1
8110e324:	01204574 	movhi	r4,33045
8110e328:	2120d004 	addi	r4,r4,-31936
8110e32c:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
8110e330:	d0e05d17 	ldw	r3,-32396(gp)
8110e334:	e0bffe17 	ldw	r2,-8(fp)
8110e338:	10800003 	ldbu	r2,0(r2)
8110e33c:	10803fcc 	andi	r2,r2,255
8110e340:	100d883a 	mov	r6,r2
8110e344:	01604574 	movhi	r5,33045
8110e348:	2960d104 	addi	r5,r5,-31932
8110e34c:	1809883a 	mov	r4,r3
8110e350:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    General Info: \n");
8110e354:	d0a05d17 	ldw	r2,-32396(gp)
8110e358:	100f883a 	mov	r7,r2
8110e35c:	018004c4 	movi	r6,19
8110e360:	01400044 	movi	r5,1
8110e364:	01204574 	movhi	r4,33045
8110e368:	2120d704 	addi	r4,r4,-31908
8110e36c:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
8110e370:	d0e05d17 	ldw	r3,-32396(gp)
8110e374:	e0bffe17 	ldw	r2,-8(fp)
8110e378:	10800117 	ldw	r2,4(r2)
8110e37c:	100d883a 	mov	r6,r2
8110e380:	01604574 	movhi	r5,33045
8110e384:	2960dc04 	addi	r5,r5,-31888
8110e388:	1809883a 	mov	r4,r3
8110e38c:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
8110e390:	d0e05d17 	ldw	r3,-32396(gp)
8110e394:	e0bffe17 	ldw	r2,-8(fp)
8110e398:	10800217 	ldw	r2,8(r2)
8110e39c:	100d883a 	mov	r6,r2
8110e3a0:	01604574 	movhi	r5,33045
8110e3a4:	2960e404 	addi	r5,r5,-31856
8110e3a8:	1809883a 	mov	r4,r3
8110e3ac:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
8110e3b0:	d0e05d17 	ldw	r3,-32396(gp)
8110e3b4:	e0bffe17 	ldw	r2,-8(fp)
8110e3b8:	10800317 	ldw	r2,12(r2)
8110e3bc:	100d883a 	mov	r6,r2
8110e3c0:	01604574 	movhi	r5,33045
8110e3c4:	2960ec04 	addi	r5,r5,-31824
8110e3c8:	1809883a 	mov	r4,r3
8110e3cc:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
8110e3d0:	d0a05d17 	ldw	r2,-32396(gp)
8110e3d4:	100f883a 	mov	r7,r2
8110e3d8:	01800644 	movi	r6,25
8110e3dc:	01400044 	movi	r5,1
8110e3e0:	01204574 	movhi	r4,33045
8110e3e4:	2120f304 	addi	r4,r4,-31796
8110e3e8:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
8110e3ec:	d0e05d17 	ldw	r3,-32396(gp)
8110e3f0:	e0bffe17 	ldw	r2,-8(fp)
8110e3f4:	10800517 	ldw	r2,20(r2)
8110e3f8:	100d883a 	mov	r6,r2
8110e3fc:	01604574 	movhi	r5,33045
8110e400:	2960fa04 	addi	r5,r5,-31768
8110e404:	1809883a 	mov	r4,r3
8110e408:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
8110e40c:	d0e05d17 	ldw	r3,-32396(gp)
8110e410:	e0bffe17 	ldw	r2,-8(fp)
8110e414:	10800417 	ldw	r2,16(r2)
8110e418:	100d883a 	mov	r6,r2
8110e41c:	01604574 	movhi	r5,33045
8110e420:	29610204 	addi	r5,r5,-31736
8110e424:	1809883a 	mov	r4,r3
8110e428:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
8110e42c:	d0e05d17 	ldw	r3,-32396(gp)
8110e430:	e0bffe17 	ldw	r2,-8(fp)
8110e434:	10800603 	ldbu	r2,24(r2)
8110e438:	10803fcc 	andi	r2,r2,255
8110e43c:	100d883a 	mov	r6,r2
8110e440:	01604574 	movhi	r5,33045
8110e444:	29610a04 	addi	r5,r5,-31704
8110e448:	1809883a 	mov	r4,r3
8110e44c:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
8110e450:	d2205d17 	ldw	r8,-32396(gp)
8110e454:	e13ffe17 	ldw	r4,-8(fp)
8110e458:	20800717 	ldw	r2,28(r4)
8110e45c:	20c00817 	ldw	r3,32(r4)
8110e460:	100d883a 	mov	r6,r2
8110e464:	180f883a 	mov	r7,r3
8110e468:	01604574 	movhi	r5,33045
8110e46c:	29611204 	addi	r5,r5,-31672
8110e470:	4009883a 	mov	r4,r8
8110e474:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"\n");
8110e478:	d0a05d17 	ldw	r2,-32396(gp)
8110e47c:	100b883a 	mov	r5,r2
8110e480:	01000284 	movi	r4,10
8110e484:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8110e488:	d0e05d17 	ldw	r3,-32396(gp)
8110e48c:	e0bffe17 	ldw	r2,-8(fp)
8110e490:	10800003 	ldbu	r2,0(r2)
8110e494:	10803fcc 	andi	r2,r2,255
8110e498:	100f883a 	mov	r7,r2
8110e49c:	000d883a 	mov	r6,zero
8110e4a0:	01604574 	movhi	r5,33045
8110e4a4:	29611a04 	addi	r5,r5,-31640
8110e4a8:	1809883a 	mov	r4,r3
8110e4ac:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Left side \n");
8110e4b0:	d0a05d17 	ldw	r2,-32396(gp)
8110e4b4:	100f883a 	mov	r7,r2
8110e4b8:	018004c4 	movi	r6,19
8110e4bc:	01400044 	movi	r5,1
8110e4c0:	01204574 	movhi	r4,33045
8110e4c4:	21212404 	addi	r4,r4,-31600
8110e4c8:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
8110e4cc:	d0e05d17 	ldw	r3,-32396(gp)
8110e4d0:	e0bffe17 	ldw	r2,-8(fp)
8110e4d4:	10800917 	ldw	r2,36(r2)
8110e4d8:	100d883a 	mov	r6,r2
8110e4dc:	01604574 	movhi	r5,33045
8110e4e0:	29612904 	addi	r5,r5,-31580
8110e4e4:	1809883a 	mov	r4,r3
8110e4e8:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
8110e4ec:	d0e05d17 	ldw	r3,-32396(gp)
8110e4f0:	e0bffe17 	ldw	r2,-8(fp)
8110e4f4:	10800a17 	ldw	r2,40(r2)
8110e4f8:	100d883a 	mov	r6,r2
8110e4fc:	01604574 	movhi	r5,33045
8110e500:	29613204 	addi	r5,r5,-31544
8110e504:	1809883a 	mov	r4,r3
8110e508:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
8110e50c:	d0e05d17 	ldw	r3,-32396(gp)
8110e510:	e0bffe17 	ldw	r2,-8(fp)
8110e514:	10800b17 	ldw	r2,44(r2)
8110e518:	100d883a 	mov	r6,r2
8110e51c:	01604574 	movhi	r5,33045
8110e520:	29613d04 	addi	r5,r5,-31500
8110e524:	1809883a 	mov	r4,r3
8110e528:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Right side \n");
8110e52c:	d0a05d17 	ldw	r2,-32396(gp)
8110e530:	100f883a 	mov	r7,r2
8110e534:	01800504 	movi	r6,20
8110e538:	01400044 	movi	r5,1
8110e53c:	01204574 	movhi	r4,33045
8110e540:	21214904 	addi	r4,r4,-31452
8110e544:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8110e548:	d0e05d17 	ldw	r3,-32396(gp)
8110e54c:	e0bffe17 	ldw	r2,-8(fp)
8110e550:	10800c17 	ldw	r2,48(r2)
8110e554:	100d883a 	mov	r6,r2
8110e558:	01604574 	movhi	r5,33045
8110e55c:	29612904 	addi	r5,r5,-31580
8110e560:	1809883a 	mov	r4,r3
8110e564:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8110e568:	d0e05d17 	ldw	r3,-32396(gp)
8110e56c:	e0bffe17 	ldw	r2,-8(fp)
8110e570:	10800d17 	ldw	r2,52(r2)
8110e574:	100d883a 	mov	r6,r2
8110e578:	01604574 	movhi	r5,33045
8110e57c:	29613204 	addi	r5,r5,-31544
8110e580:	1809883a 	mov	r4,r3
8110e584:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8110e588:	d0e05d17 	ldw	r3,-32396(gp)
8110e58c:	e0bffe17 	ldw	r2,-8(fp)
8110e590:	10800e17 	ldw	r2,56(r2)
8110e594:	100d883a 	mov	r6,r2
8110e598:	01604574 	movhi	r5,33045
8110e59c:	29613d04 	addi	r5,r5,-31500
8110e5a0:	1809883a 	mov	r4,r3
8110e5a4:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"\n");
8110e5a8:	d0a05d17 	ldw	r2,-32396(gp)
8110e5ac:	100b883a 	mov	r5,r2
8110e5b0:	01000284 	movi	r4,10
8110e5b4:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
8110e5b8:	d0e05d17 	ldw	r3,-32396(gp)
8110e5bc:	e0bffe17 	ldw	r2,-8(fp)
8110e5c0:	10800003 	ldbu	r2,0(r2)
8110e5c4:	10803fcc 	andi	r2,r2,255
8110e5c8:	100f883a 	mov	r7,r2
8110e5cc:	01800044 	movi	r6,1
8110e5d0:	01604574 	movhi	r5,33045
8110e5d4:	29611a04 	addi	r5,r5,-31640
8110e5d8:	1809883a 	mov	r4,r3
8110e5dc:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Left side \n");
8110e5e0:	d0a05d17 	ldw	r2,-32396(gp)
8110e5e4:	100f883a 	mov	r7,r2
8110e5e8:	018004c4 	movi	r6,19
8110e5ec:	01400044 	movi	r5,1
8110e5f0:	01204574 	movhi	r4,33045
8110e5f4:	21212404 	addi	r4,r4,-31600
8110e5f8:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
8110e5fc:	d0e05d17 	ldw	r3,-32396(gp)
8110e600:	e0bffe17 	ldw	r2,-8(fp)
8110e604:	10800f17 	ldw	r2,60(r2)
8110e608:	100d883a 	mov	r6,r2
8110e60c:	01604574 	movhi	r5,33045
8110e610:	29612904 	addi	r5,r5,-31580
8110e614:	1809883a 	mov	r4,r3
8110e618:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
8110e61c:	d0e05d17 	ldw	r3,-32396(gp)
8110e620:	e0bffe17 	ldw	r2,-8(fp)
8110e624:	10801017 	ldw	r2,64(r2)
8110e628:	100d883a 	mov	r6,r2
8110e62c:	01604574 	movhi	r5,33045
8110e630:	29613204 	addi	r5,r5,-31544
8110e634:	1809883a 	mov	r4,r3
8110e638:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
8110e63c:	d0e05d17 	ldw	r3,-32396(gp)
8110e640:	e0bffe17 	ldw	r2,-8(fp)
8110e644:	10801117 	ldw	r2,68(r2)
8110e648:	100d883a 	mov	r6,r2
8110e64c:	01604574 	movhi	r5,33045
8110e650:	29613d04 	addi	r5,r5,-31500
8110e654:	1809883a 	mov	r4,r3
8110e658:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Right side \n");
8110e65c:	d0a05d17 	ldw	r2,-32396(gp)
8110e660:	100f883a 	mov	r7,r2
8110e664:	01800504 	movi	r6,20
8110e668:	01400044 	movi	r5,1
8110e66c:	01204574 	movhi	r4,33045
8110e670:	21214904 	addi	r4,r4,-31452
8110e674:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8110e678:	d0e05d17 	ldw	r3,-32396(gp)
8110e67c:	e0bffe17 	ldw	r2,-8(fp)
8110e680:	10801217 	ldw	r2,72(r2)
8110e684:	100d883a 	mov	r6,r2
8110e688:	01604574 	movhi	r5,33045
8110e68c:	29612904 	addi	r5,r5,-31580
8110e690:	1809883a 	mov	r4,r3
8110e694:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
8110e698:	d0e05d17 	ldw	r3,-32396(gp)
8110e69c:	e0bffe17 	ldw	r2,-8(fp)
8110e6a0:	10801317 	ldw	r2,76(r2)
8110e6a4:	100d883a 	mov	r6,r2
8110e6a8:	01604574 	movhi	r5,33045
8110e6ac:	29613204 	addi	r5,r5,-31544
8110e6b0:	1809883a 	mov	r4,r3
8110e6b4:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
8110e6b8:	d0e05d17 	ldw	r3,-32396(gp)
8110e6bc:	e0bffe17 	ldw	r2,-8(fp)
8110e6c0:	10801417 	ldw	r2,80(r2)
8110e6c4:	100d883a 	mov	r6,r2
8110e6c8:	01604574 	movhi	r5,33045
8110e6cc:	29613d04 	addi	r5,r5,-31500
8110e6d0:	1809883a 	mov	r4,r3
8110e6d4:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"\n");
8110e6d8:	d0a05d17 	ldw	r2,-32396(gp)
8110e6dc:	100b883a 	mov	r5,r2
8110e6e0:	01000284 	movi	r4,10
8110e6e4:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
8110e6e8:	d0e05d17 	ldw	r3,-32396(gp)
8110e6ec:	e0bffe17 	ldw	r2,-8(fp)
8110e6f0:	10800003 	ldbu	r2,0(r2)
8110e6f4:	10803fcc 	andi	r2,r2,255
8110e6f8:	100f883a 	mov	r7,r2
8110e6fc:	01800084 	movi	r6,2
8110e700:	01604574 	movhi	r5,33045
8110e704:	29611a04 	addi	r5,r5,-31640
8110e708:	1809883a 	mov	r4,r3
8110e70c:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Left side \n");
8110e710:	d0a05d17 	ldw	r2,-32396(gp)
8110e714:	100f883a 	mov	r7,r2
8110e718:	018004c4 	movi	r6,19
8110e71c:	01400044 	movi	r5,1
8110e720:	01204574 	movhi	r4,33045
8110e724:	21212404 	addi	r4,r4,-31600
8110e728:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
8110e72c:	d0e05d17 	ldw	r3,-32396(gp)
8110e730:	e0bffe17 	ldw	r2,-8(fp)
8110e734:	10801517 	ldw	r2,84(r2)
8110e738:	100d883a 	mov	r6,r2
8110e73c:	01604574 	movhi	r5,33045
8110e740:	29612904 	addi	r5,r5,-31580
8110e744:	1809883a 	mov	r4,r3
8110e748:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
8110e74c:	d0e05d17 	ldw	r3,-32396(gp)
8110e750:	e0bffe17 	ldw	r2,-8(fp)
8110e754:	10801617 	ldw	r2,88(r2)
8110e758:	100d883a 	mov	r6,r2
8110e75c:	01604574 	movhi	r5,33045
8110e760:	29613204 	addi	r5,r5,-31544
8110e764:	1809883a 	mov	r4,r3
8110e768:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
8110e76c:	d0e05d17 	ldw	r3,-32396(gp)
8110e770:	e0bffe17 	ldw	r2,-8(fp)
8110e774:	10801717 	ldw	r2,92(r2)
8110e778:	100d883a 	mov	r6,r2
8110e77c:	01604574 	movhi	r5,33045
8110e780:	29613d04 	addi	r5,r5,-31500
8110e784:	1809883a 	mov	r4,r3
8110e788:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Right side \n");
8110e78c:	d0a05d17 	ldw	r2,-32396(gp)
8110e790:	100f883a 	mov	r7,r2
8110e794:	01800504 	movi	r6,20
8110e798:	01400044 	movi	r5,1
8110e79c:	01204574 	movhi	r4,33045
8110e7a0:	21214904 	addi	r4,r4,-31452
8110e7a4:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
8110e7a8:	d0e05d17 	ldw	r3,-32396(gp)
8110e7ac:	e0bffe17 	ldw	r2,-8(fp)
8110e7b0:	10801817 	ldw	r2,96(r2)
8110e7b4:	100d883a 	mov	r6,r2
8110e7b8:	01604574 	movhi	r5,33045
8110e7bc:	29612904 	addi	r5,r5,-31580
8110e7c0:	1809883a 	mov	r4,r3
8110e7c4:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
8110e7c8:	d0e05d17 	ldw	r3,-32396(gp)
8110e7cc:	e0bffe17 	ldw	r2,-8(fp)
8110e7d0:	10801917 	ldw	r2,100(r2)
8110e7d4:	100d883a 	mov	r6,r2
8110e7d8:	01604574 	movhi	r5,33045
8110e7dc:	29613204 	addi	r5,r5,-31544
8110e7e0:	1809883a 	mov	r4,r3
8110e7e4:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
8110e7e8:	d0e05d17 	ldw	r3,-32396(gp)
8110e7ec:	e0bffe17 	ldw	r2,-8(fp)
8110e7f0:	10801a17 	ldw	r2,104(r2)
8110e7f4:	100d883a 	mov	r6,r2
8110e7f8:	01604574 	movhi	r5,33045
8110e7fc:	29613d04 	addi	r5,r5,-31500
8110e800:	1809883a 	mov	r4,r3
8110e804:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"\n");
8110e808:	d0a05d17 	ldw	r2,-32396(gp)
8110e80c:	100b883a 	mov	r5,r2
8110e810:	01000284 	movi	r4,10
8110e814:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8110e818:	d0e05d17 	ldw	r3,-32396(gp)
8110e81c:	e0bffe17 	ldw	r2,-8(fp)
8110e820:	10800003 	ldbu	r2,0(r2)
8110e824:	10803fcc 	andi	r2,r2,255
8110e828:	100f883a 	mov	r7,r2
8110e82c:	018000c4 	movi	r6,3
8110e830:	01604574 	movhi	r5,33045
8110e834:	29611a04 	addi	r5,r5,-31640
8110e838:	1809883a 	mov	r4,r3
8110e83c:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Left side \n");
8110e840:	d0a05d17 	ldw	r2,-32396(gp)
8110e844:	100f883a 	mov	r7,r2
8110e848:	018004c4 	movi	r6,19
8110e84c:	01400044 	movi	r5,1
8110e850:	01204574 	movhi	r4,33045
8110e854:	21212404 	addi	r4,r4,-31600
8110e858:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
8110e85c:	d0e05d17 	ldw	r3,-32396(gp)
8110e860:	e0bffe17 	ldw	r2,-8(fp)
8110e864:	10801b17 	ldw	r2,108(r2)
8110e868:	100d883a 	mov	r6,r2
8110e86c:	01604574 	movhi	r5,33045
8110e870:	29612904 	addi	r5,r5,-31580
8110e874:	1809883a 	mov	r4,r3
8110e878:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
8110e87c:	d0e05d17 	ldw	r3,-32396(gp)
8110e880:	e0bffe17 	ldw	r2,-8(fp)
8110e884:	10801c17 	ldw	r2,112(r2)
8110e888:	100d883a 	mov	r6,r2
8110e88c:	01604574 	movhi	r5,33045
8110e890:	29613204 	addi	r5,r5,-31544
8110e894:	1809883a 	mov	r4,r3
8110e898:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
8110e89c:	d0e05d17 	ldw	r3,-32396(gp)
8110e8a0:	e0bffe17 	ldw	r2,-8(fp)
8110e8a4:	10801d17 	ldw	r2,116(r2)
8110e8a8:	100d883a 	mov	r6,r2
8110e8ac:	01604574 	movhi	r5,33045
8110e8b0:	29613d04 	addi	r5,r5,-31500
8110e8b4:	1809883a 	mov	r4,r3
8110e8b8:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"        Right side \n");
8110e8bc:	d0a05d17 	ldw	r2,-32396(gp)
8110e8c0:	100f883a 	mov	r7,r2
8110e8c4:	01800504 	movi	r6,20
8110e8c8:	01400044 	movi	r5,1
8110e8cc:	01204574 	movhi	r4,33045
8110e8d0:	21214904 	addi	r4,r4,-31452
8110e8d4:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
8110e8d8:	d0e05d17 	ldw	r3,-32396(gp)
8110e8dc:	e0bffe17 	ldw	r2,-8(fp)
8110e8e0:	10801e17 	ldw	r2,120(r2)
8110e8e4:	100d883a 	mov	r6,r2
8110e8e8:	01604574 	movhi	r5,33045
8110e8ec:	29612904 	addi	r5,r5,-31580
8110e8f0:	1809883a 	mov	r4,r3
8110e8f4:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
8110e8f8:	d0e05d17 	ldw	r3,-32396(gp)
8110e8fc:	e0bffe17 	ldw	r2,-8(fp)
8110e900:	10801f17 	ldw	r2,124(r2)
8110e904:	100d883a 	mov	r6,r2
8110e908:	01604574 	movhi	r5,33045
8110e90c:	29613204 	addi	r5,r5,-31544
8110e910:	1809883a 	mov	r4,r3
8110e914:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
8110e918:	d0e05d17 	ldw	r3,-32396(gp)
8110e91c:	e0bffe17 	ldw	r2,-8(fp)
8110e920:	10802017 	ldw	r2,128(r2)
8110e924:	100d883a 	mov	r6,r2
8110e928:	01604574 	movhi	r5,33045
8110e92c:	29613d04 	addi	r5,r5,-31500
8110e930:	1809883a 	mov	r4,r3
8110e934:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"\n");
8110e938:	d0a05d17 	ldw	r2,-32396(gp)
8110e93c:	100b883a 	mov	r5,r2
8110e940:	01000284 	movi	r4,10
8110e944:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"==============================================================================\n");
8110e948:	d0a05d17 	ldw	r2,-32396(gp)
8110e94c:	100f883a 	mov	r7,r2
8110e950:	018013c4 	movi	r6,79
8110e954:	01400044 	movi	r5,1
8110e958:	01204574 	movhi	r4,33045
8110e95c:	21214f04 	addi	r4,r4,-31428
8110e960:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"==============================================================================\n");
8110e964:	d0a05d17 	ldw	r2,-32396(gp)
8110e968:	100f883a 	mov	r7,r2
8110e96c:	018013c4 	movi	r6,79
8110e970:	01400044 	movi	r5,1
8110e974:	01204574 	movhi	r4,33045
8110e978:	21214f04 	addi	r4,r4,-31428
8110e97c:	111c7b80 	call	8111c7b8 <fwrite>
		fprintf(fp,"\n");
8110e980:	d0a05d17 	ldw	r2,-32396(gp)
8110e984:	100b883a 	mov	r5,r2
8110e988:	01000284 	movi	r4,10
8110e98c:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"\n");
8110e990:	d0a05d17 	ldw	r2,-32396(gp)
8110e994:	100b883a 	mov	r5,r2
8110e998:	01000284 	movi	r4,10
8110e99c:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"\n");
8110e9a0:	d0a05d17 	ldw	r2,-32396(gp)
8110e9a4:	100b883a 	mov	r5,r2
8110e9a8:	01000284 	movi	r4,10
8110e9ac:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"\n");
8110e9b0:	d0a05d17 	ldw	r2,-32396(gp)
8110e9b4:	100b883a 	mov	r5,r2
8110e9b8:	01000284 	movi	r4,10
8110e9bc:	111c1940 	call	8111c194 <fputc>
		fprintf(fp,"\n");
8110e9c0:	d0a05d17 	ldw	r2,-32396(gp)
8110e9c4:	100b883a 	mov	r5,r2
8110e9c8:	01000284 	movi	r4,10
8110e9cc:	111c1940 	call	8111c194 <fputc>
	}
8110e9d0:	0001883a 	nop
8110e9d4:	e037883a 	mov	sp,fp
8110e9d8:	dfc00117 	ldw	ra,4(sp)
8110e9dc:	df000017 	ldw	fp,0(sp)
8110e9e0:	dec00204 	addi	sp,sp,8
8110e9e4:	f800283a 	ret

8110e9e8 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
8110e9e8:	defff604 	addi	sp,sp,-40
8110e9ec:	de00012e 	bgeu	sp,et,8110e9f4 <vInAckHandlerTaskV2+0xc>
8110e9f0:	003b68fa 	trap	3
8110e9f4:	dfc00915 	stw	ra,36(sp)
8110e9f8:	df000815 	stw	fp,32(sp)
8110e9fc:	df000804 	addi	fp,sp,32
8110ea00:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8110ea04:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
8110ea08:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
8110ea0c:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
8110ea10:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8110ea14:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
8110ea18:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
8110ea1c:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
8110ea20:	d0a05d17 	ldw	r2,-32396(gp)
8110ea24:	100f883a 	mov	r7,r2
8110ea28:	018007c4 	movi	r6,31
8110ea2c:	01400044 	movi	r5,1
8110ea30:	01204574 	movhi	r4,33045
8110ea34:	21216304 	addi	r4,r4,-31348
8110ea38:	111c7b80 	call	8111c7b8 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
8110ea3c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
8110ea40:	e0bff917 	ldw	r2,-28(fp)
8110ea44:	10c00060 	cmpeqi	r3,r2,1
8110ea48:	1800071e 	bne	r3,zero,8110ea68 <vInAckHandlerTaskV2+0x80>
8110ea4c:	0080032e 	bgeu	zero,r2,8110ea5c <vInAckHandlerTaskV2+0x74>
8110ea50:	108000a0 	cmpeqi	r2,r2,2
8110ea54:	10004a1e 	bne	r2,zero,8110eb80 <vInAckHandlerTaskV2+0x198>
8110ea58:	0000ac06 	br	8110ed0c <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8110ea5c:	00800044 	movi	r2,1
8110ea60:	e0bff915 	stw	r2,-28(fp)
				break;
8110ea64:	0000b306 	br	8110ed34 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
8110ea68:	00800044 	movi	r2,1
8110ea6c:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
8110ea70:	d0a06117 	ldw	r2,-32380(gp)
8110ea74:	e0fffe04 	addi	r3,fp,-8
8110ea78:	180d883a 	mov	r6,r3
8110ea7c:	000b883a 	mov	r5,zero
8110ea80:	1009883a 	mov	r4,r2
8110ea84:	113a1f80 	call	8113a1f8 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110ea88:	e0bffe03 	ldbu	r2,-8(fp)
8110ea8c:	10803fcc 	andi	r2,r2,255
8110ea90:	1000391e 	bne	r2,zero,8110eb78 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
8110ea94:	d0a06017 	ldw	r2,-32384(gp)
8110ea98:	e0fffe04 	addi	r3,fp,-8
8110ea9c:	180d883a 	mov	r6,r3
8110eaa0:	000b883a 	mov	r5,zero
8110eaa4:	1009883a 	mov	r4,r2
8110eaa8:	11381ec0 	call	811381ec <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110eaac:	e0bffe03 	ldbu	r2,-8(fp)
8110eab0:	10803fcc 	andi	r2,r2,255
8110eab4:	10002b1e 	bne	r2,zero,8110eb64 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110eab8:	e03ffa45 	stb	zero,-23(fp)
8110eabc:	00002206 	br	8110eb48 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8110eac0:	e0fffa43 	ldbu	r3,-23(fp)
8110eac4:	00a045b4 	movhi	r2,33046
8110eac8:	10af4f04 	addi	r2,r2,-17092
8110eacc:	18c7883a 	add	r3,r3,r3
8110ead0:	18c7883a 	add	r3,r3,r3
8110ead4:	10c5883a 	add	r2,r2,r3
8110ead8:	10800003 	ldbu	r2,0(r2)
8110eadc:	10803fcc 	andi	r2,r2,255
8110eae0:	1080201c 	xori	r2,r2,128
8110eae4:	10bfe004 	addi	r2,r2,-128
8110eae8:	10001426 	beq	r2,zero,8110eb3c <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8110eaec:	e0fffa43 	ldbu	r3,-23(fp)
8110eaf0:	00a045b4 	movhi	r2,33046
8110eaf4:	10af4f04 	addi	r2,r2,-17092
8110eaf8:	18c7883a 	add	r3,r3,r3
8110eafc:	18c7883a 	add	r3,r3,r3
8110eb00:	10c5883a 	add	r2,r2,r3
8110eb04:	10c0000b 	ldhu	r3,0(r2)
8110eb08:	d0e0530d 	sth	r3,-32436(gp)
8110eb0c:	1080008b 	ldhu	r2,2(r2)
8110eb10:	d0a0538d 	sth	r2,-32434(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110eb14:	e0fffa43 	ldbu	r3,-23(fp)
8110eb18:	00a045b4 	movhi	r2,33046
8110eb1c:	10af4f04 	addi	r2,r2,-17092
8110eb20:	18c7883a 	add	r3,r3,r3
8110eb24:	18c7883a 	add	r3,r3,r3
8110eb28:	10c5883a 	add	r2,r2,r3
8110eb2c:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
8110eb30:	00800084 	movi	r2,2
8110eb34:	e0bff915 	stw	r2,-28(fp)
                                break;                                
8110eb38:	00000606 	br	8110eb54 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110eb3c:	e0bffa43 	ldbu	r2,-23(fp)
8110eb40:	10800044 	addi	r2,r2,1
8110eb44:	e0bffa45 	stb	r2,-23(fp)
8110eb48:	e0bffa43 	ldbu	r2,-23(fp)
8110eb4c:	108001b0 	cmpltui	r2,r2,6
8110eb50:	103fdb1e 	bne	r2,zero,8110eac0 <__reset+0xfb0eeac0>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
8110eb54:	d0a06017 	ldw	r2,-32384(gp)
8110eb58:	1009883a 	mov	r4,r2
8110eb5c:	11387900 	call	81138790 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110eb60:	00007406 	br	8110ed34 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
8110eb64:	d0a06117 	ldw	r2,-32380(gp)
8110eb68:	1009883a 	mov	r4,r2
8110eb6c:	113a5800 	call	8113a580 <OSSemPost>
                    	vFailGetMutexReceiverTask();
8110eb70:	11175e00 	call	811175e0 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110eb74:	00006f06 	br	8110ed34 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
8110eb78:	11175780 	call	81117578 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
8110eb7c:	00006d06 	br	8110ed34 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110eb80:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110eb84:	d0a06383 	ldbu	r2,-32370(gp)
8110eb88:	10803fcc 	andi	r2,r2,255
8110eb8c:	10800218 	cmpnei	r2,r2,8
8110eb90:	1000021e 	bne	r2,zero,8110eb9c <vInAckHandlerTaskV2+0x1b4>
8110eb94:	00c00104 	movi	r3,4
8110eb98:	00000106 	br	8110eba0 <vInAckHandlerTaskV2+0x1b8>
8110eb9c:	0007883a 	mov	r3,zero
8110eba0:	d0a07003 	ldbu	r2,-32320(gp)
8110eba4:	10803fcc 	andi	r2,r2,255
8110eba8:	10800218 	cmpnei	r2,r2,8
8110ebac:	1000021e 	bne	r2,zero,8110ebb8 <vInAckHandlerTaskV2+0x1d0>
8110ebb0:	00800084 	movi	r2,2
8110ebb4:	00000106 	br	8110ebbc <vInAckHandlerTaskV2+0x1d4>
8110ebb8:	0005883a 	mov	r2,zero
8110ebbc:	1884b03a 	or	r2,r3,r2
8110ebc0:	1007883a 	mov	r3,r2
8110ebc4:	d0a07043 	ldbu	r2,-32319(gp)
8110ebc8:	10803fcc 	andi	r2,r2,255
8110ebcc:	108001a0 	cmpeqi	r2,r2,6
8110ebd0:	1884b03a 	or	r2,r3,r2
8110ebd4:	1007883a 	mov	r3,r2
8110ebd8:	e0bffa83 	ldbu	r2,-22(fp)
8110ebdc:	1884b03a 	or	r2,r3,r2
8110ebe0:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
8110ebe4:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
8110ebe8:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8110ebec:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110ebf0:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
8110ebf4:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
8110ebf8:	e0bffa03 	ldbu	r2,-24(fp)
8110ebfc:	10800044 	addi	r2,r2,1
8110ec00:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110ec04:	e0bffa83 	ldbu	r2,-22(fp)
8110ec08:	1080004c 	andi	r2,r2,1
8110ec0c:	10803fcc 	andi	r2,r2,255
8110ec10:	1000061e 	bne	r2,zero,8110ec2c <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
8110ec14:	e0bffd04 	addi	r2,fp,-12
8110ec18:	100b883a 	mov	r5,r2
8110ec1c:	d1205304 	addi	r4,gp,-32436
8110ec20:	110ed380 	call	8110ed38 <bCheckInAck128>
8110ec24:	e0bff815 	stw	r2,-32(fp)
8110ec28:	00000206 	br	8110ec34 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
8110ec2c:	00800044 	movi	r2,1
8110ec30:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
8110ec34:	e0bffa83 	ldbu	r2,-22(fp)
8110ec38:	1080008c 	andi	r2,r2,2
8110ec3c:	10803fcc 	andi	r2,r2,255
8110ec40:	1000081e 	bne	r2,zero,8110ec64 <vInAckHandlerTaskV2+0x27c>
8110ec44:	e0bff817 	ldw	r2,-32(fp)
8110ec48:	1000061e 	bne	r2,zero,8110ec64 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8110ec4c:	e0bffc04 	addi	r2,fp,-16
8110ec50:	100b883a 	mov	r5,r2
8110ec54:	d1205304 	addi	r4,gp,-32436
8110ec58:	110ee800 	call	8110ee80 <bCheckInAck64>
8110ec5c:	e0bff815 	stw	r2,-32(fp)
8110ec60:	00000206 	br	8110ec6c <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
8110ec64:	00800044 	movi	r2,1
8110ec68:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8110ec6c:	e0bffa83 	ldbu	r2,-22(fp)
8110ec70:	1080010c 	andi	r2,r2,4
8110ec74:	10803fcc 	andi	r2,r2,255
8110ec78:	1000081e 	bne	r2,zero,8110ec9c <vInAckHandlerTaskV2+0x2b4>
8110ec7c:	e0bff817 	ldw	r2,-32(fp)
8110ec80:	1000061e 	bne	r2,zero,8110ec9c <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
8110ec84:	e0bffb04 	addi	r2,fp,-20
8110ec88:	100b883a 	mov	r5,r2
8110ec8c:	d1205304 	addi	r4,gp,-32436
8110ec90:	110efcc0 	call	8110efcc <bCheckInAck32>
8110ec94:	e0bff815 	stw	r2,-32(fp)
8110ec98:	00000206 	br	8110eca4 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
8110ec9c:	00800044 	movi	r2,1
8110eca0:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
8110eca4:	e0bffa03 	ldbu	r2,-24(fp)
8110eca8:	10c00044 	addi	r3,r2,1
8110ecac:	e0fffa05 	stb	r3,-24(fp)
8110ecb0:	10803fcc 	andi	r2,r2,255
8110ecb4:	10800ca8 	cmpgeui	r2,r2,50
8110ecb8:	10000e1e 	bne	r2,zero,8110ecf4 <vInAckHandlerTaskV2+0x30c>
8110ecbc:	e0bff817 	ldw	r2,-32(fp)
8110ecc0:	10000c1e 	bne	r2,zero,8110ecf4 <vInAckHandlerTaskV2+0x30c>
8110ecc4:	e0bffb17 	ldw	r2,-20(fp)
8110ecc8:	1005003a 	cmpeq	r2,r2,zero
8110eccc:	1007883a 	mov	r3,r2
8110ecd0:	e0bffc17 	ldw	r2,-16(fp)
8110ecd4:	1005003a 	cmpeq	r2,r2,zero
8110ecd8:	1884b03a 	or	r2,r3,r2
8110ecdc:	10c03fcc 	andi	r3,r2,255
8110ece0:	e0bffd17 	ldw	r2,-12(fp)
8110ece4:	1005003a 	cmpeq	r2,r2,zero
8110ece8:	10803fcc 	andi	r2,r2,255
8110ecec:	1884b03a 	or	r2,r3,r2
8110ecf0:	103fc11e 	bne	r2,zero,8110ebf8 <__reset+0xfb0eebf8>
                
                if (bFound == FALSE) {
8110ecf4:	e0bff817 	ldw	r2,-32(fp)
8110ecf8:	1000011e 	bne	r2,zero,8110ed00 <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8110ecfc:	1117a9c0 	call	81117a9c <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
8110ed00:	00800044 	movi	r2,1
8110ed04:	e0bff915 	stw	r2,-28(fp)
				break;
8110ed08:	00000a06 	br	8110ed34 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
8110ed0c:	d0a05d17 	ldw	r2,-32396(gp)
8110ed10:	100f883a 	mov	r7,r2
8110ed14:	01801144 	movi	r6,69
8110ed18:	01400044 	movi	r5,1
8110ed1c:	01204574 	movhi	r4,33045
8110ed20:	21216b04 	addi	r4,r4,-31316
8110ed24:	111c7b80 	call	8111c7b8 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
8110ed28:	00800044 	movi	r2,1
8110ed2c:	e0bff915 	stw	r2,-28(fp)
				break;
8110ed30:	0001883a 	nop
		}
	}
8110ed34:	003f4206 	br	8110ea40 <__reset+0xfb0eea40>

8110ed38 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
8110ed38:	defffa04 	addi	sp,sp,-24
8110ed3c:	de00012e 	bgeu	sp,et,8110ed44 <bCheckInAck128+0xc>
8110ed40:	003b68fa 	trap	3
8110ed44:	dfc00515 	stw	ra,20(sp)
8110ed48:	df000415 	stw	fp,16(sp)
8110ed4c:	df000404 	addi	fp,sp,16
8110ed50:	e13ffe15 	stw	r4,-8(fp)
8110ed54:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110ed58:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110ed5c:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110ed60:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110ed64:	e0bfff17 	ldw	r2,-4(fp)
8110ed68:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
8110ed6c:	d0a06917 	ldw	r2,-32348(gp)
8110ed70:	e0fffd44 	addi	r3,fp,-11
8110ed74:	180d883a 	mov	r6,r3
8110ed78:	01400144 	movi	r5,5
8110ed7c:	1009883a 	mov	r4,r2
8110ed80:	11381ec0 	call	811381ec <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110ed84:	e0bffd43 	ldbu	r2,-11(fp)
8110ed88:	10803fcc 	andi	r2,r2,255
8110ed8c:	10000226 	beq	r2,zero,8110ed98 <bCheckInAck128+0x60>
        return bFound;
8110ed90:	e0bffc17 	ldw	r2,-16(fp)
8110ed94:	00003506 	br	8110ee6c <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110ed98:	e03ffd05 	stb	zero,-12(fp)
8110ed9c:	00002706 	br	8110ee3c <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8110eda0:	e0fffd03 	ldbu	r3,-12(fp)
8110eda4:	00a045b4 	movhi	r2,33046
8110eda8:	10a65d04 	addi	r2,r2,-26252
8110edac:	18c02324 	muli	r3,r3,140
8110edb0:	10c5883a 	add	r2,r2,r3
8110edb4:	10802104 	addi	r2,r2,132
8110edb8:	10c0000b 	ldhu	r3,0(r2)
8110edbc:	e0bffe17 	ldw	r2,-8(fp)
8110edc0:	1080008b 	ldhu	r2,2(r2)
8110edc4:	18ffffcc 	andi	r3,r3,65535
8110edc8:	10bfffcc 	andi	r2,r2,65535
8110edcc:	1880181e 	bne	r3,r2,8110ee30 <bCheckInAck128+0xf8>
            bFound = TRUE;
8110edd0:	00800044 	movi	r2,1
8110edd4:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
8110edd8:	e0fffd03 	ldbu	r3,-12(fp)
8110eddc:	00a045b4 	movhi	r2,33046
8110ede0:	10a63f04 	addi	r2,r2,-26372
8110ede4:	18c7883a 	add	r3,r3,r3
8110ede8:	18c7883a 	add	r3,r3,r3
8110edec:	10c5883a 	add	r2,r2,r3
8110edf0:	10000015 	stw	zero,0(r2)
            SemCount128++;
8110edf4:	d0a07043 	ldbu	r2,-32319(gp)
8110edf8:	10800044 	addi	r2,r2,1
8110edfc:	d0a07045 	stb	r2,-32319(gp)
            error_code = OSSemPost(xSemCountBuffer128);
8110ee00:	d0a05e17 	ldw	r2,-32392(gp)
8110ee04:	1009883a 	mov	r4,r2
8110ee08:	113a5800 	call	8113a580 <OSSemPost>
8110ee0c:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110ee10:	e0bffd43 	ldbu	r2,-11(fp)
8110ee14:	10803fcc 	andi	r2,r2,255
8110ee18:	10000c26 	beq	r2,zero,8110ee4c <bCheckInAck128+0x114>
                SemCount128--;
8110ee1c:	d0a07043 	ldbu	r2,-32319(gp)
8110ee20:	10bfffc4 	addi	r2,r2,-1
8110ee24:	d0a07045 	stb	r2,-32319(gp)
                vFailSetCountSemaphorexBuffer128();
8110ee28:	11178fc0 	call	811178fc <vFailSetCountSemaphorexBuffer128>
            }
            break;
8110ee2c:	00000706 	br	8110ee4c <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110ee30:	e0bffd03 	ldbu	r2,-12(fp)
8110ee34:	10800044 	addi	r2,r2,1
8110ee38:	e0bffd05 	stb	r2,-12(fp)
8110ee3c:	e0bffd03 	ldbu	r2,-12(fp)
8110ee40:	108001b0 	cmpltui	r2,r2,6
8110ee44:	103fd61e 	bne	r2,zero,8110eda0 <__reset+0xfb0eeda0>
8110ee48:	00000106 	br	8110ee50 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
8110ee4c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8110ee50:	d0a06917 	ldw	r2,-32348(gp)
8110ee54:	1009883a 	mov	r4,r2
8110ee58:	11387900 	call	81138790 <OSMutexPost>
    (*bFinished) = TRUE;
8110ee5c:	e0bfff17 	ldw	r2,-4(fp)
8110ee60:	00c00044 	movi	r3,1
8110ee64:	10c00015 	stw	r3,0(r2)

    return bFound;
8110ee68:	e0bffc17 	ldw	r2,-16(fp)
}
8110ee6c:	e037883a 	mov	sp,fp
8110ee70:	dfc00117 	ldw	ra,4(sp)
8110ee74:	df000017 	ldw	fp,0(sp)
8110ee78:	dec00204 	addi	sp,sp,8
8110ee7c:	f800283a 	ret

8110ee80 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8110ee80:	defffa04 	addi	sp,sp,-24
8110ee84:	de00012e 	bgeu	sp,et,8110ee8c <bCheckInAck64+0xc>
8110ee88:	003b68fa 	trap	3
8110ee8c:	dfc00515 	stw	ra,20(sp)
8110ee90:	df000415 	stw	fp,16(sp)
8110ee94:	df000404 	addi	fp,sp,16
8110ee98:	e13ffe15 	stw	r4,-8(fp)
8110ee9c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110eea0:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110eea4:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110eea8:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110eeac:	e0bfff17 	ldw	r2,-4(fp)
8110eeb0:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110eeb4:	d0a06c17 	ldw	r2,-32336(gp)
8110eeb8:	e0fffd44 	addi	r3,fp,-11
8110eebc:	180d883a 	mov	r6,r3
8110eec0:	01400044 	movi	r5,1
8110eec4:	1009883a 	mov	r4,r2
8110eec8:	11381ec0 	call	811381ec <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110eecc:	e0bffd43 	ldbu	r2,-11(fp)
8110eed0:	10803fcc 	andi	r2,r2,255
8110eed4:	10000226 	beq	r2,zero,8110eee0 <bCheckInAck64+0x60>
        return bFound;
8110eed8:	e0bffc17 	ldw	r2,-16(fp)
8110eedc:	00003606 	br	8110efb8 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110eee0:	e03ffd05 	stb	zero,-12(fp)
8110eee4:	00002806 	br	8110ef88 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
8110eee8:	e0fffd03 	ldbu	r3,-12(fp)
8110eeec:	00a04574 	movhi	r2,33045
8110eef0:	10821e04 	addi	r2,r2,2168
8110eef4:	18c01324 	muli	r3,r3,76
8110eef8:	10c5883a 	add	r2,r2,r3
8110eefc:	10801104 	addi	r2,r2,68
8110ef00:	10c0000b 	ldhu	r3,0(r2)
8110ef04:	e0bffe17 	ldw	r2,-8(fp)
8110ef08:	1080008b 	ldhu	r2,2(r2)
8110ef0c:	18ffffcc 	andi	r3,r3,65535
8110ef10:	10bfffcc 	andi	r2,r2,65535
8110ef14:	1880191e 	bne	r3,r2,8110ef7c <bCheckInAck64+0xfc>
            bFound = TRUE;
8110ef18:	00800044 	movi	r2,1
8110ef1c:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8110ef20:	e0fffd03 	ldbu	r3,-12(fp)
8110ef24:	00a045b4 	movhi	r2,33046
8110ef28:	10a63f04 	addi	r2,r2,-26372
8110ef2c:	18c00184 	addi	r3,r3,6
8110ef30:	18c7883a 	add	r3,r3,r3
8110ef34:	18c7883a 	add	r3,r3,r3
8110ef38:	10c5883a 	add	r2,r2,r3
8110ef3c:	10000015 	stw	zero,0(r2)
            SemCount64++;
8110ef40:	d0a07003 	ldbu	r2,-32320(gp)
8110ef44:	10800044 	addi	r2,r2,1
8110ef48:	d0a07005 	stb	r2,-32320(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8110ef4c:	d0a05917 	ldw	r2,-32412(gp)
8110ef50:	1009883a 	mov	r4,r2
8110ef54:	113a5800 	call	8113a580 <OSSemPost>
8110ef58:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110ef5c:	e0bffd43 	ldbu	r2,-11(fp)
8110ef60:	10803fcc 	andi	r2,r2,255
8110ef64:	10000c26 	beq	r2,zero,8110ef98 <bCheckInAck64+0x118>
                SemCount64--;
8110ef68:	d0a07003 	ldbu	r2,-32320(gp)
8110ef6c:	10bfffc4 	addi	r2,r2,-1
8110ef70:	d0a07005 	stb	r2,-32320(gp)
                vFailSetCountSemaphorexBuffer64();
8110ef74:	11178940 	call	81117894 <vFailSetCountSemaphorexBuffer64>
            }
            break;
8110ef78:	00000706 	br	8110ef98 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110ef7c:	e0bffd03 	ldbu	r2,-12(fp)
8110ef80:	10800044 	addi	r2,r2,1
8110ef84:	e0bffd05 	stb	r2,-12(fp)
8110ef88:	e0bffd03 	ldbu	r2,-12(fp)
8110ef8c:	10800230 	cmpltui	r2,r2,8
8110ef90:	103fd51e 	bne	r2,zero,8110eee8 <__reset+0xfb0eeee8>
8110ef94:	00000106 	br	8110ef9c <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
8110ef98:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8110ef9c:	d0a06c17 	ldw	r2,-32336(gp)
8110efa0:	1009883a 	mov	r4,r2
8110efa4:	11387900 	call	81138790 <OSMutexPost>
    (*bFinished) = TRUE;
8110efa8:	e0bfff17 	ldw	r2,-4(fp)
8110efac:	00c00044 	movi	r3,1
8110efb0:	10c00015 	stw	r3,0(r2)

    return bFound;
8110efb4:	e0bffc17 	ldw	r2,-16(fp)
}
8110efb8:	e037883a 	mov	sp,fp
8110efbc:	dfc00117 	ldw	ra,4(sp)
8110efc0:	df000017 	ldw	fp,0(sp)
8110efc4:	dec00204 	addi	sp,sp,8
8110efc8:	f800283a 	ret

8110efcc <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
8110efcc:	defffa04 	addi	sp,sp,-24
8110efd0:	de00012e 	bgeu	sp,et,8110efd8 <bCheckInAck32+0xc>
8110efd4:	003b68fa 	trap	3
8110efd8:	dfc00515 	stw	ra,20(sp)
8110efdc:	df000415 	stw	fp,16(sp)
8110efe0:	df000404 	addi	fp,sp,16
8110efe4:	e13ffe15 	stw	r4,-8(fp)
8110efe8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110efec:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110eff0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110eff4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110eff8:	e0bfff17 	ldw	r2,-4(fp)
8110effc:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110f000:	d0a06717 	ldw	r2,-32356(gp)
8110f004:	e0fffd44 	addi	r3,fp,-11
8110f008:	180d883a 	mov	r6,r3
8110f00c:	01400044 	movi	r5,1
8110f010:	1009883a 	mov	r4,r2
8110f014:	11381ec0 	call	811381ec <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110f018:	e0bffd43 	ldbu	r2,-11(fp)
8110f01c:	10803fcc 	andi	r2,r2,255
8110f020:	10000226 	beq	r2,zero,8110f02c <bCheckInAck32+0x60>
        return bFound;
8110f024:	e0bffc17 	ldw	r2,-16(fp)
8110f028:	00003606 	br	8110f104 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110f02c:	e03ffd05 	stb	zero,-12(fp)
8110f030:	00002806 	br	8110f0d4 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8110f034:	e0fffd03 	ldbu	r3,-12(fp)
8110f038:	00a04574 	movhi	r2,33045
8110f03c:	1093cb04 	addi	r2,r2,20268
8110f040:	18c00b24 	muli	r3,r3,44
8110f044:	10c5883a 	add	r2,r2,r3
8110f048:	10800904 	addi	r2,r2,36
8110f04c:	10c0000b 	ldhu	r3,0(r2)
8110f050:	e0bffe17 	ldw	r2,-8(fp)
8110f054:	1080008b 	ldhu	r2,2(r2)
8110f058:	18ffffcc 	andi	r3,r3,65535
8110f05c:	10bfffcc 	andi	r2,r2,65535
8110f060:	1880191e 	bne	r3,r2,8110f0c8 <bCheckInAck32+0xfc>
            bFound = TRUE;
8110f064:	00800044 	movi	r2,1
8110f068:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
8110f06c:	e0fffd03 	ldbu	r3,-12(fp)
8110f070:	00a045b4 	movhi	r2,33046
8110f074:	10a63f04 	addi	r2,r2,-26372
8110f078:	18c00384 	addi	r3,r3,14
8110f07c:	18c7883a 	add	r3,r3,r3
8110f080:	18c7883a 	add	r3,r3,r3
8110f084:	10c5883a 	add	r2,r2,r3
8110f088:	10000015 	stw	zero,0(r2)
            SemCount32++;
8110f08c:	d0a06383 	ldbu	r2,-32370(gp)
8110f090:	10800044 	addi	r2,r2,1
8110f094:	d0a06385 	stb	r2,-32370(gp)
            error_code = OSSemPost(xSemCountBuffer32);
8110f098:	d0a06a17 	ldw	r2,-32344(gp)
8110f09c:	1009883a 	mov	r4,r2
8110f0a0:	113a5800 	call	8113a580 <OSSemPost>
8110f0a4:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110f0a8:	e0bffd43 	ldbu	r2,-11(fp)
8110f0ac:	10803fcc 	andi	r2,r2,255
8110f0b0:	10000c26 	beq	r2,zero,8110f0e4 <bCheckInAck32+0x118>
                SemCount32--;
8110f0b4:	d0a06383 	ldbu	r2,-32370(gp)
8110f0b8:	10bfffc4 	addi	r2,r2,-1
8110f0bc:	d0a06385 	stb	r2,-32370(gp)
                vFailSetCountSemaphorexBuffer32();
8110f0c0:	111782c0 	call	8111782c <vFailSetCountSemaphorexBuffer32>
            }
            break;
8110f0c4:	00000706 	br	8110f0e4 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110f0c8:	e0bffd03 	ldbu	r2,-12(fp)
8110f0cc:	10800044 	addi	r2,r2,1
8110f0d0:	e0bffd05 	stb	r2,-12(fp)
8110f0d4:	e0bffd03 	ldbu	r2,-12(fp)
8110f0d8:	10800230 	cmpltui	r2,r2,8
8110f0dc:	103fd51e 	bne	r2,zero,8110f034 <__reset+0xfb0ef034>
8110f0e0:	00000106 	br	8110f0e8 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
8110f0e4:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
8110f0e8:	d0a06717 	ldw	r2,-32356(gp)
8110f0ec:	1009883a 	mov	r4,r2
8110f0f0:	11387900 	call	81138790 <OSMutexPost>
    (*bFinished) = TRUE;
8110f0f4:	e0bfff17 	ldw	r2,-4(fp)
8110f0f8:	00c00044 	movi	r3,1
8110f0fc:	10c00015 	stw	r3,0(r2)

    return bFound;
8110f100:	e0bffc17 	ldw	r2,-16(fp)
}
8110f104:	e037883a 	mov	sp,fp
8110f108:	dfc00117 	ldw	ra,4(sp)
8110f10c:	df000017 	ldw	fp,0(sp)
8110f110:	dec00204 	addi	sp,sp,8
8110f114:	f800283a 	ret

8110f118 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
8110f118:	defff704 	addi	sp,sp,-36
8110f11c:	de00012e 	bgeu	sp,et,8110f124 <vInitialTask+0xc>
8110f120:	003b68fa 	trap	3
8110f124:	dfc00815 	stw	ra,32(sp)
8110f128:	df000715 	stw	fp,28(sp)
8110f12c:	df000704 	addi	fp,sp,28
8110f130:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8110f134:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110f138:	d8000415 	stw	zero,16(sp)
8110f13c:	d8000315 	stw	zero,12(sp)
8110f140:	00810004 	movi	r2,1024
8110f144:	d8800215 	stw	r2,8(sp)
8110f148:	00a04574 	movhi	r2,33045
8110f14c:	10ba1e04 	addi	r2,r2,-6024
8110f150:	d8800115 	stw	r2,4(sp)
8110f154:	008002c4 	movi	r2,11
8110f158:	d8800015 	stw	r2,0(sp)
8110f15c:	01c002c4 	movi	r7,11
8110f160:	01a04574 	movhi	r6,33045
8110f164:	31be1d04 	addi	r6,r6,-1932
8110f168:	01604574 	movhi	r5,33045
8110f16c:	294f3004 	addi	r5,r5,15552
8110f170:	01204474 	movhi	r4,33041
8110f174:	21329504 	addi	r4,r4,-13740
8110f178:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f17c:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f180:	e0bffe03 	ldbu	r2,-8(fp)
8110f184:	10803fcc 	andi	r2,r2,255
8110f188:	10000526 	beq	r2,zero,8110f1a0 <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f18c:	e0bffe03 	ldbu	r2,-8(fp)
8110f190:	10803fcc 	andi	r2,r2,255
8110f194:	1009883a 	mov	r4,r2
8110f198:	11171a80 	call	811171a8 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
8110f19c:	11186540 	call	81118654 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f1a0:	01c17704 	movi	r7,1500
8110f1a4:	000d883a 	mov	r6,zero
8110f1a8:	000b883a 	mov	r5,zero
8110f1ac:	0009883a 	mov	r4,zero
8110f1b0:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8110f1b4:	d8000415 	stw	zero,16(sp)
8110f1b8:	d8000315 	stw	zero,12(sp)
8110f1bc:	00810004 	movi	r2,1024
8110f1c0:	d8800215 	stw	r2,8(sp)
8110f1c4:	00a04574 	movhi	r2,33045
8110f1c8:	108b1e04 	addi	r2,r2,11384
8110f1cc:	d8800115 	stw	r2,4(sp)
8110f1d0:	00800284 	movi	r2,10
8110f1d4:	d8800015 	stw	r2,0(sp)
8110f1d8:	01c00284 	movi	r7,10
8110f1dc:	01a04574 	movhi	r6,33045
8110f1e0:	318f1d04 	addi	r6,r6,15476
8110f1e4:	01604574 	movhi	r5,33045
8110f1e8:	294f2804 	addi	r5,r5,15520
8110f1ec:	01204474 	movhi	r4,33041
8110f1f0:	21326d04 	addi	r4,r4,-13900
8110f1f4:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f1f8:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f1fc:	e0bffe03 	ldbu	r2,-8(fp)
8110f200:	10803fcc 	andi	r2,r2,255
8110f204:	10000526 	beq	r2,zero,8110f21c <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f208:	e0bffe03 	ldbu	r2,-8(fp)
8110f20c:	10803fcc 	andi	r2,r2,255
8110f210:	1009883a 	mov	r4,r2
8110f214:	11171a80 	call	811171a8 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
8110f218:	111892c0 	call	8111892c <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f21c:	01c17704 	movi	r7,1500
8110f220:	000d883a 	mov	r6,zero
8110f224:	000b883a 	mov	r5,zero
8110f228:	0009883a 	mov	r4,zero
8110f22c:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
8110f230:	d8000415 	stw	zero,16(sp)
8110f234:	d8000315 	stw	zero,12(sp)
8110f238:	00810004 	movi	r2,1024
8110f23c:	d8800215 	stw	r2,8(sp)
8110f240:	00a045b4 	movhi	r2,33046
8110f244:	10a74304 	addi	r2,r2,-25332
8110f248:	d8800115 	stw	r2,4(sp)
8110f24c:	00800244 	movi	r2,9
8110f250:	d8800015 	stw	r2,0(sp)
8110f254:	01c00244 	movi	r7,9
8110f258:	01a045b4 	movhi	r6,33046
8110f25c:	31ab4204 	addi	r6,r6,-21240
8110f260:	01604574 	movhi	r5,33045
8110f264:	294f3004 	addi	r5,r5,15552
8110f268:	01204474 	movhi	r4,33041
8110f26c:	213da704 	addi	r4,r4,-2404
8110f270:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f274:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f278:	e0bffe03 	ldbu	r2,-8(fp)
8110f27c:	10803fcc 	andi	r2,r2,255
8110f280:	10000526 	beq	r2,zero,8110f298 <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f284:	e0bffe03 	ldbu	r2,-8(fp)
8110f288:	10803fcc 	andi	r2,r2,255
8110f28c:	1009883a 	mov	r4,r2
8110f290:	11171a80 	call	811171a8 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
8110f294:	11188c40 	call	811188c4 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f298:	01c17704 	movi	r7,1500
8110f29c:	000d883a 	mov	r6,zero
8110f2a0:	000b883a 	mov	r5,zero
8110f2a4:	0009883a 	mov	r4,zero
8110f2a8:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
8110f2ac:	d8000415 	stw	zero,16(sp)
8110f2b0:	d8000315 	stw	zero,12(sp)
8110f2b4:	00810004 	movi	r2,1024
8110f2b8:	d8800215 	stw	r2,8(sp)
8110f2bc:	00a045b4 	movhi	r2,33046
8110f2c0:	10b95904 	addi	r2,r2,-6812
8110f2c4:	d8800115 	stw	r2,4(sp)
8110f2c8:	00800204 	movi	r2,8
8110f2cc:	d8800015 	stw	r2,0(sp)
8110f2d0:	01c00204 	movi	r7,8
8110f2d4:	01a045b4 	movhi	r6,33046
8110f2d8:	31bd5804 	addi	r6,r6,-2720
8110f2dc:	01604574 	movhi	r5,33045
8110f2e0:	294f1e04 	addi	r5,r5,15480
8110f2e4:	01204474 	movhi	r4,33041
8110f2e8:	21070e04 	addi	r4,r4,7224
8110f2ec:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f2f0:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f2f4:	e0bffe03 	ldbu	r2,-8(fp)
8110f2f8:	10803fcc 	andi	r2,r2,255
8110f2fc:	10000526 	beq	r2,zero,8110f314 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f300:	e0bffe03 	ldbu	r2,-8(fp)
8110f304:	10803fcc 	andi	r2,r2,255
8110f308:	1009883a 	mov	r4,r2
8110f30c:	11171a80 	call	811171a8 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
8110f310:	11189940 	call	81118994 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f314:	01c17704 	movi	r7,1500
8110f318:	000d883a 	mov	r6,zero
8110f31c:	000b883a 	mov	r5,zero
8110f320:	0009883a 	mov	r4,zero
8110f324:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
8110f328:	d8000415 	stw	zero,16(sp)
8110f32c:	d8000315 	stw	zero,12(sp)
8110f330:	00810004 	movi	r2,1024
8110f334:	d8800215 	stw	r2,8(sp)
8110f338:	00a04574 	movhi	r2,33045
8110f33c:	10871e04 	addi	r2,r2,7288
8110f340:	d8800115 	stw	r2,4(sp)
8110f344:	00800784 	movi	r2,30
8110f348:	d8800015 	stw	r2,0(sp)
8110f34c:	01c00784 	movi	r7,30
8110f350:	01a04574 	movhi	r6,33045
8110f354:	318b1d04 	addi	r6,r6,11380
8110f358:	000b883a 	mov	r5,zero
8110f35c:	01204474 	movhi	r4,33041
8110f360:	210db304 	addi	r4,r4,14028
8110f364:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f368:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f36c:	e0bffe03 	ldbu	r2,-8(fp)
8110f370:	10803fcc 	andi	r2,r2,255
8110f374:	10000526 	beq	r2,zero,8110f38c <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f378:	e0bffe03 	ldbu	r2,-8(fp)
8110f37c:	10803fcc 	andi	r2,r2,255
8110f380:	1009883a 	mov	r4,r2
8110f384:	11171a80 	call	811171a8 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
8110f388:	1117fc00 	call	81117fc0 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f38c:	01c03204 	movi	r7,200
8110f390:	000d883a 	mov	r6,zero
8110f394:	000b883a 	mov	r5,zero
8110f398:	0009883a 	mov	r4,zero
8110f39c:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
8110f3a0:	d8000415 	stw	zero,16(sp)
8110f3a4:	d8000315 	stw	zero,12(sp)
8110f3a8:	00810004 	movi	r2,1024
8110f3ac:	d8800215 	stw	r2,8(sp)
8110f3b0:	00a04574 	movhi	r2,33045
8110f3b4:	109a3304 	addi	r2,r2,26828
8110f3b8:	d8800115 	stw	r2,4(sp)
8110f3bc:	008006c4 	movi	r2,27
8110f3c0:	d8800015 	stw	r2,0(sp)
8110f3c4:	01c006c4 	movi	r7,27
8110f3c8:	01a04574 	movhi	r6,33045
8110f3cc:	319e3204 	addi	r6,r6,30920
8110f3d0:	000b883a 	mov	r5,zero
8110f3d4:	01204474 	movhi	r4,33041
8110f3d8:	213f5404 	addi	r4,r4,-688
8110f3dc:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f3e0:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f3e4:	e0bffe03 	ldbu	r2,-8(fp)
8110f3e8:	10803fcc 	andi	r2,r2,255
8110f3ec:	10000526 	beq	r2,zero,8110f404 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f3f0:	e0bffe03 	ldbu	r2,-8(fp)
8110f3f4:	10803fcc 	andi	r2,r2,255
8110f3f8:	1009883a 	mov	r4,r2
8110f3fc:	11171a80 	call	811171a8 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
8110f400:	1117edc0 	call	81117edc <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f404:	01c03204 	movi	r7,200
8110f408:	000d883a 	mov	r6,zero
8110f40c:	000b883a 	mov	r5,zero
8110f410:	0009883a 	mov	r4,zero
8110f414:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
8110f418:	d8000415 	stw	zero,16(sp)
8110f41c:	d8000315 	stw	zero,12(sp)
8110f420:	00810004 	movi	r2,1024
8110f424:	d8800215 	stw	r2,8(sp)
8110f428:	00a04574 	movhi	r2,33045
8110f42c:	10be1e04 	addi	r2,r2,-1928
8110f430:	d8800115 	stw	r2,4(sp)
8110f434:	00800644 	movi	r2,25
8110f438:	d8800015 	stw	r2,0(sp)
8110f43c:	01c00644 	movi	r7,25
8110f440:	01a04574 	movhi	r6,33045
8110f444:	31821d04 	addi	r6,r6,2164
8110f448:	000b883a 	mov	r5,zero
8110f44c:	01204474 	movhi	r4,33041
8110f450:	213a7a04 	addi	r4,r4,-5656
8110f454:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f458:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f45c:	e0bffe03 	ldbu	r2,-8(fp)
8110f460:	10803fcc 	andi	r2,r2,255
8110f464:	10000526 	beq	r2,zero,8110f47c <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f468:	e0bffe03 	ldbu	r2,-8(fp)
8110f46c:	10803fcc 	andi	r2,r2,255
8110f470:	1009883a 	mov	r4,r2
8110f474:	11171a80 	call	811171a8 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
8110f478:	1117e900 	call	81117e90 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f47c:	01c03204 	movi	r7,200
8110f480:	000d883a 	mov	r6,zero
8110f484:	000b883a 	mov	r5,zero
8110f488:	0009883a 	mov	r4,zero
8110f48c:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
8110f490:	d8000415 	stw	zero,16(sp)
8110f494:	d8000315 	stw	zero,12(sp)
8110f498:	00818004 	movi	r2,1536
8110f49c:	d8800215 	stw	r2,8(sp)
8110f4a0:	00a045b4 	movhi	r2,33046
8110f4a4:	10b35504 	addi	r2,r2,-12972
8110f4a8:	d8800115 	stw	r2,4(sp)
8110f4ac:	00800704 	movi	r2,28
8110f4b0:	d8800015 	stw	r2,0(sp)
8110f4b4:	01c00704 	movi	r7,28
8110f4b8:	01a045b4 	movhi	r6,33046
8110f4bc:	31b95404 	addi	r6,r6,-6832
8110f4c0:	000b883a 	mov	r5,zero
8110f4c4:	01204474 	movhi	r4,33041
8110f4c8:	21001204 	addi	r4,r4,72
8110f4cc:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f4d0:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f4d4:	e0bffe03 	ldbu	r2,-8(fp)
8110f4d8:	10803fcc 	andi	r2,r2,255
8110f4dc:	10000526 	beq	r2,zero,8110f4f4 <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f4e0:	e0bffe03 	ldbu	r2,-8(fp)
8110f4e4:	10803fcc 	andi	r2,r2,255
8110f4e8:	1009883a 	mov	r4,r2
8110f4ec:	11171a80 	call	811171a8 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
8110f4f0:	1117e440 	call	81117e44 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f4f4:	01c03204 	movi	r7,200
8110f4f8:	000d883a 	mov	r6,zero
8110f4fc:	000b883a 	mov	r5,zero
8110f500:	0009883a 	mov	r4,zero
8110f504:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8110f508:	d8000415 	stw	zero,16(sp)
8110f50c:	d8000315 	stw	zero,12(sp)
8110f510:	00818004 	movi	r2,1536
8110f514:	d8800215 	stw	r2,8(sp)
8110f518:	00a04574 	movhi	r2,33045
8110f51c:	10942304 	addi	r2,r2,20620
8110f520:	d8800115 	stw	r2,4(sp)
8110f524:	00800804 	movi	r2,32
8110f528:	d8800015 	stw	r2,0(sp)
8110f52c:	01c00804 	movi	r7,32
8110f530:	01a04574 	movhi	r6,33045
8110f534:	319a2204 	addi	r6,r6,26760
8110f538:	000b883a 	mov	r5,zero
8110f53c:	01204474 	movhi	r4,33041
8110f540:	21042e04 	addi	r4,r4,4280
8110f544:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f548:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f54c:	e0bffe03 	ldbu	r2,-8(fp)
8110f550:	10803fcc 	andi	r2,r2,255
8110f554:	10000526 	beq	r2,zero,8110f56c <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110f558:	e0bffe03 	ldbu	r2,-8(fp)
8110f55c:	10803fcc 	andi	r2,r2,255
8110f560:	1009883a 	mov	r4,r2
8110f564:	11171a80 	call	811171a8 <printErrorTask>
		#endif
		vFailReceiverCreate();
8110f568:	11177480 	call	81117748 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f56c:	01c03204 	movi	r7,200
8110f570:	000d883a 	mov	r6,zero
8110f574:	000b883a 	mov	r5,zero
8110f578:	0009883a 	mov	r4,zero
8110f57c:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
8110f580:	d8000415 	stw	zero,16(sp)
8110f584:	d8000315 	stw	zero,12(sp)
8110f588:	00810004 	movi	r2,1024
8110f58c:	d8800215 	stw	r2,8(sp)
8110f590:	00a04574 	movhi	r2,33045
8110f594:	10831204 	addi	r2,r2,3144
8110f598:	d8800115 	stw	r2,4(sp)
8110f59c:	00800684 	movi	r2,26
8110f5a0:	d8800015 	stw	r2,0(sp)
8110f5a4:	01c00684 	movi	r7,26
8110f5a8:	01a04574 	movhi	r6,33045
8110f5ac:	31871104 	addi	r6,r6,7236
8110f5b0:	000b883a 	mov	r5,zero
8110f5b4:	01204474 	movhi	r4,33041
8110f5b8:	2106b004 	addi	r4,r4,6848
8110f5bc:	113af640 	call	8113af64 <OSTaskCreateExt>
8110f5c0:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8110f5c4:	01c03204 	movi	r7,200
8110f5c8:	000d883a 	mov	r6,zero
8110f5cc:	000b883a 	mov	r5,zero
8110f5d0:	0009883a 	mov	r4,zero
8110f5d4:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8110f5d8:	e0bffe03 	ldbu	r2,-8(fp)
8110f5dc:	10803fcc 	andi	r2,r2,255
8110f5e0:	10000526 	beq	r2,zero,8110f5f8 <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110f5e4:	e0bffe03 	ldbu	r2,-8(fp)
8110f5e8:	10803fcc 	andi	r2,r2,255
8110f5ec:	1009883a 	mov	r4,r2
8110f5f0:	11171a80 	call	811171a8 <printErrorTask>
		#endif
		vFailSenderCreate();
8110f5f4:	11177940 	call	81117794 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8110f5f8:	d0a06817 	ldw	r2,-32352(gp)
8110f5fc:	e17ffe04 	addi	r5,fp,-8
8110f600:	1009883a 	mov	r4,r2
8110f604:	113cc840 	call	8113cc84 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8110f608:	e0bffe03 	ldbu	r2,-8(fp)
8110f60c:	10803fcc 	andi	r2,r2,255
8110f610:	10000126 	beq	r2,zero,8110f618 <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8110f614:	111827c0 	call	8111827c <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8110f618:	01c00084 	movi	r7,2
8110f61c:	01800784 	movi	r6,30
8110f620:	000b883a 	mov	r5,zero
8110f624:	0009883a 	mov	r4,zero
8110f628:	113c1900 	call	8113c190 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8110f62c:	01003fc4 	movi	r4,255
8110f630:	113b1500 	call	8113b150 <OSTaskDel>
8110f634:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8110f638:	e0bffe03 	ldbu	r2,-8(fp)
8110f63c:	10803fcc 	andi	r2,r2,255
8110f640:	10001026 	beq	r2,zero,8110f684 <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110f644:	e0bffe03 	ldbu	r2,-8(fp)
8110f648:	10803fcc 	andi	r2,r2,255
8110f64c:	1009883a 	mov	r4,r2
8110f650:	11171a80 	call	811171a8 <printErrorTask>
		#endif
		vFailDeleteInitialization();
8110f654:	11177e00 	call	811177e0 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8110f658:	014009c4 	movi	r5,39
8110f65c:	01000044 	movi	r4,1
8110f660:	113a8b80 	call	8113a8b8 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8110f664:	01003fc4 	movi	r4,255
8110f668:	113b1500 	call	8113b150 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8110f66c:	000f883a 	mov	r7,zero
8110f670:	01800284 	movi	r6,10
8110f674:	000b883a 	mov	r5,zero
8110f678:	0009883a 	mov	r4,zero
8110f67c:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
		}
8110f680:	003ff806 	br	8110f664 <__reset+0xfb0ef664>
	}

}
8110f684:	0001883a 	nop
8110f688:	e037883a 	mov	sp,fp
8110f68c:	dfc00117 	ldw	ra,4(sp)
8110f690:	df000017 	ldw	fp,0(sp)
8110f694:	dec00204 	addi	sp,sp,8
8110f698:	f800283a 	ret

8110f69c <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8110f69c:	defff704 	addi	sp,sp,-36
8110f6a0:	de00012e 	bgeu	sp,et,8110f6a8 <vNFeeControlTask+0xc>
8110f6a4:	003b68fa 	trap	3
8110f6a8:	dfc00815 	stw	ra,32(sp)
8110f6ac:	df000715 	stw	fp,28(sp)
8110f6b0:	df000704 	addi	fp,sp,28
8110f6b4:	e13fff15 	stw	r4,-4(fp)
	INT8U error_codeCtrl;
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
8110f6b8:	e0bfff17 	ldw	r2,-4(fp)
8110f6bc:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
8110f6c0:	d0a05d17 	ldw	r2,-32396(gp)
8110f6c4:	100f883a 	mov	r7,r2
8110f6c8:	01800804 	movi	r6,32
8110f6cc:	01400044 	movi	r5,1
8110f6d0:	01204574 	movhi	r4,33045
8110f6d4:	21217d04 	addi	r4,r4,-31244
8110f6d8:	111c7b80 	call	8111c7b8 <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
8110f6dc:	e0bffa17 	ldw	r2,-24(fp)
8110f6e0:	10809917 	ldw	r2,612(r2)
8110f6e4:	10c00168 	cmpgeui	r3,r2,5
8110f6e8:	1800de1e 	bne	r3,zero,8110fa64 <vNFeeControlTask+0x3c8>
8110f6ec:	100690ba 	slli	r3,r2,2
8110f6f0:	00a04474 	movhi	r2,33041
8110f6f4:	10bdc104 	addi	r2,r2,-2300
8110f6f8:	1885883a 	add	r2,r3,r2
8110f6fc:	10800017 	ldw	r2,0(r2)
8110f700:	1000683a 	jmp	r2
8110f704:	8110f718 	cmpnei	r4,r16,17372
8110f708:	8110f754 	ori	r4,r16,17373
8110f70c:	8110f7a8 	cmpgeui	r4,r16,17374
8110f710:	8110f85c 	xori	r4,r16,17377
8110f714:	8110f8d8 	cmpnei	r4,r16,17379
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
8110f718:	d0a06b17 	ldw	r2,-32340(gp)
8110f71c:	1009883a 	mov	r4,r2
8110f720:	11392400 	call	81139240 <OSQFlush>
8110f724:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f728:	e0bffe03 	ldbu	r2,-8(fp)
8110f72c:	10803fcc 	andi	r2,r2,255
8110f730:	10000126 	beq	r2,zero,8110f738 <vNFeeControlTask+0x9c>
					vFailFlushQueue();
8110f734:	1118f300 	call	81118f30 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
8110f738:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
8110f73c:	00800044 	movi	r2,1
8110f740:	d0a05415 	stw	r2,-32432(gp)
				pxFeeC->sMode = sMebToConfig;
8110f744:	e0bffa17 	ldw	r2,-24(fp)
8110f748:	00c00044 	movi	r3,1
8110f74c:	10c09915 	stw	r3,612(r2)
				break;
8110f750:	0000cf06 	br	8110fa90 <vNFeeControlTask+0x3f4>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
8110f754:	d0a05d17 	ldw	r2,-32396(gp)
8110f758:	100f883a 	mov	r7,r2
8110f75c:	018008c4 	movi	r6,35
8110f760:	01400044 	movi	r5,1
8110f764:	01204574 	movhi	r4,33045
8110f768:	21218604 	addi	r4,r4,-31208
8110f76c:	111c7b80 	call	8111c7b8 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110f770:	d0a05817 	ldw	r2,-32416(gp)
8110f774:	1009883a 	mov	r4,r2
8110f778:	11392400 	call	81139240 <OSQFlush>
8110f77c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f780:	e0bffe03 	ldbu	r2,-8(fp)
8110f784:	10803fcc 	andi	r2,r2,255
8110f788:	10000126 	beq	r2,zero,8110f790 <vNFeeControlTask+0xf4>
					vFailFlushQueue();
8110f78c:	1118f300 	call	81118f30 <vFailFlushQueue>
				}

				pxFeeC->ucTimeCode = 0;
8110f790:	e0bffa17 	ldw	r2,-24(fp)
8110f794:	10009805 	stb	zero,608(r2)
				pxFeeC->sMode = sMebConfig;
8110f798:	e0bffa17 	ldw	r2,-24(fp)
8110f79c:	00c000c4 	movi	r3,3
8110f7a0:	10c09915 	stw	r3,612(r2)
				break;
8110f7a4:	0000ba06 	br	8110fa90 <vNFeeControlTask+0x3f4>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
8110f7a8:	11190880 	call	81119088 <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
8110f7ac:	d0a05d17 	ldw	r2,-32396(gp)
8110f7b0:	100f883a 	mov	r7,r2
8110f7b4:	01800804 	movi	r6,32
8110f7b8:	01400044 	movi	r5,1
8110f7bc:	01204574 	movhi	r4,33045
8110f7c0:	21218f04 	addi	r4,r4,-31172
8110f7c4:	111c7b80 	call	8111c7b8 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110f7c8:	d0a05817 	ldw	r2,-32416(gp)
8110f7cc:	1009883a 	mov	r4,r2
8110f7d0:	11392400 	call	81139240 <OSQFlush>
8110f7d4:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f7d8:	e0bffe03 	ldbu	r2,-8(fp)
8110f7dc:	10803fcc 	andi	r2,r2,255
8110f7e0:	10000126 	beq	r2,zero,8110f7e8 <vNFeeControlTask+0x14c>
					vFailFlushQueue();
8110f7e4:	1118f300 	call	81118f30 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8110f7e8:	e03ff905 	stb	zero,-28(fp)
8110f7ec:	00001006 	br	8110f830 <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
8110f7f0:	e0bff903 	ldbu	r2,-28(fp)
8110f7f4:	1085883a 	add	r2,r2,r2
8110f7f8:	1087883a 	add	r3,r2,r2
8110f7fc:	d0a06504 	addi	r2,gp,-32364
8110f800:	1885883a 	add	r2,r3,r2
8110f804:	10800017 	ldw	r2,0(r2)
8110f808:	1009883a 	mov	r4,r2
8110f80c:	11392400 	call	81139240 <OSQFlush>
8110f810:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
8110f814:	e0bffe03 	ldbu	r2,-8(fp)
8110f818:	10803fcc 	andi	r2,r2,255
8110f81c:	10000126 	beq	r2,zero,8110f824 <vNFeeControlTask+0x188>
						vFailFlushQueue();
8110f820:	1118f300 	call	81118f30 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8110f824:	e0bff903 	ldbu	r2,-28(fp)
8110f828:	10800044 	addi	r2,r2,1
8110f82c:	e0bff905 	stb	r2,-28(fp)
8110f830:	e0bff903 	ldbu	r2,-28(fp)
8110f834:	103fee26 	beq	r2,zero,8110f7f0 <__reset+0xfb0ef7f0>
						vFailFlushQueue();
					}
				}


				pxFeeC->ucTimeCode = 0;
8110f838:	e0bffa17 	ldw	r2,-24(fp)
8110f83c:	10009805 	stb	zero,608(r2)

				bCmdSent = FALSE;
8110f840:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
8110f844:	00800044 	movi	r2,1
8110f848:	d0a05415 	stw	r2,-32432(gp)
				pxFeeC->sMode = sMebRun;
8110f84c:	e0bffa17 	ldw	r2,-24(fp)
8110f850:	00c00104 	movi	r3,4
8110f854:	10c09915 	stw	r3,612(r2)
				break;
8110f858:	00008d06 	br	8110fa90 <vNFeeControlTask+0x3f4>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
8110f85c:	d0a06b17 	ldw	r2,-32340(gp)
8110f860:	e0fffe04 	addi	r3,fp,-8
8110f864:	180d883a 	mov	r6,r3
8110f868:	000b883a 	mov	r5,zero
8110f86c:	1009883a 	mov	r4,r2
8110f870:	11393000 	call	81139300 <OSQPend>
8110f874:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
8110f878:	e0bffe03 	ldbu	r2,-8(fp)
8110f87c:	10803fcc 	andi	r2,r2,255
8110f880:	1000131e 	bne	r2,zero,8110f8d0 <vNFeeControlTask+0x234>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110f884:	e0bffdc3 	ldbu	r2,-9(fp)
8110f888:	10803fcc 	andi	r2,r2,255
8110f88c:	10800418 	cmpnei	r2,r2,16
8110f890:	1000051e 	bne	r2,zero,8110f8a8 <vNFeeControlTask+0x20c>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8110f894:	e0bffd17 	ldw	r2,-12(fp)
8110f898:	e17ffa17 	ldw	r5,-24(fp)
8110f89c:	1009883a 	mov	r4,r2
8110f8a0:	110fa940 	call	8110fa94 <vPerformActionNFCConfig>
8110f8a4:	00000706 	br	8110f8c4 <vNFeeControlTask+0x228>

					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"Provavel para FEE (Remover)\n");
8110f8a8:	d0a05d17 	ldw	r2,-32396(gp)
8110f8ac:	100f883a 	mov	r7,r2
8110f8b0:	01800704 	movi	r6,28
8110f8b4:	01400044 	movi	r5,1
8110f8b8:	01204574 	movhi	r4,33045
8110f8bc:	21219804 	addi	r4,r4,-31136
8110f8c0:	111c7b80 	call	8111c7b8 <fwrite>
						#endif
					}

					bDmaBack = TRUE;
8110f8c4:	00800044 	movi	r2,1
8110f8c8:	d0a05415 	stw	r2,-32432(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
8110f8cc:	00007006 	br	8110fa90 <vNFeeControlTask+0x3f4>
					}

					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8110f8d0:	1118c2c0 	call	81118c2c <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
8110f8d4:	00006e06 	br	8110fa90 <vNFeeControlTask+0x3f4>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8110f8d8:	d0a05417 	ldw	r2,-32432(gp)
8110f8dc:	10800058 	cmpnei	r2,r2,1
8110f8e0:	1000201e 	bne	r2,zero,8110f964 <vNFeeControlTask+0x2c8>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
8110f8e4:	d0a05817 	ldw	r2,-32416(gp)
8110f8e8:	e0fffe04 	addi	r3,fp,-8
8110f8ec:	180d883a 	mov	r6,r3
8110f8f0:	01400104 	movi	r5,4
8110f8f4:	1009883a 	mov	r4,r2
8110f8f8:	11393000 	call	81139300 <OSQPend>
8110f8fc:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
8110f900:	e0bffe03 	ldbu	r2,-8(fp)
8110f904:	10803fcc 	andi	r2,r2,255
8110f908:	1000161e 	bne	r2,zero,8110f964 <vNFeeControlTask+0x2c8>
						ucFeeInstL = uiCmdNFC.ucByte[0];
8110f90c:	e0bffd03 	ldbu	r2,-12(fp)
8110f910:	e0bffc05 	stb	r2,-16(fp)
#ifdef DEBUG_ON
	//fprintf(fp,"\nController: chegou agendamento ( %hhu )\n",ucFeeInstL);
#endif

						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
8110f914:	e0bffc03 	ldbu	r2,-16(fp)
8110f918:	e0fffa17 	ldw	r3,-24(fp)
8110f91c:	10809524 	muli	r2,r2,596
8110f920:	1885883a 	add	r2,r3,r2
8110f924:	10802304 	addi	r2,r2,140
8110f928:	10800017 	ldw	r2,0(r2)
8110f92c:	10800058 	cmpnei	r2,r2,1
8110f930:	10000c1e 	bne	r2,zero,8110f964 <vNFeeControlTask+0x2c8>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
8110f934:	e0bffc03 	ldbu	r2,-16(fp)
8110f938:	e0fffc03 	ldbu	r3,-16(fp)
8110f93c:	180f883a 	mov	r7,r3
8110f940:	000d883a 	mov	r6,zero
8110f944:	014023c4 	movi	r5,143
8110f948:	1009883a 	mov	r4,r2
8110f94c:	110fc880 	call	8110fc88 <bSendCmdQToNFeeInst>
8110f950:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE ) {
8110f954:	e0bffb17 	ldw	r2,-20(fp)
8110f958:	10800058 	cmpnei	r2,r2,1
8110f95c:	1000011e 	bne	r2,zero,8110f964 <vNFeeControlTask+0x2c8>
								bDmaBack = FALSE;
8110f960:	d0205415 	stw	zero,-32432(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
8110f964:	d0a05417 	ldw	r2,-32432(gp)
8110f968:	1000081e 	bne	r2,zero,8110f98c <vNFeeControlTask+0x2f0>
#ifdef DEBUG_ON
	//fprintf(fp,"\nController: Esperando bloqueado FORVA pelo dma de volta na fila xQMaskFeeCtrl\n ");
#endif
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
8110f96c:	d0a06b17 	ldw	r2,-32340(gp)
8110f970:	e0fffe04 	addi	r3,fp,-8
8110f974:	180d883a 	mov	r6,r3
8110f978:	000b883a 	mov	r5,zero
8110f97c:	1009883a 	mov	r4,r2
8110f980:	11393000 	call	81139300 <OSQPend>
8110f984:	e0bffd15 	stw	r2,-12(fp)
8110f988:	00000706 	br	8110f9a8 <vNFeeControlTask+0x30c>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
8110f98c:	d0a06b17 	ldw	r2,-32340(gp)
8110f990:	e0fffe04 	addi	r3,fp,-8
8110f994:	180d883a 	mov	r6,r3
8110f998:	01400104 	movi	r5,4
8110f99c:	1009883a 	mov	r4,r2
8110f9a0:	11393000 	call	81139300 <OSQPend>
8110f9a4:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
8110f9a8:	e0bffe03 	ldbu	r2,-8(fp)
8110f9ac:	10803fcc 	andi	r2,r2,255
8110f9b0:	1000261e 	bne	r2,zero,8110fa4c <vNFeeControlTask+0x3b0>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
8110f9b4:	e0bffd83 	ldbu	r2,-10(fp)
8110f9b8:	10803fcc 	andi	r2,r2,255
8110f9bc:	10802058 	cmpnei	r2,r2,129
8110f9c0:	1000031e 	bne	r2,zero,8110f9d0 <vNFeeControlTask+0x334>
						bDmaBack = TRUE;
8110f9c4:	00800044 	movi	r2,1
8110f9c8:	d0a05415 	stw	r2,-32432(gp)
8110f9cc:	00001f06 	br	8110fa4c <vNFeeControlTask+0x3b0>
//	fprintf(fp,"\nController: Devolveram o dma\n");
#endif
					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110f9d0:	e0bffdc3 	ldbu	r2,-9(fp)
8110f9d4:	10803fcc 	andi	r2,r2,255
8110f9d8:	10800418 	cmpnei	r2,r2,16
8110f9dc:	1000051e 	bne	r2,zero,8110f9f4 <vNFeeControlTask+0x358>
							
#ifdef DEBUG_ON
	//fprintf(fp,"\nController:  Mensagem normal para FEE controller\n ");
#endif
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
8110f9e0:	e0bffd17 	ldw	r2,-12(fp)
8110f9e4:	e17ffa17 	ldw	r5,-24(fp)
8110f9e8:	1009883a 	mov	r4,r2
8110f9ec:	110fb5c0 	call	8110fb5c <vPerformActionNFCRunning>
8110f9f0:	00001606 	br	8110fa4c <vNFeeControlTask+0x3b0>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
8110f9f4:	e0bffdc3 	ldbu	r2,-9(fp)
8110f9f8:	10803fcc 	andi	r2,r2,255
8110f9fc:	10800470 	cmpltui	r2,r2,17
8110fa00:	1000121e 	bne	r2,zero,8110fa4c <vNFeeControlTask+0x3b0>
8110fa04:	e0bffdc3 	ldbu	r2,-9(fp)
8110fa08:	10803fcc 	andi	r2,r2,255
8110fa0c:	108004e8 	cmpgeui	r2,r2,19
8110fa10:	10000e1e 	bne	r2,zero,8110fa4c <vNFeeControlTask+0x3b0>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
8110fa14:	e0bffdc3 	ldbu	r2,-9(fp)
8110fa18:	10bffbc4 	addi	r2,r2,-17
8110fa1c:	10803fcc 	andi	r2,r2,255
8110fa20:	e0fffd83 	ldbu	r3,-10(fp)
8110fa24:	18c03fcc 	andi	r3,r3,255
8110fa28:	e13ffd43 	ldbu	r4,-11(fp)
8110fa2c:	21003fcc 	andi	r4,r4,255
8110fa30:	e17ffd03 	ldbu	r5,-12(fp)
8110fa34:	29403fcc 	andi	r5,r5,255
8110fa38:	280f883a 	mov	r7,r5
8110fa3c:	200d883a 	mov	r6,r4
8110fa40:	180b883a 	mov	r5,r3
8110fa44:	1009883a 	mov	r4,r2
8110fa48:	110fc880 	call	8110fc88 <bSendCmdQToNFeeInst>

							}
						}
					}
				}
				OSTimeDlyHMSM(0,0,0,10); /*remover!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110fa4c:	01c00284 	movi	r7,10
8110fa50:	000d883a 	mov	r6,zero
8110fa54:	000b883a 	mov	r5,zero
8110fa58:	0009883a 	mov	r4,zero
8110fa5c:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
				break;		
8110fa60:	00000b06 	br	8110fa90 <vNFeeControlTask+0x3f4>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
8110fa64:	d0a05d17 	ldw	r2,-32396(gp)
8110fa68:	100f883a 	mov	r7,r2
8110fa6c:	01800f44 	movi	r6,61
8110fa70:	01400044 	movi	r5,1
8110fa74:	01204574 	movhi	r4,33045
8110fa78:	2121a004 	addi	r4,r4,-31104
8110fa7c:	111c7b80 	call	8111c7b8 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
8110fa80:	e0bffa17 	ldw	r2,-24(fp)
8110fa84:	00c000c4 	movi	r3,3
8110fa88:	10c09915 	stw	r3,612(r2)
				break;
8110fa8c:	0001883a 	nop
		}
	}
8110fa90:	003f1206 	br	8110f6dc <__reset+0xfb0ef6dc>

8110fa94 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110fa94:	defffb04 	addi	sp,sp,-20
8110fa98:	de00012e 	bgeu	sp,et,8110faa0 <vPerformActionNFCConfig+0xc>
8110fa9c:	003b68fa 	trap	3
8110faa0:	dfc00415 	stw	ra,16(sp)
8110faa4:	df000315 	stw	fp,12(sp)
8110faa8:	df000304 	addi	fp,sp,12
8110faac:	e13ffe15 	stw	r4,-8(fp)
8110fab0:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110fab4:	e0bffe17 	ldw	r2,-8(fp)
8110fab8:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110fabc:	e0bffd83 	ldbu	r2,-10(fp)
8110fac0:	10803fcc 	andi	r2,r2,255
8110fac4:	10c000a0 	cmpeqi	r3,r2,2
8110fac8:	1800121e 	bne	r3,zero,8110fb14 <vPerformActionNFCConfig+0x80>
8110facc:	10c000c8 	cmpgei	r3,r2,3
8110fad0:	1800031e 	bne	r3,zero,8110fae0 <vPerformActionNFCConfig+0x4c>
8110fad4:	10800060 	cmpeqi	r2,r2,1
8110fad8:	1000061e 	bne	r2,zero,8110faf4 <vPerformActionNFCConfig+0x60>
8110fadc:	00001106 	br	8110fb24 <vPerformActionNFCConfig+0x90>
8110fae0:	10c02860 	cmpeqi	r3,r2,161
8110fae4:	1800031e 	bne	r3,zero,8110faf4 <vPerformActionNFCConfig+0x60>
8110fae8:	108028a0 	cmpeqi	r2,r2,162
8110faec:	1000091e 	bne	r2,zero,8110fb14 <vPerformActionNFCConfig+0x80>
8110faf0:	00000c06 	br	8110fb24 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
8110faf4:	d0a05d17 	ldw	r2,-32396(gp)
8110faf8:	100f883a 	mov	r7,r2
8110fafc:	01800d44 	movi	r6,53
8110fb00:	01400044 	movi	r5,1
8110fb04:	01204574 	movhi	r4,33045
8110fb08:	2121b004 	addi	r4,r4,-31040
8110fb0c:	111c7b80 	call	8111c7b8 <fwrite>
			#endif
			/* Do nothing for now */
			break;
8110fb10:	00000c06 	br	8110fb44 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
8110fb14:	e0bfff17 	ldw	r2,-4(fp)
8110fb18:	00c00084 	movi	r3,2
8110fb1c:	10c09915 	stw	r3,612(r2)
			break;
8110fb20:	00000806 	br	8110fb44 <vPerformActionNFCConfig+0xb0>

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
8110fb24:	d0a05d17 	ldw	r2,-32396(gp)
8110fb28:	100f883a 	mov	r7,r2
8110fb2c:	018009c4 	movi	r6,39
8110fb30:	01400044 	movi	r5,1
8110fb34:	01204574 	movhi	r4,33045
8110fb38:	2121be04 	addi	r4,r4,-30984
8110fb3c:	111c7b80 	call	8111c7b8 <fwrite>
			#endif	
			break;
8110fb40:	0001883a 	nop
	}

}
8110fb44:	0001883a 	nop
8110fb48:	e037883a 	mov	sp,fp
8110fb4c:	dfc00117 	ldw	ra,4(sp)
8110fb50:	df000017 	ldw	fp,0(sp)
8110fb54:	dec00204 	addi	sp,sp,8
8110fb58:	f800283a 	ret

8110fb5c <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110fb5c:	defffa04 	addi	sp,sp,-24
8110fb60:	de00012e 	bgeu	sp,et,8110fb68 <vPerformActionNFCRunning+0xc>
8110fb64:	003b68fa 	trap	3
8110fb68:	dfc00515 	stw	ra,20(sp)
8110fb6c:	df000415 	stw	fp,16(sp)
8110fb70:	df000404 	addi	fp,sp,16
8110fb74:	e13ffe15 	stw	r4,-8(fp)
8110fb78:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
8110fb7c:	e0bffe17 	ldw	r2,-8(fp)
8110fb80:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110fb84:	e0bffd83 	ldbu	r2,-10(fp)
8110fb88:	10803fcc 	andi	r2,r2,255
8110fb8c:	10c000a0 	cmpeqi	r3,r2,2
8110fb90:	1800271e 	bne	r3,zero,8110fc30 <vPerformActionNFCRunning+0xd4>
8110fb94:	10c02860 	cmpeqi	r3,r2,161
8110fb98:	1800021e 	bne	r3,zero,8110fba4 <vPerformActionNFCRunning+0x48>
8110fb9c:	10800060 	cmpeqi	r2,r2,1
8110fba0:	10002b26 	beq	r2,zero,8110fc50 <vPerformActionNFCRunning+0xf4>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to Config Mode\n");
8110fba4:	d0a05d17 	ldw	r2,-32396(gp)
8110fba8:	100f883a 	mov	r7,r2
8110fbac:	01800b84 	movi	r6,46
8110fbb0:	01400044 	movi	r5,1
8110fbb4:	01204574 	movhi	r4,33045
8110fbb8:	2121c804 	addi	r4,r4,-30944
8110fbbc:	111c7b80 	call	8111c7b8 <fwrite>
			#endif

			pxFeeCP->sMode = sMebToConfig;
8110fbc0:	e0bfff17 	ldw	r2,-4(fp)
8110fbc4:	00c00044 	movi	r3,1
8110fbc8:	10c09915 	stw	r3,612(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8110fbcc:	e03ffc05 	stb	zero,-16(fp)
8110fbd0:	00001406 	br	8110fc24 <vPerformActionNFCRunning+0xc8>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
8110fbd4:	e0bffc03 	ldbu	r2,-16(fp)
8110fbd8:	e0ffff17 	ldw	r3,-4(fp)
8110fbdc:	10802584 	addi	r2,r2,150
8110fbe0:	1085883a 	add	r2,r2,r2
8110fbe4:	1085883a 	add	r2,r2,r2
8110fbe8:	1885883a 	add	r2,r3,r2
8110fbec:	10800017 	ldw	r2,0(r2)
8110fbf0:	10800017 	ldw	r2,0(r2)
8110fbf4:	10800058 	cmpnei	r2,r2,1
8110fbf8:	1000071e 	bne	r2,zero,8110fc18 <vPerformActionNFCRunning+0xbc>
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
8110fbfc:	e0bffc03 	ldbu	r2,-16(fp)
8110fc00:	e0fffc03 	ldbu	r3,-16(fp)
8110fc04:	180f883a 	mov	r7,r3
8110fc08:	000d883a 	mov	r6,zero
8110fc0c:	01402844 	movi	r5,161
8110fc10:	1009883a 	mov	r4,r2
8110fc14:	110fc880 	call	8110fc88 <bSendCmdQToNFeeInst>
			#endif

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8110fc18:	e0bffc03 	ldbu	r2,-16(fp)
8110fc1c:	10800044 	addi	r2,r2,1
8110fc20:	e0bffc05 	stb	r2,-16(fp)
8110fc24:	e0bffc03 	ldbu	r2,-16(fp)
8110fc28:	103fea26 	beq	r2,zero,8110fbd4 <__reset+0xfb0efbd4>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
8110fc2c:	00001006 	br	8110fc70 <vPerformActionNFCRunning+0x114>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
8110fc30:	d0a05d17 	ldw	r2,-32396(gp)
8110fc34:	100f883a 	mov	r7,r2
8110fc38:	01800d84 	movi	r6,54
8110fc3c:	01400044 	movi	r5,1
8110fc40:	01204574 	movhi	r4,33045
8110fc44:	2121d404 	addi	r4,r4,-30896
8110fc48:	111c7b80 	call	8111c7b8 <fwrite>
			#endif		
			/* Do nothing for now */

			break;		
8110fc4c:	00000806 	br	8110fc70 <vPerformActionNFCRunning+0x114>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110fc50:	d0a05d17 	ldw	r2,-32396(gp)
8110fc54:	100f883a 	mov	r7,r2
8110fc58:	01800984 	movi	r6,38
8110fc5c:	01400044 	movi	r5,1
8110fc60:	01204574 	movhi	r4,33045
8110fc64:	2121e204 	addi	r4,r4,-30840
8110fc68:	111c7b80 	call	8111c7b8 <fwrite>
			#endif	
			break;
8110fc6c:	0001883a 	nop
	}
}
8110fc70:	0001883a 	nop
8110fc74:	e037883a 	mov	sp,fp
8110fc78:	dfc00117 	ldw	ra,4(sp)
8110fc7c:	df000017 	ldw	fp,0(sp)
8110fc80:	dec00204 	addi	sp,sp,8
8110fc84:	f800283a 	ret

8110fc88 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110fc88:	defff704 	addi	sp,sp,-36
8110fc8c:	de00012e 	bgeu	sp,et,8110fc94 <bSendCmdQToNFeeInst+0xc>
8110fc90:	003b68fa 	trap	3
8110fc94:	dfc00815 	stw	ra,32(sp)
8110fc98:	df000715 	stw	fp,28(sp)
8110fc9c:	df000704 	addi	fp,sp,28
8110fca0:	2011883a 	mov	r8,r4
8110fca4:	2809883a 	mov	r4,r5
8110fca8:	3007883a 	mov	r3,r6
8110fcac:	3805883a 	mov	r2,r7
8110fcb0:	e23ffc05 	stb	r8,-16(fp)
8110fcb4:	e13ffd05 	stb	r4,-12(fp)
8110fcb8:	e0fffe05 	stb	r3,-8(fp)
8110fcbc:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8110fcc0:	e0bffc03 	ldbu	r2,-16(fp)
8110fcc4:	10800444 	addi	r2,r2,17
8110fcc8:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110fccc:	e0bffd03 	ldbu	r2,-12(fp)
8110fcd0:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110fcd4:	e0bffe03 	ldbu	r2,-8(fp)
8110fcd8:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110fcdc:	e0bfff03 	ldbu	r2,-4(fp)
8110fce0:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110fce4:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8110fce8:	e0bffc03 	ldbu	r2,-16(fp)
8110fcec:	1085883a 	add	r2,r2,r2
8110fcf0:	1087883a 	add	r3,r2,r2
8110fcf4:	d0a06504 	addi	r2,gp,-32364
8110fcf8:	1885883a 	add	r2,r3,r2
8110fcfc:	10800017 	ldw	r2,0(r2)
8110fd00:	e0fffb17 	ldw	r3,-20(fp)
8110fd04:	180b883a 	mov	r5,r3
8110fd08:	1009883a 	mov	r4,r2
8110fd0c:	11397080 	call	81139708 <OSQPost>
8110fd10:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110fd14:	e0bffa03 	ldbu	r2,-24(fp)
8110fd18:	10000526 	beq	r2,zero,8110fd30 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8110fd1c:	e0bffc03 	ldbu	r2,-16(fp)
8110fd20:	1009883a 	mov	r4,r2
8110fd24:	1118cfc0 	call	81118cfc <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8110fd28:	e03ff915 	stw	zero,-28(fp)
8110fd2c:	00000206 	br	8110fd38 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
8110fd30:	00800044 	movi	r2,1
8110fd34:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8110fd38:	e0bff917 	ldw	r2,-28(fp)
}
8110fd3c:	e037883a 	mov	sp,fp
8110fd40:	dfc00117 	ldw	ra,4(sp)
8110fd44:	df000017 	ldw	fp,0(sp)
8110fd48:	dec00204 	addi	sp,sp,8
8110fd4c:	f800283a 	ret

8110fd50 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
8110fd50:	defff704 	addi	sp,sp,-36
8110fd54:	de00012e 	bgeu	sp,et,8110fd5c <vOutAckHandlerTask+0xc>
8110fd58:	003b68fa 	trap	3
8110fd5c:	dfc00815 	stw	ra,32(sp)
8110fd60:	df000715 	stw	fp,28(sp)
8110fd64:	df000704 	addi	fp,sp,28
8110fd68:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8110fd6c:	e03ffac5 	stb	zero,-21(fp)
8110fd70:	e03ffb05 	stb	zero,-20(fp)
8110fd74:	e03ffb45 	stb	zero,-19(fp)
8110fd78:	e03ffb85 	stb	zero,-18(fp)
8110fd7c:	e03ffbc5 	stb	zero,-17(fp)
8110fd80:	e03ffc05 	stb	zero,-16(fp)
8110fd84:	e03ffc45 	stb	zero,-15(fp)
8110fd88:	e03ffc85 	stb	zero,-14(fp)
8110fd8c:	e03ffcc5 	stb	zero,-13(fp)
8110fd90:	e03ffd05 	stb	zero,-12(fp)
8110fd94:	e03ffd45 	stb	zero,-11(fp)
8110fd98:	e03ffd85 	stb	zero,-10(fp)
8110fd9c:	e03ffdc5 	stb	zero,-9(fp)
8110fda0:	e03ffe05 	stb	zero,-8(fp)
8110fda4:	e03ffe45 	stb	zero,-7(fp)
8110fda8:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8110fdac:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
8110fdb0:	d0a05d17 	ldw	r2,-32396(gp)
8110fdb4:	100f883a 	mov	r7,r2
8110fdb8:	01800804 	movi	r6,32
8110fdbc:	01400044 	movi	r5,1
8110fdc0:	01204574 	movhi	r4,33045
8110fdc4:	2121ec04 	addi	r4,r4,-30800
8110fdc8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
8110fdcc:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
8110fdd0:	e0bff917 	ldw	r2,-28(fp)
8110fdd4:	10c00060 	cmpeqi	r3,r2,1
8110fdd8:	1800071e 	bne	r3,zero,8110fdf8 <vOutAckHandlerTask+0xa8>
8110fddc:	0080032e 	bgeu	zero,r2,8110fdec <vOutAckHandlerTask+0x9c>
8110fde0:	108000a0 	cmpeqi	r2,r2,2
8110fde4:	1000471e 	bne	r2,zero,8110ff04 <vOutAckHandlerTask+0x1b4>
8110fde8:	00008c06 	br	8111001c <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8110fdec:	00800044 	movi	r2,1
8110fdf0:	e0bff915 	stw	r2,-28(fp)
				break;
8110fdf4:	00009306 	br	81110044 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8110fdf8:	00800044 	movi	r2,1
8110fdfc:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
8110fe00:	d0a05c17 	ldw	r2,-32400(gp)
8110fe04:	e0fffa84 	addi	r3,fp,-22
8110fe08:	180d883a 	mov	r6,r3
8110fe0c:	000b883a 	mov	r5,zero
8110fe10:	1009883a 	mov	r4,r2
8110fe14:	113a1f80 	call	8113a1f8 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110fe18:	e0bffa83 	ldbu	r2,-22(fp)
8110fe1c:	10803fcc 	andi	r2,r2,255
8110fe20:	1000361e 	bne	r2,zero,8110fefc <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8110fe24:	d0a06d17 	ldw	r2,-32332(gp)
8110fe28:	e0fffa84 	addi	r3,fp,-22
8110fe2c:	180d883a 	mov	r6,r3
8110fe30:	000b883a 	mov	r5,zero
8110fe34:	1009883a 	mov	r4,r2
8110fe38:	11381ec0 	call	811381ec <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110fe3c:	e0bffa83 	ldbu	r2,-22(fp)
8110fe40:	10803fcc 	andi	r2,r2,255
8110fe44:	10002b1e 	bne	r2,zero,8110fef4 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110fe48:	e03ffa05 	stb	zero,-24(fp)
8110fe4c:	00002206 	br	8110fed8 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
8110fe50:	e0fffa03 	ldbu	r3,-24(fp)
8110fe54:	00a045b4 	movhi	r2,33046
8110fe58:	10855d04 	addi	r2,r2,5492
8110fe5c:	18c7883a 	add	r3,r3,r3
8110fe60:	18c7883a 	add	r3,r3,r3
8110fe64:	10c5883a 	add	r2,r2,r3
8110fe68:	10800003 	ldbu	r2,0(r2)
8110fe6c:	10803fcc 	andi	r2,r2,255
8110fe70:	1080201c 	xori	r2,r2,128
8110fe74:	10bfe004 	addi	r2,r2,-128
8110fe78:	10001426 	beq	r2,zero,8110fecc <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8110fe7c:	e0fffa03 	ldbu	r3,-24(fp)
8110fe80:	00a045b4 	movhi	r2,33046
8110fe84:	10855d04 	addi	r2,r2,5492
8110fe88:	18c7883a 	add	r3,r3,r3
8110fe8c:	18c7883a 	add	r3,r3,r3
8110fe90:	10c5883a 	add	r2,r2,r3
8110fe94:	10c0000b 	ldhu	r3,0(r2)
8110fe98:	d0e0550d 	sth	r3,-32428(gp)
8110fe9c:	1080008b 	ldhu	r2,2(r2)
8110fea0:	d0a0558d 	sth	r2,-32426(gp)
                                eSenderAckState = sSASending;
8110fea4:	00800084 	movi	r2,2
8110fea8:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110feac:	e0fffa03 	ldbu	r3,-24(fp)
8110feb0:	00a045b4 	movhi	r2,33046
8110feb4:	10855d04 	addi	r2,r2,5492
8110feb8:	18c7883a 	add	r3,r3,r3
8110febc:	18c7883a 	add	r3,r3,r3
8110fec0:	10c5883a 	add	r2,r2,r3
8110fec4:	10000005 	stb	zero,0(r2)
                                break;
8110fec8:	00000606 	br	8110fee4 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110fecc:	e0bffa03 	ldbu	r2,-24(fp)
8110fed0:	10800044 	addi	r2,r2,1
8110fed4:	e0bffa05 	stb	r2,-24(fp)
8110fed8:	e0bffa03 	ldbu	r2,-24(fp)
8110fedc:	10800230 	cmpltui	r2,r2,8
8110fee0:	103fdb1e 	bne	r2,zero,8110fe50 <__reset+0xfb0efe50>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8110fee4:	d0a06d17 	ldw	r2,-32332(gp)
8110fee8:	1009883a 	mov	r4,r2
8110feec:	11387900 	call	81138790 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110fef0:	00005406 	br	81110044 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8110fef4:	11175100 	call	81117510 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110fef8:	00005206 	br	81110044 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8110fefc:	11174a80 	call	811174a8 <vFailGetCountSemaphoreSenderTask>
                }

                break;
8110ff00:	00005006 	br	81110044 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8110ff04:	d0a05503 	ldbu	r2,-32428(gp)
8110ff08:	10803fcc 	andi	r2,r2,255
8110ff0c:	1080201c 	xori	r2,r2,128
8110ff10:	10bfe004 	addi	r2,r2,-128
8110ff14:	108008e0 	cmpeqi	r2,r2,35
8110ff18:	1000201e 	bne	r2,zero,8110ff9c <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8110ff1c:	d0a05543 	ldbu	r2,-32427(gp)
8110ff20:	10c03fcc 	andi	r3,r2,255
8110ff24:	18c0201c 	xori	r3,r3,128
8110ff28:	18ffe004 	addi	r3,r3,-128
8110ff2c:	d0a0558b 	ldhu	r2,-32426(gp)
8110ff30:	113fffcc 	andi	r4,r2,65535
8110ff34:	e0bffac4 	addi	r2,fp,-21
8110ff38:	200f883a 	mov	r7,r4
8110ff3c:	180d883a 	mov	r6,r3
8110ff40:	01604574 	movhi	r5,33045
8110ff44:	2961f504 	addi	r5,r5,-30764
8110ff48:	1009883a 	mov	r4,r2
8110ff4c:	111daac0 	call	8111daac <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
8110ff50:	e0bffac4 	addi	r2,fp,-21
8110ff54:	1009883a 	mov	r4,r2
8110ff58:	111dcc00 	call	8111dcc0 <strlen>
8110ff5c:	1007883a 	mov	r3,r2
8110ff60:	e0bffac4 	addi	r2,fp,-21
8110ff64:	180b883a 	mov	r5,r3
8110ff68:	1009883a 	mov	r4,r2
8110ff6c:	111706c0 	call	8111706c <ucCrc8wInit>
8110ff70:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
8110ff74:	e13ffa43 	ldbu	r4,-23(fp)
8110ff78:	e0fffac4 	addi	r3,fp,-21
8110ff7c:	e0bffac4 	addi	r2,fp,-21
8110ff80:	200f883a 	mov	r7,r4
8110ff84:	180d883a 	mov	r6,r3
8110ff88:	01604574 	movhi	r5,33045
8110ff8c:	2961f704 	addi	r5,r5,-30756
8110ff90:	1009883a 	mov	r4,r2
8110ff94:	111daac0 	call	8111daac <sprintf>
8110ff98:	00000c06 	br	8110ffcc <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
8110ff9c:	e0bffac4 	addi	r2,fp,-21
8110ffa0:	00c008c4 	movi	r3,35
8110ffa4:	10c00005 	stb	r3,0(r2)
8110ffa8:	00c01f04 	movi	r3,124
8110ffac:	10c00045 	stb	r3,1(r2)
8110ffb0:	00c00d44 	movi	r3,53
8110ffb4:	10c00085 	stb	r3,2(r2)
8110ffb8:	00c00d04 	movi	r3,52
8110ffbc:	10c000c5 	stb	r3,3(r2)
8110ffc0:	00c00ec4 	movi	r3,59
8110ffc4:	10c00105 	stb	r3,4(r2)
8110ffc8:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
8110ffcc:	d0a06f17 	ldw	r2,-32324(gp)
8110ffd0:	e0fffa84 	addi	r3,fp,-22
8110ffd4:	180d883a 	mov	r6,r3
8110ffd8:	01401904 	movi	r5,100
8110ffdc:	1009883a 	mov	r4,r2
8110ffe0:	11381ec0 	call	811381ec <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8110ffe4:	e0bffa83 	ldbu	r2,-22(fp)
8110ffe8:	10803fcc 	andi	r2,r2,255
8110ffec:	1000071e 	bne	r2,zero,8111000c <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
8110fff0:	e0bffac4 	addi	r2,fp,-21
8110fff4:	1009883a 	mov	r4,r2
8110fff8:	111d7680 	call	8111d768 <puts>
                    OSMutexPost(xTxUARTMutex);
8110fffc:	d0a06f17 	ldw	r2,-32324(gp)
81110000:	1009883a 	mov	r4,r2
81110004:	11387900 	call	81138790 <OSMutexPost>
81110008:	00000106 	br	81110010 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8111000c:	11176480 	call	81117648 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81110010:	00800044 	movi	r2,1
81110014:	e0bff915 	stw	r2,-28(fp)
                
				break;
81110018:	00000a06 	br	81110044 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
8111001c:	d0a05d17 	ldw	r2,-32396(gp)
81110020:	100f883a 	mov	r7,r2
81110024:	01801104 	movi	r6,68
81110028:	01400044 	movi	r5,1
8111002c:	01204574 	movhi	r4,33045
81110030:	2121fa04 	addi	r4,r4,-30744
81110034:	111c7b80 	call	8111c7b8 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
81110038:	00800044 	movi	r2,1
8111003c:	e0bff915 	stw	r2,-28(fp)
				break;
81110040:	0001883a 	nop
		}
	}
81110044:	003f6206 	br	8110fdd0 <__reset+0xfb0efdd0>

81110048 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
81110048:	deffd704 	addi	sp,sp,-164
8111004c:	de00012e 	bgeu	sp,et,81110054 <vParserCommTask+0xc>
81110050:	003b68fa 	trap	3
81110054:	dfc02815 	stw	ra,160(sp)
81110058:	df002715 	stw	fp,156(sp)
8111005c:	df002704 	addi	fp,sp,156
81110060:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
81110064:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
81110068:	d0a05d17 	ldw	r2,-32396(gp)
8111006c:	100f883a 	mov	r7,r2
81110070:	01800704 	movi	r6,28
81110074:	01400044 	movi	r5,1
81110078:	01204574 	movhi	r4,33045
8111007c:	21220c04 	addi	r4,r4,-30672
81110080:	111c7b80 	call	8111c7b8 <fwrite>
    #endif

	eParserMode = sConfiguring;
81110084:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
81110088:	e0bfdc17 	ldw	r2,-144(fp)
8111008c:	10800168 	cmpgeui	r2,r2,5
81110090:	1003651e 	bne	r2,zero,81110e28 <vParserCommTask+0xde0>
81110094:	e0bfdc17 	ldw	r2,-144(fp)
81110098:	100690ba 	slli	r3,r2,2
8111009c:	00a04474 	movhi	r2,33041
811100a0:	10802c04 	addi	r2,r2,176
811100a4:	1885883a 	add	r2,r3,r2
811100a8:	10800017 	ldw	r2,0(r2)
811100ac:	1000683a 	jmp	r2
811100b0:	811100c4 	addi	r4,r16,17411
811100b4:	811100d0 	cmplti	r4,r16,17411
811100b8:	81110164 	muli	r4,r16,17413
811100bc:	811102c8 	cmpgei	r4,r16,17419
811100c0:	8111030c 	andi	r4,r16,17420
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
811100c4:	00800044 	movi	r2,1
811100c8:	e0bfdc15 	stw	r2,-144(fp)
				break;
811100cc:	00035906 	br	81110e34 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
811100d0:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
811100d4:	00800044 	movi	r2,1
811100d8:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
811100dc:	d0a05f17 	ldw	r2,-32388(gp)
811100e0:	e0ffde84 	addi	r3,fp,-134
811100e4:	180d883a 	mov	r6,r3
811100e8:	000b883a 	mov	r5,zero
811100ec:	1009883a 	mov	r4,r2
811100f0:	113a1f80 	call	8113a1f8 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
811100f4:	e0bfde83 	ldbu	r2,-134(fp)
811100f8:	10803fcc 	andi	r2,r2,255
811100fc:	1000171e 	bne	r2,zero,8111015c <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81110100:	01204574 	movhi	r4,33045
81110104:	21388404 	addi	r4,r4,-7664
81110108:	1110e380 	call	81110e38 <getPreParsedPacket>
8111010c:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81110110:	e0bfdd17 	ldw	r2,-140(fp)
81110114:	10800058 	cmpnei	r2,r2,1
81110118:	10000e1e 	bne	r2,zero,81110154 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8111011c:	00a04574 	movhi	r2,33045
81110120:	10b88404 	addi	r2,r2,-7664
81110124:	10800103 	ldbu	r2,4(r2)
81110128:	10803fcc 	andi	r2,r2,255
8111012c:	1080201c 	xori	r2,r2,128
81110130:	10bfe004 	addi	r2,r2,-128
81110134:	10800858 	cmpnei	r2,r2,33
81110138:	1000031e 	bne	r2,zero,81110148 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
8111013c:	008000c4 	movi	r2,3
81110140:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81110144:	00033b06 	br	81110e34 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
81110148:	00800084 	movi	r2,2
8111014c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81110150:	00033806 	br	81110e34 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
81110154:	1117bd40 	call	81117bd4 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81110158:	00033606 	br	81110e34 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8111015c:	1117b040 	call	81117b04 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
81110160:	00033406 	br	81110e34 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
81110164:	00a04574 	movhi	r2,33045
81110168:	10b88404 	addi	r2,r2,-7664
8111016c:	10800143 	ldbu	r2,5(r2)
81110170:	10803fcc 	andi	r2,r2,255
81110174:	1080201c 	xori	r2,r2,128
81110178:	10bfe004 	addi	r2,r2,-128
8111017c:	10c010e0 	cmpeqi	r3,r2,67
81110180:	1800031e 	bne	r3,zero,81110190 <vParserCommTask+0x148>
81110184:	10801420 	cmpeqi	r2,r2,80
81110188:	1000051e 	bne	r2,zero,811101a0 <vParserCommTask+0x158>
8111018c:	00004a06 	br	811102b8 <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81110190:	111583c0 	call	8111583c <vSendEthConf>
						eParserMode = sWaitingMessage;
81110194:	00800044 	movi	r2,1
81110198:	e0bfdc15 	stw	r2,-144(fp)
						break;
8111019c:	00004906 	br	811102c4 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
811101a0:	e0bfdec4 	addi	r2,fp,-133
811101a4:	01802004 	movi	r6,128
811101a8:	000b883a 	mov	r5,zero
811101ac:	1009883a 	mov	r4,r2
811101b0:	111d31c0 	call	8111d31c <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
811101b4:	00a04574 	movhi	r2,33045
811101b8:	10b88404 	addi	r2,r2,-7664
811101bc:	1080028b 	ldhu	r2,10(r2)
811101c0:	117fffcc 	andi	r5,r2,65535
811101c4:	00a04574 	movhi	r2,33045
811101c8:	10b88404 	addi	r2,r2,-7664
811101cc:	1080030b 	ldhu	r2,12(r2)
811101d0:	11bfffcc 	andi	r6,r2,65535
811101d4:	00a04574 	movhi	r2,33045
811101d8:	10b88404 	addi	r2,r2,-7664
811101dc:	1080038b 	ldhu	r2,14(r2)
811101e0:	10ffffcc 	andi	r3,r2,65535
811101e4:	00a04574 	movhi	r2,33045
811101e8:	10b88404 	addi	r2,r2,-7664
811101ec:	1080040b 	ldhu	r2,16(r2)
811101f0:	113fffcc 	andi	r4,r2,65535
811101f4:	00a04574 	movhi	r2,33045
811101f8:	10b88404 	addi	r2,r2,-7664
811101fc:	1080048b 	ldhu	r2,18(r2)
81110200:	10bfffcc 	andi	r2,r2,65535
81110204:	e23fdec4 	addi	r8,fp,-133
81110208:	d8800215 	stw	r2,8(sp)
8111020c:	d9000115 	stw	r4,4(sp)
81110210:	d8c00015 	stw	r3,0(sp)
81110214:	300f883a 	mov	r7,r6
81110218:	280d883a 	mov	r6,r5
8111021c:	01604574 	movhi	r5,33045
81110220:	29621404 	addi	r5,r5,-30640
81110224:	4009883a 	mov	r4,r8
81110228:	111daac0 	call	8111daac <sprintf>
							debug(fp, cPUSDebug );
8111022c:	d0a05d17 	ldw	r2,-32396(gp)
81110230:	e0ffdec4 	addi	r3,fp,-133
81110234:	180b883a 	mov	r5,r3
81110238:	1009883a 	mov	r4,r2
8111023c:	111c11c0 	call	8111c11c <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81110240:	00a04574 	movhi	r2,33045
81110244:	10b88404 	addi	r2,r2,-7664
81110248:	10c0030b 	ldhu	r3,12(r2)
8111024c:	00a04574 	movhi	r2,33045
81110250:	10b89704 	addi	r2,r2,-7588
81110254:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81110258:	00a04574 	movhi	r2,33045
8111025c:	10b88404 	addi	r2,r2,-7664
81110260:	10c0038b 	ldhu	r3,14(r2)
81110264:	00a04574 	movhi	r2,33045
81110268:	10b89704 	addi	r2,r2,-7588
8111026c:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81110270:	00a04574 	movhi	r2,33045
81110274:	10b88404 	addi	r2,r2,-7664
81110278:	10c0040b 	ldhu	r3,16(r2)
8111027c:	00a04574 	movhi	r2,33045
81110280:	10b89704 	addi	r2,r2,-7588
81110284:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81110288:	00a04574 	movhi	r2,33045
8111028c:	10b88404 	addi	r2,r2,-7664
81110290:	10c0048b 	ldhu	r3,18(r2)
81110294:	00a04574 	movhi	r2,33045
81110298:	10b89704 	addi	r2,r2,-7588
8111029c:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
811102a0:	00a04574 	movhi	r2,33045
811102a4:	10b89704 	addi	r2,r2,-7588
811102a8:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
811102ac:	00800104 	movi	r2,4
811102b0:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
811102b4:	00000306 	br	811102c4 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
811102b8:	00800044 	movi	r2,1
811102bc:	e0bfdc15 	stw	r2,-144(fp)
						break;
811102c0:	0001883a 	nop
				}
				break;
811102c4:	0002db06 	br	81110e34 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
811102c8:	00800044 	movi	r2,1
811102cc:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
811102d0:	00a04574 	movhi	r2,33045
811102d4:	10b89704 	addi	r2,r2,-7588
811102d8:	1080030b 	ldhu	r2,12(r2)
811102dc:	10bfffcc 	andi	r2,r2,65535
811102e0:	10c01220 	cmpeqi	r3,r2,72
811102e4:	1800051e 	bne	r3,zero,811102fc <vParserCommTask+0x2b4>
811102e8:	108014e0 	cmpeqi	r2,r2,83
811102ec:	1000051e 	bne	r2,zero,81110304 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
811102f0:	00800044 	movi	r2,1
811102f4:	e0bfdc15 	stw	r2,-144(fp)
                        break;
811102f8:	00000306 	br	81110308 <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
811102fc:	0001883a 	nop
81110300:	0002cc06 	br	81110e34 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81110304:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81110308:	0002ca06 	br	81110e34 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8111030c:	00800044 	movi	r2,1
81110310:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
81110314:	00a04574 	movhi	r2,33045
81110318:	10b89704 	addi	r2,r2,-7588
8111031c:	1080030b 	ldhu	r2,12(r2)
81110320:	10bfffcc 	andi	r2,r2,65535
81110324:	10c03ea0 	cmpeqi	r3,r2,250
81110328:	1800401e 	bne	r3,zero,8111042c <vParserCommTask+0x3e4>
8111032c:	10c03ec8 	cmpgei	r3,r2,251
81110330:	1800031e 	bne	r3,zero,81110340 <vParserCommTask+0x2f8>
81110334:	10800460 	cmpeqi	r2,r2,17
81110338:	1000061e 	bne	r2,zero,81110354 <vParserCommTask+0x30c>
8111033c:	0002b606 	br	81110e18 <vParserCommTask+0xdd0>
81110340:	10c03ee0 	cmpeqi	r3,r2,251
81110344:	18009d1e 	bne	r3,zero,811105bc <vParserCommTask+0x574>
81110348:	10803f20 	cmpeqi	r2,r2,252
8111034c:	1001321e 	bne	r2,zero,81110818 <vParserCommTask+0x7d0>
81110350:	0002b106 	br	81110e18 <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
81110354:	00a04574 	movhi	r2,33045
81110358:	10b89704 	addi	r2,r2,-7588
8111035c:	1080038b 	ldhu	r2,14(r2)
81110360:	10bfffcc 	andi	r2,r2,65535
81110364:	10800060 	cmpeqi	r2,r2,1
81110368:	10000e26 	beq	r2,zero,811103a4 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
8111036c:	d0a05d17 	ldw	r2,-32396(gp)
81110370:	100f883a 	mov	r7,r2
81110374:	01800944 	movi	r6,37
81110378:	01400044 	movi	r5,1
8111037c:	01204574 	movhi	r4,33045
81110380:	21222a04 	addi	r4,r4,-30552
81110384:	111c7b80 	call	8111c7b8 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
81110388:	00a04574 	movhi	r2,33045
8111038c:	10b89704 	addi	r2,r2,-7588
81110390:	1080040b 	ldhu	r2,16(r2)
81110394:	10bfffcc 	andi	r2,r2,65535
81110398:	1009883a 	mov	r4,r2
8111039c:	111623c0 	call	8111623c <vTMPusTestConnection>

								break;
811103a0:	00002106 	br	81110428 <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811103a4:	e0bfdec4 	addi	r2,fp,-133
811103a8:	01802004 	movi	r6,128
811103ac:	000b883a 	mov	r5,zero
811103b0:	1009883a 	mov	r4,r2
811103b4:	111d31c0 	call	8111d31c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811103b8:	00a04574 	movhi	r2,33045
811103bc:	10b89704 	addi	r2,r2,-7588
811103c0:	1080030b 	ldhu	r2,12(r2)
811103c4:	113fffcc 	andi	r4,r2,65535
811103c8:	00a04574 	movhi	r2,33045
811103cc:	10b89704 	addi	r2,r2,-7588
811103d0:	1080038b 	ldhu	r2,14(r2)
811103d4:	117fffcc 	andi	r5,r2,65535
811103d8:	00a04574 	movhi	r2,33045
811103dc:	10b89704 	addi	r2,r2,-7588
811103e0:	1080040b 	ldhu	r2,16(r2)
811103e4:	10bfffcc 	andi	r2,r2,65535
811103e8:	e0ffdec4 	addi	r3,fp,-133
811103ec:	d8800015 	stw	r2,0(sp)
811103f0:	280f883a 	mov	r7,r5
811103f4:	200d883a 	mov	r6,r4
811103f8:	01604574 	movhi	r5,33045
811103fc:	29623404 	addi	r5,r5,-30512
81110400:	1809883a 	mov	r4,r3
81110404:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110408:	d0a05d17 	ldw	r2,-32396(gp)
8111040c:	e0ffdec4 	addi	r3,fp,-133
81110410:	180b883a 	mov	r5,r3
81110414:	1009883a 	mov	r4,r2
81110418:	111c11c0 	call	8111c11c <fprintf>
								#endif
								eParserMode = sWaitingMessage;
8111041c:	00800044 	movi	r2,1
81110420:	e0bfdc15 	stw	r2,-144(fp)
								break;
81110424:	0001883a 	nop
						}
                        break;
81110428:	00027e06 	br	81110e24 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
8111042c:	00a04574 	movhi	r2,33045
81110430:	10b89704 	addi	r2,r2,-7588
81110434:	1080038b 	ldhu	r2,14(r2)
81110438:	10bfffcc 	andi	r2,r2,65535
8111043c:	10c00f20 	cmpeqi	r3,r2,60
81110440:	18001a1e 	bne	r3,zero,811104ac <vParserCommTask+0x464>
81110444:	10c00f48 	cmpgei	r3,r2,61
81110448:	1800031e 	bne	r3,zero,81110458 <vParserCommTask+0x410>
8111044c:	10800ee0 	cmpeqi	r2,r2,59
81110450:	1000061e 	bne	r2,zero,8111046c <vParserCommTask+0x424>
81110454:	00003706 	br	81110534 <vParserCommTask+0x4ec>
81110458:	10c00f60 	cmpeqi	r3,r2,61
8111045c:	18001e1e 	bne	r3,zero,811104d8 <vParserCommTask+0x490>
81110460:	10800fa0 	cmpeqi	r2,r2,62
81110464:	1000271e 	bne	r2,zero,81110504 <vParserCommTask+0x4bc>
81110468:	00003206 	br	81110534 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
8111046c:	d0a05d17 	ldw	r2,-32396(gp)
81110470:	100f883a 	mov	r7,r2
81110474:	018006c4 	movi	r6,27
81110478:	01400044 	movi	r5,1
8111047c:	01204574 	movhi	r4,33045
81110480:	21224704 	addi	r4,r4,-30436
81110484:	111c7b80 	call	8111c7b8 <fwrite>
								#endif
								vSendReset();
81110488:	1115be40 	call	81115be4 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
8111048c:	000f883a 	mov	r7,zero
81110490:	018000c4 	movi	r6,3
81110494:	000b883a 	mov	r5,zero
81110498:	0009883a 	mov	r4,zero
8111049c:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
811104a0:	0104e204 	movi	r4,5000
811104a4:	110b2c00 	call	8110b2c0 <vRstcSimucamReset>

								break;
811104a8:	00004306 	br	811105b8 <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
811104ac:	d0a05d17 	ldw	r2,-32396(gp)
811104b0:	100f883a 	mov	r7,r2
811104b4:	01800704 	movi	r6,28
811104b8:	01400044 	movi	r5,1
811104bc:	01204574 	movhi	r4,33045
811104c0:	21224e04 	addi	r4,r4,-30408
811104c4:	111c7b80 	call	8111c7b8 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811104c8:	01204574 	movhi	r4,33045
811104cc:	21389704 	addi	r4,r4,-7588
811104d0:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

								break;
811104d4:	00003806 	br	811105b8 <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
811104d8:	d0a05d17 	ldw	r2,-32396(gp)
811104dc:	100f883a 	mov	r7,r2
811104e0:	01800644 	movi	r6,25
811104e4:	01400044 	movi	r5,1
811104e8:	01204574 	movhi	r4,33045
811104ec:	21225604 	addi	r4,r4,-30376
811104f0:	111c7b80 	call	8111c7b8 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811104f4:	01204574 	movhi	r4,33045
811104f8:	21389704 	addi	r4,r4,-7588
811104fc:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

								break;
81110500:	00002d06 	br	811105b8 <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81110504:	d0a05d17 	ldw	r2,-32396(gp)
81110508:	100f883a 	mov	r7,r2
8111050c:	01800744 	movi	r6,29
81110510:	01400044 	movi	r5,1
81110514:	01204574 	movhi	r4,33045
81110518:	21225d04 	addi	r4,r4,-30348
8111051c:	111c7b80 	call	8111c7b8 <fwrite>
								#endif
								vSendTurnOff();
81110520:	1115acc0 	call	81115acc <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
81110524:	01204574 	movhi	r4,33045
81110528:	21389704 	addi	r4,r4,-7588
8111052c:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

								break;
81110530:	00002106 	br	811105b8 <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81110534:	e0bfdec4 	addi	r2,fp,-133
81110538:	01802004 	movi	r6,128
8111053c:	000b883a 	mov	r5,zero
81110540:	1009883a 	mov	r4,r2
81110544:	111d31c0 	call	8111d31c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81110548:	00a04574 	movhi	r2,33045
8111054c:	10b89704 	addi	r2,r2,-7588
81110550:	1080030b 	ldhu	r2,12(r2)
81110554:	113fffcc 	andi	r4,r2,65535
81110558:	00a04574 	movhi	r2,33045
8111055c:	10b89704 	addi	r2,r2,-7588
81110560:	1080038b 	ldhu	r2,14(r2)
81110564:	117fffcc 	andi	r5,r2,65535
81110568:	00a04574 	movhi	r2,33045
8111056c:	10b89704 	addi	r2,r2,-7588
81110570:	1080040b 	ldhu	r2,16(r2)
81110574:	10bfffcc 	andi	r2,r2,65535
81110578:	e0ffdec4 	addi	r3,fp,-133
8111057c:	d8800015 	stw	r2,0(sp)
81110580:	280f883a 	mov	r7,r5
81110584:	200d883a 	mov	r6,r4
81110588:	01604574 	movhi	r5,33045
8111058c:	29623404 	addi	r5,r5,-30512
81110590:	1809883a 	mov	r4,r3
81110594:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110598:	d0a05d17 	ldw	r2,-32396(gp)
8111059c:	e0ffdec4 	addi	r3,fp,-133
811105a0:	180b883a 	mov	r5,r3
811105a4:	1009883a 	mov	r4,r2
811105a8:	111c11c0 	call	8111c11c <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
811105ac:	00800044 	movi	r2,1
811105b0:	e0bfdc15 	stw	r2,-144(fp)
								break;
811105b4:	0001883a 	nop
						}
                        break;
811105b8:	00021a06 	br	81110e24 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
811105bc:	00a04574 	movhi	r2,33045
811105c0:	10b88404 	addi	r2,r2,-7664
811105c4:	1080050b 	ldhu	r2,20(r2)
811105c8:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
811105cc:	e0bfde0b 	ldhu	r2,-136(fp)
811105d0:	108000b0 	cmpltui	r2,r2,2
811105d4:	1000121e 	bne	r2,zero,81110620 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
811105d8:	e0bfdec4 	addi	r2,fp,-133
811105dc:	01802004 	movi	r6,128
811105e0:	000b883a 	mov	r5,zero
811105e4:	1009883a 	mov	r4,r2
811105e8:	111d31c0 	call	8111d31c <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
811105ec:	e0ffde0b 	ldhu	r3,-136(fp)
811105f0:	e0bfdec4 	addi	r2,fp,-133
811105f4:	180d883a 	mov	r6,r3
811105f8:	01604574 	movhi	r5,33045
811105fc:	29626504 	addi	r5,r5,-30316
81110600:	1009883a 	mov	r4,r2
81110604:	111daac0 	call	8111daac <sprintf>
								debug(fp, cPUSDebug );
81110608:	d0a05d17 	ldw	r2,-32396(gp)
8111060c:	e0ffdec4 	addi	r3,fp,-133
81110610:	180b883a 	mov	r5,r3
81110614:	1009883a 	mov	r4,r2
81110618:	111c11c0 	call	8111c11c <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
8111061c:	00020106 	br	81110e24 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81110620:	00a04574 	movhi	r2,33045
81110624:	10b89704 	addi	r2,r2,-7588
81110628:	10800483 	ldbu	r2,18(r2)
8111062c:	10c03fcc 	andi	r3,r2,255
81110630:	00a04574 	movhi	r2,33045
81110634:	10b89704 	addi	r2,r2,-7588
81110638:	18c00284 	addi	r3,r3,10
8111063c:	18c7883a 	add	r3,r3,r3
81110640:	10c5883a 	add	r2,r2,r3
81110644:	e0ffde0b 	ldhu	r3,-136(fp)
81110648:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
8111064c:	00a04574 	movhi	r2,33045
81110650:	10b89704 	addi	r2,r2,-7588
81110654:	10800483 	ldbu	r2,18(r2)
81110658:	10800044 	addi	r2,r2,1
8111065c:	1007883a 	mov	r3,r2
81110660:	00a04574 	movhi	r2,33045
81110664:	10b89704 	addi	r2,r2,-7588
81110668:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
8111066c:	00a04574 	movhi	r2,33045
81110670:	10b89704 	addi	r2,r2,-7588
81110674:	1080038b 	ldhu	r2,14(r2)
81110678:	10bfffcc 	andi	r2,r2,65535
8111067c:	10c000a0 	cmpeqi	r3,r2,2
81110680:	1800191e 	bne	r3,zero,811106e8 <vParserCommTask+0x6a0>
81110684:	10c00160 	cmpeqi	r3,r2,5
81110688:	18002c1e 	bne	r3,zero,8111073c <vParserCommTask+0x6f4>
8111068c:	10800060 	cmpeqi	r2,r2,1
81110690:	10003f26 	beq	r2,zero,81110790 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81110694:	e0bfdec4 	addi	r2,fp,-133
81110698:	01802004 	movi	r6,128
8111069c:	000b883a 	mov	r5,zero
811106a0:	1009883a 	mov	r4,r2
811106a4:	111d31c0 	call	8111d31c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811106a8:	e0ffde0b 	ldhu	r3,-136(fp)
811106ac:	e0bfdec4 	addi	r2,fp,-133
811106b0:	180d883a 	mov	r6,r3
811106b4:	01604574 	movhi	r5,33045
811106b8:	29627404 	addi	r5,r5,-30256
811106bc:	1009883a 	mov	r4,r2
811106c0:	111daac0 	call	8111daac <sprintf>
										debug(fp, cPUSDebug );
811106c4:	d0a05d17 	ldw	r2,-32396(gp)
811106c8:	e0ffdec4 	addi	r3,fp,-133
811106cc:	180b883a 	mov	r5,r3
811106d0:	1009883a 	mov	r4,r2
811106d4:	111c11c0 	call	8111c11c <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
811106d8:	01204574 	movhi	r4,33045
811106dc:	21389704 	addi	r4,r4,-7588
811106e0:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

									break;
811106e4:	00004b06 	br	81110814 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
811106e8:	e0bfdec4 	addi	r2,fp,-133
811106ec:	01802004 	movi	r6,128
811106f0:	000b883a 	mov	r5,zero
811106f4:	1009883a 	mov	r4,r2
811106f8:	111d31c0 	call	8111d31c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811106fc:	e0ffde0b 	ldhu	r3,-136(fp)
81110700:	e0bfdec4 	addi	r2,fp,-133
81110704:	180d883a 	mov	r6,r3
81110708:	01604574 	movhi	r5,33045
8111070c:	29628404 	addi	r5,r5,-30192
81110710:	1009883a 	mov	r4,r2
81110714:	111daac0 	call	8111daac <sprintf>
										debug(fp, cPUSDebug );
81110718:	d0a05d17 	ldw	r2,-32396(gp)
8111071c:	e0ffdec4 	addi	r3,fp,-133
81110720:	180b883a 	mov	r5,r3
81110724:	1009883a 	mov	r4,r2
81110728:	111c11c0 	call	8111c11c <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8111072c:	01204574 	movhi	r4,33045
81110730:	21389704 	addi	r4,r4,-7588
81110734:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

									break;
81110738:	00003606 	br	81110814 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8111073c:	e0bfdec4 	addi	r2,fp,-133
81110740:	01802004 	movi	r6,128
81110744:	000b883a 	mov	r5,zero
81110748:	1009883a 	mov	r4,r2
8111074c:	111d31c0 	call	8111d31c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81110750:	e0ffde0b 	ldhu	r3,-136(fp)
81110754:	e0bfdec4 	addi	r2,fp,-133
81110758:	180d883a 	mov	r6,r3
8111075c:	01604574 	movhi	r5,33045
81110760:	29629404 	addi	r5,r5,-30128
81110764:	1009883a 	mov	r4,r2
81110768:	111daac0 	call	8111daac <sprintf>
										debug(fp, cPUSDebug );
8111076c:	d0a05d17 	ldw	r2,-32396(gp)
81110770:	e0ffdec4 	addi	r3,fp,-133
81110774:	180b883a 	mov	r5,r3
81110778:	1009883a 	mov	r4,r2
8111077c:	111c11c0 	call	8111c11c <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81110780:	01204574 	movhi	r4,33045
81110784:	21389704 	addi	r4,r4,-7588
81110788:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

									break;
8111078c:	00002106 	br	81110814 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81110790:	e0bfdec4 	addi	r2,fp,-133
81110794:	01802004 	movi	r6,128
81110798:	000b883a 	mov	r5,zero
8111079c:	1009883a 	mov	r4,r2
811107a0:	111d31c0 	call	8111d31c <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811107a4:	00a04574 	movhi	r2,33045
811107a8:	10b89704 	addi	r2,r2,-7588
811107ac:	1080030b 	ldhu	r2,12(r2)
811107b0:	113fffcc 	andi	r4,r2,65535
811107b4:	00a04574 	movhi	r2,33045
811107b8:	10b89704 	addi	r2,r2,-7588
811107bc:	1080038b 	ldhu	r2,14(r2)
811107c0:	117fffcc 	andi	r5,r2,65535
811107c4:	00a04574 	movhi	r2,33045
811107c8:	10b89704 	addi	r2,r2,-7588
811107cc:	1080040b 	ldhu	r2,16(r2)
811107d0:	10bfffcc 	andi	r2,r2,65535
811107d4:	e0ffdec4 	addi	r3,fp,-133
811107d8:	d8800015 	stw	r2,0(sp)
811107dc:	280f883a 	mov	r7,r5
811107e0:	200d883a 	mov	r6,r4
811107e4:	01604574 	movhi	r5,33045
811107e8:	29623404 	addi	r5,r5,-30512
811107ec:	1809883a 	mov	r4,r3
811107f0:	111daac0 	call	8111daac <sprintf>
										debug(fp, cPUSDebug );
811107f4:	d0a05d17 	ldw	r2,-32396(gp)
811107f8:	e0ffdec4 	addi	r3,fp,-133
811107fc:	180b883a 	mov	r5,r3
81110800:	1009883a 	mov	r4,r2
81110804:	111c11c0 	call	8111c11c <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
81110808:	00800044 	movi	r2,1
8111080c:	e0bfdc15 	stw	r2,-144(fp)
									break;
81110810:	0001883a 	nop
							}
						}
                        break;
81110814:	00018306 	br	81110e24 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81110818:	00a04574 	movhi	r2,33045
8111081c:	10b88404 	addi	r2,r2,-7664
81110820:	1080050b 	ldhu	r2,20(r2)
81110824:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81110828:	00a04574 	movhi	r2,33045
8111082c:	10b89704 	addi	r2,r2,-7588
81110830:	10800483 	ldbu	r2,18(r2)
81110834:	10c03fcc 	andi	r3,r2,255
81110838:	00a04574 	movhi	r2,33045
8111083c:	10b89704 	addi	r2,r2,-7588
81110840:	18c00284 	addi	r3,r3,10
81110844:	18c7883a 	add	r3,r3,r3
81110848:	10c5883a 	add	r2,r2,r3
8111084c:	e0ffde0b 	ldhu	r3,-136(fp)
81110850:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
81110854:	00a04574 	movhi	r2,33045
81110858:	10b89704 	addi	r2,r2,-7588
8111085c:	10800483 	ldbu	r2,18(r2)
81110860:	10800044 	addi	r2,r2,1
81110864:	1007883a 	mov	r3,r2
81110868:	00a04574 	movhi	r2,33045
8111086c:	10b89704 	addi	r2,r2,-7588
81110870:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
81110874:	00a04574 	movhi	r2,33045
81110878:	10b89704 	addi	r2,r2,-7588
8111087c:	1080038b 	ldhu	r2,14(r2)
81110880:	10bfffcc 	andi	r2,r2,65535
81110884:	10c000e0 	cmpeqi	r3,r2,3
81110888:	18000a1e 	bne	r3,zero,811108b4 <vParserCommTask+0x86c>
8111088c:	10c00108 	cmpgei	r3,r2,4
81110890:	1800031e 	bne	r3,zero,811108a0 <vParserCommTask+0x858>
81110894:	108000a0 	cmpeqi	r2,r2,2
81110898:	1000451e 	bne	r2,zero,811109b0 <vParserCommTask+0x968>
8111089c:	00013c06 	br	81110d90 <vParserCommTask+0xd48>
811108a0:	10c00120 	cmpeqi	r3,r2,4
811108a4:	1800181e 	bne	r3,zero,81110908 <vParserCommTask+0x8c0>
811108a8:	10800160 	cmpeqi	r2,r2,5
811108ac:	10002b1e 	bne	r2,zero,8111095c <vParserCommTask+0x914>
811108b0:	00013706 	br	81110d90 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811108b4:	e0bfdec4 	addi	r2,fp,-133
811108b8:	01802004 	movi	r6,128
811108bc:	000b883a 	mov	r5,zero
811108c0:	1009883a 	mov	r4,r2
811108c4:	111d31c0 	call	8111d31c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811108c8:	e0ffde0b 	ldhu	r3,-136(fp)
811108cc:	e0bfdec4 	addi	r2,fp,-133
811108d0:	180d883a 	mov	r6,r3
811108d4:	01604574 	movhi	r5,33045
811108d8:	2962a604 	addi	r5,r5,-30056
811108dc:	1009883a 	mov	r4,r2
811108e0:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
811108e4:	d0a05d17 	ldw	r2,-32396(gp)
811108e8:	e0ffdec4 	addi	r3,fp,-133
811108ec:	180b883a 	mov	r5,r3
811108f0:	1009883a 	mov	r4,r2
811108f4:	111c11c0 	call	8111c11c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811108f8:	01204574 	movhi	r4,33045
811108fc:	21389704 	addi	r4,r4,-7588
81110900:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

								break;
81110904:	00014306 	br	81110e14 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81110908:	e0bfdec4 	addi	r2,fp,-133
8111090c:	01802004 	movi	r6,128
81110910:	000b883a 	mov	r5,zero
81110914:	1009883a 	mov	r4,r2
81110918:	111d31c0 	call	8111d31c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8111091c:	e0ffde0b 	ldhu	r3,-136(fp)
81110920:	e0bfdec4 	addi	r2,fp,-133
81110924:	180d883a 	mov	r6,r3
81110928:	01604574 	movhi	r5,33045
8111092c:	2962b604 	addi	r5,r5,-29992
81110930:	1009883a 	mov	r4,r2
81110934:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110938:	d0a05d17 	ldw	r2,-32396(gp)
8111093c:	e0ffdec4 	addi	r3,fp,-133
81110940:	180b883a 	mov	r5,r3
81110944:	1009883a 	mov	r4,r2
81110948:	111c11c0 	call	8111c11c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111094c:	01204574 	movhi	r4,33045
81110950:	21389704 	addi	r4,r4,-7588
81110954:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

								break;
81110958:	00012e06 	br	81110e14 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8111095c:	e0bfdec4 	addi	r2,fp,-133
81110960:	01802004 	movi	r6,128
81110964:	000b883a 	mov	r5,zero
81110968:	1009883a 	mov	r4,r2
8111096c:	111d31c0 	call	8111d31c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81110970:	e0ffde0b 	ldhu	r3,-136(fp)
81110974:	e0bfdec4 	addi	r2,fp,-133
81110978:	180d883a 	mov	r6,r3
8111097c:	01604574 	movhi	r5,33045
81110980:	2962c604 	addi	r5,r5,-29928
81110984:	1009883a 	mov	r4,r2
81110988:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
8111098c:	d0a05d17 	ldw	r2,-32396(gp)
81110990:	e0ffdec4 	addi	r3,fp,-133
81110994:	180b883a 	mov	r5,r3
81110998:	1009883a 	mov	r4,r2
8111099c:	111c11c0 	call	8111c11c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811109a0:	01204574 	movhi	r4,33045
811109a4:	21389704 	addi	r4,r4,-7588
811109a8:	1110f500 	call	81110f50 <bSendMessagePUStoMebTask>

								break;
811109ac:	00011906 	br	81110e14 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
811109b0:	00a04574 	movhi	r2,33045
811109b4:	10b89704 	addi	r2,r2,-7588
811109b8:	10800483 	ldbu	r2,18(r2)
811109bc:	10c03fcc 	andi	r3,r2,255
811109c0:	00a04574 	movhi	r2,33045
811109c4:	10b88404 	addi	r2,r2,-7664
811109c8:	1100058b 	ldhu	r4,22(r2)
811109cc:	00a04574 	movhi	r2,33045
811109d0:	10b89704 	addi	r2,r2,-7588
811109d4:	18c00284 	addi	r3,r3,10
811109d8:	18c7883a 	add	r3,r3,r3
811109dc:	10c5883a 	add	r2,r2,r3
811109e0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811109e4:	00a04574 	movhi	r2,33045
811109e8:	10b89704 	addi	r2,r2,-7588
811109ec:	10800483 	ldbu	r2,18(r2)
811109f0:	10800044 	addi	r2,r2,1
811109f4:	1007883a 	mov	r3,r2
811109f8:	00a04574 	movhi	r2,33045
811109fc:	10b89704 	addi	r2,r2,-7588
81110a00:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
81110a04:	00a04574 	movhi	r2,33045
81110a08:	10b89704 	addi	r2,r2,-7588
81110a0c:	10800483 	ldbu	r2,18(r2)
81110a10:	10c03fcc 	andi	r3,r2,255
81110a14:	00a04574 	movhi	r2,33045
81110a18:	10b88404 	addi	r2,r2,-7664
81110a1c:	1100060b 	ldhu	r4,24(r2)
81110a20:	00a04574 	movhi	r2,33045
81110a24:	10b89704 	addi	r2,r2,-7588
81110a28:	18c00284 	addi	r3,r3,10
81110a2c:	18c7883a 	add	r3,r3,r3
81110a30:	10c5883a 	add	r2,r2,r3
81110a34:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110a38:	00a04574 	movhi	r2,33045
81110a3c:	10b89704 	addi	r2,r2,-7588
81110a40:	10800483 	ldbu	r2,18(r2)
81110a44:	10800044 	addi	r2,r2,1
81110a48:	1007883a 	mov	r3,r2
81110a4c:	00a04574 	movhi	r2,33045
81110a50:	10b89704 	addi	r2,r2,-7588
81110a54:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81110a58:	00a04574 	movhi	r2,33045
81110a5c:	10b89704 	addi	r2,r2,-7588
81110a60:	10800483 	ldbu	r2,18(r2)
81110a64:	10c03fcc 	andi	r3,r2,255
81110a68:	00a04574 	movhi	r2,33045
81110a6c:	10b88404 	addi	r2,r2,-7664
81110a70:	1100068b 	ldhu	r4,26(r2)
81110a74:	00a04574 	movhi	r2,33045
81110a78:	10b89704 	addi	r2,r2,-7588
81110a7c:	18c00284 	addi	r3,r3,10
81110a80:	18c7883a 	add	r3,r3,r3
81110a84:	10c5883a 	add	r2,r2,r3
81110a88:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110a8c:	00a04574 	movhi	r2,33045
81110a90:	10b89704 	addi	r2,r2,-7588
81110a94:	10800483 	ldbu	r2,18(r2)
81110a98:	10800044 	addi	r2,r2,1
81110a9c:	1007883a 	mov	r3,r2
81110aa0:	00a04574 	movhi	r2,33045
81110aa4:	10b89704 	addi	r2,r2,-7588
81110aa8:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
81110aac:	00a04574 	movhi	r2,33045
81110ab0:	10b89704 	addi	r2,r2,-7588
81110ab4:	10800483 	ldbu	r2,18(r2)
81110ab8:	10c03fcc 	andi	r3,r2,255
81110abc:	00a04574 	movhi	r2,33045
81110ac0:	10b88404 	addi	r2,r2,-7664
81110ac4:	1100070b 	ldhu	r4,28(r2)
81110ac8:	00a04574 	movhi	r2,33045
81110acc:	10b89704 	addi	r2,r2,-7588
81110ad0:	18c00284 	addi	r3,r3,10
81110ad4:	18c7883a 	add	r3,r3,r3
81110ad8:	10c5883a 	add	r2,r2,r3
81110adc:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110ae0:	00a04574 	movhi	r2,33045
81110ae4:	10b89704 	addi	r2,r2,-7588
81110ae8:	10800483 	ldbu	r2,18(r2)
81110aec:	10800044 	addi	r2,r2,1
81110af0:	1007883a 	mov	r3,r2
81110af4:	00a04574 	movhi	r2,33045
81110af8:	10b89704 	addi	r2,r2,-7588
81110afc:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81110b00:	00a04574 	movhi	r2,33045
81110b04:	10b89704 	addi	r2,r2,-7588
81110b08:	10800483 	ldbu	r2,18(r2)
81110b0c:	10c03fcc 	andi	r3,r2,255
81110b10:	00a04574 	movhi	r2,33045
81110b14:	10b88404 	addi	r2,r2,-7664
81110b18:	1100078b 	ldhu	r4,30(r2)
81110b1c:	00a04574 	movhi	r2,33045
81110b20:	10b89704 	addi	r2,r2,-7588
81110b24:	18c00284 	addi	r3,r3,10
81110b28:	18c7883a 	add	r3,r3,r3
81110b2c:	10c5883a 	add	r2,r2,r3
81110b30:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110b34:	00a04574 	movhi	r2,33045
81110b38:	10b89704 	addi	r2,r2,-7588
81110b3c:	10800483 	ldbu	r2,18(r2)
81110b40:	10800044 	addi	r2,r2,1
81110b44:	1007883a 	mov	r3,r2
81110b48:	00a04574 	movhi	r2,33045
81110b4c:	10b89704 	addi	r2,r2,-7588
81110b50:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81110b54:	00a04574 	movhi	r2,33045
81110b58:	10b89704 	addi	r2,r2,-7588
81110b5c:	10800483 	ldbu	r2,18(r2)
81110b60:	10c03fcc 	andi	r3,r2,255
81110b64:	00a04574 	movhi	r2,33045
81110b68:	10b88404 	addi	r2,r2,-7664
81110b6c:	1100080b 	ldhu	r4,32(r2)
81110b70:	00a04574 	movhi	r2,33045
81110b74:	10b89704 	addi	r2,r2,-7588
81110b78:	18c00284 	addi	r3,r3,10
81110b7c:	18c7883a 	add	r3,r3,r3
81110b80:	10c5883a 	add	r2,r2,r3
81110b84:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110b88:	00a04574 	movhi	r2,33045
81110b8c:	10b89704 	addi	r2,r2,-7588
81110b90:	10800483 	ldbu	r2,18(r2)
81110b94:	10800044 	addi	r2,r2,1
81110b98:	1007883a 	mov	r3,r2
81110b9c:	00a04574 	movhi	r2,33045
81110ba0:	10b89704 	addi	r2,r2,-7588
81110ba4:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81110ba8:	e0bfdec4 	addi	r2,fp,-133
81110bac:	01802004 	movi	r6,128
81110bb0:	000b883a 	mov	r5,zero
81110bb4:	1009883a 	mov	r4,r2
81110bb8:	111d31c0 	call	8111d31c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81110bbc:	e0ffdec4 	addi	r3,fp,-133
81110bc0:	00a04574 	movhi	r2,33045
81110bc4:	10a2d504 	addi	r2,r2,-29868
81110bc8:	1009883a 	mov	r4,r2
81110bcc:	00800b84 	movi	r2,46
81110bd0:	100d883a 	mov	r6,r2
81110bd4:	200b883a 	mov	r5,r4
81110bd8:	1809883a 	mov	r4,r3
81110bdc:	111d1cc0 	call	8111d1cc <memcpy>
									debug(fp, cPUSDebug );
81110be0:	d0a05d17 	ldw	r2,-32396(gp)
81110be4:	e0ffdec4 	addi	r3,fp,-133
81110be8:	180b883a 	mov	r5,r3
81110bec:	1009883a 	mov	r4,r2
81110bf0:	111c11c0 	call	8111c11c <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81110bf4:	e0ffde0b 	ldhu	r3,-136(fp)
81110bf8:	e0bfdec4 	addi	r2,fp,-133
81110bfc:	180d883a 	mov	r6,r3
81110c00:	01604574 	movhi	r5,33045
81110c04:	2962e104 	addi	r5,r5,-29820
81110c08:	1009883a 	mov	r4,r2
81110c0c:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110c10:	d0a05d17 	ldw	r2,-32396(gp)
81110c14:	e0ffdec4 	addi	r3,fp,-133
81110c18:	180b883a 	mov	r5,r3
81110c1c:	1009883a 	mov	r4,r2
81110c20:	111c11c0 	call	8111c11c <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81110c24:	00a04574 	movhi	r2,33045
81110c28:	10b88404 	addi	r2,r2,-7664
81110c2c:	1080058b 	ldhu	r2,22(r2)
81110c30:	10ffffcc 	andi	r3,r2,65535
81110c34:	e0bfdec4 	addi	r2,fp,-133
81110c38:	180d883a 	mov	r6,r3
81110c3c:	01604574 	movhi	r5,33045
81110c40:	2962e804 	addi	r5,r5,-29792
81110c44:	1009883a 	mov	r4,r2
81110c48:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110c4c:	d0a05d17 	ldw	r2,-32396(gp)
81110c50:	e0ffdec4 	addi	r3,fp,-133
81110c54:	180b883a 	mov	r5,r3
81110c58:	1009883a 	mov	r4,r2
81110c5c:	111c11c0 	call	8111c11c <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81110c60:	00a04574 	movhi	r2,33045
81110c64:	10b88404 	addi	r2,r2,-7664
81110c68:	1080060b 	ldhu	r2,24(r2)
81110c6c:	10ffffcc 	andi	r3,r2,65535
81110c70:	e0bfdec4 	addi	r2,fp,-133
81110c74:	180d883a 	mov	r6,r3
81110c78:	01604574 	movhi	r5,33045
81110c7c:	2962ec04 	addi	r5,r5,-29776
81110c80:	1009883a 	mov	r4,r2
81110c84:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110c88:	d0a05d17 	ldw	r2,-32396(gp)
81110c8c:	e0ffdec4 	addi	r3,fp,-133
81110c90:	180b883a 	mov	r5,r3
81110c94:	1009883a 	mov	r4,r2
81110c98:	111c11c0 	call	8111c11c <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81110c9c:	00a04574 	movhi	r2,33045
81110ca0:	10b88404 	addi	r2,r2,-7664
81110ca4:	1080068b 	ldhu	r2,26(r2)
81110ca8:	10ffffcc 	andi	r3,r2,65535
81110cac:	e0bfdec4 	addi	r2,fp,-133
81110cb0:	180d883a 	mov	r6,r3
81110cb4:	01604574 	movhi	r5,33045
81110cb8:	2962f104 	addi	r5,r5,-29756
81110cbc:	1009883a 	mov	r4,r2
81110cc0:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110cc4:	d0a05d17 	ldw	r2,-32396(gp)
81110cc8:	e0ffdec4 	addi	r3,fp,-133
81110ccc:	180b883a 	mov	r5,r3
81110cd0:	1009883a 	mov	r4,r2
81110cd4:	111c11c0 	call	8111c11c <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81110cd8:	00a04574 	movhi	r2,33045
81110cdc:	10b88404 	addi	r2,r2,-7664
81110ce0:	1080070b 	ldhu	r2,28(r2)
81110ce4:	10ffffcc 	andi	r3,r2,65535
81110ce8:	e0bfdec4 	addi	r2,fp,-133
81110cec:	180d883a 	mov	r6,r3
81110cf0:	01604574 	movhi	r5,33045
81110cf4:	2962f804 	addi	r5,r5,-29728
81110cf8:	1009883a 	mov	r4,r2
81110cfc:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110d00:	d0a05d17 	ldw	r2,-32396(gp)
81110d04:	e0ffdec4 	addi	r3,fp,-133
81110d08:	180b883a 	mov	r5,r3
81110d0c:	1009883a 	mov	r4,r2
81110d10:	111c11c0 	call	8111c11c <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81110d14:	00a04574 	movhi	r2,33045
81110d18:	10b88404 	addi	r2,r2,-7664
81110d1c:	1080078b 	ldhu	r2,30(r2)
81110d20:	10ffffcc 	andi	r3,r2,65535
81110d24:	e0bfdec4 	addi	r2,fp,-133
81110d28:	180d883a 	mov	r6,r3
81110d2c:	01604574 	movhi	r5,33045
81110d30:	2962ff04 	addi	r5,r5,-29700
81110d34:	1009883a 	mov	r4,r2
81110d38:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110d3c:	d0a05d17 	ldw	r2,-32396(gp)
81110d40:	e0ffdec4 	addi	r3,fp,-133
81110d44:	180b883a 	mov	r5,r3
81110d48:	1009883a 	mov	r4,r2
81110d4c:	111c11c0 	call	8111c11c <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81110d50:	00a04574 	movhi	r2,33045
81110d54:	10b88404 	addi	r2,r2,-7664
81110d58:	1080080b 	ldhu	r2,32(r2)
81110d5c:	10ffffcc 	andi	r3,r2,65535
81110d60:	e0bfdec4 	addi	r2,fp,-133
81110d64:	180d883a 	mov	r6,r3
81110d68:	01604574 	movhi	r5,33045
81110d6c:	29630504 	addi	r5,r5,-29676
81110d70:	1009883a 	mov	r4,r2
81110d74:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110d78:	d0a05d17 	ldw	r2,-32396(gp)
81110d7c:	e0ffdec4 	addi	r3,fp,-133
81110d80:	180b883a 	mov	r5,r3
81110d84:	1009883a 	mov	r4,r2
81110d88:	111c11c0 	call	8111c11c <fprintf>
								#endif

								break;
81110d8c:	00002106 	br	81110e14 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81110d90:	e0bfdec4 	addi	r2,fp,-133
81110d94:	01802004 	movi	r6,128
81110d98:	000b883a 	mov	r5,zero
81110d9c:	1009883a 	mov	r4,r2
81110da0:	111d31c0 	call	8111d31c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81110da4:	00a04574 	movhi	r2,33045
81110da8:	10b89704 	addi	r2,r2,-7588
81110dac:	1080030b 	ldhu	r2,12(r2)
81110db0:	113fffcc 	andi	r4,r2,65535
81110db4:	00a04574 	movhi	r2,33045
81110db8:	10b89704 	addi	r2,r2,-7588
81110dbc:	1080038b 	ldhu	r2,14(r2)
81110dc0:	117fffcc 	andi	r5,r2,65535
81110dc4:	00a04574 	movhi	r2,33045
81110dc8:	10b89704 	addi	r2,r2,-7588
81110dcc:	1080040b 	ldhu	r2,16(r2)
81110dd0:	10bfffcc 	andi	r2,r2,65535
81110dd4:	e0ffdec4 	addi	r3,fp,-133
81110dd8:	d8800015 	stw	r2,0(sp)
81110ddc:	280f883a 	mov	r7,r5
81110de0:	200d883a 	mov	r6,r4
81110de4:	01604574 	movhi	r5,33045
81110de8:	29623404 	addi	r5,r5,-30512
81110dec:	1809883a 	mov	r4,r3
81110df0:	111daac0 	call	8111daac <sprintf>
									debug(fp, cPUSDebug );
81110df4:	d0a05d17 	ldw	r2,-32396(gp)
81110df8:	e0ffdec4 	addi	r3,fp,-133
81110dfc:	180b883a 	mov	r5,r3
81110e00:	1009883a 	mov	r4,r2
81110e04:	111c11c0 	call	8111c11c <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81110e08:	00800044 	movi	r2,1
81110e0c:	e0bfdc15 	stw	r2,-144(fp)
								break;
81110e10:	0001883a 	nop
						}
                        break;
81110e14:	00000306 	br	81110e24 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
81110e18:	00800044 	movi	r2,1
81110e1c:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81110e20:	0001883a 	nop
                }
				break;				
81110e24:	00000306 	br	81110e34 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
81110e28:	00800044 	movi	r2,1
81110e2c:	e0bfdc15 	stw	r2,-144(fp)
				break;
81110e30:	0001883a 	nop
		}
	}
81110e34:	003c9406 	br	81110088 <__reset+0xfb0f0088>

81110e38 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81110e38:	defffb04 	addi	sp,sp,-20
81110e3c:	de00012e 	bgeu	sp,et,81110e44 <getPreParsedPacket+0xc>
81110e40:	003b68fa 	trap	3
81110e44:	dfc00415 	stw	ra,16(sp)
81110e48:	df000315 	stw	fp,12(sp)
81110e4c:	df000304 	addi	fp,sp,12
81110e50:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110e54:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81110e58:	d0a06617 	ldw	r2,-32360(gp)
81110e5c:	e0fffe44 	addi	r3,fp,-7
81110e60:	180d883a 	mov	r6,r3
81110e64:	000b883a 	mov	r5,zero
81110e68:	1009883a 	mov	r4,r2
81110e6c:	11381ec0 	call	811381ec <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81110e70:	e0bffe43 	ldbu	r2,-7(fp)
81110e74:	10803fcc 	andi	r2,r2,255
81110e78:	10002e1e 	bne	r2,zero,81110f34 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81110e7c:	e03ffe05 	stb	zero,-8(fp)
81110e80:	00002506 	br	81110f18 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
81110e84:	e0fffe03 	ldbu	r3,-8(fp)
81110e88:	00a045b4 	movhi	r2,33046
81110e8c:	10856504 	addi	r2,r2,5524
81110e90:	18c01324 	muli	r3,r3,76
81110e94:	10c5883a 	add	r2,r2,r3
81110e98:	10800104 	addi	r2,r2,4
81110e9c:	10800003 	ldbu	r2,0(r2)
81110ea0:	10803fcc 	andi	r2,r2,255
81110ea4:	1080201c 	xori	r2,r2,128
81110ea8:	10bfe004 	addi	r2,r2,-128
81110eac:	10001726 	beq	r2,zero,81110f0c <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81110eb0:	e0fffe03 	ldbu	r3,-8(fp)
81110eb4:	e13fff17 	ldw	r4,-4(fp)
81110eb8:	00a045b4 	movhi	r2,33046
81110ebc:	10856504 	addi	r2,r2,5524
81110ec0:	18c01324 	muli	r3,r3,76
81110ec4:	10c5883a 	add	r2,r2,r3
81110ec8:	2007883a 	mov	r3,r4
81110ecc:	1009883a 	mov	r4,r2
81110ed0:	00801304 	movi	r2,76
81110ed4:	100d883a 	mov	r6,r2
81110ed8:	200b883a 	mov	r5,r4
81110edc:	1809883a 	mov	r4,r3
81110ee0:	111d1cc0 	call	8111d1cc <memcpy>
                bSuccess = TRUE;
81110ee4:	00800044 	movi	r2,1
81110ee8:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81110eec:	e0fffe03 	ldbu	r3,-8(fp)
81110ef0:	00a045b4 	movhi	r2,33046
81110ef4:	10856504 	addi	r2,r2,5524
81110ef8:	18c01324 	muli	r3,r3,76
81110efc:	10c5883a 	add	r2,r2,r3
81110f00:	10800104 	addi	r2,r2,4
81110f04:	10000005 	stb	zero,0(r2)
                break;
81110f08:	00000606 	br	81110f24 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81110f0c:	e0bffe03 	ldbu	r2,-8(fp)
81110f10:	10800044 	addi	r2,r2,1
81110f14:	e0bffe05 	stb	r2,-8(fp)
81110f18:	e0bffe03 	ldbu	r2,-8(fp)
81110f1c:	10800230 	cmpltui	r2,r2,8
81110f20:	103fd81e 	bne	r2,zero,81110e84 <__reset+0xfb0f0e84>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81110f24:	d0a06617 	ldw	r2,-32360(gp)
81110f28:	1009883a 	mov	r4,r2
81110f2c:	11387900 	call	81138790 <OSMutexPost>
81110f30:	00000106 	br	81110f38 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81110f34:	1117b6c0 	call	81117b6c <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81110f38:	e0bffd17 	ldw	r2,-12(fp)
}
81110f3c:	e037883a 	mov	sp,fp
81110f40:	dfc00117 	ldw	ra,4(sp)
81110f44:	df000017 	ldw	fp,0(sp)
81110f48:	dec00204 	addi	sp,sp,8
81110f4c:	f800283a 	ret

81110f50 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81110f50:	defffa04 	addi	sp,sp,-24
81110f54:	de00012e 	bgeu	sp,et,81110f5c <bSendMessagePUStoMebTask+0xc>
81110f58:	003b68fa 	trap	3
81110f5c:	dfc00515 	stw	ra,20(sp)
81110f60:	df000415 	stw	fp,16(sp)
81110f64:	df000404 	addi	fp,sp,16
81110f68:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110f6c:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81110f70:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
81110f74:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
81110f78:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
81110f7c:	d0a06e17 	ldw	r2,-32328(gp)
81110f80:	e0fffd44 	addi	r3,fp,-11
81110f84:	180d883a 	mov	r6,r3
81110f88:	01400284 	movi	r5,10
81110f8c:	1009883a 	mov	r4,r2
81110f90:	11381ec0 	call	811381ec <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110f94:	e0bffd43 	ldbu	r2,-11(fp)
81110f98:	10803fcc 	andi	r2,r2,255
81110f9c:	1000401e 	bne	r2,zero,811110a0 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81110fa0:	e03ffd05 	stb	zero,-12(fp)
81110fa4:	00003806 	br	81111088 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
81110fa8:	e0fffd03 	ldbu	r3,-12(fp)
81110fac:	00a04574 	movhi	r2,33045
81110fb0:	1082b604 	addi	r2,r2,2776
81110fb4:	18c01524 	muli	r3,r3,84
81110fb8:	10c5883a 	add	r2,r2,r3
81110fbc:	10800104 	addi	r2,r2,4
81110fc0:	10800017 	ldw	r2,0(r2)
81110fc4:	10002d1e 	bne	r2,zero,8111107c <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
81110fc8:	e0fffd03 	ldbu	r3,-12(fp)
81110fcc:	00a04574 	movhi	r2,33045
81110fd0:	1082b604 	addi	r2,r2,2776
81110fd4:	18c01524 	muli	r3,r3,84
81110fd8:	10c7883a 	add	r3,r2,r3
81110fdc:	e0bfff17 	ldw	r2,-4(fp)
81110fe0:	1009883a 	mov	r4,r2
81110fe4:	00801504 	movi	r2,84
81110fe8:	100d883a 	mov	r6,r2
81110fec:	200b883a 	mov	r5,r4
81110ff0:	1809883a 	mov	r4,r3
81110ff4:	111d1cc0 	call	8111d1cc <memcpy>
            	xPus[i].bInUse = TRUE;
81110ff8:	e0fffd03 	ldbu	r3,-12(fp)
81110ffc:	00a04574 	movhi	r2,33045
81111000:	1082b604 	addi	r2,r2,2776
81111004:	18c01524 	muli	r3,r3,84
81111008:	10c5883a 	add	r2,r2,r3
8111100c:	10800104 	addi	r2,r2,4
81111010:	00c00044 	movi	r3,1
81111014:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81111018:	00800044 	movi	r2,1
8111101c:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81111020:	00800044 	movi	r2,1
81111024:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81111028:	d0a06417 	ldw	r2,-32368(gp)
8111102c:	e0fffe17 	ldw	r3,-8(fp)
81111030:	180b883a 	mov	r5,r3
81111034:	1009883a 	mov	r4,r2
81111038:	11397080 	call	81139708 <OSQPost>
8111103c:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81111040:	e0bffd43 	ldbu	r2,-11(fp)
81111044:	10803fcc 	andi	r2,r2,255
81111048:	10000926 	beq	r2,zero,81111070 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
8111104c:	1118a5c0 	call	81118a5c <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81111050:	e0fffd03 	ldbu	r3,-12(fp)
81111054:	00a04574 	movhi	r2,33045
81111058:	1082b604 	addi	r2,r2,2776
8111105c:	18c01524 	muli	r3,r3,84
81111060:	10c5883a 	add	r2,r2,r3
81111064:	10800104 	addi	r2,r2,4
81111068:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
8111106c:	00000906 	br	81111094 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81111070:	00800044 	movi	r2,1
81111074:	e0bffc15 	stw	r2,-16(fp)
                break;
81111078:	00000606 	br	81111094 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
8111107c:	e0bffd03 	ldbu	r2,-12(fp)
81111080:	10800044 	addi	r2,r2,1
81111084:	e0bffd05 	stb	r2,-12(fp)
81111088:	e0bffd03 	ldbu	r2,-12(fp)
8111108c:	10800130 	cmpltui	r2,r2,4
81111090:	103fc51e 	bne	r2,zero,81110fa8 <__reset+0xfb0f0fa8>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81111094:	d0a06e17 	ldw	r2,-32328(gp)
81111098:	1009883a 	mov	r4,r2
8111109c:	11387900 	call	81138790 <OSMutexPost>
    }

    return bSuccess;
811110a0:	e0bffc17 	ldw	r2,-16(fp)
}
811110a4:	e037883a 	mov	sp,fp
811110a8:	dfc00117 	ldw	ra,4(sp)
811110ac:	df000017 	ldw	fp,0(sp)
811110b0:	dec00204 	addi	sp,sp,8
811110b4:	f800283a 	ret

811110b8 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
811110b8:	deffab04 	addi	sp,sp,-340
811110bc:	de00012e 	bgeu	sp,et,811110c4 <vReceiverUartTask+0xc>
811110c0:	003b68fa 	trap	3
811110c4:	dfc05415 	stw	ra,336(sp)
811110c8:	df005315 	stw	fp,332(sp)
811110cc:	df005304 	addi	fp,sp,332
811110d0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811110d4:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
811110d8:	d0a05d17 	ldw	r2,-32396(gp)
811110dc:	100f883a 	mov	r7,r2
811110e0:	01800784 	movi	r6,30
811110e4:	01400044 	movi	r5,1
811110e8:	01204574 	movhi	r4,33045
811110ec:	21230b04 	addi	r4,r4,-29652
811110f0:	111c7b80 	call	8111c7b8 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
811110f4:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
811110f8:	e0bfad17 	ldw	r2,-332(fp)
811110fc:	10c00060 	cmpeqi	r3,r2,1
81111100:	1800091e 	bne	r3,zero,81111128 <vReceiverUartTask+0x70>
81111104:	0080052e 	bgeu	zero,r2,8111111c <vReceiverUartTask+0x64>
81111108:	10c000a0 	cmpeqi	r3,r2,2
8111110c:	18005d1e 	bne	r3,zero,81111284 <vReceiverUartTask+0x1cc>
81111110:	108000e0 	cmpeqi	r2,r2,3
81111114:	10006e1e 	bne	r2,zero,811112d0 <vReceiverUartTask+0x218>
81111118:	00007706 	br	811112f8 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
8111111c:	00800044 	movi	r2,1
81111120:	e0bfad15 	stw	r2,-332(fp)
                break;
81111124:	00007706 	br	81111304 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81111128:	e0bfaf04 	addi	r2,fp,-324
8111112c:	01802004 	movi	r6,128
81111130:	000b883a 	mov	r5,zero
81111134:	1009883a 	mov	r4,r2
81111138:	111d31c0 	call	8111d31c <memset>
                scanf("%s", cReceive);
8111113c:	e0bfcf04 	addi	r2,fp,-196
81111140:	100b883a 	mov	r5,r2
81111144:	01204574 	movhi	r4,33045
81111148:	21231304 	addi	r4,r4,-29620
8111114c:	111d9d00 	call	8111d9d0 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81111150:	e0ffcf04 	addi	r3,fp,-196
81111154:	e0bfaf04 	addi	r2,fp,-324
81111158:	01801fc4 	movi	r6,127
8111115c:	180b883a 	mov	r5,r3
81111160:	1009883a 	mov	r4,r2
81111164:	111d1cc0 	call	8111d1cc <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81111168:	e0bfaf04 	addi	r2,fp,-324
8111116c:	01604574 	movhi	r5,33045
81111170:	2978ac04 	addi	r5,r5,-7504
81111174:	1009883a 	mov	r4,r2
81111178:	111175c0 	call	8111175c <bPreParserV2>
8111117c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
81111180:	e0bfae17 	ldw	r2,-328(fp)
81111184:	10800058 	cmpnei	r2,r2,1
81111188:	1000281e 	bne	r2,zero,8111122c <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
8111118c:	00a04574 	movhi	r2,33045
81111190:	10b8ac04 	addi	r2,r2,-7504
81111194:	10800103 	ldbu	r2,4(r2)
81111198:	10803fcc 	andi	r2,r2,255
8111119c:	1080201c 	xori	r2,r2,128
811111a0:	10bfe004 	addi	r2,r2,-128
811111a4:	10800fe0 	cmpeqi	r2,r2,63
811111a8:	1000081e 	bne	r2,zero,811111cc <vReceiverUartTask+0x114>
811111ac:	00a04574 	movhi	r2,33045
811111b0:	10b8ac04 	addi	r2,r2,-7504
811111b4:	10800103 	ldbu	r2,4(r2)
811111b8:	10803fcc 	andi	r2,r2,255
811111bc:	1080201c 	xori	r2,r2,128
811111c0:	10bfe004 	addi	r2,r2,-128
811111c4:	10800858 	cmpnei	r2,r2,33
811111c8:	1000031e 	bne	r2,zero,811111d8 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
811111cc:	00800084 	movi	r2,2
811111d0:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811111d4:	00004b06 	br	81111304 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
811111d8:	00a04574 	movhi	r2,33045
811111dc:	10b8ac04 	addi	r2,r2,-7504
811111e0:	10800103 	ldbu	r2,4(r2)
811111e4:	10803fcc 	andi	r2,r2,255
811111e8:	1080201c 	xori	r2,r2,128
811111ec:	10bfe004 	addi	r2,r2,-128
811111f0:	108008d8 	cmpnei	r2,r2,35
811111f4:	10000a1e 	bne	r2,zero,81111220 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
811111f8:	00800044 	movi	r2,1
811111fc:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81111200:	d0a05d17 	ldw	r2,-32396(gp)
81111204:	100f883a 	mov	r7,r2
81111208:	018006c4 	movi	r6,27
8111120c:	01400044 	movi	r5,1
81111210:	01204574 	movhi	r4,33045
81111214:	21231404 	addi	r4,r4,-29616
81111218:	111c7b80 	call	8111c7b8 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8111121c:	00003906 	br	81111304 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81111220:	008000c4 	movi	r2,3
81111224:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81111228:	00003606 	br	81111304 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
8111122c:	00a04574 	movhi	r2,33045
81111230:	10b8ac04 	addi	r2,r2,-7504
81111234:	00c008c4 	movi	r3,35
81111238:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
8111123c:	00a04574 	movhi	r2,33045
81111240:	10b8ac04 	addi	r2,r2,-7504
81111244:	00c00b84 	movi	r3,46
81111248:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
8111124c:	00a04574 	movhi	r2,33045
81111250:	10b8ac04 	addi	r2,r2,-7504
81111254:	00c00044 	movi	r3,1
81111258:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8111125c:	01204574 	movhi	r4,33045
81111260:	2138ac04 	addi	r4,r4,-7504
81111264:	11114440 	call	81111444 <setPreAckSenderFreePos>
81111268:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8111126c:	e0bfae17 	ldw	r2,-328(fp)
81111270:	1000011e 	bne	r2,zero,81111278 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81111274:	1117ca40 	call	81117ca4 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81111278:	00800044 	movi	r2,1
8111127c:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81111280:	00002006 	br	81111304 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81111284:	01204574 	movhi	r4,33045
81111288:	2138ac04 	addi	r4,r4,-7504
8111128c:	11114440 	call	81111444 <setPreAckSenderFreePos>
81111290:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81111294:	e0bfae17 	ldw	r2,-328(fp)
81111298:	10800058 	cmpnei	r2,r2,1
8111129c:	1000081e 	bne	r2,zero,811112c0 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
811112a0:	01204574 	movhi	r4,33045
811112a4:	2138ac04 	addi	r4,r4,-7504
811112a8:	11113080 	call	81111308 <setPreParsedFreePos>
811112ac:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811112b0:	e0bfae17 	ldw	r2,-328(fp)
811112b4:	1000031e 	bne	r2,zero,811112c4 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
811112b8:	1117d740 	call	81117d74 <vFailSetPreParsedBuffer>
811112bc:	00000106 	br	811112c4 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
811112c0:	1117d0c0 	call	81117d0c <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
811112c4:	00800044 	movi	r2,1
811112c8:	e0bfad15 	stw	r2,-332(fp)
                break;
811112cc:	00000d06 	br	81111304 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
811112d0:	01204574 	movhi	r4,33045
811112d4:	2138ac04 	addi	r4,r4,-7504
811112d8:	11115c00 	call	811115c0 <setPreAckReceiverFreePos>
811112dc:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
811112e0:	e0bfae17 	ldw	r2,-328(fp)
811112e4:	1000011e 	bne	r2,zero,811112ec <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
811112e8:	1117ddc0 	call	81117ddc <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
811112ec:	00800044 	movi	r2,1
811112f0:	e0bfad15 	stw	r2,-332(fp)
                break;
811112f4:	00000306 	br	81111304 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
811112f8:	00800044 	movi	r2,1
811112fc:	e0bfad15 	stw	r2,-332(fp)
                break;
81111300:	0001883a 	nop
        }

    }
81111304:	003f7c06 	br	811110f8 <__reset+0xfb0f10f8>

81111308 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81111308:	defffb04 	addi	sp,sp,-20
8111130c:	de00012e 	bgeu	sp,et,81111314 <setPreParsedFreePos+0xc>
81111310:	003b68fa 	trap	3
81111314:	dfc00415 	stw	ra,16(sp)
81111318:	df000315 	stw	fp,12(sp)
8111131c:	df000304 	addi	fp,sp,12
81111320:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81111324:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81111328:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8111132c:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81111330:	d0a06617 	ldw	r2,-32360(gp)
81111334:	e0fffe44 	addi	r3,fp,-7
81111338:	180d883a 	mov	r6,r3
8111133c:	01400284 	movi	r5,10
81111340:	1009883a 	mov	r4,r2
81111344:	11381ec0 	call	811381ec <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81111348:	e0bffe43 	ldbu	r2,-7(fp)
8111134c:	10803fcc 	andi	r2,r2,255
81111350:	1000361e 	bne	r2,zero,8111142c <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81111354:	e03ffe05 	stb	zero,-8(fp)
81111358:	00002e06 	br	81111414 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
8111135c:	e0fffe03 	ldbu	r3,-8(fp)
81111360:	00a045b4 	movhi	r2,33046
81111364:	10856504 	addi	r2,r2,5524
81111368:	18c01324 	muli	r3,r3,76
8111136c:	10c5883a 	add	r2,r2,r3
81111370:	10800104 	addi	r2,r2,4
81111374:	10800003 	ldbu	r2,0(r2)
81111378:	10803fcc 	andi	r2,r2,255
8111137c:	1080201c 	xori	r2,r2,128
81111380:	10bfe004 	addi	r2,r2,-128
81111384:	1000201e 	bne	r2,zero,81111408 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81111388:	e0fffe03 	ldbu	r3,-8(fp)
8111138c:	00a045b4 	movhi	r2,33046
81111390:	10856504 	addi	r2,r2,5524
81111394:	18c01324 	muli	r3,r3,76
81111398:	10c7883a 	add	r3,r2,r3
8111139c:	e0bfff17 	ldw	r2,-4(fp)
811113a0:	1009883a 	mov	r4,r2
811113a4:	00801304 	movi	r2,76
811113a8:	100d883a 	mov	r6,r2
811113ac:	200b883a 	mov	r5,r4
811113b0:	1809883a 	mov	r4,r3
811113b4:	111d1cc0 	call	8111d1cc <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
811113b8:	d0a05f17 	ldw	r2,-32388(gp)
811113bc:	1009883a 	mov	r4,r2
811113c0:	113a5800 	call	8113a580 <OSSemPost>
811113c4:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811113c8:	e0bffe43 	ldbu	r2,-7(fp)
811113cc:	10803fcc 	andi	r2,r2,255
811113d0:	1000031e 	bne	r2,zero,811113e0 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
811113d4:	00800044 	movi	r2,1
811113d8:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
811113dc:	00001006 	br	81111420 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
811113e0:	11173c40 	call	811173c4 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
811113e4:	e0fffe03 	ldbu	r3,-8(fp)
811113e8:	00a045b4 	movhi	r2,33046
811113ec:	10856504 	addi	r2,r2,5524
811113f0:	18c01324 	muli	r3,r3,76
811113f4:	10c5883a 	add	r2,r2,r3
811113f8:	10800104 	addi	r2,r2,4
811113fc:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81111400:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81111404:	00000606 	br	81111420 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81111408:	e0bffe03 	ldbu	r2,-8(fp)
8111140c:	10800044 	addi	r2,r2,1
81111410:	e0bffe05 	stb	r2,-8(fp)
81111414:	e0bffe03 	ldbu	r2,-8(fp)
81111418:	10800230 	cmpltui	r2,r2,8
8111141c:	103fcf1e 	bne	r2,zero,8111135c <__reset+0xfb0f135c>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81111420:	d0a06617 	ldw	r2,-32360(gp)
81111424:	1009883a 	mov	r4,r2
81111428:	11387900 	call	81138790 <OSMutexPost>
    }
    return bSuccess;
8111142c:	e0bffd17 	ldw	r2,-12(fp)
}
81111430:	e037883a 	mov	sp,fp
81111434:	dfc00117 	ldw	ra,4(sp)
81111438:	df000017 	ldw	fp,0(sp)
8111143c:	dec00204 	addi	sp,sp,8
81111440:	f800283a 	ret

81111444 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81111444:	defffb04 	addi	sp,sp,-20
81111448:	de00012e 	bgeu	sp,et,81111450 <setPreAckSenderFreePos+0xc>
8111144c:	003b68fa 	trap	3
81111450:	dfc00415 	stw	ra,16(sp)
81111454:	df000315 	stw	fp,12(sp)
81111458:	df000304 	addi	fp,sp,12
8111145c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81111460:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81111464:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81111468:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8111146c:	d0a06d17 	ldw	r2,-32332(gp)
81111470:	e0fffe44 	addi	r3,fp,-7
81111474:	180d883a 	mov	r6,r3
81111478:	01400284 	movi	r5,10
8111147c:	1009883a 	mov	r4,r2
81111480:	11381ec0 	call	811381ec <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81111484:	e0bffe43 	ldbu	r2,-7(fp)
81111488:	10803fcc 	andi	r2,r2,255
8111148c:	1000461e 	bne	r2,zero,811115a8 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81111490:	e03ffe05 	stb	zero,-8(fp)
81111494:	00003e06 	br	81111590 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81111498:	e0fffe03 	ldbu	r3,-8(fp)
8111149c:	00a045b4 	movhi	r2,33046
811114a0:	10855d04 	addi	r2,r2,5492
811114a4:	18c7883a 	add	r3,r3,r3
811114a8:	18c7883a 	add	r3,r3,r3
811114ac:	10c5883a 	add	r2,r2,r3
811114b0:	10800003 	ldbu	r2,0(r2)
811114b4:	10803fcc 	andi	r2,r2,255
811114b8:	1080201c 	xori	r2,r2,128
811114bc:	10bfe004 	addi	r2,r2,-128
811114c0:	1000301e 	bne	r2,zero,81111584 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
811114c4:	e0fffe03 	ldbu	r3,-8(fp)
811114c8:	e0bfff17 	ldw	r2,-4(fp)
811114cc:	11000103 	ldbu	r4,4(r2)
811114d0:	00a045b4 	movhi	r2,33046
811114d4:	10855d04 	addi	r2,r2,5492
811114d8:	18c7883a 	add	r3,r3,r3
811114dc:	18c7883a 	add	r3,r3,r3
811114e0:	10c5883a 	add	r2,r2,r3
811114e4:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
811114e8:	e0fffe03 	ldbu	r3,-8(fp)
811114ec:	e0bfff17 	ldw	r2,-4(fp)
811114f0:	11000143 	ldbu	r4,5(r2)
811114f4:	00a045b4 	movhi	r2,33046
811114f8:	10855d04 	addi	r2,r2,5492
811114fc:	18c7883a 	add	r3,r3,r3
81111500:	18c7883a 	add	r3,r3,r3
81111504:	10c5883a 	add	r2,r2,r3
81111508:	10800044 	addi	r2,r2,1
8111150c:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81111510:	e0fffe03 	ldbu	r3,-8(fp)
81111514:	e0bfff17 	ldw	r2,-4(fp)
81111518:	1100020b 	ldhu	r4,8(r2)
8111151c:	00a045b4 	movhi	r2,33046
81111520:	10855d04 	addi	r2,r2,5492
81111524:	18c7883a 	add	r3,r3,r3
81111528:	18c7883a 	add	r3,r3,r3
8111152c:	10c5883a 	add	r2,r2,r3
81111530:	10800084 	addi	r2,r2,2
81111534:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81111538:	d0a05c17 	ldw	r2,-32400(gp)
8111153c:	1009883a 	mov	r4,r2
81111540:	113a5800 	call	8113a580 <OSSemPost>
81111544:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81111548:	e0bffe43 	ldbu	r2,-7(fp)
8111154c:	10803fcc 	andi	r2,r2,255
81111550:	10000926 	beq	r2,zero,81111578 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81111554:	111745c0 	call	8111745c <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81111558:	e0fffe03 	ldbu	r3,-8(fp)
8111155c:	00a045b4 	movhi	r2,33046
81111560:	10855d04 	addi	r2,r2,5492
81111564:	18c7883a 	add	r3,r3,r3
81111568:	18c7883a 	add	r3,r3,r3
8111156c:	10c5883a 	add	r2,r2,r3
81111570:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81111574:	00000906 	br	8111159c <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81111578:	00800044 	movi	r2,1
8111157c:	e0bffd15 	stw	r2,-12(fp)
                break;
81111580:	00000606 	br	8111159c <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81111584:	e0bffe03 	ldbu	r2,-8(fp)
81111588:	10800044 	addi	r2,r2,1
8111158c:	e0bffe05 	stb	r2,-8(fp)
81111590:	e0bffe03 	ldbu	r2,-8(fp)
81111594:	10800230 	cmpltui	r2,r2,8
81111598:	103fbf1e 	bne	r2,zero,81111498 <__reset+0xfb0f1498>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
8111159c:	d0a06d17 	ldw	r2,-32332(gp)
811115a0:	1009883a 	mov	r4,r2
811115a4:	11387900 	call	81138790 <OSMutexPost>
    }

    return bSuccess;
811115a8:	e0bffd17 	ldw	r2,-12(fp)
}
811115ac:	e037883a 	mov	sp,fp
811115b0:	dfc00117 	ldw	ra,4(sp)
811115b4:	df000017 	ldw	fp,0(sp)
811115b8:	dec00204 	addi	sp,sp,8
811115bc:	f800283a 	ret

811115c0 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
811115c0:	defffb04 	addi	sp,sp,-20
811115c4:	de00012e 	bgeu	sp,et,811115cc <setPreAckReceiverFreePos+0xc>
811115c8:	003b68fa 	trap	3
811115cc:	dfc00415 	stw	ra,16(sp)
811115d0:	df000315 	stw	fp,12(sp)
811115d4:	df000304 	addi	fp,sp,12
811115d8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811115dc:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811115e0:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811115e4:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
811115e8:	d0a06017 	ldw	r2,-32384(gp)
811115ec:	e0fffe44 	addi	r3,fp,-7
811115f0:	180d883a 	mov	r6,r3
811115f4:	01400504 	movi	r5,20
811115f8:	1009883a 	mov	r4,r2
811115fc:	11381ec0 	call	811381ec <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81111600:	e0bffe43 	ldbu	r2,-7(fp)
81111604:	10803fcc 	andi	r2,r2,255
81111608:	1000471e 	bne	r2,zero,81111728 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8111160c:	e03ffe05 	stb	zero,-8(fp)
81111610:	00003e06 	br	8111170c <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81111614:	e0fffe03 	ldbu	r3,-8(fp)
81111618:	00a045b4 	movhi	r2,33046
8111161c:	10af4f04 	addi	r2,r2,-17092
81111620:	18c7883a 	add	r3,r3,r3
81111624:	18c7883a 	add	r3,r3,r3
81111628:	10c5883a 	add	r2,r2,r3
8111162c:	10800003 	ldbu	r2,0(r2)
81111630:	10803fcc 	andi	r2,r2,255
81111634:	1080201c 	xori	r2,r2,128
81111638:	10bfe004 	addi	r2,r2,-128
8111163c:	1000301e 	bne	r2,zero,81111700 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81111640:	e0fffe03 	ldbu	r3,-8(fp)
81111644:	e0bfff17 	ldw	r2,-4(fp)
81111648:	11000103 	ldbu	r4,4(r2)
8111164c:	00a045b4 	movhi	r2,33046
81111650:	10af4f04 	addi	r2,r2,-17092
81111654:	18c7883a 	add	r3,r3,r3
81111658:	18c7883a 	add	r3,r3,r3
8111165c:	10c5883a 	add	r2,r2,r3
81111660:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81111664:	e0fffe03 	ldbu	r3,-8(fp)
81111668:	e0bfff17 	ldw	r2,-4(fp)
8111166c:	11000143 	ldbu	r4,5(r2)
81111670:	00a045b4 	movhi	r2,33046
81111674:	10af4f04 	addi	r2,r2,-17092
81111678:	18c7883a 	add	r3,r3,r3
8111167c:	18c7883a 	add	r3,r3,r3
81111680:	10c5883a 	add	r2,r2,r3
81111684:	10800044 	addi	r2,r2,1
81111688:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
8111168c:	e0fffe03 	ldbu	r3,-8(fp)
81111690:	e0bfff17 	ldw	r2,-4(fp)
81111694:	1100020b 	ldhu	r4,8(r2)
81111698:	00a045b4 	movhi	r2,33046
8111169c:	10af4f04 	addi	r2,r2,-17092
811116a0:	18c7883a 	add	r3,r3,r3
811116a4:	18c7883a 	add	r3,r3,r3
811116a8:	10c5883a 	add	r2,r2,r3
811116ac:	10800084 	addi	r2,r2,2
811116b0:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
811116b4:	d0a06117 	ldw	r2,-32380(gp)
811116b8:	1009883a 	mov	r4,r2
811116bc:	113a5800 	call	8113a580 <OSSemPost>
811116c0:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811116c4:	e0bffe43 	ldbu	r2,-7(fp)
811116c8:	10803fcc 	andi	r2,r2,255
811116cc:	1000031e 	bne	r2,zero,811116dc <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
811116d0:	00800044 	movi	r2,1
811116d4:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
811116d8:	00000f06 	br	81111718 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
811116dc:	11174100 	call	81117410 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
811116e0:	e0fffe03 	ldbu	r3,-8(fp)
811116e4:	00a045b4 	movhi	r2,33046
811116e8:	10af4f04 	addi	r2,r2,-17092
811116ec:	18c7883a 	add	r3,r3,r3
811116f0:	18c7883a 	add	r3,r3,r3
811116f4:	10c5883a 	add	r2,r2,r3
811116f8:	10000005 	stb	zero,0(r2)
                }
                break;
811116fc:	00000606 	br	81111718 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81111700:	e0bffe03 	ldbu	r2,-8(fp)
81111704:	10800044 	addi	r2,r2,1
81111708:	e0bffe05 	stb	r2,-8(fp)
8111170c:	e0bffe03 	ldbu	r2,-8(fp)
81111710:	108001b0 	cmpltui	r2,r2,6
81111714:	103fbf1e 	bne	r2,zero,81111614 <__reset+0xfb0f1614>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81111718:	d0a06017 	ldw	r2,-32384(gp)
8111171c:	1009883a 	mov	r4,r2
81111720:	11387900 	call	81138790 <OSMutexPost>
81111724:	00000706 	br	81111744 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
81111728:	d0a05d17 	ldw	r2,-32396(gp)
8111172c:	100f883a 	mov	r7,r2
81111730:	01801404 	movi	r6,80
81111734:	01400044 	movi	r5,1
81111738:	01204574 	movhi	r4,33045
8111173c:	21231b04 	addi	r4,r4,-29588
81111740:	111c7b80 	call	8111c7b8 <fwrite>
        #endif
    }

    return bSuccess;
81111744:	e0bffd17 	ldw	r2,-12(fp)
}
81111748:	e037883a 	mov	sp,fp
8111174c:	dfc00117 	ldw	ra,4(sp)
81111750:	df000017 	ldw	fp,0(sp)
81111754:	dec00204 	addi	sp,sp,8
81111758:	f800283a 	ret

8111175c <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
8111175c:	defff404 	addi	sp,sp,-48
81111760:	de00012e 	bgeu	sp,et,81111768 <bPreParserV2+0xc>
81111764:	003b68fa 	trap	3
81111768:	dfc00b15 	stw	ra,44(sp)
8111176c:	df000a15 	stw	fp,40(sp)
81111770:	dc000915 	stw	r16,36(sp)
81111774:	df000a04 	addi	fp,sp,40
81111778:	e13ffd15 	stw	r4,-12(fp)
8111177c:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81111780:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81111784:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81111788:	01402004 	movi	r5,128
8111178c:	e13ffd17 	ldw	r4,-12(fp)
81111790:	111dd580 	call	8111dd58 <strnlen>
81111794:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81111798:	01400ec4 	movi	r5,59
8111179c:	e13ffd17 	ldw	r4,-12(fp)
811117a0:	1115e4c0 	call	81115e4c <siPosStr>
811117a4:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
811117a8:	e0fff98f 	ldh	r3,-26(fp)
811117ac:	e0bff90f 	ldh	r2,-28(fp)
811117b0:	10bfffc4 	addi	r2,r2,-1
811117b4:	18800226 	beq	r3,r2,811117c0 <bPreParserV2+0x64>
        return bSuccess;
811117b8:	e0bff617 	ldw	r2,-40(fp)
811117bc:	0000ba06 	br	81111aa8 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
811117c0:	01401f04 	movi	r5,124
811117c4:	e13ffd17 	ldw	r4,-12(fp)
811117c8:	1115e4c0 	call	81115e4c <siPosStr>
811117cc:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
811117d0:	e0bffa0f 	ldh	r2,-24(fp)
811117d4:	e0fff98f 	ldh	r3,-26(fp)
811117d8:	1880020e 	bge	r3,r2,811117e4 <bPreParserV2+0x88>
        return bSuccess;
811117dc:	e0bff617 	ldw	r2,-40(fp)
811117e0:	0000b106 	br	81111aa8 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
811117e4:	01604574 	movhi	r5,33045
811117e8:	29633004 	addi	r5,r5,-29504
811117ec:	e13ffd17 	ldw	r4,-12(fp)
811117f0:	111dc740 	call	8111dc74 <strcspn>
811117f4:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
811117f8:	e0bffa8f 	ldh	r2,-22(fp)
811117fc:	e0fffa0f 	ldh	r3,-24(fp)
81111800:	1880020e 	bge	r3,r2,8111180c <bPreParserV2+0xb0>
        return bSuccess;
81111804:	e0bff617 	ldw	r2,-40(fp)
81111808:	0000a706 	br	81111aa8 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
8111180c:	e0bffa8f 	ldh	r2,-22(fp)
81111810:	e0fffd17 	ldw	r3,-12(fp)
81111814:	1885883a 	add	r2,r3,r2
81111818:	10c00003 	ldbu	r3,0(r2)
8111181c:	e0bffe17 	ldw	r2,-8(fp)
81111820:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81111824:	e0bffe17 	ldw	r2,-8(fp)
81111828:	10800103 	ldbu	r2,4(r2)
8111182c:	10803fcc 	andi	r2,r2,255
81111830:	1080201c 	xori	r2,r2,128
81111834:	10bfe004 	addi	r2,r2,-128
81111838:	108008d8 	cmpnei	r2,r2,35
8111183c:	1000041e 	bne	r2,zero,81111850 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81111840:	00800044 	movi	r2,1
81111844:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81111848:	e0bff617 	ldw	r2,-40(fp)
8111184c:	00009606 	br	81111aa8 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81111850:	e0bffa8f 	ldh	r2,-22(fp)
81111854:	e0fffd17 	ldw	r3,-12(fp)
81111858:	1889883a 	add	r4,r3,r2
8111185c:	e0fffa0f 	ldh	r3,-24(fp)
81111860:	e0bffa8f 	ldh	r2,-22(fp)
81111864:	1885c83a 	sub	r2,r3,r2
81111868:	100b883a 	mov	r5,r2
8111186c:	111706c0 	call	8111706c <ucCrc8wInit>
81111870:	1007883a 	mov	r3,r2
81111874:	e0bffe17 	ldw	r2,-8(fp)
81111878:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
8111187c:	e0bffa8f 	ldh	r2,-22(fp)
81111880:	10800044 	addi	r2,r2,1
81111884:	e0fffd17 	ldw	r3,-12(fp)
81111888:	1885883a 	add	r2,r3,r2
8111188c:	10c00003 	ldbu	r3,0(r2)
81111890:	e0bffe17 	ldw	r2,-8(fp)
81111894:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81111898:	e0bffe17 	ldw	r2,-8(fp)
8111189c:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
811118a0:	e0bffe17 	ldw	r2,-8(fp)
811118a4:	10800204 	addi	r2,r2,8
811118a8:	01801004 	movi	r6,64
811118ac:	000b883a 	mov	r5,zero
811118b0:	1009883a 	mov	r4,r2
811118b4:	111d31c0 	call	8111d31c <memset>

    i = siIni + 3; /* "?C:i..." */
811118b8:	e0bffa8b 	ldhu	r2,-22(fp)
811118bc:	108000c4 	addi	r2,r2,3
811118c0:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
811118c4:	e0bffb44 	addi	r2,fp,-19
811118c8:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
811118cc:	e0bffb44 	addi	r2,fp,-19
811118d0:	01800184 	movi	r6,6
811118d4:	000b883a 	mov	r5,zero
811118d8:	1009883a 	mov	r4,r2
811118dc:	111d31c0 	call	8111d31c <memset>
        do {
            c = buffer[i];
811118e0:	e0bff703 	ldbu	r2,-36(fp)
811118e4:	e0fffd17 	ldw	r3,-12(fp)
811118e8:	1885883a 	add	r2,r3,r2
811118ec:	10800003 	ldbu	r2,0(r2)
811118f0:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
811118f4:	d0e00317 	ldw	r3,-32756(gp)
811118f8:	e0bffb07 	ldb	r2,-20(fp)
811118fc:	10800044 	addi	r2,r2,1
81111900:	1885883a 	add	r2,r3,r2
81111904:	10800003 	ldbu	r2,0(r2)
81111908:	10803fcc 	andi	r2,r2,255
8111190c:	1080010c 	andi	r2,r2,4
81111910:	10000626 	beq	r2,zero,8111192c <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81111914:	e0bff817 	ldw	r2,-32(fp)
81111918:	e0fffb03 	ldbu	r3,-20(fp)
8111191c:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81111920:	e0bff817 	ldw	r2,-32(fp)
81111924:	10800044 	addi	r2,r2,1
81111928:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
8111192c:	e0bff703 	ldbu	r2,-36(fp)
81111930:	10800044 	addi	r2,r2,1
81111934:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81111938:	e0bff90f 	ldh	r2,-28(fp)
8111193c:	e0fff703 	ldbu	r3,-36(fp)
81111940:	1880090e 	bge	r3,r2,81111968 <bPreParserV2+0x20c>
81111944:	e0bffb07 	ldb	r2,-20(fp)
81111948:	10800ea0 	cmpeqi	r2,r2,58
8111194c:	1000061e 	bne	r2,zero,81111968 <bPreParserV2+0x20c>
81111950:	e0bffb07 	ldb	r2,-20(fp)
81111954:	10800ee0 	cmpeqi	r2,r2,59
81111958:	1000031e 	bne	r2,zero,81111968 <bPreParserV2+0x20c>
8111195c:	e0bffb07 	ldb	r2,-20(fp)
81111960:	10801f18 	cmpnei	r2,r2,124
81111964:	103fde1e 	bne	r2,zero,811118e0 <__reset+0xfb0f18e0>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81111968:	e0bff817 	ldw	r2,-32(fp)
8111196c:	00c00284 	movi	r3,10
81111970:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81111974:	e0bffb07 	ldb	r2,-20(fp)
81111978:	10800ea0 	cmpeqi	r2,r2,58
8111197c:	1000031e 	bne	r2,zero,8111198c <bPreParserV2+0x230>
81111980:	e0bffb07 	ldb	r2,-20(fp)
81111984:	10801f18 	cmpnei	r2,r2,124
81111988:	10001a1e 	bne	r2,zero,811119f4 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
8111198c:	e0bffe17 	ldw	r2,-8(fp)
81111990:	10800183 	ldbu	r2,6(r2)
81111994:	10803fcc 	andi	r2,r2,255
81111998:	10800828 	cmpgeui	r2,r2,32
8111199c:	1000041e 	bne	r2,zero,811119b0 <bPreParserV2+0x254>
811119a0:	e0bffe17 	ldw	r2,-8(fp)
811119a4:	10800183 	ldbu	r2,6(r2)
811119a8:	14003fcc 	andi	r16,r2,255
811119ac:	00000106 	br	811119b4 <bPreParserV2+0x258>
811119b0:	04000804 	movi	r16,32
811119b4:	e0bffb44 	addi	r2,fp,-19
811119b8:	1009883a 	mov	r4,r2
811119bc:	111bfc00 	call	8111bfc0 <atoi>
811119c0:	1009883a 	mov	r4,r2
811119c4:	e0fffe17 	ldw	r3,-8(fp)
811119c8:	80800104 	addi	r2,r16,4
811119cc:	1085883a 	add	r2,r2,r2
811119d0:	1885883a 	add	r2,r3,r2
811119d4:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
811119d8:	e0bffe17 	ldw	r2,-8(fp)
811119dc:	10800183 	ldbu	r2,6(r2)
811119e0:	10800044 	addi	r2,r2,1
811119e4:	1007883a 	mov	r3,r2
811119e8:	e0bffe17 	ldw	r2,-8(fp)
811119ec:	10c00185 	stb	r3,6(r2)
811119f0:	00000906 	br	81111a18 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
811119f4:	e0bffb07 	ldb	r2,-20(fp)
811119f8:	10800ed8 	cmpnei	r2,r2,59
811119fc:	1000061e 	bne	r2,zero,81111a18 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81111a00:	e0bffb44 	addi	r2,fp,-19
81111a04:	1009883a 	mov	r4,r2
81111a08:	111bfc00 	call	8111bfc0 <atoi>
81111a0c:	1007883a 	mov	r3,r2
81111a10:	e0bffe17 	ldw	r2,-8(fp)
81111a14:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
81111a18:	e0bffb07 	ldb	r2,-20(fp)
81111a1c:	10800ee0 	cmpeqi	r2,r2,59
81111a20:	1000031e 	bne	r2,zero,81111a30 <bPreParserV2+0x2d4>
81111a24:	e0bff90f 	ldh	r2,-28(fp)
81111a28:	e0fff703 	ldbu	r3,-36(fp)
81111a2c:	18bfa516 	blt	r3,r2,811118c4 <__reset+0xfb0f18c4>


    if ( c == FINAL_CHAR )
81111a30:	e0bffb07 	ldb	r2,-20(fp)
81111a34:	10800ed8 	cmpnei	r2,r2,59
81111a38:	1000191e 	bne	r2,zero,81111aa0 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81111a3c:	e0bffe17 	ldw	r2,-8(fp)
81111a40:	10c01243 	ldbu	r3,73(r2)
81111a44:	e0bffe17 	ldw	r2,-8(fp)
81111a48:	10801203 	ldbu	r2,72(r2)
81111a4c:	18c03fcc 	andi	r3,r3,255
81111a50:	10803fcc 	andi	r2,r2,255
81111a54:	1880031e 	bne	r3,r2,81111a64 <bPreParserV2+0x308>
            bSuccess = TRUE;
81111a58:	00800044 	movi	r2,1
81111a5c:	e0bff615 	stw	r2,-40(fp)
81111a60:	00001006 	br	81111aa4 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81111a64:	d0e05d17 	ldw	r3,-32396(gp)
81111a68:	e0bffe17 	ldw	r2,-8(fp)
81111a6c:	10801203 	ldbu	r2,72(r2)
81111a70:	11003fcc 	andi	r4,r2,255
81111a74:	e0bffe17 	ldw	r2,-8(fp)
81111a78:	10801243 	ldbu	r2,73(r2)
81111a7c:	10803fcc 	andi	r2,r2,255
81111a80:	100f883a 	mov	r7,r2
81111a84:	200d883a 	mov	r6,r4
81111a88:	01604574 	movhi	r5,33045
81111a8c:	29633204 	addi	r5,r5,-29496
81111a90:	1809883a 	mov	r4,r3
81111a94:	111c11c0 	call	8111c11c <fprintf>
            #endif
            bSuccess = FALSE;
81111a98:	e03ff615 	stw	zero,-40(fp)
81111a9c:	00000106 	br	81111aa4 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81111aa0:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81111aa4:	e0bff617 	ldw	r2,-40(fp)
}
81111aa8:	e6ffff04 	addi	sp,fp,-4
81111aac:	dfc00217 	ldw	ra,8(sp)
81111ab0:	df000117 	ldw	fp,4(sp)
81111ab4:	dc000017 	ldw	r16,0(sp)
81111ab8:	dec00304 	addi	sp,sp,12
81111abc:	f800283a 	ret

81111ac0 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81111ac0:	defffb04 	addi	sp,sp,-20
81111ac4:	de00012e 	bgeu	sp,et,81111acc <vSenderComTask+0xc>
81111ac8:	003b68fa 	trap	3
81111acc:	dfc00415 	stw	ra,16(sp)
81111ad0:	df000315 	stw	fp,12(sp)
81111ad4:	df000304 	addi	fp,sp,12
81111ad8:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81111adc:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81111ae0:	d0a05d17 	ldw	r2,-32396(gp)
81111ae4:	100f883a 	mov	r7,r2
81111ae8:	01800704 	movi	r6,28
81111aec:	01400044 	movi	r5,1
81111af0:	01204574 	movhi	r4,33045
81111af4:	21233e04 	addi	r4,r4,-29448
81111af8:	111c7b80 	call	8111c7b8 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
81111afc:	e0bffd17 	ldw	r2,-12(fp)
81111b00:	10c00060 	cmpeqi	r3,r2,1
81111b04:	1800091e 	bne	r3,zero,81111b2c <vSenderComTask+0x6c>
81111b08:	0080052e 	bgeu	zero,r2,81111b20 <vSenderComTask+0x60>
81111b0c:	10c000a0 	cmpeqi	r3,r2,2
81111b10:	1800471e 	bne	r3,zero,81111c30 <vSenderComTask+0x170>
81111b14:	10800160 	cmpeqi	r2,r2,5
81111b18:	10002c1e 	bne	r2,zero,81111bcc <vSenderComTask+0x10c>
81111b1c:	00003a06 	br	81111c08 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81111b20:	00800044 	movi	r2,1
81111b24:	e0bffd15 	stw	r2,-12(fp)
                break;
81111b28:	00004206 	br	81111c34 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
81111b2c:	d0a05d17 	ldw	r2,-32396(gp)
81111b30:	100f883a 	mov	r7,r2
81111b34:	01800784 	movi	r6,30
81111b38:	01400044 	movi	r5,1
81111b3c:	01204574 	movhi	r4,33045
81111b40:	21234604 	addi	r4,r4,-29416
81111b44:	111c7b80 	call	8111c7b8 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81111b48:	01400044 	movi	r5,1
81111b4c:	01204574 	movhi	r4,33045
81111b50:	21234e04 	addi	r4,r4,-29384
81111b54:	11155440 	call	81115544 <bSendUART32v2>
81111b58:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81111b5c:	e0bffe17 	ldw	r2,-8(fp)
81111b60:	10800058 	cmpnei	r2,r2,1
81111b64:	10000a1e 	bne	r2,zero,81111b90 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81111b68:	00800144 	movi	r2,5
81111b6c:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81111b70:	d0a05d17 	ldw	r2,-32396(gp)
81111b74:	100f883a 	mov	r7,r2
81111b78:	01800d44 	movi	r6,53
81111b7c:	01400044 	movi	r5,1
81111b80:	01204574 	movhi	r4,33045
81111b84:	21235104 	addi	r4,r4,-29372
81111b88:	111c7b80 	call	8111c7b8 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81111b8c:	00002906 	br	81111c34 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
81111b90:	d0a05d17 	ldw	r2,-32396(gp)
81111b94:	100f883a 	mov	r7,r2
81111b98:	01800784 	movi	r6,30
81111b9c:	01400044 	movi	r5,1
81111ba0:	01204574 	movhi	r4,33045
81111ba4:	21235f04 	addi	r4,r4,-29316
81111ba8:	111c7b80 	call	8111c7b8 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
81111bac:	00800044 	movi	r2,1
81111bb0:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81111bb4:	000f883a 	mov	r7,zero
81111bb8:	01800144 	movi	r6,5
81111bbc:	000b883a 	mov	r5,zero
81111bc0:	0009883a 	mov	r4,zero
81111bc4:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
                }
                break;
81111bc8:	00001a06 	br	81111c34 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81111bcc:	00800144 	movi	r2,5
81111bd0:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
81111bd4:	d0a05d17 	ldw	r2,-32396(gp)
81111bd8:	100f883a 	mov	r7,r2
81111bdc:	018002c4 	movi	r6,11
81111be0:	01400044 	movi	r5,1
81111be4:	01204574 	movhi	r4,33045
81111be8:	21236704 	addi	r4,r4,-29284
81111bec:	111c7b80 	call	8111c7b8 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81111bf0:	000f883a 	mov	r7,zero
81111bf4:	01800644 	movi	r6,25
81111bf8:	000b883a 	mov	r5,zero
81111bfc:	0009883a 	mov	r4,zero
81111c00:	113c1900 	call	8113c190 <OSTimeDlyHMSM>

                break;
81111c04:	00000b06 	br	81111c34 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
81111c08:	d0a05d17 	ldw	r2,-32396(gp)
81111c0c:	100f883a 	mov	r7,r2
81111c10:	018003c4 	movi	r6,15
81111c14:	01400044 	movi	r5,1
81111c18:	01204574 	movhi	r4,33045
81111c1c:	21236a04 	addi	r4,r4,-29272
81111c20:	111c7b80 	call	8111c7b8 <fwrite>
                #endif
                eSenderMode = sDummySender;
81111c24:	00800144 	movi	r2,5
81111c28:	e0bffd15 	stw	r2,-12(fp)
                break;
81111c2c:	00000106 	br	81111c34 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81111c30:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81111c34:	003fb106 	br	81111afc <__reset+0xfb0f1afc>

81111c38 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81111c38:	defffa04 	addi	sp,sp,-24
81111c3c:	de00012e 	bgeu	sp,et,81111c44 <vSimMebTask+0xc>
81111c40:	003b68fa 	trap	3
81111c44:	dfc00515 	stw	ra,20(sp)
81111c48:	df000415 	stw	fp,16(sp)
81111c4c:	df000404 	addi	fp,sp,16
81111c50:	e13fff15 	stw	r4,-4(fp)
	TSimucam_MEB *pxMebC;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
81111c54:	e0bfff17 	ldw	r2,-4(fp)
81111c58:	e0bffc15 	stw	r2,-16(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81111c5c:	d0a05d17 	ldw	r2,-32396(gp)
81111c60:	100f883a 	mov	r7,r2
81111c64:	018008c4 	movi	r6,35
81111c68:	01400044 	movi	r5,1
81111c6c:	01204574 	movhi	r4,33045
81111c70:	21236e04 	addi	r4,r4,-29256
81111c74:	111c7b80 	call	8111c7b8 <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
81111c78:	e0bffc17 	ldw	r2,-16(fp)
81111c7c:	10800117 	ldw	r2,4(r2)
81111c80:	10c00168 	cmpgeui	r3,r2,5
81111c84:	1800ac1e 	bne	r3,zero,81111f38 <vSimMebTask+0x300>
81111c88:	100690ba 	slli	r3,r2,2
81111c8c:	00a04474 	movhi	r2,33041
81111c90:	10872804 	addi	r2,r2,7328
81111c94:	1885883a 	add	r2,r3,r2
81111c98:	10800017 	ldw	r2,0(r2)
81111c9c:	1000683a 	jmp	r2
81111ca0:	81111cb4 	orhi	r4,r16,17522
81111ca4:	81111ccc 	andi	r4,r16,17523
81111ca8:	81111d4c 	andi	r4,r16,17525
81111cac:	81111dc4 	addi	r4,r16,17527
81111cb0:	81111e9c 	xori	r4,r16,17530
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81111cb4:	e13ffc17 	ldw	r4,-16(fp)
81111cb8:	1112cdc0 	call	81112cdc <vMebInit>
				pxMebC->eMode = sMebToConfig;
81111cbc:	e0bffc17 	ldw	r2,-16(fp)
81111cc0:	00c00044 	movi	r3,1
81111cc4:	10c00115 	stw	r3,4(r2)
				break;
81111cc8:	0000a606 	br	81111f64 <vSimMebTask+0x32c>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
81111ccc:	d0a05d17 	ldw	r2,-32396(gp)
81111cd0:	100f883a 	mov	r7,r2
81111cd4:	01800584 	movi	r6,22
81111cd8:	01400044 	movi	r5,1
81111cdc:	01204574 	movhi	r4,33045
81111ce0:	21237704 	addi	r4,r4,-29220
81111ce4:	111c7b80 	call	8111c7b8 <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81111ce8:	111a5c40 	call	8111a5c4 <bStopSync>
				vSyncClearCounter();
81111cec:	110baa80 	call	8110baa8 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81111cf0:	1112e4c0 	call	81112e4c <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81111cf4:	01c00284 	movi	r7,10
81111cf8:	000d883a 	mov	r6,zero
81111cfc:	000b883a 	mov	r5,zero
81111d00:	0009883a 	mov	r4,zero
81111d04:	113c1900 	call	8113c190 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81111d08:	000d883a 	mov	r6,zero
81111d0c:	000b883a 	mov	r5,zero
81111d10:	01002844 	movi	r4,161
81111d14:	1112ab00 	call	81112ab0 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81111d18:	000d883a 	mov	r6,zero
81111d1c:	000b883a 	mov	r5,zero
81111d20:	01002844 	movi	r4,161
81111d24:	1112c540 	call	81112c54 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81111d28:	01c03e84 	movi	r7,250
81111d2c:	000d883a 	mov	r6,zero
81111d30:	000b883a 	mov	r5,zero
81111d34:	0009883a 	mov	r4,zero
81111d38:	113c1900 	call	8113c190 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81111d3c:	e0bffc17 	ldw	r2,-16(fp)
81111d40:	00c000c4 	movi	r3,3
81111d44:	10c00115 	stw	r3,4(r2)
				break;
81111d48:	00008606 	br	81111f64 <vSimMebTask+0x32c>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
81111d4c:	d0a05d17 	ldw	r2,-32396(gp)
81111d50:	100f883a 	mov	r7,r2
81111d54:	018004c4 	movi	r6,19
81111d58:	01400044 	movi	r5,1
81111d5c:	01204574 	movhi	r4,33045
81111d60:	21237d04 	addi	r4,r4,-29196
81111d64:	111c7b80 	call	8111c7b8 <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81111d68:	000d883a 	mov	r6,zero
81111d6c:	000b883a 	mov	r5,zero
81111d70:	01002884 	movi	r4,162
81111d74:	1112ab00 	call	81112ab0 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
81111d78:	000d883a 	mov	r6,zero
81111d7c:	000b883a 	mov	r5,zero
81111d80:	01002884 	movi	r4,162
81111d84:	1112c540 	call	81112c54 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
81111d88:	e0bffc17 	ldw	r2,-16(fp)
81111d8c:	1080050b 	ldhu	r2,20(r2)
81111d90:	10bfffcc 	andi	r2,r2,65535
81111d94:	100f883a 	mov	r7,r2
81111d98:	000d883a 	mov	r6,zero
81111d9c:	000b883a 	mov	r5,zero
81111da0:	0009883a 	mov	r4,zero
81111da4:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
				vSyncClearCounter();
81111da8:	110baa80 	call	8110baa8 <vSyncClearCounter>
				bStartSync();
81111dac:	111a58c0 	call	8111a58c <bStartSync>

				vEvtChangeMebMode();
81111db0:	11190600 	call	81119060 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81111db4:	e0bffc17 	ldw	r2,-16(fp)
81111db8:	00c00104 	movi	r3,4
81111dbc:	10c00115 	stw	r3,4(r2)
				break;
81111dc0:	00006806 	br	81111f64 <vSimMebTask+0x32c>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81111dc4:	d0a06417 	ldw	r2,-32368(gp)
81111dc8:	e0fffe04 	addi	r3,fp,-8
81111dcc:	180d883a 	mov	r6,r3
81111dd0:	000b883a 	mov	r5,zero
81111dd4:	1009883a 	mov	r4,r2
81111dd8:	11393000 	call	81139300 <OSQPend>
81111ddc:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81111de0:	e0bffe03 	ldbu	r2,-8(fp)
81111de4:	10803fcc 	andi	r2,r2,255
81111de8:	1000291e 	bne	r2,zero,81111e90 <vSimMebTask+0x258>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81111dec:	e0bffdc3 	ldbu	r2,-9(fp)
81111df0:	10803fcc 	andi	r2,r2,255
81111df4:	10800058 	cmpnei	r2,r2,1
81111df8:	10001c1e 	bne	r2,zero,81111e6c <vSimMebTask+0x234>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81111dfc:	e0bffd83 	ldbu	r2,-10(fp)
81111e00:	10803fcc 	andi	r2,r2,255
81111e04:	10c00060 	cmpeqi	r3,r2,1
81111e08:	1800031e 	bne	r3,zero,81111e18 <vSimMebTask+0x1e0>
81111e0c:	10803820 	cmpeqi	r2,r2,224
81111e10:	1000041e 	bne	r2,zero,81111e24 <vSimMebTask+0x1ec>
81111e14:	00000b06 	br	81111e44 <vSimMebTask+0x20c>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81111e18:	e13ffc17 	ldw	r4,-16(fp)
81111e1c:	1111f680 	call	81111f68 <vPusMebTask>
								break;
81111e20:	00001d06 	br	81111e98 <vSimMebTask+0x260>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81111e24:	d0a05d17 	ldw	r2,-32396(gp)
81111e28:	100f883a 	mov	r7,r2
81111e2c:	018012c4 	movi	r6,75
81111e30:	01400044 	movi	r5,1
81111e34:	01204574 	movhi	r4,33045
81111e38:	21238204 	addi	r4,r4,-29176
81111e3c:	111c7b80 	call	8111c7b8 <fwrite>
								#endif
								break;
81111e40:	00001506 	br	81111e98 <vSimMebTask+0x260>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81111e44:	d0a05d17 	ldw	r2,-32396(gp)
81111e48:	e0fffd83 	ldbu	r3,-10(fp)
81111e4c:	18c03fcc 	andi	r3,r3,255
81111e50:	180d883a 	mov	r6,r3
81111e54:	01604574 	movhi	r5,33045
81111e58:	29639504 	addi	r5,r5,-29100
81111e5c:	1009883a 	mov	r4,r2
81111e60:	111c11c0 	call	8111c11c <fprintf>
								#endif
								break;
81111e64:	0001883a 	nop
81111e68:	00000b06 	br	81111e98 <vSimMebTask+0x260>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81111e6c:	d0a05d17 	ldw	r2,-32396(gp)
81111e70:	e0fffdc3 	ldbu	r3,-9(fp)
81111e74:	18c03fcc 	andi	r3,r3,255
81111e78:	180d883a 	mov	r6,r3
81111e7c:	01604574 	movhi	r5,33045
81111e80:	2963a704 	addi	r5,r5,-29028
81111e84:	1009883a 	mov	r4,r2
81111e88:	111c11c0 	call	8111c11c <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81111e8c:	00003506 	br	81111f64 <vSimMebTask+0x32c>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81111e90:	1118aa80 	call	81118aa8 <vCouldNotGetCmdQueueMeb>
				}

				break;
81111e94:	00003306 	br	81111f64 <vSimMebTask+0x32c>
81111e98:	00003206 	br	81111f64 <vSimMebTask+0x32c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81111e9c:	d0a06417 	ldw	r2,-32368(gp)
81111ea0:	e0fffe04 	addi	r3,fp,-8
81111ea4:	180d883a 	mov	r6,r3
81111ea8:	000b883a 	mov	r5,zero
81111eac:	1009883a 	mov	r4,r2
81111eb0:	11393000 	call	81139300 <OSQPend>
81111eb4:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81111eb8:	e0bffe03 	ldbu	r2,-8(fp)
81111ebc:	10803fcc 	andi	r2,r2,255
81111ec0:	10001a1e 	bne	r2,zero,81111f2c <vSimMebTask+0x2f4>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81111ec4:	e0bffdc3 	ldbu	r2,-9(fp)
81111ec8:	10803fcc 	andi	r2,r2,255
81111ecc:	10800058 	cmpnei	r2,r2,1
81111ed0:	10000d1e 	bne	r2,zero,81111f08 <vSimMebTask+0x2d0>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81111ed4:	e0bffd83 	ldbu	r2,-10(fp)
81111ed8:	10803fcc 	andi	r2,r2,255
81111edc:	10c00060 	cmpeqi	r3,r2,1
81111ee0:	1800031e 	bne	r3,zero,81111ef0 <vSimMebTask+0x2b8>
81111ee4:	10803820 	cmpeqi	r2,r2,224
81111ee8:	1000041e 	bne	r2,zero,81111efc <vSimMebTask+0x2c4>
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);

								break;
							default:
								break;
81111eec:	00001106 	br	81111f34 <vSimMebTask+0x2fc>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81111ef0:	e13ffc17 	ldw	r4,-16(fp)
81111ef4:	1111f680 	call	81111f68 <vPusMebTask>
								break;
81111ef8:	00000e06 	br	81111f34 <vSimMebTask+0x2fc>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81111efc:	e13ffc17 	ldw	r4,-16(fp)
81111f00:	1112d400 	call	81112d40 <vSwapMemmory>

								break;
81111f04:	00000b06 	br	81111f34 <vSimMebTask+0x2fc>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81111f08:	d0a05d17 	ldw	r2,-32396(gp)
81111f0c:	e0fffdc3 	ldbu	r3,-9(fp)
81111f10:	18c03fcc 	andi	r3,r3,255
81111f14:	180d883a 	mov	r6,r3
81111f18:	01604574 	movhi	r5,33045
81111f1c:	2963a704 	addi	r5,r5,-29028
81111f20:	1009883a 	mov	r4,r2
81111f24:	111c11c0 	call	8111c11c <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81111f28:	00000e06 	br	81111f64 <vSimMebTask+0x32c>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81111f2c:	1118aa80 	call	81118aa8 <vCouldNotGetCmdQueueMeb>
				}			
				break;
81111f30:	00000c06 	br	81111f64 <vSimMebTask+0x32c>
81111f34:	00000b06 	br	81111f64 <vSimMebTask+0x32c>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
81111f38:	d0a05d17 	ldw	r2,-32396(gp)
81111f3c:	100f883a 	mov	r7,r2
81111f40:	01800bc4 	movi	r6,47
81111f44:	01400044 	movi	r5,1
81111f48:	01204574 	movhi	r4,33045
81111f4c:	2123b504 	addi	r4,r4,-28972
81111f50:	111c7b80 	call	8111c7b8 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81111f54:	e0bffc17 	ldw	r2,-16(fp)
81111f58:	00c00044 	movi	r3,1
81111f5c:	10c00115 	stw	r3,4(r2)
				break;
81111f60:	0001883a 	nop
		}
	}
81111f64:	003f4406 	br	81111c78 <__reset+0xfb0f1c78>

81111f68 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81111f68:	defffb04 	addi	sp,sp,-20
81111f6c:	de00012e 	bgeu	sp,et,81111f74 <vPusMebTask+0xc>
81111f70:	003b68fa 	trap	3
81111f74:	dfc00415 	stw	ra,16(sp)
81111f78:	df000315 	stw	fp,12(sp)
81111f7c:	df000304 	addi	fp,sp,12
81111f80:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
81111f84:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
81111f88:	d0a06e17 	ldw	r2,-32328(gp)
81111f8c:	e0fffe44 	addi	r3,fp,-7
81111f90:	180d883a 	mov	r6,r3
81111f94:	01400084 	movi	r5,2
81111f98:	1009883a 	mov	r4,r2
81111f9c:	11381ec0 	call	811381ec <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81111fa0:	e0bffe43 	ldbu	r2,-7(fp)
81111fa4:	10803fcc 	andi	r2,r2,255
81111fa8:	10002c1e 	bne	r2,zero,8111205c <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81111fac:	e03ffe05 	stb	zero,-8(fp)
81111fb0:	00002306 	br	81112040 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81111fb4:	e0fffe03 	ldbu	r3,-8(fp)
81111fb8:	00a04574 	movhi	r2,33045
81111fbc:	1082b604 	addi	r2,r2,2776
81111fc0:	18c01524 	muli	r3,r3,84
81111fc4:	10c5883a 	add	r2,r2,r3
81111fc8:	10800104 	addi	r2,r2,4
81111fcc:	10800017 	ldw	r2,0(r2)
81111fd0:	10800058 	cmpnei	r2,r2,1
81111fd4:	1000171e 	bne	r2,zero,81112034 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81111fd8:	e13ffe03 	ldbu	r4,-8(fp)
81111fdc:	00e04574 	movhi	r3,33045
81111fe0:	18f8bf04 	addi	r3,r3,-7428
81111fe4:	00a04574 	movhi	r2,33045
81111fe8:	1082b604 	addi	r2,r2,2776
81111fec:	21001524 	muli	r4,r4,84
81111ff0:	1105883a 	add	r2,r2,r4
81111ff4:	1009883a 	mov	r4,r2
81111ff8:	00801504 	movi	r2,84
81111ffc:	100d883a 	mov	r6,r2
81112000:	200b883a 	mov	r5,r4
81112004:	1809883a 	mov	r4,r3
81112008:	111d1cc0 	call	8111d1cc <memcpy>
            	xPus[ucIL].bInUse = FALSE;
8111200c:	e0fffe03 	ldbu	r3,-8(fp)
81112010:	00a04574 	movhi	r2,33045
81112014:	1082b604 	addi	r2,r2,2776
81112018:	18c01524 	muli	r3,r3,84
8111201c:	10c5883a 	add	r2,r2,r3
81112020:	10800104 	addi	r2,r2,4
81112024:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81112028:	00800044 	movi	r2,1
8111202c:	e0bffd15 	stw	r2,-12(fp)
                break;
81112030:	00000606 	br	8111204c <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81112034:	e0bffe03 	ldbu	r2,-8(fp)
81112038:	10800044 	addi	r2,r2,1
8111203c:	e0bffe05 	stb	r2,-8(fp)
81112040:	e0bffe03 	ldbu	r2,-8(fp)
81112044:	10800130 	cmpltui	r2,r2,4
81112048:	103fda1e 	bne	r2,zero,81111fb4 <__reset+0xfb0f1fb4>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
8111204c:	d0a06e17 	ldw	r2,-32328(gp)
81112050:	1009883a 	mov	r4,r2
81112054:	11387900 	call	81138790 <OSMutexPost>
81112058:	00000106 	br	81112060 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
8111205c:	1118b100 	call	81118b10 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
81112060:	e0bffd17 	ldw	r2,-12(fp)
81112064:	10001126 	beq	r2,zero,811120ac <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81112068:	e0bfff17 	ldw	r2,-4(fp)
8111206c:	10800117 	ldw	r2,4(r2)
81112070:	10c000e0 	cmpeqi	r3,r2,3
81112074:	1800031e 	bne	r3,zero,81112084 <vPusMebTask+0x11c>
81112078:	10800120 	cmpeqi	r2,r2,4
8111207c:	1000061e 	bne	r2,zero,81112098 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81112080:	00000a06 	br	811120ac <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81112084:	01604574 	movhi	r5,33045
81112088:	2978bf04 	addi	r5,r5,-7428
8111208c:	e13fff17 	ldw	r4,-4(fp)
81112090:	11120c40 	call	811120c4 <vPusMebInTaskConfigMode>
				break;
81112094:	00000506 	br	811120ac <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81112098:	01604574 	movhi	r5,33045
8111209c:	2978bf04 	addi	r5,r5,-7428
811120a0:	e13fff17 	ldw	r4,-4(fp)
811120a4:	11124540 	call	81112454 <vPusMebInTaskRunningMode>
				break;
811120a8:	0001883a 	nop
			default:
				break;
		}
	}
}
811120ac:	0001883a 	nop
811120b0:	e037883a 	mov	sp,fp
811120b4:	dfc00117 	ldw	ra,4(sp)
811120b8:	df000017 	ldw	fp,0(sp)
811120bc:	dec00204 	addi	sp,sp,8
811120c0:	f800283a 	ret

811120c4 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811120c4:	defffc04 	addi	sp,sp,-16
811120c8:	de00012e 	bgeu	sp,et,811120d0 <vPusMebInTaskConfigMode+0xc>
811120cc:	003b68fa 	trap	3
811120d0:	dfc00315 	stw	ra,12(sp)
811120d4:	df000215 	stw	fp,8(sp)
811120d8:	df000204 	addi	fp,sp,8
811120dc:	e13ffe15 	stw	r4,-8(fp)
811120e0:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
811120e4:	e0bfff17 	ldw	r2,-4(fp)
811120e8:	1080030b 	ldhu	r2,12(r2)
811120ec:	10bfffcc 	andi	r2,r2,65535
811120f0:	10c03ee0 	cmpeqi	r3,r2,251
811120f4:	1800081e 	bne	r3,zero,81112118 <vPusMebInTaskConfigMode+0x54>
811120f8:	10c03f20 	cmpeqi	r3,r2,252
811120fc:	18000a1e 	bne	r3,zero,81112128 <vPusMebInTaskConfigMode+0x64>
81112100:	10803ea0 	cmpeqi	r2,r2,250
81112104:	10000c26 	beq	r2,zero,81112138 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81112108:	e17fff17 	ldw	r5,-4(fp)
8111210c:	e13ffe17 	ldw	r4,-8(fp)
81112110:	11121700 	call	81112170 <vPusType250conf>
			break;
81112114:	00001006 	br	81112158 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81112118:	e17fff17 	ldw	r5,-4(fp)
8111211c:	e13ffe17 	ldw	r4,-8(fp)
81112120:	11121fc0 	call	811121fc <vPusType251conf>
			break;
81112124:	00000c06 	br	81112158 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81112128:	e17fff17 	ldw	r5,-4(fp)
8111212c:	e13ffe17 	ldw	r4,-8(fp)
81112130:	11122500 	call	81112250 <vPusType252conf>
			break;
81112134:	00000806 	br	81112158 <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81112138:	d0a05d17 	ldw	r2,-32396(gp)
8111213c:	100f883a 	mov	r7,r2
81112140:	01800d84 	movi	r6,54
81112144:	01400044 	movi	r5,1
81112148:	01204574 	movhi	r4,33045
8111214c:	2123c104 	addi	r4,r4,-28924
81112150:	111c7b80 	call	8111c7b8 <fwrite>
			#endif
			break;
81112154:	0001883a 	nop
	}
}
81112158:	0001883a 	nop
8111215c:	e037883a 	mov	sp,fp
81112160:	dfc00117 	ldw	ra,4(sp)
81112164:	df000017 	ldw	fp,0(sp)
81112168:	dec00204 	addi	sp,sp,8
8111216c:	f800283a 	ret

81112170 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112170:	defffc04 	addi	sp,sp,-16
81112174:	de00012e 	bgeu	sp,et,8111217c <vPusType250conf+0xc>
81112178:	003b68fa 	trap	3
8111217c:	dfc00315 	stw	ra,12(sp)
81112180:	df000215 	stw	fp,8(sp)
81112184:	df000204 	addi	fp,sp,8
81112188:	e13ffe15 	stw	r4,-8(fp)
8111218c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81112190:	e0bfff17 	ldw	r2,-4(fp)
81112194:	1080038b 	ldhu	r2,14(r2)
81112198:	10bfffcc 	andi	r2,r2,65535
8111219c:	10c00f60 	cmpeqi	r3,r2,61
811121a0:	1800031e 	bne	r3,zero,811121b0 <vPusType250conf+0x40>
811121a4:	10800fa0 	cmpeqi	r2,r2,62
811121a8:	10000d1e 	bne	r2,zero,811121e0 <vPusType250conf+0x70>
811121ac:	00000406 	br	811121c0 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
811121b0:	e0bffe17 	ldw	r2,-8(fp)
811121b4:	00c00084 	movi	r3,2
811121b8:	10c00115 	stw	r3,4(r2)
			break;
811121bc:	00000906 	br	811121e4 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
811121c0:	d0a05d17 	ldw	r2,-32396(gp)
811121c4:	100f883a 	mov	r7,r2
811121c8:	01800b04 	movi	r6,44
811121cc:	01400044 	movi	r5,1
811121d0:	01204574 	movhi	r4,33045
811121d4:	2123cf04 	addi	r4,r4,-28868
811121d8:	111c7b80 	call	8111c7b8 <fwrite>
			#endif
			break;
811121dc:	00000106 	br	811121e4 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
811121e0:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
811121e4:	0001883a 	nop
811121e8:	e037883a 	mov	sp,fp
811121ec:	dfc00117 	ldw	ra,4(sp)
811121f0:	df000017 	ldw	fp,0(sp)
811121f4:	dec00204 	addi	sp,sp,8
811121f8:	f800283a 	ret

811121fc <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811121fc:	defffc04 	addi	sp,sp,-16
81112200:	de00012e 	bgeu	sp,et,81112208 <vPusType251conf+0xc>
81112204:	003b68fa 	trap	3
81112208:	dfc00315 	stw	ra,12(sp)
8111220c:	df000215 	stw	fp,8(sp)
81112210:	df000204 	addi	fp,sp,8
81112214:	e13ffe15 	stw	r4,-8(fp)
81112218:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
8111221c:	d0a05d17 	ldw	r2,-32396(gp)
81112220:	100f883a 	mov	r7,r2
81112224:	01801184 	movi	r6,70
81112228:	01400044 	movi	r5,1
8111222c:	01204574 	movhi	r4,33045
81112230:	2123db04 	addi	r4,r4,-28820
81112234:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
}
81112238:	0001883a 	nop
8111223c:	e037883a 	mov	sp,fp
81112240:	dfc00117 	ldw	ra,4(sp)
81112244:	df000017 	ldw	fp,0(sp)
81112248:	dec00204 	addi	sp,sp,8
8111224c:	f800283a 	ret

81112250 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112250:	defffb04 	addi	sp,sp,-20
81112254:	de00012e 	bgeu	sp,et,8111225c <vPusType252conf+0xc>
81112258:	003b68fa 	trap	3
8111225c:	dfc00415 	stw	ra,16(sp)
81112260:	df000315 	stw	fp,12(sp)
81112264:	df000304 	addi	fp,sp,12
81112268:	e13ffe15 	stw	r4,-8(fp)
8111226c:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81112270:	e0bfff17 	ldw	r2,-4(fp)
81112274:	1080050b 	ldhu	r2,20(r2)
81112278:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
8111227c:	e0bfff17 	ldw	r2,-4(fp)
81112280:	1080038b 	ldhu	r2,14(r2)
81112284:	10bfffcc 	andi	r2,r2,65535
81112288:	10c000a0 	cmpeqi	r3,r2,2
8111228c:	18000c1e 	bne	r3,zero,811122c0 <vPusType252conf+0x70>
81112290:	10c00090 	cmplti	r3,r2,2
81112294:	1800611e 	bne	r3,zero,8111241c <vPusType252conf+0x1cc>
81112298:	10800188 	cmpgei	r2,r2,6
8111229c:	10005f1e 	bne	r2,zero,8111241c <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
811122a0:	d0a05d17 	ldw	r2,-32396(gp)
811122a4:	100f883a 	mov	r7,r2
811122a8:	01801384 	movi	r6,78
811122ac:	01400044 	movi	r5,1
811122b0:	01204574 	movhi	r4,33045
811122b4:	2123ed04 	addi	r4,r4,-28748
811122b8:	111c7b80 	call	8111c7b8 <fwrite>
			#endif
			break;
811122bc:	00005f06 	br	8111243c <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811122c0:	e0bffd0b 	ldhu	r2,-12(fp)
811122c4:	10809524 	muli	r2,r2,596
811122c8:	10805404 	addi	r2,r2,336
811122cc:	e0fffe17 	ldw	r3,-8(fp)
811122d0:	1885883a 	add	r2,r3,r2
811122d4:	1009883a 	mov	r4,r2
811122d8:	1106cd00 	call	81106cd0 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
811122dc:	e0bffd0b 	ldhu	r2,-12(fp)
811122e0:	e0fffe17 	ldw	r3,-8(fp)
811122e4:	10809524 	muli	r2,r2,596
811122e8:	1885883a 	add	r2,r3,r2
811122ec:	10806404 	addi	r2,r2,400
811122f0:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811122f4:	e0bffd0b 	ldhu	r2,-12(fp)
811122f8:	10809524 	muli	r2,r2,596
811122fc:	10805404 	addi	r2,r2,336
81112300:	e0fffe17 	ldw	r3,-8(fp)
81112304:	1885883a 	add	r2,r3,r2
81112308:	1009883a 	mov	r4,r2
8111230c:	1106c280 	call	81106c28 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81112310:	e0bffd0b 	ldhu	r2,-12(fp)
81112314:	10809524 	muli	r2,r2,596
81112318:	10805404 	addi	r2,r2,336
8111231c:	e0fffe17 	ldw	r3,-8(fp)
81112320:	1885883a 	add	r2,r3,r2
81112324:	1009883a 	mov	r4,r2
81112328:	1106eb80 	call	81106eb8 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
8111232c:	e0bffd0b 	ldhu	r2,-12(fp)
81112330:	e0ffff17 	ldw	r3,-4(fp)
81112334:	18c00b0b 	ldhu	r3,44(r3)
81112338:	1809883a 	mov	r4,r3
8111233c:	e0fffe17 	ldw	r3,-8(fp)
81112340:	10809524 	muli	r2,r2,596
81112344:	1885883a 	add	r2,r3,r2
81112348:	10805504 	addi	r2,r2,340
8111234c:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81112350:	e0bffd0b 	ldhu	r2,-12(fp)
81112354:	e0ffff17 	ldw	r3,-4(fp)
81112358:	18c0098b 	ldhu	r3,38(r3)
8111235c:	1809883a 	mov	r4,r3
81112360:	e0fffe17 	ldw	r3,-8(fp)
81112364:	10809524 	muli	r2,r2,596
81112368:	1885883a 	add	r2,r3,r2
8111236c:	10805544 	addi	r2,r2,341
81112370:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81112374:	e0bffd0b 	ldhu	r2,-12(fp)
81112378:	10809524 	muli	r2,r2,596
8111237c:	10805404 	addi	r2,r2,336
81112380:	e0fffe17 	ldw	r3,-8(fp)
81112384:	1885883a 	add	r2,r3,r2
81112388:	1009883a 	mov	r4,r2
8111238c:	1106de00 	call	81106de0 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112390:	e0bffd0b 	ldhu	r2,-12(fp)
81112394:	10809524 	muli	r2,r2,596
81112398:	10805404 	addi	r2,r2,336
8111239c:	e0fffe17 	ldw	r3,-8(fp)
811123a0:	1885883a 	add	r2,r3,r2
811123a4:	1009883a 	mov	r4,r2
811123a8:	1106cd00 	call	81106cd0 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
811123ac:	e0bffd0b 	ldhu	r2,-12(fp)
811123b0:	e0fffe17 	ldw	r3,-8(fp)
811123b4:	10809524 	muli	r2,r2,596
811123b8:	1885883a 	add	r2,r3,r2
811123bc:	10806404 	addi	r2,r2,400
811123c0:	00c00044 	movi	r3,1
811123c4:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811123c8:	e0bffd0b 	ldhu	r2,-12(fp)
811123cc:	10809524 	muli	r2,r2,596
811123d0:	10805404 	addi	r2,r2,336
811123d4:	e0fffe17 	ldw	r3,-8(fp)
811123d8:	1885883a 	add	r2,r3,r2
811123dc:	1009883a 	mov	r4,r2
811123e0:	1106c280 	call	81106c28 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
811123e4:	d0e05d17 	ldw	r3,-32396(gp)
811123e8:	e0bfff17 	ldw	r2,-4(fp)
811123ec:	10800b0b 	ldhu	r2,44(r2)
811123f0:	113fffcc 	andi	r4,r2,65535
811123f4:	e0bfff17 	ldw	r2,-4(fp)
811123f8:	1080098b 	ldhu	r2,38(r2)
811123fc:	10bfffcc 	andi	r2,r2,65535
81112400:	100f883a 	mov	r7,r2
81112404:	200d883a 	mov	r6,r4
81112408:	01604574 	movhi	r5,33045
8111240c:	29640104 	addi	r5,r5,-28668
81112410:	1809883a 	mov	r4,r3
81112414:	111c11c0 	call	8111c11c <fprintf>
			#endif

			break;
81112418:	00000806 	br	8111243c <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
8111241c:	d0a05d17 	ldw	r2,-32396(gp)
81112420:	100f883a 	mov	r7,r2
81112424:	01800b04 	movi	r6,44
81112428:	01400044 	movi	r5,1
8111242c:	01204574 	movhi	r4,33045
81112430:	2123cf04 	addi	r4,r4,-28868
81112434:	111c7b80 	call	8111c7b8 <fwrite>
			#endif
			break;
81112438:	0001883a 	nop
	}
}
8111243c:	0001883a 	nop
81112440:	e037883a 	mov	sp,fp
81112444:	dfc00117 	ldw	ra,4(sp)
81112448:	df000017 	ldw	fp,0(sp)
8111244c:	dec00204 	addi	sp,sp,8
81112450:	f800283a 	ret

81112454 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112454:	defffc04 	addi	sp,sp,-16
81112458:	de00012e 	bgeu	sp,et,81112460 <vPusMebInTaskRunningMode+0xc>
8111245c:	003b68fa 	trap	3
81112460:	dfc00315 	stw	ra,12(sp)
81112464:	df000215 	stw	fp,8(sp)
81112468:	df000204 	addi	fp,sp,8
8111246c:	e13ffe15 	stw	r4,-8(fp)
81112470:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81112474:	e0bfff17 	ldw	r2,-4(fp)
81112478:	1080030b 	ldhu	r2,12(r2)
8111247c:	10bfffcc 	andi	r2,r2,65535
81112480:	10c03ee0 	cmpeqi	r3,r2,251
81112484:	1800081e 	bne	r3,zero,811124a8 <vPusMebInTaskRunningMode+0x54>
81112488:	10c03f20 	cmpeqi	r3,r2,252
8111248c:	18000a1e 	bne	r3,zero,811124b8 <vPusMebInTaskRunningMode+0x64>
81112490:	10803ea0 	cmpeqi	r2,r2,250
81112494:	10000c26 	beq	r2,zero,811124c8 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81112498:	e17fff17 	ldw	r5,-4(fp)
8111249c:	e13ffe17 	ldw	r4,-8(fp)
811124a0:	11125000 	call	81112500 <vPusType250run>
			break;
811124a4:	00001006 	br	811124e8 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
811124a8:	e17fff17 	ldw	r5,-4(fp)
811124ac:	e13ffe17 	ldw	r4,-8(fp)
811124b0:	111258c0 	call	8111258c <vPusType251run>
			break;
811124b4:	00000c06 	br	811124e8 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
811124b8:	e17fff17 	ldw	r5,-4(fp)
811124bc:	e13ffe17 	ldw	r4,-8(fp)
811124c0:	11126a00 	call	811126a0 <vPusType252run>
			break;
811124c4:	00000806 	br	811124e8 <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
811124c8:	d0a05d17 	ldw	r2,-32396(gp)
811124cc:	100f883a 	mov	r7,r2
811124d0:	01800cc4 	movi	r6,51
811124d4:	01400044 	movi	r5,1
811124d8:	01204574 	movhi	r4,33045
811124dc:	21241104 	addi	r4,r4,-28604
811124e0:	111c7b80 	call	8111c7b8 <fwrite>
			#endif
			break;
811124e4:	0001883a 	nop
	}
}
811124e8:	0001883a 	nop
811124ec:	e037883a 	mov	sp,fp
811124f0:	dfc00117 	ldw	ra,4(sp)
811124f4:	df000017 	ldw	fp,0(sp)
811124f8:	dec00204 	addi	sp,sp,8
811124fc:	f800283a 	ret

81112500 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112500:	defffc04 	addi	sp,sp,-16
81112504:	de00012e 	bgeu	sp,et,8111250c <vPusType250run+0xc>
81112508:	003b68fa 	trap	3
8111250c:	dfc00315 	stw	ra,12(sp)
81112510:	df000215 	stw	fp,8(sp)
81112514:	df000204 	addi	fp,sp,8
81112518:	e13ffe15 	stw	r4,-8(fp)
8111251c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81112520:	e0bfff17 	ldw	r2,-4(fp)
81112524:	1080038b 	ldhu	r2,14(r2)
81112528:	10bfffcc 	andi	r2,r2,65535
8111252c:	10c00f20 	cmpeqi	r3,r2,60
81112530:	1800031e 	bne	r3,zero,81112540 <vPusType250run+0x40>
81112534:	10800fa0 	cmpeqi	r2,r2,62
81112538:	10000d1e 	bne	r2,zero,81112570 <vPusType250run+0x70>
8111253c:	00000406 	br	81112550 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81112540:	e0bffe17 	ldw	r2,-8(fp)
81112544:	00c00044 	movi	r3,1
81112548:	10c00115 	stw	r3,4(r2)
			break;
8111254c:	00000906 	br	81112574 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81112550:	d0a05d17 	ldw	r2,-32396(gp)
81112554:	100f883a 	mov	r7,r2
81112558:	01800c84 	movi	r6,50
8111255c:	01400044 	movi	r5,1
81112560:	01204574 	movhi	r4,33045
81112564:	21241e04 	addi	r4,r4,-28552
81112568:	111c7b80 	call	8111c7b8 <fwrite>
			#endif
			break;
8111256c:	00000106 	br	81112574 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81112570:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81112574:	0001883a 	nop
81112578:	e037883a 	mov	sp,fp
8111257c:	dfc00117 	ldw	ra,4(sp)
81112580:	df000017 	ldw	fp,0(sp)
81112584:	dec00204 	addi	sp,sp,8
81112588:	f800283a 	ret

8111258c <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111258c:	defffb04 	addi	sp,sp,-20
81112590:	de00012e 	bgeu	sp,et,81112598 <vPusType251run+0xc>
81112594:	003b68fa 	trap	3
81112598:	dfc00415 	stw	ra,16(sp)
8111259c:	df000315 	stw	fp,12(sp)
811125a0:	df000304 	addi	fp,sp,12
811125a4:	e13ffe15 	stw	r4,-8(fp)
811125a8:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811125ac:	e0bfff17 	ldw	r2,-4(fp)
811125b0:	1080050b 	ldhu	r2,20(r2)
811125b4:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811125b8:	e0bfff17 	ldw	r2,-4(fp)
811125bc:	1080038b 	ldhu	r2,14(r2)
811125c0:	10bfffcc 	andi	r2,r2,65535
811125c4:	10c000a0 	cmpeqi	r3,r2,2
811125c8:	18000f1e 	bne	r3,zero,81112608 <vPusType251run+0x7c>
811125cc:	10c00160 	cmpeqi	r3,r2,5
811125d0:	1800181e 	bne	r3,zero,81112634 <vPusType251run+0xa8>
811125d4:	10800060 	cmpeqi	r2,r2,1
811125d8:	10002126 	beq	r2,zero,81112660 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
811125dc:	e0bffd0b 	ldhu	r2,-12(fp)
811125e0:	10800444 	addi	r2,r2,17
811125e4:	10803fcc 	andi	r2,r2,255
811125e8:	e0fffd0b 	ldhu	r3,-12(fp)
811125ec:	18c03fcc 	andi	r3,r3,255
811125f0:	180f883a 	mov	r7,r3
811125f4:	000d883a 	mov	r6,zero
811125f8:	01400044 	movi	r5,1
811125fc:	1009883a 	mov	r4,r2
81112600:	1112b380 	call	81112b38 <vSendCmdQToNFeeCTRL_GEN>
			break;
81112604:	00002006 	br	81112688 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81112608:	e0bffd0b 	ldhu	r2,-12(fp)
8111260c:	10800444 	addi	r2,r2,17
81112610:	10803fcc 	andi	r2,r2,255
81112614:	e0fffd0b 	ldhu	r3,-12(fp)
81112618:	18c03fcc 	andi	r3,r3,255
8111261c:	180f883a 	mov	r7,r3
81112620:	000d883a 	mov	r6,zero
81112624:	01400104 	movi	r5,4
81112628:	1009883a 	mov	r4,r2
8111262c:	1112b380 	call	81112b38 <vSendCmdQToNFeeCTRL_GEN>
			break;
81112630:	00001506 	br	81112688 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81112634:	e0bffd0b 	ldhu	r2,-12(fp)
81112638:	10800444 	addi	r2,r2,17
8111263c:	10803fcc 	andi	r2,r2,255
81112640:	e0fffd0b 	ldhu	r3,-12(fp)
81112644:	18c03fcc 	andi	r3,r3,255
81112648:	180f883a 	mov	r7,r3
8111264c:	000d883a 	mov	r6,zero
81112650:	01400204 	movi	r5,8
81112654:	1009883a 	mov	r4,r2
81112658:	1112b380 	call	81112b38 <vSendCmdQToNFeeCTRL_GEN>
			break;
8111265c:	00000a06 	br	81112688 <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
81112660:	d0e05d17 	ldw	r3,-32396(gp)
81112664:	e0bfff17 	ldw	r2,-4(fp)
81112668:	1080038b 	ldhu	r2,14(r2)
8111266c:	10bfffcc 	andi	r2,r2,65535
81112670:	100d883a 	mov	r6,r2
81112674:	01604574 	movhi	r5,33045
81112678:	29642b04 	addi	r5,r5,-28500
8111267c:	1809883a 	mov	r4,r3
81112680:	111c11c0 	call	8111c11c <fprintf>
			#endif
			break;
81112684:	0001883a 	nop
	}
}
81112688:	0001883a 	nop
8111268c:	e037883a 	mov	sp,fp
81112690:	dfc00117 	ldw	ra,4(sp)
81112694:	df000017 	ldw	fp,0(sp)
81112698:	dec00204 	addi	sp,sp,8
8111269c:	f800283a 	ret

811126a0 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811126a0:	defffb04 	addi	sp,sp,-20
811126a4:	de00012e 	bgeu	sp,et,811126ac <vPusType252run+0xc>
811126a8:	003b68fa 	trap	3
811126ac:	dfc00415 	stw	ra,16(sp)
811126b0:	df000315 	stw	fp,12(sp)
811126b4:	df000304 	addi	fp,sp,12
811126b8:	e13ffe15 	stw	r4,-8(fp)
811126bc:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811126c0:	e0bfff17 	ldw	r2,-4(fp)
811126c4:	1080050b 	ldhu	r2,20(r2)
811126c8:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811126cc:	e0bfff17 	ldw	r2,-4(fp)
811126d0:	1080038b 	ldhu	r2,14(r2)
811126d4:	10bfffcc 	andi	r2,r2,65535
811126d8:	10c000e0 	cmpeqi	r3,r2,3
811126dc:	18000a1e 	bne	r3,zero,81112708 <vPusType252run+0x68>
811126e0:	10c00108 	cmpgei	r3,r2,4
811126e4:	1800031e 	bne	r3,zero,811126f4 <vPusType252run+0x54>
811126e8:	108000a0 	cmpeqi	r2,r2,2
811126ec:	1000581e 	bne	r2,zero,81112850 <vPusType252run+0x1b0>
811126f0:	0000be06 	br	811129ec <vPusType252run+0x34c>
811126f4:	10c00120 	cmpeqi	r3,r2,4
811126f8:	18002c1e 	bne	r3,zero,811127ac <vPusType252run+0x10c>
811126fc:	10800160 	cmpeqi	r2,r2,5
81112700:	1000c21e 	bne	r2,zero,81112a0c <vPusType252run+0x36c>
81112704:	0000b906 	br	811129ec <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81112708:	e0bffd0b 	ldhu	r2,-12(fp)
8111270c:	10809524 	muli	r2,r2,596
81112710:	10809a04 	addi	r2,r2,616
81112714:	e0fffe17 	ldw	r3,-8(fp)
81112718:	1885883a 	add	r2,r3,r2
8111271c:	1009883a 	mov	r4,r2
81112720:	11092540 	call	81109254 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81112724:	e0bffd0b 	ldhu	r2,-12(fp)
81112728:	e0fffe17 	ldw	r3,-8(fp)
8111272c:	10809524 	muli	r2,r2,596
81112730:	1885883a 	add	r2,r3,r2
81112734:	10809c04 	addi	r2,r2,624
81112738:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
8111273c:	e0bffd0b 	ldhu	r2,-12(fp)
81112740:	e0fffe17 	ldw	r3,-8(fp)
81112744:	10809524 	muli	r2,r2,596
81112748:	1885883a 	add	r2,r3,r2
8111274c:	10809b04 	addi	r2,r2,620
81112750:	00c00044 	movi	r3,1
81112754:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81112758:	e0bffd0b 	ldhu	r2,-12(fp)
8111275c:	e0fffe17 	ldw	r3,-8(fp)
81112760:	10809524 	muli	r2,r2,596
81112764:	1885883a 	add	r2,r3,r2
81112768:	10809d04 	addi	r2,r2,628
8111276c:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81112770:	e0bffd0b 	ldhu	r2,-12(fp)
81112774:	10809524 	muli	r2,r2,596
81112778:	10809a04 	addi	r2,r2,616
8111277c:	e0fffe17 	ldw	r3,-8(fp)
81112780:	1885883a 	add	r2,r3,r2
81112784:	1009883a 	mov	r4,r2
81112788:	11091200 	call	81109120 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
8111278c:	d0a05d17 	ldw	r2,-32396(gp)
81112790:	e0fffd0b 	ldhu	r3,-12(fp)
81112794:	180d883a 	mov	r6,r3
81112798:	01604574 	movhi	r5,33045
8111279c:	29643904 	addi	r5,r5,-28444
811127a0:	1009883a 	mov	r4,r2
811127a4:	111c11c0 	call	8111c11c <fprintf>
			#endif

			break;
811127a8:	00009906 	br	81112a10 <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811127ac:	e0bffd0b 	ldhu	r2,-12(fp)
811127b0:	10809524 	muli	r2,r2,596
811127b4:	10809a04 	addi	r2,r2,616
811127b8:	e0fffe17 	ldw	r3,-8(fp)
811127bc:	1885883a 	add	r2,r3,r2
811127c0:	1009883a 	mov	r4,r2
811127c4:	11092540 	call	81109254 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
811127c8:	e0bffd0b 	ldhu	r2,-12(fp)
811127cc:	e0fffe17 	ldw	r3,-8(fp)
811127d0:	10809524 	muli	r2,r2,596
811127d4:	1885883a 	add	r2,r3,r2
811127d8:	10809c04 	addi	r2,r2,624
811127dc:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
811127e0:	e0bffd0b 	ldhu	r2,-12(fp)
811127e4:	e0fffe17 	ldw	r3,-8(fp)
811127e8:	10809524 	muli	r2,r2,596
811127ec:	1885883a 	add	r2,r3,r2
811127f0:	10809b04 	addi	r2,r2,620
811127f4:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
811127f8:	e0bffd0b 	ldhu	r2,-12(fp)
811127fc:	e0fffe17 	ldw	r3,-8(fp)
81112800:	10809524 	muli	r2,r2,596
81112804:	1885883a 	add	r2,r3,r2
81112808:	10809d04 	addi	r2,r2,628
8111280c:	00c00044 	movi	r3,1
81112810:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81112814:	e0bffd0b 	ldhu	r2,-12(fp)
81112818:	10809524 	muli	r2,r2,596
8111281c:	10809a04 	addi	r2,r2,616
81112820:	e0fffe17 	ldw	r3,-8(fp)
81112824:	1885883a 	add	r2,r3,r2
81112828:	1009883a 	mov	r4,r2
8111282c:	11091200 	call	81109120 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81112830:	d0a05d17 	ldw	r2,-32396(gp)
81112834:	e0fffd0b 	ldhu	r3,-12(fp)
81112838:	180d883a 	mov	r6,r3
8111283c:	01604574 	movhi	r5,33045
81112840:	29644204 	addi	r5,r5,-28408
81112844:	1009883a 	mov	r4,r2
81112848:	111c11c0 	call	8111c11c <fprintf>
			#endif

			break;
8111284c:	00007006 	br	81112a10 <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81112850:	e0bffd0b 	ldhu	r2,-12(fp)
81112854:	e0fffe17 	ldw	r3,-8(fp)
81112858:	10809524 	muli	r2,r2,596
8111285c:	1885883a 	add	r2,r3,r2
81112860:	10803e04 	addi	r2,r2,248
81112864:	10800017 	ldw	r2,0(r2)
81112868:	10800058 	cmpnei	r2,r2,1
8111286c:	10004a1e 	bne	r2,zero,81112998 <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112870:	e0bffd0b 	ldhu	r2,-12(fp)
81112874:	10809524 	muli	r2,r2,596
81112878:	10805404 	addi	r2,r2,336
8111287c:	e0fffe17 	ldw	r3,-8(fp)
81112880:	1885883a 	add	r2,r3,r2
81112884:	1009883a 	mov	r4,r2
81112888:	1106cd00 	call	81106cd0 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
8111288c:	e0bffd0b 	ldhu	r2,-12(fp)
81112890:	e0fffe17 	ldw	r3,-8(fp)
81112894:	10809524 	muli	r2,r2,596
81112898:	1885883a 	add	r2,r3,r2
8111289c:	10806404 	addi	r2,r2,400
811128a0:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811128a4:	e0bffd0b 	ldhu	r2,-12(fp)
811128a8:	10809524 	muli	r2,r2,596
811128ac:	10805404 	addi	r2,r2,336
811128b0:	e0fffe17 	ldw	r3,-8(fp)
811128b4:	1885883a 	add	r2,r3,r2
811128b8:	1009883a 	mov	r4,r2
811128bc:	1106c280 	call	81106c28 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811128c0:	e0bffd0b 	ldhu	r2,-12(fp)
811128c4:	10809524 	muli	r2,r2,596
811128c8:	10805404 	addi	r2,r2,336
811128cc:	e0fffe17 	ldw	r3,-8(fp)
811128d0:	1885883a 	add	r2,r3,r2
811128d4:	1009883a 	mov	r4,r2
811128d8:	1106eb80 	call	81106eb8 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811128dc:	e0bffd0b 	ldhu	r2,-12(fp)
811128e0:	e0ffff17 	ldw	r3,-4(fp)
811128e4:	18c00b0b 	ldhu	r3,44(r3)
811128e8:	1809883a 	mov	r4,r3
811128ec:	e0fffe17 	ldw	r3,-8(fp)
811128f0:	10809524 	muli	r2,r2,596
811128f4:	1885883a 	add	r2,r3,r2
811128f8:	10805504 	addi	r2,r2,340
811128fc:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81112900:	e0bffd0b 	ldhu	r2,-12(fp)
81112904:	e0ffff17 	ldw	r3,-4(fp)
81112908:	18c0098b 	ldhu	r3,38(r3)
8111290c:	1809883a 	mov	r4,r3
81112910:	e0fffe17 	ldw	r3,-8(fp)
81112914:	10809524 	muli	r2,r2,596
81112918:	1885883a 	add	r2,r3,r2
8111291c:	10805544 	addi	r2,r2,341
81112920:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81112924:	e0bffd0b 	ldhu	r2,-12(fp)
81112928:	10809524 	muli	r2,r2,596
8111292c:	10805404 	addi	r2,r2,336
81112930:	e0fffe17 	ldw	r3,-8(fp)
81112934:	1885883a 	add	r2,r3,r2
81112938:	1009883a 	mov	r4,r2
8111293c:	1106de00 	call	81106de0 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112940:	e0bffd0b 	ldhu	r2,-12(fp)
81112944:	10809524 	muli	r2,r2,596
81112948:	10805404 	addi	r2,r2,336
8111294c:	e0fffe17 	ldw	r3,-8(fp)
81112950:	1885883a 	add	r2,r3,r2
81112954:	1009883a 	mov	r4,r2
81112958:	1106cd00 	call	81106cd0 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
8111295c:	e0bffd0b 	ldhu	r2,-12(fp)
81112960:	e0fffe17 	ldw	r3,-8(fp)
81112964:	10809524 	muli	r2,r2,596
81112968:	1885883a 	add	r2,r3,r2
8111296c:	10806404 	addi	r2,r2,400
81112970:	00c00044 	movi	r3,1
81112974:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112978:	e0bffd0b 	ldhu	r2,-12(fp)
8111297c:	10809524 	muli	r2,r2,596
81112980:	10805404 	addi	r2,r2,336
81112984:	e0fffe17 	ldw	r3,-8(fp)
81112988:	1885883a 	add	r2,r3,r2
8111298c:	1009883a 	mov	r4,r2
81112990:	1106c280 	call	81106c28 <bRmapSetIrqControl>
81112994:	00000706 	br	811129b4 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81112998:	d0a05d17 	ldw	r2,-32396(gp)
8111299c:	e0fffd0b 	ldhu	r3,-12(fp)
811129a0:	180d883a 	mov	r6,r3
811129a4:	01604574 	movhi	r5,33045
811129a8:	29644b04 	addi	r5,r5,-28372
811129ac:	1009883a 	mov	r4,r2
811129b0:	111c11c0 	call	8111c11c <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
811129b4:	d0e05d17 	ldw	r3,-32396(gp)
811129b8:	e0bfff17 	ldw	r2,-4(fp)
811129bc:	10800b0b 	ldhu	r2,44(r2)
811129c0:	113fffcc 	andi	r4,r2,65535
811129c4:	e0bfff17 	ldw	r2,-4(fp)
811129c8:	1080098b 	ldhu	r2,38(r2)
811129cc:	10bfffcc 	andi	r2,r2,65535
811129d0:	100f883a 	mov	r7,r2
811129d4:	200d883a 	mov	r6,r4
811129d8:	01604574 	movhi	r5,33045
811129dc:	29640104 	addi	r5,r5,-28668
811129e0:	1809883a 	mov	r4,r3
811129e4:	111c11c0 	call	8111c11c <fprintf>
			#endif
			break;
811129e8:	00000906 	br	81112a10 <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
811129ec:	d0a05d17 	ldw	r2,-32396(gp)
811129f0:	100f883a 	mov	r7,r2
811129f4:	01800c84 	movi	r6,50
811129f8:	01400044 	movi	r5,1
811129fc:	01204574 	movhi	r4,33045
81112a00:	21241e04 	addi	r4,r4,-28552
81112a04:	111c7b80 	call	8111c7b8 <fwrite>
			#endif
			break;
81112a08:	00000106 	br	81112a10 <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81112a0c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81112a10:	0001883a 	nop
81112a14:	e037883a 	mov	sp,fp
81112a18:	dfc00117 	ldw	ra,4(sp)
81112a1c:	df000017 	ldw	fp,0(sp)
81112a20:	dec00204 	addi	sp,sp,8
81112a24:	f800283a 	ret

81112a28 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112a28:	defff904 	addi	sp,sp,-28
81112a2c:	de00012e 	bgeu	sp,et,81112a34 <vSendCmdQToNFeeCTRL+0xc>
81112a30:	003b68fa 	trap	3
81112a34:	dfc00615 	stw	ra,24(sp)
81112a38:	df000515 	stw	fp,20(sp)
81112a3c:	df000504 	addi	fp,sp,20
81112a40:	2807883a 	mov	r3,r5
81112a44:	3005883a 	mov	r2,r6
81112a48:	e13ffd05 	stb	r4,-12(fp)
81112a4c:	e0fffe05 	stb	r3,-8(fp)
81112a50:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81112a54:	00800404 	movi	r2,16
81112a58:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112a5c:	e0bffd03 	ldbu	r2,-12(fp)
81112a60:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112a64:	e0bffe03 	ldbu	r2,-8(fp)
81112a68:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112a6c:	e0bfff03 	ldbu	r2,-4(fp)
81112a70:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81112a74:	d0a06b17 	ldw	r2,-32340(gp)
81112a78:	e0fffc17 	ldw	r3,-16(fp)
81112a7c:	180b883a 	mov	r5,r3
81112a80:	1009883a 	mov	r4,r2
81112a84:	11397080 	call	81139708 <OSQPost>
81112a88:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112a8c:	e0bffb03 	ldbu	r2,-20(fp)
81112a90:	10000126 	beq	r2,zero,81112a98 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81112a94:	1118e980 	call	81118e98 <vFailSendMsgFeeCTRL>
	}
}
81112a98:	0001883a 	nop
81112a9c:	e037883a 	mov	sp,fp
81112aa0:	dfc00117 	ldw	ra,4(sp)
81112aa4:	df000017 	ldw	fp,0(sp)
81112aa8:	dec00204 	addi	sp,sp,8
81112aac:	f800283a 	ret

81112ab0 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112ab0:	defff904 	addi	sp,sp,-28
81112ab4:	de00012e 	bgeu	sp,et,81112abc <vSendCmdQToNFeeCTRL_PRIO+0xc>
81112ab8:	003b68fa 	trap	3
81112abc:	dfc00615 	stw	ra,24(sp)
81112ac0:	df000515 	stw	fp,20(sp)
81112ac4:	df000504 	addi	fp,sp,20
81112ac8:	2807883a 	mov	r3,r5
81112acc:	3005883a 	mov	r2,r6
81112ad0:	e13ffd05 	stb	r4,-12(fp)
81112ad4:	e0fffe05 	stb	r3,-8(fp)
81112ad8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81112adc:	00800404 	movi	r2,16
81112ae0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112ae4:	e0bffd03 	ldbu	r2,-12(fp)
81112ae8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112aec:	e0bffe03 	ldbu	r2,-8(fp)
81112af0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112af4:	e0bfff03 	ldbu	r2,-4(fp)
81112af8:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81112afc:	d0a06b17 	ldw	r2,-32340(gp)
81112b00:	e0fffc17 	ldw	r3,-16(fp)
81112b04:	180b883a 	mov	r5,r3
81112b08:	1009883a 	mov	r4,r2
81112b0c:	11398780 	call	81139878 <OSQPostFront>
81112b10:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112b14:	e0bffb03 	ldbu	r2,-20(fp)
81112b18:	10000126 	beq	r2,zero,81112b20 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81112b1c:	1118e980 	call	81118e98 <vFailSendMsgFeeCTRL>
	}
}
81112b20:	0001883a 	nop
81112b24:	e037883a 	mov	sp,fp
81112b28:	dfc00117 	ldw	ra,4(sp)
81112b2c:	df000017 	ldw	fp,0(sp)
81112b30:	dec00204 	addi	sp,sp,8
81112b34:	f800283a 	ret

81112b38 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112b38:	defff804 	addi	sp,sp,-32
81112b3c:	de00012e 	bgeu	sp,et,81112b44 <vSendCmdQToNFeeCTRL_GEN+0xc>
81112b40:	003b68fa 	trap	3
81112b44:	dfc00715 	stw	ra,28(sp)
81112b48:	df000615 	stw	fp,24(sp)
81112b4c:	df000604 	addi	fp,sp,24
81112b50:	2011883a 	mov	r8,r4
81112b54:	2809883a 	mov	r4,r5
81112b58:	3007883a 	mov	r3,r6
81112b5c:	3805883a 	mov	r2,r7
81112b60:	e23ffc05 	stb	r8,-16(fp)
81112b64:	e13ffd05 	stb	r4,-12(fp)
81112b68:	e0fffe05 	stb	r3,-8(fp)
81112b6c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81112b70:	e0bffc03 	ldbu	r2,-16(fp)
81112b74:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112b78:	e0bffd03 	ldbu	r2,-12(fp)
81112b7c:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112b80:	e0bffe03 	ldbu	r2,-8(fp)
81112b84:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112b88:	e0bfff03 	ldbu	r2,-4(fp)
81112b8c:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81112b90:	d0a06b17 	ldw	r2,-32340(gp)
81112b94:	e0fffb17 	ldw	r3,-20(fp)
81112b98:	180b883a 	mov	r5,r3
81112b9c:	1009883a 	mov	r4,r2
81112ba0:	11397080 	call	81139708 <OSQPost>
81112ba4:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112ba8:	e0bffa03 	ldbu	r2,-24(fp)
81112bac:	10000126 	beq	r2,zero,81112bb4 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81112bb0:	1118e980 	call	81118e98 <vFailSendMsgFeeCTRL>
	}
}
81112bb4:	0001883a 	nop
81112bb8:	e037883a 	mov	sp,fp
81112bbc:	dfc00117 	ldw	ra,4(sp)
81112bc0:	df000017 	ldw	fp,0(sp)
81112bc4:	dec00204 	addi	sp,sp,8
81112bc8:	f800283a 	ret

81112bcc <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112bcc:	defff904 	addi	sp,sp,-28
81112bd0:	de00012e 	bgeu	sp,et,81112bd8 <vSendCmdQToDataCTRL+0xc>
81112bd4:	003b68fa 	trap	3
81112bd8:	dfc00615 	stw	ra,24(sp)
81112bdc:	df000515 	stw	fp,20(sp)
81112be0:	df000504 	addi	fp,sp,20
81112be4:	2807883a 	mov	r3,r5
81112be8:	3005883a 	mov	r2,r6
81112bec:	e13ffd05 	stb	r4,-12(fp)
81112bf0:	e0fffe05 	stb	r3,-8(fp)
81112bf4:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81112bf8:	00800804 	movi	r2,32
81112bfc:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112c00:	e0bffd03 	ldbu	r2,-12(fp)
81112c04:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112c08:	e0bffe03 	ldbu	r2,-8(fp)
81112c0c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112c10:	e0bfff03 	ldbu	r2,-4(fp)
81112c14:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81112c18:	d0a05a17 	ldw	r2,-32408(gp)
81112c1c:	e0fffc17 	ldw	r3,-16(fp)
81112c20:	180b883a 	mov	r5,r3
81112c24:	1009883a 	mov	r4,r2
81112c28:	11397080 	call	81139708 <OSQPost>
81112c2c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112c30:	e0bffb03 	ldbu	r2,-20(fp)
81112c34:	10000126 	beq	r2,zero,81112c3c <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81112c38:	1118ee40 	call	81118ee4 <vFailSendMsgDataCTRL>
	}
}
81112c3c:	0001883a 	nop
81112c40:	e037883a 	mov	sp,fp
81112c44:	dfc00117 	ldw	ra,4(sp)
81112c48:	df000017 	ldw	fp,0(sp)
81112c4c:	dec00204 	addi	sp,sp,8
81112c50:	f800283a 	ret

81112c54 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112c54:	defff904 	addi	sp,sp,-28
81112c58:	de00012e 	bgeu	sp,et,81112c60 <vSendCmdQToDataCTRL_PRIO+0xc>
81112c5c:	003b68fa 	trap	3
81112c60:	dfc00615 	stw	ra,24(sp)
81112c64:	df000515 	stw	fp,20(sp)
81112c68:	df000504 	addi	fp,sp,20
81112c6c:	2807883a 	mov	r3,r5
81112c70:	3005883a 	mov	r2,r6
81112c74:	e13ffd05 	stb	r4,-12(fp)
81112c78:	e0fffe05 	stb	r3,-8(fp)
81112c7c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81112c80:	00800404 	movi	r2,16
81112c84:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112c88:	e0bffd03 	ldbu	r2,-12(fp)
81112c8c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112c90:	e0bffe03 	ldbu	r2,-8(fp)
81112c94:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112c98:	e0bfff03 	ldbu	r2,-4(fp)
81112c9c:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81112ca0:	d0a05a17 	ldw	r2,-32408(gp)
81112ca4:	e0fffc17 	ldw	r3,-16(fp)
81112ca8:	180b883a 	mov	r5,r3
81112cac:	1009883a 	mov	r4,r2
81112cb0:	11398780 	call	81139878 <OSQPostFront>
81112cb4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112cb8:	e0bffb03 	ldbu	r2,-20(fp)
81112cbc:	10000126 	beq	r2,zero,81112cc4 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81112cc0:	1118e980 	call	81118e98 <vFailSendMsgFeeCTRL>
	}
}
81112cc4:	0001883a 	nop
81112cc8:	e037883a 	mov	sp,fp
81112ccc:	dfc00117 	ldw	ra,4(sp)
81112cd0:	df000017 	ldw	fp,0(sp)
81112cd4:	dec00204 	addi	sp,sp,8
81112cd8:	f800283a 	ret

81112cdc <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81112cdc:	defffc04 	addi	sp,sp,-16
81112ce0:	de00012e 	bgeu	sp,et,81112ce8 <vMebInit+0xc>
81112ce4:	003b68fa 	trap	3
81112ce8:	dfc00315 	stw	ra,12(sp)
81112cec:	df000215 	stw	fp,8(sp)
81112cf0:	df000204 	addi	fp,sp,8
81112cf4:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81112cf8:	e0bfff17 	ldw	r2,-4(fp)
81112cfc:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
81112d00:	e0bfff17 	ldw	r2,-4(fp)
81112d04:	00c00044 	movi	r3,1
81112d08:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
81112d0c:	d0a06417 	ldw	r2,-32368(gp)
81112d10:	1009883a 	mov	r4,r2
81112d14:	11392400 	call	81139240 <OSQFlush>
81112d18:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
81112d1c:	e0bffe03 	ldbu	r2,-8(fp)
81112d20:	10000126 	beq	r2,zero,81112d28 <vMebInit+0x4c>
		vFailFlushMEBQueue();
81112d24:	1118fc80 	call	81118fc8 <vFailFlushMEBQueue>
	}
}
81112d28:	0001883a 	nop
81112d2c:	e037883a 	mov	sp,fp
81112d30:	dfc00117 	ldw	ra,4(sp)
81112d34:	df000017 	ldw	fp,0(sp)
81112d38:	dec00204 	addi	sp,sp,8
81112d3c:	f800283a 	ret

81112d40 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
81112d40:	defffc04 	addi	sp,sp,-16
81112d44:	de00012e 	bgeu	sp,et,81112d4c <vSwapMemmory+0xc>
81112d48:	003b68fa 	trap	3
81112d4c:	dfc00315 	stw	ra,12(sp)
81112d50:	df000215 	stw	fp,8(sp)
81112d54:	df000204 	addi	fp,sp,8
81112d58:	e13fff15 	stw	r4,-4(fp)
	/*todo: Apenas para teste !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/



	/* Configurar o tamanho normal do double buffer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  */
	bSpwcGetTimecode(&pxMebCLocal->xFeeControl.xNfee[0].xChannel.xSpacewire);
81112d5c:	e0bfff17 	ldw	r2,-4(fp)
81112d60:	10809a04 	addi	r2,r2,616
81112d64:	1009883a 	mov	r4,r2
81112d68:	11094fc0 	call	811094fc <bSpwcGetTimecode>
	tCode = ( pxMebCLocal->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81112d6c:	e0bfff17 	ldw	r2,-4(fp)
81112d70:	1080a643 	ldbu	r2,665(r2)
81112d74:	e0bffe05 	stb	r2,-8(fp)
	tCodeNext = ( tCode ) % 4;
81112d78:	e0bffe03 	ldbu	r2,-8(fp)
81112d7c:	108000cc 	andi	r2,r2,3
81112d80:	e0bffe45 	stb	r2,-7(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"\n\nMEB TASK:  TIME CODE: %hhu \n ", tCode);
81112d84:	d0a05d17 	ldw	r2,-32396(gp)
81112d88:	e0fffe03 	ldbu	r3,-8(fp)
81112d8c:	180d883a 	mov	r6,r3
81112d90:	01604574 	movhi	r5,33045
81112d94:	29645e04 	addi	r5,r5,-28296
81112d98:	1009883a 	mov	r4,r2
81112d9c:	111c11c0 	call	8111c11c <fprintf>
		fprintf(fp,"MEB TASK:  MODULUS: %hhu \n\n ", tCodeNext);
81112da0:	d0a05d17 	ldw	r2,-32396(gp)
81112da4:	e0fffe43 	ldbu	r3,-7(fp)
81112da8:	180d883a 	mov	r6,r3
81112dac:	01604574 	movhi	r5,33045
81112db0:	29646604 	addi	r5,r5,-28264
81112db4:	1009883a 	mov	r4,r2
81112db8:	111c11c0 	call	8111c11c <fprintf>
	#endif


	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81112dbc:	e0bfff17 	ldw	r2,-4(fp)
81112dc0:	10800203 	ldbu	r2,8(r2)
81112dc4:	10803fcc 	andi	r2,r2,255
81112dc8:	10c00044 	addi	r3,r2,1
81112dcc:	00a00034 	movhi	r2,32768
81112dd0:	10800044 	addi	r2,r2,1
81112dd4:	1884703a 	and	r2,r3,r2
81112dd8:	1000040e 	bge	r2,zero,81112dec <vSwapMemmory+0xac>
81112ddc:	10bfffc4 	addi	r2,r2,-1
81112de0:	00ffff84 	movi	r3,-2
81112de4:	10c4b03a 	or	r2,r2,r3
81112de8:	10800044 	addi	r2,r2,1
81112dec:	1007883a 	mov	r3,r2
81112df0:	e0bfff17 	ldw	r2,-4(fp)
81112df4:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81112df8:	e0bfff17 	ldw	r2,-4(fp)
81112dfc:	10800243 	ldbu	r2,9(r2)
81112e00:	10803fcc 	andi	r2,r2,255
81112e04:	10c00044 	addi	r3,r2,1
81112e08:	00a00034 	movhi	r2,32768
81112e0c:	10800044 	addi	r2,r2,1
81112e10:	1884703a 	and	r2,r3,r2
81112e14:	1000040e 	bge	r2,zero,81112e28 <vSwapMemmory+0xe8>
81112e18:	10bfffc4 	addi	r2,r2,-1
81112e1c:	00ffff84 	movi	r3,-2
81112e20:	10c4b03a 	or	r2,r2,r3
81112e24:	10800044 	addi	r2,r2,1
81112e28:	1007883a 	mov	r3,r2
81112e2c:	e0bfff17 	ldw	r2,-4(fp)
81112e30:	10c00245 	stb	r3,9(r2)

}
81112e34:	0001883a 	nop
81112e38:	e037883a 	mov	sp,fp
81112e3c:	dfc00117 	ldw	ra,4(sp)
81112e40:	df000017 	ldw	fp,0(sp)
81112e44:	dec00204 	addi	sp,sp,8
81112e48:	f800283a 	ret

81112e4c <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81112e4c:	defffc04 	addi	sp,sp,-16
81112e50:	de00012e 	bgeu	sp,et,81112e58 <vReleaseSyncMessages+0xc>
81112e54:	003b68fa 	trap	3
81112e58:	dfc00315 	stw	ra,12(sp)
81112e5c:	df000215 	stw	fp,8(sp)
81112e60:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81112e64:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
81112e68:	00bff844 	movi	r2,-31
81112e6c:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81112e70:	e03ffe05 	stb	zero,-8(fp)
81112e74:	00001606 	br	81112ed0 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
81112e78:	e0bffe03 	ldbu	r2,-8(fp)
81112e7c:	10800444 	addi	r2,r2,17
81112e80:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
81112e84:	e0bffe03 	ldbu	r2,-8(fp)
81112e88:	1085883a 	add	r2,r2,r2
81112e8c:	1087883a 	add	r3,r2,r2
81112e90:	d0a05704 	addi	r2,gp,-32420
81112e94:	1885883a 	add	r2,r3,r2
81112e98:	10800017 	ldw	r2,0(r2)
81112e9c:	e0ffff17 	ldw	r3,-4(fp)
81112ea0:	180b883a 	mov	r5,r3
81112ea4:	1009883a 	mov	r4,r2
81112ea8:	11397080 	call	81139708 <OSQPost>
81112eac:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81112eb0:	e0bffe43 	ldbu	r2,-7(fp)
81112eb4:	10000326 	beq	r2,zero,81112ec4 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
81112eb8:	e0bffe03 	ldbu	r2,-8(fp)
81112ebc:	1009883a 	mov	r4,r2
81112ec0:	1118df80 	call	81118df8 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81112ec4:	e0bffe03 	ldbu	r2,-8(fp)
81112ec8:	10800044 	addi	r2,r2,1
81112ecc:	e0bffe05 	stb	r2,-8(fp)
81112ed0:	e0bffe03 	ldbu	r2,-8(fp)
81112ed4:	103fe826 	beq	r2,zero,81112e78 <__reset+0xfb0f2e78>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81112ed8:	0001883a 	nop
81112edc:	e037883a 	mov	sp,fp
81112ee0:	dfc00117 	ldw	ra,4(sp)
81112ee4:	df000017 	ldw	fp,0(sp)
81112ee8:	dec00204 	addi	sp,sp,8
81112eec:	f800283a 	ret

81112ef0 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
81112ef0:	defff804 	addi	sp,sp,-32
81112ef4:	de00012e 	bgeu	sp,et,81112efc <vStackMonitor+0xc>
81112ef8:	003b68fa 	trap	3
81112efc:	dfc00715 	stw	ra,28(sp)
81112f00:	df000615 	stw	fp,24(sp)
81112f04:	df000604 	addi	fp,sp,24
81112f08:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81112f0c:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
81112f10:	d0a05d17 	ldw	r2,-32396(gp)
81112f14:	100f883a 	mov	r7,r2
81112f18:	018006c4 	movi	r6,27
81112f1c:	01400044 	movi	r5,1
81112f20:	01204574 	movhi	r4,33045
81112f24:	21246e04 	addi	r4,r4,-28232
81112f28:	111c7b80 	call	8111c7b8 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81112f2c:	d0a05d17 	ldw	r2,-32396(gp)
81112f30:	100f883a 	mov	r7,r2
81112f34:	01800b04 	movi	r6,44
81112f38:	01400044 	movi	r5,1
81112f3c:	01204574 	movhi	r4,33045
81112f40:	21247504 	addi	r4,r4,-28204
81112f44:	111c7b80 	call	8111c7b8 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81112f48:	d0a05d17 	ldw	r2,-32396(gp)
81112f4c:	100f883a 	mov	r7,r2
81112f50:	01800f84 	movi	r6,62
81112f54:	01400044 	movi	r5,1
81112f58:	01204574 	movhi	r4,33045
81112f5c:	21248104 	addi	r4,r4,-28156
81112f60:	111c7b80 	call	8111c7b8 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81112f64:	e0bffd04 	addi	r2,fp,-12
81112f68:	100b883a 	mov	r5,r2
81112f6c:	01000804 	movi	r4,32
81112f70:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
81112f74:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
81112f78:	e0bffc03 	ldbu	r2,-16(fp)
81112f7c:	10000f1e 	bne	r2,zero,81112fbc <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112f80:	d1205d17 	ldw	r4,-32396(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81112f84:	e0fffd17 	ldw	r3,-12(fp)
81112f88:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112f8c:	188b883a 	add	r5,r3,r2
81112f90:	e0bffd17 	ldw	r2,-12(fp)
81112f94:	e0fffe17 	ldw	r3,-8(fp)
81112f98:	d8c00115 	stw	r3,4(sp)
81112f9c:	d8800015 	stw	r2,0(sp)
81112fa0:	280f883a 	mov	r7,r5
81112fa4:	01a04574 	movhi	r6,33045
81112fa8:	31a49104 	addi	r6,r6,-28092
81112fac:	01604574 	movhi	r5,33045
81112fb0:	29649504 	addi	r5,r5,-28076
81112fb4:	111c11c0 	call	8111c11c <fprintf>
81112fb8:	00000706 	br	81112fd8 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81112fbc:	d0a05d17 	ldw	r2,-32396(gp)
81112fc0:	100f883a 	mov	r7,r2
81112fc4:	01800904 	movi	r6,36
81112fc8:	01400044 	movi	r5,1
81112fcc:	01204574 	movhi	r4,33045
81112fd0:	2124a404 	addi	r4,r4,-28016
81112fd4:	111c7b80 	call	8111c7b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81112fd8:	e0bffd04 	addi	r2,fp,-12
81112fdc:	100b883a 	mov	r5,r2
81112fe0:	01000784 	movi	r4,30
81112fe4:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
81112fe8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112fec:	e0bffc03 	ldbu	r2,-16(fp)
81112ff0:	10000f1e 	bne	r2,zero,81113030 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112ff4:	d1205d17 	ldw	r4,-32396(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81112ff8:	e0fffd17 	ldw	r3,-12(fp)
81112ffc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113000:	188b883a 	add	r5,r3,r2
81113004:	e0bffd17 	ldw	r2,-12(fp)
81113008:	e0fffe17 	ldw	r3,-8(fp)
8111300c:	d8c00115 	stw	r3,4(sp)
81113010:	d8800015 	stw	r2,0(sp)
81113014:	280f883a 	mov	r7,r5
81113018:	01a04574 	movhi	r6,33045
8111301c:	31a4ae04 	addi	r6,r6,-27976
81113020:	01604574 	movhi	r5,33045
81113024:	29649504 	addi	r5,r5,-28076
81113028:	111c11c0 	call	8111c11c <fprintf>
8111302c:	00000706 	br	8111304c <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
81113030:	d0a05d17 	ldw	r2,-32396(gp)
81113034:	100f883a 	mov	r7,r2
81113038:	01800984 	movi	r6,38
8111303c:	01400044 	movi	r5,1
81113040:	01204574 	movhi	r4,33045
81113044:	2124b204 	addi	r4,r4,-27960
81113048:	111c7b80 	call	8111c7b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
8111304c:	e0bffd04 	addi	r2,fp,-12
81113050:	100b883a 	mov	r5,r2
81113054:	01000704 	movi	r4,28
81113058:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
8111305c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113060:	e0bffc03 	ldbu	r2,-16(fp)
81113064:	10000f1e 	bne	r2,zero,811130a4 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113068:	d1205d17 	ldw	r4,-32396(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
8111306c:	e0fffd17 	ldw	r3,-12(fp)
81113070:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113074:	188b883a 	add	r5,r3,r2
81113078:	e0bffd17 	ldw	r2,-12(fp)
8111307c:	e0fffe17 	ldw	r3,-8(fp)
81113080:	d8c00115 	stw	r3,4(sp)
81113084:	d8800015 	stw	r2,0(sp)
81113088:	280f883a 	mov	r7,r5
8111308c:	01a04574 	movhi	r6,33045
81113090:	31a4bc04 	addi	r6,r6,-27920
81113094:	01604574 	movhi	r5,33045
81113098:	29649504 	addi	r5,r5,-28076
8111309c:	111c11c0 	call	8111c11c <fprintf>
811130a0:	00000706 	br	811130c0 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
811130a4:	d0a05d17 	ldw	r2,-32396(gp)
811130a8:	100f883a 	mov	r7,r2
811130ac:	01800884 	movi	r6,34
811130b0:	01400044 	movi	r5,1
811130b4:	01204574 	movhi	r4,33045
811130b8:	2124bf04 	addi	r4,r4,-27908
811130bc:	111c7b80 	call	8111c7b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
811130c0:	e0bffd04 	addi	r2,fp,-12
811130c4:	100b883a 	mov	r5,r2
811130c8:	010006c4 	movi	r4,27
811130cc:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
811130d0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811130d4:	e0bffc03 	ldbu	r2,-16(fp)
811130d8:	10000f1e 	bne	r2,zero,81113118 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811130dc:	d1205d17 	ldw	r4,-32396(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
811130e0:	e0fffd17 	ldw	r3,-12(fp)
811130e4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811130e8:	188b883a 	add	r5,r3,r2
811130ec:	e0bffd17 	ldw	r2,-12(fp)
811130f0:	e0fffe17 	ldw	r3,-8(fp)
811130f4:	d8c00115 	stw	r3,4(sp)
811130f8:	d8800015 	stw	r2,0(sp)
811130fc:	280f883a 	mov	r7,r5
81113100:	01a04574 	movhi	r6,33045
81113104:	31a4c804 	addi	r6,r6,-27872
81113108:	01604574 	movhi	r5,33045
8111310c:	29649504 	addi	r5,r5,-28076
81113110:	111c11c0 	call	8111c11c <fprintf>
81113114:	00000706 	br	81113134 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81113118:	d0a05d17 	ldw	r2,-32396(gp)
8111311c:	100f883a 	mov	r7,r2
81113120:	018008c4 	movi	r6,35
81113124:	01400044 	movi	r5,1
81113128:	01204574 	movhi	r4,33045
8111312c:	2124cc04 	addi	r4,r4,-27856
81113130:	111c7b80 	call	8111c7b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81113134:	e0bffd04 	addi	r2,fp,-12
81113138:	100b883a 	mov	r5,r2
8111313c:	01000684 	movi	r4,26
81113140:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
81113144:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113148:	e0bffc03 	ldbu	r2,-16(fp)
8111314c:	10000f1e 	bne	r2,zero,8111318c <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113150:	d1205d17 	ldw	r4,-32396(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81113154:	e0fffd17 	ldw	r3,-12(fp)
81113158:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111315c:	188b883a 	add	r5,r3,r2
81113160:	e0bffd17 	ldw	r2,-12(fp)
81113164:	e0fffe17 	ldw	r3,-8(fp)
81113168:	d8c00115 	stw	r3,4(sp)
8111316c:	d8800015 	stw	r2,0(sp)
81113170:	280f883a 	mov	r7,r5
81113174:	01a04574 	movhi	r6,33045
81113178:	31a4d504 	addi	r6,r6,-27820
8111317c:	01604574 	movhi	r5,33045
81113180:	29649504 	addi	r5,r5,-28076
81113184:	111c11c0 	call	8111c11c <fprintf>
81113188:	00000706 	br	811131a8 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
8111318c:	d0a05d17 	ldw	r2,-32396(gp)
81113190:	100f883a 	mov	r7,r2
81113194:	01800884 	movi	r6,34
81113198:	01400044 	movi	r5,1
8111319c:	01204574 	movhi	r4,33045
811131a0:	2124d804 	addi	r4,r4,-27808
811131a4:	111c7b80 	call	8111c7b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
811131a8:	e0bffd04 	addi	r2,fp,-12
811131ac:	100b883a 	mov	r5,r2
811131b0:	01000644 	movi	r4,25
811131b4:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
811131b8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811131bc:	e0bffc03 	ldbu	r2,-16(fp)
811131c0:	10000f1e 	bne	r2,zero,81113200 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811131c4:	d1205d17 	ldw	r4,-32396(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
811131c8:	e0fffd17 	ldw	r3,-12(fp)
811131cc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811131d0:	188b883a 	add	r5,r3,r2
811131d4:	e0bffd17 	ldw	r2,-12(fp)
811131d8:	e0fffe17 	ldw	r3,-8(fp)
811131dc:	d8c00115 	stw	r3,4(sp)
811131e0:	d8800015 	stw	r2,0(sp)
811131e4:	280f883a 	mov	r7,r5
811131e8:	01a04574 	movhi	r6,33045
811131ec:	31a4e104 	addi	r6,r6,-27772
811131f0:	01604574 	movhi	r5,33045
811131f4:	29649504 	addi	r5,r5,-28076
811131f8:	111c11c0 	call	8111c11c <fprintf>
811131fc:	00000706 	br	8111321c <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
81113200:	d0a05d17 	ldw	r2,-32396(gp)
81113204:	100f883a 	mov	r7,r2
81113208:	01800884 	movi	r6,34
8111320c:	01400044 	movi	r5,1
81113210:	01204574 	movhi	r4,33045
81113214:	2124e404 	addi	r4,r4,-27760
81113218:	111c7b80 	call	8111c7b8 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
8111321c:	e0bffd04 	addi	r2,fp,-12
81113220:	100b883a 	mov	r5,r2
81113224:	01000044 	movi	r4,1
81113228:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
8111322c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113230:	e0bffc03 	ldbu	r2,-16(fp)
81113234:	10000f1e 	bne	r2,zero,81113274 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113238:	d1205d17 	ldw	r4,-32396(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
8111323c:	e0fffd17 	ldw	r3,-12(fp)
81113240:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113244:	188b883a 	add	r5,r3,r2
81113248:	e0bffd17 	ldw	r2,-12(fp)
8111324c:	e0fffe17 	ldw	r3,-8(fp)
81113250:	d8c00115 	stw	r3,4(sp)
81113254:	d8800015 	stw	r2,0(sp)
81113258:	280f883a 	mov	r7,r5
8111325c:	01a04574 	movhi	r6,33045
81113260:	31a4ed04 	addi	r6,r6,-27724
81113264:	01604574 	movhi	r5,33045
81113268:	29649504 	addi	r5,r5,-28076
8111326c:	111c11c0 	call	8111c11c <fprintf>
81113270:	00000706 	br	81113290 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81113274:	d0a05d17 	ldw	r2,-32396(gp)
81113278:	100f883a 	mov	r7,r2
8111327c:	01800804 	movi	r6,32
81113280:	01400044 	movi	r5,1
81113284:	01204574 	movhi	r4,33045
81113288:	2124f004 	addi	r4,r4,-27712
8111328c:	111c7b80 	call	8111c7b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81113290:	e0bffd04 	addi	r2,fp,-12
81113294:	100b883a 	mov	r5,r2
81113298:	010002c4 	movi	r4,11
8111329c:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
811132a0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811132a4:	e0bffc03 	ldbu	r2,-16(fp)
811132a8:	10000f1e 	bne	r2,zero,811132e8 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811132ac:	d1205d17 	ldw	r4,-32396(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
811132b0:	e0fffd17 	ldw	r3,-12(fp)
811132b4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811132b8:	188b883a 	add	r5,r3,r2
811132bc:	e0bffd17 	ldw	r2,-12(fp)
811132c0:	e0fffe17 	ldw	r3,-8(fp)
811132c4:	d8c00115 	stw	r3,4(sp)
811132c8:	d8800015 	stw	r2,0(sp)
811132cc:	280f883a 	mov	r7,r5
811132d0:	01a04574 	movhi	r6,33045
811132d4:	31a4f904 	addi	r6,r6,-27676
811132d8:	01604574 	movhi	r5,33045
811132dc:	29649504 	addi	r5,r5,-28076
811132e0:	111c11c0 	call	8111c11c <fprintf>
811132e4:	00000706 	br	81113304 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
811132e8:	d0a05d17 	ldw	r2,-32396(gp)
811132ec:	100f883a 	mov	r7,r2
811132f0:	018008c4 	movi	r6,35
811132f4:	01400044 	movi	r5,1
811132f8:	01204574 	movhi	r4,33045
811132fc:	2124fc04 	addi	r4,r4,-27664
81113300:	111c7b80 	call	8111c7b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81113304:	e0bffd04 	addi	r2,fp,-12
81113308:	100b883a 	mov	r5,r2
8111330c:	01000304 	movi	r4,12
81113310:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
81113314:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113318:	e0bffc03 	ldbu	r2,-16(fp)
8111331c:	10000f1e 	bne	r2,zero,8111335c <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113320:	d1205d17 	ldw	r4,-32396(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81113324:	e0fffd17 	ldw	r3,-12(fp)
81113328:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111332c:	188b883a 	add	r5,r3,r2
81113330:	e0bffd17 	ldw	r2,-12(fp)
81113334:	e0fffe17 	ldw	r3,-8(fp)
81113338:	d8c00115 	stw	r3,4(sp)
8111333c:	d8800015 	stw	r2,0(sp)
81113340:	280f883a 	mov	r7,r5
81113344:	01a04574 	movhi	r6,33045
81113348:	31a50504 	addi	r6,r6,-27628
8111334c:	01604574 	movhi	r5,33045
81113350:	29649504 	addi	r5,r5,-28076
81113354:	111c11c0 	call	8111c11c <fprintf>
81113358:	00000706 	br	81113378 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
8111335c:	d0a05d17 	ldw	r2,-32396(gp)
81113360:	100f883a 	mov	r7,r2
81113364:	018008c4 	movi	r6,35
81113368:	01400044 	movi	r5,1
8111336c:	01204574 	movhi	r4,33045
81113370:	21250804 	addi	r4,r4,-27616
81113374:	111c7b80 	call	8111c7b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
81113378:	e0bffd04 	addi	r2,fp,-12
8111337c:	100b883a 	mov	r5,r2
81113380:	01000344 	movi	r4,13
81113384:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
81113388:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111338c:	e0bffc03 	ldbu	r2,-16(fp)
81113390:	10000f1e 	bne	r2,zero,811133d0 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113394:	d1205d17 	ldw	r4,-32396(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81113398:	e0fffd17 	ldw	r3,-12(fp)
8111339c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811133a0:	188b883a 	add	r5,r3,r2
811133a4:	e0bffd17 	ldw	r2,-12(fp)
811133a8:	e0fffe17 	ldw	r3,-8(fp)
811133ac:	d8c00115 	stw	r3,4(sp)
811133b0:	d8800015 	stw	r2,0(sp)
811133b4:	280f883a 	mov	r7,r5
811133b8:	01a04574 	movhi	r6,33045
811133bc:	31a51104 	addi	r6,r6,-27580
811133c0:	01604574 	movhi	r5,33045
811133c4:	29649504 	addi	r5,r5,-28076
811133c8:	111c11c0 	call	8111c11c <fprintf>
811133cc:	00000706 	br	811133ec <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
811133d0:	d0a05d17 	ldw	r2,-32396(gp)
811133d4:	100f883a 	mov	r7,r2
811133d8:	018008c4 	movi	r6,35
811133dc:	01400044 	movi	r5,1
811133e0:	01204574 	movhi	r4,33045
811133e4:	21251404 	addi	r4,r4,-27568
811133e8:	111c7b80 	call	8111c7b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
811133ec:	e0bffd04 	addi	r2,fp,-12
811133f0:	100b883a 	mov	r5,r2
811133f4:	01000384 	movi	r4,14
811133f8:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
811133fc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113400:	e0bffc03 	ldbu	r2,-16(fp)
81113404:	10000f1e 	bne	r2,zero,81113444 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113408:	d1205d17 	ldw	r4,-32396(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
8111340c:	e0fffd17 	ldw	r3,-12(fp)
81113410:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113414:	188b883a 	add	r5,r3,r2
81113418:	e0bffd17 	ldw	r2,-12(fp)
8111341c:	e0fffe17 	ldw	r3,-8(fp)
81113420:	d8c00115 	stw	r3,4(sp)
81113424:	d8800015 	stw	r2,0(sp)
81113428:	280f883a 	mov	r7,r5
8111342c:	01a04574 	movhi	r6,33045
81113430:	31a51d04 	addi	r6,r6,-27532
81113434:	01604574 	movhi	r5,33045
81113438:	29649504 	addi	r5,r5,-28076
8111343c:	111c11c0 	call	8111c11c <fprintf>
81113440:	00000706 	br	81113460 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81113444:	d0a05d17 	ldw	r2,-32396(gp)
81113448:	100f883a 	mov	r7,r2
8111344c:	018008c4 	movi	r6,35
81113450:	01400044 	movi	r5,1
81113454:	01204574 	movhi	r4,33045
81113458:	21252004 	addi	r4,r4,-27520
8111345c:	111c7b80 	call	8111c7b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81113460:	e0bffd04 	addi	r2,fp,-12
81113464:	100b883a 	mov	r5,r2
81113468:	010003c4 	movi	r4,15
8111346c:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
81113470:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113474:	e0bffc03 	ldbu	r2,-16(fp)
81113478:	10000f1e 	bne	r2,zero,811134b8 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111347c:	d1205d17 	ldw	r4,-32396(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81113480:	e0fffd17 	ldw	r3,-12(fp)
81113484:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113488:	188b883a 	add	r5,r3,r2
8111348c:	e0bffd17 	ldw	r2,-12(fp)
81113490:	e0fffe17 	ldw	r3,-8(fp)
81113494:	d8c00115 	stw	r3,4(sp)
81113498:	d8800015 	stw	r2,0(sp)
8111349c:	280f883a 	mov	r7,r5
811134a0:	01a04574 	movhi	r6,33045
811134a4:	31a52904 	addi	r6,r6,-27484
811134a8:	01604574 	movhi	r5,33045
811134ac:	29649504 	addi	r5,r5,-28076
811134b0:	111c11c0 	call	8111c11c <fprintf>
811134b4:	00000706 	br	811134d4 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
811134b8:	d0a05d17 	ldw	r2,-32396(gp)
811134bc:	100f883a 	mov	r7,r2
811134c0:	018008c4 	movi	r6,35
811134c4:	01400044 	movi	r5,1
811134c8:	01204574 	movhi	r4,33045
811134cc:	21252c04 	addi	r4,r4,-27472
811134d0:	111c7b80 	call	8111c7b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
811134d4:	e0bffd04 	addi	r2,fp,-12
811134d8:	100b883a 	mov	r5,r2
811134dc:	01000404 	movi	r4,16
811134e0:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
811134e4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811134e8:	e0bffc03 	ldbu	r2,-16(fp)
811134ec:	10000f1e 	bne	r2,zero,8111352c <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811134f0:	d1205d17 	ldw	r4,-32396(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
811134f4:	e0fffd17 	ldw	r3,-12(fp)
811134f8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811134fc:	188b883a 	add	r5,r3,r2
81113500:	e0bffd17 	ldw	r2,-12(fp)
81113504:	e0fffe17 	ldw	r3,-8(fp)
81113508:	d8c00115 	stw	r3,4(sp)
8111350c:	d8800015 	stw	r2,0(sp)
81113510:	280f883a 	mov	r7,r5
81113514:	01a04574 	movhi	r6,33045
81113518:	31a53504 	addi	r6,r6,-27436
8111351c:	01604574 	movhi	r5,33045
81113520:	29649504 	addi	r5,r5,-28076
81113524:	111c11c0 	call	8111c11c <fprintf>
81113528:	00000706 	br	81113548 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
8111352c:	d0a05d17 	ldw	r2,-32396(gp)
81113530:	100f883a 	mov	r7,r2
81113534:	018008c4 	movi	r6,35
81113538:	01400044 	movi	r5,1
8111353c:	01204574 	movhi	r4,33045
81113540:	21253804 	addi	r4,r4,-27424
81113544:	111c7b80 	call	8111c7b8 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
81113548:	e0bffd04 	addi	r2,fp,-12
8111354c:	100b883a 	mov	r5,r2
81113550:	01000284 	movi	r4,10
81113554:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
81113558:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111355c:	e0bffc03 	ldbu	r2,-16(fp)
81113560:	10000f1e 	bne	r2,zero,811135a0 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113564:	d1205d17 	ldw	r4,-32396(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
81113568:	e0fffd17 	ldw	r3,-12(fp)
8111356c:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113570:	188b883a 	add	r5,r3,r2
81113574:	e0bffd17 	ldw	r2,-12(fp)
81113578:	e0fffe17 	ldw	r3,-8(fp)
8111357c:	d8c00115 	stw	r3,4(sp)
81113580:	d8800015 	stw	r2,0(sp)
81113584:	280f883a 	mov	r7,r5
81113588:	01a04574 	movhi	r6,33045
8111358c:	31a54104 	addi	r6,r6,-27388
81113590:	01604574 	movhi	r5,33045
81113594:	29649504 	addi	r5,r5,-28076
81113598:	111c11c0 	call	8111c11c <fprintf>
8111359c:	00000706 	br	811135bc <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
811135a0:	d0a05d17 	ldw	r2,-32396(gp)
811135a4:	100f883a 	mov	r7,r2
811135a8:	01800884 	movi	r6,34
811135ac:	01400044 	movi	r5,1
811135b0:	01204574 	movhi	r4,33045
811135b4:	21254404 	addi	r4,r4,-27376
811135b8:	111c7b80 	call	8111c7b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
811135bc:	e0bffd04 	addi	r2,fp,-12
811135c0:	100b883a 	mov	r5,r2
811135c4:	01000244 	movi	r4,9
811135c8:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
811135cc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811135d0:	e0bffc03 	ldbu	r2,-16(fp)
811135d4:	10000f1e 	bne	r2,zero,81113614 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811135d8:	d1205d17 	ldw	r4,-32396(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
811135dc:	e0fffd17 	ldw	r3,-12(fp)
811135e0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811135e4:	188b883a 	add	r5,r3,r2
811135e8:	e0bffd17 	ldw	r2,-12(fp)
811135ec:	e0fffe17 	ldw	r3,-8(fp)
811135f0:	d8c00115 	stw	r3,4(sp)
811135f4:	d8800015 	stw	r2,0(sp)
811135f8:	280f883a 	mov	r7,r5
811135fc:	01a04574 	movhi	r6,33045
81113600:	31a54d04 	addi	r6,r6,-27340
81113604:	01604574 	movhi	r5,33045
81113608:	29649504 	addi	r5,r5,-28076
8111360c:	111c11c0 	call	8111c11c <fprintf>
81113610:	00000706 	br	81113630 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81113614:	d0a05d17 	ldw	r2,-32396(gp)
81113618:	100f883a 	mov	r7,r2
8111361c:	01800844 	movi	r6,33
81113620:	01400044 	movi	r5,1
81113624:	01204574 	movhi	r4,33045
81113628:	21255004 	addi	r4,r4,-27328
8111362c:	111c7b80 	call	8111c7b8 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
81113630:	e0bffd04 	addi	r2,fp,-12
81113634:	100b883a 	mov	r5,r2
81113638:	01000204 	movi	r4,8
8111363c:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
81113640:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113644:	e0bffc03 	ldbu	r2,-16(fp)
81113648:	10000f1e 	bne	r2,zero,81113688 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111364c:	d1205d17 	ldw	r4,-32396(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81113650:	e0fffd17 	ldw	r3,-12(fp)
81113654:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113658:	188b883a 	add	r5,r3,r2
8111365c:	e0bffd17 	ldw	r2,-12(fp)
81113660:	e0fffe17 	ldw	r3,-8(fp)
81113664:	d8c00115 	stw	r3,4(sp)
81113668:	d8800015 	stw	r2,0(sp)
8111366c:	280f883a 	mov	r7,r5
81113670:	01a04574 	movhi	r6,33045
81113674:	31a55904 	addi	r6,r6,-27292
81113678:	01604574 	movhi	r5,33045
8111367c:	29649504 	addi	r5,r5,-28076
81113680:	111c11c0 	call	8111c11c <fprintf>
81113684:	00000706 	br	811136a4 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
81113688:	d0a05d17 	ldw	r2,-32396(gp)
8111368c:	100f883a 	mov	r7,r2
81113690:	018007c4 	movi	r6,31
81113694:	01400044 	movi	r5,1
81113698:	01204574 	movhi	r4,33045
8111369c:	21255c04 	addi	r4,r4,-27280
811136a0:	111c7b80 	call	8111c7b8 <fwrite>
    	}		


    	fprintf(fp, "\n" );
811136a4:	d0a05d17 	ldw	r2,-32396(gp)
811136a8:	100b883a 	mov	r5,r2
811136ac:	01000284 	movi	r4,10
811136b0:	111c1940 	call	8111c194 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
811136b4:	000f883a 	mov	r7,zero
811136b8:	01800284 	movi	r6,10
811136bc:	000b883a 	mov	r5,zero
811136c0:	0009883a 	mov	r4,zero
811136c4:	113c1900 	call	8113c190 <OSTimeDlyHMSM>
    }
811136c8:	003e1806 	br	81112f2c <__reset+0xfb0f2f2c>

811136cc <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
811136cc:	defffc04 	addi	sp,sp,-16
811136d0:	de00012e 	bgeu	sp,et,811136d8 <vTimeoutCheckerTaskv2+0xc>
811136d4:	003b68fa 	trap	3
811136d8:	dfc00315 	stw	ra,12(sp)
811136dc:	df000215 	stw	fp,8(sp)
811136e0:	df000204 	addi	fp,sp,8
811136e4:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811136e8:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
811136ec:	d0a05d17 	ldw	r2,-32396(gp)
811136f0:	100f883a 	mov	r7,r2
811136f4:	01800844 	movi	r6,33
811136f8:	01400044 	movi	r5,1
811136fc:	01204574 	movhi	r4,33045
81113700:	21256404 	addi	r4,r4,-27248
81113704:	111c7b80 	call	8111c7b8 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81113708:	d0a06217 	ldw	r2,-32376(gp)
8111370c:	e1bffe04 	addi	r6,fp,-8
81113710:	000b883a 	mov	r5,zero
81113714:	1009883a 	mov	r4,r2
81113718:	113a1f80 	call	8113a1f8 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
8111371c:	e0bffe03 	ldbu	r2,-8(fp)
81113720:	10803fcc 	andi	r2,r2,255
81113724:	1000021e 	bne	r2,zero,81113730 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81113728:	11137380 	call	81113738 <vCheck>
8111372c:	003ff606 	br	81113708 <__reset+0xfb0f3708>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81113730:	111800c0 	call	8111800c <vFailGetBlockingSemTimeoutTask>
        }
    }
81113734:	003ff406 	br	81113708 <__reset+0xfb0f3708>

81113738 <vCheck>:
}


void vCheck( void ) {
81113738:	defffd04 	addi	sp,sp,-12
8111373c:	de00012e 	bgeu	sp,et,81113744 <vCheck+0xc>
81113740:	003b68fa 	trap	3
81113744:	dfc00215 	stw	ra,8(sp)
81113748:	df000115 	stw	fp,4(sp)
8111374c:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81113750:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81113754:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81113758:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8111375c:	d0a06383 	ldbu	r2,-32370(gp)
81113760:	10803fcc 	andi	r2,r2,255
81113764:	10800218 	cmpnei	r2,r2,8
81113768:	1000021e 	bne	r2,zero,81113774 <vCheck+0x3c>
8111376c:	00c00104 	movi	r3,4
81113770:	00000106 	br	81113778 <vCheck+0x40>
81113774:	0007883a 	mov	r3,zero
81113778:	d0a07003 	ldbu	r2,-32320(gp)
8111377c:	10803fcc 	andi	r2,r2,255
81113780:	10800218 	cmpnei	r2,r2,8
81113784:	1000021e 	bne	r2,zero,81113790 <vCheck+0x58>
81113788:	00800084 	movi	r2,2
8111378c:	00000106 	br	81113794 <vCheck+0x5c>
81113790:	0005883a 	mov	r2,zero
81113794:	1884b03a 	or	r2,r3,r2
81113798:	1007883a 	mov	r3,r2
8111379c:	d0a07043 	ldbu	r2,-32319(gp)
811137a0:	10803fcc 	andi	r2,r2,255
811137a4:	108001a0 	cmpeqi	r2,r2,6
811137a8:	1884b03a 	or	r2,r3,r2
811137ac:	1007883a 	mov	r3,r2
811137b0:	e0bfff03 	ldbu	r2,-4(fp)
811137b4:	1884b03a 	or	r2,r3,r2
811137b8:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
811137bc:	e0bfff03 	ldbu	r2,-4(fp)
811137c0:	108001d8 	cmpnei	r2,r2,7
811137c4:	10003726 	beq	r2,zero,811138a4 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
811137c8:	d0a06f17 	ldw	r2,-32324(gp)
811137cc:	e0ffff44 	addi	r3,fp,-3
811137d0:	180d883a 	mov	r6,r3
811137d4:	000b883a 	mov	r5,zero
811137d8:	1009883a 	mov	r4,r2
811137dc:	11381ec0 	call	811381ec <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
811137e0:	e0bfff43 	ldbu	r2,-3(fp)
811137e4:	10803fcc 	andi	r2,r2,255
811137e8:	10000826 	beq	r2,zero,8111380c <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
811137ec:	d0a05d17 	ldw	r2,-32396(gp)
811137f0:	100f883a 	mov	r7,r2
811137f4:	01800f04 	movi	r6,60
811137f8:	01400044 	movi	r5,1
811137fc:	01204574 	movhi	r4,33045
81113800:	21256d04 	addi	r4,r4,-27212
81113804:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
        return;
81113808:	00002706 	br	811138a8 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8111380c:	e0bfff03 	ldbu	r2,-4(fp)
81113810:	1080004c 	andi	r2,r2,1
81113814:	10803fcc 	andi	r2,r2,255
81113818:	1000021e 	bne	r2,zero,81113824 <vCheck+0xec>
        vCheckRetransmission128();
8111381c:	11138bc0 	call	811138bc <vCheckRetransmission128>
81113820:	00000506 	br	81113838 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81113824:	01800604 	movi	r6,24
81113828:	000b883a 	mov	r5,zero
8111382c:	012045b4 	movhi	r4,33046
81113830:	21263f04 	addi	r4,r4,-26372
81113834:	111d31c0 	call	8111d31c <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81113838:	e0bfff03 	ldbu	r2,-4(fp)
8111383c:	1080008c 	andi	r2,r2,2
81113840:	10803fcc 	andi	r2,r2,255
81113844:	1000021e 	bne	r2,zero,81113850 <vCheck+0x118>
        vCheckRetransmission64();
81113848:	1113b400 	call	81113b40 <vCheckRetransmission64>
8111384c:	00000506 	br	81113864 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81113850:	01800804 	movi	r6,32
81113854:	000b883a 	mov	r5,zero
81113858:	012045b4 	movhi	r4,33046
8111385c:	21264504 	addi	r4,r4,-26348
81113860:	111d31c0 	call	8111d31c <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81113864:	e0bfff03 	ldbu	r2,-4(fp)
81113868:	1080010c 	andi	r2,r2,4
8111386c:	10803fcc 	andi	r2,r2,255
81113870:	1000021e 	bne	r2,zero,8111387c <vCheck+0x144>
        vCheckRetransmission32();
81113874:	1113dcc0 	call	81113dcc <vCheckRetransmission32>
81113878:	00000506 	br	81113890 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
8111387c:	01800804 	movi	r6,32
81113880:	000b883a 	mov	r5,zero
81113884:	012045b4 	movhi	r4,33046
81113888:	21264d04 	addi	r4,r4,-26316
8111388c:	111d31c0 	call	8111d31c <memset>


    OSMutexPost(xTxUARTMutex);
81113890:	d0a06f17 	ldw	r2,-32324(gp)
81113894:	1009883a 	mov	r4,r2
81113898:	11387900 	call	81138790 <OSMutexPost>

    return;
8111389c:	0001883a 	nop
811138a0:	00000106 	br	811138a8 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
811138a4:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
811138a8:	e037883a 	mov	sp,fp
811138ac:	dfc00117 	ldw	ra,4(sp)
811138b0:	df000017 	ldw	fp,0(sp)
811138b4:	dec00204 	addi	sp,sp,8
811138b8:	f800283a 	ret

811138bc <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
811138bc:	defffd04 	addi	sp,sp,-12
811138c0:	de00012e 	bgeu	sp,et,811138c8 <vCheckRetransmission128+0xc>
811138c4:	003b68fa 	trap	3
811138c8:	dfc00215 	stw	ra,8(sp)
811138cc:	df000115 	stw	fp,4(sp)
811138d0:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811138d4:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
811138d8:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811138dc:	d0a06917 	ldw	r2,-32348(gp)
811138e0:	e0ffff44 	addi	r3,fp,-3
811138e4:	180b883a 	mov	r5,r3
811138e8:	1009883a 	mov	r4,r2
811138ec:	1137b6c0 	call	81137b6c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811138f0:	e0bfff43 	ldbu	r2,-3(fp)
811138f4:	10803fcc 	andi	r2,r2,255
811138f8:	10008b1e 	bne	r2,zero,81113b28 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811138fc:	e03fff05 	stb	zero,-4(fp)
81113900:	00008106 	br	81113b08 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81113904:	e0ffff03 	ldbu	r3,-4(fp)
81113908:	00a045b4 	movhi	r2,33046
8111390c:	10a63f04 	addi	r2,r2,-26372
81113910:	18c7883a 	add	r3,r3,r3
81113914:	18c7883a 	add	r3,r3,r3
81113918:	10c5883a 	add	r2,r2,r3
8111391c:	10800017 	ldw	r2,0(r2)
81113920:	10800058 	cmpnei	r2,r2,1
81113924:	1000751e 	bne	r2,zero,81113afc <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81113928:	e0ffff03 	ldbu	r3,-4(fp)
8111392c:	00a045b4 	movhi	r2,33046
81113930:	10a65d04 	addi	r2,r2,-26252
81113934:	18c02324 	muli	r3,r3,140
81113938:	10c5883a 	add	r2,r2,r3
8111393c:	10802004 	addi	r2,r2,128
81113940:	10800017 	ldw	r2,0(r2)
81113944:	10800058 	cmpnei	r2,r2,1
81113948:	1000211e 	bne	r2,zero,811139d0 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
8111394c:	e0ffff03 	ldbu	r3,-4(fp)
81113950:	00a045b4 	movhi	r2,33046
81113954:	10a65d04 	addi	r2,r2,-26252
81113958:	19002324 	muli	r4,r3,140
8111395c:	1105883a 	add	r2,r2,r4
81113960:	10802184 	addi	r2,r2,134
81113964:	1080000b 	ldhu	r2,0(r2)
81113968:	10800044 	addi	r2,r2,1
8111396c:	100b883a 	mov	r5,r2
81113970:	00a045b4 	movhi	r2,33046
81113974:	10a65d04 	addi	r2,r2,-26252
81113978:	19002324 	muli	r4,r3,140
8111397c:	1105883a 	add	r2,r2,r4
81113980:	10802184 	addi	r2,r2,134
81113984:	1140000d 	sth	r5,0(r2)
81113988:	00a045b4 	movhi	r2,33046
8111398c:	10a65d04 	addi	r2,r2,-26252
81113990:	18c02324 	muli	r3,r3,140
81113994:	10c5883a 	add	r2,r2,r3
81113998:	10802184 	addi	r2,r2,134
8111399c:	1080000b 	ldhu	r2,0(r2)
811139a0:	10bfffcc 	andi	r2,r2,65535
811139a4:	10a0001c 	xori	r2,r2,32768
811139a8:	10a00004 	addi	r2,r2,-32768
811139ac:	10800090 	cmplti	r2,r2,2
811139b0:	1000071e 	bne	r2,zero,811139d0 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
811139b4:	e0ffff03 	ldbu	r3,-4(fp)
811139b8:	00a045b4 	movhi	r2,33046
811139bc:	10a65d04 	addi	r2,r2,-26252
811139c0:	18c02324 	muli	r3,r3,140
811139c4:	10c5883a 	add	r2,r2,r3
811139c8:	10802004 	addi	r2,r2,128
811139cc:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
811139d0:	e0ffff03 	ldbu	r3,-4(fp)
811139d4:	00a045b4 	movhi	r2,33046
811139d8:	10a65d04 	addi	r2,r2,-26252
811139dc:	18c02324 	muli	r3,r3,140
811139e0:	10c5883a 	add	r2,r2,r3
811139e4:	10802004 	addi	r2,r2,128
811139e8:	10800017 	ldw	r2,0(r2)
811139ec:	1000431e 	bne	r2,zero,81113afc <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
811139f0:	e0bfff03 	ldbu	r2,-4(fp)
811139f4:	10c02324 	muli	r3,r2,140
811139f8:	00a045b4 	movhi	r2,33046
811139fc:	10a65d04 	addi	r2,r2,-26252
81113a00:	1885883a 	add	r2,r3,r2
81113a04:	1009883a 	mov	r4,r2
81113a08:	111d7680 	call	8111d768 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81113a0c:	e0ffff03 	ldbu	r3,-4(fp)
81113a10:	00a045b4 	movhi	r2,33046
81113a14:	10a65d04 	addi	r2,r2,-26252
81113a18:	18c02324 	muli	r3,r3,140
81113a1c:	10c5883a 	add	r2,r2,r3
81113a20:	10802004 	addi	r2,r2,128
81113a24:	00c00044 	movi	r3,1
81113a28:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81113a2c:	e0ffff03 	ldbu	r3,-4(fp)
81113a30:	00a045b4 	movhi	r2,33046
81113a34:	10a65d04 	addi	r2,r2,-26252
81113a38:	18c02324 	muli	r3,r3,140
81113a3c:	10c5883a 	add	r2,r2,r3
81113a40:	10802184 	addi	r2,r2,134
81113a44:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81113a48:	e0ffff03 	ldbu	r3,-4(fp)
81113a4c:	00a045b4 	movhi	r2,33046
81113a50:	10a65d04 	addi	r2,r2,-26252
81113a54:	19002324 	muli	r4,r3,140
81113a58:	1105883a 	add	r2,r2,r4
81113a5c:	10802204 	addi	r2,r2,136
81113a60:	10800003 	ldbu	r2,0(r2)
81113a64:	10800044 	addi	r2,r2,1
81113a68:	100b883a 	mov	r5,r2
81113a6c:	00a045b4 	movhi	r2,33046
81113a70:	10a65d04 	addi	r2,r2,-26252
81113a74:	19002324 	muli	r4,r3,140
81113a78:	1105883a 	add	r2,r2,r4
81113a7c:	10802204 	addi	r2,r2,136
81113a80:	11400005 	stb	r5,0(r2)
81113a84:	00a045b4 	movhi	r2,33046
81113a88:	10a65d04 	addi	r2,r2,-26252
81113a8c:	18c02324 	muli	r3,r3,140
81113a90:	10c5883a 	add	r2,r2,r3
81113a94:	10802204 	addi	r2,r2,136
81113a98:	10800003 	ldbu	r2,0(r2)
81113a9c:	10803fcc 	andi	r2,r2,255
81113aa0:	108000b0 	cmpltui	r2,r2,2
81113aa4:	1000151e 	bne	r2,zero,81113afc <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81113aa8:	e0ffff03 	ldbu	r3,-4(fp)
81113aac:	00a045b4 	movhi	r2,33046
81113ab0:	10a63f04 	addi	r2,r2,-26372
81113ab4:	18c7883a 	add	r3,r3,r3
81113ab8:	18c7883a 	add	r3,r3,r3
81113abc:	10c5883a 	add	r2,r2,r3
81113ac0:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81113ac4:	d0a07043 	ldbu	r2,-32319(gp)
81113ac8:	10800044 	addi	r2,r2,1
81113acc:	d0a07045 	stb	r2,-32319(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81113ad0:	d0a05e17 	ldw	r2,-32392(gp)
81113ad4:	1009883a 	mov	r4,r2
81113ad8:	113a5800 	call	8113a580 <OSSemPost>
81113adc:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81113ae0:	e0bfff43 	ldbu	r2,-3(fp)
81113ae4:	10803fcc 	andi	r2,r2,255
81113ae8:	10000426 	beq	r2,zero,81113afc <vCheckRetransmission128+0x240>
                        SemCount128--;
81113aec:	d0a07043 	ldbu	r2,-32319(gp)
81113af0:	10bfffc4 	addi	r2,r2,-1
81113af4:	d0a07045 	stb	r2,-32319(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81113af8:	11178fc0 	call	811178fc <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81113afc:	e0bfff03 	ldbu	r2,-4(fp)
81113b00:	10800044 	addi	r2,r2,1
81113b04:	e0bfff05 	stb	r2,-4(fp)
81113b08:	e0bfff03 	ldbu	r2,-4(fp)
81113b0c:	108001b0 	cmpltui	r2,r2,6
81113b10:	103f7c1e 	bne	r2,zero,81113904 <__reset+0xfb0f3904>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81113b14:	d0a06917 	ldw	r2,-32348(gp)
81113b18:	1009883a 	mov	r4,r2
81113b1c:	11387900 	call	81138790 <OSMutexPost>

    return;
81113b20:	0001883a 	nop
81113b24:	00000106 	br	81113b2c <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81113b28:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81113b2c:	e037883a 	mov	sp,fp
81113b30:	dfc00117 	ldw	ra,4(sp)
81113b34:	df000017 	ldw	fp,0(sp)
81113b38:	dec00204 	addi	sp,sp,8
81113b3c:	f800283a 	ret

81113b40 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81113b40:	defffd04 	addi	sp,sp,-12
81113b44:	de00012e 	bgeu	sp,et,81113b4c <vCheckRetransmission64+0xc>
81113b48:	003b68fa 	trap	3
81113b4c:	dfc00215 	stw	ra,8(sp)
81113b50:	df000115 	stw	fp,4(sp)
81113b54:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81113b58:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81113b5c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81113b60:	d0a06c17 	ldw	r2,-32336(gp)
81113b64:	e0ffff44 	addi	r3,fp,-3
81113b68:	180b883a 	mov	r5,r3
81113b6c:	1009883a 	mov	r4,r2
81113b70:	1137b6c0 	call	81137b6c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81113b74:	e0bfff43 	ldbu	r2,-3(fp)
81113b78:	10803fcc 	andi	r2,r2,255
81113b7c:	10008d1e 	bne	r2,zero,81113db4 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81113b80:	e03fff05 	stb	zero,-4(fp)
81113b84:	00008306 	br	81113d94 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81113b88:	e0ffff03 	ldbu	r3,-4(fp)
81113b8c:	00a045b4 	movhi	r2,33046
81113b90:	10a63f04 	addi	r2,r2,-26372
81113b94:	18c00184 	addi	r3,r3,6
81113b98:	18c7883a 	add	r3,r3,r3
81113b9c:	18c7883a 	add	r3,r3,r3
81113ba0:	10c5883a 	add	r2,r2,r3
81113ba4:	10800017 	ldw	r2,0(r2)
81113ba8:	10800058 	cmpnei	r2,r2,1
81113bac:	1000761e 	bne	r2,zero,81113d88 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81113bb0:	e0ffff03 	ldbu	r3,-4(fp)
81113bb4:	00a04574 	movhi	r2,33045
81113bb8:	10821e04 	addi	r2,r2,2168
81113bbc:	18c01324 	muli	r3,r3,76
81113bc0:	10c5883a 	add	r2,r2,r3
81113bc4:	10801004 	addi	r2,r2,64
81113bc8:	10800017 	ldw	r2,0(r2)
81113bcc:	10800058 	cmpnei	r2,r2,1
81113bd0:	1000211e 	bne	r2,zero,81113c58 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81113bd4:	e0ffff03 	ldbu	r3,-4(fp)
81113bd8:	00a04574 	movhi	r2,33045
81113bdc:	10821e04 	addi	r2,r2,2168
81113be0:	19001324 	muli	r4,r3,76
81113be4:	1105883a 	add	r2,r2,r4
81113be8:	10801184 	addi	r2,r2,70
81113bec:	1080000b 	ldhu	r2,0(r2)
81113bf0:	10800044 	addi	r2,r2,1
81113bf4:	100b883a 	mov	r5,r2
81113bf8:	00a04574 	movhi	r2,33045
81113bfc:	10821e04 	addi	r2,r2,2168
81113c00:	19001324 	muli	r4,r3,76
81113c04:	1105883a 	add	r2,r2,r4
81113c08:	10801184 	addi	r2,r2,70
81113c0c:	1140000d 	sth	r5,0(r2)
81113c10:	00a04574 	movhi	r2,33045
81113c14:	10821e04 	addi	r2,r2,2168
81113c18:	18c01324 	muli	r3,r3,76
81113c1c:	10c5883a 	add	r2,r2,r3
81113c20:	10801184 	addi	r2,r2,70
81113c24:	1080000b 	ldhu	r2,0(r2)
81113c28:	10bfffcc 	andi	r2,r2,65535
81113c2c:	10a0001c 	xori	r2,r2,32768
81113c30:	10a00004 	addi	r2,r2,-32768
81113c34:	10800090 	cmplti	r2,r2,2
81113c38:	1000071e 	bne	r2,zero,81113c58 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81113c3c:	e0ffff03 	ldbu	r3,-4(fp)
81113c40:	00a04574 	movhi	r2,33045
81113c44:	10821e04 	addi	r2,r2,2168
81113c48:	18c01324 	muli	r3,r3,76
81113c4c:	10c5883a 	add	r2,r2,r3
81113c50:	10801004 	addi	r2,r2,64
81113c54:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81113c58:	e0ffff03 	ldbu	r3,-4(fp)
81113c5c:	00a04574 	movhi	r2,33045
81113c60:	10821e04 	addi	r2,r2,2168
81113c64:	18c01324 	muli	r3,r3,76
81113c68:	10c5883a 	add	r2,r2,r3
81113c6c:	10801004 	addi	r2,r2,64
81113c70:	10800017 	ldw	r2,0(r2)
81113c74:	1000441e 	bne	r2,zero,81113d88 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
81113c78:	e0bfff03 	ldbu	r2,-4(fp)
81113c7c:	10c01324 	muli	r3,r2,76
81113c80:	00a04574 	movhi	r2,33045
81113c84:	10821e04 	addi	r2,r2,2168
81113c88:	1885883a 	add	r2,r3,r2
81113c8c:	1009883a 	mov	r4,r2
81113c90:	111d7680 	call	8111d768 <puts>
                xBuffer64[ucIL].bSent = TRUE;
81113c94:	e0ffff03 	ldbu	r3,-4(fp)
81113c98:	00a04574 	movhi	r2,33045
81113c9c:	10821e04 	addi	r2,r2,2168
81113ca0:	18c01324 	muli	r3,r3,76
81113ca4:	10c5883a 	add	r2,r2,r3
81113ca8:	10801004 	addi	r2,r2,64
81113cac:	00c00044 	movi	r3,1
81113cb0:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81113cb4:	e0ffff03 	ldbu	r3,-4(fp)
81113cb8:	00a04574 	movhi	r2,33045
81113cbc:	10821e04 	addi	r2,r2,2168
81113cc0:	18c01324 	muli	r3,r3,76
81113cc4:	10c5883a 	add	r2,r2,r3
81113cc8:	10801184 	addi	r2,r2,70
81113ccc:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81113cd0:	e0ffff03 	ldbu	r3,-4(fp)
81113cd4:	00a04574 	movhi	r2,33045
81113cd8:	10821e04 	addi	r2,r2,2168
81113cdc:	19001324 	muli	r4,r3,76
81113ce0:	1105883a 	add	r2,r2,r4
81113ce4:	10801204 	addi	r2,r2,72
81113ce8:	10800003 	ldbu	r2,0(r2)
81113cec:	10800044 	addi	r2,r2,1
81113cf0:	100b883a 	mov	r5,r2
81113cf4:	00a04574 	movhi	r2,33045
81113cf8:	10821e04 	addi	r2,r2,2168
81113cfc:	19001324 	muli	r4,r3,76
81113d00:	1105883a 	add	r2,r2,r4
81113d04:	10801204 	addi	r2,r2,72
81113d08:	11400005 	stb	r5,0(r2)
81113d0c:	00a04574 	movhi	r2,33045
81113d10:	10821e04 	addi	r2,r2,2168
81113d14:	18c01324 	muli	r3,r3,76
81113d18:	10c5883a 	add	r2,r2,r3
81113d1c:	10801204 	addi	r2,r2,72
81113d20:	10800003 	ldbu	r2,0(r2)
81113d24:	10803fcc 	andi	r2,r2,255
81113d28:	108000b0 	cmpltui	r2,r2,2
81113d2c:	1000161e 	bne	r2,zero,81113d88 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
81113d30:	e0ffff03 	ldbu	r3,-4(fp)
81113d34:	00a045b4 	movhi	r2,33046
81113d38:	10a63f04 	addi	r2,r2,-26372
81113d3c:	18c00184 	addi	r3,r3,6
81113d40:	18c7883a 	add	r3,r3,r3
81113d44:	18c7883a 	add	r3,r3,r3
81113d48:	10c5883a 	add	r2,r2,r3
81113d4c:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81113d50:	d0a07003 	ldbu	r2,-32320(gp)
81113d54:	10800044 	addi	r2,r2,1
81113d58:	d0a07005 	stb	r2,-32320(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81113d5c:	d0a05917 	ldw	r2,-32412(gp)
81113d60:	1009883a 	mov	r4,r2
81113d64:	113a5800 	call	8113a580 <OSSemPost>
81113d68:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81113d6c:	e0bfff43 	ldbu	r2,-3(fp)
81113d70:	10803fcc 	andi	r2,r2,255
81113d74:	10000426 	beq	r2,zero,81113d88 <vCheckRetransmission64+0x248>
                        SemCount64--;
81113d78:	d0a07003 	ldbu	r2,-32320(gp)
81113d7c:	10bfffc4 	addi	r2,r2,-1
81113d80:	d0a07005 	stb	r2,-32320(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81113d84:	11178940 	call	81117894 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81113d88:	e0bfff03 	ldbu	r2,-4(fp)
81113d8c:	10800044 	addi	r2,r2,1
81113d90:	e0bfff05 	stb	r2,-4(fp)
81113d94:	e0bfff03 	ldbu	r2,-4(fp)
81113d98:	10800230 	cmpltui	r2,r2,8
81113d9c:	103f7a1e 	bne	r2,zero,81113b88 <__reset+0xfb0f3b88>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81113da0:	d0a06c17 	ldw	r2,-32336(gp)
81113da4:	1009883a 	mov	r4,r2
81113da8:	11387900 	call	81138790 <OSMutexPost>

    return;
81113dac:	0001883a 	nop
81113db0:	00000106 	br	81113db8 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81113db4:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
81113db8:	e037883a 	mov	sp,fp
81113dbc:	dfc00117 	ldw	ra,4(sp)
81113dc0:	df000017 	ldw	fp,0(sp)
81113dc4:	dec00204 	addi	sp,sp,8
81113dc8:	f800283a 	ret

81113dcc <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81113dcc:	defffd04 	addi	sp,sp,-12
81113dd0:	de00012e 	bgeu	sp,et,81113dd8 <vCheckRetransmission32+0xc>
81113dd4:	003b68fa 	trap	3
81113dd8:	dfc00215 	stw	ra,8(sp)
81113ddc:	df000115 	stw	fp,4(sp)
81113de0:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81113de4:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
81113de8:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81113dec:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81113df0:	d0a06717 	ldw	r2,-32356(gp)
81113df4:	e0ffff84 	addi	r3,fp,-2
81113df8:	180b883a 	mov	r5,r3
81113dfc:	1009883a 	mov	r4,r2
81113e00:	1137b6c0 	call	81137b6c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81113e04:	e0bfff83 	ldbu	r2,-2(fp)
81113e08:	10803fcc 	andi	r2,r2,255
81113e0c:	10009b1e 	bne	r2,zero,8111407c <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81113e10:	e03fff05 	stb	zero,-4(fp)
81113e14:	00009106 	br	8111405c <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
81113e18:	e0ffff03 	ldbu	r3,-4(fp)
81113e1c:	00a045b4 	movhi	r2,33046
81113e20:	10a63f04 	addi	r2,r2,-26372
81113e24:	18c00384 	addi	r3,r3,14
81113e28:	18c7883a 	add	r3,r3,r3
81113e2c:	18c7883a 	add	r3,r3,r3
81113e30:	10c5883a 	add	r2,r2,r3
81113e34:	10800017 	ldw	r2,0(r2)
81113e38:	10800058 	cmpnei	r2,r2,1
81113e3c:	1000841e 	bne	r2,zero,81114050 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81113e40:	e0ffff03 	ldbu	r3,-4(fp)
81113e44:	00a04574 	movhi	r2,33045
81113e48:	1093cb04 	addi	r2,r2,20268
81113e4c:	18c00b24 	muli	r3,r3,44
81113e50:	10c5883a 	add	r2,r2,r3
81113e54:	10800804 	addi	r2,r2,32
81113e58:	10800017 	ldw	r2,0(r2)
81113e5c:	10800058 	cmpnei	r2,r2,1
81113e60:	1000211e 	bne	r2,zero,81113ee8 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81113e64:	e0ffff03 	ldbu	r3,-4(fp)
81113e68:	00a04574 	movhi	r2,33045
81113e6c:	1093cb04 	addi	r2,r2,20268
81113e70:	19000b24 	muli	r4,r3,44
81113e74:	1105883a 	add	r2,r2,r4
81113e78:	10800984 	addi	r2,r2,38
81113e7c:	1080000b 	ldhu	r2,0(r2)
81113e80:	10800044 	addi	r2,r2,1
81113e84:	100b883a 	mov	r5,r2
81113e88:	00a04574 	movhi	r2,33045
81113e8c:	1093cb04 	addi	r2,r2,20268
81113e90:	19000b24 	muli	r4,r3,44
81113e94:	1105883a 	add	r2,r2,r4
81113e98:	10800984 	addi	r2,r2,38
81113e9c:	1140000d 	sth	r5,0(r2)
81113ea0:	00a04574 	movhi	r2,33045
81113ea4:	1093cb04 	addi	r2,r2,20268
81113ea8:	18c00b24 	muli	r3,r3,44
81113eac:	10c5883a 	add	r2,r2,r3
81113eb0:	10800984 	addi	r2,r2,38
81113eb4:	1080000b 	ldhu	r2,0(r2)
81113eb8:	10bfffcc 	andi	r2,r2,65535
81113ebc:	10a0001c 	xori	r2,r2,32768
81113ec0:	10a00004 	addi	r2,r2,-32768
81113ec4:	10800090 	cmplti	r2,r2,2
81113ec8:	1000071e 	bne	r2,zero,81113ee8 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81113ecc:	e0ffff03 	ldbu	r3,-4(fp)
81113ed0:	00a04574 	movhi	r2,33045
81113ed4:	1093cb04 	addi	r2,r2,20268
81113ed8:	18c00b24 	muli	r3,r3,44
81113edc:	10c5883a 	add	r2,r2,r3
81113ee0:	10800804 	addi	r2,r2,32
81113ee4:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81113ee8:	e0ffff03 	ldbu	r3,-4(fp)
81113eec:	00a04574 	movhi	r2,33045
81113ef0:	1093cb04 	addi	r2,r2,20268
81113ef4:	18c00b24 	muli	r3,r3,44
81113ef8:	10c5883a 	add	r2,r2,r3
81113efc:	10800804 	addi	r2,r2,32
81113f00:	10800017 	ldw	r2,0(r2)
81113f04:	1000521e 	bne	r2,zero,81114050 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81113f08:	e0bfff03 	ldbu	r2,-4(fp)
81113f0c:	10c00b24 	muli	r3,r2,44
81113f10:	00a04574 	movhi	r2,33045
81113f14:	1093cb04 	addi	r2,r2,20268
81113f18:	1885883a 	add	r2,r3,r2
81113f1c:	1009883a 	mov	r4,r2
81113f20:	111d7680 	call	8111d768 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81113f24:	e0ffff03 	ldbu	r3,-4(fp)
81113f28:	00a04574 	movhi	r2,33045
81113f2c:	1093cb04 	addi	r2,r2,20268
81113f30:	18c00b24 	muli	r3,r3,44
81113f34:	10c5883a 	add	r2,r2,r3
81113f38:	10800804 	addi	r2,r2,32
81113f3c:	00c00044 	movi	r3,1
81113f40:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81113f44:	e0ffff03 	ldbu	r3,-4(fp)
81113f48:	00a04574 	movhi	r2,33045
81113f4c:	1093cb04 	addi	r2,r2,20268
81113f50:	18c00b24 	muli	r3,r3,44
81113f54:	10c5883a 	add	r2,r2,r3
81113f58:	10800984 	addi	r2,r2,38
81113f5c:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81113f60:	e0ffff03 	ldbu	r3,-4(fp)
81113f64:	00a04574 	movhi	r2,33045
81113f68:	1093cb04 	addi	r2,r2,20268
81113f6c:	18c00b24 	muli	r3,r3,44
81113f70:	10c5883a 	add	r2,r2,r3
81113f74:	10800904 	addi	r2,r2,36
81113f78:	1080000b 	ldhu	r2,0(r2)
81113f7c:	10bfffcc 	andi	r2,r2,65535
81113f80:	10800058 	cmpnei	r2,r2,1
81113f84:	1000021e 	bne	r2,zero,81113f90 <vCheckRetransmission32+0x1c4>
81113f88:	00bffe84 	movi	r2,-6
81113f8c:	00000106 	br	81113f94 <vCheckRetransmission32+0x1c8>
81113f90:	00800044 	movi	r2,1
81113f94:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81113f98:	e0ffff03 	ldbu	r3,-4(fp)
81113f9c:	00a04574 	movhi	r2,33045
81113fa0:	1093cb04 	addi	r2,r2,20268
81113fa4:	19000b24 	muli	r4,r3,44
81113fa8:	1105883a 	add	r2,r2,r4
81113fac:	10800a04 	addi	r2,r2,40
81113fb0:	10800003 	ldbu	r2,0(r2)
81113fb4:	10800044 	addi	r2,r2,1
81113fb8:	100b883a 	mov	r5,r2
81113fbc:	00a04574 	movhi	r2,33045
81113fc0:	1093cb04 	addi	r2,r2,20268
81113fc4:	19000b24 	muli	r4,r3,44
81113fc8:	1105883a 	add	r2,r2,r4
81113fcc:	10800a04 	addi	r2,r2,40
81113fd0:	11400005 	stb	r5,0(r2)
81113fd4:	00a04574 	movhi	r2,33045
81113fd8:	1093cb04 	addi	r2,r2,20268
81113fdc:	18c00b24 	muli	r3,r3,44
81113fe0:	10c5883a 	add	r2,r2,r3
81113fe4:	10800a04 	addi	r2,r2,40
81113fe8:	10800003 	ldbu	r2,0(r2)
81113fec:	10803fcc 	andi	r2,r2,255
81113ff0:	e0ffff43 	ldbu	r3,-3(fp)
81113ff4:	1880162e 	bgeu	r3,r2,81114050 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81113ff8:	e0ffff03 	ldbu	r3,-4(fp)
81113ffc:	00a045b4 	movhi	r2,33046
81114000:	10a63f04 	addi	r2,r2,-26372
81114004:	18c00384 	addi	r3,r3,14
81114008:	18c7883a 	add	r3,r3,r3
8111400c:	18c7883a 	add	r3,r3,r3
81114010:	10c5883a 	add	r2,r2,r3
81114014:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81114018:	d0a06383 	ldbu	r2,-32370(gp)
8111401c:	10800044 	addi	r2,r2,1
81114020:	d0a06385 	stb	r2,-32370(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81114024:	d0a06a17 	ldw	r2,-32344(gp)
81114028:	1009883a 	mov	r4,r2
8111402c:	113a5800 	call	8113a580 <OSSemPost>
81114030:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81114034:	e0bfff83 	ldbu	r2,-2(fp)
81114038:	10803fcc 	andi	r2,r2,255
8111403c:	10000426 	beq	r2,zero,81114050 <vCheckRetransmission32+0x284>
                        SemCount32--;
81114040:	d0a06383 	ldbu	r2,-32370(gp)
81114044:	10bfffc4 	addi	r2,r2,-1
81114048:	d0a06385 	stb	r2,-32370(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8111404c:	111782c0 	call	8111782c <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81114050:	e0bfff03 	ldbu	r2,-4(fp)
81114054:	10800044 	addi	r2,r2,1
81114058:	e0bfff05 	stb	r2,-4(fp)
8111405c:	e0bfff03 	ldbu	r2,-4(fp)
81114060:	10800230 	cmpltui	r2,r2,8
81114064:	103f6c1e 	bne	r2,zero,81113e18 <__reset+0xfb0f3e18>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81114068:	d0a06717 	ldw	r2,-32356(gp)
8111406c:	1009883a 	mov	r4,r2
81114070:	11387900 	call	81138790 <OSMutexPost>

    return;
81114074:	0001883a 	nop
81114078:	00000106 	br	81114080 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8111407c:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81114080:	e037883a 	mov	sp,fp
81114084:	dfc00117 	ldw	ra,4(sp)
81114088:	df000017 	ldw	fp,0(sp)
8111408c:	dec00204 	addi	sp,sp,8
81114090:	f800283a 	ret

81114094 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81114094:	defff904 	addi	sp,sp,-28
81114098:	de00012e 	bgeu	sp,et,811140a0 <bResourcesInitRTOS+0xc>
8111409c:	003b68fa 	trap	3
811140a0:	dfc00615 	stw	ra,24(sp)
811140a4:	df000515 	stw	fp,20(sp)
811140a8:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
811140ac:	00800044 	movi	r2,1
811140b0:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
811140b4:	0009883a 	mov	r4,zero
811140b8:	1139ed00 	call	81139ed0 <OSSemCreate>
811140bc:	d0a05b15 	stw	r2,-32404(gp)
	if (!xSemCommInit) {
811140c0:	d0a05b17 	ldw	r2,-32404(gp)
811140c4:	1000021e 	bne	r2,zero,811140d0 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
811140c8:	11172c40 	call	811172c4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811140cc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
811140d0:	e0bfff04 	addi	r2,fp,-4
811140d4:	100b883a 	mov	r5,r2
811140d8:	01000444 	movi	r4,17
811140dc:	1137d180 	call	81137d18 <OSMutexCreate>
811140e0:	d0a06f15 	stw	r2,-32324(gp)
	if ( err != OS_ERR_NONE ) {
811140e4:	e0bfff03 	ldbu	r2,-4(fp)
811140e8:	10803fcc 	andi	r2,r2,255
811140ec:	10000526 	beq	r2,zero,81114104 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
811140f0:	e0bfff03 	ldbu	r2,-4(fp)
811140f4:	10803fcc 	andi	r2,r2,255
811140f8:	1009883a 	mov	r4,r2
811140fc:	11172180 	call	81117218 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114100:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81114104:	e0bfff04 	addi	r2,fp,-4
81114108:	100b883a 	mov	r5,r2
8111410c:	01000504 	movi	r4,20
81114110:	1137d180 	call	81137d18 <OSMutexCreate>
81114114:	d0a06915 	stw	r2,-32348(gp)
	if ( err != OS_ERR_NONE ) {
81114118:	e0bfff03 	ldbu	r2,-4(fp)
8111411c:	10803fcc 	andi	r2,r2,255
81114120:	10000526 	beq	r2,zero,81114138 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81114124:	e0bfff03 	ldbu	r2,-4(fp)
81114128:	10803fcc 	andi	r2,r2,255
8111412c:	1009883a 	mov	r4,r2
81114130:	11172180 	call	81117218 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114134:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81114138:	e0bfff04 	addi	r2,fp,-4
8111413c:	100b883a 	mov	r5,r2
81114140:	01000544 	movi	r4,21
81114144:	1137d180 	call	81137d18 <OSMutexCreate>
81114148:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
8111414c:	e0bfff03 	ldbu	r2,-4(fp)
81114150:	10803fcc 	andi	r2,r2,255
81114154:	10000526 	beq	r2,zero,8111416c <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81114158:	e0bfff03 	ldbu	r2,-4(fp)
8111415c:	10803fcc 	andi	r2,r2,255
81114160:	1009883a 	mov	r4,r2
81114164:	11172180 	call	81117218 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114168:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
8111416c:	e0bfff04 	addi	r2,fp,-4
81114170:	100b883a 	mov	r5,r2
81114174:	01000584 	movi	r4,22
81114178:	1137d180 	call	81137d18 <OSMutexCreate>
8111417c:	d0a06715 	stw	r2,-32356(gp)
	if ( err != OS_ERR_NONE ) {
81114180:	e0bfff03 	ldbu	r2,-4(fp)
81114184:	10803fcc 	andi	r2,r2,255
81114188:	10000526 	beq	r2,zero,811141a0 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
8111418c:	e0bfff03 	ldbu	r2,-4(fp)
81114190:	10803fcc 	andi	r2,r2,255
81114194:	1009883a 	mov	r4,r2
81114198:	11172180 	call	81117218 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111419c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
811141a0:	00800184 	movi	r2,6
811141a4:	d0a07045 	stb	r2,-32319(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
811141a8:	01000184 	movi	r4,6
811141ac:	1139ed00 	call	81139ed0 <OSSemCreate>
811141b0:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer128) {
811141b4:	d0a05e17 	ldw	r2,-32392(gp)
811141b8:	1000031e 	bne	r2,zero,811141c8 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
811141bc:	d0207045 	stb	zero,-32319(gp)
		vFailCreateSemaphoreResources();
811141c0:	11172c40 	call	811172c4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811141c4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
811141c8:	00800204 	movi	r2,8
811141cc:	d0a07005 	stb	r2,-32320(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
811141d0:	01000204 	movi	r4,8
811141d4:	1139ed00 	call	81139ed0 <OSSemCreate>
811141d8:	d0a05915 	stw	r2,-32412(gp)
	if (!xSemCountBuffer64) {
811141dc:	d0a05917 	ldw	r2,-32412(gp)
811141e0:	1000031e 	bne	r2,zero,811141f0 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
811141e4:	d0207005 	stb	zero,-32320(gp)
		vFailCreateSemaphoreResources();
811141e8:	11172c40 	call	811172c4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811141ec:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
811141f0:	00800204 	movi	r2,8
811141f4:	d0a06385 	stb	r2,-32370(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
811141f8:	01000204 	movi	r4,8
811141fc:	1139ed00 	call	81139ed0 <OSSemCreate>
81114200:	d0a06a15 	stw	r2,-32344(gp)
	if (!xSemCountBuffer32) {
81114204:	d0a06a17 	ldw	r2,-32344(gp)
81114208:	1000031e 	bne	r2,zero,81114218 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
8111420c:	d0206385 	stb	zero,-32370(gp)
		vFailCreateSemaphoreResources();
81114210:	11172c40 	call	811172c4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114214:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81114218:	e0bfff04 	addi	r2,fp,-4
8111421c:	100b883a 	mov	r5,r2
81114220:	010004c4 	movi	r4,19
81114224:	1137d180 	call	81137d18 <OSMutexCreate>
81114228:	d0a06015 	stw	r2,-32384(gp)
	if ( err != OS_ERR_NONE ) {
8111422c:	e0bfff03 	ldbu	r2,-4(fp)
81114230:	10803fcc 	andi	r2,r2,255
81114234:	10000526 	beq	r2,zero,8111424c <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81114238:	e0bfff03 	ldbu	r2,-4(fp)
8111423c:	10803fcc 	andi	r2,r2,255
81114240:	1009883a 	mov	r4,r2
81114244:	11172180 	call	81117218 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114248:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
8111424c:	e0bfff04 	addi	r2,fp,-4
81114250:	100b883a 	mov	r5,r2
81114254:	010005c4 	movi	r4,23
81114258:	1137d180 	call	81137d18 <OSMutexCreate>
8111425c:	d0a06615 	stw	r2,-32360(gp)
	if ( err != OS_ERR_NONE ) {
81114260:	e0bfff03 	ldbu	r2,-4(fp)
81114264:	10803fcc 	andi	r2,r2,255
81114268:	10000526 	beq	r2,zero,81114280 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
8111426c:	e0bfff03 	ldbu	r2,-4(fp)
81114270:	10803fcc 	andi	r2,r2,255
81114274:	1009883a 	mov	r4,r2
81114278:	11172180 	call	81117218 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111427c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81114280:	0009883a 	mov	r4,zero
81114284:	1139ed00 	call	81139ed0 <OSSemCreate>
81114288:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountReceivedACK) {
8111428c:	d0a06117 	ldw	r2,-32380(gp)
81114290:	1000021e 	bne	r2,zero,8111429c <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81114294:	11172c40 	call	811172c4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114298:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
8111429c:	0009883a 	mov	r4,zero
811142a0:	1139ed00 	call	81139ed0 <OSSemCreate>
811142a4:	d0a05f15 	stw	r2,-32388(gp)
	if (!xSemCountPreParsed) {
811142a8:	d0a05f17 	ldw	r2,-32388(gp)
811142ac:	1000021e 	bne	r2,zero,811142b8 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
811142b0:	11172c40 	call	811172c4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811142b4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
811142b8:	0009883a 	mov	r4,zero
811142bc:	1139ed00 	call	81139ed0 <OSSemCreate>
811142c0:	d0a05c15 	stw	r2,-32400(gp)
	if (!xSemCountSenderACK) {
811142c4:	d0a05c17 	ldw	r2,-32400(gp)
811142c8:	1000021e 	bne	r2,zero,811142d4 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
811142cc:	11172c40 	call	811172c4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811142d0:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
811142d4:	e0bfff04 	addi	r2,fp,-4
811142d8:	100b883a 	mov	r5,r2
811142dc:	01000484 	movi	r4,18
811142e0:	1137d180 	call	81137d18 <OSMutexCreate>
811142e4:	d0a06d15 	stw	r2,-32332(gp)
	if ( err != OS_ERR_NONE ) {
811142e8:	e0bfff03 	ldbu	r2,-4(fp)
811142ec:	10803fcc 	andi	r2,r2,255
811142f0:	10000526 	beq	r2,zero,81114308 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
811142f4:	e0bfff03 	ldbu	r2,-4(fp)
811142f8:	10803fcc 	andi	r2,r2,255
811142fc:	1009883a 	mov	r4,r2
81114300:	11172180 	call	81117218 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114304:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81114308:	0009883a 	mov	r4,zero
8111430c:	1139ed00 	call	81139ed0 <OSSemCreate>
81114310:	d0a06215 	stw	r2,-32376(gp)
	if (!xSemTimeoutChecker) {
81114314:	d0a06217 	ldw	r2,-32376(gp)
81114318:	1000021e 	bne	r2,zero,81114324 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
8111431c:	11172c40 	call	811172c4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114320:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81114324:	e0bfff04 	addi	r2,fp,-4
81114328:	d8800215 	stw	r2,8(sp)
8111432c:	00a04574 	movhi	r2,33045
81114330:	10a57d04 	addi	r2,r2,-27148
81114334:	d8800115 	stw	r2,4(sp)
81114338:	d8000015 	stw	zero,0(sp)
8111433c:	01e04474 	movhi	r7,33041
81114340:	39d7a704 	addi	r7,r7,24220
81114344:	01800084 	movi	r6,2
81114348:	01400104 	movi	r5,4
8111434c:	01000284 	movi	r4,10
81114350:	113c59c0 	call	8113c59c <OSTmrCreate>
81114354:	d0a06815 	stw	r2,-32352(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81114358:	e0bfff03 	ldbu	r2,-4(fp)
8111435c:	10803fcc 	andi	r2,r2,255
81114360:	10000226 	beq	r2,zero,8111436c <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81114364:	1117f280 	call	81117f28 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81114368:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
8111436c:	01400304 	movi	r5,12
81114370:	01204574 	movhi	r4,33045
81114374:	21071204 	addi	r4,r4,7240
81114378:	1138e040 	call	81138e04 <OSQCreate>
8111437c:	d0a05815 	stw	r2,-32416(gp)
	if ( xNfeeSchedule == NULL ) {
81114380:	d0a05817 	ldw	r2,-32416(gp)
81114384:	1000021e 	bne	r2,zero,81114390 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81114388:	111850c0 	call	8111850c <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
8111438c:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81114390:	01400104 	movi	r5,4
81114394:	012045b4 	movhi	r4,33046
81114398:	2105fd04 	addi	r4,r4,6132
8111439c:	1138e040 	call	81138e04 <OSQCreate>
811143a0:	d0a06515 	stw	r2,-32364(gp)
	if ( xFeeQ[0] == NULL ) {
811143a4:	d0a06517 	ldw	r2,-32364(gp)
811143a8:	1000031e 	bne	r2,zero,811143b8 <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
811143ac:	0009883a 	mov	r4,zero
811143b0:	11185740 	call	81118574 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811143b4:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
811143b8:	01400104 	movi	r5,4
811143bc:	012045b4 	movhi	r4,33046
811143c0:	212b4b04 	addi	r4,r4,-21204
811143c4:	1138e040 	call	81138e04 <OSQCreate>
811143c8:	d0a05715 	stw	r2,-32420(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
811143cc:	d0a05717 	ldw	r2,-32420(gp)
811143d0:	1000031e 	bne	r2,zero,811143e0 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
811143d4:	0009883a 	mov	r4,zero
811143d8:	11185e40 	call	811185e4 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
811143dc:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
811143e0:	01400204 	movi	r5,8
811143e4:	012045b4 	movhi	r4,33046
811143e8:	21265504 	addi	r4,r4,-26284
811143ec:	1138e040 	call	81138e04 <OSQCreate>
811143f0:	d0a06415 	stw	r2,-32368(gp)
	if ( xMebQ == NULL ) {
811143f4:	d0a06417 	ldw	r2,-32368(gp)
811143f8:	1000031e 	bne	r2,zero,81114408 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
811143fc:	01000144 	movi	r4,5
81114400:	11185740 	call	81118574 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81114404:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81114408:	e0bfff04 	addi	r2,fp,-4
8111440c:	100b883a 	mov	r5,r2
81114410:	010001c4 	movi	r4,7
81114414:	1137d180 	call	81137d18 <OSMutexCreate>
81114418:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
8111441c:	e0bfff03 	ldbu	r2,-4(fp)
81114420:	10803fcc 	andi	r2,r2,255
81114424:	10000526 	beq	r2,zero,8111443c <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81114428:	e0bfff03 	ldbu	r2,-4(fp)
8111442c:	10803fcc 	andi	r2,r2,255
81114430:	1009883a 	mov	r4,r2
81114434:	11189fc0 	call	811189fc <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81114438:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
8111443c:	01400404 	movi	r5,16
81114440:	012045b4 	movhi	r4,33046
81114444:	21272f04 	addi	r4,r4,-25412
81114448:	1138e040 	call	81138e04 <OSQCreate>
8111444c:	d0a06b15 	stw	r2,-32340(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81114450:	d0a06b17 	ldw	r2,-32340(gp)
81114454:	1000021e 	bne	r2,zero,81114460 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81114458:	1118b5c0 	call	81118b5c <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
8111445c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81114460:	01400404 	movi	r5,16
81114464:	01204574 	movhi	r4,33045
81114468:	211a2304 	addi	r4,r4,26764
8111446c:	1138e040 	call	81138e04 <OSQCreate>
81114470:	d0a05a15 	stw	r2,-32408(gp)
	if ( xQMaskDataCtrl == NULL ) {
81114474:	d0a05a17 	ldw	r2,-32408(gp)
81114478:	1000021e 	bne	r2,zero,81114484 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
8111447c:	1118bc40 	call	81118bc4 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81114480:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81114484:	e0bfff04 	addi	r2,fp,-4
81114488:	100b883a 	mov	r5,r2
8111448c:	01000104 	movi	r4,4
81114490:	1137d180 	call	81137d18 <OSMutexCreate>
81114494:	1007883a 	mov	r3,r2
81114498:	00a045b4 	movhi	r2,33046
8111449c:	10b95504 	addi	r2,r2,-6828
811144a0:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
811144a4:	e0bfff03 	ldbu	r2,-4(fp)
811144a8:	10803fcc 	andi	r2,r2,255
811144ac:	10000226 	beq	r2,zero,811144b8 <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
811144b0:	11172780 	call	81117278 <vFailCreateMutexDMA>
		bSuccess = FALSE;
811144b4:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
811144b8:	e0bfff04 	addi	r2,fp,-4
811144bc:	100b883a 	mov	r5,r2
811144c0:	01000184 	movi	r4,6
811144c4:	1137d180 	call	81137d18 <OSMutexCreate>
811144c8:	1007883a 	mov	r3,r2
811144cc:	00a045b4 	movhi	r2,33046
811144d0:	10b95504 	addi	r2,r2,-6828
811144d4:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
811144d8:	e0bfff03 	ldbu	r2,-4(fp)
811144dc:	10803fcc 	andi	r2,r2,255
811144e0:	10000226 	beq	r2,zero,811144ec <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
811144e4:	11172780 	call	81117278 <vFailCreateMutexDMA>
		bSuccess = FALSE;
811144e8:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
811144ec:	e0bffe17 	ldw	r2,-8(fp)
}
811144f0:	e037883a 	mov	sp,fp
811144f4:	dfc00117 	ldw	ra,4(sp)
811144f8:	df000017 	ldw	fp,0(sp)
811144fc:	dec00204 	addi	sp,sp,8
81114500:	f800283a 	ret

81114504 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81114504:	defffd04 	addi	sp,sp,-12
81114508:	de00012e 	bgeu	sp,et,81114510 <vVariablesInitialization+0xc>
8111450c:	003b68fa 	trap	3
81114510:	dfc00215 	stw	ra,8(sp)
81114514:	df000115 	stw	fp,4(sp)
81114518:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
8111451c:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
81114520:	00800084 	movi	r2,2
81114524:	d0a0630d 	sth	r2,-32372(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81114528:	01800604 	movi	r6,24
8111452c:	000b883a 	mov	r5,zero
81114530:	012045b4 	movhi	r4,33046
81114534:	21263f04 	addi	r4,r4,-26372
81114538:	111d31c0 	call	8111d31c <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
8111453c:	01800804 	movi	r6,32
81114540:	000b883a 	mov	r5,zero
81114544:	012045b4 	movhi	r4,33046
81114548:	21264504 	addi	r4,r4,-26348
8111454c:	111d31c0 	call	8111d31c <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81114550:	01800804 	movi	r6,32
81114554:	000b883a 	mov	r5,zero
81114558:	012045b4 	movhi	r4,33046
8111455c:	21264d04 	addi	r4,r4,-26316
81114560:	111d31c0 	call	8111d31c <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81114564:	e03fff05 	stb	zero,-4(fp)
81114568:	00002806 	br	8111460c <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
8111456c:	e0bfff03 	ldbu	r2,-4(fp)
81114570:	10c02324 	muli	r3,r2,140
81114574:	00a045b4 	movhi	r2,33046
81114578:	10a65d04 	addi	r2,r2,-26252
8111457c:	1885883a 	add	r2,r3,r2
81114580:	01802004 	movi	r6,128
81114584:	000b883a 	mov	r5,zero
81114588:	1009883a 	mov	r4,r2
8111458c:	111d31c0 	call	8111d31c <memset>
		xBuffer128[ucIL].bSent = FALSE;
81114590:	e0ffff03 	ldbu	r3,-4(fp)
81114594:	00a045b4 	movhi	r2,33046
81114598:	10a65d04 	addi	r2,r2,-26252
8111459c:	18c02324 	muli	r3,r3,140
811145a0:	10c5883a 	add	r2,r2,r3
811145a4:	10802004 	addi	r2,r2,128
811145a8:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
811145ac:	e0ffff03 	ldbu	r3,-4(fp)
811145b0:	00a045b4 	movhi	r2,33046
811145b4:	10a65d04 	addi	r2,r2,-26252
811145b8:	18c02324 	muli	r3,r3,140
811145bc:	10c5883a 	add	r2,r2,r3
811145c0:	10802104 	addi	r2,r2,132
811145c4:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
811145c8:	e0ffff03 	ldbu	r3,-4(fp)
811145cc:	00a045b4 	movhi	r2,33046
811145d0:	10a65d04 	addi	r2,r2,-26252
811145d4:	18c02324 	muli	r3,r3,140
811145d8:	10c5883a 	add	r2,r2,r3
811145dc:	10802184 	addi	r2,r2,134
811145e0:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
811145e4:	e0ffff03 	ldbu	r3,-4(fp)
811145e8:	00a045b4 	movhi	r2,33046
811145ec:	10a65d04 	addi	r2,r2,-26252
811145f0:	18c02324 	muli	r3,r3,140
811145f4:	10c5883a 	add	r2,r2,r3
811145f8:	10802204 	addi	r2,r2,136
811145fc:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81114600:	e0bfff03 	ldbu	r2,-4(fp)
81114604:	10800044 	addi	r2,r2,1
81114608:	e0bfff05 	stb	r2,-4(fp)
8111460c:	e0bfff03 	ldbu	r2,-4(fp)
81114610:	108001b0 	cmpltui	r2,r2,6
81114614:	103fd51e 	bne	r2,zero,8111456c <__reset+0xfb0f456c>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81114618:	e03fff05 	stb	zero,-4(fp)
8111461c:	00002806 	br	811146c0 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
81114620:	e0bfff03 	ldbu	r2,-4(fp)
81114624:	10c01324 	muli	r3,r2,76
81114628:	00a04574 	movhi	r2,33045
8111462c:	10821e04 	addi	r2,r2,2168
81114630:	1885883a 	add	r2,r3,r2
81114634:	01801004 	movi	r6,64
81114638:	000b883a 	mov	r5,zero
8111463c:	1009883a 	mov	r4,r2
81114640:	111d31c0 	call	8111d31c <memset>
		xBuffer64[ucIL].bSent = FALSE;
81114644:	e0ffff03 	ldbu	r3,-4(fp)
81114648:	00a04574 	movhi	r2,33045
8111464c:	10821e04 	addi	r2,r2,2168
81114650:	18c01324 	muli	r3,r3,76
81114654:	10c5883a 	add	r2,r2,r3
81114658:	10801004 	addi	r2,r2,64
8111465c:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81114660:	e0ffff03 	ldbu	r3,-4(fp)
81114664:	00a04574 	movhi	r2,33045
81114668:	10821e04 	addi	r2,r2,2168
8111466c:	18c01324 	muli	r3,r3,76
81114670:	10c5883a 	add	r2,r2,r3
81114674:	10801104 	addi	r2,r2,68
81114678:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
8111467c:	e0ffff03 	ldbu	r3,-4(fp)
81114680:	00a04574 	movhi	r2,33045
81114684:	10821e04 	addi	r2,r2,2168
81114688:	18c01324 	muli	r3,r3,76
8111468c:	10c5883a 	add	r2,r2,r3
81114690:	10801184 	addi	r2,r2,70
81114694:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81114698:	e0ffff03 	ldbu	r3,-4(fp)
8111469c:	00a04574 	movhi	r2,33045
811146a0:	10821e04 	addi	r2,r2,2168
811146a4:	18c01324 	muli	r3,r3,76
811146a8:	10c5883a 	add	r2,r2,r3
811146ac:	10801204 	addi	r2,r2,72
811146b0:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811146b4:	e0bfff03 	ldbu	r2,-4(fp)
811146b8:	10800044 	addi	r2,r2,1
811146bc:	e0bfff05 	stb	r2,-4(fp)
811146c0:	e0bfff03 	ldbu	r2,-4(fp)
811146c4:	10800230 	cmpltui	r2,r2,8
811146c8:	103fd51e 	bne	r2,zero,81114620 <__reset+0xfb0f4620>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811146cc:	e03fff05 	stb	zero,-4(fp)
811146d0:	00002806 	br	81114774 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
811146d4:	e0bfff03 	ldbu	r2,-4(fp)
811146d8:	10c00b24 	muli	r3,r2,44
811146dc:	00a04574 	movhi	r2,33045
811146e0:	1093cb04 	addi	r2,r2,20268
811146e4:	1885883a 	add	r2,r3,r2
811146e8:	01800804 	movi	r6,32
811146ec:	000b883a 	mov	r5,zero
811146f0:	1009883a 	mov	r4,r2
811146f4:	111d31c0 	call	8111d31c <memset>
		xBuffer32[ucIL].bSent = FALSE;
811146f8:	e0ffff03 	ldbu	r3,-4(fp)
811146fc:	00a04574 	movhi	r2,33045
81114700:	1093cb04 	addi	r2,r2,20268
81114704:	18c00b24 	muli	r3,r3,44
81114708:	10c5883a 	add	r2,r2,r3
8111470c:	10800804 	addi	r2,r2,32
81114710:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81114714:	e0ffff03 	ldbu	r3,-4(fp)
81114718:	00a04574 	movhi	r2,33045
8111471c:	1093cb04 	addi	r2,r2,20268
81114720:	18c00b24 	muli	r3,r3,44
81114724:	10c5883a 	add	r2,r2,r3
81114728:	10800904 	addi	r2,r2,36
8111472c:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81114730:	e0ffff03 	ldbu	r3,-4(fp)
81114734:	00a04574 	movhi	r2,33045
81114738:	1093cb04 	addi	r2,r2,20268
8111473c:	18c00b24 	muli	r3,r3,44
81114740:	10c5883a 	add	r2,r2,r3
81114744:	10800984 	addi	r2,r2,38
81114748:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
8111474c:	e0ffff03 	ldbu	r3,-4(fp)
81114750:	00a04574 	movhi	r2,33045
81114754:	1093cb04 	addi	r2,r2,20268
81114758:	18c00b24 	muli	r3,r3,44
8111475c:	10c5883a 	add	r2,r2,r3
81114760:	10800a04 	addi	r2,r2,40
81114764:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81114768:	e0bfff03 	ldbu	r2,-4(fp)
8111476c:	10800044 	addi	r2,r2,1
81114770:	e0bfff05 	stb	r2,-4(fp)
81114774:	e0bfff03 	ldbu	r2,-4(fp)
81114778:	10800230 	cmpltui	r2,r2,8
8111477c:	103fd51e 	bne	r2,zero,811146d4 <__reset+0xfb0f46d4>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81114780:	e03fff05 	stb	zero,-4(fp)
81114784:	00001b06 	br	811147f4 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81114788:	e0ffff03 	ldbu	r3,-4(fp)
8111478c:	00a04574 	movhi	r2,33045
81114790:	1082b604 	addi	r2,r2,2776
81114794:	18c01524 	muli	r3,r3,84
81114798:	10c5883a 	add	r2,r2,r3
8111479c:	10800104 	addi	r2,r2,4
811147a0:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
811147a4:	e0ffff03 	ldbu	r3,-4(fp)
811147a8:	00a04574 	movhi	r2,33045
811147ac:	1082b604 	addi	r2,r2,2776
811147b0:	18c01524 	muli	r3,r3,84
811147b4:	10c5883a 	add	r2,r2,r3
811147b8:	10800484 	addi	r2,r2,18
811147bc:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
811147c0:	e0bfff03 	ldbu	r2,-4(fp)
811147c4:	10801524 	muli	r2,r2,84
811147c8:	10c00504 	addi	r3,r2,20
811147cc:	00a04574 	movhi	r2,33045
811147d0:	1082b604 	addi	r2,r2,2776
811147d4:	1885883a 	add	r2,r3,r2
811147d8:	01801004 	movi	r6,64
811147dc:	000b883a 	mov	r5,zero
811147e0:	1009883a 	mov	r4,r2
811147e4:	111d31c0 	call	8111d31c <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811147e8:	e0bfff03 	ldbu	r2,-4(fp)
811147ec:	10800044 	addi	r2,r2,1
811147f0:	e0bfff05 	stb	r2,-4(fp)
811147f4:	e0bfff03 	ldbu	r2,-4(fp)
811147f8:	10800130 	cmpltui	r2,r2,4
811147fc:	103fe21e 	bne	r2,zero,81114788 <__reset+0xfb0f4788>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81114800:	0001883a 	nop
81114804:	e037883a 	mov	sp,fp
81114808:	dfc00117 	ldw	ra,4(sp)
8111480c:	df000017 	ldw	fp,0(sp)
81114810:	dec00204 	addi	sp,sp,8
81114814:	f800283a 	ret

81114818 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81114818:	defff704 	addi	sp,sp,-36
8111481c:	de00012e 	bgeu	sp,et,81114824 <main+0xc>
81114820:	003b68fa 	trap	3
81114824:	dfc00815 	stw	ra,32(sp)
81114828:	df000715 	stw	fp,28(sp)
8111482c:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81114830:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81114834:	11341b40 	call	811341b4 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81114838:	01604574 	movhi	r5,33045
8111483c:	29658104 	addi	r5,r5,-27132
81114840:	01204574 	movhi	r4,33045
81114844:	21258204 	addi	r4,r4,-27128
81114848:	111c0d40 	call	8111c0d4 <fopen>
8111484c:	d0a05d15 	stw	r2,-32396(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
81114850:	d0a05d17 	ldw	r2,-32396(gp)
81114854:	100f883a 	mov	r7,r2
81114858:	01800484 	movi	r6,18
8111485c:	01400044 	movi	r5,1
81114860:	01204574 	movhi	r4,33045
81114864:	21258704 	addi	r4,r4,-27108
81114868:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
8111486c:	11199e80 	call	811199e8 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81114870:	111a6280 	call	8111a628 <bTestSimucamCriticalHW>
81114874:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81114878:	e0bffe17 	ldw	r2,-8(fp)
8111487c:	1000031e 	bne	r2,zero,8111488c <main+0x74>
		vFailTestCriticasParts();
81114880:	11173100 	call	81117310 <vFailTestCriticasParts>
		return -1;
81114884:	00bfffc4 	movi	r2,-1
81114888:	00004106 	br	81114990 <main+0x178>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
8111488c:	111a1680 	call	8111a168 <bInitializeSDCard>
81114890:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81114894:	e0bffe17 	ldw	r2,-8(fp)
81114898:	1000031e 	bne	r2,zero,811148a8 <main+0x90>
		vFailTestCriticasParts();
8111489c:	11173100 	call	81117310 <vFailTestCriticasParts>
		return -1;
811148a0:	00bfffc4 	movi	r2,-1
811148a4:	00003a06 	br	81114990 <main+0x178>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
811148a8:	11162c40 	call	811162c4 <vLoadDefaultETHConf>
811148ac:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811148b0:	e0bffe17 	ldw	r2,-8(fp)
811148b4:	1000091e 	bne	r2,zero,811148dc <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
811148b8:	d0a05d17 	ldw	r2,-32396(gp)
811148bc:	100f883a 	mov	r7,r2
811148c0:	01801644 	movi	r6,89
811148c4:	01400044 	movi	r5,1
811148c8:	01204574 	movhi	r4,33045
811148cc:	21258c04 	addi	r4,r4,-27088
811148d0:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return -1;
811148d4:	00bfffc4 	movi	r2,-1
811148d8:	00002d06 	br	81114990 <main+0x178>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
811148dc:	1116c980 	call	81116c98 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
811148e0:	11140940 	call	81114094 <bResourcesInitRTOS>
811148e4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811148e8:	e0bffe17 	ldw	r2,-8(fp)
811148ec:	1000091e 	bne	r2,zero,81114914 <main+0xfc>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
811148f0:	d0a05d17 	ldw	r2,-32396(gp)
811148f4:	100f883a 	mov	r7,r2
811148f8:	01800ac4 	movi	r6,43
811148fc:	01400044 	movi	r5,1
81114900:	01204574 	movhi	r4,33045
81114904:	2125a304 	addi	r4,r4,-26996
81114908:	111c7b80 	call	8111c7b8 <fwrite>
		return -1;
8111490c:	00bfffc4 	movi	r2,-1
81114910:	00001f06 	br	81114990 <main+0x178>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81114914:	01204574 	movhi	r4,33045
81114918:	210f1e04 	addi	r4,r4,15480
8111491c:	1119b280 	call	81119b28 <vSimucamStructureInit>

	vVariablesInitialization();
81114920:	11145040 	call	81114504 <vVariablesInitialization>

	bInitSync();
81114924:	111a31c0 	call	8111a31c <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81114928:	01204574 	movhi	r4,33045
8111492c:	210f1e04 	addi	r4,r4,15480
81114930:	11149a40 	call	811149a4 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81114934:	d8000415 	stw	zero,16(sp)
81114938:	d8000315 	stw	zero,12(sp)
8111493c:	00810004 	movi	r2,1024
81114940:	d8800215 	stw	r2,8(sp)
81114944:	00a04574 	movhi	r2,33045
81114948:	109e3b04 	addi	r2,r2,30956
8111494c:	d8800115 	stw	r2,4(sp)
81114950:	00800044 	movi	r2,1
81114954:	d8800015 	stw	r2,0(sp)
81114958:	01c00044 	movi	r7,1
8111495c:	01a045b4 	movhi	r6,33046
81114960:	31a23a04 	addi	r6,r6,-30488
81114964:	000b883a 	mov	r5,zero
81114968:	01204474 	movhi	r4,33041
8111496c:	213c4604 	addi	r4,r4,-3816
81114970:	113af640 	call	8113af64 <OSTaskCreateExt>
81114974:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81114978:	e0bfff03 	ldbu	r2,-4(fp)
8111497c:	1000021e 	bne	r2,zero,81114988 <main+0x170>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81114980:	11344e40 	call	811344e4 <OSStart>
81114984:	00000106 	br	8111498c <main+0x174>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81114988:	11176fc0 	call	811176fc <vFailInitialization>
	}
  
	return 0;
8111498c:	0005883a 	mov	r2,zero
}
81114990:	e037883a 	mov	sp,fp
81114994:	dfc00117 	ldw	ra,4(sp)
81114998:	df000017 	ldw	fp,0(sp)
8111499c:	dec00204 	addi	sp,sp,8
811149a0:	f800283a 	ret

811149a4 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
811149a4:	defff604 	addi	sp,sp,-40
811149a8:	de00012e 	bgeu	sp,et,811149b0 <vFillMemmoryPattern+0xc>
811149ac:	003b68fa 	trap	3
811149b0:	dfc00915 	stw	ra,36(sp)
811149b4:	df000815 	stw	fp,32(sp)
811149b8:	df000804 	addi	fp,sp,32
811149bc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
811149c0:	00800044 	movi	r2,1
811149c4:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
811149c8:	d0a05d17 	ldw	r2,-32396(gp)
811149cc:	100f883a 	mov	r7,r2
811149d0:	018009c4 	movi	r6,39
811149d4:	01400044 	movi	r5,1
811149d8:	01204574 	movhi	r4,33045
811149dc:	2125ae04 	addi	r4,r4,-26952
811149e0:	111c7b80 	call	8111c7b8 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811149e4:	e03ffa05 	stb	zero,-24(fp)
811149e8:	00007606 	br	81114bc4 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811149ec:	e03ffc85 	stb	zero,-14(fp)
811149f0:	00006706 	br	81114b90 <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
811149f4:	e0bffc83 	ldbu	r2,-14(fp)
811149f8:	e0ffff17 	ldw	r3,-4(fp)
811149fc:	10809524 	muli	r2,r2,596
81114a00:	1885883a 	add	r2,r3,r2
81114a04:	10804304 	addi	r2,r2,268
81114a08:	1080000b 	ldhu	r2,0(r2)
81114a0c:	10ffffcc 	andi	r3,r2,65535
81114a10:	e0bffc83 	ldbu	r2,-14(fp)
81114a14:	e13fff17 	ldw	r4,-4(fp)
81114a18:	10809524 	muli	r2,r2,596
81114a1c:	2085883a 	add	r2,r4,r2
81114a20:	10804204 	addi	r2,r2,264
81114a24:	1080000b 	ldhu	r2,0(r2)
81114a28:	10bfffcc 	andi	r2,r2,65535
81114a2c:	1885883a 	add	r2,r3,r2
81114a30:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81114a34:	e0bffc83 	ldbu	r2,-14(fp)
81114a38:	e0ffff17 	ldw	r3,-4(fp)
81114a3c:	10809524 	muli	r2,r2,596
81114a40:	1885883a 	add	r2,r3,r2
81114a44:	10804284 	addi	r2,r2,266
81114a48:	1080000b 	ldhu	r2,0(r2)
81114a4c:	10ffffcc 	andi	r3,r2,65535
81114a50:	e0bffc83 	ldbu	r2,-14(fp)
81114a54:	e13fff17 	ldw	r4,-4(fp)
81114a58:	10809524 	muli	r2,r2,596
81114a5c:	2085883a 	add	r2,r4,r2
81114a60:	10804184 	addi	r2,r2,262
81114a64:	1080000b 	ldhu	r2,0(r2)
81114a68:	10bfffcc 	andi	r2,r2,65535
81114a6c:	1887883a 	add	r3,r3,r2
81114a70:	e0bffc83 	ldbu	r2,-14(fp)
81114a74:	e13fff17 	ldw	r4,-4(fp)
81114a78:	10809524 	muli	r2,r2,596
81114a7c:	2085883a 	add	r2,r4,r2
81114a80:	10804104 	addi	r2,r2,260
81114a84:	1080000b 	ldhu	r2,0(r2)
81114a88:	10bfffcc 	andi	r2,r2,65535
81114a8c:	1885883a 	add	r2,r3,r2
81114a90:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81114a94:	e03ffc05 	stb	zero,-16(fp)
81114a98:	00003706 	br	81114b78 <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81114a9c:	e03ffc45 	stb	zero,-15(fp)
81114aa0:	00002606 	br	81114b3c <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
81114aa4:	e0bffc43 	ldbu	r2,-15(fp)
81114aa8:	10000b1e 	bne	r2,zero,81114ad8 <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81114aac:	e0bffc83 	ldbu	r2,-14(fp)
81114ab0:	e13ffc03 	ldbu	r4,-16(fp)
81114ab4:	e0ffff17 	ldw	r3,-4(fp)
81114ab8:	21000624 	muli	r4,r4,24
81114abc:	10809524 	muli	r2,r2,596
81114ac0:	2085883a 	add	r2,r4,r2
81114ac4:	1885883a 	add	r2,r3,r2
81114ac8:	10801b04 	addi	r2,r2,108
81114acc:	10800017 	ldw	r2,0(r2)
81114ad0:	e0bffb15 	stw	r2,-20(fp)
81114ad4:	00000a06 	br	81114b00 <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81114ad8:	e0bffc83 	ldbu	r2,-14(fp)
81114adc:	e13ffc03 	ldbu	r4,-16(fp)
81114ae0:	e0ffff17 	ldw	r3,-4(fp)
81114ae4:	21000624 	muli	r4,r4,24
81114ae8:	10809524 	muli	r2,r2,596
81114aec:	2085883a 	add	r2,r4,r2
81114af0:	1885883a 	add	r2,r3,r2
81114af4:	10801e04 	addi	r2,r2,120
81114af8:	10800017 	ldw	r2,0(r2)
81114afc:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81114b00:	e0fffa03 	ldbu	r3,-24(fp)
81114b04:	e13ffc03 	ldbu	r4,-16(fp)
81114b08:	e17ffc43 	ldbu	r5,-15(fp)
81114b0c:	e0bffd17 	ldw	r2,-12(fp)
81114b10:	d8800115 	stw	r2,4(sp)
81114b14:	e0bffe17 	ldw	r2,-8(fp)
81114b18:	d8800015 	stw	r2,0(sp)
81114b1c:	280f883a 	mov	r7,r5
81114b20:	200d883a 	mov	r6,r4
81114b24:	e17ffb17 	ldw	r5,-20(fp)
81114b28:	1809883a 	mov	r4,r3
81114b2c:	1119eec0 	call	81119eec <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81114b30:	e0bffc43 	ldbu	r2,-15(fp)
81114b34:	10800044 	addi	r2,r2,1
81114b38:	e0bffc45 	stb	r2,-15(fp)
81114b3c:	e0bffc43 	ldbu	r2,-15(fp)
81114b40:	108000b0 	cmpltui	r2,r2,2
81114b44:	103fd71e 	bne	r2,zero,81114aa4 <__reset+0xfb0f4aa4>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81114b48:	d0a05d17 	ldw	r2,-32396(gp)
81114b4c:	e0fffc83 	ldbu	r3,-14(fp)
81114b50:	e13ffc03 	ldbu	r4,-16(fp)
81114b54:	200f883a 	mov	r7,r4
81114b58:	180d883a 	mov	r6,r3
81114b5c:	01604574 	movhi	r5,33045
81114b60:	2965b804 	addi	r5,r5,-26912
81114b64:	1009883a 	mov	r4,r2
81114b68:	111c11c0 	call	8111c11c <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81114b6c:	e0bffc03 	ldbu	r2,-16(fp)
81114b70:	10800044 	addi	r2,r2,1
81114b74:	e0bffc05 	stb	r2,-16(fp)
81114b78:	e0bffc03 	ldbu	r2,-16(fp)
81114b7c:	10800130 	cmpltui	r2,r2,4
81114b80:	103fc61e 	bne	r2,zero,81114a9c <__reset+0xfb0f4a9c>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81114b84:	e0bffc83 	ldbu	r2,-14(fp)
81114b88:	10800044 	addi	r2,r2,1
81114b8c:	e0bffc85 	stb	r2,-14(fp)
81114b90:	e0fffc83 	ldbu	r3,-14(fp)
81114b94:	e0bffcc3 	ldbu	r2,-13(fp)
81114b98:	18bf9636 	bltu	r3,r2,811149f4 <__reset+0xfb0f49f4>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81114b9c:	d0a05d17 	ldw	r2,-32396(gp)
81114ba0:	e0fffa03 	ldbu	r3,-24(fp)
81114ba4:	180d883a 	mov	r6,r3
81114ba8:	01604574 	movhi	r5,33045
81114bac:	2965bd04 	addi	r5,r5,-26892
81114bb0:	1009883a 	mov	r4,r2
81114bb4:	111c11c0 	call	8111c11c <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81114bb8:	e0bffa03 	ldbu	r2,-24(fp)
81114bbc:	10800044 	addi	r2,r2,1
81114bc0:	e0bffa05 	stb	r2,-24(fp)
81114bc4:	e0bffa03 	ldbu	r2,-24(fp)
81114bc8:	108000b0 	cmpltui	r2,r2,2
81114bcc:	103f871e 	bne	r2,zero,811149ec <__reset+0xfb0f49ec>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81114bd0:	d0a05d17 	ldw	r2,-32396(gp)
81114bd4:	100f883a 	mov	r7,r2
81114bd8:	01800404 	movi	r6,16
81114bdc:	01400044 	movi	r5,1
81114be0:	01204574 	movhi	r4,33045
81114be4:	2125c104 	addi	r4,r4,-26876
81114be8:	111c7b80 	call	8111c7b8 <fwrite>
#endif


}
81114bec:	0001883a 	nop
81114bf0:	e037883a 	mov	sp,fp
81114bf4:	dfc00117 	ldw	ra,4(sp)
81114bf8:	df000017 	ldw	fp,0(sp)
81114bfc:	dec00204 	addi	sp,sp,8
81114c00:	f800283a 	ret

81114c04 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81114c04:	defff604 	addi	sp,sp,-40
81114c08:	de00012e 	bgeu	sp,et,81114c10 <vPrintMemmoryPattern+0xc>
81114c0c:	003b68fa 	trap	3
81114c10:	dfc00915 	stw	ra,36(sp)
81114c14:	df000815 	stw	fp,32(sp)
81114c18:	df000804 	addi	fp,sp,32
81114c1c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81114c20:	00800044 	movi	r2,1
81114c24:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81114c28:	d0a05d17 	ldw	r2,-32396(gp)
81114c2c:	100f883a 	mov	r7,r2
81114c30:	018009c4 	movi	r6,39
81114c34:	01400044 	movi	r5,1
81114c38:	01204574 	movhi	r4,33045
81114c3c:	2125ae04 	addi	r4,r4,-26952
81114c40:	111c7b80 	call	8111c7b8 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81114c44:	e03ffa05 	stb	zero,-24(fp)
81114c48:	00007606 	br	81114e24 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81114c4c:	e03ffc85 	stb	zero,-14(fp)
81114c50:	00006706 	br	81114df0 <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81114c54:	e0bffc83 	ldbu	r2,-14(fp)
81114c58:	e0ffff17 	ldw	r3,-4(fp)
81114c5c:	10809524 	muli	r2,r2,596
81114c60:	1885883a 	add	r2,r3,r2
81114c64:	10804304 	addi	r2,r2,268
81114c68:	1080000b 	ldhu	r2,0(r2)
81114c6c:	10ffffcc 	andi	r3,r2,65535
81114c70:	e0bffc83 	ldbu	r2,-14(fp)
81114c74:	e13fff17 	ldw	r4,-4(fp)
81114c78:	10809524 	muli	r2,r2,596
81114c7c:	2085883a 	add	r2,r4,r2
81114c80:	10804204 	addi	r2,r2,264
81114c84:	1080000b 	ldhu	r2,0(r2)
81114c88:	10bfffcc 	andi	r2,r2,65535
81114c8c:	1885883a 	add	r2,r3,r2
81114c90:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81114c94:	e0bffc83 	ldbu	r2,-14(fp)
81114c98:	e0ffff17 	ldw	r3,-4(fp)
81114c9c:	10809524 	muli	r2,r2,596
81114ca0:	1885883a 	add	r2,r3,r2
81114ca4:	10804284 	addi	r2,r2,266
81114ca8:	1080000b 	ldhu	r2,0(r2)
81114cac:	10ffffcc 	andi	r3,r2,65535
81114cb0:	e0bffc83 	ldbu	r2,-14(fp)
81114cb4:	e13fff17 	ldw	r4,-4(fp)
81114cb8:	10809524 	muli	r2,r2,596
81114cbc:	2085883a 	add	r2,r4,r2
81114cc0:	10804184 	addi	r2,r2,262
81114cc4:	1080000b 	ldhu	r2,0(r2)
81114cc8:	10bfffcc 	andi	r2,r2,65535
81114ccc:	1887883a 	add	r3,r3,r2
81114cd0:	e0bffc83 	ldbu	r2,-14(fp)
81114cd4:	e13fff17 	ldw	r4,-4(fp)
81114cd8:	10809524 	muli	r2,r2,596
81114cdc:	2085883a 	add	r2,r4,r2
81114ce0:	10804104 	addi	r2,r2,260
81114ce4:	1080000b 	ldhu	r2,0(r2)
81114ce8:	10bfffcc 	andi	r2,r2,65535
81114cec:	1885883a 	add	r2,r3,r2
81114cf0:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81114cf4:	e03ffc05 	stb	zero,-16(fp)
81114cf8:	00003706 	br	81114dd8 <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81114cfc:	e03ffc45 	stb	zero,-15(fp)
81114d00:	00002606 	br	81114d9c <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
81114d04:	e0bffc43 	ldbu	r2,-15(fp)
81114d08:	10000b1e 	bne	r2,zero,81114d38 <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81114d0c:	e0bffc83 	ldbu	r2,-14(fp)
81114d10:	e13ffc03 	ldbu	r4,-16(fp)
81114d14:	e0ffff17 	ldw	r3,-4(fp)
81114d18:	21000624 	muli	r4,r4,24
81114d1c:	10809524 	muli	r2,r2,596
81114d20:	2085883a 	add	r2,r4,r2
81114d24:	1885883a 	add	r2,r3,r2
81114d28:	10801b04 	addi	r2,r2,108
81114d2c:	10800017 	ldw	r2,0(r2)
81114d30:	e0bffb15 	stw	r2,-20(fp)
81114d34:	00000a06 	br	81114d60 <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81114d38:	e0bffc83 	ldbu	r2,-14(fp)
81114d3c:	e13ffc03 	ldbu	r4,-16(fp)
81114d40:	e0ffff17 	ldw	r3,-4(fp)
81114d44:	21000624 	muli	r4,r4,24
81114d48:	10809524 	muli	r2,r2,596
81114d4c:	2085883a 	add	r2,r4,r2
81114d50:	1885883a 	add	r2,r3,r2
81114d54:	10801e04 	addi	r2,r2,120
81114d58:	10800017 	ldw	r2,0(r2)
81114d5c:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81114d60:	e0fffa03 	ldbu	r3,-24(fp)
81114d64:	e13ffc03 	ldbu	r4,-16(fp)
81114d68:	e17ffc43 	ldbu	r5,-15(fp)
81114d6c:	e0bffe17 	ldw	r2,-8(fp)
81114d70:	d8800115 	stw	r2,4(sp)
81114d74:	e0bffd17 	ldw	r2,-12(fp)
81114d78:	d8800015 	stw	r2,0(sp)
81114d7c:	280f883a 	mov	r7,r5
81114d80:	200d883a 	mov	r6,r4
81114d84:	e17ffb17 	ldw	r5,-20(fp)
81114d88:	1809883a 	mov	r4,r3
81114d8c:	1119eec0 	call	81119eec <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81114d90:	e0bffc43 	ldbu	r2,-15(fp)
81114d94:	10800044 	addi	r2,r2,1
81114d98:	e0bffc45 	stb	r2,-15(fp)
81114d9c:	e0bffc43 	ldbu	r2,-15(fp)
81114da0:	108000b0 	cmpltui	r2,r2,2
81114da4:	103fd71e 	bne	r2,zero,81114d04 <__reset+0xfb0f4d04>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81114da8:	d0a05d17 	ldw	r2,-32396(gp)
81114dac:	e0fffc83 	ldbu	r3,-14(fp)
81114db0:	e13ffc03 	ldbu	r4,-16(fp)
81114db4:	200f883a 	mov	r7,r4
81114db8:	180d883a 	mov	r6,r3
81114dbc:	01604574 	movhi	r5,33045
81114dc0:	2965b804 	addi	r5,r5,-26912
81114dc4:	1009883a 	mov	r4,r2
81114dc8:	111c11c0 	call	8111c11c <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81114dcc:	e0bffc03 	ldbu	r2,-16(fp)
81114dd0:	10800044 	addi	r2,r2,1
81114dd4:	e0bffc05 	stb	r2,-16(fp)
81114dd8:	e0bffc03 	ldbu	r2,-16(fp)
81114ddc:	10800130 	cmpltui	r2,r2,4
81114de0:	103fc61e 	bne	r2,zero,81114cfc <__reset+0xfb0f4cfc>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81114de4:	e0bffc83 	ldbu	r2,-14(fp)
81114de8:	10800044 	addi	r2,r2,1
81114dec:	e0bffc85 	stb	r2,-14(fp)
81114df0:	e0fffc83 	ldbu	r3,-14(fp)
81114df4:	e0bffcc3 	ldbu	r2,-13(fp)
81114df8:	18bf9636 	bltu	r3,r2,81114c54 <__reset+0xfb0f4c54>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81114dfc:	d0a05d17 	ldw	r2,-32396(gp)
81114e00:	e0fffa03 	ldbu	r3,-24(fp)
81114e04:	180d883a 	mov	r6,r3
81114e08:	01604574 	movhi	r5,33045
81114e0c:	2965bd04 	addi	r5,r5,-26892
81114e10:	1009883a 	mov	r4,r2
81114e14:	111c11c0 	call	8111c11c <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81114e18:	e0bffa03 	ldbu	r2,-24(fp)
81114e1c:	10800044 	addi	r2,r2,1
81114e20:	e0bffa05 	stb	r2,-24(fp)
81114e24:	e0bffa03 	ldbu	r2,-24(fp)
81114e28:	108000b0 	cmpltui	r2,r2,2
81114e2c:	103f871e 	bne	r2,zero,81114c4c <__reset+0xfb0f4c4c>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81114e30:	d0a05d17 	ldw	r2,-32396(gp)
81114e34:	100f883a 	mov	r7,r2
81114e38:	01800404 	movi	r6,16
81114e3c:	01400044 	movi	r5,1
81114e40:	01204574 	movhi	r4,33045
81114e44:	2125c104 	addi	r4,r4,-26876
81114e48:	111c7b80 	call	8111c7b8 <fwrite>
#endif


}
81114e4c:	0001883a 	nop
81114e50:	e037883a 	mov	sp,fp
81114e54:	dfc00117 	ldw	ra,4(sp)
81114e58:	df000017 	ldw	fp,0(sp)
81114e5c:	dec00204 	addi	sp,sp,8
81114e60:	f800283a 	ret

81114e64 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81114e64:	defffe04 	addi	sp,sp,-8
81114e68:	de00012e 	bgeu	sp,et,81114e70 <vCCDLoadDefaultValues+0xc>
81114e6c:	003b68fa 	trap	3
81114e70:	df000115 	stw	fp,4(sp)
81114e74:	df000104 	addi	fp,sp,4
81114e78:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
81114e7c:	e0bfff17 	ldw	r2,-4(fp)
81114e80:	00c46784 	movi	r3,4510
81114e84:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
81114e88:	e0bfff17 	ldw	r2,-4(fp)
81114e8c:	00c00784 	movi	r3,30
81114e90:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
81114e94:	e0bfff17 	ldw	r2,-4(fp)
81114e98:	00c233c4 	movi	r3,2255
81114e9c:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
81114ea0:	e0bfff17 	ldw	r2,-4(fp)
81114ea4:	00c003c4 	movi	r3,15
81114ea8:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
81114eac:	e0bfff17 	ldw	r2,-4(fp)
81114eb0:	00c00644 	movi	r3,25
81114eb4:	10c0000d 	sth	r3,0(r2)
}
81114eb8:	0001883a 	nop
81114ebc:	e037883a 	mov	sp,fp
81114ec0:	df000017 	ldw	fp,0(sp)
81114ec4:	dec00104 	addi	sp,sp,4
81114ec8:	f800283a 	ret

81114ecc <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81114ecc:	defff904 	addi	sp,sp,-28
81114ed0:	de00012e 	bgeu	sp,et,81114ed8 <vCCDChangeValues+0xc>
81114ed4:	003b68fa 	trap	3
81114ed8:	df000615 	stw	fp,24(sp)
81114edc:	df000604 	addi	fp,sp,24
81114ee0:	e13ffa15 	stw	r4,-24(fp)
81114ee4:	2811883a 	mov	r8,r5
81114ee8:	300b883a 	mov	r5,r6
81114eec:	3809883a 	mov	r4,r7
81114ef0:	e0c00117 	ldw	r3,4(fp)
81114ef4:	e0800217 	ldw	r2,8(fp)
81114ef8:	e23ffb0d 	sth	r8,-20(fp)
81114efc:	e17ffc0d 	sth	r5,-16(fp)
81114f00:	e13ffd0d 	sth	r4,-12(fp)
81114f04:	e0fffe0d 	sth	r3,-8(fp)
81114f08:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81114f0c:	e0bffa17 	ldw	r2,-24(fp)
81114f10:	e0fffb0b 	ldhu	r3,-20(fp)
81114f14:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81114f18:	e0bffa17 	ldw	r2,-24(fp)
81114f1c:	e0fffc0b 	ldhu	r3,-16(fp)
81114f20:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81114f24:	e0bffa17 	ldw	r2,-24(fp)
81114f28:	e0fffd0b 	ldhu	r3,-12(fp)
81114f2c:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81114f30:	e0bffa17 	ldw	r2,-24(fp)
81114f34:	e0fffe0b 	ldhu	r3,-8(fp)
81114f38:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81114f3c:	e0bffa17 	ldw	r2,-24(fp)
81114f40:	e0ffff0b 	ldhu	r3,-4(fp)
81114f44:	10c0000d 	sth	r3,0(r2)
}
81114f48:	0001883a 	nop
81114f4c:	e037883a 	mov	sp,fp
81114f50:	df000017 	ldw	fp,0(sp)
81114f54:	dec00104 	addi	sp,sp,4
81114f58:	f800283a 	ret

81114f5c <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81114f5c:	defff904 	addi	sp,sp,-28
81114f60:	de00012e 	bgeu	sp,et,81114f68 <bSendUART128v2+0xc>
81114f64:	003b68fa 	trap	3
81114f68:	dfc00615 	stw	ra,24(sp)
81114f6c:	df000515 	stw	fp,20(sp)
81114f70:	df000504 	addi	fp,sp,20
81114f74:	e13ffe15 	stw	r4,-8(fp)
81114f78:	2805883a 	mov	r2,r5
81114f7c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81114f80:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81114f84:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81114f88:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81114f8c:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81114f90:	d0a05e17 	ldw	r2,-32392(gp)
81114f94:	e0fffd04 	addi	r3,fp,-12
81114f98:	180d883a 	mov	r6,r3
81114f9c:	01400504 	movi	r5,20
81114fa0:	1009883a 	mov	r4,r2
81114fa4:	113a1f80 	call	8113a1f8 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81114fa8:	e0bffd03 	ldbu	r2,-12(fp)
81114fac:	10803fcc 	andi	r2,r2,255
81114fb0:	10000326 	beq	r2,zero,81114fc0 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81114fb4:	11179640 	call	81117964 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81114fb8:	e0bffc17 	ldw	r2,-16(fp)
81114fbc:	00009e06 	br	81115238 <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81114fc0:	d0a06917 	ldw	r2,-32348(gp)
81114fc4:	e0fffd04 	addi	r3,fp,-12
81114fc8:	180d883a 	mov	r6,r3
81114fcc:	01400104 	movi	r5,4
81114fd0:	1009883a 	mov	r4,r2
81114fd4:	11381ec0 	call	811381ec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81114fd8:	e0bffd03 	ldbu	r2,-12(fp)
81114fdc:	10803fcc 	andi	r2,r2,255
81114fe0:	10001126 	beq	r2,zero,81115028 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81114fe4:	d0a05d17 	ldw	r2,-32396(gp)
81114fe8:	100f883a 	mov	r7,r2
81114fec:	01801484 	movi	r6,82
81114ff0:	01400044 	movi	r5,1
81114ff4:	01204574 	movhi	r4,33045
81114ff8:	2125c604 	addi	r4,r4,-26856
81114ffc:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81115000:	d0a05e17 	ldw	r2,-32392(gp)
81115004:	1009883a 	mov	r4,r2
81115008:	113a5800 	call	8113a580 <OSSemPost>
8111500c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81115010:	e0bffd03 	ldbu	r2,-12(fp)
81115014:	10803fcc 	andi	r2,r2,255
81115018:	10000126 	beq	r2,zero,81115020 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8111501c:	11178fc0 	call	811178fc <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81115020:	e0bffc17 	ldw	r2,-16(fp)
81115024:	00008406 	br	81115238 <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81115028:	e03ffb05 	stb	zero,-20(fp)
8111502c:	00004306 	br	8111513c <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81115030:	e0fffb03 	ldbu	r3,-20(fp)
81115034:	00a045b4 	movhi	r2,33046
81115038:	10a63f04 	addi	r2,r2,-26372
8111503c:	18c7883a 	add	r3,r3,r3
81115040:	18c7883a 	add	r3,r3,r3
81115044:	10c5883a 	add	r2,r2,r3
81115048:	10800017 	ldw	r2,0(r2)
8111504c:	1000381e 	bne	r2,zero,81115130 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81115050:	e0bffb03 	ldbu	r2,-20(fp)
81115054:	10c02324 	muli	r3,r2,140
81115058:	00a045b4 	movhi	r2,33046
8111505c:	10a65d04 	addi	r2,r2,-26252
81115060:	1885883a 	add	r2,r3,r2
81115064:	01802004 	movi	r6,128
81115068:	000b883a 	mov	r5,zero
8111506c:	1009883a 	mov	r4,r2
81115070:	111d31c0 	call	8111d31c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81115074:	e0bffb03 	ldbu	r2,-20(fp)
81115078:	10c02324 	muli	r3,r2,140
8111507c:	00a045b4 	movhi	r2,33046
81115080:	10a65d04 	addi	r2,r2,-26252
81115084:	1885883a 	add	r2,r3,r2
81115088:	01801fc4 	movi	r6,127
8111508c:	e17ffe17 	ldw	r5,-8(fp)
81115090:	1009883a 	mov	r4,r2
81115094:	111d1cc0 	call	8111d1cc <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81115098:	e13ffb03 	ldbu	r4,-20(fp)
8111509c:	e0ffff0b 	ldhu	r3,-4(fp)
811150a0:	00a045b4 	movhi	r2,33046
811150a4:	10a65d04 	addi	r2,r2,-26252
811150a8:	21002324 	muli	r4,r4,140
811150ac:	1105883a 	add	r2,r2,r4
811150b0:	10802104 	addi	r2,r2,132
811150b4:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
811150b8:	e0fffb03 	ldbu	r3,-20(fp)
811150bc:	00a045b4 	movhi	r2,33046
811150c0:	10a65d04 	addi	r2,r2,-26252
811150c4:	18c02324 	muli	r3,r3,140
811150c8:	10c5883a 	add	r2,r2,r3
811150cc:	10802204 	addi	r2,r2,136
811150d0:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
811150d4:	e0fffb03 	ldbu	r3,-20(fp)
811150d8:	00a045b4 	movhi	r2,33046
811150dc:	10a65d04 	addi	r2,r2,-26252
811150e0:	18c02324 	muli	r3,r3,140
811150e4:	10c5883a 	add	r2,r2,r3
811150e8:	10802184 	addi	r2,r2,134
811150ec:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
811150f0:	e0fffb03 	ldbu	r3,-20(fp)
811150f4:	00a045b4 	movhi	r2,33046
811150f8:	10a65d04 	addi	r2,r2,-26252
811150fc:	18c02324 	muli	r3,r3,140
81115100:	10c5883a 	add	r2,r2,r3
81115104:	10802004 	addi	r2,r2,128
81115108:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
8111510c:	e0fffb03 	ldbu	r3,-20(fp)
81115110:	00a045b4 	movhi	r2,33046
81115114:	10a63f04 	addi	r2,r2,-26372
81115118:	18c7883a 	add	r3,r3,r3
8111511c:	18c7883a 	add	r3,r3,r3
81115120:	10c5883a 	add	r2,r2,r3
81115124:	00c00044 	movi	r3,1
81115128:	10c00015 	stw	r3,0(r2)
			break;
8111512c:	00000606 	br	81115148 <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81115130:	e0bffb03 	ldbu	r2,-20(fp)
81115134:	10800044 	addi	r2,r2,1
81115138:	e0bffb05 	stb	r2,-20(fp)
8111513c:	e0bffb03 	ldbu	r2,-20(fp)
81115140:	108001b0 	cmpltui	r2,r2,6
81115144:	103fba1e 	bne	r2,zero,81115030 <__reset+0xfb0f5030>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81115148:	e0bffb03 	ldbu	r2,-20(fp)
8111514c:	108001b0 	cmpltui	r2,r2,6
81115150:	1000091e 	bne	r2,zero,81115178 <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81115154:	d0a05e17 	ldw	r2,-32392(gp)
81115158:	1009883a 	mov	r4,r2
8111515c:	113a5800 	call	8113a580 <OSSemPost>
81115160:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81115164:	d0a06917 	ldw	r2,-32348(gp)
81115168:	1009883a 	mov	r4,r2
8111516c:	11387900 	call	81138790 <OSMutexPost>
		return bSuccessL;
81115170:	e0bffc17 	ldw	r2,-16(fp)
81115174:	00003006 	br	81115238 <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
81115178:	00800044 	movi	r2,1
8111517c:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81115180:	d0a07043 	ldbu	r2,-32319(gp)
81115184:	10bfffc4 	addi	r2,r2,-1
81115188:	d0a07045 	stb	r2,-32319(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111518c:	d0a06f17 	ldw	r2,-32324(gp)
81115190:	e0fffd04 	addi	r3,fp,-12
81115194:	180d883a 	mov	r6,r3
81115198:	01400084 	movi	r5,2
8111519c:	1009883a 	mov	r4,r2
811151a0:	11381ec0 	call	811381ec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811151a4:	e0bffd03 	ldbu	r2,-12(fp)
811151a8:	10803fcc 	andi	r2,r2,255
811151ac:	10000c26 	beq	r2,zero,811151e0 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
811151b0:	d0a05d17 	ldw	r2,-32396(gp)
811151b4:	100f883a 	mov	r7,r2
811151b8:	01801c04 	movi	r6,112
811151bc:	01400044 	movi	r5,1
811151c0:	01204574 	movhi	r4,33045
811151c4:	2125db04 	addi	r4,r4,-26772
811151c8:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811151cc:	d0a06917 	ldw	r2,-32348(gp)
811151d0:	1009883a 	mov	r4,r2
811151d4:	11387900 	call	81138790 <OSMutexPost>
		return bSuccessL;
811151d8:	e0bffc17 	ldw	r2,-16(fp)
811151dc:	00001606 	br	81115238 <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
811151e0:	e0bffb03 	ldbu	r2,-20(fp)
811151e4:	10c02324 	muli	r3,r2,140
811151e8:	00a045b4 	movhi	r2,33046
811151ec:	10a65d04 	addi	r2,r2,-26252
811151f0:	1885883a 	add	r2,r3,r2
811151f4:	1009883a 	mov	r4,r2
811151f8:	111d7680 	call	8111d768 <puts>
	xBuffer128[ucIL].bSent = TRUE;
811151fc:	e0fffb03 	ldbu	r3,-20(fp)
81115200:	00a045b4 	movhi	r2,33046
81115204:	10a65d04 	addi	r2,r2,-26252
81115208:	18c02324 	muli	r3,r3,140
8111520c:	10c5883a 	add	r2,r2,r3
81115210:	10802004 	addi	r2,r2,128
81115214:	00c00044 	movi	r3,1
81115218:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
8111521c:	d0a06f17 	ldw	r2,-32324(gp)
81115220:	1009883a 	mov	r4,r2
81115224:	11387900 	call	81138790 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81115228:	d0a06917 	ldw	r2,-32348(gp)
8111522c:	1009883a 	mov	r4,r2
81115230:	11387900 	call	81138790 <OSMutexPost>

	return bSuccessL;
81115234:	e0bffc17 	ldw	r2,-16(fp)
}
81115238:	e037883a 	mov	sp,fp
8111523c:	dfc00117 	ldw	ra,4(sp)
81115240:	df000017 	ldw	fp,0(sp)
81115244:	dec00204 	addi	sp,sp,8
81115248:	f800283a 	ret

8111524c <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
8111524c:	defff904 	addi	sp,sp,-28
81115250:	de00012e 	bgeu	sp,et,81115258 <bSendUART64v2+0xc>
81115254:	003b68fa 	trap	3
81115258:	dfc00615 	stw	ra,24(sp)
8111525c:	df000515 	stw	fp,20(sp)
81115260:	df000504 	addi	fp,sp,20
81115264:	e13ffe15 	stw	r4,-8(fp)
81115268:	2805883a 	mov	r2,r5
8111526c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81115270:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81115274:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81115278:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8111527c:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81115280:	d0a05917 	ldw	r2,-32412(gp)
81115284:	e0fffd04 	addi	r3,fp,-12
81115288:	180d883a 	mov	r6,r3
8111528c:	01400504 	movi	r5,20
81115290:	1009883a 	mov	r4,r2
81115294:	113a1f80 	call	8113a1f8 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81115298:	e0bffd03 	ldbu	r2,-12(fp)
8111529c:	10803fcc 	andi	r2,r2,255
811152a0:	10000326 	beq	r2,zero,811152b0 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811152a4:	11179cc0 	call	811179cc <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
811152a8:	e0bffc17 	ldw	r2,-16(fp)
811152ac:	0000a006 	br	81115530 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811152b0:	d0a06c17 	ldw	r2,-32336(gp)
811152b4:	e0fffd04 	addi	r3,fp,-12
811152b8:	180d883a 	mov	r6,r3
811152bc:	01400104 	movi	r5,4
811152c0:	1009883a 	mov	r4,r2
811152c4:	11381ec0 	call	811381ec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811152c8:	e0bffd03 	ldbu	r2,-12(fp)
811152cc:	10803fcc 	andi	r2,r2,255
811152d0:	10001126 	beq	r2,zero,81115318 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
811152d4:	d0a05d17 	ldw	r2,-32396(gp)
811152d8:	100f883a 	mov	r7,r2
811152dc:	018013c4 	movi	r6,79
811152e0:	01400044 	movi	r5,1
811152e4:	01204574 	movhi	r4,33045
811152e8:	2125f804 	addi	r4,r4,-26656
811152ec:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
811152f0:	d0a05917 	ldw	r2,-32412(gp)
811152f4:	1009883a 	mov	r4,r2
811152f8:	113a5800 	call	8113a580 <OSSemPost>
811152fc:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81115300:	e0bffd03 	ldbu	r2,-12(fp)
81115304:	10803fcc 	andi	r2,r2,255
81115308:	10000126 	beq	r2,zero,81115310 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8111530c:	11178940 	call	81117894 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81115310:	e0bffc17 	ldw	r2,-16(fp)
81115314:	00008606 	br	81115530 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81115318:	e03ffb05 	stb	zero,-20(fp)
8111531c:	00004506 	br	81115434 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81115320:	e0fffb03 	ldbu	r3,-20(fp)
81115324:	00a045b4 	movhi	r2,33046
81115328:	10a63f04 	addi	r2,r2,-26372
8111532c:	18c00184 	addi	r3,r3,6
81115330:	18c7883a 	add	r3,r3,r3
81115334:	18c7883a 	add	r3,r3,r3
81115338:	10c5883a 	add	r2,r2,r3
8111533c:	10800017 	ldw	r2,0(r2)
81115340:	1000391e 	bne	r2,zero,81115428 <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81115344:	e0bffb03 	ldbu	r2,-20(fp)
81115348:	10c01324 	muli	r3,r2,76
8111534c:	00a04574 	movhi	r2,33045
81115350:	10821e04 	addi	r2,r2,2168
81115354:	1885883a 	add	r2,r3,r2
81115358:	01801004 	movi	r6,64
8111535c:	000b883a 	mov	r5,zero
81115360:	1009883a 	mov	r4,r2
81115364:	111d31c0 	call	8111d31c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81115368:	e0bffb03 	ldbu	r2,-20(fp)
8111536c:	10c01324 	muli	r3,r2,76
81115370:	00a04574 	movhi	r2,33045
81115374:	10821e04 	addi	r2,r2,2168
81115378:	1885883a 	add	r2,r3,r2
8111537c:	01800fc4 	movi	r6,63
81115380:	e17ffe17 	ldw	r5,-8(fp)
81115384:	1009883a 	mov	r4,r2
81115388:	111d1cc0 	call	8111d1cc <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
8111538c:	e13ffb03 	ldbu	r4,-20(fp)
81115390:	e0ffff0b 	ldhu	r3,-4(fp)
81115394:	00a04574 	movhi	r2,33045
81115398:	10821e04 	addi	r2,r2,2168
8111539c:	21001324 	muli	r4,r4,76
811153a0:	1105883a 	add	r2,r2,r4
811153a4:	10801104 	addi	r2,r2,68
811153a8:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
811153ac:	e0fffb03 	ldbu	r3,-20(fp)
811153b0:	00a04574 	movhi	r2,33045
811153b4:	10821e04 	addi	r2,r2,2168
811153b8:	18c01324 	muli	r3,r3,76
811153bc:	10c5883a 	add	r2,r2,r3
811153c0:	10801204 	addi	r2,r2,72
811153c4:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
811153c8:	e0fffb03 	ldbu	r3,-20(fp)
811153cc:	00a04574 	movhi	r2,33045
811153d0:	10821e04 	addi	r2,r2,2168
811153d4:	18c01324 	muli	r3,r3,76
811153d8:	10c5883a 	add	r2,r2,r3
811153dc:	10801184 	addi	r2,r2,70
811153e0:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
811153e4:	e0fffb03 	ldbu	r3,-20(fp)
811153e8:	00a04574 	movhi	r2,33045
811153ec:	10821e04 	addi	r2,r2,2168
811153f0:	18c01324 	muli	r3,r3,76
811153f4:	10c5883a 	add	r2,r2,r3
811153f8:	10801004 	addi	r2,r2,64
811153fc:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81115400:	e0fffb03 	ldbu	r3,-20(fp)
81115404:	00a045b4 	movhi	r2,33046
81115408:	10a63f04 	addi	r2,r2,-26372
8111540c:	18c00184 	addi	r3,r3,6
81115410:	18c7883a 	add	r3,r3,r3
81115414:	18c7883a 	add	r3,r3,r3
81115418:	10c5883a 	add	r2,r2,r3
8111541c:	00c00044 	movi	r3,1
81115420:	10c00015 	stw	r3,0(r2)
			break;
81115424:	00000606 	br	81115440 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81115428:	e0bffb03 	ldbu	r2,-20(fp)
8111542c:	10800044 	addi	r2,r2,1
81115430:	e0bffb05 	stb	r2,-20(fp)
81115434:	e0bffb03 	ldbu	r2,-20(fp)
81115438:	10800230 	cmpltui	r2,r2,8
8111543c:	103fb81e 	bne	r2,zero,81115320 <__reset+0xfb0f5320>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81115440:	e0bffb03 	ldbu	r2,-20(fp)
81115444:	10800230 	cmpltui	r2,r2,8
81115448:	1000091e 	bne	r2,zero,81115470 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8111544c:	d0a05917 	ldw	r2,-32412(gp)
81115450:	1009883a 	mov	r4,r2
81115454:	113a5800 	call	8113a580 <OSSemPost>
81115458:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
8111545c:	d0a06c17 	ldw	r2,-32336(gp)
81115460:	1009883a 	mov	r4,r2
81115464:	11387900 	call	81138790 <OSMutexPost>
		return bSuccessL;
81115468:	e0bffc17 	ldw	r2,-16(fp)
8111546c:	00003006 	br	81115530 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
81115470:	00800044 	movi	r2,1
81115474:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81115478:	d0a07003 	ldbu	r2,-32320(gp)
8111547c:	10bfffc4 	addi	r2,r2,-1
81115480:	d0a07005 	stb	r2,-32320(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81115484:	d0a06f17 	ldw	r2,-32324(gp)
81115488:	e0fffd04 	addi	r3,fp,-12
8111548c:	180d883a 	mov	r6,r3
81115490:	01400084 	movi	r5,2
81115494:	1009883a 	mov	r4,r2
81115498:	11381ec0 	call	811381ec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111549c:	e0bffd03 	ldbu	r2,-12(fp)
811154a0:	10803fcc 	andi	r2,r2,255
811154a4:	10000c26 	beq	r2,zero,811154d8 <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
811154a8:	d0a05d17 	ldw	r2,-32396(gp)
811154ac:	100f883a 	mov	r7,r2
811154b0:	01801bc4 	movi	r6,111
811154b4:	01400044 	movi	r5,1
811154b8:	01204574 	movhi	r4,33045
811154bc:	21260c04 	addi	r4,r4,-26576
811154c0:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
811154c4:	d0a06c17 	ldw	r2,-32336(gp)
811154c8:	1009883a 	mov	r4,r2
811154cc:	11387900 	call	81138790 <OSMutexPost>
		return bSuccessL;
811154d0:	e0bffc17 	ldw	r2,-16(fp)
811154d4:	00001606 	br	81115530 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
811154d8:	e0bffb03 	ldbu	r2,-20(fp)
811154dc:	10c01324 	muli	r3,r2,76
811154e0:	00a04574 	movhi	r2,33045
811154e4:	10821e04 	addi	r2,r2,2168
811154e8:	1885883a 	add	r2,r3,r2
811154ec:	1009883a 	mov	r4,r2
811154f0:	111d7680 	call	8111d768 <puts>
	xBuffer64[ucIL].bSent = TRUE;
811154f4:	e0fffb03 	ldbu	r3,-20(fp)
811154f8:	00a04574 	movhi	r2,33045
811154fc:	10821e04 	addi	r2,r2,2168
81115500:	18c01324 	muli	r3,r3,76
81115504:	10c5883a 	add	r2,r2,r3
81115508:	10801004 	addi	r2,r2,64
8111550c:	00c00044 	movi	r3,1
81115510:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81115514:	d0a06f17 	ldw	r2,-32324(gp)
81115518:	1009883a 	mov	r4,r2
8111551c:	11387900 	call	81138790 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81115520:	d0a06c17 	ldw	r2,-32336(gp)
81115524:	1009883a 	mov	r4,r2
81115528:	11387900 	call	81138790 <OSMutexPost>

	return bSuccessL;
8111552c:	e0bffc17 	ldw	r2,-16(fp)
}
81115530:	e037883a 	mov	sp,fp
81115534:	dfc00117 	ldw	ra,4(sp)
81115538:	df000017 	ldw	fp,0(sp)
8111553c:	dec00204 	addi	sp,sp,8
81115540:	f800283a 	ret

81115544 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81115544:	defff904 	addi	sp,sp,-28
81115548:	de00012e 	bgeu	sp,et,81115550 <bSendUART32v2+0xc>
8111554c:	003b68fa 	trap	3
81115550:	dfc00615 	stw	ra,24(sp)
81115554:	df000515 	stw	fp,20(sp)
81115558:	df000504 	addi	fp,sp,20
8111555c:	e13ffe15 	stw	r4,-8(fp)
81115560:	2805883a 	mov	r2,r5
81115564:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81115568:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8111556c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81115570:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81115574:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81115578:	d0a06a17 	ldw	r2,-32344(gp)
8111557c:	e0fffd04 	addi	r3,fp,-12
81115580:	180d883a 	mov	r6,r3
81115584:	01400504 	movi	r5,20
81115588:	1009883a 	mov	r4,r2
8111558c:	113a1f80 	call	8113a1f8 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81115590:	e0bffd03 	ldbu	r2,-12(fp)
81115594:	10803fcc 	andi	r2,r2,255
81115598:	10000326 	beq	r2,zero,811155a8 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8111559c:	1117a340 	call	81117a34 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
811155a0:	e0bffc17 	ldw	r2,-16(fp)
811155a4:	0000a006 	br	81115828 <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811155a8:	d0a06717 	ldw	r2,-32356(gp)
811155ac:	e0fffd04 	addi	r3,fp,-12
811155b0:	180d883a 	mov	r6,r3
811155b4:	01400104 	movi	r5,4
811155b8:	1009883a 	mov	r4,r2
811155bc:	11381ec0 	call	811381ec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811155c0:	e0bffd03 	ldbu	r2,-12(fp)
811155c4:	10803fcc 	andi	r2,r2,255
811155c8:	10001126 	beq	r2,zero,81115610 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
811155cc:	d0a05d17 	ldw	r2,-32396(gp)
811155d0:	100f883a 	mov	r7,r2
811155d4:	018013c4 	movi	r6,79
811155d8:	01400044 	movi	r5,1
811155dc:	01204574 	movhi	r4,33045
811155e0:	21262804 	addi	r4,r4,-26464
811155e4:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
811155e8:	d0a06a17 	ldw	r2,-32344(gp)
811155ec:	1009883a 	mov	r4,r2
811155f0:	113a5800 	call	8113a580 <OSSemPost>
811155f4:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811155f8:	e0bffd03 	ldbu	r2,-12(fp)
811155fc:	10803fcc 	andi	r2,r2,255
81115600:	10000126 	beq	r2,zero,81115608 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81115604:	111782c0 	call	8111782c <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81115608:	e0bffc17 	ldw	r2,-16(fp)
8111560c:	00008606 	br	81115828 <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81115610:	e03ffb05 	stb	zero,-20(fp)
81115614:	00004506 	br	8111572c <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81115618:	e0fffb03 	ldbu	r3,-20(fp)
8111561c:	00a045b4 	movhi	r2,33046
81115620:	10a63f04 	addi	r2,r2,-26372
81115624:	18c00384 	addi	r3,r3,14
81115628:	18c7883a 	add	r3,r3,r3
8111562c:	18c7883a 	add	r3,r3,r3
81115630:	10c5883a 	add	r2,r2,r3
81115634:	10800017 	ldw	r2,0(r2)
81115638:	1000391e 	bne	r2,zero,81115720 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
8111563c:	e0bffb03 	ldbu	r2,-20(fp)
81115640:	10c00b24 	muli	r3,r2,44
81115644:	00a04574 	movhi	r2,33045
81115648:	1093cb04 	addi	r2,r2,20268
8111564c:	1885883a 	add	r2,r3,r2
81115650:	01800804 	movi	r6,32
81115654:	000b883a 	mov	r5,zero
81115658:	1009883a 	mov	r4,r2
8111565c:	111d31c0 	call	8111d31c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81115660:	e0bffb03 	ldbu	r2,-20(fp)
81115664:	10c00b24 	muli	r3,r2,44
81115668:	00a04574 	movhi	r2,33045
8111566c:	1093cb04 	addi	r2,r2,20268
81115670:	1885883a 	add	r2,r3,r2
81115674:	018007c4 	movi	r6,31
81115678:	e17ffe17 	ldw	r5,-8(fp)
8111567c:	1009883a 	mov	r4,r2
81115680:	111d1cc0 	call	8111d1cc <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81115684:	e13ffb03 	ldbu	r4,-20(fp)
81115688:	e0ffff0b 	ldhu	r3,-4(fp)
8111568c:	00a04574 	movhi	r2,33045
81115690:	1093cb04 	addi	r2,r2,20268
81115694:	21000b24 	muli	r4,r4,44
81115698:	1105883a 	add	r2,r2,r4
8111569c:	10800904 	addi	r2,r2,36
811156a0:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
811156a4:	e0fffb03 	ldbu	r3,-20(fp)
811156a8:	00a04574 	movhi	r2,33045
811156ac:	1093cb04 	addi	r2,r2,20268
811156b0:	18c00b24 	muli	r3,r3,44
811156b4:	10c5883a 	add	r2,r2,r3
811156b8:	10800a04 	addi	r2,r2,40
811156bc:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
811156c0:	e0fffb03 	ldbu	r3,-20(fp)
811156c4:	00a04574 	movhi	r2,33045
811156c8:	1093cb04 	addi	r2,r2,20268
811156cc:	18c00b24 	muli	r3,r3,44
811156d0:	10c5883a 	add	r2,r2,r3
811156d4:	10800984 	addi	r2,r2,38
811156d8:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
811156dc:	e0fffb03 	ldbu	r3,-20(fp)
811156e0:	00a04574 	movhi	r2,33045
811156e4:	1093cb04 	addi	r2,r2,20268
811156e8:	18c00b24 	muli	r3,r3,44
811156ec:	10c5883a 	add	r2,r2,r3
811156f0:	10800804 	addi	r2,r2,32
811156f4:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
811156f8:	e0fffb03 	ldbu	r3,-20(fp)
811156fc:	00a045b4 	movhi	r2,33046
81115700:	10a63f04 	addi	r2,r2,-26372
81115704:	18c00384 	addi	r3,r3,14
81115708:	18c7883a 	add	r3,r3,r3
8111570c:	18c7883a 	add	r3,r3,r3
81115710:	10c5883a 	add	r2,r2,r3
81115714:	00c00044 	movi	r3,1
81115718:	10c00015 	stw	r3,0(r2)
			break;
8111571c:	00000606 	br	81115738 <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81115720:	e0bffb03 	ldbu	r2,-20(fp)
81115724:	10800044 	addi	r2,r2,1
81115728:	e0bffb05 	stb	r2,-20(fp)
8111572c:	e0bffb03 	ldbu	r2,-20(fp)
81115730:	10800230 	cmpltui	r2,r2,8
81115734:	103fb81e 	bne	r2,zero,81115618 <__reset+0xfb0f5618>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81115738:	e0bffb03 	ldbu	r2,-20(fp)
8111573c:	10800230 	cmpltui	r2,r2,8
81115740:	1000091e 	bne	r2,zero,81115768 <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81115744:	d0a06a17 	ldw	r2,-32344(gp)
81115748:	1009883a 	mov	r4,r2
8111574c:	113a5800 	call	8113a580 <OSSemPost>
81115750:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81115754:	d0a06717 	ldw	r2,-32356(gp)
81115758:	1009883a 	mov	r4,r2
8111575c:	11387900 	call	81138790 <OSMutexPost>
		return bSuccessL;
81115760:	e0bffc17 	ldw	r2,-16(fp)
81115764:	00003006 	br	81115828 <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81115768:	00800044 	movi	r2,1
8111576c:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81115770:	d0a06383 	ldbu	r2,-32370(gp)
81115774:	10bfffc4 	addi	r2,r2,-1
81115778:	d0a06385 	stb	r2,-32370(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111577c:	d0a06f17 	ldw	r2,-32324(gp)
81115780:	e0fffd04 	addi	r3,fp,-12
81115784:	180d883a 	mov	r6,r3
81115788:	01400084 	movi	r5,2
8111578c:	1009883a 	mov	r4,r2
81115790:	11381ec0 	call	811381ec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81115794:	e0bffd03 	ldbu	r2,-12(fp)
81115798:	10803fcc 	andi	r2,r2,255
8111579c:	10000c26 	beq	r2,zero,811157d0 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
811157a0:	d0a05d17 	ldw	r2,-32396(gp)
811157a4:	100f883a 	mov	r7,r2
811157a8:	01801bc4 	movi	r6,111
811157ac:	01400044 	movi	r5,1
811157b0:	01204574 	movhi	r4,33045
811157b4:	21263c04 	addi	r4,r4,-26384
811157b8:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
811157bc:	d0a06717 	ldw	r2,-32356(gp)
811157c0:	1009883a 	mov	r4,r2
811157c4:	11387900 	call	81138790 <OSMutexPost>
		return bSuccessL;
811157c8:	e0bffc17 	ldw	r2,-16(fp)
811157cc:	00001606 	br	81115828 <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
811157d0:	e0bffb03 	ldbu	r2,-20(fp)
811157d4:	10c00b24 	muli	r3,r2,44
811157d8:	00a04574 	movhi	r2,33045
811157dc:	1093cb04 	addi	r2,r2,20268
811157e0:	1885883a 	add	r2,r3,r2
811157e4:	1009883a 	mov	r4,r2
811157e8:	111d7680 	call	8111d768 <puts>
	xBuffer32[ucIL].bSent = TRUE;
811157ec:	e0fffb03 	ldbu	r3,-20(fp)
811157f0:	00a04574 	movhi	r2,33045
811157f4:	1093cb04 	addi	r2,r2,20268
811157f8:	18c00b24 	muli	r3,r3,44
811157fc:	10c5883a 	add	r2,r2,r3
81115800:	10800804 	addi	r2,r2,32
81115804:	00c00044 	movi	r3,1
81115808:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
8111580c:	d0a06f17 	ldw	r2,-32324(gp)
81115810:	1009883a 	mov	r4,r2
81115814:	11387900 	call	81138790 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81115818:	d0a06717 	ldw	r2,-32356(gp)
8111581c:	1009883a 	mov	r4,r2
81115820:	11387900 	call	81138790 <OSMutexPost>

	return bSuccessL;
81115824:	e0bffc17 	ldw	r2,-16(fp)
}
81115828:	e037883a 	mov	sp,fp
8111582c:	dfc00117 	ldw	ra,4(sp)
81115830:	df000017 	ldw	fp,0(sp)
81115834:	dec00204 	addi	sp,sp,8
81115838:	f800283a 	ret

8111583c <vSendEthConf>:


void vSendEthConf ( void ) {
8111583c:	deffc304 	addi	sp,sp,-244
81115840:	de00012e 	bgeu	sp,et,81115848 <vSendEthConf+0xc>
81115844:	003b68fa 	trap	3
81115848:	dfc03c15 	stw	ra,240(sp)
8111584c:	df003b15 	stw	fp,236(sp)
81115850:	dd403a15 	stw	r21,232(sp)
81115854:	dd003915 	stw	r20,228(sp)
81115858:	dcc03815 	stw	r19,224(sp)
8111585c:	dc803715 	stw	r18,220(sp)
81115860:	dc403615 	stw	r17,216(sp)
81115864:	dc003515 	stw	r16,212(sp)
81115868:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
8111586c:	e03fd98d 	sth	zero,-154(fp)
81115870:	e03fda0d 	sth	zero,-152(fp)
81115874:	e0bfda84 	addi	r2,fp,-150
81115878:	00c01f04 	movi	r3,124
8111587c:	180d883a 	mov	r6,r3
81115880:	000b883a 	mov	r5,zero
81115884:	1009883a 	mov	r4,r2
81115888:	111d31c0 	call	8111d31c <memset>
    unsigned char crc = 0;
8111588c:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115890:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115894:	1115dfc0 	call	81115dfc <usiGetIdCMD>
81115898:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111589c:	e57fd90b 	ldhu	r21,-156(fp)
811158a0:	00a045b4 	movhi	r2,33046
811158a4:	10860504 	addi	r2,r2,6164
811158a8:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811158ac:	00a045b4 	movhi	r2,33046
811158b0:	10860504 	addi	r2,r2,6164
811158b4:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811158b8:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811158bc:	00a045b4 	movhi	r2,33046
811158c0:	10860504 	addi	r2,r2,6164
811158c4:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811158c8:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811158cc:	00a045b4 	movhi	r2,33046
811158d0:	10860504 	addi	r2,r2,6164
811158d4:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811158d8:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811158dc:	00a045b4 	movhi	r2,33046
811158e0:	10860504 	addi	r2,r2,6164
811158e4:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811158e8:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811158ec:	00a045b4 	movhi	r2,33046
811158f0:	10860504 	addi	r2,r2,6164
811158f4:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811158f8:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811158fc:	00a045b4 	movhi	r2,33046
81115900:	10860504 	addi	r2,r2,6164
81115904:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115908:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111590c:	00a045b4 	movhi	r2,33046
81115910:	10860504 	addi	r2,r2,6164
81115914:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115918:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111591c:	00a045b4 	movhi	r2,33046
81115920:	10860504 	addi	r2,r2,6164
81115924:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115928:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111592c:	00a045b4 	movhi	r2,33046
81115930:	10860504 	addi	r2,r2,6164
81115934:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115938:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111593c:	00a045b4 	movhi	r2,33046
81115940:	10860504 	addi	r2,r2,6164
81115944:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115948:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111594c:	00a045b4 	movhi	r2,33046
81115950:	10860504 	addi	r2,r2,6164
81115954:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115958:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111595c:	00a045b4 	movhi	r2,33046
81115960:	10860504 	addi	r2,r2,6164
81115964:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115968:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111596c:	00a045b4 	movhi	r2,33046
81115970:	10860504 	addi	r2,r2,6164
81115974:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115978:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111597c:	00a045b4 	movhi	r2,33046
81115980:	10860504 	addi	r2,r2,6164
81115984:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115988:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111598c:	00a045b4 	movhi	r2,33046
81115990:	10860504 	addi	r2,r2,6164
81115994:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115998:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111599c:	00a045b4 	movhi	r2,33046
811159a0:	10860504 	addi	r2,r2,6164
811159a4:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811159a8:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
811159ac:	00a045b4 	movhi	r2,33046
811159b0:	10860504 	addi	r2,r2,6164
811159b4:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811159b8:	10bfffcc 	andi	r2,r2,65535
811159bc:	e53fd984 	addi	r20,fp,-154
811159c0:	d8801115 	stw	r2,68(sp)
811159c4:	dcc01015 	stw	r19,64(sp)
811159c8:	dc800f15 	stw	r18,60(sp)
811159cc:	dc400e15 	stw	r17,56(sp)
811159d0:	dc000d15 	stw	r16,52(sp)
811159d4:	dbc00c15 	stw	r15,48(sp)
811159d8:	db800b15 	stw	r14,44(sp)
811159dc:	db400a15 	stw	r13,40(sp)
811159e0:	db000915 	stw	r12,36(sp)
811159e4:	dac00815 	stw	r11,32(sp)
811159e8:	da800715 	stw	r10,28(sp)
811159ec:	da400615 	stw	r9,24(sp)
811159f0:	da000515 	stw	r8,20(sp)
811159f4:	d9c00415 	stw	r7,16(sp)
811159f8:	d9800315 	stw	r6,12(sp)
811159fc:	d9400215 	stw	r5,8(sp)
81115a00:	d9000115 	stw	r4,4(sp)
81115a04:	d8c00015 	stw	r3,0(sp)
81115a08:	a80f883a 	mov	r7,r21
81115a0c:	018010c4 	movi	r6,67
81115a10:	01604574 	movhi	r5,33045
81115a14:	29665804 	addi	r5,r5,-26272
81115a18:	a009883a 	mov	r4,r20
81115a1c:	111daac0 	call	8111daac <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81115a20:	e0bfd984 	addi	r2,fp,-154
81115a24:	1009883a 	mov	r4,r2
81115a28:	111dcc00 	call	8111dcc0 <strlen>
81115a2c:	1007883a 	mov	r3,r2
81115a30:	e0bfd984 	addi	r2,fp,-154
81115a34:	180b883a 	mov	r5,r3
81115a38:	1009883a 	mov	r4,r2
81115a3c:	111706c0 	call	8111706c <ucCrc8wInit>
81115a40:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81115a44:	e13fd703 	ldbu	r4,-164(fp)
81115a48:	e0ffd984 	addi	r3,fp,-154
81115a4c:	e0bfd984 	addi	r2,fp,-154
81115a50:	200f883a 	mov	r7,r4
81115a54:	180d883a 	mov	r6,r3
81115a58:	01604574 	movhi	r5,33045
81115a5c:	29667004 	addi	r5,r5,-26176
81115a60:	1009883a 	mov	r4,r2
81115a64:	111daac0 	call	8111daac <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81115a68:	e0bfd90b 	ldhu	r2,-156(fp)
81115a6c:	10ffffcc 	andi	r3,r2,65535
81115a70:	18e0001c 	xori	r3,r3,32768
81115a74:	18e00004 	addi	r3,r3,-32768
81115a78:	e0bfd984 	addi	r2,fp,-154
81115a7c:	180b883a 	mov	r5,r3
81115a80:	1009883a 	mov	r4,r2
81115a84:	1114f5c0 	call	81114f5c <bSendUART128v2>
81115a88:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81115a8c:	e0bfd817 	ldw	r2,-160(fp)
81115a90:	10800060 	cmpeqi	r2,r2,1
81115a94:	1000011e 	bne	r2,zero,81115a9c <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81115a98:	1117c3c0 	call	81117c3c <vCouldNotSendEthConfUART>
	}
}
81115a9c:	0001883a 	nop
81115aa0:	e6fffa04 	addi	sp,fp,-24
81115aa4:	dfc00717 	ldw	ra,28(sp)
81115aa8:	df000617 	ldw	fp,24(sp)
81115aac:	dd400517 	ldw	r21,20(sp)
81115ab0:	dd000417 	ldw	r20,16(sp)
81115ab4:	dcc00317 	ldw	r19,12(sp)
81115ab8:	dc800217 	ldw	r18,8(sp)
81115abc:	dc400117 	ldw	r17,4(sp)
81115ac0:	dc000017 	ldw	r16,0(sp)
81115ac4:	dec00804 	addi	sp,sp,32
81115ac8:	f800283a 	ret

81115acc <vSendTurnOff>:


void vSendTurnOff ( void ) {
81115acc:	defff304 	addi	sp,sp,-52
81115ad0:	de00012e 	bgeu	sp,et,81115ad8 <vSendTurnOff+0xc>
81115ad4:	003b68fa 	trap	3
81115ad8:	dfc00c15 	stw	ra,48(sp)
81115adc:	df000b15 	stw	fp,44(sp)
81115ae0:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81115ae4:	e03ff78d 	sth	zero,-34(fp)
81115ae8:	e03ff80d 	sth	zero,-32(fp)
81115aec:	e03ff88d 	sth	zero,-30(fp)
81115af0:	e03ff90d 	sth	zero,-28(fp)
81115af4:	e03ff98d 	sth	zero,-26(fp)
81115af8:	e03ffa0d 	sth	zero,-24(fp)
81115afc:	e03ffa8d 	sth	zero,-22(fp)
81115b00:	e03ffb0d 	sth	zero,-20(fp)
81115b04:	e03ffb8d 	sth	zero,-18(fp)
81115b08:	e03ffc0d 	sth	zero,-16(fp)
81115b0c:	e03ffc8d 	sth	zero,-14(fp)
81115b10:	e03ffd0d 	sth	zero,-12(fp)
81115b14:	e03ffd8d 	sth	zero,-10(fp)
81115b18:	e03ffe0d 	sth	zero,-8(fp)
81115b1c:	e03ffe8d 	sth	zero,-6(fp)
81115b20:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81115b24:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115b28:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115b2c:	1115dfc0 	call	81115dfc <usiGetIdCMD>
81115b30:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81115b34:	e0fff70b 	ldhu	r3,-36(fp)
81115b38:	e0bff784 	addi	r2,fp,-34
81115b3c:	180d883a 	mov	r6,r3
81115b40:	01604574 	movhi	r5,33045
81115b44:	29667304 	addi	r5,r5,-26164
81115b48:	1009883a 	mov	r4,r2
81115b4c:	111daac0 	call	8111daac <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81115b50:	e0bff784 	addi	r2,fp,-34
81115b54:	1009883a 	mov	r4,r2
81115b58:	111dcc00 	call	8111dcc0 <strlen>
81115b5c:	1007883a 	mov	r3,r2
81115b60:	e0bff784 	addi	r2,fp,-34
81115b64:	180b883a 	mov	r5,r3
81115b68:	1009883a 	mov	r4,r2
81115b6c:	111706c0 	call	8111706c <ucCrc8wInit>
81115b70:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81115b74:	e13ff503 	ldbu	r4,-44(fp)
81115b78:	e0fff784 	addi	r3,fp,-34
81115b7c:	e0bff784 	addi	r2,fp,-34
81115b80:	200f883a 	mov	r7,r4
81115b84:	180d883a 	mov	r6,r3
81115b88:	01604574 	movhi	r5,33045
81115b8c:	29667004 	addi	r5,r5,-26176
81115b90:	1009883a 	mov	r4,r2
81115b94:	111daac0 	call	8111daac <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81115b98:	e0bff70b 	ldhu	r2,-36(fp)
81115b9c:	10ffffcc 	andi	r3,r2,65535
81115ba0:	18e0001c 	xori	r3,r3,32768
81115ba4:	18e00004 	addi	r3,r3,-32768
81115ba8:	e0bff784 	addi	r2,fp,-34
81115bac:	180b883a 	mov	r5,r3
81115bb0:	1009883a 	mov	r4,r2
81115bb4:	11155440 	call	81115544 <bSendUART32v2>
81115bb8:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81115bbc:	e0bff617 	ldw	r2,-40(fp)
81115bc0:	10800060 	cmpeqi	r2,r2,1
81115bc4:	1000011e 	bne	r2,zero,81115bcc <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81115bc8:	11182e40 	call	811182e4 <vCouldNotSendTurnOff>
	}
}
81115bcc:	0001883a 	nop
81115bd0:	e037883a 	mov	sp,fp
81115bd4:	dfc00117 	ldw	ra,4(sp)
81115bd8:	df000017 	ldw	fp,0(sp)
81115bdc:	dec00204 	addi	sp,sp,8
81115be0:	f800283a 	ret

81115be4 <vSendReset>:

void vSendReset ( void ) {
81115be4:	defff304 	addi	sp,sp,-52
81115be8:	de00012e 	bgeu	sp,et,81115bf0 <vSendReset+0xc>
81115bec:	003b68fa 	trap	3
81115bf0:	dfc00c15 	stw	ra,48(sp)
81115bf4:	df000b15 	stw	fp,44(sp)
81115bf8:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81115bfc:	e03ff78d 	sth	zero,-34(fp)
81115c00:	e03ff80d 	sth	zero,-32(fp)
81115c04:	e03ff88d 	sth	zero,-30(fp)
81115c08:	e03ff90d 	sth	zero,-28(fp)
81115c0c:	e03ff98d 	sth	zero,-26(fp)
81115c10:	e03ffa0d 	sth	zero,-24(fp)
81115c14:	e03ffa8d 	sth	zero,-22(fp)
81115c18:	e03ffb0d 	sth	zero,-20(fp)
81115c1c:	e03ffb8d 	sth	zero,-18(fp)
81115c20:	e03ffc0d 	sth	zero,-16(fp)
81115c24:	e03ffc8d 	sth	zero,-14(fp)
81115c28:	e03ffd0d 	sth	zero,-12(fp)
81115c2c:	e03ffd8d 	sth	zero,-10(fp)
81115c30:	e03ffe0d 	sth	zero,-8(fp)
81115c34:	e03ffe8d 	sth	zero,-6(fp)
81115c38:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81115c3c:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115c40:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115c44:	1115dfc0 	call	81115dfc <usiGetIdCMD>
81115c48:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81115c4c:	e0fff70b 	ldhu	r3,-36(fp)
81115c50:	e0bff784 	addi	r2,fp,-34
81115c54:	180d883a 	mov	r6,r3
81115c58:	01604574 	movhi	r5,33045
81115c5c:	29667504 	addi	r5,r5,-26156
81115c60:	1009883a 	mov	r4,r2
81115c64:	111daac0 	call	8111daac <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81115c68:	e0bff784 	addi	r2,fp,-34
81115c6c:	1009883a 	mov	r4,r2
81115c70:	111dcc00 	call	8111dcc0 <strlen>
81115c74:	1007883a 	mov	r3,r2
81115c78:	e0bff784 	addi	r2,fp,-34
81115c7c:	180b883a 	mov	r5,r3
81115c80:	1009883a 	mov	r4,r2
81115c84:	111706c0 	call	8111706c <ucCrc8wInit>
81115c88:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81115c8c:	e13ff503 	ldbu	r4,-44(fp)
81115c90:	e0fff784 	addi	r3,fp,-34
81115c94:	e0bff784 	addi	r2,fp,-34
81115c98:	200f883a 	mov	r7,r4
81115c9c:	180d883a 	mov	r6,r3
81115ca0:	01604574 	movhi	r5,33045
81115ca4:	29667004 	addi	r5,r5,-26176
81115ca8:	1009883a 	mov	r4,r2
81115cac:	111daac0 	call	8111daac <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81115cb0:	e0bff70b 	ldhu	r2,-36(fp)
81115cb4:	10ffffcc 	andi	r3,r2,65535
81115cb8:	18e0001c 	xori	r3,r3,32768
81115cbc:	18e00004 	addi	r3,r3,-32768
81115cc0:	e0bff784 	addi	r2,fp,-34
81115cc4:	180b883a 	mov	r5,r3
81115cc8:	1009883a 	mov	r4,r2
81115ccc:	11155440 	call	81115544 <bSendUART32v2>
81115cd0:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81115cd4:	e0bff617 	ldw	r2,-40(fp)
81115cd8:	10800060 	cmpeqi	r2,r2,1
81115cdc:	1000011e 	bne	r2,zero,81115ce4 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81115ce0:	11182e40 	call	811182e4 <vCouldNotSendTurnOff>
	}
}
81115ce4:	0001883a 	nop
81115ce8:	e037883a 	mov	sp,fp
81115cec:	dfc00117 	ldw	ra,4(sp)
81115cf0:	df000017 	ldw	fp,0(sp)
81115cf4:	dec00204 	addi	sp,sp,8
81115cf8:	f800283a 	ret

81115cfc <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81115cfc:	deffda04 	addi	sp,sp,-152
81115d00:	de00012e 	bgeu	sp,et,81115d08 <vSendLog+0xc>
81115d04:	003b68fa 	trap	3
81115d08:	dfc02515 	stw	ra,148(sp)
81115d0c:	df002415 	stw	fp,144(sp)
81115d10:	df002404 	addi	fp,sp,144
81115d14:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
81115d18:	e03fde8d 	sth	zero,-134(fp)
81115d1c:	e03fdf0d 	sth	zero,-132(fp)
81115d20:	e0bfdf84 	addi	r2,fp,-130
81115d24:	00c01f04 	movi	r3,124
81115d28:	180d883a 	mov	r6,r3
81115d2c:	000b883a 	mov	r5,zero
81115d30:	1009883a 	mov	r4,r2
81115d34:	111d31c0 	call	8111d31c <memset>
    unsigned char crc = 0;
81115d38:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115d3c:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115d40:	1115dfc0 	call	81115dfc <usiGetIdCMD>
81115d44:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81115d48:	e0ffde0b 	ldhu	r3,-136(fp)
81115d4c:	e0bfde84 	addi	r2,fp,-134
81115d50:	e1ffff17 	ldw	r7,-4(fp)
81115d54:	180d883a 	mov	r6,r3
81115d58:	01604574 	movhi	r5,33045
81115d5c:	29667704 	addi	r5,r5,-26148
81115d60:	1009883a 	mov	r4,r2
81115d64:	111daac0 	call	8111daac <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
81115d68:	e0bfde84 	addi	r2,fp,-134
81115d6c:	1009883a 	mov	r4,r2
81115d70:	111dcc00 	call	8111dcc0 <strlen>
81115d74:	1007883a 	mov	r3,r2
81115d78:	e0bfde84 	addi	r2,fp,-134
81115d7c:	180b883a 	mov	r5,r3
81115d80:	1009883a 	mov	r4,r2
81115d84:	111706c0 	call	8111706c <ucCrc8wInit>
81115d88:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
81115d8c:	e13fdc03 	ldbu	r4,-144(fp)
81115d90:	e0ffde84 	addi	r3,fp,-134
81115d94:	e0bfde84 	addi	r2,fp,-134
81115d98:	200f883a 	mov	r7,r4
81115d9c:	180d883a 	mov	r6,r3
81115da0:	01604574 	movhi	r5,33045
81115da4:	29667004 	addi	r5,r5,-26176
81115da8:	1009883a 	mov	r4,r2
81115dac:	111daac0 	call	8111daac <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
81115db0:	e0bfde0b 	ldhu	r2,-136(fp)
81115db4:	10ffffcc 	andi	r3,r2,65535
81115db8:	18e0001c 	xori	r3,r3,32768
81115dbc:	18e00004 	addi	r3,r3,-32768
81115dc0:	e0bfde84 	addi	r2,fp,-134
81115dc4:	180b883a 	mov	r5,r3
81115dc8:	1009883a 	mov	r4,r2
81115dcc:	1114f5c0 	call	81114f5c <bSendUART128v2>
81115dd0:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81115dd4:	e0bfdd17 	ldw	r2,-140(fp)
81115dd8:	10800060 	cmpeqi	r2,r2,1
81115ddc:	1000011e 	bne	r2,zero,81115de4 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
81115de0:	11183b40 	call	811183b4 <vCouldNotSendLog>
	}
}
81115de4:	0001883a 	nop
81115de8:	e037883a 	mov	sp,fp
81115dec:	dfc00117 	ldw	ra,4(sp)
81115df0:	df000017 	ldw	fp,0(sp)
81115df4:	dec00204 	addi	sp,sp,8
81115df8:	f800283a 	ret

81115dfc <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81115dfc:	deffff04 	addi	sp,sp,-4
81115e00:	de00012e 	bgeu	sp,et,81115e08 <usiGetIdCMD+0xc>
81115e04:	003b68fa 	trap	3
81115e08:	df000015 	stw	fp,0(sp)
81115e0c:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
81115e10:	d0a0630b 	ldhu	r2,-32372(gp)
81115e14:	10ffffcc 	andi	r3,r2,65535
81115e18:	00bfffd4 	movui	r2,65535
81115e1c:	1880031e 	bne	r3,r2,81115e2c <usiGetIdCMD+0x30>
        usiIdCMD = 2;
81115e20:	00800084 	movi	r2,2
81115e24:	d0a0630d 	sth	r2,-32372(gp)
81115e28:	00000306 	br	81115e38 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81115e2c:	d0a0630b 	ldhu	r2,-32372(gp)
81115e30:	10800044 	addi	r2,r2,1
81115e34:	d0a0630d 	sth	r2,-32372(gp)

    return usiIdCMD;
81115e38:	d0a0630b 	ldhu	r2,-32372(gp)
}
81115e3c:	e037883a 	mov	sp,fp
81115e40:	df000017 	ldw	fp,0(sp)
81115e44:	dec00104 	addi	sp,sp,4
81115e48:	f800283a 	ret

81115e4c <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
81115e4c:	defffb04 	addi	sp,sp,-20
81115e50:	de00012e 	bgeu	sp,et,81115e58 <siPosStr+0xc>
81115e54:	003b68fa 	trap	3
81115e58:	dfc00415 	stw	ra,16(sp)
81115e5c:	df000315 	stw	fp,12(sp)
81115e60:	df000304 	addi	fp,sp,12
81115e64:	e13ffe15 	stw	r4,-8(fp)
81115e68:	2805883a 	mov	r2,r5
81115e6c:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
81115e70:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
81115e74:	e0bfff03 	ldbu	r2,-4(fp)
81115e78:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
81115e7c:	e17ffd04 	addi	r5,fp,-12
81115e80:	e13ffe17 	ldw	r4,-8(fp)
81115e84:	111dc740 	call	8111dc74 <strcspn>
}
81115e88:	e037883a 	mov	sp,fp
81115e8c:	dfc00117 	ldw	ra,4(sp)
81115e90:	df000017 	ldw	fp,0(sp)
81115e94:	dec00204 	addi	sp,sp,8
81115e98:	f800283a 	ret

81115e9c <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
81115e9c:	defffc04 	addi	sp,sp,-16
81115ea0:	de00012e 	bgeu	sp,et,81115ea8 <vTimeoutCheck+0xc>
81115ea4:	003b68fa 	trap	3
81115ea8:	dfc00315 	stw	ra,12(sp)
81115eac:	df000215 	stw	fp,8(sp)
81115eb0:	df000204 	addi	fp,sp,8
81115eb4:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
81115eb8:	d0a06217 	ldw	r2,-32376(gp)
81115ebc:	1009883a 	mov	r4,r2
81115ec0:	113a5800 	call	8113a580 <OSSemPost>
81115ec4:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
81115ec8:	e0bffe03 	ldbu	r2,-8(fp)
81115ecc:	10000126 	beq	r2,zero,81115ed4 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
81115ed0:	11180740 	call	81118074 <vFailPostBlockingSemTimeoutTask>
	}
}
81115ed4:	0001883a 	nop
81115ed8:	e037883a 	mov	sp,fp
81115edc:	dfc00117 	ldw	ra,4(sp)
81115ee0:	df000017 	ldw	fp,0(sp)
81115ee4:	dec00204 	addi	sp,sp,8
81115ee8:	f800283a 	ret

81115eec <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81115eec:	deffe304 	addi	sp,sp,-116
81115ef0:	de00012e 	bgeu	sp,et,81115ef8 <vSendPusTM64+0xc>
81115ef4:	003b68fa 	trap	3
81115ef8:	dfc01815 	stw	ra,96(sp)
81115efc:	df001715 	stw	fp,92(sp)
81115f00:	df001704 	addi	fp,sp,92
81115f04:	e1000215 	stw	r4,8(fp)
81115f08:	e1400315 	stw	r5,12(fp)
81115f0c:	e1800415 	stw	r6,16(fp)
81115f10:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81115f14:	e03fef8d 	sth	zero,-66(fp)
81115f18:	e03ff00d 	sth	zero,-64(fp)
81115f1c:	e0bff084 	addi	r2,fp,-62
81115f20:	00c00f04 	movi	r3,60
81115f24:	180d883a 	mov	r6,r3
81115f28:	000b883a 	mov	r5,zero
81115f2c:	1009883a 	mov	r4,r2
81115f30:	111d31c0 	call	8111d31c <memset>
    unsigned char crc = 0;
81115f34:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81115f38:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115f3c:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115f40:	1115dfc0 	call	81115dfc <usiGetIdCMD>
81115f44:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81115f48:	e1bfef0b 	ldhu	r6,-68(fp)
81115f4c:	e080040b 	ldhu	r2,16(fp)
81115f50:	11ffffcc 	andi	r7,r2,65535
81115f54:	e080048b 	ldhu	r2,18(fp)
81115f58:	10bfffcc 	andi	r2,r2,65535
81115f5c:	e0c0050b 	ldhu	r3,20(fp)
81115f60:	18ffffcc 	andi	r3,r3,65535
81115f64:	e100058b 	ldhu	r4,22(fp)
81115f68:	213fffcc 	andi	r4,r4,65535
81115f6c:	e140060b 	ldhu	r5,24(fp)
81115f70:	297fffcc 	andi	r5,r5,65535
81115f74:	e23fef84 	addi	r8,fp,-66
81115f78:	d9400315 	stw	r5,12(sp)
81115f7c:	d9000215 	stw	r4,8(sp)
81115f80:	d8c00115 	stw	r3,4(sp)
81115f84:	d8800015 	stw	r2,0(sp)
81115f88:	01604574 	movhi	r5,33045
81115f8c:	29667a04 	addi	r5,r5,-26136
81115f90:	4009883a 	mov	r4,r8
81115f94:	111daac0 	call	8111daac <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81115f98:	e03fed05 	stb	zero,-76(fp)
81115f9c:	00001206 	br	81115fe8 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81115fa0:	e0bfed03 	ldbu	r2,-76(fp)
81115fa4:	10800284 	addi	r2,r2,10
81115fa8:	1085883a 	add	r2,r2,r2
81115fac:	e0c00204 	addi	r3,fp,8
81115fb0:	1885883a 	add	r2,r3,r2
81115fb4:	1080000b 	ldhu	r2,0(r2)
81115fb8:	113fffcc 	andi	r4,r2,65535
81115fbc:	e0ffef84 	addi	r3,fp,-66
81115fc0:	e0bfef84 	addi	r2,fp,-66
81115fc4:	200f883a 	mov	r7,r4
81115fc8:	180d883a 	mov	r6,r3
81115fcc:	01604574 	movhi	r5,33045
81115fd0:	29668104 	addi	r5,r5,-26108
81115fd4:	1009883a 	mov	r4,r2
81115fd8:	111daac0 	call	8111daac <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81115fdc:	e0bfed03 	ldbu	r2,-76(fp)
81115fe0:	10800044 	addi	r2,r2,1
81115fe4:	e0bfed05 	stb	r2,-76(fp)
81115fe8:	e0800683 	ldbu	r2,26(fp)
81115fec:	10803fcc 	andi	r2,r2,255
81115ff0:	e0ffed03 	ldbu	r3,-76(fp)
81115ff4:	18bfea36 	bltu	r3,r2,81115fa0 <__reset+0xfb0f5fa0>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81115ff8:	e0bfef84 	addi	r2,fp,-66
81115ffc:	1009883a 	mov	r4,r2
81116000:	111dcc00 	call	8111dcc0 <strlen>
81116004:	1007883a 	mov	r3,r2
81116008:	e0bfef84 	addi	r2,fp,-66
8111600c:	180b883a 	mov	r5,r3
81116010:	1009883a 	mov	r4,r2
81116014:	111706c0 	call	8111706c <ucCrc8wInit>
81116018:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111601c:	e13fed43 	ldbu	r4,-75(fp)
81116020:	e0ffef84 	addi	r3,fp,-66
81116024:	e0bfef84 	addi	r2,fp,-66
81116028:	200f883a 	mov	r7,r4
8111602c:	180d883a 	mov	r6,r3
81116030:	01604574 	movhi	r5,33045
81116034:	29667004 	addi	r5,r5,-26176
81116038:	1009883a 	mov	r4,r2
8111603c:	111daac0 	call	8111daac <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81116040:	e0bfef0b 	ldhu	r2,-68(fp)
81116044:	10ffffcc 	andi	r3,r2,65535
81116048:	18e0001c 	xori	r3,r3,32768
8111604c:	18e00004 	addi	r3,r3,-32768
81116050:	e0bfef84 	addi	r2,fp,-66
81116054:	180b883a 	mov	r5,r3
81116058:	1009883a 	mov	r4,r2
8111605c:	111524c0 	call	8111524c <bSendUART64v2>
81116060:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
81116064:	e0bfee17 	ldw	r2,-72(fp)
81116068:	10800060 	cmpeqi	r2,r2,1
8111606c:	1000031e 	bne	r2,zero,8111607c <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81116070:	e0bfef84 	addi	r2,fp,-66
81116074:	1009883a 	mov	r4,r2
81116078:	111841c0 	call	8111841c <vCouldNotSendTMPusCommand>
	}
}
8111607c:	0001883a 	nop
81116080:	e037883a 	mov	sp,fp
81116084:	dfc00117 	ldw	ra,4(sp)
81116088:	df000017 	ldw	fp,0(sp)
8111608c:	dec00604 	addi	sp,sp,24
81116090:	f800283a 	ret

81116094 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
81116094:	deffd304 	addi	sp,sp,-180
81116098:	de00012e 	bgeu	sp,et,811160a0 <vSendPusTM128+0xc>
8111609c:	003b68fa 	trap	3
811160a0:	dfc02815 	stw	ra,160(sp)
811160a4:	df002715 	stw	fp,156(sp)
811160a8:	df002704 	addi	fp,sp,156
811160ac:	e1000215 	stw	r4,8(fp)
811160b0:	e1400315 	stw	r5,12(fp)
811160b4:	e1800415 	stw	r6,16(fp)
811160b8:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
811160bc:	e03fdf8d 	sth	zero,-130(fp)
811160c0:	e03fe00d 	sth	zero,-128(fp)
811160c4:	e0bfe084 	addi	r2,fp,-126
811160c8:	00c01f04 	movi	r3,124
811160cc:	180d883a 	mov	r6,r3
811160d0:	000b883a 	mov	r5,zero
811160d4:	1009883a 	mov	r4,r2
811160d8:	111d31c0 	call	8111d31c <memset>
    unsigned char crc = 0;
811160dc:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
811160e0:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
811160e4:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
811160e8:	1115dfc0 	call	81115dfc <usiGetIdCMD>
811160ec:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
811160f0:	e1bfdf0b 	ldhu	r6,-132(fp)
811160f4:	e080040b 	ldhu	r2,16(fp)
811160f8:	11ffffcc 	andi	r7,r2,65535
811160fc:	e080048b 	ldhu	r2,18(fp)
81116100:	10bfffcc 	andi	r2,r2,65535
81116104:	e0c0050b 	ldhu	r3,20(fp)
81116108:	18ffffcc 	andi	r3,r3,65535
8111610c:	e100058b 	ldhu	r4,22(fp)
81116110:	213fffcc 	andi	r4,r4,65535
81116114:	e140060b 	ldhu	r5,24(fp)
81116118:	297fffcc 	andi	r5,r5,65535
8111611c:	e23fdf84 	addi	r8,fp,-130
81116120:	d9400315 	stw	r5,12(sp)
81116124:	d9000215 	stw	r4,8(sp)
81116128:	d8c00115 	stw	r3,4(sp)
8111612c:	d8800015 	stw	r2,0(sp)
81116130:	01604574 	movhi	r5,33045
81116134:	29667a04 	addi	r5,r5,-26136
81116138:	4009883a 	mov	r4,r8
8111613c:	111daac0 	call	8111daac <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81116140:	e03fdd05 	stb	zero,-140(fp)
81116144:	00001206 	br	81116190 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81116148:	e0bfdd03 	ldbu	r2,-140(fp)
8111614c:	10800284 	addi	r2,r2,10
81116150:	1085883a 	add	r2,r2,r2
81116154:	e0c00204 	addi	r3,fp,8
81116158:	1885883a 	add	r2,r3,r2
8111615c:	1080000b 	ldhu	r2,0(r2)
81116160:	113fffcc 	andi	r4,r2,65535
81116164:	e0ffdf84 	addi	r3,fp,-130
81116168:	e0bfdf84 	addi	r2,fp,-130
8111616c:	200f883a 	mov	r7,r4
81116170:	180d883a 	mov	r6,r3
81116174:	01604574 	movhi	r5,33045
81116178:	29668104 	addi	r5,r5,-26108
8111617c:	1009883a 	mov	r4,r2
81116180:	111daac0 	call	8111daac <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81116184:	e0bfdd03 	ldbu	r2,-140(fp)
81116188:	10800044 	addi	r2,r2,1
8111618c:	e0bfdd05 	stb	r2,-140(fp)
81116190:	e0800683 	ldbu	r2,26(fp)
81116194:	10803fcc 	andi	r2,r2,255
81116198:	e0ffdd03 	ldbu	r3,-140(fp)
8111619c:	18bfea36 	bltu	r3,r2,81116148 <__reset+0xfb0f6148>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
811161a0:	e0bfdf84 	addi	r2,fp,-130
811161a4:	1009883a 	mov	r4,r2
811161a8:	111dcc00 	call	8111dcc0 <strlen>
811161ac:	1007883a 	mov	r3,r2
811161b0:	e0bfdf84 	addi	r2,fp,-130
811161b4:	180b883a 	mov	r5,r3
811161b8:	1009883a 	mov	r4,r2
811161bc:	111706c0 	call	8111706c <ucCrc8wInit>
811161c0:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
811161c4:	e13fdd43 	ldbu	r4,-139(fp)
811161c8:	e0ffdf84 	addi	r3,fp,-130
811161cc:	e0bfdf84 	addi	r2,fp,-130
811161d0:	200f883a 	mov	r7,r4
811161d4:	180d883a 	mov	r6,r3
811161d8:	01604574 	movhi	r5,33045
811161dc:	29667004 	addi	r5,r5,-26176
811161e0:	1009883a 	mov	r4,r2
811161e4:	111daac0 	call	8111daac <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
811161e8:	e0bfdf0b 	ldhu	r2,-132(fp)
811161ec:	10ffffcc 	andi	r3,r2,65535
811161f0:	18e0001c 	xori	r3,r3,32768
811161f4:	18e00004 	addi	r3,r3,-32768
811161f8:	e0bfdf84 	addi	r2,fp,-130
811161fc:	180b883a 	mov	r5,r3
81116200:	1009883a 	mov	r4,r2
81116204:	1114f5c0 	call	81114f5c <bSendUART128v2>
81116208:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
8111620c:	e0bfde17 	ldw	r2,-136(fp)
81116210:	10800060 	cmpeqi	r2,r2,1
81116214:	1000031e 	bne	r2,zero,81116224 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81116218:	e0bfdf84 	addi	r2,fp,-130
8111621c:	1009883a 	mov	r4,r2
81116220:	111841c0 	call	8111841c <vCouldNotSendTMPusCommand>
	}
}
81116224:	0001883a 	nop
81116228:	e037883a 	mov	sp,fp
8111622c:	dfc00117 	ldw	ra,4(sp)
81116230:	df000017 	ldw	fp,0(sp)
81116234:	dec00604 	addi	sp,sp,24
81116238:	f800283a 	ret

8111623c <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
8111623c:	deffd704 	addi	sp,sp,-164
81116240:	de00012e 	bgeu	sp,et,81116248 <vTMPusTestConnection+0xc>
81116244:	003b68fa 	trap	3
81116248:	dfc02815 	stw	ra,160(sp)
8111624c:	df002715 	stw	fp,156(sp)
81116250:	df002704 	addi	fp,sp,156
81116254:	2005883a 	mov	r2,r4
81116258:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
8111625c:	e0bfff0b 	ldhu	r2,-4(fp)
81116260:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81116264:	00801c04 	movi	r2,112
81116268:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
8111626c:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
81116270:	00800444 	movi	r2,17
81116274:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81116278:	00800084 	movi	r2,2
8111627c:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81116280:	d809883a 	mov	r4,sp
81116284:	e0bfee04 	addi	r2,fp,-72
81116288:	00c01104 	movi	r3,68
8111628c:	180d883a 	mov	r6,r3
81116290:	100b883a 	mov	r5,r2
81116294:	111d1cc0 	call	8111d1cc <memcpy>
81116298:	e13fea17 	ldw	r4,-88(fp)
8111629c:	e17feb17 	ldw	r5,-84(fp)
811162a0:	e1bfec17 	ldw	r6,-80(fp)
811162a4:	e1ffed17 	ldw	r7,-76(fp)
811162a8:	1115eec0 	call	81115eec <vSendPusTM64>
}
811162ac:	0001883a 	nop
811162b0:	e037883a 	mov	sp,fp
811162b4:	dfc00117 	ldw	ra,4(sp)
811162b8:	df000017 	ldw	fp,0(sp)
811162bc:	dec00204 	addi	sp,sp,8
811162c0:	f800283a 	ret

811162c4 <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
811162c4:	defff504 	addi	sp,sp,-44
811162c8:	de00012e 	bgeu	sp,et,811162d0 <vLoadDefaultETHConf+0xc>
811162cc:	003b68fa 	trap	3
811162d0:	dfc00a15 	stw	ra,40(sp)
811162d4:	df000915 	stw	fp,36(sp)
811162d8:	dc000815 	stw	r16,32(sp)
811162dc:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
811162e0:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
811162e4:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
811162e8:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
811162ec:	d0a07117 	ldw	r2,-32316(gp)
811162f0:	10800058 	cmpnei	r2,r2,1
811162f4:	1002041e 	bne	r2,zero,81116b08 <vLoadDefaultETHConf+0x844>
811162f8:	111a1080 	call	8111a108 <bSDcardIsPresent>
811162fc:	10020226 	beq	r2,zero,81116b08 <vLoadDefaultETHConf+0x844>
81116300:	111a1380 	call	8111a138 <bSDcardFAT16Check>
81116304:	10020026 	beq	r2,zero,81116b08 <vLoadDefaultETHConf+0x844>

		siFile = siOpenFile( ETH_FILE_NAME );
81116308:	01204574 	movhi	r4,33045
8111630c:	21268304 	addi	r4,r4,-26100
81116310:	111a2600 	call	8111a260 <siOpenFile>
81116314:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81116318:	e0bffc0f 	ldh	r2,-16(fp)
8111631c:	1001f216 	blt	r2,zero,81116ae8 <vLoadDefaultETHConf+0x824>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81116320:	e0bffd04 	addi	r2,fp,-12
81116324:	01800204 	movi	r6,8
81116328:	01400284 	movi	r5,10
8111632c:	1009883a 	mov	r4,r2
81116330:	111d31c0 	call	8111d31c <memset>
			p_inteiro = inteiro;
81116334:	e0bffd04 	addi	r2,fp,-12
81116338:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
8111633c:	e0bffc0f 	ldh	r2,-16(fp)
81116340:	1009883a 	mov	r4,r2
81116344:	111a2dc0 	call	8111a2dc <cGetNextChar>
81116348:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
8111634c:	e0bff947 	ldb	r2,-27(fp)
81116350:	10800084 	addi	r2,r2,2
81116354:	10c015a8 	cmpgeui	r3,r2,86
81116358:	1801d71e 	bne	r3,zero,81116ab8 <vLoadDefaultETHConf+0x7f4>
8111635c:	100690ba 	slli	r3,r2,2
81116360:	00a04474 	movhi	r2,33041
81116364:	1098dd04 	addi	r2,r2,25460
81116368:	1885883a 	add	r2,r3,r2
8111636c:	10800017 	ldw	r2,0(r2)
81116370:	1000683a 	jmp	r2
81116374:	8111650c 	andi	r4,r16,17812
81116378:	81116500 	call	88111650 <__reset+0x20f1650>
8111637c:	81116ab8 	rdprs	r4,r16,17834
81116380:	81116ab8 	rdprs	r4,r16,17834
81116384:	81116ab8 	rdprs	r4,r16,17834
81116388:	81116ab8 	rdprs	r4,r16,17834
8111638c:	81116ab8 	rdprs	r4,r16,17834
81116390:	81116ab8 	rdprs	r4,r16,17834
81116394:	81116ab8 	rdprs	r4,r16,17834
81116398:	81116ab8 	rdprs	r4,r16,17834
8111639c:	81116ab8 	rdprs	r4,r16,17834
811163a0:	81116ab8 	rdprs	r4,r16,17834
811163a4:	81116ad8 	cmpnei	r4,r16,17835
811163a8:	81116ab8 	rdprs	r4,r16,17834
811163ac:	81116ab8 	rdprs	r4,r16,17834
811163b0:	81116ad8 	cmpnei	r4,r16,17835
811163b4:	81116ab8 	rdprs	r4,r16,17834
811163b8:	81116ab8 	rdprs	r4,r16,17834
811163bc:	81116ab8 	rdprs	r4,r16,17834
811163c0:	81116ab8 	rdprs	r4,r16,17834
811163c4:	81116ab8 	rdprs	r4,r16,17834
811163c8:	81116ab8 	rdprs	r4,r16,17834
811163cc:	81116ab8 	rdprs	r4,r16,17834
811163d0:	81116ab8 	rdprs	r4,r16,17834
811163d4:	81116ab8 	rdprs	r4,r16,17834
811163d8:	81116ab8 	rdprs	r4,r16,17834
811163dc:	81116ab8 	rdprs	r4,r16,17834
811163e0:	81116ab8 	rdprs	r4,r16,17834
811163e4:	81116ab8 	rdprs	r4,r16,17834
811163e8:	81116ab8 	rdprs	r4,r16,17834
811163ec:	81116ab8 	rdprs	r4,r16,17834
811163f0:	81116ab8 	rdprs	r4,r16,17834
811163f4:	81116ab8 	rdprs	r4,r16,17834
811163f8:	81116ab8 	rdprs	r4,r16,17834
811163fc:	81116ad8 	cmpnei	r4,r16,17835
81116400:	81116ab8 	rdprs	r4,r16,17834
81116404:	81116ab8 	rdprs	r4,r16,17834
81116408:	81116ab8 	rdprs	r4,r16,17834
8111640c:	81116ab8 	rdprs	r4,r16,17834
81116410:	81116ab8 	rdprs	r4,r16,17834
81116414:	81116ab8 	rdprs	r4,r16,17834
81116418:	811164cc 	andi	r4,r16,17811
8111641c:	81116ab8 	rdprs	r4,r16,17834
81116420:	81116ab8 	rdprs	r4,r16,17834
81116424:	81116ab8 	rdprs	r4,r16,17834
81116428:	81116ab8 	rdprs	r4,r16,17834
8111642c:	81116ab8 	rdprs	r4,r16,17834
81116430:	81116ab8 	rdprs	r4,r16,17834
81116434:	81116ab8 	rdprs	r4,r16,17834
81116438:	81116ab8 	rdprs	r4,r16,17834
8111643c:	81116ab8 	rdprs	r4,r16,17834
81116440:	81116ab8 	rdprs	r4,r16,17834
81116444:	81116ab8 	rdprs	r4,r16,17834
81116448:	81116ab8 	rdprs	r4,r16,17834
8111644c:	81116ab8 	rdprs	r4,r16,17834
81116450:	81116ab8 	rdprs	r4,r16,17834
81116454:	81116ab8 	rdprs	r4,r16,17834
81116458:	81116ab8 	rdprs	r4,r16,17834
8111645c:	81116ab8 	rdprs	r4,r16,17834
81116460:	81116ab8 	rdprs	r4,r16,17834
81116464:	81116ab8 	rdprs	r4,r16,17834
81116468:	81116ab8 	rdprs	r4,r16,17834
8111646c:	81116a70 	cmpltui	r4,r16,17833
81116470:	81116ab8 	rdprs	r4,r16,17834
81116474:	81116ab8 	rdprs	r4,r16,17834
81116478:	81116ab8 	rdprs	r4,r16,17834
8111647c:	81116ab8 	rdprs	r4,r16,17834
81116480:	81116ab8 	rdprs	r4,r16,17834
81116484:	81116ab8 	rdprs	r4,r16,17834
81116488:	81116ab8 	rdprs	r4,r16,17834
8111648c:	81116870 	cmpltui	r4,r16,17825
81116490:	81116ab8 	rdprs	r4,r16,17834
81116494:	81116ab8 	rdprs	r4,r16,17834
81116498:	811166d0 	cmplti	r4,r16,17819
8111649c:	811169c8 	cmpgei	r4,r16,17831
811164a0:	81116604 	addi	r4,r16,17816
811164a4:	81116ab8 	rdprs	r4,r16,17834
811164a8:	81116ab8 	rdprs	r4,r16,17834
811164ac:	81116ab8 	rdprs	r4,r16,17834
811164b0:	81116534 	orhi	r4,r16,17812
811164b4:	81116ab8 	rdprs	r4,r16,17834
811164b8:	81116ab8 	rdprs	r4,r16,17834
811164bc:	81116940 	call	88111694 <__reset+0x20f1694>
811164c0:	81116ab8 	rdprs	r4,r16,17834
811164c4:	81116ab8 	rdprs	r4,r16,17834
811164c8:	811167a0 	cmpeqi	r4,r16,17822
					case 39:// single quote '
						c = cGetNextChar(siFile);
811164cc:	e0bffc0f 	ldh	r2,-16(fp)
811164d0:	1009883a 	mov	r4,r2
811164d4:	111a2dc0 	call	8111a2dc <cGetNextChar>
811164d8:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
811164dc:	00000406 	br	811164f0 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
811164e0:	e0bffc0f 	ldh	r2,-16(fp)
811164e4:	1009883a 	mov	r4,r2
811164e8:	111a2dc0 	call	8111a2dc <cGetNextChar>
811164ec:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
811164f0:	e0bff947 	ldb	r2,-27(fp)
811164f4:	108009d8 	cmpnei	r2,r2,39
811164f8:	103ff91e 	bne	r2,zero,811164e0 <__reset+0xfb0f64e0>
							c = cGetNextChar(siFile);
						}
						break;
811164fc:	00017706 	br	81116adc <vLoadDefaultETHConf+0x818>
					case -1: 	//EOF
						bEOF = TRUE;
81116500:	00800044 	movi	r2,1
81116504:	e0bff815 	stw	r2,-32(fp)
						break;
81116508:	00017406 	br	81116adc <vLoadDefaultETHConf+0x818>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
8111650c:	d0a05d17 	ldw	r2,-32396(gp)
81116510:	100f883a 	mov	r7,r2
81116514:	018006c4 	movi	r6,27
81116518:	01400044 	movi	r5,1
8111651c:	01204574 	movhi	r4,33045
81116520:	21268504 	addi	r4,r4,-26092
81116524:	111c7b80 	call	8111c7b8 <fwrite>
						#endif
						bEOF = TRUE;
81116528:	00800044 	movi	r2,1
8111652c:	e0bff815 	stw	r2,-32(fp)
						break;
81116530:	00016a06 	br	81116adc <vLoadDefaultETHConf+0x818>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81116534:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116538:	e0bffc0f 	ldh	r2,-16(fp)
8111653c:	1009883a 	mov	r4,r2
81116540:	111a2dc0 	call	8111a2dc <cGetNextChar>
81116544:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81116548:	d0e00317 	ldw	r3,-32756(gp)
8111654c:	e0bff947 	ldb	r2,-27(fp)
81116550:	10800044 	addi	r2,r2,1
81116554:	1885883a 	add	r2,r3,r2
81116558:	10800003 	ldbu	r2,0(r2)
8111655c:	10803fcc 	andi	r2,r2,255
81116560:	1080010c 	andi	r2,r2,4
81116564:	10000626 	beq	r2,zero,81116580 <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
81116568:	e0bffa17 	ldw	r2,-24(fp)
8111656c:	e0fff943 	ldbu	r3,-27(fp)
81116570:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81116574:	e0bffa17 	ldw	r2,-24(fp)
81116578:	10800044 	addi	r2,r2,1
8111657c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
81116580:	e0bff947 	ldb	r2,-27(fp)
81116584:	10800ea0 	cmpeqi	r2,r2,58
81116588:	1000031e 	bne	r2,zero,81116598 <vLoadDefaultETHConf+0x2d4>
8111658c:	e0bff947 	ldb	r2,-27(fp)
81116590:	10800ed8 	cmpnei	r2,r2,59
81116594:	103fe81e 	bne	r2,zero,81116538 <__reset+0xfb0f6538>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116598:	e0bffa17 	ldw	r2,-24(fp)
8111659c:	00c00284 	movi	r3,10
811165a0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
811165a4:	e0bff903 	ldbu	r2,-28(fp)
811165a8:	10800168 	cmpgeui	r2,r2,5
811165ac:	1000021e 	bne	r2,zero,811165b8 <vLoadDefaultETHConf+0x2f4>
811165b0:	e43ff903 	ldbu	r16,-28(fp)
811165b4:	00000106 	br	811165bc <vLoadDefaultETHConf+0x2f8>
811165b8:	04000144 	movi	r16,5
811165bc:	e0bffd04 	addi	r2,fp,-12
811165c0:	1009883a 	mov	r4,r2
811165c4:	111bfc00 	call	8111bfc0 <atoi>
811165c8:	1007883a 	mov	r3,r2
811165cc:	00a045b4 	movhi	r2,33046
811165d0:	10860504 	addi	r2,r2,6164
811165d4:	1405883a 	add	r2,r2,r16
811165d8:	10800404 	addi	r2,r2,16
811165dc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811165e0:	e0bffd04 	addi	r2,fp,-12
811165e4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811165e8:	e0bff903 	ldbu	r2,-28(fp)
811165ec:	10800044 	addi	r2,r2,1
811165f0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811165f4:	e0bff947 	ldb	r2,-27(fp)
811165f8:	10800ed8 	cmpnei	r2,r2,59
811165fc:	103fce1e 	bne	r2,zero,81116538 <__reset+0xfb0f6538>

						break;
81116600:	00013606 	br	81116adc <vLoadDefaultETHConf+0x818>
					case 'I':

						ucParser = 0;
81116604:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116608:	e0bffc0f 	ldh	r2,-16(fp)
8111660c:	1009883a 	mov	r4,r2
81116610:	111a2dc0 	call	8111a2dc <cGetNextChar>
81116614:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81116618:	d0e00317 	ldw	r3,-32756(gp)
8111661c:	e0bff947 	ldb	r2,-27(fp)
81116620:	10800044 	addi	r2,r2,1
81116624:	1885883a 	add	r2,r3,r2
81116628:	10800003 	ldbu	r2,0(r2)
8111662c:	10803fcc 	andi	r2,r2,255
81116630:	1080010c 	andi	r2,r2,4
81116634:	10000626 	beq	r2,zero,81116650 <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
81116638:	e0bffa17 	ldw	r2,-24(fp)
8111663c:	e0fff943 	ldbu	r3,-27(fp)
81116640:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81116644:	e0bffa17 	ldw	r2,-24(fp)
81116648:	10800044 	addi	r2,r2,1
8111664c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81116650:	e0bff947 	ldb	r2,-27(fp)
81116654:	10800ba0 	cmpeqi	r2,r2,46
81116658:	1000031e 	bne	r2,zero,81116668 <vLoadDefaultETHConf+0x3a4>
8111665c:	e0bff947 	ldb	r2,-27(fp)
81116660:	10800ed8 	cmpnei	r2,r2,59
81116664:	103fe81e 	bne	r2,zero,81116608 <__reset+0xfb0f6608>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116668:	e0bffa17 	ldw	r2,-24(fp)
8111666c:	00c00284 	movi	r3,10
81116670:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81116674:	e0bff903 	ldbu	r2,-28(fp)
81116678:	108000e8 	cmpgeui	r2,r2,3
8111667c:	1000021e 	bne	r2,zero,81116688 <vLoadDefaultETHConf+0x3c4>
81116680:	e43ff903 	ldbu	r16,-28(fp)
81116684:	00000106 	br	8111668c <vLoadDefaultETHConf+0x3c8>
81116688:	040000c4 	movi	r16,3
8111668c:	e0bffd04 	addi	r2,fp,-12
81116690:	1009883a 	mov	r4,r2
81116694:	111bfc00 	call	8111bfc0 <atoi>
81116698:	1007883a 	mov	r3,r2
8111669c:	00a045b4 	movhi	r2,33046
811166a0:	10860504 	addi	r2,r2,6164
811166a4:	1405883a 	add	r2,r2,r16
811166a8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811166ac:	e0bffd04 	addi	r2,fp,-12
811166b0:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811166b4:	e0bff903 	ldbu	r2,-28(fp)
811166b8:	10800044 	addi	r2,r2,1
811166bc:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811166c0:	e0bff947 	ldb	r2,-27(fp)
811166c4:	10800ed8 	cmpnei	r2,r2,59
811166c8:	103fcf1e 	bne	r2,zero,81116608 <__reset+0xfb0f6608>

						break;
811166cc:	00010306 	br	81116adc <vLoadDefaultETHConf+0x818>
					case 'G':

						ucParser = 0;
811166d0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811166d4:	e0bffc0f 	ldh	r2,-16(fp)
811166d8:	1009883a 	mov	r4,r2
811166dc:	111a2dc0 	call	8111a2dc <cGetNextChar>
811166e0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811166e4:	d0e00317 	ldw	r3,-32756(gp)
811166e8:	e0bff947 	ldb	r2,-27(fp)
811166ec:	10800044 	addi	r2,r2,1
811166f0:	1885883a 	add	r2,r3,r2
811166f4:	10800003 	ldbu	r2,0(r2)
811166f8:	10803fcc 	andi	r2,r2,255
811166fc:	1080010c 	andi	r2,r2,4
81116700:	10000626 	beq	r2,zero,8111671c <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81116704:	e0bffa17 	ldw	r2,-24(fp)
81116708:	e0fff943 	ldbu	r3,-27(fp)
8111670c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81116710:	e0bffa17 	ldw	r2,-24(fp)
81116714:	10800044 	addi	r2,r2,1
81116718:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111671c:	e0bff947 	ldb	r2,-27(fp)
81116720:	10800ba0 	cmpeqi	r2,r2,46
81116724:	1000031e 	bne	r2,zero,81116734 <vLoadDefaultETHConf+0x470>
81116728:	e0bff947 	ldb	r2,-27(fp)
8111672c:	10800ed8 	cmpnei	r2,r2,59
81116730:	103fe81e 	bne	r2,zero,811166d4 <__reset+0xfb0f66d4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116734:	e0bffa17 	ldw	r2,-24(fp)
81116738:	00c00284 	movi	r3,10
8111673c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81116740:	e0bff903 	ldbu	r2,-28(fp)
81116744:	108000e8 	cmpgeui	r2,r2,3
81116748:	1000021e 	bne	r2,zero,81116754 <vLoadDefaultETHConf+0x490>
8111674c:	e43ff903 	ldbu	r16,-28(fp)
81116750:	00000106 	br	81116758 <vLoadDefaultETHConf+0x494>
81116754:	040000c4 	movi	r16,3
81116758:	e0bffd04 	addi	r2,fp,-12
8111675c:	1009883a 	mov	r4,r2
81116760:	111bfc00 	call	8111bfc0 <atoi>
81116764:	1007883a 	mov	r3,r2
81116768:	00a045b4 	movhi	r2,33046
8111676c:	10860504 	addi	r2,r2,6164
81116770:	1405883a 	add	r2,r2,r16
81116774:	10800104 	addi	r2,r2,4
81116778:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111677c:	e0bffd04 	addi	r2,fp,-12
81116780:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116784:	e0bff903 	ldbu	r2,-28(fp)
81116788:	10800044 	addi	r2,r2,1
8111678c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116790:	e0bff947 	ldb	r2,-27(fp)
81116794:	10800ed8 	cmpnei	r2,r2,59
81116798:	103fce1e 	bne	r2,zero,811166d4 <__reset+0xfb0f66d4>

						break;
8111679c:	0000cf06 	br	81116adc <vLoadDefaultETHConf+0x818>
					case 'S':

						ucParser = 0;
811167a0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811167a4:	e0bffc0f 	ldh	r2,-16(fp)
811167a8:	1009883a 	mov	r4,r2
811167ac:	111a2dc0 	call	8111a2dc <cGetNextChar>
811167b0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811167b4:	d0e00317 	ldw	r3,-32756(gp)
811167b8:	e0bff947 	ldb	r2,-27(fp)
811167bc:	10800044 	addi	r2,r2,1
811167c0:	1885883a 	add	r2,r3,r2
811167c4:	10800003 	ldbu	r2,0(r2)
811167c8:	10803fcc 	andi	r2,r2,255
811167cc:	1080010c 	andi	r2,r2,4
811167d0:	10000626 	beq	r2,zero,811167ec <vLoadDefaultETHConf+0x528>
									(*p_inteiro) = c;
811167d4:	e0bffa17 	ldw	r2,-24(fp)
811167d8:	e0fff943 	ldbu	r3,-27(fp)
811167dc:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811167e0:	e0bffa17 	ldw	r2,-24(fp)
811167e4:	10800044 	addi	r2,r2,1
811167e8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811167ec:	e0bff947 	ldb	r2,-27(fp)
811167f0:	10800ba0 	cmpeqi	r2,r2,46
811167f4:	1000031e 	bne	r2,zero,81116804 <vLoadDefaultETHConf+0x540>
811167f8:	e0bff947 	ldb	r2,-27(fp)
811167fc:	10800ed8 	cmpnei	r2,r2,59
81116800:	103fe81e 	bne	r2,zero,811167a4 <__reset+0xfb0f67a4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116804:	e0bffa17 	ldw	r2,-24(fp)
81116808:	00c00284 	movi	r3,10
8111680c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81116810:	e0bff903 	ldbu	r2,-28(fp)
81116814:	108000e8 	cmpgeui	r2,r2,3
81116818:	1000021e 	bne	r2,zero,81116824 <vLoadDefaultETHConf+0x560>
8111681c:	e43ff903 	ldbu	r16,-28(fp)
81116820:	00000106 	br	81116828 <vLoadDefaultETHConf+0x564>
81116824:	040000c4 	movi	r16,3
81116828:	e0bffd04 	addi	r2,fp,-12
8111682c:	1009883a 	mov	r4,r2
81116830:	111bfc00 	call	8111bfc0 <atoi>
81116834:	1007883a 	mov	r3,r2
81116838:	00a045b4 	movhi	r2,33046
8111683c:	10860504 	addi	r2,r2,6164
81116840:	1405883a 	add	r2,r2,r16
81116844:	10800204 	addi	r2,r2,8
81116848:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111684c:	e0bffd04 	addi	r2,fp,-12
81116850:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116854:	e0bff903 	ldbu	r2,-28(fp)
81116858:	10800044 	addi	r2,r2,1
8111685c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116860:	e0bff947 	ldb	r2,-27(fp)
81116864:	10800ed8 	cmpnei	r2,r2,59
81116868:	103fce1e 	bne	r2,zero,811167a4 <__reset+0xfb0f67a4>

						break;
8111686c:	00009b06 	br	81116adc <vLoadDefaultETHConf+0x818>
					case 'D':

						ucParser = 0;
81116870:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116874:	e0bffc0f 	ldh	r2,-16(fp)
81116878:	1009883a 	mov	r4,r2
8111687c:	111a2dc0 	call	8111a2dc <cGetNextChar>
81116880:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81116884:	d0e00317 	ldw	r3,-32756(gp)
81116888:	e0bff947 	ldb	r2,-27(fp)
8111688c:	10800044 	addi	r2,r2,1
81116890:	1885883a 	add	r2,r3,r2
81116894:	10800003 	ldbu	r2,0(r2)
81116898:	10803fcc 	andi	r2,r2,255
8111689c:	1080010c 	andi	r2,r2,4
811168a0:	10000626 	beq	r2,zero,811168bc <vLoadDefaultETHConf+0x5f8>
									(*p_inteiro) = c;
811168a4:	e0bffa17 	ldw	r2,-24(fp)
811168a8:	e0fff943 	ldbu	r3,-27(fp)
811168ac:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811168b0:	e0bffa17 	ldw	r2,-24(fp)
811168b4:	10800044 	addi	r2,r2,1
811168b8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811168bc:	e0bff947 	ldb	r2,-27(fp)
811168c0:	10800ba0 	cmpeqi	r2,r2,46
811168c4:	1000031e 	bne	r2,zero,811168d4 <vLoadDefaultETHConf+0x610>
811168c8:	e0bff947 	ldb	r2,-27(fp)
811168cc:	10800ed8 	cmpnei	r2,r2,59
811168d0:	103fe81e 	bne	r2,zero,81116874 <__reset+0xfb0f6874>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811168d4:	e0bffa17 	ldw	r2,-24(fp)
811168d8:	00c00284 	movi	r3,10
811168dc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
811168e0:	e0bff903 	ldbu	r2,-28(fp)
811168e4:	108000e8 	cmpgeui	r2,r2,3
811168e8:	1000021e 	bne	r2,zero,811168f4 <vLoadDefaultETHConf+0x630>
811168ec:	e43ff903 	ldbu	r16,-28(fp)
811168f0:	00000106 	br	811168f8 <vLoadDefaultETHConf+0x634>
811168f4:	040000c4 	movi	r16,3
811168f8:	e0bffd04 	addi	r2,fp,-12
811168fc:	1009883a 	mov	r4,r2
81116900:	111bfc00 	call	8111bfc0 <atoi>
81116904:	1007883a 	mov	r3,r2
81116908:	00a045b4 	movhi	r2,33046
8111690c:	10860504 	addi	r2,r2,6164
81116910:	1405883a 	add	r2,r2,r16
81116914:	10800304 	addi	r2,r2,12
81116918:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111691c:	e0bffd04 	addi	r2,fp,-12
81116920:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116924:	e0bff903 	ldbu	r2,-28(fp)
81116928:	10800044 	addi	r2,r2,1
8111692c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116930:	e0bff947 	ldb	r2,-27(fp)
81116934:	10800ed8 	cmpnei	r2,r2,59
81116938:	103fce1e 	bne	r2,zero,81116874 <__reset+0xfb0f6874>

						break;						
8111693c:	00006706 	br	81116adc <vLoadDefaultETHConf+0x818>
					case 'P':

						do {
							c = cGetNextChar(siFile);
81116940:	e0bffc0f 	ldh	r2,-16(fp)
81116944:	1009883a 	mov	r4,r2
81116948:	111a2dc0 	call	8111a2dc <cGetNextChar>
8111694c:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81116950:	d0e00317 	ldw	r3,-32756(gp)
81116954:	e0bff947 	ldb	r2,-27(fp)
81116958:	10800044 	addi	r2,r2,1
8111695c:	1885883a 	add	r2,r3,r2
81116960:	10800003 	ldbu	r2,0(r2)
81116964:	10803fcc 	andi	r2,r2,255
81116968:	1080010c 	andi	r2,r2,4
8111696c:	10000626 	beq	r2,zero,81116988 <vLoadDefaultETHConf+0x6c4>
								(*p_inteiro) = c;
81116970:	e0bffa17 	ldw	r2,-24(fp)
81116974:	e0fff943 	ldbu	r3,-27(fp)
81116978:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111697c:	e0bffa17 	ldw	r2,-24(fp)
81116980:	10800044 	addi	r2,r2,1
81116984:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81116988:	e0bff947 	ldb	r2,-27(fp)
8111698c:	10800ed8 	cmpnei	r2,r2,59
81116990:	103feb1e 	bne	r2,zero,81116940 <__reset+0xfb0f6940>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116994:	e0bffa17 	ldw	r2,-24(fp)
81116998:	00c00284 	movi	r3,10
8111699c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
811169a0:	e0bffd04 	addi	r2,fp,-12
811169a4:	1009883a 	mov	r4,r2
811169a8:	111bfc00 	call	8111bfc0 <atoi>
811169ac:	1007883a 	mov	r3,r2
811169b0:	00a045b4 	movhi	r2,33046
811169b4:	10860504 	addi	r2,r2,6164
811169b8:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811169bc:	e0bffd04 	addi	r2,fp,-12
811169c0:	e0bffa15 	stw	r2,-24(fp)

						break;
811169c4:	00004506 	br	81116adc <vLoadDefaultETHConf+0x818>
					case 'H':

						do {
							c = cGetNextChar(siFile);
811169c8:	e0bffc0f 	ldh	r2,-16(fp)
811169cc:	1009883a 	mov	r4,r2
811169d0:	111a2dc0 	call	8111a2dc <cGetNextChar>
811169d4:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
811169d8:	d0e00317 	ldw	r3,-32756(gp)
811169dc:	e0bff947 	ldb	r2,-27(fp)
811169e0:	10800044 	addi	r2,r2,1
811169e4:	1885883a 	add	r2,r3,r2
811169e8:	10800003 	ldbu	r2,0(r2)
811169ec:	10803fcc 	andi	r2,r2,255
811169f0:	1080010c 	andi	r2,r2,4
811169f4:	10000626 	beq	r2,zero,81116a10 <vLoadDefaultETHConf+0x74c>
								(*p_inteiro) = c;
811169f8:	e0bffa17 	ldw	r2,-24(fp)
811169fc:	e0fff943 	ldbu	r3,-27(fp)
81116a00:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81116a04:	e0bffa17 	ldw	r2,-24(fp)
81116a08:	10800044 	addi	r2,r2,1
81116a0c:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81116a10:	e0bff947 	ldb	r2,-27(fp)
81116a14:	10800ed8 	cmpnei	r2,r2,59
81116a18:	103feb1e 	bne	r2,zero,811169c8 <__reset+0xfb0f69c8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116a1c:	e0bffa17 	ldw	r2,-24(fp)
81116a20:	00c00284 	movi	r3,10
81116a24:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81116a28:	e0bffd04 	addi	r2,fp,-12
81116a2c:	1009883a 	mov	r4,r2
81116a30:	111bfc00 	call	8111bfc0 <atoi>
81116a34:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81116a38:	e0bffc8f 	ldh	r2,-14(fp)
81116a3c:	10800058 	cmpnei	r2,r2,1
81116a40:	1000051e 	bne	r2,zero,81116a58 <vLoadDefaultETHConf+0x794>
							xConfEth.bDHCP = TRUE;
81116a44:	00a045b4 	movhi	r2,33046
81116a48:	10860504 	addi	r2,r2,6164
81116a4c:	00c00044 	movi	r3,1
81116a50:	10c00615 	stw	r3,24(r2)
81116a54:	00000306 	br	81116a64 <vLoadDefaultETHConf+0x7a0>
						else
							xConfEth.bDHCP = FALSE;
81116a58:	00a045b4 	movhi	r2,33046
81116a5c:	10860504 	addi	r2,r2,6164
81116a60:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81116a64:	e0bffd04 	addi	r2,fp,-12
81116a68:	e0bffa15 	stw	r2,-24(fp)

						break;
81116a6c:	00001b06 	br	81116adc <vLoadDefaultETHConf+0x818>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81116a70:	e0bffc0f 	ldh	r2,-16(fp)
81116a74:	1009883a 	mov	r4,r2
81116a78:	111a29c0 	call	8111a29c <siCloseFile>
81116a7c:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81116a80:	e0bffb17 	ldw	r2,-20(fp)
81116a84:	1000071e 	bne	r2,zero,81116aa4 <vLoadDefaultETHConf+0x7e0>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81116a88:	d0a05d17 	ldw	r2,-32396(gp)
81116a8c:	100f883a 	mov	r7,r2
81116a90:	01800784 	movi	r6,30
81116a94:	01400044 	movi	r5,1
81116a98:	01204574 	movhi	r4,33045
81116a9c:	21268c04 	addi	r4,r4,-26064
81116aa0:	111c7b80 	call	8111c7b8 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81116aa4:	00800044 	movi	r2,1
81116aa8:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81116aac:	00800044 	movi	r2,1
81116ab0:	e0bff715 	stw	r2,-36(fp)
						break;
81116ab4:	00000906 	br	81116adc <vLoadDefaultETHConf+0x818>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
81116ab8:	d0a05d17 	ldw	r2,-32396(gp)
81116abc:	100f883a 	mov	r7,r2
81116ac0:	01800844 	movi	r6,33
81116ac4:	01400044 	movi	r5,1
81116ac8:	01204574 	movhi	r4,33045
81116acc:	21269404 	addi	r4,r4,-26032
81116ad0:	111c7b80 	call	8111c7b8 <fwrite>
						#endif
						break;
81116ad4:	00000106 	br	81116adc <vLoadDefaultETHConf+0x818>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81116ad8:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81116adc:	e0bff817 	ldw	r2,-32(fp)
81116ae0:	103e1626 	beq	r2,zero,8111633c <__reset+0xfb0f633c>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81116ae4:	00000f06 	br	81116b24 <vLoadDefaultETHConf+0x860>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
81116ae8:	d0a05d17 	ldw	r2,-32396(gp)
81116aec:	100f883a 	mov	r7,r2
81116af0:	01800604 	movi	r6,24
81116af4:	01400044 	movi	r5,1
81116af8:	01204574 	movhi	r4,33045
81116afc:	21269d04 	addi	r4,r4,-25996
81116b00:	111c7b80 	call	8111c7b8 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81116b04:	00000706 	br	81116b24 <vLoadDefaultETHConf+0x860>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
81116b08:	d0a05d17 	ldw	r2,-32396(gp)
81116b0c:	100f883a 	mov	r7,r2
81116b10:	018004c4 	movi	r6,19
81116b14:	01400044 	movi	r5,1
81116b18:	01204574 	movhi	r4,33045
81116b1c:	2126a404 	addi	r4,r4,-25968
81116b20:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81116b24:	e0bff717 	ldw	r2,-36(fp)
81116b28:	1000541e 	bne	r2,zero,81116c7c <vLoadDefaultETHConf+0x9b8>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81116b2c:	01204574 	movhi	r4,33045
81116b30:	2126a904 	addi	r4,r4,-25948
81116b34:	111d7680 	call	8111d768 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81116b38:	01604574 	movhi	r5,33045
81116b3c:	29668304 	addi	r5,r5,-26100
81116b40:	01204574 	movhi	r4,33045
81116b44:	2126bd04 	addi	r4,r4,-25868
81116b48:	111d4e40 	call	8111d4e4 <printf>


		xConfEth.siPortPUS = 17000;
81116b4c:	00a045b4 	movhi	r2,33046
81116b50:	10860504 	addi	r2,r2,6164
81116b54:	00d09a04 	movi	r3,17000
81116b58:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
81116b5c:	00a045b4 	movhi	r2,33046
81116b60:	10860504 	addi	r2,r2,6164
81116b64:	00fff004 	movi	r3,-64
81116b68:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
81116b6c:	00a045b4 	movhi	r2,33046
81116b70:	10860504 	addi	r2,r2,6164
81116b74:	00ffea04 	movi	r3,-88
81116b78:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
81116b7c:	00a045b4 	movhi	r2,33046
81116b80:	10860504 	addi	r2,r2,6164
81116b84:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81116b88:	00a045b4 	movhi	r2,33046
81116b8c:	10860504 	addi	r2,r2,6164
81116b90:	00c00144 	movi	r3,5
81116b94:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81116b98:	00a045b4 	movhi	r2,33046
81116b9c:	10860504 	addi	r2,r2,6164
81116ba0:	00fff004 	movi	r3,-64
81116ba4:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81116ba8:	00a045b4 	movhi	r2,33046
81116bac:	10860504 	addi	r2,r2,6164
81116bb0:	00ffea04 	movi	r3,-88
81116bb4:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
81116bb8:	00a045b4 	movhi	r2,33046
81116bbc:	10860504 	addi	r2,r2,6164
81116bc0:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81116bc4:	00a045b4 	movhi	r2,33046
81116bc8:	10860504 	addi	r2,r2,6164
81116bcc:	00c00044 	movi	r3,1
81116bd0:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81116bd4:	00a045b4 	movhi	r2,33046
81116bd8:	10860504 	addi	r2,r2,6164
81116bdc:	00ffffc4 	movi	r3,-1
81116be0:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
81116be4:	00a045b4 	movhi	r2,33046
81116be8:	10860504 	addi	r2,r2,6164
81116bec:	00ffffc4 	movi	r3,-1
81116bf0:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
81116bf4:	00a045b4 	movhi	r2,33046
81116bf8:	10860504 	addi	r2,r2,6164
81116bfc:	00ffffc4 	movi	r3,-1
81116c00:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
81116c04:	00a045b4 	movhi	r2,33046
81116c08:	10860504 	addi	r2,r2,6164
81116c0c:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
81116c10:	00a045b4 	movhi	r2,33046
81116c14:	10860504 	addi	r2,r2,6164
81116c18:	00ffff04 	movi	r3,-4
81116c1c:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
81116c20:	00a045b4 	movhi	r2,33046
81116c24:	10860504 	addi	r2,r2,6164
81116c28:	00fffdc4 	movi	r3,-9
81116c2c:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
81116c30:	00a045b4 	movhi	r2,33046
81116c34:	10860504 	addi	r2,r2,6164
81116c38:	00c018c4 	movi	r3,99
81116c3c:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
81116c40:	00a045b4 	movhi	r2,33046
81116c44:	10860504 	addi	r2,r2,6164
81116c48:	00c01344 	movi	r3,77
81116c4c:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
81116c50:	00a045b4 	movhi	r2,33046
81116c54:	10860504 	addi	r2,r2,6164
81116c58:	00c007c4 	movi	r3,31
81116c5c:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
81116c60:	00a045b4 	movhi	r2,33046
81116c64:	10860504 	addi	r2,r2,6164
81116c68:	00c01084 	movi	r3,66
81116c6c:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
81116c70:	00a045b4 	movhi	r2,33046
81116c74:	10860504 	addi	r2,r2,6164
81116c78:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
81116c7c:	e0bff717 	ldw	r2,-36(fp)
}
81116c80:	e6ffff04 	addi	sp,fp,-4
81116c84:	dfc00217 	ldw	ra,8(sp)
81116c88:	df000117 	ldw	fp,4(sp)
81116c8c:	dc000017 	ldw	r16,0(sp)
81116c90:	dec00304 	addi	sp,sp,12
81116c94:	f800283a 	ret

81116c98 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
81116c98:	defff004 	addi	sp,sp,-64
81116c9c:	de00012e 	bgeu	sp,et,81116ca4 <vShowEthConfig+0xc>
81116ca0:	003b68fa 	trap	3
81116ca4:	dfc00f15 	stw	ra,60(sp)
81116ca8:	df000e15 	stw	fp,56(sp)
81116cac:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
81116cb0:	d0a05d17 	ldw	r2,-32396(gp)
81116cb4:	100f883a 	mov	r7,r2
81116cb8:	018007c4 	movi	r6,31
81116cbc:	01400044 	movi	r5,1
81116cc0:	01204574 	movhi	r4,33045
81116cc4:	2126c304 	addi	r4,r4,-25844
81116cc8:	111c7b80 	call	8111c7b8 <fwrite>

		memset(buffer,0,40);
81116ccc:	01800a04 	movi	r6,40
81116cd0:	000b883a 	mov	r5,zero
81116cd4:	e13ff604 	addi	r4,fp,-40
81116cd8:	111d31c0 	call	8111d31c <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
81116cdc:	00a045b4 	movhi	r2,33046
81116ce0:	10860504 	addi	r2,r2,6164
81116ce4:	10800403 	ldbu	r2,16(r2)
81116ce8:	11803fcc 	andi	r6,r2,255
81116cec:	00a045b4 	movhi	r2,33046
81116cf0:	10860504 	addi	r2,r2,6164
81116cf4:	10800443 	ldbu	r2,17(r2)
81116cf8:	11c03fcc 	andi	r7,r2,255
81116cfc:	00a045b4 	movhi	r2,33046
81116d00:	10860504 	addi	r2,r2,6164
81116d04:	10800483 	ldbu	r2,18(r2)
81116d08:	10c03fcc 	andi	r3,r2,255
81116d0c:	00a045b4 	movhi	r2,33046
81116d10:	10860504 	addi	r2,r2,6164
81116d14:	108004c3 	ldbu	r2,19(r2)
81116d18:	11003fcc 	andi	r4,r2,255
81116d1c:	00a045b4 	movhi	r2,33046
81116d20:	10860504 	addi	r2,r2,6164
81116d24:	10800503 	ldbu	r2,20(r2)
81116d28:	11403fcc 	andi	r5,r2,255
81116d2c:	00a045b4 	movhi	r2,33046
81116d30:	10860504 	addi	r2,r2,6164
81116d34:	10800543 	ldbu	r2,21(r2)
81116d38:	10803fcc 	andi	r2,r2,255
81116d3c:	d8800315 	stw	r2,12(sp)
81116d40:	d9400215 	stw	r5,8(sp)
81116d44:	d9000115 	stw	r4,4(sp)
81116d48:	d8c00015 	stw	r3,0(sp)
81116d4c:	01604574 	movhi	r5,33045
81116d50:	2966cb04 	addi	r5,r5,-25812
81116d54:	e13ff604 	addi	r4,fp,-40
81116d58:	111daac0 	call	8111daac <sprintf>
		debug(fp, buffer );
81116d5c:	d0a05d17 	ldw	r2,-32396(gp)
81116d60:	e17ff604 	addi	r5,fp,-40
81116d64:	1009883a 	mov	r4,r2
81116d68:	111c11c0 	call	8111c11c <fprintf>

		memset(buffer,0,40);
81116d6c:	01800a04 	movi	r6,40
81116d70:	000b883a 	mov	r5,zero
81116d74:	e13ff604 	addi	r4,fp,-40
81116d78:	111d31c0 	call	8111d31c <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
81116d7c:	00a045b4 	movhi	r2,33046
81116d80:	10860504 	addi	r2,r2,6164
81116d84:	10800003 	ldbu	r2,0(r2)
81116d88:	11003fcc 	andi	r4,r2,255
81116d8c:	00a045b4 	movhi	r2,33046
81116d90:	10860504 	addi	r2,r2,6164
81116d94:	10800043 	ldbu	r2,1(r2)
81116d98:	11403fcc 	andi	r5,r2,255
81116d9c:	00a045b4 	movhi	r2,33046
81116da0:	10860504 	addi	r2,r2,6164
81116da4:	10800083 	ldbu	r2,2(r2)
81116da8:	10c03fcc 	andi	r3,r2,255
81116dac:	00a045b4 	movhi	r2,33046
81116db0:	10860504 	addi	r2,r2,6164
81116db4:	108000c3 	ldbu	r2,3(r2)
81116db8:	10803fcc 	andi	r2,r2,255
81116dbc:	d8800115 	stw	r2,4(sp)
81116dc0:	d8c00015 	stw	r3,0(sp)
81116dc4:	280f883a 	mov	r7,r5
81116dc8:	200d883a 	mov	r6,r4
81116dcc:	01604574 	movhi	r5,33045
81116dd0:	2966d404 	addi	r5,r5,-25776
81116dd4:	e13ff604 	addi	r4,fp,-40
81116dd8:	111daac0 	call	8111daac <sprintf>
		debug(fp, buffer );
81116ddc:	d0a05d17 	ldw	r2,-32396(gp)
81116de0:	e17ff604 	addi	r5,fp,-40
81116de4:	1009883a 	mov	r4,r2
81116de8:	111c11c0 	call	8111c11c <fprintf>

		memset(buffer,0,40);
81116dec:	01800a04 	movi	r6,40
81116df0:	000b883a 	mov	r5,zero
81116df4:	e13ff604 	addi	r4,fp,-40
81116df8:	111d31c0 	call	8111d31c <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
81116dfc:	00a045b4 	movhi	r2,33046
81116e00:	10860504 	addi	r2,r2,6164
81116e04:	10800103 	ldbu	r2,4(r2)
81116e08:	11003fcc 	andi	r4,r2,255
81116e0c:	00a045b4 	movhi	r2,33046
81116e10:	10860504 	addi	r2,r2,6164
81116e14:	10800143 	ldbu	r2,5(r2)
81116e18:	11403fcc 	andi	r5,r2,255
81116e1c:	00a045b4 	movhi	r2,33046
81116e20:	10860504 	addi	r2,r2,6164
81116e24:	10800183 	ldbu	r2,6(r2)
81116e28:	10c03fcc 	andi	r3,r2,255
81116e2c:	00a045b4 	movhi	r2,33046
81116e30:	10860504 	addi	r2,r2,6164
81116e34:	108001c3 	ldbu	r2,7(r2)
81116e38:	10803fcc 	andi	r2,r2,255
81116e3c:	d8800115 	stw	r2,4(sp)
81116e40:	d8c00015 	stw	r3,0(sp)
81116e44:	280f883a 	mov	r7,r5
81116e48:	200d883a 	mov	r6,r4
81116e4c:	01604574 	movhi	r5,33045
81116e50:	2966da04 	addi	r5,r5,-25752
81116e54:	e13ff604 	addi	r4,fp,-40
81116e58:	111daac0 	call	8111daac <sprintf>
		debug(fp, buffer );
81116e5c:	d0a05d17 	ldw	r2,-32396(gp)
81116e60:	e17ff604 	addi	r5,fp,-40
81116e64:	1009883a 	mov	r4,r2
81116e68:	111c11c0 	call	8111c11c <fprintf>

		memset(buffer,0,40);
81116e6c:	01800a04 	movi	r6,40
81116e70:	000b883a 	mov	r5,zero
81116e74:	e13ff604 	addi	r4,fp,-40
81116e78:	111d31c0 	call	8111d31c <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
81116e7c:	00a045b4 	movhi	r2,33046
81116e80:	10860504 	addi	r2,r2,6164
81116e84:	10800203 	ldbu	r2,8(r2)
81116e88:	11003fcc 	andi	r4,r2,255
81116e8c:	00a045b4 	movhi	r2,33046
81116e90:	10860504 	addi	r2,r2,6164
81116e94:	10800243 	ldbu	r2,9(r2)
81116e98:	11403fcc 	andi	r5,r2,255
81116e9c:	00a045b4 	movhi	r2,33046
81116ea0:	10860504 	addi	r2,r2,6164
81116ea4:	10800283 	ldbu	r2,10(r2)
81116ea8:	10c03fcc 	andi	r3,r2,255
81116eac:	00a045b4 	movhi	r2,33046
81116eb0:	10860504 	addi	r2,r2,6164
81116eb4:	108002c3 	ldbu	r2,11(r2)
81116eb8:	10803fcc 	andi	r2,r2,255
81116ebc:	d8800115 	stw	r2,4(sp)
81116ec0:	d8c00015 	stw	r3,0(sp)
81116ec4:	280f883a 	mov	r7,r5
81116ec8:	200d883a 	mov	r6,r4
81116ecc:	01604574 	movhi	r5,33045
81116ed0:	2966e104 	addi	r5,r5,-25724
81116ed4:	e13ff604 	addi	r4,fp,-40
81116ed8:	111daac0 	call	8111daac <sprintf>
		debug(fp, buffer );
81116edc:	d0a05d17 	ldw	r2,-32396(gp)
81116ee0:	e17ff604 	addi	r5,fp,-40
81116ee4:	1009883a 	mov	r4,r2
81116ee8:	111c11c0 	call	8111c11c <fprintf>

		memset(buffer,0,40);
81116eec:	01800a04 	movi	r6,40
81116ef0:	000b883a 	mov	r5,zero
81116ef4:	e13ff604 	addi	r4,fp,-40
81116ef8:	111d31c0 	call	8111d31c <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
81116efc:	00a045b4 	movhi	r2,33046
81116f00:	10860504 	addi	r2,r2,6164
81116f04:	10800303 	ldbu	r2,12(r2)
81116f08:	11003fcc 	andi	r4,r2,255
81116f0c:	00a045b4 	movhi	r2,33046
81116f10:	10860504 	addi	r2,r2,6164
81116f14:	10800343 	ldbu	r2,13(r2)
81116f18:	11403fcc 	andi	r5,r2,255
81116f1c:	00a045b4 	movhi	r2,33046
81116f20:	10860504 	addi	r2,r2,6164
81116f24:	10800383 	ldbu	r2,14(r2)
81116f28:	10c03fcc 	andi	r3,r2,255
81116f2c:	00a045b4 	movhi	r2,33046
81116f30:	10860504 	addi	r2,r2,6164
81116f34:	108003c3 	ldbu	r2,15(r2)
81116f38:	10803fcc 	andi	r2,r2,255
81116f3c:	d8800115 	stw	r2,4(sp)
81116f40:	d8c00015 	stw	r3,0(sp)
81116f44:	280f883a 	mov	r7,r5
81116f48:	200d883a 	mov	r6,r4
81116f4c:	01604574 	movhi	r5,33045
81116f50:	2966e804 	addi	r5,r5,-25696
81116f54:	e13ff604 	addi	r4,fp,-40
81116f58:	111daac0 	call	8111daac <sprintf>
		debug(fp, buffer );
81116f5c:	d0a05d17 	ldw	r2,-32396(gp)
81116f60:	e17ff604 	addi	r5,fp,-40
81116f64:	1009883a 	mov	r4,r2
81116f68:	111c11c0 	call	8111c11c <fprintf>

		memset(buffer,0,40);
81116f6c:	01800a04 	movi	r6,40
81116f70:	000b883a 	mov	r5,zero
81116f74:	e13ff604 	addi	r4,fp,-40
81116f78:	111d31c0 	call	8111d31c <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
81116f7c:	00a045b4 	movhi	r2,33046
81116f80:	10860504 	addi	r2,r2,6164
81116f84:	1080058b 	ldhu	r2,22(r2)
81116f88:	10bfffcc 	andi	r2,r2,65535
81116f8c:	100d883a 	mov	r6,r2
81116f90:	01604574 	movhi	r5,33045
81116f94:	2966ef04 	addi	r5,r5,-25668
81116f98:	e13ff604 	addi	r4,fp,-40
81116f9c:	111daac0 	call	8111daac <sprintf>
		debug(fp, buffer );
81116fa0:	d0a05d17 	ldw	r2,-32396(gp)
81116fa4:	e17ff604 	addi	r5,fp,-40
81116fa8:	1009883a 	mov	r4,r2
81116fac:	111c11c0 	call	8111c11c <fprintf>

	}
81116fb0:	0001883a 	nop
81116fb4:	e037883a 	mov	sp,fp
81116fb8:	dfc00117 	ldw	ra,4(sp)
81116fbc:	df000017 	ldw	fp,0(sp)
81116fc0:	dec00204 	addi	sp,sp,8
81116fc4:	f800283a 	ret

81116fc8 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
81116fc8:	defffb04 	addi	sp,sp,-20
81116fcc:	de00012e 	bgeu	sp,et,81116fd4 <ucCrc8+0xc>
81116fd0:	003b68fa 	trap	3
81116fd4:	df000415 	stw	fp,16(sp)
81116fd8:	df000404 	addi	fp,sp,16
81116fdc:	e13ffd15 	stw	r4,-12(fp)
81116fe0:	e17ffe15 	stw	r5,-8(fp)
81116fe4:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
81116fe8:	e0bffe17 	ldw	r2,-8(fp)
81116fec:	1000021e 	bne	r2,zero,81116ff8 <ucCrc8+0x30>
        return 0;
81116ff0:	0005883a 	mov	r2,zero
81116ff4:	00001906 	br	8111705c <ucCrc8+0x94>
    crc &= 0xff;
81116ff8:	e0bffd17 	ldw	r2,-12(fp)
81116ffc:	10803fcc 	andi	r2,r2,255
81117000:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
81117004:	e0fffe17 	ldw	r3,-8(fp)
81117008:	e0bfff17 	ldw	r2,-4(fp)
8111700c:	1885883a 	add	r2,r3,r2
81117010:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
81117014:	00000d06 	br	8111704c <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
81117018:	e0bffe17 	ldw	r2,-8(fp)
8111701c:	10c00044 	addi	r3,r2,1
81117020:	e0fffe15 	stw	r3,-8(fp)
81117024:	10800003 	ldbu	r2,0(r2)
81117028:	10c03fcc 	andi	r3,r2,255
8111702c:	e0bffd17 	ldw	r2,-12(fp)
81117030:	1886f03a 	xor	r3,r3,r2
81117034:	00a04574 	movhi	r2,33045
81117038:	10a6f2c4 	addi	r2,r2,-25653
8111703c:	10c5883a 	add	r2,r2,r3
81117040:	10800003 	ldbu	r2,0(r2)
81117044:	10803fcc 	andi	r2,r2,255
81117048:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111704c:	e0fffe17 	ldw	r3,-8(fp)
81117050:	e0bffc17 	ldw	r2,-16(fp)
81117054:	18bff036 	bltu	r3,r2,81117018 <__reset+0xfb0f7018>
        crc = crc8_table[crc ^ *data++];
    return crc;
81117058:	e0bffd17 	ldw	r2,-12(fp)
}
8111705c:	e037883a 	mov	sp,fp
81117060:	df000017 	ldw	fp,0(sp)
81117064:	dec00104 	addi	sp,sp,4
81117068:	f800283a 	ret

8111706c <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111706c:	defffb04 	addi	sp,sp,-20
81117070:	de00012e 	bgeu	sp,et,81117078 <ucCrc8wInit+0xc>
81117074:	003b68fa 	trap	3
81117078:	dfc00415 	stw	ra,16(sp)
8111707c:	df000315 	stw	fp,12(sp)
81117080:	df000304 	addi	fp,sp,12
81117084:	e13ffe15 	stw	r4,-8(fp)
81117088:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111708c:	000d883a 	mov	r6,zero
81117090:	000b883a 	mov	r5,zero
81117094:	0009883a 	mov	r4,zero
81117098:	1116fc80 	call	81116fc8 <ucCrc8>
8111709c:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
811170a0:	e0bffd03 	ldbu	r2,-12(fp)
811170a4:	e1bfff17 	ldw	r6,-4(fp)
811170a8:	e17ffe17 	ldw	r5,-8(fp)
811170ac:	1009883a 	mov	r4,r2
811170b0:	1116fc80 	call	81116fc8 <ucCrc8>
}
811170b4:	e037883a 	mov	sp,fp
811170b8:	dfc00117 	ldw	ra,4(sp)
811170bc:	df000017 	ldw	fp,0(sp)
811170c0:	dec00204 	addi	sp,sp,8
811170c4:	f800283a 	ret

811170c8 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
811170c8:	defffc04 	addi	sp,sp,-16
811170cc:	de00012e 	bgeu	sp,et,811170d4 <vDataControllerInit+0xc>
811170d0:	003b68fa 	trap	3
811170d4:	df000315 	stw	fp,12(sp)
811170d8:	df000304 	addi	fp,sp,12
811170dc:	e13ffe15 	stw	r4,-8(fp)
811170e0:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
811170e4:	e0bffe17 	ldw	r2,-8(fp)
811170e8:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
811170ec:	e03ffd05 	stb	zero,-12(fp)
811170f0:	00001c06 	br	81117164 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
811170f4:	e0bffd03 	ldbu	r2,-12(fp)
811170f8:	e0fffd03 	ldbu	r3,-12(fp)
811170fc:	18c09524 	muli	r3,r3,596
81117100:	e13fff17 	ldw	r4,-4(fp)
81117104:	20c7883a 	add	r3,r4,r3
81117108:	e13ffe17 	ldw	r4,-8(fp)
8111710c:	10800084 	addi	r2,r2,2
81117110:	1085883a 	add	r2,r2,r2
81117114:	1085883a 	add	r2,r2,r2
81117118:	2085883a 	add	r2,r4,r2
8111711c:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
81117120:	e17ffd03 	ldbu	r5,-12(fp)
81117124:	e0bffd03 	ldbu	r2,-12(fp)
81117128:	e0ffff17 	ldw	r3,-4(fp)
8111712c:	10802584 	addi	r2,r2,150
81117130:	1085883a 	add	r2,r2,r2
81117134:	1085883a 	add	r2,r2,r2
81117138:	1885883a 	add	r2,r3,r2
8111713c:	10c00017 	ldw	r3,0(r2)
81117140:	e13ffe17 	ldw	r4,-8(fp)
81117144:	288000c4 	addi	r2,r5,3
81117148:	1085883a 	add	r2,r2,r2
8111714c:	1085883a 	add	r2,r2,r2
81117150:	2085883a 	add	r2,r4,r2
81117154:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81117158:	e0bffd03 	ldbu	r2,-12(fp)
8111715c:	10800044 	addi	r2,r2,1
81117160:	e0bffd05 	stb	r2,-12(fp)
81117164:	e0bffd03 	ldbu	r2,-12(fp)
81117168:	103fe226 	beq	r2,zero,811170f4 <__reset+0xfb0f70f4>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111716c:	e0bfff17 	ldw	r2,-4(fp)
81117170:	10c09804 	addi	r3,r2,608
81117174:	e0bffe17 	ldw	r2,-8(fp)
81117178:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111717c:	e0bffe17 	ldw	r2,-8(fp)
81117180:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
81117184:	e0bffe17 	ldw	r2,-8(fp)
81117188:	10c00504 	addi	r3,r2,20
8111718c:	e0bfff17 	ldw	r2,-4(fp)
81117190:	10c09a15 	stw	r3,616(r2)
}
81117194:	0001883a 	nop
81117198:	e037883a 	mov	sp,fp
8111719c:	df000017 	ldw	fp,0(sp)
811171a0:	dec00104 	addi	sp,sp,4
811171a4:	f800283a 	ret

811171a8 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
811171a8:	defff904 	addi	sp,sp,-28
811171ac:	de00012e 	bgeu	sp,et,811171b4 <printErrorTask+0xc>
811171b0:	003b68fa 	trap	3
811171b4:	dfc00615 	stw	ra,24(sp)
811171b8:	df000515 	stw	fp,20(sp)
811171bc:	df000504 	addi	fp,sp,20
811171c0:	2005883a 	mov	r2,r4
811171c4:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
811171c8:	e03ffb15 	stw	zero,-20(fp)
811171cc:	e03ffc15 	stw	zero,-16(fp)
811171d0:	e03ffd15 	stw	zero,-12(fp)
811171d4:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
811171d8:	e0bfff03 	ldbu	r2,-4(fp)
811171dc:	100d883a 	mov	r6,r2
811171e0:	01604574 	movhi	r5,33045
811171e4:	29673304 	addi	r5,r5,-25396
811171e8:	e13ffb04 	addi	r4,fp,-20
811171ec:	111daac0 	call	8111daac <sprintf>
		debug(fp, buffer);
811171f0:	d0a05d17 	ldw	r2,-32396(gp)
811171f4:	e17ffb04 	addi	r5,fp,-20
811171f8:	1009883a 	mov	r4,r2
811171fc:	111c11c0 	call	8111c11c <fprintf>
	}
81117200:	0001883a 	nop
81117204:	e037883a 	mov	sp,fp
81117208:	dfc00117 	ldw	ra,4(sp)
8111720c:	df000017 	ldw	fp,0(sp)
81117210:	dec00204 	addi	sp,sp,8
81117214:	f800283a 	ret

81117218 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
81117218:	defffd04 	addi	sp,sp,-12
8111721c:	de00012e 	bgeu	sp,et,81117224 <vFailCreateMutexSResources+0xc>
81117220:	003b68fa 	trap	3
81117224:	dfc00215 	stw	ra,8(sp)
81117228:	df000115 	stw	fp,4(sp)
8111722c:	df000104 	addi	fp,sp,4
81117230:	2005883a 	mov	r2,r4
81117234:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
81117238:	d0a05d17 	ldw	r2,-32396(gp)
8111723c:	100f883a 	mov	r7,r2
81117240:	018008c4 	movi	r6,35
81117244:	01400044 	movi	r5,1
81117248:	01204574 	movhi	r4,33045
8111724c:	21273604 	addi	r4,r4,-25384
81117250:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81117254:	e0bfff03 	ldbu	r2,-4(fp)
81117258:	1009883a 	mov	r4,r2
8111725c:	11171a80 	call	811171a8 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117260:	0001883a 	nop
81117264:	e037883a 	mov	sp,fp
81117268:	dfc00117 	ldw	ra,4(sp)
8111726c:	df000017 	ldw	fp,0(sp)
81117270:	dec00204 	addi	sp,sp,8
81117274:	f800283a 	ret

81117278 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
81117278:	defffe04 	addi	sp,sp,-8
8111727c:	de00012e 	bgeu	sp,et,81117284 <vFailCreateMutexDMA+0xc>
81117280:	003b68fa 	trap	3
81117284:	dfc00115 	stw	ra,4(sp)
81117288:	df000015 	stw	fp,0(sp)
8111728c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
81117290:	d0a05d17 	ldw	r2,-32396(gp)
81117294:	100f883a 	mov	r7,r2
81117298:	018009c4 	movi	r6,39
8111729c:	01400044 	movi	r5,1
811172a0:	01204574 	movhi	r4,33045
811172a4:	21273f04 	addi	r4,r4,-25348
811172a8:	111c7b80 	call	8111c7b8 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811172ac:	0001883a 	nop
811172b0:	e037883a 	mov	sp,fp
811172b4:	dfc00117 	ldw	ra,4(sp)
811172b8:	df000017 	ldw	fp,0(sp)
811172bc:	dec00204 	addi	sp,sp,8
811172c0:	f800283a 	ret

811172c4 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
811172c4:	defffe04 	addi	sp,sp,-8
811172c8:	de00012e 	bgeu	sp,et,811172d0 <vFailCreateSemaphoreResources+0xc>
811172cc:	003b68fa 	trap	3
811172d0:	dfc00115 	stw	ra,4(sp)
811172d4:	df000015 	stw	fp,0(sp)
811172d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
811172dc:	d0a05d17 	ldw	r2,-32396(gp)
811172e0:	100f883a 	mov	r7,r2
811172e4:	01800984 	movi	r6,38
811172e8:	01400044 	movi	r5,1
811172ec:	01204574 	movhi	r4,33045
811172f0:	21274904 	addi	r4,r4,-25308
811172f4:	111c7b80 	call	8111c7b8 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811172f8:	0001883a 	nop
811172fc:	e037883a 	mov	sp,fp
81117300:	dfc00117 	ldw	ra,4(sp)
81117304:	df000017 	ldw	fp,0(sp)
81117308:	dec00204 	addi	sp,sp,8
8111730c:	f800283a 	ret

81117310 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
81117310:	defffe04 	addi	sp,sp,-8
81117314:	de00012e 	bgeu	sp,et,8111731c <vFailTestCriticasParts+0xc>
81117318:	003b68fa 	trap	3
8111731c:	dfc00115 	stw	ra,4(sp)
81117320:	df000015 	stw	fp,0(sp)
81117324:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
81117328:	d0a05d17 	ldw	r2,-32396(gp)
8111732c:	100f883a 	mov	r7,r2
81117330:	018007c4 	movi	r6,31
81117334:	01400044 	movi	r5,1
81117338:	01204574 	movhi	r4,33045
8111733c:	21275304 	addi	r4,r4,-25268
81117340:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117344:	0001883a 	nop
81117348:	e037883a 	mov	sp,fp
8111734c:	dfc00117 	ldw	ra,4(sp)
81117350:	df000017 	ldw	fp,0(sp)
81117354:	dec00204 	addi	sp,sp,8
81117358:	f800283a 	ret

8111735c <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111735c:	defffe04 	addi	sp,sp,-8
81117360:	de00012e 	bgeu	sp,et,81117368 <vFailSendxSemCommInit+0xc>
81117364:	003b68fa 	trap	3
81117368:	dfc00115 	stw	ra,4(sp)
8111736c:	df000015 	stw	fp,0(sp)
81117370:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
81117374:	d0a05d17 	ldw	r2,-32396(gp)
81117378:	100f883a 	mov	r7,r2
8111737c:	01800744 	movi	r6,29
81117380:	01400044 	movi	r5,1
81117384:	01204574 	movhi	r4,33045
81117388:	21275b04 	addi	r4,r4,-25236
8111738c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
81117390:	d0a05d17 	ldw	r2,-32396(gp)
81117394:	100f883a 	mov	r7,r2
81117398:	01800a44 	movi	r6,41
8111739c:	01400044 	movi	r5,1
811173a0:	01204574 	movhi	r4,33045
811173a4:	21276304 	addi	r4,r4,-25204
811173a8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811173ac:	0001883a 	nop
811173b0:	e037883a 	mov	sp,fp
811173b4:	dfc00117 	ldw	ra,4(sp)
811173b8:	df000017 	ldw	fp,0(sp)
811173bc:	dec00204 	addi	sp,sp,8
811173c0:	f800283a 	ret

811173c4 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
811173c4:	defffe04 	addi	sp,sp,-8
811173c8:	de00012e 	bgeu	sp,et,811173d0 <vFailSendPreParsedSemaphore+0xc>
811173cc:	003b68fa 	trap	3
811173d0:	dfc00115 	stw	ra,4(sp)
811173d4:	df000015 	stw	fp,0(sp)
811173d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
811173dc:	d0a05d17 	ldw	r2,-32396(gp)
811173e0:	100f883a 	mov	r7,r2
811173e4:	01800904 	movi	r6,36
811173e8:	01400044 	movi	r5,1
811173ec:	01204574 	movhi	r4,33045
811173f0:	21276e04 	addi	r4,r4,-25160
811173f4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811173f8:	0001883a 	nop
811173fc:	e037883a 	mov	sp,fp
81117400:	dfc00117 	ldw	ra,4(sp)
81117404:	df000017 	ldw	fp,0(sp)
81117408:	dec00204 	addi	sp,sp,8
8111740c:	f800283a 	ret

81117410 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
81117410:	defffe04 	addi	sp,sp,-8
81117414:	de00012e 	bgeu	sp,et,8111741c <vFailSendPreAckReceiverSemaphore+0xc>
81117418:	003b68fa 	trap	3
8111741c:	dfc00115 	stw	ra,4(sp)
81117420:	df000015 	stw	fp,0(sp)
81117424:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
81117428:	d0a05d17 	ldw	r2,-32396(gp)
8111742c:	100f883a 	mov	r7,r2
81117430:	01800a44 	movi	r6,41
81117434:	01400044 	movi	r5,1
81117438:	01204574 	movhi	r4,33045
8111743c:	21277804 	addi	r4,r4,-25120
81117440:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117444:	0001883a 	nop
81117448:	e037883a 	mov	sp,fp
8111744c:	dfc00117 	ldw	ra,4(sp)
81117450:	df000017 	ldw	fp,0(sp)
81117454:	dec00204 	addi	sp,sp,8
81117458:	f800283a 	ret

8111745c <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111745c:	defffe04 	addi	sp,sp,-8
81117460:	de00012e 	bgeu	sp,et,81117468 <vFailSendPreAckSenderSemaphore+0xc>
81117464:	003b68fa 	trap	3
81117468:	dfc00115 	stw	ra,4(sp)
8111746c:	df000015 	stw	fp,0(sp)
81117470:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
81117474:	d0a05d17 	ldw	r2,-32396(gp)
81117478:	100f883a 	mov	r7,r2
8111747c:	018009c4 	movi	r6,39
81117480:	01400044 	movi	r5,1
81117484:	01204574 	movhi	r4,33045
81117488:	21278304 	addi	r4,r4,-25076
8111748c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117490:	0001883a 	nop
81117494:	e037883a 	mov	sp,fp
81117498:	dfc00117 	ldw	ra,4(sp)
8111749c:	df000017 	ldw	fp,0(sp)
811174a0:	dec00204 	addi	sp,sp,8
811174a4:	f800283a 	ret

811174a8 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
811174a8:	defffe04 	addi	sp,sp,-8
811174ac:	de00012e 	bgeu	sp,et,811174b4 <vFailGetCountSemaphoreSenderTask+0xc>
811174b0:	003b68fa 	trap	3
811174b4:	dfc00115 	stw	ra,4(sp)
811174b8:	df000015 	stw	fp,0(sp)
811174bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
811174c0:	d0a05d17 	ldw	r2,-32396(gp)
811174c4:	100f883a 	mov	r7,r2
811174c8:	01800a44 	movi	r6,41
811174cc:	01400044 	movi	r5,1
811174d0:	01204574 	movhi	r4,33045
811174d4:	21278d04 	addi	r4,r4,-25036
811174d8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
811174dc:	d0a05d17 	ldw	r2,-32396(gp)
811174e0:	100f883a 	mov	r7,r2
811174e4:	01801104 	movi	r6,68
811174e8:	01400044 	movi	r5,1
811174ec:	01204574 	movhi	r4,33045
811174f0:	21279804 	addi	r4,r4,-24992
811174f4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811174f8:	0001883a 	nop
811174fc:	e037883a 	mov	sp,fp
81117500:	dfc00117 	ldw	ra,4(sp)
81117504:	df000017 	ldw	fp,0(sp)
81117508:	dec00204 	addi	sp,sp,8
8111750c:	f800283a 	ret

81117510 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
81117510:	defffe04 	addi	sp,sp,-8
81117514:	de00012e 	bgeu	sp,et,8111751c <vFailGetMutexSenderTask+0xc>
81117518:	003b68fa 	trap	3
8111751c:	dfc00115 	stw	ra,4(sp)
81117520:	df000015 	stw	fp,0(sp)
81117524:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
81117528:	d0a05d17 	ldw	r2,-32396(gp)
8111752c:	100f883a 	mov	r7,r2
81117530:	01800804 	movi	r6,32
81117534:	01400044 	movi	r5,1
81117538:	01204574 	movhi	r4,33045
8111753c:	2127aa04 	addi	r4,r4,-24920
81117540:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
81117544:	d0a05d17 	ldw	r2,-32396(gp)
81117548:	100f883a 	mov	r7,r2
8111754c:	01801084 	movi	r6,66
81117550:	01400044 	movi	r5,1
81117554:	01204574 	movhi	r4,33045
81117558:	2127b304 	addi	r4,r4,-24884
8111755c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117560:	0001883a 	nop
81117564:	e037883a 	mov	sp,fp
81117568:	dfc00117 	ldw	ra,4(sp)
8111756c:	df000017 	ldw	fp,0(sp)
81117570:	dec00204 	addi	sp,sp,8
81117574:	f800283a 	ret

81117578 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
81117578:	defffe04 	addi	sp,sp,-8
8111757c:	de00012e 	bgeu	sp,et,81117584 <vFailGetCountSemaphoreReceiverTask+0xc>
81117580:	003b68fa 	trap	3
81117584:	dfc00115 	stw	ra,4(sp)
81117588:	df000015 	stw	fp,0(sp)
8111758c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
81117590:	d0a05d17 	ldw	r2,-32396(gp)
81117594:	100f883a 	mov	r7,r2
81117598:	01800ac4 	movi	r6,43
8111759c:	01400044 	movi	r5,1
811175a0:	01204574 	movhi	r4,33045
811175a4:	2127c404 	addi	r4,r4,-24816
811175a8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
811175ac:	d0a05d17 	ldw	r2,-32396(gp)
811175b0:	100f883a 	mov	r7,r2
811175b4:	01801184 	movi	r6,70
811175b8:	01400044 	movi	r5,1
811175bc:	01204574 	movhi	r4,33045
811175c0:	2127cf04 	addi	r4,r4,-24772
811175c4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811175c8:	0001883a 	nop
811175cc:	e037883a 	mov	sp,fp
811175d0:	dfc00117 	ldw	ra,4(sp)
811175d4:	df000017 	ldw	fp,0(sp)
811175d8:	dec00204 	addi	sp,sp,8
811175dc:	f800283a 	ret

811175e0 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
811175e0:	defffe04 	addi	sp,sp,-8
811175e4:	de00012e 	bgeu	sp,et,811175ec <vFailGetMutexReceiverTask+0xc>
811175e8:	003b68fa 	trap	3
811175ec:	dfc00115 	stw	ra,4(sp)
811175f0:	df000015 	stw	fp,0(sp)
811175f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
811175f8:	d0a05d17 	ldw	r2,-32396(gp)
811175fc:	100f883a 	mov	r7,r2
81117600:	01800884 	movi	r6,34
81117604:	01400044 	movi	r5,1
81117608:	01204574 	movhi	r4,33045
8111760c:	2127e104 	addi	r4,r4,-24700
81117610:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
81117614:	d0a05d17 	ldw	r2,-32396(gp)
81117618:	100f883a 	mov	r7,r2
8111761c:	01801104 	movi	r6,68
81117620:	01400044 	movi	r5,1
81117624:	01204574 	movhi	r4,33045
81117628:	2127ea04 	addi	r4,r4,-24664
8111762c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117630:	0001883a 	nop
81117634:	e037883a 	mov	sp,fp
81117638:	dfc00117 	ldw	ra,4(sp)
8111763c:	df000017 	ldw	fp,0(sp)
81117640:	dec00204 	addi	sp,sp,8
81117644:	f800283a 	ret

81117648 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
81117648:	defffe04 	addi	sp,sp,-8
8111764c:	de00012e 	bgeu	sp,et,81117654 <vFailGetMutexTxUARTSenderTask+0xc>
81117650:	003b68fa 	trap	3
81117654:	dfc00115 	stw	ra,4(sp)
81117658:	df000015 	stw	fp,0(sp)
8111765c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
81117660:	d0a05d17 	ldw	r2,-32396(gp)
81117664:	100f883a 	mov	r7,r2
81117668:	01800984 	movi	r6,38
8111766c:	01400044 	movi	r5,1
81117670:	01204574 	movhi	r4,33045
81117674:	2127fc04 	addi	r4,r4,-24592
81117678:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111767c:	d0a05d17 	ldw	r2,-32396(gp)
81117680:	100f883a 	mov	r7,r2
81117684:	01801044 	movi	r6,65
81117688:	01400044 	movi	r5,1
8111768c:	01204574 	movhi	r4,33045
81117690:	21280604 	addi	r4,r4,-24552
81117694:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117698:	0001883a 	nop
8111769c:	e037883a 	mov	sp,fp
811176a0:	dfc00117 	ldw	ra,4(sp)
811176a4:	df000017 	ldw	fp,0(sp)
811176a8:	dec00204 	addi	sp,sp,8
811176ac:	f800283a 	ret

811176b0 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
811176b0:	defffe04 	addi	sp,sp,-8
811176b4:	de00012e 	bgeu	sp,et,811176bc <vFailGetMacRTC+0xc>
811176b8:	003b68fa 	trap	3
811176bc:	dfc00115 	stw	ra,4(sp)
811176c0:	df000015 	stw	fp,0(sp)
811176c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
811176c8:	d0a05d17 	ldw	r2,-32396(gp)
811176cc:	100f883a 	mov	r7,r2
811176d0:	018003c4 	movi	r6,15
811176d4:	01400044 	movi	r5,1
811176d8:	01204574 	movhi	r4,33045
811176dc:	21281704 	addi	r4,r4,-24484
811176e0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811176e4:	0001883a 	nop
811176e8:	e037883a 	mov	sp,fp
811176ec:	dfc00117 	ldw	ra,4(sp)
811176f0:	df000017 	ldw	fp,0(sp)
811176f4:	dec00204 	addi	sp,sp,8
811176f8:	f800283a 	ret

811176fc <vFailInitialization>:


void vFailInitialization( void )
{
811176fc:	defffe04 	addi	sp,sp,-8
81117700:	de00012e 	bgeu	sp,et,81117708 <vFailInitialization+0xc>
81117704:	003b68fa 	trap	3
81117708:	dfc00115 	stw	ra,4(sp)
8111770c:	df000015 	stw	fp,0(sp)
81117710:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
81117714:	d0a05d17 	ldw	r2,-32396(gp)
81117718:	100f883a 	mov	r7,r2
8111771c:	01800504 	movi	r6,20
81117720:	01400044 	movi	r5,1
81117724:	01204574 	movhi	r4,33045
81117728:	21281b04 	addi	r4,r4,-24468
8111772c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117730:	0001883a 	nop
81117734:	e037883a 	mov	sp,fp
81117738:	dfc00117 	ldw	ra,4(sp)
8111773c:	df000017 	ldw	fp,0(sp)
81117740:	dec00204 	addi	sp,sp,8
81117744:	f800283a 	ret

81117748 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
81117748:	defffe04 	addi	sp,sp,-8
8111774c:	de00012e 	bgeu	sp,et,81117754 <vFailReceiverCreate+0xc>
81117750:	003b68fa 	trap	3
81117754:	dfc00115 	stw	ra,4(sp)
81117758:	df000015 	stw	fp,0(sp)
8111775c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81117760:	d0a05d17 	ldw	r2,-32396(gp)
81117764:	100f883a 	mov	r7,r2
81117768:	01800484 	movi	r6,18
8111776c:	01400044 	movi	r5,1
81117770:	01204574 	movhi	r4,33045
81117774:	21282104 	addi	r4,r4,-24444
81117778:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111777c:	0001883a 	nop
81117780:	e037883a 	mov	sp,fp
81117784:	dfc00117 	ldw	ra,4(sp)
81117788:	df000017 	ldw	fp,0(sp)
8111778c:	dec00204 	addi	sp,sp,8
81117790:	f800283a 	ret

81117794 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
81117794:	defffe04 	addi	sp,sp,-8
81117798:	de00012e 	bgeu	sp,et,811177a0 <vFailSenderCreate+0xc>
8111779c:	003b68fa 	trap	3
811177a0:	dfc00115 	stw	ra,4(sp)
811177a4:	df000015 	stw	fp,0(sp)
811177a8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
811177ac:	d0a05d17 	ldw	r2,-32396(gp)
811177b0:	100f883a 	mov	r7,r2
811177b4:	01800484 	movi	r6,18
811177b8:	01400044 	movi	r5,1
811177bc:	01204574 	movhi	r4,33045
811177c0:	21282604 	addi	r4,r4,-24424
811177c4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811177c8:	0001883a 	nop
811177cc:	e037883a 	mov	sp,fp
811177d0:	dfc00117 	ldw	ra,4(sp)
811177d4:	df000017 	ldw	fp,0(sp)
811177d8:	dec00204 	addi	sp,sp,8
811177dc:	f800283a 	ret

811177e0 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
811177e0:	defffe04 	addi	sp,sp,-8
811177e4:	de00012e 	bgeu	sp,et,811177ec <vFailDeleteInitialization+0xc>
811177e8:	003b68fa 	trap	3
811177ec:	dfc00115 	stw	ra,4(sp)
811177f0:	df000015 	stw	fp,0(sp)
811177f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
811177f8:	d0a05d17 	ldw	r2,-32396(gp)
811177fc:	100f883a 	mov	r7,r2
81117800:	01800684 	movi	r6,26
81117804:	01400044 	movi	r5,1
81117808:	01204574 	movhi	r4,33045
8111780c:	21282b04 	addi	r4,r4,-24404
81117810:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117814:	0001883a 	nop
81117818:	e037883a 	mov	sp,fp
8111781c:	dfc00117 	ldw	ra,4(sp)
81117820:	df000017 	ldw	fp,0(sp)
81117824:	dec00204 	addi	sp,sp,8
81117828:	f800283a 	ret

8111782c <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111782c:	defffe04 	addi	sp,sp,-8
81117830:	de00012e 	bgeu	sp,et,81117838 <vFailSetCountSemaphorexBuffer32+0xc>
81117834:	003b68fa 	trap	3
81117838:	dfc00115 	stw	ra,4(sp)
8111783c:	df000015 	stw	fp,0(sp)
81117840:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
81117844:	d0a05d17 	ldw	r2,-32396(gp)
81117848:	100f883a 	mov	r7,r2
8111784c:	01800a04 	movi	r6,40
81117850:	01400044 	movi	r5,1
81117854:	01204574 	movhi	r4,33045
81117858:	21283204 	addi	r4,r4,-24376
8111785c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81117860:	d0a05d17 	ldw	r2,-32396(gp)
81117864:	100f883a 	mov	r7,r2
81117868:	018008c4 	movi	r6,35
8111786c:	01400044 	movi	r5,1
81117870:	01204574 	movhi	r4,33045
81117874:	21283d04 	addi	r4,r4,-24332
81117878:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111787c:	0001883a 	nop
81117880:	e037883a 	mov	sp,fp
81117884:	dfc00117 	ldw	ra,4(sp)
81117888:	df000017 	ldw	fp,0(sp)
8111788c:	dec00204 	addi	sp,sp,8
81117890:	f800283a 	ret

81117894 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
81117894:	defffe04 	addi	sp,sp,-8
81117898:	de00012e 	bgeu	sp,et,811178a0 <vFailSetCountSemaphorexBuffer64+0xc>
8111789c:	003b68fa 	trap	3
811178a0:	dfc00115 	stw	ra,4(sp)
811178a4:	df000015 	stw	fp,0(sp)
811178a8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
811178ac:	d0a05d17 	ldw	r2,-32396(gp)
811178b0:	100f883a 	mov	r7,r2
811178b4:	01800a04 	movi	r6,40
811178b8:	01400044 	movi	r5,1
811178bc:	01204574 	movhi	r4,33045
811178c0:	21284604 	addi	r4,r4,-24296
811178c4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
811178c8:	d0a05d17 	ldw	r2,-32396(gp)
811178cc:	100f883a 	mov	r7,r2
811178d0:	018008c4 	movi	r6,35
811178d4:	01400044 	movi	r5,1
811178d8:	01204574 	movhi	r4,33045
811178dc:	21283d04 	addi	r4,r4,-24332
811178e0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811178e4:	0001883a 	nop
811178e8:	e037883a 	mov	sp,fp
811178ec:	dfc00117 	ldw	ra,4(sp)
811178f0:	df000017 	ldw	fp,0(sp)
811178f4:	dec00204 	addi	sp,sp,8
811178f8:	f800283a 	ret

811178fc <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
811178fc:	defffe04 	addi	sp,sp,-8
81117900:	de00012e 	bgeu	sp,et,81117908 <vFailSetCountSemaphorexBuffer128+0xc>
81117904:	003b68fa 	trap	3
81117908:	dfc00115 	stw	ra,4(sp)
8111790c:	df000015 	stw	fp,0(sp)
81117910:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
81117914:	d0a05d17 	ldw	r2,-32396(gp)
81117918:	100f883a 	mov	r7,r2
8111791c:	01800a44 	movi	r6,41
81117920:	01400044 	movi	r5,1
81117924:	01204574 	movhi	r4,33045
81117928:	21285104 	addi	r4,r4,-24252
8111792c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81117930:	d0a05d17 	ldw	r2,-32396(gp)
81117934:	100f883a 	mov	r7,r2
81117938:	018008c4 	movi	r6,35
8111793c:	01400044 	movi	r5,1
81117940:	01204574 	movhi	r4,33045
81117944:	21283d04 	addi	r4,r4,-24332
81117948:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111794c:	0001883a 	nop
81117950:	e037883a 	mov	sp,fp
81117954:	dfc00117 	ldw	ra,4(sp)
81117958:	df000017 	ldw	fp,0(sp)
8111795c:	dec00204 	addi	sp,sp,8
81117960:	f800283a 	ret

81117964 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
81117964:	defffe04 	addi	sp,sp,-8
81117968:	de00012e 	bgeu	sp,et,81117970 <vFailGetCountSemaphorexBuffer128+0xc>
8111796c:	003b68fa 	trap	3
81117970:	dfc00115 	stw	ra,4(sp)
81117974:	df000015 	stw	fp,0(sp)
81117978:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111797c:	d0a05d17 	ldw	r2,-32396(gp)
81117980:	100f883a 	mov	r7,r2
81117984:	01800a44 	movi	r6,41
81117988:	01400044 	movi	r5,1
8111798c:	01204574 	movhi	r4,33045
81117990:	21285c04 	addi	r4,r4,-24208
81117994:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81117998:	d0a05d17 	ldw	r2,-32396(gp)
8111799c:	100f883a 	mov	r7,r2
811179a0:	01800884 	movi	r6,34
811179a4:	01400044 	movi	r5,1
811179a8:	01204574 	movhi	r4,33045
811179ac:	21286704 	addi	r4,r4,-24164
811179b0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811179b4:	0001883a 	nop
811179b8:	e037883a 	mov	sp,fp
811179bc:	dfc00117 	ldw	ra,4(sp)
811179c0:	df000017 	ldw	fp,0(sp)
811179c4:	dec00204 	addi	sp,sp,8
811179c8:	f800283a 	ret

811179cc <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
811179cc:	defffe04 	addi	sp,sp,-8
811179d0:	de00012e 	bgeu	sp,et,811179d8 <vFailGetCountSemaphorexBuffer64+0xc>
811179d4:	003b68fa 	trap	3
811179d8:	dfc00115 	stw	ra,4(sp)
811179dc:	df000015 	stw	fp,0(sp)
811179e0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
811179e4:	d0a05d17 	ldw	r2,-32396(gp)
811179e8:	100f883a 	mov	r7,r2
811179ec:	01800a04 	movi	r6,40
811179f0:	01400044 	movi	r5,1
811179f4:	01204574 	movhi	r4,33045
811179f8:	21287004 	addi	r4,r4,-24128
811179fc:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81117a00:	d0a05d17 	ldw	r2,-32396(gp)
81117a04:	100f883a 	mov	r7,r2
81117a08:	01800884 	movi	r6,34
81117a0c:	01400044 	movi	r5,1
81117a10:	01204574 	movhi	r4,33045
81117a14:	21286704 	addi	r4,r4,-24164
81117a18:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117a1c:	0001883a 	nop
81117a20:	e037883a 	mov	sp,fp
81117a24:	dfc00117 	ldw	ra,4(sp)
81117a28:	df000017 	ldw	fp,0(sp)
81117a2c:	dec00204 	addi	sp,sp,8
81117a30:	f800283a 	ret

81117a34 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
81117a34:	defffe04 	addi	sp,sp,-8
81117a38:	de00012e 	bgeu	sp,et,81117a40 <vFailGetCountSemaphorexBuffer32+0xc>
81117a3c:	003b68fa 	trap	3
81117a40:	dfc00115 	stw	ra,4(sp)
81117a44:	df000015 	stw	fp,0(sp)
81117a48:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
81117a4c:	d0a05d17 	ldw	r2,-32396(gp)
81117a50:	100f883a 	mov	r7,r2
81117a54:	01800a04 	movi	r6,40
81117a58:	01400044 	movi	r5,1
81117a5c:	01204574 	movhi	r4,33045
81117a60:	21287b04 	addi	r4,r4,-24084
81117a64:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81117a68:	d0a05d17 	ldw	r2,-32396(gp)
81117a6c:	100f883a 	mov	r7,r2
81117a70:	01800884 	movi	r6,34
81117a74:	01400044 	movi	r5,1
81117a78:	01204574 	movhi	r4,33045
81117a7c:	21286704 	addi	r4,r4,-24164
81117a80:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117a84:	0001883a 	nop
81117a88:	e037883a 	mov	sp,fp
81117a8c:	dfc00117 	ldw	ra,4(sp)
81117a90:	df000017 	ldw	fp,0(sp)
81117a94:	dec00204 	addi	sp,sp,8
81117a98:	f800283a 	ret

81117a9c <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
81117a9c:	defffe04 	addi	sp,sp,-8
81117aa0:	de00012e 	bgeu	sp,et,81117aa8 <vFailFoundBufferRetransmission+0xc>
81117aa4:	003b68fa 	trap	3
81117aa8:	dfc00115 	stw	ra,4(sp)
81117aac:	df000015 	stw	fp,0(sp)
81117ab0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
81117ab4:	d0a05d17 	ldw	r2,-32396(gp)
81117ab8:	100f883a 	mov	r7,r2
81117abc:	01800a84 	movi	r6,42
81117ac0:	01400044 	movi	r5,1
81117ac4:	01204574 	movhi	r4,33045
81117ac8:	21288604 	addi	r4,r4,-24040
81117acc:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
81117ad0:	d0a05d17 	ldw	r2,-32396(gp)
81117ad4:	100f883a 	mov	r7,r2
81117ad8:	01801204 	movi	r6,72
81117adc:	01400044 	movi	r5,1
81117ae0:	01204574 	movhi	r4,33045
81117ae4:	21289104 	addi	r4,r4,-23996
81117ae8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117aec:	0001883a 	nop
81117af0:	e037883a 	mov	sp,fp
81117af4:	dfc00117 	ldw	ra,4(sp)
81117af8:	df000017 	ldw	fp,0(sp)
81117afc:	dec00204 	addi	sp,sp,8
81117b00:	f800283a 	ret

81117b04 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
81117b04:	defffe04 	addi	sp,sp,-8
81117b08:	de00012e 	bgeu	sp,et,81117b10 <vFailGetCountSemaphorePreParsedBuffer+0xc>
81117b0c:	003b68fa 	trap	3
81117b10:	dfc00115 	stw	ra,4(sp)
81117b14:	df000015 	stw	fp,0(sp)
81117b18:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
81117b1c:	d0a05d17 	ldw	r2,-32396(gp)
81117b20:	100f883a 	mov	r7,r2
81117b24:	01800b84 	movi	r6,46
81117b28:	01400044 	movi	r5,1
81117b2c:	01204574 	movhi	r4,33045
81117b30:	2128a404 	addi	r4,r4,-23920
81117b34:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
81117b38:	d0a05d17 	ldw	r2,-32396(gp)
81117b3c:	100f883a 	mov	r7,r2
81117b40:	018010c4 	movi	r6,67
81117b44:	01400044 	movi	r5,1
81117b48:	01204574 	movhi	r4,33045
81117b4c:	2128b004 	addi	r4,r4,-23872
81117b50:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117b54:	0001883a 	nop
81117b58:	e037883a 	mov	sp,fp
81117b5c:	dfc00117 	ldw	ra,4(sp)
81117b60:	df000017 	ldw	fp,0(sp)
81117b64:	dec00204 	addi	sp,sp,8
81117b68:	f800283a 	ret

81117b6c <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
81117b6c:	defffe04 	addi	sp,sp,-8
81117b70:	de00012e 	bgeu	sp,et,81117b78 <vFailGetxMutexPreParsedParserRxTask+0xc>
81117b74:	003b68fa 	trap	3
81117b78:	dfc00115 	stw	ra,4(sp)
81117b7c:	df000015 	stw	fp,0(sp)
81117b80:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
81117b84:	d0a05d17 	ldw	r2,-32396(gp)
81117b88:	100f883a 	mov	r7,r2
81117b8c:	01800b04 	movi	r6,44
81117b90:	01400044 	movi	r5,1
81117b94:	01204574 	movhi	r4,33045
81117b98:	2128c104 	addi	r4,r4,-23804
81117b9c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
81117ba0:	d0a05d17 	ldw	r2,-32396(gp)
81117ba4:	100f883a 	mov	r7,r2
81117ba8:	01800fc4 	movi	r6,63
81117bac:	01400044 	movi	r5,1
81117bb0:	01204574 	movhi	r4,33045
81117bb4:	2128cd04 	addi	r4,r4,-23756
81117bb8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117bbc:	0001883a 	nop
81117bc0:	e037883a 	mov	sp,fp
81117bc4:	dfc00117 	ldw	ra,4(sp)
81117bc8:	df000017 	ldw	fp,0(sp)
81117bcc:	dec00204 	addi	sp,sp,8
81117bd0:	f800283a 	ret

81117bd4 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
81117bd4:	defffe04 	addi	sp,sp,-8
81117bd8:	de00012e 	bgeu	sp,et,81117be0 <vNoContentInPreParsedBuffer+0xc>
81117bdc:	003b68fa 	trap	3
81117be0:	dfc00115 	stw	ra,4(sp)
81117be4:	df000015 	stw	fp,0(sp)
81117be8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
81117bec:	d0a05d17 	ldw	r2,-32396(gp)
81117bf0:	100f883a 	mov	r7,r2
81117bf4:	01800904 	movi	r6,36
81117bf8:	01400044 	movi	r5,1
81117bfc:	01204574 	movhi	r4,33045
81117c00:	2128dd04 	addi	r4,r4,-23692
81117c04:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
81117c08:	d0a05d17 	ldw	r2,-32396(gp)
81117c0c:	100f883a 	mov	r7,r2
81117c10:	01801684 	movi	r6,90
81117c14:	01400044 	movi	r5,1
81117c18:	01204574 	movhi	r4,33045
81117c1c:	2128e704 	addi	r4,r4,-23652
81117c20:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117c24:	0001883a 	nop
81117c28:	e037883a 	mov	sp,fp
81117c2c:	dfc00117 	ldw	ra,4(sp)
81117c30:	df000017 	ldw	fp,0(sp)
81117c34:	dec00204 	addi	sp,sp,8
81117c38:	f800283a 	ret

81117c3c <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
81117c3c:	defffe04 	addi	sp,sp,-8
81117c40:	de00012e 	bgeu	sp,et,81117c48 <vCouldNotSendEthConfUART+0xc>
81117c44:	003b68fa 	trap	3
81117c48:	dfc00115 	stw	ra,4(sp)
81117c4c:	df000015 	stw	fp,0(sp)
81117c50:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
81117c54:	d0a05d17 	ldw	r2,-32396(gp)
81117c58:	100f883a 	mov	r7,r2
81117c5c:	01800844 	movi	r6,33
81117c60:	01400044 	movi	r5,1
81117c64:	01204574 	movhi	r4,33045
81117c68:	2128fe04 	addi	r4,r4,-23560
81117c6c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
81117c70:	d0a05d17 	ldw	r2,-32396(gp)
81117c74:	100f883a 	mov	r7,r2
81117c78:	01801784 	movi	r6,94
81117c7c:	01400044 	movi	r5,1
81117c80:	01204574 	movhi	r4,33045
81117c84:	21290704 	addi	r4,r4,-23524
81117c88:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117c8c:	0001883a 	nop
81117c90:	e037883a 	mov	sp,fp
81117c94:	dfc00117 	ldw	ra,4(sp)
81117c98:	df000017 	ldw	fp,0(sp)
81117c9c:	dec00204 	addi	sp,sp,8
81117ca0:	f800283a 	ret

81117ca4 <vFailSendNack>:

void vFailSendNack( void )
{
81117ca4:	defffe04 	addi	sp,sp,-8
81117ca8:	de00012e 	bgeu	sp,et,81117cb0 <vFailSendNack+0xc>
81117cac:	003b68fa 	trap	3
81117cb0:	dfc00115 	stw	ra,4(sp)
81117cb4:	df000015 	stw	fp,0(sp)
81117cb8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
81117cbc:	d0a05d17 	ldw	r2,-32396(gp)
81117cc0:	100f883a 	mov	r7,r2
81117cc4:	01800584 	movi	r6,22
81117cc8:	01400044 	movi	r5,1
81117ccc:	01204574 	movhi	r4,33045
81117cd0:	21291f04 	addi	r4,r4,-23428
81117cd4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
81117cd8:	d0a05d17 	ldw	r2,-32396(gp)
81117cdc:	100f883a 	mov	r7,r2
81117ce0:	01800a84 	movi	r6,42
81117ce4:	01400044 	movi	r5,1
81117ce8:	01204574 	movhi	r4,33045
81117cec:	21292504 	addi	r4,r4,-23404
81117cf0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117cf4:	0001883a 	nop
81117cf8:	e037883a 	mov	sp,fp
81117cfc:	dfc00117 	ldw	ra,4(sp)
81117d00:	df000017 	ldw	fp,0(sp)
81117d04:	dec00204 	addi	sp,sp,8
81117d08:	f800283a 	ret

81117d0c <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
81117d0c:	defffe04 	addi	sp,sp,-8
81117d10:	de00012e 	bgeu	sp,et,81117d18 <vFailSetPreAckSenderBuffer+0xc>
81117d14:	003b68fa 	trap	3
81117d18:	dfc00115 	stw	ra,4(sp)
81117d1c:	df000015 	stw	fp,0(sp)
81117d20:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
81117d24:	d0a05d17 	ldw	r2,-32396(gp)
81117d28:	100f883a 	mov	r7,r2
81117d2c:	018008c4 	movi	r6,35
81117d30:	01400044 	movi	r5,1
81117d34:	01204574 	movhi	r4,33045
81117d38:	21293004 	addi	r4,r4,-23360
81117d3c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
81117d40:	d0a05d17 	ldw	r2,-32396(gp)
81117d44:	100f883a 	mov	r7,r2
81117d48:	01801584 	movi	r6,86
81117d4c:	01400044 	movi	r5,1
81117d50:	01204574 	movhi	r4,33045
81117d54:	21293904 	addi	r4,r4,-23324
81117d58:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117d5c:	0001883a 	nop
81117d60:	e037883a 	mov	sp,fp
81117d64:	dfc00117 	ldw	ra,4(sp)
81117d68:	df000017 	ldw	fp,0(sp)
81117d6c:	dec00204 	addi	sp,sp,8
81117d70:	f800283a 	ret

81117d74 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
81117d74:	defffe04 	addi	sp,sp,-8
81117d78:	de00012e 	bgeu	sp,et,81117d80 <vFailSetPreParsedBuffer+0xc>
81117d7c:	003b68fa 	trap	3
81117d80:	dfc00115 	stw	ra,4(sp)
81117d84:	df000015 	stw	fp,0(sp)
81117d88:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
81117d8c:	d0a05d17 	ldw	r2,-32396(gp)
81117d90:	100f883a 	mov	r7,r2
81117d94:	01800804 	movi	r6,32
81117d98:	01400044 	movi	r5,1
81117d9c:	01204574 	movhi	r4,33045
81117da0:	21294f04 	addi	r4,r4,-23236
81117da4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
81117da8:	d0a05d17 	ldw	r2,-32396(gp)
81117dac:	100f883a 	mov	r7,r2
81117db0:	018013c4 	movi	r6,79
81117db4:	01400044 	movi	r5,1
81117db8:	01204574 	movhi	r4,33045
81117dbc:	21295804 	addi	r4,r4,-23200
81117dc0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117dc4:	0001883a 	nop
81117dc8:	e037883a 	mov	sp,fp
81117dcc:	dfc00117 	ldw	ra,4(sp)
81117dd0:	df000017 	ldw	fp,0(sp)
81117dd4:	dec00204 	addi	sp,sp,8
81117dd8:	f800283a 	ret

81117ddc <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
81117ddc:	defffe04 	addi	sp,sp,-8
81117de0:	de00012e 	bgeu	sp,et,81117de8 <vFailSetPreAckReceiverBuffer+0xc>
81117de4:	003b68fa 	trap	3
81117de8:	dfc00115 	stw	ra,4(sp)
81117dec:	df000015 	stw	fp,0(sp)
81117df0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
81117df4:	d0a05d17 	ldw	r2,-32396(gp)
81117df8:	100f883a 	mov	r7,r2
81117dfc:	01800944 	movi	r6,37
81117e00:	01400044 	movi	r5,1
81117e04:	01204574 	movhi	r4,33045
81117e08:	21296c04 	addi	r4,r4,-23120
81117e0c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
81117e10:	d0a05d17 	ldw	r2,-32396(gp)
81117e14:	100f883a 	mov	r7,r2
81117e18:	018015c4 	movi	r6,87
81117e1c:	01400044 	movi	r5,1
81117e20:	01204574 	movhi	r4,33045
81117e24:	21297604 	addi	r4,r4,-23080
81117e28:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117e2c:	0001883a 	nop
81117e30:	e037883a 	mov	sp,fp
81117e34:	dfc00117 	ldw	ra,4(sp)
81117e38:	df000017 	ldw	fp,0(sp)
81117e3c:	dec00204 	addi	sp,sp,8
81117e40:	f800283a 	ret

81117e44 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
81117e44:	defffe04 	addi	sp,sp,-8
81117e48:	de00012e 	bgeu	sp,et,81117e50 <vFailParserCommTaskCreate+0xc>
81117e4c:	003b68fa 	trap	3
81117e50:	dfc00115 	stw	ra,4(sp)
81117e54:	df000015 	stw	fp,0(sp)
81117e58:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
81117e5c:	d0a05d17 	ldw	r2,-32396(gp)
81117e60:	100f883a 	mov	r7,r2
81117e64:	01800684 	movi	r6,26
81117e68:	01400044 	movi	r5,1
81117e6c:	01204574 	movhi	r4,33045
81117e70:	21298c04 	addi	r4,r4,-22992
81117e74:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117e78:	0001883a 	nop
81117e7c:	e037883a 	mov	sp,fp
81117e80:	dfc00117 	ldw	ra,4(sp)
81117e84:	df000017 	ldw	fp,0(sp)
81117e88:	dec00204 	addi	sp,sp,8
81117e8c:	f800283a 	ret

81117e90 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
81117e90:	defffe04 	addi	sp,sp,-8
81117e94:	de00012e 	bgeu	sp,et,81117e9c <vFailInAckHandlerTaskCreate+0xc>
81117e98:	003b68fa 	trap	3
81117e9c:	dfc00115 	stw	ra,4(sp)
81117ea0:	df000015 	stw	fp,0(sp)
81117ea4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81117ea8:	d0a05d17 	ldw	r2,-32396(gp)
81117eac:	100f883a 	mov	r7,r2
81117eb0:	01800704 	movi	r6,28
81117eb4:	01400044 	movi	r5,1
81117eb8:	01204574 	movhi	r4,33045
81117ebc:	21299304 	addi	r4,r4,-22964
81117ec0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117ec4:	0001883a 	nop
81117ec8:	e037883a 	mov	sp,fp
81117ecc:	dfc00117 	ldw	ra,4(sp)
81117ed0:	df000017 	ldw	fp,0(sp)
81117ed4:	dec00204 	addi	sp,sp,8
81117ed8:	f800283a 	ret

81117edc <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
81117edc:	defffe04 	addi	sp,sp,-8
81117ee0:	de00012e 	bgeu	sp,et,81117ee8 <vFailOutAckHandlerTaskCreate+0xc>
81117ee4:	003b68fa 	trap	3
81117ee8:	dfc00115 	stw	ra,4(sp)
81117eec:	df000015 	stw	fp,0(sp)
81117ef0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81117ef4:	d0a05d17 	ldw	r2,-32396(gp)
81117ef8:	100f883a 	mov	r7,r2
81117efc:	01800704 	movi	r6,28
81117f00:	01400044 	movi	r5,1
81117f04:	01204574 	movhi	r4,33045
81117f08:	21299304 	addi	r4,r4,-22964
81117f0c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117f10:	0001883a 	nop
81117f14:	e037883a 	mov	sp,fp
81117f18:	dfc00117 	ldw	ra,4(sp)
81117f1c:	df000017 	ldw	fp,0(sp)
81117f20:	dec00204 	addi	sp,sp,8
81117f24:	f800283a 	ret

81117f28 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
81117f28:	defffe04 	addi	sp,sp,-8
81117f2c:	de00012e 	bgeu	sp,et,81117f34 <vFailCreateTimerRetransmisison+0xc>
81117f30:	003b68fa 	trap	3
81117f34:	dfc00115 	stw	ra,4(sp)
81117f38:	df000015 	stw	fp,0(sp)
81117f3c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
81117f40:	d0a05d17 	ldw	r2,-32396(gp)
81117f44:	100f883a 	mov	r7,r2
81117f48:	018007c4 	movi	r6,31
81117f4c:	01400044 	movi	r5,1
81117f50:	01204574 	movhi	r4,33045
81117f54:	21299b04 	addi	r4,r4,-22932
81117f58:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117f5c:	0001883a 	nop
81117f60:	e037883a 	mov	sp,fp
81117f64:	dfc00117 	ldw	ra,4(sp)
81117f68:	df000017 	ldw	fp,0(sp)
81117f6c:	dec00204 	addi	sp,sp,8
81117f70:	f800283a 	ret

81117f74 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
81117f74:	defffe04 	addi	sp,sp,-8
81117f78:	de00012e 	bgeu	sp,et,81117f80 <vCouldNotCheckBufferTimeOutFunction+0xc>
81117f7c:	003b68fa 	trap	3
81117f80:	dfc00115 	stw	ra,4(sp)
81117f84:	df000015 	stw	fp,0(sp)
81117f88:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
81117f8c:	d0a05d17 	ldw	r2,-32396(gp)
81117f90:	100f883a 	mov	r7,r2
81117f94:	01800904 	movi	r6,36
81117f98:	01400044 	movi	r5,1
81117f9c:	01204574 	movhi	r4,33045
81117fa0:	2129a304 	addi	r4,r4,-22900
81117fa4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117fa8:	0001883a 	nop
81117fac:	e037883a 	mov	sp,fp
81117fb0:	dfc00117 	ldw	ra,4(sp)
81117fb4:	df000017 	ldw	fp,0(sp)
81117fb8:	dec00204 	addi	sp,sp,8
81117fbc:	f800283a 	ret

81117fc0 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
81117fc0:	defffe04 	addi	sp,sp,-8
81117fc4:	de00012e 	bgeu	sp,et,81117fcc <vFailTimeoutCheckerTaskCreate+0xc>
81117fc8:	003b68fa 	trap	3
81117fcc:	dfc00115 	stw	ra,4(sp)
81117fd0:	df000015 	stw	fp,0(sp)
81117fd4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
81117fd8:	d0a05d17 	ldw	r2,-32396(gp)
81117fdc:	100f883a 	mov	r7,r2
81117fe0:	01800a04 	movi	r6,40
81117fe4:	01400044 	movi	r5,1
81117fe8:	01204574 	movhi	r4,33045
81117fec:	2129ad04 	addi	r4,r4,-22860
81117ff0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117ff4:	0001883a 	nop
81117ff8:	e037883a 	mov	sp,fp
81117ffc:	dfc00117 	ldw	ra,4(sp)
81118000:	df000017 	ldw	fp,0(sp)
81118004:	dec00204 	addi	sp,sp,8
81118008:	f800283a 	ret

8111800c <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111800c:	defffe04 	addi	sp,sp,-8
81118010:	de00012e 	bgeu	sp,et,81118018 <vFailGetBlockingSemTimeoutTask+0xc>
81118014:	003b68fa 	trap	3
81118018:	dfc00115 	stw	ra,4(sp)
8111801c:	df000015 	stw	fp,0(sp)
81118020:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
81118024:	d0a05d17 	ldw	r2,-32396(gp)
81118028:	100f883a 	mov	r7,r2
8111802c:	018009c4 	movi	r6,39
81118030:	01400044 	movi	r5,1
81118034:	01204574 	movhi	r4,33045
81118038:	2129b804 	addi	r4,r4,-22816
8111803c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
81118040:	d0a05d17 	ldw	r2,-32396(gp)
81118044:	100f883a 	mov	r7,r2
81118048:	01800cc4 	movi	r6,51
8111804c:	01400044 	movi	r5,1
81118050:	01204574 	movhi	r4,33045
81118054:	2129c204 	addi	r4,r4,-22776
81118058:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111805c:	0001883a 	nop
81118060:	e037883a 	mov	sp,fp
81118064:	dfc00117 	ldw	ra,4(sp)
81118068:	df000017 	ldw	fp,0(sp)
8111806c:	dec00204 	addi	sp,sp,8
81118070:	f800283a 	ret

81118074 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
81118074:	defffe04 	addi	sp,sp,-8
81118078:	de00012e 	bgeu	sp,et,81118080 <vFailPostBlockingSemTimeoutTask+0xc>
8111807c:	003b68fa 	trap	3
81118080:	dfc00115 	stw	ra,4(sp)
81118084:	df000015 	stw	fp,0(sp)
81118088:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111808c:	d0a05d17 	ldw	r2,-32396(gp)
81118090:	100f883a 	mov	r7,r2
81118094:	01800a04 	movi	r6,40
81118098:	01400044 	movi	r5,1
8111809c:	01204574 	movhi	r4,33045
811180a0:	2129cf04 	addi	r4,r4,-22724
811180a4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
811180a8:	d0a05d17 	ldw	r2,-32396(gp)
811180ac:	100f883a 	mov	r7,r2
811180b0:	01800c84 	movi	r6,50
811180b4:	01400044 	movi	r5,1
811180b8:	01204574 	movhi	r4,33045
811180bc:	2129da04 	addi	r4,r4,-22680
811180c0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811180c4:	0001883a 	nop
811180c8:	e037883a 	mov	sp,fp
811180cc:	dfc00117 	ldw	ra,4(sp)
811180d0:	df000017 	ldw	fp,0(sp)
811180d4:	dec00204 	addi	sp,sp,8
811180d8:	f800283a 	ret

811180dc <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
811180dc:	defffe04 	addi	sp,sp,-8
811180e0:	de00012e 	bgeu	sp,et,811180e8 <vFailCouldNotRetransmitTimeoutTask+0xc>
811180e4:	003b68fa 	trap	3
811180e8:	dfc00115 	stw	ra,4(sp)
811180ec:	df000015 	stw	fp,0(sp)
811180f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
811180f4:	d0a05d17 	ldw	r2,-32396(gp)
811180f8:	100f883a 	mov	r7,r2
811180fc:	01800ac4 	movi	r6,43
81118100:	01400044 	movi	r5,1
81118104:	01204574 	movhi	r4,33045
81118108:	2129e704 	addi	r4,r4,-22628
8111810c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
81118110:	d0a05d17 	ldw	r2,-32396(gp)
81118114:	100f883a 	mov	r7,r2
81118118:	01801644 	movi	r6,89
8111811c:	01400044 	movi	r5,1
81118120:	01204574 	movhi	r4,33045
81118124:	2129f204 	addi	r4,r4,-22584
81118128:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111812c:	0001883a 	nop
81118130:	e037883a 	mov	sp,fp
81118134:	dfc00117 	ldw	ra,4(sp)
81118138:	df000017 	ldw	fp,0(sp)
8111813c:	dec00204 	addi	sp,sp,8
81118140:	f800283a 	ret

81118144 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
81118144:	defffe04 	addi	sp,sp,-8
81118148:	de00012e 	bgeu	sp,et,81118150 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111814c:	003b68fa 	trap	3
81118150:	dfc00115 	stw	ra,4(sp)
81118154:	df000015 	stw	fp,0(sp)
81118158:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111815c:	d0a05d17 	ldw	r2,-32396(gp)
81118160:	100f883a 	mov	r7,r2
81118164:	01800a84 	movi	r6,42
81118168:	01400044 	movi	r5,1
8111816c:	01204574 	movhi	r4,33045
81118170:	212a0904 	addi	r4,r4,-22492
81118174:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
81118178:	d0a05d17 	ldw	r2,-32396(gp)
8111817c:	100f883a 	mov	r7,r2
81118180:	01801444 	movi	r6,81
81118184:	01400044 	movi	r5,1
81118188:	01204574 	movhi	r4,33045
8111818c:	212a1404 	addi	r4,r4,-22448
81118190:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118194:	0001883a 	nop
81118198:	e037883a 	mov	sp,fp
8111819c:	dfc00117 	ldw	ra,4(sp)
811181a0:	df000017 	ldw	fp,0(sp)
811181a4:	dec00204 	addi	sp,sp,8
811181a8:	f800283a 	ret

811181ac <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
811181ac:	defffe04 	addi	sp,sp,-8
811181b0:	de00012e 	bgeu	sp,et,811181b8 <vCouldNotRetransmitB64TimeoutTask+0xc>
811181b4:	003b68fa 	trap	3
811181b8:	dfc00115 	stw	ra,4(sp)
811181bc:	df000015 	stw	fp,0(sp)
811181c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
811181c4:	d0a05d17 	ldw	r2,-32396(gp)
811181c8:	100f883a 	mov	r7,r2
811181cc:	01800a84 	movi	r6,42
811181d0:	01400044 	movi	r5,1
811181d4:	01204574 	movhi	r4,33045
811181d8:	212a2904 	addi	r4,r4,-22364
811181dc:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
811181e0:	d0a05d17 	ldw	r2,-32396(gp)
811181e4:	100f883a 	mov	r7,r2
811181e8:	01801444 	movi	r6,81
811181ec:	01400044 	movi	r5,1
811181f0:	01204574 	movhi	r4,33045
811181f4:	212a3404 	addi	r4,r4,-22320
811181f8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811181fc:	0001883a 	nop
81118200:	e037883a 	mov	sp,fp
81118204:	dfc00117 	ldw	ra,4(sp)
81118208:	df000017 	ldw	fp,0(sp)
8111820c:	dec00204 	addi	sp,sp,8
81118210:	f800283a 	ret

81118214 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
81118214:	defffe04 	addi	sp,sp,-8
81118218:	de00012e 	bgeu	sp,et,81118220 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111821c:	003b68fa 	trap	3
81118220:	dfc00115 	stw	ra,4(sp)
81118224:	df000015 	stw	fp,0(sp)
81118228:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111822c:	d0a05d17 	ldw	r2,-32396(gp)
81118230:	100f883a 	mov	r7,r2
81118234:	01800ac4 	movi	r6,43
81118238:	01400044 	movi	r5,1
8111823c:	01204574 	movhi	r4,33045
81118240:	212a4904 	addi	r4,r4,-22236
81118244:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
81118248:	d0a05d17 	ldw	r2,-32396(gp)
8111824c:	100f883a 	mov	r7,r2
81118250:	01801484 	movi	r6,82
81118254:	01400044 	movi	r5,1
81118258:	01204574 	movhi	r4,33045
8111825c:	212a5404 	addi	r4,r4,-22192
81118260:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118264:	0001883a 	nop
81118268:	e037883a 	mov	sp,fp
8111826c:	dfc00117 	ldw	ra,4(sp)
81118270:	df000017 	ldw	fp,0(sp)
81118274:	dec00204 	addi	sp,sp,8
81118278:	f800283a 	ret

8111827c <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111827c:	defffe04 	addi	sp,sp,-8
81118280:	de00012e 	bgeu	sp,et,81118288 <vFailStartTimerRetransmission+0xc>
81118284:	003b68fa 	trap	3
81118288:	dfc00115 	stw	ra,4(sp)
8111828c:	df000015 	stw	fp,0(sp)
81118290:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
81118294:	d0a05d17 	ldw	r2,-32396(gp)
81118298:	100f883a 	mov	r7,r2
8111829c:	01800984 	movi	r6,38
811182a0:	01400044 	movi	r5,1
811182a4:	01204574 	movhi	r4,33045
811182a8:	212a6904 	addi	r4,r4,-22108
811182ac:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
811182b0:	d0a05d17 	ldw	r2,-32396(gp)
811182b4:	100f883a 	mov	r7,r2
811182b8:	01800d44 	movi	r6,53
811182bc:	01400044 	movi	r5,1
811182c0:	01204574 	movhi	r4,33045
811182c4:	212a7304 	addi	r4,r4,-22068
811182c8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811182cc:	0001883a 	nop
811182d0:	e037883a 	mov	sp,fp
811182d4:	dfc00117 	ldw	ra,4(sp)
811182d8:	df000017 	ldw	fp,0(sp)
811182dc:	dec00204 	addi	sp,sp,8
811182e0:	f800283a 	ret

811182e4 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
811182e4:	defffe04 	addi	sp,sp,-8
811182e8:	de00012e 	bgeu	sp,et,811182f0 <vCouldNotSendTurnOff+0xc>
811182ec:	003b68fa 	trap	3
811182f0:	dfc00115 	stw	ra,4(sp)
811182f4:	df000015 	stw	fp,0(sp)
811182f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
811182fc:	d0a05d17 	ldw	r2,-32396(gp)
81118300:	100f883a 	mov	r7,r2
81118304:	01800744 	movi	r6,29
81118308:	01400044 	movi	r5,1
8111830c:	01204574 	movhi	r4,33045
81118310:	212a8104 	addi	r4,r4,-22012
81118314:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
81118318:	d0a05d17 	ldw	r2,-32396(gp)
8111831c:	100f883a 	mov	r7,r2
81118320:	01800984 	movi	r6,38
81118324:	01400044 	movi	r5,1
81118328:	01204574 	movhi	r4,33045
8111832c:	212a8904 	addi	r4,r4,-21980
81118330:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118334:	0001883a 	nop
81118338:	e037883a 	mov	sp,fp
8111833c:	dfc00117 	ldw	ra,4(sp)
81118340:	df000017 	ldw	fp,0(sp)
81118344:	dec00204 	addi	sp,sp,8
81118348:	f800283a 	ret

8111834c <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111834c:	defffe04 	addi	sp,sp,-8
81118350:	de00012e 	bgeu	sp,et,81118358 <vCouldNotSendReset+0xc>
81118354:	003b68fa 	trap	3
81118358:	dfc00115 	stw	ra,4(sp)
8111835c:	df000015 	stw	fp,0(sp)
81118360:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
81118364:	d0a05d17 	ldw	r2,-32396(gp)
81118368:	100f883a 	mov	r7,r2
8111836c:	018006c4 	movi	r6,27
81118370:	01400044 	movi	r5,1
81118374:	01204574 	movhi	r4,33045
81118378:	212a9304 	addi	r4,r4,-21940
8111837c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
81118380:	d0a05d17 	ldw	r2,-32396(gp)
81118384:	100f883a 	mov	r7,r2
81118388:	018008c4 	movi	r6,35
8111838c:	01400044 	movi	r5,1
81118390:	01204574 	movhi	r4,33045
81118394:	212a9a04 	addi	r4,r4,-21912
81118398:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111839c:	0001883a 	nop
811183a0:	e037883a 	mov	sp,fp
811183a4:	dfc00117 	ldw	ra,4(sp)
811183a8:	df000017 	ldw	fp,0(sp)
811183ac:	dec00204 	addi	sp,sp,8
811183b0:	f800283a 	ret

811183b4 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
811183b4:	defffe04 	addi	sp,sp,-8
811183b8:	de00012e 	bgeu	sp,et,811183c0 <vCouldNotSendLog+0xc>
811183bc:	003b68fa 	trap	3
811183c0:	dfc00115 	stw	ra,4(sp)
811183c4:	df000015 	stw	fp,0(sp)
811183c8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
811183cc:	d0a05d17 	ldw	r2,-32396(gp)
811183d0:	100f883a 	mov	r7,r2
811183d4:	01800644 	movi	r6,25
811183d8:	01400044 	movi	r5,1
811183dc:	01204574 	movhi	r4,33045
811183e0:	212aa304 	addi	r4,r4,-21876
811183e4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
811183e8:	d0a05d17 	ldw	r2,-32396(gp)
811183ec:	100f883a 	mov	r7,r2
811183f0:	018008c4 	movi	r6,35
811183f4:	01400044 	movi	r5,1
811183f8:	01204574 	movhi	r4,33045
811183fc:	212aaa04 	addi	r4,r4,-21848
81118400:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118404:	0001883a 	nop
81118408:	e037883a 	mov	sp,fp
8111840c:	dfc00117 	ldw	ra,4(sp)
81118410:	df000017 	ldw	fp,0(sp)
81118414:	dec00204 	addi	sp,sp,8
81118418:	f800283a 	ret

8111841c <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111841c:	defffd04 	addi	sp,sp,-12
81118420:	de00012e 	bgeu	sp,et,81118428 <vCouldNotSendTMPusCommand+0xc>
81118424:	003b68fa 	trap	3
81118428:	dfc00215 	stw	ra,8(sp)
8111842c:	df000115 	stw	fp,4(sp)
81118430:	df000104 	addi	fp,sp,4
81118434:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
81118438:	d0a05d17 	ldw	r2,-32396(gp)
8111843c:	100f883a 	mov	r7,r2
81118440:	01800884 	movi	r6,34
81118444:	01400044 	movi	r5,1
81118448:	01204574 	movhi	r4,33045
8111844c:	212ab304 	addi	r4,r4,-21812
81118450:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
81118454:	d0a05d17 	ldw	r2,-32396(gp)
81118458:	100f883a 	mov	r7,r2
8111845c:	01800ac4 	movi	r6,43
81118460:	01400044 	movi	r5,1
81118464:	01204574 	movhi	r4,33045
81118468:	212abc04 	addi	r4,r4,-21776
8111846c:	111c7b80 	call	8111c7b8 <fwrite>
		debug(fp,"cData");
81118470:	d0a05d17 	ldw	r2,-32396(gp)
81118474:	100f883a 	mov	r7,r2
81118478:	01800144 	movi	r6,5
8111847c:	01400044 	movi	r5,1
81118480:	01204574 	movhi	r4,33045
81118484:	212ac704 	addi	r4,r4,-21732
81118488:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111848c:	0001883a 	nop
81118490:	e037883a 	mov	sp,fp
81118494:	dfc00117 	ldw	ra,4(sp)
81118498:	df000017 	ldw	fp,0(sp)
8111849c:	dec00204 	addi	sp,sp,8
811184a0:	f800283a 	ret

811184a4 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
811184a4:	defffe04 	addi	sp,sp,-8
811184a8:	de00012e 	bgeu	sp,et,811184b0 <vWarnCouldNotgetMutexRetrans128+0xc>
811184ac:	003b68fa 	trap	3
811184b0:	dfc00115 	stw	ra,4(sp)
811184b4:	df000015 	stw	fp,0(sp)
811184b8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
811184bc:	d0a05d17 	ldw	r2,-32396(gp)
811184c0:	100f883a 	mov	r7,r2
811184c4:	01800a04 	movi	r6,40
811184c8:	01400044 	movi	r5,1
811184cc:	01204574 	movhi	r4,33045
811184d0:	212ac904 	addi	r4,r4,-21724
811184d4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
811184d8:	d0a05d17 	ldw	r2,-32396(gp)
811184dc:	100f883a 	mov	r7,r2
811184e0:	018014c4 	movi	r6,83
811184e4:	01400044 	movi	r5,1
811184e8:	01204574 	movhi	r4,33045
811184ec:	212ad404 	addi	r4,r4,-21680
811184f0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811184f4:	0001883a 	nop
811184f8:	e037883a 	mov	sp,fp
811184fc:	dfc00117 	ldw	ra,4(sp)
81118500:	df000017 	ldw	fp,0(sp)
81118504:	dec00204 	addi	sp,sp,8
81118508:	f800283a 	ret

8111850c <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111850c:	defffe04 	addi	sp,sp,-8
81118510:	de00012e 	bgeu	sp,et,81118518 <vFailCreateScheduleQueue+0xc>
81118514:	003b68fa 	trap	3
81118518:	dfc00115 	stw	ra,4(sp)
8111851c:	df000015 	stw	fp,0(sp)
81118520:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
81118524:	d0a05d17 	ldw	r2,-32396(gp)
81118528:	100f883a 	mov	r7,r2
8111852c:	01800844 	movi	r6,33
81118530:	01400044 	movi	r5,1
81118534:	01204574 	movhi	r4,33045
81118538:	212ae904 	addi	r4,r4,-21596
8111853c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
81118540:	d0a05d17 	ldw	r2,-32396(gp)
81118544:	100f883a 	mov	r7,r2
81118548:	01801204 	movi	r6,72
8111854c:	01400044 	movi	r5,1
81118550:	01204574 	movhi	r4,33045
81118554:	212af204 	addi	r4,r4,-21560
81118558:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111855c:	0001883a 	nop
81118560:	e037883a 	mov	sp,fp
81118564:	dfc00117 	ldw	ra,4(sp)
81118568:	df000017 	ldw	fp,0(sp)
8111856c:	dec00204 	addi	sp,sp,8
81118570:	f800283a 	ret

81118574 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
81118574:	defffd04 	addi	sp,sp,-12
81118578:	de00012e 	bgeu	sp,et,81118580 <vFailCreateNFEEQueue+0xc>
8111857c:	003b68fa 	trap	3
81118580:	dfc00215 	stw	ra,8(sp)
81118584:	df000115 	stw	fp,4(sp)
81118588:	df000104 	addi	fp,sp,4
8111858c:	2005883a 	mov	r2,r4
81118590:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
81118594:	d0a05d17 	ldw	r2,-32396(gp)
81118598:	100f883a 	mov	r7,r2
8111859c:	01800744 	movi	r6,29
811185a0:	01400044 	movi	r5,1
811185a4:	01204574 	movhi	r4,33045
811185a8:	212b0504 	addi	r4,r4,-21484
811185ac:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
811185b0:	d0a05d17 	ldw	r2,-32396(gp)
811185b4:	e0ffff03 	ldbu	r3,-4(fp)
811185b8:	180d883a 	mov	r6,r3
811185bc:	01604574 	movhi	r5,33045
811185c0:	296b0d04 	addi	r5,r5,-21452
811185c4:	1009883a 	mov	r4,r2
811185c8:	111d4e40 	call	8111d4e4 <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811185cc:	0001883a 	nop
811185d0:	e037883a 	mov	sp,fp
811185d4:	dfc00117 	ldw	ra,4(sp)
811185d8:	df000017 	ldw	fp,0(sp)
811185dc:	dec00204 	addi	sp,sp,8
811185e0:	f800283a 	ret

811185e4 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
811185e4:	defffd04 	addi	sp,sp,-12
811185e8:	de00012e 	bgeu	sp,et,811185f0 <vFailCreateNFEESyncQueue+0xc>
811185ec:	003b68fa 	trap	3
811185f0:	dfc00215 	stw	ra,8(sp)
811185f4:	df000115 	stw	fp,4(sp)
811185f8:	df000104 	addi	fp,sp,4
811185fc:	2005883a 	mov	r2,r4
81118600:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
81118604:	d0a05d17 	ldw	r2,-32396(gp)
81118608:	100f883a 	mov	r7,r2
8111860c:	01800844 	movi	r6,33
81118610:	01400044 	movi	r5,1
81118614:	01204574 	movhi	r4,33045
81118618:	212b1b04 	addi	r4,r4,-21396
8111861c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
81118620:	d0a05d17 	ldw	r2,-32396(gp)
81118624:	e0ffff03 	ldbu	r3,-4(fp)
81118628:	180d883a 	mov	r6,r3
8111862c:	01604574 	movhi	r5,33045
81118630:	296b2404 	addi	r5,r5,-21360
81118634:	1009883a 	mov	r4,r2
81118638:	111d4e40 	call	8111d4e4 <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111863c:	0001883a 	nop
81118640:	e037883a 	mov	sp,fp
81118644:	dfc00117 	ldw	ra,4(sp)
81118648:	df000017 	ldw	fp,0(sp)
8111864c:	dec00204 	addi	sp,sp,8
81118650:	f800283a 	ret

81118654 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
81118654:	defffe04 	addi	sp,sp,-8
81118658:	de00012e 	bgeu	sp,et,81118660 <vCoudlNotCreateNFee0Task+0xc>
8111865c:	003b68fa 	trap	3
81118660:	dfc00115 	stw	ra,4(sp)
81118664:	df000015 	stw	fp,0(sp)
81118668:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111866c:	d0a05d17 	ldw	r2,-32396(gp)
81118670:	100f883a 	mov	r7,r2
81118674:	01800844 	movi	r6,33
81118678:	01400044 	movi	r5,1
8111867c:	01204574 	movhi	r4,33045
81118680:	212b3204 	addi	r4,r4,-21304
81118684:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
81118688:	d0a05d17 	ldw	r2,-32396(gp)
8111868c:	100f883a 	mov	r7,r2
81118690:	01800784 	movi	r6,30
81118694:	01400044 	movi	r5,1
81118698:	01204574 	movhi	r4,33045
8111869c:	212b3b04 	addi	r4,r4,-21268
811186a0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811186a4:	0001883a 	nop
811186a8:	e037883a 	mov	sp,fp
811186ac:	dfc00117 	ldw	ra,4(sp)
811186b0:	df000017 	ldw	fp,0(sp)
811186b4:	dec00204 	addi	sp,sp,8
811186b8:	f800283a 	ret

811186bc <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
811186bc:	defffe04 	addi	sp,sp,-8
811186c0:	de00012e 	bgeu	sp,et,811186c8 <vCoudlNotCreateNFee1Task+0xc>
811186c4:	003b68fa 	trap	3
811186c8:	dfc00115 	stw	ra,4(sp)
811186cc:	df000015 	stw	fp,0(sp)
811186d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
811186d4:	d0a05d17 	ldw	r2,-32396(gp)
811186d8:	100f883a 	mov	r7,r2
811186dc:	01800844 	movi	r6,33
811186e0:	01400044 	movi	r5,1
811186e4:	01204574 	movhi	r4,33045
811186e8:	212b4304 	addi	r4,r4,-21236
811186ec:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
811186f0:	d0a05d17 	ldw	r2,-32396(gp)
811186f4:	100f883a 	mov	r7,r2
811186f8:	01800784 	movi	r6,30
811186fc:	01400044 	movi	r5,1
81118700:	01204574 	movhi	r4,33045
81118704:	212b4c04 	addi	r4,r4,-21200
81118708:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111870c:	0001883a 	nop
81118710:	e037883a 	mov	sp,fp
81118714:	dfc00117 	ldw	ra,4(sp)
81118718:	df000017 	ldw	fp,0(sp)
8111871c:	dec00204 	addi	sp,sp,8
81118720:	f800283a 	ret

81118724 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
81118724:	defffe04 	addi	sp,sp,-8
81118728:	de00012e 	bgeu	sp,et,81118730 <vCoudlNotCreateNFee2Task+0xc>
8111872c:	003b68fa 	trap	3
81118730:	dfc00115 	stw	ra,4(sp)
81118734:	df000015 	stw	fp,0(sp)
81118738:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111873c:	d0a05d17 	ldw	r2,-32396(gp)
81118740:	100f883a 	mov	r7,r2
81118744:	01800844 	movi	r6,33
81118748:	01400044 	movi	r5,1
8111874c:	01204574 	movhi	r4,33045
81118750:	212b5404 	addi	r4,r4,-21168
81118754:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
81118758:	d0a05d17 	ldw	r2,-32396(gp)
8111875c:	100f883a 	mov	r7,r2
81118760:	01800784 	movi	r6,30
81118764:	01400044 	movi	r5,1
81118768:	01204574 	movhi	r4,33045
8111876c:	212b5d04 	addi	r4,r4,-21132
81118770:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118774:	0001883a 	nop
81118778:	e037883a 	mov	sp,fp
8111877c:	dfc00117 	ldw	ra,4(sp)
81118780:	df000017 	ldw	fp,0(sp)
81118784:	dec00204 	addi	sp,sp,8
81118788:	f800283a 	ret

8111878c <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111878c:	defffe04 	addi	sp,sp,-8
81118790:	de00012e 	bgeu	sp,et,81118798 <vCoudlNotCreateNFee3Task+0xc>
81118794:	003b68fa 	trap	3
81118798:	dfc00115 	stw	ra,4(sp)
8111879c:	df000015 	stw	fp,0(sp)
811187a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
811187a4:	d0a05d17 	ldw	r2,-32396(gp)
811187a8:	100f883a 	mov	r7,r2
811187ac:	01800844 	movi	r6,33
811187b0:	01400044 	movi	r5,1
811187b4:	01204574 	movhi	r4,33045
811187b8:	212b6504 	addi	r4,r4,-21100
811187bc:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
811187c0:	d0a05d17 	ldw	r2,-32396(gp)
811187c4:	100f883a 	mov	r7,r2
811187c8:	01800784 	movi	r6,30
811187cc:	01400044 	movi	r5,1
811187d0:	01204574 	movhi	r4,33045
811187d4:	212b6e04 	addi	r4,r4,-21064
811187d8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811187dc:	0001883a 	nop
811187e0:	e037883a 	mov	sp,fp
811187e4:	dfc00117 	ldw	ra,4(sp)
811187e8:	df000017 	ldw	fp,0(sp)
811187ec:	dec00204 	addi	sp,sp,8
811187f0:	f800283a 	ret

811187f4 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
811187f4:	defffe04 	addi	sp,sp,-8
811187f8:	de00012e 	bgeu	sp,et,81118800 <vCoudlNotCreateNFee4Task+0xc>
811187fc:	003b68fa 	trap	3
81118800:	dfc00115 	stw	ra,4(sp)
81118804:	df000015 	stw	fp,0(sp)
81118808:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111880c:	d0a05d17 	ldw	r2,-32396(gp)
81118810:	100f883a 	mov	r7,r2
81118814:	01800844 	movi	r6,33
81118818:	01400044 	movi	r5,1
8111881c:	01204574 	movhi	r4,33045
81118820:	212b7604 	addi	r4,r4,-21032
81118824:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
81118828:	d0a05d17 	ldw	r2,-32396(gp)
8111882c:	100f883a 	mov	r7,r2
81118830:	01800784 	movi	r6,30
81118834:	01400044 	movi	r5,1
81118838:	01204574 	movhi	r4,33045
8111883c:	212b7f04 	addi	r4,r4,-20996
81118840:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118844:	0001883a 	nop
81118848:	e037883a 	mov	sp,fp
8111884c:	dfc00117 	ldw	ra,4(sp)
81118850:	df000017 	ldw	fp,0(sp)
81118854:	dec00204 	addi	sp,sp,8
81118858:	f800283a 	ret

8111885c <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111885c:	defffe04 	addi	sp,sp,-8
81118860:	de00012e 	bgeu	sp,et,81118868 <vCoudlNotCreateNFee5Task+0xc>
81118864:	003b68fa 	trap	3
81118868:	dfc00115 	stw	ra,4(sp)
8111886c:	df000015 	stw	fp,0(sp)
81118870:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
81118874:	d0a05d17 	ldw	r2,-32396(gp)
81118878:	100f883a 	mov	r7,r2
8111887c:	01800844 	movi	r6,33
81118880:	01400044 	movi	r5,1
81118884:	01204574 	movhi	r4,33045
81118888:	212b8704 	addi	r4,r4,-20964
8111888c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
81118890:	d0a05d17 	ldw	r2,-32396(gp)
81118894:	100f883a 	mov	r7,r2
81118898:	01800784 	movi	r6,30
8111889c:	01400044 	movi	r5,1
811188a0:	01204574 	movhi	r4,33045
811188a4:	212b9004 	addi	r4,r4,-20928
811188a8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811188ac:	0001883a 	nop
811188b0:	e037883a 	mov	sp,fp
811188b4:	dfc00117 	ldw	ra,4(sp)
811188b8:	df000017 	ldw	fp,0(sp)
811188bc:	dec00204 	addi	sp,sp,8
811188c0:	f800283a 	ret

811188c4 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
811188c4:	defffe04 	addi	sp,sp,-8
811188c8:	de00012e 	bgeu	sp,et,811188d0 <vCoudlNotCreateNFeeControllerTask+0xc>
811188cc:	003b68fa 	trap	3
811188d0:	dfc00115 	stw	ra,4(sp)
811188d4:	df000015 	stw	fp,0(sp)
811188d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
811188dc:	d0a05d17 	ldw	r2,-32396(gp)
811188e0:	100f883a 	mov	r7,r2
811188e4:	01800a84 	movi	r6,42
811188e8:	01400044 	movi	r5,1
811188ec:	01204574 	movhi	r4,33045
811188f0:	212b9804 	addi	r4,r4,-20896
811188f4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
811188f8:	d0a05d17 	ldw	r2,-32396(gp)
811188fc:	100f883a 	mov	r7,r2
81118900:	018009c4 	movi	r6,39
81118904:	01400044 	movi	r5,1
81118908:	01204574 	movhi	r4,33045
8111890c:	212ba304 	addi	r4,r4,-20852
81118910:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118914:	0001883a 	nop
81118918:	e037883a 	mov	sp,fp
8111891c:	dfc00117 	ldw	ra,4(sp)
81118920:	df000017 	ldw	fp,0(sp)
81118924:	dec00204 	addi	sp,sp,8
81118928:	f800283a 	ret

8111892c <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111892c:	defffe04 	addi	sp,sp,-8
81118930:	de00012e 	bgeu	sp,et,81118938 <vCoudlNotCreateDataControllerTask+0xc>
81118934:	003b68fa 	trap	3
81118938:	dfc00115 	stw	ra,4(sp)
8111893c:	df000015 	stw	fp,0(sp)
81118940:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
81118944:	d0a05d17 	ldw	r2,-32396(gp)
81118948:	100f883a 	mov	r7,r2
8111894c:	01800a84 	movi	r6,42
81118950:	01400044 	movi	r5,1
81118954:	01204574 	movhi	r4,33045
81118958:	212bad04 	addi	r4,r4,-20812
8111895c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
81118960:	d0a05d17 	ldw	r2,-32396(gp)
81118964:	100f883a 	mov	r7,r2
81118968:	018009c4 	movi	r6,39
8111896c:	01400044 	movi	r5,1
81118970:	01204574 	movhi	r4,33045
81118974:	212bb804 	addi	r4,r4,-20768
81118978:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111897c:	0001883a 	nop
81118980:	e037883a 	mov	sp,fp
81118984:	dfc00117 	ldw	ra,4(sp)
81118988:	df000017 	ldw	fp,0(sp)
8111898c:	dec00204 	addi	sp,sp,8
81118990:	f800283a 	ret

81118994 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
81118994:	defffe04 	addi	sp,sp,-8
81118998:	de00012e 	bgeu	sp,et,811189a0 <vCoudlNotCreateMebTask+0xc>
8111899c:	003b68fa 	trap	3
811189a0:	dfc00115 	stw	ra,4(sp)
811189a4:	df000015 	stw	fp,0(sp)
811189a8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
811189ac:	d0a05d17 	ldw	r2,-32396(gp)
811189b0:	100f883a 	mov	r7,r2
811189b4:	018007c4 	movi	r6,31
811189b8:	01400044 	movi	r5,1
811189bc:	01204574 	movhi	r4,33045
811189c0:	212bc204 	addi	r4,r4,-20728
811189c4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
811189c8:	d0a05d17 	ldw	r2,-32396(gp)
811189cc:	100f883a 	mov	r7,r2
811189d0:	018006c4 	movi	r6,27
811189d4:	01400044 	movi	r5,1
811189d8:	01204574 	movhi	r4,33045
811189dc:	212bca04 	addi	r4,r4,-20696
811189e0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811189e4:	0001883a 	nop
811189e8:	e037883a 	mov	sp,fp
811189ec:	dfc00117 	ldw	ra,4(sp)
811189f0:	df000017 	ldw	fp,0(sp)
811189f4:	dec00204 	addi	sp,sp,8
811189f8:	f800283a 	ret

811189fc <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
811189fc:	defffd04 	addi	sp,sp,-12
81118a00:	de00012e 	bgeu	sp,et,81118a08 <vFailCreateMutexSPUSQueueMeb+0xc>
81118a04:	003b68fa 	trap	3
81118a08:	dfc00215 	stw	ra,8(sp)
81118a0c:	df000115 	stw	fp,4(sp)
81118a10:	df000104 	addi	fp,sp,4
81118a14:	2005883a 	mov	r2,r4
81118a18:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
81118a1c:	d0a05d17 	ldw	r2,-32396(gp)
81118a20:	100f883a 	mov	r7,r2
81118a24:	01800944 	movi	r6,37
81118a28:	01400044 	movi	r5,1
81118a2c:	01204574 	movhi	r4,33045
81118a30:	212bd104 	addi	r4,r4,-20668
81118a34:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81118a38:	e0bfff03 	ldbu	r2,-4(fp)
81118a3c:	1009883a 	mov	r4,r2
81118a40:	11171a80 	call	811171a8 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118a44:	0001883a 	nop
81118a48:	e037883a 	mov	sp,fp
81118a4c:	dfc00117 	ldw	ra,4(sp)
81118a50:	df000017 	ldw	fp,0(sp)
81118a54:	dec00204 	addi	sp,sp,8
81118a58:	f800283a 	ret

81118a5c <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
81118a5c:	defffe04 	addi	sp,sp,-8
81118a60:	de00012e 	bgeu	sp,et,81118a68 <vFailSendPUStoMebTask+0xc>
81118a64:	003b68fa 	trap	3
81118a68:	dfc00115 	stw	ra,4(sp)
81118a6c:	df000015 	stw	fp,0(sp)
81118a70:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
81118a74:	d0a05d17 	ldw	r2,-32396(gp)
81118a78:	100f883a 	mov	r7,r2
81118a7c:	01800784 	movi	r6,30
81118a80:	01400044 	movi	r5,1
81118a84:	01204574 	movhi	r4,33045
81118a88:	212bdb04 	addi	r4,r4,-20628
81118a8c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118a90:	0001883a 	nop
81118a94:	e037883a 	mov	sp,fp
81118a98:	dfc00117 	ldw	ra,4(sp)
81118a9c:	df000017 	ldw	fp,0(sp)
81118aa0:	dec00204 	addi	sp,sp,8
81118aa4:	f800283a 	ret

81118aa8 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
81118aa8:	defffe04 	addi	sp,sp,-8
81118aac:	de00012e 	bgeu	sp,et,81118ab4 <vCouldNotGetCmdQueueMeb+0xc>
81118ab0:	003b68fa 	trap	3
81118ab4:	dfc00115 	stw	ra,4(sp)
81118ab8:	df000015 	stw	fp,0(sp)
81118abc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
81118ac0:	d0a05d17 	ldw	r2,-32396(gp)
81118ac4:	100f883a 	mov	r7,r2
81118ac8:	01800a84 	movi	r6,42
81118acc:	01400044 	movi	r5,1
81118ad0:	01204574 	movhi	r4,33045
81118ad4:	212be304 	addi	r4,r4,-20596
81118ad8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
81118adc:	d0a05d17 	ldw	r2,-32396(gp)
81118ae0:	100f883a 	mov	r7,r2
81118ae4:	01800cc4 	movi	r6,51
81118ae8:	01400044 	movi	r5,1
81118aec:	01204574 	movhi	r4,33045
81118af0:	212bee04 	addi	r4,r4,-20552
81118af4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118af8:	0001883a 	nop
81118afc:	e037883a 	mov	sp,fp
81118b00:	dfc00117 	ldw	ra,4(sp)
81118b04:	df000017 	ldw	fp,0(sp)
81118b08:	dec00204 	addi	sp,sp,8
81118b0c:	f800283a 	ret

81118b10 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
81118b10:	defffe04 	addi	sp,sp,-8
81118b14:	de00012e 	bgeu	sp,et,81118b1c <vCouldNotGetMutexMebPus+0xc>
81118b18:	003b68fa 	trap	3
81118b1c:	dfc00115 	stw	ra,4(sp)
81118b20:	df000015 	stw	fp,0(sp)
81118b24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
81118b28:	d0a05d17 	ldw	r2,-32396(gp)
81118b2c:	100f883a 	mov	r7,r2
81118b30:	01800804 	movi	r6,32
81118b34:	01400044 	movi	r5,1
81118b38:	01204574 	movhi	r4,33045
81118b3c:	212bfb04 	addi	r4,r4,-20500
81118b40:	111c7b80 	call	8111c7b8 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118b44:	0001883a 	nop
81118b48:	e037883a 	mov	sp,fp
81118b4c:	dfc00117 	ldw	ra,4(sp)
81118b50:	df000017 	ldw	fp,0(sp)
81118b54:	dec00204 	addi	sp,sp,8
81118b58:	f800283a 	ret

81118b5c <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
81118b5c:	defffe04 	addi	sp,sp,-8
81118b60:	de00012e 	bgeu	sp,et,81118b68 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
81118b64:	003b68fa 	trap	3
81118b68:	dfc00115 	stw	ra,4(sp)
81118b6c:	df000015 	stw	fp,0(sp)
81118b70:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
81118b74:	d0a05d17 	ldw	r2,-32396(gp)
81118b78:	100f883a 	mov	r7,r2
81118b7c:	01800a44 	movi	r6,41
81118b80:	01400044 	movi	r5,1
81118b84:	01204574 	movhi	r4,33045
81118b88:	212c0404 	addi	r4,r4,-20464
81118b8c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
81118b90:	d0a05d17 	ldw	r2,-32396(gp)
81118b94:	100f883a 	mov	r7,r2
81118b98:	01800c84 	movi	r6,50
81118b9c:	01400044 	movi	r5,1
81118ba0:	01204574 	movhi	r4,33045
81118ba4:	212c0f04 	addi	r4,r4,-20420
81118ba8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118bac:	0001883a 	nop
81118bb0:	e037883a 	mov	sp,fp
81118bb4:	dfc00117 	ldw	ra,4(sp)
81118bb8:	df000017 	ldw	fp,0(sp)
81118bbc:	dec00204 	addi	sp,sp,8
81118bc0:	f800283a 	ret

81118bc4 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
81118bc4:	defffe04 	addi	sp,sp,-8
81118bc8:	de00012e 	bgeu	sp,et,81118bd0 <vCouldNotCreateQueueMaskDataCtrl+0xc>
81118bcc:	003b68fa 	trap	3
81118bd0:	dfc00115 	stw	ra,4(sp)
81118bd4:	df000015 	stw	fp,0(sp)
81118bd8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
81118bdc:	d0a05d17 	ldw	r2,-32396(gp)
81118be0:	100f883a 	mov	r7,r2
81118be4:	01800a44 	movi	r6,41
81118be8:	01400044 	movi	r5,1
81118bec:	01204574 	movhi	r4,33045
81118bf0:	212c1c04 	addi	r4,r4,-20368
81118bf4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
81118bf8:	d0a05d17 	ldw	r2,-32396(gp)
81118bfc:	100f883a 	mov	r7,r2
81118c00:	01800c84 	movi	r6,50
81118c04:	01400044 	movi	r5,1
81118c08:	01204574 	movhi	r4,33045
81118c0c:	212c2704 	addi	r4,r4,-20324
81118c10:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118c14:	0001883a 	nop
81118c18:	e037883a 	mov	sp,fp
81118c1c:	dfc00117 	ldw	ra,4(sp)
81118c20:	df000017 	ldw	fp,0(sp)
81118c24:	dec00204 	addi	sp,sp,8
81118c28:	f800283a 	ret

81118c2c <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
81118c2c:	defffe04 	addi	sp,sp,-8
81118c30:	de00012e 	bgeu	sp,et,81118c38 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
81118c34:	003b68fa 	trap	3
81118c38:	dfc00115 	stw	ra,4(sp)
81118c3c:	df000015 	stw	fp,0(sp)
81118c40:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
81118c44:	d0a05d17 	ldw	r2,-32396(gp)
81118c48:	100f883a 	mov	r7,r2
81118c4c:	01800984 	movi	r6,38
81118c50:	01400044 	movi	r5,1
81118c54:	01204574 	movhi	r4,33045
81118c58:	212c3404 	addi	r4,r4,-20272
81118c5c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
81118c60:	d0a05d17 	ldw	r2,-32396(gp)
81118c64:	100f883a 	mov	r7,r2
81118c68:	01800bc4 	movi	r6,47
81118c6c:	01400044 	movi	r5,1
81118c70:	01204574 	movhi	r4,33045
81118c74:	212c3e04 	addi	r4,r4,-20232
81118c78:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118c7c:	0001883a 	nop
81118c80:	e037883a 	mov	sp,fp
81118c84:	dfc00117 	ldw	ra,4(sp)
81118c88:	df000017 	ldw	fp,0(sp)
81118c8c:	dec00204 	addi	sp,sp,8
81118c90:	f800283a 	ret

81118c94 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
81118c94:	defffe04 	addi	sp,sp,-8
81118c98:	de00012e 	bgeu	sp,et,81118ca0 <vCouldNotGetQueueMaskDataCtrl+0xc>
81118c9c:	003b68fa 	trap	3
81118ca0:	dfc00115 	stw	ra,4(sp)
81118ca4:	df000015 	stw	fp,0(sp)
81118ca8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
81118cac:	d0a05d17 	ldw	r2,-32396(gp)
81118cb0:	100f883a 	mov	r7,r2
81118cb4:	01800984 	movi	r6,38
81118cb8:	01400044 	movi	r5,1
81118cbc:	01204574 	movhi	r4,33045
81118cc0:	212c4a04 	addi	r4,r4,-20184
81118cc4:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
81118cc8:	d0a05d17 	ldw	r2,-32396(gp)
81118ccc:	100f883a 	mov	r7,r2
81118cd0:	01800bc4 	movi	r6,47
81118cd4:	01400044 	movi	r5,1
81118cd8:	01204574 	movhi	r4,33045
81118cdc:	212c5404 	addi	r4,r4,-20144
81118ce0:	111c7b80 	call	8111c7b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118ce4:	0001883a 	nop
81118ce8:	e037883a 	mov	sp,fp
81118cec:	dfc00117 	ldw	ra,4(sp)
81118cf0:	df000017 	ldw	fp,0(sp)
81118cf4:	dec00204 	addi	sp,sp,8
81118cf8:	f800283a 	ret

81118cfc <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
81118cfc:	defffd04 	addi	sp,sp,-12
81118d00:	de00012e 	bgeu	sp,et,81118d08 <vFailSendMsgAccessDMA+0xc>
81118d04:	003b68fa 	trap	3
81118d08:	dfc00215 	stw	ra,8(sp)
81118d0c:	df000115 	stw	fp,4(sp)
81118d10:	df000104 	addi	fp,sp,4
81118d14:	2005883a 	mov	r2,r4
81118d18:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
81118d1c:	d0a05d17 	ldw	r2,-32396(gp)
81118d20:	e0ffff03 	ldbu	r3,-4(fp)
81118d24:	180d883a 	mov	r6,r3
81118d28:	01604574 	movhi	r5,33045
81118d2c:	296c6004 	addi	r5,r5,-20096
81118d30:	1009883a 	mov	r4,r2
81118d34:	111c11c0 	call	8111c11c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118d38:	0001883a 	nop
81118d3c:	e037883a 	mov	sp,fp
81118d40:	dfc00117 	ldw	ra,4(sp)
81118d44:	df000017 	ldw	fp,0(sp)
81118d48:	dec00204 	addi	sp,sp,8
81118d4c:	f800283a 	ret

81118d50 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
81118d50:	defffd04 	addi	sp,sp,-12
81118d54:	de00012e 	bgeu	sp,et,81118d5c <vFailRequestDMA+0xc>
81118d58:	003b68fa 	trap	3
81118d5c:	dfc00215 	stw	ra,8(sp)
81118d60:	df000115 	stw	fp,4(sp)
81118d64:	df000104 	addi	fp,sp,4
81118d68:	2005883a 	mov	r2,r4
81118d6c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
81118d70:	d0a05d17 	ldw	r2,-32396(gp)
81118d74:	e0ffff03 	ldbu	r3,-4(fp)
81118d78:	180d883a 	mov	r6,r3
81118d7c:	01604574 	movhi	r5,33045
81118d80:	296c6804 	addi	r5,r5,-20064
81118d84:	1009883a 	mov	r4,r2
81118d88:	111c11c0 	call	8111c11c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118d8c:	0001883a 	nop
81118d90:	e037883a 	mov	sp,fp
81118d94:	dfc00117 	ldw	ra,4(sp)
81118d98:	df000017 	ldw	fp,0(sp)
81118d9c:	dec00204 	addi	sp,sp,8
81118da0:	f800283a 	ret

81118da4 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
81118da4:	defffd04 	addi	sp,sp,-12
81118da8:	de00012e 	bgeu	sp,et,81118db0 <vFailRequestDMAFromIRQ+0xc>
81118dac:	003b68fa 	trap	3
81118db0:	dfc00215 	stw	ra,8(sp)
81118db4:	df000115 	stw	fp,4(sp)
81118db8:	df000104 	addi	fp,sp,4
81118dbc:	2005883a 	mov	r2,r4
81118dc0:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
81118dc4:	d0a05d17 	ldw	r2,-32396(gp)
81118dc8:	e0ffff03 	ldbu	r3,-4(fp)
81118dcc:	180d883a 	mov	r6,r3
81118dd0:	01604574 	movhi	r5,33045
81118dd4:	296c6804 	addi	r5,r5,-20064
81118dd8:	1009883a 	mov	r4,r2
81118ddc:	111c11c0 	call	8111c11c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118de0:	0001883a 	nop
81118de4:	e037883a 	mov	sp,fp
81118de8:	dfc00117 	ldw	ra,4(sp)
81118dec:	df000017 	ldw	fp,0(sp)
81118df0:	dec00204 	addi	sp,sp,8
81118df4:	f800283a 	ret

81118df8 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
81118df8:	defffd04 	addi	sp,sp,-12
81118dfc:	de00012e 	bgeu	sp,et,81118e04 <vFailSendMsgSync+0xc>
81118e00:	003b68fa 	trap	3
81118e04:	dfc00215 	stw	ra,8(sp)
81118e08:	df000115 	stw	fp,4(sp)
81118e0c:	df000104 	addi	fp,sp,4
81118e10:	2005883a 	mov	r2,r4
81118e14:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
81118e18:	d0a05d17 	ldw	r2,-32396(gp)
81118e1c:	e0ffff03 	ldbu	r3,-4(fp)
81118e20:	180d883a 	mov	r6,r3
81118e24:	01604574 	movhi	r5,33045
81118e28:	296c6f04 	addi	r5,r5,-20036
81118e2c:	1009883a 	mov	r4,r2
81118e30:	111c11c0 	call	8111c11c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118e34:	0001883a 	nop
81118e38:	e037883a 	mov	sp,fp
81118e3c:	dfc00117 	ldw	ra,4(sp)
81118e40:	df000017 	ldw	fp,0(sp)
81118e44:	dec00204 	addi	sp,sp,8
81118e48:	f800283a 	ret

81118e4c <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
81118e4c:	defffe04 	addi	sp,sp,-8
81118e50:	de00012e 	bgeu	sp,et,81118e58 <vFailSendMsgMasterSyncMeb+0xc>
81118e54:	003b68fa 	trap	3
81118e58:	dfc00115 	stw	ra,4(sp)
81118e5c:	df000015 	stw	fp,0(sp)
81118e60:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
81118e64:	d0a05d17 	ldw	r2,-32396(gp)
81118e68:	100f883a 	mov	r7,r2
81118e6c:	018006c4 	movi	r6,27
81118e70:	01400044 	movi	r5,1
81118e74:	01204574 	movhi	r4,33045
81118e78:	212c7604 	addi	r4,r4,-20008
81118e7c:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118e80:	0001883a 	nop
81118e84:	e037883a 	mov	sp,fp
81118e88:	dfc00117 	ldw	ra,4(sp)
81118e8c:	df000017 	ldw	fp,0(sp)
81118e90:	dec00204 	addi	sp,sp,8
81118e94:	f800283a 	ret

81118e98 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
81118e98:	defffe04 	addi	sp,sp,-8
81118e9c:	de00012e 	bgeu	sp,et,81118ea4 <vFailSendMsgFeeCTRL+0xc>
81118ea0:	003b68fa 	trap	3
81118ea4:	dfc00115 	stw	ra,4(sp)
81118ea8:	df000015 	stw	fp,0(sp)
81118eac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
81118eb0:	d0a05d17 	ldw	r2,-32396(gp)
81118eb4:	100f883a 	mov	r7,r2
81118eb8:	018005c4 	movi	r6,23
81118ebc:	01400044 	movi	r5,1
81118ec0:	01204574 	movhi	r4,33045
81118ec4:	212c7d04 	addi	r4,r4,-19980
81118ec8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118ecc:	0001883a 	nop
81118ed0:	e037883a 	mov	sp,fp
81118ed4:	dfc00117 	ldw	ra,4(sp)
81118ed8:	df000017 	ldw	fp,0(sp)
81118edc:	dec00204 	addi	sp,sp,8
81118ee0:	f800283a 	ret

81118ee4 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
81118ee4:	defffe04 	addi	sp,sp,-8
81118ee8:	de00012e 	bgeu	sp,et,81118ef0 <vFailSendMsgDataCTRL+0xc>
81118eec:	003b68fa 	trap	3
81118ef0:	dfc00115 	stw	ra,4(sp)
81118ef4:	df000015 	stw	fp,0(sp)
81118ef8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
81118efc:	d0a05d17 	ldw	r2,-32396(gp)
81118f00:	100f883a 	mov	r7,r2
81118f04:	01800604 	movi	r6,24
81118f08:	01400044 	movi	r5,1
81118f0c:	01204574 	movhi	r4,33045
81118f10:	212c8304 	addi	r4,r4,-19956
81118f14:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118f18:	0001883a 	nop
81118f1c:	e037883a 	mov	sp,fp
81118f20:	dfc00117 	ldw	ra,4(sp)
81118f24:	df000017 	ldw	fp,0(sp)
81118f28:	dec00204 	addi	sp,sp,8
81118f2c:	f800283a 	ret

81118f30 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
81118f30:	defffe04 	addi	sp,sp,-8
81118f34:	de00012e 	bgeu	sp,et,81118f3c <vFailFlushQueue+0xc>
81118f38:	003b68fa 	trap	3
81118f3c:	dfc00115 	stw	ra,4(sp)
81118f40:	df000015 	stw	fp,0(sp)
81118f44:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
81118f48:	d0a05d17 	ldw	r2,-32396(gp)
81118f4c:	100f883a 	mov	r7,r2
81118f50:	01800744 	movi	r6,29
81118f54:	01400044 	movi	r5,1
81118f58:	01204574 	movhi	r4,33045
81118f5c:	212c8a04 	addi	r4,r4,-19928
81118f60:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118f64:	0001883a 	nop
81118f68:	e037883a 	mov	sp,fp
81118f6c:	dfc00117 	ldw	ra,4(sp)
81118f70:	df000017 	ldw	fp,0(sp)
81118f74:	dec00204 	addi	sp,sp,8
81118f78:	f800283a 	ret

81118f7c <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
81118f7c:	defffe04 	addi	sp,sp,-8
81118f80:	de00012e 	bgeu	sp,et,81118f88 <vFailFlushQueueData+0xc>
81118f84:	003b68fa 	trap	3
81118f88:	dfc00115 	stw	ra,4(sp)
81118f8c:	df000015 	stw	fp,0(sp)
81118f90:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
81118f94:	d0a05d17 	ldw	r2,-32396(gp)
81118f98:	100f883a 	mov	r7,r2
81118f9c:	01800844 	movi	r6,33
81118fa0:	01400044 	movi	r5,1
81118fa4:	01204574 	movhi	r4,33045
81118fa8:	212c9204 	addi	r4,r4,-19896
81118fac:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118fb0:	0001883a 	nop
81118fb4:	e037883a 	mov	sp,fp
81118fb8:	dfc00117 	ldw	ra,4(sp)
81118fbc:	df000017 	ldw	fp,0(sp)
81118fc0:	dec00204 	addi	sp,sp,8
81118fc4:	f800283a 	ret

81118fc8 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
81118fc8:	defffe04 	addi	sp,sp,-8
81118fcc:	de00012e 	bgeu	sp,et,81118fd4 <vFailFlushMEBQueue+0xc>
81118fd0:	003b68fa 	trap	3
81118fd4:	dfc00115 	stw	ra,4(sp)
81118fd8:	df000015 	stw	fp,0(sp)
81118fdc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
81118fe0:	d0a05d17 	ldw	r2,-32396(gp)
81118fe4:	100f883a 	mov	r7,r2
81118fe8:	01800804 	movi	r6,32
81118fec:	01400044 	movi	r5,1
81118ff0:	01204574 	movhi	r4,33045
81118ff4:	212c9b04 	addi	r4,r4,-19860
81118ff8:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118ffc:	0001883a 	nop
81119000:	e037883a 	mov	sp,fp
81119004:	dfc00117 	ldw	ra,4(sp)
81119008:	df000017 	ldw	fp,0(sp)
8111900c:	dec00204 	addi	sp,sp,8
81119010:	f800283a 	ret

81119014 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
81119014:	defffe04 	addi	sp,sp,-8
81119018:	de00012e 	bgeu	sp,et,81119020 <vFailFlushNFEEQueue+0xc>
8111901c:	003b68fa 	trap	3
81119020:	dfc00115 	stw	ra,4(sp)
81119024:	df000015 	stw	fp,0(sp)
81119028:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111902c:	d0a05d17 	ldw	r2,-32396(gp)
81119030:	100f883a 	mov	r7,r2
81119034:	01800844 	movi	r6,33
81119038:	01400044 	movi	r5,1
8111903c:	01204574 	movhi	r4,33045
81119040:	212ca404 	addi	r4,r4,-19824
81119044:	111c7b80 	call	8111c7b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119048:	0001883a 	nop
8111904c:	e037883a 	mov	sp,fp
81119050:	dfc00117 	ldw	ra,4(sp)
81119054:	df000017 	ldw	fp,0(sp)
81119058:	dec00204 	addi	sp,sp,8
8111905c:	f800283a 	ret

81119060 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
81119060:	deffff04 	addi	sp,sp,-4
81119064:	de00012e 	bgeu	sp,et,8111906c <vEvtChangeMebMode+0xc>
81119068:	003b68fa 	trap	3
8111906c:	df000015 	stw	fp,0(sp)
81119070:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81119074:	0001883a 	nop
81119078:	e037883a 	mov	sp,fp
8111907c:	df000017 	ldw	fp,0(sp)
81119080:	dec00104 	addi	sp,sp,4
81119084:	f800283a 	ret

81119088 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
81119088:	deffff04 	addi	sp,sp,-4
8111908c:	de00012e 	bgeu	sp,et,81119094 <vEvtChangeFeeControllerMode+0xc>
81119090:	003b68fa 	trap	3
81119094:	df000015 	stw	fp,0(sp)
81119098:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111909c:	0001883a 	nop
811190a0:	e037883a 	mov	sp,fp
811190a4:	df000017 	ldw	fp,0(sp)
811190a8:	dec00104 	addi	sp,sp,4
811190ac:	f800283a 	ret

811190b0 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
811190b0:	deffff04 	addi	sp,sp,-4
811190b4:	de00012e 	bgeu	sp,et,811190bc <vEvtChangeDataControllerMode+0xc>
811190b8:	003b68fa 	trap	3
811190bc:	df000015 	stw	fp,0(sp)
811190c0:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
811190c4:	0001883a 	nop
811190c8:	e037883a 	mov	sp,fp
811190cc:	df000017 	ldw	fp,0(sp)
811190d0:	dec00104 	addi	sp,sp,4
811190d4:	f800283a 	ret

811190d8 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
811190d8:	defffd04 	addi	sp,sp,-12
811190dc:	de00012e 	bgeu	sp,et,811190e4 <vNFeeNotInUse+0xc>
811190e0:	003b68fa 	trap	3
811190e4:	df000215 	stw	fp,8(sp)
811190e8:	df000204 	addi	fp,sp,8
811190ec:	e13ffe15 	stw	r4,-8(fp)
811190f0:	2805883a 	mov	r2,r5
811190f4:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
811190f8:	e0bffe17 	ldw	r2,-8(fp)
811190fc:	e0ffff03 	ldbu	r3,-4(fp)
81119100:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
81119104:	e0bffe17 	ldw	r2,-8(fp)
81119108:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111910c:	e0bffe17 	ldw	r2,-8(fp)
81119110:	10002315 	stw	zero,140(r2)
}
81119114:	0001883a 	nop
81119118:	e037883a 	mov	sp,fp
8111911c:	df000017 	ldw	fp,0(sp)
81119120:	dec00104 	addi	sp,sp,4
81119124:	f800283a 	ret

81119128 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81119128:	defffb04 	addi	sp,sp,-20
8111912c:	de00012e 	bgeu	sp,et,81119134 <vNFeeStructureInit+0xc>
81119130:	003b68fa 	trap	3
81119134:	dfc00415 	stw	ra,16(sp)
81119138:	df000315 	stw	fp,12(sp)
8111913c:	df000304 	addi	fp,sp,12
81119140:	e13ffe15 	stw	r4,-8(fp)
81119144:	2805883a 	mov	r2,r5
81119148:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111914c:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
81119150:	e0bffe17 	ldw	r2,-8(fp)
81119154:	e0ffff03 	ldbu	r3,-4(fp)
81119158:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111915c:	e0bffe17 	ldw	r2,-8(fp)
81119160:	10802f04 	addi	r2,r2,188
81119164:	1009883a 	mov	r4,r2
81119168:	1114e640 	call	81114e64 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111916c:	e13ffe17 	ldw	r4,-8(fp)
81119170:	11192a00 	call	811192a0 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
81119174:	e0bffe17 	ldw	r2,-8(fp)
81119178:	00c00044 	movi	r3,1
8111917c:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81119180:	e0bffe17 	ldw	r2,-8(fp)
81119184:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
81119188:	e0bffe17 	ldw	r2,-8(fp)
8111918c:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
81119190:	e0bffe17 	ldw	r2,-8(fp)
81119194:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
81119198:	e0bffe17 	ldw	r2,-8(fp)
8111919c:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
811191a0:	e0bffe17 	ldw	r2,-8(fp)
811191a4:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
811191a8:	e0bffe17 	ldw	r2,-8(fp)
811191ac:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
811191b0:	e0bffe17 	ldw	r2,-8(fp)
811191b4:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
811191b8:	e0bffe17 	ldw	r2,-8(fp)
811191bc:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
811191c0:	e0bffe17 	ldw	r2,-8(fp)
811191c4:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
811191c8:	e0bffe17 	ldw	r2,-8(fp)
811191cc:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
811191d0:	e0bffe17 	ldw	r2,-8(fp)
811191d4:	10002d15 	stw	zero,180(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
811191d8:	e03ffd05 	stb	zero,-12(fp)
811191dc:	00000906 	br	81119204 <vNFeeStructureInit+0xdc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
811191e0:	e0bffd03 	ldbu	r2,-12(fp)
811191e4:	e0fffe17 	ldw	r3,-8(fp)
811191e8:	1885883a 	add	r2,r3,r2
811191ec:	10802a44 	addi	r2,r2,169
811191f0:	e0fffd03 	ldbu	r3,-12(fp)
811191f4:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
811191f8:	e0bffd03 	ldbu	r2,-12(fp)
811191fc:	10800044 	addi	r2,r2,1
81119200:	e0bffd05 	stb	r2,-12(fp)
81119204:	e0bffd03 	ldbu	r2,-12(fp)
81119208:	10800130 	cmpltui	r2,r2,4
8111920c:	103ff41e 	bne	r2,zero,811191e0 <__reset+0xfb0f91e0>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, ucIdNFEE ) == FALSE ) {
81119210:	e0bffe17 	ldw	r2,-8(fp)
81119214:	10803204 	addi	r2,r2,200
81119218:	e0ffff03 	ldbu	r3,-4(fp)
8111921c:	180b883a 	mov	r5,r3
81119220:	1009883a 	mov	r4,r2
81119224:	110461c0 	call	8110461c <bCommInitCh>
81119228:	1000091e 	bne	r2,zero,81119250 <vNFeeStructureInit+0x128>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111922c:	d0e05d17 	ldw	r3,-32396(gp)
81119230:	e0bffe17 	ldw	r2,-8(fp)
81119234:	10800003 	ldbu	r2,0(r2)
81119238:	10803fcc 	andi	r2,r2,255
8111923c:	100d883a 	mov	r6,r2
81119240:	01604574 	movhi	r5,33045
81119244:	296cad04 	addi	r5,r5,-19788
81119248:	1809883a 	mov	r4,r3
8111924c:	111c11c0 	call	8111c11c <fprintf>
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, ucIdNFEE ) == FALSE ) {
81119250:	e0bfff03 	ldbu	r2,-4(fp)
81119254:	100b883a 	mov	r5,r2
81119258:	01000044 	movi	r4,1
8111925c:	11044b00 	call	811044b0 <bCommSetGlobalIrqEn>
81119260:	1000091e 	bne	r2,zero,81119288 <vNFeeStructureInit+0x160>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
81119264:	d0e05d17 	ldw	r3,-32396(gp)
81119268:	e0bffe17 	ldw	r2,-8(fp)
8111926c:	10800003 	ldbu	r2,0(r2)
81119270:	10803fcc 	andi	r2,r2,255
81119274:	100d883a 	mov	r6,r2
81119278:	01604574 	movhi	r5,33045
8111927c:	296cb904 	addi	r5,r5,-19740
81119280:	1809883a 	mov	r4,r3
81119284:	111c11c0 	call	8111c11c <fprintf>
		#endif
    }

}
81119288:	0001883a 	nop
8111928c:	e037883a 	mov	sp,fp
81119290:	dfc00117 	ldw	ra,4(sp)
81119294:	df000017 	ldw	fp,0(sp)
81119298:	dec00204 	addi	sp,sp,8
8111929c:	f800283a 	ret

811192a0 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
811192a0:	defff404 	addi	sp,sp,-48
811192a4:	de00012e 	bgeu	sp,et,811192ac <vUpdateMemMapFEE+0xc>
811192a8:	003b68fa 	trap	3
811192ac:	df000b15 	stw	fp,44(sp)
811192b0:	df000b04 	addi	fp,sp,44
811192b4:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
811192b8:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
811192bc:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
811192c0:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
811192c4:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
811192c8:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
811192cc:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
811192d0:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
811192d4:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
811192d8:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
811192dc:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
811192e0:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
811192e4:	e17fff17 	ldw	r5,-4(fp)
811192e8:	01035a34 	movhi	r4,3432
811192ec:	21348c04 	addi	r4,r4,-11728
811192f0:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
811192f4:	e13fff17 	ldw	r4,-4(fp)
811192f8:	21000003 	ldbu	r4,0(r4)
811192fc:	21403fcc 	andi	r5,r4,255
81119300:	01035a34 	movhi	r4,3432
81119304:	21348c04 	addi	r4,r4,-11728
81119308:	2909383a 	mul	r4,r5,r4
8111930c:	200b883a 	mov	r5,r4
81119310:	e13fff17 	ldw	r4,-4(fp)
81119314:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
81119318:	e13fff17 	ldw	r4,-4(fp)
8111931c:	21400117 	ldw	r5,4(r4)
81119320:	01033234 	movhi	r4,3272
81119324:	21348c04 	addi	r4,r4,-11728
81119328:	290b883a 	add	r5,r5,r4
8111932c:	e13fff17 	ldw	r4,-4(fp)
81119330:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81119334:	e13fff17 	ldw	r4,-4(fp)
81119338:	2100310b 	ldhu	r4,196(r4)
8111933c:	217fffcc 	andi	r5,r4,65535
81119340:	e13fff17 	ldw	r4,-4(fp)
81119344:	2100300b 	ldhu	r4,192(r4)
81119348:	213fffcc 	andi	r4,r4,65535
8111934c:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
81119350:	e13fff17 	ldw	r4,-4(fp)
81119354:	2100308b 	ldhu	r4,194(r4)
81119358:	21bfffcc 	andi	r6,r4,65535
8111935c:	e13fff17 	ldw	r4,-4(fp)
81119360:	21002f8b 	ldhu	r4,190(r4)
81119364:	213fffcc 	andi	r4,r4,65535
81119368:	310d883a 	add	r6,r6,r4
8111936c:	e13fff17 	ldw	r4,-4(fp)
81119370:	21002f0b 	ldhu	r4,188(r4)
81119374:	213fffcc 	andi	r4,r4,65535
81119378:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111937c:	2909383a 	mul	r4,r5,r4
81119380:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
81119384:	e13ffa17 	ldw	r4,-24(fp)
81119388:	2109883a 	add	r4,r4,r4
8111938c:	200b883a 	mov	r5,r4
81119390:	e13fff17 	ldw	r4,-4(fp)
81119394:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
81119398:	e13fff17 	ldw	r4,-4(fp)
8111939c:	21000517 	ldw	r4,20(r4)
811193a0:	2008d0fa 	srli	r4,r4,3
811193a4:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
811193a8:	e13fff17 	ldw	r4,-4(fp)
811193ac:	21000517 	ldw	r4,20(r4)
811193b0:	210001cc 	andi	r4,r4,7
811193b4:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
811193b8:	e13ffb17 	ldw	r4,-20(fp)
811193bc:	20001226 	beq	r4,zero,81119408 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
811193c0:	e13ff517 	ldw	r4,-44(fp)
811193c4:	21000044 	addi	r4,r4,1
811193c8:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
811193cc:	e13fff17 	ldw	r4,-4(fp)
811193d0:	21400517 	ldw	r5,20(r4)
811193d4:	e13ffb17 	ldw	r4,-20(fp)
811193d8:	2909c83a 	sub	r4,r5,r4
811193dc:	21400204 	addi	r5,r4,8
811193e0:	e13fff17 	ldw	r4,-4(fp)
811193e4:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
811193e8:	e13ffb17 	ldw	r4,-20(fp)
811193ec:	200b883a 	mov	r5,r4
811193f0:	01000204 	movi	r4,8
811193f4:	2149c83a 	sub	r4,r4,r5
811193f8:	200b883a 	mov	r5,r4
811193fc:	e13fff17 	ldw	r4,-4(fp)
81119400:	21400605 	stb	r5,24(r4)
81119404:	00000206 	br	81119410 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
81119408:	e13fff17 	ldw	r4,-4(fp)
8111940c:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
81119410:	e13ff517 	ldw	r4,-44(fp)
81119414:	2008d13a 	srli	r4,r4,4
81119418:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111941c:	e13ff517 	ldw	r4,-44(fp)
81119420:	210003cc 	andi	r4,r4,15
81119424:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
81119428:	e13ffc17 	ldw	r4,-16(fp)
8111942c:	20000b26 	beq	r4,zero,8111945c <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
81119430:	e13ff717 	ldw	r4,-36(fp)
81119434:	21000044 	addi	r4,r4,1
81119438:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111943c:	e17ff517 	ldw	r5,-44(fp)
81119440:	e13ffc17 	ldw	r4,-16(fp)
81119444:	290bc83a 	sub	r5,r5,r4
81119448:	e13ff717 	ldw	r4,-36(fp)
8111944c:	2909883a 	add	r4,r5,r4
81119450:	21000404 	addi	r4,r4,16
81119454:	e13ff615 	stw	r4,-40(fp)
81119458:	00000406 	br	8111946c <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111945c:	e17ff517 	ldw	r5,-44(fp)
81119460:	e13ff717 	ldw	r4,-36(fp)
81119464:	2909883a 	add	r4,r5,r4
81119468:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111946c:	e13ff617 	ldw	r4,-40(fp)
81119470:	200a90fa 	slli	r5,r4,3
81119474:	e13fff17 	ldw	r4,-4(fp)
81119478:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111947c:	e13ffb17 	ldw	r4,-20(fp)
81119480:	20000926 	beq	r4,zero,811194a8 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
81119484:	e13ffc17 	ldw	r4,-16(fp)
81119488:	2109883a 	add	r4,r4,r4
8111948c:	2109883a 	add	r4,r4,r4
81119490:	200b883a 	mov	r5,r4
81119494:	e13ffb17 	ldw	r4,-20(fp)
81119498:	2008d07a 	srli	r4,r4,1
8111949c:	2909883a 	add	r4,r5,r4
811194a0:	e13ff805 	stb	r4,-32(fp)
811194a4:	00000406 	br	811194b8 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
811194a8:	e13ffc17 	ldw	r4,-16(fp)
811194ac:	2109883a 	add	r4,r4,r4
811194b0:	2109883a 	add	r4,r4,r4
811194b4:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
811194b8:	e13ff803 	ldbu	r4,-32(fp)
811194bc:	01401004 	movi	r5,64
811194c0:	2909c83a 	sub	r4,r5,r4
811194c4:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
811194c8:	e13ffd03 	ldbu	r4,-12(fp)
811194cc:	217ff804 	addi	r5,r4,-32
811194d0:	28000416 	blt	r5,zero,811194e4 <vUpdateMemMapFEE+0x244>
811194d4:	013fffc4 	movi	r4,-1
811194d8:	2144d83a 	srl	r2,r4,r5
811194dc:	0007883a 	mov	r3,zero
811194e0:	00000a06 	br	8111950c <vUpdateMemMapFEE+0x26c>
811194e4:	017fffc4 	movi	r5,-1
811194e8:	280c907a 	slli	r6,r5,1
811194ec:	014007c4 	movi	r5,31
811194f0:	290bc83a 	sub	r5,r5,r4
811194f4:	314a983a 	sll	r5,r6,r5
811194f8:	01bfffc4 	movi	r6,-1
811194fc:	3104d83a 	srl	r2,r6,r4
81119500:	2884b03a 	or	r2,r5,r2
81119504:	017fffc4 	movi	r5,-1
81119508:	2906d83a 	srl	r3,r5,r4
8111950c:	e13fff17 	ldw	r4,-4(fp)
81119510:	20800715 	stw	r2,28(r4)
81119514:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
81119518:	e0bfff17 	ldw	r2,-4(fp)
8111951c:	e0fff717 	ldw	r3,-36(fp)
81119520:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
81119524:	e0bfff17 	ldw	r2,-4(fp)
81119528:	10c00117 	ldw	r3,4(r2)
8111952c:	008004b4 	movhi	r2,18
81119530:	10a40004 	addi	r2,r2,-28672
81119534:	1885883a 	add	r2,r3,r2
81119538:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111953c:	e0bfff17 	ldw	r2,-4(fp)
81119540:	10c00517 	ldw	r3,20(r2)
81119544:	008000b4 	movhi	r2,2
81119548:	10a40004 	addi	r2,r2,-28672
8111954c:	1885883a 	add	r2,r3,r2
81119550:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81119554:	e03ff845 	stb	zero,-31(fp)
81119558:	00001906 	br	811195c0 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111955c:	e0bff843 	ldbu	r2,-31(fp)
81119560:	e0ffff17 	ldw	r3,-4(fp)
81119564:	10800624 	muli	r2,r2,24
81119568:	1885883a 	add	r2,r3,r2
8111956c:	10800904 	addi	r2,r2,36
81119570:	e0fff917 	ldw	r3,-28(fp)
81119574:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81119578:	e0fff917 	ldw	r3,-28(fp)
8111957c:	e0bffe17 	ldw	r2,-8(fp)
81119580:	1885883a 	add	r2,r3,r2
81119584:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
81119588:	e0bff843 	ldbu	r2,-31(fp)
8111958c:	e0ffff17 	ldw	r3,-4(fp)
81119590:	10800624 	muli	r2,r2,24
81119594:	1885883a 	add	r2,r3,r2
81119598:	10800c04 	addi	r2,r2,48
8111959c:	e0fff917 	ldw	r3,-28(fp)
811195a0:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
811195a4:	e0fff917 	ldw	r3,-28(fp)
811195a8:	e0bffe17 	ldw	r2,-8(fp)
811195ac:	1885883a 	add	r2,r3,r2
811195b0:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
811195b4:	e0bff843 	ldbu	r2,-31(fp)
811195b8:	10800044 	addi	r2,r2,1
811195bc:	e0bff845 	stb	r2,-31(fp)
811195c0:	e0bff843 	ldbu	r2,-31(fp)
811195c4:	10800130 	cmpltui	r2,r2,4
811195c8:	103fe41e 	bne	r2,zero,8111955c <__reset+0xfb0f955c>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
811195cc:	0001883a 	nop
811195d0:	e037883a 	mov	sp,fp
811195d4:	df000017 	ldw	fp,0(sp)
811195d8:	dec00104 	addi	sp,sp,4
811195dc:	f800283a 	ret

811195e0 <vFeeSpwRMAPLoadDefault>:

/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
811195e0:	defffe04 	addi	sp,sp,-8
811195e4:	de00012e 	bgeu	sp,et,811195ec <vFeeSpwRMAPLoadDefault+0xc>
811195e8:	003b68fa 	trap	3
811195ec:	df000115 	stw	fp,4(sp)
811195f0:	df000104 	addi	fp,sp,4
811195f4:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
811195f8:	0001883a 	nop
811195fc:	e037883a 	mov	sp,fp
81119600:	df000017 	ldw	fp,0(sp)
81119604:	dec00104 	addi	sp,sp,4
81119608:	f800283a 	ret

8111960c <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111960c:	defffe04 	addi	sp,sp,-8
81119610:	de00012e 	bgeu	sp,et,81119618 <vFeeSpwRMAPChangeConfig+0xc>
81119614:	003b68fa 	trap	3
81119618:	df000115 	stw	fp,4(sp)
8111961c:	df000104 	addi	fp,sp,4
81119620:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
81119624:	0001883a 	nop
81119628:	e037883a 	mov	sp,fp
8111962c:	df000017 	ldw	fp,0(sp)
81119630:	dec00104 	addi	sp,sp,4
81119634:	f800283a 	ret

81119638 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
81119638:	defffe04 	addi	sp,sp,-8
8111963c:	de00012e 	bgeu	sp,et,81119644 <vFeeSpwRMAPChangeDefault+0xc>
81119640:	003b68fa 	trap	3
81119644:	df000115 	stw	fp,4(sp)
81119648:	df000104 	addi	fp,sp,4
8111964c:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
81119650:	0001883a 	nop
81119654:	e037883a 	mov	sp,fp
81119658:	df000017 	ldw	fp,0(sp)
8111965c:	dec00104 	addi	sp,sp,4
81119660:	f800283a 	ret

81119664 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
81119664:	defffe04 	addi	sp,sp,-8
81119668:	de00012e 	bgeu	sp,et,81119670 <cFeeSpwChannelEnable+0xc>
8111966c:	003b68fa 	trap	3
81119670:	df000115 	stw	fp,4(sp)
81119674:	df000104 	addi	fp,sp,4
81119678:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111967c:	0001883a 	nop
81119680:	e037883a 	mov	sp,fp
81119684:	df000017 	ldw	fp,0(sp)
81119688:	dec00104 	addi	sp,sp,4
8111968c:	f800283a 	ret

81119690 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
81119690:	defffe04 	addi	sp,sp,-8
81119694:	de00012e 	bgeu	sp,et,8111969c <cFeeSpwChannelDisable+0xc>
81119698:	003b68fa 	trap	3
8111969c:	df000115 	stw	fp,4(sp)
811196a0:	df000104 	addi	fp,sp,4
811196a4:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
811196a8:	0001883a 	nop
811196ac:	e037883a 	mov	sp,fp
811196b0:	df000017 	ldw	fp,0(sp)
811196b4:	dec00104 	addi	sp,sp,4
811196b8:	f800283a 	ret

811196bc <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
811196bc:	defffe04 	addi	sp,sp,-8
811196c0:	de00012e 	bgeu	sp,et,811196c8 <cFeeRMAPDump+0xc>
811196c4:	003b68fa 	trap	3
811196c8:	df000115 	stw	fp,4(sp)
811196cc:	df000104 	addi	fp,sp,4
811196d0:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
811196d4:	0001883a 	nop
811196d8:	e037883a 	mov	sp,fp
811196dc:	df000017 	ldw	fp,0(sp)
811196e0:	dec00104 	addi	sp,sp,4
811196e4:	f800283a 	ret

811196e8 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
811196e8:	defffe04 	addi	sp,sp,-8
811196ec:	de00012e 	bgeu	sp,et,811196f4 <cFeeRMAPEchoingEnable+0xc>
811196f0:	003b68fa 	trap	3
811196f4:	df000115 	stw	fp,4(sp)
811196f8:	df000104 	addi	fp,sp,4
811196fc:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
81119700:	e0bfff17 	ldw	r2,-4(fp)
81119704:	00c00044 	movi	r3,1
81119708:	10c02515 	stw	r3,148(r2)
}
8111970c:	0001883a 	nop
81119710:	e037883a 	mov	sp,fp
81119714:	df000017 	ldw	fp,0(sp)
81119718:	dec00104 	addi	sp,sp,4
8111971c:	f800283a 	ret

81119720 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
81119720:	defffe04 	addi	sp,sp,-8
81119724:	de00012e 	bgeu	sp,et,8111972c <cFeeRMAPEchoingDisable+0xc>
81119728:	003b68fa 	trap	3
8111972c:	df000115 	stw	fp,4(sp)
81119730:	df000104 	addi	fp,sp,4
81119734:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
81119738:	e0bfff17 	ldw	r2,-4(fp)
8111973c:	10002515 	stw	zero,148(r2)
}
81119740:	0001883a 	nop
81119744:	e037883a 	mov	sp,fp
81119748:	df000017 	ldw	fp,0(sp)
8111974c:	dec00104 	addi	sp,sp,4
81119750:	f800283a 	ret

81119754 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
81119754:	defffe04 	addi	sp,sp,-8
81119758:	de00012e 	bgeu	sp,et,81119760 <cFeeRMAPLogEnable+0xc>
8111975c:	003b68fa 	trap	3
81119760:	df000115 	stw	fp,4(sp)
81119764:	df000104 	addi	fp,sp,4
81119768:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111976c:	e0bfff17 	ldw	r2,-4(fp)
81119770:	00c00044 	movi	r3,1
81119774:	10c02415 	stw	r3,144(r2)
}
81119778:	0001883a 	nop
8111977c:	e037883a 	mov	sp,fp
81119780:	df000017 	ldw	fp,0(sp)
81119784:	dec00104 	addi	sp,sp,4
81119788:	f800283a 	ret

8111978c <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111978c:	defffe04 	addi	sp,sp,-8
81119790:	de00012e 	bgeu	sp,et,81119798 <cFeeRMAPLogDisable+0xc>
81119794:	003b68fa 	trap	3
81119798:	df000115 	stw	fp,4(sp)
8111979c:	df000104 	addi	fp,sp,4
811197a0:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
811197a4:	e0bfff17 	ldw	r2,-4(fp)
811197a8:	10002415 	stw	zero,144(r2)
}
811197ac:	0001883a 	nop
811197b0:	e037883a 	mov	sp,fp
811197b4:	df000017 	ldw	fp,0(sp)
811197b8:	dec00104 	addi	sp,sp,4
811197bc:	f800283a 	ret

811197c0 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
811197c0:	defffc04 	addi	sp,sp,-16
811197c4:	de00012e 	bgeu	sp,et,811197cc <vNFeeControlInit+0xc>
811197c8:	003b68fa 	trap	3
811197cc:	dfc00315 	stw	ra,12(sp)
811197d0:	df000215 	stw	fp,8(sp)
811197d4:	df000204 	addi	fp,sp,8
811197d8:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
811197dc:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
811197e0:	e13fff17 	ldw	r4,-4(fp)
811197e4:	111990c0 	call	8111990c <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
811197e8:	e13fff17 	ldw	r4,-4(fp)
811197ec:	11199400 	call	81119940 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
811197f0:	e0bfff17 	ldw	r2,-4(fp)
811197f4:	10009915 	stw	zero,612(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
811197f8:	e03ffe05 	stb	zero,-8(fp)
811197fc:	00002b06 	br	811198ac <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
81119800:	e0bffe03 	ldbu	r2,-8(fp)
81119804:	10809524 	muli	r2,r2,596
81119808:	e0ffff17 	ldw	r3,-4(fp)
8111980c:	1885883a 	add	r2,r3,r2
81119810:	e0fffe03 	ldbu	r3,-8(fp)
81119814:	180b883a 	mov	r5,r3
81119818:	1009883a 	mov	r4,r2
8111981c:	11191280 	call	81119128 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
81119820:	e0bffe03 	ldbu	r2,-8(fp)
81119824:	e0fffe03 	ldbu	r3,-8(fp)
81119828:	18c09524 	muli	r3,r3,596
8111982c:	18c02104 	addi	r3,r3,132
81119830:	e13fff17 	ldw	r4,-4(fp)
81119834:	20c7883a 	add	r3,r4,r3
81119838:	e13fff17 	ldw	r4,-4(fp)
8111983c:	10802584 	addi	r2,r2,150
81119840:	1085883a 	add	r2,r2,r2
81119844:	1085883a 	add	r2,r2,r2
81119848:	2085883a 	add	r2,r4,r2
8111984c:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
81119850:	e0bffe03 	ldbu	r2,-8(fp)
81119854:	e0fffe03 	ldbu	r3,-8(fp)
81119858:	18c09524 	muli	r3,r3,596
8111985c:	18c02704 	addi	r3,r3,156
81119860:	e13fff17 	ldw	r4,-4(fp)
81119864:	20c7883a 	add	r3,r4,r3
81119868:	e13fff17 	ldw	r4,-4(fp)
8111986c:	108025c4 	addi	r2,r2,151
81119870:	1085883a 	add	r2,r2,r2
81119874:	1085883a 	add	r2,r2,r2
81119878:	2085883a 	add	r2,r4,r2
8111987c:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
81119880:	e0bffe03 	ldbu	r2,-8(fp)
81119884:	e0ffff17 	ldw	r3,-4(fp)
81119888:	18c09517 	ldw	r3,596(r3)
8111988c:	e13fff17 	ldw	r4,-4(fp)
81119890:	10809524 	muli	r2,r2,596
81119894:	2085883a 	add	r2,r4,r2
81119898:	10802904 	addi	r2,r2,164
8111989c:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
811198a0:	e0bffe03 	ldbu	r2,-8(fp)
811198a4:	10800044 	addi	r2,r2,1
811198a8:	e0bffe05 	stb	r2,-8(fp)
811198ac:	e0bffe03 	ldbu	r2,-8(fp)
811198b0:	103fd326 	beq	r2,zero,81119800 <__reset+0xfb0f9800>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
811198b4:	0001883a 	nop
811198b8:	e037883a 	mov	sp,fp
811198bc:	dfc00117 	ldw	ra,4(sp)
811198c0:	df000017 	ldw	fp,0(sp)
811198c4:	dec00204 	addi	sp,sp,8
811198c8:	f800283a 	ret

811198cc <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
811198cc:	defffd04 	addi	sp,sp,-12
811198d0:	de00012e 	bgeu	sp,et,811198d8 <vSetTimeCode+0xc>
811198d4:	003b68fa 	trap	3
811198d8:	df000215 	stw	fp,8(sp)
811198dc:	df000204 	addi	fp,sp,8
811198e0:	e13ffe15 	stw	r4,-8(fp)
811198e4:	2805883a 	mov	r2,r5
811198e8:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
811198ec:	e0bffe17 	ldw	r2,-8(fp)
811198f0:	e0ffff03 	ldbu	r3,-4(fp)
811198f4:	10c09805 	stb	r3,608(r2)
}
811198f8:	0001883a 	nop
811198fc:	e037883a 	mov	sp,fp
81119900:	df000017 	ldw	fp,0(sp)
81119904:	dec00104 	addi	sp,sp,4
81119908:	f800283a 	ret

8111990c <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111990c:	defffe04 	addi	sp,sp,-8
81119910:	de00012e 	bgeu	sp,et,81119918 <vResetTimeCode+0xc>
81119914:	003b68fa 	trap	3
81119918:	df000115 	stw	fp,4(sp)
8111991c:	df000104 	addi	fp,sp,4
81119920:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
81119924:	e0bfff17 	ldw	r2,-4(fp)
81119928:	10009805 	stb	zero,608(r2)
}
8111992c:	0001883a 	nop
81119930:	e037883a 	mov	sp,fp
81119934:	df000017 	ldw	fp,0(sp)
81119938:	dec00104 	addi	sp,sp,4
8111993c:	f800283a 	ret

81119940 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
81119940:	defffe04 	addi	sp,sp,-8
81119944:	de00012e 	bgeu	sp,et,8111994c <vLoadDefaultIdNFEEMaster+0xc>
81119948:	003b68fa 	trap	3
8111994c:	df000115 	stw	fp,4(sp)
81119950:	df000104 	addi	fp,sp,4
81119954:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
81119958:	e0bfff17 	ldw	r2,-4(fp)
8111995c:	10009845 	stb	zero,609(r2)
}
81119960:	0001883a 	nop
81119964:	e037883a 	mov	sp,fp
81119968:	df000017 	ldw	fp,0(sp)
8111996c:	dec00104 	addi	sp,sp,4
81119970:	f800283a 	ret

81119974 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81119974:	defffd04 	addi	sp,sp,-12
81119978:	de00012e 	bgeu	sp,et,81119980 <vChangeIdNFEEMaster+0xc>
8111997c:	003b68fa 	trap	3
81119980:	df000215 	stw	fp,8(sp)
81119984:	df000204 	addi	fp,sp,8
81119988:	e13ffe15 	stw	r4,-8(fp)
8111998c:	2805883a 	mov	r2,r5
81119990:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
81119994:	e0bffe17 	ldw	r2,-8(fp)
81119998:	e0ffff03 	ldbu	r3,-4(fp)
8111999c:	10c09845 	stb	r3,609(r2)
}
811199a0:	0001883a 	nop
811199a4:	e037883a 	mov	sp,fp
811199a8:	df000017 	ldw	fp,0(sp)
811199ac:	dec00104 	addi	sp,sp,4
811199b0:	f800283a 	ret

811199b4 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
811199b4:	defffd04 	addi	sp,sp,-12
811199b8:	de00012e 	bgeu	sp,et,811199c0 <vChangeDefaultIdNFEEMaster+0xc>
811199bc:	003b68fa 	trap	3
811199c0:	df000215 	stw	fp,8(sp)
811199c4:	df000204 	addi	fp,sp,8
811199c8:	e13ffe15 	stw	r4,-8(fp)
811199cc:	2805883a 	mov	r2,r5
811199d0:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
811199d4:	0001883a 	nop
811199d8:	e037883a 	mov	sp,fp
811199dc:	df000017 	ldw	fp,0(sp)
811199e0:	dec00104 	addi	sp,sp,4
811199e4:	f800283a 	ret

811199e8 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
811199e8:	defffe04 	addi	sp,sp,-8
811199ec:	de00012e 	bgeu	sp,et,811199f4 <vInitSimucamBasicHW+0xc>
811199f0:	003b68fa 	trap	3
811199f4:	dfc00115 	stw	ra,4(sp)
811199f8:	df000015 	stw	fp,0(sp)
811199fc:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
81119a00:	01403fc4 	movi	r5,255
81119a04:	0009883a 	mov	r4,zero
81119a08:	110a1e40 	call	8110a1e4 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
81119a0c:	01400834 	movhi	r5,32
81119a10:	297fffc4 	addi	r5,r5,-1
81119a14:	0009883a 	mov	r4,zero
81119a18:	110a2640 	call	8110a264 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
81119a1c:	01400074 	movhi	r5,1
81119a20:	01000044 	movi	r4,1
81119a24:	110a2640 	call	8110a264 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
81119a28:	0009883a 	mov	r4,zero
81119a2c:	110b8400 	call	8110b840 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
81119a30:	0009883a 	mov	r4,zero
81119a34:	110b9100 	call	8110b910 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81119a38:	01008004 	movi	r4,512
81119a3c:	110b3a00 	call	8110b3a0 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81119a40:	01008004 	movi	r4,512
81119a44:	110b32c0 	call	8110b32c <vRstcReleaseDeviceReset>

}
81119a48:	0001883a 	nop
81119a4c:	e037883a 	mov	sp,fp
81119a50:	dfc00117 	ldw	ra,4(sp)
81119a54:	df000017 	ldw	fp,0(sp)
81119a58:	dec00204 	addi	sp,sp,8
81119a5c:	f800283a 	ret

81119a60 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
81119a60:	defffd04 	addi	sp,sp,-12
81119a64:	de00012e 	bgeu	sp,et,81119a6c <bLogWriteSDCard+0xc>
81119a68:	003b68fa 	trap	3
81119a6c:	df000215 	stw	fp,8(sp)
81119a70:	df000204 	addi	fp,sp,8
81119a74:	e13ffe15 	stw	r4,-8(fp)
81119a78:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
81119a7c:	00800044 	movi	r2,1
}
81119a80:	e037883a 	mov	sp,fp
81119a84:	df000017 	ldw	fp,0(sp)
81119a88:	dec00104 	addi	sp,sp,4
81119a8c:	f800283a 	ret

81119a90 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
81119a90:	deffe004 	addi	sp,sp,-128
81119a94:	de00012e 	bgeu	sp,et,81119a9c <vLogWriteNUC+0xc>
81119a98:	003b68fa 	trap	3
81119a9c:	dfc01f15 	stw	ra,124(sp)
81119aa0:	df001e15 	stw	fp,120(sp)
81119aa4:	df001e04 	addi	fp,sp,120
81119aa8:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
81119aac:	e03fe215 	stw	zero,-120(fp)
81119ab0:	e0bfe304 	addi	r2,fp,-116
81119ab4:	00c01b84 	movi	r3,110
81119ab8:	180d883a 	mov	r6,r3
81119abc:	000b883a 	mov	r5,zero
81119ac0:	1009883a 	mov	r4,r2
81119ac4:	111d31c0 	call	8111d31c <memset>
	memset(cTemp,0,114);
81119ac8:	01801c84 	movi	r6,114
81119acc:	000b883a 	mov	r5,zero
81119ad0:	e13fe204 	addi	r4,fp,-120
81119ad4:	111d31c0 	call	8111d31c <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
81119ad8:	e13fff17 	ldw	r4,-4(fp)
81119adc:	111dcc00 	call	8111dcc0 <strlen>
81119ae0:	10801c68 	cmpgeui	r2,r2,113
81119ae4:	1000031e 	bne	r2,zero,81119af4 <vLogWriteNUC+0x64>
81119ae8:	e13fff17 	ldw	r4,-4(fp)
81119aec:	111dcc00 	call	8111dcc0 <strlen>
81119af0:	00000106 	br	81119af8 <vLogWriteNUC+0x68>
81119af4:	00801c44 	movi	r2,113
81119af8:	100d883a 	mov	r6,r2
81119afc:	e17fff17 	ldw	r5,-4(fp)
81119b00:	e13fe204 	addi	r4,fp,-120
81119b04:	111d1cc0 	call	8111d1cc <memcpy>
	vSendLog ( cDataIn );
81119b08:	e13fff17 	ldw	r4,-4(fp)
81119b0c:	1115cfc0 	call	81115cfc <vSendLog>
}
81119b10:	0001883a 	nop
81119b14:	e037883a 	mov	sp,fp
81119b18:	dfc00117 	ldw	ra,4(sp)
81119b1c:	df000017 	ldw	fp,0(sp)
81119b20:	dec00204 	addi	sp,sp,8
81119b24:	f800283a 	ret

81119b28 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
81119b28:	defffd04 	addi	sp,sp,-12
81119b2c:	de00012e 	bgeu	sp,et,81119b34 <vSimucamStructureInit+0xc>
81119b30:	003b68fa 	trap	3
81119b34:	dfc00215 	stw	ra,8(sp)
81119b38:	df000115 	stw	fp,4(sp)
81119b3c:	df000104 	addi	fp,sp,4
81119b40:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
81119b44:	e0bfff17 	ldw	r2,-4(fp)
81119b48:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
81119b4c:	e0bfff17 	ldw	r2,-4(fp)
81119b50:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
81119b54:	e13fff17 	ldw	r4,-4(fp)
81119b58:	1119c140 	call	81119c14 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
81119b5c:	e13fff17 	ldw	r4,-4(fp)
81119b60:	1119cb80 	call	81119cb8 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
81119b64:	e13fff17 	ldw	r4,-4(fp)
81119b68:	1119d600 	call	81119d60 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
81119b6c:	e13fff17 	ldw	r4,-4(fp)
81119b70:	1119e000 	call	81119e00 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
81119b74:	e0bfff17 	ldw	r2,-4(fp)
81119b78:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
81119b7c:	e0bfff17 	ldw	r2,-4(fp)
81119b80:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
81119b84:	e0bfff17 	ldw	r2,-4(fp)
81119b88:	00c07d04 	movi	r3,500
81119b8c:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
81119b90:	e0bfff17 	ldw	r2,-4(fp)
81119b94:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
81119b98:	e0bfff17 	ldw	r2,-4(fp)
81119b9c:	00c00044 	movi	r3,1
81119ba0:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
81119ba4:	e0bfff17 	ldw	r2,-4(fp)
81119ba8:	10c00204 	addi	r3,r2,8
81119bac:	e0bfff17 	ldw	r2,-4(fp)
81119bb0:	10c0a715 	stw	r3,668(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
81119bb4:	e0bfff17 	ldw	r2,-4(fp)
81119bb8:	10c00244 	addi	r3,r2,9
81119bbc:	e0bfff17 	ldw	r2,-4(fp)
81119bc0:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
81119bc4:	e0bfff17 	ldw	r2,-4(fp)
81119bc8:	10800017 	ldw	r2,0(r2)
81119bcc:	10000b1e 	bne	r2,zero,81119bfc <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
81119bd0:	e0bfff17 	ldw	r2,-4(fp)
81119bd4:	10801204 	addi	r2,r2,72
81119bd8:	1009883a 	mov	r4,r2
81119bdc:	11197c00 	call	811197c0 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
81119be0:	e0bfff17 	ldw	r2,-4(fp)
81119be4:	10c00a04 	addi	r3,r2,40
81119be8:	e0bfff17 	ldw	r2,-4(fp)
81119bec:	10801204 	addi	r2,r2,72
81119bf0:	100b883a 	mov	r5,r2
81119bf4:	1809883a 	mov	r4,r3
81119bf8:	11170c80 	call	811170c8 <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
81119bfc:	0001883a 	nop
81119c00:	e037883a 	mov	sp,fp
81119c04:	dfc00117 	ldw	ra,4(sp)
81119c08:	df000017 	ldw	fp,0(sp)
81119c0c:	dec00204 	addi	sp,sp,8
81119c10:	f800283a 	ret

81119c14 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
81119c14:	defffe04 	addi	sp,sp,-8
81119c18:	de00012e 	bgeu	sp,et,81119c20 <vLoadDefaultEPValue+0xc>
81119c1c:	003b68fa 	trap	3
81119c20:	df000115 	stw	fp,4(sp)
81119c24:	df000104 	addi	fp,sp,4
81119c28:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
81119c2c:	e0bfff17 	ldw	r2,-4(fp)
81119c30:	00d07234 	movhi	r3,16840
81119c34:	10c00315 	stw	r3,12(r2)
}
81119c38:	0001883a 	nop
81119c3c:	e037883a 	mov	sp,fp
81119c40:	df000017 	ldw	fp,0(sp)
81119c44:	dec00104 	addi	sp,sp,4
81119c48:	f800283a 	ret

81119c4c <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81119c4c:	defffd04 	addi	sp,sp,-12
81119c50:	de00012e 	bgeu	sp,et,81119c58 <vChangeEPValue+0xc>
81119c54:	003b68fa 	trap	3
81119c58:	df000215 	stw	fp,8(sp)
81119c5c:	df000204 	addi	fp,sp,8
81119c60:	e13ffe15 	stw	r4,-8(fp)
81119c64:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
81119c68:	e0bffe17 	ldw	r2,-8(fp)
81119c6c:	e0ffff17 	ldw	r3,-4(fp)
81119c70:	10c00315 	stw	r3,12(r2)
}
81119c74:	0001883a 	nop
81119c78:	e037883a 	mov	sp,fp
81119c7c:	df000017 	ldw	fp,0(sp)
81119c80:	dec00104 	addi	sp,sp,4
81119c84:	f800283a 	ret

81119c88 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81119c88:	defffd04 	addi	sp,sp,-12
81119c8c:	de00012e 	bgeu	sp,et,81119c94 <vChangeDefaultEPValue+0xc>
81119c90:	003b68fa 	trap	3
81119c94:	df000215 	stw	fp,8(sp)
81119c98:	df000204 	addi	fp,sp,8
81119c9c:	e13ffe15 	stw	r4,-8(fp)
81119ca0:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
81119ca4:	0001883a 	nop
81119ca8:	e037883a 	mov	sp,fp
81119cac:	df000017 	ldw	fp,0(sp)
81119cb0:	dec00104 	addi	sp,sp,4
81119cb4:	f800283a 	ret

81119cb8 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
81119cb8:	defffe04 	addi	sp,sp,-8
81119cbc:	de00012e 	bgeu	sp,et,81119cc4 <vLoadDefaultRTValue+0xc>
81119cc0:	003b68fa 	trap	3
81119cc4:	df000115 	stw	fp,4(sp)
81119cc8:	df000104 	addi	fp,sp,4
81119ccc:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
81119cd0:	e0ffff17 	ldw	r3,-4(fp)
81119cd4:	00901eb4 	movhi	r2,16506
81119cd8:	10a66684 	addi	r2,r2,-26214
81119cdc:	18800415 	stw	r2,16(r3)
}
81119ce0:	0001883a 	nop
81119ce4:	e037883a 	mov	sp,fp
81119ce8:	df000017 	ldw	fp,0(sp)
81119cec:	dec00104 	addi	sp,sp,4
81119cf0:	f800283a 	ret

81119cf4 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81119cf4:	defffd04 	addi	sp,sp,-12
81119cf8:	de00012e 	bgeu	sp,et,81119d00 <vChangeRTValue+0xc>
81119cfc:	003b68fa 	trap	3
81119d00:	df000215 	stw	fp,8(sp)
81119d04:	df000204 	addi	fp,sp,8
81119d08:	e13ffe15 	stw	r4,-8(fp)
81119d0c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
81119d10:	e0bffe17 	ldw	r2,-8(fp)
81119d14:	e0ffff17 	ldw	r3,-4(fp)
81119d18:	10c00415 	stw	r3,16(r2)
}
81119d1c:	0001883a 	nop
81119d20:	e037883a 	mov	sp,fp
81119d24:	df000017 	ldw	fp,0(sp)
81119d28:	dec00104 	addi	sp,sp,4
81119d2c:	f800283a 	ret

81119d30 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81119d30:	defffd04 	addi	sp,sp,-12
81119d34:	de00012e 	bgeu	sp,et,81119d3c <vChangeDefaultRTValue+0xc>
81119d38:	003b68fa 	trap	3
81119d3c:	df000215 	stw	fp,8(sp)
81119d40:	df000204 	addi	fp,sp,8
81119d44:	e13ffe15 	stw	r4,-8(fp)
81119d48:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
81119d4c:	0001883a 	nop
81119d50:	e037883a 	mov	sp,fp
81119d54:	df000017 	ldw	fp,0(sp)
81119d58:	dec00104 	addi	sp,sp,4
81119d5c:	f800283a 	ret

81119d60 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
81119d60:	defffe04 	addi	sp,sp,-8
81119d64:	de00012e 	bgeu	sp,et,81119d6c <vLoadDefaultSyncSource+0xc>
81119d68:	003b68fa 	trap	3
81119d6c:	df000115 	stw	fp,4(sp)
81119d70:	df000104 	addi	fp,sp,4
81119d74:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
81119d78:	e0bfff17 	ldw	r2,-4(fp)
81119d7c:	10000815 	stw	zero,32(r2)
}
81119d80:	0001883a 	nop
81119d84:	e037883a 	mov	sp,fp
81119d88:	df000017 	ldw	fp,0(sp)
81119d8c:	dec00104 	addi	sp,sp,4
81119d90:	f800283a 	ret

81119d94 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81119d94:	defffd04 	addi	sp,sp,-12
81119d98:	de00012e 	bgeu	sp,et,81119da0 <vChangeSyncSource+0xc>
81119d9c:	003b68fa 	trap	3
81119da0:	df000215 	stw	fp,8(sp)
81119da4:	df000204 	addi	fp,sp,8
81119da8:	e13ffe15 	stw	r4,-8(fp)
81119dac:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
81119db0:	e0bffe17 	ldw	r2,-8(fp)
81119db4:	e0ffff17 	ldw	r3,-4(fp)
81119db8:	10c00815 	stw	r3,32(r2)
}
81119dbc:	0001883a 	nop
81119dc0:	e037883a 	mov	sp,fp
81119dc4:	df000017 	ldw	fp,0(sp)
81119dc8:	dec00104 	addi	sp,sp,4
81119dcc:	f800283a 	ret

81119dd0 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81119dd0:	defffd04 	addi	sp,sp,-12
81119dd4:	de00012e 	bgeu	sp,et,81119ddc <vChangeDefaultSyncSource+0xc>
81119dd8:	003b68fa 	trap	3
81119ddc:	df000215 	stw	fp,8(sp)
81119de0:	df000204 	addi	fp,sp,8
81119de4:	e13ffe15 	stw	r4,-8(fp)
81119de8:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
81119dec:	0001883a 	nop
81119df0:	e037883a 	mov	sp,fp
81119df4:	df000017 	ldw	fp,0(sp)
81119df8:	dec00104 	addi	sp,sp,4
81119dfc:	f800283a 	ret

81119e00 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
81119e00:	defffe04 	addi	sp,sp,-8
81119e04:	de00012e 	bgeu	sp,et,81119e0c <vLoadDefaultAutoResetSync+0xc>
81119e08:	003b68fa 	trap	3
81119e0c:	df000115 	stw	fp,4(sp)
81119e10:	df000104 	addi	fp,sp,4
81119e14:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
81119e18:	e0bfff17 	ldw	r2,-4(fp)
81119e1c:	00c00044 	movi	r3,1
81119e20:	10c00915 	stw	r3,36(r2)
}
81119e24:	0001883a 	nop
81119e28:	e037883a 	mov	sp,fp
81119e2c:	df000017 	ldw	fp,0(sp)
81119e30:	dec00104 	addi	sp,sp,4
81119e34:	f800283a 	ret

81119e38 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81119e38:	defffd04 	addi	sp,sp,-12
81119e3c:	de00012e 	bgeu	sp,et,81119e44 <vChangeAutoResetSync+0xc>
81119e40:	003b68fa 	trap	3
81119e44:	df000215 	stw	fp,8(sp)
81119e48:	df000204 	addi	fp,sp,8
81119e4c:	e13ffe15 	stw	r4,-8(fp)
81119e50:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
81119e54:	e0bffe17 	ldw	r2,-8(fp)
81119e58:	e0ffff17 	ldw	r3,-4(fp)
81119e5c:	10c00915 	stw	r3,36(r2)
}
81119e60:	0001883a 	nop
81119e64:	e037883a 	mov	sp,fp
81119e68:	df000017 	ldw	fp,0(sp)
81119e6c:	dec00104 	addi	sp,sp,4
81119e70:	f800283a 	ret

81119e74 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81119e74:	defffd04 	addi	sp,sp,-12
81119e78:	de00012e 	bgeu	sp,et,81119e80 <vChangeDefaultAutoResetSync+0xc>
81119e7c:	003b68fa 	trap	3
81119e80:	df000215 	stw	fp,8(sp)
81119e84:	df000204 	addi	fp,sp,8
81119e88:	e13ffe15 	stw	r4,-8(fp)
81119e8c:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
81119e90:	0001883a 	nop
81119e94:	e037883a 	mov	sp,fp
81119e98:	df000017 	ldw	fp,0(sp)
81119e9c:	dec00104 	addi	sp,sp,4
81119ea0:	f800283a 	ret

81119ea4 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
81119ea4:	defffc04 	addi	sp,sp,-16
81119ea8:	de00012e 	bgeu	sp,et,81119eb0 <vSyncReset+0xc>
81119eac:	003b68fa 	trap	3
81119eb0:	dfc00315 	stw	ra,12(sp)
81119eb4:	df000215 	stw	fp,8(sp)
81119eb8:	df000204 	addi	fp,sp,8
81119ebc:	e13ffe15 	stw	r4,-8(fp)
81119ec0:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
81119ec4:	e0bffe17 	ldw	r2,-8(fp)
81119ec8:	10801204 	addi	r2,r2,72
81119ecc:	1009883a 	mov	r4,r2
81119ed0:	111990c0 	call	8111990c <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
81119ed4:	0001883a 	nop
81119ed8:	e037883a 	mov	sp,fp
81119edc:	dfc00117 	ldw	ra,4(sp)
81119ee0:	df000017 	ldw	fp,0(sp)
81119ee4:	dec00204 	addi	sp,sp,8
81119ee8:	f800283a 	ret

81119eec <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
81119eec:	defff004 	addi	sp,sp,-64
81119ef0:	de00012e 	bgeu	sp,et,81119ef8 <pattern_createPattern+0xc>
81119ef4:	003b68fa 	trap	3
81119ef8:	dfc00f15 	stw	ra,60(sp)
81119efc:	df000e15 	stw	fp,56(sp)
81119f00:	dcc00d15 	stw	r19,52(sp)
81119f04:	dc800c15 	stw	r18,48(sp)
81119f08:	dc400b15 	stw	r17,44(sp)
81119f0c:	dc000a15 	stw	r16,40(sp)
81119f10:	df000e04 	addi	fp,sp,56
81119f14:	e17ff915 	stw	r5,-28(fp)
81119f18:	3007883a 	mov	r3,r6
81119f1c:	3805883a 	mov	r2,r7
81119f20:	e13ff805 	stb	r4,-32(fp)
81119f24:	e0fffa05 	stb	r3,-24(fp)
81119f28:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
81119f2c:	e0bff803 	ldbu	r2,-32(fp)
81119f30:	1009883a 	mov	r4,r2
81119f34:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
81119f38:	e0bff917 	ldw	r2,-28(fp)
81119f3c:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
81119f40:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
81119f44:	e0bff217 	ldw	r2,-56(fp)
81119f48:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81119f4c:	e03ff515 	stw	zero,-44(fp)
81119f50:	00003606 	br	8111a02c <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81119f54:	e03ff615 	stw	zero,-40(fp)
81119f58:	00002e06 	br	8111a014 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
81119f5c:	e0bff303 	ldbu	r2,-52(fp)
81119f60:	10801018 	cmpnei	r2,r2,64
81119f64:	10000b1e 	bne	r2,zero,81119f94 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
81119f68:	e0bff417 	ldw	r2,-48(fp)
81119f6c:	00ffffc4 	movi	r3,-1
81119f70:	10c02015 	stw	r3,128(r2)
81119f74:	00ffffc4 	movi	r3,-1
81119f78:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
81119f7c:	e0bff217 	ldw	r2,-56(fp)
81119f80:	10802204 	addi	r2,r2,136
81119f84:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
81119f88:	e0bff217 	ldw	r2,-56(fp)
81119f8c:	e0bff415 	stw	r2,-48(fp)
				i = 0;
81119f90:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
81119f94:	e0bff303 	ldbu	r2,-52(fp)
81119f98:	10c00044 	addi	r3,r2,1
81119f9c:	e0fff305 	stb	r3,-52(fp)
81119fa0:	10803fcc 	andi	r2,r2,255
81119fa4:	e0fffa03 	ldbu	r3,-24(fp)
81119fa8:	18c000cc 	andi	r3,r3,3
81119fac:	180692fa 	slli	r3,r3,11
81119fb0:	1809883a 	mov	r4,r3
81119fb4:	00f80004 	movi	r3,-8192
81119fb8:	20c6b03a 	or	r3,r4,r3
81119fbc:	1809883a 	mov	r4,r3
81119fc0:	e0fffb03 	ldbu	r3,-20(fp)
81119fc4:	18c0004c 	andi	r3,r3,1
81119fc8:	180692ba 	slli	r3,r3,10
81119fcc:	20c6b03a 	or	r3,r4,r3
81119fd0:	1809883a 	mov	r4,r3
81119fd4:	e0fff517 	ldw	r3,-44(fp)
81119fd8:	18c007cc 	andi	r3,r3,31
81119fdc:	1806917a 	slli	r3,r3,5
81119fe0:	20c6b03a 	or	r3,r4,r3
81119fe4:	1809883a 	mov	r4,r3
81119fe8:	e0fff617 	ldw	r3,-40(fp)
81119fec:	18c007cc 	andi	r3,r3,31
81119ff0:	20c6b03a 	or	r3,r4,r3
81119ff4:	1809883a 	mov	r4,r3
81119ff8:	e0fff417 	ldw	r3,-48(fp)
81119ffc:	1085883a 	add	r2,r2,r2
8111a000:	1885883a 	add	r2,r3,r2
8111a004:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111a008:	e0bff617 	ldw	r2,-40(fp)
8111a00c:	10800044 	addi	r2,r2,1
8111a010:	e0bff615 	stw	r2,-40(fp)
8111a014:	e0fff617 	ldw	r3,-40(fp)
8111a018:	e0800217 	ldw	r2,8(fp)
8111a01c:	18bfcf36 	bltu	r3,r2,81119f5c <__reset+0xfb0f9f5c>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111a020:	e0bff517 	ldw	r2,-44(fp)
8111a024:	10800044 	addi	r2,r2,1
8111a028:	e0bff515 	stw	r2,-44(fp)
8111a02c:	e0fff517 	ldw	r3,-44(fp)
8111a030:	e0800317 	ldw	r2,12(fp)
8111a034:	18bfc736 	bltu	r3,r2,81119f54 <__reset+0xfb0f9f54>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111a038:	e0bff303 	ldbu	r2,-52(fp)
8111a03c:	e0bff705 	stb	r2,-36(fp)
8111a040:	00000806 	br	8111a064 <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
8111a044:	e0bff703 	ldbu	r2,-36(fp)
8111a048:	e0fff417 	ldw	r3,-48(fp)
8111a04c:	1085883a 	add	r2,r2,r2
8111a050:	1885883a 	add	r2,r3,r2
8111a054:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111a058:	e0bff703 	ldbu	r2,-36(fp)
8111a05c:	10800044 	addi	r2,r2,1
8111a060:	e0bff705 	stb	r2,-36(fp)
8111a064:	e0bff703 	ldbu	r2,-36(fp)
8111a068:	10801030 	cmpltui	r2,r2,64
8111a06c:	103ff51e 	bne	r2,zero,8111a044 <__reset+0xfb0fa044>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
8111a070:	e0bff417 	ldw	r2,-48(fp)
8111a074:	10002015 	stw	zero,128(r2)
8111a078:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111a07c:	e03ff745 	stb	zero,-35(fp)
8111a080:	00001106 	br	8111a0c8 <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
8111a084:	e13ff417 	ldw	r4,-48(fp)
8111a088:	20802017 	ldw	r2,128(r4)
8111a08c:	20c02117 	ldw	r3,132(r4)
8111a090:	e13ff743 	ldbu	r4,-35(fp)
8111a094:	01400044 	movi	r5,1
8111a098:	2908983a 	sll	r4,r5,r4
8111a09c:	2025883a 	mov	r18,r4
8111a0a0:	2009d7fa 	srai	r4,r4,31
8111a0a4:	2027883a 	mov	r19,r4
8111a0a8:	14a0b03a 	or	r16,r2,r18
8111a0ac:	1ce2b03a 	or	r17,r3,r19
8111a0b0:	e0bff417 	ldw	r2,-48(fp)
8111a0b4:	14002015 	stw	r16,128(r2)
8111a0b8:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111a0bc:	e0bff743 	ldbu	r2,-35(fp)
8111a0c0:	10800044 	addi	r2,r2,1
8111a0c4:	e0bff745 	stb	r2,-35(fp)
8111a0c8:	e0fff743 	ldbu	r3,-35(fp)
8111a0cc:	e0bff303 	ldbu	r2,-52(fp)
8111a0d0:	18bfec36 	bltu	r3,r2,8111a084 <__reset+0xfb0fa084>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111a0d4:	e0bff217 	ldw	r2,-56(fp)
8111a0d8:	10802204 	addi	r2,r2,136
8111a0dc:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111a0e0:	e0bff217 	ldw	r2,-56(fp)
}
8111a0e4:	e6fffc04 	addi	sp,fp,-16
8111a0e8:	dfc00517 	ldw	ra,20(sp)
8111a0ec:	df000417 	ldw	fp,16(sp)
8111a0f0:	dcc00317 	ldw	r19,12(sp)
8111a0f4:	dc800217 	ldw	r18,8(sp)
8111a0f8:	dc400117 	ldw	r17,4(sp)
8111a0fc:	dc000017 	ldw	r16,0(sp)
8111a100:	dec00604 	addi	sp,sp,24
8111a104:	f800283a 	ret

8111a108 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111a108:	defffe04 	addi	sp,sp,-8
8111a10c:	de00012e 	bgeu	sp,et,8111a114 <bSDcardIsPresent+0xc>
8111a110:	003b68fa 	trap	3
8111a114:	dfc00115 	stw	ra,4(sp)
8111a118:	df000015 	stw	fp,0(sp)
8111a11c:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111a120:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
}
8111a124:	e037883a 	mov	sp,fp
8111a128:	dfc00117 	ldw	ra,4(sp)
8111a12c:	df000017 	ldw	fp,0(sp)
8111a130:	dec00204 	addi	sp,sp,8
8111a134:	f800283a 	ret

8111a138 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111a138:	defffe04 	addi	sp,sp,-8
8111a13c:	de00012e 	bgeu	sp,et,8111a144 <bSDcardFAT16Check+0xc>
8111a140:	003b68fa 	trap	3
8111a144:	dfc00115 	stw	ra,4(sp)
8111a148:	df000015 	stw	fp,0(sp)
8111a14c:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111a150:	11407040 	call	81140704 <alt_up_sd_card_is_FAT16>
}
8111a154:	e037883a 	mov	sp,fp
8111a158:	dfc00117 	ldw	ra,4(sp)
8111a15c:	df000017 	ldw	fp,0(sp)
8111a160:	dec00204 	addi	sp,sp,8
8111a164:	f800283a 	ret

8111a168 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111a168:	defffd04 	addi	sp,sp,-12
8111a16c:	de00012e 	bgeu	sp,et,8111a174 <bInitializeSDCard+0xc>
8111a170:	003b68fa 	trap	3
8111a174:	dfc00215 	stw	ra,8(sp)
8111a178:	df000115 	stw	fp,4(sp)
8111a17c:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111a180:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111a184:	d0207215 	stw	zero,-32312(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111a188:	01204574 	movhi	r4,33045
8111a18c:	212cc904 	addi	r4,r4,-19676
8111a190:	11405740 	call	81140574 <alt_up_sd_card_open_dev>
8111a194:	d0a07215 	stw	r2,-32312(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111a198:	d0a07217 	ldw	r2,-32312(gp)
8111a19c:	10002226 	beq	r2,zero,8111a228 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111a1a0:	111a1080 	call	8111a108 <bSDcardIsPresent>
8111a1a4:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111a1a8:	e0bfff17 	ldw	r2,-4(fp)
8111a1ac:	10001626 	beq	r2,zero,8111a208 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111a1b0:	111a1380 	call	8111a138 <bSDcardFAT16Check>
8111a1b4:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111a1b8:	e0bfff17 	ldw	r2,-4(fp)
8111a1bc:	10000a26 	beq	r2,zero,8111a1e8 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111a1c0:	00800044 	movi	r2,1
8111a1c4:	d0a07115 	stw	r2,-32316(gp)
				debug(fp, "SD is up.\r\n");
8111a1c8:	d0a05d17 	ldw	r2,-32396(gp)
8111a1cc:	100f883a 	mov	r7,r2
8111a1d0:	018002c4 	movi	r6,11
8111a1d4:	01400044 	movi	r5,1
8111a1d8:	01204574 	movhi	r4,33045
8111a1dc:	212cd404 	addi	r4,r4,-19632
8111a1e0:	111c7b80 	call	8111c7b8 <fwrite>
8111a1e4:	00001806 	br	8111a248 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
8111a1e8:	d0a05d17 	ldw	r2,-32396(gp)
8111a1ec:	100f883a 	mov	r7,r2
8111a1f0:	01800984 	movi	r6,38
8111a1f4:	01400044 	movi	r5,1
8111a1f8:	01204574 	movhi	r4,33045
8111a1fc:	212cd704 	addi	r4,r4,-19620
8111a200:	111c7b80 	call	8111c7b8 <fwrite>
8111a204:	00001006 	br	8111a248 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
8111a208:	d0a05d17 	ldw	r2,-32396(gp)
8111a20c:	100f883a 	mov	r7,r2
8111a210:	01800744 	movi	r6,29
8111a214:	01400044 	movi	r5,1
8111a218:	01204574 	movhi	r4,33045
8111a21c:	212ce104 	addi	r4,r4,-19580
8111a220:	111c7b80 	call	8111c7b8 <fwrite>
8111a224:	00000806 	br	8111a248 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111a228:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
8111a22c:	d0a05d17 	ldw	r2,-32396(gp)
8111a230:	100f883a 	mov	r7,r2
8111a234:	018008c4 	movi	r6,35
8111a238:	01400044 	movi	r5,1
8111a23c:	01204574 	movhi	r4,33045
8111a240:	212ce904 	addi	r4,r4,-19548
8111a244:	111c7b80 	call	8111c7b8 <fwrite>
	}

	return bSucess;
8111a248:	e0bfff17 	ldw	r2,-4(fp)
}
8111a24c:	e037883a 	mov	sp,fp
8111a250:	dfc00117 	ldw	ra,4(sp)
8111a254:	df000017 	ldw	fp,0(sp)
8111a258:	dec00204 	addi	sp,sp,8
8111a25c:	f800283a 	ret

8111a260 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111a260:	defffd04 	addi	sp,sp,-12
8111a264:	de00012e 	bgeu	sp,et,8111a26c <siOpenFile+0xc>
8111a268:	003b68fa 	trap	3
8111a26c:	dfc00215 	stw	ra,8(sp)
8111a270:	df000115 	stw	fp,4(sp)
8111a274:	df000104 	addi	fp,sp,4
8111a278:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111a27c:	000b883a 	mov	r5,zero
8111a280:	e13fff17 	ldw	r4,-4(fp)
8111a284:	1140c100 	call	81140c10 <alt_up_sd_card_fopen>
}
8111a288:	e037883a 	mov	sp,fp
8111a28c:	dfc00117 	ldw	ra,4(sp)
8111a290:	df000017 	ldw	fp,0(sp)
8111a294:	dec00204 	addi	sp,sp,8
8111a298:	f800283a 	ret

8111a29c <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111a29c:	defffd04 	addi	sp,sp,-12
8111a2a0:	de00012e 	bgeu	sp,et,8111a2a8 <siCloseFile+0xc>
8111a2a4:	003b68fa 	trap	3
8111a2a8:	dfc00215 	stw	ra,8(sp)
8111a2ac:	df000115 	stw	fp,4(sp)
8111a2b0:	df000104 	addi	fp,sp,4
8111a2b4:	2005883a 	mov	r2,r4
8111a2b8:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111a2bc:	e0bfff0f 	ldh	r2,-4(fp)
8111a2c0:	1009883a 	mov	r4,r2
8111a2c4:	1141a5c0 	call	81141a5c <alt_up_sd_card_fclose>
}
8111a2c8:	e037883a 	mov	sp,fp
8111a2cc:	dfc00117 	ldw	ra,4(sp)
8111a2d0:	df000017 	ldw	fp,0(sp)
8111a2d4:	dec00204 	addi	sp,sp,8
8111a2d8:	f800283a 	ret

8111a2dc <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111a2dc:	defffd04 	addi	sp,sp,-12
8111a2e0:	de00012e 	bgeu	sp,et,8111a2e8 <cGetNextChar+0xc>
8111a2e4:	003b68fa 	trap	3
8111a2e8:	dfc00215 	stw	ra,8(sp)
8111a2ec:	df000115 	stw	fp,4(sp)
8111a2f0:	df000104 	addi	fp,sp,4
8111a2f4:	2005883a 	mov	r2,r4
8111a2f8:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111a2fc:	e0bfff0f 	ldh	r2,-4(fp)
8111a300:	1009883a 	mov	r4,r2
8111a304:	11410b40 	call	811410b4 <alt_up_sd_card_read>
}
8111a308:	e037883a 	mov	sp,fp
8111a30c:	dfc00117 	ldw	ra,4(sp)
8111a310:	df000017 	ldw	fp,0(sp)
8111a314:	dec00204 	addi	sp,sp,8
8111a318:	f800283a 	ret

8111a31c <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8111a31c:	defffc04 	addi	sp,sp,-16
8111a320:	de00012e 	bgeu	sp,et,8111a328 <bInitSync+0xc>
8111a324:	003b68fa 	trap	3
8111a328:	dfc00315 	stw	ra,12(sp)
8111a32c:	df000215 	stw	fp,8(sp)
8111a330:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111a334:	110bad40 	call	8110bad4 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
8111a338:	d0a05d17 	ldw	r2,-32396(gp)
8111a33c:	100f883a 	mov	r7,r2
8111a340:	01800684 	movi	r6,26
8111a344:	01400044 	movi	r5,1
8111a348:	01204574 	movhi	r4,33045
8111a34c:	212cf204 	addi	r4,r4,-19512
8111a350:	111c7b80 	call	8111c7b8 <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8111a354:	01004c74 	movhi	r4,305
8111a358:	210b4004 	addi	r4,r4,11520
8111a35c:	110bcdc0 	call	8110bcdc <bSyncSetMbt>
8111a360:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a364:	e0bffe17 	ldw	r2,-8(fp)
8111a368:	1000091e 	bne	r2,zero,8111a390 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a36c:	d0a05d17 	ldw	r2,-32396(gp)
8111a370:	100f883a 	mov	r7,r2
8111a374:	018005c4 	movi	r6,23
8111a378:	01400044 	movi	r5,1
8111a37c:	01204574 	movhi	r4,33045
8111a380:	212cf904 	addi	r4,r4,-19484
8111a384:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a388:	e0bffe17 	ldw	r2,-8(fp)
8111a38c:	00007a06 	br	8111a578 <bInitSync+0x25c>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111a390:	01002674 	movhi	r4,153
8111a394:	2125a004 	addi	r4,r4,-27008
8111a398:	110bd1c0 	call	8110bd1c <bSyncSetBt>
8111a39c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a3a0:	e0bffe17 	ldw	r2,-8(fp)
8111a3a4:	1000091e 	bne	r2,zero,8111a3cc <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a3a8:	d0a05d17 	ldw	r2,-32396(gp)
8111a3ac:	100f883a 	mov	r7,r2
8111a3b0:	018005c4 	movi	r6,23
8111a3b4:	01400044 	movi	r5,1
8111a3b8:	01204574 	movhi	r4,33045
8111a3bc:	212cf904 	addi	r4,r4,-19484
8111a3c0:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a3c4:	e0bffe17 	ldw	r2,-8(fp)
8111a3c8:	00006b06 	br	8111a578 <bInitSync+0x25c>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer((alt_u32)PER);
8111a3cc:	0112a074 	movhi	r4,19073
8111a3d0:	211f2004 	addi	r4,r4,31872
8111a3d4:	110bd5c0 	call	8110bd5c <bSyncSetPer>
8111a3d8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a3dc:	e0bffe17 	ldw	r2,-8(fp)
8111a3e0:	1000091e 	bne	r2,zero,8111a408 <bInitSync+0xec>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a3e4:	d0a05d17 	ldw	r2,-32396(gp)
8111a3e8:	100f883a 	mov	r7,r2
8111a3ec:	018005c4 	movi	r6,23
8111a3f0:	01400044 	movi	r5,1
8111a3f4:	01204574 	movhi	r4,33045
8111a3f8:	212cf904 	addi	r4,r4,-19484
8111a3fc:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a400:	e0bffe17 	ldw	r2,-8(fp)
8111a404:	00005c06 	br	8111a578 <bInitSync+0x25c>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8111a408:	01005f74 	movhi	r4,381
8111a40c:	211e1004 	addi	r4,r4,30784
8111a410:	110bd9c0 	call	8110bd9c <bSyncSetOst>
8111a414:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a418:	e0bffe17 	ldw	r2,-8(fp)
8111a41c:	1000091e 	bne	r2,zero,8111a444 <bInitSync+0x128>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a420:	d0a05d17 	ldw	r2,-32396(gp)
8111a424:	100f883a 	mov	r7,r2
8111a428:	018005c4 	movi	r6,23
8111a42c:	01400044 	movi	r5,1
8111a430:	01204574 	movhi	r4,33045
8111a434:	212cf904 	addi	r4,r4,-19484
8111a438:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a43c:	e0bffe17 	ldw	r2,-8(fp)
8111a440:	00004d06 	br	8111a578 <bInitSync+0x25c>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8111a444:	0009883a 	mov	r4,zero
8111a448:	110bddc0 	call	8110bddc <bSyncSetPolarity>
8111a44c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a450:	e0bffe17 	ldw	r2,-8(fp)
8111a454:	1000091e 	bne	r2,zero,8111a47c <bInitSync+0x160>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a458:	d0a05d17 	ldw	r2,-32396(gp)
8111a45c:	100f883a 	mov	r7,r2
8111a460:	018005c4 	movi	r6,23
8111a464:	01400044 	movi	r5,1
8111a468:	01204574 	movhi	r4,33045
8111a46c:	212cf904 	addi	r4,r4,-19484
8111a470:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a474:	e0bffe17 	ldw	r2,-8(fp)
8111a478:	00003f06 	br	8111a578 <bInitSync+0x25c>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8111a47c:	01000104 	movi	r4,4
8111a480:	110be500 	call	8110be50 <bSyncSetNCycles>
8111a484:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a488:	e0bffe17 	ldw	r2,-8(fp)
8111a48c:	1000091e 	bne	r2,zero,8111a4b4 <bInitSync+0x198>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a490:	d0a05d17 	ldw	r2,-32396(gp)
8111a494:	100f883a 	mov	r7,r2
8111a498:	018005c4 	movi	r6,23
8111a49c:	01400044 	movi	r5,1
8111a4a0:	01204574 	movhi	r4,33045
8111a4a4:	212cf904 	addi	r4,r4,-19484
8111a4a8:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a4ac:	e0bffe17 	ldw	r2,-8(fp)
8111a4b0:	00003106 	br	8111a578 <bInitSync+0x25c>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8111a4b4:	01000044 	movi	r4,1
8111a4b8:	110c02c0 	call	8110c02c <bSyncCtrExtnIrq>
8111a4bc:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a4c0:	e0bffe17 	ldw	r2,-8(fp)
8111a4c4:	1000091e 	bne	r2,zero,8111a4ec <bInitSync+0x1d0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a4c8:	d0a05d17 	ldw	r2,-32396(gp)
8111a4cc:	100f883a 	mov	r7,r2
8111a4d0:	018005c4 	movi	r6,23
8111a4d4:	01400044 	movi	r5,1
8111a4d8:	01204574 	movhi	r4,33045
8111a4dc:	212cf904 	addi	r4,r4,-19484
8111a4e0:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a4e4:	e0bffe17 	ldw	r2,-8(fp)
8111a4e8:	00002306 	br	8111a578 <bInitSync+0x25c>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8111a4ec:	01000044 	movi	r4,1
8111a4f0:	110c1f40 	call	8110c1f4 <bSyncCtrSyncOutEnable>
8111a4f4:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a4f8:	e0bffe17 	ldw	r2,-8(fp)
8111a4fc:	1000091e 	bne	r2,zero,8111a524 <bInitSync+0x208>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a500:	d0a05d17 	ldw	r2,-32396(gp)
8111a504:	100f883a 	mov	r7,r2
8111a508:	018005c4 	movi	r6,23
8111a50c:	01400044 	movi	r5,1
8111a510:	01204574 	movhi	r4,33045
8111a514:	212cf904 	addi	r4,r4,-19484
8111a518:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a51c:	e0bffe17 	ldw	r2,-8(fp)
8111a520:	00001506 	br	8111a578 <bInitSync+0x25c>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8111a524:	01000044 	movi	r4,1
8111a528:	110c2680 	call	8110c268 <bSyncCtrCh1OutEnable>
8111a52c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111a530:	e0bffe17 	ldw	r2,-8(fp)
8111a534:	1000091e 	bne	r2,zero,8111a55c <bInitSync+0x240>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111a538:	d0a05d17 	ldw	r2,-32396(gp)
8111a53c:	100f883a 	mov	r7,r2
8111a540:	018005c4 	movi	r6,23
8111a544:	01400044 	movi	r5,1
8111a548:	01204574 	movhi	r4,33045
8111a54c:	212cf904 	addi	r4,r4,-19484
8111a550:	111c7b80 	call	8111c7b8 <fwrite>
		#endif
		return bSuccess;
8111a554:	e0bffe17 	ldw	r2,-8(fp)
8111a558:	00000706 	br	8111a578 <bInitSync+0x25c>
	}

	bSuccess = bSyncCtrStart();
8111a55c:	110c0a40 	call	8110c0a4 <bSyncCtrStart>
8111a560:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
8111a564:	110c0f80 	call	8110c0f8 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111a568:	01000044 	movi	r4,1
8111a56c:	110c67c0 	call	8110c67c <bSyncIrqEnableBlank>
8111a570:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
8111a574:	e0bffe17 	ldw	r2,-8(fp)
}
8111a578:	e037883a 	mov	sp,fp
8111a57c:	dfc00117 	ldw	ra,4(sp)
8111a580:	df000017 	ldw	fp,0(sp)
8111a584:	dec00204 	addi	sp,sp,8
8111a588:	f800283a 	ret

8111a58c <bStartSync>:


bool bStartSync(void) {
8111a58c:	defffd04 	addi	sp,sp,-12
8111a590:	de00012e 	bgeu	sp,et,8111a598 <bStartSync+0xc>
8111a594:	003b68fa 	trap	3
8111a598:	dfc00215 	stw	ra,8(sp)
8111a59c:	df000115 	stw	fp,4(sp)
8111a5a0:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSuccess = bSyncCtrStart();
8111a5a4:	110c0a40 	call	8110c0a4 <bSyncCtrStart>
8111a5a8:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8111a5ac:	e0bfff17 	ldw	r2,-4(fp)
}
8111a5b0:	e037883a 	mov	sp,fp
8111a5b4:	dfc00117 	ldw	ra,4(sp)
8111a5b8:	df000017 	ldw	fp,0(sp)
8111a5bc:	dec00204 	addi	sp,sp,8
8111a5c0:	f800283a 	ret

8111a5c4 <bStopSync>:

bool bStopSync(void) {
8111a5c4:	defffe04 	addi	sp,sp,-8
8111a5c8:	de00012e 	bgeu	sp,et,8111a5d0 <bStopSync+0xc>
8111a5cc:	003b68fa 	trap	3
8111a5d0:	dfc00115 	stw	ra,4(sp)
8111a5d4:	df000015 	stw	fp,0(sp)
8111a5d8:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8111a5dc:	110c0f80 	call	8110c0f8 <bSyncCtrReset>
}
8111a5e0:	e037883a 	mov	sp,fp
8111a5e4:	dfc00117 	ldw	ra,4(sp)
8111a5e8:	df000017 	ldw	fp,0(sp)
8111a5ec:	dec00204 	addi	sp,sp,8
8111a5f0:	f800283a 	ret

8111a5f4 <bClearCounterSync>:

void bClearCounterSync(void) {
8111a5f4:	defffe04 	addi	sp,sp,-8
8111a5f8:	de00012e 	bgeu	sp,et,8111a600 <bClearCounterSync+0xc>
8111a5fc:	003b68fa 	trap	3
8111a600:	dfc00115 	stw	ra,4(sp)
8111a604:	df000015 	stw	fp,0(sp)
8111a608:	d839883a 	mov	fp,sp

	vSyncClearCounter();
8111a60c:	110baa80 	call	8110baa8 <vSyncClearCounter>
}
8111a610:	0001883a 	nop
8111a614:	e037883a 	mov	sp,fp
8111a618:	dfc00117 	ldw	ra,4(sp)
8111a61c:	df000017 	ldw	fp,0(sp)
8111a620:	dec00204 	addi	sp,sp,8
8111a624:	f800283a 	ret

8111a628 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111a628:	defffd04 	addi	sp,sp,-12
8111a62c:	de00012e 	bgeu	sp,et,8111a634 <bTestSimucamCriticalHW+0xc>
8111a630:	003b68fa 	trap	3
8111a634:	dfc00215 	stw	ra,8(sp)
8111a638:	df000115 	stw	fp,4(sp)
8111a63c:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8111a640:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8111a644:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111a648:	e0bfff17 	ldw	r2,-4(fp)
8111a64c:	1000021e 	bne	r2,zero,8111a658 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8111a650:	e0bfff17 	ldw	r2,-4(fp)
8111a654:	00001106 	br	8111a69c <bTestSimucamCriticalHW+0x74>
	}

	bSuccess = bSdmaInitM2Dma();
8111a658:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
8111a65c:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111a660:	e0bfff17 	ldw	r2,-4(fp)
8111a664:	1000021e 	bne	r2,zero,8111a670 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111a668:	e0bfff17 	ldw	r2,-4(fp)
8111a66c:	00000b06 	br	8111a69c <bTestSimucamCriticalHW+0x74>
	}

	xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
8111a670:	00a045b4 	movhi	r2,33046
8111a674:	10b95504 	addi	r2,r2,-6828
8111a678:	00e04434 	movhi	r3,33040
8111a67c:	18cf2404 	addi	r3,r3,15504
8111a680:	10c00115 	stw	r3,4(r2)
	xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;
8111a684:	00a045b4 	movhi	r2,33046
8111a688:	10b95504 	addi	r2,r2,-6828
8111a68c:	00e04434 	movhi	r3,33040
8111a690:	18d02704 	addi	r3,r3,16540
8111a694:	10c00115 	stw	r3,4(r2)


	return TRUE;
8111a698:	00800044 	movi	r2,1
}
8111a69c:	e037883a 	mov	sp,fp
8111a6a0:	dfc00117 	ldw	ra,4(sp)
8111a6a4:	df000017 	ldw	fp,0(sp)
8111a6a8:	dec00204 	addi	sp,sp,8
8111a6ac:	f800283a 	ret

8111a6b0 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111a6b0:	defffc04 	addi	sp,sp,-16
8111a6b4:	de00012e 	bgeu	sp,et,8111a6bc <_reg_write+0xc>
8111a6b8:	003b68fa 	trap	3
8111a6bc:	df000315 	stw	fp,12(sp)
8111a6c0:	df000304 	addi	fp,sp,12
8111a6c4:	e13ffd15 	stw	r4,-12(fp)
8111a6c8:	e17ffe15 	stw	r5,-8(fp)
8111a6cc:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111a6d0:	e0bffe17 	ldw	r2,-8(fp)
8111a6d4:	1085883a 	add	r2,r2,r2
8111a6d8:	1085883a 	add	r2,r2,r2
8111a6dc:	1007883a 	mov	r3,r2
8111a6e0:	e0bffd17 	ldw	r2,-12(fp)
8111a6e4:	1885883a 	add	r2,r3,r2
8111a6e8:	1007883a 	mov	r3,r2
8111a6ec:	e0bfff17 	ldw	r2,-4(fp)
8111a6f0:	18800035 	stwio	r2,0(r3)
	return 1;
8111a6f4:	00800044 	movi	r2,1

}
8111a6f8:	e037883a 	mov	sp,fp
8111a6fc:	df000017 	ldw	fp,0(sp)
8111a700:	dec00104 	addi	sp,sp,4
8111a704:	f800283a 	ret

8111a708 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111a708:	defffc04 	addi	sp,sp,-16
8111a70c:	de00012e 	bgeu	sp,et,8111a714 <_reg_read+0xc>
8111a710:	003b68fa 	trap	3
8111a714:	df000315 	stw	fp,12(sp)
8111a718:	df000304 	addi	fp,sp,12
8111a71c:	e13ffd15 	stw	r4,-12(fp)
8111a720:	e17ffe15 	stw	r5,-8(fp)
8111a724:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111a728:	e0bffe17 	ldw	r2,-8(fp)
8111a72c:	1085883a 	add	r2,r2,r2
8111a730:	1085883a 	add	r2,r2,r2
8111a734:	1007883a 	mov	r3,r2
8111a738:	e0bffd17 	ldw	r2,-12(fp)
8111a73c:	1885883a 	add	r2,r3,r2
8111a740:	10c00037 	ldwio	r3,0(r2)
8111a744:	e0bfff17 	ldw	r2,-4(fp)
8111a748:	10c00015 	stw	r3,0(r2)
	return 1;
8111a74c:	00800044 	movi	r2,1

}
8111a750:	e037883a 	mov	sp,fp
8111a754:	df000017 	ldw	fp,0(sp)
8111a758:	dec00104 	addi	sp,sp,4
8111a75c:	f800283a 	ret

8111a760 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111a760:	defffa04 	addi	sp,sp,-24
8111a764:	de00012e 	bgeu	sp,et,8111a76c <_print_codec_status+0xc>
8111a768:	003b68fa 	trap	3
8111a76c:	dfc00515 	stw	ra,20(sp)
8111a770:	df000415 	stw	fp,16(sp)
8111a774:	df000404 	addi	fp,sp,16
8111a778:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111a77c:	e0bfff17 	ldw	r2,-4(fp)
8111a780:	1005d1ba 	srai	r2,r2,6
8111a784:	1080004c 	andi	r2,r2,1
8111a788:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111a78c:	e0bfff17 	ldw	r2,-4(fp)
8111a790:	1005d17a 	srai	r2,r2,5
8111a794:	1080004c 	andi	r2,r2,1
8111a798:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111a79c:	e0bfff17 	ldw	r2,-4(fp)
8111a7a0:	1005d13a 	srai	r2,r2,4
8111a7a4:	1080004c 	andi	r2,r2,1
8111a7a8:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111a7ac:	00e04574 	movhi	r3,33045
8111a7b0:	18f8de04 	addi	r3,r3,-7304
8111a7b4:	00a04574 	movhi	r2,33045
8111a7b8:	10acff04 	addi	r2,r2,-19460
8111a7bc:	1009883a 	mov	r4,r2
8111a7c0:	008005c4 	movi	r2,23
8111a7c4:	100d883a 	mov	r6,r2
8111a7c8:	200b883a 	mov	r5,r4
8111a7cc:	1809883a 	mov	r4,r3
8111a7d0:	111d1cc0 	call	8111d1cc <memcpy>
	debug(fp, cDebugBuffer);
8111a7d4:	d0a05d17 	ldw	r2,-32396(gp)
8111a7d8:	01604574 	movhi	r5,33045
8111a7dc:	2978de04 	addi	r5,r5,-7304
8111a7e0:	1009883a 	mov	r4,r2
8111a7e4:	111c11c0 	call	8111c11c <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111a7e8:	e0bffc17 	ldw	r2,-16(fp)
8111a7ec:	10800058 	cmpnei	r2,r2,1
8111a7f0:	1000031e 	bne	r2,zero,8111a800 <_print_codec_status+0xa0>
8111a7f4:	00a04574 	movhi	r2,33045
8111a7f8:	10ad0504 	addi	r2,r2,-19436
8111a7fc:	00000206 	br	8111a808 <_print_codec_status+0xa8>
8111a800:	00a04574 	movhi	r2,33045
8111a804:	10ad0604 	addi	r2,r2,-19432
8111a808:	100d883a 	mov	r6,r2
8111a80c:	01604574 	movhi	r5,33045
8111a810:	296d0704 	addi	r5,r5,-19428
8111a814:	01204574 	movhi	r4,33045
8111a818:	2138de04 	addi	r4,r4,-7304
8111a81c:	111daac0 	call	8111daac <sprintf>
	debug(fp, cDebugBuffer);
8111a820:	d0a05d17 	ldw	r2,-32396(gp)
8111a824:	01604574 	movhi	r5,33045
8111a828:	2978de04 	addi	r5,r5,-7304
8111a82c:	1009883a 	mov	r4,r2
8111a830:	111c11c0 	call	8111c11c <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111a834:	e0bffd17 	ldw	r2,-12(fp)
8111a838:	10800058 	cmpnei	r2,r2,1
8111a83c:	1000031e 	bne	r2,zero,8111a84c <_print_codec_status+0xec>
8111a840:	00a04574 	movhi	r2,33045
8111a844:	10ad0504 	addi	r2,r2,-19436
8111a848:	00000206 	br	8111a854 <_print_codec_status+0xf4>
8111a84c:	00a04574 	movhi	r2,33045
8111a850:	10ad0604 	addi	r2,r2,-19432
8111a854:	100d883a 	mov	r6,r2
8111a858:	01604574 	movhi	r5,33045
8111a85c:	296d0d04 	addi	r5,r5,-19404
8111a860:	01204574 	movhi	r4,33045
8111a864:	2138de04 	addi	r4,r4,-7304
8111a868:	111daac0 	call	8111daac <sprintf>
	debug(fp, cDebugBuffer);
8111a86c:	d0a05d17 	ldw	r2,-32396(gp)
8111a870:	01604574 	movhi	r5,33045
8111a874:	2978de04 	addi	r5,r5,-7304
8111a878:	1009883a 	mov	r4,r2
8111a87c:	111c11c0 	call	8111c11c <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111a880:	e0bffe17 	ldw	r2,-8(fp)
8111a884:	10800058 	cmpnei	r2,r2,1
8111a888:	1000031e 	bne	r2,zero,8111a898 <_print_codec_status+0x138>
8111a88c:	00a04574 	movhi	r2,33045
8111a890:	10ad0504 	addi	r2,r2,-19436
8111a894:	00000206 	br	8111a8a0 <_print_codec_status+0x140>
8111a898:	00a04574 	movhi	r2,33045
8111a89c:	10ad0604 	addi	r2,r2,-19432
8111a8a0:	100d883a 	mov	r6,r2
8111a8a4:	01604574 	movhi	r5,33045
8111a8a8:	296d1304 	addi	r5,r5,-19380
8111a8ac:	01204574 	movhi	r4,33045
8111a8b0:	2138de04 	addi	r4,r4,-7304
8111a8b4:	111daac0 	call	8111daac <sprintf>
	debug(fp, cDebugBuffer);
8111a8b8:	d0a05d17 	ldw	r2,-32396(gp)
8111a8bc:	01604574 	movhi	r5,33045
8111a8c0:	2978de04 	addi	r5,r5,-7304
8111a8c4:	1009883a 	mov	r4,r2
8111a8c8:	111c11c0 	call	8111c11c <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111a8cc:	00a04574 	movhi	r2,33045
8111a8d0:	10b8de04 	addi	r2,r2,-7304
8111a8d4:	00c00b44 	movi	r3,45
8111a8d8:	10c00005 	stb	r3,0(r2)
8111a8dc:	00c00b44 	movi	r3,45
8111a8e0:	10c00045 	stb	r3,1(r2)
8111a8e4:	00c00b44 	movi	r3,45
8111a8e8:	10c00085 	stb	r3,2(r2)
8111a8ec:	00c00b44 	movi	r3,45
8111a8f0:	10c000c5 	stb	r3,3(r2)
8111a8f4:	00c00b44 	movi	r3,45
8111a8f8:	10c00105 	stb	r3,4(r2)
8111a8fc:	00c00b44 	movi	r3,45
8111a900:	10c00145 	stb	r3,5(r2)
8111a904:	00c00b44 	movi	r3,45
8111a908:	10c00185 	stb	r3,6(r2)
8111a90c:	00c00b44 	movi	r3,45
8111a910:	10c001c5 	stb	r3,7(r2)
8111a914:	00c00804 	movi	r3,32
8111a918:	10c00205 	stb	r3,8(r2)
8111a91c:	00c00804 	movi	r3,32
8111a920:	10c00245 	stb	r3,9(r2)
8111a924:	00c00284 	movi	r3,10
8111a928:	10c00285 	stb	r3,10(r2)
8111a92c:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111a930:	d0a05d17 	ldw	r2,-32396(gp)
8111a934:	01604574 	movhi	r5,33045
8111a938:	2978de04 	addi	r5,r5,-7304
8111a93c:	1009883a 	mov	r4,r2
8111a940:	111c11c0 	call	8111c11c <fprintf>
#endif
}
8111a944:	0001883a 	nop
8111a948:	e037883a 	mov	sp,fp
8111a94c:	dfc00117 	ldw	ra,4(sp)
8111a950:	df000017 	ldw	fp,0(sp)
8111a954:	dec00204 	addi	sp,sp,8
8111a958:	f800283a 	ret

8111a95c <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111a95c:	defffb04 	addi	sp,sp,-20
8111a960:	de00012e 	bgeu	sp,et,8111a968 <_split_codec_status+0xc>
8111a964:	003b68fa 	trap	3
8111a968:	df000415 	stw	fp,16(sp)
8111a96c:	df000404 	addi	fp,sp,16
8111a970:	e13ffc15 	stw	r4,-16(fp)
8111a974:	e17ffd15 	stw	r5,-12(fp)
8111a978:	e1bffe15 	stw	r6,-8(fp)
8111a97c:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111a980:	e0bffc17 	ldw	r2,-16(fp)
8111a984:	1005d1ba 	srai	r2,r2,6
8111a988:	10c0004c 	andi	r3,r2,1
8111a98c:	e0bffd17 	ldw	r2,-12(fp)
8111a990:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111a994:	e0bffc17 	ldw	r2,-16(fp)
8111a998:	1005d17a 	srai	r2,r2,5
8111a99c:	10c0004c 	andi	r3,r2,1
8111a9a0:	e0bffe17 	ldw	r2,-8(fp)
8111a9a4:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111a9a8:	e0bffc17 	ldw	r2,-16(fp)
8111a9ac:	1005d13a 	srai	r2,r2,4
8111a9b0:	10c0004c 	andi	r3,r2,1
8111a9b4:	e0bfff17 	ldw	r2,-4(fp)
8111a9b8:	10c00015 	stw	r3,0(r2)
}
8111a9bc:	0001883a 	nop
8111a9c0:	e037883a 	mov	sp,fp
8111a9c4:	df000017 	ldw	fp,0(sp)
8111a9c8:	dec00104 	addi	sp,sp,4
8111a9cc:	f800283a 	ret

8111a9d0 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111a9d0:	defffc04 	addi	sp,sp,-16
8111a9d4:	de00012e 	bgeu	sp,et,8111a9dc <aatoh+0xc>
8111a9d8:	003b68fa 	trap	3
8111a9dc:	df000315 	stw	fp,12(sp)
8111a9e0:	df000304 	addi	fp,sp,12
8111a9e4:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111a9e8:	e0bfff17 	ldw	r2,-4(fp)
8111a9ec:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111a9f0:	e0bffd17 	ldw	r2,-12(fp)
8111a9f4:	10c00003 	ldbu	r3,0(r2)
8111a9f8:	e0bffd17 	ldw	r2,-12(fp)
8111a9fc:	10800003 	ldbu	r2,0(r2)
8111aa00:	10803fcc 	andi	r2,r2,255
8111aa04:	10800eb0 	cmpltui	r2,r2,58
8111aa08:	1000021e 	bne	r2,zero,8111aa14 <aatoh+0x44>
8111aa0c:	00800dc4 	movi	r2,55
8111aa10:	00000106 	br	8111aa18 <aatoh+0x48>
8111aa14:	00800c04 	movi	r2,48
8111aa18:	1885c83a 	sub	r2,r3,r2
8111aa1c:	1004913a 	slli	r2,r2,4
8111aa20:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111aa24:	e0bffd17 	ldw	r2,-12(fp)
8111aa28:	10800044 	addi	r2,r2,1
8111aa2c:	10c00003 	ldbu	r3,0(r2)
8111aa30:	e0bffd17 	ldw	r2,-12(fp)
8111aa34:	10800044 	addi	r2,r2,1
8111aa38:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111aa3c:	10803fcc 	andi	r2,r2,255
8111aa40:	10800eb0 	cmpltui	r2,r2,58
8111aa44:	1000021e 	bne	r2,zero,8111aa50 <aatoh+0x80>
8111aa48:	00800dc4 	movi	r2,55
8111aa4c:	00000106 	br	8111aa54 <aatoh+0x84>
8111aa50:	00800c04 	movi	r2,48
8111aa54:	1885c83a 	sub	r2,r3,r2
8111aa58:	2085883a 	add	r2,r4,r2
8111aa5c:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111aa60:	e0bffe03 	ldbu	r2,-8(fp)
}
8111aa64:	e037883a 	mov	sp,fp
8111aa68:	df000017 	ldw	fp,0(sp)
8111aa6c:	dec00104 	addi	sp,sp,4
8111aa70:	f800283a 	ret

8111aa74 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111aa74:	defffd04 	addi	sp,sp,-12
8111aa78:	de00012e 	bgeu	sp,et,8111aa80 <Verif_Error+0xc>
8111aa7c:	003b68fa 	trap	3
8111aa80:	dfc00215 	stw	ra,8(sp)
8111aa84:	df000115 	stw	fp,4(sp)
8111aa88:	df000104 	addi	fp,sp,4
8111aa8c:	2005883a 	mov	r2,r4
8111aa90:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111aa94:	e0bfff03 	ldbu	r2,-4(fp)
8111aa98:	1000091e 	bne	r2,zero,8111aac0 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111aa9c:	d0a05d17 	ldw	r2,-32396(gp)
8111aaa0:	100f883a 	mov	r7,r2
8111aaa4:	018001c4 	movi	r6,7
8111aaa8:	01400044 	movi	r5,1
8111aaac:	01204574 	movhi	r4,33045
8111aab0:	212d1904 	addi	r4,r4,-19356
8111aab4:	111c7b80 	call	8111c7b8 <fwrite>
#endif
		return 0;
8111aab8:	0005883a 	mov	r2,zero
8111aabc:	00000106 	br	8111aac4 <Verif_Error+0x50>
	} else
		return 1;
8111aac0:	00800044 	movi	r2,1
}
8111aac4:	e037883a 	mov	sp,fp
8111aac8:	dfc00117 	ldw	ra,4(sp)
8111aacc:	df000017 	ldw	fp,0(sp)
8111aad0:	dec00204 	addi	sp,sp,8
8111aad4:	f800283a 	ret

8111aad8 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111aad8:	defffe04 	addi	sp,sp,-8
8111aadc:	de00012e 	bgeu	sp,et,8111aae4 <toInt+0xc>
8111aae0:	003b68fa 	trap	3
8111aae4:	df000115 	stw	fp,4(sp)
8111aae8:	df000104 	addi	fp,sp,4
8111aaec:	2005883a 	mov	r2,r4
8111aaf0:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111aaf4:	e0bfff03 	ldbu	r2,-4(fp)
8111aaf8:	10bff404 	addi	r2,r2,-48
}
8111aafc:	e037883a 	mov	sp,fp
8111ab00:	df000017 	ldw	fp,0(sp)
8111ab04:	dec00104 	addi	sp,sp,4
8111ab08:	f800283a 	ret

8111ab0c <__divsf3>:
8111ab0c:	defff504 	addi	sp,sp,-44
8111ab10:	200cd5fa 	srli	r6,r4,23
8111ab14:	de00012e 	bgeu	sp,et,8111ab1c <__divsf3+0x10>
8111ab18:	003b68fa 	trap	3
8111ab1c:	dcc00415 	stw	r19,16(sp)
8111ab20:	2026d7fa 	srli	r19,r4,31
8111ab24:	00c02034 	movhi	r3,128
8111ab28:	dd800715 	stw	r22,28(sp)
8111ab2c:	dd000515 	stw	r20,20(sp)
8111ab30:	dc800315 	stw	r18,12(sp)
8111ab34:	18ffffc4 	addi	r3,r3,-1
8111ab38:	dfc00a15 	stw	ra,40(sp)
8111ab3c:	df000915 	stw	fp,36(sp)
8111ab40:	ddc00815 	stw	r23,32(sp)
8111ab44:	dd400615 	stw	r21,24(sp)
8111ab48:	dc400215 	stw	r17,8(sp)
8111ab4c:	dc000115 	stw	r16,4(sp)
8111ab50:	35003fcc 	andi	r20,r6,255
8111ab54:	1924703a 	and	r18,r3,r4
8111ab58:	9d803fcc 	andi	r22,r19,255
8111ab5c:	a0005226 	beq	r20,zero,8111aca8 <__divsf3+0x19c>
8111ab60:	00803fc4 	movi	r2,255
8111ab64:	a0802e26 	beq	r20,r2,8111ac20 <__divsf3+0x114>
8111ab68:	91002034 	orhi	r4,r18,128
8111ab6c:	202490fa 	slli	r18,r4,3
8111ab70:	a53fe044 	addi	r20,r20,-127
8111ab74:	0021883a 	mov	r16,zero
8111ab78:	002f883a 	mov	r23,zero
8111ab7c:	280cd5fa 	srli	r6,r5,23
8111ab80:	282ad7fa 	srli	r21,r5,31
8111ab84:	00c02034 	movhi	r3,128
8111ab88:	18ffffc4 	addi	r3,r3,-1
8111ab8c:	31803fcc 	andi	r6,r6,255
8111ab90:	1962703a 	and	r17,r3,r5
8111ab94:	af003fcc 	andi	fp,r21,255
8111ab98:	30004a26 	beq	r6,zero,8111acc4 <__divsf3+0x1b8>
8111ab9c:	00803fc4 	movi	r2,255
8111aba0:	30804526 	beq	r6,r2,8111acb8 <__divsf3+0x1ac>
8111aba4:	89402034 	orhi	r5,r17,128
8111aba8:	282290fa 	slli	r17,r5,3
8111abac:	31bfe044 	addi	r6,r6,-127
8111abb0:	000b883a 	mov	r5,zero
8111abb4:	2c20b03a 	or	r16,r5,r16
8111abb8:	802090ba 	slli	r16,r16,2
8111abbc:	00a044b4 	movhi	r2,33042
8111abc0:	10aaf804 	addi	r2,r2,-21536
8111abc4:	80a1883a 	add	r16,r16,r2
8111abc8:	81000017 	ldw	r4,0(r16)
8111abcc:	9d46f03a 	xor	r3,r19,r21
8111abd0:	180f883a 	mov	r7,r3
8111abd4:	18803fcc 	andi	r2,r3,255
8111abd8:	a18dc83a 	sub	r6,r20,r6
8111abdc:	2000683a 	jmp	r4
8111abe0:	8111adc4 	addi	r4,r16,18103
8111abe4:	8111ac48 	cmpgei	r4,r16,18097
8111abe8:	8111adb8 	rdprs	r4,r16,18102
8111abec:	8111ac34 	orhi	r4,r16,18096
8111abf0:	8111adb8 	rdprs	r4,r16,18102
8111abf4:	8111ad90 	cmplti	r4,r16,18102
8111abf8:	8111adb8 	rdprs	r4,r16,18102
8111abfc:	8111ac34 	orhi	r4,r16,18096
8111ac00:	8111ac48 	cmpgei	r4,r16,18097
8111ac04:	8111ac48 	cmpgei	r4,r16,18097
8111ac08:	8111ad90 	cmplti	r4,r16,18102
8111ac0c:	8111ac34 	orhi	r4,r16,18096
8111ac10:	8111aea4 	muli	r4,r16,18106
8111ac14:	8111aea4 	muli	r4,r16,18106
8111ac18:	8111aea4 	muli	r4,r16,18106
8111ac1c:	8111ae58 	cmpnei	r4,r16,18105
8111ac20:	9000581e 	bne	r18,zero,8111ad84 <__divsf3+0x278>
8111ac24:	04000204 	movi	r16,8
8111ac28:	05c00084 	movi	r23,2
8111ac2c:	003fd306 	br	8111ab7c <__reset+0xfb0fab7c>
8111ac30:	0023883a 	mov	r17,zero
8111ac34:	e02d883a 	mov	r22,fp
8111ac38:	282f883a 	mov	r23,r5
8111ac3c:	00800084 	movi	r2,2
8111ac40:	b8808f1e 	bne	r23,r2,8111ae80 <__divsf3+0x374>
8111ac44:	b005883a 	mov	r2,r22
8111ac48:	11c0004c 	andi	r7,r2,1
8111ac4c:	013fffc4 	movi	r4,-1
8111ac50:	000d883a 	mov	r6,zero
8111ac54:	21003fcc 	andi	r4,r4,255
8111ac58:	200895fa 	slli	r4,r4,23
8111ac5c:	38803fcc 	andi	r2,r7,255
8111ac60:	00c02034 	movhi	r3,128
8111ac64:	100497fa 	slli	r2,r2,31
8111ac68:	18ffffc4 	addi	r3,r3,-1
8111ac6c:	30c6703a 	and	r3,r6,r3
8111ac70:	1906b03a 	or	r3,r3,r4
8111ac74:	1884b03a 	or	r2,r3,r2
8111ac78:	dfc00a17 	ldw	ra,40(sp)
8111ac7c:	df000917 	ldw	fp,36(sp)
8111ac80:	ddc00817 	ldw	r23,32(sp)
8111ac84:	dd800717 	ldw	r22,28(sp)
8111ac88:	dd400617 	ldw	r21,24(sp)
8111ac8c:	dd000517 	ldw	r20,20(sp)
8111ac90:	dcc00417 	ldw	r19,16(sp)
8111ac94:	dc800317 	ldw	r18,12(sp)
8111ac98:	dc400217 	ldw	r17,8(sp)
8111ac9c:	dc000117 	ldw	r16,4(sp)
8111aca0:	dec00b04 	addi	sp,sp,44
8111aca4:	f800283a 	ret
8111aca8:	90002b1e 	bne	r18,zero,8111ad58 <__divsf3+0x24c>
8111acac:	04000104 	movi	r16,4
8111acb0:	05c00044 	movi	r23,1
8111acb4:	003fb106 	br	8111ab7c <__reset+0xfb0fab7c>
8111acb8:	8800251e 	bne	r17,zero,8111ad50 <__divsf3+0x244>
8111acbc:	01400084 	movi	r5,2
8111acc0:	00000206 	br	8111accc <__divsf3+0x1c0>
8111acc4:	88001a1e 	bne	r17,zero,8111ad30 <__divsf3+0x224>
8111acc8:	01400044 	movi	r5,1
8111accc:	8160b03a 	or	r16,r16,r5
8111acd0:	802090ba 	slli	r16,r16,2
8111acd4:	00e044b4 	movhi	r3,33042
8111acd8:	18eb3c04 	addi	r3,r3,-21264
8111acdc:	80e1883a 	add	r16,r16,r3
8111ace0:	80c00017 	ldw	r3,0(r16)
8111ace4:	9d44f03a 	xor	r2,r19,r21
8111ace8:	a18dc83a 	sub	r6,r20,r6
8111acec:	1800683a 	jmp	r3
8111acf0:	8111ac48 	cmpgei	r4,r16,18097
8111acf4:	8111ac48 	cmpgei	r4,r16,18097
8111acf8:	8111ae94 	ori	r4,r16,18106
8111acfc:	8111ac30 	cmpltui	r4,r16,18096
8111ad00:	8111ae94 	ori	r4,r16,18106
8111ad04:	8111ad90 	cmplti	r4,r16,18102
8111ad08:	8111ae94 	ori	r4,r16,18106
8111ad0c:	8111ac30 	cmpltui	r4,r16,18096
8111ad10:	8111ac48 	cmpgei	r4,r16,18097
8111ad14:	8111ac48 	cmpgei	r4,r16,18097
8111ad18:	8111ad90 	cmplti	r4,r16,18102
8111ad1c:	8111ac30 	cmpltui	r4,r16,18096
8111ad20:	8111aea4 	muli	r4,r16,18106
8111ad24:	8111aea4 	muli	r4,r16,18106
8111ad28:	8111aea4 	muli	r4,r16,18106
8111ad2c:	8111aebc 	xorhi	r4,r16,18106
8111ad30:	8809883a 	mov	r4,r17
8111ad34:	111bf5c0 	call	8111bf5c <__clzsi2>
8111ad38:	10fffec4 	addi	r3,r2,-5
8111ad3c:	10801d84 	addi	r2,r2,118
8111ad40:	88e2983a 	sll	r17,r17,r3
8111ad44:	008dc83a 	sub	r6,zero,r2
8111ad48:	000b883a 	mov	r5,zero
8111ad4c:	003f9906 	br	8111abb4 <__reset+0xfb0fabb4>
8111ad50:	014000c4 	movi	r5,3
8111ad54:	003f9706 	br	8111abb4 <__reset+0xfb0fabb4>
8111ad58:	9009883a 	mov	r4,r18
8111ad5c:	d9400015 	stw	r5,0(sp)
8111ad60:	111bf5c0 	call	8111bf5c <__clzsi2>
8111ad64:	10fffec4 	addi	r3,r2,-5
8111ad68:	11801d84 	addi	r6,r2,118
8111ad6c:	90e4983a 	sll	r18,r18,r3
8111ad70:	01a9c83a 	sub	r20,zero,r6
8111ad74:	0021883a 	mov	r16,zero
8111ad78:	002f883a 	mov	r23,zero
8111ad7c:	d9400017 	ldw	r5,0(sp)
8111ad80:	003f7e06 	br	8111ab7c <__reset+0xfb0fab7c>
8111ad84:	04000304 	movi	r16,12
8111ad88:	05c000c4 	movi	r23,3
8111ad8c:	003f7b06 	br	8111ab7c <__reset+0xfb0fab7c>
8111ad90:	01802034 	movhi	r6,128
8111ad94:	000f883a 	mov	r7,zero
8111ad98:	31bfffc4 	addi	r6,r6,-1
8111ad9c:	013fffc4 	movi	r4,-1
8111ada0:	003fac06 	br	8111ac54 <__reset+0xfb0fac54>
8111ada4:	01400044 	movi	r5,1
8111ada8:	2909c83a 	sub	r4,r5,r4
8111adac:	00c006c4 	movi	r3,27
8111adb0:	19004b0e 	bge	r3,r4,8111aee0 <__divsf3+0x3d4>
8111adb4:	114e703a 	and	r7,r2,r5
8111adb8:	0009883a 	mov	r4,zero
8111adbc:	000d883a 	mov	r6,zero
8111adc0:	003fa406 	br	8111ac54 <__reset+0xfb0fac54>
8111adc4:	9006917a 	slli	r3,r18,5
8111adc8:	8822917a 	slli	r17,r17,5
8111adcc:	1c40372e 	bgeu	r3,r17,8111aeac <__divsf3+0x3a0>
8111add0:	31bfffc4 	addi	r6,r6,-1
8111add4:	010006c4 	movi	r4,27
8111add8:	000b883a 	mov	r5,zero
8111addc:	180f883a 	mov	r7,r3
8111ade0:	294b883a 	add	r5,r5,r5
8111ade4:	18c7883a 	add	r3,r3,r3
8111ade8:	38000116 	blt	r7,zero,8111adf0 <__divsf3+0x2e4>
8111adec:	1c400236 	bltu	r3,r17,8111adf8 <__divsf3+0x2ec>
8111adf0:	1c47c83a 	sub	r3,r3,r17
8111adf4:	29400054 	ori	r5,r5,1
8111adf8:	213fffc4 	addi	r4,r4,-1
8111adfc:	203ff71e 	bne	r4,zero,8111addc <__reset+0xfb0faddc>
8111ae00:	1806c03a 	cmpne	r3,r3,zero
8111ae04:	1962b03a 	or	r17,r3,r5
8111ae08:	31001fc4 	addi	r4,r6,127
8111ae0c:	013fe50e 	bge	zero,r4,8111ada4 <__reset+0xfb0fada4>
8111ae10:	88c001cc 	andi	r3,r17,7
8111ae14:	18000426 	beq	r3,zero,8111ae28 <__divsf3+0x31c>
8111ae18:	88c003cc 	andi	r3,r17,15
8111ae1c:	01400104 	movi	r5,4
8111ae20:	19400126 	beq	r3,r5,8111ae28 <__divsf3+0x31c>
8111ae24:	8963883a 	add	r17,r17,r5
8111ae28:	88c2002c 	andhi	r3,r17,2048
8111ae2c:	18000426 	beq	r3,zero,8111ae40 <__divsf3+0x334>
8111ae30:	00fe0034 	movhi	r3,63488
8111ae34:	18ffffc4 	addi	r3,r3,-1
8111ae38:	31002004 	addi	r4,r6,128
8111ae3c:	88e2703a 	and	r17,r17,r3
8111ae40:	00c03f84 	movi	r3,254
8111ae44:	193f8016 	blt	r3,r4,8111ac48 <__reset+0xfb0fac48>
8111ae48:	880c91ba 	slli	r6,r17,6
8111ae4c:	11c0004c 	andi	r7,r2,1
8111ae50:	300cd27a 	srli	r6,r6,9
8111ae54:	003f7f06 	br	8111ac54 <__reset+0xfb0fac54>
8111ae58:	9080102c 	andhi	r2,r18,64
8111ae5c:	10000226 	beq	r2,zero,8111ae68 <__divsf3+0x35c>
8111ae60:	8880102c 	andhi	r2,r17,64
8111ae64:	10001826 	beq	r2,zero,8111aec8 <__divsf3+0x3bc>
8111ae68:	00802034 	movhi	r2,128
8111ae6c:	91801034 	orhi	r6,r18,64
8111ae70:	10bfffc4 	addi	r2,r2,-1
8111ae74:	980f883a 	mov	r7,r19
8111ae78:	308c703a 	and	r6,r6,r2
8111ae7c:	003fc706 	br	8111ad9c <__reset+0xfb0fad9c>
8111ae80:	008000c4 	movi	r2,3
8111ae84:	b8802d26 	beq	r23,r2,8111af3c <__divsf3+0x430>
8111ae88:	00c00044 	movi	r3,1
8111ae8c:	b005883a 	mov	r2,r22
8111ae90:	b8ffdd1e 	bne	r23,r3,8111ae08 <__reset+0xfb0fae08>
8111ae94:	11c0004c 	andi	r7,r2,1
8111ae98:	0009883a 	mov	r4,zero
8111ae9c:	000d883a 	mov	r6,zero
8111aea0:	003f6c06 	br	8111ac54 <__reset+0xfb0fac54>
8111aea4:	9023883a 	mov	r17,r18
8111aea8:	003f6406 	br	8111ac3c <__reset+0xfb0fac3c>
8111aeac:	1c47c83a 	sub	r3,r3,r17
8111aeb0:	01000684 	movi	r4,26
8111aeb4:	01400044 	movi	r5,1
8111aeb8:	003fc806 	br	8111addc <__reset+0xfb0faddc>
8111aebc:	9080102c 	andhi	r2,r18,64
8111aec0:	103fe926 	beq	r2,zero,8111ae68 <__reset+0xfb0fae68>
8111aec4:	0023883a 	mov	r17,zero
8111aec8:	00802034 	movhi	r2,128
8111aecc:	89801034 	orhi	r6,r17,64
8111aed0:	10bfffc4 	addi	r2,r2,-1
8111aed4:	a80f883a 	mov	r7,r21
8111aed8:	308c703a 	and	r6,r6,r2
8111aedc:	003faf06 	br	8111ad9c <__reset+0xfb0fad9c>
8111aee0:	01c00804 	movi	r7,32
8111aee4:	390fc83a 	sub	r7,r7,r4
8111aee8:	89ce983a 	sll	r7,r17,r7
8111aeec:	890ad83a 	srl	r5,r17,r4
8111aef0:	380ec03a 	cmpne	r7,r7,zero
8111aef4:	29cab03a 	or	r5,r5,r7
8111aef8:	28c001cc 	andi	r3,r5,7
8111aefc:	18000426 	beq	r3,zero,8111af10 <__divsf3+0x404>
8111af00:	28c003cc 	andi	r3,r5,15
8111af04:	01000104 	movi	r4,4
8111af08:	19000126 	beq	r3,r4,8111af10 <__divsf3+0x404>
8111af0c:	290b883a 	add	r5,r5,r4
8111af10:	28c1002c 	andhi	r3,r5,1024
8111af14:	18000426 	beq	r3,zero,8111af28 <__divsf3+0x41c>
8111af18:	11c0004c 	andi	r7,r2,1
8111af1c:	01000044 	movi	r4,1
8111af20:	000d883a 	mov	r6,zero
8111af24:	003f4b06 	br	8111ac54 <__reset+0xfb0fac54>
8111af28:	280a91ba 	slli	r5,r5,6
8111af2c:	11c0004c 	andi	r7,r2,1
8111af30:	0009883a 	mov	r4,zero
8111af34:	280cd27a 	srli	r6,r5,9
8111af38:	003f4606 	br	8111ac54 <__reset+0xfb0fac54>
8111af3c:	00802034 	movhi	r2,128
8111af40:	89801034 	orhi	r6,r17,64
8111af44:	10bfffc4 	addi	r2,r2,-1
8111af48:	b00f883a 	mov	r7,r22
8111af4c:	308c703a 	and	r6,r6,r2
8111af50:	003f9206 	br	8111ad9c <__reset+0xfb0fad9c>

8111af54 <__mulsf3>:
8111af54:	defff504 	addi	sp,sp,-44
8111af58:	de00012e 	bgeu	sp,et,8111af60 <__mulsf3+0xc>
8111af5c:	003b68fa 	trap	3
8111af60:	dc000115 	stw	r16,4(sp)
8111af64:	2020d5fa 	srli	r16,r4,23
8111af68:	dd400615 	stw	r21,24(sp)
8111af6c:	202ad7fa 	srli	r21,r4,31
8111af70:	dc800315 	stw	r18,12(sp)
8111af74:	04802034 	movhi	r18,128
8111af78:	df000915 	stw	fp,36(sp)
8111af7c:	dd000515 	stw	r20,20(sp)
8111af80:	94bfffc4 	addi	r18,r18,-1
8111af84:	dfc00a15 	stw	ra,40(sp)
8111af88:	ddc00815 	stw	r23,32(sp)
8111af8c:	dd800715 	stw	r22,28(sp)
8111af90:	dcc00415 	stw	r19,16(sp)
8111af94:	dc400215 	stw	r17,8(sp)
8111af98:	84003fcc 	andi	r16,r16,255
8111af9c:	9124703a 	and	r18,r18,r4
8111afa0:	a829883a 	mov	r20,r21
8111afa4:	af003fcc 	andi	fp,r21,255
8111afa8:	80005426 	beq	r16,zero,8111b0fc <__mulsf3+0x1a8>
8111afac:	00803fc4 	movi	r2,255
8111afb0:	80802f26 	beq	r16,r2,8111b070 <__mulsf3+0x11c>
8111afb4:	91002034 	orhi	r4,r18,128
8111afb8:	202490fa 	slli	r18,r4,3
8111afbc:	843fe044 	addi	r16,r16,-127
8111afc0:	0023883a 	mov	r17,zero
8111afc4:	002f883a 	mov	r23,zero
8111afc8:	2804d5fa 	srli	r2,r5,23
8111afcc:	282cd7fa 	srli	r22,r5,31
8111afd0:	01002034 	movhi	r4,128
8111afd4:	213fffc4 	addi	r4,r4,-1
8111afd8:	10803fcc 	andi	r2,r2,255
8111afdc:	2166703a 	and	r19,r4,r5
8111afe0:	b1803fcc 	andi	r6,r22,255
8111afe4:	10004c26 	beq	r2,zero,8111b118 <__mulsf3+0x1c4>
8111afe8:	00c03fc4 	movi	r3,255
8111afec:	10c04726 	beq	r2,r3,8111b10c <__mulsf3+0x1b8>
8111aff0:	99002034 	orhi	r4,r19,128
8111aff4:	202690fa 	slli	r19,r4,3
8111aff8:	10bfe044 	addi	r2,r2,-127
8111affc:	0007883a 	mov	r3,zero
8111b000:	80a1883a 	add	r16,r16,r2
8111b004:	010003c4 	movi	r4,15
8111b008:	1c44b03a 	or	r2,r3,r17
8111b00c:	b56af03a 	xor	r21,r22,r21
8111b010:	81c00044 	addi	r7,r16,1
8111b014:	20806b36 	bltu	r4,r2,8111b1c4 <__mulsf3+0x270>
8111b018:	100490ba 	slli	r2,r2,2
8111b01c:	012044b4 	movhi	r4,33042
8111b020:	212c0c04 	addi	r4,r4,-20432
8111b024:	1105883a 	add	r2,r2,r4
8111b028:	10800017 	ldw	r2,0(r2)
8111b02c:	1000683a 	jmp	r2
8111b030:	8111b1c4 	addi	r4,r16,18119
8111b034:	8111b084 	addi	r4,r16,18114
8111b038:	8111b084 	addi	r4,r16,18114
8111b03c:	8111b080 	call	88111b08 <__reset+0x20f1b08>
8111b040:	8111b1a8 	cmpgeui	r4,r16,18118
8111b044:	8111b1a8 	cmpgeui	r4,r16,18118
8111b048:	8111b194 	ori	r4,r16,18118
8111b04c:	8111b080 	call	88111b08 <__reset+0x20f1b08>
8111b050:	8111b1a8 	cmpgeui	r4,r16,18118
8111b054:	8111b194 	ori	r4,r16,18118
8111b058:	8111b1a8 	cmpgeui	r4,r16,18118
8111b05c:	8111b080 	call	88111b08 <__reset+0x20f1b08>
8111b060:	8111b1b4 	orhi	r4,r16,18118
8111b064:	8111b1b4 	orhi	r4,r16,18118
8111b068:	8111b1b4 	orhi	r4,r16,18118
8111b06c:	8111b290 	cmplti	r4,r16,18122
8111b070:	90003b1e 	bne	r18,zero,8111b160 <__mulsf3+0x20c>
8111b074:	04400204 	movi	r17,8
8111b078:	05c00084 	movi	r23,2
8111b07c:	003fd206 	br	8111afc8 <__reset+0xfb0fafc8>
8111b080:	302b883a 	mov	r21,r6
8111b084:	00800084 	movi	r2,2
8111b088:	18802626 	beq	r3,r2,8111b124 <__mulsf3+0x1d0>
8111b08c:	008000c4 	movi	r2,3
8111b090:	1880ab26 	beq	r3,r2,8111b340 <__mulsf3+0x3ec>
8111b094:	00800044 	movi	r2,1
8111b098:	1880a21e 	bne	r3,r2,8111b324 <__mulsf3+0x3d0>
8111b09c:	a829883a 	mov	r20,r21
8111b0a0:	0007883a 	mov	r3,zero
8111b0a4:	0009883a 	mov	r4,zero
8111b0a8:	18803fcc 	andi	r2,r3,255
8111b0ac:	100695fa 	slli	r3,r2,23
8111b0b0:	a0803fcc 	andi	r2,r20,255
8111b0b4:	100a97fa 	slli	r5,r2,31
8111b0b8:	00802034 	movhi	r2,128
8111b0bc:	10bfffc4 	addi	r2,r2,-1
8111b0c0:	2084703a 	and	r2,r4,r2
8111b0c4:	10c4b03a 	or	r2,r2,r3
8111b0c8:	1144b03a 	or	r2,r2,r5
8111b0cc:	dfc00a17 	ldw	ra,40(sp)
8111b0d0:	df000917 	ldw	fp,36(sp)
8111b0d4:	ddc00817 	ldw	r23,32(sp)
8111b0d8:	dd800717 	ldw	r22,28(sp)
8111b0dc:	dd400617 	ldw	r21,24(sp)
8111b0e0:	dd000517 	ldw	r20,20(sp)
8111b0e4:	dcc00417 	ldw	r19,16(sp)
8111b0e8:	dc800317 	ldw	r18,12(sp)
8111b0ec:	dc400217 	ldw	r17,8(sp)
8111b0f0:	dc000117 	ldw	r16,4(sp)
8111b0f4:	dec00b04 	addi	sp,sp,44
8111b0f8:	f800283a 	ret
8111b0fc:	90000d1e 	bne	r18,zero,8111b134 <__mulsf3+0x1e0>
8111b100:	04400104 	movi	r17,4
8111b104:	05c00044 	movi	r23,1
8111b108:	003faf06 	br	8111afc8 <__reset+0xfb0fafc8>
8111b10c:	9806c03a 	cmpne	r3,r19,zero
8111b110:	18c00084 	addi	r3,r3,2
8111b114:	003fba06 	br	8111b000 <__reset+0xfb0fb000>
8111b118:	9800141e 	bne	r19,zero,8111b16c <__mulsf3+0x218>
8111b11c:	00c00044 	movi	r3,1
8111b120:	003fb706 	br	8111b000 <__reset+0xfb0fb000>
8111b124:	a829883a 	mov	r20,r21
8111b128:	00ffffc4 	movi	r3,-1
8111b12c:	0009883a 	mov	r4,zero
8111b130:	003fdd06 	br	8111b0a8 <__reset+0xfb0fb0a8>
8111b134:	9009883a 	mov	r4,r18
8111b138:	d9400015 	stw	r5,0(sp)
8111b13c:	111bf5c0 	call	8111bf5c <__clzsi2>
8111b140:	10fffec4 	addi	r3,r2,-5
8111b144:	10801d84 	addi	r2,r2,118
8111b148:	90e4983a 	sll	r18,r18,r3
8111b14c:	00a1c83a 	sub	r16,zero,r2
8111b150:	0023883a 	mov	r17,zero
8111b154:	002f883a 	mov	r23,zero
8111b158:	d9400017 	ldw	r5,0(sp)
8111b15c:	003f9a06 	br	8111afc8 <__reset+0xfb0fafc8>
8111b160:	04400304 	movi	r17,12
8111b164:	05c000c4 	movi	r23,3
8111b168:	003f9706 	br	8111afc8 <__reset+0xfb0fafc8>
8111b16c:	9809883a 	mov	r4,r19
8111b170:	d9800015 	stw	r6,0(sp)
8111b174:	111bf5c0 	call	8111bf5c <__clzsi2>
8111b178:	10fffec4 	addi	r3,r2,-5
8111b17c:	10801d84 	addi	r2,r2,118
8111b180:	98e6983a 	sll	r19,r19,r3
8111b184:	0085c83a 	sub	r2,zero,r2
8111b188:	0007883a 	mov	r3,zero
8111b18c:	d9800017 	ldw	r6,0(sp)
8111b190:	003f9b06 	br	8111b000 <__reset+0xfb0fb000>
8111b194:	01002034 	movhi	r4,128
8111b198:	0029883a 	mov	r20,zero
8111b19c:	213fffc4 	addi	r4,r4,-1
8111b1a0:	00ffffc4 	movi	r3,-1
8111b1a4:	003fc006 	br	8111b0a8 <__reset+0xfb0fb0a8>
8111b1a8:	9027883a 	mov	r19,r18
8111b1ac:	b807883a 	mov	r3,r23
8111b1b0:	003fb406 	br	8111b084 <__reset+0xfb0fb084>
8111b1b4:	9027883a 	mov	r19,r18
8111b1b8:	e02b883a 	mov	r21,fp
8111b1bc:	b807883a 	mov	r3,r23
8111b1c0:	003fb006 	br	8111b084 <__reset+0xfb0fb084>
8111b1c4:	9004d43a 	srli	r2,r18,16
8111b1c8:	9810d43a 	srli	r8,r19,16
8111b1cc:	94bfffcc 	andi	r18,r18,65535
8111b1d0:	993fffcc 	andi	r4,r19,65535
8111b1d4:	910d383a 	mul	r6,r18,r4
8111b1d8:	20a7383a 	mul	r19,r4,r2
8111b1dc:	9225383a 	mul	r18,r18,r8
8111b1e0:	3006d43a 	srli	r3,r6,16
8111b1e4:	1211383a 	mul	r8,r2,r8
8111b1e8:	94e5883a 	add	r18,r18,r19
8111b1ec:	1c87883a 	add	r3,r3,r18
8111b1f0:	1cc0022e 	bgeu	r3,r19,8111b1fc <__mulsf3+0x2a8>
8111b1f4:	00800074 	movhi	r2,1
8111b1f8:	4091883a 	add	r8,r8,r2
8111b1fc:	1804943a 	slli	r2,r3,16
8111b200:	31bfffcc 	andi	r6,r6,65535
8111b204:	1806d43a 	srli	r3,r3,16
8111b208:	1185883a 	add	r2,r2,r6
8111b20c:	102691ba 	slli	r19,r2,6
8111b210:	1a07883a 	add	r3,r3,r8
8111b214:	1004d6ba 	srli	r2,r2,26
8111b218:	180891ba 	slli	r4,r3,6
8111b21c:	9826c03a 	cmpne	r19,r19,zero
8111b220:	9884b03a 	or	r2,r19,r2
8111b224:	1126b03a 	or	r19,r2,r4
8111b228:	9882002c 	andhi	r2,r19,2048
8111b22c:	10000426 	beq	r2,zero,8111b240 <__mulsf3+0x2ec>
8111b230:	9804d07a 	srli	r2,r19,1
8111b234:	9900004c 	andi	r4,r19,1
8111b238:	3821883a 	mov	r16,r7
8111b23c:	1126b03a 	or	r19,r2,r4
8111b240:	80c01fc4 	addi	r3,r16,127
8111b244:	00c0210e 	bge	zero,r3,8111b2cc <__mulsf3+0x378>
8111b248:	988001cc 	andi	r2,r19,7
8111b24c:	10000426 	beq	r2,zero,8111b260 <__mulsf3+0x30c>
8111b250:	988003cc 	andi	r2,r19,15
8111b254:	01000104 	movi	r4,4
8111b258:	11000126 	beq	r2,r4,8111b260 <__mulsf3+0x30c>
8111b25c:	9927883a 	add	r19,r19,r4
8111b260:	9882002c 	andhi	r2,r19,2048
8111b264:	10000426 	beq	r2,zero,8111b278 <__mulsf3+0x324>
8111b268:	00be0034 	movhi	r2,63488
8111b26c:	10bfffc4 	addi	r2,r2,-1
8111b270:	80c02004 	addi	r3,r16,128
8111b274:	98a6703a 	and	r19,r19,r2
8111b278:	00803f84 	movi	r2,254
8111b27c:	10ffa916 	blt	r2,r3,8111b124 <__reset+0xfb0fb124>
8111b280:	980891ba 	slli	r4,r19,6
8111b284:	a829883a 	mov	r20,r21
8111b288:	2008d27a 	srli	r4,r4,9
8111b28c:	003f8606 	br	8111b0a8 <__reset+0xfb0fb0a8>
8111b290:	9080102c 	andhi	r2,r18,64
8111b294:	10000826 	beq	r2,zero,8111b2b8 <__mulsf3+0x364>
8111b298:	9880102c 	andhi	r2,r19,64
8111b29c:	1000061e 	bne	r2,zero,8111b2b8 <__mulsf3+0x364>
8111b2a0:	00802034 	movhi	r2,128
8111b2a4:	99001034 	orhi	r4,r19,64
8111b2a8:	10bfffc4 	addi	r2,r2,-1
8111b2ac:	b029883a 	mov	r20,r22
8111b2b0:	2088703a 	and	r4,r4,r2
8111b2b4:	003fba06 	br	8111b1a0 <__reset+0xfb0fb1a0>
8111b2b8:	00802034 	movhi	r2,128
8111b2bc:	91001034 	orhi	r4,r18,64
8111b2c0:	10bfffc4 	addi	r2,r2,-1
8111b2c4:	2088703a 	and	r4,r4,r2
8111b2c8:	003fb506 	br	8111b1a0 <__reset+0xfb0fb1a0>
8111b2cc:	00800044 	movi	r2,1
8111b2d0:	10c7c83a 	sub	r3,r2,r3
8111b2d4:	008006c4 	movi	r2,27
8111b2d8:	10ff7016 	blt	r2,r3,8111b09c <__reset+0xfb0fb09c>
8111b2dc:	00800804 	movi	r2,32
8111b2e0:	10c5c83a 	sub	r2,r2,r3
8111b2e4:	9884983a 	sll	r2,r19,r2
8111b2e8:	98c6d83a 	srl	r3,r19,r3
8111b2ec:	1004c03a 	cmpne	r2,r2,zero
8111b2f0:	1884b03a 	or	r2,r3,r2
8111b2f4:	10c001cc 	andi	r3,r2,7
8111b2f8:	18000426 	beq	r3,zero,8111b30c <__mulsf3+0x3b8>
8111b2fc:	10c003cc 	andi	r3,r2,15
8111b300:	01000104 	movi	r4,4
8111b304:	19000126 	beq	r3,r4,8111b30c <__mulsf3+0x3b8>
8111b308:	1105883a 	add	r2,r2,r4
8111b30c:	10c1002c 	andhi	r3,r2,1024
8111b310:	18000626 	beq	r3,zero,8111b32c <__mulsf3+0x3d8>
8111b314:	a829883a 	mov	r20,r21
8111b318:	00c00044 	movi	r3,1
8111b31c:	0009883a 	mov	r4,zero
8111b320:	003f6106 	br	8111b0a8 <__reset+0xfb0fb0a8>
8111b324:	3821883a 	mov	r16,r7
8111b328:	003fc506 	br	8111b240 <__reset+0xfb0fb240>
8111b32c:	100491ba 	slli	r2,r2,6
8111b330:	a829883a 	mov	r20,r21
8111b334:	0007883a 	mov	r3,zero
8111b338:	1008d27a 	srli	r4,r2,9
8111b33c:	003f5a06 	br	8111b0a8 <__reset+0xfb0fb0a8>
8111b340:	00802034 	movhi	r2,128
8111b344:	99001034 	orhi	r4,r19,64
8111b348:	10bfffc4 	addi	r2,r2,-1
8111b34c:	a829883a 	mov	r20,r21
8111b350:	2088703a 	and	r4,r4,r2
8111b354:	003f9206 	br	8111b1a0 <__reset+0xfb0fb1a0>

8111b358 <__floatsisf>:
8111b358:	defffd04 	addi	sp,sp,-12
8111b35c:	de00012e 	bgeu	sp,et,8111b364 <__floatsisf+0xc>
8111b360:	003b68fa 	trap	3
8111b364:	dfc00215 	stw	ra,8(sp)
8111b368:	dc400115 	stw	r17,4(sp)
8111b36c:	dc000015 	stw	r16,0(sp)
8111b370:	20003526 	beq	r4,zero,8111b448 <__floatsisf+0xf0>
8111b374:	2021883a 	mov	r16,r4
8111b378:	2022d7fa 	srli	r17,r4,31
8111b37c:	20003616 	blt	r4,zero,8111b458 <__floatsisf+0x100>
8111b380:	8009883a 	mov	r4,r16
8111b384:	111bf5c0 	call	8111bf5c <__clzsi2>
8111b388:	00c02784 	movi	r3,158
8111b38c:	1887c83a 	sub	r3,r3,r2
8111b390:	01002584 	movi	r4,150
8111b394:	20c01416 	blt	r4,r3,8111b3e8 <__floatsisf+0x90>
8111b398:	20c9c83a 	sub	r4,r4,r3
8111b39c:	8120983a 	sll	r16,r16,r4
8111b3a0:	00802034 	movhi	r2,128
8111b3a4:	10bfffc4 	addi	r2,r2,-1
8111b3a8:	8809883a 	mov	r4,r17
8111b3ac:	80a0703a 	and	r16,r16,r2
8111b3b0:	18803fcc 	andi	r2,r3,255
8111b3b4:	100695fa 	slli	r3,r2,23
8111b3b8:	20803fcc 	andi	r2,r4,255
8111b3bc:	100897fa 	slli	r4,r2,31
8111b3c0:	00802034 	movhi	r2,128
8111b3c4:	10bfffc4 	addi	r2,r2,-1
8111b3c8:	8084703a 	and	r2,r16,r2
8111b3cc:	10c4b03a 	or	r2,r2,r3
8111b3d0:	1104b03a 	or	r2,r2,r4
8111b3d4:	dfc00217 	ldw	ra,8(sp)
8111b3d8:	dc400117 	ldw	r17,4(sp)
8111b3dc:	dc000017 	ldw	r16,0(sp)
8111b3e0:	dec00304 	addi	sp,sp,12
8111b3e4:	f800283a 	ret
8111b3e8:	01002644 	movi	r4,153
8111b3ec:	20c01c16 	blt	r4,r3,8111b460 <__floatsisf+0x108>
8111b3f0:	20c9c83a 	sub	r4,r4,r3
8111b3f4:	8120983a 	sll	r16,r16,r4
8111b3f8:	013f0034 	movhi	r4,64512
8111b3fc:	213fffc4 	addi	r4,r4,-1
8111b400:	814001cc 	andi	r5,r16,7
8111b404:	8108703a 	and	r4,r16,r4
8111b408:	28000426 	beq	r5,zero,8111b41c <__floatsisf+0xc4>
8111b40c:	840003cc 	andi	r16,r16,15
8111b410:	01400104 	movi	r5,4
8111b414:	81400126 	beq	r16,r5,8111b41c <__floatsisf+0xc4>
8111b418:	2149883a 	add	r4,r4,r5
8111b41c:	2141002c 	andhi	r5,r4,1024
8111b420:	28000526 	beq	r5,zero,8111b438 <__floatsisf+0xe0>
8111b424:	00c027c4 	movi	r3,159
8111b428:	1887c83a 	sub	r3,r3,r2
8111b42c:	00bf0034 	movhi	r2,64512
8111b430:	10bfffc4 	addi	r2,r2,-1
8111b434:	2088703a 	and	r4,r4,r2
8111b438:	202091ba 	slli	r16,r4,6
8111b43c:	8809883a 	mov	r4,r17
8111b440:	8020d27a 	srli	r16,r16,9
8111b444:	003fda06 	br	8111b3b0 <__reset+0xfb0fb3b0>
8111b448:	0009883a 	mov	r4,zero
8111b44c:	0007883a 	mov	r3,zero
8111b450:	0021883a 	mov	r16,zero
8111b454:	003fd606 	br	8111b3b0 <__reset+0xfb0fb3b0>
8111b458:	0121c83a 	sub	r16,zero,r4
8111b45c:	003fc806 	br	8111b380 <__reset+0xfb0fb380>
8111b460:	01002e44 	movi	r4,185
8111b464:	20c9c83a 	sub	r4,r4,r3
8111b468:	01400144 	movi	r5,5
8111b46c:	8108983a 	sll	r4,r16,r4
8111b470:	288bc83a 	sub	r5,r5,r2
8111b474:	8160d83a 	srl	r16,r16,r5
8111b478:	2008c03a 	cmpne	r4,r4,zero
8111b47c:	8120b03a 	or	r16,r16,r4
8111b480:	003fdd06 	br	8111b3f8 <__reset+0xfb0fb3f8>

8111b484 <__floatunsisf>:
8111b484:	defffe04 	addi	sp,sp,-8
8111b488:	de00012e 	bgeu	sp,et,8111b490 <__floatunsisf+0xc>
8111b48c:	003b68fa 	trap	3
8111b490:	dfc00115 	stw	ra,4(sp)
8111b494:	dc000015 	stw	r16,0(sp)
8111b498:	20002c26 	beq	r4,zero,8111b54c <__floatunsisf+0xc8>
8111b49c:	2021883a 	mov	r16,r4
8111b4a0:	111bf5c0 	call	8111bf5c <__clzsi2>
8111b4a4:	00c02784 	movi	r3,158
8111b4a8:	1887c83a 	sub	r3,r3,r2
8111b4ac:	01002584 	movi	r4,150
8111b4b0:	20c00f16 	blt	r4,r3,8111b4f0 <__floatunsisf+0x6c>
8111b4b4:	20c9c83a 	sub	r4,r4,r3
8111b4b8:	8108983a 	sll	r4,r16,r4
8111b4bc:	00802034 	movhi	r2,128
8111b4c0:	10bfffc4 	addi	r2,r2,-1
8111b4c4:	2088703a 	and	r4,r4,r2
8111b4c8:	18803fcc 	andi	r2,r3,255
8111b4cc:	100695fa 	slli	r3,r2,23
8111b4d0:	00802034 	movhi	r2,128
8111b4d4:	10bfffc4 	addi	r2,r2,-1
8111b4d8:	2084703a 	and	r2,r4,r2
8111b4dc:	10c4b03a 	or	r2,r2,r3
8111b4e0:	dfc00117 	ldw	ra,4(sp)
8111b4e4:	dc000017 	ldw	r16,0(sp)
8111b4e8:	dec00204 	addi	sp,sp,8
8111b4ec:	f800283a 	ret
8111b4f0:	01002644 	movi	r4,153
8111b4f4:	20c01816 	blt	r4,r3,8111b558 <__floatunsisf+0xd4>
8111b4f8:	20c9c83a 	sub	r4,r4,r3
8111b4fc:	8108983a 	sll	r4,r16,r4
8111b500:	017f0034 	movhi	r5,64512
8111b504:	297fffc4 	addi	r5,r5,-1
8111b508:	218001cc 	andi	r6,r4,7
8111b50c:	214a703a 	and	r5,r4,r5
8111b510:	30000426 	beq	r6,zero,8111b524 <__floatunsisf+0xa0>
8111b514:	210003cc 	andi	r4,r4,15
8111b518:	01800104 	movi	r6,4
8111b51c:	21800126 	beq	r4,r6,8111b524 <__floatunsisf+0xa0>
8111b520:	298b883a 	add	r5,r5,r6
8111b524:	2901002c 	andhi	r4,r5,1024
8111b528:	20000526 	beq	r4,zero,8111b540 <__floatunsisf+0xbc>
8111b52c:	00c027c4 	movi	r3,159
8111b530:	1887c83a 	sub	r3,r3,r2
8111b534:	00bf0034 	movhi	r2,64512
8111b538:	10bfffc4 	addi	r2,r2,-1
8111b53c:	288a703a 	and	r5,r5,r2
8111b540:	280891ba 	slli	r4,r5,6
8111b544:	2008d27a 	srli	r4,r4,9
8111b548:	003fdf06 	br	8111b4c8 <__reset+0xfb0fb4c8>
8111b54c:	0007883a 	mov	r3,zero
8111b550:	0009883a 	mov	r4,zero
8111b554:	003fdc06 	br	8111b4c8 <__reset+0xfb0fb4c8>
8111b558:	01402e44 	movi	r5,185
8111b55c:	28cbc83a 	sub	r5,r5,r3
8111b560:	01000144 	movi	r4,5
8111b564:	2089c83a 	sub	r4,r4,r2
8111b568:	814a983a 	sll	r5,r16,r5
8111b56c:	8108d83a 	srl	r4,r16,r4
8111b570:	2820c03a 	cmpne	r16,r5,zero
8111b574:	2408b03a 	or	r4,r4,r16
8111b578:	003fe106 	br	8111b500 <__reset+0xfb0fb500>

8111b57c <__muldf3>:
8111b57c:	defff304 	addi	sp,sp,-52
8111b580:	2804d53a 	srli	r2,r5,20
8111b584:	de00012e 	bgeu	sp,et,8111b58c <__muldf3+0x10>
8111b588:	003b68fa 	trap	3
8111b58c:	dd800915 	stw	r22,36(sp)
8111b590:	282cd7fa 	srli	r22,r5,31
8111b594:	dc000315 	stw	r16,12(sp)
8111b598:	04000434 	movhi	r16,16
8111b59c:	dd400815 	stw	r21,32(sp)
8111b5a0:	dc800515 	stw	r18,20(sp)
8111b5a4:	843fffc4 	addi	r16,r16,-1
8111b5a8:	dfc00c15 	stw	ra,48(sp)
8111b5ac:	df000b15 	stw	fp,44(sp)
8111b5b0:	ddc00a15 	stw	r23,40(sp)
8111b5b4:	dd000715 	stw	r20,28(sp)
8111b5b8:	dcc00615 	stw	r19,24(sp)
8111b5bc:	dc400415 	stw	r17,16(sp)
8111b5c0:	1481ffcc 	andi	r18,r2,2047
8111b5c4:	2c20703a 	and	r16,r5,r16
8111b5c8:	b02b883a 	mov	r21,r22
8111b5cc:	b2403fcc 	andi	r9,r22,255
8111b5d0:	90006026 	beq	r18,zero,8111b754 <__muldf3+0x1d8>
8111b5d4:	0081ffc4 	movi	r2,2047
8111b5d8:	2029883a 	mov	r20,r4
8111b5dc:	90803626 	beq	r18,r2,8111b6b8 <__muldf3+0x13c>
8111b5e0:	80800434 	orhi	r2,r16,16
8111b5e4:	100490fa 	slli	r2,r2,3
8111b5e8:	2020d77a 	srli	r16,r4,29
8111b5ec:	202890fa 	slli	r20,r4,3
8111b5f0:	94bf0044 	addi	r18,r18,-1023
8111b5f4:	80a0b03a 	or	r16,r16,r2
8111b5f8:	0027883a 	mov	r19,zero
8111b5fc:	0039883a 	mov	fp,zero
8111b600:	3804d53a 	srli	r2,r7,20
8111b604:	382ed7fa 	srli	r23,r7,31
8111b608:	04400434 	movhi	r17,16
8111b60c:	8c7fffc4 	addi	r17,r17,-1
8111b610:	1081ffcc 	andi	r2,r2,2047
8111b614:	3011883a 	mov	r8,r6
8111b618:	3c62703a 	and	r17,r7,r17
8111b61c:	ba803fcc 	andi	r10,r23,255
8111b620:	10006d26 	beq	r2,zero,8111b7d8 <__muldf3+0x25c>
8111b624:	00c1ffc4 	movi	r3,2047
8111b628:	10c06526 	beq	r2,r3,8111b7c0 <__muldf3+0x244>
8111b62c:	88c00434 	orhi	r3,r17,16
8111b630:	180690fa 	slli	r3,r3,3
8111b634:	3022d77a 	srli	r17,r6,29
8111b638:	301090fa 	slli	r8,r6,3
8111b63c:	10bf0044 	addi	r2,r2,-1023
8111b640:	88e2b03a 	or	r17,r17,r3
8111b644:	000b883a 	mov	r5,zero
8111b648:	9085883a 	add	r2,r18,r2
8111b64c:	2cc8b03a 	or	r4,r5,r19
8111b650:	00c003c4 	movi	r3,15
8111b654:	bdacf03a 	xor	r22,r23,r22
8111b658:	12c00044 	addi	r11,r2,1
8111b65c:	19009936 	bltu	r3,r4,8111b8c4 <__muldf3+0x348>
8111b660:	200890ba 	slli	r4,r4,2
8111b664:	00e044b4 	movhi	r3,33042
8111b668:	18ed9e04 	addi	r3,r3,-18824
8111b66c:	20c9883a 	add	r4,r4,r3
8111b670:	20c00017 	ldw	r3,0(r4)
8111b674:	1800683a 	jmp	r3
8111b678:	8111b8c4 	addi	r4,r16,18147
8111b67c:	8111b6d8 	cmpnei	r4,r16,18139
8111b680:	8111b6d8 	cmpnei	r4,r16,18139
8111b684:	8111b6d4 	ori	r4,r16,18139
8111b688:	8111b8a0 	cmpeqi	r4,r16,18146
8111b68c:	8111b8a0 	cmpeqi	r4,r16,18146
8111b690:	8111b888 	cmpgei	r4,r16,18146
8111b694:	8111b6d4 	ori	r4,r16,18139
8111b698:	8111b8a0 	cmpeqi	r4,r16,18146
8111b69c:	8111b888 	cmpgei	r4,r16,18146
8111b6a0:	8111b8a0 	cmpeqi	r4,r16,18146
8111b6a4:	8111b6d4 	ori	r4,r16,18139
8111b6a8:	8111b8b0 	cmpltui	r4,r16,18146
8111b6ac:	8111b8b0 	cmpltui	r4,r16,18146
8111b6b0:	8111b8b0 	cmpltui	r4,r16,18146
8111b6b4:	8111bacc 	andi	r4,r16,18155
8111b6b8:	2404b03a 	or	r2,r4,r16
8111b6bc:	10006f1e 	bne	r2,zero,8111b87c <__muldf3+0x300>
8111b6c0:	04c00204 	movi	r19,8
8111b6c4:	0021883a 	mov	r16,zero
8111b6c8:	0029883a 	mov	r20,zero
8111b6cc:	07000084 	movi	fp,2
8111b6d0:	003fcb06 	br	8111b600 <__reset+0xfb0fb600>
8111b6d4:	502d883a 	mov	r22,r10
8111b6d8:	00800084 	movi	r2,2
8111b6dc:	28805726 	beq	r5,r2,8111b83c <__muldf3+0x2c0>
8111b6e0:	008000c4 	movi	r2,3
8111b6e4:	28816626 	beq	r5,r2,8111bc80 <__muldf3+0x704>
8111b6e8:	00800044 	movi	r2,1
8111b6ec:	2881411e 	bne	r5,r2,8111bbf4 <__muldf3+0x678>
8111b6f0:	b02b883a 	mov	r21,r22
8111b6f4:	0005883a 	mov	r2,zero
8111b6f8:	000b883a 	mov	r5,zero
8111b6fc:	0029883a 	mov	r20,zero
8111b700:	1004953a 	slli	r2,r2,20
8111b704:	a8c03fcc 	andi	r3,r21,255
8111b708:	04400434 	movhi	r17,16
8111b70c:	8c7fffc4 	addi	r17,r17,-1
8111b710:	180697fa 	slli	r3,r3,31
8111b714:	2c4a703a 	and	r5,r5,r17
8111b718:	288ab03a 	or	r5,r5,r2
8111b71c:	28c6b03a 	or	r3,r5,r3
8111b720:	a005883a 	mov	r2,r20
8111b724:	dfc00c17 	ldw	ra,48(sp)
8111b728:	df000b17 	ldw	fp,44(sp)
8111b72c:	ddc00a17 	ldw	r23,40(sp)
8111b730:	dd800917 	ldw	r22,36(sp)
8111b734:	dd400817 	ldw	r21,32(sp)
8111b738:	dd000717 	ldw	r20,28(sp)
8111b73c:	dcc00617 	ldw	r19,24(sp)
8111b740:	dc800517 	ldw	r18,20(sp)
8111b744:	dc400417 	ldw	r17,16(sp)
8111b748:	dc000317 	ldw	r16,12(sp)
8111b74c:	dec00d04 	addi	sp,sp,52
8111b750:	f800283a 	ret
8111b754:	2404b03a 	or	r2,r4,r16
8111b758:	2027883a 	mov	r19,r4
8111b75c:	10004226 	beq	r2,zero,8111b868 <__muldf3+0x2ec>
8111b760:	8000fc26 	beq	r16,zero,8111bb54 <__muldf3+0x5d8>
8111b764:	8009883a 	mov	r4,r16
8111b768:	d9800215 	stw	r6,8(sp)
8111b76c:	d9c00015 	stw	r7,0(sp)
8111b770:	da400115 	stw	r9,4(sp)
8111b774:	111bf5c0 	call	8111bf5c <__clzsi2>
8111b778:	d9800217 	ldw	r6,8(sp)
8111b77c:	d9c00017 	ldw	r7,0(sp)
8111b780:	da400117 	ldw	r9,4(sp)
8111b784:	113ffd44 	addi	r4,r2,-11
8111b788:	00c00704 	movi	r3,28
8111b78c:	1900ed16 	blt	r3,r4,8111bb44 <__muldf3+0x5c8>
8111b790:	00c00744 	movi	r3,29
8111b794:	147ffe04 	addi	r17,r2,-8
8111b798:	1907c83a 	sub	r3,r3,r4
8111b79c:	8460983a 	sll	r16,r16,r17
8111b7a0:	98c6d83a 	srl	r3,r19,r3
8111b7a4:	9c68983a 	sll	r20,r19,r17
8111b7a8:	1c20b03a 	or	r16,r3,r16
8111b7ac:	1080fcc4 	addi	r2,r2,1011
8111b7b0:	00a5c83a 	sub	r18,zero,r2
8111b7b4:	0027883a 	mov	r19,zero
8111b7b8:	0039883a 	mov	fp,zero
8111b7bc:	003f9006 	br	8111b600 <__reset+0xfb0fb600>
8111b7c0:	3446b03a 	or	r3,r6,r17
8111b7c4:	1800261e 	bne	r3,zero,8111b860 <__muldf3+0x2e4>
8111b7c8:	0023883a 	mov	r17,zero
8111b7cc:	0011883a 	mov	r8,zero
8111b7d0:	01400084 	movi	r5,2
8111b7d4:	003f9c06 	br	8111b648 <__reset+0xfb0fb648>
8111b7d8:	3446b03a 	or	r3,r6,r17
8111b7dc:	18001c26 	beq	r3,zero,8111b850 <__muldf3+0x2d4>
8111b7e0:	8800ce26 	beq	r17,zero,8111bb1c <__muldf3+0x5a0>
8111b7e4:	8809883a 	mov	r4,r17
8111b7e8:	d9800215 	stw	r6,8(sp)
8111b7ec:	da400115 	stw	r9,4(sp)
8111b7f0:	da800015 	stw	r10,0(sp)
8111b7f4:	111bf5c0 	call	8111bf5c <__clzsi2>
8111b7f8:	d9800217 	ldw	r6,8(sp)
8111b7fc:	da400117 	ldw	r9,4(sp)
8111b800:	da800017 	ldw	r10,0(sp)
8111b804:	113ffd44 	addi	r4,r2,-11
8111b808:	00c00704 	movi	r3,28
8111b80c:	1900bf16 	blt	r3,r4,8111bb0c <__muldf3+0x590>
8111b810:	00c00744 	movi	r3,29
8111b814:	123ffe04 	addi	r8,r2,-8
8111b818:	1907c83a 	sub	r3,r3,r4
8111b81c:	8a22983a 	sll	r17,r17,r8
8111b820:	30c6d83a 	srl	r3,r6,r3
8111b824:	3210983a 	sll	r8,r6,r8
8111b828:	1c62b03a 	or	r17,r3,r17
8111b82c:	1080fcc4 	addi	r2,r2,1011
8111b830:	0085c83a 	sub	r2,zero,r2
8111b834:	000b883a 	mov	r5,zero
8111b838:	003f8306 	br	8111b648 <__reset+0xfb0fb648>
8111b83c:	b02b883a 	mov	r21,r22
8111b840:	0081ffc4 	movi	r2,2047
8111b844:	000b883a 	mov	r5,zero
8111b848:	0029883a 	mov	r20,zero
8111b84c:	003fac06 	br	8111b700 <__reset+0xfb0fb700>
8111b850:	0023883a 	mov	r17,zero
8111b854:	0011883a 	mov	r8,zero
8111b858:	01400044 	movi	r5,1
8111b85c:	003f7a06 	br	8111b648 <__reset+0xfb0fb648>
8111b860:	014000c4 	movi	r5,3
8111b864:	003f7806 	br	8111b648 <__reset+0xfb0fb648>
8111b868:	04c00104 	movi	r19,4
8111b86c:	0021883a 	mov	r16,zero
8111b870:	0029883a 	mov	r20,zero
8111b874:	07000044 	movi	fp,1
8111b878:	003f6106 	br	8111b600 <__reset+0xfb0fb600>
8111b87c:	04c00304 	movi	r19,12
8111b880:	070000c4 	movi	fp,3
8111b884:	003f5e06 	br	8111b600 <__reset+0xfb0fb600>
8111b888:	01400434 	movhi	r5,16
8111b88c:	002b883a 	mov	r21,zero
8111b890:	297fffc4 	addi	r5,r5,-1
8111b894:	053fffc4 	movi	r20,-1
8111b898:	0081ffc4 	movi	r2,2047
8111b89c:	003f9806 	br	8111b700 <__reset+0xfb0fb700>
8111b8a0:	8023883a 	mov	r17,r16
8111b8a4:	a011883a 	mov	r8,r20
8111b8a8:	e00b883a 	mov	r5,fp
8111b8ac:	003f8a06 	br	8111b6d8 <__reset+0xfb0fb6d8>
8111b8b0:	8023883a 	mov	r17,r16
8111b8b4:	a011883a 	mov	r8,r20
8111b8b8:	482d883a 	mov	r22,r9
8111b8bc:	e00b883a 	mov	r5,fp
8111b8c0:	003f8506 	br	8111b6d8 <__reset+0xfb0fb6d8>
8111b8c4:	a00ad43a 	srli	r5,r20,16
8111b8c8:	401ad43a 	srli	r13,r8,16
8111b8cc:	a53fffcc 	andi	r20,r20,65535
8111b8d0:	423fffcc 	andi	r8,r8,65535
8111b8d4:	4519383a 	mul	r12,r8,r20
8111b8d8:	4147383a 	mul	r3,r8,r5
8111b8dc:	6d09383a 	mul	r4,r13,r20
8111b8e0:	600cd43a 	srli	r6,r12,16
8111b8e4:	2b5d383a 	mul	r14,r5,r13
8111b8e8:	20c9883a 	add	r4,r4,r3
8111b8ec:	310d883a 	add	r6,r6,r4
8111b8f0:	30c0022e 	bgeu	r6,r3,8111b8fc <__muldf3+0x380>
8111b8f4:	00c00074 	movhi	r3,1
8111b8f8:	70dd883a 	add	r14,r14,r3
8111b8fc:	8826d43a 	srli	r19,r17,16
8111b900:	8bffffcc 	andi	r15,r17,65535
8111b904:	7d23383a 	mul	r17,r15,r20
8111b908:	7949383a 	mul	r4,r15,r5
8111b90c:	9d29383a 	mul	r20,r19,r20
8111b910:	8814d43a 	srli	r10,r17,16
8111b914:	3012943a 	slli	r9,r6,16
8111b918:	a129883a 	add	r20,r20,r4
8111b91c:	633fffcc 	andi	r12,r12,65535
8111b920:	5515883a 	add	r10,r10,r20
8111b924:	3006d43a 	srli	r3,r6,16
8111b928:	4b13883a 	add	r9,r9,r12
8111b92c:	2ccb383a 	mul	r5,r5,r19
8111b930:	5100022e 	bgeu	r10,r4,8111b93c <__muldf3+0x3c0>
8111b934:	01000074 	movhi	r4,1
8111b938:	290b883a 	add	r5,r5,r4
8111b93c:	802ad43a 	srli	r21,r16,16
8111b940:	843fffcc 	andi	r16,r16,65535
8111b944:	440d383a 	mul	r6,r8,r16
8111b948:	4565383a 	mul	r18,r8,r21
8111b94c:	8349383a 	mul	r4,r16,r13
8111b950:	500e943a 	slli	r7,r10,16
8111b954:	3010d43a 	srli	r8,r6,16
8111b958:	5028d43a 	srli	r20,r10,16
8111b95c:	2489883a 	add	r4,r4,r18
8111b960:	8abfffcc 	andi	r10,r17,65535
8111b964:	3a95883a 	add	r10,r7,r10
8111b968:	4119883a 	add	r12,r8,r4
8111b96c:	a169883a 	add	r20,r20,r5
8111b970:	1a87883a 	add	r3,r3,r10
8111b974:	6d5b383a 	mul	r13,r13,r21
8111b978:	6480022e 	bgeu	r12,r18,8111b984 <__muldf3+0x408>
8111b97c:	01000074 	movhi	r4,1
8111b980:	691b883a 	add	r13,r13,r4
8111b984:	7c25383a 	mul	r18,r15,r16
8111b988:	7d4b383a 	mul	r5,r15,r21
8111b98c:	84cf383a 	mul	r7,r16,r19
8111b990:	901ed43a 	srli	r15,r18,16
8111b994:	6008d43a 	srli	r4,r12,16
8111b998:	6010943a 	slli	r8,r12,16
8111b99c:	394f883a 	add	r7,r7,r5
8111b9a0:	333fffcc 	andi	r12,r6,65535
8111b9a4:	79df883a 	add	r15,r15,r7
8111b9a8:	235b883a 	add	r13,r4,r13
8111b9ac:	9d63383a 	mul	r17,r19,r21
8111b9b0:	4309883a 	add	r4,r8,r12
8111b9b4:	7940022e 	bgeu	r15,r5,8111b9c0 <__muldf3+0x444>
8111b9b8:	01400074 	movhi	r5,1
8111b9bc:	8963883a 	add	r17,r17,r5
8111b9c0:	780a943a 	slli	r5,r15,16
8111b9c4:	91bfffcc 	andi	r6,r18,65535
8111b9c8:	70c7883a 	add	r3,r14,r3
8111b9cc:	298d883a 	add	r6,r5,r6
8111b9d0:	1a8f803a 	cmpltu	r7,r3,r10
8111b9d4:	350b883a 	add	r5,r6,r20
8111b9d8:	20c7883a 	add	r3,r4,r3
8111b9dc:	3955883a 	add	r10,r7,r5
8111b9e0:	1909803a 	cmpltu	r4,r3,r4
8111b9e4:	6a91883a 	add	r8,r13,r10
8111b9e8:	780cd43a 	srli	r6,r15,16
8111b9ec:	2219883a 	add	r12,r4,r8
8111b9f0:	2d0b803a 	cmpltu	r5,r5,r20
8111b9f4:	51cf803a 	cmpltu	r7,r10,r7
8111b9f8:	29ceb03a 	or	r7,r5,r7
8111b9fc:	4351803a 	cmpltu	r8,r8,r13
8111ba00:	610b803a 	cmpltu	r5,r12,r4
8111ba04:	4148b03a 	or	r4,r8,r5
8111ba08:	398f883a 	add	r7,r7,r6
8111ba0c:	3909883a 	add	r4,r7,r4
8111ba10:	1810927a 	slli	r8,r3,9
8111ba14:	2449883a 	add	r4,r4,r17
8111ba18:	2008927a 	slli	r4,r4,9
8111ba1c:	6022d5fa 	srli	r17,r12,23
8111ba20:	1806d5fa 	srli	r3,r3,23
8111ba24:	4252b03a 	or	r9,r8,r9
8111ba28:	600a927a 	slli	r5,r12,9
8111ba2c:	4810c03a 	cmpne	r8,r9,zero
8111ba30:	2462b03a 	or	r17,r4,r17
8111ba34:	40c6b03a 	or	r3,r8,r3
8111ba38:	8900402c 	andhi	r4,r17,256
8111ba3c:	1950b03a 	or	r8,r3,r5
8111ba40:	20000726 	beq	r4,zero,8111ba60 <__muldf3+0x4e4>
8111ba44:	4006d07a 	srli	r3,r8,1
8111ba48:	880497fa 	slli	r2,r17,31
8111ba4c:	4200004c 	andi	r8,r8,1
8111ba50:	8822d07a 	srli	r17,r17,1
8111ba54:	1a10b03a 	or	r8,r3,r8
8111ba58:	1210b03a 	or	r8,r2,r8
8111ba5c:	5805883a 	mov	r2,r11
8111ba60:	1140ffc4 	addi	r5,r2,1023
8111ba64:	0140440e 	bge	zero,r5,8111bb78 <__muldf3+0x5fc>
8111ba68:	40c001cc 	andi	r3,r8,7
8111ba6c:	18000726 	beq	r3,zero,8111ba8c <__muldf3+0x510>
8111ba70:	40c003cc 	andi	r3,r8,15
8111ba74:	01000104 	movi	r4,4
8111ba78:	19000426 	beq	r3,r4,8111ba8c <__muldf3+0x510>
8111ba7c:	4107883a 	add	r3,r8,r4
8111ba80:	1a11803a 	cmpltu	r8,r3,r8
8111ba84:	8a23883a 	add	r17,r17,r8
8111ba88:	1811883a 	mov	r8,r3
8111ba8c:	88c0402c 	andhi	r3,r17,256
8111ba90:	18000426 	beq	r3,zero,8111baa4 <__muldf3+0x528>
8111ba94:	11410004 	addi	r5,r2,1024
8111ba98:	00bfc034 	movhi	r2,65280
8111ba9c:	10bfffc4 	addi	r2,r2,-1
8111baa0:	88a2703a 	and	r17,r17,r2
8111baa4:	0081ff84 	movi	r2,2046
8111baa8:	117f6416 	blt	r2,r5,8111b83c <__reset+0xfb0fb83c>
8111baac:	8828977a 	slli	r20,r17,29
8111bab0:	4010d0fa 	srli	r8,r8,3
8111bab4:	8822927a 	slli	r17,r17,9
8111bab8:	2881ffcc 	andi	r2,r5,2047
8111babc:	a228b03a 	or	r20,r20,r8
8111bac0:	880ad33a 	srli	r5,r17,12
8111bac4:	b02b883a 	mov	r21,r22
8111bac8:	003f0d06 	br	8111b700 <__reset+0xfb0fb700>
8111bacc:	8080022c 	andhi	r2,r16,8
8111bad0:	10000926 	beq	r2,zero,8111baf8 <__muldf3+0x57c>
8111bad4:	8880022c 	andhi	r2,r17,8
8111bad8:	1000071e 	bne	r2,zero,8111baf8 <__muldf3+0x57c>
8111badc:	00800434 	movhi	r2,16
8111bae0:	89400234 	orhi	r5,r17,8
8111bae4:	10bfffc4 	addi	r2,r2,-1
8111bae8:	b82b883a 	mov	r21,r23
8111baec:	288a703a 	and	r5,r5,r2
8111baf0:	4029883a 	mov	r20,r8
8111baf4:	003f6806 	br	8111b898 <__reset+0xfb0fb898>
8111baf8:	00800434 	movhi	r2,16
8111bafc:	81400234 	orhi	r5,r16,8
8111bb00:	10bfffc4 	addi	r2,r2,-1
8111bb04:	288a703a 	and	r5,r5,r2
8111bb08:	003f6306 	br	8111b898 <__reset+0xfb0fb898>
8111bb0c:	147ff604 	addi	r17,r2,-40
8111bb10:	3462983a 	sll	r17,r6,r17
8111bb14:	0011883a 	mov	r8,zero
8111bb18:	003f4406 	br	8111b82c <__reset+0xfb0fb82c>
8111bb1c:	3009883a 	mov	r4,r6
8111bb20:	d9800215 	stw	r6,8(sp)
8111bb24:	da400115 	stw	r9,4(sp)
8111bb28:	da800015 	stw	r10,0(sp)
8111bb2c:	111bf5c0 	call	8111bf5c <__clzsi2>
8111bb30:	10800804 	addi	r2,r2,32
8111bb34:	da800017 	ldw	r10,0(sp)
8111bb38:	da400117 	ldw	r9,4(sp)
8111bb3c:	d9800217 	ldw	r6,8(sp)
8111bb40:	003f3006 	br	8111b804 <__reset+0xfb0fb804>
8111bb44:	143ff604 	addi	r16,r2,-40
8111bb48:	9c20983a 	sll	r16,r19,r16
8111bb4c:	0029883a 	mov	r20,zero
8111bb50:	003f1606 	br	8111b7ac <__reset+0xfb0fb7ac>
8111bb54:	d9800215 	stw	r6,8(sp)
8111bb58:	d9c00015 	stw	r7,0(sp)
8111bb5c:	da400115 	stw	r9,4(sp)
8111bb60:	111bf5c0 	call	8111bf5c <__clzsi2>
8111bb64:	10800804 	addi	r2,r2,32
8111bb68:	da400117 	ldw	r9,4(sp)
8111bb6c:	d9c00017 	ldw	r7,0(sp)
8111bb70:	d9800217 	ldw	r6,8(sp)
8111bb74:	003f0306 	br	8111b784 <__reset+0xfb0fb784>
8111bb78:	00c00044 	movi	r3,1
8111bb7c:	1947c83a 	sub	r3,r3,r5
8111bb80:	00800e04 	movi	r2,56
8111bb84:	10feda16 	blt	r2,r3,8111b6f0 <__reset+0xfb0fb6f0>
8111bb88:	008007c4 	movi	r2,31
8111bb8c:	10c01b16 	blt	r2,r3,8111bbfc <__muldf3+0x680>
8111bb90:	00800804 	movi	r2,32
8111bb94:	10c5c83a 	sub	r2,r2,r3
8111bb98:	888a983a 	sll	r5,r17,r2
8111bb9c:	40c8d83a 	srl	r4,r8,r3
8111bba0:	4084983a 	sll	r2,r8,r2
8111bba4:	88e2d83a 	srl	r17,r17,r3
8111bba8:	2906b03a 	or	r3,r5,r4
8111bbac:	1004c03a 	cmpne	r2,r2,zero
8111bbb0:	1886b03a 	or	r3,r3,r2
8111bbb4:	188001cc 	andi	r2,r3,7
8111bbb8:	10000726 	beq	r2,zero,8111bbd8 <__muldf3+0x65c>
8111bbbc:	188003cc 	andi	r2,r3,15
8111bbc0:	01000104 	movi	r4,4
8111bbc4:	11000426 	beq	r2,r4,8111bbd8 <__muldf3+0x65c>
8111bbc8:	1805883a 	mov	r2,r3
8111bbcc:	10c00104 	addi	r3,r2,4
8111bbd0:	1885803a 	cmpltu	r2,r3,r2
8111bbd4:	88a3883a 	add	r17,r17,r2
8111bbd8:	8880202c 	andhi	r2,r17,128
8111bbdc:	10001c26 	beq	r2,zero,8111bc50 <__muldf3+0x6d4>
8111bbe0:	b02b883a 	mov	r21,r22
8111bbe4:	00800044 	movi	r2,1
8111bbe8:	000b883a 	mov	r5,zero
8111bbec:	0029883a 	mov	r20,zero
8111bbf0:	003ec306 	br	8111b700 <__reset+0xfb0fb700>
8111bbf4:	5805883a 	mov	r2,r11
8111bbf8:	003f9906 	br	8111ba60 <__reset+0xfb0fba60>
8111bbfc:	00bff844 	movi	r2,-31
8111bc00:	1145c83a 	sub	r2,r2,r5
8111bc04:	8888d83a 	srl	r4,r17,r2
8111bc08:	00800804 	movi	r2,32
8111bc0c:	18801a26 	beq	r3,r2,8111bc78 <__muldf3+0x6fc>
8111bc10:	00801004 	movi	r2,64
8111bc14:	10c5c83a 	sub	r2,r2,r3
8111bc18:	8884983a 	sll	r2,r17,r2
8111bc1c:	1204b03a 	or	r2,r2,r8
8111bc20:	1004c03a 	cmpne	r2,r2,zero
8111bc24:	2084b03a 	or	r2,r4,r2
8111bc28:	144001cc 	andi	r17,r2,7
8111bc2c:	88000d1e 	bne	r17,zero,8111bc64 <__muldf3+0x6e8>
8111bc30:	000b883a 	mov	r5,zero
8111bc34:	1028d0fa 	srli	r20,r2,3
8111bc38:	b02b883a 	mov	r21,r22
8111bc3c:	0005883a 	mov	r2,zero
8111bc40:	a468b03a 	or	r20,r20,r17
8111bc44:	003eae06 	br	8111b700 <__reset+0xfb0fb700>
8111bc48:	1007883a 	mov	r3,r2
8111bc4c:	0023883a 	mov	r17,zero
8111bc50:	880a927a 	slli	r5,r17,9
8111bc54:	1805883a 	mov	r2,r3
8111bc58:	8822977a 	slli	r17,r17,29
8111bc5c:	280ad33a 	srli	r5,r5,12
8111bc60:	003ff406 	br	8111bc34 <__reset+0xfb0fbc34>
8111bc64:	10c003cc 	andi	r3,r2,15
8111bc68:	01000104 	movi	r4,4
8111bc6c:	193ff626 	beq	r3,r4,8111bc48 <__reset+0xfb0fbc48>
8111bc70:	0023883a 	mov	r17,zero
8111bc74:	003fd506 	br	8111bbcc <__reset+0xfb0fbbcc>
8111bc78:	0005883a 	mov	r2,zero
8111bc7c:	003fe706 	br	8111bc1c <__reset+0xfb0fbc1c>
8111bc80:	00800434 	movhi	r2,16
8111bc84:	89400234 	orhi	r5,r17,8
8111bc88:	10bfffc4 	addi	r2,r2,-1
8111bc8c:	b02b883a 	mov	r21,r22
8111bc90:	288a703a 	and	r5,r5,r2
8111bc94:	4029883a 	mov	r20,r8
8111bc98:	003eff06 	br	8111b898 <__reset+0xfb0fb898>

8111bc9c <__extendsfdf2>:
8111bc9c:	200ad5fa 	srli	r5,r4,23
8111bca0:	defffd04 	addi	sp,sp,-12
8111bca4:	de00012e 	bgeu	sp,et,8111bcac <__extendsfdf2+0x10>
8111bca8:	003b68fa 	trap	3
8111bcac:	29403fcc 	andi	r5,r5,255
8111bcb0:	dc400115 	stw	r17,4(sp)
8111bcb4:	29800044 	addi	r6,r5,1
8111bcb8:	04402034 	movhi	r17,128
8111bcbc:	dc000015 	stw	r16,0(sp)
8111bcc0:	8c7fffc4 	addi	r17,r17,-1
8111bcc4:	dfc00215 	stw	ra,8(sp)
8111bcc8:	31803fcc 	andi	r6,r6,255
8111bccc:	00800044 	movi	r2,1
8111bcd0:	8922703a 	and	r17,r17,r4
8111bcd4:	2020d7fa 	srli	r16,r4,31
8111bcd8:	1180110e 	bge	r2,r6,8111bd20 <__extendsfdf2+0x84>
8111bcdc:	880cd0fa 	srli	r6,r17,3
8111bce0:	8822977a 	slli	r17,r17,29
8111bce4:	2940e004 	addi	r5,r5,896
8111bce8:	2941ffcc 	andi	r5,r5,2047
8111bcec:	2804953a 	slli	r2,r5,20
8111bcf0:	01400434 	movhi	r5,16
8111bcf4:	800697fa 	slli	r3,r16,31
8111bcf8:	297fffc4 	addi	r5,r5,-1
8111bcfc:	314a703a 	and	r5,r6,r5
8111bd00:	288ab03a 	or	r5,r5,r2
8111bd04:	28c6b03a 	or	r3,r5,r3
8111bd08:	8805883a 	mov	r2,r17
8111bd0c:	dfc00217 	ldw	ra,8(sp)
8111bd10:	dc400117 	ldw	r17,4(sp)
8111bd14:	dc000017 	ldw	r16,0(sp)
8111bd18:	dec00304 	addi	sp,sp,12
8111bd1c:	f800283a 	ret
8111bd20:	2800111e 	bne	r5,zero,8111bd68 <__extendsfdf2+0xcc>
8111bd24:	88001c26 	beq	r17,zero,8111bd98 <__extendsfdf2+0xfc>
8111bd28:	8809883a 	mov	r4,r17
8111bd2c:	111bf5c0 	call	8111bf5c <__clzsi2>
8111bd30:	00c00284 	movi	r3,10
8111bd34:	18801b16 	blt	r3,r2,8111bda4 <__extendsfdf2+0x108>
8111bd38:	018002c4 	movi	r6,11
8111bd3c:	308dc83a 	sub	r6,r6,r2
8111bd40:	11000544 	addi	r4,r2,21
8111bd44:	8986d83a 	srl	r3,r17,r6
8111bd48:	8922983a 	sll	r17,r17,r4
8111bd4c:	0180e244 	movi	r6,905
8111bd50:	01400434 	movhi	r5,16
8111bd54:	3085c83a 	sub	r2,r6,r2
8111bd58:	297fffc4 	addi	r5,r5,-1
8111bd5c:	194c703a 	and	r6,r3,r5
8111bd60:	1141ffcc 	andi	r5,r2,2047
8111bd64:	003fe006 	br	8111bce8 <__reset+0xfb0fbce8>
8111bd68:	88000826 	beq	r17,zero,8111bd8c <__extendsfdf2+0xf0>
8111bd6c:	880cd0fa 	srli	r6,r17,3
8111bd70:	00800434 	movhi	r2,16
8111bd74:	10bfffc4 	addi	r2,r2,-1
8111bd78:	31800234 	orhi	r6,r6,8
8111bd7c:	8822977a 	slli	r17,r17,29
8111bd80:	308c703a 	and	r6,r6,r2
8111bd84:	0141ffc4 	movi	r5,2047
8111bd88:	003fd706 	br	8111bce8 <__reset+0xfb0fbce8>
8111bd8c:	0141ffc4 	movi	r5,2047
8111bd90:	000d883a 	mov	r6,zero
8111bd94:	003fd406 	br	8111bce8 <__reset+0xfb0fbce8>
8111bd98:	000b883a 	mov	r5,zero
8111bd9c:	000d883a 	mov	r6,zero
8111bda0:	003fd106 	br	8111bce8 <__reset+0xfb0fbce8>
8111bda4:	11bffd44 	addi	r6,r2,-11
8111bda8:	8986983a 	sll	r3,r17,r6
8111bdac:	0023883a 	mov	r17,zero
8111bdb0:	003fe606 	br	8111bd4c <__reset+0xfb0fbd4c>

8111bdb4 <__truncdfsf2>:
8111bdb4:	2810d53a 	srli	r8,r5,20
8111bdb8:	01c00434 	movhi	r7,16
8111bdbc:	39ffffc4 	addi	r7,r7,-1
8111bdc0:	29ce703a 	and	r7,r5,r7
8111bdc4:	4201ffcc 	andi	r8,r8,2047
8111bdc8:	380e90fa 	slli	r7,r7,3
8111bdcc:	200cd77a 	srli	r6,r4,29
8111bdd0:	42400044 	addi	r9,r8,1
8111bdd4:	4a41ffcc 	andi	r9,r9,2047
8111bdd8:	00c00044 	movi	r3,1
8111bddc:	280ad7fa 	srli	r5,r5,31
8111bde0:	31ceb03a 	or	r7,r6,r7
8111bde4:	200490fa 	slli	r2,r4,3
8111bde8:	1a40230e 	bge	r3,r9,8111be78 <__truncdfsf2+0xc4>
8111bdec:	40ff2004 	addi	r3,r8,-896
8111bdf0:	01803f84 	movi	r6,254
8111bdf4:	30c01516 	blt	r6,r3,8111be4c <__truncdfsf2+0x98>
8111bdf8:	00c0380e 	bge	zero,r3,8111bedc <__truncdfsf2+0x128>
8111bdfc:	200c91ba 	slli	r6,r4,6
8111be00:	380e90fa 	slli	r7,r7,3
8111be04:	1004d77a 	srli	r2,r2,29
8111be08:	300cc03a 	cmpne	r6,r6,zero
8111be0c:	31ccb03a 	or	r6,r6,r7
8111be10:	308cb03a 	or	r6,r6,r2
8111be14:	308001cc 	andi	r2,r6,7
8111be18:	10000426 	beq	r2,zero,8111be2c <__truncdfsf2+0x78>
8111be1c:	308003cc 	andi	r2,r6,15
8111be20:	01000104 	movi	r4,4
8111be24:	11000126 	beq	r2,r4,8111be2c <__truncdfsf2+0x78>
8111be28:	31800104 	addi	r6,r6,4
8111be2c:	3081002c 	andhi	r2,r6,1024
8111be30:	10001626 	beq	r2,zero,8111be8c <__truncdfsf2+0xd8>
8111be34:	18c00044 	addi	r3,r3,1
8111be38:	00803fc4 	movi	r2,255
8111be3c:	18800326 	beq	r3,r2,8111be4c <__truncdfsf2+0x98>
8111be40:	300c91ba 	slli	r6,r6,6
8111be44:	300cd27a 	srli	r6,r6,9
8111be48:	00000206 	br	8111be54 <__truncdfsf2+0xa0>
8111be4c:	00ffffc4 	movi	r3,-1
8111be50:	000d883a 	mov	r6,zero
8111be54:	18c03fcc 	andi	r3,r3,255
8111be58:	180895fa 	slli	r4,r3,23
8111be5c:	00c02034 	movhi	r3,128
8111be60:	280a97fa 	slli	r5,r5,31
8111be64:	18ffffc4 	addi	r3,r3,-1
8111be68:	30c6703a 	and	r3,r6,r3
8111be6c:	1906b03a 	or	r3,r3,r4
8111be70:	1944b03a 	or	r2,r3,r5
8111be74:	f800283a 	ret
8111be78:	40000b1e 	bne	r8,zero,8111bea8 <__truncdfsf2+0xf4>
8111be7c:	388cb03a 	or	r6,r7,r2
8111be80:	0007883a 	mov	r3,zero
8111be84:	30000426 	beq	r6,zero,8111be98 <__truncdfsf2+0xe4>
8111be88:	01800144 	movi	r6,5
8111be8c:	00803fc4 	movi	r2,255
8111be90:	300cd0fa 	srli	r6,r6,3
8111be94:	18800a26 	beq	r3,r2,8111bec0 <__truncdfsf2+0x10c>
8111be98:	00802034 	movhi	r2,128
8111be9c:	10bfffc4 	addi	r2,r2,-1
8111bea0:	308c703a 	and	r6,r6,r2
8111bea4:	003feb06 	br	8111be54 <__reset+0xfb0fbe54>
8111bea8:	3888b03a 	or	r4,r7,r2
8111beac:	203fe726 	beq	r4,zero,8111be4c <__reset+0xfb0fbe4c>
8111beb0:	380c90fa 	slli	r6,r7,3
8111beb4:	00c03fc4 	movi	r3,255
8111beb8:	31808034 	orhi	r6,r6,512
8111bebc:	003fd506 	br	8111be14 <__reset+0xfb0fbe14>
8111bec0:	303fe226 	beq	r6,zero,8111be4c <__reset+0xfb0fbe4c>
8111bec4:	00802034 	movhi	r2,128
8111bec8:	31801034 	orhi	r6,r6,64
8111becc:	10bfffc4 	addi	r2,r2,-1
8111bed0:	00ffffc4 	movi	r3,-1
8111bed4:	308c703a 	and	r6,r6,r2
8111bed8:	003fde06 	br	8111be54 <__reset+0xfb0fbe54>
8111bedc:	013ffa44 	movi	r4,-23
8111bee0:	19000e16 	blt	r3,r4,8111bf1c <__truncdfsf2+0x168>
8111bee4:	01000784 	movi	r4,30
8111bee8:	20c9c83a 	sub	r4,r4,r3
8111beec:	018007c4 	movi	r6,31
8111bef0:	39c02034 	orhi	r7,r7,128
8111bef4:	31000b16 	blt	r6,r4,8111bf24 <__truncdfsf2+0x170>
8111bef8:	423f2084 	addi	r8,r8,-894
8111befc:	120c983a 	sll	r6,r2,r8
8111bf00:	3a0e983a 	sll	r7,r7,r8
8111bf04:	1104d83a 	srl	r2,r2,r4
8111bf08:	300cc03a 	cmpne	r6,r6,zero
8111bf0c:	31ceb03a 	or	r7,r6,r7
8111bf10:	388cb03a 	or	r6,r7,r2
8111bf14:	0007883a 	mov	r3,zero
8111bf18:	003fbe06 	br	8111be14 <__reset+0xfb0fbe14>
8111bf1c:	0007883a 	mov	r3,zero
8111bf20:	003fd906 	br	8111be88 <__reset+0xfb0fbe88>
8111bf24:	01bfff84 	movi	r6,-2
8111bf28:	30cdc83a 	sub	r6,r6,r3
8111bf2c:	00c00804 	movi	r3,32
8111bf30:	398cd83a 	srl	r6,r7,r6
8111bf34:	20c00726 	beq	r4,r3,8111bf54 <__truncdfsf2+0x1a0>
8111bf38:	423f2884 	addi	r8,r8,-862
8111bf3c:	3a0e983a 	sll	r7,r7,r8
8111bf40:	3884b03a 	or	r2,r7,r2
8111bf44:	1004c03a 	cmpne	r2,r2,zero
8111bf48:	118cb03a 	or	r6,r2,r6
8111bf4c:	0007883a 	mov	r3,zero
8111bf50:	003fb006 	br	8111be14 <__reset+0xfb0fbe14>
8111bf54:	000f883a 	mov	r7,zero
8111bf58:	003ff906 	br	8111bf40 <__reset+0xfb0fbf40>

8111bf5c <__clzsi2>:
8111bf5c:	00bfffd4 	movui	r2,65535
8111bf60:	11000536 	bltu	r2,r4,8111bf78 <__clzsi2+0x1c>
8111bf64:	00803fc4 	movi	r2,255
8111bf68:	11000f36 	bltu	r2,r4,8111bfa8 <__clzsi2+0x4c>
8111bf6c:	00800804 	movi	r2,32
8111bf70:	0007883a 	mov	r3,zero
8111bf74:	00000506 	br	8111bf8c <__clzsi2+0x30>
8111bf78:	00804034 	movhi	r2,256
8111bf7c:	10bfffc4 	addi	r2,r2,-1
8111bf80:	11000c2e 	bgeu	r2,r4,8111bfb4 <__clzsi2+0x58>
8111bf84:	00800204 	movi	r2,8
8111bf88:	00c00604 	movi	r3,24
8111bf8c:	20c8d83a 	srl	r4,r4,r3
8111bf90:	00e04574 	movhi	r3,33045
8111bf94:	18ed1b04 	addi	r3,r3,-19348
8111bf98:	1909883a 	add	r4,r3,r4
8111bf9c:	20c00003 	ldbu	r3,0(r4)
8111bfa0:	10c5c83a 	sub	r2,r2,r3
8111bfa4:	f800283a 	ret
8111bfa8:	00800604 	movi	r2,24
8111bfac:	00c00204 	movi	r3,8
8111bfb0:	003ff606 	br	8111bf8c <__reset+0xfb0fbf8c>
8111bfb4:	00800404 	movi	r2,16
8111bfb8:	1007883a 	mov	r3,r2
8111bfbc:	003ff306 	br	8111bf8c <__reset+0xfb0fbf8c>

8111bfc0 <atoi>:
8111bfc0:	01800284 	movi	r6,10
8111bfc4:	000b883a 	mov	r5,zero
8111bfc8:	111dfdc1 	jmpi	8111dfdc <strtol>

8111bfcc <_atoi_r>:
8111bfcc:	01c00284 	movi	r7,10
8111bfd0:	000d883a 	mov	r6,zero
8111bfd4:	111dd9c1 	jmpi	8111dd9c <_strtol_r>

8111bfd8 <_fopen_r>:
8111bfd8:	defffa04 	addi	sp,sp,-24
8111bfdc:	3005883a 	mov	r2,r6
8111bfe0:	de00012e 	bgeu	sp,et,8111bfe8 <_fopen_r+0x10>
8111bfe4:	003b68fa 	trap	3
8111bfe8:	d80d883a 	mov	r6,sp
8111bfec:	dcc00415 	stw	r19,16(sp)
8111bff0:	2827883a 	mov	r19,r5
8111bff4:	100b883a 	mov	r5,r2
8111bff8:	dc800315 	stw	r18,12(sp)
8111bffc:	dfc00515 	stw	ra,20(sp)
8111c000:	dc400215 	stw	r17,8(sp)
8111c004:	dc000115 	stw	r16,4(sp)
8111c008:	2025883a 	mov	r18,r4
8111c00c:	1125fe40 	call	81125fe4 <__sflags>
8111c010:	10002726 	beq	r2,zero,8111c0b0 <_fopen_r+0xd8>
8111c014:	9009883a 	mov	r4,r18
8111c018:	1023883a 	mov	r17,r2
8111c01c:	1125e5c0 	call	81125e5c <__sfp>
8111c020:	1021883a 	mov	r16,r2
8111c024:	10002226 	beq	r2,zero,8111c0b0 <_fopen_r+0xd8>
8111c028:	d9800017 	ldw	r6,0(sp)
8111c02c:	01c06d84 	movi	r7,438
8111c030:	980b883a 	mov	r5,r19
8111c034:	9009883a 	mov	r4,r18
8111c038:	111d4440 	call	8111d444 <_open_r>
8111c03c:	10001916 	blt	r2,zero,8111c0a4 <_fopen_r+0xcc>
8111c040:	8080038d 	sth	r2,14(r16)
8111c044:	00a044b4 	movhi	r2,33042
8111c048:	10b6c804 	addi	r2,r2,-9440
8111c04c:	80800815 	stw	r2,32(r16)
8111c050:	00a044b4 	movhi	r2,33042
8111c054:	10b6e104 	addi	r2,r2,-9340
8111c058:	80800915 	stw	r2,36(r16)
8111c05c:	00a044b4 	movhi	r2,33042
8111c060:	10b70204 	addi	r2,r2,-9208
8111c064:	80800a15 	stw	r2,40(r16)
8111c068:	00a044b4 	movhi	r2,33042
8111c06c:	10b71b04 	addi	r2,r2,-9108
8111c070:	8440030d 	sth	r17,12(r16)
8111c074:	84000715 	stw	r16,28(r16)
8111c078:	80800b15 	stw	r2,44(r16)
8111c07c:	8c40400c 	andi	r17,r17,256
8111c080:	88000d1e 	bne	r17,zero,8111c0b8 <_fopen_r+0xe0>
8111c084:	8005883a 	mov	r2,r16
8111c088:	dfc00517 	ldw	ra,20(sp)
8111c08c:	dcc00417 	ldw	r19,16(sp)
8111c090:	dc800317 	ldw	r18,12(sp)
8111c094:	dc400217 	ldw	r17,8(sp)
8111c098:	dc000117 	ldw	r16,4(sp)
8111c09c:	dec00604 	addi	sp,sp,24
8111c0a0:	f800283a 	ret
8111c0a4:	1125fa40 	call	81125fa4 <__sfp_lock_acquire>
8111c0a8:	8000030d 	sth	zero,12(r16)
8111c0ac:	1125fa80 	call	81125fa8 <__sfp_lock_release>
8111c0b0:	0005883a 	mov	r2,zero
8111c0b4:	003ff406 	br	8111c088 <__reset+0xfb0fc088>
8111c0b8:	01c00084 	movi	r7,2
8111c0bc:	000d883a 	mov	r6,zero
8111c0c0:	800b883a 	mov	r5,r16
8111c0c4:	9009883a 	mov	r4,r18
8111c0c8:	111c1f80 	call	8111c1f8 <_fseek_r>
8111c0cc:	8005883a 	mov	r2,r16
8111c0d0:	003fed06 	br	8111c088 <__reset+0xfb0fc088>

8111c0d4 <fopen>:
8111c0d4:	00a04574 	movhi	r2,33045
8111c0d8:	10b7d604 	addi	r2,r2,-8360
8111c0dc:	280d883a 	mov	r6,r5
8111c0e0:	200b883a 	mov	r5,r4
8111c0e4:	11000017 	ldw	r4,0(r2)
8111c0e8:	111bfd81 	jmpi	8111bfd8 <_fopen_r>

8111c0ec <_fprintf_r>:
8111c0ec:	defffe04 	addi	sp,sp,-8
8111c0f0:	2809883a 	mov	r4,r5
8111c0f4:	300b883a 	mov	r5,r6
8111c0f8:	de00012e 	bgeu	sp,et,8111c100 <_fprintf_r+0x14>
8111c0fc:	003b68fa 	trap	3
8111c100:	dfc00015 	stw	ra,0(sp)
8111c104:	d9c00115 	stw	r7,4(sp)
8111c108:	d9800104 	addi	r6,sp,4
8111c10c:	11223d80 	call	811223d8 <__vfprintf_internal>
8111c110:	dfc00017 	ldw	ra,0(sp)
8111c114:	dec00204 	addi	sp,sp,8
8111c118:	f800283a 	ret

8111c11c <fprintf>:
8111c11c:	defffd04 	addi	sp,sp,-12
8111c120:	de00012e 	bgeu	sp,et,8111c128 <fprintf+0xc>
8111c124:	003b68fa 	trap	3
8111c128:	dfc00015 	stw	ra,0(sp)
8111c12c:	d9800115 	stw	r6,4(sp)
8111c130:	d9c00215 	stw	r7,8(sp)
8111c134:	d9800104 	addi	r6,sp,4
8111c138:	11223d80 	call	811223d8 <__vfprintf_internal>
8111c13c:	dfc00017 	ldw	ra,0(sp)
8111c140:	dec00304 	addi	sp,sp,12
8111c144:	f800283a 	ret

8111c148 <_fputc_r>:
8111c148:	defffc04 	addi	sp,sp,-16
8111c14c:	de00012e 	bgeu	sp,et,8111c154 <_fputc_r+0xc>
8111c150:	003b68fa 	trap	3
8111c154:	dc000215 	stw	r16,8(sp)
8111c158:	dfc00315 	stw	ra,12(sp)
8111c15c:	2021883a 	mov	r16,r4
8111c160:	20000726 	beq	r4,zero,8111c180 <_fputc_r+0x38>
8111c164:	20800e17 	ldw	r2,56(r4)
8111c168:	1000051e 	bne	r2,zero,8111c180 <_fputc_r+0x38>
8111c16c:	d9400015 	stw	r5,0(sp)
8111c170:	d9800115 	stw	r6,4(sp)
8111c174:	1125f940 	call	81125f94 <__sinit>
8111c178:	d9800117 	ldw	r6,4(sp)
8111c17c:	d9400017 	ldw	r5,0(sp)
8111c180:	8009883a 	mov	r4,r16
8111c184:	dfc00317 	ldw	ra,12(sp)
8111c188:	dc000217 	ldw	r16,8(sp)
8111c18c:	dec00404 	addi	sp,sp,16
8111c190:	111d5281 	jmpi	8111d528 <_putc_r>

8111c194 <fputc>:
8111c194:	00a04574 	movhi	r2,33045
8111c198:	defffc04 	addi	sp,sp,-16
8111c19c:	10b7d604 	addi	r2,r2,-8360
8111c1a0:	de00012e 	bgeu	sp,et,8111c1a8 <fputc+0x14>
8111c1a4:	003b68fa 	trap	3
8111c1a8:	dc000115 	stw	r16,4(sp)
8111c1ac:	14000017 	ldw	r16,0(r2)
8111c1b0:	dc400215 	stw	r17,8(sp)
8111c1b4:	dfc00315 	stw	ra,12(sp)
8111c1b8:	2023883a 	mov	r17,r4
8111c1bc:	80000626 	beq	r16,zero,8111c1d8 <fputc+0x44>
8111c1c0:	80800e17 	ldw	r2,56(r16)
8111c1c4:	1000041e 	bne	r2,zero,8111c1d8 <fputc+0x44>
8111c1c8:	8009883a 	mov	r4,r16
8111c1cc:	d9400015 	stw	r5,0(sp)
8111c1d0:	1125f940 	call	81125f94 <__sinit>
8111c1d4:	d9400017 	ldw	r5,0(sp)
8111c1d8:	280d883a 	mov	r6,r5
8111c1dc:	8009883a 	mov	r4,r16
8111c1e0:	880b883a 	mov	r5,r17
8111c1e4:	dfc00317 	ldw	ra,12(sp)
8111c1e8:	dc400217 	ldw	r17,8(sp)
8111c1ec:	dc000117 	ldw	r16,4(sp)
8111c1f0:	dec00404 	addi	sp,sp,16
8111c1f4:	111d5281 	jmpi	8111d528 <_putc_r>

8111c1f8 <_fseek_r>:
8111c1f8:	111c2181 	jmpi	8111c218 <_fseeko_r>

8111c1fc <fseek>:
8111c1fc:	00a04574 	movhi	r2,33045
8111c200:	10b7d604 	addi	r2,r2,-8360
8111c204:	300f883a 	mov	r7,r6
8111c208:	280d883a 	mov	r6,r5
8111c20c:	200b883a 	mov	r5,r4
8111c210:	11000017 	ldw	r4,0(r2)
8111c214:	111c2181 	jmpi	8111c218 <_fseeko_r>

8111c218 <_fseeko_r>:
8111c218:	deffe804 	addi	sp,sp,-96
8111c21c:	de00012e 	bgeu	sp,et,8111c224 <_fseeko_r+0xc>
8111c220:	003b68fa 	trap	3
8111c224:	dd401415 	stw	r21,80(sp)
8111c228:	dc801115 	stw	r18,68(sp)
8111c22c:	dc401015 	stw	r17,64(sp)
8111c230:	dc000f15 	stw	r16,60(sp)
8111c234:	dfc01715 	stw	ra,92(sp)
8111c238:	ddc01615 	stw	r23,88(sp)
8111c23c:	dd801515 	stw	r22,84(sp)
8111c240:	dd001315 	stw	r20,76(sp)
8111c244:	dcc01215 	stw	r19,72(sp)
8111c248:	2023883a 	mov	r17,r4
8111c24c:	2821883a 	mov	r16,r5
8111c250:	302b883a 	mov	r21,r6
8111c254:	3825883a 	mov	r18,r7
8111c258:	20000226 	beq	r4,zero,8111c264 <_fseeko_r+0x4c>
8111c25c:	20800e17 	ldw	r2,56(r4)
8111c260:	10005a26 	beq	r2,zero,8111c3cc <_fseeko_r+0x1b4>
8111c264:	8080030b 	ldhu	r2,12(r16)
8111c268:	00c04204 	movi	r3,264
8111c26c:	1080420c 	andi	r2,r2,264
8111c270:	10c05b26 	beq	r2,r3,8111c3e0 <_fseeko_r+0x1c8>
8111c274:	85000a17 	ldw	r20,40(r16)
8111c278:	a000f626 	beq	r20,zero,8111c654 <_fseeko_r+0x43c>
8111c27c:	00800044 	movi	r2,1
8111c280:	90803e26 	beq	r18,r2,8111c37c <_fseeko_r+0x164>
8111c284:	00800084 	movi	r2,2
8111c288:	90801026 	beq	r18,r2,8111c2cc <_fseeko_r+0xb4>
8111c28c:	90000f26 	beq	r18,zero,8111c2cc <_fseeko_r+0xb4>
8111c290:	00800584 	movi	r2,22
8111c294:	88800015 	stw	r2,0(r17)
8111c298:	04ffffc4 	movi	r19,-1
8111c29c:	9805883a 	mov	r2,r19
8111c2a0:	dfc01717 	ldw	ra,92(sp)
8111c2a4:	ddc01617 	ldw	r23,88(sp)
8111c2a8:	dd801517 	ldw	r22,84(sp)
8111c2ac:	dd401417 	ldw	r21,80(sp)
8111c2b0:	dd001317 	ldw	r20,76(sp)
8111c2b4:	dcc01217 	ldw	r19,72(sp)
8111c2b8:	dc801117 	ldw	r18,68(sp)
8111c2bc:	dc401017 	ldw	r17,64(sp)
8111c2c0:	dc000f17 	ldw	r16,60(sp)
8111c2c4:	dec01804 	addi	sp,sp,96
8111c2c8:	f800283a 	ret
8111c2cc:	80800417 	ldw	r2,16(r16)
8111c2d0:	002f883a 	mov	r23,zero
8111c2d4:	0027883a 	mov	r19,zero
8111c2d8:	1000cb26 	beq	r2,zero,8111c608 <_fseeko_r+0x3f0>
8111c2dc:	8080030b 	ldhu	r2,12(r16)
8111c2e0:	10c2068c 	andi	r3,r2,2074
8111c2e4:	1800071e 	bne	r3,zero,8111c304 <_fseeko_r+0xec>
8111c2e8:	10c1000c 	andi	r3,r2,1024
8111c2ec:	1800451e 	bne	r3,zero,8111c404 <_fseeko_r+0x1ec>
8111c2f0:	00e044b4 	movhi	r3,33042
8111c2f4:	18f70204 	addi	r3,r3,-9208
8111c2f8:	a0c0b726 	beq	r20,r3,8111c5d8 <_fseeko_r+0x3c0>
8111c2fc:	10820014 	ori	r2,r2,2048
8111c300:	8080030d 	sth	r2,12(r16)
8111c304:	800b883a 	mov	r5,r16
8111c308:	8809883a 	mov	r4,r17
8111c30c:	1125b980 	call	81125b98 <_fflush_r>
8111c310:	1027883a 	mov	r19,r2
8111c314:	103fe01e 	bne	r2,zero,8111c298 <__reset+0xfb0fc298>
8111c318:	81400717 	ldw	r5,28(r16)
8111c31c:	900f883a 	mov	r7,r18
8111c320:	a80d883a 	mov	r6,r21
8111c324:	8809883a 	mov	r4,r17
8111c328:	a03ee83a 	callr	r20
8111c32c:	00ffffc4 	movi	r3,-1
8111c330:	10ffd926 	beq	r2,r3,8111c298 <__reset+0xfb0fc298>
8111c334:	81400c17 	ldw	r5,48(r16)
8111c338:	28000526 	beq	r5,zero,8111c350 <_fseeko_r+0x138>
8111c33c:	80801004 	addi	r2,r16,64
8111c340:	28800226 	beq	r5,r2,8111c34c <_fseeko_r+0x134>
8111c344:	8809883a 	mov	r4,r17
8111c348:	112642c0 	call	8112642c <_free_r>
8111c34c:	80000c15 	stw	zero,48(r16)
8111c350:	8080030b 	ldhu	r2,12(r16)
8111c354:	80c00417 	ldw	r3,16(r16)
8111c358:	80000115 	stw	zero,4(r16)
8111c35c:	10bdf7cc 	andi	r2,r2,63455
8111c360:	80c00015 	stw	r3,0(r16)
8111c364:	8080030d 	sth	r2,12(r16)
8111c368:	01800204 	movi	r6,8
8111c36c:	000b883a 	mov	r5,zero
8111c370:	81001704 	addi	r4,r16,92
8111c374:	111d31c0 	call	8111d31c <memset>
8111c378:	003fc806 	br	8111c29c <__reset+0xfb0fc29c>
8111c37c:	800b883a 	mov	r5,r16
8111c380:	8809883a 	mov	r4,r17
8111c384:	1125b980 	call	81125b98 <_fflush_r>
8111c388:	8080030b 	ldhu	r2,12(r16)
8111c38c:	10c4000c 	andi	r3,r2,4096
8111c390:	18008726 	beq	r3,zero,8111c5b0 <_fseeko_r+0x398>
8111c394:	84c01417 	ldw	r19,80(r16)
8111c398:	10c0010c 	andi	r3,r2,4
8111c39c:	1800431e 	bne	r3,zero,8111c4ac <_fseeko_r+0x294>
8111c3a0:	1080020c 	andi	r2,r2,8
8111c3a4:	10008026 	beq	r2,zero,8111c5a8 <_fseeko_r+0x390>
8111c3a8:	80c00017 	ldw	r3,0(r16)
8111c3ac:	80800417 	ldw	r2,16(r16)
8111c3b0:	18000226 	beq	r3,zero,8111c3bc <_fseeko_r+0x1a4>
8111c3b4:	1887c83a 	sub	r3,r3,r2
8111c3b8:	98e7883a 	add	r19,r19,r3
8111c3bc:	aceb883a 	add	r21,r21,r19
8111c3c0:	05c00044 	movi	r23,1
8111c3c4:	0025883a 	mov	r18,zero
8111c3c8:	003fc306 	br	8111c2d8 <__reset+0xfb0fc2d8>
8111c3cc:	1125f940 	call	81125f94 <__sinit>
8111c3d0:	8080030b 	ldhu	r2,12(r16)
8111c3d4:	00c04204 	movi	r3,264
8111c3d8:	1080420c 	andi	r2,r2,264
8111c3dc:	10ffa51e 	bne	r2,r3,8111c274 <__reset+0xfb0fc274>
8111c3e0:	800b883a 	mov	r5,r16
8111c3e4:	8809883a 	mov	r4,r17
8111c3e8:	1125b980 	call	81125b98 <_fflush_r>
8111c3ec:	003fa106 	br	8111c274 <__reset+0xfb0fc274>
8111c3f0:	8080030b 	ldhu	r2,12(r16)
8111c3f4:	00c10004 	movi	r3,1024
8111c3f8:	80c01315 	stw	r3,76(r16)
8111c3fc:	10c4b03a 	or	r2,r2,r3
8111c400:	8080030d 	sth	r2,12(r16)
8111c404:	9000311e 	bne	r18,zero,8111c4cc <_fseeko_r+0x2b4>
8111c408:	a82d883a 	mov	r22,r21
8111c40c:	b800371e 	bne	r23,zero,8111c4ec <_fseeko_r+0x2d4>
8111c410:	8080030b 	ldhu	r2,12(r16)
8111c414:	1084000c 	andi	r2,r2,4096
8111c418:	10007f26 	beq	r2,zero,8111c618 <_fseeko_r+0x400>
8111c41c:	80801417 	ldw	r2,80(r16)
8111c420:	81800117 	ldw	r6,4(r16)
8111c424:	81400c17 	ldw	r5,48(r16)
8111c428:	11a7c83a 	sub	r19,r2,r6
8111c42c:	28008226 	beq	r5,zero,8111c638 <_fseeko_r+0x420>
8111c430:	81c00f17 	ldw	r7,60(r16)
8111c434:	99e7c83a 	sub	r19,r19,r7
8111c438:	81000e17 	ldw	r4,56(r16)
8111c43c:	80800417 	ldw	r2,16(r16)
8111c440:	99a7883a 	add	r19,r19,r6
8111c444:	2087c83a 	sub	r3,r4,r2
8111c448:	98e7c83a 	sub	r19,r19,r3
8111c44c:	38c7883a 	add	r3,r7,r3
8111c450:	b4c02b16 	blt	r22,r19,8111c500 <_fseeko_r+0x2e8>
8111c454:	98c9883a 	add	r4,r19,r3
8111c458:	b100292e 	bgeu	r22,r4,8111c500 <_fseeko_r+0x2e8>
8111c45c:	b4e7c83a 	sub	r19,r22,r19
8111c460:	14c5883a 	add	r2,r2,r19
8111c464:	1ce7c83a 	sub	r19,r3,r19
8111c468:	80800015 	stw	r2,0(r16)
8111c46c:	84c00115 	stw	r19,4(r16)
8111c470:	28000526 	beq	r5,zero,8111c488 <_fseeko_r+0x270>
8111c474:	80801004 	addi	r2,r16,64
8111c478:	28800226 	beq	r5,r2,8111c484 <_fseeko_r+0x26c>
8111c47c:	8809883a 	mov	r4,r17
8111c480:	112642c0 	call	8112642c <_free_r>
8111c484:	80000c15 	stw	zero,48(r16)
8111c488:	8080030b 	ldhu	r2,12(r16)
8111c48c:	01800204 	movi	r6,8
8111c490:	000b883a 	mov	r5,zero
8111c494:	10bff7cc 	andi	r2,r2,65503
8111c498:	8080030d 	sth	r2,12(r16)
8111c49c:	81001704 	addi	r4,r16,92
8111c4a0:	111d31c0 	call	8111d31c <memset>
8111c4a4:	0027883a 	mov	r19,zero
8111c4a8:	003f7c06 	br	8111c29c <__reset+0xfb0fc29c>
8111c4ac:	80c00117 	ldw	r3,4(r16)
8111c4b0:	80800c17 	ldw	r2,48(r16)
8111c4b4:	98e7c83a 	sub	r19,r19,r3
8111c4b8:	10003b26 	beq	r2,zero,8111c5a8 <_fseeko_r+0x390>
8111c4bc:	80c00f17 	ldw	r3,60(r16)
8111c4c0:	80800417 	ldw	r2,16(r16)
8111c4c4:	98e7c83a 	sub	r19,r19,r3
8111c4c8:	003fbc06 	br	8111c3bc <__reset+0xfb0fc3bc>
8111c4cc:	8140038f 	ldh	r5,14(r16)
8111c4d0:	d80d883a 	mov	r6,sp
8111c4d4:	8809883a 	mov	r4,r17
8111c4d8:	111c6800 	call	8111c680 <_fstat_r>
8111c4dc:	103f891e 	bne	r2,zero,8111c304 <__reset+0xfb0fc304>
8111c4e0:	dd800417 	ldw	r22,16(sp)
8111c4e4:	adad883a 	add	r22,r21,r22
8111c4e8:	b83fc926 	beq	r23,zero,8111c410 <__reset+0xfb0fc410>
8111c4ec:	81400c17 	ldw	r5,48(r16)
8111c4f0:	81800117 	ldw	r6,4(r16)
8111c4f4:	28005026 	beq	r5,zero,8111c638 <_fseeko_r+0x420>
8111c4f8:	81c00f17 	ldw	r7,60(r16)
8111c4fc:	003fce06 	br	8111c438 <__reset+0xfb0fc438>
8111c500:	84c01317 	ldw	r19,76(r16)
8111c504:	81400717 	ldw	r5,28(r16)
8111c508:	000f883a 	mov	r7,zero
8111c50c:	04e7c83a 	sub	r19,zero,r19
8111c510:	9da6703a 	and	r19,r19,r22
8111c514:	980d883a 	mov	r6,r19
8111c518:	8809883a 	mov	r4,r17
8111c51c:	a03ee83a 	callr	r20
8111c520:	00ffffc4 	movi	r3,-1
8111c524:	10ff7726 	beq	r2,r3,8111c304 <__reset+0xfb0fc304>
8111c528:	80800417 	ldw	r2,16(r16)
8111c52c:	81400c17 	ldw	r5,48(r16)
8111c530:	80000115 	stw	zero,4(r16)
8111c534:	80800015 	stw	r2,0(r16)
8111c538:	28000526 	beq	r5,zero,8111c550 <_fseeko_r+0x338>
8111c53c:	80801004 	addi	r2,r16,64
8111c540:	28800226 	beq	r5,r2,8111c54c <_fseeko_r+0x334>
8111c544:	8809883a 	mov	r4,r17
8111c548:	112642c0 	call	8112642c <_free_r>
8111c54c:	80000c15 	stw	zero,48(r16)
8111c550:	8080030b 	ldhu	r2,12(r16)
8111c554:	b4e7c83a 	sub	r19,r22,r19
8111c558:	10bff7cc 	andi	r2,r2,65503
8111c55c:	8080030d 	sth	r2,12(r16)
8111c560:	98000b26 	beq	r19,zero,8111c590 <_fseeko_r+0x378>
8111c564:	800b883a 	mov	r5,r16
8111c568:	8809883a 	mov	r4,r17
8111c56c:	111d7980 	call	8111d798 <__srefill_r>
8111c570:	103f641e 	bne	r2,zero,8111c304 <__reset+0xfb0fc304>
8111c574:	80800117 	ldw	r2,4(r16)
8111c578:	14ff6236 	bltu	r2,r19,8111c304 <__reset+0xfb0fc304>
8111c57c:	80c00017 	ldw	r3,0(r16)
8111c580:	14c5c83a 	sub	r2,r2,r19
8111c584:	80800115 	stw	r2,4(r16)
8111c588:	1ce7883a 	add	r19,r3,r19
8111c58c:	84c00015 	stw	r19,0(r16)
8111c590:	01800204 	movi	r6,8
8111c594:	000b883a 	mov	r5,zero
8111c598:	81001704 	addi	r4,r16,92
8111c59c:	111d31c0 	call	8111d31c <memset>
8111c5a0:	0027883a 	mov	r19,zero
8111c5a4:	003f3d06 	br	8111c29c <__reset+0xfb0fc29c>
8111c5a8:	80800417 	ldw	r2,16(r16)
8111c5ac:	003f8306 	br	8111c3bc <__reset+0xfb0fc3bc>
8111c5b0:	81400717 	ldw	r5,28(r16)
8111c5b4:	900f883a 	mov	r7,r18
8111c5b8:	000d883a 	mov	r6,zero
8111c5bc:	8809883a 	mov	r4,r17
8111c5c0:	a03ee83a 	callr	r20
8111c5c4:	1027883a 	mov	r19,r2
8111c5c8:	00bfffc4 	movi	r2,-1
8111c5cc:	98bf3226 	beq	r19,r2,8111c298 <__reset+0xfb0fc298>
8111c5d0:	8080030b 	ldhu	r2,12(r16)
8111c5d4:	003f7006 	br	8111c398 <__reset+0xfb0fc398>
8111c5d8:	8140038f 	ldh	r5,14(r16)
8111c5dc:	283f4716 	blt	r5,zero,8111c2fc <__reset+0xfb0fc2fc>
8111c5e0:	d80d883a 	mov	r6,sp
8111c5e4:	8809883a 	mov	r4,r17
8111c5e8:	111c6800 	call	8111c680 <_fstat_r>
8111c5ec:	1000041e 	bne	r2,zero,8111c600 <_fseeko_r+0x3e8>
8111c5f0:	d8800117 	ldw	r2,4(sp)
8111c5f4:	00e00014 	movui	r3,32768
8111c5f8:	10bc000c 	andi	r2,r2,61440
8111c5fc:	10ff7c26 	beq	r2,r3,8111c3f0 <__reset+0xfb0fc3f0>
8111c600:	8080030b 	ldhu	r2,12(r16)
8111c604:	003f3d06 	br	8111c2fc <__reset+0xfb0fc2fc>
8111c608:	800b883a 	mov	r5,r16
8111c60c:	8809883a 	mov	r4,r17
8111c610:	111c7f40 	call	8111c7f4 <__smakebuf_r>
8111c614:	003f3106 	br	8111c2dc <__reset+0xfb0fc2dc>
8111c618:	81400717 	ldw	r5,28(r16)
8111c61c:	01c00044 	movi	r7,1
8111c620:	000d883a 	mov	r6,zero
8111c624:	8809883a 	mov	r4,r17
8111c628:	a03ee83a 	callr	r20
8111c62c:	00ffffc4 	movi	r3,-1
8111c630:	10ff7b1e 	bne	r2,r3,8111c420 <__reset+0xfb0fc420>
8111c634:	003f3306 	br	8111c304 <__reset+0xfb0fc304>
8111c638:	80c00017 	ldw	r3,0(r16)
8111c63c:	80800417 	ldw	r2,16(r16)
8111c640:	000b883a 	mov	r5,zero
8111c644:	1887c83a 	sub	r3,r3,r2
8111c648:	98e7c83a 	sub	r19,r19,r3
8111c64c:	30c7883a 	add	r3,r6,r3
8111c650:	003f7f06 	br	8111c450 <__reset+0xfb0fc450>
8111c654:	00800744 	movi	r2,29
8111c658:	88800015 	stw	r2,0(r17)
8111c65c:	04ffffc4 	movi	r19,-1
8111c660:	003f0e06 	br	8111c29c <__reset+0xfb0fc29c>

8111c664 <fseeko>:
8111c664:	00a04574 	movhi	r2,33045
8111c668:	10b7d604 	addi	r2,r2,-8360
8111c66c:	300f883a 	mov	r7,r6
8111c670:	280d883a 	mov	r6,r5
8111c674:	200b883a 	mov	r5,r4
8111c678:	11000017 	ldw	r4,0(r2)
8111c67c:	111c2181 	jmpi	8111c218 <_fseeko_r>

8111c680 <_fstat_r>:
8111c680:	defffd04 	addi	sp,sp,-12
8111c684:	de00012e 	bgeu	sp,et,8111c68c <_fstat_r+0xc>
8111c688:	003b68fa 	trap	3
8111c68c:	2805883a 	mov	r2,r5
8111c690:	dc000015 	stw	r16,0(sp)
8111c694:	04204574 	movhi	r16,33045
8111c698:	dc400115 	stw	r17,4(sp)
8111c69c:	84384404 	addi	r16,r16,-7920
8111c6a0:	2023883a 	mov	r17,r4
8111c6a4:	300b883a 	mov	r5,r6
8111c6a8:	1009883a 	mov	r4,r2
8111c6ac:	dfc00215 	stw	ra,8(sp)
8111c6b0:	80000015 	stw	zero,0(r16)
8111c6b4:	1131c6c0 	call	81131c6c <fstat>
8111c6b8:	00ffffc4 	movi	r3,-1
8111c6bc:	10c00526 	beq	r2,r3,8111c6d4 <_fstat_r+0x54>
8111c6c0:	dfc00217 	ldw	ra,8(sp)
8111c6c4:	dc400117 	ldw	r17,4(sp)
8111c6c8:	dc000017 	ldw	r16,0(sp)
8111c6cc:	dec00304 	addi	sp,sp,12
8111c6d0:	f800283a 	ret
8111c6d4:	80c00017 	ldw	r3,0(r16)
8111c6d8:	183ff926 	beq	r3,zero,8111c6c0 <__reset+0xfb0fc6c0>
8111c6dc:	88c00015 	stw	r3,0(r17)
8111c6e0:	003ff706 	br	8111c6c0 <__reset+0xfb0fc6c0>

8111c6e4 <_fwrite_r>:
8111c6e4:	defff504 	addi	sp,sp,-44
8111c6e8:	de00012e 	bgeu	sp,et,8111c6f0 <_fwrite_r+0xc>
8111c6ec:	003b68fa 	trap	3
8111c6f0:	dc800815 	stw	r18,32(sp)
8111c6f4:	39a5383a 	mul	r18,r7,r6
8111c6f8:	d8800304 	addi	r2,sp,12
8111c6fc:	d8800015 	stw	r2,0(sp)
8111c700:	00800044 	movi	r2,1
8111c704:	dcc00915 	stw	r19,36(sp)
8111c708:	dc400715 	stw	r17,28(sp)
8111c70c:	dc000615 	stw	r16,24(sp)
8111c710:	d9400315 	stw	r5,12(sp)
8111c714:	dfc00a15 	stw	ra,40(sp)
8111c718:	dc800415 	stw	r18,16(sp)
8111c71c:	dc800215 	stw	r18,8(sp)
8111c720:	d8800115 	stw	r2,4(sp)
8111c724:	3027883a 	mov	r19,r6
8111c728:	3821883a 	mov	r16,r7
8111c72c:	2023883a 	mov	r17,r4
8111c730:	d9400b17 	ldw	r5,44(sp)
8111c734:	20000226 	beq	r4,zero,8111c740 <_fwrite_r+0x5c>
8111c738:	20800e17 	ldw	r2,56(r4)
8111c73c:	10001a26 	beq	r2,zero,8111c7a8 <_fwrite_r+0xc4>
8111c740:	2880030b 	ldhu	r2,12(r5)
8111c744:	10c8000c 	andi	r3,r2,8192
8111c748:	1800061e 	bne	r3,zero,8111c764 <_fwrite_r+0x80>
8111c74c:	29001917 	ldw	r4,100(r5)
8111c750:	00f7ffc4 	movi	r3,-8193
8111c754:	10880014 	ori	r2,r2,8192
8111c758:	20c6703a 	and	r3,r4,r3
8111c75c:	2880030d 	sth	r2,12(r5)
8111c760:	28c01915 	stw	r3,100(r5)
8111c764:	d80d883a 	mov	r6,sp
8111c768:	8809883a 	mov	r4,r17
8111c76c:	11267440 	call	81126744 <__sfvwrite_r>
8111c770:	10000b26 	beq	r2,zero,8111c7a0 <_fwrite_r+0xbc>
8111c774:	d9000217 	ldw	r4,8(sp)
8111c778:	980b883a 	mov	r5,r19
8111c77c:	9109c83a 	sub	r4,r18,r4
8111c780:	112f7b40 	call	8112f7b4 <__udivsi3>
8111c784:	dfc00a17 	ldw	ra,40(sp)
8111c788:	dcc00917 	ldw	r19,36(sp)
8111c78c:	dc800817 	ldw	r18,32(sp)
8111c790:	dc400717 	ldw	r17,28(sp)
8111c794:	dc000617 	ldw	r16,24(sp)
8111c798:	dec00b04 	addi	sp,sp,44
8111c79c:	f800283a 	ret
8111c7a0:	8005883a 	mov	r2,r16
8111c7a4:	003ff706 	br	8111c784 <__reset+0xfb0fc784>
8111c7a8:	d9400515 	stw	r5,20(sp)
8111c7ac:	1125f940 	call	81125f94 <__sinit>
8111c7b0:	d9400517 	ldw	r5,20(sp)
8111c7b4:	003fe206 	br	8111c740 <__reset+0xfb0fc740>

8111c7b8 <fwrite>:
8111c7b8:	defffe04 	addi	sp,sp,-8
8111c7bc:	00a04574 	movhi	r2,33045
8111c7c0:	de00012e 	bgeu	sp,et,8111c7c8 <fwrite+0x10>
8111c7c4:	003b68fa 	trap	3
8111c7c8:	10b7d604 	addi	r2,r2,-8360
8111c7cc:	d9c00015 	stw	r7,0(sp)
8111c7d0:	300f883a 	mov	r7,r6
8111c7d4:	280d883a 	mov	r6,r5
8111c7d8:	200b883a 	mov	r5,r4
8111c7dc:	11000017 	ldw	r4,0(r2)
8111c7e0:	dfc00115 	stw	ra,4(sp)
8111c7e4:	111c6e40 	call	8111c6e4 <_fwrite_r>
8111c7e8:	dfc00117 	ldw	ra,4(sp)
8111c7ec:	dec00204 	addi	sp,sp,8
8111c7f0:	f800283a 	ret

8111c7f4 <__smakebuf_r>:
8111c7f4:	2880030b 	ldhu	r2,12(r5)
8111c7f8:	10c0008c 	andi	r3,r2,2
8111c7fc:	1800431e 	bne	r3,zero,8111c90c <__smakebuf_r+0x118>
8111c800:	deffec04 	addi	sp,sp,-80
8111c804:	de00012e 	bgeu	sp,et,8111c80c <__smakebuf_r+0x18>
8111c808:	003b68fa 	trap	3
8111c80c:	dc000f15 	stw	r16,60(sp)
8111c810:	2821883a 	mov	r16,r5
8111c814:	2940038f 	ldh	r5,14(r5)
8111c818:	dc401015 	stw	r17,64(sp)
8111c81c:	dfc01315 	stw	ra,76(sp)
8111c820:	dcc01215 	stw	r19,72(sp)
8111c824:	dc801115 	stw	r18,68(sp)
8111c828:	2023883a 	mov	r17,r4
8111c82c:	28001c16 	blt	r5,zero,8111c8a0 <__smakebuf_r+0xac>
8111c830:	d80d883a 	mov	r6,sp
8111c834:	111c6800 	call	8111c680 <_fstat_r>
8111c838:	10001816 	blt	r2,zero,8111c89c <__smakebuf_r+0xa8>
8111c83c:	d8800117 	ldw	r2,4(sp)
8111c840:	00e00014 	movui	r3,32768
8111c844:	10bc000c 	andi	r2,r2,61440
8111c848:	14c80020 	cmpeqi	r19,r2,8192
8111c84c:	10c03726 	beq	r2,r3,8111c92c <__smakebuf_r+0x138>
8111c850:	80c0030b 	ldhu	r3,12(r16)
8111c854:	18c20014 	ori	r3,r3,2048
8111c858:	80c0030d 	sth	r3,12(r16)
8111c85c:	00c80004 	movi	r3,8192
8111c860:	10c0521e 	bne	r2,r3,8111c9ac <__smakebuf_r+0x1b8>
8111c864:	8140038f 	ldh	r5,14(r16)
8111c868:	8809883a 	mov	r4,r17
8111c86c:	1126da00 	call	81126da0 <_isatty_r>
8111c870:	10004c26 	beq	r2,zero,8111c9a4 <__smakebuf_r+0x1b0>
8111c874:	8080030b 	ldhu	r2,12(r16)
8111c878:	80c010c4 	addi	r3,r16,67
8111c87c:	80c00015 	stw	r3,0(r16)
8111c880:	10800054 	ori	r2,r2,1
8111c884:	8080030d 	sth	r2,12(r16)
8111c888:	00800044 	movi	r2,1
8111c88c:	80c00415 	stw	r3,16(r16)
8111c890:	80800515 	stw	r2,20(r16)
8111c894:	04810004 	movi	r18,1024
8111c898:	00000706 	br	8111c8b8 <__smakebuf_r+0xc4>
8111c89c:	8080030b 	ldhu	r2,12(r16)
8111c8a0:	10c0200c 	andi	r3,r2,128
8111c8a4:	18001f1e 	bne	r3,zero,8111c924 <__smakebuf_r+0x130>
8111c8a8:	04810004 	movi	r18,1024
8111c8ac:	10820014 	ori	r2,r2,2048
8111c8b0:	8080030d 	sth	r2,12(r16)
8111c8b4:	0027883a 	mov	r19,zero
8111c8b8:	900b883a 	mov	r5,r18
8111c8bc:	8809883a 	mov	r4,r17
8111c8c0:	111c9b80 	call	8111c9b8 <_malloc_r>
8111c8c4:	10002c26 	beq	r2,zero,8111c978 <__smakebuf_r+0x184>
8111c8c8:	80c0030b 	ldhu	r3,12(r16)
8111c8cc:	012044b4 	movhi	r4,33042
8111c8d0:	21170d04 	addi	r4,r4,23604
8111c8d4:	89000f15 	stw	r4,60(r17)
8111c8d8:	18c02014 	ori	r3,r3,128
8111c8dc:	80c0030d 	sth	r3,12(r16)
8111c8e0:	80800015 	stw	r2,0(r16)
8111c8e4:	80800415 	stw	r2,16(r16)
8111c8e8:	84800515 	stw	r18,20(r16)
8111c8ec:	98001a1e 	bne	r19,zero,8111c958 <__smakebuf_r+0x164>
8111c8f0:	dfc01317 	ldw	ra,76(sp)
8111c8f4:	dcc01217 	ldw	r19,72(sp)
8111c8f8:	dc801117 	ldw	r18,68(sp)
8111c8fc:	dc401017 	ldw	r17,64(sp)
8111c900:	dc000f17 	ldw	r16,60(sp)
8111c904:	dec01404 	addi	sp,sp,80
8111c908:	f800283a 	ret
8111c90c:	288010c4 	addi	r2,r5,67
8111c910:	28800015 	stw	r2,0(r5)
8111c914:	28800415 	stw	r2,16(r5)
8111c918:	00800044 	movi	r2,1
8111c91c:	28800515 	stw	r2,20(r5)
8111c920:	f800283a 	ret
8111c924:	04801004 	movi	r18,64
8111c928:	003fe006 	br	8111c8ac <__reset+0xfb0fc8ac>
8111c92c:	81000a17 	ldw	r4,40(r16)
8111c930:	00e044b4 	movhi	r3,33042
8111c934:	18f70204 	addi	r3,r3,-9208
8111c938:	20ffc51e 	bne	r4,r3,8111c850 <__reset+0xfb0fc850>
8111c93c:	8080030b 	ldhu	r2,12(r16)
8111c940:	04810004 	movi	r18,1024
8111c944:	84801315 	stw	r18,76(r16)
8111c948:	1484b03a 	or	r2,r2,r18
8111c94c:	8080030d 	sth	r2,12(r16)
8111c950:	0027883a 	mov	r19,zero
8111c954:	003fd806 	br	8111c8b8 <__reset+0xfb0fc8b8>
8111c958:	8140038f 	ldh	r5,14(r16)
8111c95c:	8809883a 	mov	r4,r17
8111c960:	1126da00 	call	81126da0 <_isatty_r>
8111c964:	103fe226 	beq	r2,zero,8111c8f0 <__reset+0xfb0fc8f0>
8111c968:	8080030b 	ldhu	r2,12(r16)
8111c96c:	10800054 	ori	r2,r2,1
8111c970:	8080030d 	sth	r2,12(r16)
8111c974:	003fde06 	br	8111c8f0 <__reset+0xfb0fc8f0>
8111c978:	8080030b 	ldhu	r2,12(r16)
8111c97c:	10c0800c 	andi	r3,r2,512
8111c980:	183fdb1e 	bne	r3,zero,8111c8f0 <__reset+0xfb0fc8f0>
8111c984:	10800094 	ori	r2,r2,2
8111c988:	80c010c4 	addi	r3,r16,67
8111c98c:	8080030d 	sth	r2,12(r16)
8111c990:	00800044 	movi	r2,1
8111c994:	80c00015 	stw	r3,0(r16)
8111c998:	80c00415 	stw	r3,16(r16)
8111c99c:	80800515 	stw	r2,20(r16)
8111c9a0:	003fd306 	br	8111c8f0 <__reset+0xfb0fc8f0>
8111c9a4:	04810004 	movi	r18,1024
8111c9a8:	003fc306 	br	8111c8b8 <__reset+0xfb0fc8b8>
8111c9ac:	0027883a 	mov	r19,zero
8111c9b0:	04810004 	movi	r18,1024
8111c9b4:	003fc006 	br	8111c8b8 <__reset+0xfb0fc8b8>

8111c9b8 <_malloc_r>:
8111c9b8:	defff504 	addi	sp,sp,-44
8111c9bc:	de00012e 	bgeu	sp,et,8111c9c4 <_malloc_r+0xc>
8111c9c0:	003b68fa 	trap	3
8111c9c4:	288002c4 	addi	r2,r5,11
8111c9c8:	dc800315 	stw	r18,12(sp)
8111c9cc:	dfc00a15 	stw	ra,40(sp)
8111c9d0:	df000915 	stw	fp,36(sp)
8111c9d4:	ddc00815 	stw	r23,32(sp)
8111c9d8:	dd800715 	stw	r22,28(sp)
8111c9dc:	dd400615 	stw	r21,24(sp)
8111c9e0:	dd000515 	stw	r20,20(sp)
8111c9e4:	dcc00415 	stw	r19,16(sp)
8111c9e8:	dc400215 	stw	r17,8(sp)
8111c9ec:	dc000115 	stw	r16,4(sp)
8111c9f0:	00c00584 	movi	r3,22
8111c9f4:	2025883a 	mov	r18,r4
8111c9f8:	18807f2e 	bgeu	r3,r2,8111cbf8 <_malloc_r+0x240>
8111c9fc:	047ffe04 	movi	r17,-8
8111ca00:	1462703a 	and	r17,r2,r17
8111ca04:	8800a316 	blt	r17,zero,8111cc94 <_malloc_r+0x2dc>
8111ca08:	8940a236 	bltu	r17,r5,8111cc94 <_malloc_r+0x2dc>
8111ca0c:	11337b40 	call	811337b4 <__malloc_lock>
8111ca10:	00807dc4 	movi	r2,503
8111ca14:	1441e92e 	bgeu	r2,r17,8111d1bc <_malloc_r+0x804>
8111ca18:	8804d27a 	srli	r2,r17,9
8111ca1c:	1000a126 	beq	r2,zero,8111cca4 <_malloc_r+0x2ec>
8111ca20:	00c00104 	movi	r3,4
8111ca24:	18811e36 	bltu	r3,r2,8111cea0 <_malloc_r+0x4e8>
8111ca28:	8804d1ba 	srli	r2,r17,6
8111ca2c:	12000e44 	addi	r8,r2,57
8111ca30:	11c00e04 	addi	r7,r2,56
8111ca34:	4209883a 	add	r4,r8,r8
8111ca38:	04e04574 	movhi	r19,33045
8111ca3c:	2109883a 	add	r4,r4,r4
8111ca40:	9cf19404 	addi	r19,r19,-14768
8111ca44:	2109883a 	add	r4,r4,r4
8111ca48:	9909883a 	add	r4,r19,r4
8111ca4c:	24000117 	ldw	r16,4(r4)
8111ca50:	213ffe04 	addi	r4,r4,-8
8111ca54:	24009726 	beq	r4,r16,8111ccb4 <_malloc_r+0x2fc>
8111ca58:	80800117 	ldw	r2,4(r16)
8111ca5c:	01bfff04 	movi	r6,-4
8111ca60:	014003c4 	movi	r5,15
8111ca64:	1184703a 	and	r2,r2,r6
8111ca68:	1447c83a 	sub	r3,r2,r17
8111ca6c:	28c00716 	blt	r5,r3,8111ca8c <_malloc_r+0xd4>
8111ca70:	1800920e 	bge	r3,zero,8111ccbc <_malloc_r+0x304>
8111ca74:	84000317 	ldw	r16,12(r16)
8111ca78:	24008e26 	beq	r4,r16,8111ccb4 <_malloc_r+0x2fc>
8111ca7c:	80800117 	ldw	r2,4(r16)
8111ca80:	1184703a 	and	r2,r2,r6
8111ca84:	1447c83a 	sub	r3,r2,r17
8111ca88:	28fff90e 	bge	r5,r3,8111ca70 <__reset+0xfb0fca70>
8111ca8c:	3809883a 	mov	r4,r7
8111ca90:	01a04574 	movhi	r6,33045
8111ca94:	9c000417 	ldw	r16,16(r19)
8111ca98:	31b19404 	addi	r6,r6,-14768
8111ca9c:	32000204 	addi	r8,r6,8
8111caa0:	82013426 	beq	r16,r8,8111cf74 <_malloc_r+0x5bc>
8111caa4:	80c00117 	ldw	r3,4(r16)
8111caa8:	00bfff04 	movi	r2,-4
8111caac:	188e703a 	and	r7,r3,r2
8111cab0:	3c45c83a 	sub	r2,r7,r17
8111cab4:	00c003c4 	movi	r3,15
8111cab8:	18811f16 	blt	r3,r2,8111cf38 <_malloc_r+0x580>
8111cabc:	32000515 	stw	r8,20(r6)
8111cac0:	32000415 	stw	r8,16(r6)
8111cac4:	10007f0e 	bge	r2,zero,8111ccc4 <_malloc_r+0x30c>
8111cac8:	00807fc4 	movi	r2,511
8111cacc:	11c0fd36 	bltu	r2,r7,8111cec4 <_malloc_r+0x50c>
8111cad0:	3806d0fa 	srli	r3,r7,3
8111cad4:	01c00044 	movi	r7,1
8111cad8:	30800117 	ldw	r2,4(r6)
8111cadc:	19400044 	addi	r5,r3,1
8111cae0:	294b883a 	add	r5,r5,r5
8111cae4:	1807d0ba 	srai	r3,r3,2
8111cae8:	294b883a 	add	r5,r5,r5
8111caec:	294b883a 	add	r5,r5,r5
8111caf0:	298b883a 	add	r5,r5,r6
8111caf4:	38c6983a 	sll	r3,r7,r3
8111caf8:	29c00017 	ldw	r7,0(r5)
8111cafc:	2a7ffe04 	addi	r9,r5,-8
8111cb00:	1886b03a 	or	r3,r3,r2
8111cb04:	82400315 	stw	r9,12(r16)
8111cb08:	81c00215 	stw	r7,8(r16)
8111cb0c:	30c00115 	stw	r3,4(r6)
8111cb10:	2c000015 	stw	r16,0(r5)
8111cb14:	3c000315 	stw	r16,12(r7)
8111cb18:	2005d0ba 	srai	r2,r4,2
8111cb1c:	01400044 	movi	r5,1
8111cb20:	288a983a 	sll	r5,r5,r2
8111cb24:	19406f36 	bltu	r3,r5,8111cce4 <_malloc_r+0x32c>
8111cb28:	28c4703a 	and	r2,r5,r3
8111cb2c:	10000a1e 	bne	r2,zero,8111cb58 <_malloc_r+0x1a0>
8111cb30:	00bfff04 	movi	r2,-4
8111cb34:	294b883a 	add	r5,r5,r5
8111cb38:	2088703a 	and	r4,r4,r2
8111cb3c:	28c4703a 	and	r2,r5,r3
8111cb40:	21000104 	addi	r4,r4,4
8111cb44:	1000041e 	bne	r2,zero,8111cb58 <_malloc_r+0x1a0>
8111cb48:	294b883a 	add	r5,r5,r5
8111cb4c:	28c4703a 	and	r2,r5,r3
8111cb50:	21000104 	addi	r4,r4,4
8111cb54:	103ffc26 	beq	r2,zero,8111cb48 <__reset+0xfb0fcb48>
8111cb58:	02bfff04 	movi	r10,-4
8111cb5c:	024003c4 	movi	r9,15
8111cb60:	21800044 	addi	r6,r4,1
8111cb64:	318d883a 	add	r6,r6,r6
8111cb68:	318d883a 	add	r6,r6,r6
8111cb6c:	318d883a 	add	r6,r6,r6
8111cb70:	998d883a 	add	r6,r19,r6
8111cb74:	333ffe04 	addi	r12,r6,-8
8111cb78:	2017883a 	mov	r11,r4
8111cb7c:	31800104 	addi	r6,r6,4
8111cb80:	34000017 	ldw	r16,0(r6)
8111cb84:	31fffd04 	addi	r7,r6,-12
8111cb88:	81c0041e 	bne	r16,r7,8111cb9c <_malloc_r+0x1e4>
8111cb8c:	0000fb06 	br	8111cf7c <_malloc_r+0x5c4>
8111cb90:	1801030e 	bge	r3,zero,8111cfa0 <_malloc_r+0x5e8>
8111cb94:	84000317 	ldw	r16,12(r16)
8111cb98:	81c0f826 	beq	r16,r7,8111cf7c <_malloc_r+0x5c4>
8111cb9c:	80800117 	ldw	r2,4(r16)
8111cba0:	1284703a 	and	r2,r2,r10
8111cba4:	1447c83a 	sub	r3,r2,r17
8111cba8:	48fff90e 	bge	r9,r3,8111cb90 <__reset+0xfb0fcb90>
8111cbac:	80800317 	ldw	r2,12(r16)
8111cbb0:	81000217 	ldw	r4,8(r16)
8111cbb4:	89400054 	ori	r5,r17,1
8111cbb8:	81400115 	stw	r5,4(r16)
8111cbbc:	20800315 	stw	r2,12(r4)
8111cbc0:	11000215 	stw	r4,8(r2)
8111cbc4:	8463883a 	add	r17,r16,r17
8111cbc8:	9c400515 	stw	r17,20(r19)
8111cbcc:	9c400415 	stw	r17,16(r19)
8111cbd0:	18800054 	ori	r2,r3,1
8111cbd4:	88800115 	stw	r2,4(r17)
8111cbd8:	8a000315 	stw	r8,12(r17)
8111cbdc:	8a000215 	stw	r8,8(r17)
8111cbe0:	88e3883a 	add	r17,r17,r3
8111cbe4:	88c00015 	stw	r3,0(r17)
8111cbe8:	9009883a 	mov	r4,r18
8111cbec:	11338dc0 	call	811338dc <__malloc_unlock>
8111cbf0:	80800204 	addi	r2,r16,8
8111cbf4:	00001b06 	br	8111cc64 <_malloc_r+0x2ac>
8111cbf8:	04400404 	movi	r17,16
8111cbfc:	89402536 	bltu	r17,r5,8111cc94 <_malloc_r+0x2dc>
8111cc00:	11337b40 	call	811337b4 <__malloc_lock>
8111cc04:	00800184 	movi	r2,6
8111cc08:	01000084 	movi	r4,2
8111cc0c:	04e04574 	movhi	r19,33045
8111cc10:	1085883a 	add	r2,r2,r2
8111cc14:	9cf19404 	addi	r19,r19,-14768
8111cc18:	1085883a 	add	r2,r2,r2
8111cc1c:	9885883a 	add	r2,r19,r2
8111cc20:	14000117 	ldw	r16,4(r2)
8111cc24:	10fffe04 	addi	r3,r2,-8
8111cc28:	80c0d926 	beq	r16,r3,8111cf90 <_malloc_r+0x5d8>
8111cc2c:	80c00117 	ldw	r3,4(r16)
8111cc30:	81000317 	ldw	r4,12(r16)
8111cc34:	00bfff04 	movi	r2,-4
8111cc38:	1884703a 	and	r2,r3,r2
8111cc3c:	81400217 	ldw	r5,8(r16)
8111cc40:	8085883a 	add	r2,r16,r2
8111cc44:	10c00117 	ldw	r3,4(r2)
8111cc48:	29000315 	stw	r4,12(r5)
8111cc4c:	21400215 	stw	r5,8(r4)
8111cc50:	18c00054 	ori	r3,r3,1
8111cc54:	10c00115 	stw	r3,4(r2)
8111cc58:	9009883a 	mov	r4,r18
8111cc5c:	11338dc0 	call	811338dc <__malloc_unlock>
8111cc60:	80800204 	addi	r2,r16,8
8111cc64:	dfc00a17 	ldw	ra,40(sp)
8111cc68:	df000917 	ldw	fp,36(sp)
8111cc6c:	ddc00817 	ldw	r23,32(sp)
8111cc70:	dd800717 	ldw	r22,28(sp)
8111cc74:	dd400617 	ldw	r21,24(sp)
8111cc78:	dd000517 	ldw	r20,20(sp)
8111cc7c:	dcc00417 	ldw	r19,16(sp)
8111cc80:	dc800317 	ldw	r18,12(sp)
8111cc84:	dc400217 	ldw	r17,8(sp)
8111cc88:	dc000117 	ldw	r16,4(sp)
8111cc8c:	dec00b04 	addi	sp,sp,44
8111cc90:	f800283a 	ret
8111cc94:	00800304 	movi	r2,12
8111cc98:	90800015 	stw	r2,0(r18)
8111cc9c:	0005883a 	mov	r2,zero
8111cca0:	003ff006 	br	8111cc64 <__reset+0xfb0fcc64>
8111cca4:	01002004 	movi	r4,128
8111cca8:	02001004 	movi	r8,64
8111ccac:	01c00fc4 	movi	r7,63
8111ccb0:	003f6106 	br	8111ca38 <__reset+0xfb0fca38>
8111ccb4:	4009883a 	mov	r4,r8
8111ccb8:	003f7506 	br	8111ca90 <__reset+0xfb0fca90>
8111ccbc:	81000317 	ldw	r4,12(r16)
8111ccc0:	003fde06 	br	8111cc3c <__reset+0xfb0fcc3c>
8111ccc4:	81c5883a 	add	r2,r16,r7
8111ccc8:	11400117 	ldw	r5,4(r2)
8111cccc:	9009883a 	mov	r4,r18
8111ccd0:	29400054 	ori	r5,r5,1
8111ccd4:	11400115 	stw	r5,4(r2)
8111ccd8:	11338dc0 	call	811338dc <__malloc_unlock>
8111ccdc:	80800204 	addi	r2,r16,8
8111cce0:	003fe006 	br	8111cc64 <__reset+0xfb0fcc64>
8111cce4:	9c000217 	ldw	r16,8(r19)
8111cce8:	00bfff04 	movi	r2,-4
8111ccec:	85800117 	ldw	r22,4(r16)
8111ccf0:	b0ac703a 	and	r22,r22,r2
8111ccf4:	b4400336 	bltu	r22,r17,8111cd04 <_malloc_r+0x34c>
8111ccf8:	b445c83a 	sub	r2,r22,r17
8111ccfc:	00c003c4 	movi	r3,15
8111cd00:	18805d16 	blt	r3,r2,8111ce78 <_malloc_r+0x4c0>
8111cd04:	05e04574 	movhi	r23,33045
8111cd08:	00a04574 	movhi	r2,33045
8111cd0c:	10b84704 	addi	r2,r2,-7908
8111cd10:	bdf7d704 	addi	r23,r23,-8356
8111cd14:	15400017 	ldw	r21,0(r2)
8111cd18:	b8c00017 	ldw	r3,0(r23)
8111cd1c:	00bfffc4 	movi	r2,-1
8111cd20:	858d883a 	add	r6,r16,r22
8111cd24:	8d6b883a 	add	r21,r17,r21
8111cd28:	1880ea26 	beq	r3,r2,8111d0d4 <_malloc_r+0x71c>
8111cd2c:	ad4403c4 	addi	r21,r21,4111
8111cd30:	00bc0004 	movi	r2,-4096
8111cd34:	a8aa703a 	and	r21,r21,r2
8111cd38:	a80b883a 	mov	r5,r21
8111cd3c:	9009883a 	mov	r4,r18
8111cd40:	d9800015 	stw	r6,0(sp)
8111cd44:	111d9740 	call	8111d974 <_sbrk_r>
8111cd48:	1029883a 	mov	r20,r2
8111cd4c:	00bfffc4 	movi	r2,-1
8111cd50:	d9800017 	ldw	r6,0(sp)
8111cd54:	a080e826 	beq	r20,r2,8111d0f8 <_malloc_r+0x740>
8111cd58:	a180a636 	bltu	r20,r6,8111cff4 <_malloc_r+0x63c>
8111cd5c:	07204574 	movhi	fp,33045
8111cd60:	e738d404 	addi	fp,fp,-7344
8111cd64:	e0800017 	ldw	r2,0(fp)
8111cd68:	a887883a 	add	r3,r21,r2
8111cd6c:	e0c00015 	stw	r3,0(fp)
8111cd70:	3500e626 	beq	r6,r20,8111d10c <_malloc_r+0x754>
8111cd74:	b9000017 	ldw	r4,0(r23)
8111cd78:	00bfffc4 	movi	r2,-1
8111cd7c:	2080ee26 	beq	r4,r2,8111d138 <_malloc_r+0x780>
8111cd80:	a185c83a 	sub	r2,r20,r6
8111cd84:	10c5883a 	add	r2,r2,r3
8111cd88:	e0800015 	stw	r2,0(fp)
8111cd8c:	a0c001cc 	andi	r3,r20,7
8111cd90:	1800bc26 	beq	r3,zero,8111d084 <_malloc_r+0x6cc>
8111cd94:	a0e9c83a 	sub	r20,r20,r3
8111cd98:	00840204 	movi	r2,4104
8111cd9c:	a5000204 	addi	r20,r20,8
8111cda0:	10c7c83a 	sub	r3,r2,r3
8111cda4:	a545883a 	add	r2,r20,r21
8111cda8:	1083ffcc 	andi	r2,r2,4095
8111cdac:	18abc83a 	sub	r21,r3,r2
8111cdb0:	a80b883a 	mov	r5,r21
8111cdb4:	9009883a 	mov	r4,r18
8111cdb8:	111d9740 	call	8111d974 <_sbrk_r>
8111cdbc:	00ffffc4 	movi	r3,-1
8111cdc0:	10c0e126 	beq	r2,r3,8111d148 <_malloc_r+0x790>
8111cdc4:	1505c83a 	sub	r2,r2,r20
8111cdc8:	1545883a 	add	r2,r2,r21
8111cdcc:	10800054 	ori	r2,r2,1
8111cdd0:	e0c00017 	ldw	r3,0(fp)
8111cdd4:	9d000215 	stw	r20,8(r19)
8111cdd8:	a0800115 	stw	r2,4(r20)
8111cddc:	a8c7883a 	add	r3,r21,r3
8111cde0:	e0c00015 	stw	r3,0(fp)
8111cde4:	84c00e26 	beq	r16,r19,8111ce20 <_malloc_r+0x468>
8111cde8:	018003c4 	movi	r6,15
8111cdec:	3580a72e 	bgeu	r6,r22,8111d08c <_malloc_r+0x6d4>
8111cdf0:	81400117 	ldw	r5,4(r16)
8111cdf4:	013ffe04 	movi	r4,-8
8111cdf8:	b0bffd04 	addi	r2,r22,-12
8111cdfc:	1104703a 	and	r2,r2,r4
8111ce00:	2900004c 	andi	r4,r5,1
8111ce04:	2088b03a 	or	r4,r4,r2
8111ce08:	81000115 	stw	r4,4(r16)
8111ce0c:	01400144 	movi	r5,5
8111ce10:	8089883a 	add	r4,r16,r2
8111ce14:	21400115 	stw	r5,4(r4)
8111ce18:	21400215 	stw	r5,8(r4)
8111ce1c:	3080cd36 	bltu	r6,r2,8111d154 <_malloc_r+0x79c>
8111ce20:	00a04574 	movhi	r2,33045
8111ce24:	10b84604 	addi	r2,r2,-7912
8111ce28:	11000017 	ldw	r4,0(r2)
8111ce2c:	20c0012e 	bgeu	r4,r3,8111ce34 <_malloc_r+0x47c>
8111ce30:	10c00015 	stw	r3,0(r2)
8111ce34:	00a04574 	movhi	r2,33045
8111ce38:	10b84504 	addi	r2,r2,-7916
8111ce3c:	11000017 	ldw	r4,0(r2)
8111ce40:	9c000217 	ldw	r16,8(r19)
8111ce44:	20c0012e 	bgeu	r4,r3,8111ce4c <_malloc_r+0x494>
8111ce48:	10c00015 	stw	r3,0(r2)
8111ce4c:	80c00117 	ldw	r3,4(r16)
8111ce50:	00bfff04 	movi	r2,-4
8111ce54:	1886703a 	and	r3,r3,r2
8111ce58:	1c45c83a 	sub	r2,r3,r17
8111ce5c:	1c400236 	bltu	r3,r17,8111ce68 <_malloc_r+0x4b0>
8111ce60:	00c003c4 	movi	r3,15
8111ce64:	18800416 	blt	r3,r2,8111ce78 <_malloc_r+0x4c0>
8111ce68:	9009883a 	mov	r4,r18
8111ce6c:	11338dc0 	call	811338dc <__malloc_unlock>
8111ce70:	0005883a 	mov	r2,zero
8111ce74:	003f7b06 	br	8111cc64 <__reset+0xfb0fcc64>
8111ce78:	88c00054 	ori	r3,r17,1
8111ce7c:	80c00115 	stw	r3,4(r16)
8111ce80:	8463883a 	add	r17,r16,r17
8111ce84:	10800054 	ori	r2,r2,1
8111ce88:	9c400215 	stw	r17,8(r19)
8111ce8c:	88800115 	stw	r2,4(r17)
8111ce90:	9009883a 	mov	r4,r18
8111ce94:	11338dc0 	call	811338dc <__malloc_unlock>
8111ce98:	80800204 	addi	r2,r16,8
8111ce9c:	003f7106 	br	8111cc64 <__reset+0xfb0fcc64>
8111cea0:	00c00504 	movi	r3,20
8111cea4:	18804a2e 	bgeu	r3,r2,8111cfd0 <_malloc_r+0x618>
8111cea8:	00c01504 	movi	r3,84
8111ceac:	18806e36 	bltu	r3,r2,8111d068 <_malloc_r+0x6b0>
8111ceb0:	8804d33a 	srli	r2,r17,12
8111ceb4:	12001bc4 	addi	r8,r2,111
8111ceb8:	11c01b84 	addi	r7,r2,110
8111cebc:	4209883a 	add	r4,r8,r8
8111cec0:	003edd06 	br	8111ca38 <__reset+0xfb0fca38>
8111cec4:	3804d27a 	srli	r2,r7,9
8111cec8:	00c00104 	movi	r3,4
8111cecc:	1880442e 	bgeu	r3,r2,8111cfe0 <_malloc_r+0x628>
8111ced0:	00c00504 	movi	r3,20
8111ced4:	18808136 	bltu	r3,r2,8111d0dc <_malloc_r+0x724>
8111ced8:	11401704 	addi	r5,r2,92
8111cedc:	10c016c4 	addi	r3,r2,91
8111cee0:	294b883a 	add	r5,r5,r5
8111cee4:	294b883a 	add	r5,r5,r5
8111cee8:	294b883a 	add	r5,r5,r5
8111ceec:	994b883a 	add	r5,r19,r5
8111cef0:	28800017 	ldw	r2,0(r5)
8111cef4:	01a04574 	movhi	r6,33045
8111cef8:	297ffe04 	addi	r5,r5,-8
8111cefc:	31b19404 	addi	r6,r6,-14768
8111cf00:	28806526 	beq	r5,r2,8111d098 <_malloc_r+0x6e0>
8111cf04:	01bfff04 	movi	r6,-4
8111cf08:	10c00117 	ldw	r3,4(r2)
8111cf0c:	1986703a 	and	r3,r3,r6
8111cf10:	38c0022e 	bgeu	r7,r3,8111cf1c <_malloc_r+0x564>
8111cf14:	10800217 	ldw	r2,8(r2)
8111cf18:	28bffb1e 	bne	r5,r2,8111cf08 <__reset+0xfb0fcf08>
8111cf1c:	11400317 	ldw	r5,12(r2)
8111cf20:	98c00117 	ldw	r3,4(r19)
8111cf24:	81400315 	stw	r5,12(r16)
8111cf28:	80800215 	stw	r2,8(r16)
8111cf2c:	2c000215 	stw	r16,8(r5)
8111cf30:	14000315 	stw	r16,12(r2)
8111cf34:	003ef806 	br	8111cb18 <__reset+0xfb0fcb18>
8111cf38:	88c00054 	ori	r3,r17,1
8111cf3c:	80c00115 	stw	r3,4(r16)
8111cf40:	8463883a 	add	r17,r16,r17
8111cf44:	34400515 	stw	r17,20(r6)
8111cf48:	34400415 	stw	r17,16(r6)
8111cf4c:	10c00054 	ori	r3,r2,1
8111cf50:	8a000315 	stw	r8,12(r17)
8111cf54:	8a000215 	stw	r8,8(r17)
8111cf58:	88c00115 	stw	r3,4(r17)
8111cf5c:	88a3883a 	add	r17,r17,r2
8111cf60:	88800015 	stw	r2,0(r17)
8111cf64:	9009883a 	mov	r4,r18
8111cf68:	11338dc0 	call	811338dc <__malloc_unlock>
8111cf6c:	80800204 	addi	r2,r16,8
8111cf70:	003f3c06 	br	8111cc64 <__reset+0xfb0fcc64>
8111cf74:	30c00117 	ldw	r3,4(r6)
8111cf78:	003ee706 	br	8111cb18 <__reset+0xfb0fcb18>
8111cf7c:	5ac00044 	addi	r11,r11,1
8111cf80:	588000cc 	andi	r2,r11,3
8111cf84:	31800204 	addi	r6,r6,8
8111cf88:	103efd1e 	bne	r2,zero,8111cb80 <__reset+0xfb0fcb80>
8111cf8c:	00002406 	br	8111d020 <_malloc_r+0x668>
8111cf90:	14000317 	ldw	r16,12(r2)
8111cf94:	143f251e 	bne	r2,r16,8111cc2c <__reset+0xfb0fcc2c>
8111cf98:	21000084 	addi	r4,r4,2
8111cf9c:	003ebc06 	br	8111ca90 <__reset+0xfb0fca90>
8111cfa0:	8085883a 	add	r2,r16,r2
8111cfa4:	10c00117 	ldw	r3,4(r2)
8111cfa8:	81000317 	ldw	r4,12(r16)
8111cfac:	81400217 	ldw	r5,8(r16)
8111cfb0:	18c00054 	ori	r3,r3,1
8111cfb4:	10c00115 	stw	r3,4(r2)
8111cfb8:	29000315 	stw	r4,12(r5)
8111cfbc:	21400215 	stw	r5,8(r4)
8111cfc0:	9009883a 	mov	r4,r18
8111cfc4:	11338dc0 	call	811338dc <__malloc_unlock>
8111cfc8:	80800204 	addi	r2,r16,8
8111cfcc:	003f2506 	br	8111cc64 <__reset+0xfb0fcc64>
8111cfd0:	12001704 	addi	r8,r2,92
8111cfd4:	11c016c4 	addi	r7,r2,91
8111cfd8:	4209883a 	add	r4,r8,r8
8111cfdc:	003e9606 	br	8111ca38 <__reset+0xfb0fca38>
8111cfe0:	3804d1ba 	srli	r2,r7,6
8111cfe4:	11400e44 	addi	r5,r2,57
8111cfe8:	10c00e04 	addi	r3,r2,56
8111cfec:	294b883a 	add	r5,r5,r5
8111cff0:	003fbc06 	br	8111cee4 <__reset+0xfb0fcee4>
8111cff4:	84ff5926 	beq	r16,r19,8111cd5c <__reset+0xfb0fcd5c>
8111cff8:	00a04574 	movhi	r2,33045
8111cffc:	10b19404 	addi	r2,r2,-14768
8111d000:	14000217 	ldw	r16,8(r2)
8111d004:	00bfff04 	movi	r2,-4
8111d008:	80c00117 	ldw	r3,4(r16)
8111d00c:	1886703a 	and	r3,r3,r2
8111d010:	003f9106 	br	8111ce58 <__reset+0xfb0fce58>
8111d014:	60800217 	ldw	r2,8(r12)
8111d018:	213fffc4 	addi	r4,r4,-1
8111d01c:	1300651e 	bne	r2,r12,8111d1b4 <_malloc_r+0x7fc>
8111d020:	208000cc 	andi	r2,r4,3
8111d024:	633ffe04 	addi	r12,r12,-8
8111d028:	103ffa1e 	bne	r2,zero,8111d014 <__reset+0xfb0fd014>
8111d02c:	98800117 	ldw	r2,4(r19)
8111d030:	0146303a 	nor	r3,zero,r5
8111d034:	1884703a 	and	r2,r3,r2
8111d038:	98800115 	stw	r2,4(r19)
8111d03c:	294b883a 	add	r5,r5,r5
8111d040:	117f2836 	bltu	r2,r5,8111cce4 <__reset+0xfb0fcce4>
8111d044:	283f2726 	beq	r5,zero,8111cce4 <__reset+0xfb0fcce4>
8111d048:	2886703a 	and	r3,r5,r2
8111d04c:	5809883a 	mov	r4,r11
8111d050:	183ec31e 	bne	r3,zero,8111cb60 <__reset+0xfb0fcb60>
8111d054:	294b883a 	add	r5,r5,r5
8111d058:	2886703a 	and	r3,r5,r2
8111d05c:	21000104 	addi	r4,r4,4
8111d060:	183ffc26 	beq	r3,zero,8111d054 <__reset+0xfb0fd054>
8111d064:	003ebe06 	br	8111cb60 <__reset+0xfb0fcb60>
8111d068:	00c05504 	movi	r3,340
8111d06c:	18801236 	bltu	r3,r2,8111d0b8 <_malloc_r+0x700>
8111d070:	8804d3fa 	srli	r2,r17,15
8111d074:	12001e04 	addi	r8,r2,120
8111d078:	11c01dc4 	addi	r7,r2,119
8111d07c:	4209883a 	add	r4,r8,r8
8111d080:	003e6d06 	br	8111ca38 <__reset+0xfb0fca38>
8111d084:	00c40004 	movi	r3,4096
8111d088:	003f4606 	br	8111cda4 <__reset+0xfb0fcda4>
8111d08c:	00800044 	movi	r2,1
8111d090:	a0800115 	stw	r2,4(r20)
8111d094:	003f7406 	br	8111ce68 <__reset+0xfb0fce68>
8111d098:	1805d0ba 	srai	r2,r3,2
8111d09c:	01c00044 	movi	r7,1
8111d0a0:	30c00117 	ldw	r3,4(r6)
8111d0a4:	388e983a 	sll	r7,r7,r2
8111d0a8:	2805883a 	mov	r2,r5
8111d0ac:	38c6b03a 	or	r3,r7,r3
8111d0b0:	30c00115 	stw	r3,4(r6)
8111d0b4:	003f9b06 	br	8111cf24 <__reset+0xfb0fcf24>
8111d0b8:	00c15504 	movi	r3,1364
8111d0bc:	18801a36 	bltu	r3,r2,8111d128 <_malloc_r+0x770>
8111d0c0:	8804d4ba 	srli	r2,r17,18
8111d0c4:	12001f44 	addi	r8,r2,125
8111d0c8:	11c01f04 	addi	r7,r2,124
8111d0cc:	4209883a 	add	r4,r8,r8
8111d0d0:	003e5906 	br	8111ca38 <__reset+0xfb0fca38>
8111d0d4:	ad400404 	addi	r21,r21,16
8111d0d8:	003f1706 	br	8111cd38 <__reset+0xfb0fcd38>
8111d0dc:	00c01504 	movi	r3,84
8111d0e0:	18802336 	bltu	r3,r2,8111d170 <_malloc_r+0x7b8>
8111d0e4:	3804d33a 	srli	r2,r7,12
8111d0e8:	11401bc4 	addi	r5,r2,111
8111d0ec:	10c01b84 	addi	r3,r2,110
8111d0f0:	294b883a 	add	r5,r5,r5
8111d0f4:	003f7b06 	br	8111cee4 <__reset+0xfb0fcee4>
8111d0f8:	9c000217 	ldw	r16,8(r19)
8111d0fc:	00bfff04 	movi	r2,-4
8111d100:	80c00117 	ldw	r3,4(r16)
8111d104:	1886703a 	and	r3,r3,r2
8111d108:	003f5306 	br	8111ce58 <__reset+0xfb0fce58>
8111d10c:	3083ffcc 	andi	r2,r6,4095
8111d110:	103f181e 	bne	r2,zero,8111cd74 <__reset+0xfb0fcd74>
8111d114:	99000217 	ldw	r4,8(r19)
8111d118:	b545883a 	add	r2,r22,r21
8111d11c:	10800054 	ori	r2,r2,1
8111d120:	20800115 	stw	r2,4(r4)
8111d124:	003f3e06 	br	8111ce20 <__reset+0xfb0fce20>
8111d128:	01003f84 	movi	r4,254
8111d12c:	02001fc4 	movi	r8,127
8111d130:	01c01f84 	movi	r7,126
8111d134:	003e4006 	br	8111ca38 <__reset+0xfb0fca38>
8111d138:	00a04574 	movhi	r2,33045
8111d13c:	10b7d704 	addi	r2,r2,-8356
8111d140:	15000015 	stw	r20,0(r2)
8111d144:	003f1106 	br	8111cd8c <__reset+0xfb0fcd8c>
8111d148:	00800044 	movi	r2,1
8111d14c:	002b883a 	mov	r21,zero
8111d150:	003f1f06 	br	8111cdd0 <__reset+0xfb0fcdd0>
8111d154:	81400204 	addi	r5,r16,8
8111d158:	9009883a 	mov	r4,r18
8111d15c:	112642c0 	call	8112642c <_free_r>
8111d160:	00a04574 	movhi	r2,33045
8111d164:	10b8d404 	addi	r2,r2,-7344
8111d168:	10c00017 	ldw	r3,0(r2)
8111d16c:	003f2c06 	br	8111ce20 <__reset+0xfb0fce20>
8111d170:	00c05504 	movi	r3,340
8111d174:	18800536 	bltu	r3,r2,8111d18c <_malloc_r+0x7d4>
8111d178:	3804d3fa 	srli	r2,r7,15
8111d17c:	11401e04 	addi	r5,r2,120
8111d180:	10c01dc4 	addi	r3,r2,119
8111d184:	294b883a 	add	r5,r5,r5
8111d188:	003f5606 	br	8111cee4 <__reset+0xfb0fcee4>
8111d18c:	00c15504 	movi	r3,1364
8111d190:	18800536 	bltu	r3,r2,8111d1a8 <_malloc_r+0x7f0>
8111d194:	3804d4ba 	srli	r2,r7,18
8111d198:	11401f44 	addi	r5,r2,125
8111d19c:	10c01f04 	addi	r3,r2,124
8111d1a0:	294b883a 	add	r5,r5,r5
8111d1a4:	003f4f06 	br	8111cee4 <__reset+0xfb0fcee4>
8111d1a8:	01403f84 	movi	r5,254
8111d1ac:	00c01f84 	movi	r3,126
8111d1b0:	003f4c06 	br	8111cee4 <__reset+0xfb0fcee4>
8111d1b4:	98800117 	ldw	r2,4(r19)
8111d1b8:	003fa006 	br	8111d03c <__reset+0xfb0fd03c>
8111d1bc:	8808d0fa 	srli	r4,r17,3
8111d1c0:	20800044 	addi	r2,r4,1
8111d1c4:	1085883a 	add	r2,r2,r2
8111d1c8:	003e9006 	br	8111cc0c <__reset+0xfb0fcc0c>

8111d1cc <memcpy>:
8111d1cc:	defffd04 	addi	sp,sp,-12
8111d1d0:	de00012e 	bgeu	sp,et,8111d1d8 <memcpy+0xc>
8111d1d4:	003b68fa 	trap	3
8111d1d8:	00c003c4 	movi	r3,15
8111d1dc:	dfc00215 	stw	ra,8(sp)
8111d1e0:	dc400115 	stw	r17,4(sp)
8111d1e4:	dc000015 	stw	r16,0(sp)
8111d1e8:	2005883a 	mov	r2,r4
8111d1ec:	1980452e 	bgeu	r3,r6,8111d304 <memcpy+0x138>
8111d1f0:	2906b03a 	or	r3,r5,r4
8111d1f4:	18c000cc 	andi	r3,r3,3
8111d1f8:	1800441e 	bne	r3,zero,8111d30c <memcpy+0x140>
8111d1fc:	347ffc04 	addi	r17,r6,-16
8111d200:	8822d13a 	srli	r17,r17,4
8111d204:	28c00104 	addi	r3,r5,4
8111d208:	23400104 	addi	r13,r4,4
8111d20c:	8820913a 	slli	r16,r17,4
8111d210:	2b000204 	addi	r12,r5,8
8111d214:	22c00204 	addi	r11,r4,8
8111d218:	84000504 	addi	r16,r16,20
8111d21c:	2a800304 	addi	r10,r5,12
8111d220:	22400304 	addi	r9,r4,12
8111d224:	2c21883a 	add	r16,r5,r16
8111d228:	2811883a 	mov	r8,r5
8111d22c:	200f883a 	mov	r7,r4
8111d230:	41000017 	ldw	r4,0(r8)
8111d234:	1fc00017 	ldw	ra,0(r3)
8111d238:	63c00017 	ldw	r15,0(r12)
8111d23c:	39000015 	stw	r4,0(r7)
8111d240:	53800017 	ldw	r14,0(r10)
8111d244:	6fc00015 	stw	ra,0(r13)
8111d248:	5bc00015 	stw	r15,0(r11)
8111d24c:	4b800015 	stw	r14,0(r9)
8111d250:	18c00404 	addi	r3,r3,16
8111d254:	39c00404 	addi	r7,r7,16
8111d258:	42000404 	addi	r8,r8,16
8111d25c:	6b400404 	addi	r13,r13,16
8111d260:	63000404 	addi	r12,r12,16
8111d264:	5ac00404 	addi	r11,r11,16
8111d268:	52800404 	addi	r10,r10,16
8111d26c:	4a400404 	addi	r9,r9,16
8111d270:	1c3fef1e 	bne	r3,r16,8111d230 <__reset+0xfb0fd230>
8111d274:	89c00044 	addi	r7,r17,1
8111d278:	380e913a 	slli	r7,r7,4
8111d27c:	310003cc 	andi	r4,r6,15
8111d280:	02c000c4 	movi	r11,3
8111d284:	11c7883a 	add	r3,r2,r7
8111d288:	29cb883a 	add	r5,r5,r7
8111d28c:	5900212e 	bgeu	r11,r4,8111d314 <memcpy+0x148>
8111d290:	1813883a 	mov	r9,r3
8111d294:	2811883a 	mov	r8,r5
8111d298:	200f883a 	mov	r7,r4
8111d29c:	42800017 	ldw	r10,0(r8)
8111d2a0:	4a400104 	addi	r9,r9,4
8111d2a4:	39ffff04 	addi	r7,r7,-4
8111d2a8:	4abfff15 	stw	r10,-4(r9)
8111d2ac:	42000104 	addi	r8,r8,4
8111d2b0:	59fffa36 	bltu	r11,r7,8111d29c <__reset+0xfb0fd29c>
8111d2b4:	213fff04 	addi	r4,r4,-4
8111d2b8:	2008d0ba 	srli	r4,r4,2
8111d2bc:	318000cc 	andi	r6,r6,3
8111d2c0:	21000044 	addi	r4,r4,1
8111d2c4:	2109883a 	add	r4,r4,r4
8111d2c8:	2109883a 	add	r4,r4,r4
8111d2cc:	1907883a 	add	r3,r3,r4
8111d2d0:	290b883a 	add	r5,r5,r4
8111d2d4:	30000626 	beq	r6,zero,8111d2f0 <memcpy+0x124>
8111d2d8:	198d883a 	add	r6,r3,r6
8111d2dc:	29c00003 	ldbu	r7,0(r5)
8111d2e0:	18c00044 	addi	r3,r3,1
8111d2e4:	29400044 	addi	r5,r5,1
8111d2e8:	19ffffc5 	stb	r7,-1(r3)
8111d2ec:	19bffb1e 	bne	r3,r6,8111d2dc <__reset+0xfb0fd2dc>
8111d2f0:	dfc00217 	ldw	ra,8(sp)
8111d2f4:	dc400117 	ldw	r17,4(sp)
8111d2f8:	dc000017 	ldw	r16,0(sp)
8111d2fc:	dec00304 	addi	sp,sp,12
8111d300:	f800283a 	ret
8111d304:	2007883a 	mov	r3,r4
8111d308:	003ff206 	br	8111d2d4 <__reset+0xfb0fd2d4>
8111d30c:	2007883a 	mov	r3,r4
8111d310:	003ff106 	br	8111d2d8 <__reset+0xfb0fd2d8>
8111d314:	200d883a 	mov	r6,r4
8111d318:	003fee06 	br	8111d2d4 <__reset+0xfb0fd2d4>

8111d31c <memset>:
8111d31c:	20c000cc 	andi	r3,r4,3
8111d320:	2005883a 	mov	r2,r4
8111d324:	18004426 	beq	r3,zero,8111d438 <memset+0x11c>
8111d328:	31ffffc4 	addi	r7,r6,-1
8111d32c:	30004026 	beq	r6,zero,8111d430 <memset+0x114>
8111d330:	2813883a 	mov	r9,r5
8111d334:	200d883a 	mov	r6,r4
8111d338:	2007883a 	mov	r3,r4
8111d33c:	00000406 	br	8111d350 <memset+0x34>
8111d340:	3a3fffc4 	addi	r8,r7,-1
8111d344:	31800044 	addi	r6,r6,1
8111d348:	38003926 	beq	r7,zero,8111d430 <memset+0x114>
8111d34c:	400f883a 	mov	r7,r8
8111d350:	18c00044 	addi	r3,r3,1
8111d354:	32400005 	stb	r9,0(r6)
8111d358:	1a0000cc 	andi	r8,r3,3
8111d35c:	403ff81e 	bne	r8,zero,8111d340 <__reset+0xfb0fd340>
8111d360:	010000c4 	movi	r4,3
8111d364:	21c02d2e 	bgeu	r4,r7,8111d41c <memset+0x100>
8111d368:	29003fcc 	andi	r4,r5,255
8111d36c:	200c923a 	slli	r6,r4,8
8111d370:	3108b03a 	or	r4,r6,r4
8111d374:	200c943a 	slli	r6,r4,16
8111d378:	218cb03a 	or	r6,r4,r6
8111d37c:	010003c4 	movi	r4,15
8111d380:	21c0182e 	bgeu	r4,r7,8111d3e4 <memset+0xc8>
8111d384:	3b3ffc04 	addi	r12,r7,-16
8111d388:	6018d13a 	srli	r12,r12,4
8111d38c:	1a000104 	addi	r8,r3,4
8111d390:	1ac00204 	addi	r11,r3,8
8111d394:	6008913a 	slli	r4,r12,4
8111d398:	1a800304 	addi	r10,r3,12
8111d39c:	1813883a 	mov	r9,r3
8111d3a0:	21000504 	addi	r4,r4,20
8111d3a4:	1909883a 	add	r4,r3,r4
8111d3a8:	49800015 	stw	r6,0(r9)
8111d3ac:	41800015 	stw	r6,0(r8)
8111d3b0:	59800015 	stw	r6,0(r11)
8111d3b4:	51800015 	stw	r6,0(r10)
8111d3b8:	42000404 	addi	r8,r8,16
8111d3bc:	4a400404 	addi	r9,r9,16
8111d3c0:	5ac00404 	addi	r11,r11,16
8111d3c4:	52800404 	addi	r10,r10,16
8111d3c8:	413ff71e 	bne	r8,r4,8111d3a8 <__reset+0xfb0fd3a8>
8111d3cc:	63000044 	addi	r12,r12,1
8111d3d0:	6018913a 	slli	r12,r12,4
8111d3d4:	39c003cc 	andi	r7,r7,15
8111d3d8:	010000c4 	movi	r4,3
8111d3dc:	1b07883a 	add	r3,r3,r12
8111d3e0:	21c00e2e 	bgeu	r4,r7,8111d41c <memset+0x100>
8111d3e4:	1813883a 	mov	r9,r3
8111d3e8:	3811883a 	mov	r8,r7
8111d3ec:	010000c4 	movi	r4,3
8111d3f0:	49800015 	stw	r6,0(r9)
8111d3f4:	423fff04 	addi	r8,r8,-4
8111d3f8:	4a400104 	addi	r9,r9,4
8111d3fc:	223ffc36 	bltu	r4,r8,8111d3f0 <__reset+0xfb0fd3f0>
8111d400:	393fff04 	addi	r4,r7,-4
8111d404:	2008d0ba 	srli	r4,r4,2
8111d408:	39c000cc 	andi	r7,r7,3
8111d40c:	21000044 	addi	r4,r4,1
8111d410:	2109883a 	add	r4,r4,r4
8111d414:	2109883a 	add	r4,r4,r4
8111d418:	1907883a 	add	r3,r3,r4
8111d41c:	38000526 	beq	r7,zero,8111d434 <memset+0x118>
8111d420:	19cf883a 	add	r7,r3,r7
8111d424:	19400005 	stb	r5,0(r3)
8111d428:	18c00044 	addi	r3,r3,1
8111d42c:	38fffd1e 	bne	r7,r3,8111d424 <__reset+0xfb0fd424>
8111d430:	f800283a 	ret
8111d434:	f800283a 	ret
8111d438:	2007883a 	mov	r3,r4
8111d43c:	300f883a 	mov	r7,r6
8111d440:	003fc706 	br	8111d360 <__reset+0xfb0fd360>

8111d444 <_open_r>:
8111d444:	defffd04 	addi	sp,sp,-12
8111d448:	de00012e 	bgeu	sp,et,8111d450 <_open_r+0xc>
8111d44c:	003b68fa 	trap	3
8111d450:	2805883a 	mov	r2,r5
8111d454:	dc000015 	stw	r16,0(sp)
8111d458:	04204574 	movhi	r16,33045
8111d45c:	dc400115 	stw	r17,4(sp)
8111d460:	300b883a 	mov	r5,r6
8111d464:	84384404 	addi	r16,r16,-7920
8111d468:	2023883a 	mov	r17,r4
8111d46c:	380d883a 	mov	r6,r7
8111d470:	1009883a 	mov	r4,r2
8111d474:	dfc00215 	stw	ra,8(sp)
8111d478:	80000015 	stw	zero,0(r16)
8111d47c:	1132e340 	call	81132e34 <open>
8111d480:	00ffffc4 	movi	r3,-1
8111d484:	10c00526 	beq	r2,r3,8111d49c <_open_r+0x58>
8111d488:	dfc00217 	ldw	ra,8(sp)
8111d48c:	dc400117 	ldw	r17,4(sp)
8111d490:	dc000017 	ldw	r16,0(sp)
8111d494:	dec00304 	addi	sp,sp,12
8111d498:	f800283a 	ret
8111d49c:	80c00017 	ldw	r3,0(r16)
8111d4a0:	183ff926 	beq	r3,zero,8111d488 <__reset+0xfb0fd488>
8111d4a4:	88c00015 	stw	r3,0(r17)
8111d4a8:	003ff706 	br	8111d488 <__reset+0xfb0fd488>

8111d4ac <_printf_r>:
8111d4ac:	defffd04 	addi	sp,sp,-12
8111d4b0:	2805883a 	mov	r2,r5
8111d4b4:	de00012e 	bgeu	sp,et,8111d4bc <_printf_r+0x10>
8111d4b8:	003b68fa 	trap	3
8111d4bc:	dfc00015 	stw	ra,0(sp)
8111d4c0:	d9800115 	stw	r6,4(sp)
8111d4c4:	d9c00215 	stw	r7,8(sp)
8111d4c8:	21400217 	ldw	r5,8(r4)
8111d4cc:	d9c00104 	addi	r7,sp,4
8111d4d0:	100d883a 	mov	r6,r2
8111d4d4:	11201d80 	call	811201d8 <___vfprintf_internal_r>
8111d4d8:	dfc00017 	ldw	ra,0(sp)
8111d4dc:	dec00304 	addi	sp,sp,12
8111d4e0:	f800283a 	ret

8111d4e4 <printf>:
8111d4e4:	defffc04 	addi	sp,sp,-16
8111d4e8:	de00012e 	bgeu	sp,et,8111d4f0 <printf+0xc>
8111d4ec:	003b68fa 	trap	3
8111d4f0:	dfc00015 	stw	ra,0(sp)
8111d4f4:	d9400115 	stw	r5,4(sp)
8111d4f8:	d9800215 	stw	r6,8(sp)
8111d4fc:	d9c00315 	stw	r7,12(sp)
8111d500:	00a04574 	movhi	r2,33045
8111d504:	10b7d604 	addi	r2,r2,-8360
8111d508:	10800017 	ldw	r2,0(r2)
8111d50c:	200b883a 	mov	r5,r4
8111d510:	d9800104 	addi	r6,sp,4
8111d514:	11000217 	ldw	r4,8(r2)
8111d518:	11223d80 	call	811223d8 <__vfprintf_internal>
8111d51c:	dfc00017 	ldw	ra,0(sp)
8111d520:	dec00404 	addi	sp,sp,16
8111d524:	f800283a 	ret

8111d528 <_putc_r>:
8111d528:	defffc04 	addi	sp,sp,-16
8111d52c:	de00012e 	bgeu	sp,et,8111d534 <_putc_r+0xc>
8111d530:	003b68fa 	trap	3
8111d534:	dc000215 	stw	r16,8(sp)
8111d538:	dfc00315 	stw	ra,12(sp)
8111d53c:	2021883a 	mov	r16,r4
8111d540:	20000226 	beq	r4,zero,8111d54c <_putc_r+0x24>
8111d544:	20800e17 	ldw	r2,56(r4)
8111d548:	10001b26 	beq	r2,zero,8111d5b8 <_putc_r+0x90>
8111d54c:	30800217 	ldw	r2,8(r6)
8111d550:	10bfffc4 	addi	r2,r2,-1
8111d554:	30800215 	stw	r2,8(r6)
8111d558:	10000a16 	blt	r2,zero,8111d584 <_putc_r+0x5c>
8111d55c:	30800017 	ldw	r2,0(r6)
8111d560:	11400005 	stb	r5,0(r2)
8111d564:	30800017 	ldw	r2,0(r6)
8111d568:	10c00044 	addi	r3,r2,1
8111d56c:	30c00015 	stw	r3,0(r6)
8111d570:	10800003 	ldbu	r2,0(r2)
8111d574:	dfc00317 	ldw	ra,12(sp)
8111d578:	dc000217 	ldw	r16,8(sp)
8111d57c:	dec00404 	addi	sp,sp,16
8111d580:	f800283a 	ret
8111d584:	30c00617 	ldw	r3,24(r6)
8111d588:	10c00616 	blt	r2,r3,8111d5a4 <_putc_r+0x7c>
8111d58c:	30800017 	ldw	r2,0(r6)
8111d590:	00c00284 	movi	r3,10
8111d594:	11400005 	stb	r5,0(r2)
8111d598:	30800017 	ldw	r2,0(r6)
8111d59c:	11400003 	ldbu	r5,0(r2)
8111d5a0:	28fff11e 	bne	r5,r3,8111d568 <__reset+0xfb0fd568>
8111d5a4:	8009883a 	mov	r4,r16
8111d5a8:	dfc00317 	ldw	ra,12(sp)
8111d5ac:	dc000217 	ldw	r16,8(sp)
8111d5b0:	dec00404 	addi	sp,sp,16
8111d5b4:	1123d5c1 	jmpi	81123d5c <__swbuf_r>
8111d5b8:	d9400015 	stw	r5,0(sp)
8111d5bc:	d9800115 	stw	r6,4(sp)
8111d5c0:	1125f940 	call	81125f94 <__sinit>
8111d5c4:	d9800117 	ldw	r6,4(sp)
8111d5c8:	d9400017 	ldw	r5,0(sp)
8111d5cc:	003fdf06 	br	8111d54c <__reset+0xfb0fd54c>

8111d5d0 <putc>:
8111d5d0:	00a04574 	movhi	r2,33045
8111d5d4:	defffc04 	addi	sp,sp,-16
8111d5d8:	10b7d604 	addi	r2,r2,-8360
8111d5dc:	de00012e 	bgeu	sp,et,8111d5e4 <putc+0x14>
8111d5e0:	003b68fa 	trap	3
8111d5e4:	dc000115 	stw	r16,4(sp)
8111d5e8:	14000017 	ldw	r16,0(r2)
8111d5ec:	dc400215 	stw	r17,8(sp)
8111d5f0:	dfc00315 	stw	ra,12(sp)
8111d5f4:	2023883a 	mov	r17,r4
8111d5f8:	80000226 	beq	r16,zero,8111d604 <putc+0x34>
8111d5fc:	80800e17 	ldw	r2,56(r16)
8111d600:	10001a26 	beq	r2,zero,8111d66c <putc+0x9c>
8111d604:	28800217 	ldw	r2,8(r5)
8111d608:	10bfffc4 	addi	r2,r2,-1
8111d60c:	28800215 	stw	r2,8(r5)
8111d610:	10000b16 	blt	r2,zero,8111d640 <putc+0x70>
8111d614:	28800017 	ldw	r2,0(r5)
8111d618:	14400005 	stb	r17,0(r2)
8111d61c:	28800017 	ldw	r2,0(r5)
8111d620:	10c00044 	addi	r3,r2,1
8111d624:	28c00015 	stw	r3,0(r5)
8111d628:	10800003 	ldbu	r2,0(r2)
8111d62c:	dfc00317 	ldw	ra,12(sp)
8111d630:	dc400217 	ldw	r17,8(sp)
8111d634:	dc000117 	ldw	r16,4(sp)
8111d638:	dec00404 	addi	sp,sp,16
8111d63c:	f800283a 	ret
8111d640:	28c00617 	ldw	r3,24(r5)
8111d644:	10c00e16 	blt	r2,r3,8111d680 <putc+0xb0>
8111d648:	28800017 	ldw	r2,0(r5)
8111d64c:	01000284 	movi	r4,10
8111d650:	14400005 	stb	r17,0(r2)
8111d654:	28800017 	ldw	r2,0(r5)
8111d658:	10c00003 	ldbu	r3,0(r2)
8111d65c:	193ff01e 	bne	r3,r4,8111d620 <__reset+0xfb0fd620>
8111d660:	280d883a 	mov	r6,r5
8111d664:	180b883a 	mov	r5,r3
8111d668:	00000706 	br	8111d688 <putc+0xb8>
8111d66c:	8009883a 	mov	r4,r16
8111d670:	d9400015 	stw	r5,0(sp)
8111d674:	1125f940 	call	81125f94 <__sinit>
8111d678:	d9400017 	ldw	r5,0(sp)
8111d67c:	003fe106 	br	8111d604 <__reset+0xfb0fd604>
8111d680:	280d883a 	mov	r6,r5
8111d684:	880b883a 	mov	r5,r17
8111d688:	8009883a 	mov	r4,r16
8111d68c:	dfc00317 	ldw	ra,12(sp)
8111d690:	dc400217 	ldw	r17,8(sp)
8111d694:	dc000117 	ldw	r16,4(sp)
8111d698:	dec00404 	addi	sp,sp,16
8111d69c:	1123d5c1 	jmpi	81123d5c <__swbuf_r>

8111d6a0 <_puts_r>:
8111d6a0:	defff604 	addi	sp,sp,-40
8111d6a4:	de00012e 	bgeu	sp,et,8111d6ac <_puts_r+0xc>
8111d6a8:	003b68fa 	trap	3
8111d6ac:	dc000715 	stw	r16,28(sp)
8111d6b0:	2021883a 	mov	r16,r4
8111d6b4:	2809883a 	mov	r4,r5
8111d6b8:	dc400815 	stw	r17,32(sp)
8111d6bc:	dfc00915 	stw	ra,36(sp)
8111d6c0:	2823883a 	mov	r17,r5
8111d6c4:	111dcc00 	call	8111dcc0 <strlen>
8111d6c8:	10c00044 	addi	r3,r2,1
8111d6cc:	d8800115 	stw	r2,4(sp)
8111d6d0:	00a04574 	movhi	r2,33045
8111d6d4:	10adfd04 	addi	r2,r2,-18444
8111d6d8:	d8800215 	stw	r2,8(sp)
8111d6dc:	00800044 	movi	r2,1
8111d6e0:	d8800315 	stw	r2,12(sp)
8111d6e4:	00800084 	movi	r2,2
8111d6e8:	dc400015 	stw	r17,0(sp)
8111d6ec:	d8c00615 	stw	r3,24(sp)
8111d6f0:	dec00415 	stw	sp,16(sp)
8111d6f4:	d8800515 	stw	r2,20(sp)
8111d6f8:	80000226 	beq	r16,zero,8111d704 <_puts_r+0x64>
8111d6fc:	80800e17 	ldw	r2,56(r16)
8111d700:	10001426 	beq	r2,zero,8111d754 <_puts_r+0xb4>
8111d704:	81400217 	ldw	r5,8(r16)
8111d708:	2880030b 	ldhu	r2,12(r5)
8111d70c:	10c8000c 	andi	r3,r2,8192
8111d710:	1800061e 	bne	r3,zero,8111d72c <_puts_r+0x8c>
8111d714:	29001917 	ldw	r4,100(r5)
8111d718:	00f7ffc4 	movi	r3,-8193
8111d71c:	10880014 	ori	r2,r2,8192
8111d720:	20c6703a 	and	r3,r4,r3
8111d724:	2880030d 	sth	r2,12(r5)
8111d728:	28c01915 	stw	r3,100(r5)
8111d72c:	d9800404 	addi	r6,sp,16
8111d730:	8009883a 	mov	r4,r16
8111d734:	11267440 	call	81126744 <__sfvwrite_r>
8111d738:	1000091e 	bne	r2,zero,8111d760 <_puts_r+0xc0>
8111d73c:	00800284 	movi	r2,10
8111d740:	dfc00917 	ldw	ra,36(sp)
8111d744:	dc400817 	ldw	r17,32(sp)
8111d748:	dc000717 	ldw	r16,28(sp)
8111d74c:	dec00a04 	addi	sp,sp,40
8111d750:	f800283a 	ret
8111d754:	8009883a 	mov	r4,r16
8111d758:	1125f940 	call	81125f94 <__sinit>
8111d75c:	003fe906 	br	8111d704 <__reset+0xfb0fd704>
8111d760:	00bfffc4 	movi	r2,-1
8111d764:	003ff606 	br	8111d740 <__reset+0xfb0fd740>

8111d768 <puts>:
8111d768:	00a04574 	movhi	r2,33045
8111d76c:	10b7d604 	addi	r2,r2,-8360
8111d770:	200b883a 	mov	r5,r4
8111d774:	11000017 	ldw	r4,0(r2)
8111d778:	111d6a01 	jmpi	8111d6a0 <_puts_r>

8111d77c <lflush>:
8111d77c:	2080030b 	ldhu	r2,12(r4)
8111d780:	00c00244 	movi	r3,9
8111d784:	1080024c 	andi	r2,r2,9
8111d788:	10c00226 	beq	r2,r3,8111d794 <lflush+0x18>
8111d78c:	0005883a 	mov	r2,zero
8111d790:	f800283a 	ret
8111d794:	1125bfc1 	jmpi	81125bfc <fflush>

8111d798 <__srefill_r>:
8111d798:	defffc04 	addi	sp,sp,-16
8111d79c:	de00012e 	bgeu	sp,et,8111d7a4 <__srefill_r+0xc>
8111d7a0:	003b68fa 	trap	3
8111d7a4:	dc400115 	stw	r17,4(sp)
8111d7a8:	dc000015 	stw	r16,0(sp)
8111d7ac:	dfc00315 	stw	ra,12(sp)
8111d7b0:	dc800215 	stw	r18,8(sp)
8111d7b4:	2023883a 	mov	r17,r4
8111d7b8:	2821883a 	mov	r16,r5
8111d7bc:	20000226 	beq	r4,zero,8111d7c8 <__srefill_r+0x30>
8111d7c0:	20800e17 	ldw	r2,56(r4)
8111d7c4:	10003c26 	beq	r2,zero,8111d8b8 <__srefill_r+0x120>
8111d7c8:	80c0030b 	ldhu	r3,12(r16)
8111d7cc:	1908000c 	andi	r4,r3,8192
8111d7d0:	1805883a 	mov	r2,r3
8111d7d4:	2000071e 	bne	r4,zero,8111d7f4 <__srefill_r+0x5c>
8111d7d8:	81001917 	ldw	r4,100(r16)
8111d7dc:	18880014 	ori	r2,r3,8192
8111d7e0:	00f7ffc4 	movi	r3,-8193
8111d7e4:	20c8703a 	and	r4,r4,r3
8111d7e8:	8080030d 	sth	r2,12(r16)
8111d7ec:	1007883a 	mov	r3,r2
8111d7f0:	81001915 	stw	r4,100(r16)
8111d7f4:	80000115 	stw	zero,4(r16)
8111d7f8:	1100080c 	andi	r4,r2,32
8111d7fc:	2000571e 	bne	r4,zero,8111d95c <__srefill_r+0x1c4>
8111d800:	1100010c 	andi	r4,r2,4
8111d804:	20001f26 	beq	r4,zero,8111d884 <__srefill_r+0xec>
8111d808:	81400c17 	ldw	r5,48(r16)
8111d80c:	28000826 	beq	r5,zero,8111d830 <__srefill_r+0x98>
8111d810:	80801004 	addi	r2,r16,64
8111d814:	28800226 	beq	r5,r2,8111d820 <__srefill_r+0x88>
8111d818:	8809883a 	mov	r4,r17
8111d81c:	112642c0 	call	8112642c <_free_r>
8111d820:	80800f17 	ldw	r2,60(r16)
8111d824:	80000c15 	stw	zero,48(r16)
8111d828:	80800115 	stw	r2,4(r16)
8111d82c:	1000391e 	bne	r2,zero,8111d914 <__srefill_r+0x17c>
8111d830:	80800417 	ldw	r2,16(r16)
8111d834:	10004b26 	beq	r2,zero,8111d964 <__srefill_r+0x1cc>
8111d838:	8480030b 	ldhu	r18,12(r16)
8111d83c:	908000cc 	andi	r2,r18,3
8111d840:	10001f1e 	bne	r2,zero,8111d8c0 <__srefill_r+0x128>
8111d844:	81800417 	ldw	r6,16(r16)
8111d848:	80800817 	ldw	r2,32(r16)
8111d84c:	81c00517 	ldw	r7,20(r16)
8111d850:	81400717 	ldw	r5,28(r16)
8111d854:	81800015 	stw	r6,0(r16)
8111d858:	8809883a 	mov	r4,r17
8111d85c:	103ee83a 	callr	r2
8111d860:	80800115 	stw	r2,4(r16)
8111d864:	00800e0e 	bge	zero,r2,8111d8a0 <__srefill_r+0x108>
8111d868:	0005883a 	mov	r2,zero
8111d86c:	dfc00317 	ldw	ra,12(sp)
8111d870:	dc800217 	ldw	r18,8(sp)
8111d874:	dc400117 	ldw	r17,4(sp)
8111d878:	dc000017 	ldw	r16,0(sp)
8111d87c:	dec00404 	addi	sp,sp,16
8111d880:	f800283a 	ret
8111d884:	1100040c 	andi	r4,r2,16
8111d888:	20003026 	beq	r4,zero,8111d94c <__srefill_r+0x1b4>
8111d88c:	1080020c 	andi	r2,r2,8
8111d890:	1000241e 	bne	r2,zero,8111d924 <__srefill_r+0x18c>
8111d894:	18c00114 	ori	r3,r3,4
8111d898:	80c0030d 	sth	r3,12(r16)
8111d89c:	003fe406 	br	8111d830 <__reset+0xfb0fd830>
8111d8a0:	80c0030b 	ldhu	r3,12(r16)
8111d8a4:	1000161e 	bne	r2,zero,8111d900 <__srefill_r+0x168>
8111d8a8:	18c00814 	ori	r3,r3,32
8111d8ac:	00bfffc4 	movi	r2,-1
8111d8b0:	80c0030d 	sth	r3,12(r16)
8111d8b4:	003fed06 	br	8111d86c <__reset+0xfb0fd86c>
8111d8b8:	1125f940 	call	81125f94 <__sinit>
8111d8bc:	003fc206 	br	8111d7c8 <__reset+0xfb0fd7c8>
8111d8c0:	00a04574 	movhi	r2,33045
8111d8c4:	10b7d504 	addi	r2,r2,-8364
8111d8c8:	11000017 	ldw	r4,0(r2)
8111d8cc:	016044b4 	movhi	r5,33042
8111d8d0:	00800044 	movi	r2,1
8111d8d4:	2975df04 	addi	r5,r5,-10372
8111d8d8:	8080030d 	sth	r2,12(r16)
8111d8dc:	1126c080 	call	81126c08 <_fwalk>
8111d8e0:	00800244 	movi	r2,9
8111d8e4:	8480030d 	sth	r18,12(r16)
8111d8e8:	9480024c 	andi	r18,r18,9
8111d8ec:	90bfd51e 	bne	r18,r2,8111d844 <__reset+0xfb0fd844>
8111d8f0:	800b883a 	mov	r5,r16
8111d8f4:	8809883a 	mov	r4,r17
8111d8f8:	11259740 	call	81125974 <__sflush_r>
8111d8fc:	003fd106 	br	8111d844 <__reset+0xfb0fd844>
8111d900:	18c01014 	ori	r3,r3,64
8111d904:	80000115 	stw	zero,4(r16)
8111d908:	00bfffc4 	movi	r2,-1
8111d90c:	80c0030d 	sth	r3,12(r16)
8111d910:	003fd606 	br	8111d86c <__reset+0xfb0fd86c>
8111d914:	80c00e17 	ldw	r3,56(r16)
8111d918:	0005883a 	mov	r2,zero
8111d91c:	80c00015 	stw	r3,0(r16)
8111d920:	003fd206 	br	8111d86c <__reset+0xfb0fd86c>
8111d924:	800b883a 	mov	r5,r16
8111d928:	8809883a 	mov	r4,r17
8111d92c:	1125b980 	call	81125b98 <_fflush_r>
8111d930:	10000a1e 	bne	r2,zero,8111d95c <__srefill_r+0x1c4>
8111d934:	8080030b 	ldhu	r2,12(r16)
8111d938:	00fffdc4 	movi	r3,-9
8111d93c:	80000215 	stw	zero,8(r16)
8111d940:	1886703a 	and	r3,r3,r2
8111d944:	80000615 	stw	zero,24(r16)
8111d948:	003fd206 	br	8111d894 <__reset+0xfb0fd894>
8111d94c:	00800244 	movi	r2,9
8111d950:	88800015 	stw	r2,0(r17)
8111d954:	18c01014 	ori	r3,r3,64
8111d958:	80c0030d 	sth	r3,12(r16)
8111d95c:	00bfffc4 	movi	r2,-1
8111d960:	003fc206 	br	8111d86c <__reset+0xfb0fd86c>
8111d964:	800b883a 	mov	r5,r16
8111d968:	8809883a 	mov	r4,r17
8111d96c:	111c7f40 	call	8111c7f4 <__smakebuf_r>
8111d970:	003fb106 	br	8111d838 <__reset+0xfb0fd838>

8111d974 <_sbrk_r>:
8111d974:	defffd04 	addi	sp,sp,-12
8111d978:	de00012e 	bgeu	sp,et,8111d980 <_sbrk_r+0xc>
8111d97c:	003b68fa 	trap	3
8111d980:	dc000015 	stw	r16,0(sp)
8111d984:	04204574 	movhi	r16,33045
8111d988:	dc400115 	stw	r17,4(sp)
8111d98c:	84384404 	addi	r16,r16,-7920
8111d990:	2023883a 	mov	r17,r4
8111d994:	2809883a 	mov	r4,r5
8111d998:	dfc00215 	stw	ra,8(sp)
8111d99c:	80000015 	stw	zero,0(r16)
8111d9a0:	11331440 	call	81133144 <sbrk>
8111d9a4:	00ffffc4 	movi	r3,-1
8111d9a8:	10c00526 	beq	r2,r3,8111d9c0 <_sbrk_r+0x4c>
8111d9ac:	dfc00217 	ldw	ra,8(sp)
8111d9b0:	dc400117 	ldw	r17,4(sp)
8111d9b4:	dc000017 	ldw	r16,0(sp)
8111d9b8:	dec00304 	addi	sp,sp,12
8111d9bc:	f800283a 	ret
8111d9c0:	80c00017 	ldw	r3,0(r16)
8111d9c4:	183ff926 	beq	r3,zero,8111d9ac <__reset+0xfb0fd9ac>
8111d9c8:	88c00015 	stw	r3,0(r17)
8111d9cc:	003ff706 	br	8111d9ac <__reset+0xfb0fd9ac>

8111d9d0 <scanf>:
8111d9d0:	defffc04 	addi	sp,sp,-16
8111d9d4:	de00012e 	bgeu	sp,et,8111d9dc <scanf+0xc>
8111d9d8:	003b68fa 	trap	3
8111d9dc:	dfc00015 	stw	ra,0(sp)
8111d9e0:	d9400115 	stw	r5,4(sp)
8111d9e4:	d9800215 	stw	r6,8(sp)
8111d9e8:	d9c00315 	stw	r7,12(sp)
8111d9ec:	00a04574 	movhi	r2,33045
8111d9f0:	10b7d604 	addi	r2,r2,-8360
8111d9f4:	200d883a 	mov	r6,r4
8111d9f8:	11000017 	ldw	r4,0(r2)
8111d9fc:	d9c00104 	addi	r7,sp,4
8111da00:	21400117 	ldw	r5,4(r4)
8111da04:	1123d080 	call	81123d08 <_vfscanf_r>
8111da08:	dfc00017 	ldw	ra,0(sp)
8111da0c:	dec00404 	addi	sp,sp,16
8111da10:	f800283a 	ret

8111da14 <_scanf_r>:
8111da14:	defffd04 	addi	sp,sp,-12
8111da18:	2805883a 	mov	r2,r5
8111da1c:	de00012e 	bgeu	sp,et,8111da24 <_scanf_r+0x10>
8111da20:	003b68fa 	trap	3
8111da24:	dfc00015 	stw	ra,0(sp)
8111da28:	d9800115 	stw	r6,4(sp)
8111da2c:	d9c00215 	stw	r7,8(sp)
8111da30:	21400117 	ldw	r5,4(r4)
8111da34:	d9c00104 	addi	r7,sp,4
8111da38:	100d883a 	mov	r6,r2
8111da3c:	1123d080 	call	81123d08 <_vfscanf_r>
8111da40:	dfc00017 	ldw	ra,0(sp)
8111da44:	dec00304 	addi	sp,sp,12
8111da48:	f800283a 	ret

8111da4c <_sprintf_r>:
8111da4c:	deffe404 	addi	sp,sp,-112
8111da50:	2807883a 	mov	r3,r5
8111da54:	de00012e 	bgeu	sp,et,8111da5c <_sprintf_r+0x10>
8111da58:	003b68fa 	trap	3
8111da5c:	dfc01a15 	stw	ra,104(sp)
8111da60:	d9c01b15 	stw	r7,108(sp)
8111da64:	00a00034 	movhi	r2,32768
8111da68:	10bfffc4 	addi	r2,r2,-1
8111da6c:	02008204 	movi	r8,520
8111da70:	d8800215 	stw	r2,8(sp)
8111da74:	d8800515 	stw	r2,20(sp)
8111da78:	d9c01b04 	addi	r7,sp,108
8111da7c:	d80b883a 	mov	r5,sp
8111da80:	00bfffc4 	movi	r2,-1
8111da84:	d8c00015 	stw	r3,0(sp)
8111da88:	d8c00415 	stw	r3,16(sp)
8111da8c:	da00030d 	sth	r8,12(sp)
8111da90:	d880038d 	sth	r2,14(sp)
8111da94:	111dff80 	call	8111dff8 <___svfprintf_internal_r>
8111da98:	d8c00017 	ldw	r3,0(sp)
8111da9c:	18000005 	stb	zero,0(r3)
8111daa0:	dfc01a17 	ldw	ra,104(sp)
8111daa4:	dec01c04 	addi	sp,sp,112
8111daa8:	f800283a 	ret

8111daac <sprintf>:
8111daac:	deffe304 	addi	sp,sp,-116
8111dab0:	2007883a 	mov	r3,r4
8111dab4:	de00012e 	bgeu	sp,et,8111dabc <sprintf+0x10>
8111dab8:	003b68fa 	trap	3
8111dabc:	dfc01a15 	stw	ra,104(sp)
8111dac0:	d9801b15 	stw	r6,108(sp)
8111dac4:	d9c01c15 	stw	r7,112(sp)
8111dac8:	01204574 	movhi	r4,33045
8111dacc:	2137d604 	addi	r4,r4,-8360
8111dad0:	21000017 	ldw	r4,0(r4)
8111dad4:	00a00034 	movhi	r2,32768
8111dad8:	10bfffc4 	addi	r2,r2,-1
8111dadc:	280d883a 	mov	r6,r5
8111dae0:	02008204 	movi	r8,520
8111dae4:	d8800215 	stw	r2,8(sp)
8111dae8:	d8800515 	stw	r2,20(sp)
8111daec:	d9c01b04 	addi	r7,sp,108
8111daf0:	d80b883a 	mov	r5,sp
8111daf4:	00bfffc4 	movi	r2,-1
8111daf8:	d8c00015 	stw	r3,0(sp)
8111dafc:	d8c00415 	stw	r3,16(sp)
8111db00:	da00030d 	sth	r8,12(sp)
8111db04:	d880038d 	sth	r2,14(sp)
8111db08:	111dff80 	call	8111dff8 <___svfprintf_internal_r>
8111db0c:	d8c00017 	ldw	r3,0(sp)
8111db10:	18000005 	stb	zero,0(r3)
8111db14:	dfc01a17 	ldw	ra,104(sp)
8111db18:	dec01d04 	addi	sp,sp,116
8111db1c:	f800283a 	ret

8111db20 <__sread>:
8111db20:	defffe04 	addi	sp,sp,-8
8111db24:	de00012e 	bgeu	sp,et,8111db2c <__sread+0xc>
8111db28:	003b68fa 	trap	3
8111db2c:	dc000015 	stw	r16,0(sp)
8111db30:	2821883a 	mov	r16,r5
8111db34:	2940038f 	ldh	r5,14(r5)
8111db38:	dfc00115 	stw	ra,4(sp)
8111db3c:	11284580 	call	81128458 <_read_r>
8111db40:	10000716 	blt	r2,zero,8111db60 <__sread+0x40>
8111db44:	80c01417 	ldw	r3,80(r16)
8111db48:	1887883a 	add	r3,r3,r2
8111db4c:	80c01415 	stw	r3,80(r16)
8111db50:	dfc00117 	ldw	ra,4(sp)
8111db54:	dc000017 	ldw	r16,0(sp)
8111db58:	dec00204 	addi	sp,sp,8
8111db5c:	f800283a 	ret
8111db60:	80c0030b 	ldhu	r3,12(r16)
8111db64:	18fbffcc 	andi	r3,r3,61439
8111db68:	80c0030d 	sth	r3,12(r16)
8111db6c:	dfc00117 	ldw	ra,4(sp)
8111db70:	dc000017 	ldw	r16,0(sp)
8111db74:	dec00204 	addi	sp,sp,8
8111db78:	f800283a 	ret

8111db7c <__seofread>:
8111db7c:	0005883a 	mov	r2,zero
8111db80:	f800283a 	ret

8111db84 <__swrite>:
8111db84:	defffb04 	addi	sp,sp,-20
8111db88:	de00012e 	bgeu	sp,et,8111db90 <__swrite+0xc>
8111db8c:	003b68fa 	trap	3
8111db90:	2880030b 	ldhu	r2,12(r5)
8111db94:	dcc00315 	stw	r19,12(sp)
8111db98:	dc800215 	stw	r18,8(sp)
8111db9c:	dc400115 	stw	r17,4(sp)
8111dba0:	dc000015 	stw	r16,0(sp)
8111dba4:	dfc00415 	stw	ra,16(sp)
8111dba8:	10c0400c 	andi	r3,r2,256
8111dbac:	2821883a 	mov	r16,r5
8111dbb0:	2023883a 	mov	r17,r4
8111dbb4:	3025883a 	mov	r18,r6
8111dbb8:	3827883a 	mov	r19,r7
8111dbbc:	18000526 	beq	r3,zero,8111dbd4 <__swrite+0x50>
8111dbc0:	2940038f 	ldh	r5,14(r5)
8111dbc4:	01c00084 	movi	r7,2
8111dbc8:	000d883a 	mov	r6,zero
8111dbcc:	1126f100 	call	81126f10 <_lseek_r>
8111dbd0:	8080030b 	ldhu	r2,12(r16)
8111dbd4:	8140038f 	ldh	r5,14(r16)
8111dbd8:	10bbffcc 	andi	r2,r2,61439
8111dbdc:	980f883a 	mov	r7,r19
8111dbe0:	900d883a 	mov	r6,r18
8111dbe4:	8809883a 	mov	r4,r17
8111dbe8:	8080030d 	sth	r2,12(r16)
8111dbec:	dfc00417 	ldw	ra,16(sp)
8111dbf0:	dcc00317 	ldw	r19,12(sp)
8111dbf4:	dc800217 	ldw	r18,8(sp)
8111dbf8:	dc400117 	ldw	r17,4(sp)
8111dbfc:	dc000017 	ldw	r16,0(sp)
8111dc00:	dec00504 	addi	sp,sp,20
8111dc04:	1123ebc1 	jmpi	81123ebc <_write_r>

8111dc08 <__sseek>:
8111dc08:	defffe04 	addi	sp,sp,-8
8111dc0c:	de00012e 	bgeu	sp,et,8111dc14 <__sseek+0xc>
8111dc10:	003b68fa 	trap	3
8111dc14:	dc000015 	stw	r16,0(sp)
8111dc18:	2821883a 	mov	r16,r5
8111dc1c:	2940038f 	ldh	r5,14(r5)
8111dc20:	dfc00115 	stw	ra,4(sp)
8111dc24:	1126f100 	call	81126f10 <_lseek_r>
8111dc28:	00ffffc4 	movi	r3,-1
8111dc2c:	10c00826 	beq	r2,r3,8111dc50 <__sseek+0x48>
8111dc30:	80c0030b 	ldhu	r3,12(r16)
8111dc34:	80801415 	stw	r2,80(r16)
8111dc38:	18c40014 	ori	r3,r3,4096
8111dc3c:	80c0030d 	sth	r3,12(r16)
8111dc40:	dfc00117 	ldw	ra,4(sp)
8111dc44:	dc000017 	ldw	r16,0(sp)
8111dc48:	dec00204 	addi	sp,sp,8
8111dc4c:	f800283a 	ret
8111dc50:	80c0030b 	ldhu	r3,12(r16)
8111dc54:	18fbffcc 	andi	r3,r3,61439
8111dc58:	80c0030d 	sth	r3,12(r16)
8111dc5c:	dfc00117 	ldw	ra,4(sp)
8111dc60:	dc000017 	ldw	r16,0(sp)
8111dc64:	dec00204 	addi	sp,sp,8
8111dc68:	f800283a 	ret

8111dc6c <__sclose>:
8111dc6c:	2940038f 	ldh	r5,14(r5)
8111dc70:	11240801 	jmpi	81124080 <_close_r>

8111dc74 <strcspn>:
8111dc74:	21c00007 	ldb	r7,0(r4)
8111dc78:	38000f26 	beq	r7,zero,8111dcb8 <strcspn+0x44>
8111dc7c:	2a000007 	ldb	r8,0(r5)
8111dc80:	2005883a 	mov	r2,r4
8111dc84:	40000726 	beq	r8,zero,8111dca4 <strcspn+0x30>
8111dc88:	3a000926 	beq	r7,r8,8111dcb0 <strcspn+0x3c>
8111dc8c:	2807883a 	mov	r3,r5
8111dc90:	00000106 	br	8111dc98 <strcspn+0x24>
8111dc94:	31c00626 	beq	r6,r7,8111dcb0 <strcspn+0x3c>
8111dc98:	18c00044 	addi	r3,r3,1
8111dc9c:	19800007 	ldb	r6,0(r3)
8111dca0:	303ffc1e 	bne	r6,zero,8111dc94 <__reset+0xfb0fdc94>
8111dca4:	10800044 	addi	r2,r2,1
8111dca8:	11c00007 	ldb	r7,0(r2)
8111dcac:	383ff51e 	bne	r7,zero,8111dc84 <__reset+0xfb0fdc84>
8111dcb0:	1105c83a 	sub	r2,r2,r4
8111dcb4:	f800283a 	ret
8111dcb8:	0005883a 	mov	r2,zero
8111dcbc:	f800283a 	ret

8111dcc0 <strlen>:
8111dcc0:	208000cc 	andi	r2,r4,3
8111dcc4:	10002026 	beq	r2,zero,8111dd48 <strlen+0x88>
8111dcc8:	20800007 	ldb	r2,0(r4)
8111dccc:	10002026 	beq	r2,zero,8111dd50 <strlen+0x90>
8111dcd0:	2005883a 	mov	r2,r4
8111dcd4:	00000206 	br	8111dce0 <strlen+0x20>
8111dcd8:	10c00007 	ldb	r3,0(r2)
8111dcdc:	18001826 	beq	r3,zero,8111dd40 <strlen+0x80>
8111dce0:	10800044 	addi	r2,r2,1
8111dce4:	10c000cc 	andi	r3,r2,3
8111dce8:	183ffb1e 	bne	r3,zero,8111dcd8 <__reset+0xfb0fdcd8>
8111dcec:	10c00017 	ldw	r3,0(r2)
8111dcf0:	01ffbff4 	movhi	r7,65279
8111dcf4:	39ffbfc4 	addi	r7,r7,-257
8111dcf8:	00ca303a 	nor	r5,zero,r3
8111dcfc:	01a02074 	movhi	r6,32897
8111dd00:	19c7883a 	add	r3,r3,r7
8111dd04:	31a02004 	addi	r6,r6,-32640
8111dd08:	1946703a 	and	r3,r3,r5
8111dd0c:	1986703a 	and	r3,r3,r6
8111dd10:	1800091e 	bne	r3,zero,8111dd38 <strlen+0x78>
8111dd14:	10800104 	addi	r2,r2,4
8111dd18:	10c00017 	ldw	r3,0(r2)
8111dd1c:	19cb883a 	add	r5,r3,r7
8111dd20:	00c6303a 	nor	r3,zero,r3
8111dd24:	28c6703a 	and	r3,r5,r3
8111dd28:	1986703a 	and	r3,r3,r6
8111dd2c:	183ff926 	beq	r3,zero,8111dd14 <__reset+0xfb0fdd14>
8111dd30:	00000106 	br	8111dd38 <strlen+0x78>
8111dd34:	10800044 	addi	r2,r2,1
8111dd38:	10c00007 	ldb	r3,0(r2)
8111dd3c:	183ffd1e 	bne	r3,zero,8111dd34 <__reset+0xfb0fdd34>
8111dd40:	1105c83a 	sub	r2,r2,r4
8111dd44:	f800283a 	ret
8111dd48:	2005883a 	mov	r2,r4
8111dd4c:	003fe706 	br	8111dcec <__reset+0xfb0fdcec>
8111dd50:	0005883a 	mov	r2,zero
8111dd54:	f800283a 	ret

8111dd58 <strnlen>:
8111dd58:	28000e26 	beq	r5,zero,8111dd94 <strnlen+0x3c>
8111dd5c:	20800007 	ldb	r2,0(r4)
8111dd60:	10000c26 	beq	r2,zero,8111dd94 <strnlen+0x3c>
8111dd64:	20c00044 	addi	r3,r4,1
8111dd68:	214b883a 	add	r5,r4,r5
8111dd6c:	28c00526 	beq	r5,r3,8111dd84 <strnlen+0x2c>
8111dd70:	19800007 	ldb	r6,0(r3)
8111dd74:	19c00044 	addi	r7,r3,1
8111dd78:	30000426 	beq	r6,zero,8111dd8c <strnlen+0x34>
8111dd7c:	3807883a 	mov	r3,r7
8111dd80:	28fffb1e 	bne	r5,r3,8111dd70 <__reset+0xfb0fdd70>
8111dd84:	2905c83a 	sub	r2,r5,r4
8111dd88:	f800283a 	ret
8111dd8c:	1905c83a 	sub	r2,r3,r4
8111dd90:	f800283a 	ret
8111dd94:	0005883a 	mov	r2,zero
8111dd98:	f800283a 	ret

8111dd9c <_strtol_r>:
8111dd9c:	00a04574 	movhi	r2,33045
8111dda0:	defff404 	addi	sp,sp,-48
8111dda4:	10b7d404 	addi	r2,r2,-8368
8111dda8:	de00012e 	bgeu	sp,et,8111ddb0 <_strtol_r+0x14>
8111ddac:	003b68fa 	trap	3
8111ddb0:	dd400715 	stw	r21,28(sp)
8111ddb4:	15400017 	ldw	r21,0(r2)
8111ddb8:	dd800815 	stw	r22,32(sp)
8111ddbc:	dd000615 	stw	r20,24(sp)
8111ddc0:	dcc00515 	stw	r19,20(sp)
8111ddc4:	d9000015 	stw	r4,0(sp)
8111ddc8:	dfc00b15 	stw	ra,44(sp)
8111ddcc:	df000a15 	stw	fp,40(sp)
8111ddd0:	ddc00915 	stw	r23,36(sp)
8111ddd4:	dc800415 	stw	r18,16(sp)
8111ddd8:	dc400315 	stw	r17,12(sp)
8111dddc:	dc000215 	stw	r16,8(sp)
8111dde0:	2829883a 	mov	r20,r5
8111dde4:	3027883a 	mov	r19,r6
8111dde8:	382d883a 	mov	r22,r7
8111ddec:	2809883a 	mov	r4,r5
8111ddf0:	24000003 	ldbu	r16,0(r4)
8111ddf4:	24400044 	addi	r17,r4,1
8111ddf8:	2007883a 	mov	r3,r4
8111ddfc:	ac05883a 	add	r2,r21,r16
8111de00:	10800043 	ldbu	r2,1(r2)
8111de04:	8809883a 	mov	r4,r17
8111de08:	1080020c 	andi	r2,r2,8
8111de0c:	103ff81e 	bne	r2,zero,8111ddf0 <__reset+0xfb0fddf0>
8111de10:	00800b44 	movi	r2,45
8111de14:	80805826 	beq	r16,r2,8111df78 <_strtol_r+0x1dc>
8111de18:	00800ac4 	movi	r2,43
8111de1c:	80805a26 	beq	r16,r2,8111df88 <_strtol_r+0x1ec>
8111de20:	0039883a 	mov	fp,zero
8111de24:	b0004426 	beq	r22,zero,8111df38 <_strtol_r+0x19c>
8111de28:	00800404 	movi	r2,16
8111de2c:	b0806026 	beq	r22,r2,8111dfb0 <_strtol_r+0x214>
8111de30:	b02f883a 	mov	r23,r22
8111de34:	00a00034 	movhi	r2,32768
8111de38:	e025003a 	cmpeq	r18,fp,zero
8111de3c:	14a5c83a 	sub	r18,r2,r18
8111de40:	b80b883a 	mov	r5,r23
8111de44:	9009883a 	mov	r4,r18
8111de48:	112f8180 	call	8112f818 <__umodsi3>
8111de4c:	b80b883a 	mov	r5,r23
8111de50:	9009883a 	mov	r4,r18
8111de54:	d8800115 	stw	r2,4(sp)
8111de58:	112f7b40 	call	8112f7b4 <__udivsi3>
8111de5c:	ac07883a 	add	r3,r21,r16
8111de60:	18c00043 	ldbu	r3,1(r3)
8111de64:	880b883a 	mov	r5,r17
8111de68:	000d883a 	mov	r6,zero
8111de6c:	1a00010c 	andi	r8,r3,4
8111de70:	0009883a 	mov	r4,zero
8111de74:	02800044 	movi	r10,1
8111de78:	027fffc4 	movi	r9,-1
8111de7c:	d9c00117 	ldw	r7,4(sp)
8111de80:	40000e26 	beq	r8,zero,8111debc <_strtol_r+0x120>
8111de84:	843ff404 	addi	r16,r16,-48
8111de88:	8580120e 	bge	r16,r22,8111ded4 <_strtol_r+0x138>
8111de8c:	32400526 	beq	r6,r9,8111dea4 <_strtol_r+0x108>
8111de90:	11002536 	bltu	r2,r4,8111df28 <_strtol_r+0x18c>
8111de94:	20802326 	beq	r4,r2,8111df24 <_strtol_r+0x188>
8111de98:	25c9383a 	mul	r4,r4,r23
8111de9c:	01800044 	movi	r6,1
8111dea0:	8109883a 	add	r4,r16,r4
8111dea4:	2c000003 	ldbu	r16,0(r5)
8111dea8:	29400044 	addi	r5,r5,1
8111deac:	ac07883a 	add	r3,r21,r16
8111deb0:	18c00043 	ldbu	r3,1(r3)
8111deb4:	1a00010c 	andi	r8,r3,4
8111deb8:	403ff21e 	bne	r8,zero,8111de84 <__reset+0xfb0fde84>
8111debc:	18c000cc 	andi	r3,r3,3
8111dec0:	18000426 	beq	r3,zero,8111ded4 <_strtol_r+0x138>
8111dec4:	1a801a26 	beq	r3,r10,8111df30 <_strtol_r+0x194>
8111dec8:	00c015c4 	movi	r3,87
8111decc:	80e1c83a 	sub	r16,r16,r3
8111ded0:	85bfee16 	blt	r16,r22,8111de8c <__reset+0xfb0fde8c>
8111ded4:	00bfffc4 	movi	r2,-1
8111ded8:	30801e26 	beq	r6,r2,8111df54 <_strtol_r+0x1b8>
8111dedc:	e0001b1e 	bne	fp,zero,8111df4c <_strtol_r+0x1b0>
8111dee0:	2005883a 	mov	r2,r4
8111dee4:	98000326 	beq	r19,zero,8111def4 <_strtol_r+0x158>
8111dee8:	3000211e 	bne	r6,zero,8111df70 <_strtol_r+0x1d4>
8111deec:	a00b883a 	mov	r5,r20
8111def0:	99400015 	stw	r5,0(r19)
8111def4:	dfc00b17 	ldw	ra,44(sp)
8111def8:	df000a17 	ldw	fp,40(sp)
8111defc:	ddc00917 	ldw	r23,36(sp)
8111df00:	dd800817 	ldw	r22,32(sp)
8111df04:	dd400717 	ldw	r21,28(sp)
8111df08:	dd000617 	ldw	r20,24(sp)
8111df0c:	dcc00517 	ldw	r19,20(sp)
8111df10:	dc800417 	ldw	r18,16(sp)
8111df14:	dc400317 	ldw	r17,12(sp)
8111df18:	dc000217 	ldw	r16,8(sp)
8111df1c:	dec00c04 	addi	sp,sp,48
8111df20:	f800283a 	ret
8111df24:	3c3fdc0e 	bge	r7,r16,8111de98 <__reset+0xfb0fde98>
8111df28:	01bfffc4 	movi	r6,-1
8111df2c:	003fdd06 	br	8111dea4 <__reset+0xfb0fdea4>
8111df30:	00c00dc4 	movi	r3,55
8111df34:	003fe506 	br	8111decc <__reset+0xfb0fdecc>
8111df38:	00800c04 	movi	r2,48
8111df3c:	80801626 	beq	r16,r2,8111df98 <_strtol_r+0x1fc>
8111df40:	05800284 	movi	r22,10
8111df44:	b02f883a 	mov	r23,r22
8111df48:	003fba06 	br	8111de34 <__reset+0xfb0fde34>
8111df4c:	0109c83a 	sub	r4,zero,r4
8111df50:	003fe306 	br	8111dee0 <__reset+0xfb0fdee0>
8111df54:	d9000017 	ldw	r4,0(sp)
8111df58:	00c00884 	movi	r3,34
8111df5c:	e005003a 	cmpeq	r2,fp,zero
8111df60:	20c00015 	stw	r3,0(r4)
8111df64:	00e00034 	movhi	r3,32768
8111df68:	1885c83a 	sub	r2,r3,r2
8111df6c:	983fe126 	beq	r19,zero,8111def4 <__reset+0xfb0fdef4>
8111df70:	297fffc4 	addi	r5,r5,-1
8111df74:	003fde06 	br	8111def0 <__reset+0xfb0fdef0>
8111df78:	1c400084 	addi	r17,r3,2
8111df7c:	1c000043 	ldbu	r16,1(r3)
8111df80:	07000044 	movi	fp,1
8111df84:	003fa706 	br	8111de24 <__reset+0xfb0fde24>
8111df88:	1c400084 	addi	r17,r3,2
8111df8c:	1c000043 	ldbu	r16,1(r3)
8111df90:	0039883a 	mov	fp,zero
8111df94:	003fa306 	br	8111de24 <__reset+0xfb0fde24>
8111df98:	88800003 	ldbu	r2,0(r17)
8111df9c:	00c01604 	movi	r3,88
8111dfa0:	108037cc 	andi	r2,r2,223
8111dfa4:	10c00826 	beq	r2,r3,8111dfc8 <_strtol_r+0x22c>
8111dfa8:	05800204 	movi	r22,8
8111dfac:	003fa006 	br	8111de30 <__reset+0xfb0fde30>
8111dfb0:	00800c04 	movi	r2,48
8111dfb4:	80bf9e1e 	bne	r16,r2,8111de30 <__reset+0xfb0fde30>
8111dfb8:	88800003 	ldbu	r2,0(r17)
8111dfbc:	00c01604 	movi	r3,88
8111dfc0:	108037cc 	andi	r2,r2,223
8111dfc4:	10ff9a1e 	bne	r2,r3,8111de30 <__reset+0xfb0fde30>
8111dfc8:	05c00404 	movi	r23,16
8111dfcc:	8c000043 	ldbu	r16,1(r17)
8111dfd0:	b82d883a 	mov	r22,r23
8111dfd4:	8c400084 	addi	r17,r17,2
8111dfd8:	003f9606 	br	8111de34 <__reset+0xfb0fde34>

8111dfdc <strtol>:
8111dfdc:	00a04574 	movhi	r2,33045
8111dfe0:	10b7d604 	addi	r2,r2,-8360
8111dfe4:	300f883a 	mov	r7,r6
8111dfe8:	280d883a 	mov	r6,r5
8111dfec:	200b883a 	mov	r5,r4
8111dff0:	11000017 	ldw	r4,0(r2)
8111dff4:	111dd9c1 	jmpi	8111dd9c <_strtol_r>

8111dff8 <___svfprintf_internal_r>:
8111dff8:	deffb704 	addi	sp,sp,-292
8111dffc:	de00012e 	bgeu	sp,et,8111e004 <___svfprintf_internal_r+0xc>
8111e000:	003b68fa 	trap	3
8111e004:	dfc04815 	stw	ra,288(sp)
8111e008:	ddc04615 	stw	r23,280(sp)
8111e00c:	d9402c15 	stw	r5,176(sp)
8111e010:	d9003915 	stw	r4,228(sp)
8111e014:	302f883a 	mov	r23,r6
8111e018:	d9c02d15 	stw	r7,180(sp)
8111e01c:	df004715 	stw	fp,284(sp)
8111e020:	dd804515 	stw	r22,276(sp)
8111e024:	dd404415 	stw	r21,272(sp)
8111e028:	dd004315 	stw	r20,268(sp)
8111e02c:	dcc04215 	stw	r19,264(sp)
8111e030:	dc804115 	stw	r18,260(sp)
8111e034:	dc404015 	stw	r17,256(sp)
8111e038:	dc003f15 	stw	r16,252(sp)
8111e03c:	1126ee00 	call	81126ee0 <_localeconv_r>
8111e040:	10800017 	ldw	r2,0(r2)
8111e044:	1009883a 	mov	r4,r2
8111e048:	d8803415 	stw	r2,208(sp)
8111e04c:	111dcc00 	call	8111dcc0 <strlen>
8111e050:	d8c02c17 	ldw	r3,176(sp)
8111e054:	d8803815 	stw	r2,224(sp)
8111e058:	1880030b 	ldhu	r2,12(r3)
8111e05c:	1080200c 	andi	r2,r2,128
8111e060:	10000226 	beq	r2,zero,8111e06c <___svfprintf_internal_r+0x74>
8111e064:	18800417 	ldw	r2,16(r3)
8111e068:	10067f26 	beq	r2,zero,8111fa68 <___svfprintf_internal_r+0x1a70>
8111e06c:	dcc03917 	ldw	r19,228(sp)
8111e070:	d8c00404 	addi	r3,sp,16
8111e074:	05604574 	movhi	r21,33045
8111e078:	d9001e04 	addi	r4,sp,120
8111e07c:	ad6e0e84 	addi	r21,r21,-18374
8111e080:	d8c01e15 	stw	r3,120(sp)
8111e084:	d8002015 	stw	zero,128(sp)
8111e088:	d8001f15 	stw	zero,124(sp)
8111e08c:	d8003315 	stw	zero,204(sp)
8111e090:	d8003615 	stw	zero,216(sp)
8111e094:	d8003715 	stw	zero,220(sp)
8111e098:	1811883a 	mov	r8,r3
8111e09c:	d8003a15 	stw	zero,232(sp)
8111e0a0:	d8003b15 	stw	zero,236(sp)
8111e0a4:	d8002f15 	stw	zero,188(sp)
8111e0a8:	d9002815 	stw	r4,160(sp)
8111e0ac:	b8800007 	ldb	r2,0(r23)
8111e0b0:	10026726 	beq	r2,zero,8111ea50 <___svfprintf_internal_r+0xa58>
8111e0b4:	00c00944 	movi	r3,37
8111e0b8:	b821883a 	mov	r16,r23
8111e0bc:	10c0021e 	bne	r2,r3,8111e0c8 <___svfprintf_internal_r+0xd0>
8111e0c0:	00001406 	br	8111e114 <___svfprintf_internal_r+0x11c>
8111e0c4:	10c00326 	beq	r2,r3,8111e0d4 <___svfprintf_internal_r+0xdc>
8111e0c8:	84000044 	addi	r16,r16,1
8111e0cc:	80800007 	ldb	r2,0(r16)
8111e0d0:	103ffc1e 	bne	r2,zero,8111e0c4 <__reset+0xfb0fe0c4>
8111e0d4:	85e3c83a 	sub	r17,r16,r23
8111e0d8:	88000e26 	beq	r17,zero,8111e114 <___svfprintf_internal_r+0x11c>
8111e0dc:	d8c02017 	ldw	r3,128(sp)
8111e0e0:	d8801f17 	ldw	r2,124(sp)
8111e0e4:	45c00015 	stw	r23,0(r8)
8111e0e8:	1c47883a 	add	r3,r3,r17
8111e0ec:	10800044 	addi	r2,r2,1
8111e0f0:	d8c02015 	stw	r3,128(sp)
8111e0f4:	44400115 	stw	r17,4(r8)
8111e0f8:	d8801f15 	stw	r2,124(sp)
8111e0fc:	00c001c4 	movi	r3,7
8111e100:	18809716 	blt	r3,r2,8111e360 <___svfprintf_internal_r+0x368>
8111e104:	42000204 	addi	r8,r8,8
8111e108:	d9402f17 	ldw	r5,188(sp)
8111e10c:	2c4b883a 	add	r5,r5,r17
8111e110:	d9402f15 	stw	r5,188(sp)
8111e114:	80800007 	ldb	r2,0(r16)
8111e118:	10009826 	beq	r2,zero,8111e37c <___svfprintf_internal_r+0x384>
8111e11c:	84400047 	ldb	r17,1(r16)
8111e120:	00bfffc4 	movi	r2,-1
8111e124:	85c00044 	addi	r23,r16,1
8111e128:	d8002785 	stb	zero,158(sp)
8111e12c:	0007883a 	mov	r3,zero
8111e130:	000f883a 	mov	r7,zero
8111e134:	d8802915 	stw	r2,164(sp)
8111e138:	d8003115 	stw	zero,196(sp)
8111e13c:	0025883a 	mov	r18,zero
8111e140:	01401604 	movi	r5,88
8111e144:	01800244 	movi	r6,9
8111e148:	02800a84 	movi	r10,42
8111e14c:	02401b04 	movi	r9,108
8111e150:	bdc00044 	addi	r23,r23,1
8111e154:	88bff804 	addi	r2,r17,-32
8111e158:	2882f036 	bltu	r5,r2,8111ed1c <___svfprintf_internal_r+0xd24>
8111e15c:	100490ba 	slli	r2,r2,2
8111e160:	012044b4 	movhi	r4,33042
8111e164:	21385d04 	addi	r4,r4,-7820
8111e168:	1105883a 	add	r2,r2,r4
8111e16c:	10800017 	ldw	r2,0(r2)
8111e170:	1000683a 	jmp	r2
8111e174:	8111ec84 	addi	r4,r16,18354
8111e178:	8111ed1c 	xori	r4,r16,18356
8111e17c:	8111ed1c 	xori	r4,r16,18356
8111e180:	8111ec78 	rdprs	r4,r16,18353
8111e184:	8111ed1c 	xori	r4,r16,18356
8111e188:	8111ed1c 	xori	r4,r16,18356
8111e18c:	8111ed1c 	xori	r4,r16,18356
8111e190:	8111ed1c 	xori	r4,r16,18356
8111e194:	8111ed1c 	xori	r4,r16,18356
8111e198:	8111ed1c 	xori	r4,r16,18356
8111e19c:	8111e3d8 	cmpnei	r4,r16,18319
8111e1a0:	8111ebb4 	orhi	r4,r16,18350
8111e1a4:	8111ed1c 	xori	r4,r16,18356
8111e1a8:	8111e2e8 	cmpgeui	r4,r16,18315
8111e1ac:	8111e400 	call	88111e40 <__reset+0x20f1e40>
8111e1b0:	8111ed1c 	xori	r4,r16,18356
8111e1b4:	8111e474 	orhi	r4,r16,18321
8111e1b8:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1bc:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1c0:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1c4:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1c8:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1cc:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1d0:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1d4:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1d8:	8111e440 	call	88111e44 <__reset+0x20f1e44>
8111e1dc:	8111ed1c 	xori	r4,r16,18356
8111e1e0:	8111ed1c 	xori	r4,r16,18356
8111e1e4:	8111ed1c 	xori	r4,r16,18356
8111e1e8:	8111ed1c 	xori	r4,r16,18356
8111e1ec:	8111ed1c 	xori	r4,r16,18356
8111e1f0:	8111ed1c 	xori	r4,r16,18356
8111e1f4:	8111ed1c 	xori	r4,r16,18356
8111e1f8:	8111ed1c 	xori	r4,r16,18356
8111e1fc:	8111ed1c 	xori	r4,r16,18356
8111e200:	8111ed1c 	xori	r4,r16,18356
8111e204:	8111e52c 	andhi	r4,r16,18324
8111e208:	8111e480 	call	88111e48 <__reset+0x20f1e48>
8111e20c:	8111ed1c 	xori	r4,r16,18356
8111e210:	8111e480 	call	88111e48 <__reset+0x20f1e48>
8111e214:	8111ed1c 	xori	r4,r16,18356
8111e218:	8111ed1c 	xori	r4,r16,18356
8111e21c:	8111ed1c 	xori	r4,r16,18356
8111e220:	8111ed1c 	xori	r4,r16,18356
8111e224:	8111e520 	cmpeqi	r4,r16,18324
8111e228:	8111ed1c 	xori	r4,r16,18356
8111e22c:	8111ed1c 	xori	r4,r16,18356
8111e230:	8111e5e8 	cmpgeui	r4,r16,18327
8111e234:	8111ed1c 	xori	r4,r16,18356
8111e238:	8111ed1c 	xori	r4,r16,18356
8111e23c:	8111ed1c 	xori	r4,r16,18356
8111e240:	8111ed1c 	xori	r4,r16,18356
8111e244:	8111ed1c 	xori	r4,r16,18356
8111e248:	8111ea58 	cmpnei	r4,r16,18345
8111e24c:	8111ed1c 	xori	r4,r16,18356
8111e250:	8111ed1c 	xori	r4,r16,18356
8111e254:	8111eab8 	rdprs	r4,r16,18346
8111e258:	8111ed1c 	xori	r4,r16,18356
8111e25c:	8111ed1c 	xori	r4,r16,18356
8111e260:	8111ed1c 	xori	r4,r16,18356
8111e264:	8111ed1c 	xori	r4,r16,18356
8111e268:	8111ed1c 	xori	r4,r16,18356
8111e26c:	8111ed1c 	xori	r4,r16,18356
8111e270:	8111ed1c 	xori	r4,r16,18356
8111e274:	8111ed1c 	xori	r4,r16,18356
8111e278:	8111ed1c 	xori	r4,r16,18356
8111e27c:	8111ed1c 	xori	r4,r16,18356
8111e280:	8111eb68 	cmpgeui	r4,r16,18349
8111e284:	8111eca4 	muli	r4,r16,18354
8111e288:	8111e480 	call	88111e48 <__reset+0x20f1e48>
8111e28c:	8111e480 	call	88111e48 <__reset+0x20f1e48>
8111e290:	8111e480 	call	88111e48 <__reset+0x20f1e48>
8111e294:	8111ecf8 	rdprs	r4,r16,18355
8111e298:	8111eca4 	muli	r4,r16,18354
8111e29c:	8111ed1c 	xori	r4,r16,18356
8111e2a0:	8111ed1c 	xori	r4,r16,18356
8111e2a4:	8111ecb4 	orhi	r4,r16,18354
8111e2a8:	8111ed1c 	xori	r4,r16,18356
8111e2ac:	8111ecc4 	addi	r4,r16,18355
8111e2b0:	8111eba4 	muli	r4,r16,18350
8111e2b4:	8111e2f4 	orhi	r4,r16,18315
8111e2b8:	8111ebc4 	addi	r4,r16,18351
8111e2bc:	8111ed1c 	xori	r4,r16,18356
8111e2c0:	8111ebd0 	cmplti	r4,r16,18351
8111e2c4:	8111ed1c 	xori	r4,r16,18356
8111e2c8:	8111ec2c 	andhi	r4,r16,18352
8111e2cc:	8111ed1c 	xori	r4,r16,18356
8111e2d0:	8111ed1c 	xori	r4,r16,18356
8111e2d4:	8111ec3c 	xorhi	r4,r16,18352
8111e2d8:	d9003117 	ldw	r4,196(sp)
8111e2dc:	d8802d15 	stw	r2,180(sp)
8111e2e0:	0109c83a 	sub	r4,zero,r4
8111e2e4:	d9003115 	stw	r4,196(sp)
8111e2e8:	94800114 	ori	r18,r18,4
8111e2ec:	bc400007 	ldb	r17,0(r23)
8111e2f0:	003f9706 	br	8111e150 <__reset+0xfb0fe150>
8111e2f4:	00800c04 	movi	r2,48
8111e2f8:	d9002d17 	ldw	r4,180(sp)
8111e2fc:	d9402917 	ldw	r5,164(sp)
8111e300:	d8802705 	stb	r2,156(sp)
8111e304:	00801e04 	movi	r2,120
8111e308:	d8802745 	stb	r2,157(sp)
8111e30c:	d8002785 	stb	zero,158(sp)
8111e310:	20c00104 	addi	r3,r4,4
8111e314:	25000017 	ldw	r20,0(r4)
8111e318:	002d883a 	mov	r22,zero
8111e31c:	90800094 	ori	r2,r18,2
8111e320:	28028616 	blt	r5,zero,8111ed3c <___svfprintf_internal_r+0xd44>
8111e324:	00bfdfc4 	movi	r2,-129
8111e328:	90a4703a 	and	r18,r18,r2
8111e32c:	d8c02d15 	stw	r3,180(sp)
8111e330:	94800094 	ori	r18,r18,2
8111e334:	a002731e 	bne	r20,zero,8111ed04 <___svfprintf_internal_r+0xd0c>
8111e338:	00a04574 	movhi	r2,33045
8111e33c:	10ae0704 	addi	r2,r2,-18404
8111e340:	d8803a15 	stw	r2,232(sp)
8111e344:	04401e04 	movi	r17,120
8111e348:	d8c02917 	ldw	r3,164(sp)
8111e34c:	0039883a 	mov	fp,zero
8111e350:	1801d526 	beq	r3,zero,8111eaa8 <___svfprintf_internal_r+0xab0>
8111e354:	0029883a 	mov	r20,zero
8111e358:	002d883a 	mov	r22,zero
8111e35c:	0001f106 	br	8111eb24 <___svfprintf_internal_r+0xb2c>
8111e360:	d9402c17 	ldw	r5,176(sp)
8111e364:	d9801e04 	addi	r6,sp,120
8111e368:	9809883a 	mov	r4,r19
8111e36c:	112ac180 	call	8112ac18 <__ssprint_r>
8111e370:	1000081e 	bne	r2,zero,8111e394 <___svfprintf_internal_r+0x39c>
8111e374:	da000404 	addi	r8,sp,16
8111e378:	003f6306 	br	8111e108 <__reset+0xfb0fe108>
8111e37c:	d8802017 	ldw	r2,128(sp)
8111e380:	10000426 	beq	r2,zero,8111e394 <___svfprintf_internal_r+0x39c>
8111e384:	d9402c17 	ldw	r5,176(sp)
8111e388:	d9003917 	ldw	r4,228(sp)
8111e38c:	d9801e04 	addi	r6,sp,120
8111e390:	112ac180 	call	8112ac18 <__ssprint_r>
8111e394:	d8802c17 	ldw	r2,176(sp)
8111e398:	10c0030b 	ldhu	r3,12(r2)
8111e39c:	d8802f17 	ldw	r2,188(sp)
8111e3a0:	18c0100c 	andi	r3,r3,64
8111e3a4:	1805f51e 	bne	r3,zero,8111fb7c <___svfprintf_internal_r+0x1b84>
8111e3a8:	dfc04817 	ldw	ra,288(sp)
8111e3ac:	df004717 	ldw	fp,284(sp)
8111e3b0:	ddc04617 	ldw	r23,280(sp)
8111e3b4:	dd804517 	ldw	r22,276(sp)
8111e3b8:	dd404417 	ldw	r21,272(sp)
8111e3bc:	dd004317 	ldw	r20,268(sp)
8111e3c0:	dcc04217 	ldw	r19,264(sp)
8111e3c4:	dc804117 	ldw	r18,260(sp)
8111e3c8:	dc404017 	ldw	r17,256(sp)
8111e3cc:	dc003f17 	ldw	r16,252(sp)
8111e3d0:	dec04904 	addi	sp,sp,292
8111e3d4:	f800283a 	ret
8111e3d8:	d8802d17 	ldw	r2,180(sp)
8111e3dc:	d9002d17 	ldw	r4,180(sp)
8111e3e0:	10800017 	ldw	r2,0(r2)
8111e3e4:	d8803115 	stw	r2,196(sp)
8111e3e8:	20800104 	addi	r2,r4,4
8111e3ec:	d9003117 	ldw	r4,196(sp)
8111e3f0:	203fb916 	blt	r4,zero,8111e2d8 <__reset+0xfb0fe2d8>
8111e3f4:	d8802d15 	stw	r2,180(sp)
8111e3f8:	bc400007 	ldb	r17,0(r23)
8111e3fc:	003f5406 	br	8111e150 <__reset+0xfb0fe150>
8111e400:	bc400007 	ldb	r17,0(r23)
8111e404:	bac00044 	addi	r11,r23,1
8111e408:	8a873926 	beq	r17,r10,811200f0 <___svfprintf_internal_r+0x20f8>
8111e40c:	88bff404 	addi	r2,r17,-48
8111e410:	0009883a 	mov	r4,zero
8111e414:	30868836 	bltu	r6,r2,8111fe38 <___svfprintf_internal_r+0x1e40>
8111e418:	5c400007 	ldb	r17,0(r11)
8111e41c:	210002a4 	muli	r4,r4,10
8111e420:	5dc00044 	addi	r23,r11,1
8111e424:	b817883a 	mov	r11,r23
8111e428:	2089883a 	add	r4,r4,r2
8111e42c:	88bff404 	addi	r2,r17,-48
8111e430:	30bff92e 	bgeu	r6,r2,8111e418 <__reset+0xfb0fe418>
8111e434:	2005d716 	blt	r4,zero,8111fb94 <___svfprintf_internal_r+0x1b9c>
8111e438:	d9002915 	stw	r4,164(sp)
8111e43c:	003f4506 	br	8111e154 <__reset+0xfb0fe154>
8111e440:	b809883a 	mov	r4,r23
8111e444:	d8003115 	stw	zero,196(sp)
8111e448:	88bff404 	addi	r2,r17,-48
8111e44c:	0017883a 	mov	r11,zero
8111e450:	24400007 	ldb	r17,0(r4)
8111e454:	5ac002a4 	muli	r11,r11,10
8111e458:	bdc00044 	addi	r23,r23,1
8111e45c:	b809883a 	mov	r4,r23
8111e460:	12d7883a 	add	r11,r2,r11
8111e464:	88bff404 	addi	r2,r17,-48
8111e468:	30bff92e 	bgeu	r6,r2,8111e450 <__reset+0xfb0fe450>
8111e46c:	dac03115 	stw	r11,196(sp)
8111e470:	003f3806 	br	8111e154 <__reset+0xfb0fe154>
8111e474:	94802014 	ori	r18,r18,128
8111e478:	bc400007 	ldb	r17,0(r23)
8111e47c:	003f3406 	br	8111e150 <__reset+0xfb0fe150>
8111e480:	18c03fcc 	andi	r3,r3,255
8111e484:	1807471e 	bne	r3,zero,811201a4 <___svfprintf_internal_r+0x21ac>
8111e488:	9080020c 	andi	r2,r18,8
8111e48c:	10047d26 	beq	r2,zero,8111f684 <___svfprintf_internal_r+0x168c>
8111e490:	d8c02d17 	ldw	r3,180(sp)
8111e494:	d9002d17 	ldw	r4,180(sp)
8111e498:	d9402d17 	ldw	r5,180(sp)
8111e49c:	18c00017 	ldw	r3,0(r3)
8111e4a0:	21000117 	ldw	r4,4(r4)
8111e4a4:	29400204 	addi	r5,r5,8
8111e4a8:	d8c03615 	stw	r3,216(sp)
8111e4ac:	d9003715 	stw	r4,220(sp)
8111e4b0:	d9402d15 	stw	r5,180(sp)
8111e4b4:	d9003617 	ldw	r4,216(sp)
8111e4b8:	d9403717 	ldw	r5,220(sp)
8111e4bc:	da003e15 	stw	r8,248(sp)
8111e4c0:	04000044 	movi	r16,1
8111e4c4:	1128a2c0 	call	81128a2c <__fpclassifyd>
8111e4c8:	da003e17 	ldw	r8,248(sp)
8111e4cc:	14044b1e 	bne	r2,r16,8111f5fc <___svfprintf_internal_r+0x1604>
8111e4d0:	d9003617 	ldw	r4,216(sp)
8111e4d4:	d9403717 	ldw	r5,220(sp)
8111e4d8:	000d883a 	mov	r6,zero
8111e4dc:	000f883a 	mov	r7,zero
8111e4e0:	1130d740 	call	81130d74 <__ledf2>
8111e4e4:	da003e17 	ldw	r8,248(sp)
8111e4e8:	1005f316 	blt	r2,zero,8111fcb8 <___svfprintf_internal_r+0x1cc0>
8111e4ec:	df002783 	ldbu	fp,158(sp)
8111e4f0:	008011c4 	movi	r2,71
8111e4f4:	1445590e 	bge	r2,r17,8111fa5c <___svfprintf_internal_r+0x1a64>
8111e4f8:	04204574 	movhi	r16,33045
8111e4fc:	842dff04 	addi	r16,r16,-18436
8111e500:	00c000c4 	movi	r3,3
8111e504:	00bfdfc4 	movi	r2,-129
8111e508:	d8c02a15 	stw	r3,168(sp)
8111e50c:	90a4703a 	and	r18,r18,r2
8111e510:	d8c02e15 	stw	r3,184(sp)
8111e514:	d8002915 	stw	zero,164(sp)
8111e518:	d8003215 	stw	zero,200(sp)
8111e51c:	00006606 	br	8111e6b8 <___svfprintf_internal_r+0x6c0>
8111e520:	94800214 	ori	r18,r18,8
8111e524:	bc400007 	ldb	r17,0(r23)
8111e528:	003f0906 	br	8111e150 <__reset+0xfb0fe150>
8111e52c:	18c03fcc 	andi	r3,r3,255
8111e530:	1807181e 	bne	r3,zero,81120194 <___svfprintf_internal_r+0x219c>
8111e534:	94800414 	ori	r18,r18,16
8111e538:	9080080c 	andi	r2,r18,32
8111e53c:	10039626 	beq	r2,zero,8111f398 <___svfprintf_internal_r+0x13a0>
8111e540:	d9402d17 	ldw	r5,180(sp)
8111e544:	28800117 	ldw	r2,4(r5)
8111e548:	2d000017 	ldw	r20,0(r5)
8111e54c:	29400204 	addi	r5,r5,8
8111e550:	d9402d15 	stw	r5,180(sp)
8111e554:	102d883a 	mov	r22,r2
8111e558:	10039816 	blt	r2,zero,8111f3bc <___svfprintf_internal_r+0x13c4>
8111e55c:	d9402917 	ldw	r5,164(sp)
8111e560:	df002783 	ldbu	fp,158(sp)
8111e564:	2803ab16 	blt	r5,zero,8111f414 <___svfprintf_internal_r+0x141c>
8111e568:	00ffdfc4 	movi	r3,-129
8111e56c:	a584b03a 	or	r2,r20,r22
8111e570:	90e4703a 	and	r18,r18,r3
8111e574:	10014a26 	beq	r2,zero,8111eaa0 <___svfprintf_internal_r+0xaa8>
8111e578:	b0034b26 	beq	r22,zero,8111f2a8 <___svfprintf_internal_r+0x12b0>
8111e57c:	dc402a15 	stw	r17,168(sp)
8111e580:	dc001e04 	addi	r16,sp,120
8111e584:	b023883a 	mov	r17,r22
8111e588:	402d883a 	mov	r22,r8
8111e58c:	a009883a 	mov	r4,r20
8111e590:	880b883a 	mov	r5,r17
8111e594:	01800284 	movi	r6,10
8111e598:	000f883a 	mov	r7,zero
8111e59c:	112f17c0 	call	8112f17c <__umoddi3>
8111e5a0:	10800c04 	addi	r2,r2,48
8111e5a4:	843fffc4 	addi	r16,r16,-1
8111e5a8:	a009883a 	mov	r4,r20
8111e5ac:	880b883a 	mov	r5,r17
8111e5b0:	80800005 	stb	r2,0(r16)
8111e5b4:	01800284 	movi	r6,10
8111e5b8:	000f883a 	mov	r7,zero
8111e5bc:	112ebfc0 	call	8112ebfc <__udivdi3>
8111e5c0:	1029883a 	mov	r20,r2
8111e5c4:	10c4b03a 	or	r2,r2,r3
8111e5c8:	1823883a 	mov	r17,r3
8111e5cc:	103fef1e 	bne	r2,zero,8111e58c <__reset+0xfb0fe58c>
8111e5d0:	d8c02817 	ldw	r3,160(sp)
8111e5d4:	dc402a17 	ldw	r17,168(sp)
8111e5d8:	b011883a 	mov	r8,r22
8111e5dc:	1c07c83a 	sub	r3,r3,r16
8111e5e0:	d8c02e15 	stw	r3,184(sp)
8111e5e4:	00002e06 	br	8111e6a0 <___svfprintf_internal_r+0x6a8>
8111e5e8:	18c03fcc 	andi	r3,r3,255
8111e5ec:	1806e71e 	bne	r3,zero,8112018c <___svfprintf_internal_r+0x2194>
8111e5f0:	94800414 	ori	r18,r18,16
8111e5f4:	9080080c 	andi	r2,r18,32
8111e5f8:	1002d426 	beq	r2,zero,8111f14c <___svfprintf_internal_r+0x1154>
8111e5fc:	d9402d17 	ldw	r5,180(sp)
8111e600:	d8c02917 	ldw	r3,164(sp)
8111e604:	d8002785 	stb	zero,158(sp)
8111e608:	28800204 	addi	r2,r5,8
8111e60c:	2d000017 	ldw	r20,0(r5)
8111e610:	2d800117 	ldw	r22,4(r5)
8111e614:	18041516 	blt	r3,zero,8111f66c <___svfprintf_internal_r+0x1674>
8111e618:	013fdfc4 	movi	r4,-129
8111e61c:	a586b03a 	or	r3,r20,r22
8111e620:	d8802d15 	stw	r2,180(sp)
8111e624:	9124703a 	and	r18,r18,r4
8111e628:	1802d51e 	bne	r3,zero,8111f180 <___svfprintf_internal_r+0x1188>
8111e62c:	d9402917 	ldw	r5,164(sp)
8111e630:	0039883a 	mov	fp,zero
8111e634:	2806be26 	beq	r5,zero,81120130 <___svfprintf_internal_r+0x2138>
8111e638:	0029883a 	mov	r20,zero
8111e63c:	002d883a 	mov	r22,zero
8111e640:	dc001e04 	addi	r16,sp,120
8111e644:	a006d0fa 	srli	r3,r20,3
8111e648:	b008977a 	slli	r4,r22,29
8111e64c:	b02cd0fa 	srli	r22,r22,3
8111e650:	a50001cc 	andi	r20,r20,7
8111e654:	a0800c04 	addi	r2,r20,48
8111e658:	843fffc4 	addi	r16,r16,-1
8111e65c:	20e8b03a 	or	r20,r4,r3
8111e660:	80800005 	stb	r2,0(r16)
8111e664:	a586b03a 	or	r3,r20,r22
8111e668:	183ff61e 	bne	r3,zero,8111e644 <__reset+0xfb0fe644>
8111e66c:	90c0004c 	andi	r3,r18,1
8111e670:	18013926 	beq	r3,zero,8111eb58 <___svfprintf_internal_r+0xb60>
8111e674:	10803fcc 	andi	r2,r2,255
8111e678:	1080201c 	xori	r2,r2,128
8111e67c:	10bfe004 	addi	r2,r2,-128
8111e680:	00c00c04 	movi	r3,48
8111e684:	10c13426 	beq	r2,r3,8111eb58 <___svfprintf_internal_r+0xb60>
8111e688:	80ffffc5 	stb	r3,-1(r16)
8111e68c:	d8c02817 	ldw	r3,160(sp)
8111e690:	80bfffc4 	addi	r2,r16,-1
8111e694:	1021883a 	mov	r16,r2
8111e698:	1887c83a 	sub	r3,r3,r2
8111e69c:	d8c02e15 	stw	r3,184(sp)
8111e6a0:	d8802e17 	ldw	r2,184(sp)
8111e6a4:	d9002917 	ldw	r4,164(sp)
8111e6a8:	1100010e 	bge	r2,r4,8111e6b0 <___svfprintf_internal_r+0x6b8>
8111e6ac:	2005883a 	mov	r2,r4
8111e6b0:	d8802a15 	stw	r2,168(sp)
8111e6b4:	d8003215 	stw	zero,200(sp)
8111e6b8:	e7003fcc 	andi	fp,fp,255
8111e6bc:	e700201c 	xori	fp,fp,128
8111e6c0:	e73fe004 	addi	fp,fp,-128
8111e6c4:	e0000326 	beq	fp,zero,8111e6d4 <___svfprintf_internal_r+0x6dc>
8111e6c8:	d8c02a17 	ldw	r3,168(sp)
8111e6cc:	18c00044 	addi	r3,r3,1
8111e6d0:	d8c02a15 	stw	r3,168(sp)
8111e6d4:	90c0008c 	andi	r3,r18,2
8111e6d8:	d8c02b15 	stw	r3,172(sp)
8111e6dc:	18000326 	beq	r3,zero,8111e6ec <___svfprintf_internal_r+0x6f4>
8111e6e0:	d8c02a17 	ldw	r3,168(sp)
8111e6e4:	18c00084 	addi	r3,r3,2
8111e6e8:	d8c02a15 	stw	r3,168(sp)
8111e6ec:	90c0210c 	andi	r3,r18,132
8111e6f0:	d8c03015 	stw	r3,192(sp)
8111e6f4:	1801a11e 	bne	r3,zero,8111ed7c <___svfprintf_internal_r+0xd84>
8111e6f8:	d9003117 	ldw	r4,196(sp)
8111e6fc:	d8c02a17 	ldw	r3,168(sp)
8111e700:	20e9c83a 	sub	r20,r4,r3
8111e704:	05019d0e 	bge	zero,r20,8111ed7c <___svfprintf_internal_r+0xd84>
8111e708:	02400404 	movi	r9,16
8111e70c:	d8c02017 	ldw	r3,128(sp)
8111e710:	d8801f17 	ldw	r2,124(sp)
8111e714:	4d051b0e 	bge	r9,r20,8111fb84 <___svfprintf_internal_r+0x1b8c>
8111e718:	01604574 	movhi	r5,33045
8111e71c:	296e1284 	addi	r5,r5,-18358
8111e720:	dc403c15 	stw	r17,240(sp)
8111e724:	d9403515 	stw	r5,212(sp)
8111e728:	a023883a 	mov	r17,r20
8111e72c:	482d883a 	mov	r22,r9
8111e730:	9029883a 	mov	r20,r18
8111e734:	070001c4 	movi	fp,7
8111e738:	8025883a 	mov	r18,r16
8111e73c:	dc002c17 	ldw	r16,176(sp)
8111e740:	00000306 	br	8111e750 <___svfprintf_internal_r+0x758>
8111e744:	8c7ffc04 	addi	r17,r17,-16
8111e748:	42000204 	addi	r8,r8,8
8111e74c:	b440130e 	bge	r22,r17,8111e79c <___svfprintf_internal_r+0x7a4>
8111e750:	01204574 	movhi	r4,33045
8111e754:	18c00404 	addi	r3,r3,16
8111e758:	10800044 	addi	r2,r2,1
8111e75c:	212e1284 	addi	r4,r4,-18358
8111e760:	41000015 	stw	r4,0(r8)
8111e764:	45800115 	stw	r22,4(r8)
8111e768:	d8c02015 	stw	r3,128(sp)
8111e76c:	d8801f15 	stw	r2,124(sp)
8111e770:	e0bff40e 	bge	fp,r2,8111e744 <__reset+0xfb0fe744>
8111e774:	d9801e04 	addi	r6,sp,120
8111e778:	800b883a 	mov	r5,r16
8111e77c:	9809883a 	mov	r4,r19
8111e780:	112ac180 	call	8112ac18 <__ssprint_r>
8111e784:	103f031e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111e788:	8c7ffc04 	addi	r17,r17,-16
8111e78c:	d8c02017 	ldw	r3,128(sp)
8111e790:	d8801f17 	ldw	r2,124(sp)
8111e794:	da000404 	addi	r8,sp,16
8111e798:	b47fed16 	blt	r22,r17,8111e750 <__reset+0xfb0fe750>
8111e79c:	9021883a 	mov	r16,r18
8111e7a0:	a025883a 	mov	r18,r20
8111e7a4:	8829883a 	mov	r20,r17
8111e7a8:	dc403c17 	ldw	r17,240(sp)
8111e7ac:	d9403517 	ldw	r5,212(sp)
8111e7b0:	a0c7883a 	add	r3,r20,r3
8111e7b4:	10800044 	addi	r2,r2,1
8111e7b8:	41400015 	stw	r5,0(r8)
8111e7bc:	45000115 	stw	r20,4(r8)
8111e7c0:	d8c02015 	stw	r3,128(sp)
8111e7c4:	d8801f15 	stw	r2,124(sp)
8111e7c8:	010001c4 	movi	r4,7
8111e7cc:	20829f16 	blt	r4,r2,8111f24c <___svfprintf_internal_r+0x1254>
8111e7d0:	df002787 	ldb	fp,158(sp)
8111e7d4:	42000204 	addi	r8,r8,8
8111e7d8:	e0000c26 	beq	fp,zero,8111e80c <___svfprintf_internal_r+0x814>
8111e7dc:	d8801f17 	ldw	r2,124(sp)
8111e7e0:	d9002784 	addi	r4,sp,158
8111e7e4:	18c00044 	addi	r3,r3,1
8111e7e8:	10800044 	addi	r2,r2,1
8111e7ec:	41000015 	stw	r4,0(r8)
8111e7f0:	01000044 	movi	r4,1
8111e7f4:	41000115 	stw	r4,4(r8)
8111e7f8:	d8c02015 	stw	r3,128(sp)
8111e7fc:	d8801f15 	stw	r2,124(sp)
8111e800:	010001c4 	movi	r4,7
8111e804:	20823816 	blt	r4,r2,8111f0e8 <___svfprintf_internal_r+0x10f0>
8111e808:	42000204 	addi	r8,r8,8
8111e80c:	d8802b17 	ldw	r2,172(sp)
8111e810:	10000c26 	beq	r2,zero,8111e844 <___svfprintf_internal_r+0x84c>
8111e814:	d8801f17 	ldw	r2,124(sp)
8111e818:	d9002704 	addi	r4,sp,156
8111e81c:	18c00084 	addi	r3,r3,2
8111e820:	10800044 	addi	r2,r2,1
8111e824:	41000015 	stw	r4,0(r8)
8111e828:	01000084 	movi	r4,2
8111e82c:	41000115 	stw	r4,4(r8)
8111e830:	d8c02015 	stw	r3,128(sp)
8111e834:	d8801f15 	stw	r2,124(sp)
8111e838:	010001c4 	movi	r4,7
8111e83c:	20823216 	blt	r4,r2,8111f108 <___svfprintf_internal_r+0x1110>
8111e840:	42000204 	addi	r8,r8,8
8111e844:	d9003017 	ldw	r4,192(sp)
8111e848:	00802004 	movi	r2,128
8111e84c:	20819726 	beq	r4,r2,8111eeac <___svfprintf_internal_r+0xeb4>
8111e850:	d9402917 	ldw	r5,164(sp)
8111e854:	d8802e17 	ldw	r2,184(sp)
8111e858:	28adc83a 	sub	r22,r5,r2
8111e85c:	05802f0e 	bge	zero,r22,8111e91c <___svfprintf_internal_r+0x924>
8111e860:	07000404 	movi	fp,16
8111e864:	d8801f17 	ldw	r2,124(sp)
8111e868:	e583c00e 	bge	fp,r22,8111f76c <___svfprintf_internal_r+0x1774>
8111e86c:	01604574 	movhi	r5,33045
8111e870:	296e0e84 	addi	r5,r5,-18374
8111e874:	dc402915 	stw	r17,164(sp)
8111e878:	d9402b15 	stw	r5,172(sp)
8111e87c:	b023883a 	mov	r17,r22
8111e880:	050001c4 	movi	r20,7
8111e884:	902d883a 	mov	r22,r18
8111e888:	8025883a 	mov	r18,r16
8111e88c:	dc002c17 	ldw	r16,176(sp)
8111e890:	00000306 	br	8111e8a0 <___svfprintf_internal_r+0x8a8>
8111e894:	8c7ffc04 	addi	r17,r17,-16
8111e898:	42000204 	addi	r8,r8,8
8111e89c:	e440110e 	bge	fp,r17,8111e8e4 <___svfprintf_internal_r+0x8ec>
8111e8a0:	18c00404 	addi	r3,r3,16
8111e8a4:	10800044 	addi	r2,r2,1
8111e8a8:	45400015 	stw	r21,0(r8)
8111e8ac:	47000115 	stw	fp,4(r8)
8111e8b0:	d8c02015 	stw	r3,128(sp)
8111e8b4:	d8801f15 	stw	r2,124(sp)
8111e8b8:	a0bff60e 	bge	r20,r2,8111e894 <__reset+0xfb0fe894>
8111e8bc:	d9801e04 	addi	r6,sp,120
8111e8c0:	800b883a 	mov	r5,r16
8111e8c4:	9809883a 	mov	r4,r19
8111e8c8:	112ac180 	call	8112ac18 <__ssprint_r>
8111e8cc:	103eb11e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111e8d0:	8c7ffc04 	addi	r17,r17,-16
8111e8d4:	d8c02017 	ldw	r3,128(sp)
8111e8d8:	d8801f17 	ldw	r2,124(sp)
8111e8dc:	da000404 	addi	r8,sp,16
8111e8e0:	e47fef16 	blt	fp,r17,8111e8a0 <__reset+0xfb0fe8a0>
8111e8e4:	9021883a 	mov	r16,r18
8111e8e8:	b025883a 	mov	r18,r22
8111e8ec:	882d883a 	mov	r22,r17
8111e8f0:	dc402917 	ldw	r17,164(sp)
8111e8f4:	d9002b17 	ldw	r4,172(sp)
8111e8f8:	1d87883a 	add	r3,r3,r22
8111e8fc:	10800044 	addi	r2,r2,1
8111e900:	41000015 	stw	r4,0(r8)
8111e904:	45800115 	stw	r22,4(r8)
8111e908:	d8c02015 	stw	r3,128(sp)
8111e90c:	d8801f15 	stw	r2,124(sp)
8111e910:	010001c4 	movi	r4,7
8111e914:	2081ec16 	blt	r4,r2,8111f0c8 <___svfprintf_internal_r+0x10d0>
8111e918:	42000204 	addi	r8,r8,8
8111e91c:	9080400c 	andi	r2,r18,256
8111e920:	1001181e 	bne	r2,zero,8111ed84 <___svfprintf_internal_r+0xd8c>
8111e924:	d9402e17 	ldw	r5,184(sp)
8111e928:	d8801f17 	ldw	r2,124(sp)
8111e92c:	44000015 	stw	r16,0(r8)
8111e930:	1947883a 	add	r3,r3,r5
8111e934:	10800044 	addi	r2,r2,1
8111e938:	41400115 	stw	r5,4(r8)
8111e93c:	d8c02015 	stw	r3,128(sp)
8111e940:	d8801f15 	stw	r2,124(sp)
8111e944:	010001c4 	movi	r4,7
8111e948:	2081d116 	blt	r4,r2,8111f090 <___svfprintf_internal_r+0x1098>
8111e94c:	42000204 	addi	r8,r8,8
8111e950:	9480010c 	andi	r18,r18,4
8111e954:	90003226 	beq	r18,zero,8111ea20 <___svfprintf_internal_r+0xa28>
8111e958:	d9403117 	ldw	r5,196(sp)
8111e95c:	d8802a17 	ldw	r2,168(sp)
8111e960:	28a1c83a 	sub	r16,r5,r2
8111e964:	04002e0e 	bge	zero,r16,8111ea20 <___svfprintf_internal_r+0xa28>
8111e968:	04400404 	movi	r17,16
8111e96c:	d8801f17 	ldw	r2,124(sp)
8111e970:	8c04b90e 	bge	r17,r16,8111fc58 <___svfprintf_internal_r+0x1c60>
8111e974:	01604574 	movhi	r5,33045
8111e978:	296e1284 	addi	r5,r5,-18358
8111e97c:	d9403515 	stw	r5,212(sp)
8111e980:	048001c4 	movi	r18,7
8111e984:	dd002c17 	ldw	r20,176(sp)
8111e988:	00000306 	br	8111e998 <___svfprintf_internal_r+0x9a0>
8111e98c:	843ffc04 	addi	r16,r16,-16
8111e990:	42000204 	addi	r8,r8,8
8111e994:	8c00130e 	bge	r17,r16,8111e9e4 <___svfprintf_internal_r+0x9ec>
8111e998:	01204574 	movhi	r4,33045
8111e99c:	18c00404 	addi	r3,r3,16
8111e9a0:	10800044 	addi	r2,r2,1
8111e9a4:	212e1284 	addi	r4,r4,-18358
8111e9a8:	41000015 	stw	r4,0(r8)
8111e9ac:	44400115 	stw	r17,4(r8)
8111e9b0:	d8c02015 	stw	r3,128(sp)
8111e9b4:	d8801f15 	stw	r2,124(sp)
8111e9b8:	90bff40e 	bge	r18,r2,8111e98c <__reset+0xfb0fe98c>
8111e9bc:	d9801e04 	addi	r6,sp,120
8111e9c0:	a00b883a 	mov	r5,r20
8111e9c4:	9809883a 	mov	r4,r19
8111e9c8:	112ac180 	call	8112ac18 <__ssprint_r>
8111e9cc:	103e711e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111e9d0:	843ffc04 	addi	r16,r16,-16
8111e9d4:	d8c02017 	ldw	r3,128(sp)
8111e9d8:	d8801f17 	ldw	r2,124(sp)
8111e9dc:	da000404 	addi	r8,sp,16
8111e9e0:	8c3fed16 	blt	r17,r16,8111e998 <__reset+0xfb0fe998>
8111e9e4:	d9403517 	ldw	r5,212(sp)
8111e9e8:	1c07883a 	add	r3,r3,r16
8111e9ec:	10800044 	addi	r2,r2,1
8111e9f0:	41400015 	stw	r5,0(r8)
8111e9f4:	44000115 	stw	r16,4(r8)
8111e9f8:	d8c02015 	stw	r3,128(sp)
8111e9fc:	d8801f15 	stw	r2,124(sp)
8111ea00:	010001c4 	movi	r4,7
8111ea04:	2080060e 	bge	r4,r2,8111ea20 <___svfprintf_internal_r+0xa28>
8111ea08:	d9402c17 	ldw	r5,176(sp)
8111ea0c:	d9801e04 	addi	r6,sp,120
8111ea10:	9809883a 	mov	r4,r19
8111ea14:	112ac180 	call	8112ac18 <__ssprint_r>
8111ea18:	103e5e1e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111ea1c:	d8c02017 	ldw	r3,128(sp)
8111ea20:	d8803117 	ldw	r2,196(sp)
8111ea24:	d9002a17 	ldw	r4,168(sp)
8111ea28:	1100010e 	bge	r2,r4,8111ea30 <___svfprintf_internal_r+0xa38>
8111ea2c:	2005883a 	mov	r2,r4
8111ea30:	d9402f17 	ldw	r5,188(sp)
8111ea34:	288b883a 	add	r5,r5,r2
8111ea38:	d9402f15 	stw	r5,188(sp)
8111ea3c:	18019c1e 	bne	r3,zero,8111f0b0 <___svfprintf_internal_r+0x10b8>
8111ea40:	b8800007 	ldb	r2,0(r23)
8111ea44:	d8001f15 	stw	zero,124(sp)
8111ea48:	da000404 	addi	r8,sp,16
8111ea4c:	103d991e 	bne	r2,zero,8111e0b4 <__reset+0xfb0fe0b4>
8111ea50:	b821883a 	mov	r16,r23
8111ea54:	003daf06 	br	8111e114 <__reset+0xfb0fe114>
8111ea58:	18c03fcc 	andi	r3,r3,255
8111ea5c:	1805c71e 	bne	r3,zero,8112017c <___svfprintf_internal_r+0x2184>
8111ea60:	94800414 	ori	r18,r18,16
8111ea64:	9080080c 	andi	r2,r18,32
8111ea68:	10020126 	beq	r2,zero,8111f270 <___svfprintf_internal_r+0x1278>
8111ea6c:	d8802d17 	ldw	r2,180(sp)
8111ea70:	d9002917 	ldw	r4,164(sp)
8111ea74:	d8002785 	stb	zero,158(sp)
8111ea78:	10c00204 	addi	r3,r2,8
8111ea7c:	15000017 	ldw	r20,0(r2)
8111ea80:	15800117 	ldw	r22,4(r2)
8111ea84:	20038e16 	blt	r4,zero,8111f8c0 <___svfprintf_internal_r+0x18c8>
8111ea88:	013fdfc4 	movi	r4,-129
8111ea8c:	a584b03a 	or	r2,r20,r22
8111ea90:	d8c02d15 	stw	r3,180(sp)
8111ea94:	9124703a 	and	r18,r18,r4
8111ea98:	0039883a 	mov	fp,zero
8111ea9c:	103eb61e 	bne	r2,zero,8111e578 <__reset+0xfb0fe578>
8111eaa0:	d8802917 	ldw	r2,164(sp)
8111eaa4:	1002c81e 	bne	r2,zero,8111f5c8 <___svfprintf_internal_r+0x15d0>
8111eaa8:	d8002915 	stw	zero,164(sp)
8111eaac:	d8002e15 	stw	zero,184(sp)
8111eab0:	dc001e04 	addi	r16,sp,120
8111eab4:	003efa06 	br	8111e6a0 <__reset+0xfb0fe6a0>
8111eab8:	18c03fcc 	andi	r3,r3,255
8111eabc:	1805ad1e 	bne	r3,zero,81120174 <___svfprintf_internal_r+0x217c>
8111eac0:	01604574 	movhi	r5,33045
8111eac4:	296e0204 	addi	r5,r5,-18424
8111eac8:	d9403a15 	stw	r5,232(sp)
8111eacc:	9080080c 	andi	r2,r18,32
8111ead0:	10006126 	beq	r2,zero,8111ec58 <___svfprintf_internal_r+0xc60>
8111ead4:	d8802d17 	ldw	r2,180(sp)
8111ead8:	15000017 	ldw	r20,0(r2)
8111eadc:	15800117 	ldw	r22,4(r2)
8111eae0:	10800204 	addi	r2,r2,8
8111eae4:	d8802d15 	stw	r2,180(sp)
8111eae8:	9080004c 	andi	r2,r18,1
8111eaec:	10018e26 	beq	r2,zero,8111f128 <___svfprintf_internal_r+0x1130>
8111eaf0:	a584b03a 	or	r2,r20,r22
8111eaf4:	10030926 	beq	r2,zero,8111f71c <___svfprintf_internal_r+0x1724>
8111eaf8:	d8c02917 	ldw	r3,164(sp)
8111eafc:	00800c04 	movi	r2,48
8111eb00:	d8802705 	stb	r2,156(sp)
8111eb04:	dc402745 	stb	r17,157(sp)
8111eb08:	d8002785 	stb	zero,158(sp)
8111eb0c:	90800094 	ori	r2,r18,2
8111eb10:	18048716 	blt	r3,zero,8111fd30 <___svfprintf_internal_r+0x1d38>
8111eb14:	00bfdfc4 	movi	r2,-129
8111eb18:	90a4703a 	and	r18,r18,r2
8111eb1c:	94800094 	ori	r18,r18,2
8111eb20:	0039883a 	mov	fp,zero
8111eb24:	d9003a17 	ldw	r4,232(sp)
8111eb28:	dc001e04 	addi	r16,sp,120
8111eb2c:	a08003cc 	andi	r2,r20,15
8111eb30:	b006973a 	slli	r3,r22,28
8111eb34:	2085883a 	add	r2,r4,r2
8111eb38:	a028d13a 	srli	r20,r20,4
8111eb3c:	10800003 	ldbu	r2,0(r2)
8111eb40:	b02cd13a 	srli	r22,r22,4
8111eb44:	843fffc4 	addi	r16,r16,-1
8111eb48:	1d28b03a 	or	r20,r3,r20
8111eb4c:	80800005 	stb	r2,0(r16)
8111eb50:	a584b03a 	or	r2,r20,r22
8111eb54:	103ff51e 	bne	r2,zero,8111eb2c <__reset+0xfb0feb2c>
8111eb58:	d8c02817 	ldw	r3,160(sp)
8111eb5c:	1c07c83a 	sub	r3,r3,r16
8111eb60:	d8c02e15 	stw	r3,184(sp)
8111eb64:	003ece06 	br	8111e6a0 <__reset+0xfb0fe6a0>
8111eb68:	d8c02d17 	ldw	r3,180(sp)
8111eb6c:	d9002d17 	ldw	r4,180(sp)
8111eb70:	d8002785 	stb	zero,158(sp)
8111eb74:	18800017 	ldw	r2,0(r3)
8111eb78:	21000104 	addi	r4,r4,4
8111eb7c:	00c00044 	movi	r3,1
8111eb80:	d8c02a15 	stw	r3,168(sp)
8111eb84:	d8801405 	stb	r2,80(sp)
8111eb88:	d9002d15 	stw	r4,180(sp)
8111eb8c:	d8c02e15 	stw	r3,184(sp)
8111eb90:	d8002915 	stw	zero,164(sp)
8111eb94:	d8003215 	stw	zero,200(sp)
8111eb98:	dc001404 	addi	r16,sp,80
8111eb9c:	0039883a 	mov	fp,zero
8111eba0:	003ecc06 	br	8111e6d4 <__reset+0xfb0fe6d4>
8111eba4:	18c03fcc 	andi	r3,r3,255
8111eba8:	183e9226 	beq	r3,zero,8111e5f4 <__reset+0xfb0fe5f4>
8111ebac:	d9c02785 	stb	r7,158(sp)
8111ebb0:	003e9006 	br	8111e5f4 <__reset+0xfb0fe5f4>
8111ebb4:	00c00044 	movi	r3,1
8111ebb8:	01c00ac4 	movi	r7,43
8111ebbc:	bc400007 	ldb	r17,0(r23)
8111ebc0:	003d6306 	br	8111e150 <__reset+0xfb0fe150>
8111ebc4:	94800814 	ori	r18,r18,32
8111ebc8:	bc400007 	ldb	r17,0(r23)
8111ebcc:	003d6006 	br	8111e150 <__reset+0xfb0fe150>
8111ebd0:	d8c02d17 	ldw	r3,180(sp)
8111ebd4:	d8002785 	stb	zero,158(sp)
8111ebd8:	1c000017 	ldw	r16,0(r3)
8111ebdc:	1d000104 	addi	r20,r3,4
8111ebe0:	80040f26 	beq	r16,zero,8111fc20 <___svfprintf_internal_r+0x1c28>
8111ebe4:	d9002917 	ldw	r4,164(sp)
8111ebe8:	2003dc16 	blt	r4,zero,8111fb5c <___svfprintf_internal_r+0x1b64>
8111ebec:	200d883a 	mov	r6,r4
8111ebf0:	000b883a 	mov	r5,zero
8111ebf4:	8009883a 	mov	r4,r16
8111ebf8:	da003e15 	stw	r8,248(sp)
8111ebfc:	11271bc0 	call	811271bc <memchr>
8111ec00:	da003e17 	ldw	r8,248(sp)
8111ec04:	10045826 	beq	r2,zero,8111fd68 <___svfprintf_internal_r+0x1d70>
8111ec08:	1405c83a 	sub	r2,r2,r16
8111ec0c:	d8802e15 	stw	r2,184(sp)
8111ec10:	1003d816 	blt	r2,zero,8111fb74 <___svfprintf_internal_r+0x1b7c>
8111ec14:	df002783 	ldbu	fp,158(sp)
8111ec18:	d8802a15 	stw	r2,168(sp)
8111ec1c:	dd002d15 	stw	r20,180(sp)
8111ec20:	d8002915 	stw	zero,164(sp)
8111ec24:	d8003215 	stw	zero,200(sp)
8111ec28:	003ea306 	br	8111e6b8 <__reset+0xfb0fe6b8>
8111ec2c:	18c03fcc 	andi	r3,r3,255
8111ec30:	183f8c26 	beq	r3,zero,8111ea64 <__reset+0xfb0fea64>
8111ec34:	d9c02785 	stb	r7,158(sp)
8111ec38:	003f8a06 	br	8111ea64 <__reset+0xfb0fea64>
8111ec3c:	18c03fcc 	andi	r3,r3,255
8111ec40:	1805631e 	bne	r3,zero,811201d0 <___svfprintf_internal_r+0x21d8>
8111ec44:	01604574 	movhi	r5,33045
8111ec48:	296e0704 	addi	r5,r5,-18404
8111ec4c:	d9403a15 	stw	r5,232(sp)
8111ec50:	9080080c 	andi	r2,r18,32
8111ec54:	103f9f1e 	bne	r2,zero,8111ead4 <__reset+0xfb0fead4>
8111ec58:	9080040c 	andi	r2,r18,16
8111ec5c:	10029c26 	beq	r2,zero,8111f6d0 <___svfprintf_internal_r+0x16d8>
8111ec60:	d8c02d17 	ldw	r3,180(sp)
8111ec64:	002d883a 	mov	r22,zero
8111ec68:	1d000017 	ldw	r20,0(r3)
8111ec6c:	18c00104 	addi	r3,r3,4
8111ec70:	d8c02d15 	stw	r3,180(sp)
8111ec74:	003f9c06 	br	8111eae8 <__reset+0xfb0feae8>
8111ec78:	94800054 	ori	r18,r18,1
8111ec7c:	bc400007 	ldb	r17,0(r23)
8111ec80:	003d3306 	br	8111e150 <__reset+0xfb0fe150>
8111ec84:	38803fcc 	andi	r2,r7,255
8111ec88:	1080201c 	xori	r2,r2,128
8111ec8c:	10bfe004 	addi	r2,r2,-128
8111ec90:	1002971e 	bne	r2,zero,8111f6f0 <___svfprintf_internal_r+0x16f8>
8111ec94:	00c00044 	movi	r3,1
8111ec98:	01c00804 	movi	r7,32
8111ec9c:	bc400007 	ldb	r17,0(r23)
8111eca0:	003d2b06 	br	8111e150 <__reset+0xfb0fe150>
8111eca4:	18c03fcc 	andi	r3,r3,255
8111eca8:	183e2326 	beq	r3,zero,8111e538 <__reset+0xfb0fe538>
8111ecac:	d9c02785 	stb	r7,158(sp)
8111ecb0:	003e2106 	br	8111e538 <__reset+0xfb0fe538>
8111ecb4:	bc400007 	ldb	r17,0(r23)
8111ecb8:	8a430426 	beq	r17,r9,8111f8cc <___svfprintf_internal_r+0x18d4>
8111ecbc:	94800414 	ori	r18,r18,16
8111ecc0:	003d2306 	br	8111e150 <__reset+0xfb0fe150>
8111ecc4:	18c03fcc 	andi	r3,r3,255
8111ecc8:	18053f1e 	bne	r3,zero,811201c8 <___svfprintf_internal_r+0x21d0>
8111eccc:	9080080c 	andi	r2,r18,32
8111ecd0:	10028926 	beq	r2,zero,8111f6f8 <___svfprintf_internal_r+0x1700>
8111ecd4:	d9402d17 	ldw	r5,180(sp)
8111ecd8:	d9002f17 	ldw	r4,188(sp)
8111ecdc:	28800017 	ldw	r2,0(r5)
8111ece0:	2007d7fa 	srai	r3,r4,31
8111ece4:	29400104 	addi	r5,r5,4
8111ece8:	d9402d15 	stw	r5,180(sp)
8111ecec:	11000015 	stw	r4,0(r2)
8111ecf0:	10c00115 	stw	r3,4(r2)
8111ecf4:	003ced06 	br	8111e0ac <__reset+0xfb0fe0ac>
8111ecf8:	94801014 	ori	r18,r18,64
8111ecfc:	bc400007 	ldb	r17,0(r23)
8111ed00:	003d1306 	br	8111e150 <__reset+0xfb0fe150>
8111ed04:	01204574 	movhi	r4,33045
8111ed08:	212e0704 	addi	r4,r4,-18404
8111ed0c:	0039883a 	mov	fp,zero
8111ed10:	d9003a15 	stw	r4,232(sp)
8111ed14:	04401e04 	movi	r17,120
8111ed18:	003f8206 	br	8111eb24 <__reset+0xfb0feb24>
8111ed1c:	18c03fcc 	andi	r3,r3,255
8111ed20:	1805221e 	bne	r3,zero,811201ac <___svfprintf_internal_r+0x21b4>
8111ed24:	883d9526 	beq	r17,zero,8111e37c <__reset+0xfb0fe37c>
8111ed28:	00c00044 	movi	r3,1
8111ed2c:	d8c02a15 	stw	r3,168(sp)
8111ed30:	dc401405 	stb	r17,80(sp)
8111ed34:	d8002785 	stb	zero,158(sp)
8111ed38:	003f9406 	br	8111eb8c <__reset+0xfb0feb8c>
8111ed3c:	01204574 	movhi	r4,33045
8111ed40:	212e0704 	addi	r4,r4,-18404
8111ed44:	d9003a15 	stw	r4,232(sp)
8111ed48:	d8c02d15 	stw	r3,180(sp)
8111ed4c:	1025883a 	mov	r18,r2
8111ed50:	04401e04 	movi	r17,120
8111ed54:	a584b03a 	or	r2,r20,r22
8111ed58:	1000fa1e 	bne	r2,zero,8111f144 <___svfprintf_internal_r+0x114c>
8111ed5c:	0039883a 	mov	fp,zero
8111ed60:	00800084 	movi	r2,2
8111ed64:	10803fcc 	andi	r2,r2,255
8111ed68:	00c00044 	movi	r3,1
8111ed6c:	10c21626 	beq	r2,r3,8111f5c8 <___svfprintf_internal_r+0x15d0>
8111ed70:	00c00084 	movi	r3,2
8111ed74:	10fe301e 	bne	r2,r3,8111e638 <__reset+0xfb0fe638>
8111ed78:	003d7606 	br	8111e354 <__reset+0xfb0fe354>
8111ed7c:	d8c02017 	ldw	r3,128(sp)
8111ed80:	003e9506 	br	8111e7d8 <__reset+0xfb0fe7d8>
8111ed84:	00801944 	movi	r2,101
8111ed88:	14407c0e 	bge	r2,r17,8111ef7c <___svfprintf_internal_r+0xf84>
8111ed8c:	d9003617 	ldw	r4,216(sp)
8111ed90:	d9403717 	ldw	r5,220(sp)
8111ed94:	000d883a 	mov	r6,zero
8111ed98:	000f883a 	mov	r7,zero
8111ed9c:	d8c03d15 	stw	r3,244(sp)
8111eda0:	da003e15 	stw	r8,248(sp)
8111eda4:	1130c100 	call	81130c10 <__eqdf2>
8111eda8:	d8c03d17 	ldw	r3,244(sp)
8111edac:	da003e17 	ldw	r8,248(sp)
8111edb0:	1000f51e 	bne	r2,zero,8111f188 <___svfprintf_internal_r+0x1190>
8111edb4:	d8801f17 	ldw	r2,124(sp)
8111edb8:	01204574 	movhi	r4,33045
8111edbc:	212e0e04 	addi	r4,r4,-18376
8111edc0:	18c00044 	addi	r3,r3,1
8111edc4:	10800044 	addi	r2,r2,1
8111edc8:	41000015 	stw	r4,0(r8)
8111edcc:	01000044 	movi	r4,1
8111edd0:	41000115 	stw	r4,4(r8)
8111edd4:	d8c02015 	stw	r3,128(sp)
8111edd8:	d8801f15 	stw	r2,124(sp)
8111eddc:	010001c4 	movi	r4,7
8111ede0:	20826616 	blt	r4,r2,8111f77c <___svfprintf_internal_r+0x1784>
8111ede4:	42000204 	addi	r8,r8,8
8111ede8:	d8802617 	ldw	r2,152(sp)
8111edec:	d9403317 	ldw	r5,204(sp)
8111edf0:	11400216 	blt	r2,r5,8111edfc <___svfprintf_internal_r+0xe04>
8111edf4:	9080004c 	andi	r2,r18,1
8111edf8:	103ed526 	beq	r2,zero,8111e950 <__reset+0xfb0fe950>
8111edfc:	d8803817 	ldw	r2,224(sp)
8111ee00:	d9003417 	ldw	r4,208(sp)
8111ee04:	d9403817 	ldw	r5,224(sp)
8111ee08:	1887883a 	add	r3,r3,r2
8111ee0c:	d8801f17 	ldw	r2,124(sp)
8111ee10:	41000015 	stw	r4,0(r8)
8111ee14:	41400115 	stw	r5,4(r8)
8111ee18:	10800044 	addi	r2,r2,1
8111ee1c:	d8c02015 	stw	r3,128(sp)
8111ee20:	d8801f15 	stw	r2,124(sp)
8111ee24:	010001c4 	movi	r4,7
8111ee28:	2082af16 	blt	r4,r2,8111f8e8 <___svfprintf_internal_r+0x18f0>
8111ee2c:	42000204 	addi	r8,r8,8
8111ee30:	d8803317 	ldw	r2,204(sp)
8111ee34:	143fffc4 	addi	r16,r2,-1
8111ee38:	043ec50e 	bge	zero,r16,8111e950 <__reset+0xfb0fe950>
8111ee3c:	04400404 	movi	r17,16
8111ee40:	d8801f17 	ldw	r2,124(sp)
8111ee44:	8c00860e 	bge	r17,r16,8111f060 <___svfprintf_internal_r+0x1068>
8111ee48:	01604574 	movhi	r5,33045
8111ee4c:	296e0e84 	addi	r5,r5,-18374
8111ee50:	d9402b15 	stw	r5,172(sp)
8111ee54:	058001c4 	movi	r22,7
8111ee58:	dd002c17 	ldw	r20,176(sp)
8111ee5c:	00000306 	br	8111ee6c <___svfprintf_internal_r+0xe74>
8111ee60:	42000204 	addi	r8,r8,8
8111ee64:	843ffc04 	addi	r16,r16,-16
8111ee68:	8c00800e 	bge	r17,r16,8111f06c <___svfprintf_internal_r+0x1074>
8111ee6c:	18c00404 	addi	r3,r3,16
8111ee70:	10800044 	addi	r2,r2,1
8111ee74:	45400015 	stw	r21,0(r8)
8111ee78:	44400115 	stw	r17,4(r8)
8111ee7c:	d8c02015 	stw	r3,128(sp)
8111ee80:	d8801f15 	stw	r2,124(sp)
8111ee84:	b0bff60e 	bge	r22,r2,8111ee60 <__reset+0xfb0fee60>
8111ee88:	d9801e04 	addi	r6,sp,120
8111ee8c:	a00b883a 	mov	r5,r20
8111ee90:	9809883a 	mov	r4,r19
8111ee94:	112ac180 	call	8112ac18 <__ssprint_r>
8111ee98:	103d3e1e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111ee9c:	d8c02017 	ldw	r3,128(sp)
8111eea0:	d8801f17 	ldw	r2,124(sp)
8111eea4:	da000404 	addi	r8,sp,16
8111eea8:	003fee06 	br	8111ee64 <__reset+0xfb0fee64>
8111eeac:	d9403117 	ldw	r5,196(sp)
8111eeb0:	d8802a17 	ldw	r2,168(sp)
8111eeb4:	28adc83a 	sub	r22,r5,r2
8111eeb8:	05be650e 	bge	zero,r22,8111e850 <__reset+0xfb0fe850>
8111eebc:	07000404 	movi	fp,16
8111eec0:	d8801f17 	ldw	r2,124(sp)
8111eec4:	e583a20e 	bge	fp,r22,8111fd50 <___svfprintf_internal_r+0x1d58>
8111eec8:	01604574 	movhi	r5,33045
8111eecc:	296e0e84 	addi	r5,r5,-18374
8111eed0:	dc403015 	stw	r17,192(sp)
8111eed4:	d9402b15 	stw	r5,172(sp)
8111eed8:	b023883a 	mov	r17,r22
8111eedc:	050001c4 	movi	r20,7
8111eee0:	902d883a 	mov	r22,r18
8111eee4:	8025883a 	mov	r18,r16
8111eee8:	dc002c17 	ldw	r16,176(sp)
8111eeec:	00000306 	br	8111eefc <___svfprintf_internal_r+0xf04>
8111eef0:	8c7ffc04 	addi	r17,r17,-16
8111eef4:	42000204 	addi	r8,r8,8
8111eef8:	e440110e 	bge	fp,r17,8111ef40 <___svfprintf_internal_r+0xf48>
8111eefc:	18c00404 	addi	r3,r3,16
8111ef00:	10800044 	addi	r2,r2,1
8111ef04:	45400015 	stw	r21,0(r8)
8111ef08:	47000115 	stw	fp,4(r8)
8111ef0c:	d8c02015 	stw	r3,128(sp)
8111ef10:	d8801f15 	stw	r2,124(sp)
8111ef14:	a0bff60e 	bge	r20,r2,8111eef0 <__reset+0xfb0feef0>
8111ef18:	d9801e04 	addi	r6,sp,120
8111ef1c:	800b883a 	mov	r5,r16
8111ef20:	9809883a 	mov	r4,r19
8111ef24:	112ac180 	call	8112ac18 <__ssprint_r>
8111ef28:	103d1a1e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111ef2c:	8c7ffc04 	addi	r17,r17,-16
8111ef30:	d8c02017 	ldw	r3,128(sp)
8111ef34:	d8801f17 	ldw	r2,124(sp)
8111ef38:	da000404 	addi	r8,sp,16
8111ef3c:	e47fef16 	blt	fp,r17,8111eefc <__reset+0xfb0feefc>
8111ef40:	9021883a 	mov	r16,r18
8111ef44:	b025883a 	mov	r18,r22
8111ef48:	882d883a 	mov	r22,r17
8111ef4c:	dc403017 	ldw	r17,192(sp)
8111ef50:	d9002b17 	ldw	r4,172(sp)
8111ef54:	1d87883a 	add	r3,r3,r22
8111ef58:	10800044 	addi	r2,r2,1
8111ef5c:	41000015 	stw	r4,0(r8)
8111ef60:	45800115 	stw	r22,4(r8)
8111ef64:	d8c02015 	stw	r3,128(sp)
8111ef68:	d8801f15 	stw	r2,124(sp)
8111ef6c:	010001c4 	movi	r4,7
8111ef70:	20819a16 	blt	r4,r2,8111f5dc <___svfprintf_internal_r+0x15e4>
8111ef74:	42000204 	addi	r8,r8,8
8111ef78:	003e3506 	br	8111e850 <__reset+0xfb0fe850>
8111ef7c:	d9403317 	ldw	r5,204(sp)
8111ef80:	00800044 	movi	r2,1
8111ef84:	18c00044 	addi	r3,r3,1
8111ef88:	1141710e 	bge	r2,r5,8111f550 <___svfprintf_internal_r+0x1558>
8111ef8c:	dc401f17 	ldw	r17,124(sp)
8111ef90:	00800044 	movi	r2,1
8111ef94:	40800115 	stw	r2,4(r8)
8111ef98:	8c400044 	addi	r17,r17,1
8111ef9c:	44000015 	stw	r16,0(r8)
8111efa0:	d8c02015 	stw	r3,128(sp)
8111efa4:	dc401f15 	stw	r17,124(sp)
8111efa8:	008001c4 	movi	r2,7
8111efac:	14417416 	blt	r2,r17,8111f580 <___svfprintf_internal_r+0x1588>
8111efb0:	42000204 	addi	r8,r8,8
8111efb4:	d8803817 	ldw	r2,224(sp)
8111efb8:	d9003417 	ldw	r4,208(sp)
8111efbc:	8c400044 	addi	r17,r17,1
8111efc0:	10c7883a 	add	r3,r2,r3
8111efc4:	40800115 	stw	r2,4(r8)
8111efc8:	41000015 	stw	r4,0(r8)
8111efcc:	d8c02015 	stw	r3,128(sp)
8111efd0:	dc401f15 	stw	r17,124(sp)
8111efd4:	008001c4 	movi	r2,7
8111efd8:	14417216 	blt	r2,r17,8111f5a4 <___svfprintf_internal_r+0x15ac>
8111efdc:	45800204 	addi	r22,r8,8
8111efe0:	d9003617 	ldw	r4,216(sp)
8111efe4:	d9403717 	ldw	r5,220(sp)
8111efe8:	000d883a 	mov	r6,zero
8111efec:	000f883a 	mov	r7,zero
8111eff0:	d8c03d15 	stw	r3,244(sp)
8111eff4:	1130c100 	call	81130c10 <__eqdf2>
8111eff8:	d8c03d17 	ldw	r3,244(sp)
8111effc:	1000b326 	beq	r2,zero,8111f2cc <___svfprintf_internal_r+0x12d4>
8111f000:	d9403317 	ldw	r5,204(sp)
8111f004:	84000044 	addi	r16,r16,1
8111f008:	8c400044 	addi	r17,r17,1
8111f00c:	28bfffc4 	addi	r2,r5,-1
8111f010:	1887883a 	add	r3,r3,r2
8111f014:	b0800115 	stw	r2,4(r22)
8111f018:	b4000015 	stw	r16,0(r22)
8111f01c:	d8c02015 	stw	r3,128(sp)
8111f020:	dc401f15 	stw	r17,124(sp)
8111f024:	008001c4 	movi	r2,7
8111f028:	1440d216 	blt	r2,r17,8111f374 <___svfprintf_internal_r+0x137c>
8111f02c:	b5800204 	addi	r22,r22,8
8111f030:	d9003b17 	ldw	r4,236(sp)
8111f034:	df0022c4 	addi	fp,sp,139
8111f038:	8c400044 	addi	r17,r17,1
8111f03c:	20c7883a 	add	r3,r4,r3
8111f040:	b7000015 	stw	fp,0(r22)
8111f044:	b1000115 	stw	r4,4(r22)
8111f048:	d8c02015 	stw	r3,128(sp)
8111f04c:	dc401f15 	stw	r17,124(sp)
8111f050:	008001c4 	movi	r2,7
8111f054:	14400e16 	blt	r2,r17,8111f090 <___svfprintf_internal_r+0x1098>
8111f058:	b2000204 	addi	r8,r22,8
8111f05c:	003e3c06 	br	8111e950 <__reset+0xfb0fe950>
8111f060:	01204574 	movhi	r4,33045
8111f064:	212e0e84 	addi	r4,r4,-18374
8111f068:	d9002b15 	stw	r4,172(sp)
8111f06c:	d9002b17 	ldw	r4,172(sp)
8111f070:	1c07883a 	add	r3,r3,r16
8111f074:	44000115 	stw	r16,4(r8)
8111f078:	41000015 	stw	r4,0(r8)
8111f07c:	10800044 	addi	r2,r2,1
8111f080:	d8c02015 	stw	r3,128(sp)
8111f084:	d8801f15 	stw	r2,124(sp)
8111f088:	010001c4 	movi	r4,7
8111f08c:	20be2f0e 	bge	r4,r2,8111e94c <__reset+0xfb0fe94c>
8111f090:	d9402c17 	ldw	r5,176(sp)
8111f094:	d9801e04 	addi	r6,sp,120
8111f098:	9809883a 	mov	r4,r19
8111f09c:	112ac180 	call	8112ac18 <__ssprint_r>
8111f0a0:	103cbc1e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f0a4:	d8c02017 	ldw	r3,128(sp)
8111f0a8:	da000404 	addi	r8,sp,16
8111f0ac:	003e2806 	br	8111e950 <__reset+0xfb0fe950>
8111f0b0:	d9402c17 	ldw	r5,176(sp)
8111f0b4:	d9801e04 	addi	r6,sp,120
8111f0b8:	9809883a 	mov	r4,r19
8111f0bc:	112ac180 	call	8112ac18 <__ssprint_r>
8111f0c0:	103e5f26 	beq	r2,zero,8111ea40 <__reset+0xfb0fea40>
8111f0c4:	003cb306 	br	8111e394 <__reset+0xfb0fe394>
8111f0c8:	d9402c17 	ldw	r5,176(sp)
8111f0cc:	d9801e04 	addi	r6,sp,120
8111f0d0:	9809883a 	mov	r4,r19
8111f0d4:	112ac180 	call	8112ac18 <__ssprint_r>
8111f0d8:	103cae1e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f0dc:	d8c02017 	ldw	r3,128(sp)
8111f0e0:	da000404 	addi	r8,sp,16
8111f0e4:	003e0d06 	br	8111e91c <__reset+0xfb0fe91c>
8111f0e8:	d9402c17 	ldw	r5,176(sp)
8111f0ec:	d9801e04 	addi	r6,sp,120
8111f0f0:	9809883a 	mov	r4,r19
8111f0f4:	112ac180 	call	8112ac18 <__ssprint_r>
8111f0f8:	103ca61e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f0fc:	d8c02017 	ldw	r3,128(sp)
8111f100:	da000404 	addi	r8,sp,16
8111f104:	003dc106 	br	8111e80c <__reset+0xfb0fe80c>
8111f108:	d9402c17 	ldw	r5,176(sp)
8111f10c:	d9801e04 	addi	r6,sp,120
8111f110:	9809883a 	mov	r4,r19
8111f114:	112ac180 	call	8112ac18 <__ssprint_r>
8111f118:	103c9e1e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f11c:	d8c02017 	ldw	r3,128(sp)
8111f120:	da000404 	addi	r8,sp,16
8111f124:	003dc706 	br	8111e844 <__reset+0xfb0fe844>
8111f128:	d8802917 	ldw	r2,164(sp)
8111f12c:	d8002785 	stb	zero,158(sp)
8111f130:	103f0816 	blt	r2,zero,8111ed54 <__reset+0xfb0fed54>
8111f134:	00ffdfc4 	movi	r3,-129
8111f138:	a584b03a 	or	r2,r20,r22
8111f13c:	90e4703a 	and	r18,r18,r3
8111f140:	103c8126 	beq	r2,zero,8111e348 <__reset+0xfb0fe348>
8111f144:	0039883a 	mov	fp,zero
8111f148:	003e7606 	br	8111eb24 <__reset+0xfb0feb24>
8111f14c:	9080040c 	andi	r2,r18,16
8111f150:	10013d26 	beq	r2,zero,8111f648 <___svfprintf_internal_r+0x1650>
8111f154:	d9002d17 	ldw	r4,180(sp)
8111f158:	d9402917 	ldw	r5,164(sp)
8111f15c:	d8002785 	stb	zero,158(sp)
8111f160:	20800104 	addi	r2,r4,4
8111f164:	25000017 	ldw	r20,0(r4)
8111f168:	002d883a 	mov	r22,zero
8111f16c:	28013f16 	blt	r5,zero,8111f66c <___svfprintf_internal_r+0x1674>
8111f170:	00ffdfc4 	movi	r3,-129
8111f174:	d8802d15 	stw	r2,180(sp)
8111f178:	90e4703a 	and	r18,r18,r3
8111f17c:	a03d2b26 	beq	r20,zero,8111e62c <__reset+0xfb0fe62c>
8111f180:	0039883a 	mov	fp,zero
8111f184:	003d2e06 	br	8111e640 <__reset+0xfb0fe640>
8111f188:	dc402617 	ldw	r17,152(sp)
8111f18c:	0441830e 	bge	zero,r17,8111f79c <___svfprintf_internal_r+0x17a4>
8111f190:	dc403217 	ldw	r17,200(sp)
8111f194:	d8803317 	ldw	r2,204(sp)
8111f198:	1440010e 	bge	r2,r17,8111f1a0 <___svfprintf_internal_r+0x11a8>
8111f19c:	1023883a 	mov	r17,r2
8111f1a0:	04400a0e 	bge	zero,r17,8111f1cc <___svfprintf_internal_r+0x11d4>
8111f1a4:	d8801f17 	ldw	r2,124(sp)
8111f1a8:	1c47883a 	add	r3,r3,r17
8111f1ac:	44000015 	stw	r16,0(r8)
8111f1b0:	10800044 	addi	r2,r2,1
8111f1b4:	44400115 	stw	r17,4(r8)
8111f1b8:	d8c02015 	stw	r3,128(sp)
8111f1bc:	d8801f15 	stw	r2,124(sp)
8111f1c0:	010001c4 	movi	r4,7
8111f1c4:	20827516 	blt	r4,r2,8111fb9c <___svfprintf_internal_r+0x1ba4>
8111f1c8:	42000204 	addi	r8,r8,8
8111f1cc:	88027b16 	blt	r17,zero,8111fbbc <___svfprintf_internal_r+0x1bc4>
8111f1d0:	d9003217 	ldw	r4,200(sp)
8111f1d4:	2463c83a 	sub	r17,r4,r17
8111f1d8:	0440990e 	bge	zero,r17,8111f440 <___svfprintf_internal_r+0x1448>
8111f1dc:	05800404 	movi	r22,16
8111f1e0:	d8801f17 	ldw	r2,124(sp)
8111f1e4:	b441530e 	bge	r22,r17,8111f734 <___svfprintf_internal_r+0x173c>
8111f1e8:	01204574 	movhi	r4,33045
8111f1ec:	212e0e84 	addi	r4,r4,-18374
8111f1f0:	d9002b15 	stw	r4,172(sp)
8111f1f4:	070001c4 	movi	fp,7
8111f1f8:	dd002c17 	ldw	r20,176(sp)
8111f1fc:	00000306 	br	8111f20c <___svfprintf_internal_r+0x1214>
8111f200:	42000204 	addi	r8,r8,8
8111f204:	8c7ffc04 	addi	r17,r17,-16
8111f208:	b4414d0e 	bge	r22,r17,8111f740 <___svfprintf_internal_r+0x1748>
8111f20c:	18c00404 	addi	r3,r3,16
8111f210:	10800044 	addi	r2,r2,1
8111f214:	45400015 	stw	r21,0(r8)
8111f218:	45800115 	stw	r22,4(r8)
8111f21c:	d8c02015 	stw	r3,128(sp)
8111f220:	d8801f15 	stw	r2,124(sp)
8111f224:	e0bff60e 	bge	fp,r2,8111f200 <__reset+0xfb0ff200>
8111f228:	d9801e04 	addi	r6,sp,120
8111f22c:	a00b883a 	mov	r5,r20
8111f230:	9809883a 	mov	r4,r19
8111f234:	112ac180 	call	8112ac18 <__ssprint_r>
8111f238:	103c561e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f23c:	d8c02017 	ldw	r3,128(sp)
8111f240:	d8801f17 	ldw	r2,124(sp)
8111f244:	da000404 	addi	r8,sp,16
8111f248:	003fee06 	br	8111f204 <__reset+0xfb0ff204>
8111f24c:	d9402c17 	ldw	r5,176(sp)
8111f250:	d9801e04 	addi	r6,sp,120
8111f254:	9809883a 	mov	r4,r19
8111f258:	112ac180 	call	8112ac18 <__ssprint_r>
8111f25c:	103c4d1e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f260:	d8c02017 	ldw	r3,128(sp)
8111f264:	df002787 	ldb	fp,158(sp)
8111f268:	da000404 	addi	r8,sp,16
8111f26c:	003d5a06 	br	8111e7d8 <__reset+0xfb0fe7d8>
8111f270:	9080040c 	andi	r2,r18,16
8111f274:	10005c26 	beq	r2,zero,8111f3e8 <___svfprintf_internal_r+0x13f0>
8111f278:	d9402d17 	ldw	r5,180(sp)
8111f27c:	d8c02917 	ldw	r3,164(sp)
8111f280:	d8002785 	stb	zero,158(sp)
8111f284:	28800104 	addi	r2,r5,4
8111f288:	2d000017 	ldw	r20,0(r5)
8111f28c:	002d883a 	mov	r22,zero
8111f290:	18005e16 	blt	r3,zero,8111f40c <___svfprintf_internal_r+0x1414>
8111f294:	00ffdfc4 	movi	r3,-129
8111f298:	d8802d15 	stw	r2,180(sp)
8111f29c:	90e4703a 	and	r18,r18,r3
8111f2a0:	0039883a 	mov	fp,zero
8111f2a4:	a03dfe26 	beq	r20,zero,8111eaa0 <__reset+0xfb0feaa0>
8111f2a8:	00800244 	movi	r2,9
8111f2ac:	153cb336 	bltu	r2,r20,8111e57c <__reset+0xfb0fe57c>
8111f2b0:	a5000c04 	addi	r20,r20,48
8111f2b4:	dc001dc4 	addi	r16,sp,119
8111f2b8:	dd001dc5 	stb	r20,119(sp)
8111f2bc:	d8c02817 	ldw	r3,160(sp)
8111f2c0:	1c07c83a 	sub	r3,r3,r16
8111f2c4:	d8c02e15 	stw	r3,184(sp)
8111f2c8:	003cf506 	br	8111e6a0 <__reset+0xfb0fe6a0>
8111f2cc:	d8803317 	ldw	r2,204(sp)
8111f2d0:	143fffc4 	addi	r16,r2,-1
8111f2d4:	043f560e 	bge	zero,r16,8111f030 <__reset+0xfb0ff030>
8111f2d8:	07000404 	movi	fp,16
8111f2dc:	e403530e 	bge	fp,r16,8112002c <___svfprintf_internal_r+0x2034>
8111f2e0:	01604574 	movhi	r5,33045
8111f2e4:	296e0e84 	addi	r5,r5,-18374
8111f2e8:	d9402b15 	stw	r5,172(sp)
8111f2ec:	01c001c4 	movi	r7,7
8111f2f0:	dd002c17 	ldw	r20,176(sp)
8111f2f4:	00000306 	br	8111f304 <___svfprintf_internal_r+0x130c>
8111f2f8:	843ffc04 	addi	r16,r16,-16
8111f2fc:	b5800204 	addi	r22,r22,8
8111f300:	e400130e 	bge	fp,r16,8111f350 <___svfprintf_internal_r+0x1358>
8111f304:	18c00404 	addi	r3,r3,16
8111f308:	8c400044 	addi	r17,r17,1
8111f30c:	b5400015 	stw	r21,0(r22)
8111f310:	b7000115 	stw	fp,4(r22)
8111f314:	d8c02015 	stw	r3,128(sp)
8111f318:	dc401f15 	stw	r17,124(sp)
8111f31c:	3c7ff60e 	bge	r7,r17,8111f2f8 <__reset+0xfb0ff2f8>
8111f320:	d9801e04 	addi	r6,sp,120
8111f324:	a00b883a 	mov	r5,r20
8111f328:	9809883a 	mov	r4,r19
8111f32c:	d9c03d15 	stw	r7,244(sp)
8111f330:	112ac180 	call	8112ac18 <__ssprint_r>
8111f334:	d9c03d17 	ldw	r7,244(sp)
8111f338:	103c161e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f33c:	843ffc04 	addi	r16,r16,-16
8111f340:	d8c02017 	ldw	r3,128(sp)
8111f344:	dc401f17 	ldw	r17,124(sp)
8111f348:	dd800404 	addi	r22,sp,16
8111f34c:	e43fed16 	blt	fp,r16,8111f304 <__reset+0xfb0ff304>
8111f350:	d8802b17 	ldw	r2,172(sp)
8111f354:	1c07883a 	add	r3,r3,r16
8111f358:	8c400044 	addi	r17,r17,1
8111f35c:	b0800015 	stw	r2,0(r22)
8111f360:	b4000115 	stw	r16,4(r22)
8111f364:	d8c02015 	stw	r3,128(sp)
8111f368:	dc401f15 	stw	r17,124(sp)
8111f36c:	008001c4 	movi	r2,7
8111f370:	147f2e0e 	bge	r2,r17,8111f02c <__reset+0xfb0ff02c>
8111f374:	d9402c17 	ldw	r5,176(sp)
8111f378:	d9801e04 	addi	r6,sp,120
8111f37c:	9809883a 	mov	r4,r19
8111f380:	112ac180 	call	8112ac18 <__ssprint_r>
8111f384:	103c031e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f388:	d8c02017 	ldw	r3,128(sp)
8111f38c:	dc401f17 	ldw	r17,124(sp)
8111f390:	dd800404 	addi	r22,sp,16
8111f394:	003f2606 	br	8111f030 <__reset+0xfb0ff030>
8111f398:	9080040c 	andi	r2,r18,16
8111f39c:	1000c326 	beq	r2,zero,8111f6ac <___svfprintf_internal_r+0x16b4>
8111f3a0:	d8802d17 	ldw	r2,180(sp)
8111f3a4:	15000017 	ldw	r20,0(r2)
8111f3a8:	10800104 	addi	r2,r2,4
8111f3ac:	d8802d15 	stw	r2,180(sp)
8111f3b0:	a02dd7fa 	srai	r22,r20,31
8111f3b4:	b005883a 	mov	r2,r22
8111f3b8:	103c680e 	bge	r2,zero,8111e55c <__reset+0xfb0fe55c>
8111f3bc:	0529c83a 	sub	r20,zero,r20
8111f3c0:	a004c03a 	cmpne	r2,r20,zero
8111f3c4:	05adc83a 	sub	r22,zero,r22
8111f3c8:	b0adc83a 	sub	r22,r22,r2
8111f3cc:	d8802917 	ldw	r2,164(sp)
8111f3d0:	07000b44 	movi	fp,45
8111f3d4:	df002785 	stb	fp,158(sp)
8111f3d8:	10022e16 	blt	r2,zero,8111fc94 <___svfprintf_internal_r+0x1c9c>
8111f3dc:	00bfdfc4 	movi	r2,-129
8111f3e0:	90a4703a 	and	r18,r18,r2
8111f3e4:	003c6406 	br	8111e578 <__reset+0xfb0fe578>
8111f3e8:	9080100c 	andi	r2,r18,64
8111f3ec:	d8002785 	stb	zero,158(sp)
8111f3f0:	10012526 	beq	r2,zero,8111f888 <___svfprintf_internal_r+0x1890>
8111f3f4:	d9002d17 	ldw	r4,180(sp)
8111f3f8:	d9402917 	ldw	r5,164(sp)
8111f3fc:	002d883a 	mov	r22,zero
8111f400:	20800104 	addi	r2,r4,4
8111f404:	2500000b 	ldhu	r20,0(r4)
8111f408:	283fa20e 	bge	r5,zero,8111f294 <__reset+0xfb0ff294>
8111f40c:	d8802d15 	stw	r2,180(sp)
8111f410:	0039883a 	mov	fp,zero
8111f414:	a584b03a 	or	r2,r20,r22
8111f418:	103c571e 	bne	r2,zero,8111e578 <__reset+0xfb0fe578>
8111f41c:	00800044 	movi	r2,1
8111f420:	003e5006 	br	8111ed64 <__reset+0xfb0fed64>
8111f424:	d9402c17 	ldw	r5,176(sp)
8111f428:	d9801e04 	addi	r6,sp,120
8111f42c:	9809883a 	mov	r4,r19
8111f430:	112ac180 	call	8112ac18 <__ssprint_r>
8111f434:	103bd71e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f438:	d8c02017 	ldw	r3,128(sp)
8111f43c:	da000404 	addi	r8,sp,16
8111f440:	d9003217 	ldw	r4,200(sp)
8111f444:	d8802617 	ldw	r2,152(sp)
8111f448:	d9403317 	ldw	r5,204(sp)
8111f44c:	8123883a 	add	r17,r16,r4
8111f450:	11400216 	blt	r2,r5,8111f45c <___svfprintf_internal_r+0x1464>
8111f454:	9100004c 	andi	r4,r18,1
8111f458:	20000d26 	beq	r4,zero,8111f490 <___svfprintf_internal_r+0x1498>
8111f45c:	d9003817 	ldw	r4,224(sp)
8111f460:	d9403417 	ldw	r5,208(sp)
8111f464:	1907883a 	add	r3,r3,r4
8111f468:	d9001f17 	ldw	r4,124(sp)
8111f46c:	41400015 	stw	r5,0(r8)
8111f470:	d9403817 	ldw	r5,224(sp)
8111f474:	21000044 	addi	r4,r4,1
8111f478:	d8c02015 	stw	r3,128(sp)
8111f47c:	41400115 	stw	r5,4(r8)
8111f480:	d9001f15 	stw	r4,124(sp)
8111f484:	014001c4 	movi	r5,7
8111f488:	2901dc16 	blt	r5,r4,8111fbfc <___svfprintf_internal_r+0x1c04>
8111f48c:	42000204 	addi	r8,r8,8
8111f490:	d9003317 	ldw	r4,204(sp)
8111f494:	8121883a 	add	r16,r16,r4
8111f498:	2085c83a 	sub	r2,r4,r2
8111f49c:	8461c83a 	sub	r16,r16,r17
8111f4a0:	1400010e 	bge	r2,r16,8111f4a8 <___svfprintf_internal_r+0x14b0>
8111f4a4:	1021883a 	mov	r16,r2
8111f4a8:	04000a0e 	bge	zero,r16,8111f4d4 <___svfprintf_internal_r+0x14dc>
8111f4ac:	d9001f17 	ldw	r4,124(sp)
8111f4b0:	1c07883a 	add	r3,r3,r16
8111f4b4:	44400015 	stw	r17,0(r8)
8111f4b8:	21000044 	addi	r4,r4,1
8111f4bc:	44000115 	stw	r16,4(r8)
8111f4c0:	d8c02015 	stw	r3,128(sp)
8111f4c4:	d9001f15 	stw	r4,124(sp)
8111f4c8:	014001c4 	movi	r5,7
8111f4cc:	2901e616 	blt	r5,r4,8111fc68 <___svfprintf_internal_r+0x1c70>
8111f4d0:	42000204 	addi	r8,r8,8
8111f4d4:	8001f616 	blt	r16,zero,8111fcb0 <___svfprintf_internal_r+0x1cb8>
8111f4d8:	1421c83a 	sub	r16,r2,r16
8111f4dc:	043d1c0e 	bge	zero,r16,8111e950 <__reset+0xfb0fe950>
8111f4e0:	04400404 	movi	r17,16
8111f4e4:	d8801f17 	ldw	r2,124(sp)
8111f4e8:	8c3edd0e 	bge	r17,r16,8111f060 <__reset+0xfb0ff060>
8111f4ec:	01604574 	movhi	r5,33045
8111f4f0:	296e0e84 	addi	r5,r5,-18374
8111f4f4:	d9402b15 	stw	r5,172(sp)
8111f4f8:	058001c4 	movi	r22,7
8111f4fc:	dd002c17 	ldw	r20,176(sp)
8111f500:	00000306 	br	8111f510 <___svfprintf_internal_r+0x1518>
8111f504:	42000204 	addi	r8,r8,8
8111f508:	843ffc04 	addi	r16,r16,-16
8111f50c:	8c3ed70e 	bge	r17,r16,8111f06c <__reset+0xfb0ff06c>
8111f510:	18c00404 	addi	r3,r3,16
8111f514:	10800044 	addi	r2,r2,1
8111f518:	45400015 	stw	r21,0(r8)
8111f51c:	44400115 	stw	r17,4(r8)
8111f520:	d8c02015 	stw	r3,128(sp)
8111f524:	d8801f15 	stw	r2,124(sp)
8111f528:	b0bff60e 	bge	r22,r2,8111f504 <__reset+0xfb0ff504>
8111f52c:	d9801e04 	addi	r6,sp,120
8111f530:	a00b883a 	mov	r5,r20
8111f534:	9809883a 	mov	r4,r19
8111f538:	112ac180 	call	8112ac18 <__ssprint_r>
8111f53c:	103b951e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f540:	d8c02017 	ldw	r3,128(sp)
8111f544:	d8801f17 	ldw	r2,124(sp)
8111f548:	da000404 	addi	r8,sp,16
8111f54c:	003fee06 	br	8111f508 <__reset+0xfb0ff508>
8111f550:	9088703a 	and	r4,r18,r2
8111f554:	203e8d1e 	bne	r4,zero,8111ef8c <__reset+0xfb0fef8c>
8111f558:	dc401f17 	ldw	r17,124(sp)
8111f55c:	40800115 	stw	r2,4(r8)
8111f560:	44000015 	stw	r16,0(r8)
8111f564:	8c400044 	addi	r17,r17,1
8111f568:	d8c02015 	stw	r3,128(sp)
8111f56c:	dc401f15 	stw	r17,124(sp)
8111f570:	008001c4 	movi	r2,7
8111f574:	147f7f16 	blt	r2,r17,8111f374 <__reset+0xfb0ff374>
8111f578:	45800204 	addi	r22,r8,8
8111f57c:	003eac06 	br	8111f030 <__reset+0xfb0ff030>
8111f580:	d9402c17 	ldw	r5,176(sp)
8111f584:	d9801e04 	addi	r6,sp,120
8111f588:	9809883a 	mov	r4,r19
8111f58c:	112ac180 	call	8112ac18 <__ssprint_r>
8111f590:	103b801e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f594:	d8c02017 	ldw	r3,128(sp)
8111f598:	dc401f17 	ldw	r17,124(sp)
8111f59c:	da000404 	addi	r8,sp,16
8111f5a0:	003e8406 	br	8111efb4 <__reset+0xfb0fefb4>
8111f5a4:	d9402c17 	ldw	r5,176(sp)
8111f5a8:	d9801e04 	addi	r6,sp,120
8111f5ac:	9809883a 	mov	r4,r19
8111f5b0:	112ac180 	call	8112ac18 <__ssprint_r>
8111f5b4:	103b771e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f5b8:	d8c02017 	ldw	r3,128(sp)
8111f5bc:	dc401f17 	ldw	r17,124(sp)
8111f5c0:	dd800404 	addi	r22,sp,16
8111f5c4:	003e8606 	br	8111efe0 <__reset+0xfb0fefe0>
8111f5c8:	0029883a 	mov	r20,zero
8111f5cc:	a5000c04 	addi	r20,r20,48
8111f5d0:	dc001dc4 	addi	r16,sp,119
8111f5d4:	dd001dc5 	stb	r20,119(sp)
8111f5d8:	003f3806 	br	8111f2bc <__reset+0xfb0ff2bc>
8111f5dc:	d9402c17 	ldw	r5,176(sp)
8111f5e0:	d9801e04 	addi	r6,sp,120
8111f5e4:	9809883a 	mov	r4,r19
8111f5e8:	112ac180 	call	8112ac18 <__ssprint_r>
8111f5ec:	103b691e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f5f0:	d8c02017 	ldw	r3,128(sp)
8111f5f4:	da000404 	addi	r8,sp,16
8111f5f8:	003c9506 	br	8111e850 <__reset+0xfb0fe850>
8111f5fc:	d9003617 	ldw	r4,216(sp)
8111f600:	d9403717 	ldw	r5,220(sp)
8111f604:	da003e15 	stw	r8,248(sp)
8111f608:	1128a2c0 	call	81128a2c <__fpclassifyd>
8111f60c:	da003e17 	ldw	r8,248(sp)
8111f610:	1000bd1e 	bne	r2,zero,8111f908 <___svfprintf_internal_r+0x1910>
8111f614:	008011c4 	movi	r2,71
8111f618:	14411e0e 	bge	r2,r17,8111fa94 <___svfprintf_internal_r+0x1a9c>
8111f61c:	04204574 	movhi	r16,33045
8111f620:	842e0104 	addi	r16,r16,-18428
8111f624:	00c000c4 	movi	r3,3
8111f628:	00bfdfc4 	movi	r2,-129
8111f62c:	d8c02a15 	stw	r3,168(sp)
8111f630:	90a4703a 	and	r18,r18,r2
8111f634:	df002783 	ldbu	fp,158(sp)
8111f638:	d8c02e15 	stw	r3,184(sp)
8111f63c:	d8002915 	stw	zero,164(sp)
8111f640:	d8003215 	stw	zero,200(sp)
8111f644:	003c1c06 	br	8111e6b8 <__reset+0xfb0fe6b8>
8111f648:	9080100c 	andi	r2,r18,64
8111f64c:	d8002785 	stb	zero,158(sp)
8111f650:	10009426 	beq	r2,zero,8111f8a4 <___svfprintf_internal_r+0x18ac>
8111f654:	d8c02d17 	ldw	r3,180(sp)
8111f658:	d9002917 	ldw	r4,164(sp)
8111f65c:	002d883a 	mov	r22,zero
8111f660:	18800104 	addi	r2,r3,4
8111f664:	1d00000b 	ldhu	r20,0(r3)
8111f668:	203ec10e 	bge	r4,zero,8111f170 <__reset+0xfb0ff170>
8111f66c:	a586b03a 	or	r3,r20,r22
8111f670:	d8802d15 	stw	r2,180(sp)
8111f674:	183ec21e 	bne	r3,zero,8111f180 <__reset+0xfb0ff180>
8111f678:	0039883a 	mov	fp,zero
8111f67c:	0005883a 	mov	r2,zero
8111f680:	003db806 	br	8111ed64 <__reset+0xfb0fed64>
8111f684:	d8802d17 	ldw	r2,180(sp)
8111f688:	d8c02d17 	ldw	r3,180(sp)
8111f68c:	d9002d17 	ldw	r4,180(sp)
8111f690:	10800017 	ldw	r2,0(r2)
8111f694:	18c00117 	ldw	r3,4(r3)
8111f698:	21000204 	addi	r4,r4,8
8111f69c:	d8803615 	stw	r2,216(sp)
8111f6a0:	d8c03715 	stw	r3,220(sp)
8111f6a4:	d9002d15 	stw	r4,180(sp)
8111f6a8:	003b8206 	br	8111e4b4 <__reset+0xfb0fe4b4>
8111f6ac:	9080100c 	andi	r2,r18,64
8111f6b0:	10010726 	beq	r2,zero,8111fad0 <___svfprintf_internal_r+0x1ad8>
8111f6b4:	d8c02d17 	ldw	r3,180(sp)
8111f6b8:	1d00000f 	ldh	r20,0(r3)
8111f6bc:	18c00104 	addi	r3,r3,4
8111f6c0:	d8c02d15 	stw	r3,180(sp)
8111f6c4:	a02dd7fa 	srai	r22,r20,31
8111f6c8:	b005883a 	mov	r2,r22
8111f6cc:	003ba206 	br	8111e558 <__reset+0xfb0fe558>
8111f6d0:	9080100c 	andi	r2,r18,64
8111f6d4:	10010526 	beq	r2,zero,8111faec <___svfprintf_internal_r+0x1af4>
8111f6d8:	d9002d17 	ldw	r4,180(sp)
8111f6dc:	002d883a 	mov	r22,zero
8111f6e0:	2500000b 	ldhu	r20,0(r4)
8111f6e4:	21000104 	addi	r4,r4,4
8111f6e8:	d9002d15 	stw	r4,180(sp)
8111f6ec:	003cfe06 	br	8111eae8 <__reset+0xfb0feae8>
8111f6f0:	bc400007 	ldb	r17,0(r23)
8111f6f4:	003a9606 	br	8111e150 <__reset+0xfb0fe150>
8111f6f8:	9080040c 	andi	r2,r18,16
8111f6fc:	10010126 	beq	r2,zero,8111fb04 <___svfprintf_internal_r+0x1b0c>
8111f700:	d9402d17 	ldw	r5,180(sp)
8111f704:	d8c02f17 	ldw	r3,188(sp)
8111f708:	28800017 	ldw	r2,0(r5)
8111f70c:	29400104 	addi	r5,r5,4
8111f710:	d9402d15 	stw	r5,180(sp)
8111f714:	10c00015 	stw	r3,0(r2)
8111f718:	003a6406 	br	8111e0ac <__reset+0xfb0fe0ac>
8111f71c:	d9002917 	ldw	r4,164(sp)
8111f720:	d8002785 	stb	zero,158(sp)
8111f724:	203d8d16 	blt	r4,zero,8111ed5c <__reset+0xfb0fed5c>
8111f728:	00bfdfc4 	movi	r2,-129
8111f72c:	90a4703a 	and	r18,r18,r2
8111f730:	003b0506 	br	8111e348 <__reset+0xfb0fe348>
8111f734:	01604574 	movhi	r5,33045
8111f738:	296e0e84 	addi	r5,r5,-18374
8111f73c:	d9402b15 	stw	r5,172(sp)
8111f740:	d9402b17 	ldw	r5,172(sp)
8111f744:	1c47883a 	add	r3,r3,r17
8111f748:	10800044 	addi	r2,r2,1
8111f74c:	41400015 	stw	r5,0(r8)
8111f750:	44400115 	stw	r17,4(r8)
8111f754:	d8c02015 	stw	r3,128(sp)
8111f758:	d8801f15 	stw	r2,124(sp)
8111f75c:	010001c4 	movi	r4,7
8111f760:	20bf3016 	blt	r4,r2,8111f424 <__reset+0xfb0ff424>
8111f764:	42000204 	addi	r8,r8,8
8111f768:	003f3506 	br	8111f440 <__reset+0xfb0ff440>
8111f76c:	01204574 	movhi	r4,33045
8111f770:	212e0e84 	addi	r4,r4,-18374
8111f774:	d9002b15 	stw	r4,172(sp)
8111f778:	003c5e06 	br	8111e8f4 <__reset+0xfb0fe8f4>
8111f77c:	d9402c17 	ldw	r5,176(sp)
8111f780:	d9801e04 	addi	r6,sp,120
8111f784:	9809883a 	mov	r4,r19
8111f788:	112ac180 	call	8112ac18 <__ssprint_r>
8111f78c:	103b011e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f790:	d8c02017 	ldw	r3,128(sp)
8111f794:	da000404 	addi	r8,sp,16
8111f798:	003d9306 	br	8111ede8 <__reset+0xfb0fede8>
8111f79c:	d8801f17 	ldw	r2,124(sp)
8111f7a0:	01604574 	movhi	r5,33045
8111f7a4:	01000044 	movi	r4,1
8111f7a8:	18c00044 	addi	r3,r3,1
8111f7ac:	10800044 	addi	r2,r2,1
8111f7b0:	296e0e04 	addi	r5,r5,-18376
8111f7b4:	41000115 	stw	r4,4(r8)
8111f7b8:	41400015 	stw	r5,0(r8)
8111f7bc:	d8c02015 	stw	r3,128(sp)
8111f7c0:	d8801f15 	stw	r2,124(sp)
8111f7c4:	010001c4 	movi	r4,7
8111f7c8:	2080b516 	blt	r4,r2,8111faa0 <___svfprintf_internal_r+0x1aa8>
8111f7cc:	42000204 	addi	r8,r8,8
8111f7d0:	8800041e 	bne	r17,zero,8111f7e4 <___svfprintf_internal_r+0x17ec>
8111f7d4:	d8803317 	ldw	r2,204(sp)
8111f7d8:	1000021e 	bne	r2,zero,8111f7e4 <___svfprintf_internal_r+0x17ec>
8111f7dc:	9080004c 	andi	r2,r18,1
8111f7e0:	103c5b26 	beq	r2,zero,8111e950 <__reset+0xfb0fe950>
8111f7e4:	d9003817 	ldw	r4,224(sp)
8111f7e8:	d8801f17 	ldw	r2,124(sp)
8111f7ec:	d9403417 	ldw	r5,208(sp)
8111f7f0:	20c7883a 	add	r3,r4,r3
8111f7f4:	10800044 	addi	r2,r2,1
8111f7f8:	41000115 	stw	r4,4(r8)
8111f7fc:	41400015 	stw	r5,0(r8)
8111f800:	d8c02015 	stw	r3,128(sp)
8111f804:	d8801f15 	stw	r2,124(sp)
8111f808:	010001c4 	movi	r4,7
8111f80c:	20818016 	blt	r4,r2,8111fe10 <___svfprintf_internal_r+0x1e18>
8111f810:	42000204 	addi	r8,r8,8
8111f814:	0463c83a 	sub	r17,zero,r17
8111f818:	0440cb0e 	bge	zero,r17,8111fb48 <___svfprintf_internal_r+0x1b50>
8111f81c:	05800404 	movi	r22,16
8111f820:	b440e80e 	bge	r22,r17,8111fbc4 <___svfprintf_internal_r+0x1bcc>
8111f824:	01604574 	movhi	r5,33045
8111f828:	296e0e84 	addi	r5,r5,-18374
8111f82c:	d9402b15 	stw	r5,172(sp)
8111f830:	070001c4 	movi	fp,7
8111f834:	dd002c17 	ldw	r20,176(sp)
8111f838:	00000306 	br	8111f848 <___svfprintf_internal_r+0x1850>
8111f83c:	42000204 	addi	r8,r8,8
8111f840:	8c7ffc04 	addi	r17,r17,-16
8111f844:	b440e20e 	bge	r22,r17,8111fbd0 <___svfprintf_internal_r+0x1bd8>
8111f848:	18c00404 	addi	r3,r3,16
8111f84c:	10800044 	addi	r2,r2,1
8111f850:	45400015 	stw	r21,0(r8)
8111f854:	45800115 	stw	r22,4(r8)
8111f858:	d8c02015 	stw	r3,128(sp)
8111f85c:	d8801f15 	stw	r2,124(sp)
8111f860:	e0bff60e 	bge	fp,r2,8111f83c <__reset+0xfb0ff83c>
8111f864:	d9801e04 	addi	r6,sp,120
8111f868:	a00b883a 	mov	r5,r20
8111f86c:	9809883a 	mov	r4,r19
8111f870:	112ac180 	call	8112ac18 <__ssprint_r>
8111f874:	103ac71e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f878:	d8c02017 	ldw	r3,128(sp)
8111f87c:	d8801f17 	ldw	r2,124(sp)
8111f880:	da000404 	addi	r8,sp,16
8111f884:	003fee06 	br	8111f840 <__reset+0xfb0ff840>
8111f888:	d8c02d17 	ldw	r3,180(sp)
8111f88c:	d9002917 	ldw	r4,164(sp)
8111f890:	002d883a 	mov	r22,zero
8111f894:	18800104 	addi	r2,r3,4
8111f898:	1d000017 	ldw	r20,0(r3)
8111f89c:	203e7d0e 	bge	r4,zero,8111f294 <__reset+0xfb0ff294>
8111f8a0:	003eda06 	br	8111f40c <__reset+0xfb0ff40c>
8111f8a4:	d9402d17 	ldw	r5,180(sp)
8111f8a8:	d8c02917 	ldw	r3,164(sp)
8111f8ac:	002d883a 	mov	r22,zero
8111f8b0:	28800104 	addi	r2,r5,4
8111f8b4:	2d000017 	ldw	r20,0(r5)
8111f8b8:	183e2d0e 	bge	r3,zero,8111f170 <__reset+0xfb0ff170>
8111f8bc:	003f6b06 	br	8111f66c <__reset+0xfb0ff66c>
8111f8c0:	d8c02d15 	stw	r3,180(sp)
8111f8c4:	0039883a 	mov	fp,zero
8111f8c8:	003ed206 	br	8111f414 <__reset+0xfb0ff414>
8111f8cc:	bc400043 	ldbu	r17,1(r23)
8111f8d0:	94800814 	ori	r18,r18,32
8111f8d4:	bdc00044 	addi	r23,r23,1
8111f8d8:	8c403fcc 	andi	r17,r17,255
8111f8dc:	8c40201c 	xori	r17,r17,128
8111f8e0:	8c7fe004 	addi	r17,r17,-128
8111f8e4:	003a1a06 	br	8111e150 <__reset+0xfb0fe150>
8111f8e8:	d9402c17 	ldw	r5,176(sp)
8111f8ec:	d9801e04 	addi	r6,sp,120
8111f8f0:	9809883a 	mov	r4,r19
8111f8f4:	112ac180 	call	8112ac18 <__ssprint_r>
8111f8f8:	103aa61e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111f8fc:	d8c02017 	ldw	r3,128(sp)
8111f900:	da000404 	addi	r8,sp,16
8111f904:	003d4a06 	br	8111ee30 <__reset+0xfb0fee30>
8111f908:	d9002917 	ldw	r4,164(sp)
8111f90c:	05bff7c4 	movi	r22,-33
8111f910:	00bfffc4 	movi	r2,-1
8111f914:	8dac703a 	and	r22,r17,r22
8111f918:	20806a26 	beq	r4,r2,8111fac4 <___svfprintf_internal_r+0x1acc>
8111f91c:	008011c4 	movi	r2,71
8111f920:	b0813726 	beq	r22,r2,8111fe00 <___svfprintf_internal_r+0x1e08>
8111f924:	d9003717 	ldw	r4,220(sp)
8111f928:	90c04014 	ori	r3,r18,256
8111f92c:	d8c02b15 	stw	r3,172(sp)
8111f930:	20015d16 	blt	r4,zero,8111fea8 <___svfprintf_internal_r+0x1eb0>
8111f934:	dd003717 	ldw	r20,220(sp)
8111f938:	d8002a05 	stb	zero,168(sp)
8111f93c:	00801984 	movi	r2,102
8111f940:	88814026 	beq	r17,r2,8111fe44 <___svfprintf_internal_r+0x1e4c>
8111f944:	00801184 	movi	r2,70
8111f948:	88817126 	beq	r17,r2,8111ff10 <___svfprintf_internal_r+0x1f18>
8111f94c:	00801144 	movi	r2,69
8111f950:	b0816226 	beq	r22,r2,8111fedc <___svfprintf_internal_r+0x1ee4>
8111f954:	d8c02917 	ldw	r3,164(sp)
8111f958:	d8802104 	addi	r2,sp,132
8111f95c:	d8800315 	stw	r2,12(sp)
8111f960:	d9403617 	ldw	r5,216(sp)
8111f964:	d8802504 	addi	r2,sp,148
8111f968:	d8800215 	stw	r2,8(sp)
8111f96c:	d8802604 	addi	r2,sp,152
8111f970:	d8c00015 	stw	r3,0(sp)
8111f974:	d8800115 	stw	r2,4(sp)
8111f978:	01c00084 	movi	r7,2
8111f97c:	a00d883a 	mov	r6,r20
8111f980:	9809883a 	mov	r4,r19
8111f984:	d8c03d15 	stw	r3,244(sp)
8111f988:	da003e15 	stw	r8,248(sp)
8111f98c:	11242e40 	call	811242e4 <_dtoa_r>
8111f990:	1021883a 	mov	r16,r2
8111f994:	008019c4 	movi	r2,103
8111f998:	d8c03d17 	ldw	r3,244(sp)
8111f99c:	da003e17 	ldw	r8,248(sp)
8111f9a0:	8880e726 	beq	r17,r2,8111fd40 <___svfprintf_internal_r+0x1d48>
8111f9a4:	008011c4 	movi	r2,71
8111f9a8:	8880d426 	beq	r17,r2,8111fcfc <___svfprintf_internal_r+0x1d04>
8111f9ac:	80f9883a 	add	fp,r16,r3
8111f9b0:	d9003617 	ldw	r4,216(sp)
8111f9b4:	000d883a 	mov	r6,zero
8111f9b8:	000f883a 	mov	r7,zero
8111f9bc:	a00b883a 	mov	r5,r20
8111f9c0:	da003e15 	stw	r8,248(sp)
8111f9c4:	1130c100 	call	81130c10 <__eqdf2>
8111f9c8:	da003e17 	ldw	r8,248(sp)
8111f9cc:	1000e426 	beq	r2,zero,8111fd60 <___svfprintf_internal_r+0x1d68>
8111f9d0:	d8802117 	ldw	r2,132(sp)
8111f9d4:	1700062e 	bgeu	r2,fp,8111f9f0 <___svfprintf_internal_r+0x19f8>
8111f9d8:	01000c04 	movi	r4,48
8111f9dc:	10c00044 	addi	r3,r2,1
8111f9e0:	d8c02115 	stw	r3,132(sp)
8111f9e4:	11000005 	stb	r4,0(r2)
8111f9e8:	d8802117 	ldw	r2,132(sp)
8111f9ec:	173ffb36 	bltu	r2,fp,8111f9dc <__reset+0xfb0ff9dc>
8111f9f0:	1405c83a 	sub	r2,r2,r16
8111f9f4:	d8803315 	stw	r2,204(sp)
8111f9f8:	008011c4 	movi	r2,71
8111f9fc:	b080c526 	beq	r22,r2,8111fd14 <___svfprintf_internal_r+0x1d1c>
8111fa00:	00801944 	movi	r2,101
8111fa04:	1441d90e 	bge	r2,r17,8112016c <___svfprintf_internal_r+0x2174>
8111fa08:	d8c02617 	ldw	r3,152(sp)
8111fa0c:	00801984 	movi	r2,102
8111fa10:	d8c03215 	stw	r3,200(sp)
8111fa14:	88813426 	beq	r17,r2,8111fee8 <___svfprintf_internal_r+0x1ef0>
8111fa18:	d8c03217 	ldw	r3,200(sp)
8111fa1c:	d9003317 	ldw	r4,204(sp)
8111fa20:	19012516 	blt	r3,r4,8111feb8 <___svfprintf_internal_r+0x1ec0>
8111fa24:	9480004c 	andi	r18,r18,1
8111fa28:	9001841e 	bne	r18,zero,8112003c <___svfprintf_internal_r+0x2044>
8111fa2c:	1805883a 	mov	r2,r3
8111fa30:	1801cc16 	blt	r3,zero,81120164 <___svfprintf_internal_r+0x216c>
8111fa34:	d8c03217 	ldw	r3,200(sp)
8111fa38:	044019c4 	movi	r17,103
8111fa3c:	d8c02e15 	stw	r3,184(sp)
8111fa40:	df002a07 	ldb	fp,168(sp)
8111fa44:	e000a61e 	bne	fp,zero,8111fce0 <___svfprintf_internal_r+0x1ce8>
8111fa48:	df002783 	ldbu	fp,158(sp)
8111fa4c:	d8802a15 	stw	r2,168(sp)
8111fa50:	dc802b17 	ldw	r18,172(sp)
8111fa54:	d8002915 	stw	zero,164(sp)
8111fa58:	003b1706 	br	8111e6b8 <__reset+0xfb0fe6b8>
8111fa5c:	04204574 	movhi	r16,33045
8111fa60:	842dfe04 	addi	r16,r16,-18440
8111fa64:	003aa606 	br	8111e500 <__reset+0xfb0fe500>
8111fa68:	d9003917 	ldw	r4,228(sp)
8111fa6c:	04001004 	movi	r16,64
8111fa70:	800b883a 	mov	r5,r16
8111fa74:	111c9b80 	call	8111c9b8 <_malloc_r>
8111fa78:	d9002c17 	ldw	r4,176(sp)
8111fa7c:	20800015 	stw	r2,0(r4)
8111fa80:	20800415 	stw	r2,16(r4)
8111fa84:	1001cb26 	beq	r2,zero,811201b4 <___svfprintf_internal_r+0x21bc>
8111fa88:	d8802c17 	ldw	r2,176(sp)
8111fa8c:	14000515 	stw	r16,20(r2)
8111fa90:	00397606 	br	8111e06c <__reset+0xfb0fe06c>
8111fa94:	04204574 	movhi	r16,33045
8111fa98:	842e0004 	addi	r16,r16,-18432
8111fa9c:	003ee106 	br	8111f624 <__reset+0xfb0ff624>
8111faa0:	d9402c17 	ldw	r5,176(sp)
8111faa4:	d9801e04 	addi	r6,sp,120
8111faa8:	9809883a 	mov	r4,r19
8111faac:	112ac180 	call	8112ac18 <__ssprint_r>
8111fab0:	103a381e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111fab4:	dc402617 	ldw	r17,152(sp)
8111fab8:	d8c02017 	ldw	r3,128(sp)
8111fabc:	da000404 	addi	r8,sp,16
8111fac0:	003f4306 	br	8111f7d0 <__reset+0xfb0ff7d0>
8111fac4:	01400184 	movi	r5,6
8111fac8:	d9402915 	stw	r5,164(sp)
8111facc:	003f9506 	br	8111f924 <__reset+0xfb0ff924>
8111fad0:	d9002d17 	ldw	r4,180(sp)
8111fad4:	25000017 	ldw	r20,0(r4)
8111fad8:	21000104 	addi	r4,r4,4
8111fadc:	d9002d15 	stw	r4,180(sp)
8111fae0:	a02dd7fa 	srai	r22,r20,31
8111fae4:	b005883a 	mov	r2,r22
8111fae8:	003a9b06 	br	8111e558 <__reset+0xfb0fe558>
8111faec:	d9402d17 	ldw	r5,180(sp)
8111faf0:	002d883a 	mov	r22,zero
8111faf4:	2d000017 	ldw	r20,0(r5)
8111faf8:	29400104 	addi	r5,r5,4
8111fafc:	d9402d15 	stw	r5,180(sp)
8111fb00:	003bf906 	br	8111eae8 <__reset+0xfb0feae8>
8111fb04:	9480100c 	andi	r18,r18,64
8111fb08:	90006e26 	beq	r18,zero,8111fcc4 <___svfprintf_internal_r+0x1ccc>
8111fb0c:	d9002d17 	ldw	r4,180(sp)
8111fb10:	d9402f17 	ldw	r5,188(sp)
8111fb14:	20800017 	ldw	r2,0(r4)
8111fb18:	21000104 	addi	r4,r4,4
8111fb1c:	d9002d15 	stw	r4,180(sp)
8111fb20:	1140000d 	sth	r5,0(r2)
8111fb24:	00396106 	br	8111e0ac <__reset+0xfb0fe0ac>
8111fb28:	d9402c17 	ldw	r5,176(sp)
8111fb2c:	d9801e04 	addi	r6,sp,120
8111fb30:	9809883a 	mov	r4,r19
8111fb34:	112ac180 	call	8112ac18 <__ssprint_r>
8111fb38:	103a161e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111fb3c:	d8c02017 	ldw	r3,128(sp)
8111fb40:	d8801f17 	ldw	r2,124(sp)
8111fb44:	da000404 	addi	r8,sp,16
8111fb48:	d9403317 	ldw	r5,204(sp)
8111fb4c:	10800044 	addi	r2,r2,1
8111fb50:	44000015 	stw	r16,0(r8)
8111fb54:	28c7883a 	add	r3,r5,r3
8111fb58:	003b7706 	br	8111e938 <__reset+0xfb0fe938>
8111fb5c:	8009883a 	mov	r4,r16
8111fb60:	da003e15 	stw	r8,248(sp)
8111fb64:	111dcc00 	call	8111dcc0 <strlen>
8111fb68:	d8802e15 	stw	r2,184(sp)
8111fb6c:	da003e17 	ldw	r8,248(sp)
8111fb70:	103c280e 	bge	r2,zero,8111ec14 <__reset+0xfb0fec14>
8111fb74:	0005883a 	mov	r2,zero
8111fb78:	003c2606 	br	8111ec14 <__reset+0xfb0fec14>
8111fb7c:	00bfffc4 	movi	r2,-1
8111fb80:	003a0906 	br	8111e3a8 <__reset+0xfb0fe3a8>
8111fb84:	01204574 	movhi	r4,33045
8111fb88:	212e1284 	addi	r4,r4,-18358
8111fb8c:	d9003515 	stw	r4,212(sp)
8111fb90:	003b0606 	br	8111e7ac <__reset+0xfb0fe7ac>
8111fb94:	013fffc4 	movi	r4,-1
8111fb98:	003a2706 	br	8111e438 <__reset+0xfb0fe438>
8111fb9c:	d9402c17 	ldw	r5,176(sp)
8111fba0:	d9801e04 	addi	r6,sp,120
8111fba4:	9809883a 	mov	r4,r19
8111fba8:	112ac180 	call	8112ac18 <__ssprint_r>
8111fbac:	1039f91e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111fbb0:	d8c02017 	ldw	r3,128(sp)
8111fbb4:	da000404 	addi	r8,sp,16
8111fbb8:	003d8406 	br	8111f1cc <__reset+0xfb0ff1cc>
8111fbbc:	0023883a 	mov	r17,zero
8111fbc0:	003d8306 	br	8111f1d0 <__reset+0xfb0ff1d0>
8111fbc4:	01204574 	movhi	r4,33045
8111fbc8:	212e0e84 	addi	r4,r4,-18374
8111fbcc:	d9002b15 	stw	r4,172(sp)
8111fbd0:	d9002b17 	ldw	r4,172(sp)
8111fbd4:	1c47883a 	add	r3,r3,r17
8111fbd8:	10800044 	addi	r2,r2,1
8111fbdc:	41000015 	stw	r4,0(r8)
8111fbe0:	44400115 	stw	r17,4(r8)
8111fbe4:	d8c02015 	stw	r3,128(sp)
8111fbe8:	d8801f15 	stw	r2,124(sp)
8111fbec:	010001c4 	movi	r4,7
8111fbf0:	20bfcd16 	blt	r4,r2,8111fb28 <__reset+0xfb0ffb28>
8111fbf4:	42000204 	addi	r8,r8,8
8111fbf8:	003fd306 	br	8111fb48 <__reset+0xfb0ffb48>
8111fbfc:	d9402c17 	ldw	r5,176(sp)
8111fc00:	d9801e04 	addi	r6,sp,120
8111fc04:	9809883a 	mov	r4,r19
8111fc08:	112ac180 	call	8112ac18 <__ssprint_r>
8111fc0c:	1039e11e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111fc10:	d8802617 	ldw	r2,152(sp)
8111fc14:	d8c02017 	ldw	r3,128(sp)
8111fc18:	da000404 	addi	r8,sp,16
8111fc1c:	003e1c06 	br	8111f490 <__reset+0xfb0ff490>
8111fc20:	d8802917 	ldw	r2,164(sp)
8111fc24:	00c00184 	movi	r3,6
8111fc28:	1880012e 	bgeu	r3,r2,8111fc30 <___svfprintf_internal_r+0x1c38>
8111fc2c:	1805883a 	mov	r2,r3
8111fc30:	d8802e15 	stw	r2,184(sp)
8111fc34:	1000f316 	blt	r2,zero,81120004 <___svfprintf_internal_r+0x200c>
8111fc38:	04204574 	movhi	r16,33045
8111fc3c:	d8802a15 	stw	r2,168(sp)
8111fc40:	dd002d15 	stw	r20,180(sp)
8111fc44:	d8002915 	stw	zero,164(sp)
8111fc48:	d8003215 	stw	zero,200(sp)
8111fc4c:	842e0c04 	addi	r16,r16,-18384
8111fc50:	0039883a 	mov	fp,zero
8111fc54:	003a9f06 	br	8111e6d4 <__reset+0xfb0fe6d4>
8111fc58:	01204574 	movhi	r4,33045
8111fc5c:	212e1284 	addi	r4,r4,-18358
8111fc60:	d9003515 	stw	r4,212(sp)
8111fc64:	003b5f06 	br	8111e9e4 <__reset+0xfb0fe9e4>
8111fc68:	d9402c17 	ldw	r5,176(sp)
8111fc6c:	d9801e04 	addi	r6,sp,120
8111fc70:	9809883a 	mov	r4,r19
8111fc74:	112ac180 	call	8112ac18 <__ssprint_r>
8111fc78:	1039c61e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111fc7c:	d8802617 	ldw	r2,152(sp)
8111fc80:	d9403317 	ldw	r5,204(sp)
8111fc84:	d8c02017 	ldw	r3,128(sp)
8111fc88:	da000404 	addi	r8,sp,16
8111fc8c:	2885c83a 	sub	r2,r5,r2
8111fc90:	003e1006 	br	8111f4d4 <__reset+0xfb0ff4d4>
8111fc94:	00800044 	movi	r2,1
8111fc98:	10803fcc 	andi	r2,r2,255
8111fc9c:	00c00044 	movi	r3,1
8111fca0:	10fa3526 	beq	r2,r3,8111e578 <__reset+0xfb0fe578>
8111fca4:	00c00084 	movi	r3,2
8111fca8:	10fb9e26 	beq	r2,r3,8111eb24 <__reset+0xfb0feb24>
8111fcac:	003a6406 	br	8111e640 <__reset+0xfb0fe640>
8111fcb0:	0021883a 	mov	r16,zero
8111fcb4:	003e0806 	br	8111f4d8 <__reset+0xfb0ff4d8>
8111fcb8:	07000b44 	movi	fp,45
8111fcbc:	df002785 	stb	fp,158(sp)
8111fcc0:	003a0b06 	br	8111e4f0 <__reset+0xfb0fe4f0>
8111fcc4:	d8c02d17 	ldw	r3,180(sp)
8111fcc8:	d9002f17 	ldw	r4,188(sp)
8111fccc:	18800017 	ldw	r2,0(r3)
8111fcd0:	18c00104 	addi	r3,r3,4
8111fcd4:	d8c02d15 	stw	r3,180(sp)
8111fcd8:	11000015 	stw	r4,0(r2)
8111fcdc:	0038f306 	br	8111e0ac <__reset+0xfb0fe0ac>
8111fce0:	00c00b44 	movi	r3,45
8111fce4:	d8c02785 	stb	r3,158(sp)
8111fce8:	d8802a15 	stw	r2,168(sp)
8111fcec:	dc802b17 	ldw	r18,172(sp)
8111fcf0:	d8002915 	stw	zero,164(sp)
8111fcf4:	07000b44 	movi	fp,45
8111fcf8:	003a7306 	br	8111e6c8 <__reset+0xfb0fe6c8>
8111fcfc:	9080004c 	andi	r2,r18,1
8111fd00:	1000941e 	bne	r2,zero,8111ff54 <___svfprintf_internal_r+0x1f5c>
8111fd04:	d8802117 	ldw	r2,132(sp)
8111fd08:	1405c83a 	sub	r2,r2,r16
8111fd0c:	d8803315 	stw	r2,204(sp)
8111fd10:	b441161e 	bne	r22,r17,8112016c <___svfprintf_internal_r+0x2174>
8111fd14:	dd802617 	ldw	r22,152(sp)
8111fd18:	00bfff44 	movi	r2,-3
8111fd1c:	b0801a16 	blt	r22,r2,8111fd88 <___svfprintf_internal_r+0x1d90>
8111fd20:	d9402917 	ldw	r5,164(sp)
8111fd24:	2d801816 	blt	r5,r22,8111fd88 <___svfprintf_internal_r+0x1d90>
8111fd28:	dd803215 	stw	r22,200(sp)
8111fd2c:	003f3a06 	br	8111fa18 <__reset+0xfb0ffa18>
8111fd30:	1025883a 	mov	r18,r2
8111fd34:	0039883a 	mov	fp,zero
8111fd38:	00800084 	movi	r2,2
8111fd3c:	003fd606 	br	8111fc98 <__reset+0xfb0ffc98>
8111fd40:	9080004c 	andi	r2,r18,1
8111fd44:	103f191e 	bne	r2,zero,8111f9ac <__reset+0xfb0ff9ac>
8111fd48:	d8802117 	ldw	r2,132(sp)
8111fd4c:	003f2806 	br	8111f9f0 <__reset+0xfb0ff9f0>
8111fd50:	01204574 	movhi	r4,33045
8111fd54:	212e0e84 	addi	r4,r4,-18374
8111fd58:	d9002b15 	stw	r4,172(sp)
8111fd5c:	003c7c06 	br	8111ef50 <__reset+0xfb0fef50>
8111fd60:	e005883a 	mov	r2,fp
8111fd64:	003f2206 	br	8111f9f0 <__reset+0xfb0ff9f0>
8111fd68:	d9402917 	ldw	r5,164(sp)
8111fd6c:	df002783 	ldbu	fp,158(sp)
8111fd70:	dd002d15 	stw	r20,180(sp)
8111fd74:	d9402a15 	stw	r5,168(sp)
8111fd78:	d9402e15 	stw	r5,184(sp)
8111fd7c:	d8002915 	stw	zero,164(sp)
8111fd80:	d8003215 	stw	zero,200(sp)
8111fd84:	003a4c06 	br	8111e6b8 <__reset+0xfb0fe6b8>
8111fd88:	8c7fff84 	addi	r17,r17,-2
8111fd8c:	b5bfffc4 	addi	r22,r22,-1
8111fd90:	dd802615 	stw	r22,152(sp)
8111fd94:	dc4022c5 	stb	r17,139(sp)
8111fd98:	b000c316 	blt	r22,zero,811200a8 <___svfprintf_internal_r+0x20b0>
8111fd9c:	00800ac4 	movi	r2,43
8111fda0:	d8802305 	stb	r2,140(sp)
8111fda4:	00800244 	movi	r2,9
8111fda8:	15806e16 	blt	r2,r22,8111ff64 <___svfprintf_internal_r+0x1f6c>
8111fdac:	00800c04 	movi	r2,48
8111fdb0:	b5800c04 	addi	r22,r22,48
8111fdb4:	d8802345 	stb	r2,141(sp)
8111fdb8:	dd802385 	stb	r22,142(sp)
8111fdbc:	d88023c4 	addi	r2,sp,143
8111fdc0:	df0022c4 	addi	fp,sp,139
8111fdc4:	d8c03317 	ldw	r3,204(sp)
8111fdc8:	1739c83a 	sub	fp,r2,fp
8111fdcc:	d9003317 	ldw	r4,204(sp)
8111fdd0:	e0c7883a 	add	r3,fp,r3
8111fdd4:	df003b15 	stw	fp,236(sp)
8111fdd8:	d8c02e15 	stw	r3,184(sp)
8111fddc:	00800044 	movi	r2,1
8111fde0:	1100b70e 	bge	r2,r4,811200c0 <___svfprintf_internal_r+0x20c8>
8111fde4:	d8c02e17 	ldw	r3,184(sp)
8111fde8:	18c00044 	addi	r3,r3,1
8111fdec:	d8c02e15 	stw	r3,184(sp)
8111fdf0:	1805883a 	mov	r2,r3
8111fdf4:	1800b016 	blt	r3,zero,811200b8 <___svfprintf_internal_r+0x20c0>
8111fdf8:	d8003215 	stw	zero,200(sp)
8111fdfc:	003f1006 	br	8111fa40 <__reset+0xfb0ffa40>
8111fe00:	d8802917 	ldw	r2,164(sp)
8111fe04:	103ec71e 	bne	r2,zero,8111f924 <__reset+0xfb0ff924>
8111fe08:	dc002915 	stw	r16,164(sp)
8111fe0c:	003ec506 	br	8111f924 <__reset+0xfb0ff924>
8111fe10:	d9402c17 	ldw	r5,176(sp)
8111fe14:	d9801e04 	addi	r6,sp,120
8111fe18:	9809883a 	mov	r4,r19
8111fe1c:	112ac180 	call	8112ac18 <__ssprint_r>
8111fe20:	10395c1e 	bne	r2,zero,8111e394 <__reset+0xfb0fe394>
8111fe24:	dc402617 	ldw	r17,152(sp)
8111fe28:	d8c02017 	ldw	r3,128(sp)
8111fe2c:	d8801f17 	ldw	r2,124(sp)
8111fe30:	da000404 	addi	r8,sp,16
8111fe34:	003e7706 	br	8111f814 <__reset+0xfb0ff814>
8111fe38:	582f883a 	mov	r23,r11
8111fe3c:	d8002915 	stw	zero,164(sp)
8111fe40:	0038c406 	br	8111e154 <__reset+0xfb0fe154>
8111fe44:	d8c02917 	ldw	r3,164(sp)
8111fe48:	d8802104 	addi	r2,sp,132
8111fe4c:	d8800315 	stw	r2,12(sp)
8111fe50:	d9403617 	ldw	r5,216(sp)
8111fe54:	d8802504 	addi	r2,sp,148
8111fe58:	d8800215 	stw	r2,8(sp)
8111fe5c:	d8802604 	addi	r2,sp,152
8111fe60:	d8c00015 	stw	r3,0(sp)
8111fe64:	9809883a 	mov	r4,r19
8111fe68:	d8800115 	stw	r2,4(sp)
8111fe6c:	01c000c4 	movi	r7,3
8111fe70:	a00d883a 	mov	r6,r20
8111fe74:	da003e15 	stw	r8,248(sp)
8111fe78:	11242e40 	call	811242e4 <_dtoa_r>
8111fe7c:	d9002917 	ldw	r4,164(sp)
8111fe80:	da003e17 	ldw	r8,248(sp)
8111fe84:	1021883a 	mov	r16,r2
8111fe88:	1139883a 	add	fp,r2,r4
8111fe8c:	2007883a 	mov	r3,r4
8111fe90:	81000007 	ldb	r4,0(r16)
8111fe94:	00800c04 	movi	r2,48
8111fe98:	20806f26 	beq	r4,r2,81120058 <___svfprintf_internal_r+0x2060>
8111fe9c:	d8c02617 	ldw	r3,152(sp)
8111fea0:	e0f9883a 	add	fp,fp,r3
8111fea4:	003ec206 	br	8111f9b0 <__reset+0xfb0ff9b0>
8111fea8:	00c00b44 	movi	r3,45
8111feac:	2520003c 	xorhi	r20,r4,32768
8111feb0:	d8c02a05 	stb	r3,168(sp)
8111feb4:	003ea106 	br	8111f93c <__reset+0xfb0ff93c>
8111feb8:	d8c03217 	ldw	r3,200(sp)
8111febc:	00c0890e 	bge	zero,r3,811200e4 <___svfprintf_internal_r+0x20ec>
8111fec0:	00800044 	movi	r2,1
8111fec4:	d9003317 	ldw	r4,204(sp)
8111fec8:	1105883a 	add	r2,r2,r4
8111fecc:	d8802e15 	stw	r2,184(sp)
8111fed0:	10005f16 	blt	r2,zero,81120050 <___svfprintf_internal_r+0x2058>
8111fed4:	044019c4 	movi	r17,103
8111fed8:	003ed906 	br	8111fa40 <__reset+0xfb0ffa40>
8111fedc:	d9002917 	ldw	r4,164(sp)
8111fee0:	20c00044 	addi	r3,r4,1
8111fee4:	003e9c06 	br	8111f958 <__reset+0xfb0ff958>
8111fee8:	d9002917 	ldw	r4,164(sp)
8111feec:	00c0680e 	bge	zero,r3,81120090 <___svfprintf_internal_r+0x2098>
8111fef0:	2000461e 	bne	r4,zero,8112000c <___svfprintf_internal_r+0x2014>
8111fef4:	9480004c 	andi	r18,r18,1
8111fef8:	9000441e 	bne	r18,zero,8112000c <___svfprintf_internal_r+0x2014>
8111fefc:	1805883a 	mov	r2,r3
8111ff00:	1800a016 	blt	r3,zero,81120184 <___svfprintf_internal_r+0x218c>
8111ff04:	d8c03217 	ldw	r3,200(sp)
8111ff08:	d8c02e15 	stw	r3,184(sp)
8111ff0c:	003ecc06 	br	8111fa40 <__reset+0xfb0ffa40>
8111ff10:	d9402917 	ldw	r5,164(sp)
8111ff14:	d8802104 	addi	r2,sp,132
8111ff18:	d8800315 	stw	r2,12(sp)
8111ff1c:	d9400015 	stw	r5,0(sp)
8111ff20:	d8802504 	addi	r2,sp,148
8111ff24:	d9403617 	ldw	r5,216(sp)
8111ff28:	d8800215 	stw	r2,8(sp)
8111ff2c:	d8802604 	addi	r2,sp,152
8111ff30:	d8800115 	stw	r2,4(sp)
8111ff34:	01c000c4 	movi	r7,3
8111ff38:	a00d883a 	mov	r6,r20
8111ff3c:	9809883a 	mov	r4,r19
8111ff40:	da003e15 	stw	r8,248(sp)
8111ff44:	11242e40 	call	811242e4 <_dtoa_r>
8111ff48:	d8c02917 	ldw	r3,164(sp)
8111ff4c:	da003e17 	ldw	r8,248(sp)
8111ff50:	1021883a 	mov	r16,r2
8111ff54:	00801184 	movi	r2,70
8111ff58:	80f9883a 	add	fp,r16,r3
8111ff5c:	88bfcc26 	beq	r17,r2,8111fe90 <__reset+0xfb0ffe90>
8111ff60:	003e9306 	br	8111f9b0 <__reset+0xfb0ff9b0>
8111ff64:	df0022c4 	addi	fp,sp,139
8111ff68:	dc002915 	stw	r16,164(sp)
8111ff6c:	9829883a 	mov	r20,r19
8111ff70:	e021883a 	mov	r16,fp
8111ff74:	4027883a 	mov	r19,r8
8111ff78:	b009883a 	mov	r4,r22
8111ff7c:	01400284 	movi	r5,10
8111ff80:	112f7400 	call	8112f740 <__modsi3>
8111ff84:	10800c04 	addi	r2,r2,48
8111ff88:	843fffc4 	addi	r16,r16,-1
8111ff8c:	b009883a 	mov	r4,r22
8111ff90:	01400284 	movi	r5,10
8111ff94:	80800005 	stb	r2,0(r16)
8111ff98:	112f6bc0 	call	8112f6bc <__divsi3>
8111ff9c:	102d883a 	mov	r22,r2
8111ffa0:	00800244 	movi	r2,9
8111ffa4:	15bff416 	blt	r2,r22,8111ff78 <__reset+0xfb0fff78>
8111ffa8:	9811883a 	mov	r8,r19
8111ffac:	b0800c04 	addi	r2,r22,48
8111ffb0:	a027883a 	mov	r19,r20
8111ffb4:	8029883a 	mov	r20,r16
8111ffb8:	a17fffc4 	addi	r5,r20,-1
8111ffbc:	a0bfffc5 	stb	r2,-1(r20)
8111ffc0:	dc002917 	ldw	r16,164(sp)
8111ffc4:	2f00752e 	bgeu	r5,fp,8112019c <___svfprintf_internal_r+0x21a4>
8111ffc8:	d9c02384 	addi	r7,sp,142
8111ffcc:	3d0fc83a 	sub	r7,r7,r20
8111ffd0:	d9002344 	addi	r4,sp,141
8111ffd4:	e1cf883a 	add	r7,fp,r7
8111ffd8:	00000106 	br	8111ffe0 <___svfprintf_internal_r+0x1fe8>
8111ffdc:	28800003 	ldbu	r2,0(r5)
8111ffe0:	20800005 	stb	r2,0(r4)
8111ffe4:	21000044 	addi	r4,r4,1
8111ffe8:	29400044 	addi	r5,r5,1
8111ffec:	21fffb1e 	bne	r4,r7,8111ffdc <__reset+0xfb0fffdc>
8111fff0:	d8802304 	addi	r2,sp,140
8111fff4:	1505c83a 	sub	r2,r2,r20
8111fff8:	d8c02344 	addi	r3,sp,141
8111fffc:	1885883a 	add	r2,r3,r2
81120000:	003f7006 	br	8111fdc4 <__reset+0xfb0ffdc4>
81120004:	0005883a 	mov	r2,zero
81120008:	003f0b06 	br	8111fc38 <__reset+0xfb0ffc38>
8112000c:	d9002917 	ldw	r4,164(sp)
81120010:	d8c03217 	ldw	r3,200(sp)
81120014:	20800044 	addi	r2,r4,1
81120018:	1885883a 	add	r2,r3,r2
8112001c:	d8802e15 	stw	r2,184(sp)
81120020:	103e870e 	bge	r2,zero,8111fa40 <__reset+0xfb0ffa40>
81120024:	0005883a 	mov	r2,zero
81120028:	003e8506 	br	8111fa40 <__reset+0xfb0ffa40>
8112002c:	01204574 	movhi	r4,33045
81120030:	212e0e84 	addi	r4,r4,-18374
81120034:	d9002b15 	stw	r4,172(sp)
81120038:	003cc506 	br	8111f350 <__reset+0xfb0ff350>
8112003c:	d8c03217 	ldw	r3,200(sp)
81120040:	18c00044 	addi	r3,r3,1
81120044:	d8c02e15 	stw	r3,184(sp)
81120048:	1805883a 	mov	r2,r3
8112004c:	183fa10e 	bge	r3,zero,8111fed4 <__reset+0xfb0ffed4>
81120050:	0005883a 	mov	r2,zero
81120054:	003f9f06 	br	8111fed4 <__reset+0xfb0ffed4>
81120058:	d9003617 	ldw	r4,216(sp)
8112005c:	000d883a 	mov	r6,zero
81120060:	000f883a 	mov	r7,zero
81120064:	a00b883a 	mov	r5,r20
81120068:	d8c03d15 	stw	r3,244(sp)
8112006c:	da003e15 	stw	r8,248(sp)
81120070:	1130c100 	call	81130c10 <__eqdf2>
81120074:	d8c03d17 	ldw	r3,244(sp)
81120078:	da003e17 	ldw	r8,248(sp)
8112007c:	103f8726 	beq	r2,zero,8111fe9c <__reset+0xfb0ffe9c>
81120080:	00800044 	movi	r2,1
81120084:	10c7c83a 	sub	r3,r2,r3
81120088:	d8c02615 	stw	r3,152(sp)
8112008c:	003f8406 	br	8111fea0 <__reset+0xfb0ffea0>
81120090:	20000e1e 	bne	r4,zero,811200cc <___svfprintf_internal_r+0x20d4>
81120094:	9480004c 	andi	r18,r18,1
81120098:	90000c1e 	bne	r18,zero,811200cc <___svfprintf_internal_r+0x20d4>
8112009c:	00800044 	movi	r2,1
811200a0:	d8802e15 	stw	r2,184(sp)
811200a4:	003e6606 	br	8111fa40 <__reset+0xfb0ffa40>
811200a8:	00800b44 	movi	r2,45
811200ac:	05adc83a 	sub	r22,zero,r22
811200b0:	d8802305 	stb	r2,140(sp)
811200b4:	003f3b06 	br	8111fda4 <__reset+0xfb0ffda4>
811200b8:	0005883a 	mov	r2,zero
811200bc:	003f4e06 	br	8111fdf8 <__reset+0xfb0ffdf8>
811200c0:	90a4703a 	and	r18,r18,r2
811200c4:	903f4a26 	beq	r18,zero,8111fdf0 <__reset+0xfb0ffdf0>
811200c8:	003f4606 	br	8111fde4 <__reset+0xfb0ffde4>
811200cc:	d8c02917 	ldw	r3,164(sp)
811200d0:	18c00084 	addi	r3,r3,2
811200d4:	d8c02e15 	stw	r3,184(sp)
811200d8:	1805883a 	mov	r2,r3
811200dc:	183e580e 	bge	r3,zero,8111fa40 <__reset+0xfb0ffa40>
811200e0:	003fd006 	br	81120024 <__reset+0xfb100024>
811200e4:	00800084 	movi	r2,2
811200e8:	10c5c83a 	sub	r2,r2,r3
811200ec:	003f7506 	br	8111fec4 <__reset+0xfb0ffec4>
811200f0:	d8802d17 	ldw	r2,180(sp)
811200f4:	d9002d17 	ldw	r4,180(sp)
811200f8:	bc400043 	ldbu	r17,1(r23)
811200fc:	10800017 	ldw	r2,0(r2)
81120100:	582f883a 	mov	r23,r11
81120104:	d8802915 	stw	r2,164(sp)
81120108:	20800104 	addi	r2,r4,4
8112010c:	d9002917 	ldw	r4,164(sp)
81120110:	d8802d15 	stw	r2,180(sp)
81120114:	203df00e 	bge	r4,zero,8111f8d8 <__reset+0xfb0ff8d8>
81120118:	8c403fcc 	andi	r17,r17,255
8112011c:	00bfffc4 	movi	r2,-1
81120120:	8c40201c 	xori	r17,r17,128
81120124:	d8802915 	stw	r2,164(sp)
81120128:	8c7fe004 	addi	r17,r17,-128
8112012c:	00380806 	br	8111e150 <__reset+0xfb0fe150>
81120130:	9080004c 	andi	r2,r18,1
81120134:	0039883a 	mov	fp,zero
81120138:	10000726 	beq	r2,zero,81120158 <___svfprintf_internal_r+0x2160>
8112013c:	d8c02817 	ldw	r3,160(sp)
81120140:	dc001dc4 	addi	r16,sp,119
81120144:	00800c04 	movi	r2,48
81120148:	1c07c83a 	sub	r3,r3,r16
8112014c:	d8801dc5 	stb	r2,119(sp)
81120150:	d8c02e15 	stw	r3,184(sp)
81120154:	00395206 	br	8111e6a0 <__reset+0xfb0fe6a0>
81120158:	d8002e15 	stw	zero,184(sp)
8112015c:	dc001e04 	addi	r16,sp,120
81120160:	00394f06 	br	8111e6a0 <__reset+0xfb0fe6a0>
81120164:	0005883a 	mov	r2,zero
81120168:	003e3206 	br	8111fa34 <__reset+0xfb0ffa34>
8112016c:	dd802617 	ldw	r22,152(sp)
81120170:	003f0606 	br	8111fd8c <__reset+0xfb0ffd8c>
81120174:	d9c02785 	stb	r7,158(sp)
81120178:	003a5106 	br	8111eac0 <__reset+0xfb0feac0>
8112017c:	d9c02785 	stb	r7,158(sp)
81120180:	003a3706 	br	8111ea60 <__reset+0xfb0fea60>
81120184:	0005883a 	mov	r2,zero
81120188:	003f5e06 	br	8111ff04 <__reset+0xfb0fff04>
8112018c:	d9c02785 	stb	r7,158(sp)
81120190:	00391706 	br	8111e5f0 <__reset+0xfb0fe5f0>
81120194:	d9c02785 	stb	r7,158(sp)
81120198:	0038e606 	br	8111e534 <__reset+0xfb0fe534>
8112019c:	d8802344 	addi	r2,sp,141
811201a0:	003f0806 	br	8111fdc4 <__reset+0xfb0ffdc4>
811201a4:	d9c02785 	stb	r7,158(sp)
811201a8:	0038b706 	br	8111e488 <__reset+0xfb0fe488>
811201ac:	d9c02785 	stb	r7,158(sp)
811201b0:	003adc06 	br	8111ed24 <__reset+0xfb0fed24>
811201b4:	d9403917 	ldw	r5,228(sp)
811201b8:	00800304 	movi	r2,12
811201bc:	28800015 	stw	r2,0(r5)
811201c0:	00bfffc4 	movi	r2,-1
811201c4:	00387806 	br	8111e3a8 <__reset+0xfb0fe3a8>
811201c8:	d9c02785 	stb	r7,158(sp)
811201cc:	003abf06 	br	8111eccc <__reset+0xfb0feccc>
811201d0:	d9c02785 	stb	r7,158(sp)
811201d4:	003a9b06 	br	8111ec44 <__reset+0xfb0fec44>

811201d8 <___vfprintf_internal_r>:
811201d8:	deffb804 	addi	sp,sp,-288
811201dc:	de00012e 	bgeu	sp,et,811201e4 <___vfprintf_internal_r+0xc>
811201e0:	003b68fa 	trap	3
811201e4:	dfc04715 	stw	ra,284(sp)
811201e8:	ddc04515 	stw	r23,276(sp)
811201ec:	dd404315 	stw	r21,268(sp)
811201f0:	d9002c15 	stw	r4,176(sp)
811201f4:	282f883a 	mov	r23,r5
811201f8:	302b883a 	mov	r21,r6
811201fc:	d9c02d15 	stw	r7,180(sp)
81120200:	df004615 	stw	fp,280(sp)
81120204:	dd804415 	stw	r22,272(sp)
81120208:	dd004215 	stw	r20,264(sp)
8112020c:	dcc04115 	stw	r19,260(sp)
81120210:	dc804015 	stw	r18,256(sp)
81120214:	dc403f15 	stw	r17,252(sp)
81120218:	dc003e15 	stw	r16,248(sp)
8112021c:	1126ee00 	call	81126ee0 <_localeconv_r>
81120220:	10800017 	ldw	r2,0(r2)
81120224:	1009883a 	mov	r4,r2
81120228:	d8803415 	stw	r2,208(sp)
8112022c:	111dcc00 	call	8111dcc0 <strlen>
81120230:	d8803715 	stw	r2,220(sp)
81120234:	d8802c17 	ldw	r2,176(sp)
81120238:	10000226 	beq	r2,zero,81120244 <___vfprintf_internal_r+0x6c>
8112023c:	10800e17 	ldw	r2,56(r2)
81120240:	1000f926 	beq	r2,zero,81120628 <___vfprintf_internal_r+0x450>
81120244:	b880030b 	ldhu	r2,12(r23)
81120248:	10c8000c 	andi	r3,r2,8192
8112024c:	1800061e 	bne	r3,zero,81120268 <___vfprintf_internal_r+0x90>
81120250:	b9001917 	ldw	r4,100(r23)
81120254:	00f7ffc4 	movi	r3,-8193
81120258:	10880014 	ori	r2,r2,8192
8112025c:	20c6703a 	and	r3,r4,r3
81120260:	b880030d 	sth	r2,12(r23)
81120264:	b8c01915 	stw	r3,100(r23)
81120268:	10c0020c 	andi	r3,r2,8
8112026c:	1800c126 	beq	r3,zero,81120574 <___vfprintf_internal_r+0x39c>
81120270:	b8c00417 	ldw	r3,16(r23)
81120274:	1800bf26 	beq	r3,zero,81120574 <___vfprintf_internal_r+0x39c>
81120278:	1080068c 	andi	r2,r2,26
8112027c:	00c00284 	movi	r3,10
81120280:	10c0c426 	beq	r2,r3,81120594 <___vfprintf_internal_r+0x3bc>
81120284:	d8c00404 	addi	r3,sp,16
81120288:	05204574 	movhi	r20,33045
8112028c:	d9001e04 	addi	r4,sp,120
81120290:	a52e1684 	addi	r20,r20,-18342
81120294:	d8c01e15 	stw	r3,120(sp)
81120298:	d8002015 	stw	zero,128(sp)
8112029c:	d8001f15 	stw	zero,124(sp)
811202a0:	d8003315 	stw	zero,204(sp)
811202a4:	d8003615 	stw	zero,216(sp)
811202a8:	d8003815 	stw	zero,224(sp)
811202ac:	1811883a 	mov	r8,r3
811202b0:	d8003915 	stw	zero,228(sp)
811202b4:	d8003a15 	stw	zero,232(sp)
811202b8:	d8002f15 	stw	zero,188(sp)
811202bc:	d9002815 	stw	r4,160(sp)
811202c0:	a8800007 	ldb	r2,0(r21)
811202c4:	10027b26 	beq	r2,zero,81120cb4 <___vfprintf_internal_r+0xadc>
811202c8:	00c00944 	movi	r3,37
811202cc:	a821883a 	mov	r16,r21
811202d0:	10c0021e 	bne	r2,r3,811202dc <___vfprintf_internal_r+0x104>
811202d4:	00001406 	br	81120328 <___vfprintf_internal_r+0x150>
811202d8:	10c00326 	beq	r2,r3,811202e8 <___vfprintf_internal_r+0x110>
811202dc:	84000044 	addi	r16,r16,1
811202e0:	80800007 	ldb	r2,0(r16)
811202e4:	103ffc1e 	bne	r2,zero,811202d8 <__reset+0xfb1002d8>
811202e8:	8563c83a 	sub	r17,r16,r21
811202ec:	88000e26 	beq	r17,zero,81120328 <___vfprintf_internal_r+0x150>
811202f0:	d8c02017 	ldw	r3,128(sp)
811202f4:	d8801f17 	ldw	r2,124(sp)
811202f8:	45400015 	stw	r21,0(r8)
811202fc:	1c47883a 	add	r3,r3,r17
81120300:	10800044 	addi	r2,r2,1
81120304:	d8c02015 	stw	r3,128(sp)
81120308:	44400115 	stw	r17,4(r8)
8112030c:	d8801f15 	stw	r2,124(sp)
81120310:	00c001c4 	movi	r3,7
81120314:	1880a716 	blt	r3,r2,811205b4 <___vfprintf_internal_r+0x3dc>
81120318:	42000204 	addi	r8,r8,8
8112031c:	d9402f17 	ldw	r5,188(sp)
81120320:	2c4b883a 	add	r5,r5,r17
81120324:	d9402f15 	stw	r5,188(sp)
81120328:	80800007 	ldb	r2,0(r16)
8112032c:	1000a826 	beq	r2,zero,811205d0 <___vfprintf_internal_r+0x3f8>
81120330:	84400047 	ldb	r17,1(r16)
81120334:	00bfffc4 	movi	r2,-1
81120338:	85400044 	addi	r21,r16,1
8112033c:	d8002785 	stb	zero,158(sp)
81120340:	0007883a 	mov	r3,zero
81120344:	000f883a 	mov	r7,zero
81120348:	d8802915 	stw	r2,164(sp)
8112034c:	d8003115 	stw	zero,196(sp)
81120350:	0025883a 	mov	r18,zero
81120354:	01401604 	movi	r5,88
81120358:	01800244 	movi	r6,9
8112035c:	02800a84 	movi	r10,42
81120360:	02401b04 	movi	r9,108
81120364:	ad400044 	addi	r21,r21,1
81120368:	88bff804 	addi	r2,r17,-32
8112036c:	28830436 	bltu	r5,r2,81120f80 <___vfprintf_internal_r+0xda8>
81120370:	100490ba 	slli	r2,r2,2
81120374:	012044b4 	movhi	r4,33042
81120378:	2100e204 	addi	r4,r4,904
8112037c:	1105883a 	add	r2,r2,r4
81120380:	10800017 	ldw	r2,0(r2)
81120384:	1000683a 	jmp	r2
81120388:	81120ea0 	cmpeqi	r4,r16,18490
8112038c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120390:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120394:	81120ec0 	call	881120ec <__reset+0x20f20ec>
81120398:	81120f80 	call	881120f8 <__reset+0x20f20f8>
8112039c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203a0:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203a4:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203a8:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203ac:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203b0:	81120634 	orhi	r4,r16,18456
811203b4:	81120ddc 	xori	r4,r16,18487
811203b8:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203bc:	811204fc 	xorhi	r4,r16,18451
811203c0:	8112065c 	xori	r4,r16,18457
811203c4:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203c8:	8112069c 	xori	r4,r16,18458
811203cc:	811206a8 	cmpgeui	r4,r16,18458
811203d0:	811206a8 	cmpgeui	r4,r16,18458
811203d4:	811206a8 	cmpgeui	r4,r16,18458
811203d8:	811206a8 	cmpgeui	r4,r16,18458
811203dc:	811206a8 	cmpgeui	r4,r16,18458
811203e0:	811206a8 	cmpgeui	r4,r16,18458
811203e4:	811206a8 	cmpgeui	r4,r16,18458
811203e8:	811206a8 	cmpgeui	r4,r16,18458
811203ec:	811206a8 	cmpgeui	r4,r16,18458
811203f0:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203f4:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203f8:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811203fc:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120400:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120404:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120408:	81120f80 	call	881120f8 <__reset+0x20f20f8>
8112040c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120410:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120414:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120418:	811206dc 	xori	r4,r16,18459
8112041c:	81120798 	cmpnei	r4,r16,18462
81120420:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120424:	81120798 	cmpnei	r4,r16,18462
81120428:	81120f80 	call	881120f8 <__reset+0x20f20f8>
8112042c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120430:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120434:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120438:	81120838 	rdprs	r4,r16,18464
8112043c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120440:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120444:	81120844 	addi	r4,r16,18465
81120448:	81120f80 	call	881120f8 <__reset+0x20f20f8>
8112044c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120450:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120454:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120458:	81120f80 	call	881120f8 <__reset+0x20f20f8>
8112045c:	81120cbc 	xorhi	r4,r16,18482
81120460:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120464:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120468:	81120d1c 	xori	r4,r16,18484
8112046c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120470:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120474:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120478:	81120f80 	call	881120f8 <__reset+0x20f20f8>
8112047c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120480:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120484:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120488:	81120f80 	call	881120f8 <__reset+0x20f20f8>
8112048c:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120490:	81120f80 	call	881120f8 <__reset+0x20f20f8>
81120494:	81120f2c 	andhi	r4,r16,18492
81120498:	81120ecc 	andi	r4,r16,18491
8112049c:	81120798 	cmpnei	r4,r16,18462
811204a0:	81120798 	cmpnei	r4,r16,18462
811204a4:	81120798 	cmpnei	r4,r16,18462
811204a8:	81120edc 	xori	r4,r16,18491
811204ac:	81120ecc 	andi	r4,r16,18491
811204b0:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811204b4:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811204b8:	81120ee8 	cmpgeui	r4,r16,18491
811204bc:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811204c0:	81120ef8 	rdprs	r4,r16,18491
811204c4:	81120dcc 	andi	r4,r16,18487
811204c8:	81120508 	cmpgei	r4,r16,18452
811204cc:	81120dec 	andhi	r4,r16,18487
811204d0:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811204d4:	81120df8 	rdprs	r4,r16,18487
811204d8:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811204dc:	81120e54 	ori	r4,r16,18489
811204e0:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811204e4:	81120f80 	call	881120f8 <__reset+0x20f20f8>
811204e8:	81120e64 	muli	r4,r16,18489
811204ec:	d9003117 	ldw	r4,196(sp)
811204f0:	d8802d15 	stw	r2,180(sp)
811204f4:	0109c83a 	sub	r4,zero,r4
811204f8:	d9003115 	stw	r4,196(sp)
811204fc:	94800114 	ori	r18,r18,4
81120500:	ac400007 	ldb	r17,0(r21)
81120504:	003f9706 	br	81120364 <__reset+0xfb100364>
81120508:	00800c04 	movi	r2,48
8112050c:	d9002d17 	ldw	r4,180(sp)
81120510:	d9402917 	ldw	r5,164(sp)
81120514:	d8802705 	stb	r2,156(sp)
81120518:	00801e04 	movi	r2,120
8112051c:	d8802745 	stb	r2,157(sp)
81120520:	d8002785 	stb	zero,158(sp)
81120524:	20c00104 	addi	r3,r4,4
81120528:	24c00017 	ldw	r19,0(r4)
8112052c:	002d883a 	mov	r22,zero
81120530:	90800094 	ori	r2,r18,2
81120534:	28029a16 	blt	r5,zero,81120fa0 <___vfprintf_internal_r+0xdc8>
81120538:	00bfdfc4 	movi	r2,-129
8112053c:	90a4703a 	and	r18,r18,r2
81120540:	d8c02d15 	stw	r3,180(sp)
81120544:	94800094 	ori	r18,r18,2
81120548:	9802871e 	bne	r19,zero,81120f68 <___vfprintf_internal_r+0xd90>
8112054c:	00a04574 	movhi	r2,33045
81120550:	10ae0704 	addi	r2,r2,-18404
81120554:	d8803915 	stw	r2,228(sp)
81120558:	04401e04 	movi	r17,120
8112055c:	d8802917 	ldw	r2,164(sp)
81120560:	0039883a 	mov	fp,zero
81120564:	1001e926 	beq	r2,zero,81120d0c <___vfprintf_internal_r+0xb34>
81120568:	0027883a 	mov	r19,zero
8112056c:	002d883a 	mov	r22,zero
81120570:	00020506 	br	81120d88 <___vfprintf_internal_r+0xbb0>
81120574:	d9002c17 	ldw	r4,176(sp)
81120578:	b80b883a 	mov	r5,r23
8112057c:	1123f240 	call	81123f24 <__swsetup_r>
81120580:	1005ac1e 	bne	r2,zero,81121c34 <___vfprintf_internal_r+0x1a5c>
81120584:	b880030b 	ldhu	r2,12(r23)
81120588:	00c00284 	movi	r3,10
8112058c:	1080068c 	andi	r2,r2,26
81120590:	10ff3c1e 	bne	r2,r3,81120284 <__reset+0xfb100284>
81120594:	b880038f 	ldh	r2,14(r23)
81120598:	103f3a16 	blt	r2,zero,81120284 <__reset+0xfb100284>
8112059c:	d9c02d17 	ldw	r7,180(sp)
811205a0:	d9002c17 	ldw	r4,176(sp)
811205a4:	a80d883a 	mov	r6,r21
811205a8:	b80b883a 	mov	r5,r23
811205ac:	11223f40 	call	811223f4 <__sbprintf>
811205b0:	00001106 	br	811205f8 <___vfprintf_internal_r+0x420>
811205b4:	d9002c17 	ldw	r4,176(sp)
811205b8:	d9801e04 	addi	r6,sp,120
811205bc:	b80b883a 	mov	r5,r23
811205c0:	112c3c80 	call	8112c3c8 <__sprint_r>
811205c4:	1000081e 	bne	r2,zero,811205e8 <___vfprintf_internal_r+0x410>
811205c8:	da000404 	addi	r8,sp,16
811205cc:	003f5306 	br	8112031c <__reset+0xfb10031c>
811205d0:	d8802017 	ldw	r2,128(sp)
811205d4:	10000426 	beq	r2,zero,811205e8 <___vfprintf_internal_r+0x410>
811205d8:	d9002c17 	ldw	r4,176(sp)
811205dc:	d9801e04 	addi	r6,sp,120
811205e0:	b80b883a 	mov	r5,r23
811205e4:	112c3c80 	call	8112c3c8 <__sprint_r>
811205e8:	b880030b 	ldhu	r2,12(r23)
811205ec:	1080100c 	andi	r2,r2,64
811205f0:	1005901e 	bne	r2,zero,81121c34 <___vfprintf_internal_r+0x1a5c>
811205f4:	d8802f17 	ldw	r2,188(sp)
811205f8:	dfc04717 	ldw	ra,284(sp)
811205fc:	df004617 	ldw	fp,280(sp)
81120600:	ddc04517 	ldw	r23,276(sp)
81120604:	dd804417 	ldw	r22,272(sp)
81120608:	dd404317 	ldw	r21,268(sp)
8112060c:	dd004217 	ldw	r20,264(sp)
81120610:	dcc04117 	ldw	r19,260(sp)
81120614:	dc804017 	ldw	r18,256(sp)
81120618:	dc403f17 	ldw	r17,252(sp)
8112061c:	dc003e17 	ldw	r16,248(sp)
81120620:	dec04804 	addi	sp,sp,288
81120624:	f800283a 	ret
81120628:	d9002c17 	ldw	r4,176(sp)
8112062c:	1125f940 	call	81125f94 <__sinit>
81120630:	003f0406 	br	81120244 <__reset+0xfb100244>
81120634:	d8802d17 	ldw	r2,180(sp)
81120638:	d9002d17 	ldw	r4,180(sp)
8112063c:	10800017 	ldw	r2,0(r2)
81120640:	d8803115 	stw	r2,196(sp)
81120644:	20800104 	addi	r2,r4,4
81120648:	d9003117 	ldw	r4,196(sp)
8112064c:	203fa716 	blt	r4,zero,811204ec <__reset+0xfb1004ec>
81120650:	d8802d15 	stw	r2,180(sp)
81120654:	ac400007 	ldb	r17,0(r21)
81120658:	003f4206 	br	81120364 <__reset+0xfb100364>
8112065c:	ac400007 	ldb	r17,0(r21)
81120660:	aac00044 	addi	r11,r21,1
81120664:	8a872826 	beq	r17,r10,81122308 <___vfprintf_internal_r+0x2130>
81120668:	88bff404 	addi	r2,r17,-48
8112066c:	0009883a 	mov	r4,zero
81120670:	30867d36 	bltu	r6,r2,81122068 <___vfprintf_internal_r+0x1e90>
81120674:	5c400007 	ldb	r17,0(r11)
81120678:	210002a4 	muli	r4,r4,10
8112067c:	5d400044 	addi	r21,r11,1
81120680:	a817883a 	mov	r11,r21
81120684:	2089883a 	add	r4,r4,r2
81120688:	88bff404 	addi	r2,r17,-48
8112068c:	30bff92e 	bgeu	r6,r2,81120674 <__reset+0xfb100674>
81120690:	2005c916 	blt	r4,zero,81121db8 <___vfprintf_internal_r+0x1be0>
81120694:	d9002915 	stw	r4,164(sp)
81120698:	003f3306 	br	81120368 <__reset+0xfb100368>
8112069c:	94802014 	ori	r18,r18,128
811206a0:	ac400007 	ldb	r17,0(r21)
811206a4:	003f2f06 	br	81120364 <__reset+0xfb100364>
811206a8:	a809883a 	mov	r4,r21
811206ac:	d8003115 	stw	zero,196(sp)
811206b0:	88bff404 	addi	r2,r17,-48
811206b4:	0017883a 	mov	r11,zero
811206b8:	24400007 	ldb	r17,0(r4)
811206bc:	5ac002a4 	muli	r11,r11,10
811206c0:	ad400044 	addi	r21,r21,1
811206c4:	a809883a 	mov	r4,r21
811206c8:	12d7883a 	add	r11,r2,r11
811206cc:	88bff404 	addi	r2,r17,-48
811206d0:	30bff92e 	bgeu	r6,r2,811206b8 <__reset+0xfb1006b8>
811206d4:	dac03115 	stw	r11,196(sp)
811206d8:	003f2306 	br	81120368 <__reset+0xfb100368>
811206dc:	18c03fcc 	andi	r3,r3,255
811206e0:	18072b1e 	bne	r3,zero,81122390 <___vfprintf_internal_r+0x21b8>
811206e4:	94800414 	ori	r18,r18,16
811206e8:	9080080c 	andi	r2,r18,32
811206ec:	10037b26 	beq	r2,zero,811214dc <___vfprintf_internal_r+0x1304>
811206f0:	d9402d17 	ldw	r5,180(sp)
811206f4:	28800117 	ldw	r2,4(r5)
811206f8:	2cc00017 	ldw	r19,0(r5)
811206fc:	29400204 	addi	r5,r5,8
81120700:	d9402d15 	stw	r5,180(sp)
81120704:	102d883a 	mov	r22,r2
81120708:	10044b16 	blt	r2,zero,81121838 <___vfprintf_internal_r+0x1660>
8112070c:	d9402917 	ldw	r5,164(sp)
81120710:	df002783 	ldbu	fp,158(sp)
81120714:	2803bc16 	blt	r5,zero,81121608 <___vfprintf_internal_r+0x1430>
81120718:	00ffdfc4 	movi	r3,-129
8112071c:	9d84b03a 	or	r2,r19,r22
81120720:	90e4703a 	and	r18,r18,r3
81120724:	10017726 	beq	r2,zero,81120d04 <___vfprintf_internal_r+0xb2c>
81120728:	b0038326 	beq	r22,zero,81121538 <___vfprintf_internal_r+0x1360>
8112072c:	dc402a15 	stw	r17,168(sp)
81120730:	dc001e04 	addi	r16,sp,120
81120734:	b023883a 	mov	r17,r22
81120738:	402d883a 	mov	r22,r8
8112073c:	9809883a 	mov	r4,r19
81120740:	880b883a 	mov	r5,r17
81120744:	01800284 	movi	r6,10
81120748:	000f883a 	mov	r7,zero
8112074c:	112f17c0 	call	8112f17c <__umoddi3>
81120750:	10800c04 	addi	r2,r2,48
81120754:	843fffc4 	addi	r16,r16,-1
81120758:	9809883a 	mov	r4,r19
8112075c:	880b883a 	mov	r5,r17
81120760:	80800005 	stb	r2,0(r16)
81120764:	01800284 	movi	r6,10
81120768:	000f883a 	mov	r7,zero
8112076c:	112ebfc0 	call	8112ebfc <__udivdi3>
81120770:	1027883a 	mov	r19,r2
81120774:	10c4b03a 	or	r2,r2,r3
81120778:	1823883a 	mov	r17,r3
8112077c:	103fef1e 	bne	r2,zero,8112073c <__reset+0xfb10073c>
81120780:	d8c02817 	ldw	r3,160(sp)
81120784:	dc402a17 	ldw	r17,168(sp)
81120788:	b011883a 	mov	r8,r22
8112078c:	1c07c83a 	sub	r3,r3,r16
81120790:	d8c02e15 	stw	r3,184(sp)
81120794:	00005906 	br	811208fc <___vfprintf_internal_r+0x724>
81120798:	18c03fcc 	andi	r3,r3,255
8112079c:	1806fa1e 	bne	r3,zero,81122388 <___vfprintf_internal_r+0x21b0>
811207a0:	9080020c 	andi	r2,r18,8
811207a4:	10048a26 	beq	r2,zero,811219d0 <___vfprintf_internal_r+0x17f8>
811207a8:	d8c02d17 	ldw	r3,180(sp)
811207ac:	d9002d17 	ldw	r4,180(sp)
811207b0:	d9402d17 	ldw	r5,180(sp)
811207b4:	18c00017 	ldw	r3,0(r3)
811207b8:	21000117 	ldw	r4,4(r4)
811207bc:	29400204 	addi	r5,r5,8
811207c0:	d8c03615 	stw	r3,216(sp)
811207c4:	d9003815 	stw	r4,224(sp)
811207c8:	d9402d15 	stw	r5,180(sp)
811207cc:	d9003617 	ldw	r4,216(sp)
811207d0:	d9403817 	ldw	r5,224(sp)
811207d4:	da003d15 	stw	r8,244(sp)
811207d8:	04000044 	movi	r16,1
811207dc:	1128a2c0 	call	81128a2c <__fpclassifyd>
811207e0:	da003d17 	ldw	r8,244(sp)
811207e4:	14041f1e 	bne	r2,r16,81121864 <___vfprintf_internal_r+0x168c>
811207e8:	d9003617 	ldw	r4,216(sp)
811207ec:	d9403817 	ldw	r5,224(sp)
811207f0:	000d883a 	mov	r6,zero
811207f4:	000f883a 	mov	r7,zero
811207f8:	1130d740 	call	81130d74 <__ledf2>
811207fc:	da003d17 	ldw	r8,244(sp)
81120800:	1005be16 	blt	r2,zero,81121efc <___vfprintf_internal_r+0x1d24>
81120804:	df002783 	ldbu	fp,158(sp)
81120808:	008011c4 	movi	r2,71
8112080c:	1445330e 	bge	r2,r17,81121cdc <___vfprintf_internal_r+0x1b04>
81120810:	04204574 	movhi	r16,33045
81120814:	842dff04 	addi	r16,r16,-18436
81120818:	00c000c4 	movi	r3,3
8112081c:	00bfdfc4 	movi	r2,-129
81120820:	d8c02a15 	stw	r3,168(sp)
81120824:	90a4703a 	and	r18,r18,r2
81120828:	d8c02e15 	stw	r3,184(sp)
8112082c:	d8002915 	stw	zero,164(sp)
81120830:	d8003215 	stw	zero,200(sp)
81120834:	00003706 	br	81120914 <___vfprintf_internal_r+0x73c>
81120838:	94800214 	ori	r18,r18,8
8112083c:	ac400007 	ldb	r17,0(r21)
81120840:	003ec806 	br	81120364 <__reset+0xfb100364>
81120844:	18c03fcc 	andi	r3,r3,255
81120848:	1806db1e 	bne	r3,zero,811223b8 <___vfprintf_internal_r+0x21e0>
8112084c:	94800414 	ori	r18,r18,16
81120850:	9080080c 	andi	r2,r18,32
81120854:	1002d826 	beq	r2,zero,811213b8 <___vfprintf_internal_r+0x11e0>
81120858:	d9402d17 	ldw	r5,180(sp)
8112085c:	d8c02917 	ldw	r3,164(sp)
81120860:	d8002785 	stb	zero,158(sp)
81120864:	28800204 	addi	r2,r5,8
81120868:	2cc00017 	ldw	r19,0(r5)
8112086c:	2d800117 	ldw	r22,4(r5)
81120870:	18048f16 	blt	r3,zero,81121ab0 <___vfprintf_internal_r+0x18d8>
81120874:	013fdfc4 	movi	r4,-129
81120878:	9d86b03a 	or	r3,r19,r22
8112087c:	d8802d15 	stw	r2,180(sp)
81120880:	9124703a 	and	r18,r18,r4
81120884:	1802d91e 	bne	r3,zero,811213ec <___vfprintf_internal_r+0x1214>
81120888:	d8c02917 	ldw	r3,164(sp)
8112088c:	0039883a 	mov	fp,zero
81120890:	1805c326 	beq	r3,zero,81121fa0 <___vfprintf_internal_r+0x1dc8>
81120894:	0027883a 	mov	r19,zero
81120898:	002d883a 	mov	r22,zero
8112089c:	dc001e04 	addi	r16,sp,120
811208a0:	9806d0fa 	srli	r3,r19,3
811208a4:	b008977a 	slli	r4,r22,29
811208a8:	b02cd0fa 	srli	r22,r22,3
811208ac:	9cc001cc 	andi	r19,r19,7
811208b0:	98800c04 	addi	r2,r19,48
811208b4:	843fffc4 	addi	r16,r16,-1
811208b8:	20e6b03a 	or	r19,r4,r3
811208bc:	80800005 	stb	r2,0(r16)
811208c0:	9d86b03a 	or	r3,r19,r22
811208c4:	183ff61e 	bne	r3,zero,811208a0 <__reset+0xfb1008a0>
811208c8:	90c0004c 	andi	r3,r18,1
811208cc:	18013b26 	beq	r3,zero,81120dbc <___vfprintf_internal_r+0xbe4>
811208d0:	10803fcc 	andi	r2,r2,255
811208d4:	1080201c 	xori	r2,r2,128
811208d8:	10bfe004 	addi	r2,r2,-128
811208dc:	00c00c04 	movi	r3,48
811208e0:	10c13626 	beq	r2,r3,81120dbc <___vfprintf_internal_r+0xbe4>
811208e4:	80ffffc5 	stb	r3,-1(r16)
811208e8:	d8c02817 	ldw	r3,160(sp)
811208ec:	80bfffc4 	addi	r2,r16,-1
811208f0:	1021883a 	mov	r16,r2
811208f4:	1887c83a 	sub	r3,r3,r2
811208f8:	d8c02e15 	stw	r3,184(sp)
811208fc:	d8802e17 	ldw	r2,184(sp)
81120900:	d9002917 	ldw	r4,164(sp)
81120904:	1100010e 	bge	r2,r4,8112090c <___vfprintf_internal_r+0x734>
81120908:	2005883a 	mov	r2,r4
8112090c:	d8802a15 	stw	r2,168(sp)
81120910:	d8003215 	stw	zero,200(sp)
81120914:	e7003fcc 	andi	fp,fp,255
81120918:	e700201c 	xori	fp,fp,128
8112091c:	e73fe004 	addi	fp,fp,-128
81120920:	e0000326 	beq	fp,zero,81120930 <___vfprintf_internal_r+0x758>
81120924:	d8c02a17 	ldw	r3,168(sp)
81120928:	18c00044 	addi	r3,r3,1
8112092c:	d8c02a15 	stw	r3,168(sp)
81120930:	90c0008c 	andi	r3,r18,2
81120934:	d8c02b15 	stw	r3,172(sp)
81120938:	18000326 	beq	r3,zero,81120948 <___vfprintf_internal_r+0x770>
8112093c:	d8c02a17 	ldw	r3,168(sp)
81120940:	18c00084 	addi	r3,r3,2
81120944:	d8c02a15 	stw	r3,168(sp)
81120948:	90c0210c 	andi	r3,r18,132
8112094c:	d8c03015 	stw	r3,192(sp)
81120950:	1801a31e 	bne	r3,zero,81120fe0 <___vfprintf_internal_r+0xe08>
81120954:	d9003117 	ldw	r4,196(sp)
81120958:	d8c02a17 	ldw	r3,168(sp)
8112095c:	20e7c83a 	sub	r19,r4,r3
81120960:	04c19f0e 	bge	zero,r19,81120fe0 <___vfprintf_internal_r+0xe08>
81120964:	02400404 	movi	r9,16
81120968:	d8c02017 	ldw	r3,128(sp)
8112096c:	d8801f17 	ldw	r2,124(sp)
81120970:	4cc50d0e 	bge	r9,r19,81121da8 <___vfprintf_internal_r+0x1bd0>
81120974:	01604574 	movhi	r5,33045
81120978:	296e1a84 	addi	r5,r5,-18326
8112097c:	dc403b15 	stw	r17,236(sp)
81120980:	d9403515 	stw	r5,212(sp)
81120984:	9823883a 	mov	r17,r19
81120988:	482d883a 	mov	r22,r9
8112098c:	9027883a 	mov	r19,r18
81120990:	070001c4 	movi	fp,7
81120994:	8025883a 	mov	r18,r16
81120998:	dc002c17 	ldw	r16,176(sp)
8112099c:	00000306 	br	811209ac <___vfprintf_internal_r+0x7d4>
811209a0:	8c7ffc04 	addi	r17,r17,-16
811209a4:	42000204 	addi	r8,r8,8
811209a8:	b440130e 	bge	r22,r17,811209f8 <___vfprintf_internal_r+0x820>
811209ac:	01204574 	movhi	r4,33045
811209b0:	18c00404 	addi	r3,r3,16
811209b4:	10800044 	addi	r2,r2,1
811209b8:	212e1a84 	addi	r4,r4,-18326
811209bc:	41000015 	stw	r4,0(r8)
811209c0:	45800115 	stw	r22,4(r8)
811209c4:	d8c02015 	stw	r3,128(sp)
811209c8:	d8801f15 	stw	r2,124(sp)
811209cc:	e0bff40e 	bge	fp,r2,811209a0 <__reset+0xfb1009a0>
811209d0:	d9801e04 	addi	r6,sp,120
811209d4:	b80b883a 	mov	r5,r23
811209d8:	8009883a 	mov	r4,r16
811209dc:	112c3c80 	call	8112c3c8 <__sprint_r>
811209e0:	103f011e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
811209e4:	8c7ffc04 	addi	r17,r17,-16
811209e8:	d8c02017 	ldw	r3,128(sp)
811209ec:	d8801f17 	ldw	r2,124(sp)
811209f0:	da000404 	addi	r8,sp,16
811209f4:	b47fed16 	blt	r22,r17,811209ac <__reset+0xfb1009ac>
811209f8:	9021883a 	mov	r16,r18
811209fc:	9825883a 	mov	r18,r19
81120a00:	8827883a 	mov	r19,r17
81120a04:	dc403b17 	ldw	r17,236(sp)
81120a08:	d9403517 	ldw	r5,212(sp)
81120a0c:	98c7883a 	add	r3,r19,r3
81120a10:	10800044 	addi	r2,r2,1
81120a14:	41400015 	stw	r5,0(r8)
81120a18:	44c00115 	stw	r19,4(r8)
81120a1c:	d8c02015 	stw	r3,128(sp)
81120a20:	d8801f15 	stw	r2,124(sp)
81120a24:	010001c4 	movi	r4,7
81120a28:	2082a316 	blt	r4,r2,811214b8 <___vfprintf_internal_r+0x12e0>
81120a2c:	df002787 	ldb	fp,158(sp)
81120a30:	42000204 	addi	r8,r8,8
81120a34:	e0000c26 	beq	fp,zero,81120a68 <___vfprintf_internal_r+0x890>
81120a38:	d8801f17 	ldw	r2,124(sp)
81120a3c:	d9002784 	addi	r4,sp,158
81120a40:	18c00044 	addi	r3,r3,1
81120a44:	10800044 	addi	r2,r2,1
81120a48:	41000015 	stw	r4,0(r8)
81120a4c:	01000044 	movi	r4,1
81120a50:	41000115 	stw	r4,4(r8)
81120a54:	d8c02015 	stw	r3,128(sp)
81120a58:	d8801f15 	stw	r2,124(sp)
81120a5c:	010001c4 	movi	r4,7
81120a60:	20823c16 	blt	r4,r2,81121354 <___vfprintf_internal_r+0x117c>
81120a64:	42000204 	addi	r8,r8,8
81120a68:	d8802b17 	ldw	r2,172(sp)
81120a6c:	10000c26 	beq	r2,zero,81120aa0 <___vfprintf_internal_r+0x8c8>
81120a70:	d8801f17 	ldw	r2,124(sp)
81120a74:	d9002704 	addi	r4,sp,156
81120a78:	18c00084 	addi	r3,r3,2
81120a7c:	10800044 	addi	r2,r2,1
81120a80:	41000015 	stw	r4,0(r8)
81120a84:	01000084 	movi	r4,2
81120a88:	41000115 	stw	r4,4(r8)
81120a8c:	d8c02015 	stw	r3,128(sp)
81120a90:	d8801f15 	stw	r2,124(sp)
81120a94:	010001c4 	movi	r4,7
81120a98:	20823616 	blt	r4,r2,81121374 <___vfprintf_internal_r+0x119c>
81120a9c:	42000204 	addi	r8,r8,8
81120aa0:	d9003017 	ldw	r4,192(sp)
81120aa4:	00802004 	movi	r2,128
81120aa8:	20819926 	beq	r4,r2,81121110 <___vfprintf_internal_r+0xf38>
81120aac:	d9402917 	ldw	r5,164(sp)
81120ab0:	d8802e17 	ldw	r2,184(sp)
81120ab4:	28adc83a 	sub	r22,r5,r2
81120ab8:	0580310e 	bge	zero,r22,81120b80 <___vfprintf_internal_r+0x9a8>
81120abc:	07000404 	movi	fp,16
81120ac0:	d8801f17 	ldw	r2,124(sp)
81120ac4:	e584140e 	bge	fp,r22,81121b18 <___vfprintf_internal_r+0x1940>
81120ac8:	01604574 	movhi	r5,33045
81120acc:	296e1684 	addi	r5,r5,-18342
81120ad0:	dc402915 	stw	r17,164(sp)
81120ad4:	d9402b15 	stw	r5,172(sp)
81120ad8:	b023883a 	mov	r17,r22
81120adc:	04c001c4 	movi	r19,7
81120ae0:	a82d883a 	mov	r22,r21
81120ae4:	902b883a 	mov	r21,r18
81120ae8:	8025883a 	mov	r18,r16
81120aec:	dc002c17 	ldw	r16,176(sp)
81120af0:	00000306 	br	81120b00 <___vfprintf_internal_r+0x928>
81120af4:	8c7ffc04 	addi	r17,r17,-16
81120af8:	42000204 	addi	r8,r8,8
81120afc:	e440110e 	bge	fp,r17,81120b44 <___vfprintf_internal_r+0x96c>
81120b00:	18c00404 	addi	r3,r3,16
81120b04:	10800044 	addi	r2,r2,1
81120b08:	45000015 	stw	r20,0(r8)
81120b0c:	47000115 	stw	fp,4(r8)
81120b10:	d8c02015 	stw	r3,128(sp)
81120b14:	d8801f15 	stw	r2,124(sp)
81120b18:	98bff60e 	bge	r19,r2,81120af4 <__reset+0xfb100af4>
81120b1c:	d9801e04 	addi	r6,sp,120
81120b20:	b80b883a 	mov	r5,r23
81120b24:	8009883a 	mov	r4,r16
81120b28:	112c3c80 	call	8112c3c8 <__sprint_r>
81120b2c:	103eae1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81120b30:	8c7ffc04 	addi	r17,r17,-16
81120b34:	d8c02017 	ldw	r3,128(sp)
81120b38:	d8801f17 	ldw	r2,124(sp)
81120b3c:	da000404 	addi	r8,sp,16
81120b40:	e47fef16 	blt	fp,r17,81120b00 <__reset+0xfb100b00>
81120b44:	9021883a 	mov	r16,r18
81120b48:	a825883a 	mov	r18,r21
81120b4c:	b02b883a 	mov	r21,r22
81120b50:	882d883a 	mov	r22,r17
81120b54:	dc402917 	ldw	r17,164(sp)
81120b58:	d9002b17 	ldw	r4,172(sp)
81120b5c:	1d87883a 	add	r3,r3,r22
81120b60:	10800044 	addi	r2,r2,1
81120b64:	41000015 	stw	r4,0(r8)
81120b68:	45800115 	stw	r22,4(r8)
81120b6c:	d8c02015 	stw	r3,128(sp)
81120b70:	d8801f15 	stw	r2,124(sp)
81120b74:	010001c4 	movi	r4,7
81120b78:	2081ee16 	blt	r4,r2,81121334 <___vfprintf_internal_r+0x115c>
81120b7c:	42000204 	addi	r8,r8,8
81120b80:	9080400c 	andi	r2,r18,256
81120b84:	1001181e 	bne	r2,zero,81120fe8 <___vfprintf_internal_r+0xe10>
81120b88:	d9402e17 	ldw	r5,184(sp)
81120b8c:	d8801f17 	ldw	r2,124(sp)
81120b90:	44000015 	stw	r16,0(r8)
81120b94:	1947883a 	add	r3,r3,r5
81120b98:	10800044 	addi	r2,r2,1
81120b9c:	41400115 	stw	r5,4(r8)
81120ba0:	d8c02015 	stw	r3,128(sp)
81120ba4:	d8801f15 	stw	r2,124(sp)
81120ba8:	010001c4 	movi	r4,7
81120bac:	2081d316 	blt	r4,r2,811212fc <___vfprintf_internal_r+0x1124>
81120bb0:	42000204 	addi	r8,r8,8
81120bb4:	9480010c 	andi	r18,r18,4
81120bb8:	90003226 	beq	r18,zero,81120c84 <___vfprintf_internal_r+0xaac>
81120bbc:	d9403117 	ldw	r5,196(sp)
81120bc0:	d8802a17 	ldw	r2,168(sp)
81120bc4:	28a1c83a 	sub	r16,r5,r2
81120bc8:	04002e0e 	bge	zero,r16,81120c84 <___vfprintf_internal_r+0xaac>
81120bcc:	04400404 	movi	r17,16
81120bd0:	d8801f17 	ldw	r2,124(sp)
81120bd4:	8c04a20e 	bge	r17,r16,81121e60 <___vfprintf_internal_r+0x1c88>
81120bd8:	01604574 	movhi	r5,33045
81120bdc:	296e1a84 	addi	r5,r5,-18326
81120be0:	d9403515 	stw	r5,212(sp)
81120be4:	048001c4 	movi	r18,7
81120be8:	dcc02c17 	ldw	r19,176(sp)
81120bec:	00000306 	br	81120bfc <___vfprintf_internal_r+0xa24>
81120bf0:	843ffc04 	addi	r16,r16,-16
81120bf4:	42000204 	addi	r8,r8,8
81120bf8:	8c00130e 	bge	r17,r16,81120c48 <___vfprintf_internal_r+0xa70>
81120bfc:	01204574 	movhi	r4,33045
81120c00:	18c00404 	addi	r3,r3,16
81120c04:	10800044 	addi	r2,r2,1
81120c08:	212e1a84 	addi	r4,r4,-18326
81120c0c:	41000015 	stw	r4,0(r8)
81120c10:	44400115 	stw	r17,4(r8)
81120c14:	d8c02015 	stw	r3,128(sp)
81120c18:	d8801f15 	stw	r2,124(sp)
81120c1c:	90bff40e 	bge	r18,r2,81120bf0 <__reset+0xfb100bf0>
81120c20:	d9801e04 	addi	r6,sp,120
81120c24:	b80b883a 	mov	r5,r23
81120c28:	9809883a 	mov	r4,r19
81120c2c:	112c3c80 	call	8112c3c8 <__sprint_r>
81120c30:	103e6d1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81120c34:	843ffc04 	addi	r16,r16,-16
81120c38:	d8c02017 	ldw	r3,128(sp)
81120c3c:	d8801f17 	ldw	r2,124(sp)
81120c40:	da000404 	addi	r8,sp,16
81120c44:	8c3fed16 	blt	r17,r16,81120bfc <__reset+0xfb100bfc>
81120c48:	d9403517 	ldw	r5,212(sp)
81120c4c:	1c07883a 	add	r3,r3,r16
81120c50:	10800044 	addi	r2,r2,1
81120c54:	41400015 	stw	r5,0(r8)
81120c58:	44000115 	stw	r16,4(r8)
81120c5c:	d8c02015 	stw	r3,128(sp)
81120c60:	d8801f15 	stw	r2,124(sp)
81120c64:	010001c4 	movi	r4,7
81120c68:	2080060e 	bge	r4,r2,81120c84 <___vfprintf_internal_r+0xaac>
81120c6c:	d9002c17 	ldw	r4,176(sp)
81120c70:	d9801e04 	addi	r6,sp,120
81120c74:	b80b883a 	mov	r5,r23
81120c78:	112c3c80 	call	8112c3c8 <__sprint_r>
81120c7c:	103e5a1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81120c80:	d8c02017 	ldw	r3,128(sp)
81120c84:	d8803117 	ldw	r2,196(sp)
81120c88:	d9002a17 	ldw	r4,168(sp)
81120c8c:	1100010e 	bge	r2,r4,81120c94 <___vfprintf_internal_r+0xabc>
81120c90:	2005883a 	mov	r2,r4
81120c94:	d9402f17 	ldw	r5,188(sp)
81120c98:	288b883a 	add	r5,r5,r2
81120c9c:	d9402f15 	stw	r5,188(sp)
81120ca0:	18019e1e 	bne	r3,zero,8112131c <___vfprintf_internal_r+0x1144>
81120ca4:	a8800007 	ldb	r2,0(r21)
81120ca8:	d8001f15 	stw	zero,124(sp)
81120cac:	da000404 	addi	r8,sp,16
81120cb0:	103d851e 	bne	r2,zero,811202c8 <__reset+0xfb1002c8>
81120cb4:	a821883a 	mov	r16,r21
81120cb8:	003d9b06 	br	81120328 <__reset+0xfb100328>
81120cbc:	18c03fcc 	andi	r3,r3,255
81120cc0:	1805c11e 	bne	r3,zero,811223c8 <___vfprintf_internal_r+0x21f0>
81120cc4:	94800414 	ori	r18,r18,16
81120cc8:	9080080c 	andi	r2,r18,32
81120ccc:	10020c26 	beq	r2,zero,81121500 <___vfprintf_internal_r+0x1328>
81120cd0:	d8802d17 	ldw	r2,180(sp)
81120cd4:	d9002917 	ldw	r4,164(sp)
81120cd8:	d8002785 	stb	zero,158(sp)
81120cdc:	10c00204 	addi	r3,r2,8
81120ce0:	14c00017 	ldw	r19,0(r2)
81120ce4:	15800117 	ldw	r22,4(r2)
81120ce8:	20040f16 	blt	r4,zero,81121d28 <___vfprintf_internal_r+0x1b50>
81120cec:	013fdfc4 	movi	r4,-129
81120cf0:	9d84b03a 	or	r2,r19,r22
81120cf4:	d8c02d15 	stw	r3,180(sp)
81120cf8:	9124703a 	and	r18,r18,r4
81120cfc:	0039883a 	mov	fp,zero
81120d00:	103e891e 	bne	r2,zero,81120728 <__reset+0xfb100728>
81120d04:	d9002917 	ldw	r4,164(sp)
81120d08:	2002c11e 	bne	r4,zero,81121810 <___vfprintf_internal_r+0x1638>
81120d0c:	d8002915 	stw	zero,164(sp)
81120d10:	d8002e15 	stw	zero,184(sp)
81120d14:	dc001e04 	addi	r16,sp,120
81120d18:	003ef806 	br	811208fc <__reset+0xfb1008fc>
81120d1c:	18c03fcc 	andi	r3,r3,255
81120d20:	18059d1e 	bne	r3,zero,81122398 <___vfprintf_internal_r+0x21c0>
81120d24:	01604574 	movhi	r5,33045
81120d28:	296e0204 	addi	r5,r5,-18424
81120d2c:	d9403915 	stw	r5,228(sp)
81120d30:	9080080c 	andi	r2,r18,32
81120d34:	10005226 	beq	r2,zero,81120e80 <___vfprintf_internal_r+0xca8>
81120d38:	d8802d17 	ldw	r2,180(sp)
81120d3c:	14c00017 	ldw	r19,0(r2)
81120d40:	15800117 	ldw	r22,4(r2)
81120d44:	10800204 	addi	r2,r2,8
81120d48:	d8802d15 	stw	r2,180(sp)
81120d4c:	9080004c 	andi	r2,r18,1
81120d50:	10019026 	beq	r2,zero,81121394 <___vfprintf_internal_r+0x11bc>
81120d54:	9d84b03a 	or	r2,r19,r22
81120d58:	10036926 	beq	r2,zero,81121b00 <___vfprintf_internal_r+0x1928>
81120d5c:	d8c02917 	ldw	r3,164(sp)
81120d60:	00800c04 	movi	r2,48
81120d64:	d8802705 	stb	r2,156(sp)
81120d68:	dc402745 	stb	r17,157(sp)
81120d6c:	d8002785 	stb	zero,158(sp)
81120d70:	90800094 	ori	r2,r18,2
81120d74:	18045d16 	blt	r3,zero,81121eec <___vfprintf_internal_r+0x1d14>
81120d78:	00bfdfc4 	movi	r2,-129
81120d7c:	90a4703a 	and	r18,r18,r2
81120d80:	94800094 	ori	r18,r18,2
81120d84:	0039883a 	mov	fp,zero
81120d88:	d9003917 	ldw	r4,228(sp)
81120d8c:	dc001e04 	addi	r16,sp,120
81120d90:	988003cc 	andi	r2,r19,15
81120d94:	b006973a 	slli	r3,r22,28
81120d98:	2085883a 	add	r2,r4,r2
81120d9c:	9826d13a 	srli	r19,r19,4
81120da0:	10800003 	ldbu	r2,0(r2)
81120da4:	b02cd13a 	srli	r22,r22,4
81120da8:	843fffc4 	addi	r16,r16,-1
81120dac:	1ce6b03a 	or	r19,r3,r19
81120db0:	80800005 	stb	r2,0(r16)
81120db4:	9d84b03a 	or	r2,r19,r22
81120db8:	103ff51e 	bne	r2,zero,81120d90 <__reset+0xfb100d90>
81120dbc:	d8c02817 	ldw	r3,160(sp)
81120dc0:	1c07c83a 	sub	r3,r3,r16
81120dc4:	d8c02e15 	stw	r3,184(sp)
81120dc8:	003ecc06 	br	811208fc <__reset+0xfb1008fc>
81120dcc:	18c03fcc 	andi	r3,r3,255
81120dd0:	183e9f26 	beq	r3,zero,81120850 <__reset+0xfb100850>
81120dd4:	d9c02785 	stb	r7,158(sp)
81120dd8:	003e9d06 	br	81120850 <__reset+0xfb100850>
81120ddc:	00c00044 	movi	r3,1
81120de0:	01c00ac4 	movi	r7,43
81120de4:	ac400007 	ldb	r17,0(r21)
81120de8:	003d5e06 	br	81120364 <__reset+0xfb100364>
81120dec:	94800814 	ori	r18,r18,32
81120df0:	ac400007 	ldb	r17,0(r21)
81120df4:	003d5b06 	br	81120364 <__reset+0xfb100364>
81120df8:	d8c02d17 	ldw	r3,180(sp)
81120dfc:	d8002785 	stb	zero,158(sp)
81120e00:	1c000017 	ldw	r16,0(r3)
81120e04:	1cc00104 	addi	r19,r3,4
81120e08:	80041926 	beq	r16,zero,81121e70 <___vfprintf_internal_r+0x1c98>
81120e0c:	d9002917 	ldw	r4,164(sp)
81120e10:	2003d016 	blt	r4,zero,81121d54 <___vfprintf_internal_r+0x1b7c>
81120e14:	200d883a 	mov	r6,r4
81120e18:	000b883a 	mov	r5,zero
81120e1c:	8009883a 	mov	r4,r16
81120e20:	da003d15 	stw	r8,244(sp)
81120e24:	11271bc0 	call	811271bc <memchr>
81120e28:	da003d17 	ldw	r8,244(sp)
81120e2c:	10045426 	beq	r2,zero,81121f80 <___vfprintf_internal_r+0x1da8>
81120e30:	1405c83a 	sub	r2,r2,r16
81120e34:	d8802e15 	stw	r2,184(sp)
81120e38:	1003cc16 	blt	r2,zero,81121d6c <___vfprintf_internal_r+0x1b94>
81120e3c:	df002783 	ldbu	fp,158(sp)
81120e40:	d8802a15 	stw	r2,168(sp)
81120e44:	dcc02d15 	stw	r19,180(sp)
81120e48:	d8002915 	stw	zero,164(sp)
81120e4c:	d8003215 	stw	zero,200(sp)
81120e50:	003eb006 	br	81120914 <__reset+0xfb100914>
81120e54:	18c03fcc 	andi	r3,r3,255
81120e58:	183f9b26 	beq	r3,zero,81120cc8 <__reset+0xfb100cc8>
81120e5c:	d9c02785 	stb	r7,158(sp)
81120e60:	003f9906 	br	81120cc8 <__reset+0xfb100cc8>
81120e64:	18c03fcc 	andi	r3,r3,255
81120e68:	1805551e 	bne	r3,zero,811223c0 <___vfprintf_internal_r+0x21e8>
81120e6c:	01604574 	movhi	r5,33045
81120e70:	296e0704 	addi	r5,r5,-18404
81120e74:	d9403915 	stw	r5,228(sp)
81120e78:	9080080c 	andi	r2,r18,32
81120e7c:	103fae1e 	bne	r2,zero,81120d38 <__reset+0xfb100d38>
81120e80:	9080040c 	andi	r2,r18,16
81120e84:	1002de26 	beq	r2,zero,81121a00 <___vfprintf_internal_r+0x1828>
81120e88:	d8c02d17 	ldw	r3,180(sp)
81120e8c:	002d883a 	mov	r22,zero
81120e90:	1cc00017 	ldw	r19,0(r3)
81120e94:	18c00104 	addi	r3,r3,4
81120e98:	d8c02d15 	stw	r3,180(sp)
81120e9c:	003fab06 	br	81120d4c <__reset+0xfb100d4c>
81120ea0:	38803fcc 	andi	r2,r7,255
81120ea4:	1080201c 	xori	r2,r2,128
81120ea8:	10bfe004 	addi	r2,r2,-128
81120eac:	1002d21e 	bne	r2,zero,811219f8 <___vfprintf_internal_r+0x1820>
81120eb0:	00c00044 	movi	r3,1
81120eb4:	01c00804 	movi	r7,32
81120eb8:	ac400007 	ldb	r17,0(r21)
81120ebc:	003d2906 	br	81120364 <__reset+0xfb100364>
81120ec0:	94800054 	ori	r18,r18,1
81120ec4:	ac400007 	ldb	r17,0(r21)
81120ec8:	003d2606 	br	81120364 <__reset+0xfb100364>
81120ecc:	18c03fcc 	andi	r3,r3,255
81120ed0:	183e0526 	beq	r3,zero,811206e8 <__reset+0xfb1006e8>
81120ed4:	d9c02785 	stb	r7,158(sp)
81120ed8:	003e0306 	br	811206e8 <__reset+0xfb1006e8>
81120edc:	94801014 	ori	r18,r18,64
81120ee0:	ac400007 	ldb	r17,0(r21)
81120ee4:	003d1f06 	br	81120364 <__reset+0xfb100364>
81120ee8:	ac400007 	ldb	r17,0(r21)
81120eec:	8a438726 	beq	r17,r9,81121d0c <___vfprintf_internal_r+0x1b34>
81120ef0:	94800414 	ori	r18,r18,16
81120ef4:	003d1b06 	br	81120364 <__reset+0xfb100364>
81120ef8:	18c03fcc 	andi	r3,r3,255
81120efc:	1805341e 	bne	r3,zero,811223d0 <___vfprintf_internal_r+0x21f8>
81120f00:	9080080c 	andi	r2,r18,32
81120f04:	1002cd26 	beq	r2,zero,81121a3c <___vfprintf_internal_r+0x1864>
81120f08:	d9402d17 	ldw	r5,180(sp)
81120f0c:	d9002f17 	ldw	r4,188(sp)
81120f10:	28800017 	ldw	r2,0(r5)
81120f14:	2007d7fa 	srai	r3,r4,31
81120f18:	29400104 	addi	r5,r5,4
81120f1c:	d9402d15 	stw	r5,180(sp)
81120f20:	11000015 	stw	r4,0(r2)
81120f24:	10c00115 	stw	r3,4(r2)
81120f28:	003ce506 	br	811202c0 <__reset+0xfb1002c0>
81120f2c:	d8c02d17 	ldw	r3,180(sp)
81120f30:	d9002d17 	ldw	r4,180(sp)
81120f34:	d8002785 	stb	zero,158(sp)
81120f38:	18800017 	ldw	r2,0(r3)
81120f3c:	21000104 	addi	r4,r4,4
81120f40:	00c00044 	movi	r3,1
81120f44:	d8c02a15 	stw	r3,168(sp)
81120f48:	d8801405 	stb	r2,80(sp)
81120f4c:	d9002d15 	stw	r4,180(sp)
81120f50:	d8c02e15 	stw	r3,184(sp)
81120f54:	d8002915 	stw	zero,164(sp)
81120f58:	d8003215 	stw	zero,200(sp)
81120f5c:	dc001404 	addi	r16,sp,80
81120f60:	0039883a 	mov	fp,zero
81120f64:	003e7206 	br	81120930 <__reset+0xfb100930>
81120f68:	01204574 	movhi	r4,33045
81120f6c:	212e0704 	addi	r4,r4,-18404
81120f70:	0039883a 	mov	fp,zero
81120f74:	d9003915 	stw	r4,228(sp)
81120f78:	04401e04 	movi	r17,120
81120f7c:	003f8206 	br	81120d88 <__reset+0xfb100d88>
81120f80:	18c03fcc 	andi	r3,r3,255
81120f84:	1805061e 	bne	r3,zero,811223a0 <___vfprintf_internal_r+0x21c8>
81120f88:	883d9126 	beq	r17,zero,811205d0 <__reset+0xfb1005d0>
81120f8c:	00c00044 	movi	r3,1
81120f90:	d8c02a15 	stw	r3,168(sp)
81120f94:	dc401405 	stb	r17,80(sp)
81120f98:	d8002785 	stb	zero,158(sp)
81120f9c:	003fec06 	br	81120f50 <__reset+0xfb100f50>
81120fa0:	01604574 	movhi	r5,33045
81120fa4:	296e0704 	addi	r5,r5,-18404
81120fa8:	d9403915 	stw	r5,228(sp)
81120fac:	d8c02d15 	stw	r3,180(sp)
81120fb0:	1025883a 	mov	r18,r2
81120fb4:	04401e04 	movi	r17,120
81120fb8:	9d84b03a 	or	r2,r19,r22
81120fbc:	1000fc1e 	bne	r2,zero,811213b0 <___vfprintf_internal_r+0x11d8>
81120fc0:	0039883a 	mov	fp,zero
81120fc4:	00800084 	movi	r2,2
81120fc8:	10803fcc 	andi	r2,r2,255
81120fcc:	00c00044 	movi	r3,1
81120fd0:	10c20f26 	beq	r2,r3,81121810 <___vfprintf_internal_r+0x1638>
81120fd4:	00c00084 	movi	r3,2
81120fd8:	10fd6326 	beq	r2,r3,81120568 <__reset+0xfb100568>
81120fdc:	003e2d06 	br	81120894 <__reset+0xfb100894>
81120fe0:	d8c02017 	ldw	r3,128(sp)
81120fe4:	003e9306 	br	81120a34 <__reset+0xfb100a34>
81120fe8:	00801944 	movi	r2,101
81120fec:	14407e0e 	bge	r2,r17,811211e8 <___vfprintf_internal_r+0x1010>
81120ff0:	d9003617 	ldw	r4,216(sp)
81120ff4:	d9403817 	ldw	r5,224(sp)
81120ff8:	000d883a 	mov	r6,zero
81120ffc:	000f883a 	mov	r7,zero
81121000:	d8c03c15 	stw	r3,240(sp)
81121004:	da003d15 	stw	r8,244(sp)
81121008:	1130c100 	call	81130c10 <__eqdf2>
8112100c:	d8c03c17 	ldw	r3,240(sp)
81121010:	da003d17 	ldw	r8,244(sp)
81121014:	1000f71e 	bne	r2,zero,811213f4 <___vfprintf_internal_r+0x121c>
81121018:	d8801f17 	ldw	r2,124(sp)
8112101c:	01204574 	movhi	r4,33045
81121020:	212e0e04 	addi	r4,r4,-18376
81121024:	18c00044 	addi	r3,r3,1
81121028:	10800044 	addi	r2,r2,1
8112102c:	41000015 	stw	r4,0(r8)
81121030:	01000044 	movi	r4,1
81121034:	41000115 	stw	r4,4(r8)
81121038:	d8c02015 	stw	r3,128(sp)
8112103c:	d8801f15 	stw	r2,124(sp)
81121040:	010001c4 	movi	r4,7
81121044:	2082b816 	blt	r4,r2,81121b28 <___vfprintf_internal_r+0x1950>
81121048:	42000204 	addi	r8,r8,8
8112104c:	d8802617 	ldw	r2,152(sp)
81121050:	d9403317 	ldw	r5,204(sp)
81121054:	11400216 	blt	r2,r5,81121060 <___vfprintf_internal_r+0xe88>
81121058:	9080004c 	andi	r2,r18,1
8112105c:	103ed526 	beq	r2,zero,81120bb4 <__reset+0xfb100bb4>
81121060:	d8803717 	ldw	r2,220(sp)
81121064:	d9003417 	ldw	r4,208(sp)
81121068:	d9403717 	ldw	r5,220(sp)
8112106c:	1887883a 	add	r3,r3,r2
81121070:	d8801f17 	ldw	r2,124(sp)
81121074:	41000015 	stw	r4,0(r8)
81121078:	41400115 	stw	r5,4(r8)
8112107c:	10800044 	addi	r2,r2,1
81121080:	d8c02015 	stw	r3,128(sp)
81121084:	d8801f15 	stw	r2,124(sp)
81121088:	010001c4 	movi	r4,7
8112108c:	20832916 	blt	r4,r2,81121d34 <___vfprintf_internal_r+0x1b5c>
81121090:	42000204 	addi	r8,r8,8
81121094:	d8803317 	ldw	r2,204(sp)
81121098:	143fffc4 	addi	r16,r2,-1
8112109c:	043ec50e 	bge	zero,r16,81120bb4 <__reset+0xfb100bb4>
811210a0:	04400404 	movi	r17,16
811210a4:	d8801f17 	ldw	r2,124(sp)
811210a8:	8c00880e 	bge	r17,r16,811212cc <___vfprintf_internal_r+0x10f4>
811210ac:	01604574 	movhi	r5,33045
811210b0:	296e1684 	addi	r5,r5,-18342
811210b4:	d9402b15 	stw	r5,172(sp)
811210b8:	058001c4 	movi	r22,7
811210bc:	dcc02c17 	ldw	r19,176(sp)
811210c0:	00000306 	br	811210d0 <___vfprintf_internal_r+0xef8>
811210c4:	42000204 	addi	r8,r8,8
811210c8:	843ffc04 	addi	r16,r16,-16
811210cc:	8c00820e 	bge	r17,r16,811212d8 <___vfprintf_internal_r+0x1100>
811210d0:	18c00404 	addi	r3,r3,16
811210d4:	10800044 	addi	r2,r2,1
811210d8:	45000015 	stw	r20,0(r8)
811210dc:	44400115 	stw	r17,4(r8)
811210e0:	d8c02015 	stw	r3,128(sp)
811210e4:	d8801f15 	stw	r2,124(sp)
811210e8:	b0bff60e 	bge	r22,r2,811210c4 <__reset+0xfb1010c4>
811210ec:	d9801e04 	addi	r6,sp,120
811210f0:	b80b883a 	mov	r5,r23
811210f4:	9809883a 	mov	r4,r19
811210f8:	112c3c80 	call	8112c3c8 <__sprint_r>
811210fc:	103d3a1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121100:	d8c02017 	ldw	r3,128(sp)
81121104:	d8801f17 	ldw	r2,124(sp)
81121108:	da000404 	addi	r8,sp,16
8112110c:	003fee06 	br	811210c8 <__reset+0xfb1010c8>
81121110:	d9403117 	ldw	r5,196(sp)
81121114:	d8802a17 	ldw	r2,168(sp)
81121118:	28adc83a 	sub	r22,r5,r2
8112111c:	05be630e 	bge	zero,r22,81120aac <__reset+0xfb100aac>
81121120:	07000404 	movi	fp,16
81121124:	d8801f17 	ldw	r2,124(sp)
81121128:	e5838f0e 	bge	fp,r22,81121f68 <___vfprintf_internal_r+0x1d90>
8112112c:	01604574 	movhi	r5,33045
81121130:	296e1684 	addi	r5,r5,-18342
81121134:	dc403015 	stw	r17,192(sp)
81121138:	d9402b15 	stw	r5,172(sp)
8112113c:	b023883a 	mov	r17,r22
81121140:	04c001c4 	movi	r19,7
81121144:	a82d883a 	mov	r22,r21
81121148:	902b883a 	mov	r21,r18
8112114c:	8025883a 	mov	r18,r16
81121150:	dc002c17 	ldw	r16,176(sp)
81121154:	00000306 	br	81121164 <___vfprintf_internal_r+0xf8c>
81121158:	8c7ffc04 	addi	r17,r17,-16
8112115c:	42000204 	addi	r8,r8,8
81121160:	e440110e 	bge	fp,r17,811211a8 <___vfprintf_internal_r+0xfd0>
81121164:	18c00404 	addi	r3,r3,16
81121168:	10800044 	addi	r2,r2,1
8112116c:	45000015 	stw	r20,0(r8)
81121170:	47000115 	stw	fp,4(r8)
81121174:	d8c02015 	stw	r3,128(sp)
81121178:	d8801f15 	stw	r2,124(sp)
8112117c:	98bff60e 	bge	r19,r2,81121158 <__reset+0xfb101158>
81121180:	d9801e04 	addi	r6,sp,120
81121184:	b80b883a 	mov	r5,r23
81121188:	8009883a 	mov	r4,r16
8112118c:	112c3c80 	call	8112c3c8 <__sprint_r>
81121190:	103d151e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121194:	8c7ffc04 	addi	r17,r17,-16
81121198:	d8c02017 	ldw	r3,128(sp)
8112119c:	d8801f17 	ldw	r2,124(sp)
811211a0:	da000404 	addi	r8,sp,16
811211a4:	e47fef16 	blt	fp,r17,81121164 <__reset+0xfb101164>
811211a8:	9021883a 	mov	r16,r18
811211ac:	a825883a 	mov	r18,r21
811211b0:	b02b883a 	mov	r21,r22
811211b4:	882d883a 	mov	r22,r17
811211b8:	dc403017 	ldw	r17,192(sp)
811211bc:	d9002b17 	ldw	r4,172(sp)
811211c0:	1d87883a 	add	r3,r3,r22
811211c4:	10800044 	addi	r2,r2,1
811211c8:	41000015 	stw	r4,0(r8)
811211cc:	45800115 	stw	r22,4(r8)
811211d0:	d8c02015 	stw	r3,128(sp)
811211d4:	d8801f15 	stw	r2,124(sp)
811211d8:	010001c4 	movi	r4,7
811211dc:	20818e16 	blt	r4,r2,81121818 <___vfprintf_internal_r+0x1640>
811211e0:	42000204 	addi	r8,r8,8
811211e4:	003e3106 	br	81120aac <__reset+0xfb100aac>
811211e8:	d9403317 	ldw	r5,204(sp)
811211ec:	00800044 	movi	r2,1
811211f0:	18c00044 	addi	r3,r3,1
811211f4:	1141530e 	bge	r2,r5,81121744 <___vfprintf_internal_r+0x156c>
811211f8:	dc401f17 	ldw	r17,124(sp)
811211fc:	00800044 	movi	r2,1
81121200:	40800115 	stw	r2,4(r8)
81121204:	8c400044 	addi	r17,r17,1
81121208:	44000015 	stw	r16,0(r8)
8112120c:	d8c02015 	stw	r3,128(sp)
81121210:	dc401f15 	stw	r17,124(sp)
81121214:	008001c4 	movi	r2,7
81121218:	14416b16 	blt	r2,r17,811217c8 <___vfprintf_internal_r+0x15f0>
8112121c:	42000204 	addi	r8,r8,8
81121220:	d8803717 	ldw	r2,220(sp)
81121224:	d9003417 	ldw	r4,208(sp)
81121228:	8c400044 	addi	r17,r17,1
8112122c:	10c7883a 	add	r3,r2,r3
81121230:	40800115 	stw	r2,4(r8)
81121234:	41000015 	stw	r4,0(r8)
81121238:	d8c02015 	stw	r3,128(sp)
8112123c:	dc401f15 	stw	r17,124(sp)
81121240:	008001c4 	movi	r2,7
81121244:	14416916 	blt	r2,r17,811217ec <___vfprintf_internal_r+0x1614>
81121248:	45800204 	addi	r22,r8,8
8112124c:	d9003617 	ldw	r4,216(sp)
81121250:	d9403817 	ldw	r5,224(sp)
81121254:	000d883a 	mov	r6,zero
81121258:	000f883a 	mov	r7,zero
8112125c:	d8c03c15 	stw	r3,240(sp)
81121260:	1130c100 	call	81130c10 <__eqdf2>
81121264:	d8c03c17 	ldw	r3,240(sp)
81121268:	1000bc26 	beq	r2,zero,8112155c <___vfprintf_internal_r+0x1384>
8112126c:	d9403317 	ldw	r5,204(sp)
81121270:	84000044 	addi	r16,r16,1
81121274:	8c400044 	addi	r17,r17,1
81121278:	28bfffc4 	addi	r2,r5,-1
8112127c:	1887883a 	add	r3,r3,r2
81121280:	b0800115 	stw	r2,4(r22)
81121284:	b4000015 	stw	r16,0(r22)
81121288:	d8c02015 	stw	r3,128(sp)
8112128c:	dc401f15 	stw	r17,124(sp)
81121290:	008001c4 	movi	r2,7
81121294:	14414316 	blt	r2,r17,811217a4 <___vfprintf_internal_r+0x15cc>
81121298:	b5800204 	addi	r22,r22,8
8112129c:	d9003a17 	ldw	r4,232(sp)
811212a0:	df0022c4 	addi	fp,sp,139
811212a4:	8c400044 	addi	r17,r17,1
811212a8:	20c7883a 	add	r3,r4,r3
811212ac:	b7000015 	stw	fp,0(r22)
811212b0:	b1000115 	stw	r4,4(r22)
811212b4:	d8c02015 	stw	r3,128(sp)
811212b8:	dc401f15 	stw	r17,124(sp)
811212bc:	008001c4 	movi	r2,7
811212c0:	14400e16 	blt	r2,r17,811212fc <___vfprintf_internal_r+0x1124>
811212c4:	b2000204 	addi	r8,r22,8
811212c8:	003e3a06 	br	81120bb4 <__reset+0xfb100bb4>
811212cc:	01204574 	movhi	r4,33045
811212d0:	212e1684 	addi	r4,r4,-18342
811212d4:	d9002b15 	stw	r4,172(sp)
811212d8:	d9002b17 	ldw	r4,172(sp)
811212dc:	1c07883a 	add	r3,r3,r16
811212e0:	44000115 	stw	r16,4(r8)
811212e4:	41000015 	stw	r4,0(r8)
811212e8:	10800044 	addi	r2,r2,1
811212ec:	d8c02015 	stw	r3,128(sp)
811212f0:	d8801f15 	stw	r2,124(sp)
811212f4:	010001c4 	movi	r4,7
811212f8:	20be2d0e 	bge	r4,r2,81120bb0 <__reset+0xfb100bb0>
811212fc:	d9002c17 	ldw	r4,176(sp)
81121300:	d9801e04 	addi	r6,sp,120
81121304:	b80b883a 	mov	r5,r23
81121308:	112c3c80 	call	8112c3c8 <__sprint_r>
8112130c:	103cb61e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121310:	d8c02017 	ldw	r3,128(sp)
81121314:	da000404 	addi	r8,sp,16
81121318:	003e2606 	br	81120bb4 <__reset+0xfb100bb4>
8112131c:	d9002c17 	ldw	r4,176(sp)
81121320:	d9801e04 	addi	r6,sp,120
81121324:	b80b883a 	mov	r5,r23
81121328:	112c3c80 	call	8112c3c8 <__sprint_r>
8112132c:	103e5d26 	beq	r2,zero,81120ca4 <__reset+0xfb100ca4>
81121330:	003cad06 	br	811205e8 <__reset+0xfb1005e8>
81121334:	d9002c17 	ldw	r4,176(sp)
81121338:	d9801e04 	addi	r6,sp,120
8112133c:	b80b883a 	mov	r5,r23
81121340:	112c3c80 	call	8112c3c8 <__sprint_r>
81121344:	103ca81e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121348:	d8c02017 	ldw	r3,128(sp)
8112134c:	da000404 	addi	r8,sp,16
81121350:	003e0b06 	br	81120b80 <__reset+0xfb100b80>
81121354:	d9002c17 	ldw	r4,176(sp)
81121358:	d9801e04 	addi	r6,sp,120
8112135c:	b80b883a 	mov	r5,r23
81121360:	112c3c80 	call	8112c3c8 <__sprint_r>
81121364:	103ca01e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121368:	d8c02017 	ldw	r3,128(sp)
8112136c:	da000404 	addi	r8,sp,16
81121370:	003dbd06 	br	81120a68 <__reset+0xfb100a68>
81121374:	d9002c17 	ldw	r4,176(sp)
81121378:	d9801e04 	addi	r6,sp,120
8112137c:	b80b883a 	mov	r5,r23
81121380:	112c3c80 	call	8112c3c8 <__sprint_r>
81121384:	103c981e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121388:	d8c02017 	ldw	r3,128(sp)
8112138c:	da000404 	addi	r8,sp,16
81121390:	003dc306 	br	81120aa0 <__reset+0xfb100aa0>
81121394:	d8802917 	ldw	r2,164(sp)
81121398:	d8002785 	stb	zero,158(sp)
8112139c:	103f0616 	blt	r2,zero,81120fb8 <__reset+0xfb100fb8>
811213a0:	00ffdfc4 	movi	r3,-129
811213a4:	9d84b03a 	or	r2,r19,r22
811213a8:	90e4703a 	and	r18,r18,r3
811213ac:	103c6b26 	beq	r2,zero,8112055c <__reset+0xfb10055c>
811213b0:	0039883a 	mov	fp,zero
811213b4:	003e7406 	br	81120d88 <__reset+0xfb100d88>
811213b8:	9080040c 	andi	r2,r18,16
811213bc:	1001b326 	beq	r2,zero,81121a8c <___vfprintf_internal_r+0x18b4>
811213c0:	d9002d17 	ldw	r4,180(sp)
811213c4:	d9402917 	ldw	r5,164(sp)
811213c8:	d8002785 	stb	zero,158(sp)
811213cc:	20800104 	addi	r2,r4,4
811213d0:	24c00017 	ldw	r19,0(r4)
811213d4:	002d883a 	mov	r22,zero
811213d8:	2801b516 	blt	r5,zero,81121ab0 <___vfprintf_internal_r+0x18d8>
811213dc:	00ffdfc4 	movi	r3,-129
811213e0:	d8802d15 	stw	r2,180(sp)
811213e4:	90e4703a 	and	r18,r18,r3
811213e8:	983d2726 	beq	r19,zero,81120888 <__reset+0xfb100888>
811213ec:	0039883a 	mov	fp,zero
811213f0:	003d2a06 	br	8112089c <__reset+0xfb10089c>
811213f4:	dc402617 	ldw	r17,152(sp)
811213f8:	0441d30e 	bge	zero,r17,81121b48 <___vfprintf_internal_r+0x1970>
811213fc:	dc403217 	ldw	r17,200(sp)
81121400:	d8803317 	ldw	r2,204(sp)
81121404:	1440010e 	bge	r2,r17,8112140c <___vfprintf_internal_r+0x1234>
81121408:	1023883a 	mov	r17,r2
8112140c:	04400a0e 	bge	zero,r17,81121438 <___vfprintf_internal_r+0x1260>
81121410:	d8801f17 	ldw	r2,124(sp)
81121414:	1c47883a 	add	r3,r3,r17
81121418:	44000015 	stw	r16,0(r8)
8112141c:	10800044 	addi	r2,r2,1
81121420:	44400115 	stw	r17,4(r8)
81121424:	d8c02015 	stw	r3,128(sp)
81121428:	d8801f15 	stw	r2,124(sp)
8112142c:	010001c4 	movi	r4,7
81121430:	20826516 	blt	r4,r2,81121dc8 <___vfprintf_internal_r+0x1bf0>
81121434:	42000204 	addi	r8,r8,8
81121438:	88026116 	blt	r17,zero,81121dc0 <___vfprintf_internal_r+0x1be8>
8112143c:	d9003217 	ldw	r4,200(sp)
81121440:	2463c83a 	sub	r17,r4,r17
81121444:	04407b0e 	bge	zero,r17,81121634 <___vfprintf_internal_r+0x145c>
81121448:	05800404 	movi	r22,16
8112144c:	d8801f17 	ldw	r2,124(sp)
81121450:	b4419d0e 	bge	r22,r17,81121ac8 <___vfprintf_internal_r+0x18f0>
81121454:	01204574 	movhi	r4,33045
81121458:	212e1684 	addi	r4,r4,-18342
8112145c:	d9002b15 	stw	r4,172(sp)
81121460:	070001c4 	movi	fp,7
81121464:	dcc02c17 	ldw	r19,176(sp)
81121468:	00000306 	br	81121478 <___vfprintf_internal_r+0x12a0>
8112146c:	42000204 	addi	r8,r8,8
81121470:	8c7ffc04 	addi	r17,r17,-16
81121474:	b441970e 	bge	r22,r17,81121ad4 <___vfprintf_internal_r+0x18fc>
81121478:	18c00404 	addi	r3,r3,16
8112147c:	10800044 	addi	r2,r2,1
81121480:	45000015 	stw	r20,0(r8)
81121484:	45800115 	stw	r22,4(r8)
81121488:	d8c02015 	stw	r3,128(sp)
8112148c:	d8801f15 	stw	r2,124(sp)
81121490:	e0bff60e 	bge	fp,r2,8112146c <__reset+0xfb10146c>
81121494:	d9801e04 	addi	r6,sp,120
81121498:	b80b883a 	mov	r5,r23
8112149c:	9809883a 	mov	r4,r19
811214a0:	112c3c80 	call	8112c3c8 <__sprint_r>
811214a4:	103c501e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
811214a8:	d8c02017 	ldw	r3,128(sp)
811214ac:	d8801f17 	ldw	r2,124(sp)
811214b0:	da000404 	addi	r8,sp,16
811214b4:	003fee06 	br	81121470 <__reset+0xfb101470>
811214b8:	d9002c17 	ldw	r4,176(sp)
811214bc:	d9801e04 	addi	r6,sp,120
811214c0:	b80b883a 	mov	r5,r23
811214c4:	112c3c80 	call	8112c3c8 <__sprint_r>
811214c8:	103c471e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
811214cc:	d8c02017 	ldw	r3,128(sp)
811214d0:	df002787 	ldb	fp,158(sp)
811214d4:	da000404 	addi	r8,sp,16
811214d8:	003d5606 	br	81120a34 <__reset+0xfb100a34>
811214dc:	9080040c 	andi	r2,r18,16
811214e0:	10016126 	beq	r2,zero,81121a68 <___vfprintf_internal_r+0x1890>
811214e4:	d8802d17 	ldw	r2,180(sp)
811214e8:	14c00017 	ldw	r19,0(r2)
811214ec:	10800104 	addi	r2,r2,4
811214f0:	d8802d15 	stw	r2,180(sp)
811214f4:	982dd7fa 	srai	r22,r19,31
811214f8:	b005883a 	mov	r2,r22
811214fc:	003c8206 	br	81120708 <__reset+0xfb100708>
81121500:	9080040c 	andi	r2,r18,16
81121504:	10003526 	beq	r2,zero,811215dc <___vfprintf_internal_r+0x1404>
81121508:	d9402d17 	ldw	r5,180(sp)
8112150c:	d8c02917 	ldw	r3,164(sp)
81121510:	d8002785 	stb	zero,158(sp)
81121514:	28800104 	addi	r2,r5,4
81121518:	2cc00017 	ldw	r19,0(r5)
8112151c:	002d883a 	mov	r22,zero
81121520:	18003716 	blt	r3,zero,81121600 <___vfprintf_internal_r+0x1428>
81121524:	00ffdfc4 	movi	r3,-129
81121528:	d8802d15 	stw	r2,180(sp)
8112152c:	90e4703a 	and	r18,r18,r3
81121530:	0039883a 	mov	fp,zero
81121534:	983df326 	beq	r19,zero,81120d04 <__reset+0xfb100d04>
81121538:	00800244 	movi	r2,9
8112153c:	14fc7b36 	bltu	r2,r19,8112072c <__reset+0xfb10072c>
81121540:	d8c02817 	ldw	r3,160(sp)
81121544:	dc001dc4 	addi	r16,sp,119
81121548:	9cc00c04 	addi	r19,r19,48
8112154c:	1c07c83a 	sub	r3,r3,r16
81121550:	dcc01dc5 	stb	r19,119(sp)
81121554:	d8c02e15 	stw	r3,184(sp)
81121558:	003ce806 	br	811208fc <__reset+0xfb1008fc>
8112155c:	d8803317 	ldw	r2,204(sp)
81121560:	143fffc4 	addi	r16,r2,-1
81121564:	043f4d0e 	bge	zero,r16,8112129c <__reset+0xfb10129c>
81121568:	07000404 	movi	fp,16
8112156c:	e400810e 	bge	fp,r16,81121774 <___vfprintf_internal_r+0x159c>
81121570:	01604574 	movhi	r5,33045
81121574:	296e1684 	addi	r5,r5,-18342
81121578:	d9402b15 	stw	r5,172(sp)
8112157c:	01c001c4 	movi	r7,7
81121580:	dcc02c17 	ldw	r19,176(sp)
81121584:	00000306 	br	81121594 <___vfprintf_internal_r+0x13bc>
81121588:	b5800204 	addi	r22,r22,8
8112158c:	843ffc04 	addi	r16,r16,-16
81121590:	e4007b0e 	bge	fp,r16,81121780 <___vfprintf_internal_r+0x15a8>
81121594:	18c00404 	addi	r3,r3,16
81121598:	8c400044 	addi	r17,r17,1
8112159c:	b5000015 	stw	r20,0(r22)
811215a0:	b7000115 	stw	fp,4(r22)
811215a4:	d8c02015 	stw	r3,128(sp)
811215a8:	dc401f15 	stw	r17,124(sp)
811215ac:	3c7ff60e 	bge	r7,r17,81121588 <__reset+0xfb101588>
811215b0:	d9801e04 	addi	r6,sp,120
811215b4:	b80b883a 	mov	r5,r23
811215b8:	9809883a 	mov	r4,r19
811215bc:	d9c03c15 	stw	r7,240(sp)
811215c0:	112c3c80 	call	8112c3c8 <__sprint_r>
811215c4:	d9c03c17 	ldw	r7,240(sp)
811215c8:	103c071e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
811215cc:	d8c02017 	ldw	r3,128(sp)
811215d0:	dc401f17 	ldw	r17,124(sp)
811215d4:	dd800404 	addi	r22,sp,16
811215d8:	003fec06 	br	8112158c <__reset+0xfb10158c>
811215dc:	9080100c 	andi	r2,r18,64
811215e0:	d8002785 	stb	zero,158(sp)
811215e4:	10010e26 	beq	r2,zero,81121a20 <___vfprintf_internal_r+0x1848>
811215e8:	d9002d17 	ldw	r4,180(sp)
811215ec:	d9402917 	ldw	r5,164(sp)
811215f0:	002d883a 	mov	r22,zero
811215f4:	20800104 	addi	r2,r4,4
811215f8:	24c0000b 	ldhu	r19,0(r4)
811215fc:	283fc90e 	bge	r5,zero,81121524 <__reset+0xfb101524>
81121600:	d8802d15 	stw	r2,180(sp)
81121604:	0039883a 	mov	fp,zero
81121608:	9d84b03a 	or	r2,r19,r22
8112160c:	103c461e 	bne	r2,zero,81120728 <__reset+0xfb100728>
81121610:	00800044 	movi	r2,1
81121614:	003e6c06 	br	81120fc8 <__reset+0xfb100fc8>
81121618:	d9002c17 	ldw	r4,176(sp)
8112161c:	d9801e04 	addi	r6,sp,120
81121620:	b80b883a 	mov	r5,r23
81121624:	112c3c80 	call	8112c3c8 <__sprint_r>
81121628:	103bef1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
8112162c:	d8c02017 	ldw	r3,128(sp)
81121630:	da000404 	addi	r8,sp,16
81121634:	d9003217 	ldw	r4,200(sp)
81121638:	d8802617 	ldw	r2,152(sp)
8112163c:	d9403317 	ldw	r5,204(sp)
81121640:	8123883a 	add	r17,r16,r4
81121644:	11400216 	blt	r2,r5,81121650 <___vfprintf_internal_r+0x1478>
81121648:	9100004c 	andi	r4,r18,1
8112164c:	20000d26 	beq	r4,zero,81121684 <___vfprintf_internal_r+0x14ac>
81121650:	d9003717 	ldw	r4,220(sp)
81121654:	d9403417 	ldw	r5,208(sp)
81121658:	1907883a 	add	r3,r3,r4
8112165c:	d9001f17 	ldw	r4,124(sp)
81121660:	41400015 	stw	r5,0(r8)
81121664:	d9403717 	ldw	r5,220(sp)
81121668:	21000044 	addi	r4,r4,1
8112166c:	d8c02015 	stw	r3,128(sp)
81121670:	41400115 	stw	r5,4(r8)
81121674:	d9001f15 	stw	r4,124(sp)
81121678:	014001c4 	movi	r5,7
8112167c:	2901e816 	blt	r5,r4,81121e20 <___vfprintf_internal_r+0x1c48>
81121680:	42000204 	addi	r8,r8,8
81121684:	d9003317 	ldw	r4,204(sp)
81121688:	8121883a 	add	r16,r16,r4
8112168c:	2085c83a 	sub	r2,r4,r2
81121690:	8461c83a 	sub	r16,r16,r17
81121694:	1400010e 	bge	r2,r16,8112169c <___vfprintf_internal_r+0x14c4>
81121698:	1021883a 	mov	r16,r2
8112169c:	04000a0e 	bge	zero,r16,811216c8 <___vfprintf_internal_r+0x14f0>
811216a0:	d9001f17 	ldw	r4,124(sp)
811216a4:	1c07883a 	add	r3,r3,r16
811216a8:	44400015 	stw	r17,0(r8)
811216ac:	21000044 	addi	r4,r4,1
811216b0:	44000115 	stw	r16,4(r8)
811216b4:	d8c02015 	stw	r3,128(sp)
811216b8:	d9001f15 	stw	r4,124(sp)
811216bc:	014001c4 	movi	r5,7
811216c0:	2901fb16 	blt	r5,r4,81121eb0 <___vfprintf_internal_r+0x1cd8>
811216c4:	42000204 	addi	r8,r8,8
811216c8:	8001f716 	blt	r16,zero,81121ea8 <___vfprintf_internal_r+0x1cd0>
811216cc:	1421c83a 	sub	r16,r2,r16
811216d0:	043d380e 	bge	zero,r16,81120bb4 <__reset+0xfb100bb4>
811216d4:	04400404 	movi	r17,16
811216d8:	d8801f17 	ldw	r2,124(sp)
811216dc:	8c3efb0e 	bge	r17,r16,811212cc <__reset+0xfb1012cc>
811216e0:	01604574 	movhi	r5,33045
811216e4:	296e1684 	addi	r5,r5,-18342
811216e8:	d9402b15 	stw	r5,172(sp)
811216ec:	058001c4 	movi	r22,7
811216f0:	dcc02c17 	ldw	r19,176(sp)
811216f4:	00000306 	br	81121704 <___vfprintf_internal_r+0x152c>
811216f8:	42000204 	addi	r8,r8,8
811216fc:	843ffc04 	addi	r16,r16,-16
81121700:	8c3ef50e 	bge	r17,r16,811212d8 <__reset+0xfb1012d8>
81121704:	18c00404 	addi	r3,r3,16
81121708:	10800044 	addi	r2,r2,1
8112170c:	45000015 	stw	r20,0(r8)
81121710:	44400115 	stw	r17,4(r8)
81121714:	d8c02015 	stw	r3,128(sp)
81121718:	d8801f15 	stw	r2,124(sp)
8112171c:	b0bff60e 	bge	r22,r2,811216f8 <__reset+0xfb1016f8>
81121720:	d9801e04 	addi	r6,sp,120
81121724:	b80b883a 	mov	r5,r23
81121728:	9809883a 	mov	r4,r19
8112172c:	112c3c80 	call	8112c3c8 <__sprint_r>
81121730:	103bad1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121734:	d8c02017 	ldw	r3,128(sp)
81121738:	d8801f17 	ldw	r2,124(sp)
8112173c:	da000404 	addi	r8,sp,16
81121740:	003fee06 	br	811216fc <__reset+0xfb1016fc>
81121744:	9088703a 	and	r4,r18,r2
81121748:	203eab1e 	bne	r4,zero,811211f8 <__reset+0xfb1011f8>
8112174c:	dc401f17 	ldw	r17,124(sp)
81121750:	40800115 	stw	r2,4(r8)
81121754:	44000015 	stw	r16,0(r8)
81121758:	8c400044 	addi	r17,r17,1
8112175c:	d8c02015 	stw	r3,128(sp)
81121760:	dc401f15 	stw	r17,124(sp)
81121764:	008001c4 	movi	r2,7
81121768:	14400e16 	blt	r2,r17,811217a4 <___vfprintf_internal_r+0x15cc>
8112176c:	45800204 	addi	r22,r8,8
81121770:	003eca06 	br	8112129c <__reset+0xfb10129c>
81121774:	01204574 	movhi	r4,33045
81121778:	212e1684 	addi	r4,r4,-18342
8112177c:	d9002b15 	stw	r4,172(sp)
81121780:	d8802b17 	ldw	r2,172(sp)
81121784:	1c07883a 	add	r3,r3,r16
81121788:	8c400044 	addi	r17,r17,1
8112178c:	b0800015 	stw	r2,0(r22)
81121790:	b4000115 	stw	r16,4(r22)
81121794:	d8c02015 	stw	r3,128(sp)
81121798:	dc401f15 	stw	r17,124(sp)
8112179c:	008001c4 	movi	r2,7
811217a0:	147ebd0e 	bge	r2,r17,81121298 <__reset+0xfb101298>
811217a4:	d9002c17 	ldw	r4,176(sp)
811217a8:	d9801e04 	addi	r6,sp,120
811217ac:	b80b883a 	mov	r5,r23
811217b0:	112c3c80 	call	8112c3c8 <__sprint_r>
811217b4:	103b8c1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
811217b8:	d8c02017 	ldw	r3,128(sp)
811217bc:	dc401f17 	ldw	r17,124(sp)
811217c0:	dd800404 	addi	r22,sp,16
811217c4:	003eb506 	br	8112129c <__reset+0xfb10129c>
811217c8:	d9002c17 	ldw	r4,176(sp)
811217cc:	d9801e04 	addi	r6,sp,120
811217d0:	b80b883a 	mov	r5,r23
811217d4:	112c3c80 	call	8112c3c8 <__sprint_r>
811217d8:	103b831e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
811217dc:	d8c02017 	ldw	r3,128(sp)
811217e0:	dc401f17 	ldw	r17,124(sp)
811217e4:	da000404 	addi	r8,sp,16
811217e8:	003e8d06 	br	81121220 <__reset+0xfb101220>
811217ec:	d9002c17 	ldw	r4,176(sp)
811217f0:	d9801e04 	addi	r6,sp,120
811217f4:	b80b883a 	mov	r5,r23
811217f8:	112c3c80 	call	8112c3c8 <__sprint_r>
811217fc:	103b7a1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121800:	d8c02017 	ldw	r3,128(sp)
81121804:	dc401f17 	ldw	r17,124(sp)
81121808:	dd800404 	addi	r22,sp,16
8112180c:	003e8f06 	br	8112124c <__reset+0xfb10124c>
81121810:	0027883a 	mov	r19,zero
81121814:	003f4a06 	br	81121540 <__reset+0xfb101540>
81121818:	d9002c17 	ldw	r4,176(sp)
8112181c:	d9801e04 	addi	r6,sp,120
81121820:	b80b883a 	mov	r5,r23
81121824:	112c3c80 	call	8112c3c8 <__sprint_r>
81121828:	103b6f1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
8112182c:	d8c02017 	ldw	r3,128(sp)
81121830:	da000404 	addi	r8,sp,16
81121834:	003c9d06 	br	81120aac <__reset+0xfb100aac>
81121838:	04e7c83a 	sub	r19,zero,r19
8112183c:	9804c03a 	cmpne	r2,r19,zero
81121840:	05adc83a 	sub	r22,zero,r22
81121844:	b0adc83a 	sub	r22,r22,r2
81121848:	d8802917 	ldw	r2,164(sp)
8112184c:	07000b44 	movi	fp,45
81121850:	df002785 	stb	fp,158(sp)
81121854:	10017b16 	blt	r2,zero,81121e44 <___vfprintf_internal_r+0x1c6c>
81121858:	00bfdfc4 	movi	r2,-129
8112185c:	90a4703a 	and	r18,r18,r2
81121860:	003bb106 	br	81120728 <__reset+0xfb100728>
81121864:	d9003617 	ldw	r4,216(sp)
81121868:	d9403817 	ldw	r5,224(sp)
8112186c:	da003d15 	stw	r8,244(sp)
81121870:	1128a2c0 	call	81128a2c <__fpclassifyd>
81121874:	da003d17 	ldw	r8,244(sp)
81121878:	1000f026 	beq	r2,zero,81121c3c <___vfprintf_internal_r+0x1a64>
8112187c:	d9002917 	ldw	r4,164(sp)
81121880:	05bff7c4 	movi	r22,-33
81121884:	00bfffc4 	movi	r2,-1
81121888:	8dac703a 	and	r22,r17,r22
8112188c:	20820026 	beq	r4,r2,81122090 <___vfprintf_internal_r+0x1eb8>
81121890:	008011c4 	movi	r2,71
81121894:	b081f726 	beq	r22,r2,81122074 <___vfprintf_internal_r+0x1e9c>
81121898:	d9003817 	ldw	r4,224(sp)
8112189c:	90c04014 	ori	r3,r18,256
811218a0:	d8c02b15 	stw	r3,172(sp)
811218a4:	20021516 	blt	r4,zero,811220fc <___vfprintf_internal_r+0x1f24>
811218a8:	dcc03817 	ldw	r19,224(sp)
811218ac:	d8002a05 	stb	zero,168(sp)
811218b0:	00801984 	movi	r2,102
811218b4:	8881f926 	beq	r17,r2,8112209c <___vfprintf_internal_r+0x1ec4>
811218b8:	00801184 	movi	r2,70
811218bc:	88821c26 	beq	r17,r2,81122130 <___vfprintf_internal_r+0x1f58>
811218c0:	00801144 	movi	r2,69
811218c4:	b081ef26 	beq	r22,r2,81122084 <___vfprintf_internal_r+0x1eac>
811218c8:	d8c02917 	ldw	r3,164(sp)
811218cc:	d8802104 	addi	r2,sp,132
811218d0:	d8800315 	stw	r2,12(sp)
811218d4:	d9403617 	ldw	r5,216(sp)
811218d8:	d8802504 	addi	r2,sp,148
811218dc:	d9002c17 	ldw	r4,176(sp)
811218e0:	d8800215 	stw	r2,8(sp)
811218e4:	d8802604 	addi	r2,sp,152
811218e8:	d8c00015 	stw	r3,0(sp)
811218ec:	d8800115 	stw	r2,4(sp)
811218f0:	01c00084 	movi	r7,2
811218f4:	980d883a 	mov	r6,r19
811218f8:	d8c03c15 	stw	r3,240(sp)
811218fc:	da003d15 	stw	r8,244(sp)
81121900:	11242e40 	call	811242e4 <_dtoa_r>
81121904:	1021883a 	mov	r16,r2
81121908:	008019c4 	movi	r2,103
8112190c:	d8c03c17 	ldw	r3,240(sp)
81121910:	da003d17 	ldw	r8,244(sp)
81121914:	88817126 	beq	r17,r2,81121edc <___vfprintf_internal_r+0x1d04>
81121918:	008011c4 	movi	r2,71
8112191c:	88829226 	beq	r17,r2,81122368 <___vfprintf_internal_r+0x2190>
81121920:	80f9883a 	add	fp,r16,r3
81121924:	d9003617 	ldw	r4,216(sp)
81121928:	000d883a 	mov	r6,zero
8112192c:	000f883a 	mov	r7,zero
81121930:	980b883a 	mov	r5,r19
81121934:	da003d15 	stw	r8,244(sp)
81121938:	1130c100 	call	81130c10 <__eqdf2>
8112193c:	da003d17 	ldw	r8,244(sp)
81121940:	10018d26 	beq	r2,zero,81121f78 <___vfprintf_internal_r+0x1da0>
81121944:	d8802117 	ldw	r2,132(sp)
81121948:	1700062e 	bgeu	r2,fp,81121964 <___vfprintf_internal_r+0x178c>
8112194c:	01000c04 	movi	r4,48
81121950:	10c00044 	addi	r3,r2,1
81121954:	d8c02115 	stw	r3,132(sp)
81121958:	11000005 	stb	r4,0(r2)
8112195c:	d8802117 	ldw	r2,132(sp)
81121960:	173ffb36 	bltu	r2,fp,81121950 <__reset+0xfb101950>
81121964:	1405c83a 	sub	r2,r2,r16
81121968:	d8803315 	stw	r2,204(sp)
8112196c:	008011c4 	movi	r2,71
81121970:	b0817626 	beq	r22,r2,81121f4c <___vfprintf_internal_r+0x1d74>
81121974:	00801944 	movi	r2,101
81121978:	1442810e 	bge	r2,r17,81122380 <___vfprintf_internal_r+0x21a8>
8112197c:	d8c02617 	ldw	r3,152(sp)
81121980:	00801984 	movi	r2,102
81121984:	d8c03215 	stw	r3,200(sp)
81121988:	8881fe26 	beq	r17,r2,81122184 <___vfprintf_internal_r+0x1fac>
8112198c:	d8c03217 	ldw	r3,200(sp)
81121990:	d9003317 	ldw	r4,204(sp)
81121994:	1901dd16 	blt	r3,r4,8112210c <___vfprintf_internal_r+0x1f34>
81121998:	9480004c 	andi	r18,r18,1
8112199c:	90022b1e 	bne	r18,zero,8112224c <___vfprintf_internal_r+0x2074>
811219a0:	1805883a 	mov	r2,r3
811219a4:	18028016 	blt	r3,zero,811223a8 <___vfprintf_internal_r+0x21d0>
811219a8:	d8c03217 	ldw	r3,200(sp)
811219ac:	044019c4 	movi	r17,103
811219b0:	d8c02e15 	stw	r3,184(sp)
811219b4:	df002a07 	ldb	fp,168(sp)
811219b8:	e001531e 	bne	fp,zero,81121f08 <___vfprintf_internal_r+0x1d30>
811219bc:	df002783 	ldbu	fp,158(sp)
811219c0:	d8802a15 	stw	r2,168(sp)
811219c4:	dc802b17 	ldw	r18,172(sp)
811219c8:	d8002915 	stw	zero,164(sp)
811219cc:	003bd106 	br	81120914 <__reset+0xfb100914>
811219d0:	d8802d17 	ldw	r2,180(sp)
811219d4:	d8c02d17 	ldw	r3,180(sp)
811219d8:	d9002d17 	ldw	r4,180(sp)
811219dc:	10800017 	ldw	r2,0(r2)
811219e0:	18c00117 	ldw	r3,4(r3)
811219e4:	21000204 	addi	r4,r4,8
811219e8:	d8803615 	stw	r2,216(sp)
811219ec:	d8c03815 	stw	r3,224(sp)
811219f0:	d9002d15 	stw	r4,180(sp)
811219f4:	003b7506 	br	811207cc <__reset+0xfb1007cc>
811219f8:	ac400007 	ldb	r17,0(r21)
811219fc:	003a5906 	br	81120364 <__reset+0xfb100364>
81121a00:	9080100c 	andi	r2,r18,64
81121a04:	1000a826 	beq	r2,zero,81121ca8 <___vfprintf_internal_r+0x1ad0>
81121a08:	d9002d17 	ldw	r4,180(sp)
81121a0c:	002d883a 	mov	r22,zero
81121a10:	24c0000b 	ldhu	r19,0(r4)
81121a14:	21000104 	addi	r4,r4,4
81121a18:	d9002d15 	stw	r4,180(sp)
81121a1c:	003ccb06 	br	81120d4c <__reset+0xfb100d4c>
81121a20:	d8c02d17 	ldw	r3,180(sp)
81121a24:	d9002917 	ldw	r4,164(sp)
81121a28:	002d883a 	mov	r22,zero
81121a2c:	18800104 	addi	r2,r3,4
81121a30:	1cc00017 	ldw	r19,0(r3)
81121a34:	203ebb0e 	bge	r4,zero,81121524 <__reset+0xfb101524>
81121a38:	003ef106 	br	81121600 <__reset+0xfb101600>
81121a3c:	9080040c 	andi	r2,r18,16
81121a40:	1000921e 	bne	r2,zero,81121c8c <___vfprintf_internal_r+0x1ab4>
81121a44:	9480100c 	andi	r18,r18,64
81121a48:	90013926 	beq	r18,zero,81121f30 <___vfprintf_internal_r+0x1d58>
81121a4c:	d9002d17 	ldw	r4,180(sp)
81121a50:	d9402f17 	ldw	r5,188(sp)
81121a54:	20800017 	ldw	r2,0(r4)
81121a58:	21000104 	addi	r4,r4,4
81121a5c:	d9002d15 	stw	r4,180(sp)
81121a60:	1140000d 	sth	r5,0(r2)
81121a64:	003a1606 	br	811202c0 <__reset+0xfb1002c0>
81121a68:	9080100c 	andi	r2,r18,64
81121a6c:	10008026 	beq	r2,zero,81121c70 <___vfprintf_internal_r+0x1a98>
81121a70:	d8c02d17 	ldw	r3,180(sp)
81121a74:	1cc0000f 	ldh	r19,0(r3)
81121a78:	18c00104 	addi	r3,r3,4
81121a7c:	d8c02d15 	stw	r3,180(sp)
81121a80:	982dd7fa 	srai	r22,r19,31
81121a84:	b005883a 	mov	r2,r22
81121a88:	003b1f06 	br	81120708 <__reset+0xfb100708>
81121a8c:	9080100c 	andi	r2,r18,64
81121a90:	d8002785 	stb	zero,158(sp)
81121a94:	10008a1e 	bne	r2,zero,81121cc0 <___vfprintf_internal_r+0x1ae8>
81121a98:	d9402d17 	ldw	r5,180(sp)
81121a9c:	d8c02917 	ldw	r3,164(sp)
81121aa0:	002d883a 	mov	r22,zero
81121aa4:	28800104 	addi	r2,r5,4
81121aa8:	2cc00017 	ldw	r19,0(r5)
81121aac:	183e4b0e 	bge	r3,zero,811213dc <__reset+0xfb1013dc>
81121ab0:	9d86b03a 	or	r3,r19,r22
81121ab4:	d8802d15 	stw	r2,180(sp)
81121ab8:	183e4c1e 	bne	r3,zero,811213ec <__reset+0xfb1013ec>
81121abc:	0039883a 	mov	fp,zero
81121ac0:	0005883a 	mov	r2,zero
81121ac4:	003d4006 	br	81120fc8 <__reset+0xfb100fc8>
81121ac8:	01604574 	movhi	r5,33045
81121acc:	296e1684 	addi	r5,r5,-18342
81121ad0:	d9402b15 	stw	r5,172(sp)
81121ad4:	d9402b17 	ldw	r5,172(sp)
81121ad8:	1c47883a 	add	r3,r3,r17
81121adc:	10800044 	addi	r2,r2,1
81121ae0:	41400015 	stw	r5,0(r8)
81121ae4:	44400115 	stw	r17,4(r8)
81121ae8:	d8c02015 	stw	r3,128(sp)
81121aec:	d8801f15 	stw	r2,124(sp)
81121af0:	010001c4 	movi	r4,7
81121af4:	20bec816 	blt	r4,r2,81121618 <__reset+0xfb101618>
81121af8:	42000204 	addi	r8,r8,8
81121afc:	003ecd06 	br	81121634 <__reset+0xfb101634>
81121b00:	d9002917 	ldw	r4,164(sp)
81121b04:	d8002785 	stb	zero,158(sp)
81121b08:	203d2d16 	blt	r4,zero,81120fc0 <__reset+0xfb100fc0>
81121b0c:	00bfdfc4 	movi	r2,-129
81121b10:	90a4703a 	and	r18,r18,r2
81121b14:	003a9106 	br	8112055c <__reset+0xfb10055c>
81121b18:	01204574 	movhi	r4,33045
81121b1c:	212e1684 	addi	r4,r4,-18342
81121b20:	d9002b15 	stw	r4,172(sp)
81121b24:	003c0c06 	br	81120b58 <__reset+0xfb100b58>
81121b28:	d9002c17 	ldw	r4,176(sp)
81121b2c:	d9801e04 	addi	r6,sp,120
81121b30:	b80b883a 	mov	r5,r23
81121b34:	112c3c80 	call	8112c3c8 <__sprint_r>
81121b38:	103aab1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121b3c:	d8c02017 	ldw	r3,128(sp)
81121b40:	da000404 	addi	r8,sp,16
81121b44:	003d4106 	br	8112104c <__reset+0xfb10104c>
81121b48:	d8801f17 	ldw	r2,124(sp)
81121b4c:	01604574 	movhi	r5,33045
81121b50:	01000044 	movi	r4,1
81121b54:	18c00044 	addi	r3,r3,1
81121b58:	10800044 	addi	r2,r2,1
81121b5c:	296e0e04 	addi	r5,r5,-18376
81121b60:	41000115 	stw	r4,4(r8)
81121b64:	41400015 	stw	r5,0(r8)
81121b68:	d8c02015 	stw	r3,128(sp)
81121b6c:	d8801f15 	stw	r2,124(sp)
81121b70:	010001c4 	movi	r4,7
81121b74:	20805c16 	blt	r4,r2,81121ce8 <___vfprintf_internal_r+0x1b10>
81121b78:	42000204 	addi	r8,r8,8
81121b7c:	8800041e 	bne	r17,zero,81121b90 <___vfprintf_internal_r+0x19b8>
81121b80:	d8803317 	ldw	r2,204(sp)
81121b84:	1000021e 	bne	r2,zero,81121b90 <___vfprintf_internal_r+0x19b8>
81121b88:	9080004c 	andi	r2,r18,1
81121b8c:	103c0926 	beq	r2,zero,81120bb4 <__reset+0xfb100bb4>
81121b90:	d9003717 	ldw	r4,220(sp)
81121b94:	d8801f17 	ldw	r2,124(sp)
81121b98:	d9403417 	ldw	r5,208(sp)
81121b9c:	20c7883a 	add	r3,r4,r3
81121ba0:	10800044 	addi	r2,r2,1
81121ba4:	41000115 	stw	r4,4(r8)
81121ba8:	41400015 	stw	r5,0(r8)
81121bac:	d8c02015 	stw	r3,128(sp)
81121bb0:	d8801f15 	stw	r2,124(sp)
81121bb4:	010001c4 	movi	r4,7
81121bb8:	20812116 	blt	r4,r2,81122040 <___vfprintf_internal_r+0x1e68>
81121bbc:	42000204 	addi	r8,r8,8
81121bc0:	0463c83a 	sub	r17,zero,r17
81121bc4:	0440730e 	bge	zero,r17,81121d94 <___vfprintf_internal_r+0x1bbc>
81121bc8:	05800404 	movi	r22,16
81121bcc:	b440860e 	bge	r22,r17,81121de8 <___vfprintf_internal_r+0x1c10>
81121bd0:	01604574 	movhi	r5,33045
81121bd4:	296e1684 	addi	r5,r5,-18342
81121bd8:	d9402b15 	stw	r5,172(sp)
81121bdc:	070001c4 	movi	fp,7
81121be0:	dcc02c17 	ldw	r19,176(sp)
81121be4:	00000306 	br	81121bf4 <___vfprintf_internal_r+0x1a1c>
81121be8:	42000204 	addi	r8,r8,8
81121bec:	8c7ffc04 	addi	r17,r17,-16
81121bf0:	b440800e 	bge	r22,r17,81121df4 <___vfprintf_internal_r+0x1c1c>
81121bf4:	18c00404 	addi	r3,r3,16
81121bf8:	10800044 	addi	r2,r2,1
81121bfc:	45000015 	stw	r20,0(r8)
81121c00:	45800115 	stw	r22,4(r8)
81121c04:	d8c02015 	stw	r3,128(sp)
81121c08:	d8801f15 	stw	r2,124(sp)
81121c0c:	e0bff60e 	bge	fp,r2,81121be8 <__reset+0xfb101be8>
81121c10:	d9801e04 	addi	r6,sp,120
81121c14:	b80b883a 	mov	r5,r23
81121c18:	9809883a 	mov	r4,r19
81121c1c:	112c3c80 	call	8112c3c8 <__sprint_r>
81121c20:	103a711e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121c24:	d8c02017 	ldw	r3,128(sp)
81121c28:	d8801f17 	ldw	r2,124(sp)
81121c2c:	da000404 	addi	r8,sp,16
81121c30:	003fee06 	br	81121bec <__reset+0xfb101bec>
81121c34:	00bfffc4 	movi	r2,-1
81121c38:	003a6f06 	br	811205f8 <__reset+0xfb1005f8>
81121c3c:	008011c4 	movi	r2,71
81121c40:	1440b816 	blt	r2,r17,81121f24 <___vfprintf_internal_r+0x1d4c>
81121c44:	04204574 	movhi	r16,33045
81121c48:	842e0004 	addi	r16,r16,-18432
81121c4c:	00c000c4 	movi	r3,3
81121c50:	00bfdfc4 	movi	r2,-129
81121c54:	d8c02a15 	stw	r3,168(sp)
81121c58:	90a4703a 	and	r18,r18,r2
81121c5c:	df002783 	ldbu	fp,158(sp)
81121c60:	d8c02e15 	stw	r3,184(sp)
81121c64:	d8002915 	stw	zero,164(sp)
81121c68:	d8003215 	stw	zero,200(sp)
81121c6c:	003b2906 	br	81120914 <__reset+0xfb100914>
81121c70:	d9002d17 	ldw	r4,180(sp)
81121c74:	24c00017 	ldw	r19,0(r4)
81121c78:	21000104 	addi	r4,r4,4
81121c7c:	d9002d15 	stw	r4,180(sp)
81121c80:	982dd7fa 	srai	r22,r19,31
81121c84:	b005883a 	mov	r2,r22
81121c88:	003a9f06 	br	81120708 <__reset+0xfb100708>
81121c8c:	d9402d17 	ldw	r5,180(sp)
81121c90:	d8c02f17 	ldw	r3,188(sp)
81121c94:	28800017 	ldw	r2,0(r5)
81121c98:	29400104 	addi	r5,r5,4
81121c9c:	d9402d15 	stw	r5,180(sp)
81121ca0:	10c00015 	stw	r3,0(r2)
81121ca4:	00398606 	br	811202c0 <__reset+0xfb1002c0>
81121ca8:	d9402d17 	ldw	r5,180(sp)
81121cac:	002d883a 	mov	r22,zero
81121cb0:	2cc00017 	ldw	r19,0(r5)
81121cb4:	29400104 	addi	r5,r5,4
81121cb8:	d9402d15 	stw	r5,180(sp)
81121cbc:	003c2306 	br	81120d4c <__reset+0xfb100d4c>
81121cc0:	d8c02d17 	ldw	r3,180(sp)
81121cc4:	d9002917 	ldw	r4,164(sp)
81121cc8:	002d883a 	mov	r22,zero
81121ccc:	18800104 	addi	r2,r3,4
81121cd0:	1cc0000b 	ldhu	r19,0(r3)
81121cd4:	203dc10e 	bge	r4,zero,811213dc <__reset+0xfb1013dc>
81121cd8:	003f7506 	br	81121ab0 <__reset+0xfb101ab0>
81121cdc:	04204574 	movhi	r16,33045
81121ce0:	842dfe04 	addi	r16,r16,-18440
81121ce4:	003acc06 	br	81120818 <__reset+0xfb100818>
81121ce8:	d9002c17 	ldw	r4,176(sp)
81121cec:	d9801e04 	addi	r6,sp,120
81121cf0:	b80b883a 	mov	r5,r23
81121cf4:	112c3c80 	call	8112c3c8 <__sprint_r>
81121cf8:	103a3b1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121cfc:	dc402617 	ldw	r17,152(sp)
81121d00:	d8c02017 	ldw	r3,128(sp)
81121d04:	da000404 	addi	r8,sp,16
81121d08:	003f9c06 	br	81121b7c <__reset+0xfb101b7c>
81121d0c:	ac400043 	ldbu	r17,1(r21)
81121d10:	94800814 	ori	r18,r18,32
81121d14:	ad400044 	addi	r21,r21,1
81121d18:	8c403fcc 	andi	r17,r17,255
81121d1c:	8c40201c 	xori	r17,r17,128
81121d20:	8c7fe004 	addi	r17,r17,-128
81121d24:	00398f06 	br	81120364 <__reset+0xfb100364>
81121d28:	d8c02d15 	stw	r3,180(sp)
81121d2c:	0039883a 	mov	fp,zero
81121d30:	003e3506 	br	81121608 <__reset+0xfb101608>
81121d34:	d9002c17 	ldw	r4,176(sp)
81121d38:	d9801e04 	addi	r6,sp,120
81121d3c:	b80b883a 	mov	r5,r23
81121d40:	112c3c80 	call	8112c3c8 <__sprint_r>
81121d44:	103a281e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121d48:	d8c02017 	ldw	r3,128(sp)
81121d4c:	da000404 	addi	r8,sp,16
81121d50:	003cd006 	br	81121094 <__reset+0xfb101094>
81121d54:	8009883a 	mov	r4,r16
81121d58:	da003d15 	stw	r8,244(sp)
81121d5c:	111dcc00 	call	8111dcc0 <strlen>
81121d60:	d8802e15 	stw	r2,184(sp)
81121d64:	da003d17 	ldw	r8,244(sp)
81121d68:	103c340e 	bge	r2,zero,81120e3c <__reset+0xfb100e3c>
81121d6c:	0005883a 	mov	r2,zero
81121d70:	003c3206 	br	81120e3c <__reset+0xfb100e3c>
81121d74:	d9002c17 	ldw	r4,176(sp)
81121d78:	d9801e04 	addi	r6,sp,120
81121d7c:	b80b883a 	mov	r5,r23
81121d80:	112c3c80 	call	8112c3c8 <__sprint_r>
81121d84:	103a181e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121d88:	d8c02017 	ldw	r3,128(sp)
81121d8c:	d8801f17 	ldw	r2,124(sp)
81121d90:	da000404 	addi	r8,sp,16
81121d94:	d9403317 	ldw	r5,204(sp)
81121d98:	10800044 	addi	r2,r2,1
81121d9c:	44000015 	stw	r16,0(r8)
81121da0:	28c7883a 	add	r3,r5,r3
81121da4:	003b7d06 	br	81120b9c <__reset+0xfb100b9c>
81121da8:	01204574 	movhi	r4,33045
81121dac:	212e1a84 	addi	r4,r4,-18326
81121db0:	d9003515 	stw	r4,212(sp)
81121db4:	003b1406 	br	81120a08 <__reset+0xfb100a08>
81121db8:	013fffc4 	movi	r4,-1
81121dbc:	003a3506 	br	81120694 <__reset+0xfb100694>
81121dc0:	0023883a 	mov	r17,zero
81121dc4:	003d9d06 	br	8112143c <__reset+0xfb10143c>
81121dc8:	d9002c17 	ldw	r4,176(sp)
81121dcc:	d9801e04 	addi	r6,sp,120
81121dd0:	b80b883a 	mov	r5,r23
81121dd4:	112c3c80 	call	8112c3c8 <__sprint_r>
81121dd8:	103a031e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121ddc:	d8c02017 	ldw	r3,128(sp)
81121de0:	da000404 	addi	r8,sp,16
81121de4:	003d9406 	br	81121438 <__reset+0xfb101438>
81121de8:	01204574 	movhi	r4,33045
81121dec:	212e1684 	addi	r4,r4,-18342
81121df0:	d9002b15 	stw	r4,172(sp)
81121df4:	d9002b17 	ldw	r4,172(sp)
81121df8:	1c47883a 	add	r3,r3,r17
81121dfc:	10800044 	addi	r2,r2,1
81121e00:	41000015 	stw	r4,0(r8)
81121e04:	44400115 	stw	r17,4(r8)
81121e08:	d8c02015 	stw	r3,128(sp)
81121e0c:	d8801f15 	stw	r2,124(sp)
81121e10:	010001c4 	movi	r4,7
81121e14:	20bfd716 	blt	r4,r2,81121d74 <__reset+0xfb101d74>
81121e18:	42000204 	addi	r8,r8,8
81121e1c:	003fdd06 	br	81121d94 <__reset+0xfb101d94>
81121e20:	d9002c17 	ldw	r4,176(sp)
81121e24:	d9801e04 	addi	r6,sp,120
81121e28:	b80b883a 	mov	r5,r23
81121e2c:	112c3c80 	call	8112c3c8 <__sprint_r>
81121e30:	1039ed1e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121e34:	d8802617 	ldw	r2,152(sp)
81121e38:	d8c02017 	ldw	r3,128(sp)
81121e3c:	da000404 	addi	r8,sp,16
81121e40:	003e1006 	br	81121684 <__reset+0xfb101684>
81121e44:	00800044 	movi	r2,1
81121e48:	10803fcc 	andi	r2,r2,255
81121e4c:	00c00044 	movi	r3,1
81121e50:	10fa3526 	beq	r2,r3,81120728 <__reset+0xfb100728>
81121e54:	00c00084 	movi	r3,2
81121e58:	10fbcb26 	beq	r2,r3,81120d88 <__reset+0xfb100d88>
81121e5c:	003a8f06 	br	8112089c <__reset+0xfb10089c>
81121e60:	01204574 	movhi	r4,33045
81121e64:	212e1a84 	addi	r4,r4,-18326
81121e68:	d9003515 	stw	r4,212(sp)
81121e6c:	003b7606 	br	81120c48 <__reset+0xfb100c48>
81121e70:	d8802917 	ldw	r2,164(sp)
81121e74:	00c00184 	movi	r3,6
81121e78:	1880012e 	bgeu	r3,r2,81121e80 <___vfprintf_internal_r+0x1ca8>
81121e7c:	1805883a 	mov	r2,r3
81121e80:	d8802e15 	stw	r2,184(sp)
81121e84:	1000ef16 	blt	r2,zero,81122244 <___vfprintf_internal_r+0x206c>
81121e88:	04204574 	movhi	r16,33045
81121e8c:	d8802a15 	stw	r2,168(sp)
81121e90:	dcc02d15 	stw	r19,180(sp)
81121e94:	d8002915 	stw	zero,164(sp)
81121e98:	d8003215 	stw	zero,200(sp)
81121e9c:	842e0c04 	addi	r16,r16,-18384
81121ea0:	0039883a 	mov	fp,zero
81121ea4:	003aa206 	br	81120930 <__reset+0xfb100930>
81121ea8:	0021883a 	mov	r16,zero
81121eac:	003e0706 	br	811216cc <__reset+0xfb1016cc>
81121eb0:	d9002c17 	ldw	r4,176(sp)
81121eb4:	d9801e04 	addi	r6,sp,120
81121eb8:	b80b883a 	mov	r5,r23
81121ebc:	112c3c80 	call	8112c3c8 <__sprint_r>
81121ec0:	1039c91e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81121ec4:	d8802617 	ldw	r2,152(sp)
81121ec8:	d9403317 	ldw	r5,204(sp)
81121ecc:	d8c02017 	ldw	r3,128(sp)
81121ed0:	da000404 	addi	r8,sp,16
81121ed4:	2885c83a 	sub	r2,r5,r2
81121ed8:	003dfb06 	br	811216c8 <__reset+0xfb1016c8>
81121edc:	9080004c 	andi	r2,r18,1
81121ee0:	103e8f1e 	bne	r2,zero,81121920 <__reset+0xfb101920>
81121ee4:	d8802117 	ldw	r2,132(sp)
81121ee8:	003e9e06 	br	81121964 <__reset+0xfb101964>
81121eec:	1025883a 	mov	r18,r2
81121ef0:	0039883a 	mov	fp,zero
81121ef4:	00800084 	movi	r2,2
81121ef8:	003fd306 	br	81121e48 <__reset+0xfb101e48>
81121efc:	07000b44 	movi	fp,45
81121f00:	df002785 	stb	fp,158(sp)
81121f04:	003a4006 	br	81120808 <__reset+0xfb100808>
81121f08:	00c00b44 	movi	r3,45
81121f0c:	d8c02785 	stb	r3,158(sp)
81121f10:	d8802a15 	stw	r2,168(sp)
81121f14:	dc802b17 	ldw	r18,172(sp)
81121f18:	d8002915 	stw	zero,164(sp)
81121f1c:	07000b44 	movi	fp,45
81121f20:	003a8006 	br	81120924 <__reset+0xfb100924>
81121f24:	04204574 	movhi	r16,33045
81121f28:	842e0104 	addi	r16,r16,-18428
81121f2c:	003f4706 	br	81121c4c <__reset+0xfb101c4c>
81121f30:	d8c02d17 	ldw	r3,180(sp)
81121f34:	d9002f17 	ldw	r4,188(sp)
81121f38:	18800017 	ldw	r2,0(r3)
81121f3c:	18c00104 	addi	r3,r3,4
81121f40:	d8c02d15 	stw	r3,180(sp)
81121f44:	11000015 	stw	r4,0(r2)
81121f48:	0038dd06 	br	811202c0 <__reset+0xfb1002c0>
81121f4c:	dd802617 	ldw	r22,152(sp)
81121f50:	00bfff44 	movi	r2,-3
81121f54:	b0801c16 	blt	r22,r2,81121fc8 <___vfprintf_internal_r+0x1df0>
81121f58:	d9402917 	ldw	r5,164(sp)
81121f5c:	2d801a16 	blt	r5,r22,81121fc8 <___vfprintf_internal_r+0x1df0>
81121f60:	dd803215 	stw	r22,200(sp)
81121f64:	003e8906 	br	8112198c <__reset+0xfb10198c>
81121f68:	01204574 	movhi	r4,33045
81121f6c:	212e1684 	addi	r4,r4,-18342
81121f70:	d9002b15 	stw	r4,172(sp)
81121f74:	003c9106 	br	811211bc <__reset+0xfb1011bc>
81121f78:	e005883a 	mov	r2,fp
81121f7c:	003e7906 	br	81121964 <__reset+0xfb101964>
81121f80:	d9402917 	ldw	r5,164(sp)
81121f84:	df002783 	ldbu	fp,158(sp)
81121f88:	dcc02d15 	stw	r19,180(sp)
81121f8c:	d9402a15 	stw	r5,168(sp)
81121f90:	d9402e15 	stw	r5,184(sp)
81121f94:	d8002915 	stw	zero,164(sp)
81121f98:	d8003215 	stw	zero,200(sp)
81121f9c:	003a5d06 	br	81120914 <__reset+0xfb100914>
81121fa0:	9080004c 	andi	r2,r18,1
81121fa4:	0039883a 	mov	fp,zero
81121fa8:	10000426 	beq	r2,zero,81121fbc <___vfprintf_internal_r+0x1de4>
81121fac:	00800c04 	movi	r2,48
81121fb0:	dc001dc4 	addi	r16,sp,119
81121fb4:	d8801dc5 	stb	r2,119(sp)
81121fb8:	003b8006 	br	81120dbc <__reset+0xfb100dbc>
81121fbc:	d8002e15 	stw	zero,184(sp)
81121fc0:	dc001e04 	addi	r16,sp,120
81121fc4:	003a4d06 	br	811208fc <__reset+0xfb1008fc>
81121fc8:	8c7fff84 	addi	r17,r17,-2
81121fcc:	b5bfffc4 	addi	r22,r22,-1
81121fd0:	dd802615 	stw	r22,152(sp)
81121fd4:	dc4022c5 	stb	r17,139(sp)
81121fd8:	b000bf16 	blt	r22,zero,811222d8 <___vfprintf_internal_r+0x2100>
81121fdc:	00800ac4 	movi	r2,43
81121fe0:	d8802305 	stb	r2,140(sp)
81121fe4:	00800244 	movi	r2,9
81121fe8:	15807016 	blt	r2,r22,811221ac <___vfprintf_internal_r+0x1fd4>
81121fec:	00800c04 	movi	r2,48
81121ff0:	b5800c04 	addi	r22,r22,48
81121ff4:	d8802345 	stb	r2,141(sp)
81121ff8:	dd802385 	stb	r22,142(sp)
81121ffc:	d88023c4 	addi	r2,sp,143
81122000:	df0022c4 	addi	fp,sp,139
81122004:	d8c03317 	ldw	r3,204(sp)
81122008:	1739c83a 	sub	fp,r2,fp
8112200c:	d9003317 	ldw	r4,204(sp)
81122010:	e0c7883a 	add	r3,fp,r3
81122014:	df003a15 	stw	fp,232(sp)
81122018:	d8c02e15 	stw	r3,184(sp)
8112201c:	00800044 	movi	r2,1
81122020:	1100b30e 	bge	r2,r4,811222f0 <___vfprintf_internal_r+0x2118>
81122024:	d8c02e17 	ldw	r3,184(sp)
81122028:	18c00044 	addi	r3,r3,1
8112202c:	d8c02e15 	stw	r3,184(sp)
81122030:	1805883a 	mov	r2,r3
81122034:	1800ac16 	blt	r3,zero,811222e8 <___vfprintf_internal_r+0x2110>
81122038:	d8003215 	stw	zero,200(sp)
8112203c:	003e5d06 	br	811219b4 <__reset+0xfb1019b4>
81122040:	d9002c17 	ldw	r4,176(sp)
81122044:	d9801e04 	addi	r6,sp,120
81122048:	b80b883a 	mov	r5,r23
8112204c:	112c3c80 	call	8112c3c8 <__sprint_r>
81122050:	1039651e 	bne	r2,zero,811205e8 <__reset+0xfb1005e8>
81122054:	dc402617 	ldw	r17,152(sp)
81122058:	d8c02017 	ldw	r3,128(sp)
8112205c:	d8801f17 	ldw	r2,124(sp)
81122060:	da000404 	addi	r8,sp,16
81122064:	003ed606 	br	81121bc0 <__reset+0xfb101bc0>
81122068:	582b883a 	mov	r21,r11
8112206c:	d8002915 	stw	zero,164(sp)
81122070:	0038bd06 	br	81120368 <__reset+0xfb100368>
81122074:	d8802917 	ldw	r2,164(sp)
81122078:	103e071e 	bne	r2,zero,81121898 <__reset+0xfb101898>
8112207c:	dc002915 	stw	r16,164(sp)
81122080:	003e0506 	br	81121898 <__reset+0xfb101898>
81122084:	d9002917 	ldw	r4,164(sp)
81122088:	20c00044 	addi	r3,r4,1
8112208c:	003e0f06 	br	811218cc <__reset+0xfb1018cc>
81122090:	01400184 	movi	r5,6
81122094:	d9402915 	stw	r5,164(sp)
81122098:	003dff06 	br	81121898 <__reset+0xfb101898>
8112209c:	d8802104 	addi	r2,sp,132
811220a0:	d8800315 	stw	r2,12(sp)
811220a4:	d8802504 	addi	r2,sp,148
811220a8:	d8800215 	stw	r2,8(sp)
811220ac:	d8802604 	addi	r2,sp,152
811220b0:	d8800115 	stw	r2,4(sp)
811220b4:	d8802917 	ldw	r2,164(sp)
811220b8:	d9403617 	ldw	r5,216(sp)
811220bc:	d9002c17 	ldw	r4,176(sp)
811220c0:	d8800015 	stw	r2,0(sp)
811220c4:	01c000c4 	movi	r7,3
811220c8:	980d883a 	mov	r6,r19
811220cc:	da003d15 	stw	r8,244(sp)
811220d0:	11242e40 	call	811242e4 <_dtoa_r>
811220d4:	d8c02917 	ldw	r3,164(sp)
811220d8:	da003d17 	ldw	r8,244(sp)
811220dc:	1021883a 	mov	r16,r2
811220e0:	10f9883a 	add	fp,r2,r3
811220e4:	81000007 	ldb	r4,0(r16)
811220e8:	00800c04 	movi	r2,48
811220ec:	20805e26 	beq	r4,r2,81122268 <___vfprintf_internal_r+0x2090>
811220f0:	d8c02617 	ldw	r3,152(sp)
811220f4:	e0f9883a 	add	fp,fp,r3
811220f8:	003e0a06 	br	81121924 <__reset+0xfb101924>
811220fc:	00c00b44 	movi	r3,45
81122100:	24e0003c 	xorhi	r19,r4,32768
81122104:	d8c02a05 	stb	r3,168(sp)
81122108:	003de906 	br	811218b0 <__reset+0xfb1018b0>
8112210c:	d8c03217 	ldw	r3,200(sp)
81122110:	00c07a0e 	bge	zero,r3,811222fc <___vfprintf_internal_r+0x2124>
81122114:	00800044 	movi	r2,1
81122118:	d9003317 	ldw	r4,204(sp)
8112211c:	1105883a 	add	r2,r2,r4
81122120:	d8802e15 	stw	r2,184(sp)
81122124:	10004e16 	blt	r2,zero,81122260 <___vfprintf_internal_r+0x2088>
81122128:	044019c4 	movi	r17,103
8112212c:	003e2106 	br	811219b4 <__reset+0xfb1019b4>
81122130:	d9002917 	ldw	r4,164(sp)
81122134:	d8802104 	addi	r2,sp,132
81122138:	d8800315 	stw	r2,12(sp)
8112213c:	d9000015 	stw	r4,0(sp)
81122140:	d8802504 	addi	r2,sp,148
81122144:	d9403617 	ldw	r5,216(sp)
81122148:	d9002c17 	ldw	r4,176(sp)
8112214c:	d8800215 	stw	r2,8(sp)
81122150:	d8802604 	addi	r2,sp,152
81122154:	d8800115 	stw	r2,4(sp)
81122158:	01c000c4 	movi	r7,3
8112215c:	980d883a 	mov	r6,r19
81122160:	da003d15 	stw	r8,244(sp)
81122164:	11242e40 	call	811242e4 <_dtoa_r>
81122168:	d8c02917 	ldw	r3,164(sp)
8112216c:	da003d17 	ldw	r8,244(sp)
81122170:	1021883a 	mov	r16,r2
81122174:	00801184 	movi	r2,70
81122178:	80f9883a 	add	fp,r16,r3
8112217c:	88bfd926 	beq	r17,r2,811220e4 <__reset+0xfb1020e4>
81122180:	003de806 	br	81121924 <__reset+0xfb101924>
81122184:	d9002917 	ldw	r4,164(sp)
81122188:	00c04d0e 	bge	zero,r3,811222c0 <___vfprintf_internal_r+0x20e8>
8112218c:	2000441e 	bne	r4,zero,811222a0 <___vfprintf_internal_r+0x20c8>
81122190:	9480004c 	andi	r18,r18,1
81122194:	9000421e 	bne	r18,zero,811222a0 <___vfprintf_internal_r+0x20c8>
81122198:	1805883a 	mov	r2,r3
8112219c:	18007016 	blt	r3,zero,81122360 <___vfprintf_internal_r+0x2188>
811221a0:	d8c03217 	ldw	r3,200(sp)
811221a4:	d8c02e15 	stw	r3,184(sp)
811221a8:	003e0206 	br	811219b4 <__reset+0xfb1019b4>
811221ac:	df0022c4 	addi	fp,sp,139
811221b0:	dc002915 	stw	r16,164(sp)
811221b4:	4027883a 	mov	r19,r8
811221b8:	e021883a 	mov	r16,fp
811221bc:	b009883a 	mov	r4,r22
811221c0:	01400284 	movi	r5,10
811221c4:	112f7400 	call	8112f740 <__modsi3>
811221c8:	10800c04 	addi	r2,r2,48
811221cc:	843fffc4 	addi	r16,r16,-1
811221d0:	b009883a 	mov	r4,r22
811221d4:	01400284 	movi	r5,10
811221d8:	80800005 	stb	r2,0(r16)
811221dc:	112f6bc0 	call	8112f6bc <__divsi3>
811221e0:	102d883a 	mov	r22,r2
811221e4:	00800244 	movi	r2,9
811221e8:	15bff416 	blt	r2,r22,811221bc <__reset+0xfb1021bc>
811221ec:	9811883a 	mov	r8,r19
811221f0:	b0800c04 	addi	r2,r22,48
811221f4:	8027883a 	mov	r19,r16
811221f8:	997fffc4 	addi	r5,r19,-1
811221fc:	98bfffc5 	stb	r2,-1(r19)
81122200:	dc002917 	ldw	r16,164(sp)
81122204:	2f006a2e 	bgeu	r5,fp,811223b0 <___vfprintf_internal_r+0x21d8>
81122208:	d9c02384 	addi	r7,sp,142
8112220c:	3ccfc83a 	sub	r7,r7,r19
81122210:	d9002344 	addi	r4,sp,141
81122214:	e1cf883a 	add	r7,fp,r7
81122218:	00000106 	br	81122220 <___vfprintf_internal_r+0x2048>
8112221c:	28800003 	ldbu	r2,0(r5)
81122220:	20800005 	stb	r2,0(r4)
81122224:	21000044 	addi	r4,r4,1
81122228:	29400044 	addi	r5,r5,1
8112222c:	393ffb1e 	bne	r7,r4,8112221c <__reset+0xfb10221c>
81122230:	d8802304 	addi	r2,sp,140
81122234:	14c5c83a 	sub	r2,r2,r19
81122238:	d8c02344 	addi	r3,sp,141
8112223c:	1885883a 	add	r2,r3,r2
81122240:	003f7006 	br	81122004 <__reset+0xfb102004>
81122244:	0005883a 	mov	r2,zero
81122248:	003f0f06 	br	81121e88 <__reset+0xfb101e88>
8112224c:	d8c03217 	ldw	r3,200(sp)
81122250:	18c00044 	addi	r3,r3,1
81122254:	d8c02e15 	stw	r3,184(sp)
81122258:	1805883a 	mov	r2,r3
8112225c:	183fb20e 	bge	r3,zero,81122128 <__reset+0xfb102128>
81122260:	0005883a 	mov	r2,zero
81122264:	003fb006 	br	81122128 <__reset+0xfb102128>
81122268:	d9003617 	ldw	r4,216(sp)
8112226c:	000d883a 	mov	r6,zero
81122270:	000f883a 	mov	r7,zero
81122274:	980b883a 	mov	r5,r19
81122278:	d8c03c15 	stw	r3,240(sp)
8112227c:	da003d15 	stw	r8,244(sp)
81122280:	1130c100 	call	81130c10 <__eqdf2>
81122284:	d8c03c17 	ldw	r3,240(sp)
81122288:	da003d17 	ldw	r8,244(sp)
8112228c:	103f9826 	beq	r2,zero,811220f0 <__reset+0xfb1020f0>
81122290:	00800044 	movi	r2,1
81122294:	10c7c83a 	sub	r3,r2,r3
81122298:	d8c02615 	stw	r3,152(sp)
8112229c:	003f9506 	br	811220f4 <__reset+0xfb1020f4>
811222a0:	d9002917 	ldw	r4,164(sp)
811222a4:	d8c03217 	ldw	r3,200(sp)
811222a8:	20800044 	addi	r2,r4,1
811222ac:	1885883a 	add	r2,r3,r2
811222b0:	d8802e15 	stw	r2,184(sp)
811222b4:	103dbf0e 	bge	r2,zero,811219b4 <__reset+0xfb1019b4>
811222b8:	0005883a 	mov	r2,zero
811222bc:	003dbd06 	br	811219b4 <__reset+0xfb1019b4>
811222c0:	2000211e 	bne	r4,zero,81122348 <___vfprintf_internal_r+0x2170>
811222c4:	9480004c 	andi	r18,r18,1
811222c8:	90001f1e 	bne	r18,zero,81122348 <___vfprintf_internal_r+0x2170>
811222cc:	00800044 	movi	r2,1
811222d0:	d8802e15 	stw	r2,184(sp)
811222d4:	003db706 	br	811219b4 <__reset+0xfb1019b4>
811222d8:	00800b44 	movi	r2,45
811222dc:	05adc83a 	sub	r22,zero,r22
811222e0:	d8802305 	stb	r2,140(sp)
811222e4:	003f3f06 	br	81121fe4 <__reset+0xfb101fe4>
811222e8:	0005883a 	mov	r2,zero
811222ec:	003f5206 	br	81122038 <__reset+0xfb102038>
811222f0:	90a4703a 	and	r18,r18,r2
811222f4:	903f4e26 	beq	r18,zero,81122030 <__reset+0xfb102030>
811222f8:	003f4a06 	br	81122024 <__reset+0xfb102024>
811222fc:	00800084 	movi	r2,2
81122300:	10c5c83a 	sub	r2,r2,r3
81122304:	003f8406 	br	81122118 <__reset+0xfb102118>
81122308:	d8802d17 	ldw	r2,180(sp)
8112230c:	d9002d17 	ldw	r4,180(sp)
81122310:	ac400043 	ldbu	r17,1(r21)
81122314:	10800017 	ldw	r2,0(r2)
81122318:	582b883a 	mov	r21,r11
8112231c:	d8802915 	stw	r2,164(sp)
81122320:	20800104 	addi	r2,r4,4
81122324:	d9002917 	ldw	r4,164(sp)
81122328:	d8802d15 	stw	r2,180(sp)
8112232c:	203e7a0e 	bge	r4,zero,81121d18 <__reset+0xfb101d18>
81122330:	8c403fcc 	andi	r17,r17,255
81122334:	00bfffc4 	movi	r2,-1
81122338:	8c40201c 	xori	r17,r17,128
8112233c:	d8802915 	stw	r2,164(sp)
81122340:	8c7fe004 	addi	r17,r17,-128
81122344:	00380706 	br	81120364 <__reset+0xfb100364>
81122348:	d8c02917 	ldw	r3,164(sp)
8112234c:	18c00084 	addi	r3,r3,2
81122350:	d8c02e15 	stw	r3,184(sp)
81122354:	1805883a 	mov	r2,r3
81122358:	183d960e 	bge	r3,zero,811219b4 <__reset+0xfb1019b4>
8112235c:	003fd606 	br	811222b8 <__reset+0xfb1022b8>
81122360:	0005883a 	mov	r2,zero
81122364:	003f8e06 	br	811221a0 <__reset+0xfb1021a0>
81122368:	9080004c 	andi	r2,r18,1
8112236c:	103f811e 	bne	r2,zero,81122174 <__reset+0xfb102174>
81122370:	d8802117 	ldw	r2,132(sp)
81122374:	1405c83a 	sub	r2,r2,r16
81122378:	d8803315 	stw	r2,204(sp)
8112237c:	b47ef326 	beq	r22,r17,81121f4c <__reset+0xfb101f4c>
81122380:	dd802617 	ldw	r22,152(sp)
81122384:	003f1106 	br	81121fcc <__reset+0xfb101fcc>
81122388:	d9c02785 	stb	r7,158(sp)
8112238c:	00390406 	br	811207a0 <__reset+0xfb1007a0>
81122390:	d9c02785 	stb	r7,158(sp)
81122394:	0038d306 	br	811206e4 <__reset+0xfb1006e4>
81122398:	d9c02785 	stb	r7,158(sp)
8112239c:	003a6106 	br	81120d24 <__reset+0xfb100d24>
811223a0:	d9c02785 	stb	r7,158(sp)
811223a4:	003af806 	br	81120f88 <__reset+0xfb100f88>
811223a8:	0005883a 	mov	r2,zero
811223ac:	003d7e06 	br	811219a8 <__reset+0xfb1019a8>
811223b0:	d8802344 	addi	r2,sp,141
811223b4:	003f1306 	br	81122004 <__reset+0xfb102004>
811223b8:	d9c02785 	stb	r7,158(sp)
811223bc:	00392306 	br	8112084c <__reset+0xfb10084c>
811223c0:	d9c02785 	stb	r7,158(sp)
811223c4:	003aa906 	br	81120e6c <__reset+0xfb100e6c>
811223c8:	d9c02785 	stb	r7,158(sp)
811223cc:	003a3d06 	br	81120cc4 <__reset+0xfb100cc4>
811223d0:	d9c02785 	stb	r7,158(sp)
811223d4:	003aca06 	br	81120f00 <__reset+0xfb100f00>

811223d8 <__vfprintf_internal>:
811223d8:	00a04574 	movhi	r2,33045
811223dc:	10b7d604 	addi	r2,r2,-8360
811223e0:	300f883a 	mov	r7,r6
811223e4:	280d883a 	mov	r6,r5
811223e8:	200b883a 	mov	r5,r4
811223ec:	11000017 	ldw	r4,0(r2)
811223f0:	11201d81 	jmpi	811201d8 <___vfprintf_internal_r>

811223f4 <__sbprintf>:
811223f4:	defee204 	addi	sp,sp,-1144
811223f8:	de00012e 	bgeu	sp,et,81122400 <__sbprintf+0xc>
811223fc:	003b68fa 	trap	3
81122400:	2880030b 	ldhu	r2,12(r5)
81122404:	2ac01917 	ldw	r11,100(r5)
81122408:	2a80038b 	ldhu	r10,14(r5)
8112240c:	2a400717 	ldw	r9,28(r5)
81122410:	2a000917 	ldw	r8,36(r5)
81122414:	00c10004 	movi	r3,1024
81122418:	dc011a15 	stw	r16,1128(sp)
8112241c:	10bfff4c 	andi	r2,r2,65533
81122420:	2821883a 	mov	r16,r5
81122424:	d8cb883a 	add	r5,sp,r3
81122428:	dc811c15 	stw	r18,1136(sp)
8112242c:	dc411b15 	stw	r17,1132(sp)
81122430:	dfc11d15 	stw	ra,1140(sp)
81122434:	2025883a 	mov	r18,r4
81122438:	d881030d 	sth	r2,1036(sp)
8112243c:	dac11915 	stw	r11,1124(sp)
81122440:	da81038d 	sth	r10,1038(sp)
81122444:	da410715 	stw	r9,1052(sp)
81122448:	da010915 	stw	r8,1060(sp)
8112244c:	dec10015 	stw	sp,1024(sp)
81122450:	dec10415 	stw	sp,1040(sp)
81122454:	d8c10215 	stw	r3,1032(sp)
81122458:	d8c10515 	stw	r3,1044(sp)
8112245c:	d8010615 	stw	zero,1048(sp)
81122460:	11201d80 	call	811201d8 <___vfprintf_internal_r>
81122464:	1023883a 	mov	r17,r2
81122468:	10000416 	blt	r2,zero,8112247c <__sbprintf+0x88>
8112246c:	d9410004 	addi	r5,sp,1024
81122470:	9009883a 	mov	r4,r18
81122474:	1125b980 	call	81125b98 <_fflush_r>
81122478:	10000d1e 	bne	r2,zero,811224b0 <__sbprintf+0xbc>
8112247c:	d881030b 	ldhu	r2,1036(sp)
81122480:	1080100c 	andi	r2,r2,64
81122484:	10000326 	beq	r2,zero,81122494 <__sbprintf+0xa0>
81122488:	8080030b 	ldhu	r2,12(r16)
8112248c:	10801014 	ori	r2,r2,64
81122490:	8080030d 	sth	r2,12(r16)
81122494:	8805883a 	mov	r2,r17
81122498:	dfc11d17 	ldw	ra,1140(sp)
8112249c:	dc811c17 	ldw	r18,1136(sp)
811224a0:	dc411b17 	ldw	r17,1132(sp)
811224a4:	dc011a17 	ldw	r16,1128(sp)
811224a8:	dec11e04 	addi	sp,sp,1144
811224ac:	f800283a 	ret
811224b0:	047fffc4 	movi	r17,-1
811224b4:	003ff106 	br	8112247c <__reset+0xfb10247c>

811224b8 <__svfscanf_r>:
811224b8:	deff4b04 	addi	sp,sp,-724
811224bc:	de00012e 	bgeu	sp,et,811224c4 <__svfscanf_r+0xc>
811224c0:	003b68fa 	trap	3
811224c4:	2880030b 	ldhu	r2,12(r5)
811224c8:	df00b315 	stw	fp,716(sp)
811224cc:	dd80b115 	stw	r22,708(sp)
811224d0:	dfc0b415 	stw	ra,720(sp)
811224d4:	ddc0b215 	stw	r23,712(sp)
811224d8:	dd40b015 	stw	r21,704(sp)
811224dc:	dd00af15 	stw	r20,700(sp)
811224e0:	dcc0ae15 	stw	r19,696(sp)
811224e4:	dc80ad15 	stw	r18,692(sp)
811224e8:	dc40ac15 	stw	r17,688(sp)
811224ec:	dc00ab15 	stw	r16,684(sp)
811224f0:	10c8000c 	andi	r3,r2,8192
811224f4:	d9c09c15 	stw	r7,624(sp)
811224f8:	2839883a 	mov	fp,r5
811224fc:	202d883a 	mov	r22,r4
81122500:	1800061e 	bne	r3,zero,8112251c <__svfscanf_r+0x64>
81122504:	29001917 	ldw	r4,100(r5)
81122508:	00f7ffc4 	movi	r3,-8193
8112250c:	10880014 	ori	r2,r2,8192
81122510:	20c6703a 	and	r3,r4,r3
81122514:	2880030d 	sth	r2,12(r5)
81122518:	28c01915 	stw	r3,100(r5)
8112251c:	30800003 	ldbu	r2,0(r6)
81122520:	0021883a 	mov	r16,zero
81122524:	05e04574 	movhi	r23,33045
81122528:	d800a115 	stw	zero,644(sp)
8112252c:	d8009e15 	stw	zero,632(sp)
81122530:	d800a015 	stw	zero,640(sp)
81122534:	d8809b15 	stw	r2,620(sp)
81122538:	bdf7d404 	addi	r23,r23,-8368
8112253c:	8025883a 	mov	r18,r16
81122540:	35000044 	addi	r20,r6,1
81122544:	10001e26 	beq	r2,zero,811225c0 <__svfscanf_r+0x108>
81122548:	b9c00017 	ldw	r7,0(r23)
8112254c:	3887883a 	add	r3,r7,r2
81122550:	18c00043 	ldbu	r3,1(r3)
81122554:	18c0020c 	andi	r3,r3,8
81122558:	18001b26 	beq	r3,zero,811225c8 <__svfscanf_r+0x110>
8112255c:	e0800117 	ldw	r2,4(fp)
81122560:	00800e0e 	bge	zero,r2,8112259c <__svfscanf_r+0xe4>
81122564:	e0c00017 	ldw	r3,0(fp)
81122568:	b9000017 	ldw	r4,0(r23)
8112256c:	18800003 	ldbu	r2,0(r3)
81122570:	2085883a 	add	r2,r4,r2
81122574:	10800043 	ldbu	r2,1(r2)
81122578:	1080020c 	andi	r2,r2,8
8112257c:	10000b26 	beq	r2,zero,811225ac <__svfscanf_r+0xf4>
81122580:	e0800117 	ldw	r2,4(fp)
81122584:	18c00044 	addi	r3,r3,1
81122588:	e0c00015 	stw	r3,0(fp)
8112258c:	10bfffc4 	addi	r2,r2,-1
81122590:	e0800115 	stw	r2,4(fp)
81122594:	94800044 	addi	r18,r18,1
81122598:	00bff216 	blt	zero,r2,81122564 <__reset+0xfb102564>
8112259c:	e00b883a 	mov	r5,fp
811225a0:	b009883a 	mov	r4,r22
811225a4:	111d7980 	call	8111d798 <__srefill_r>
811225a8:	103fee26 	beq	r2,zero,81122564 <__reset+0xfb102564>
811225ac:	a00d883a 	mov	r6,r20
811225b0:	30800003 	ldbu	r2,0(r6)
811225b4:	35000044 	addi	r20,r6,1
811225b8:	d8809b15 	stw	r2,620(sp)
811225bc:	103fe21e 	bne	r2,zero,81122548 <__reset+0xfb102548>
811225c0:	d880a017 	ldw	r2,640(sp)
811225c4:	00009906 	br	8112282c <__svfscanf_r+0x374>
811225c8:	00c00944 	movi	r3,37
811225cc:	10c0881e 	bne	r2,r3,811227f0 <__svfscanf_r+0x338>
811225d0:	30c00043 	ldbu	r3,1(r6)
811225d4:	0023883a 	mov	r17,zero
811225d8:	0027883a 	mov	r19,zero
811225dc:	01001e04 	movi	r4,120
811225e0:	01401b04 	movi	r5,108
811225e4:	a1800044 	addi	r6,r20,1
811225e8:	20c0a236 	bltu	r4,r3,81122874 <__svfscanf_r+0x3bc>
811225ec:	180490ba 	slli	r2,r3,2
811225f0:	022044b4 	movhi	r8,33042
811225f4:	42098104 	addi	r8,r8,9732
811225f8:	1205883a 	add	r2,r2,r8
811225fc:	10800017 	ldw	r2,0(r2)
81122600:	1000683a 	jmp	r2
81122604:	81122828 	cmpgeui	r4,r16,18592
81122608:	81122874 	orhi	r4,r16,18593
8112260c:	81122874 	orhi	r4,r16,18593
81122610:	81122874 	orhi	r4,r16,18593
81122614:	81122874 	orhi	r4,r16,18593
81122618:	81122874 	orhi	r4,r16,18593
8112261c:	81122874 	orhi	r4,r16,18593
81122620:	81122874 	orhi	r4,r16,18593
81122624:	81122874 	orhi	r4,r16,18593
81122628:	81122874 	orhi	r4,r16,18593
8112262c:	81122874 	orhi	r4,r16,18593
81122630:	81122874 	orhi	r4,r16,18593
81122634:	81122874 	orhi	r4,r16,18593
81122638:	81122874 	orhi	r4,r16,18593
8112263c:	81122874 	orhi	r4,r16,18593
81122640:	81122874 	orhi	r4,r16,18593
81122644:	81122874 	orhi	r4,r16,18593
81122648:	81122874 	orhi	r4,r16,18593
8112264c:	81122874 	orhi	r4,r16,18593
81122650:	81122874 	orhi	r4,r16,18593
81122654:	81122874 	orhi	r4,r16,18593
81122658:	81122874 	orhi	r4,r16,18593
8112265c:	81122874 	orhi	r4,r16,18593
81122660:	81122874 	orhi	r4,r16,18593
81122664:	81122874 	orhi	r4,r16,18593
81122668:	81122874 	orhi	r4,r16,18593
8112266c:	81122874 	orhi	r4,r16,18593
81122670:	81122874 	orhi	r4,r16,18593
81122674:	81122874 	orhi	r4,r16,18593
81122678:	81122874 	orhi	r4,r16,18593
8112267c:	81122874 	orhi	r4,r16,18593
81122680:	81122874 	orhi	r4,r16,18593
81122684:	81122874 	orhi	r4,r16,18593
81122688:	81122874 	orhi	r4,r16,18593
8112268c:	81122874 	orhi	r4,r16,18593
81122690:	81122874 	orhi	r4,r16,18593
81122694:	81122874 	orhi	r4,r16,18593
81122698:	811227e8 	cmpgeui	r4,r16,18591
8112269c:	81122874 	orhi	r4,r16,18593
811226a0:	81122874 	orhi	r4,r16,18593
811226a4:	81122874 	orhi	r4,r16,18593
811226a8:	81122874 	orhi	r4,r16,18593
811226ac:	8112285c 	xori	r4,r16,18593
811226b0:	81122874 	orhi	r4,r16,18593
811226b4:	81122874 	orhi	r4,r16,18593
811226b8:	81122874 	orhi	r4,r16,18593
811226bc:	81122874 	orhi	r4,r16,18593
811226c0:	81122874 	orhi	r4,r16,18593
811226c4:	81122990 	cmplti	r4,r16,18598
811226c8:	81122990 	cmplti	r4,r16,18598
811226cc:	81122990 	cmplti	r4,r16,18598
811226d0:	81122990 	cmplti	r4,r16,18598
811226d4:	81122990 	cmplti	r4,r16,18598
811226d8:	81122990 	cmplti	r4,r16,18598
811226dc:	81122990 	cmplti	r4,r16,18598
811226e0:	81122990 	cmplti	r4,r16,18598
811226e4:	81122990 	cmplti	r4,r16,18598
811226e8:	81122990 	cmplti	r4,r16,18598
811226ec:	81122874 	orhi	r4,r16,18593
811226f0:	81122874 	orhi	r4,r16,18593
811226f4:	81122874 	orhi	r4,r16,18593
811226f8:	81122874 	orhi	r4,r16,18593
811226fc:	81122874 	orhi	r4,r16,18593
81122700:	81122874 	orhi	r4,r16,18593
81122704:	81122874 	orhi	r4,r16,18593
81122708:	81122874 	orhi	r4,r16,18593
8112270c:	81122874 	orhi	r4,r16,18593
81122710:	81122874 	orhi	r4,r16,18593
81122714:	81122964 	muli	r4,r16,18597
81122718:	81122a14 	ori	r4,r16,18600
8112271c:	81122874 	orhi	r4,r16,18593
81122720:	81122a14 	ori	r4,r16,18600
81122724:	81122874 	orhi	r4,r16,18593
81122728:	81122874 	orhi	r4,r16,18593
8112272c:	81122874 	orhi	r4,r16,18593
81122730:	81122874 	orhi	r4,r16,18593
81122734:	81122a00 	call	881122a0 <__reset+0x20f22a0>
81122738:	81122874 	orhi	r4,r16,18593
8112273c:	81122874 	orhi	r4,r16,18593
81122740:	811229d4 	ori	r4,r16,18599
81122744:	81122874 	orhi	r4,r16,18593
81122748:	81122874 	orhi	r4,r16,18593
8112274c:	81122874 	orhi	r4,r16,18593
81122750:	81122874 	orhi	r4,r16,18593
81122754:	81122874 	orhi	r4,r16,18593
81122758:	81122874 	orhi	r4,r16,18593
8112275c:	81122874 	orhi	r4,r16,18593
81122760:	81122874 	orhi	r4,r16,18593
81122764:	811229ac 	andhi	r4,r16,18598
81122768:	81122874 	orhi	r4,r16,18593
8112276c:	81122874 	orhi	r4,r16,18593
81122770:	81122b48 	cmpgei	r4,r16,18605
81122774:	81122874 	orhi	r4,r16,18593
81122778:	81122874 	orhi	r4,r16,18593
8112277c:	81122874 	orhi	r4,r16,18593
81122780:	81122874 	orhi	r4,r16,18593
81122784:	81122874 	orhi	r4,r16,18593
81122788:	81122874 	orhi	r4,r16,18593
8112278c:	81122874 	orhi	r4,r16,18593
81122790:	81122acc 	andi	r4,r16,18603
81122794:	81122aa4 	muli	r4,r16,18602
81122798:	81122a14 	ori	r4,r16,18600
8112279c:	81122a14 	ori	r4,r16,18600
811227a0:	81122a14 	ori	r4,r16,18600
811227a4:	81122a90 	cmplti	r4,r16,18602
811227a8:	81122bd4 	ori	r4,r16,18607
811227ac:	81122874 	orhi	r4,r16,18593
811227b0:	81122874 	orhi	r4,r16,18593
811227b4:	81122a7c 	xorhi	r4,r16,18601
811227b8:	81122874 	orhi	r4,r16,18593
811227bc:	81122a4c 	andi	r4,r16,18601
811227c0:	81122a28 	cmpgeui	r4,r16,18600
811227c4:	81122938 	rdprs	r4,r16,18596
811227c8:	81122874 	orhi	r4,r16,18593
811227cc:	81122874 	orhi	r4,r16,18593
811227d0:	81122924 	muli	r4,r16,18596
811227d4:	81122874 	orhi	r4,r16,18593
811227d8:	811228ac 	andhi	r4,r16,18594
811227dc:	81122874 	orhi	r4,r16,18593
811227e0:	81122874 	orhi	r4,r16,18593
811227e4:	811229ac 	andhi	r4,r16,18598
811227e8:	d9809d15 	stw	r6,628(sp)
811227ec:	3029883a 	mov	r20,r6
811227f0:	e0800117 	ldw	r2,4(fp)
811227f4:	0081aa0e 	bge	zero,r2,81122ea0 <__svfscanf_r+0x9e8>
811227f8:	e0800017 	ldw	r2,0(fp)
811227fc:	a0ffffc3 	ldbu	r3,-1(r20)
81122800:	11000003 	ldbu	r4,0(r2)
81122804:	20ff6e1e 	bne	r4,r3,811225c0 <__reset+0xfb1025c0>
81122808:	e0c00117 	ldw	r3,4(fp)
8112280c:	10800044 	addi	r2,r2,1
81122810:	e0800015 	stw	r2,0(fp)
81122814:	18bfffc4 	addi	r2,r3,-1
81122818:	e0800115 	stw	r2,4(fp)
8112281c:	94800044 	addi	r18,r18,1
81122820:	a00d883a 	mov	r6,r20
81122824:	003f6206 	br	811225b0 <__reset+0xfb1025b0>
81122828:	00bfffc4 	movi	r2,-1
8112282c:	dfc0b417 	ldw	ra,720(sp)
81122830:	df00b317 	ldw	fp,716(sp)
81122834:	ddc0b217 	ldw	r23,712(sp)
81122838:	dd80b117 	ldw	r22,708(sp)
8112283c:	dd40b017 	ldw	r21,704(sp)
81122840:	dd00af17 	ldw	r20,700(sp)
81122844:	dcc0ae17 	ldw	r19,696(sp)
81122848:	dc80ad17 	ldw	r18,692(sp)
8112284c:	dc40ac17 	ldw	r17,688(sp)
81122850:	dc00ab17 	ldw	r16,684(sp)
81122854:	dec0b504 	addi	sp,sp,724
81122858:	f800283a 	ret
8112285c:	a0800043 	ldbu	r2,1(r20)
81122860:	3029883a 	mov	r20,r6
81122864:	8c400414 	ori	r17,r17,16
81122868:	10c03fcc 	andi	r3,r2,255
8112286c:	a1800044 	addi	r6,r20,1
81122870:	20ff5e2e 	bgeu	r4,r3,811225ec <__reset+0xfb1025ec>
81122874:	38c7883a 	add	r3,r7,r3
81122878:	18800043 	ldbu	r2,1(r3)
8112287c:	d9809d15 	stw	r6,628(sp)
81122880:	00c00044 	movi	r3,1
81122884:	108000cc 	andi	r2,r2,3
81122888:	10c18f26 	beq	r2,r3,81122ec8 <__svfscanf_r+0xa10>
8112288c:	e0800117 	ldw	r2,4(fp)
81122890:	00808716 	blt	zero,r2,81122ab0 <__svfscanf_r+0x5f8>
81122894:	e00b883a 	mov	r5,fp
81122898:	b009883a 	mov	r4,r22
8112289c:	111d7980 	call	8111d798 <__srefill_r>
811228a0:	1001431e 	bne	r2,zero,81122db0 <__svfscanf_r+0x8f8>
811228a4:	b9c00017 	ldw	r7,0(r23)
811228a8:	00008106 	br	81122ab0 <__svfscanf_r+0x5f8>
811228ac:	e0800117 	ldw	r2,4(fp)
811228b0:	d9809d15 	stw	r6,628(sp)
811228b4:	0081a30e 	bge	zero,r2,81122f44 <__svfscanf_r+0xa8c>
811228b8:	00a044f4 	movhi	r2,33043
811228bc:	10a9b204 	addi	r2,r2,-22840
811228c0:	02000284 	movi	r8,10
811228c4:	d880a115 	stw	r2,644(sp)
811228c8:	da009e15 	stw	r8,632(sp)
811228cc:	050000c4 	movi	r20,3
811228d0:	e0c00017 	ldw	r3,0(fp)
811228d4:	00000206 	br	811228e0 <__svfscanf_r+0x428>
811228d8:	18c00044 	addi	r3,r3,1
811228dc:	e0c00015 	stw	r3,0(fp)
811228e0:	19000003 	ldbu	r4,0(r3)
811228e4:	20803fcc 	andi	r2,r4,255
811228e8:	3885883a 	add	r2,r7,r2
811228ec:	10800043 	ldbu	r2,1(r2)
811228f0:	1140020c 	andi	r5,r2,8
811228f4:	2801ab26 	beq	r5,zero,81122fa4 <__svfscanf_r+0xaec>
811228f8:	e0800117 	ldw	r2,4(fp)
811228fc:	94800044 	addi	r18,r18,1
81122900:	10bfffc4 	addi	r2,r2,-1
81122904:	e0800115 	stw	r2,4(fp)
81122908:	00bff316 	blt	zero,r2,811228d8 <__reset+0xfb1028d8>
8112290c:	e00b883a 	mov	r5,fp
81122910:	b009883a 	mov	r4,r22
81122914:	111d7980 	call	8111d798 <__srefill_r>
81122918:	1001251e 	bne	r2,zero,81122db0 <__svfscanf_r+0x8f8>
8112291c:	b9c00017 	ldw	r7,0(r23)
81122920:	003feb06 	br	811228d0 <__reset+0xfb1028d0>
81122924:	e0800117 	ldw	r2,4(fp)
81122928:	d9809d15 	stw	r6,628(sp)
8112292c:	00818b0e 	bge	zero,r2,81122f5c <__svfscanf_r+0xaa4>
81122930:	05000084 	movi	r20,2
81122934:	003fe606 	br	811228d0 <__reset+0xfb1028d0>
81122938:	e0800117 	ldw	r2,4(fp)
8112293c:	d9809d15 	stw	r6,628(sp)
81122940:	8c408814 	ori	r17,r17,544
81122944:	00801d0e 	bge	zero,r2,811229bc <__svfscanf_r+0x504>
81122948:	00a044f4 	movhi	r2,33043
8112294c:	10a9b204 	addi	r2,r2,-22840
81122950:	02000404 	movi	r8,16
81122954:	d880a115 	stw	r2,644(sp)
81122958:	da009e15 	stw	r8,632(sp)
8112295c:	050000c4 	movi	r20,3
81122960:	003fdb06 	br	811228d0 <__reset+0xfb1028d0>
81122964:	e0800117 	ldw	r2,4(fp)
81122968:	d9809d15 	stw	r6,628(sp)
8112296c:	8c400054 	ori	r17,r17,1
81122970:	00bfc80e 	bge	zero,r2,81122894 <__reset+0xfb102894>
81122974:	00e044b4 	movhi	r3,33042
81122978:	18f76704 	addi	r3,r3,-8804
8112297c:	02000284 	movi	r8,10
81122980:	d8c0a115 	stw	r3,644(sp)
81122984:	da009e15 	stw	r8,632(sp)
81122988:	050000c4 	movi	r20,3
8112298c:	003fd006 	br	811228d0 <__reset+0xfb1028d0>
81122990:	9cc002a4 	muli	r19,r19,10
81122994:	a0800043 	ldbu	r2,1(r20)
81122998:	3029883a 	mov	r20,r6
8112299c:	98e7883a 	add	r19,r19,r3
811229a0:	9cfff404 	addi	r19,r19,-48
811229a4:	10c03fcc 	andi	r3,r2,255
811229a8:	003f0e06 	br	811225e4 <__reset+0xfb1025e4>
811229ac:	e0800117 	ldw	r2,4(fp)
811229b0:	d9809d15 	stw	r6,628(sp)
811229b4:	8c408014 	ori	r17,r17,512
811229b8:	00bfe316 	blt	zero,r2,81122948 <__reset+0xfb102948>
811229bc:	e00b883a 	mov	r5,fp
811229c0:	b009883a 	mov	r4,r22
811229c4:	111d7980 	call	8111d798 <__srefill_r>
811229c8:	1000f91e 	bne	r2,zero,81122db0 <__svfscanf_r+0x8f8>
811229cc:	b9c00017 	ldw	r7,0(r23)
811229d0:	003fdd06 	br	81122948 <__reset+0xfb102948>
811229d4:	e0800117 	ldw	r2,4(fp)
811229d8:	d9809d15 	stw	r6,628(sp)
811229dc:	8c400054 	ori	r17,r17,1
811229e0:	0080140e 	bge	zero,r2,81122a34 <__svfscanf_r+0x57c>
811229e4:	00a044f4 	movhi	r2,33043
811229e8:	10a9b204 	addi	r2,r2,-22840
811229ec:	02000204 	movi	r8,8
811229f0:	d880a115 	stw	r2,644(sp)
811229f4:	da009e15 	stw	r8,632(sp)
811229f8:	050000c4 	movi	r20,3
811229fc:	003fb406 	br	811228d0 <__reset+0xfb1028d0>
81122a00:	a0800043 	ldbu	r2,1(r20)
81122a04:	8c400094 	ori	r17,r17,2
81122a08:	3029883a 	mov	r20,r6
81122a0c:	10c03fcc 	andi	r3,r2,255
81122a10:	003ef406 	br	811225e4 <__reset+0xfb1025e4>
81122a14:	e0800117 	ldw	r2,4(fp)
81122a18:	d9809d15 	stw	r6,628(sp)
81122a1c:	0081420e 	bge	zero,r2,81122f28 <__svfscanf_r+0xa70>
81122a20:	05000104 	movi	r20,4
81122a24:	003faa06 	br	811228d0 <__reset+0xfb1028d0>
81122a28:	e0800117 	ldw	r2,4(fp)
81122a2c:	d9809d15 	stw	r6,628(sp)
81122a30:	00bfec16 	blt	zero,r2,811229e4 <__reset+0xfb1029e4>
81122a34:	e00b883a 	mov	r5,fp
81122a38:	b009883a 	mov	r4,r22
81122a3c:	111d7980 	call	8111d798 <__srefill_r>
81122a40:	1000db1e 	bne	r2,zero,81122db0 <__svfscanf_r+0x8f8>
81122a44:	b9c00017 	ldw	r7,0(r23)
81122a48:	003fe606 	br	811229e4 <__reset+0xfb1029e4>
81122a4c:	d9809d15 	stw	r6,628(sp)
81122a50:	8880040c 	andi	r2,r17,16
81122a54:	10009c1e 	bne	r2,zero,81122cc8 <__svfscanf_r+0x810>
81122a58:	8880010c 	andi	r2,r17,4
81122a5c:	10011e26 	beq	r2,zero,81122ed8 <__svfscanf_r+0xa20>
81122a60:	da009c17 	ldw	r8,624(sp)
81122a64:	3029883a 	mov	r20,r6
81122a68:	40800017 	ldw	r2,0(r8)
81122a6c:	42000104 	addi	r8,r8,4
81122a70:	da009c15 	stw	r8,624(sp)
81122a74:	1480000d 	sth	r18,0(r2)
81122a78:	003ecc06 	br	811225ac <__reset+0xfb1025ac>
81122a7c:	a0c00043 	ldbu	r3,1(r20)
81122a80:	19410c26 	beq	r3,r5,81122eb4 <__svfscanf_r+0x9fc>
81122a84:	8c400054 	ori	r17,r17,1
81122a88:	3029883a 	mov	r20,r6
81122a8c:	003ed506 	br	811225e4 <__reset+0xfb1025e4>
81122a90:	a0800043 	ldbu	r2,1(r20)
81122a94:	8c400114 	ori	r17,r17,4
81122a98:	3029883a 	mov	r20,r6
81122a9c:	10c03fcc 	andi	r3,r2,255
81122aa0:	003ed006 	br	811225e4 <__reset+0xfb1025e4>
81122aa4:	e0800117 	ldw	r2,4(fp)
81122aa8:	d9809d15 	stw	r6,628(sp)
81122aac:	00bf790e 	bge	zero,r2,81122894 <__reset+0xfb102894>
81122ab0:	00a044b4 	movhi	r2,33042
81122ab4:	10b76704 	addi	r2,r2,-8804
81122ab8:	02000284 	movi	r8,10
81122abc:	d880a115 	stw	r2,644(sp)
81122ac0:	da009e15 	stw	r8,632(sp)
81122ac4:	050000c4 	movi	r20,3
81122ac8:	003f8106 	br	811228d0 <__reset+0xfb1028d0>
81122acc:	e0800117 	ldw	r2,4(fp)
81122ad0:	d9809d15 	stw	r6,628(sp)
81122ad4:	0080c40e 	bge	zero,r2,81122de8 <__svfscanf_r+0x930>
81122ad8:	9800011e 	bne	r19,zero,81122ae0 <__svfscanf_r+0x628>
81122adc:	04c00044 	movi	r19,1
81122ae0:	8880004c 	andi	r2,r17,1
81122ae4:	1000441e 	bne	r2,zero,81122bf8 <__svfscanf_r+0x740>
81122ae8:	8c40040c 	andi	r17,r17,16
81122aec:	8800da26 	beq	r17,zero,81122e58 <__svfscanf_r+0x9a0>
81122af0:	0021883a 	mov	r16,zero
81122af4:	00000806 	br	81122b18 <__svfscanf_r+0x660>
81122af8:	1887883a 	add	r3,r3,r2
81122afc:	e00b883a 	mov	r5,fp
81122b00:	b009883a 	mov	r4,r22
81122b04:	e0c00015 	stw	r3,0(fp)
81122b08:	80a1883a 	add	r16,r16,r2
81122b0c:	98a7c83a 	sub	r19,r19,r2
81122b10:	111d7980 	call	8111d798 <__srefill_r>
81122b14:	1000ca1e 	bne	r2,zero,81122e40 <__svfscanf_r+0x988>
81122b18:	e0800117 	ldw	r2,4(fp)
81122b1c:	e0c00017 	ldw	r3,0(fp)
81122b20:	14fff516 	blt	r2,r19,81122af8 <__reset+0xfb102af8>
81122b24:	14c5c83a 	sub	r2,r2,r19
81122b28:	1cd5883a 	add	r10,r3,r19
81122b2c:	84e1883a 	add	r16,r16,r19
81122b30:	e0800115 	stw	r2,4(fp)
81122b34:	e2800015 	stw	r10,0(fp)
81122b38:	dd009d17 	ldw	r20,628(sp)
81122b3c:	9425883a 	add	r18,r18,r16
81122b40:	a00d883a 	mov	r6,r20
81122b44:	003e9a06 	br	811225b0 <__reset+0xfb1025b0>
81122b48:	300b883a 	mov	r5,r6
81122b4c:	d9005884 	addi	r4,sp,354
81122b50:	d9809d15 	stw	r6,628(sp)
81122b54:	1128aa00 	call	81128aa0 <__sccl>
81122b58:	1029883a 	mov	r20,r2
81122b5c:	e0800117 	ldw	r2,4(fp)
81122b60:	0081050e 	bge	zero,r2,81122f78 <__svfscanf_r+0xac0>
81122b64:	e1000017 	ldw	r4,0(fp)
81122b68:	20800003 	ldbu	r2,0(r4)
81122b6c:	98005926 	beq	r19,zero,81122cd4 <__svfscanf_r+0x81c>
81122b70:	8c40040c 	andi	r17,r17,16
81122b74:	88005a26 	beq	r17,zero,81122ce0 <__svfscanf_r+0x828>
81122b78:	9823883a 	mov	r17,r19
81122b7c:	0021883a 	mov	r16,zero
81122b80:	00000106 	br	81122b88 <__svfscanf_r+0x6d0>
81122b84:	20800003 	ldbu	r2,0(r4)
81122b88:	10803fcc 	andi	r2,r2,255
81122b8c:	d8c05884 	addi	r3,sp,354
81122b90:	1885883a 	add	r2,r3,r2
81122b94:	10800007 	ldb	r2,0(r2)
81122b98:	1000ad26 	beq	r2,zero,81122e50 <__svfscanf_r+0x998>
81122b9c:	e0800117 	ldw	r2,4(fp)
81122ba0:	21000044 	addi	r4,r4,1
81122ba4:	84000044 	addi	r16,r16,1
81122ba8:	10bfffc4 	addi	r2,r2,-1
81122bac:	e0800115 	stw	r2,4(fp)
81122bb0:	e1000015 	stw	r4,0(fp)
81122bb4:	84c0a026 	beq	r16,r19,81122e38 <__svfscanf_r+0x980>
81122bb8:	00bff216 	blt	zero,r2,81122b84 <__reset+0xfb102b84>
81122bbc:	e00b883a 	mov	r5,fp
81122bc0:	b009883a 	mov	r4,r22
81122bc4:	111d7980 	call	8111d798 <__srefill_r>
81122bc8:	10009a1e 	bne	r2,zero,81122e34 <__svfscanf_r+0x97c>
81122bcc:	e1000017 	ldw	r4,0(fp)
81122bd0:	003fec06 	br	81122b84 <__reset+0xfb102b84>
81122bd4:	e0800117 	ldw	r2,4(fp)
81122bd8:	d9809d15 	stw	r6,628(sp)
81122bdc:	0080eb0e 	bge	zero,r2,81122f8c <__svfscanf_r+0xad4>
81122be0:	00a044b4 	movhi	r2,33042
81122be4:	10b76704 	addi	r2,r2,-8804
81122be8:	d880a115 	stw	r2,644(sp)
81122bec:	d8009e15 	stw	zero,632(sp)
81122bf0:	050000c4 	movi	r20,3
81122bf4:	003f3606 	br	811228d0 <__reset+0xfb1028d0>
81122bf8:	dd409904 	addi	r21,sp,612
81122bfc:	8c40040c 	andi	r17,r17,16
81122c00:	01800204 	movi	r6,8
81122c04:	000b883a 	mov	r5,zero
81122c08:	a809883a 	mov	r4,r21
81122c0c:	dc409f15 	stw	r17,636(sp)
81122c10:	111d31c0 	call	8111d31c <memset>
81122c14:	dc409f17 	ldw	r17,636(sp)
81122c18:	88006e26 	beq	r17,zero,81122dd4 <__svfscanf_r+0x91c>
81122c1c:	0029883a 	mov	r20,zero
81122c20:	0023883a 	mov	r17,zero
81122c24:	1126ebc0 	call	81126ebc <__locale_mb_cur_max>
81122c28:	14406126 	beq	r2,r17,81122db0 <__svfscanf_r+0x8f8>
81122c2c:	e0800017 	ldw	r2,0(fp)
81122c30:	e0c00117 	ldw	r3,4(fp)
81122c34:	d9000104 	addi	r4,sp,4
81122c38:	12000003 	ldbu	r8,0(r2)
81122c3c:	18ffffc4 	addi	r3,r3,-1
81122c40:	10800044 	addi	r2,r2,1
81122c44:	e0c00115 	stw	r3,4(fp)
81122c48:	e0800015 	stw	r2,0(fp)
81122c4c:	8c000044 	addi	r16,r17,1
81122c50:	dd400015 	stw	r21,0(sp)
81122c54:	2463883a 	add	r17,r4,r17
81122c58:	200d883a 	mov	r6,r4
81122c5c:	a00b883a 	mov	r5,r20
81122c60:	800f883a 	mov	r7,r16
81122c64:	b009883a 	mov	r4,r22
81122c68:	8a000005 	stb	r8,0(r17)
81122c6c:	1126f780 	call	81126f78 <_mbrtowc_r>
81122c70:	017fffc4 	movi	r5,-1
81122c74:	11404e26 	beq	r2,r5,81122db0 <__svfscanf_r+0x8f8>
81122c78:	1000601e 	bne	r2,zero,81122dfc <__svfscanf_r+0x944>
81122c7c:	da009f17 	ldw	r8,636(sp)
81122c80:	4000641e 	bne	r8,zero,81122e14 <__svfscanf_r+0x95c>
81122c84:	a0000015 	stw	zero,0(r20)
81122c88:	9425883a 	add	r18,r18,r16
81122c8c:	9967883a 	add	r19,r19,r5
81122c90:	a5000104 	addi	r20,r20,4
81122c94:	e0800117 	ldw	r2,4(fp)
81122c98:	0023883a 	mov	r17,zero
81122c9c:	00804b16 	blt	zero,r2,81122dcc <__svfscanf_r+0x914>
81122ca0:	e00b883a 	mov	r5,fp
81122ca4:	b009883a 	mov	r4,r22
81122ca8:	111d7980 	call	8111d798 <__srefill_r>
81122cac:	10004726 	beq	r2,zero,81122dcc <__svfscanf_r+0x914>
81122cb0:	88003f1e 	bne	r17,zero,81122db0 <__svfscanf_r+0x8f8>
81122cb4:	d8c09f17 	ldw	r3,636(sp)
81122cb8:	1800031e 	bne	r3,zero,81122cc8 <__svfscanf_r+0x810>
81122cbc:	da00a017 	ldw	r8,640(sp)
81122cc0:	42000044 	addi	r8,r8,1
81122cc4:	da00a015 	stw	r8,640(sp)
81122cc8:	dd009d17 	ldw	r20,628(sp)
81122ccc:	a00d883a 	mov	r6,r20
81122cd0:	003e3706 	br	811225b0 <__reset+0xfb1025b0>
81122cd4:	8c40040c 	andi	r17,r17,16
81122cd8:	04ffffc4 	movi	r19,-1
81122cdc:	883fa61e 	bne	r17,zero,81122b78 <__reset+0xfb102b78>
81122ce0:	da009c17 	ldw	r8,624(sp)
81122ce4:	9abfffc4 	addi	r10,r19,-1
81122ce8:	44000017 	ldw	r16,0(r8)
81122cec:	44400104 	addi	r17,r8,4
81122cf0:	8007883a 	mov	r3,r16
81122cf4:	82ab883a 	add	r21,r16,r10
81122cf8:	00000306 	br	81122d08 <__svfscanf_r+0x850>
81122cfc:	e1000017 	ldw	r4,0(fp)
81122d00:	9807883a 	mov	r3,r19
81122d04:	20800003 	ldbu	r2,0(r4)
81122d08:	10803fcc 	andi	r2,r2,255
81122d0c:	d9405884 	addi	r5,sp,354
81122d10:	2885883a 	add	r2,r5,r2
81122d14:	10800007 	ldb	r2,0(r2)
81122d18:	10004b26 	beq	r2,zero,81122e48 <__svfscanf_r+0x990>
81122d1c:	e0800117 	ldw	r2,4(fp)
81122d20:	21400044 	addi	r5,r4,1
81122d24:	e1400015 	stw	r5,0(fp)
81122d28:	10bfffc4 	addi	r2,r2,-1
81122d2c:	e0800115 	stw	r2,4(fp)
81122d30:	20800003 	ldbu	r2,0(r4)
81122d34:	1cc00044 	addi	r19,r3,1
81122d38:	18800005 	stb	r2,0(r3)
81122d3c:	1d400726 	beq	r3,r21,81122d5c <__svfscanf_r+0x8a4>
81122d40:	e0800117 	ldw	r2,4(fp)
81122d44:	00bfed16 	blt	zero,r2,81122cfc <__reset+0xfb102cfc>
81122d48:	e00b883a 	mov	r5,fp
81122d4c:	b009883a 	mov	r4,r22
81122d50:	111d7980 	call	8111d798 <__srefill_r>
81122d54:	103fe926 	beq	r2,zero,81122cfc <__reset+0xfb102cfc>
81122d58:	84c01526 	beq	r16,r19,81122db0 <__svfscanf_r+0x8f8>
81122d5c:	9c21c83a 	sub	r16,r19,r16
81122d60:	803e1726 	beq	r16,zero,811225c0 <__reset+0xfb1025c0>
81122d64:	da00a017 	ldw	r8,640(sp)
81122d68:	98000005 	stb	zero,0(r19)
81122d6c:	dc409c15 	stw	r17,624(sp)
81122d70:	42000044 	addi	r8,r8,1
81122d74:	da00a015 	stw	r8,640(sp)
81122d78:	9425883a 	add	r18,r18,r16
81122d7c:	a00d883a 	mov	r6,r20
81122d80:	003e0b06 	br	811225b0 <__reset+0xfb1025b0>
81122d84:	017fff84 	movi	r5,-2
81122d88:	11439b1e 	bne	r2,r5,81123bf8 <__svfscanf_r+0x1740>
81122d8c:	8821883a 	mov	r16,r17
81122d90:	e0800117 	ldw	r2,4(fp)
81122d94:	0082e516 	blt	zero,r2,8112392c <__svfscanf_r+0x1474>
81122d98:	e00b883a 	mov	r5,fp
81122d9c:	b009883a 	mov	r4,r22
81122da0:	111d7980 	call	8111d798 <__srefill_r>
81122da4:	1002e126 	beq	r2,zero,8112392c <__svfscanf_r+0x1474>
81122da8:	dc409f17 	ldw	r17,636(sp)
81122dac:	8002e826 	beq	r16,zero,81123950 <__svfscanf_r+0x1498>
81122db0:	da00a017 	ldw	r8,640(sp)
81122db4:	403e9c26 	beq	r8,zero,81122828 <__reset+0xfb102828>
81122db8:	e080030b 	ldhu	r2,12(fp)
81122dbc:	1080100c 	andi	r2,r2,64
81122dc0:	103e991e 	bne	r2,zero,81122828 <__reset+0xfb102828>
81122dc4:	4005883a 	mov	r2,r8
81122dc8:	003e9806 	br	8112282c <__reset+0xfb10282c>
81122dcc:	983f951e 	bne	r19,zero,81122c24 <__reset+0xfb102c24>
81122dd0:	003fb806 	br	81122cb4 <__reset+0xfb102cb4>
81122dd4:	da009c17 	ldw	r8,624(sp)
81122dd8:	45000017 	ldw	r20,0(r8)
81122ddc:	42000104 	addi	r8,r8,4
81122de0:	da009c15 	stw	r8,624(sp)
81122de4:	003f8e06 	br	81122c20 <__reset+0xfb102c20>
81122de8:	e00b883a 	mov	r5,fp
81122dec:	b009883a 	mov	r4,r22
81122df0:	111d7980 	call	8111d798 <__srefill_r>
81122df4:	103f3826 	beq	r2,zero,81122ad8 <__reset+0xfb102ad8>
81122df8:	003fed06 	br	81122db0 <__reset+0xfb102db0>
81122dfc:	00ffff84 	movi	r3,-2
81122e00:	10c0071e 	bne	r2,r3,81122e20 <__svfscanf_r+0x968>
81122e04:	e0800117 	ldw	r2,4(fp)
81122e08:	8023883a 	mov	r17,r16
81122e0c:	00bf8516 	blt	zero,r2,81122c24 <__reset+0xfb102c24>
81122e10:	003fa306 	br	81122ca0 <__reset+0xfb102ca0>
81122e14:	9425883a 	add	r18,r18,r16
81122e18:	9cffffc4 	addi	r19,r19,-1
81122e1c:	003f9d06 	br	81122c94 <__reset+0xfb102c94>
81122e20:	da009f17 	ldw	r8,636(sp)
81122e24:	9425883a 	add	r18,r18,r16
81122e28:	9cffffc4 	addi	r19,r19,-1
81122e2c:	403f9826 	beq	r8,zero,81122c90 <__reset+0xfb102c90>
81122e30:	003f9806 	br	81122c94 <__reset+0xfb102c94>
81122e34:	8023883a 	mov	r17,r16
81122e38:	8821883a 	mov	r16,r17
81122e3c:	003fce06 	br	81122d78 <__reset+0xfb102d78>
81122e40:	803f3d1e 	bne	r16,zero,81122b38 <__reset+0xfb102b38>
81122e44:	003fda06 	br	81122db0 <__reset+0xfb102db0>
81122e48:	1827883a 	mov	r19,r3
81122e4c:	003fc306 	br	81122d5c <__reset+0xfb102d5c>
81122e50:	803fc91e 	bne	r16,zero,81122d78 <__reset+0xfb102d78>
81122e54:	003dda06 	br	811225c0 <__reset+0xfb1025c0>
81122e58:	da009c17 	ldw	r8,624(sp)
81122e5c:	df000015 	stw	fp,0(sp)
81122e60:	980f883a 	mov	r7,r19
81122e64:	41400017 	ldw	r5,0(r8)
81122e68:	01800044 	movi	r6,1
81122e6c:	b009883a 	mov	r4,r22
81122e70:	11260900 	call	81126090 <_fread_r>
81122e74:	da009c17 	ldw	r8,624(sp)
81122e78:	40c00104 	addi	r3,r8,4
81122e7c:	103fcc26 	beq	r2,zero,81122db0 <__reset+0xfb102db0>
81122e80:	da00a017 	ldw	r8,640(sp)
81122e84:	dd009d17 	ldw	r20,628(sp)
81122e88:	90a5883a 	add	r18,r18,r2
81122e8c:	42000044 	addi	r8,r8,1
81122e90:	da00a015 	stw	r8,640(sp)
81122e94:	d8c09c15 	stw	r3,624(sp)
81122e98:	a00d883a 	mov	r6,r20
81122e9c:	003dc406 	br	811225b0 <__reset+0xfb1025b0>
81122ea0:	e00b883a 	mov	r5,fp
81122ea4:	b009883a 	mov	r4,r22
81122ea8:	111d7980 	call	8111d798 <__srefill_r>
81122eac:	103e5226 	beq	r2,zero,811227f8 <__reset+0xfb1027f8>
81122eb0:	003fbf06 	br	81122db0 <__reset+0xfb102db0>
81122eb4:	a0800083 	ldbu	r2,2(r20)
81122eb8:	8c400094 	ori	r17,r17,2
81122ebc:	a5000084 	addi	r20,r20,2
81122ec0:	10c03fcc 	andi	r3,r2,255
81122ec4:	003dc706 	br	811225e4 <__reset+0xfb1025e4>
81122ec8:	e0800117 	ldw	r2,4(fp)
81122ecc:	88e2b03a 	or	r17,r17,r3
81122ed0:	00bef716 	blt	zero,r2,81122ab0 <__reset+0xfb102ab0>
81122ed4:	003e6f06 	br	81122894 <__reset+0xfb102894>
81122ed8:	8880004c 	andi	r2,r17,1
81122edc:	10000b1e 	bne	r2,zero,81122f0c <__svfscanf_r+0xa54>
81122ee0:	8c40008c 	andi	r17,r17,2
81122ee4:	88000926 	beq	r17,zero,81122f0c <__svfscanf_r+0xa54>
81122ee8:	da009c17 	ldw	r8,624(sp)
81122eec:	9007d7fa 	srai	r3,r18,31
81122ef0:	dd009d17 	ldw	r20,628(sp)
81122ef4:	40800017 	ldw	r2,0(r8)
81122ef8:	42000104 	addi	r8,r8,4
81122efc:	da009c15 	stw	r8,624(sp)
81122f00:	14800015 	stw	r18,0(r2)
81122f04:	10c00115 	stw	r3,4(r2)
81122f08:	003da806 	br	811225ac <__reset+0xfb1025ac>
81122f0c:	da009c17 	ldw	r8,624(sp)
81122f10:	dd009d17 	ldw	r20,628(sp)
81122f14:	40800017 	ldw	r2,0(r8)
81122f18:	42000104 	addi	r8,r8,4
81122f1c:	da009c15 	stw	r8,624(sp)
81122f20:	14800015 	stw	r18,0(r2)
81122f24:	003da106 	br	811225ac <__reset+0xfb1025ac>
81122f28:	e00b883a 	mov	r5,fp
81122f2c:	b009883a 	mov	r4,r22
81122f30:	111d7980 	call	8111d798 <__srefill_r>
81122f34:	103f9e1e 	bne	r2,zero,81122db0 <__reset+0xfb102db0>
81122f38:	b9c00017 	ldw	r7,0(r23)
81122f3c:	05000104 	movi	r20,4
81122f40:	003e6306 	br	811228d0 <__reset+0xfb1028d0>
81122f44:	e00b883a 	mov	r5,fp
81122f48:	b009883a 	mov	r4,r22
81122f4c:	111d7980 	call	8111d798 <__srefill_r>
81122f50:	103f971e 	bne	r2,zero,81122db0 <__reset+0xfb102db0>
81122f54:	b9c00017 	ldw	r7,0(r23)
81122f58:	003e5706 	br	811228b8 <__reset+0xfb1028b8>
81122f5c:	e00b883a 	mov	r5,fp
81122f60:	b009883a 	mov	r4,r22
81122f64:	111d7980 	call	8111d798 <__srefill_r>
81122f68:	103f911e 	bne	r2,zero,81122db0 <__reset+0xfb102db0>
81122f6c:	b9c00017 	ldw	r7,0(r23)
81122f70:	05000084 	movi	r20,2
81122f74:	003e5606 	br	811228d0 <__reset+0xfb1028d0>
81122f78:	e00b883a 	mov	r5,fp
81122f7c:	b009883a 	mov	r4,r22
81122f80:	111d7980 	call	8111d798 <__srefill_r>
81122f84:	103ef726 	beq	r2,zero,81122b64 <__reset+0xfb102b64>
81122f88:	003f8906 	br	81122db0 <__reset+0xfb102db0>
81122f8c:	e00b883a 	mov	r5,fp
81122f90:	b009883a 	mov	r4,r22
81122f94:	111d7980 	call	8111d798 <__srefill_r>
81122f98:	103f851e 	bne	r2,zero,81122db0 <__reset+0xfb102db0>
81122f9c:	b9c00017 	ldw	r7,0(r23)
81122fa0:	003f0f06 	br	81122be0 <__reset+0xfb102be0>
81122fa4:	014000c4 	movi	r5,3
81122fa8:	a1414a26 	beq	r20,r5,811234d4 <__svfscanf_r+0x101c>
81122fac:	01000104 	movi	r4,4
81122fb0:	a101f11e 	bne	r20,r4,81123778 <__svfscanf_r+0x12c0>
81122fb4:	b009883a 	mov	r4,r22
81122fb8:	1126ee00 	call	81126ee0 <_localeconv_r>
81122fbc:	10800017 	ldw	r2,0(r2)
81122fc0:	98ffffc4 	addi	r3,r19,-1
81122fc4:	d880a315 	stw	r2,652(sp)
81122fc8:	00805704 	movi	r2,348
81122fcc:	10c21e2e 	bgeu	r2,r3,81123848 <__svfscanf_r+0x1390>
81122fd0:	9cffa8c4 	addi	r19,r19,-349
81122fd4:	dcc0a215 	stw	r19,648(sp)
81122fd8:	04c05744 	movi	r19,349
81122fdc:	8d01e014 	ori	r20,r17,1920
81122fe0:	0023883a 	mov	r17,zero
81122fe4:	dc000104 	addi	r16,sp,4
81122fe8:	8805883a 	mov	r2,r17
81122fec:	0019883a 	mov	r12,zero
81122ff0:	8023883a 	mov	r17,r16
81122ff4:	b007883a 	mov	r3,r22
81122ff8:	9821883a 	mov	r16,r19
81122ffc:	002b883a 	mov	r21,zero
81123000:	d800a515 	stw	zero,660(sp)
81123004:	d800a415 	stw	zero,656(sp)
81123008:	d8009f15 	stw	zero,636(sp)
8112300c:	01c01384 	movi	r7,78
81123010:	602d883a 	mov	r22,r12
81123014:	1027883a 	mov	r19,r2
81123018:	e1000017 	ldw	r4,0(fp)
8112301c:	21400003 	ldbu	r5,0(r4)
81123020:	28bff544 	addi	r2,r5,-43
81123024:	10803fcc 	andi	r2,r2,255
81123028:	38810e36 	bltu	r7,r2,81123464 <__svfscanf_r+0xfac>
8112302c:	100490ba 	slli	r2,r2,2
81123030:	01a044b4 	movhi	r6,33042
81123034:	318c1104 	addi	r6,r6,12356
81123038:	1185883a 	add	r2,r2,r6
8112303c:	10800017 	ldw	r2,0(r2)
81123040:	1000683a 	jmp	r2
81123044:	8112333c 	xorhi	r4,r16,18636
81123048:	81123464 	muli	r4,r16,18641
8112304c:	8112333c 	xorhi	r4,r16,18636
81123050:	81123464 	muli	r4,r16,18641
81123054:	81123464 	muli	r4,r16,18641
81123058:	81123310 	cmplti	r4,r16,18636
8112305c:	81123180 	call	88112318 <__reset+0x20f2318>
81123060:	81123180 	call	88112318 <__reset+0x20f2318>
81123064:	81123180 	call	88112318 <__reset+0x20f2318>
81123068:	81123180 	call	88112318 <__reset+0x20f2318>
8112306c:	81123180 	call	88112318 <__reset+0x20f2318>
81123070:	81123180 	call	88112318 <__reset+0x20f2318>
81123074:	81123180 	call	88112318 <__reset+0x20f2318>
81123078:	81123180 	call	88112318 <__reset+0x20f2318>
8112307c:	81123180 	call	88112318 <__reset+0x20f2318>
81123080:	81123464 	muli	r4,r16,18641
81123084:	81123464 	muli	r4,r16,18641
81123088:	81123464 	muli	r4,r16,18641
8112308c:	81123464 	muli	r4,r16,18641
81123090:	81123464 	muli	r4,r16,18641
81123094:	81123464 	muli	r4,r16,18641
81123098:	81123464 	muli	r4,r16,18641
8112309c:	81123454 	ori	r4,r16,18641
811230a0:	81123464 	muli	r4,r16,18641
811230a4:	81123464 	muli	r4,r16,18641
811230a8:	81123464 	muli	r4,r16,18641
811230ac:	81123410 	cmplti	r4,r16,18640
811230b0:	811233f4 	orhi	r4,r16,18639
811230b4:	81123464 	muli	r4,r16,18641
811230b8:	81123464 	muli	r4,r16,18641
811230bc:	811233c0 	call	8811233c <__reset+0x20f233c>
811230c0:	81123464 	muli	r4,r16,18641
811230c4:	81123464 	muli	r4,r16,18641
811230c8:	81123464 	muli	r4,r16,18641
811230cc:	81123464 	muli	r4,r16,18641
811230d0:	81123388 	cmpgei	r4,r16,18638
811230d4:	81123464 	muli	r4,r16,18641
811230d8:	81123464 	muli	r4,r16,18641
811230dc:	81123464 	muli	r4,r16,18641
811230e0:	81123464 	muli	r4,r16,18641
811230e4:	81123464 	muli	r4,r16,18641
811230e8:	8112336c 	andhi	r4,r16,18637
811230ec:	81123464 	muli	r4,r16,18641
811230f0:	81123464 	muli	r4,r16,18641
811230f4:	81123464 	muli	r4,r16,18641
811230f8:	81123464 	muli	r4,r16,18641
811230fc:	81123350 	cmplti	r4,r16,18637
81123100:	81123464 	muli	r4,r16,18641
81123104:	81123464 	muli	r4,r16,18641
81123108:	81123464 	muli	r4,r16,18641
8112310c:	81123464 	muli	r4,r16,18641
81123110:	81123464 	muli	r4,r16,18641
81123114:	81123464 	muli	r4,r16,18641
81123118:	81123464 	muli	r4,r16,18641
8112311c:	81123454 	ori	r4,r16,18641
81123120:	81123464 	muli	r4,r16,18641
81123124:	81123464 	muli	r4,r16,18641
81123128:	81123464 	muli	r4,r16,18641
8112312c:	81123410 	cmplti	r4,r16,18640
81123130:	811233f4 	orhi	r4,r16,18639
81123134:	81123464 	muli	r4,r16,18641
81123138:	81123464 	muli	r4,r16,18641
8112313c:	811233c0 	call	8811233c <__reset+0x20f233c>
81123140:	81123464 	muli	r4,r16,18641
81123144:	81123464 	muli	r4,r16,18641
81123148:	81123464 	muli	r4,r16,18641
8112314c:	81123464 	muli	r4,r16,18641
81123150:	81123388 	cmpgei	r4,r16,18638
81123154:	81123464 	muli	r4,r16,18641
81123158:	81123464 	muli	r4,r16,18641
8112315c:	81123464 	muli	r4,r16,18641
81123160:	81123464 	muli	r4,r16,18641
81123164:	81123464 	muli	r4,r16,18641
81123168:	8112336c 	andhi	r4,r16,18637
8112316c:	81123464 	muli	r4,r16,18641
81123170:	81123464 	muli	r4,r16,18641
81123174:	81123464 	muli	r4,r16,18641
81123178:	81123464 	muli	r4,r16,18641
8112317c:	81123350 	cmplti	r4,r16,18637
81123180:	a8803fcc 	andi	r2,r21,255
81123184:	1080201c 	xori	r2,r2,128
81123188:	10bfe004 	addi	r2,r2,-128
8112318c:	b085883a 	add	r2,r22,r2
81123190:	10000d1e 	bne	r2,zero,811231c8 <__svfscanf_r+0xd10>
81123194:	00bf9fc4 	movi	r2,-385
81123198:	a0a8703a 	and	r20,r20,r2
8112319c:	89400005 	stb	r5,0(r17)
811231a0:	8c400044 	addi	r17,r17,1
811231a4:	e0800117 	ldw	r2,4(fp)
811231a8:	843fffc4 	addi	r16,r16,-1
811231ac:	94800044 	addi	r18,r18,1
811231b0:	10bfffc4 	addi	r2,r2,-1
811231b4:	e0800115 	stw	r2,4(fp)
811231b8:	0080b40e 	bge	zero,r2,8112348c <__svfscanf_r+0xfd4>
811231bc:	21000044 	addi	r4,r4,1
811231c0:	e1000015 	stw	r4,0(fp)
811231c4:	803f941e 	bne	r16,zero,81123018 <__reset+0xfb103018>
811231c8:	8821883a 	mov	r16,r17
811231cc:	b019883a 	mov	r12,r22
811231d0:	9823883a 	mov	r17,r19
811231d4:	182d883a 	mov	r22,r3
811231d8:	9801961e 	bne	r19,zero,81123834 <__svfscanf_r+0x137c>
811231dc:	633fffc4 	addi	r12,r12,-1
811231e0:	00800044 	movi	r2,1
811231e4:	1302882e 	bgeu	r2,r12,81123c08 <__svfscanf_r+0x1750>
811231e8:	a8803fcc 	andi	r2,r21,255
811231ec:	1080201c 	xori	r2,r2,128
811231f0:	10bfe004 	addi	r2,r2,-128
811231f4:	113fffc4 	addi	r4,r2,-1
811231f8:	01400184 	movi	r5,6
811231fc:	29001136 	bltu	r5,r4,81123244 <__svfscanf_r+0xd8c>
81123200:	01000084 	movi	r4,2
81123204:	2082900e 	bge	r4,r2,81123c48 <__svfscanf_r+0x1790>
81123208:	00c000c4 	movi	r3,3
8112320c:	10c00d26 	beq	r2,r3,81123244 <__svfscanf_r+0xd8c>
81123210:	9425c83a 	sub	r18,r18,r16
81123214:	1827883a 	mov	r19,r3
81123218:	843fffc4 	addi	r16,r16,-1
8112321c:	81400007 	ldb	r5,0(r16)
81123220:	e00d883a 	mov	r6,fp
81123224:	b009883a 	mov	r4,r22
81123228:	112c1100 	call	8112c110 <_ungetc_r>
8112322c:	a8bfffc4 	addi	r2,r21,-1
81123230:	10c03fcc 	andi	r3,r2,255
81123234:	8493883a 	add	r9,r16,r18
81123238:	102b883a 	mov	r21,r2
8112323c:	98fff636 	bltu	r19,r3,81123218 <__reset+0xfb103218>
81123240:	4825883a 	mov	r18,r9
81123244:	a080400c 	andi	r2,r20,256
81123248:	10001426 	beq	r2,zero,8112329c <__svfscanf_r+0xde4>
8112324c:	a081000c 	andi	r2,r20,1024
81123250:	1002571e 	bne	r2,zero,81123bb0 <__svfscanf_r+0x16f8>
81123254:	817fffc7 	ldb	r5,-1(r16)
81123258:	00801944 	movi	r2,101
8112325c:	84ffffc4 	addi	r19,r16,-1
81123260:	957fffc4 	addi	r21,r18,-1
81123264:	28800826 	beq	r5,r2,81123288 <__svfscanf_r+0xdd0>
81123268:	00801144 	movi	r2,69
8112326c:	28800626 	beq	r5,r2,81123288 <__svfscanf_r+0xdd0>
81123270:	e00d883a 	mov	r6,fp
81123274:	b009883a 	mov	r4,r22
81123278:	112c1100 	call	8112c110 <_ungetc_r>
8112327c:	817fff87 	ldb	r5,-2(r16)
81123280:	84ffff84 	addi	r19,r16,-2
81123284:	957fff84 	addi	r21,r18,-2
81123288:	e00d883a 	mov	r6,fp
8112328c:	b009883a 	mov	r4,r22
81123290:	112c1100 	call	8112c110 <_ungetc_r>
81123294:	a825883a 	mov	r18,r21
81123298:	9821883a 	mov	r16,r19
8112329c:	a080040c 	andi	r2,r20,16
811232a0:	103e891e 	bne	r2,zero,81122cc8 <__reset+0xfb102cc8>
811232a4:	80000005 	stb	zero,0(r16)
811232a8:	a081800c 	andi	r2,r20,1536
811232ac:	01010004 	movi	r4,1024
811232b0:	1101dd26 	beq	r2,r4,81123a28 <__svfscanf_r+0x1570>
811232b4:	da00a417 	ldw	r8,656(sp)
811232b8:	4001e71e 	bne	r8,zero,81123a58 <__svfscanf_r+0x15a0>
811232bc:	000d883a 	mov	r6,zero
811232c0:	d9400104 	addi	r5,sp,4
811232c4:	b009883a 	mov	r4,r22
811232c8:	1128cc00 	call	81128cc0 <_strtod_r>
811232cc:	1021883a 	mov	r16,r2
811232d0:	a080004c 	andi	r2,r20,1
811232d4:	1000021e 	bne	r2,zero,811232e0 <__svfscanf_r+0xe28>
811232d8:	a2c0008c 	andi	r11,r20,2
811232dc:	5801e826 	beq	r11,zero,81123a80 <__svfscanf_r+0x15c8>
811232e0:	da009c17 	ldw	r8,624(sp)
811232e4:	40800017 	ldw	r2,0(r8)
811232e8:	42000104 	addi	r8,r8,4
811232ec:	da009c15 	stw	r8,624(sp)
811232f0:	14000015 	stw	r16,0(r2)
811232f4:	10c00115 	stw	r3,4(r2)
811232f8:	da00a017 	ldw	r8,640(sp)
811232fc:	dd009d17 	ldw	r20,628(sp)
81123300:	42000044 	addi	r8,r8,1
81123304:	da00a015 	stw	r8,640(sp)
81123308:	a00d883a 	mov	r6,r20
8112330c:	003ca806 	br	811225b0 <__reset+0xfb1025b0>
81123310:	a080400c 	andi	r2,r20,256
81123314:	103f9a26 	beq	r2,zero,81123180 <__reset+0xfb103180>
81123318:	da00a217 	ldw	r8,648(sp)
8112331c:	00bfdfc4 	movi	r2,-129
81123320:	a0a8703a 	and	r20,r20,r2
81123324:	9cc00044 	addi	r19,r19,1
81123328:	403f9e26 	beq	r8,zero,811231a4 <__reset+0xfb1031a4>
8112332c:	423fffc4 	addi	r8,r8,-1
81123330:	da00a215 	stw	r8,648(sp)
81123334:	84000044 	addi	r16,r16,1
81123338:	003f9a06 	br	811231a4 <__reset+0xfb1031a4>
8112333c:	a080200c 	andi	r2,r20,128
81123340:	103fa126 	beq	r2,zero,811231c8 <__reset+0xfb1031c8>
81123344:	00bfdfc4 	movi	r2,-129
81123348:	a0a8703a 	and	r20,r20,r2
8112334c:	003f9306 	br	8112319c <__reset+0xfb10319c>
81123350:	a8803fcc 	andi	r2,r21,255
81123354:	1080201c 	xori	r2,r2,128
81123358:	10bfe004 	addi	r2,r2,-128
8112335c:	020001c4 	movi	r8,7
81123360:	123f991e 	bne	r2,r8,811231c8 <__reset+0xfb1031c8>
81123364:	05400204 	movi	r21,8
81123368:	003f8c06 	br	8112319c <__reset+0xfb10319c>
8112336c:	a8803fcc 	andi	r2,r21,255
81123370:	1080201c 	xori	r2,r2,128
81123374:	10bfe004 	addi	r2,r2,-128
81123378:	01800184 	movi	r6,6
8112337c:	11bf921e 	bne	r2,r6,811231c8 <__reset+0xfb1031c8>
81123380:	054001c4 	movi	r21,7
81123384:	003f8506 	br	8112319c <__reset+0xfb10319c>
81123388:	b000491e 	bne	r22,zero,811234b0 <__svfscanf_r+0xff8>
8112338c:	9800031e 	bne	r19,zero,8112339c <__svfscanf_r+0xee4>
81123390:	a081c00c 	andi	r2,r20,1792
81123394:	0181c004 	movi	r6,1792
81123398:	11819f26 	beq	r2,r6,81123a18 <__svfscanf_r+0x1560>
8112339c:	a8803fcc 	andi	r2,r21,255
811233a0:	1080201c 	xori	r2,r2,128
811233a4:	10bfe004 	addi	r2,r2,-128
811233a8:	01800044 	movi	r6,1
811233ac:	11800226 	beq	r2,r6,811233b8 <__svfscanf_r+0xf00>
811233b0:	01800104 	movi	r6,4
811233b4:	11bf841e 	bne	r2,r6,811231c8 <__reset+0xfb1031c8>
811233b8:	ad400044 	addi	r21,r21,1
811233bc:	003f7706 	br	8112319c <__reset+0xfb10319c>
811233c0:	a8803fcc 	andi	r2,r21,255
811233c4:	1080201c 	xori	r2,r2,128
811233c8:	10bfe004 	addi	r2,r2,-128
811233cc:	10003c1e 	bne	r2,zero,811234c0 <__svfscanf_r+0x1008>
811233d0:	9801141e 	bne	r19,zero,81123824 <__svfscanf_r+0x136c>
811233d4:	a081c00c 	andi	r2,r20,1792
811233d8:	0181c004 	movi	r6,1792
811233dc:	11818226 	beq	r2,r6,811239e8 <__svfscanf_r+0x1530>
811233e0:	8821883a 	mov	r16,r17
811233e4:	b019883a 	mov	r12,r22
811233e8:	9823883a 	mov	r17,r19
811233ec:	182d883a 	mov	r22,r3
811233f0:	003f7a06 	br	811231dc <__reset+0xfb1031dc>
811233f4:	a8803fcc 	andi	r2,r21,255
811233f8:	1080201c 	xori	r2,r2,128
811233fc:	10bfe004 	addi	r2,r2,-128
81123400:	01800084 	movi	r6,2
81123404:	11bf701e 	bne	r2,r6,811231c8 <__reset+0xfb1031c8>
81123408:	054000c4 	movi	r21,3
8112340c:	003f6306 	br	8112319c <__reset+0xfb10319c>
81123410:	a081400c 	andi	r2,r20,1280
81123414:	01810004 	movi	r6,1024
81123418:	11800326 	beq	r2,r6,81123428 <__svfscanf_r+0xf70>
8112341c:	a184703a 	and	r2,r20,r6
81123420:	103f6926 	beq	r2,zero,811231c8 <__reset+0xfb1031c8>
81123424:	983fee26 	beq	r19,zero,811233e0 <__reset+0xfb1033e0>
81123428:	a080800c 	andi	r2,r20,512
8112342c:	1000041e 	bne	r2,zero,81123440 <__svfscanf_r+0xf88>
81123430:	da009f17 	ldw	r8,636(sp)
81123434:	dc40a515 	stw	r17,660(sp)
81123438:	9a27c83a 	sub	r19,r19,r8
8112343c:	dcc0a415 	stw	r19,656(sp)
81123440:	00be1fc4 	movi	r2,-1921
81123444:	a0a8703a 	and	r20,r20,r2
81123448:	a5006014 	ori	r20,r20,384
8112344c:	0027883a 	mov	r19,zero
81123450:	003f5206 	br	8112319c <__reset+0xfb10319c>
81123454:	00800044 	movi	r2,1
81123458:	b0bf5b1e 	bne	r22,r2,811231c8 <__reset+0xfb1031c8>
8112345c:	05800084 	movi	r22,2
81123460:	003f4e06 	br	8112319c <__reset+0xfb10319c>
81123464:	d980a317 	ldw	r6,652(sp)
81123468:	30800003 	ldbu	r2,0(r6)
8112346c:	29803fcc 	andi	r6,r5,255
81123470:	30bf551e 	bne	r6,r2,811231c8 <__reset+0xfb1031c8>
81123474:	a080800c 	andi	r2,r20,512
81123478:	103f5326 	beq	r2,zero,811231c8 <__reset+0xfb1031c8>
8112347c:	023f5fc4 	movi	r8,-641
81123480:	a228703a 	and	r20,r20,r8
81123484:	dcc09f15 	stw	r19,636(sp)
81123488:	003f4406 	br	8112319c <__reset+0xfb10319c>
8112348c:	1809883a 	mov	r4,r3
81123490:	e00b883a 	mov	r5,fp
81123494:	d8c0a615 	stw	r3,664(sp)
81123498:	d9c0aa15 	stw	r7,680(sp)
8112349c:	111d7980 	call	8111d798 <__srefill_r>
811234a0:	d8c0a617 	ldw	r3,664(sp)
811234a4:	d9c0aa17 	ldw	r7,680(sp)
811234a8:	103f4626 	beq	r2,zero,811231c4 <__reset+0xfb1031c4>
811234ac:	003f4606 	br	811231c8 <__reset+0xfb1031c8>
811234b0:	00800084 	movi	r2,2
811234b4:	b0bfb91e 	bne	r22,r2,8112339c <__reset+0xfb10339c>
811234b8:	058000c4 	movi	r22,3
811234bc:	003f3706 	br	8112319c <__reset+0xfb10319c>
811234c0:	018000c4 	movi	r6,3
811234c4:	11bfbc26 	beq	r2,r6,811233b8 <__reset+0xfb1033b8>
811234c8:	01800144 	movi	r6,5
811234cc:	11bfba26 	beq	r2,r6,811233b8 <__reset+0xfb1033b8>
811234d0:	003f3d06 	br	811231c8 <__reset+0xfb1031c8>
811234d4:	98bfffc4 	addi	r2,r19,-1
811234d8:	01405704 	movi	r5,348
811234dc:	2880d82e 	bgeu	r5,r2,81123840 <__svfscanf_r+0x1388>
811234e0:	99ffa8c4 	addi	r7,r19,-349
811234e4:	04c05744 	movi	r19,349
811234e8:	8c436014 	ori	r17,r17,3456
811234ec:	9013883a 	mov	r9,r18
811234f0:	8825883a 	mov	r18,r17
811234f4:	dc409e17 	ldw	r17,632(sp)
811234f8:	0029883a 	mov	r20,zero
811234fc:	dc000104 	addi	r16,sp,4
81123500:	05401344 	movi	r21,77
81123504:	02c08004 	movi	r11,512
81123508:	01bf7fc4 	movi	r6,-513
8112350c:	023fdfc4 	movi	r8,-129
81123510:	20bff544 	addi	r2,r4,-43
81123514:	10803fcc 	andi	r2,r2,255
81123518:	a8807236 	bltu	r21,r2,811236e4 <__svfscanf_r+0x122c>
8112351c:	100490ba 	slli	r2,r2,2
81123520:	016044b4 	movhi	r5,33042
81123524:	294d4d04 	addi	r5,r5,13620
81123528:	1145883a 	add	r2,r2,r5
8112352c:	10800017 	ldw	r2,0(r2)
81123530:	1000683a 	jmp	r2
81123534:	81123768 	cmpgeui	r4,r16,18653
81123538:	811236e4 	muli	r4,r16,18651
8112353c:	81123768 	cmpgeui	r4,r16,18653
81123540:	811236e4 	muli	r4,r16,18651
81123544:	811236e4 	muli	r4,r16,18651
81123548:	81123740 	call	88112374 <__reset+0x20f2374>
8112354c:	81123720 	cmpeqi	r4,r16,18652
81123550:	81123720 	cmpeqi	r4,r16,18652
81123554:	81123720 	cmpeqi	r4,r16,18652
81123558:	81123720 	cmpeqi	r4,r16,18652
8112355c:	81123720 	cmpeqi	r4,r16,18652
81123560:	81123720 	cmpeqi	r4,r16,18652
81123564:	81123720 	cmpeqi	r4,r16,18652
81123568:	811236c8 	cmpgei	r4,r16,18651
8112356c:	811236c8 	cmpgei	r4,r16,18651
81123570:	811236e4 	muli	r4,r16,18651
81123574:	811236e4 	muli	r4,r16,18651
81123578:	811236e4 	muli	r4,r16,18651
8112357c:	811236e4 	muli	r4,r16,18651
81123580:	811236e4 	muli	r4,r16,18651
81123584:	811236e4 	muli	r4,r16,18651
81123588:	811236e4 	muli	r4,r16,18651
8112358c:	811236b4 	orhi	r4,r16,18650
81123590:	811236b4 	orhi	r4,r16,18650
81123594:	811236b4 	orhi	r4,r16,18650
81123598:	811236b4 	orhi	r4,r16,18650
8112359c:	811236b4 	orhi	r4,r16,18650
811235a0:	811236b4 	orhi	r4,r16,18650
811235a4:	811236e4 	muli	r4,r16,18651
811235a8:	811236e4 	muli	r4,r16,18651
811235ac:	811236e4 	muli	r4,r16,18651
811235b0:	811236e4 	muli	r4,r16,18651
811235b4:	811236e4 	muli	r4,r16,18651
811235b8:	811236e4 	muli	r4,r16,18651
811235bc:	811236e4 	muli	r4,r16,18651
811235c0:	811236e4 	muli	r4,r16,18651
811235c4:	811236e4 	muli	r4,r16,18651
811235c8:	811236e4 	muli	r4,r16,18651
811235cc:	811236e4 	muli	r4,r16,18651
811235d0:	811236e4 	muli	r4,r16,18651
811235d4:	811236e4 	muli	r4,r16,18651
811235d8:	811236e4 	muli	r4,r16,18651
811235dc:	811236e4 	muli	r4,r16,18651
811235e0:	811236e4 	muli	r4,r16,18651
811235e4:	811236e4 	muli	r4,r16,18651
811235e8:	8112366c 	andhi	r4,r16,18649
811235ec:	811236e4 	muli	r4,r16,18651
811235f0:	811236e4 	muli	r4,r16,18651
811235f4:	811236e4 	muli	r4,r16,18651
811235f8:	811236e4 	muli	r4,r16,18651
811235fc:	811236e4 	muli	r4,r16,18651
81123600:	811236e4 	muli	r4,r16,18651
81123604:	811236e4 	muli	r4,r16,18651
81123608:	811236e4 	muli	r4,r16,18651
8112360c:	811236b4 	orhi	r4,r16,18650
81123610:	811236b4 	orhi	r4,r16,18650
81123614:	811236b4 	orhi	r4,r16,18650
81123618:	811236b4 	orhi	r4,r16,18650
8112361c:	811236b4 	orhi	r4,r16,18650
81123620:	811236b4 	orhi	r4,r16,18650
81123624:	811236e4 	muli	r4,r16,18651
81123628:	811236e4 	muli	r4,r16,18651
8112362c:	811236e4 	muli	r4,r16,18651
81123630:	811236e4 	muli	r4,r16,18651
81123634:	811236e4 	muli	r4,r16,18651
81123638:	811236e4 	muli	r4,r16,18651
8112363c:	811236e4 	muli	r4,r16,18651
81123640:	811236e4 	muli	r4,r16,18651
81123644:	811236e4 	muli	r4,r16,18651
81123648:	811236e4 	muli	r4,r16,18651
8112364c:	811236e4 	muli	r4,r16,18651
81123650:	811236e4 	muli	r4,r16,18651
81123654:	811236e4 	muli	r4,r16,18651
81123658:	811236e4 	muli	r4,r16,18651
8112365c:	811236e4 	muli	r4,r16,18651
81123660:	811236e4 	muli	r4,r16,18651
81123664:	811236e4 	muli	r4,r16,18651
81123668:	8112366c 	andhi	r4,r16,18649
8112366c:	9081800c 	andi	r2,r18,1536
81123670:	12c01c1e 	bne	r2,r11,811236e4 <__svfscanf_r+0x122c>
81123674:	91a4703a 	and	r18,r18,r6
81123678:	94814014 	ori	r18,r18,1280
8112367c:	04400404 	movi	r17,16
81123680:	81000005 	stb	r4,0(r16)
81123684:	84000044 	addi	r16,r16,1
81123688:	e0800117 	ldw	r2,4(fp)
8112368c:	10bfffc4 	addi	r2,r2,-1
81123690:	e0800115 	stw	r2,4(fp)
81123694:	0080540e 	bge	zero,r2,811237e8 <__svfscanf_r+0x1330>
81123698:	18c00044 	addi	r3,r3,1
8112369c:	e0c00015 	stw	r3,0(fp)
811236a0:	9cffffc4 	addi	r19,r19,-1
811236a4:	98000f26 	beq	r19,zero,811236e4 <__svfscanf_r+0x122c>
811236a8:	e0c00017 	ldw	r3,0(fp)
811236ac:	19000003 	ldbu	r4,0(r3)
811236b0:	003f9706 	br	81123510 <__reset+0xfb103510>
811236b4:	00800284 	movi	r2,10
811236b8:	14400a0e 	bge	r2,r17,811236e4 <__svfscanf_r+0x122c>
811236bc:	00bd1fc4 	movi	r2,-2945
811236c0:	90a4703a 	and	r18,r18,r2
811236c4:	003fee06 	br	81123680 <__reset+0xfb103680>
811236c8:	01604574 	movhi	r5,33045
811236cc:	8c63883a 	add	r17,r17,r17
811236d0:	296e2084 	addi	r5,r5,-18302
811236d4:	2c45883a 	add	r2,r5,r17
811236d8:	1440000f 	ldh	r17,0(r2)
811236dc:	00800204 	movi	r2,8
811236e0:	147ff616 	blt	r2,r17,811236bc <__reset+0xfb1036bc>
811236e4:	dc409e15 	stw	r17,632(sp)
811236e8:	9023883a 	mov	r17,r18
811236ec:	8880400c 	andi	r2,r17,256
811236f0:	4825883a 	mov	r18,r9
811236f4:	10000426 	beq	r2,zero,81123708 <__svfscanf_r+0x1250>
811236f8:	d9800104 	addi	r6,sp,4
811236fc:	3400be36 	bltu	r6,r16,811239f8 <__svfscanf_r+0x1540>
81123700:	da000104 	addi	r8,sp,4
81123704:	443bae26 	beq	r8,r16,811225c0 <__reset+0xfb1025c0>
81123708:	8880040c 	andi	r2,r17,16
8112370c:	10009326 	beq	r2,zero,8112395c <__svfscanf_r+0x14a4>
81123710:	d8800104 	addi	r2,sp,4
81123714:	80a1c83a 	sub	r16,r16,r2
81123718:	8521883a 	add	r16,r16,r20
8112371c:	003d0606 	br	81122b38 <__reset+0xfb102b38>
81123720:	01604574 	movhi	r5,33045
81123724:	8c63883a 	add	r17,r17,r17
81123728:	296e2084 	addi	r5,r5,-18302
8112372c:	2c45883a 	add	r2,r5,r17
81123730:	1440000f 	ldh	r17,0(r2)
81123734:	00bd1fc4 	movi	r2,-2945
81123738:	90a4703a 	and	r18,r18,r2
8112373c:	003fd006 	br	81123680 <__reset+0xfb103680>
81123740:	9082000c 	andi	r2,r18,2048
81123744:	103fce26 	beq	r2,zero,81123680 <__reset+0xfb103680>
81123748:	8800021e 	bne	r17,zero,81123754 <__svfscanf_r+0x129c>
8112374c:	94808014 	ori	r18,r18,512
81123750:	04400204 	movi	r17,8
81123754:	9081000c 	andi	r2,r18,1024
81123758:	10009426 	beq	r2,zero,811239ac <__svfscanf_r+0x14f4>
8112375c:	00be9fc4 	movi	r2,-1409
81123760:	90a4703a 	and	r18,r18,r2
81123764:	003fc606 	br	81123680 <__reset+0xfb103680>
81123768:	9080200c 	andi	r2,r18,128
8112376c:	103fdd26 	beq	r2,zero,811236e4 <__reset+0xfb1036e4>
81123770:	9224703a 	and	r18,r18,r8
81123774:	003fc206 	br	81123680 <__reset+0xfb103680>
81123778:	9800011e 	bne	r19,zero,81123780 <__svfscanf_r+0x12c8>
8112377c:	04ffffc4 	movi	r19,-1
81123780:	8900004c 	andi	r4,r17,1
81123784:	20005b1e 	bne	r4,zero,811238f4 <__svfscanf_r+0x143c>
81123788:	8c40040c 	andi	r17,r17,16
8112378c:	88003026 	beq	r17,zero,81123850 <__svfscanf_r+0x1398>
81123790:	0021883a 	mov	r16,zero
81123794:	00000306 	br	811237a4 <__svfscanf_r+0x12ec>
81123798:	18800003 	ldbu	r2,0(r3)
8112379c:	3885883a 	add	r2,r7,r2
811237a0:	10800043 	ldbu	r2,1(r2)
811237a4:	1080020c 	andi	r2,r2,8
811237a8:	103ce31e 	bne	r2,zero,81122b38 <__reset+0xfb102b38>
811237ac:	e0800117 	ldw	r2,4(fp)
811237b0:	18c00044 	addi	r3,r3,1
811237b4:	84000044 	addi	r16,r16,1
811237b8:	10bfffc4 	addi	r2,r2,-1
811237bc:	e0800115 	stw	r2,4(fp)
811237c0:	e0c00015 	stw	r3,0(fp)
811237c4:	84fcdc26 	beq	r16,r19,81122b38 <__reset+0xfb102b38>
811237c8:	00bff316 	blt	zero,r2,81123798 <__reset+0xfb103798>
811237cc:	e00b883a 	mov	r5,fp
811237d0:	b009883a 	mov	r4,r22
811237d4:	111d7980 	call	8111d798 <__srefill_r>
811237d8:	103cd71e 	bne	r2,zero,81122b38 <__reset+0xfb102b38>
811237dc:	b9c00017 	ldw	r7,0(r23)
811237e0:	e0c00017 	ldw	r3,0(fp)
811237e4:	003fec06 	br	81123798 <__reset+0xfb103798>
811237e8:	e00b883a 	mov	r5,fp
811237ec:	b009883a 	mov	r4,r22
811237f0:	d980a715 	stw	r6,668(sp)
811237f4:	d9c0aa15 	stw	r7,680(sp)
811237f8:	da00a815 	stw	r8,672(sp)
811237fc:	da40a915 	stw	r9,676(sp)
81123800:	dac0a615 	stw	r11,664(sp)
81123804:	111d7980 	call	8111d798 <__srefill_r>
81123808:	d980a717 	ldw	r6,668(sp)
8112380c:	d9c0aa17 	ldw	r7,680(sp)
81123810:	da00a817 	ldw	r8,672(sp)
81123814:	da40a917 	ldw	r9,676(sp)
81123818:	dac0a617 	ldw	r11,664(sp)
8112381c:	103fa026 	beq	r2,zero,811236a0 <__reset+0xfb1036a0>
81123820:	003fb006 	br	811236e4 <__reset+0xfb1036e4>
81123824:	8821883a 	mov	r16,r17
81123828:	b019883a 	mov	r12,r22
8112382c:	9823883a 	mov	r17,r19
81123830:	182d883a 	mov	r22,r3
81123834:	00bfbfc4 	movi	r2,-257
81123838:	a0a8703a 	and	r20,r20,r2
8112383c:	003e6706 	br	811231dc <__reset+0xfb1031dc>
81123840:	000f883a 	mov	r7,zero
81123844:	003f2806 	br	811234e8 <__reset+0xfb1034e8>
81123848:	d800a215 	stw	zero,648(sp)
8112384c:	003de306 	br	81122fdc <__reset+0xfb102fdc>
81123850:	da009c17 	ldw	r8,624(sp)
81123854:	9abfffc4 	addi	r10,r19,-1
81123858:	44400017 	ldw	r17,0(r8)
8112385c:	44000104 	addi	r16,r8,4
81123860:	880b883a 	mov	r5,r17
81123864:	8aa9883a 	add	r20,r17,r10
81123868:	00000606 	br	81123884 <__svfscanf_r+0x13cc>
8112386c:	e0c00017 	ldw	r3,0(fp)
81123870:	b9000017 	ldw	r4,0(r23)
81123874:	a80b883a 	mov	r5,r21
81123878:	18800003 	ldbu	r2,0(r3)
8112387c:	2085883a 	add	r2,r4,r2
81123880:	10800043 	ldbu	r2,1(r2)
81123884:	1080020c 	andi	r2,r2,8
81123888:	1000551e 	bne	r2,zero,811239e0 <__svfscanf_r+0x1528>
8112388c:	e0800117 	ldw	r2,4(fp)
81123890:	19000044 	addi	r4,r3,1
81123894:	e1000015 	stw	r4,0(fp)
81123898:	10bfffc4 	addi	r2,r2,-1
8112389c:	e0800115 	stw	r2,4(fp)
811238a0:	18800003 	ldbu	r2,0(r3)
811238a4:	2d400044 	addi	r21,r5,1
811238a8:	a827883a 	mov	r19,r21
811238ac:	28800005 	stb	r2,0(r5)
811238b0:	2d000626 	beq	r5,r20,811238cc <__svfscanf_r+0x1414>
811238b4:	e0800117 	ldw	r2,4(fp)
811238b8:	00bfec16 	blt	zero,r2,8112386c <__reset+0xfb10386c>
811238bc:	e00b883a 	mov	r5,fp
811238c0:	b009883a 	mov	r4,r22
811238c4:	111d7980 	call	8111d798 <__srefill_r>
811238c8:	103fe826 	beq	r2,zero,8112386c <__reset+0xfb10386c>
811238cc:	da00a017 	ldw	r8,640(sp)
811238d0:	dd009d17 	ldw	r20,628(sp)
811238d4:	9c63c83a 	sub	r17,r19,r17
811238d8:	42000044 	addi	r8,r8,1
811238dc:	98000005 	stb	zero,0(r19)
811238e0:	9465883a 	add	r18,r18,r17
811238e4:	da00a015 	stw	r8,640(sp)
811238e8:	dc009c15 	stw	r16,624(sp)
811238ec:	a00d883a 	mov	r6,r20
811238f0:	003b2f06 	br	811225b0 <__reset+0xfb1025b0>
811238f4:	dd409904 	addi	r21,sp,612
811238f8:	8c40040c 	andi	r17,r17,16
811238fc:	01800204 	movi	r6,8
81123900:	000b883a 	mov	r5,zero
81123904:	a809883a 	mov	r4,r21
81123908:	111d31c0 	call	8111d31c <memset>
8112390c:	8800401e 	bne	r17,zero,81123a10 <__svfscanf_r+0x1558>
81123910:	da009c17 	ldw	r8,624(sp)
81123914:	45000017 	ldw	r20,0(r8)
81123918:	42000104 	addi	r8,r8,4
8112391c:	da009c15 	stw	r8,624(sp)
81123920:	000d883a 	mov	r6,zero
81123924:	3021883a 	mov	r16,r6
81123928:	dc409f15 	stw	r17,636(sp)
8112392c:	e0800017 	ldw	r2,0(fp)
81123930:	b8c00017 	ldw	r3,0(r23)
81123934:	10800003 	ldbu	r2,0(r2)
81123938:	1885883a 	add	r2,r3,r2
8112393c:	10800043 	ldbu	r2,1(r2)
81123940:	1080020c 	andi	r2,r2,8
81123944:	1000011e 	bne	r2,zero,8112394c <__svfscanf_r+0x1494>
81123948:	9800701e 	bne	r19,zero,81123b0c <__svfscanf_r+0x1654>
8112394c:	dc409f17 	ldw	r17,636(sp)
81123950:	883cdd1e 	bne	r17,zero,81122cc8 <__reset+0xfb102cc8>
81123954:	a0000015 	stw	zero,0(r20)
81123958:	003cd806 	br	81122cbc <__reset+0xfb102cbc>
8112395c:	d9c09e17 	ldw	r7,632(sp)
81123960:	da00a117 	ldw	r8,644(sp)
81123964:	000d883a 	mov	r6,zero
81123968:	d9400104 	addi	r5,sp,4
8112396c:	b009883a 	mov	r4,r22
81123970:	80000005 	stb	zero,0(r16)
81123974:	403ee83a 	callr	r8
81123978:	88c0080c 	andi	r3,r17,32
8112397c:	1800121e 	bne	r3,zero,811239c8 <__svfscanf_r+0x1510>
81123980:	88c0010c 	andi	r3,r17,4
81123984:	18004d26 	beq	r3,zero,81123abc <__svfscanf_r+0x1604>
81123988:	da009c17 	ldw	r8,624(sp)
8112398c:	40c00017 	ldw	r3,0(r8)
81123990:	42000104 	addi	r8,r8,4
81123994:	da009c15 	stw	r8,624(sp)
81123998:	1880000d 	sth	r2,0(r3)
8112399c:	da00a017 	ldw	r8,640(sp)
811239a0:	42000044 	addi	r8,r8,1
811239a4:	da00a015 	stw	r8,640(sp)
811239a8:	003f5906 	br	81123710 <__reset+0xfb103710>
811239ac:	00bf1fc4 	movi	r2,-897
811239b0:	90a4703a 	and	r18,r18,r2
811239b4:	38000226 	beq	r7,zero,811239c0 <__svfscanf_r+0x1508>
811239b8:	39ffffc4 	addi	r7,r7,-1
811239bc:	9cc00044 	addi	r19,r19,1
811239c0:	a5000044 	addi	r20,r20,1
811239c4:	003f3006 	br	81123688 <__reset+0xfb103688>
811239c8:	da009c17 	ldw	r8,624(sp)
811239cc:	40c00017 	ldw	r3,0(r8)
811239d0:	42000104 	addi	r8,r8,4
811239d4:	da009c15 	stw	r8,624(sp)
811239d8:	18800015 	stw	r2,0(r3)
811239dc:	003fef06 	br	8112399c <__reset+0xfb10399c>
811239e0:	2827883a 	mov	r19,r5
811239e4:	003fb906 	br	811238cc <__reset+0xfb1038cc>
811239e8:	01be1fc4 	movi	r6,-1921
811239ec:	a1a8703a 	and	r20,r20,r6
811239f0:	05400044 	movi	r21,1
811239f4:	003de906 	br	8112319c <__reset+0xfb10319c>
811239f8:	817fffc7 	ldb	r5,-1(r16)
811239fc:	e00d883a 	mov	r6,fp
81123a00:	b009883a 	mov	r4,r22
81123a04:	843fffc4 	addi	r16,r16,-1
81123a08:	112c1100 	call	8112c110 <_ungetc_r>
81123a0c:	003f3c06 	br	81123700 <__reset+0xfb103700>
81123a10:	dd009b04 	addi	r20,sp,620
81123a14:	003fc206 	br	81123920 <__reset+0xfb103920>
81123a18:	00be1fc4 	movi	r2,-1921
81123a1c:	a0a8703a 	and	r20,r20,r2
81123a20:	05800044 	movi	r22,1
81123a24:	003ddd06 	br	8112319c <__reset+0xfb10319c>
81123a28:	d8c09f17 	ldw	r3,636(sp)
81123a2c:	88e3c83a 	sub	r17,r17,r3
81123a30:	044dc83a 	sub	r6,zero,r17
81123a34:	883e2126 	beq	r17,zero,811232bc <__reset+0xfb1032bc>
81123a38:	d88055c4 	addi	r2,sp,343
81123a3c:	80800136 	bltu	r16,r2,81123a44 <__svfscanf_r+0x158c>
81123a40:	dc005584 	addi	r16,sp,342
81123a44:	01604574 	movhi	r5,33045
81123a48:	296e1f04 	addi	r5,r5,-18308
81123a4c:	8009883a 	mov	r4,r16
81123a50:	111daac0 	call	8111daac <sprintf>
81123a54:	003e1906 	br	811232bc <__reset+0xfb1032bc>
81123a58:	d8c0a517 	ldw	r3,660(sp)
81123a5c:	000d883a 	mov	r6,zero
81123a60:	01c00284 	movi	r7,10
81123a64:	19400044 	addi	r5,r3,1
81123a68:	b009883a 	mov	r4,r22
81123a6c:	111dd9c0 	call	8111dd9c <_strtol_r>
81123a70:	da00a417 	ldw	r8,656(sp)
81123a74:	dc00a517 	ldw	r16,660(sp)
81123a78:	120dc83a 	sub	r6,r2,r8
81123a7c:	003fee06 	br	81123a38 <__reset+0xfb103a38>
81123a80:	da009c17 	ldw	r8,624(sp)
81123a84:	180b883a 	mov	r5,r3
81123a88:	8009883a 	mov	r4,r16
81123a8c:	45000017 	ldw	r20,0(r8)
81123a90:	44400104 	addi	r17,r8,4
81123a94:	d8c0a615 	stw	r3,664(sp)
81123a98:	1128a2c0 	call	81128a2c <__fpclassifyd>
81123a9c:	d8c0a617 	ldw	r3,664(sp)
81123aa0:	10006426 	beq	r2,zero,81123c34 <__svfscanf_r+0x177c>
81123aa4:	8009883a 	mov	r4,r16
81123aa8:	180b883a 	mov	r5,r3
81123aac:	111bdb40 	call	8111bdb4 <__truncdfsf2>
81123ab0:	a0800015 	stw	r2,0(r20)
81123ab4:	dc409c15 	stw	r17,624(sp)
81123ab8:	003e0f06 	br	811232f8 <__reset+0xfb1032f8>
81123abc:	88c0004c 	andi	r3,r17,1
81123ac0:	183fc11e 	bne	r3,zero,811239c8 <__reset+0xfb1039c8>
81123ac4:	8c40008c 	andi	r17,r17,2
81123ac8:	883fbf26 	beq	r17,zero,811239c8 <__reset+0xfb1039c8>
81123acc:	da00a117 	ldw	r8,644(sp)
81123ad0:	00a044f4 	movhi	r2,33043
81123ad4:	10a9b204 	addi	r2,r2,-22840
81123ad8:	d9c09e17 	ldw	r7,632(sp)
81123adc:	000d883a 	mov	r6,zero
81123ae0:	d9400104 	addi	r5,sp,4
81123ae4:	b009883a 	mov	r4,r22
81123ae8:	40806226 	beq	r8,r2,81123c74 <__svfscanf_r+0x17bc>
81123aec:	112a3e00 	call	8112a3e0 <_strtoll_r>
81123af0:	da009c17 	ldw	r8,624(sp)
81123af4:	41000017 	ldw	r4,0(r8)
81123af8:	42000104 	addi	r8,r8,4
81123afc:	da009c15 	stw	r8,624(sp)
81123b00:	20800015 	stw	r2,0(r4)
81123b04:	20c00115 	stw	r3,4(r4)
81123b08:	003fa406 	br	8112399c <__reset+0xfb10399c>
81123b0c:	1126ebc0 	call	81126ebc <__locale_mb_cur_max>
81123b10:	80bca726 	beq	r16,r2,81122db0 <__reset+0xfb102db0>
81123b14:	e0800017 	ldw	r2,0(fp)
81123b18:	e1000117 	ldw	r4,4(fp)
81123b1c:	d8c00104 	addi	r3,sp,4
81123b20:	12000003 	ldbu	r8,0(r2)
81123b24:	213fffc4 	addi	r4,r4,-1
81123b28:	10800044 	addi	r2,r2,1
81123b2c:	e1000115 	stw	r4,4(fp)
81123b30:	e0800015 	stw	r2,0(fp)
81123b34:	84400044 	addi	r17,r16,1
81123b38:	dd400015 	stw	r21,0(sp)
81123b3c:	1c21883a 	add	r16,r3,r16
81123b40:	b009883a 	mov	r4,r22
81123b44:	880f883a 	mov	r7,r17
81123b48:	180d883a 	mov	r6,r3
81123b4c:	a00b883a 	mov	r5,r20
81123b50:	82000005 	stb	r8,0(r16)
81123b54:	1126f780 	call	81126f78 <_mbrtowc_r>
81123b58:	013fffc4 	movi	r4,-1
81123b5c:	113c9426 	beq	r2,r4,81122db0 <__reset+0xfb102db0>
81123b60:	103c881e 	bne	r2,zero,81122d84 <__reset+0xfb102d84>
81123b64:	a0000015 	stw	zero,0(r20)
81123b68:	0009883a 	mov	r4,zero
81123b6c:	1126dfc0 	call	81126dfc <iswspace>
81123b70:	10001a26 	beq	r2,zero,81123bdc <__svfscanf_r+0x1724>
81123b74:	8821883a 	mov	r16,r17
81123b78:	dc409f17 	ldw	r17,636(sp)
81123b7c:	803f7426 	beq	r16,zero,81123950 <__reset+0xfb103950>
81123b80:	843fffc4 	addi	r16,r16,-1
81123b84:	d9800104 	addi	r6,sp,4
81123b88:	342b883a 	add	r21,r6,r16
81123b8c:	00000106 	br	81123b94 <__svfscanf_r+0x16dc>
81123b90:	843fffc4 	addi	r16,r16,-1
81123b94:	a9400003 	ldbu	r5,0(r21)
81123b98:	e00d883a 	mov	r6,fp
81123b9c:	b009883a 	mov	r4,r22
81123ba0:	112c1100 	call	8112c110 <_ungetc_r>
81123ba4:	ad7fffc4 	addi	r21,r21,-1
81123ba8:	803ff91e 	bne	r16,zero,81123b90 <__reset+0xfb103b90>
81123bac:	003f6806 	br	81123950 <__reset+0xfb103950>
81123bb0:	d9800104 	addi	r6,sp,4
81123bb4:	802b883a 	mov	r21,r16
81123bb8:	343a812e 	bgeu	r6,r16,811225c0 <__reset+0xfb1025c0>
81123bbc:	ad7fffc4 	addi	r21,r21,-1
81123bc0:	a9400007 	ldb	r5,0(r21)
81123bc4:	e00d883a 	mov	r6,fp
81123bc8:	b009883a 	mov	r4,r22
81123bcc:	112c1100 	call	8112c110 <_ungetc_r>
81123bd0:	da000104 	addi	r8,sp,4
81123bd4:	457ff91e 	bne	r8,r21,81123bbc <__reset+0xfb103bbc>
81123bd8:	003a7906 	br	811225c0 <__reset+0xfb1025c0>
81123bdc:	da009f17 	ldw	r8,636(sp)
81123be0:	9465883a 	add	r18,r18,r17
81123be4:	9cffffc4 	addi	r19,r19,-1
81123be8:	4000051e 	bne	r8,zero,81123c00 <__svfscanf_r+0x1748>
81123bec:	a5000104 	addi	r20,r20,4
81123bf0:	0021883a 	mov	r16,zero
81123bf4:	003c6606 	br	81122d90 <__reset+0xfb102d90>
81123bf8:	a1000017 	ldw	r4,0(r20)
81123bfc:	003fdb06 	br	81123b6c <__reset+0xfb103b6c>
81123c00:	0021883a 	mov	r16,zero
81123c04:	003c6206 	br	81122d90 <__reset+0xfb102d90>
81123c08:	d8800104 	addi	r2,sp,4
81123c0c:	802b883a 	mov	r21,r16
81123c10:	143a6b2e 	bgeu	r2,r16,811225c0 <__reset+0xfb1025c0>
81123c14:	ad7fffc4 	addi	r21,r21,-1
81123c18:	a9400007 	ldb	r5,0(r21)
81123c1c:	e00d883a 	mov	r6,fp
81123c20:	b009883a 	mov	r4,r22
81123c24:	112c1100 	call	8112c110 <_ungetc_r>
81123c28:	d8c00104 	addi	r3,sp,4
81123c2c:	1d7ff91e 	bne	r3,r21,81123c14 <__reset+0xfb103c14>
81123c30:	003a6306 	br	811225c0 <__reset+0xfb1025c0>
81123c34:	0009883a 	mov	r4,zero
81123c38:	1128b700 	call	81128b70 <nanf>
81123c3c:	a0800015 	stw	r2,0(r20)
81123c40:	dc409c15 	stw	r17,624(sp)
81123c44:	003dac06 	br	811232f8 <__reset+0xfb1032f8>
81123c48:	d9000104 	addi	r4,sp,4
81123c4c:	802b883a 	mov	r21,r16
81123c50:	243a5b2e 	bgeu	r4,r16,811225c0 <__reset+0xfb1025c0>
81123c54:	ad7fffc4 	addi	r21,r21,-1
81123c58:	a9400007 	ldb	r5,0(r21)
81123c5c:	e00d883a 	mov	r6,fp
81123c60:	b009883a 	mov	r4,r22
81123c64:	112c1100 	call	8112c110 <_ungetc_r>
81123c68:	d9400104 	addi	r5,sp,4
81123c6c:	2d7ff91e 	bne	r5,r21,81123c54 <__reset+0xfb103c54>
81123c70:	003a5306 	br	811225c0 <__reset+0xfb1025c0>
81123c74:	112a9380 	call	8112a938 <_strtoull_r>
81123c78:	003f9d06 	br	81123af0 <__reset+0xfb103af0>

81123c7c <vfscanf>:
81123c7c:	00a04574 	movhi	r2,33045
81123c80:	defffb04 	addi	sp,sp,-20
81123c84:	10b7d604 	addi	r2,r2,-8360
81123c88:	de00012e 	bgeu	sp,et,81123c90 <vfscanf+0x14>
81123c8c:	003b68fa 	trap	3
81123c90:	dc000215 	stw	r16,8(sp)
81123c94:	14000017 	ldw	r16,0(r2)
81123c98:	dc400315 	stw	r17,12(sp)
81123c9c:	dfc00415 	stw	ra,16(sp)
81123ca0:	2023883a 	mov	r17,r4
81123ca4:	80000826 	beq	r16,zero,81123cc8 <vfscanf+0x4c>
81123ca8:	80800e17 	ldw	r2,56(r16)
81123cac:	1000061e 	bne	r2,zero,81123cc8 <vfscanf+0x4c>
81123cb0:	8009883a 	mov	r4,r16
81123cb4:	d9400015 	stw	r5,0(sp)
81123cb8:	d9800115 	stw	r6,4(sp)
81123cbc:	1125f940 	call	81125f94 <__sinit>
81123cc0:	d9800117 	ldw	r6,4(sp)
81123cc4:	d9400017 	ldw	r5,0(sp)
81123cc8:	300f883a 	mov	r7,r6
81123ccc:	8009883a 	mov	r4,r16
81123cd0:	280d883a 	mov	r6,r5
81123cd4:	880b883a 	mov	r5,r17
81123cd8:	dfc00417 	ldw	ra,16(sp)
81123cdc:	dc400317 	ldw	r17,12(sp)
81123ce0:	dc000217 	ldw	r16,8(sp)
81123ce4:	dec00504 	addi	sp,sp,20
81123ce8:	11224b81 	jmpi	811224b8 <__svfscanf_r>

81123cec <__svfscanf>:
81123cec:	00a04574 	movhi	r2,33045
81123cf0:	10b7d604 	addi	r2,r2,-8360
81123cf4:	300f883a 	mov	r7,r6
81123cf8:	280d883a 	mov	r6,r5
81123cfc:	200b883a 	mov	r5,r4
81123d00:	11000017 	ldw	r4,0(r2)
81123d04:	11224b81 	jmpi	811224b8 <__svfscanf_r>

81123d08 <_vfscanf_r>:
81123d08:	defffb04 	addi	sp,sp,-20
81123d0c:	de00012e 	bgeu	sp,et,81123d14 <_vfscanf_r+0xc>
81123d10:	003b68fa 	trap	3
81123d14:	dc000315 	stw	r16,12(sp)
81123d18:	dfc00415 	stw	ra,16(sp)
81123d1c:	2021883a 	mov	r16,r4
81123d20:	20000926 	beq	r4,zero,81123d48 <_vfscanf_r+0x40>
81123d24:	20800e17 	ldw	r2,56(r4)
81123d28:	1000071e 	bne	r2,zero,81123d48 <_vfscanf_r+0x40>
81123d2c:	d9400015 	stw	r5,0(sp)
81123d30:	d9800115 	stw	r6,4(sp)
81123d34:	d9c00215 	stw	r7,8(sp)
81123d38:	1125f940 	call	81125f94 <__sinit>
81123d3c:	d9c00217 	ldw	r7,8(sp)
81123d40:	d9800117 	ldw	r6,4(sp)
81123d44:	d9400017 	ldw	r5,0(sp)
81123d48:	8009883a 	mov	r4,r16
81123d4c:	dfc00417 	ldw	ra,16(sp)
81123d50:	dc000317 	ldw	r16,12(sp)
81123d54:	dec00504 	addi	sp,sp,20
81123d58:	11224b81 	jmpi	811224b8 <__svfscanf_r>

81123d5c <__swbuf_r>:
81123d5c:	defffb04 	addi	sp,sp,-20
81123d60:	de00012e 	bgeu	sp,et,81123d68 <__swbuf_r+0xc>
81123d64:	003b68fa 	trap	3
81123d68:	dcc00315 	stw	r19,12(sp)
81123d6c:	dc800215 	stw	r18,8(sp)
81123d70:	dc000015 	stw	r16,0(sp)
81123d74:	dfc00415 	stw	ra,16(sp)
81123d78:	dc400115 	stw	r17,4(sp)
81123d7c:	2025883a 	mov	r18,r4
81123d80:	2827883a 	mov	r19,r5
81123d84:	3021883a 	mov	r16,r6
81123d88:	20000226 	beq	r4,zero,81123d94 <__swbuf_r+0x38>
81123d8c:	20800e17 	ldw	r2,56(r4)
81123d90:	10004226 	beq	r2,zero,81123e9c <__swbuf_r+0x140>
81123d94:	80800617 	ldw	r2,24(r16)
81123d98:	8100030b 	ldhu	r4,12(r16)
81123d9c:	80800215 	stw	r2,8(r16)
81123da0:	2080020c 	andi	r2,r4,8
81123da4:	10003626 	beq	r2,zero,81123e80 <__swbuf_r+0x124>
81123da8:	80c00417 	ldw	r3,16(r16)
81123dac:	18003426 	beq	r3,zero,81123e80 <__swbuf_r+0x124>
81123db0:	2088000c 	andi	r2,r4,8192
81123db4:	9c403fcc 	andi	r17,r19,255
81123db8:	10001a26 	beq	r2,zero,81123e24 <__swbuf_r+0xc8>
81123dbc:	80800017 	ldw	r2,0(r16)
81123dc0:	81000517 	ldw	r4,20(r16)
81123dc4:	10c7c83a 	sub	r3,r2,r3
81123dc8:	1900200e 	bge	r3,r4,81123e4c <__swbuf_r+0xf0>
81123dcc:	18c00044 	addi	r3,r3,1
81123dd0:	81000217 	ldw	r4,8(r16)
81123dd4:	11400044 	addi	r5,r2,1
81123dd8:	81400015 	stw	r5,0(r16)
81123ddc:	213fffc4 	addi	r4,r4,-1
81123de0:	81000215 	stw	r4,8(r16)
81123de4:	14c00005 	stb	r19,0(r2)
81123de8:	80800517 	ldw	r2,20(r16)
81123dec:	10c01e26 	beq	r2,r3,81123e68 <__swbuf_r+0x10c>
81123df0:	8080030b 	ldhu	r2,12(r16)
81123df4:	1080004c 	andi	r2,r2,1
81123df8:	10000226 	beq	r2,zero,81123e04 <__swbuf_r+0xa8>
81123dfc:	00800284 	movi	r2,10
81123e00:	88801926 	beq	r17,r2,81123e68 <__swbuf_r+0x10c>
81123e04:	8805883a 	mov	r2,r17
81123e08:	dfc00417 	ldw	ra,16(sp)
81123e0c:	dcc00317 	ldw	r19,12(sp)
81123e10:	dc800217 	ldw	r18,8(sp)
81123e14:	dc400117 	ldw	r17,4(sp)
81123e18:	dc000017 	ldw	r16,0(sp)
81123e1c:	dec00504 	addi	sp,sp,20
81123e20:	f800283a 	ret
81123e24:	81401917 	ldw	r5,100(r16)
81123e28:	00b7ffc4 	movi	r2,-8193
81123e2c:	21080014 	ori	r4,r4,8192
81123e30:	2884703a 	and	r2,r5,r2
81123e34:	80801915 	stw	r2,100(r16)
81123e38:	80800017 	ldw	r2,0(r16)
81123e3c:	8100030d 	sth	r4,12(r16)
81123e40:	81000517 	ldw	r4,20(r16)
81123e44:	10c7c83a 	sub	r3,r2,r3
81123e48:	193fe016 	blt	r3,r4,81123dcc <__reset+0xfb103dcc>
81123e4c:	800b883a 	mov	r5,r16
81123e50:	9009883a 	mov	r4,r18
81123e54:	1125b980 	call	81125b98 <_fflush_r>
81123e58:	1000071e 	bne	r2,zero,81123e78 <__swbuf_r+0x11c>
81123e5c:	80800017 	ldw	r2,0(r16)
81123e60:	00c00044 	movi	r3,1
81123e64:	003fda06 	br	81123dd0 <__reset+0xfb103dd0>
81123e68:	800b883a 	mov	r5,r16
81123e6c:	9009883a 	mov	r4,r18
81123e70:	1125b980 	call	81125b98 <_fflush_r>
81123e74:	103fe326 	beq	r2,zero,81123e04 <__reset+0xfb103e04>
81123e78:	00bfffc4 	movi	r2,-1
81123e7c:	003fe206 	br	81123e08 <__reset+0xfb103e08>
81123e80:	800b883a 	mov	r5,r16
81123e84:	9009883a 	mov	r4,r18
81123e88:	1123f240 	call	81123f24 <__swsetup_r>
81123e8c:	103ffa1e 	bne	r2,zero,81123e78 <__reset+0xfb103e78>
81123e90:	8100030b 	ldhu	r4,12(r16)
81123e94:	80c00417 	ldw	r3,16(r16)
81123e98:	003fc506 	br	81123db0 <__reset+0xfb103db0>
81123e9c:	1125f940 	call	81125f94 <__sinit>
81123ea0:	003fbc06 	br	81123d94 <__reset+0xfb103d94>

81123ea4 <__swbuf>:
81123ea4:	00a04574 	movhi	r2,33045
81123ea8:	10b7d604 	addi	r2,r2,-8360
81123eac:	280d883a 	mov	r6,r5
81123eb0:	200b883a 	mov	r5,r4
81123eb4:	11000017 	ldw	r4,0(r2)
81123eb8:	1123d5c1 	jmpi	81123d5c <__swbuf_r>

81123ebc <_write_r>:
81123ebc:	defffd04 	addi	sp,sp,-12
81123ec0:	de00012e 	bgeu	sp,et,81123ec8 <_write_r+0xc>
81123ec4:	003b68fa 	trap	3
81123ec8:	2805883a 	mov	r2,r5
81123ecc:	dc000015 	stw	r16,0(sp)
81123ed0:	04204574 	movhi	r16,33045
81123ed4:	dc400115 	stw	r17,4(sp)
81123ed8:	300b883a 	mov	r5,r6
81123edc:	84384404 	addi	r16,r16,-7920
81123ee0:	2023883a 	mov	r17,r4
81123ee4:	380d883a 	mov	r6,r7
81123ee8:	1009883a 	mov	r4,r2
81123eec:	dfc00215 	stw	ra,8(sp)
81123ef0:	80000015 	stw	zero,0(r16)
81123ef4:	11335740 	call	81133574 <write>
81123ef8:	00ffffc4 	movi	r3,-1
81123efc:	10c00526 	beq	r2,r3,81123f14 <_write_r+0x58>
81123f00:	dfc00217 	ldw	ra,8(sp)
81123f04:	dc400117 	ldw	r17,4(sp)
81123f08:	dc000017 	ldw	r16,0(sp)
81123f0c:	dec00304 	addi	sp,sp,12
81123f10:	f800283a 	ret
81123f14:	80c00017 	ldw	r3,0(r16)
81123f18:	183ff926 	beq	r3,zero,81123f00 <__reset+0xfb103f00>
81123f1c:	88c00015 	stw	r3,0(r17)
81123f20:	003ff706 	br	81123f00 <__reset+0xfb103f00>

81123f24 <__swsetup_r>:
81123f24:	00a04574 	movhi	r2,33045
81123f28:	defffd04 	addi	sp,sp,-12
81123f2c:	10b7d604 	addi	r2,r2,-8360
81123f30:	de00012e 	bgeu	sp,et,81123f38 <__swsetup_r+0x14>
81123f34:	003b68fa 	trap	3
81123f38:	dc400115 	stw	r17,4(sp)
81123f3c:	2023883a 	mov	r17,r4
81123f40:	11000017 	ldw	r4,0(r2)
81123f44:	dc000015 	stw	r16,0(sp)
81123f48:	dfc00215 	stw	ra,8(sp)
81123f4c:	2821883a 	mov	r16,r5
81123f50:	20000226 	beq	r4,zero,81123f5c <__swsetup_r+0x38>
81123f54:	20800e17 	ldw	r2,56(r4)
81123f58:	10003126 	beq	r2,zero,81124020 <__swsetup_r+0xfc>
81123f5c:	8080030b 	ldhu	r2,12(r16)
81123f60:	10c0020c 	andi	r3,r2,8
81123f64:	1009883a 	mov	r4,r2
81123f68:	18000f26 	beq	r3,zero,81123fa8 <__swsetup_r+0x84>
81123f6c:	80c00417 	ldw	r3,16(r16)
81123f70:	18001526 	beq	r3,zero,81123fc8 <__swsetup_r+0xa4>
81123f74:	1100004c 	andi	r4,r2,1
81123f78:	20001c1e 	bne	r4,zero,81123fec <__swsetup_r+0xc8>
81123f7c:	1080008c 	andi	r2,r2,2
81123f80:	1000291e 	bne	r2,zero,81124028 <__swsetup_r+0x104>
81123f84:	80800517 	ldw	r2,20(r16)
81123f88:	80800215 	stw	r2,8(r16)
81123f8c:	18001c26 	beq	r3,zero,81124000 <__swsetup_r+0xdc>
81123f90:	0005883a 	mov	r2,zero
81123f94:	dfc00217 	ldw	ra,8(sp)
81123f98:	dc400117 	ldw	r17,4(sp)
81123f9c:	dc000017 	ldw	r16,0(sp)
81123fa0:	dec00304 	addi	sp,sp,12
81123fa4:	f800283a 	ret
81123fa8:	2080040c 	andi	r2,r4,16
81123fac:	10002e26 	beq	r2,zero,81124068 <__swsetup_r+0x144>
81123fb0:	2080010c 	andi	r2,r4,4
81123fb4:	10001e1e 	bne	r2,zero,81124030 <__swsetup_r+0x10c>
81123fb8:	80c00417 	ldw	r3,16(r16)
81123fbc:	20800214 	ori	r2,r4,8
81123fc0:	8080030d 	sth	r2,12(r16)
81123fc4:	183feb1e 	bne	r3,zero,81123f74 <__reset+0xfb103f74>
81123fc8:	1100a00c 	andi	r4,r2,640
81123fcc:	01408004 	movi	r5,512
81123fd0:	217fe826 	beq	r4,r5,81123f74 <__reset+0xfb103f74>
81123fd4:	800b883a 	mov	r5,r16
81123fd8:	8809883a 	mov	r4,r17
81123fdc:	111c7f40 	call	8111c7f4 <__smakebuf_r>
81123fe0:	8080030b 	ldhu	r2,12(r16)
81123fe4:	80c00417 	ldw	r3,16(r16)
81123fe8:	003fe206 	br	81123f74 <__reset+0xfb103f74>
81123fec:	80800517 	ldw	r2,20(r16)
81123ff0:	80000215 	stw	zero,8(r16)
81123ff4:	0085c83a 	sub	r2,zero,r2
81123ff8:	80800615 	stw	r2,24(r16)
81123ffc:	183fe41e 	bne	r3,zero,81123f90 <__reset+0xfb103f90>
81124000:	80c0030b 	ldhu	r3,12(r16)
81124004:	0005883a 	mov	r2,zero
81124008:	1900200c 	andi	r4,r3,128
8112400c:	203fe126 	beq	r4,zero,81123f94 <__reset+0xfb103f94>
81124010:	18c01014 	ori	r3,r3,64
81124014:	80c0030d 	sth	r3,12(r16)
81124018:	00bfffc4 	movi	r2,-1
8112401c:	003fdd06 	br	81123f94 <__reset+0xfb103f94>
81124020:	1125f940 	call	81125f94 <__sinit>
81124024:	003fcd06 	br	81123f5c <__reset+0xfb103f5c>
81124028:	0005883a 	mov	r2,zero
8112402c:	003fd606 	br	81123f88 <__reset+0xfb103f88>
81124030:	81400c17 	ldw	r5,48(r16)
81124034:	28000626 	beq	r5,zero,81124050 <__swsetup_r+0x12c>
81124038:	80801004 	addi	r2,r16,64
8112403c:	28800326 	beq	r5,r2,8112404c <__swsetup_r+0x128>
81124040:	8809883a 	mov	r4,r17
81124044:	112642c0 	call	8112642c <_free_r>
81124048:	8100030b 	ldhu	r4,12(r16)
8112404c:	80000c15 	stw	zero,48(r16)
81124050:	80c00417 	ldw	r3,16(r16)
81124054:	00bff6c4 	movi	r2,-37
81124058:	1108703a 	and	r4,r2,r4
8112405c:	80000115 	stw	zero,4(r16)
81124060:	80c00015 	stw	r3,0(r16)
81124064:	003fd506 	br	81123fbc <__reset+0xfb103fbc>
81124068:	00800244 	movi	r2,9
8112406c:	88800015 	stw	r2,0(r17)
81124070:	20801014 	ori	r2,r4,64
81124074:	8080030d 	sth	r2,12(r16)
81124078:	00bfffc4 	movi	r2,-1
8112407c:	003fc506 	br	81123f94 <__reset+0xfb103f94>

81124080 <_close_r>:
81124080:	defffd04 	addi	sp,sp,-12
81124084:	de00012e 	bgeu	sp,et,8112408c <_close_r+0xc>
81124088:	003b68fa 	trap	3
8112408c:	dc000015 	stw	r16,0(sp)
81124090:	04204574 	movhi	r16,33045
81124094:	dc400115 	stw	r17,4(sp)
81124098:	84384404 	addi	r16,r16,-7920
8112409c:	2023883a 	mov	r17,r4
811240a0:	2809883a 	mov	r4,r5
811240a4:	dfc00215 	stw	ra,8(sp)
811240a8:	80000015 	stw	zero,0(r16)
811240ac:	1131af40 	call	81131af4 <close>
811240b0:	00ffffc4 	movi	r3,-1
811240b4:	10c00526 	beq	r2,r3,811240cc <_close_r+0x4c>
811240b8:	dfc00217 	ldw	ra,8(sp)
811240bc:	dc400117 	ldw	r17,4(sp)
811240c0:	dc000017 	ldw	r16,0(sp)
811240c4:	dec00304 	addi	sp,sp,12
811240c8:	f800283a 	ret
811240cc:	80c00017 	ldw	r3,0(r16)
811240d0:	183ff926 	beq	r3,zero,811240b8 <__reset+0xfb1040b8>
811240d4:	88c00015 	stw	r3,0(r17)
811240d8:	003ff706 	br	811240b8 <__reset+0xfb1040b8>

811240dc <quorem>:
811240dc:	defff704 	addi	sp,sp,-36
811240e0:	de00012e 	bgeu	sp,et,811240e8 <quorem+0xc>
811240e4:	003b68fa 	trap	3
811240e8:	dc800215 	stw	r18,8(sp)
811240ec:	20800417 	ldw	r2,16(r4)
811240f0:	2c800417 	ldw	r18,16(r5)
811240f4:	dfc00815 	stw	ra,32(sp)
811240f8:	ddc00715 	stw	r23,28(sp)
811240fc:	dd800615 	stw	r22,24(sp)
81124100:	dd400515 	stw	r21,20(sp)
81124104:	dd000415 	stw	r20,16(sp)
81124108:	dcc00315 	stw	r19,12(sp)
8112410c:	dc400115 	stw	r17,4(sp)
81124110:	dc000015 	stw	r16,0(sp)
81124114:	14807116 	blt	r2,r18,811242dc <quorem+0x200>
81124118:	94bfffc4 	addi	r18,r18,-1
8112411c:	94ad883a 	add	r22,r18,r18
81124120:	b5ad883a 	add	r22,r22,r22
81124124:	2c400504 	addi	r17,r5,20
81124128:	8da9883a 	add	r20,r17,r22
8112412c:	25400504 	addi	r21,r4,20
81124130:	282f883a 	mov	r23,r5
81124134:	adad883a 	add	r22,r21,r22
81124138:	a1400017 	ldw	r5,0(r20)
8112413c:	2021883a 	mov	r16,r4
81124140:	b1000017 	ldw	r4,0(r22)
81124144:	29400044 	addi	r5,r5,1
81124148:	112f7b40 	call	8112f7b4 <__udivsi3>
8112414c:	1027883a 	mov	r19,r2
81124150:	10002c26 	beq	r2,zero,81124204 <quorem+0x128>
81124154:	a813883a 	mov	r9,r21
81124158:	880b883a 	mov	r5,r17
8112415c:	0009883a 	mov	r4,zero
81124160:	000d883a 	mov	r6,zero
81124164:	2a000017 	ldw	r8,0(r5)
81124168:	49c00017 	ldw	r7,0(r9)
8112416c:	29400104 	addi	r5,r5,4
81124170:	40bfffcc 	andi	r2,r8,65535
81124174:	14c5383a 	mul	r2,r2,r19
81124178:	4010d43a 	srli	r8,r8,16
8112417c:	38ffffcc 	andi	r3,r7,65535
81124180:	1105883a 	add	r2,r2,r4
81124184:	1008d43a 	srli	r4,r2,16
81124188:	44d1383a 	mul	r8,r8,r19
8112418c:	198d883a 	add	r6,r3,r6
81124190:	10ffffcc 	andi	r3,r2,65535
81124194:	30c7c83a 	sub	r3,r6,r3
81124198:	380ed43a 	srli	r7,r7,16
8112419c:	4105883a 	add	r2,r8,r4
811241a0:	180dd43a 	srai	r6,r3,16
811241a4:	113fffcc 	andi	r4,r2,65535
811241a8:	390fc83a 	sub	r7,r7,r4
811241ac:	398d883a 	add	r6,r7,r6
811241b0:	300e943a 	slli	r7,r6,16
811241b4:	18ffffcc 	andi	r3,r3,65535
811241b8:	1008d43a 	srli	r4,r2,16
811241bc:	38ceb03a 	or	r7,r7,r3
811241c0:	49c00015 	stw	r7,0(r9)
811241c4:	300dd43a 	srai	r6,r6,16
811241c8:	4a400104 	addi	r9,r9,4
811241cc:	a17fe52e 	bgeu	r20,r5,81124164 <__reset+0xfb104164>
811241d0:	b0800017 	ldw	r2,0(r22)
811241d4:	10000b1e 	bne	r2,zero,81124204 <quorem+0x128>
811241d8:	b0bfff04 	addi	r2,r22,-4
811241dc:	a880082e 	bgeu	r21,r2,81124200 <quorem+0x124>
811241e0:	b0ffff17 	ldw	r3,-4(r22)
811241e4:	18000326 	beq	r3,zero,811241f4 <quorem+0x118>
811241e8:	00000506 	br	81124200 <quorem+0x124>
811241ec:	10c00017 	ldw	r3,0(r2)
811241f0:	1800031e 	bne	r3,zero,81124200 <quorem+0x124>
811241f4:	10bfff04 	addi	r2,r2,-4
811241f8:	94bfffc4 	addi	r18,r18,-1
811241fc:	a8bffb36 	bltu	r21,r2,811241ec <__reset+0xfb1041ec>
81124200:	84800415 	stw	r18,16(r16)
81124204:	b80b883a 	mov	r5,r23
81124208:	8009883a 	mov	r4,r16
8112420c:	1127cfc0 	call	81127cfc <__mcmp>
81124210:	10002616 	blt	r2,zero,811242ac <quorem+0x1d0>
81124214:	9cc00044 	addi	r19,r19,1
81124218:	a805883a 	mov	r2,r21
8112421c:	000b883a 	mov	r5,zero
81124220:	11000017 	ldw	r4,0(r2)
81124224:	89800017 	ldw	r6,0(r17)
81124228:	10800104 	addi	r2,r2,4
8112422c:	20ffffcc 	andi	r3,r4,65535
81124230:	194b883a 	add	r5,r3,r5
81124234:	30ffffcc 	andi	r3,r6,65535
81124238:	28c7c83a 	sub	r3,r5,r3
8112423c:	300cd43a 	srli	r6,r6,16
81124240:	2008d43a 	srli	r4,r4,16
81124244:	180bd43a 	srai	r5,r3,16
81124248:	18ffffcc 	andi	r3,r3,65535
8112424c:	2189c83a 	sub	r4,r4,r6
81124250:	2149883a 	add	r4,r4,r5
81124254:	200c943a 	slli	r6,r4,16
81124258:	8c400104 	addi	r17,r17,4
8112425c:	200bd43a 	srai	r5,r4,16
81124260:	30c6b03a 	or	r3,r6,r3
81124264:	10ffff15 	stw	r3,-4(r2)
81124268:	a47fed2e 	bgeu	r20,r17,81124220 <__reset+0xfb104220>
8112426c:	9485883a 	add	r2,r18,r18
81124270:	1085883a 	add	r2,r2,r2
81124274:	a887883a 	add	r3,r21,r2
81124278:	18800017 	ldw	r2,0(r3)
8112427c:	10000b1e 	bne	r2,zero,811242ac <quorem+0x1d0>
81124280:	18bfff04 	addi	r2,r3,-4
81124284:	a880082e 	bgeu	r21,r2,811242a8 <quorem+0x1cc>
81124288:	18ffff17 	ldw	r3,-4(r3)
8112428c:	18000326 	beq	r3,zero,8112429c <quorem+0x1c0>
81124290:	00000506 	br	811242a8 <quorem+0x1cc>
81124294:	10c00017 	ldw	r3,0(r2)
81124298:	1800031e 	bne	r3,zero,811242a8 <quorem+0x1cc>
8112429c:	10bfff04 	addi	r2,r2,-4
811242a0:	94bfffc4 	addi	r18,r18,-1
811242a4:	a8bffb36 	bltu	r21,r2,81124294 <__reset+0xfb104294>
811242a8:	84800415 	stw	r18,16(r16)
811242ac:	9805883a 	mov	r2,r19
811242b0:	dfc00817 	ldw	ra,32(sp)
811242b4:	ddc00717 	ldw	r23,28(sp)
811242b8:	dd800617 	ldw	r22,24(sp)
811242bc:	dd400517 	ldw	r21,20(sp)
811242c0:	dd000417 	ldw	r20,16(sp)
811242c4:	dcc00317 	ldw	r19,12(sp)
811242c8:	dc800217 	ldw	r18,8(sp)
811242cc:	dc400117 	ldw	r17,4(sp)
811242d0:	dc000017 	ldw	r16,0(sp)
811242d4:	dec00904 	addi	sp,sp,36
811242d8:	f800283a 	ret
811242dc:	0005883a 	mov	r2,zero
811242e0:	003ff306 	br	811242b0 <__reset+0xfb1042b0>

811242e4 <_dtoa_r>:
811242e4:	deffde04 	addi	sp,sp,-136
811242e8:	de00012e 	bgeu	sp,et,811242f0 <_dtoa_r+0xc>
811242ec:	003b68fa 	trap	3
811242f0:	20801017 	ldw	r2,64(r4)
811242f4:	df002015 	stw	fp,128(sp)
811242f8:	dcc01b15 	stw	r19,108(sp)
811242fc:	dc801a15 	stw	r18,104(sp)
81124300:	dc401915 	stw	r17,100(sp)
81124304:	dc001815 	stw	r16,96(sp)
81124308:	dfc02115 	stw	ra,132(sp)
8112430c:	ddc01f15 	stw	r23,124(sp)
81124310:	dd801e15 	stw	r22,120(sp)
81124314:	dd401d15 	stw	r21,116(sp)
81124318:	dd001c15 	stw	r20,112(sp)
8112431c:	d9c00315 	stw	r7,12(sp)
81124320:	2039883a 	mov	fp,r4
81124324:	3023883a 	mov	r17,r6
81124328:	2825883a 	mov	r18,r5
8112432c:	dc002417 	ldw	r16,144(sp)
81124330:	3027883a 	mov	r19,r6
81124334:	10000826 	beq	r2,zero,81124358 <_dtoa_r+0x74>
81124338:	21801117 	ldw	r6,68(r4)
8112433c:	00c00044 	movi	r3,1
81124340:	100b883a 	mov	r5,r2
81124344:	1986983a 	sll	r3,r3,r6
81124348:	11800115 	stw	r6,4(r2)
8112434c:	10c00215 	stw	r3,8(r2)
81124350:	11274ac0 	call	811274ac <_Bfree>
81124354:	e0001015 	stw	zero,64(fp)
81124358:	88002e16 	blt	r17,zero,81124414 <_dtoa_r+0x130>
8112435c:	80000015 	stw	zero,0(r16)
81124360:	889ffc2c 	andhi	r2,r17,32752
81124364:	00dffc34 	movhi	r3,32752
81124368:	10c01c26 	beq	r2,r3,811243dc <_dtoa_r+0xf8>
8112436c:	000d883a 	mov	r6,zero
81124370:	000f883a 	mov	r7,zero
81124374:	9009883a 	mov	r4,r18
81124378:	980b883a 	mov	r5,r19
8112437c:	1130c100 	call	81130c10 <__eqdf2>
81124380:	10002b1e 	bne	r2,zero,81124430 <_dtoa_r+0x14c>
81124384:	d9c02317 	ldw	r7,140(sp)
81124388:	00800044 	movi	r2,1
8112438c:	38800015 	stw	r2,0(r7)
81124390:	d8802517 	ldw	r2,148(sp)
81124394:	10019e26 	beq	r2,zero,81124a10 <_dtoa_r+0x72c>
81124398:	d8c02517 	ldw	r3,148(sp)
8112439c:	00a04574 	movhi	r2,33045
811243a0:	10ae0e44 	addi	r2,r2,-18375
811243a4:	18800015 	stw	r2,0(r3)
811243a8:	10bfffc4 	addi	r2,r2,-1
811243ac:	dfc02117 	ldw	ra,132(sp)
811243b0:	df002017 	ldw	fp,128(sp)
811243b4:	ddc01f17 	ldw	r23,124(sp)
811243b8:	dd801e17 	ldw	r22,120(sp)
811243bc:	dd401d17 	ldw	r21,116(sp)
811243c0:	dd001c17 	ldw	r20,112(sp)
811243c4:	dcc01b17 	ldw	r19,108(sp)
811243c8:	dc801a17 	ldw	r18,104(sp)
811243cc:	dc401917 	ldw	r17,100(sp)
811243d0:	dc001817 	ldw	r16,96(sp)
811243d4:	dec02204 	addi	sp,sp,136
811243d8:	f800283a 	ret
811243dc:	d8c02317 	ldw	r3,140(sp)
811243e0:	0089c3c4 	movi	r2,9999
811243e4:	18800015 	stw	r2,0(r3)
811243e8:	90017726 	beq	r18,zero,811249c8 <_dtoa_r+0x6e4>
811243ec:	00a04574 	movhi	r2,33045
811243f0:	10ae2c04 	addi	r2,r2,-18256
811243f4:	d9002517 	ldw	r4,148(sp)
811243f8:	203fec26 	beq	r4,zero,811243ac <__reset+0xfb1043ac>
811243fc:	10c000c7 	ldb	r3,3(r2)
81124400:	1801781e 	bne	r3,zero,811249e4 <_dtoa_r+0x700>
81124404:	10c000c4 	addi	r3,r2,3
81124408:	d9802517 	ldw	r6,148(sp)
8112440c:	30c00015 	stw	r3,0(r6)
81124410:	003fe606 	br	811243ac <__reset+0xfb1043ac>
81124414:	04e00034 	movhi	r19,32768
81124418:	9cffffc4 	addi	r19,r19,-1
8112441c:	00800044 	movi	r2,1
81124420:	8ce6703a 	and	r19,r17,r19
81124424:	80800015 	stw	r2,0(r16)
81124428:	9823883a 	mov	r17,r19
8112442c:	003fcc06 	br	81124360 <__reset+0xfb104360>
81124430:	d8800204 	addi	r2,sp,8
81124434:	d8800015 	stw	r2,0(sp)
81124438:	d9c00104 	addi	r7,sp,4
8112443c:	900b883a 	mov	r5,r18
81124440:	980d883a 	mov	r6,r19
81124444:	e009883a 	mov	r4,fp
81124448:	8820d53a 	srli	r16,r17,20
8112444c:	11280d80 	call	811280d8 <__d2b>
81124450:	d8800915 	stw	r2,36(sp)
81124454:	8001651e 	bne	r16,zero,811249ec <_dtoa_r+0x708>
81124458:	dd800217 	ldw	r22,8(sp)
8112445c:	dc000117 	ldw	r16,4(sp)
81124460:	00800804 	movi	r2,32
81124464:	b421883a 	add	r16,r22,r16
81124468:	80c10c84 	addi	r3,r16,1074
8112446c:	10c2d10e 	bge	r2,r3,81124fb4 <_dtoa_r+0xcd0>
81124470:	00801004 	movi	r2,64
81124474:	81010484 	addi	r4,r16,1042
81124478:	10c7c83a 	sub	r3,r2,r3
8112447c:	9108d83a 	srl	r4,r18,r4
81124480:	88e2983a 	sll	r17,r17,r3
81124484:	2448b03a 	or	r4,r4,r17
81124488:	11318d00 	call	811318d0 <__floatunsidf>
8112448c:	017f8434 	movhi	r5,65040
81124490:	01800044 	movi	r6,1
81124494:	1009883a 	mov	r4,r2
81124498:	194b883a 	add	r5,r3,r5
8112449c:	843fffc4 	addi	r16,r16,-1
811244a0:	d9801115 	stw	r6,68(sp)
811244a4:	000d883a 	mov	r6,zero
811244a8:	01cffe34 	movhi	r7,16376
811244ac:	1130e680 	call	81130e68 <__subdf3>
811244b0:	0198dbf4 	movhi	r6,25455
811244b4:	01cff4f4 	movhi	r7,16339
811244b8:	3190d844 	addi	r6,r6,17249
811244bc:	39e1e9c4 	addi	r7,r7,-30809
811244c0:	1009883a 	mov	r4,r2
811244c4:	180b883a 	mov	r5,r3
811244c8:	111b57c0 	call	8111b57c <__muldf3>
811244cc:	01a2d874 	movhi	r6,35681
811244d0:	01cff1f4 	movhi	r7,16327
811244d4:	31b22cc4 	addi	r6,r6,-14157
811244d8:	39e28a04 	addi	r7,r7,-30168
811244dc:	180b883a 	mov	r5,r3
811244e0:	1009883a 	mov	r4,r2
811244e4:	112fa6c0 	call	8112fa6c <__adddf3>
811244e8:	8009883a 	mov	r4,r16
811244ec:	1029883a 	mov	r20,r2
811244f0:	1823883a 	mov	r17,r3
811244f4:	11317ec0 	call	811317ec <__floatsidf>
811244f8:	019427f4 	movhi	r6,20639
811244fc:	01cff4f4 	movhi	r7,16339
81124500:	319e7ec4 	addi	r6,r6,31227
81124504:	39d104c4 	addi	r7,r7,17427
81124508:	1009883a 	mov	r4,r2
8112450c:	180b883a 	mov	r5,r3
81124510:	111b57c0 	call	8111b57c <__muldf3>
81124514:	100d883a 	mov	r6,r2
81124518:	180f883a 	mov	r7,r3
8112451c:	a009883a 	mov	r4,r20
81124520:	880b883a 	mov	r5,r17
81124524:	112fa6c0 	call	8112fa6c <__adddf3>
81124528:	1009883a 	mov	r4,r2
8112452c:	180b883a 	mov	r5,r3
81124530:	1029883a 	mov	r20,r2
81124534:	1823883a 	mov	r17,r3
81124538:	113176c0 	call	8113176c <__fixdfsi>
8112453c:	000d883a 	mov	r6,zero
81124540:	000f883a 	mov	r7,zero
81124544:	a009883a 	mov	r4,r20
81124548:	880b883a 	mov	r5,r17
8112454c:	d8800515 	stw	r2,20(sp)
81124550:	1130d740 	call	81130d74 <__ledf2>
81124554:	10028716 	blt	r2,zero,81124f74 <_dtoa_r+0xc90>
81124558:	d8c00517 	ldw	r3,20(sp)
8112455c:	00800584 	movi	r2,22
81124560:	10c27536 	bltu	r2,r3,81124f38 <_dtoa_r+0xc54>
81124564:	180490fa 	slli	r2,r3,3
81124568:	00e04574 	movhi	r3,33045
8112456c:	18ee4704 	addi	r3,r3,-18148
81124570:	1885883a 	add	r2,r3,r2
81124574:	11000017 	ldw	r4,0(r2)
81124578:	11400117 	ldw	r5,4(r2)
8112457c:	900d883a 	mov	r6,r18
81124580:	980f883a 	mov	r7,r19
81124584:	1130c980 	call	81130c98 <__gedf2>
81124588:	00828d0e 	bge	zero,r2,81124fc0 <_dtoa_r+0xcdc>
8112458c:	d9000517 	ldw	r4,20(sp)
81124590:	d8000e15 	stw	zero,56(sp)
81124594:	213fffc4 	addi	r4,r4,-1
81124598:	d9000515 	stw	r4,20(sp)
8112459c:	b42dc83a 	sub	r22,r22,r16
811245a0:	b5bfffc4 	addi	r22,r22,-1
811245a4:	b0026f16 	blt	r22,zero,81124f64 <_dtoa_r+0xc80>
811245a8:	d8000815 	stw	zero,32(sp)
811245ac:	d9c00517 	ldw	r7,20(sp)
811245b0:	38026416 	blt	r7,zero,81124f44 <_dtoa_r+0xc60>
811245b4:	b1ed883a 	add	r22,r22,r7
811245b8:	d9c00d15 	stw	r7,52(sp)
811245bc:	d8000a15 	stw	zero,40(sp)
811245c0:	d9800317 	ldw	r6,12(sp)
811245c4:	00800244 	movi	r2,9
811245c8:	11811436 	bltu	r2,r6,81124a1c <_dtoa_r+0x738>
811245cc:	00800144 	movi	r2,5
811245d0:	1184e10e 	bge	r2,r6,81125958 <_dtoa_r+0x1674>
811245d4:	31bfff04 	addi	r6,r6,-4
811245d8:	d9800315 	stw	r6,12(sp)
811245dc:	0023883a 	mov	r17,zero
811245e0:	d9800317 	ldw	r6,12(sp)
811245e4:	008000c4 	movi	r2,3
811245e8:	30836726 	beq	r6,r2,81125388 <_dtoa_r+0x10a4>
811245ec:	1183410e 	bge	r2,r6,811252f4 <_dtoa_r+0x1010>
811245f0:	d9c00317 	ldw	r7,12(sp)
811245f4:	00800104 	movi	r2,4
811245f8:	38827c26 	beq	r7,r2,81124fec <_dtoa_r+0xd08>
811245fc:	00800144 	movi	r2,5
81124600:	3884c41e 	bne	r7,r2,81125914 <_dtoa_r+0x1630>
81124604:	00800044 	movi	r2,1
81124608:	d8800b15 	stw	r2,44(sp)
8112460c:	d8c00517 	ldw	r3,20(sp)
81124610:	d9002217 	ldw	r4,136(sp)
81124614:	1907883a 	add	r3,r3,r4
81124618:	19800044 	addi	r6,r3,1
8112461c:	d8c00c15 	stw	r3,48(sp)
81124620:	d9800615 	stw	r6,24(sp)
81124624:	0183a40e 	bge	zero,r6,811254b8 <_dtoa_r+0x11d4>
81124628:	d9800617 	ldw	r6,24(sp)
8112462c:	3021883a 	mov	r16,r6
81124630:	e0001115 	stw	zero,68(fp)
81124634:	008005c4 	movi	r2,23
81124638:	1184c92e 	bgeu	r2,r6,81125960 <_dtoa_r+0x167c>
8112463c:	00c00044 	movi	r3,1
81124640:	00800104 	movi	r2,4
81124644:	1085883a 	add	r2,r2,r2
81124648:	11000504 	addi	r4,r2,20
8112464c:	180b883a 	mov	r5,r3
81124650:	18c00044 	addi	r3,r3,1
81124654:	313ffb2e 	bgeu	r6,r4,81124644 <__reset+0xfb104644>
81124658:	e1401115 	stw	r5,68(fp)
8112465c:	e009883a 	mov	r4,fp
81124660:	11273fc0 	call	811273fc <_Balloc>
81124664:	d8800715 	stw	r2,28(sp)
81124668:	e0801015 	stw	r2,64(fp)
8112466c:	00800384 	movi	r2,14
81124670:	1400f736 	bltu	r2,r16,81124a50 <_dtoa_r+0x76c>
81124674:	8800f626 	beq	r17,zero,81124a50 <_dtoa_r+0x76c>
81124678:	d9c00517 	ldw	r7,20(sp)
8112467c:	01c39a0e 	bge	zero,r7,811254e8 <_dtoa_r+0x1204>
81124680:	388003cc 	andi	r2,r7,15
81124684:	100490fa 	slli	r2,r2,3
81124688:	382bd13a 	srai	r21,r7,4
8112468c:	00e04574 	movhi	r3,33045
81124690:	18ee4704 	addi	r3,r3,-18148
81124694:	1885883a 	add	r2,r3,r2
81124698:	a8c0040c 	andi	r3,r21,16
8112469c:	12400017 	ldw	r9,0(r2)
811246a0:	12000117 	ldw	r8,4(r2)
811246a4:	18037926 	beq	r3,zero,8112548c <_dtoa_r+0x11a8>
811246a8:	00a04574 	movhi	r2,33045
811246ac:	10ae3d04 	addi	r2,r2,-18188
811246b0:	11800817 	ldw	r6,32(r2)
811246b4:	11c00917 	ldw	r7,36(r2)
811246b8:	9009883a 	mov	r4,r18
811246bc:	980b883a 	mov	r5,r19
811246c0:	da001715 	stw	r8,92(sp)
811246c4:	da401615 	stw	r9,88(sp)
811246c8:	11303200 	call	81130320 <__divdf3>
811246cc:	da001717 	ldw	r8,92(sp)
811246d0:	da401617 	ldw	r9,88(sp)
811246d4:	ad4003cc 	andi	r21,r21,15
811246d8:	040000c4 	movi	r16,3
811246dc:	1023883a 	mov	r17,r2
811246e0:	1829883a 	mov	r20,r3
811246e4:	a8001126 	beq	r21,zero,8112472c <_dtoa_r+0x448>
811246e8:	05e04574 	movhi	r23,33045
811246ec:	bdee3d04 	addi	r23,r23,-18188
811246f0:	4805883a 	mov	r2,r9
811246f4:	4007883a 	mov	r3,r8
811246f8:	a980004c 	andi	r6,r21,1
811246fc:	1009883a 	mov	r4,r2
81124700:	a82bd07a 	srai	r21,r21,1
81124704:	180b883a 	mov	r5,r3
81124708:	30000426 	beq	r6,zero,8112471c <_dtoa_r+0x438>
8112470c:	b9800017 	ldw	r6,0(r23)
81124710:	b9c00117 	ldw	r7,4(r23)
81124714:	84000044 	addi	r16,r16,1
81124718:	111b57c0 	call	8111b57c <__muldf3>
8112471c:	bdc00204 	addi	r23,r23,8
81124720:	a83ff51e 	bne	r21,zero,811246f8 <__reset+0xfb1046f8>
81124724:	1013883a 	mov	r9,r2
81124728:	1811883a 	mov	r8,r3
8112472c:	480d883a 	mov	r6,r9
81124730:	400f883a 	mov	r7,r8
81124734:	8809883a 	mov	r4,r17
81124738:	a00b883a 	mov	r5,r20
8112473c:	11303200 	call	81130320 <__divdf3>
81124740:	d8800f15 	stw	r2,60(sp)
81124744:	d8c01015 	stw	r3,64(sp)
81124748:	d8c00e17 	ldw	r3,56(sp)
8112474c:	18000626 	beq	r3,zero,81124768 <_dtoa_r+0x484>
81124750:	d9000f17 	ldw	r4,60(sp)
81124754:	d9401017 	ldw	r5,64(sp)
81124758:	000d883a 	mov	r6,zero
8112475c:	01cffc34 	movhi	r7,16368
81124760:	1130d740 	call	81130d74 <__ledf2>
81124764:	10040b16 	blt	r2,zero,81125794 <_dtoa_r+0x14b0>
81124768:	8009883a 	mov	r4,r16
8112476c:	11317ec0 	call	811317ec <__floatsidf>
81124770:	d9800f17 	ldw	r6,60(sp)
81124774:	d9c01017 	ldw	r7,64(sp)
81124778:	1009883a 	mov	r4,r2
8112477c:	180b883a 	mov	r5,r3
81124780:	111b57c0 	call	8111b57c <__muldf3>
81124784:	000d883a 	mov	r6,zero
81124788:	01d00734 	movhi	r7,16412
8112478c:	1009883a 	mov	r4,r2
81124790:	180b883a 	mov	r5,r3
81124794:	112fa6c0 	call	8112fa6c <__adddf3>
81124798:	1021883a 	mov	r16,r2
8112479c:	d8800617 	ldw	r2,24(sp)
811247a0:	047f3034 	movhi	r17,64704
811247a4:	1c63883a 	add	r17,r3,r17
811247a8:	10031826 	beq	r2,zero,8112540c <_dtoa_r+0x1128>
811247ac:	d8c00517 	ldw	r3,20(sp)
811247b0:	db000617 	ldw	r12,24(sp)
811247b4:	d8c01315 	stw	r3,76(sp)
811247b8:	d9000b17 	ldw	r4,44(sp)
811247bc:	20038f26 	beq	r4,zero,811255fc <_dtoa_r+0x1318>
811247c0:	60bfffc4 	addi	r2,r12,-1
811247c4:	100490fa 	slli	r2,r2,3
811247c8:	00e04574 	movhi	r3,33045
811247cc:	18ee4704 	addi	r3,r3,-18148
811247d0:	1885883a 	add	r2,r3,r2
811247d4:	11800017 	ldw	r6,0(r2)
811247d8:	11c00117 	ldw	r7,4(r2)
811247dc:	d8800717 	ldw	r2,28(sp)
811247e0:	0009883a 	mov	r4,zero
811247e4:	014ff834 	movhi	r5,16352
811247e8:	db001615 	stw	r12,88(sp)
811247ec:	15c00044 	addi	r23,r2,1
811247f0:	11303200 	call	81130320 <__divdf3>
811247f4:	800d883a 	mov	r6,r16
811247f8:	880f883a 	mov	r7,r17
811247fc:	1009883a 	mov	r4,r2
81124800:	180b883a 	mov	r5,r3
81124804:	1130e680 	call	81130e68 <__subdf3>
81124808:	d9401017 	ldw	r5,64(sp)
8112480c:	d9000f17 	ldw	r4,60(sp)
81124810:	102b883a 	mov	r21,r2
81124814:	d8c01215 	stw	r3,72(sp)
81124818:	113176c0 	call	8113176c <__fixdfsi>
8112481c:	1009883a 	mov	r4,r2
81124820:	1029883a 	mov	r20,r2
81124824:	11317ec0 	call	811317ec <__floatsidf>
81124828:	d9000f17 	ldw	r4,60(sp)
8112482c:	d9401017 	ldw	r5,64(sp)
81124830:	100d883a 	mov	r6,r2
81124834:	180f883a 	mov	r7,r3
81124838:	1130e680 	call	81130e68 <__subdf3>
8112483c:	1823883a 	mov	r17,r3
81124840:	d8c00717 	ldw	r3,28(sp)
81124844:	d9401217 	ldw	r5,72(sp)
81124848:	a2000c04 	addi	r8,r20,48
8112484c:	1021883a 	mov	r16,r2
81124850:	1a000005 	stb	r8,0(r3)
81124854:	800d883a 	mov	r6,r16
81124858:	880f883a 	mov	r7,r17
8112485c:	a809883a 	mov	r4,r21
81124860:	4029883a 	mov	r20,r8
81124864:	1130c980 	call	81130c98 <__gedf2>
81124868:	00841d16 	blt	zero,r2,811258e0 <_dtoa_r+0x15fc>
8112486c:	800d883a 	mov	r6,r16
81124870:	880f883a 	mov	r7,r17
81124874:	0009883a 	mov	r4,zero
81124878:	014ffc34 	movhi	r5,16368
8112487c:	1130e680 	call	81130e68 <__subdf3>
81124880:	d9401217 	ldw	r5,72(sp)
81124884:	100d883a 	mov	r6,r2
81124888:	180f883a 	mov	r7,r3
8112488c:	a809883a 	mov	r4,r21
81124890:	1130c980 	call	81130c98 <__gedf2>
81124894:	db001617 	ldw	r12,88(sp)
81124898:	00840e16 	blt	zero,r2,811258d4 <_dtoa_r+0x15f0>
8112489c:	00800044 	movi	r2,1
811248a0:	13006b0e 	bge	r2,r12,81124a50 <_dtoa_r+0x76c>
811248a4:	d9000717 	ldw	r4,28(sp)
811248a8:	dd800f15 	stw	r22,60(sp)
811248ac:	dcc01015 	stw	r19,64(sp)
811248b0:	2319883a 	add	r12,r4,r12
811248b4:	dcc01217 	ldw	r19,72(sp)
811248b8:	602d883a 	mov	r22,r12
811248bc:	dc801215 	stw	r18,72(sp)
811248c0:	b825883a 	mov	r18,r23
811248c4:	00000906 	br	811248ec <_dtoa_r+0x608>
811248c8:	1130e680 	call	81130e68 <__subdf3>
811248cc:	a80d883a 	mov	r6,r21
811248d0:	980f883a 	mov	r7,r19
811248d4:	1009883a 	mov	r4,r2
811248d8:	180b883a 	mov	r5,r3
811248dc:	1130d740 	call	81130d74 <__ledf2>
811248e0:	1003e816 	blt	r2,zero,81125884 <_dtoa_r+0x15a0>
811248e4:	b825883a 	mov	r18,r23
811248e8:	bd83e926 	beq	r23,r22,81125890 <_dtoa_r+0x15ac>
811248ec:	a809883a 	mov	r4,r21
811248f0:	980b883a 	mov	r5,r19
811248f4:	000d883a 	mov	r6,zero
811248f8:	01d00934 	movhi	r7,16420
811248fc:	111b57c0 	call	8111b57c <__muldf3>
81124900:	000d883a 	mov	r6,zero
81124904:	01d00934 	movhi	r7,16420
81124908:	8009883a 	mov	r4,r16
8112490c:	880b883a 	mov	r5,r17
81124910:	102b883a 	mov	r21,r2
81124914:	1827883a 	mov	r19,r3
81124918:	111b57c0 	call	8111b57c <__muldf3>
8112491c:	180b883a 	mov	r5,r3
81124920:	1009883a 	mov	r4,r2
81124924:	1821883a 	mov	r16,r3
81124928:	1023883a 	mov	r17,r2
8112492c:	113176c0 	call	8113176c <__fixdfsi>
81124930:	1009883a 	mov	r4,r2
81124934:	1029883a 	mov	r20,r2
81124938:	11317ec0 	call	811317ec <__floatsidf>
8112493c:	8809883a 	mov	r4,r17
81124940:	800b883a 	mov	r5,r16
81124944:	100d883a 	mov	r6,r2
81124948:	180f883a 	mov	r7,r3
8112494c:	1130e680 	call	81130e68 <__subdf3>
81124950:	a5000c04 	addi	r20,r20,48
81124954:	a80d883a 	mov	r6,r21
81124958:	980f883a 	mov	r7,r19
8112495c:	1009883a 	mov	r4,r2
81124960:	180b883a 	mov	r5,r3
81124964:	95000005 	stb	r20,0(r18)
81124968:	1021883a 	mov	r16,r2
8112496c:	1823883a 	mov	r17,r3
81124970:	1130d740 	call	81130d74 <__ledf2>
81124974:	bdc00044 	addi	r23,r23,1
81124978:	800d883a 	mov	r6,r16
8112497c:	880f883a 	mov	r7,r17
81124980:	0009883a 	mov	r4,zero
81124984:	014ffc34 	movhi	r5,16368
81124988:	103fcf0e 	bge	r2,zero,811248c8 <__reset+0xfb1048c8>
8112498c:	d8c01317 	ldw	r3,76(sp)
81124990:	d8c00515 	stw	r3,20(sp)
81124994:	d9400917 	ldw	r5,36(sp)
81124998:	e009883a 	mov	r4,fp
8112499c:	11274ac0 	call	811274ac <_Bfree>
811249a0:	d9000517 	ldw	r4,20(sp)
811249a4:	d9802317 	ldw	r6,140(sp)
811249a8:	d9c02517 	ldw	r7,148(sp)
811249ac:	b8000005 	stb	zero,0(r23)
811249b0:	20800044 	addi	r2,r4,1
811249b4:	30800015 	stw	r2,0(r6)
811249b8:	3802aa26 	beq	r7,zero,81125464 <_dtoa_r+0x1180>
811249bc:	3dc00015 	stw	r23,0(r7)
811249c0:	d8800717 	ldw	r2,28(sp)
811249c4:	003e7906 	br	811243ac <__reset+0xfb1043ac>
811249c8:	00800434 	movhi	r2,16
811249cc:	10bfffc4 	addi	r2,r2,-1
811249d0:	88a2703a 	and	r17,r17,r2
811249d4:	883e851e 	bne	r17,zero,811243ec <__reset+0xfb1043ec>
811249d8:	00a04574 	movhi	r2,33045
811249dc:	10ae2904 	addi	r2,r2,-18268
811249e0:	003e8406 	br	811243f4 <__reset+0xfb1043f4>
811249e4:	10c00204 	addi	r3,r2,8
811249e8:	003e8706 	br	81124408 <__reset+0xfb104408>
811249ec:	01400434 	movhi	r5,16
811249f0:	297fffc4 	addi	r5,r5,-1
811249f4:	994a703a 	and	r5,r19,r5
811249f8:	9009883a 	mov	r4,r18
811249fc:	843f0044 	addi	r16,r16,-1023
81124a00:	294ffc34 	orhi	r5,r5,16368
81124a04:	dd800217 	ldw	r22,8(sp)
81124a08:	d8001115 	stw	zero,68(sp)
81124a0c:	003ea506 	br	811244a4 <__reset+0xfb1044a4>
81124a10:	00a04574 	movhi	r2,33045
81124a14:	10ae0e04 	addi	r2,r2,-18376
81124a18:	003e6406 	br	811243ac <__reset+0xfb1043ac>
81124a1c:	e0001115 	stw	zero,68(fp)
81124a20:	000b883a 	mov	r5,zero
81124a24:	e009883a 	mov	r4,fp
81124a28:	11273fc0 	call	811273fc <_Balloc>
81124a2c:	01bfffc4 	movi	r6,-1
81124a30:	01c00044 	movi	r7,1
81124a34:	d8800715 	stw	r2,28(sp)
81124a38:	d9800c15 	stw	r6,48(sp)
81124a3c:	e0801015 	stw	r2,64(fp)
81124a40:	d8000315 	stw	zero,12(sp)
81124a44:	d9c00b15 	stw	r7,44(sp)
81124a48:	d9800615 	stw	r6,24(sp)
81124a4c:	d8002215 	stw	zero,136(sp)
81124a50:	d8800117 	ldw	r2,4(sp)
81124a54:	10008916 	blt	r2,zero,81124c7c <_dtoa_r+0x998>
81124a58:	d9000517 	ldw	r4,20(sp)
81124a5c:	00c00384 	movi	r3,14
81124a60:	19008616 	blt	r3,r4,81124c7c <_dtoa_r+0x998>
81124a64:	200490fa 	slli	r2,r4,3
81124a68:	00e04574 	movhi	r3,33045
81124a6c:	d9802217 	ldw	r6,136(sp)
81124a70:	18ee4704 	addi	r3,r3,-18148
81124a74:	1885883a 	add	r2,r3,r2
81124a78:	14000017 	ldw	r16,0(r2)
81124a7c:	14400117 	ldw	r17,4(r2)
81124a80:	30016316 	blt	r6,zero,81125010 <_dtoa_r+0xd2c>
81124a84:	800d883a 	mov	r6,r16
81124a88:	880f883a 	mov	r7,r17
81124a8c:	9009883a 	mov	r4,r18
81124a90:	980b883a 	mov	r5,r19
81124a94:	11303200 	call	81130320 <__divdf3>
81124a98:	180b883a 	mov	r5,r3
81124a9c:	1009883a 	mov	r4,r2
81124aa0:	113176c0 	call	8113176c <__fixdfsi>
81124aa4:	1009883a 	mov	r4,r2
81124aa8:	102b883a 	mov	r21,r2
81124aac:	11317ec0 	call	811317ec <__floatsidf>
81124ab0:	800d883a 	mov	r6,r16
81124ab4:	880f883a 	mov	r7,r17
81124ab8:	1009883a 	mov	r4,r2
81124abc:	180b883a 	mov	r5,r3
81124ac0:	111b57c0 	call	8111b57c <__muldf3>
81124ac4:	100d883a 	mov	r6,r2
81124ac8:	180f883a 	mov	r7,r3
81124acc:	9009883a 	mov	r4,r18
81124ad0:	980b883a 	mov	r5,r19
81124ad4:	1130e680 	call	81130e68 <__subdf3>
81124ad8:	d9c00717 	ldw	r7,28(sp)
81124adc:	1009883a 	mov	r4,r2
81124ae0:	a8800c04 	addi	r2,r21,48
81124ae4:	38800005 	stb	r2,0(r7)
81124ae8:	3dc00044 	addi	r23,r7,1
81124aec:	d9c00617 	ldw	r7,24(sp)
81124af0:	01800044 	movi	r6,1
81124af4:	180b883a 	mov	r5,r3
81124af8:	2005883a 	mov	r2,r4
81124afc:	39803826 	beq	r7,r6,81124be0 <_dtoa_r+0x8fc>
81124b00:	000d883a 	mov	r6,zero
81124b04:	01d00934 	movhi	r7,16420
81124b08:	111b57c0 	call	8111b57c <__muldf3>
81124b0c:	000d883a 	mov	r6,zero
81124b10:	000f883a 	mov	r7,zero
81124b14:	1009883a 	mov	r4,r2
81124b18:	180b883a 	mov	r5,r3
81124b1c:	1025883a 	mov	r18,r2
81124b20:	1827883a 	mov	r19,r3
81124b24:	1130c100 	call	81130c10 <__eqdf2>
81124b28:	103f9a26 	beq	r2,zero,81124994 <__reset+0xfb104994>
81124b2c:	d9c00617 	ldw	r7,24(sp)
81124b30:	d8c00717 	ldw	r3,28(sp)
81124b34:	b829883a 	mov	r20,r23
81124b38:	38bfffc4 	addi	r2,r7,-1
81124b3c:	18ad883a 	add	r22,r3,r2
81124b40:	00000a06 	br	81124b6c <_dtoa_r+0x888>
81124b44:	111b57c0 	call	8111b57c <__muldf3>
81124b48:	000d883a 	mov	r6,zero
81124b4c:	000f883a 	mov	r7,zero
81124b50:	1009883a 	mov	r4,r2
81124b54:	180b883a 	mov	r5,r3
81124b58:	1025883a 	mov	r18,r2
81124b5c:	1827883a 	mov	r19,r3
81124b60:	b829883a 	mov	r20,r23
81124b64:	1130c100 	call	81130c10 <__eqdf2>
81124b68:	103f8a26 	beq	r2,zero,81124994 <__reset+0xfb104994>
81124b6c:	800d883a 	mov	r6,r16
81124b70:	880f883a 	mov	r7,r17
81124b74:	9009883a 	mov	r4,r18
81124b78:	980b883a 	mov	r5,r19
81124b7c:	11303200 	call	81130320 <__divdf3>
81124b80:	180b883a 	mov	r5,r3
81124b84:	1009883a 	mov	r4,r2
81124b88:	113176c0 	call	8113176c <__fixdfsi>
81124b8c:	1009883a 	mov	r4,r2
81124b90:	102b883a 	mov	r21,r2
81124b94:	11317ec0 	call	811317ec <__floatsidf>
81124b98:	800d883a 	mov	r6,r16
81124b9c:	880f883a 	mov	r7,r17
81124ba0:	1009883a 	mov	r4,r2
81124ba4:	180b883a 	mov	r5,r3
81124ba8:	111b57c0 	call	8111b57c <__muldf3>
81124bac:	100d883a 	mov	r6,r2
81124bb0:	180f883a 	mov	r7,r3
81124bb4:	9009883a 	mov	r4,r18
81124bb8:	980b883a 	mov	r5,r19
81124bbc:	1130e680 	call	81130e68 <__subdf3>
81124bc0:	aa000c04 	addi	r8,r21,48
81124bc4:	a2000005 	stb	r8,0(r20)
81124bc8:	000d883a 	mov	r6,zero
81124bcc:	01d00934 	movhi	r7,16420
81124bd0:	1009883a 	mov	r4,r2
81124bd4:	180b883a 	mov	r5,r3
81124bd8:	a5c00044 	addi	r23,r20,1
81124bdc:	b53fd91e 	bne	r22,r20,81124b44 <__reset+0xfb104b44>
81124be0:	100d883a 	mov	r6,r2
81124be4:	180f883a 	mov	r7,r3
81124be8:	1009883a 	mov	r4,r2
81124bec:	180b883a 	mov	r5,r3
81124bf0:	112fa6c0 	call	8112fa6c <__adddf3>
81124bf4:	100d883a 	mov	r6,r2
81124bf8:	180f883a 	mov	r7,r3
81124bfc:	8009883a 	mov	r4,r16
81124c00:	880b883a 	mov	r5,r17
81124c04:	1027883a 	mov	r19,r2
81124c08:	1825883a 	mov	r18,r3
81124c0c:	1130d740 	call	81130d74 <__ledf2>
81124c10:	10000816 	blt	r2,zero,81124c34 <_dtoa_r+0x950>
81124c14:	980d883a 	mov	r6,r19
81124c18:	900f883a 	mov	r7,r18
81124c1c:	8009883a 	mov	r4,r16
81124c20:	880b883a 	mov	r5,r17
81124c24:	1130c100 	call	81130c10 <__eqdf2>
81124c28:	103f5a1e 	bne	r2,zero,81124994 <__reset+0xfb104994>
81124c2c:	ad40004c 	andi	r21,r21,1
81124c30:	a83f5826 	beq	r21,zero,81124994 <__reset+0xfb104994>
81124c34:	bd3fffc3 	ldbu	r20,-1(r23)
81124c38:	b8bfffc4 	addi	r2,r23,-1
81124c3c:	1007883a 	mov	r3,r2
81124c40:	01400e44 	movi	r5,57
81124c44:	d9800717 	ldw	r6,28(sp)
81124c48:	00000506 	br	81124c60 <_dtoa_r+0x97c>
81124c4c:	18ffffc4 	addi	r3,r3,-1
81124c50:	11824726 	beq	r2,r6,81125570 <_dtoa_r+0x128c>
81124c54:	1d000003 	ldbu	r20,0(r3)
81124c58:	102f883a 	mov	r23,r2
81124c5c:	10bfffc4 	addi	r2,r2,-1
81124c60:	a1003fcc 	andi	r4,r20,255
81124c64:	2100201c 	xori	r4,r4,128
81124c68:	213fe004 	addi	r4,r4,-128
81124c6c:	217ff726 	beq	r4,r5,81124c4c <__reset+0xfb104c4c>
81124c70:	a2000044 	addi	r8,r20,1
81124c74:	12000005 	stb	r8,0(r2)
81124c78:	003f4606 	br	81124994 <__reset+0xfb104994>
81124c7c:	d9000b17 	ldw	r4,44(sp)
81124c80:	2000c826 	beq	r4,zero,81124fa4 <_dtoa_r+0xcc0>
81124c84:	d9800317 	ldw	r6,12(sp)
81124c88:	00c00044 	movi	r3,1
81124c8c:	1980f90e 	bge	r3,r6,81125074 <_dtoa_r+0xd90>
81124c90:	d8800617 	ldw	r2,24(sp)
81124c94:	d8c00a17 	ldw	r3,40(sp)
81124c98:	157fffc4 	addi	r21,r2,-1
81124c9c:	1d41f316 	blt	r3,r21,8112546c <_dtoa_r+0x1188>
81124ca0:	1d6bc83a 	sub	r21,r3,r21
81124ca4:	d9c00617 	ldw	r7,24(sp)
81124ca8:	3802aa16 	blt	r7,zero,81125754 <_dtoa_r+0x1470>
81124cac:	dd000817 	ldw	r20,32(sp)
81124cb0:	d8800617 	ldw	r2,24(sp)
81124cb4:	d8c00817 	ldw	r3,32(sp)
81124cb8:	01400044 	movi	r5,1
81124cbc:	e009883a 	mov	r4,fp
81124cc0:	1887883a 	add	r3,r3,r2
81124cc4:	d8c00815 	stw	r3,32(sp)
81124cc8:	b0ad883a 	add	r22,r22,r2
81124ccc:	11278200 	call	81127820 <__i2b>
81124cd0:	1023883a 	mov	r17,r2
81124cd4:	a0000826 	beq	r20,zero,81124cf8 <_dtoa_r+0xa14>
81124cd8:	0580070e 	bge	zero,r22,81124cf8 <_dtoa_r+0xa14>
81124cdc:	a005883a 	mov	r2,r20
81124ce0:	b500b916 	blt	r22,r20,81124fc8 <_dtoa_r+0xce4>
81124ce4:	d9000817 	ldw	r4,32(sp)
81124ce8:	a0a9c83a 	sub	r20,r20,r2
81124cec:	b0adc83a 	sub	r22,r22,r2
81124cf0:	2089c83a 	sub	r4,r4,r2
81124cf4:	d9000815 	stw	r4,32(sp)
81124cf8:	d9800a17 	ldw	r6,40(sp)
81124cfc:	0181810e 	bge	zero,r6,81125304 <_dtoa_r+0x1020>
81124d00:	d9c00b17 	ldw	r7,44(sp)
81124d04:	3800b326 	beq	r7,zero,81124fd4 <_dtoa_r+0xcf0>
81124d08:	a800b226 	beq	r21,zero,81124fd4 <_dtoa_r+0xcf0>
81124d0c:	880b883a 	mov	r5,r17
81124d10:	a80d883a 	mov	r6,r21
81124d14:	e009883a 	mov	r4,fp
81124d18:	1127a640 	call	81127a64 <__pow5mult>
81124d1c:	d9800917 	ldw	r6,36(sp)
81124d20:	100b883a 	mov	r5,r2
81124d24:	e009883a 	mov	r4,fp
81124d28:	1023883a 	mov	r17,r2
81124d2c:	11278640 	call	81127864 <__multiply>
81124d30:	1021883a 	mov	r16,r2
81124d34:	d8800a17 	ldw	r2,40(sp)
81124d38:	d9400917 	ldw	r5,36(sp)
81124d3c:	e009883a 	mov	r4,fp
81124d40:	1545c83a 	sub	r2,r2,r21
81124d44:	d8800a15 	stw	r2,40(sp)
81124d48:	11274ac0 	call	811274ac <_Bfree>
81124d4c:	d8c00a17 	ldw	r3,40(sp)
81124d50:	18009f1e 	bne	r3,zero,81124fd0 <_dtoa_r+0xcec>
81124d54:	05c00044 	movi	r23,1
81124d58:	e009883a 	mov	r4,fp
81124d5c:	b80b883a 	mov	r5,r23
81124d60:	11278200 	call	81127820 <__i2b>
81124d64:	d9000d17 	ldw	r4,52(sp)
81124d68:	102b883a 	mov	r21,r2
81124d6c:	2000ce26 	beq	r4,zero,811250a8 <_dtoa_r+0xdc4>
81124d70:	200d883a 	mov	r6,r4
81124d74:	100b883a 	mov	r5,r2
81124d78:	e009883a 	mov	r4,fp
81124d7c:	1127a640 	call	81127a64 <__pow5mult>
81124d80:	d9800317 	ldw	r6,12(sp)
81124d84:	102b883a 	mov	r21,r2
81124d88:	b981810e 	bge	r23,r6,81125390 <_dtoa_r+0x10ac>
81124d8c:	0027883a 	mov	r19,zero
81124d90:	a8800417 	ldw	r2,16(r21)
81124d94:	05c00804 	movi	r23,32
81124d98:	10800104 	addi	r2,r2,4
81124d9c:	1085883a 	add	r2,r2,r2
81124da0:	1085883a 	add	r2,r2,r2
81124da4:	a885883a 	add	r2,r21,r2
81124da8:	11000017 	ldw	r4,0(r2)
81124dac:	11277080 	call	81127708 <__hi0bits>
81124db0:	b885c83a 	sub	r2,r23,r2
81124db4:	1585883a 	add	r2,r2,r22
81124db8:	108007cc 	andi	r2,r2,31
81124dbc:	1000b326 	beq	r2,zero,8112508c <_dtoa_r+0xda8>
81124dc0:	00c00804 	movi	r3,32
81124dc4:	1887c83a 	sub	r3,r3,r2
81124dc8:	01000104 	movi	r4,4
81124dcc:	20c2cd0e 	bge	r4,r3,81125904 <_dtoa_r+0x1620>
81124dd0:	00c00704 	movi	r3,28
81124dd4:	1885c83a 	sub	r2,r3,r2
81124dd8:	d8c00817 	ldw	r3,32(sp)
81124ddc:	a0a9883a 	add	r20,r20,r2
81124de0:	b0ad883a 	add	r22,r22,r2
81124de4:	1887883a 	add	r3,r3,r2
81124de8:	d8c00815 	stw	r3,32(sp)
81124dec:	d9800817 	ldw	r6,32(sp)
81124df0:	0180040e 	bge	zero,r6,81124e04 <_dtoa_r+0xb20>
81124df4:	800b883a 	mov	r5,r16
81124df8:	e009883a 	mov	r4,fp
81124dfc:	1127bac0 	call	81127bac <__lshift>
81124e00:	1021883a 	mov	r16,r2
81124e04:	0580050e 	bge	zero,r22,81124e1c <_dtoa_r+0xb38>
81124e08:	a80b883a 	mov	r5,r21
81124e0c:	b00d883a 	mov	r6,r22
81124e10:	e009883a 	mov	r4,fp
81124e14:	1127bac0 	call	81127bac <__lshift>
81124e18:	102b883a 	mov	r21,r2
81124e1c:	d9c00e17 	ldw	r7,56(sp)
81124e20:	3801211e 	bne	r7,zero,811252a8 <_dtoa_r+0xfc4>
81124e24:	d9800617 	ldw	r6,24(sp)
81124e28:	0181380e 	bge	zero,r6,8112530c <_dtoa_r+0x1028>
81124e2c:	d8c00b17 	ldw	r3,44(sp)
81124e30:	1800ab1e 	bne	r3,zero,811250e0 <_dtoa_r+0xdfc>
81124e34:	dc800717 	ldw	r18,28(sp)
81124e38:	dcc00617 	ldw	r19,24(sp)
81124e3c:	9029883a 	mov	r20,r18
81124e40:	00000206 	br	81124e4c <_dtoa_r+0xb68>
81124e44:	11274d40 	call	811274d4 <__multadd>
81124e48:	1021883a 	mov	r16,r2
81124e4c:	a80b883a 	mov	r5,r21
81124e50:	8009883a 	mov	r4,r16
81124e54:	11240dc0 	call	811240dc <quorem>
81124e58:	10800c04 	addi	r2,r2,48
81124e5c:	90800005 	stb	r2,0(r18)
81124e60:	94800044 	addi	r18,r18,1
81124e64:	9507c83a 	sub	r3,r18,r20
81124e68:	000f883a 	mov	r7,zero
81124e6c:	01800284 	movi	r6,10
81124e70:	800b883a 	mov	r5,r16
81124e74:	e009883a 	mov	r4,fp
81124e78:	1cfff216 	blt	r3,r19,81124e44 <__reset+0xfb104e44>
81124e7c:	1011883a 	mov	r8,r2
81124e80:	d8800617 	ldw	r2,24(sp)
81124e84:	0082370e 	bge	zero,r2,81125764 <_dtoa_r+0x1480>
81124e88:	d9000717 	ldw	r4,28(sp)
81124e8c:	0025883a 	mov	r18,zero
81124e90:	20af883a 	add	r23,r4,r2
81124e94:	01800044 	movi	r6,1
81124e98:	800b883a 	mov	r5,r16
81124e9c:	e009883a 	mov	r4,fp
81124ea0:	da001715 	stw	r8,92(sp)
81124ea4:	1127bac0 	call	81127bac <__lshift>
81124ea8:	a80b883a 	mov	r5,r21
81124eac:	1009883a 	mov	r4,r2
81124eb0:	d8800915 	stw	r2,36(sp)
81124eb4:	1127cfc0 	call	81127cfc <__mcmp>
81124eb8:	da001717 	ldw	r8,92(sp)
81124ebc:	0081800e 	bge	zero,r2,811254c0 <_dtoa_r+0x11dc>
81124ec0:	b93fffc3 	ldbu	r4,-1(r23)
81124ec4:	b8bfffc4 	addi	r2,r23,-1
81124ec8:	1007883a 	mov	r3,r2
81124ecc:	01800e44 	movi	r6,57
81124ed0:	d9c00717 	ldw	r7,28(sp)
81124ed4:	00000506 	br	81124eec <_dtoa_r+0xc08>
81124ed8:	18ffffc4 	addi	r3,r3,-1
81124edc:	11c12326 	beq	r2,r7,8112536c <_dtoa_r+0x1088>
81124ee0:	19000003 	ldbu	r4,0(r3)
81124ee4:	102f883a 	mov	r23,r2
81124ee8:	10bfffc4 	addi	r2,r2,-1
81124eec:	21403fcc 	andi	r5,r4,255
81124ef0:	2940201c 	xori	r5,r5,128
81124ef4:	297fe004 	addi	r5,r5,-128
81124ef8:	29bff726 	beq	r5,r6,81124ed8 <__reset+0xfb104ed8>
81124efc:	21000044 	addi	r4,r4,1
81124f00:	11000005 	stb	r4,0(r2)
81124f04:	a80b883a 	mov	r5,r21
81124f08:	e009883a 	mov	r4,fp
81124f0c:	11274ac0 	call	811274ac <_Bfree>
81124f10:	883ea026 	beq	r17,zero,81124994 <__reset+0xfb104994>
81124f14:	90000426 	beq	r18,zero,81124f28 <_dtoa_r+0xc44>
81124f18:	94400326 	beq	r18,r17,81124f28 <_dtoa_r+0xc44>
81124f1c:	900b883a 	mov	r5,r18
81124f20:	e009883a 	mov	r4,fp
81124f24:	11274ac0 	call	811274ac <_Bfree>
81124f28:	880b883a 	mov	r5,r17
81124f2c:	e009883a 	mov	r4,fp
81124f30:	11274ac0 	call	811274ac <_Bfree>
81124f34:	003e9706 	br	81124994 <__reset+0xfb104994>
81124f38:	01800044 	movi	r6,1
81124f3c:	d9800e15 	stw	r6,56(sp)
81124f40:	003d9606 	br	8112459c <__reset+0xfb10459c>
81124f44:	d8800817 	ldw	r2,32(sp)
81124f48:	d8c00517 	ldw	r3,20(sp)
81124f4c:	d8000d15 	stw	zero,52(sp)
81124f50:	10c5c83a 	sub	r2,r2,r3
81124f54:	00c9c83a 	sub	r4,zero,r3
81124f58:	d8800815 	stw	r2,32(sp)
81124f5c:	d9000a15 	stw	r4,40(sp)
81124f60:	003d9706 	br	811245c0 <__reset+0xfb1045c0>
81124f64:	05adc83a 	sub	r22,zero,r22
81124f68:	dd800815 	stw	r22,32(sp)
81124f6c:	002d883a 	mov	r22,zero
81124f70:	003d8e06 	br	811245ac <__reset+0xfb1045ac>
81124f74:	d9000517 	ldw	r4,20(sp)
81124f78:	11317ec0 	call	811317ec <__floatsidf>
81124f7c:	100d883a 	mov	r6,r2
81124f80:	180f883a 	mov	r7,r3
81124f84:	a009883a 	mov	r4,r20
81124f88:	880b883a 	mov	r5,r17
81124f8c:	1130c100 	call	81130c10 <__eqdf2>
81124f90:	103d7126 	beq	r2,zero,81124558 <__reset+0xfb104558>
81124f94:	d9c00517 	ldw	r7,20(sp)
81124f98:	39ffffc4 	addi	r7,r7,-1
81124f9c:	d9c00515 	stw	r7,20(sp)
81124fa0:	003d6d06 	br	81124558 <__reset+0xfb104558>
81124fa4:	dd400a17 	ldw	r21,40(sp)
81124fa8:	dd000817 	ldw	r20,32(sp)
81124fac:	0023883a 	mov	r17,zero
81124fb0:	003f4806 	br	81124cd4 <__reset+0xfb104cd4>
81124fb4:	10e3c83a 	sub	r17,r2,r3
81124fb8:	9448983a 	sll	r4,r18,r17
81124fbc:	003d3206 	br	81124488 <__reset+0xfb104488>
81124fc0:	d8000e15 	stw	zero,56(sp)
81124fc4:	003d7506 	br	8112459c <__reset+0xfb10459c>
81124fc8:	b005883a 	mov	r2,r22
81124fcc:	003f4506 	br	81124ce4 <__reset+0xfb104ce4>
81124fd0:	dc000915 	stw	r16,36(sp)
81124fd4:	d9800a17 	ldw	r6,40(sp)
81124fd8:	d9400917 	ldw	r5,36(sp)
81124fdc:	e009883a 	mov	r4,fp
81124fe0:	1127a640 	call	81127a64 <__pow5mult>
81124fe4:	1021883a 	mov	r16,r2
81124fe8:	003f5a06 	br	81124d54 <__reset+0xfb104d54>
81124fec:	01c00044 	movi	r7,1
81124ff0:	d9c00b15 	stw	r7,44(sp)
81124ff4:	d8802217 	ldw	r2,136(sp)
81124ff8:	0081280e 	bge	zero,r2,8112549c <_dtoa_r+0x11b8>
81124ffc:	100d883a 	mov	r6,r2
81125000:	1021883a 	mov	r16,r2
81125004:	d8800c15 	stw	r2,48(sp)
81125008:	d8800615 	stw	r2,24(sp)
8112500c:	003d8806 	br	81124630 <__reset+0xfb104630>
81125010:	d8800617 	ldw	r2,24(sp)
81125014:	00be9b16 	blt	zero,r2,81124a84 <__reset+0xfb104a84>
81125018:	10010f1e 	bne	r2,zero,81125458 <_dtoa_r+0x1174>
8112501c:	880b883a 	mov	r5,r17
81125020:	000d883a 	mov	r6,zero
81125024:	01d00534 	movhi	r7,16404
81125028:	8009883a 	mov	r4,r16
8112502c:	111b57c0 	call	8111b57c <__muldf3>
81125030:	900d883a 	mov	r6,r18
81125034:	980f883a 	mov	r7,r19
81125038:	1009883a 	mov	r4,r2
8112503c:	180b883a 	mov	r5,r3
81125040:	1130c980 	call	81130c98 <__gedf2>
81125044:	002b883a 	mov	r21,zero
81125048:	0023883a 	mov	r17,zero
8112504c:	1000bf16 	blt	r2,zero,8112534c <_dtoa_r+0x1068>
81125050:	d9802217 	ldw	r6,136(sp)
81125054:	ddc00717 	ldw	r23,28(sp)
81125058:	018c303a 	nor	r6,zero,r6
8112505c:	d9800515 	stw	r6,20(sp)
81125060:	a80b883a 	mov	r5,r21
81125064:	e009883a 	mov	r4,fp
81125068:	11274ac0 	call	811274ac <_Bfree>
8112506c:	883e4926 	beq	r17,zero,81124994 <__reset+0xfb104994>
81125070:	003fad06 	br	81124f28 <__reset+0xfb104f28>
81125074:	d9c01117 	ldw	r7,68(sp)
81125078:	3801bc26 	beq	r7,zero,8112576c <_dtoa_r+0x1488>
8112507c:	10810cc4 	addi	r2,r2,1075
81125080:	dd400a17 	ldw	r21,40(sp)
81125084:	dd000817 	ldw	r20,32(sp)
81125088:	003f0a06 	br	81124cb4 <__reset+0xfb104cb4>
8112508c:	00800704 	movi	r2,28
81125090:	d9000817 	ldw	r4,32(sp)
81125094:	a0a9883a 	add	r20,r20,r2
81125098:	b0ad883a 	add	r22,r22,r2
8112509c:	2089883a 	add	r4,r4,r2
811250a0:	d9000815 	stw	r4,32(sp)
811250a4:	003f5106 	br	81124dec <__reset+0xfb104dec>
811250a8:	d8c00317 	ldw	r3,12(sp)
811250ac:	b8c1fc0e 	bge	r23,r3,811258a0 <_dtoa_r+0x15bc>
811250b0:	0027883a 	mov	r19,zero
811250b4:	b805883a 	mov	r2,r23
811250b8:	003f3e06 	br	81124db4 <__reset+0xfb104db4>
811250bc:	880b883a 	mov	r5,r17
811250c0:	e009883a 	mov	r4,fp
811250c4:	000f883a 	mov	r7,zero
811250c8:	01800284 	movi	r6,10
811250cc:	11274d40 	call	811274d4 <__multadd>
811250d0:	d9000c17 	ldw	r4,48(sp)
811250d4:	1023883a 	mov	r17,r2
811250d8:	0102040e 	bge	zero,r4,811258ec <_dtoa_r+0x1608>
811250dc:	d9000615 	stw	r4,24(sp)
811250e0:	0500050e 	bge	zero,r20,811250f8 <_dtoa_r+0xe14>
811250e4:	880b883a 	mov	r5,r17
811250e8:	a00d883a 	mov	r6,r20
811250ec:	e009883a 	mov	r4,fp
811250f0:	1127bac0 	call	81127bac <__lshift>
811250f4:	1023883a 	mov	r17,r2
811250f8:	9801241e 	bne	r19,zero,8112558c <_dtoa_r+0x12a8>
811250fc:	8829883a 	mov	r20,r17
81125100:	d9000617 	ldw	r4,24(sp)
81125104:	dcc00717 	ldw	r19,28(sp)
81125108:	9480004c 	andi	r18,r18,1
8112510c:	20bfffc4 	addi	r2,r4,-1
81125110:	9885883a 	add	r2,r19,r2
81125114:	d8800415 	stw	r2,16(sp)
81125118:	dc800615 	stw	r18,24(sp)
8112511c:	a80b883a 	mov	r5,r21
81125120:	8009883a 	mov	r4,r16
81125124:	11240dc0 	call	811240dc <quorem>
81125128:	880b883a 	mov	r5,r17
8112512c:	8009883a 	mov	r4,r16
81125130:	102f883a 	mov	r23,r2
81125134:	1127cfc0 	call	81127cfc <__mcmp>
81125138:	a80b883a 	mov	r5,r21
8112513c:	a00d883a 	mov	r6,r20
81125140:	e009883a 	mov	r4,fp
81125144:	102d883a 	mov	r22,r2
81125148:	1127d5c0 	call	81127d5c <__mdiff>
8112514c:	1007883a 	mov	r3,r2
81125150:	10800317 	ldw	r2,12(r2)
81125154:	bc800c04 	addi	r18,r23,48
81125158:	180b883a 	mov	r5,r3
8112515c:	10004e1e 	bne	r2,zero,81125298 <_dtoa_r+0xfb4>
81125160:	8009883a 	mov	r4,r16
81125164:	d8c01615 	stw	r3,88(sp)
81125168:	1127cfc0 	call	81127cfc <__mcmp>
8112516c:	d8c01617 	ldw	r3,88(sp)
81125170:	e009883a 	mov	r4,fp
81125174:	d8801615 	stw	r2,88(sp)
81125178:	180b883a 	mov	r5,r3
8112517c:	11274ac0 	call	811274ac <_Bfree>
81125180:	d8801617 	ldw	r2,88(sp)
81125184:	1000041e 	bne	r2,zero,81125198 <_dtoa_r+0xeb4>
81125188:	d9800317 	ldw	r6,12(sp)
8112518c:	3000021e 	bne	r6,zero,81125198 <_dtoa_r+0xeb4>
81125190:	d8c00617 	ldw	r3,24(sp)
81125194:	18003726 	beq	r3,zero,81125274 <_dtoa_r+0xf90>
81125198:	b0002016 	blt	r22,zero,8112521c <_dtoa_r+0xf38>
8112519c:	b000041e 	bne	r22,zero,811251b0 <_dtoa_r+0xecc>
811251a0:	d9000317 	ldw	r4,12(sp)
811251a4:	2000021e 	bne	r4,zero,811251b0 <_dtoa_r+0xecc>
811251a8:	d8c00617 	ldw	r3,24(sp)
811251ac:	18001b26 	beq	r3,zero,8112521c <_dtoa_r+0xf38>
811251b0:	00810716 	blt	zero,r2,811255d0 <_dtoa_r+0x12ec>
811251b4:	d8c00417 	ldw	r3,16(sp)
811251b8:	9d800044 	addi	r22,r19,1
811251bc:	9c800005 	stb	r18,0(r19)
811251c0:	b02f883a 	mov	r23,r22
811251c4:	98c10626 	beq	r19,r3,811255e0 <_dtoa_r+0x12fc>
811251c8:	800b883a 	mov	r5,r16
811251cc:	000f883a 	mov	r7,zero
811251d0:	01800284 	movi	r6,10
811251d4:	e009883a 	mov	r4,fp
811251d8:	11274d40 	call	811274d4 <__multadd>
811251dc:	1021883a 	mov	r16,r2
811251e0:	000f883a 	mov	r7,zero
811251e4:	01800284 	movi	r6,10
811251e8:	880b883a 	mov	r5,r17
811251ec:	e009883a 	mov	r4,fp
811251f0:	8d002526 	beq	r17,r20,81125288 <_dtoa_r+0xfa4>
811251f4:	11274d40 	call	811274d4 <__multadd>
811251f8:	a00b883a 	mov	r5,r20
811251fc:	000f883a 	mov	r7,zero
81125200:	01800284 	movi	r6,10
81125204:	e009883a 	mov	r4,fp
81125208:	1023883a 	mov	r17,r2
8112520c:	11274d40 	call	811274d4 <__multadd>
81125210:	1029883a 	mov	r20,r2
81125214:	b027883a 	mov	r19,r22
81125218:	003fc006 	br	8112511c <__reset+0xfb10511c>
8112521c:	9011883a 	mov	r8,r18
81125220:	00800e0e 	bge	zero,r2,8112525c <_dtoa_r+0xf78>
81125224:	800b883a 	mov	r5,r16
81125228:	01800044 	movi	r6,1
8112522c:	e009883a 	mov	r4,fp
81125230:	da001715 	stw	r8,92(sp)
81125234:	1127bac0 	call	81127bac <__lshift>
81125238:	a80b883a 	mov	r5,r21
8112523c:	1009883a 	mov	r4,r2
81125240:	1021883a 	mov	r16,r2
81125244:	1127cfc0 	call	81127cfc <__mcmp>
81125248:	da001717 	ldw	r8,92(sp)
8112524c:	0081960e 	bge	zero,r2,811258a8 <_dtoa_r+0x15c4>
81125250:	00800e44 	movi	r2,57
81125254:	40817026 	beq	r8,r2,81125818 <_dtoa_r+0x1534>
81125258:	ba000c44 	addi	r8,r23,49
8112525c:	8825883a 	mov	r18,r17
81125260:	9dc00044 	addi	r23,r19,1
81125264:	9a000005 	stb	r8,0(r19)
81125268:	a023883a 	mov	r17,r20
8112526c:	dc000915 	stw	r16,36(sp)
81125270:	003f2406 	br	81124f04 <__reset+0xfb104f04>
81125274:	00800e44 	movi	r2,57
81125278:	9011883a 	mov	r8,r18
8112527c:	90816626 	beq	r18,r2,81125818 <_dtoa_r+0x1534>
81125280:	05bff516 	blt	zero,r22,81125258 <__reset+0xfb105258>
81125284:	003ff506 	br	8112525c <__reset+0xfb10525c>
81125288:	11274d40 	call	811274d4 <__multadd>
8112528c:	1023883a 	mov	r17,r2
81125290:	1029883a 	mov	r20,r2
81125294:	003fdf06 	br	81125214 <__reset+0xfb105214>
81125298:	e009883a 	mov	r4,fp
8112529c:	11274ac0 	call	811274ac <_Bfree>
811252a0:	00800044 	movi	r2,1
811252a4:	003fbc06 	br	81125198 <__reset+0xfb105198>
811252a8:	a80b883a 	mov	r5,r21
811252ac:	8009883a 	mov	r4,r16
811252b0:	1127cfc0 	call	81127cfc <__mcmp>
811252b4:	103edb0e 	bge	r2,zero,81124e24 <__reset+0xfb104e24>
811252b8:	800b883a 	mov	r5,r16
811252bc:	000f883a 	mov	r7,zero
811252c0:	01800284 	movi	r6,10
811252c4:	e009883a 	mov	r4,fp
811252c8:	11274d40 	call	811274d4 <__multadd>
811252cc:	1021883a 	mov	r16,r2
811252d0:	d8800517 	ldw	r2,20(sp)
811252d4:	d8c00b17 	ldw	r3,44(sp)
811252d8:	10bfffc4 	addi	r2,r2,-1
811252dc:	d8800515 	stw	r2,20(sp)
811252e0:	183f761e 	bne	r3,zero,811250bc <__reset+0xfb1050bc>
811252e4:	d9000c17 	ldw	r4,48(sp)
811252e8:	0101730e 	bge	zero,r4,811258b8 <_dtoa_r+0x15d4>
811252ec:	d9000615 	stw	r4,24(sp)
811252f0:	003ed006 	br	81124e34 <__reset+0xfb104e34>
811252f4:	00800084 	movi	r2,2
811252f8:	3081861e 	bne	r6,r2,81125914 <_dtoa_r+0x1630>
811252fc:	d8000b15 	stw	zero,44(sp)
81125300:	003f3c06 	br	81124ff4 <__reset+0xfb104ff4>
81125304:	dc000917 	ldw	r16,36(sp)
81125308:	003e9206 	br	81124d54 <__reset+0xfb104d54>
8112530c:	d9c00317 	ldw	r7,12(sp)
81125310:	00800084 	movi	r2,2
81125314:	11fec50e 	bge	r2,r7,81124e2c <__reset+0xfb104e2c>
81125318:	d9000617 	ldw	r4,24(sp)
8112531c:	20013c1e 	bne	r4,zero,81125810 <_dtoa_r+0x152c>
81125320:	a80b883a 	mov	r5,r21
81125324:	000f883a 	mov	r7,zero
81125328:	01800144 	movi	r6,5
8112532c:	e009883a 	mov	r4,fp
81125330:	11274d40 	call	811274d4 <__multadd>
81125334:	100b883a 	mov	r5,r2
81125338:	8009883a 	mov	r4,r16
8112533c:	102b883a 	mov	r21,r2
81125340:	1127cfc0 	call	81127cfc <__mcmp>
81125344:	dc000915 	stw	r16,36(sp)
81125348:	00bf410e 	bge	zero,r2,81125050 <__reset+0xfb105050>
8112534c:	d9c00717 	ldw	r7,28(sp)
81125350:	00800c44 	movi	r2,49
81125354:	38800005 	stb	r2,0(r7)
81125358:	d8800517 	ldw	r2,20(sp)
8112535c:	3dc00044 	addi	r23,r7,1
81125360:	10800044 	addi	r2,r2,1
81125364:	d8800515 	stw	r2,20(sp)
81125368:	003f3d06 	br	81125060 <__reset+0xfb105060>
8112536c:	d9800517 	ldw	r6,20(sp)
81125370:	d9c00717 	ldw	r7,28(sp)
81125374:	00800c44 	movi	r2,49
81125378:	31800044 	addi	r6,r6,1
8112537c:	d9800515 	stw	r6,20(sp)
81125380:	38800005 	stb	r2,0(r7)
81125384:	003edf06 	br	81124f04 <__reset+0xfb104f04>
81125388:	d8000b15 	stw	zero,44(sp)
8112538c:	003c9f06 	br	8112460c <__reset+0xfb10460c>
81125390:	903e7e1e 	bne	r18,zero,81124d8c <__reset+0xfb104d8c>
81125394:	00800434 	movhi	r2,16
81125398:	10bfffc4 	addi	r2,r2,-1
8112539c:	9884703a 	and	r2,r19,r2
811253a0:	1000ea1e 	bne	r2,zero,8112574c <_dtoa_r+0x1468>
811253a4:	9cdffc2c 	andhi	r19,r19,32752
811253a8:	9800e826 	beq	r19,zero,8112574c <_dtoa_r+0x1468>
811253ac:	d9c00817 	ldw	r7,32(sp)
811253b0:	b5800044 	addi	r22,r22,1
811253b4:	04c00044 	movi	r19,1
811253b8:	39c00044 	addi	r7,r7,1
811253bc:	d9c00815 	stw	r7,32(sp)
811253c0:	d8800d17 	ldw	r2,52(sp)
811253c4:	103e721e 	bne	r2,zero,81124d90 <__reset+0xfb104d90>
811253c8:	00800044 	movi	r2,1
811253cc:	003e7906 	br	81124db4 <__reset+0xfb104db4>
811253d0:	8009883a 	mov	r4,r16
811253d4:	11317ec0 	call	811317ec <__floatsidf>
811253d8:	d9800f17 	ldw	r6,60(sp)
811253dc:	d9c01017 	ldw	r7,64(sp)
811253e0:	1009883a 	mov	r4,r2
811253e4:	180b883a 	mov	r5,r3
811253e8:	111b57c0 	call	8111b57c <__muldf3>
811253ec:	000d883a 	mov	r6,zero
811253f0:	01d00734 	movhi	r7,16412
811253f4:	1009883a 	mov	r4,r2
811253f8:	180b883a 	mov	r5,r3
811253fc:	112fa6c0 	call	8112fa6c <__adddf3>
81125400:	047f3034 	movhi	r17,64704
81125404:	1021883a 	mov	r16,r2
81125408:	1c63883a 	add	r17,r3,r17
8112540c:	d9000f17 	ldw	r4,60(sp)
81125410:	d9401017 	ldw	r5,64(sp)
81125414:	000d883a 	mov	r6,zero
81125418:	01d00534 	movhi	r7,16404
8112541c:	1130e680 	call	81130e68 <__subdf3>
81125420:	800d883a 	mov	r6,r16
81125424:	880f883a 	mov	r7,r17
81125428:	1009883a 	mov	r4,r2
8112542c:	180b883a 	mov	r5,r3
81125430:	102b883a 	mov	r21,r2
81125434:	1829883a 	mov	r20,r3
81125438:	1130c980 	call	81130c98 <__gedf2>
8112543c:	00806c16 	blt	zero,r2,811255f0 <_dtoa_r+0x130c>
81125440:	89e0003c 	xorhi	r7,r17,32768
81125444:	800d883a 	mov	r6,r16
81125448:	a809883a 	mov	r4,r21
8112544c:	a00b883a 	mov	r5,r20
81125450:	1130d740 	call	81130d74 <__ledf2>
81125454:	103d7e0e 	bge	r2,zero,81124a50 <__reset+0xfb104a50>
81125458:	002b883a 	mov	r21,zero
8112545c:	0023883a 	mov	r17,zero
81125460:	003efb06 	br	81125050 <__reset+0xfb105050>
81125464:	d8800717 	ldw	r2,28(sp)
81125468:	003bd006 	br	811243ac <__reset+0xfb1043ac>
8112546c:	d9000a17 	ldw	r4,40(sp)
81125470:	d9800d17 	ldw	r6,52(sp)
81125474:	dd400a15 	stw	r21,40(sp)
81125478:	a905c83a 	sub	r2,r21,r4
8112547c:	308d883a 	add	r6,r6,r2
81125480:	d9800d15 	stw	r6,52(sp)
81125484:	002b883a 	mov	r21,zero
81125488:	003e0606 	br	81124ca4 <__reset+0xfb104ca4>
8112548c:	9023883a 	mov	r17,r18
81125490:	9829883a 	mov	r20,r19
81125494:	04000084 	movi	r16,2
81125498:	003c9206 	br	811246e4 <__reset+0xfb1046e4>
8112549c:	04000044 	movi	r16,1
811254a0:	dc000c15 	stw	r16,48(sp)
811254a4:	dc000615 	stw	r16,24(sp)
811254a8:	dc002215 	stw	r16,136(sp)
811254ac:	e0001115 	stw	zero,68(fp)
811254b0:	000b883a 	mov	r5,zero
811254b4:	003c6906 	br	8112465c <__reset+0xfb10465c>
811254b8:	3021883a 	mov	r16,r6
811254bc:	003ffb06 	br	811254ac <__reset+0xfb1054ac>
811254c0:	1000021e 	bne	r2,zero,811254cc <_dtoa_r+0x11e8>
811254c4:	4200004c 	andi	r8,r8,1
811254c8:	403e7d1e 	bne	r8,zero,81124ec0 <__reset+0xfb104ec0>
811254cc:	01000c04 	movi	r4,48
811254d0:	00000106 	br	811254d8 <_dtoa_r+0x11f4>
811254d4:	102f883a 	mov	r23,r2
811254d8:	b8bfffc4 	addi	r2,r23,-1
811254dc:	10c00007 	ldb	r3,0(r2)
811254e0:	193ffc26 	beq	r3,r4,811254d4 <__reset+0xfb1054d4>
811254e4:	003e8706 	br	81124f04 <__reset+0xfb104f04>
811254e8:	d8800517 	ldw	r2,20(sp)
811254ec:	00a3c83a 	sub	r17,zero,r2
811254f0:	8800a426 	beq	r17,zero,81125784 <_dtoa_r+0x14a0>
811254f4:	888003cc 	andi	r2,r17,15
811254f8:	100490fa 	slli	r2,r2,3
811254fc:	00e04574 	movhi	r3,33045
81125500:	18ee4704 	addi	r3,r3,-18148
81125504:	1885883a 	add	r2,r3,r2
81125508:	11800017 	ldw	r6,0(r2)
8112550c:	11c00117 	ldw	r7,4(r2)
81125510:	9009883a 	mov	r4,r18
81125514:	980b883a 	mov	r5,r19
81125518:	8823d13a 	srai	r17,r17,4
8112551c:	111b57c0 	call	8111b57c <__muldf3>
81125520:	d8800f15 	stw	r2,60(sp)
81125524:	d8c01015 	stw	r3,64(sp)
81125528:	8800e826 	beq	r17,zero,811258cc <_dtoa_r+0x15e8>
8112552c:	05204574 	movhi	r20,33045
81125530:	a52e3d04 	addi	r20,r20,-18188
81125534:	04000084 	movi	r16,2
81125538:	8980004c 	andi	r6,r17,1
8112553c:	1009883a 	mov	r4,r2
81125540:	8823d07a 	srai	r17,r17,1
81125544:	180b883a 	mov	r5,r3
81125548:	30000426 	beq	r6,zero,8112555c <_dtoa_r+0x1278>
8112554c:	a1800017 	ldw	r6,0(r20)
81125550:	a1c00117 	ldw	r7,4(r20)
81125554:	84000044 	addi	r16,r16,1
81125558:	111b57c0 	call	8111b57c <__muldf3>
8112555c:	a5000204 	addi	r20,r20,8
81125560:	883ff51e 	bne	r17,zero,81125538 <__reset+0xfb105538>
81125564:	d8800f15 	stw	r2,60(sp)
81125568:	d8c01015 	stw	r3,64(sp)
8112556c:	003c7606 	br	81124748 <__reset+0xfb104748>
81125570:	00c00c04 	movi	r3,48
81125574:	10c00005 	stb	r3,0(r2)
81125578:	d8c00517 	ldw	r3,20(sp)
8112557c:	bd3fffc3 	ldbu	r20,-1(r23)
81125580:	18c00044 	addi	r3,r3,1
81125584:	d8c00515 	stw	r3,20(sp)
81125588:	003db906 	br	81124c70 <__reset+0xfb104c70>
8112558c:	89400117 	ldw	r5,4(r17)
81125590:	e009883a 	mov	r4,fp
81125594:	11273fc0 	call	811273fc <_Balloc>
81125598:	89800417 	ldw	r6,16(r17)
8112559c:	89400304 	addi	r5,r17,12
811255a0:	11000304 	addi	r4,r2,12
811255a4:	31800084 	addi	r6,r6,2
811255a8:	318d883a 	add	r6,r6,r6
811255ac:	318d883a 	add	r6,r6,r6
811255b0:	1027883a 	mov	r19,r2
811255b4:	111d1cc0 	call	8111d1cc <memcpy>
811255b8:	01800044 	movi	r6,1
811255bc:	980b883a 	mov	r5,r19
811255c0:	e009883a 	mov	r4,fp
811255c4:	1127bac0 	call	81127bac <__lshift>
811255c8:	1029883a 	mov	r20,r2
811255cc:	003ecc06 	br	81125100 <__reset+0xfb105100>
811255d0:	00800e44 	movi	r2,57
811255d4:	90809026 	beq	r18,r2,81125818 <_dtoa_r+0x1534>
811255d8:	92000044 	addi	r8,r18,1
811255dc:	003f1f06 	br	8112525c <__reset+0xfb10525c>
811255e0:	9011883a 	mov	r8,r18
811255e4:	8825883a 	mov	r18,r17
811255e8:	a023883a 	mov	r17,r20
811255ec:	003e2906 	br	81124e94 <__reset+0xfb104e94>
811255f0:	002b883a 	mov	r21,zero
811255f4:	0023883a 	mov	r17,zero
811255f8:	003f5406 	br	8112534c <__reset+0xfb10534c>
811255fc:	61bfffc4 	addi	r6,r12,-1
81125600:	300490fa 	slli	r2,r6,3
81125604:	00e04574 	movhi	r3,33045
81125608:	18ee4704 	addi	r3,r3,-18148
8112560c:	1885883a 	add	r2,r3,r2
81125610:	11000017 	ldw	r4,0(r2)
81125614:	11400117 	ldw	r5,4(r2)
81125618:	d8800717 	ldw	r2,28(sp)
8112561c:	880f883a 	mov	r7,r17
81125620:	d9801215 	stw	r6,72(sp)
81125624:	800d883a 	mov	r6,r16
81125628:	db001615 	stw	r12,88(sp)
8112562c:	15c00044 	addi	r23,r2,1
81125630:	111b57c0 	call	8111b57c <__muldf3>
81125634:	d9401017 	ldw	r5,64(sp)
81125638:	d9000f17 	ldw	r4,60(sp)
8112563c:	d8c01515 	stw	r3,84(sp)
81125640:	d8801415 	stw	r2,80(sp)
81125644:	113176c0 	call	8113176c <__fixdfsi>
81125648:	1009883a 	mov	r4,r2
8112564c:	1021883a 	mov	r16,r2
81125650:	11317ec0 	call	811317ec <__floatsidf>
81125654:	d9000f17 	ldw	r4,60(sp)
81125658:	d9401017 	ldw	r5,64(sp)
8112565c:	100d883a 	mov	r6,r2
81125660:	180f883a 	mov	r7,r3
81125664:	1130e680 	call	81130e68 <__subdf3>
81125668:	1829883a 	mov	r20,r3
8112566c:	d8c00717 	ldw	r3,28(sp)
81125670:	84000c04 	addi	r16,r16,48
81125674:	1023883a 	mov	r17,r2
81125678:	1c000005 	stb	r16,0(r3)
8112567c:	db001617 	ldw	r12,88(sp)
81125680:	00800044 	movi	r2,1
81125684:	60802226 	beq	r12,r2,81125710 <_dtoa_r+0x142c>
81125688:	d9c00717 	ldw	r7,28(sp)
8112568c:	8805883a 	mov	r2,r17
81125690:	b82b883a 	mov	r21,r23
81125694:	3b19883a 	add	r12,r7,r12
81125698:	6023883a 	mov	r17,r12
8112569c:	a007883a 	mov	r3,r20
811256a0:	dc800f15 	stw	r18,60(sp)
811256a4:	000d883a 	mov	r6,zero
811256a8:	01d00934 	movhi	r7,16420
811256ac:	1009883a 	mov	r4,r2
811256b0:	180b883a 	mov	r5,r3
811256b4:	111b57c0 	call	8111b57c <__muldf3>
811256b8:	180b883a 	mov	r5,r3
811256bc:	1009883a 	mov	r4,r2
811256c0:	1829883a 	mov	r20,r3
811256c4:	1025883a 	mov	r18,r2
811256c8:	113176c0 	call	8113176c <__fixdfsi>
811256cc:	1009883a 	mov	r4,r2
811256d0:	1021883a 	mov	r16,r2
811256d4:	11317ec0 	call	811317ec <__floatsidf>
811256d8:	100d883a 	mov	r6,r2
811256dc:	180f883a 	mov	r7,r3
811256e0:	9009883a 	mov	r4,r18
811256e4:	a00b883a 	mov	r5,r20
811256e8:	84000c04 	addi	r16,r16,48
811256ec:	1130e680 	call	81130e68 <__subdf3>
811256f0:	ad400044 	addi	r21,r21,1
811256f4:	ac3fffc5 	stb	r16,-1(r21)
811256f8:	ac7fea1e 	bne	r21,r17,811256a4 <__reset+0xfb1056a4>
811256fc:	1023883a 	mov	r17,r2
81125700:	d8801217 	ldw	r2,72(sp)
81125704:	dc800f17 	ldw	r18,60(sp)
81125708:	1829883a 	mov	r20,r3
8112570c:	b8af883a 	add	r23,r23,r2
81125710:	d9001417 	ldw	r4,80(sp)
81125714:	d9401517 	ldw	r5,84(sp)
81125718:	000d883a 	mov	r6,zero
8112571c:	01cff834 	movhi	r7,16352
81125720:	112fa6c0 	call	8112fa6c <__adddf3>
81125724:	880d883a 	mov	r6,r17
81125728:	a00f883a 	mov	r7,r20
8112572c:	1009883a 	mov	r4,r2
81125730:	180b883a 	mov	r5,r3
81125734:	1130d740 	call	81130d74 <__ledf2>
81125738:	10003e0e 	bge	r2,zero,81125834 <_dtoa_r+0x1550>
8112573c:	d9001317 	ldw	r4,76(sp)
81125740:	bd3fffc3 	ldbu	r20,-1(r23)
81125744:	d9000515 	stw	r4,20(sp)
81125748:	003d3b06 	br	81124c38 <__reset+0xfb104c38>
8112574c:	0027883a 	mov	r19,zero
81125750:	003f1b06 	br	811253c0 <__reset+0xfb1053c0>
81125754:	d8800817 	ldw	r2,32(sp)
81125758:	11e9c83a 	sub	r20,r2,r7
8112575c:	0005883a 	mov	r2,zero
81125760:	003d5406 	br	81124cb4 <__reset+0xfb104cb4>
81125764:	00800044 	movi	r2,1
81125768:	003dc706 	br	81124e88 <__reset+0xfb104e88>
8112576c:	d8c00217 	ldw	r3,8(sp)
81125770:	00800d84 	movi	r2,54
81125774:	dd400a17 	ldw	r21,40(sp)
81125778:	10c5c83a 	sub	r2,r2,r3
8112577c:	dd000817 	ldw	r20,32(sp)
81125780:	003d4c06 	br	81124cb4 <__reset+0xfb104cb4>
81125784:	dc800f15 	stw	r18,60(sp)
81125788:	dcc01015 	stw	r19,64(sp)
8112578c:	04000084 	movi	r16,2
81125790:	003bed06 	br	81124748 <__reset+0xfb104748>
81125794:	d9000617 	ldw	r4,24(sp)
81125798:	203f0d26 	beq	r4,zero,811253d0 <__reset+0xfb1053d0>
8112579c:	d9800c17 	ldw	r6,48(sp)
811257a0:	01bcab0e 	bge	zero,r6,81124a50 <__reset+0xfb104a50>
811257a4:	d9401017 	ldw	r5,64(sp)
811257a8:	d9000f17 	ldw	r4,60(sp)
811257ac:	000d883a 	mov	r6,zero
811257b0:	01d00934 	movhi	r7,16420
811257b4:	111b57c0 	call	8111b57c <__muldf3>
811257b8:	81000044 	addi	r4,r16,1
811257bc:	d8800f15 	stw	r2,60(sp)
811257c0:	d8c01015 	stw	r3,64(sp)
811257c4:	11317ec0 	call	811317ec <__floatsidf>
811257c8:	d9800f17 	ldw	r6,60(sp)
811257cc:	d9c01017 	ldw	r7,64(sp)
811257d0:	1009883a 	mov	r4,r2
811257d4:	180b883a 	mov	r5,r3
811257d8:	111b57c0 	call	8111b57c <__muldf3>
811257dc:	01d00734 	movhi	r7,16412
811257e0:	000d883a 	mov	r6,zero
811257e4:	1009883a 	mov	r4,r2
811257e8:	180b883a 	mov	r5,r3
811257ec:	112fa6c0 	call	8112fa6c <__adddf3>
811257f0:	d9c00517 	ldw	r7,20(sp)
811257f4:	047f3034 	movhi	r17,64704
811257f8:	1021883a 	mov	r16,r2
811257fc:	39ffffc4 	addi	r7,r7,-1
81125800:	d9c01315 	stw	r7,76(sp)
81125804:	1c63883a 	add	r17,r3,r17
81125808:	db000c17 	ldw	r12,48(sp)
8112580c:	003bea06 	br	811247b8 <__reset+0xfb1047b8>
81125810:	dc000915 	stw	r16,36(sp)
81125814:	003e0e06 	br	81125050 <__reset+0xfb105050>
81125818:	01000e44 	movi	r4,57
8112581c:	8825883a 	mov	r18,r17
81125820:	9dc00044 	addi	r23,r19,1
81125824:	99000005 	stb	r4,0(r19)
81125828:	a023883a 	mov	r17,r20
8112582c:	dc000915 	stw	r16,36(sp)
81125830:	003da406 	br	81124ec4 <__reset+0xfb104ec4>
81125834:	d9801417 	ldw	r6,80(sp)
81125838:	d9c01517 	ldw	r7,84(sp)
8112583c:	0009883a 	mov	r4,zero
81125840:	014ff834 	movhi	r5,16352
81125844:	1130e680 	call	81130e68 <__subdf3>
81125848:	880d883a 	mov	r6,r17
8112584c:	a00f883a 	mov	r7,r20
81125850:	1009883a 	mov	r4,r2
81125854:	180b883a 	mov	r5,r3
81125858:	1130c980 	call	81130c98 <__gedf2>
8112585c:	00bc7c0e 	bge	zero,r2,81124a50 <__reset+0xfb104a50>
81125860:	01000c04 	movi	r4,48
81125864:	00000106 	br	8112586c <_dtoa_r+0x1588>
81125868:	102f883a 	mov	r23,r2
8112586c:	b8bfffc4 	addi	r2,r23,-1
81125870:	10c00007 	ldb	r3,0(r2)
81125874:	193ffc26 	beq	r3,r4,81125868 <__reset+0xfb105868>
81125878:	d9801317 	ldw	r6,76(sp)
8112587c:	d9800515 	stw	r6,20(sp)
81125880:	003c4406 	br	81124994 <__reset+0xfb104994>
81125884:	d9801317 	ldw	r6,76(sp)
81125888:	d9800515 	stw	r6,20(sp)
8112588c:	003cea06 	br	81124c38 <__reset+0xfb104c38>
81125890:	dd800f17 	ldw	r22,60(sp)
81125894:	dcc01017 	ldw	r19,64(sp)
81125898:	dc801217 	ldw	r18,72(sp)
8112589c:	003c6c06 	br	81124a50 <__reset+0xfb104a50>
811258a0:	903e031e 	bne	r18,zero,811250b0 <__reset+0xfb1050b0>
811258a4:	003ebb06 	br	81125394 <__reset+0xfb105394>
811258a8:	103e6c1e 	bne	r2,zero,8112525c <__reset+0xfb10525c>
811258ac:	4080004c 	andi	r2,r8,1
811258b0:	103e6a26 	beq	r2,zero,8112525c <__reset+0xfb10525c>
811258b4:	003e6606 	br	81125250 <__reset+0xfb105250>
811258b8:	d8c00317 	ldw	r3,12(sp)
811258bc:	00800084 	movi	r2,2
811258c0:	10c02916 	blt	r2,r3,81125968 <_dtoa_r+0x1684>
811258c4:	d9000c17 	ldw	r4,48(sp)
811258c8:	003e8806 	br	811252ec <__reset+0xfb1052ec>
811258cc:	04000084 	movi	r16,2
811258d0:	003b9d06 	br	81124748 <__reset+0xfb104748>
811258d4:	d9001317 	ldw	r4,76(sp)
811258d8:	d9000515 	stw	r4,20(sp)
811258dc:	003cd606 	br	81124c38 <__reset+0xfb104c38>
811258e0:	d8801317 	ldw	r2,76(sp)
811258e4:	d8800515 	stw	r2,20(sp)
811258e8:	003c2a06 	br	81124994 <__reset+0xfb104994>
811258ec:	d9800317 	ldw	r6,12(sp)
811258f0:	00800084 	movi	r2,2
811258f4:	11801516 	blt	r2,r6,8112594c <_dtoa_r+0x1668>
811258f8:	d9c00c17 	ldw	r7,48(sp)
811258fc:	d9c00615 	stw	r7,24(sp)
81125900:	003df706 	br	811250e0 <__reset+0xfb1050e0>
81125904:	193d3926 	beq	r3,r4,81124dec <__reset+0xfb104dec>
81125908:	00c00f04 	movi	r3,60
8112590c:	1885c83a 	sub	r2,r3,r2
81125910:	003ddf06 	br	81125090 <__reset+0xfb105090>
81125914:	e009883a 	mov	r4,fp
81125918:	e0001115 	stw	zero,68(fp)
8112591c:	000b883a 	mov	r5,zero
81125920:	11273fc0 	call	811273fc <_Balloc>
81125924:	d8800715 	stw	r2,28(sp)
81125928:	d8c00717 	ldw	r3,28(sp)
8112592c:	00bfffc4 	movi	r2,-1
81125930:	01000044 	movi	r4,1
81125934:	d8800c15 	stw	r2,48(sp)
81125938:	e0c01015 	stw	r3,64(fp)
8112593c:	d9000b15 	stw	r4,44(sp)
81125940:	d8800615 	stw	r2,24(sp)
81125944:	d8002215 	stw	zero,136(sp)
81125948:	003c4106 	br	81124a50 <__reset+0xfb104a50>
8112594c:	d8c00c17 	ldw	r3,48(sp)
81125950:	d8c00615 	stw	r3,24(sp)
81125954:	003e7006 	br	81125318 <__reset+0xfb105318>
81125958:	04400044 	movi	r17,1
8112595c:	003b2006 	br	811245e0 <__reset+0xfb1045e0>
81125960:	000b883a 	mov	r5,zero
81125964:	003b3d06 	br	8112465c <__reset+0xfb10465c>
81125968:	d8800c17 	ldw	r2,48(sp)
8112596c:	d8800615 	stw	r2,24(sp)
81125970:	003e6906 	br	81125318 <__reset+0xfb105318>

81125974 <__sflush_r>:
81125974:	defffb04 	addi	sp,sp,-20
81125978:	de00012e 	bgeu	sp,et,81125980 <__sflush_r+0xc>
8112597c:	003b68fa 	trap	3
81125980:	2880030b 	ldhu	r2,12(r5)
81125984:	dcc00315 	stw	r19,12(sp)
81125988:	dc400115 	stw	r17,4(sp)
8112598c:	dfc00415 	stw	ra,16(sp)
81125990:	dc800215 	stw	r18,8(sp)
81125994:	dc000015 	stw	r16,0(sp)
81125998:	10c0020c 	andi	r3,r2,8
8112599c:	2823883a 	mov	r17,r5
811259a0:	2027883a 	mov	r19,r4
811259a4:	1800311e 	bne	r3,zero,81125a6c <__sflush_r+0xf8>
811259a8:	28c00117 	ldw	r3,4(r5)
811259ac:	10820014 	ori	r2,r2,2048
811259b0:	2880030d 	sth	r2,12(r5)
811259b4:	00c04b0e 	bge	zero,r3,81125ae4 <__sflush_r+0x170>
811259b8:	8a000a17 	ldw	r8,40(r17)
811259bc:	40002326 	beq	r8,zero,81125a4c <__sflush_r+0xd8>
811259c0:	9c000017 	ldw	r16,0(r19)
811259c4:	10c4000c 	andi	r3,r2,4096
811259c8:	98000015 	stw	zero,0(r19)
811259cc:	18004826 	beq	r3,zero,81125af0 <__sflush_r+0x17c>
811259d0:	89801417 	ldw	r6,80(r17)
811259d4:	10c0010c 	andi	r3,r2,4
811259d8:	18000626 	beq	r3,zero,811259f4 <__sflush_r+0x80>
811259dc:	88c00117 	ldw	r3,4(r17)
811259e0:	88800c17 	ldw	r2,48(r17)
811259e4:	30cdc83a 	sub	r6,r6,r3
811259e8:	10000226 	beq	r2,zero,811259f4 <__sflush_r+0x80>
811259ec:	88800f17 	ldw	r2,60(r17)
811259f0:	308dc83a 	sub	r6,r6,r2
811259f4:	89400717 	ldw	r5,28(r17)
811259f8:	000f883a 	mov	r7,zero
811259fc:	9809883a 	mov	r4,r19
81125a00:	403ee83a 	callr	r8
81125a04:	00ffffc4 	movi	r3,-1
81125a08:	10c04426 	beq	r2,r3,81125b1c <__sflush_r+0x1a8>
81125a0c:	88c0030b 	ldhu	r3,12(r17)
81125a10:	89000417 	ldw	r4,16(r17)
81125a14:	88000115 	stw	zero,4(r17)
81125a18:	197dffcc 	andi	r5,r3,63487
81125a1c:	8940030d 	sth	r5,12(r17)
81125a20:	89000015 	stw	r4,0(r17)
81125a24:	18c4000c 	andi	r3,r3,4096
81125a28:	18002c1e 	bne	r3,zero,81125adc <__sflush_r+0x168>
81125a2c:	89400c17 	ldw	r5,48(r17)
81125a30:	9c000015 	stw	r16,0(r19)
81125a34:	28000526 	beq	r5,zero,81125a4c <__sflush_r+0xd8>
81125a38:	88801004 	addi	r2,r17,64
81125a3c:	28800226 	beq	r5,r2,81125a48 <__sflush_r+0xd4>
81125a40:	9809883a 	mov	r4,r19
81125a44:	112642c0 	call	8112642c <_free_r>
81125a48:	88000c15 	stw	zero,48(r17)
81125a4c:	0005883a 	mov	r2,zero
81125a50:	dfc00417 	ldw	ra,16(sp)
81125a54:	dcc00317 	ldw	r19,12(sp)
81125a58:	dc800217 	ldw	r18,8(sp)
81125a5c:	dc400117 	ldw	r17,4(sp)
81125a60:	dc000017 	ldw	r16,0(sp)
81125a64:	dec00504 	addi	sp,sp,20
81125a68:	f800283a 	ret
81125a6c:	2c800417 	ldw	r18,16(r5)
81125a70:	903ff626 	beq	r18,zero,81125a4c <__reset+0xfb105a4c>
81125a74:	2c000017 	ldw	r16,0(r5)
81125a78:	108000cc 	andi	r2,r2,3
81125a7c:	2c800015 	stw	r18,0(r5)
81125a80:	84a1c83a 	sub	r16,r16,r18
81125a84:	1000131e 	bne	r2,zero,81125ad4 <__sflush_r+0x160>
81125a88:	28800517 	ldw	r2,20(r5)
81125a8c:	88800215 	stw	r2,8(r17)
81125a90:	04000316 	blt	zero,r16,81125aa0 <__sflush_r+0x12c>
81125a94:	003fed06 	br	81125a4c <__reset+0xfb105a4c>
81125a98:	90a5883a 	add	r18,r18,r2
81125a9c:	043feb0e 	bge	zero,r16,81125a4c <__reset+0xfb105a4c>
81125aa0:	88800917 	ldw	r2,36(r17)
81125aa4:	89400717 	ldw	r5,28(r17)
81125aa8:	800f883a 	mov	r7,r16
81125aac:	900d883a 	mov	r6,r18
81125ab0:	9809883a 	mov	r4,r19
81125ab4:	103ee83a 	callr	r2
81125ab8:	80a1c83a 	sub	r16,r16,r2
81125abc:	00bff616 	blt	zero,r2,81125a98 <__reset+0xfb105a98>
81125ac0:	88c0030b 	ldhu	r3,12(r17)
81125ac4:	00bfffc4 	movi	r2,-1
81125ac8:	18c01014 	ori	r3,r3,64
81125acc:	88c0030d 	sth	r3,12(r17)
81125ad0:	003fdf06 	br	81125a50 <__reset+0xfb105a50>
81125ad4:	0005883a 	mov	r2,zero
81125ad8:	003fec06 	br	81125a8c <__reset+0xfb105a8c>
81125adc:	88801415 	stw	r2,80(r17)
81125ae0:	003fd206 	br	81125a2c <__reset+0xfb105a2c>
81125ae4:	28c00f17 	ldw	r3,60(r5)
81125ae8:	00ffb316 	blt	zero,r3,811259b8 <__reset+0xfb1059b8>
81125aec:	003fd706 	br	81125a4c <__reset+0xfb105a4c>
81125af0:	89400717 	ldw	r5,28(r17)
81125af4:	000d883a 	mov	r6,zero
81125af8:	01c00044 	movi	r7,1
81125afc:	9809883a 	mov	r4,r19
81125b00:	403ee83a 	callr	r8
81125b04:	100d883a 	mov	r6,r2
81125b08:	00bfffc4 	movi	r2,-1
81125b0c:	30801426 	beq	r6,r2,81125b60 <__sflush_r+0x1ec>
81125b10:	8880030b 	ldhu	r2,12(r17)
81125b14:	8a000a17 	ldw	r8,40(r17)
81125b18:	003fae06 	br	811259d4 <__reset+0xfb1059d4>
81125b1c:	98c00017 	ldw	r3,0(r19)
81125b20:	183fba26 	beq	r3,zero,81125a0c <__reset+0xfb105a0c>
81125b24:	01000744 	movi	r4,29
81125b28:	19000626 	beq	r3,r4,81125b44 <__sflush_r+0x1d0>
81125b2c:	01000584 	movi	r4,22
81125b30:	19000426 	beq	r3,r4,81125b44 <__sflush_r+0x1d0>
81125b34:	88c0030b 	ldhu	r3,12(r17)
81125b38:	18c01014 	ori	r3,r3,64
81125b3c:	88c0030d 	sth	r3,12(r17)
81125b40:	003fc306 	br	81125a50 <__reset+0xfb105a50>
81125b44:	8880030b 	ldhu	r2,12(r17)
81125b48:	88c00417 	ldw	r3,16(r17)
81125b4c:	88000115 	stw	zero,4(r17)
81125b50:	10bdffcc 	andi	r2,r2,63487
81125b54:	8880030d 	sth	r2,12(r17)
81125b58:	88c00015 	stw	r3,0(r17)
81125b5c:	003fb306 	br	81125a2c <__reset+0xfb105a2c>
81125b60:	98800017 	ldw	r2,0(r19)
81125b64:	103fea26 	beq	r2,zero,81125b10 <__reset+0xfb105b10>
81125b68:	00c00744 	movi	r3,29
81125b6c:	10c00226 	beq	r2,r3,81125b78 <__sflush_r+0x204>
81125b70:	00c00584 	movi	r3,22
81125b74:	10c0031e 	bne	r2,r3,81125b84 <__sflush_r+0x210>
81125b78:	9c000015 	stw	r16,0(r19)
81125b7c:	0005883a 	mov	r2,zero
81125b80:	003fb306 	br	81125a50 <__reset+0xfb105a50>
81125b84:	88c0030b 	ldhu	r3,12(r17)
81125b88:	3005883a 	mov	r2,r6
81125b8c:	18c01014 	ori	r3,r3,64
81125b90:	88c0030d 	sth	r3,12(r17)
81125b94:	003fae06 	br	81125a50 <__reset+0xfb105a50>

81125b98 <_fflush_r>:
81125b98:	defffd04 	addi	sp,sp,-12
81125b9c:	de00012e 	bgeu	sp,et,81125ba4 <_fflush_r+0xc>
81125ba0:	003b68fa 	trap	3
81125ba4:	dc000115 	stw	r16,4(sp)
81125ba8:	dfc00215 	stw	ra,8(sp)
81125bac:	2021883a 	mov	r16,r4
81125bb0:	20000226 	beq	r4,zero,81125bbc <_fflush_r+0x24>
81125bb4:	20800e17 	ldw	r2,56(r4)
81125bb8:	10000c26 	beq	r2,zero,81125bec <_fflush_r+0x54>
81125bbc:	2880030f 	ldh	r2,12(r5)
81125bc0:	1000051e 	bne	r2,zero,81125bd8 <_fflush_r+0x40>
81125bc4:	0005883a 	mov	r2,zero
81125bc8:	dfc00217 	ldw	ra,8(sp)
81125bcc:	dc000117 	ldw	r16,4(sp)
81125bd0:	dec00304 	addi	sp,sp,12
81125bd4:	f800283a 	ret
81125bd8:	8009883a 	mov	r4,r16
81125bdc:	dfc00217 	ldw	ra,8(sp)
81125be0:	dc000117 	ldw	r16,4(sp)
81125be4:	dec00304 	addi	sp,sp,12
81125be8:	11259741 	jmpi	81125974 <__sflush_r>
81125bec:	d9400015 	stw	r5,0(sp)
81125bf0:	1125f940 	call	81125f94 <__sinit>
81125bf4:	d9400017 	ldw	r5,0(sp)
81125bf8:	003ff006 	br	81125bbc <__reset+0xfb105bbc>

81125bfc <fflush>:
81125bfc:	20000526 	beq	r4,zero,81125c14 <fflush+0x18>
81125c00:	00a04574 	movhi	r2,33045
81125c04:	10b7d604 	addi	r2,r2,-8360
81125c08:	200b883a 	mov	r5,r4
81125c0c:	11000017 	ldw	r4,0(r2)
81125c10:	1125b981 	jmpi	81125b98 <_fflush_r>
81125c14:	00a04574 	movhi	r2,33045
81125c18:	10b7d504 	addi	r2,r2,-8364
81125c1c:	11000017 	ldw	r4,0(r2)
81125c20:	016044b4 	movhi	r5,33042
81125c24:	2956e604 	addi	r5,r5,23448
81125c28:	1126cd41 	jmpi	81126cd4 <_fwalk_reent>

81125c2c <__fp_unlock>:
81125c2c:	0005883a 	mov	r2,zero
81125c30:	f800283a 	ret

81125c34 <_cleanup_r>:
81125c34:	016044f4 	movhi	r5,33043
81125c38:	29767c04 	addi	r5,r5,-9744
81125c3c:	1126cd41 	jmpi	81126cd4 <_fwalk_reent>

81125c40 <__sinit.part.1>:
81125c40:	defff704 	addi	sp,sp,-36
81125c44:	00e044b4 	movhi	r3,33042
81125c48:	de00012e 	bgeu	sp,et,81125c50 <__sinit.part.1+0x10>
81125c4c:	003b68fa 	trap	3
81125c50:	18d70d04 	addi	r3,r3,23604
81125c54:	dfc00815 	stw	ra,32(sp)
81125c58:	ddc00715 	stw	r23,28(sp)
81125c5c:	dd800615 	stw	r22,24(sp)
81125c60:	dd400515 	stw	r21,20(sp)
81125c64:	dd000415 	stw	r20,16(sp)
81125c68:	dcc00315 	stw	r19,12(sp)
81125c6c:	dc800215 	stw	r18,8(sp)
81125c70:	dc400115 	stw	r17,4(sp)
81125c74:	dc000015 	stw	r16,0(sp)
81125c78:	24000117 	ldw	r16,4(r4)
81125c7c:	20c00f15 	stw	r3,60(r4)
81125c80:	2080bb04 	addi	r2,r4,748
81125c84:	00c000c4 	movi	r3,3
81125c88:	20c0b915 	stw	r3,740(r4)
81125c8c:	2080ba15 	stw	r2,744(r4)
81125c90:	2000b815 	stw	zero,736(r4)
81125c94:	05c00204 	movi	r23,8
81125c98:	00800104 	movi	r2,4
81125c9c:	2025883a 	mov	r18,r4
81125ca0:	b80d883a 	mov	r6,r23
81125ca4:	81001704 	addi	r4,r16,92
81125ca8:	000b883a 	mov	r5,zero
81125cac:	80000015 	stw	zero,0(r16)
81125cb0:	80000115 	stw	zero,4(r16)
81125cb4:	80000215 	stw	zero,8(r16)
81125cb8:	8080030d 	sth	r2,12(r16)
81125cbc:	80001915 	stw	zero,100(r16)
81125cc0:	8000038d 	sth	zero,14(r16)
81125cc4:	80000415 	stw	zero,16(r16)
81125cc8:	80000515 	stw	zero,20(r16)
81125ccc:	80000615 	stw	zero,24(r16)
81125cd0:	111d31c0 	call	8111d31c <memset>
81125cd4:	05a044b4 	movhi	r22,33042
81125cd8:	94400217 	ldw	r17,8(r18)
81125cdc:	056044b4 	movhi	r21,33042
81125ce0:	052044b4 	movhi	r20,33042
81125ce4:	04e044b4 	movhi	r19,33042
81125ce8:	b5b6c804 	addi	r22,r22,-9440
81125cec:	ad76e104 	addi	r21,r21,-9340
81125cf0:	a5370204 	addi	r20,r20,-9208
81125cf4:	9cf71b04 	addi	r19,r19,-9108
81125cf8:	85800815 	stw	r22,32(r16)
81125cfc:	85400915 	stw	r21,36(r16)
81125d00:	85000a15 	stw	r20,40(r16)
81125d04:	84c00b15 	stw	r19,44(r16)
81125d08:	84000715 	stw	r16,28(r16)
81125d0c:	00800284 	movi	r2,10
81125d10:	8880030d 	sth	r2,12(r17)
81125d14:	00800044 	movi	r2,1
81125d18:	b80d883a 	mov	r6,r23
81125d1c:	89001704 	addi	r4,r17,92
81125d20:	000b883a 	mov	r5,zero
81125d24:	88000015 	stw	zero,0(r17)
81125d28:	88000115 	stw	zero,4(r17)
81125d2c:	88000215 	stw	zero,8(r17)
81125d30:	88001915 	stw	zero,100(r17)
81125d34:	8880038d 	sth	r2,14(r17)
81125d38:	88000415 	stw	zero,16(r17)
81125d3c:	88000515 	stw	zero,20(r17)
81125d40:	88000615 	stw	zero,24(r17)
81125d44:	111d31c0 	call	8111d31c <memset>
81125d48:	94000317 	ldw	r16,12(r18)
81125d4c:	00800484 	movi	r2,18
81125d50:	8c400715 	stw	r17,28(r17)
81125d54:	8d800815 	stw	r22,32(r17)
81125d58:	8d400915 	stw	r21,36(r17)
81125d5c:	8d000a15 	stw	r20,40(r17)
81125d60:	8cc00b15 	stw	r19,44(r17)
81125d64:	8080030d 	sth	r2,12(r16)
81125d68:	00800084 	movi	r2,2
81125d6c:	80000015 	stw	zero,0(r16)
81125d70:	80000115 	stw	zero,4(r16)
81125d74:	80000215 	stw	zero,8(r16)
81125d78:	80001915 	stw	zero,100(r16)
81125d7c:	8080038d 	sth	r2,14(r16)
81125d80:	80000415 	stw	zero,16(r16)
81125d84:	80000515 	stw	zero,20(r16)
81125d88:	80000615 	stw	zero,24(r16)
81125d8c:	b80d883a 	mov	r6,r23
81125d90:	000b883a 	mov	r5,zero
81125d94:	81001704 	addi	r4,r16,92
81125d98:	111d31c0 	call	8111d31c <memset>
81125d9c:	00800044 	movi	r2,1
81125da0:	84000715 	stw	r16,28(r16)
81125da4:	85800815 	stw	r22,32(r16)
81125da8:	85400915 	stw	r21,36(r16)
81125dac:	85000a15 	stw	r20,40(r16)
81125db0:	84c00b15 	stw	r19,44(r16)
81125db4:	90800e15 	stw	r2,56(r18)
81125db8:	dfc00817 	ldw	ra,32(sp)
81125dbc:	ddc00717 	ldw	r23,28(sp)
81125dc0:	dd800617 	ldw	r22,24(sp)
81125dc4:	dd400517 	ldw	r21,20(sp)
81125dc8:	dd000417 	ldw	r20,16(sp)
81125dcc:	dcc00317 	ldw	r19,12(sp)
81125dd0:	dc800217 	ldw	r18,8(sp)
81125dd4:	dc400117 	ldw	r17,4(sp)
81125dd8:	dc000017 	ldw	r16,0(sp)
81125ddc:	dec00904 	addi	sp,sp,36
81125de0:	f800283a 	ret

81125de4 <__fp_lock>:
81125de4:	0005883a 	mov	r2,zero
81125de8:	f800283a 	ret

81125dec <__sfmoreglue>:
81125dec:	defffc04 	addi	sp,sp,-16
81125df0:	de00012e 	bgeu	sp,et,81125df8 <__sfmoreglue+0xc>
81125df4:	003b68fa 	trap	3
81125df8:	dc400115 	stw	r17,4(sp)
81125dfc:	2c7fffc4 	addi	r17,r5,-1
81125e00:	8c401a24 	muli	r17,r17,104
81125e04:	dc800215 	stw	r18,8(sp)
81125e08:	2825883a 	mov	r18,r5
81125e0c:	89401d04 	addi	r5,r17,116
81125e10:	dc000015 	stw	r16,0(sp)
81125e14:	dfc00315 	stw	ra,12(sp)
81125e18:	111c9b80 	call	8111c9b8 <_malloc_r>
81125e1c:	1021883a 	mov	r16,r2
81125e20:	10000726 	beq	r2,zero,81125e40 <__sfmoreglue+0x54>
81125e24:	11000304 	addi	r4,r2,12
81125e28:	10000015 	stw	zero,0(r2)
81125e2c:	14800115 	stw	r18,4(r2)
81125e30:	11000215 	stw	r4,8(r2)
81125e34:	89801a04 	addi	r6,r17,104
81125e38:	000b883a 	mov	r5,zero
81125e3c:	111d31c0 	call	8111d31c <memset>
81125e40:	8005883a 	mov	r2,r16
81125e44:	dfc00317 	ldw	ra,12(sp)
81125e48:	dc800217 	ldw	r18,8(sp)
81125e4c:	dc400117 	ldw	r17,4(sp)
81125e50:	dc000017 	ldw	r16,0(sp)
81125e54:	dec00404 	addi	sp,sp,16
81125e58:	f800283a 	ret

81125e5c <__sfp>:
81125e5c:	defffb04 	addi	sp,sp,-20
81125e60:	de00012e 	bgeu	sp,et,81125e68 <__sfp+0xc>
81125e64:	003b68fa 	trap	3
81125e68:	dc000015 	stw	r16,0(sp)
81125e6c:	04204574 	movhi	r16,33045
81125e70:	8437d504 	addi	r16,r16,-8364
81125e74:	dcc00315 	stw	r19,12(sp)
81125e78:	2027883a 	mov	r19,r4
81125e7c:	81000017 	ldw	r4,0(r16)
81125e80:	dfc00415 	stw	ra,16(sp)
81125e84:	dc800215 	stw	r18,8(sp)
81125e88:	20800e17 	ldw	r2,56(r4)
81125e8c:	dc400115 	stw	r17,4(sp)
81125e90:	1000021e 	bne	r2,zero,81125e9c <__sfp+0x40>
81125e94:	1125c400 	call	81125c40 <__sinit.part.1>
81125e98:	81000017 	ldw	r4,0(r16)
81125e9c:	2480b804 	addi	r18,r4,736
81125ea0:	047fffc4 	movi	r17,-1
81125ea4:	91000117 	ldw	r4,4(r18)
81125ea8:	94000217 	ldw	r16,8(r18)
81125eac:	213fffc4 	addi	r4,r4,-1
81125eb0:	20000a16 	blt	r4,zero,81125edc <__sfp+0x80>
81125eb4:	8080030f 	ldh	r2,12(r16)
81125eb8:	10000c26 	beq	r2,zero,81125eec <__sfp+0x90>
81125ebc:	80c01d04 	addi	r3,r16,116
81125ec0:	00000206 	br	81125ecc <__sfp+0x70>
81125ec4:	18bfe60f 	ldh	r2,-104(r3)
81125ec8:	10000826 	beq	r2,zero,81125eec <__sfp+0x90>
81125ecc:	213fffc4 	addi	r4,r4,-1
81125ed0:	1c3ffd04 	addi	r16,r3,-12
81125ed4:	18c01a04 	addi	r3,r3,104
81125ed8:	247ffa1e 	bne	r4,r17,81125ec4 <__reset+0xfb105ec4>
81125edc:	90800017 	ldw	r2,0(r18)
81125ee0:	10001d26 	beq	r2,zero,81125f58 <__sfp+0xfc>
81125ee4:	1025883a 	mov	r18,r2
81125ee8:	003fee06 	br	81125ea4 <__reset+0xfb105ea4>
81125eec:	00bfffc4 	movi	r2,-1
81125ef0:	8080038d 	sth	r2,14(r16)
81125ef4:	00800044 	movi	r2,1
81125ef8:	8080030d 	sth	r2,12(r16)
81125efc:	80001915 	stw	zero,100(r16)
81125f00:	80000015 	stw	zero,0(r16)
81125f04:	80000215 	stw	zero,8(r16)
81125f08:	80000115 	stw	zero,4(r16)
81125f0c:	80000415 	stw	zero,16(r16)
81125f10:	80000515 	stw	zero,20(r16)
81125f14:	80000615 	stw	zero,24(r16)
81125f18:	01800204 	movi	r6,8
81125f1c:	000b883a 	mov	r5,zero
81125f20:	81001704 	addi	r4,r16,92
81125f24:	111d31c0 	call	8111d31c <memset>
81125f28:	8005883a 	mov	r2,r16
81125f2c:	80000c15 	stw	zero,48(r16)
81125f30:	80000d15 	stw	zero,52(r16)
81125f34:	80001115 	stw	zero,68(r16)
81125f38:	80001215 	stw	zero,72(r16)
81125f3c:	dfc00417 	ldw	ra,16(sp)
81125f40:	dcc00317 	ldw	r19,12(sp)
81125f44:	dc800217 	ldw	r18,8(sp)
81125f48:	dc400117 	ldw	r17,4(sp)
81125f4c:	dc000017 	ldw	r16,0(sp)
81125f50:	dec00504 	addi	sp,sp,20
81125f54:	f800283a 	ret
81125f58:	01400104 	movi	r5,4
81125f5c:	9809883a 	mov	r4,r19
81125f60:	1125dec0 	call	81125dec <__sfmoreglue>
81125f64:	90800015 	stw	r2,0(r18)
81125f68:	103fde1e 	bne	r2,zero,81125ee4 <__reset+0xfb105ee4>
81125f6c:	00800304 	movi	r2,12
81125f70:	98800015 	stw	r2,0(r19)
81125f74:	0005883a 	mov	r2,zero
81125f78:	003ff006 	br	81125f3c <__reset+0xfb105f3c>

81125f7c <_cleanup>:
81125f7c:	00a04574 	movhi	r2,33045
81125f80:	10b7d504 	addi	r2,r2,-8364
81125f84:	11000017 	ldw	r4,0(r2)
81125f88:	016044f4 	movhi	r5,33043
81125f8c:	29767c04 	addi	r5,r5,-9744
81125f90:	1126cd41 	jmpi	81126cd4 <_fwalk_reent>

81125f94 <__sinit>:
81125f94:	20800e17 	ldw	r2,56(r4)
81125f98:	10000126 	beq	r2,zero,81125fa0 <__sinit+0xc>
81125f9c:	f800283a 	ret
81125fa0:	1125c401 	jmpi	81125c40 <__sinit.part.1>

81125fa4 <__sfp_lock_acquire>:
81125fa4:	f800283a 	ret

81125fa8 <__sfp_lock_release>:
81125fa8:	f800283a 	ret

81125fac <__sinit_lock_acquire>:
81125fac:	f800283a 	ret

81125fb0 <__sinit_lock_release>:
81125fb0:	f800283a 	ret

81125fb4 <__fp_lock_all>:
81125fb4:	00a04574 	movhi	r2,33045
81125fb8:	10b7d604 	addi	r2,r2,-8360
81125fbc:	11000017 	ldw	r4,0(r2)
81125fc0:	016044b4 	movhi	r5,33042
81125fc4:	29577904 	addi	r5,r5,24036
81125fc8:	1126c081 	jmpi	81126c08 <_fwalk>

81125fcc <__fp_unlock_all>:
81125fcc:	00a04574 	movhi	r2,33045
81125fd0:	10b7d604 	addi	r2,r2,-8360
81125fd4:	11000017 	ldw	r4,0(r2)
81125fd8:	016044b4 	movhi	r5,33042
81125fdc:	29570b04 	addi	r5,r5,23596
81125fe0:	1126c081 	jmpi	81126c08 <_fwalk>

81125fe4 <__sflags>:
81125fe4:	28800007 	ldb	r2,0(r5)
81125fe8:	00c01c84 	movi	r3,114
81125fec:	10c02426 	beq	r2,r3,81126080 <__sflags+0x9c>
81125ff0:	00c01dc4 	movi	r3,119
81125ff4:	10c01e26 	beq	r2,r3,81126070 <__sflags+0x8c>
81125ff8:	00c01844 	movi	r3,97
81125ffc:	10c00426 	beq	r2,r3,81126010 <__sflags+0x2c>
81126000:	00800584 	movi	r2,22
81126004:	20800015 	stw	r2,0(r4)
81126008:	0005883a 	mov	r2,zero
8112600c:	f800283a 	ret
81126010:	02c08204 	movi	r11,520
81126014:	01000044 	movi	r4,1
81126018:	00804204 	movi	r2,264
8112601c:	01c00ac4 	movi	r7,43
81126020:	02bff8c4 	movi	r10,-29
81126024:	027fff04 	movi	r9,-4
81126028:	02001e04 	movi	r8,120
8112602c:	29400044 	addi	r5,r5,1
81126030:	28c00007 	ldb	r3,0(r5)
81126034:	18000626 	beq	r3,zero,81126050 <__sflags+0x6c>
81126038:	19c00826 	beq	r3,r7,8112605c <__sflags+0x78>
8112603c:	1a3ffb1e 	bne	r3,r8,8112602c <__reset+0xfb10602c>
81126040:	29400044 	addi	r5,r5,1
81126044:	28c00007 	ldb	r3,0(r5)
81126048:	21020014 	ori	r4,r4,2048
8112604c:	183ffa1e 	bne	r3,zero,81126038 <__reset+0xfb106038>
81126050:	22c8b03a 	or	r4,r4,r11
81126054:	31000015 	stw	r4,0(r6)
81126058:	f800283a 	ret
8112605c:	1284703a 	and	r2,r2,r10
81126060:	2248703a 	and	r4,r4,r9
81126064:	10800414 	ori	r2,r2,16
81126068:	21000094 	ori	r4,r4,2
8112606c:	003fef06 	br	8112602c <__reset+0xfb10602c>
81126070:	02c18004 	movi	r11,1536
81126074:	01000044 	movi	r4,1
81126078:	00800204 	movi	r2,8
8112607c:	003fe706 	br	8112601c <__reset+0xfb10601c>
81126080:	0017883a 	mov	r11,zero
81126084:	0009883a 	mov	r4,zero
81126088:	00800104 	movi	r2,4
8112608c:	003fe306 	br	8112601c <__reset+0xfb10601c>

81126090 <_fread_r>:
81126090:	defff404 	addi	sp,sp,-48
81126094:	de00012e 	bgeu	sp,et,8112609c <_fread_r+0xc>
81126098:	003b68fa 	trap	3
8112609c:	dd800815 	stw	r22,32(sp)
811260a0:	39ad383a 	mul	r22,r7,r6
811260a4:	dc000215 	stw	r16,8(sp)
811260a8:	dfc00b15 	stw	ra,44(sp)
811260ac:	df000a15 	stw	fp,40(sp)
811260b0:	ddc00915 	stw	r23,36(sp)
811260b4:	dd400715 	stw	r21,28(sp)
811260b8:	dd000615 	stw	r20,24(sp)
811260bc:	dcc00515 	stw	r19,20(sp)
811260c0:	dc800415 	stw	r18,16(sp)
811260c4:	dc400315 	stw	r17,12(sp)
811260c8:	dc000c17 	ldw	r16,48(sp)
811260cc:	b0003b26 	beq	r22,zero,811261bc <_fread_r+0x12c>
811260d0:	302f883a 	mov	r23,r6
811260d4:	382b883a 	mov	r21,r7
811260d8:	2029883a 	mov	r20,r4
811260dc:	2827883a 	mov	r19,r5
811260e0:	20000226 	beq	r4,zero,811260ec <_fread_r+0x5c>
811260e4:	20800e17 	ldw	r2,56(r4)
811260e8:	10006e26 	beq	r2,zero,811262a4 <_fread_r+0x214>
811260ec:	8080030b 	ldhu	r2,12(r16)
811260f0:	10c8000c 	andi	r3,r2,8192
811260f4:	1800061e 	bne	r3,zero,81126110 <_fread_r+0x80>
811260f8:	81001917 	ldw	r4,100(r16)
811260fc:	00f7ffc4 	movi	r3,-8193
81126100:	10880014 	ori	r2,r2,8192
81126104:	20c6703a 	and	r3,r4,r3
81126108:	8080030d 	sth	r2,12(r16)
8112610c:	80c01915 	stw	r3,100(r16)
81126110:	84400117 	ldw	r17,4(r16)
81126114:	88005f16 	blt	r17,zero,81126294 <_fread_r+0x204>
81126118:	8809883a 	mov	r4,r17
8112611c:	1080008c 	andi	r2,r2,2
81126120:	1000281e 	bne	r2,zero,811261c4 <_fread_r+0x134>
81126124:	b025883a 	mov	r18,r22
81126128:	00000b06 	br	81126158 <_fread_r+0xc8>
8112612c:	111d1cc0 	call	8111d1cc <memcpy>
81126130:	80800017 	ldw	r2,0(r16)
81126134:	9c67883a 	add	r19,r19,r17
81126138:	9465c83a 	sub	r18,r18,r17
8112613c:	1463883a 	add	r17,r2,r17
81126140:	800b883a 	mov	r5,r16
81126144:	a009883a 	mov	r4,r20
81126148:	84400015 	stw	r17,0(r16)
8112614c:	111d7980 	call	8111d798 <__srefill_r>
81126150:	10004c1e 	bne	r2,zero,81126284 <_fread_r+0x1f4>
81126154:	84400117 	ldw	r17,4(r16)
81126158:	880d883a 	mov	r6,r17
8112615c:	9809883a 	mov	r4,r19
81126160:	81400017 	ldw	r5,0(r16)
81126164:	8cbff136 	bltu	r17,r18,8112612c <__reset+0xfb10612c>
81126168:	900d883a 	mov	r6,r18
8112616c:	111d1cc0 	call	8111d1cc <memcpy>
81126170:	80c00117 	ldw	r3,4(r16)
81126174:	81000017 	ldw	r4,0(r16)
81126178:	a805883a 	mov	r2,r21
8112617c:	1c87c83a 	sub	r3,r3,r18
81126180:	24a5883a 	add	r18,r4,r18
81126184:	80c00115 	stw	r3,4(r16)
81126188:	84800015 	stw	r18,0(r16)
8112618c:	dfc00b17 	ldw	ra,44(sp)
81126190:	df000a17 	ldw	fp,40(sp)
81126194:	ddc00917 	ldw	r23,36(sp)
81126198:	dd800817 	ldw	r22,32(sp)
8112619c:	dd400717 	ldw	r21,28(sp)
811261a0:	dd000617 	ldw	r20,24(sp)
811261a4:	dcc00517 	ldw	r19,20(sp)
811261a8:	dc800417 	ldw	r18,16(sp)
811261ac:	dc400317 	ldw	r17,12(sp)
811261b0:	dc000217 	ldw	r16,8(sp)
811261b4:	dec00c04 	addi	sp,sp,48
811261b8:	f800283a 	ret
811261bc:	0005883a 	mov	r2,zero
811261c0:	003ff206 	br	8112618c <__reset+0xfb10618c>
811261c4:	b007883a 	mov	r3,r22
811261c8:	2580012e 	bgeu	r4,r22,811261d0 <_fread_r+0x140>
811261cc:	2007883a 	mov	r3,r4
811261d0:	81400017 	ldw	r5,0(r16)
811261d4:	180d883a 	mov	r6,r3
811261d8:	9809883a 	mov	r4,r19
811261dc:	d8c00115 	stw	r3,4(sp)
811261e0:	111d1cc0 	call	8111d1cc <memcpy>
811261e4:	d8c00117 	ldw	r3,4(sp)
811261e8:	84400017 	ldw	r17,0(r16)
811261ec:	80800117 	ldw	r2,4(r16)
811261f0:	81400c17 	ldw	r5,48(r16)
811261f4:	88e3883a 	add	r17,r17,r3
811261f8:	10c5c83a 	sub	r2,r2,r3
811261fc:	84400015 	stw	r17,0(r16)
81126200:	80800115 	stw	r2,4(r16)
81126204:	b0e5c83a 	sub	r18,r22,r3
81126208:	28002b26 	beq	r5,zero,811262b8 <_fread_r+0x228>
8112620c:	90002b26 	beq	r18,zero,811262bc <_fread_r+0x22c>
81126210:	80801004 	addi	r2,r16,64
81126214:	28800526 	beq	r5,r2,8112622c <_fread_r+0x19c>
81126218:	a009883a 	mov	r4,r20
8112621c:	d8c00115 	stw	r3,4(sp)
81126220:	112642c0 	call	8112642c <_free_r>
81126224:	d8c00117 	ldw	r3,4(sp)
81126228:	84400017 	ldw	r17,0(r16)
8112622c:	80000c15 	stw	zero,48(r16)
81126230:	80800517 	ldw	r2,20(r16)
81126234:	87000417 	ldw	fp,16(r16)
81126238:	98e7883a 	add	r19,r19,r3
8112623c:	d8800015 	stw	r2,0(sp)
81126240:	00000106 	br	81126248 <_fread_r+0x1b8>
81126244:	90001d26 	beq	r18,zero,811262bc <_fread_r+0x22c>
81126248:	84c00415 	stw	r19,16(r16)
8112624c:	84800515 	stw	r18,20(r16)
81126250:	84c00015 	stw	r19,0(r16)
81126254:	a009883a 	mov	r4,r20
81126258:	800b883a 	mov	r5,r16
8112625c:	111d7980 	call	8111d798 <__srefill_r>
81126260:	d9000017 	ldw	r4,0(sp)
81126264:	80c00117 	ldw	r3,4(r16)
81126268:	87000415 	stw	fp,16(r16)
8112626c:	81000515 	stw	r4,20(r16)
81126270:	84400015 	stw	r17,0(r16)
81126274:	80000115 	stw	zero,4(r16)
81126278:	90e5c83a 	sub	r18,r18,r3
8112627c:	98e7883a 	add	r19,r19,r3
81126280:	103ff026 	beq	r2,zero,81126244 <__reset+0xfb106244>
81126284:	b80b883a 	mov	r5,r23
81126288:	b489c83a 	sub	r4,r22,r18
8112628c:	112f7b40 	call	8112f7b4 <__udivsi3>
81126290:	003fbe06 	br	8112618c <__reset+0xfb10618c>
81126294:	80000115 	stw	zero,4(r16)
81126298:	0009883a 	mov	r4,zero
8112629c:	0023883a 	mov	r17,zero
811262a0:	003f9e06 	br	8112611c <__reset+0xfb10611c>
811262a4:	1125f940 	call	81125f94 <__sinit>
811262a8:	8080030b 	ldhu	r2,12(r16)
811262ac:	10c8000c 	andi	r3,r2,8192
811262b0:	183f971e 	bne	r3,zero,81126110 <__reset+0xfb106110>
811262b4:	003f9006 	br	811260f8 <__reset+0xfb1060f8>
811262b8:	903fdd1e 	bne	r18,zero,81126230 <__reset+0xfb106230>
811262bc:	a805883a 	mov	r2,r21
811262c0:	003fb206 	br	8112618c <__reset+0xfb10618c>

811262c4 <fread>:
811262c4:	defffe04 	addi	sp,sp,-8
811262c8:	00a04574 	movhi	r2,33045
811262cc:	de00012e 	bgeu	sp,et,811262d4 <fread+0x10>
811262d0:	003b68fa 	trap	3
811262d4:	10b7d604 	addi	r2,r2,-8360
811262d8:	d9c00015 	stw	r7,0(sp)
811262dc:	300f883a 	mov	r7,r6
811262e0:	280d883a 	mov	r6,r5
811262e4:	200b883a 	mov	r5,r4
811262e8:	11000017 	ldw	r4,0(r2)
811262ec:	dfc00115 	stw	ra,4(sp)
811262f0:	11260900 	call	81126090 <_fread_r>
811262f4:	dfc00117 	ldw	ra,4(sp)
811262f8:	dec00204 	addi	sp,sp,8
811262fc:	f800283a 	ret

81126300 <_malloc_trim_r>:
81126300:	defffb04 	addi	sp,sp,-20
81126304:	de00012e 	bgeu	sp,et,8112630c <_malloc_trim_r+0xc>
81126308:	003b68fa 	trap	3
8112630c:	dcc00315 	stw	r19,12(sp)
81126310:	04e04574 	movhi	r19,33045
81126314:	dc800215 	stw	r18,8(sp)
81126318:	dc400115 	stw	r17,4(sp)
8112631c:	dc000015 	stw	r16,0(sp)
81126320:	dfc00415 	stw	ra,16(sp)
81126324:	2821883a 	mov	r16,r5
81126328:	9cf19404 	addi	r19,r19,-14768
8112632c:	2025883a 	mov	r18,r4
81126330:	11337b40 	call	811337b4 <__malloc_lock>
81126334:	98800217 	ldw	r2,8(r19)
81126338:	14400117 	ldw	r17,4(r2)
8112633c:	00bfff04 	movi	r2,-4
81126340:	88a2703a 	and	r17,r17,r2
81126344:	8c21c83a 	sub	r16,r17,r16
81126348:	8403fbc4 	addi	r16,r16,4079
8112634c:	8020d33a 	srli	r16,r16,12
81126350:	0083ffc4 	movi	r2,4095
81126354:	843fffc4 	addi	r16,r16,-1
81126358:	8020933a 	slli	r16,r16,12
8112635c:	1400060e 	bge	r2,r16,81126378 <_malloc_trim_r+0x78>
81126360:	000b883a 	mov	r5,zero
81126364:	9009883a 	mov	r4,r18
81126368:	111d9740 	call	8111d974 <_sbrk_r>
8112636c:	98c00217 	ldw	r3,8(r19)
81126370:	1c47883a 	add	r3,r3,r17
81126374:	10c00a26 	beq	r2,r3,811263a0 <_malloc_trim_r+0xa0>
81126378:	9009883a 	mov	r4,r18
8112637c:	11338dc0 	call	811338dc <__malloc_unlock>
81126380:	0005883a 	mov	r2,zero
81126384:	dfc00417 	ldw	ra,16(sp)
81126388:	dcc00317 	ldw	r19,12(sp)
8112638c:	dc800217 	ldw	r18,8(sp)
81126390:	dc400117 	ldw	r17,4(sp)
81126394:	dc000017 	ldw	r16,0(sp)
81126398:	dec00504 	addi	sp,sp,20
8112639c:	f800283a 	ret
811263a0:	040bc83a 	sub	r5,zero,r16
811263a4:	9009883a 	mov	r4,r18
811263a8:	111d9740 	call	8111d974 <_sbrk_r>
811263ac:	00ffffc4 	movi	r3,-1
811263b0:	10c00d26 	beq	r2,r3,811263e8 <_malloc_trim_r+0xe8>
811263b4:	00e04574 	movhi	r3,33045
811263b8:	18f8d404 	addi	r3,r3,-7344
811263bc:	18800017 	ldw	r2,0(r3)
811263c0:	99000217 	ldw	r4,8(r19)
811263c4:	8c23c83a 	sub	r17,r17,r16
811263c8:	8c400054 	ori	r17,r17,1
811263cc:	1421c83a 	sub	r16,r2,r16
811263d0:	24400115 	stw	r17,4(r4)
811263d4:	9009883a 	mov	r4,r18
811263d8:	1c000015 	stw	r16,0(r3)
811263dc:	11338dc0 	call	811338dc <__malloc_unlock>
811263e0:	00800044 	movi	r2,1
811263e4:	003fe706 	br	81126384 <__reset+0xfb106384>
811263e8:	000b883a 	mov	r5,zero
811263ec:	9009883a 	mov	r4,r18
811263f0:	111d9740 	call	8111d974 <_sbrk_r>
811263f4:	99000217 	ldw	r4,8(r19)
811263f8:	014003c4 	movi	r5,15
811263fc:	1107c83a 	sub	r3,r2,r4
81126400:	28ffdd0e 	bge	r5,r3,81126378 <__reset+0xfb106378>
81126404:	01604574 	movhi	r5,33045
81126408:	2977d704 	addi	r5,r5,-8356
8112640c:	29400017 	ldw	r5,0(r5)
81126410:	18c00054 	ori	r3,r3,1
81126414:	20c00115 	stw	r3,4(r4)
81126418:	00e04574 	movhi	r3,33045
8112641c:	1145c83a 	sub	r2,r2,r5
81126420:	18f8d404 	addi	r3,r3,-7344
81126424:	18800015 	stw	r2,0(r3)
81126428:	003fd306 	br	81126378 <__reset+0xfb106378>

8112642c <_free_r>:
8112642c:	28004326 	beq	r5,zero,8112653c <_free_r+0x110>
81126430:	defffd04 	addi	sp,sp,-12
81126434:	de00012e 	bgeu	sp,et,8112643c <_free_r+0x10>
81126438:	003b68fa 	trap	3
8112643c:	dc400115 	stw	r17,4(sp)
81126440:	dc000015 	stw	r16,0(sp)
81126444:	2023883a 	mov	r17,r4
81126448:	2821883a 	mov	r16,r5
8112644c:	dfc00215 	stw	ra,8(sp)
81126450:	11337b40 	call	811337b4 <__malloc_lock>
81126454:	81ffff17 	ldw	r7,-4(r16)
81126458:	00bfff84 	movi	r2,-2
8112645c:	01204574 	movhi	r4,33045
81126460:	81bffe04 	addi	r6,r16,-8
81126464:	3884703a 	and	r2,r7,r2
81126468:	21319404 	addi	r4,r4,-14768
8112646c:	308b883a 	add	r5,r6,r2
81126470:	2a400117 	ldw	r9,4(r5)
81126474:	22000217 	ldw	r8,8(r4)
81126478:	00ffff04 	movi	r3,-4
8112647c:	48c6703a 	and	r3,r9,r3
81126480:	2a005726 	beq	r5,r8,811265e0 <_free_r+0x1b4>
81126484:	28c00115 	stw	r3,4(r5)
81126488:	39c0004c 	andi	r7,r7,1
8112648c:	3800091e 	bne	r7,zero,811264b4 <_free_r+0x88>
81126490:	823ffe17 	ldw	r8,-8(r16)
81126494:	22400204 	addi	r9,r4,8
81126498:	320dc83a 	sub	r6,r6,r8
8112649c:	31c00217 	ldw	r7,8(r6)
811264a0:	1205883a 	add	r2,r2,r8
811264a4:	3a406526 	beq	r7,r9,8112663c <_free_r+0x210>
811264a8:	32000317 	ldw	r8,12(r6)
811264ac:	3a000315 	stw	r8,12(r7)
811264b0:	41c00215 	stw	r7,8(r8)
811264b4:	28cf883a 	add	r7,r5,r3
811264b8:	39c00117 	ldw	r7,4(r7)
811264bc:	39c0004c 	andi	r7,r7,1
811264c0:	38003a26 	beq	r7,zero,811265ac <_free_r+0x180>
811264c4:	10c00054 	ori	r3,r2,1
811264c8:	30c00115 	stw	r3,4(r6)
811264cc:	3087883a 	add	r3,r6,r2
811264d0:	18800015 	stw	r2,0(r3)
811264d4:	00c07fc4 	movi	r3,511
811264d8:	18801936 	bltu	r3,r2,81126540 <_free_r+0x114>
811264dc:	1004d0fa 	srli	r2,r2,3
811264e0:	01c00044 	movi	r7,1
811264e4:	21400117 	ldw	r5,4(r4)
811264e8:	10c00044 	addi	r3,r2,1
811264ec:	18c7883a 	add	r3,r3,r3
811264f0:	1005d0ba 	srai	r2,r2,2
811264f4:	18c7883a 	add	r3,r3,r3
811264f8:	18c7883a 	add	r3,r3,r3
811264fc:	1907883a 	add	r3,r3,r4
81126500:	3884983a 	sll	r2,r7,r2
81126504:	19c00017 	ldw	r7,0(r3)
81126508:	1a3ffe04 	addi	r8,r3,-8
8112650c:	1144b03a 	or	r2,r2,r5
81126510:	32000315 	stw	r8,12(r6)
81126514:	31c00215 	stw	r7,8(r6)
81126518:	20800115 	stw	r2,4(r4)
8112651c:	19800015 	stw	r6,0(r3)
81126520:	39800315 	stw	r6,12(r7)
81126524:	8809883a 	mov	r4,r17
81126528:	dfc00217 	ldw	ra,8(sp)
8112652c:	dc400117 	ldw	r17,4(sp)
81126530:	dc000017 	ldw	r16,0(sp)
81126534:	dec00304 	addi	sp,sp,12
81126538:	11338dc1 	jmpi	811338dc <__malloc_unlock>
8112653c:	f800283a 	ret
81126540:	100ad27a 	srli	r5,r2,9
81126544:	00c00104 	movi	r3,4
81126548:	19404a36 	bltu	r3,r5,81126674 <_free_r+0x248>
8112654c:	100ad1ba 	srli	r5,r2,6
81126550:	28c00e44 	addi	r3,r5,57
81126554:	18c7883a 	add	r3,r3,r3
81126558:	29400e04 	addi	r5,r5,56
8112655c:	18c7883a 	add	r3,r3,r3
81126560:	18c7883a 	add	r3,r3,r3
81126564:	1909883a 	add	r4,r3,r4
81126568:	20c00017 	ldw	r3,0(r4)
8112656c:	01e04574 	movhi	r7,33045
81126570:	213ffe04 	addi	r4,r4,-8
81126574:	39f19404 	addi	r7,r7,-14768
81126578:	20c04426 	beq	r4,r3,8112668c <_free_r+0x260>
8112657c:	01ffff04 	movi	r7,-4
81126580:	19400117 	ldw	r5,4(r3)
81126584:	29ca703a 	and	r5,r5,r7
81126588:	1140022e 	bgeu	r2,r5,81126594 <_free_r+0x168>
8112658c:	18c00217 	ldw	r3,8(r3)
81126590:	20fffb1e 	bne	r4,r3,81126580 <__reset+0xfb106580>
81126594:	19000317 	ldw	r4,12(r3)
81126598:	31000315 	stw	r4,12(r6)
8112659c:	30c00215 	stw	r3,8(r6)
811265a0:	21800215 	stw	r6,8(r4)
811265a4:	19800315 	stw	r6,12(r3)
811265a8:	003fde06 	br	81126524 <__reset+0xfb106524>
811265ac:	29c00217 	ldw	r7,8(r5)
811265b0:	10c5883a 	add	r2,r2,r3
811265b4:	00e04574 	movhi	r3,33045
811265b8:	18f19604 	addi	r3,r3,-14760
811265bc:	38c03b26 	beq	r7,r3,811266ac <_free_r+0x280>
811265c0:	2a000317 	ldw	r8,12(r5)
811265c4:	11400054 	ori	r5,r2,1
811265c8:	3087883a 	add	r3,r6,r2
811265cc:	3a000315 	stw	r8,12(r7)
811265d0:	41c00215 	stw	r7,8(r8)
811265d4:	31400115 	stw	r5,4(r6)
811265d8:	18800015 	stw	r2,0(r3)
811265dc:	003fbd06 	br	811264d4 <__reset+0xfb1064d4>
811265e0:	39c0004c 	andi	r7,r7,1
811265e4:	10c5883a 	add	r2,r2,r3
811265e8:	3800071e 	bne	r7,zero,81126608 <_free_r+0x1dc>
811265ec:	81fffe17 	ldw	r7,-8(r16)
811265f0:	31cdc83a 	sub	r6,r6,r7
811265f4:	30c00317 	ldw	r3,12(r6)
811265f8:	31400217 	ldw	r5,8(r6)
811265fc:	11c5883a 	add	r2,r2,r7
81126600:	28c00315 	stw	r3,12(r5)
81126604:	19400215 	stw	r5,8(r3)
81126608:	10c00054 	ori	r3,r2,1
8112660c:	30c00115 	stw	r3,4(r6)
81126610:	00e04574 	movhi	r3,33045
81126614:	18f7d804 	addi	r3,r3,-8352
81126618:	18c00017 	ldw	r3,0(r3)
8112661c:	21800215 	stw	r6,8(r4)
81126620:	10ffc036 	bltu	r2,r3,81126524 <__reset+0xfb106524>
81126624:	00a04574 	movhi	r2,33045
81126628:	10b84704 	addi	r2,r2,-7908
8112662c:	11400017 	ldw	r5,0(r2)
81126630:	8809883a 	mov	r4,r17
81126634:	11263000 	call	81126300 <_malloc_trim_r>
81126638:	003fba06 	br	81126524 <__reset+0xfb106524>
8112663c:	28c9883a 	add	r4,r5,r3
81126640:	21000117 	ldw	r4,4(r4)
81126644:	2100004c 	andi	r4,r4,1
81126648:	2000391e 	bne	r4,zero,81126730 <_free_r+0x304>
8112664c:	29c00217 	ldw	r7,8(r5)
81126650:	29000317 	ldw	r4,12(r5)
81126654:	1885883a 	add	r2,r3,r2
81126658:	10c00054 	ori	r3,r2,1
8112665c:	39000315 	stw	r4,12(r7)
81126660:	21c00215 	stw	r7,8(r4)
81126664:	30c00115 	stw	r3,4(r6)
81126668:	308d883a 	add	r6,r6,r2
8112666c:	30800015 	stw	r2,0(r6)
81126670:	003fac06 	br	81126524 <__reset+0xfb106524>
81126674:	00c00504 	movi	r3,20
81126678:	19401536 	bltu	r3,r5,811266d0 <_free_r+0x2a4>
8112667c:	28c01704 	addi	r3,r5,92
81126680:	18c7883a 	add	r3,r3,r3
81126684:	294016c4 	addi	r5,r5,91
81126688:	003fb406 	br	8112655c <__reset+0xfb10655c>
8112668c:	280bd0ba 	srai	r5,r5,2
81126690:	00c00044 	movi	r3,1
81126694:	38800117 	ldw	r2,4(r7)
81126698:	194a983a 	sll	r5,r3,r5
8112669c:	2007883a 	mov	r3,r4
811266a0:	2884b03a 	or	r2,r5,r2
811266a4:	38800115 	stw	r2,4(r7)
811266a8:	003fbb06 	br	81126598 <__reset+0xfb106598>
811266ac:	21800515 	stw	r6,20(r4)
811266b0:	21800415 	stw	r6,16(r4)
811266b4:	10c00054 	ori	r3,r2,1
811266b8:	31c00315 	stw	r7,12(r6)
811266bc:	31c00215 	stw	r7,8(r6)
811266c0:	30c00115 	stw	r3,4(r6)
811266c4:	308d883a 	add	r6,r6,r2
811266c8:	30800015 	stw	r2,0(r6)
811266cc:	003f9506 	br	81126524 <__reset+0xfb106524>
811266d0:	00c01504 	movi	r3,84
811266d4:	19400536 	bltu	r3,r5,811266ec <_free_r+0x2c0>
811266d8:	100ad33a 	srli	r5,r2,12
811266dc:	28c01bc4 	addi	r3,r5,111
811266e0:	18c7883a 	add	r3,r3,r3
811266e4:	29401b84 	addi	r5,r5,110
811266e8:	003f9c06 	br	8112655c <__reset+0xfb10655c>
811266ec:	00c05504 	movi	r3,340
811266f0:	19400536 	bltu	r3,r5,81126708 <_free_r+0x2dc>
811266f4:	100ad3fa 	srli	r5,r2,15
811266f8:	28c01e04 	addi	r3,r5,120
811266fc:	18c7883a 	add	r3,r3,r3
81126700:	29401dc4 	addi	r5,r5,119
81126704:	003f9506 	br	8112655c <__reset+0xfb10655c>
81126708:	00c15504 	movi	r3,1364
8112670c:	19400536 	bltu	r3,r5,81126724 <_free_r+0x2f8>
81126710:	100ad4ba 	srli	r5,r2,18
81126714:	28c01f44 	addi	r3,r5,125
81126718:	18c7883a 	add	r3,r3,r3
8112671c:	29401f04 	addi	r5,r5,124
81126720:	003f8e06 	br	8112655c <__reset+0xfb10655c>
81126724:	00c03f84 	movi	r3,254
81126728:	01401f84 	movi	r5,126
8112672c:	003f8b06 	br	8112655c <__reset+0xfb10655c>
81126730:	10c00054 	ori	r3,r2,1
81126734:	30c00115 	stw	r3,4(r6)
81126738:	308d883a 	add	r6,r6,r2
8112673c:	30800015 	stw	r2,0(r6)
81126740:	003f7806 	br	81126524 <__reset+0xfb106524>

81126744 <__sfvwrite_r>:
81126744:	30800217 	ldw	r2,8(r6)
81126748:	10006926 	beq	r2,zero,811268f0 <__sfvwrite_r+0x1ac>
8112674c:	defff404 	addi	sp,sp,-48
81126750:	de00012e 	bgeu	sp,et,81126758 <__sfvwrite_r+0x14>
81126754:	003b68fa 	trap	3
81126758:	28c0030b 	ldhu	r3,12(r5)
8112675c:	dd400715 	stw	r21,28(sp)
81126760:	dd000615 	stw	r20,24(sp)
81126764:	dc000215 	stw	r16,8(sp)
81126768:	dfc00b15 	stw	ra,44(sp)
8112676c:	df000a15 	stw	fp,40(sp)
81126770:	ddc00915 	stw	r23,36(sp)
81126774:	dd800815 	stw	r22,32(sp)
81126778:	dcc00515 	stw	r19,20(sp)
8112677c:	dc800415 	stw	r18,16(sp)
81126780:	dc400315 	stw	r17,12(sp)
81126784:	1880020c 	andi	r2,r3,8
81126788:	2821883a 	mov	r16,r5
8112678c:	202b883a 	mov	r21,r4
81126790:	3029883a 	mov	r20,r6
81126794:	10002726 	beq	r2,zero,81126834 <__sfvwrite_r+0xf0>
81126798:	28800417 	ldw	r2,16(r5)
8112679c:	10002526 	beq	r2,zero,81126834 <__sfvwrite_r+0xf0>
811267a0:	1880008c 	andi	r2,r3,2
811267a4:	a4400017 	ldw	r17,0(r20)
811267a8:	10002a26 	beq	r2,zero,81126854 <__sfvwrite_r+0x110>
811267ac:	05a00034 	movhi	r22,32768
811267b0:	0027883a 	mov	r19,zero
811267b4:	0025883a 	mov	r18,zero
811267b8:	b5bf0004 	addi	r22,r22,-1024
811267bc:	980d883a 	mov	r6,r19
811267c0:	a809883a 	mov	r4,r21
811267c4:	90004626 	beq	r18,zero,811268e0 <__sfvwrite_r+0x19c>
811267c8:	900f883a 	mov	r7,r18
811267cc:	b480022e 	bgeu	r22,r18,811267d8 <__sfvwrite_r+0x94>
811267d0:	01e00034 	movhi	r7,32768
811267d4:	39ff0004 	addi	r7,r7,-1024
811267d8:	80800917 	ldw	r2,36(r16)
811267dc:	81400717 	ldw	r5,28(r16)
811267e0:	103ee83a 	callr	r2
811267e4:	0080570e 	bge	zero,r2,81126944 <__sfvwrite_r+0x200>
811267e8:	a0c00217 	ldw	r3,8(r20)
811267ec:	98a7883a 	add	r19,r19,r2
811267f0:	90a5c83a 	sub	r18,r18,r2
811267f4:	1885c83a 	sub	r2,r3,r2
811267f8:	a0800215 	stw	r2,8(r20)
811267fc:	103fef1e 	bne	r2,zero,811267bc <__reset+0xfb1067bc>
81126800:	0005883a 	mov	r2,zero
81126804:	dfc00b17 	ldw	ra,44(sp)
81126808:	df000a17 	ldw	fp,40(sp)
8112680c:	ddc00917 	ldw	r23,36(sp)
81126810:	dd800817 	ldw	r22,32(sp)
81126814:	dd400717 	ldw	r21,28(sp)
81126818:	dd000617 	ldw	r20,24(sp)
8112681c:	dcc00517 	ldw	r19,20(sp)
81126820:	dc800417 	ldw	r18,16(sp)
81126824:	dc400317 	ldw	r17,12(sp)
81126828:	dc000217 	ldw	r16,8(sp)
8112682c:	dec00c04 	addi	sp,sp,48
81126830:	f800283a 	ret
81126834:	800b883a 	mov	r5,r16
81126838:	a809883a 	mov	r4,r21
8112683c:	1123f240 	call	81123f24 <__swsetup_r>
81126840:	1000eb1e 	bne	r2,zero,81126bf0 <__sfvwrite_r+0x4ac>
81126844:	80c0030b 	ldhu	r3,12(r16)
81126848:	a4400017 	ldw	r17,0(r20)
8112684c:	1880008c 	andi	r2,r3,2
81126850:	103fd61e 	bne	r2,zero,811267ac <__reset+0xfb1067ac>
81126854:	1880004c 	andi	r2,r3,1
81126858:	10003f1e 	bne	r2,zero,81126958 <__sfvwrite_r+0x214>
8112685c:	0039883a 	mov	fp,zero
81126860:	0025883a 	mov	r18,zero
81126864:	90001a26 	beq	r18,zero,811268d0 <__sfvwrite_r+0x18c>
81126868:	1880800c 	andi	r2,r3,512
8112686c:	84c00217 	ldw	r19,8(r16)
81126870:	10002126 	beq	r2,zero,811268f8 <__sfvwrite_r+0x1b4>
81126874:	982f883a 	mov	r23,r19
81126878:	94c09336 	bltu	r18,r19,81126ac8 <__sfvwrite_r+0x384>
8112687c:	1881200c 	andi	r2,r3,1152
81126880:	10009e1e 	bne	r2,zero,81126afc <__sfvwrite_r+0x3b8>
81126884:	81000017 	ldw	r4,0(r16)
81126888:	b80d883a 	mov	r6,r23
8112688c:	e00b883a 	mov	r5,fp
81126890:	11272a00 	call	811272a0 <memmove>
81126894:	80c00217 	ldw	r3,8(r16)
81126898:	81000017 	ldw	r4,0(r16)
8112689c:	9005883a 	mov	r2,r18
811268a0:	1ce7c83a 	sub	r19,r3,r19
811268a4:	25cf883a 	add	r7,r4,r23
811268a8:	84c00215 	stw	r19,8(r16)
811268ac:	81c00015 	stw	r7,0(r16)
811268b0:	a0c00217 	ldw	r3,8(r20)
811268b4:	e0b9883a 	add	fp,fp,r2
811268b8:	90a5c83a 	sub	r18,r18,r2
811268bc:	18a7c83a 	sub	r19,r3,r2
811268c0:	a4c00215 	stw	r19,8(r20)
811268c4:	983fce26 	beq	r19,zero,81126800 <__reset+0xfb106800>
811268c8:	80c0030b 	ldhu	r3,12(r16)
811268cc:	903fe61e 	bne	r18,zero,81126868 <__reset+0xfb106868>
811268d0:	8f000017 	ldw	fp,0(r17)
811268d4:	8c800117 	ldw	r18,4(r17)
811268d8:	8c400204 	addi	r17,r17,8
811268dc:	003fe106 	br	81126864 <__reset+0xfb106864>
811268e0:	8cc00017 	ldw	r19,0(r17)
811268e4:	8c800117 	ldw	r18,4(r17)
811268e8:	8c400204 	addi	r17,r17,8
811268ec:	003fb306 	br	811267bc <__reset+0xfb1067bc>
811268f0:	0005883a 	mov	r2,zero
811268f4:	f800283a 	ret
811268f8:	81000017 	ldw	r4,0(r16)
811268fc:	80800417 	ldw	r2,16(r16)
81126900:	11005736 	bltu	r2,r4,81126a60 <__sfvwrite_r+0x31c>
81126904:	85c00517 	ldw	r23,20(r16)
81126908:	95c05536 	bltu	r18,r23,81126a60 <__sfvwrite_r+0x31c>
8112690c:	00a00034 	movhi	r2,32768
81126910:	10bfffc4 	addi	r2,r2,-1
81126914:	9009883a 	mov	r4,r18
81126918:	1480012e 	bgeu	r2,r18,81126920 <__sfvwrite_r+0x1dc>
8112691c:	1009883a 	mov	r4,r2
81126920:	b80b883a 	mov	r5,r23
81126924:	112f6bc0 	call	8112f6bc <__divsi3>
81126928:	15cf383a 	mul	r7,r2,r23
8112692c:	81400717 	ldw	r5,28(r16)
81126930:	80800917 	ldw	r2,36(r16)
81126934:	e00d883a 	mov	r6,fp
81126938:	a809883a 	mov	r4,r21
8112693c:	103ee83a 	callr	r2
81126940:	00bfdb16 	blt	zero,r2,811268b0 <__reset+0xfb1068b0>
81126944:	8080030b 	ldhu	r2,12(r16)
81126948:	10801014 	ori	r2,r2,64
8112694c:	8080030d 	sth	r2,12(r16)
81126950:	00bfffc4 	movi	r2,-1
81126954:	003fab06 	br	81126804 <__reset+0xfb106804>
81126958:	0027883a 	mov	r19,zero
8112695c:	0011883a 	mov	r8,zero
81126960:	0039883a 	mov	fp,zero
81126964:	0025883a 	mov	r18,zero
81126968:	90001f26 	beq	r18,zero,811269e8 <__sfvwrite_r+0x2a4>
8112696c:	40005a26 	beq	r8,zero,81126ad8 <__sfvwrite_r+0x394>
81126970:	982d883a 	mov	r22,r19
81126974:	94c0012e 	bgeu	r18,r19,8112697c <__sfvwrite_r+0x238>
81126978:	902d883a 	mov	r22,r18
8112697c:	81000017 	ldw	r4,0(r16)
81126980:	80800417 	ldw	r2,16(r16)
81126984:	b02f883a 	mov	r23,r22
81126988:	81c00517 	ldw	r7,20(r16)
8112698c:	1100032e 	bgeu	r2,r4,8112699c <__sfvwrite_r+0x258>
81126990:	80c00217 	ldw	r3,8(r16)
81126994:	38c7883a 	add	r3,r7,r3
81126998:	1d801816 	blt	r3,r22,811269fc <__sfvwrite_r+0x2b8>
8112699c:	b1c03e16 	blt	r22,r7,81126a98 <__sfvwrite_r+0x354>
811269a0:	80800917 	ldw	r2,36(r16)
811269a4:	81400717 	ldw	r5,28(r16)
811269a8:	e00d883a 	mov	r6,fp
811269ac:	da000115 	stw	r8,4(sp)
811269b0:	a809883a 	mov	r4,r21
811269b4:	103ee83a 	callr	r2
811269b8:	102f883a 	mov	r23,r2
811269bc:	da000117 	ldw	r8,4(sp)
811269c0:	00bfe00e 	bge	zero,r2,81126944 <__reset+0xfb106944>
811269c4:	9de7c83a 	sub	r19,r19,r23
811269c8:	98001f26 	beq	r19,zero,81126a48 <__sfvwrite_r+0x304>
811269cc:	a0800217 	ldw	r2,8(r20)
811269d0:	e5f9883a 	add	fp,fp,r23
811269d4:	95e5c83a 	sub	r18,r18,r23
811269d8:	15efc83a 	sub	r23,r2,r23
811269dc:	a5c00215 	stw	r23,8(r20)
811269e0:	b83f8726 	beq	r23,zero,81126800 <__reset+0xfb106800>
811269e4:	903fe11e 	bne	r18,zero,8112696c <__reset+0xfb10696c>
811269e8:	8f000017 	ldw	fp,0(r17)
811269ec:	8c800117 	ldw	r18,4(r17)
811269f0:	0011883a 	mov	r8,zero
811269f4:	8c400204 	addi	r17,r17,8
811269f8:	003fdb06 	br	81126968 <__reset+0xfb106968>
811269fc:	180d883a 	mov	r6,r3
81126a00:	e00b883a 	mov	r5,fp
81126a04:	da000115 	stw	r8,4(sp)
81126a08:	d8c00015 	stw	r3,0(sp)
81126a0c:	11272a00 	call	811272a0 <memmove>
81126a10:	d8c00017 	ldw	r3,0(sp)
81126a14:	80800017 	ldw	r2,0(r16)
81126a18:	800b883a 	mov	r5,r16
81126a1c:	a809883a 	mov	r4,r21
81126a20:	10c5883a 	add	r2,r2,r3
81126a24:	80800015 	stw	r2,0(r16)
81126a28:	d8c00015 	stw	r3,0(sp)
81126a2c:	1125b980 	call	81125b98 <_fflush_r>
81126a30:	d8c00017 	ldw	r3,0(sp)
81126a34:	da000117 	ldw	r8,4(sp)
81126a38:	103fc21e 	bne	r2,zero,81126944 <__reset+0xfb106944>
81126a3c:	182f883a 	mov	r23,r3
81126a40:	9de7c83a 	sub	r19,r19,r23
81126a44:	983fe11e 	bne	r19,zero,811269cc <__reset+0xfb1069cc>
81126a48:	800b883a 	mov	r5,r16
81126a4c:	a809883a 	mov	r4,r21
81126a50:	1125b980 	call	81125b98 <_fflush_r>
81126a54:	103fbb1e 	bne	r2,zero,81126944 <__reset+0xfb106944>
81126a58:	0011883a 	mov	r8,zero
81126a5c:	003fdb06 	br	811269cc <__reset+0xfb1069cc>
81126a60:	94c0012e 	bgeu	r18,r19,81126a68 <__sfvwrite_r+0x324>
81126a64:	9027883a 	mov	r19,r18
81126a68:	980d883a 	mov	r6,r19
81126a6c:	e00b883a 	mov	r5,fp
81126a70:	11272a00 	call	811272a0 <memmove>
81126a74:	80800217 	ldw	r2,8(r16)
81126a78:	80c00017 	ldw	r3,0(r16)
81126a7c:	14c5c83a 	sub	r2,r2,r19
81126a80:	1cc7883a 	add	r3,r3,r19
81126a84:	80800215 	stw	r2,8(r16)
81126a88:	80c00015 	stw	r3,0(r16)
81126a8c:	10004326 	beq	r2,zero,81126b9c <__sfvwrite_r+0x458>
81126a90:	9805883a 	mov	r2,r19
81126a94:	003f8606 	br	811268b0 <__reset+0xfb1068b0>
81126a98:	b00d883a 	mov	r6,r22
81126a9c:	e00b883a 	mov	r5,fp
81126aa0:	da000115 	stw	r8,4(sp)
81126aa4:	11272a00 	call	811272a0 <memmove>
81126aa8:	80800217 	ldw	r2,8(r16)
81126aac:	80c00017 	ldw	r3,0(r16)
81126ab0:	da000117 	ldw	r8,4(sp)
81126ab4:	1585c83a 	sub	r2,r2,r22
81126ab8:	1dad883a 	add	r22,r3,r22
81126abc:	80800215 	stw	r2,8(r16)
81126ac0:	85800015 	stw	r22,0(r16)
81126ac4:	003fbf06 	br	811269c4 <__reset+0xfb1069c4>
81126ac8:	81000017 	ldw	r4,0(r16)
81126acc:	9027883a 	mov	r19,r18
81126ad0:	902f883a 	mov	r23,r18
81126ad4:	003f6c06 	br	81126888 <__reset+0xfb106888>
81126ad8:	900d883a 	mov	r6,r18
81126adc:	01400284 	movi	r5,10
81126ae0:	e009883a 	mov	r4,fp
81126ae4:	11271bc0 	call	811271bc <memchr>
81126ae8:	10003e26 	beq	r2,zero,81126be4 <__sfvwrite_r+0x4a0>
81126aec:	10800044 	addi	r2,r2,1
81126af0:	1727c83a 	sub	r19,r2,fp
81126af4:	02000044 	movi	r8,1
81126af8:	003f9d06 	br	81126970 <__reset+0xfb106970>
81126afc:	80800517 	ldw	r2,20(r16)
81126b00:	81400417 	ldw	r5,16(r16)
81126b04:	81c00017 	ldw	r7,0(r16)
81126b08:	10a7883a 	add	r19,r2,r2
81126b0c:	9885883a 	add	r2,r19,r2
81126b10:	1026d7fa 	srli	r19,r2,31
81126b14:	396dc83a 	sub	r22,r7,r5
81126b18:	b1000044 	addi	r4,r22,1
81126b1c:	9885883a 	add	r2,r19,r2
81126b20:	1027d07a 	srai	r19,r2,1
81126b24:	2485883a 	add	r2,r4,r18
81126b28:	980d883a 	mov	r6,r19
81126b2c:	9880022e 	bgeu	r19,r2,81126b38 <__sfvwrite_r+0x3f4>
81126b30:	1027883a 	mov	r19,r2
81126b34:	100d883a 	mov	r6,r2
81126b38:	18c1000c 	andi	r3,r3,1024
81126b3c:	18001c26 	beq	r3,zero,81126bb0 <__sfvwrite_r+0x46c>
81126b40:	300b883a 	mov	r5,r6
81126b44:	a809883a 	mov	r4,r21
81126b48:	111c9b80 	call	8111c9b8 <_malloc_r>
81126b4c:	102f883a 	mov	r23,r2
81126b50:	10002926 	beq	r2,zero,81126bf8 <__sfvwrite_r+0x4b4>
81126b54:	81400417 	ldw	r5,16(r16)
81126b58:	b00d883a 	mov	r6,r22
81126b5c:	1009883a 	mov	r4,r2
81126b60:	111d1cc0 	call	8111d1cc <memcpy>
81126b64:	8080030b 	ldhu	r2,12(r16)
81126b68:	00fedfc4 	movi	r3,-1153
81126b6c:	10c4703a 	and	r2,r2,r3
81126b70:	10802014 	ori	r2,r2,128
81126b74:	8080030d 	sth	r2,12(r16)
81126b78:	bd89883a 	add	r4,r23,r22
81126b7c:	9d8fc83a 	sub	r7,r19,r22
81126b80:	85c00415 	stw	r23,16(r16)
81126b84:	84c00515 	stw	r19,20(r16)
81126b88:	81000015 	stw	r4,0(r16)
81126b8c:	9027883a 	mov	r19,r18
81126b90:	81c00215 	stw	r7,8(r16)
81126b94:	902f883a 	mov	r23,r18
81126b98:	003f3b06 	br	81126888 <__reset+0xfb106888>
81126b9c:	800b883a 	mov	r5,r16
81126ba0:	a809883a 	mov	r4,r21
81126ba4:	1125b980 	call	81125b98 <_fflush_r>
81126ba8:	103fb926 	beq	r2,zero,81126a90 <__reset+0xfb106a90>
81126bac:	003f6506 	br	81126944 <__reset+0xfb106944>
81126bb0:	a809883a 	mov	r4,r21
81126bb4:	11284c00 	call	811284c0 <_realloc_r>
81126bb8:	102f883a 	mov	r23,r2
81126bbc:	103fee1e 	bne	r2,zero,81126b78 <__reset+0xfb106b78>
81126bc0:	81400417 	ldw	r5,16(r16)
81126bc4:	a809883a 	mov	r4,r21
81126bc8:	112642c0 	call	8112642c <_free_r>
81126bcc:	8080030b 	ldhu	r2,12(r16)
81126bd0:	00ffdfc4 	movi	r3,-129
81126bd4:	1884703a 	and	r2,r3,r2
81126bd8:	00c00304 	movi	r3,12
81126bdc:	a8c00015 	stw	r3,0(r21)
81126be0:	003f5906 	br	81126948 <__reset+0xfb106948>
81126be4:	94c00044 	addi	r19,r18,1
81126be8:	02000044 	movi	r8,1
81126bec:	003f6006 	br	81126970 <__reset+0xfb106970>
81126bf0:	00bfffc4 	movi	r2,-1
81126bf4:	003f0306 	br	81126804 <__reset+0xfb106804>
81126bf8:	00800304 	movi	r2,12
81126bfc:	a8800015 	stw	r2,0(r21)
81126c00:	8080030b 	ldhu	r2,12(r16)
81126c04:	003f5006 	br	81126948 <__reset+0xfb106948>

81126c08 <_fwalk>:
81126c08:	defff704 	addi	sp,sp,-36
81126c0c:	de00012e 	bgeu	sp,et,81126c14 <_fwalk+0xc>
81126c10:	003b68fa 	trap	3
81126c14:	dd000415 	stw	r20,16(sp)
81126c18:	dfc00815 	stw	ra,32(sp)
81126c1c:	ddc00715 	stw	r23,28(sp)
81126c20:	dd800615 	stw	r22,24(sp)
81126c24:	dd400515 	stw	r21,20(sp)
81126c28:	dcc00315 	stw	r19,12(sp)
81126c2c:	dc800215 	stw	r18,8(sp)
81126c30:	dc400115 	stw	r17,4(sp)
81126c34:	dc000015 	stw	r16,0(sp)
81126c38:	2500b804 	addi	r20,r4,736
81126c3c:	a0002326 	beq	r20,zero,81126ccc <_fwalk+0xc4>
81126c40:	282b883a 	mov	r21,r5
81126c44:	002f883a 	mov	r23,zero
81126c48:	05800044 	movi	r22,1
81126c4c:	04ffffc4 	movi	r19,-1
81126c50:	a4400117 	ldw	r17,4(r20)
81126c54:	a4800217 	ldw	r18,8(r20)
81126c58:	8c7fffc4 	addi	r17,r17,-1
81126c5c:	88000d16 	blt	r17,zero,81126c94 <_fwalk+0x8c>
81126c60:	94000304 	addi	r16,r18,12
81126c64:	94800384 	addi	r18,r18,14
81126c68:	8080000b 	ldhu	r2,0(r16)
81126c6c:	8c7fffc4 	addi	r17,r17,-1
81126c70:	813ffd04 	addi	r4,r16,-12
81126c74:	b080042e 	bgeu	r22,r2,81126c88 <_fwalk+0x80>
81126c78:	9080000f 	ldh	r2,0(r18)
81126c7c:	14c00226 	beq	r2,r19,81126c88 <_fwalk+0x80>
81126c80:	a83ee83a 	callr	r21
81126c84:	b8aeb03a 	or	r23,r23,r2
81126c88:	84001a04 	addi	r16,r16,104
81126c8c:	94801a04 	addi	r18,r18,104
81126c90:	8cfff51e 	bne	r17,r19,81126c68 <__reset+0xfb106c68>
81126c94:	a5000017 	ldw	r20,0(r20)
81126c98:	a03fed1e 	bne	r20,zero,81126c50 <__reset+0xfb106c50>
81126c9c:	b805883a 	mov	r2,r23
81126ca0:	dfc00817 	ldw	ra,32(sp)
81126ca4:	ddc00717 	ldw	r23,28(sp)
81126ca8:	dd800617 	ldw	r22,24(sp)
81126cac:	dd400517 	ldw	r21,20(sp)
81126cb0:	dd000417 	ldw	r20,16(sp)
81126cb4:	dcc00317 	ldw	r19,12(sp)
81126cb8:	dc800217 	ldw	r18,8(sp)
81126cbc:	dc400117 	ldw	r17,4(sp)
81126cc0:	dc000017 	ldw	r16,0(sp)
81126cc4:	dec00904 	addi	sp,sp,36
81126cc8:	f800283a 	ret
81126ccc:	002f883a 	mov	r23,zero
81126cd0:	003ff206 	br	81126c9c <__reset+0xfb106c9c>

81126cd4 <_fwalk_reent>:
81126cd4:	defff704 	addi	sp,sp,-36
81126cd8:	de00012e 	bgeu	sp,et,81126ce0 <_fwalk_reent+0xc>
81126cdc:	003b68fa 	trap	3
81126ce0:	dd000415 	stw	r20,16(sp)
81126ce4:	dfc00815 	stw	ra,32(sp)
81126ce8:	ddc00715 	stw	r23,28(sp)
81126cec:	dd800615 	stw	r22,24(sp)
81126cf0:	dd400515 	stw	r21,20(sp)
81126cf4:	dcc00315 	stw	r19,12(sp)
81126cf8:	dc800215 	stw	r18,8(sp)
81126cfc:	dc400115 	stw	r17,4(sp)
81126d00:	dc000015 	stw	r16,0(sp)
81126d04:	2500b804 	addi	r20,r4,736
81126d08:	a0002326 	beq	r20,zero,81126d98 <_fwalk_reent+0xc4>
81126d0c:	282b883a 	mov	r21,r5
81126d10:	2027883a 	mov	r19,r4
81126d14:	002f883a 	mov	r23,zero
81126d18:	05800044 	movi	r22,1
81126d1c:	04bfffc4 	movi	r18,-1
81126d20:	a4400117 	ldw	r17,4(r20)
81126d24:	a4000217 	ldw	r16,8(r20)
81126d28:	8c7fffc4 	addi	r17,r17,-1
81126d2c:	88000c16 	blt	r17,zero,81126d60 <_fwalk_reent+0x8c>
81126d30:	84000304 	addi	r16,r16,12
81126d34:	8080000b 	ldhu	r2,0(r16)
81126d38:	8c7fffc4 	addi	r17,r17,-1
81126d3c:	817ffd04 	addi	r5,r16,-12
81126d40:	b080052e 	bgeu	r22,r2,81126d58 <_fwalk_reent+0x84>
81126d44:	8080008f 	ldh	r2,2(r16)
81126d48:	9809883a 	mov	r4,r19
81126d4c:	14800226 	beq	r2,r18,81126d58 <_fwalk_reent+0x84>
81126d50:	a83ee83a 	callr	r21
81126d54:	b8aeb03a 	or	r23,r23,r2
81126d58:	84001a04 	addi	r16,r16,104
81126d5c:	8cbff51e 	bne	r17,r18,81126d34 <__reset+0xfb106d34>
81126d60:	a5000017 	ldw	r20,0(r20)
81126d64:	a03fee1e 	bne	r20,zero,81126d20 <__reset+0xfb106d20>
81126d68:	b805883a 	mov	r2,r23
81126d6c:	dfc00817 	ldw	ra,32(sp)
81126d70:	ddc00717 	ldw	r23,28(sp)
81126d74:	dd800617 	ldw	r22,24(sp)
81126d78:	dd400517 	ldw	r21,20(sp)
81126d7c:	dd000417 	ldw	r20,16(sp)
81126d80:	dcc00317 	ldw	r19,12(sp)
81126d84:	dc800217 	ldw	r18,8(sp)
81126d88:	dc400117 	ldw	r17,4(sp)
81126d8c:	dc000017 	ldw	r16,0(sp)
81126d90:	dec00904 	addi	sp,sp,36
81126d94:	f800283a 	ret
81126d98:	002f883a 	mov	r23,zero
81126d9c:	003ff206 	br	81126d68 <__reset+0xfb106d68>

81126da0 <_isatty_r>:
81126da0:	defffd04 	addi	sp,sp,-12
81126da4:	de00012e 	bgeu	sp,et,81126dac <_isatty_r+0xc>
81126da8:	003b68fa 	trap	3
81126dac:	dc000015 	stw	r16,0(sp)
81126db0:	04204574 	movhi	r16,33045
81126db4:	dc400115 	stw	r17,4(sp)
81126db8:	84384404 	addi	r16,r16,-7920
81126dbc:	2023883a 	mov	r17,r4
81126dc0:	2809883a 	mov	r4,r5
81126dc4:	dfc00215 	stw	ra,8(sp)
81126dc8:	80000015 	stw	zero,0(r16)
81126dcc:	1131ef00 	call	81131ef0 <isatty>
81126dd0:	00ffffc4 	movi	r3,-1
81126dd4:	10c00526 	beq	r2,r3,81126dec <_isatty_r+0x4c>
81126dd8:	dfc00217 	ldw	ra,8(sp)
81126ddc:	dc400117 	ldw	r17,4(sp)
81126de0:	dc000017 	ldw	r16,0(sp)
81126de4:	dec00304 	addi	sp,sp,12
81126de8:	f800283a 	ret
81126dec:	80c00017 	ldw	r3,0(r16)
81126df0:	183ff926 	beq	r3,zero,81126dd8 <__reset+0xfb106dd8>
81126df4:	88c00015 	stw	r3,0(r17)
81126df8:	003ff706 	br	81126dd8 <__reset+0xfb106dd8>

81126dfc <iswspace>:
81126dfc:	00803fc4 	movi	r2,255
81126e00:	11000836 	bltu	r2,r4,81126e24 <iswspace+0x28>
81126e04:	00a04574 	movhi	r2,33045
81126e08:	10b7d404 	addi	r2,r2,-8368
81126e0c:	10800017 	ldw	r2,0(r2)
81126e10:	1109883a 	add	r4,r2,r4
81126e14:	20800043 	ldbu	r2,1(r4)
81126e18:	1080020c 	andi	r2,r2,8
81126e1c:	10803fcc 	andi	r2,r2,255
81126e20:	f800283a 	ret
81126e24:	0005883a 	mov	r2,zero
81126e28:	f800283a 	ret

81126e2c <_setlocale_r>:
81126e2c:	30001d26 	beq	r6,zero,81126ea4 <_setlocale_r+0x78>
81126e30:	01604574 	movhi	r5,33045
81126e34:	defffe04 	addi	sp,sp,-8
81126e38:	296e2d04 	addi	r5,r5,-18252
81126e3c:	3009883a 	mov	r4,r6
81126e40:	de00012e 	bgeu	sp,et,81126e48 <_setlocale_r+0x1c>
81126e44:	003b68fa 	trap	3
81126e48:	dc000015 	stw	r16,0(sp)
81126e4c:	dfc00115 	stw	ra,4(sp)
81126e50:	3021883a 	mov	r16,r6
81126e54:	1128b780 	call	81128b78 <strcmp>
81126e58:	1000061e 	bne	r2,zero,81126e74 <_setlocale_r+0x48>
81126e5c:	00a04574 	movhi	r2,33045
81126e60:	10adfc04 	addi	r2,r2,-18448
81126e64:	dfc00117 	ldw	ra,4(sp)
81126e68:	dc000017 	ldw	r16,0(sp)
81126e6c:	dec00204 	addi	sp,sp,8
81126e70:	f800283a 	ret
81126e74:	01604574 	movhi	r5,33045
81126e78:	296dfc04 	addi	r5,r5,-18448
81126e7c:	8009883a 	mov	r4,r16
81126e80:	1128b780 	call	81128b78 <strcmp>
81126e84:	103ff526 	beq	r2,zero,81126e5c <__reset+0xfb106e5c>
81126e88:	01604574 	movhi	r5,33045
81126e8c:	296e0604 	addi	r5,r5,-18408
81126e90:	8009883a 	mov	r4,r16
81126e94:	1128b780 	call	81128b78 <strcmp>
81126e98:	103ff026 	beq	r2,zero,81126e5c <__reset+0xfb106e5c>
81126e9c:	0005883a 	mov	r2,zero
81126ea0:	003ff006 	br	81126e64 <__reset+0xfb106e64>
81126ea4:	00a04574 	movhi	r2,33045
81126ea8:	10adfc04 	addi	r2,r2,-18448
81126eac:	f800283a 	ret

81126eb0 <__locale_charset>:
81126eb0:	00a04574 	movhi	r2,33045
81126eb4:	10b29e04 	addi	r2,r2,-13704
81126eb8:	f800283a 	ret

81126ebc <__locale_mb_cur_max>:
81126ebc:	00a04574 	movhi	r2,33045
81126ec0:	10b7d904 	addi	r2,r2,-8348
81126ec4:	10800017 	ldw	r2,0(r2)
81126ec8:	f800283a 	ret

81126ecc <__locale_msgcharset>:
81126ecc:	00a04574 	movhi	r2,33045
81126ed0:	10b29604 	addi	r2,r2,-13736
81126ed4:	f800283a 	ret

81126ed8 <__locale_cjk_lang>:
81126ed8:	0005883a 	mov	r2,zero
81126edc:	f800283a 	ret

81126ee0 <_localeconv_r>:
81126ee0:	00a04574 	movhi	r2,33045
81126ee4:	10b2a604 	addi	r2,r2,-13672
81126ee8:	f800283a 	ret

81126eec <setlocale>:
81126eec:	00a04574 	movhi	r2,33045
81126ef0:	10b7d604 	addi	r2,r2,-8360
81126ef4:	280d883a 	mov	r6,r5
81126ef8:	200b883a 	mov	r5,r4
81126efc:	11000017 	ldw	r4,0(r2)
81126f00:	1126e2c1 	jmpi	81126e2c <_setlocale_r>

81126f04 <localeconv>:
81126f04:	00a04574 	movhi	r2,33045
81126f08:	10b2a604 	addi	r2,r2,-13672
81126f0c:	f800283a 	ret

81126f10 <_lseek_r>:
81126f10:	defffd04 	addi	sp,sp,-12
81126f14:	de00012e 	bgeu	sp,et,81126f1c <_lseek_r+0xc>
81126f18:	003b68fa 	trap	3
81126f1c:	2805883a 	mov	r2,r5
81126f20:	dc000015 	stw	r16,0(sp)
81126f24:	04204574 	movhi	r16,33045
81126f28:	dc400115 	stw	r17,4(sp)
81126f2c:	300b883a 	mov	r5,r6
81126f30:	84384404 	addi	r16,r16,-7920
81126f34:	2023883a 	mov	r17,r4
81126f38:	380d883a 	mov	r6,r7
81126f3c:	1009883a 	mov	r4,r2
81126f40:	dfc00215 	stw	ra,8(sp)
81126f44:	80000015 	stw	zero,0(r16)
81126f48:	1132aec0 	call	81132aec <lseek>
81126f4c:	00ffffc4 	movi	r3,-1
81126f50:	10c00526 	beq	r2,r3,81126f68 <_lseek_r+0x58>
81126f54:	dfc00217 	ldw	ra,8(sp)
81126f58:	dc400117 	ldw	r17,4(sp)
81126f5c:	dc000017 	ldw	r16,0(sp)
81126f60:	dec00304 	addi	sp,sp,12
81126f64:	f800283a 	ret
81126f68:	80c00017 	ldw	r3,0(r16)
81126f6c:	183ff926 	beq	r3,zero,81126f54 <__reset+0xfb106f54>
81126f70:	88c00015 	stw	r3,0(r17)
81126f74:	003ff706 	br	81126f54 <__reset+0xfb106f54>

81126f78 <_mbrtowc_r>:
81126f78:	defff704 	addi	sp,sp,-36
81126f7c:	00a04574 	movhi	r2,33045
81126f80:	de00012e 	bgeu	sp,et,81126f88 <_mbrtowc_r+0x10>
81126f84:	003b68fa 	trap	3
81126f88:	10b7da04 	addi	r2,r2,-8344
81126f8c:	dc800715 	stw	r18,28(sp)
81126f90:	dc400615 	stw	r17,24(sp)
81126f94:	dc000515 	stw	r16,20(sp)
81126f98:	dfc00815 	stw	ra,32(sp)
81126f9c:	2021883a 	mov	r16,r4
81126fa0:	dc400917 	ldw	r17,36(sp)
81126fa4:	14800017 	ldw	r18,0(r2)
81126fa8:	30001626 	beq	r6,zero,81127004 <_mbrtowc_r+0x8c>
81126fac:	d9400215 	stw	r5,8(sp)
81126fb0:	d9800315 	stw	r6,12(sp)
81126fb4:	d9c00415 	stw	r7,16(sp)
81126fb8:	1126eb00 	call	81126eb0 <__locale_charset>
81126fbc:	d9c00417 	ldw	r7,16(sp)
81126fc0:	d9800317 	ldw	r6,12(sp)
81126fc4:	d9400217 	ldw	r5,8(sp)
81126fc8:	d8800015 	stw	r2,0(sp)
81126fcc:	dc400115 	stw	r17,4(sp)
81126fd0:	8009883a 	mov	r4,r16
81126fd4:	903ee83a 	callr	r18
81126fd8:	00ffffc4 	movi	r3,-1
81126fdc:	10c0031e 	bne	r2,r3,81126fec <_mbrtowc_r+0x74>
81126fe0:	88000015 	stw	zero,0(r17)
81126fe4:	00c02284 	movi	r3,138
81126fe8:	80c00015 	stw	r3,0(r16)
81126fec:	dfc00817 	ldw	ra,32(sp)
81126ff0:	dc800717 	ldw	r18,28(sp)
81126ff4:	dc400617 	ldw	r17,24(sp)
81126ff8:	dc000517 	ldw	r16,20(sp)
81126ffc:	dec00904 	addi	sp,sp,36
81127000:	f800283a 	ret
81127004:	1126eb00 	call	81126eb0 <__locale_charset>
81127008:	01a04574 	movhi	r6,33045
8112700c:	31ae0604 	addi	r6,r6,-18408
81127010:	dc400115 	stw	r17,4(sp)
81127014:	d8800015 	stw	r2,0(sp)
81127018:	01c00044 	movi	r7,1
8112701c:	000b883a 	mov	r5,zero
81127020:	8009883a 	mov	r4,r16
81127024:	903ee83a 	callr	r18
81127028:	003feb06 	br	81126fd8 <__reset+0xfb106fd8>

8112702c <mbrtowc>:
8112702c:	defff704 	addi	sp,sp,-36
81127030:	00a04574 	movhi	r2,33045
81127034:	de00012e 	bgeu	sp,et,8112703c <mbrtowc+0x10>
81127038:	003b68fa 	trap	3
8112703c:	10b7d604 	addi	r2,r2,-8360
81127040:	dc800415 	stw	r18,16(sp)
81127044:	dc400315 	stw	r17,12(sp)
81127048:	dfc00815 	stw	ra,32(sp)
8112704c:	dd400715 	stw	r21,28(sp)
81127050:	dd000615 	stw	r20,24(sp)
81127054:	dcc00515 	stw	r19,20(sp)
81127058:	dc000215 	stw	r16,8(sp)
8112705c:	3825883a 	mov	r18,r7
81127060:	14400017 	ldw	r17,0(r2)
81127064:	28001c26 	beq	r5,zero,811270d8 <mbrtowc+0xac>
81127068:	00a04574 	movhi	r2,33045
8112706c:	10b7da04 	addi	r2,r2,-8344
81127070:	15400017 	ldw	r21,0(r2)
81127074:	2821883a 	mov	r16,r5
81127078:	2027883a 	mov	r19,r4
8112707c:	3029883a 	mov	r20,r6
81127080:	1126eb00 	call	81126eb0 <__locale_charset>
81127084:	d8800015 	stw	r2,0(sp)
81127088:	dc800115 	stw	r18,4(sp)
8112708c:	a00f883a 	mov	r7,r20
81127090:	800d883a 	mov	r6,r16
81127094:	980b883a 	mov	r5,r19
81127098:	8809883a 	mov	r4,r17
8112709c:	a83ee83a 	callr	r21
811270a0:	00ffffc4 	movi	r3,-1
811270a4:	10c0031e 	bne	r2,r3,811270b4 <mbrtowc+0x88>
811270a8:	90000015 	stw	zero,0(r18)
811270ac:	00c02284 	movi	r3,138
811270b0:	88c00015 	stw	r3,0(r17)
811270b4:	dfc00817 	ldw	ra,32(sp)
811270b8:	dd400717 	ldw	r21,28(sp)
811270bc:	dd000617 	ldw	r20,24(sp)
811270c0:	dcc00517 	ldw	r19,20(sp)
811270c4:	dc800417 	ldw	r18,16(sp)
811270c8:	dc400317 	ldw	r17,12(sp)
811270cc:	dc000217 	ldw	r16,8(sp)
811270d0:	dec00904 	addi	sp,sp,36
811270d4:	f800283a 	ret
811270d8:	00a04574 	movhi	r2,33045
811270dc:	10b7da04 	addi	r2,r2,-8344
811270e0:	14000017 	ldw	r16,0(r2)
811270e4:	1126eb00 	call	81126eb0 <__locale_charset>
811270e8:	01a04574 	movhi	r6,33045
811270ec:	31ae0604 	addi	r6,r6,-18408
811270f0:	dc800115 	stw	r18,4(sp)
811270f4:	d8800015 	stw	r2,0(sp)
811270f8:	01c00044 	movi	r7,1
811270fc:	000b883a 	mov	r5,zero
81127100:	8809883a 	mov	r4,r17
81127104:	803ee83a 	callr	r16
81127108:	003fe506 	br	811270a0 <__reset+0xfb1070a0>

8112710c <__ascii_mbtowc>:
8112710c:	deffff04 	addi	sp,sp,-4
81127110:	de00012e 	bgeu	sp,et,81127118 <__ascii_mbtowc+0xc>
81127114:	003b68fa 	trap	3
81127118:	28000826 	beq	r5,zero,8112713c <__ascii_mbtowc+0x30>
8112711c:	30000926 	beq	r6,zero,81127144 <__ascii_mbtowc+0x38>
81127120:	38000b26 	beq	r7,zero,81127150 <__ascii_mbtowc+0x44>
81127124:	30800003 	ldbu	r2,0(r6)
81127128:	28800015 	stw	r2,0(r5)
8112712c:	30800003 	ldbu	r2,0(r6)
81127130:	1004c03a 	cmpne	r2,r2,zero
81127134:	dec00104 	addi	sp,sp,4
81127138:	f800283a 	ret
8112713c:	d80b883a 	mov	r5,sp
81127140:	303ff71e 	bne	r6,zero,81127120 <__reset+0xfb107120>
81127144:	0005883a 	mov	r2,zero
81127148:	dec00104 	addi	sp,sp,4
8112714c:	f800283a 	ret
81127150:	00bfff84 	movi	r2,-2
81127154:	003ff706 	br	81127134 <__reset+0xfb107134>

81127158 <_mbtowc_r>:
81127158:	00a04574 	movhi	r2,33045
8112715c:	defff804 	addi	sp,sp,-32
81127160:	10b7da04 	addi	r2,r2,-8344
81127164:	de00012e 	bgeu	sp,et,8112716c <_mbtowc_r+0x14>
81127168:	003b68fa 	trap	3
8112716c:	dfc00715 	stw	ra,28(sp)
81127170:	dc000615 	stw	r16,24(sp)
81127174:	14000017 	ldw	r16,0(r2)
81127178:	d9000215 	stw	r4,8(sp)
8112717c:	d9400315 	stw	r5,12(sp)
81127180:	d9800415 	stw	r6,16(sp)
81127184:	d9c00515 	stw	r7,20(sp)
81127188:	1126eb00 	call	81126eb0 <__locale_charset>
8112718c:	d8800015 	stw	r2,0(sp)
81127190:	d8800817 	ldw	r2,32(sp)
81127194:	d9c00517 	ldw	r7,20(sp)
81127198:	d9800417 	ldw	r6,16(sp)
8112719c:	d9400317 	ldw	r5,12(sp)
811271a0:	d9000217 	ldw	r4,8(sp)
811271a4:	d8800115 	stw	r2,4(sp)
811271a8:	803ee83a 	callr	r16
811271ac:	dfc00717 	ldw	ra,28(sp)
811271b0:	dc000617 	ldw	r16,24(sp)
811271b4:	dec00804 	addi	sp,sp,32
811271b8:	f800283a 	ret

811271bc <memchr>:
811271bc:	208000cc 	andi	r2,r4,3
811271c0:	280f883a 	mov	r7,r5
811271c4:	10003426 	beq	r2,zero,81127298 <memchr+0xdc>
811271c8:	30bfffc4 	addi	r2,r6,-1
811271cc:	30001a26 	beq	r6,zero,81127238 <memchr+0x7c>
811271d0:	20c00003 	ldbu	r3,0(r4)
811271d4:	29803fcc 	andi	r6,r5,255
811271d8:	30c0051e 	bne	r6,r3,811271f0 <memchr+0x34>
811271dc:	00001806 	br	81127240 <memchr+0x84>
811271e0:	10001526 	beq	r2,zero,81127238 <memchr+0x7c>
811271e4:	20c00003 	ldbu	r3,0(r4)
811271e8:	10bfffc4 	addi	r2,r2,-1
811271ec:	30c01426 	beq	r6,r3,81127240 <memchr+0x84>
811271f0:	21000044 	addi	r4,r4,1
811271f4:	20c000cc 	andi	r3,r4,3
811271f8:	183ff91e 	bne	r3,zero,811271e0 <__reset+0xfb1071e0>
811271fc:	020000c4 	movi	r8,3
81127200:	40801136 	bltu	r8,r2,81127248 <memchr+0x8c>
81127204:	10000c26 	beq	r2,zero,81127238 <memchr+0x7c>
81127208:	20c00003 	ldbu	r3,0(r4)
8112720c:	29403fcc 	andi	r5,r5,255
81127210:	28c00b26 	beq	r5,r3,81127240 <memchr+0x84>
81127214:	20c00044 	addi	r3,r4,1
81127218:	39803fcc 	andi	r6,r7,255
8112721c:	2089883a 	add	r4,r4,r2
81127220:	00000306 	br	81127230 <memchr+0x74>
81127224:	18c00044 	addi	r3,r3,1
81127228:	197fffc3 	ldbu	r5,-1(r3)
8112722c:	31400526 	beq	r6,r5,81127244 <memchr+0x88>
81127230:	1805883a 	mov	r2,r3
81127234:	20fffb1e 	bne	r4,r3,81127224 <__reset+0xfb107224>
81127238:	0005883a 	mov	r2,zero
8112723c:	f800283a 	ret
81127240:	2005883a 	mov	r2,r4
81127244:	f800283a 	ret
81127248:	28c03fcc 	andi	r3,r5,255
8112724c:	1812923a 	slli	r9,r3,8
81127250:	02ffbff4 	movhi	r11,65279
81127254:	02a02074 	movhi	r10,32897
81127258:	48d2b03a 	or	r9,r9,r3
8112725c:	4806943a 	slli	r3,r9,16
81127260:	5affbfc4 	addi	r11,r11,-257
81127264:	52a02004 	addi	r10,r10,-32640
81127268:	48d2b03a 	or	r9,r9,r3
8112726c:	20c00017 	ldw	r3,0(r4)
81127270:	48c6f03a 	xor	r3,r9,r3
81127274:	1acd883a 	add	r6,r3,r11
81127278:	00c6303a 	nor	r3,zero,r3
8112727c:	30c6703a 	and	r3,r6,r3
81127280:	1a86703a 	and	r3,r3,r10
81127284:	183fe01e 	bne	r3,zero,81127208 <__reset+0xfb107208>
81127288:	10bfff04 	addi	r2,r2,-4
8112728c:	21000104 	addi	r4,r4,4
81127290:	40bff636 	bltu	r8,r2,8112726c <__reset+0xfb10726c>
81127294:	003fdb06 	br	81127204 <__reset+0xfb107204>
81127298:	3005883a 	mov	r2,r6
8112729c:	003fd706 	br	811271fc <__reset+0xfb1071fc>

811272a0 <memmove>:
811272a0:	2005883a 	mov	r2,r4
811272a4:	29000b2e 	bgeu	r5,r4,811272d4 <memmove+0x34>
811272a8:	298f883a 	add	r7,r5,r6
811272ac:	21c0092e 	bgeu	r4,r7,811272d4 <memmove+0x34>
811272b0:	2187883a 	add	r3,r4,r6
811272b4:	198bc83a 	sub	r5,r3,r6
811272b8:	30004826 	beq	r6,zero,811273dc <memmove+0x13c>
811272bc:	39ffffc4 	addi	r7,r7,-1
811272c0:	39000003 	ldbu	r4,0(r7)
811272c4:	18ffffc4 	addi	r3,r3,-1
811272c8:	19000005 	stb	r4,0(r3)
811272cc:	28fffb1e 	bne	r5,r3,811272bc <__reset+0xfb1072bc>
811272d0:	f800283a 	ret
811272d4:	00c003c4 	movi	r3,15
811272d8:	1980412e 	bgeu	r3,r6,811273e0 <memmove+0x140>
811272dc:	2886b03a 	or	r3,r5,r2
811272e0:	18c000cc 	andi	r3,r3,3
811272e4:	1800401e 	bne	r3,zero,811273e8 <memmove+0x148>
811272e8:	33fffc04 	addi	r15,r6,-16
811272ec:	781ed13a 	srli	r15,r15,4
811272f0:	28c00104 	addi	r3,r5,4
811272f4:	13400104 	addi	r13,r2,4
811272f8:	781c913a 	slli	r14,r15,4
811272fc:	2b000204 	addi	r12,r5,8
81127300:	12c00204 	addi	r11,r2,8
81127304:	73800504 	addi	r14,r14,20
81127308:	2a800304 	addi	r10,r5,12
8112730c:	12400304 	addi	r9,r2,12
81127310:	2b9d883a 	add	r14,r5,r14
81127314:	2811883a 	mov	r8,r5
81127318:	100f883a 	mov	r7,r2
8112731c:	41000017 	ldw	r4,0(r8)
81127320:	39c00404 	addi	r7,r7,16
81127324:	18c00404 	addi	r3,r3,16
81127328:	393ffc15 	stw	r4,-16(r7)
8112732c:	193ffc17 	ldw	r4,-16(r3)
81127330:	6b400404 	addi	r13,r13,16
81127334:	5ac00404 	addi	r11,r11,16
81127338:	693ffc15 	stw	r4,-16(r13)
8112733c:	61000017 	ldw	r4,0(r12)
81127340:	4a400404 	addi	r9,r9,16
81127344:	42000404 	addi	r8,r8,16
81127348:	593ffc15 	stw	r4,-16(r11)
8112734c:	51000017 	ldw	r4,0(r10)
81127350:	63000404 	addi	r12,r12,16
81127354:	52800404 	addi	r10,r10,16
81127358:	493ffc15 	stw	r4,-16(r9)
8112735c:	1bbfef1e 	bne	r3,r14,8112731c <__reset+0xfb10731c>
81127360:	79000044 	addi	r4,r15,1
81127364:	2008913a 	slli	r4,r4,4
81127368:	328003cc 	andi	r10,r6,15
8112736c:	02c000c4 	movi	r11,3
81127370:	1107883a 	add	r3,r2,r4
81127374:	290b883a 	add	r5,r5,r4
81127378:	5a801e2e 	bgeu	r11,r10,811273f4 <memmove+0x154>
8112737c:	1813883a 	mov	r9,r3
81127380:	2811883a 	mov	r8,r5
81127384:	500f883a 	mov	r7,r10
81127388:	41000017 	ldw	r4,0(r8)
8112738c:	4a400104 	addi	r9,r9,4
81127390:	39ffff04 	addi	r7,r7,-4
81127394:	493fff15 	stw	r4,-4(r9)
81127398:	42000104 	addi	r8,r8,4
8112739c:	59fffa36 	bltu	r11,r7,81127388 <__reset+0xfb107388>
811273a0:	513fff04 	addi	r4,r10,-4
811273a4:	2008d0ba 	srli	r4,r4,2
811273a8:	318000cc 	andi	r6,r6,3
811273ac:	21000044 	addi	r4,r4,1
811273b0:	2109883a 	add	r4,r4,r4
811273b4:	2109883a 	add	r4,r4,r4
811273b8:	1907883a 	add	r3,r3,r4
811273bc:	290b883a 	add	r5,r5,r4
811273c0:	30000b26 	beq	r6,zero,811273f0 <memmove+0x150>
811273c4:	198d883a 	add	r6,r3,r6
811273c8:	29c00003 	ldbu	r7,0(r5)
811273cc:	18c00044 	addi	r3,r3,1
811273d0:	29400044 	addi	r5,r5,1
811273d4:	19ffffc5 	stb	r7,-1(r3)
811273d8:	19bffb1e 	bne	r3,r6,811273c8 <__reset+0xfb1073c8>
811273dc:	f800283a 	ret
811273e0:	1007883a 	mov	r3,r2
811273e4:	003ff606 	br	811273c0 <__reset+0xfb1073c0>
811273e8:	1007883a 	mov	r3,r2
811273ec:	003ff506 	br	811273c4 <__reset+0xfb1073c4>
811273f0:	f800283a 	ret
811273f4:	500d883a 	mov	r6,r10
811273f8:	003ff106 	br	811273c0 <__reset+0xfb1073c0>

811273fc <_Balloc>:
811273fc:	defffc04 	addi	sp,sp,-16
81127400:	de00012e 	bgeu	sp,et,81127408 <_Balloc+0xc>
81127404:	003b68fa 	trap	3
81127408:	20801317 	ldw	r2,76(r4)
8112740c:	dc400115 	stw	r17,4(sp)
81127410:	dc000015 	stw	r16,0(sp)
81127414:	dfc00315 	stw	ra,12(sp)
81127418:	dc800215 	stw	r18,8(sp)
8112741c:	2023883a 	mov	r17,r4
81127420:	2821883a 	mov	r16,r5
81127424:	10000f26 	beq	r2,zero,81127464 <_Balloc+0x68>
81127428:	8407883a 	add	r3,r16,r16
8112742c:	18c7883a 	add	r3,r3,r3
81127430:	10c7883a 	add	r3,r2,r3
81127434:	18800017 	ldw	r2,0(r3)
81127438:	10001126 	beq	r2,zero,81127480 <_Balloc+0x84>
8112743c:	11000017 	ldw	r4,0(r2)
81127440:	19000015 	stw	r4,0(r3)
81127444:	10000415 	stw	zero,16(r2)
81127448:	10000315 	stw	zero,12(r2)
8112744c:	dfc00317 	ldw	ra,12(sp)
81127450:	dc800217 	ldw	r18,8(sp)
81127454:	dc400117 	ldw	r17,4(sp)
81127458:	dc000017 	ldw	r16,0(sp)
8112745c:	dec00404 	addi	sp,sp,16
81127460:	f800283a 	ret
81127464:	01800844 	movi	r6,33
81127468:	01400104 	movi	r5,4
8112746c:	112d9240 	call	8112d924 <_calloc_r>
81127470:	88801315 	stw	r2,76(r17)
81127474:	103fec1e 	bne	r2,zero,81127428 <__reset+0xfb107428>
81127478:	0005883a 	mov	r2,zero
8112747c:	003ff306 	br	8112744c <__reset+0xfb10744c>
81127480:	01400044 	movi	r5,1
81127484:	2c24983a 	sll	r18,r5,r16
81127488:	8809883a 	mov	r4,r17
8112748c:	91800144 	addi	r6,r18,5
81127490:	318d883a 	add	r6,r6,r6
81127494:	318d883a 	add	r6,r6,r6
81127498:	112d9240 	call	8112d924 <_calloc_r>
8112749c:	103ff626 	beq	r2,zero,81127478 <__reset+0xfb107478>
811274a0:	14000115 	stw	r16,4(r2)
811274a4:	14800215 	stw	r18,8(r2)
811274a8:	003fe606 	br	81127444 <__reset+0xfb107444>

811274ac <_Bfree>:
811274ac:	28000826 	beq	r5,zero,811274d0 <_Bfree+0x24>
811274b0:	28c00117 	ldw	r3,4(r5)
811274b4:	20801317 	ldw	r2,76(r4)
811274b8:	18c7883a 	add	r3,r3,r3
811274bc:	18c7883a 	add	r3,r3,r3
811274c0:	10c5883a 	add	r2,r2,r3
811274c4:	10c00017 	ldw	r3,0(r2)
811274c8:	28c00015 	stw	r3,0(r5)
811274cc:	11400015 	stw	r5,0(r2)
811274d0:	f800283a 	ret

811274d4 <__multadd>:
811274d4:	defffa04 	addi	sp,sp,-24
811274d8:	de00012e 	bgeu	sp,et,811274e0 <__multadd+0xc>
811274dc:	003b68fa 	trap	3
811274e0:	0011883a 	mov	r8,zero
811274e4:	dc800315 	stw	r18,12(sp)
811274e8:	dc400215 	stw	r17,8(sp)
811274ec:	dc000115 	stw	r16,4(sp)
811274f0:	2823883a 	mov	r17,r5
811274f4:	2c000417 	ldw	r16,16(r5)
811274f8:	dfc00515 	stw	ra,20(sp)
811274fc:	dcc00415 	stw	r19,16(sp)
81127500:	2025883a 	mov	r18,r4
81127504:	29400504 	addi	r5,r5,20
81127508:	28c00017 	ldw	r3,0(r5)
8112750c:	29400104 	addi	r5,r5,4
81127510:	42000044 	addi	r8,r8,1
81127514:	18bfffcc 	andi	r2,r3,65535
81127518:	1185383a 	mul	r2,r2,r6
8112751c:	1806d43a 	srli	r3,r3,16
81127520:	11cf883a 	add	r7,r2,r7
81127524:	3808d43a 	srli	r4,r7,16
81127528:	1987383a 	mul	r3,r3,r6
8112752c:	38bfffcc 	andi	r2,r7,65535
81127530:	1907883a 	add	r3,r3,r4
81127534:	1808943a 	slli	r4,r3,16
81127538:	180ed43a 	srli	r7,r3,16
8112753c:	2085883a 	add	r2,r4,r2
81127540:	28bfff15 	stw	r2,-4(r5)
81127544:	443ff016 	blt	r8,r16,81127508 <__reset+0xfb107508>
81127548:	38000926 	beq	r7,zero,81127570 <__multadd+0x9c>
8112754c:	88800217 	ldw	r2,8(r17)
81127550:	80800f0e 	bge	r16,r2,81127590 <__multadd+0xbc>
81127554:	80800144 	addi	r2,r16,5
81127558:	1085883a 	add	r2,r2,r2
8112755c:	1085883a 	add	r2,r2,r2
81127560:	8885883a 	add	r2,r17,r2
81127564:	11c00015 	stw	r7,0(r2)
81127568:	84000044 	addi	r16,r16,1
8112756c:	8c000415 	stw	r16,16(r17)
81127570:	8805883a 	mov	r2,r17
81127574:	dfc00517 	ldw	ra,20(sp)
81127578:	dcc00417 	ldw	r19,16(sp)
8112757c:	dc800317 	ldw	r18,12(sp)
81127580:	dc400217 	ldw	r17,8(sp)
81127584:	dc000117 	ldw	r16,4(sp)
81127588:	dec00604 	addi	sp,sp,24
8112758c:	f800283a 	ret
81127590:	89400117 	ldw	r5,4(r17)
81127594:	9009883a 	mov	r4,r18
81127598:	d9c00015 	stw	r7,0(sp)
8112759c:	29400044 	addi	r5,r5,1
811275a0:	11273fc0 	call	811273fc <_Balloc>
811275a4:	89800417 	ldw	r6,16(r17)
811275a8:	89400304 	addi	r5,r17,12
811275ac:	11000304 	addi	r4,r2,12
811275b0:	31800084 	addi	r6,r6,2
811275b4:	318d883a 	add	r6,r6,r6
811275b8:	318d883a 	add	r6,r6,r6
811275bc:	1027883a 	mov	r19,r2
811275c0:	111d1cc0 	call	8111d1cc <memcpy>
811275c4:	d9c00017 	ldw	r7,0(sp)
811275c8:	88000a26 	beq	r17,zero,811275f4 <__multadd+0x120>
811275cc:	88c00117 	ldw	r3,4(r17)
811275d0:	90801317 	ldw	r2,76(r18)
811275d4:	18c7883a 	add	r3,r3,r3
811275d8:	18c7883a 	add	r3,r3,r3
811275dc:	10c5883a 	add	r2,r2,r3
811275e0:	10c00017 	ldw	r3,0(r2)
811275e4:	88c00015 	stw	r3,0(r17)
811275e8:	14400015 	stw	r17,0(r2)
811275ec:	9823883a 	mov	r17,r19
811275f0:	003fd806 	br	81127554 <__reset+0xfb107554>
811275f4:	9823883a 	mov	r17,r19
811275f8:	003fd606 	br	81127554 <__reset+0xfb107554>

811275fc <__s2b>:
811275fc:	defff904 	addi	sp,sp,-28
81127600:	de00012e 	bgeu	sp,et,81127608 <__s2b+0xc>
81127604:	003b68fa 	trap	3
81127608:	dc400115 	stw	r17,4(sp)
8112760c:	dc000015 	stw	r16,0(sp)
81127610:	2023883a 	mov	r17,r4
81127614:	2821883a 	mov	r16,r5
81127618:	39000204 	addi	r4,r7,8
8112761c:	01400244 	movi	r5,9
81127620:	dcc00315 	stw	r19,12(sp)
81127624:	dc800215 	stw	r18,8(sp)
81127628:	dfc00615 	stw	ra,24(sp)
8112762c:	dd400515 	stw	r21,20(sp)
81127630:	dd000415 	stw	r20,16(sp)
81127634:	3825883a 	mov	r18,r7
81127638:	3027883a 	mov	r19,r6
8112763c:	112f6bc0 	call	8112f6bc <__divsi3>
81127640:	00c00044 	movi	r3,1
81127644:	000b883a 	mov	r5,zero
81127648:	1880030e 	bge	r3,r2,81127658 <__s2b+0x5c>
8112764c:	18c7883a 	add	r3,r3,r3
81127650:	29400044 	addi	r5,r5,1
81127654:	18bffd16 	blt	r3,r2,8112764c <__reset+0xfb10764c>
81127658:	8809883a 	mov	r4,r17
8112765c:	11273fc0 	call	811273fc <_Balloc>
81127660:	d8c00717 	ldw	r3,28(sp)
81127664:	10c00515 	stw	r3,20(r2)
81127668:	00c00044 	movi	r3,1
8112766c:	10c00415 	stw	r3,16(r2)
81127670:	00c00244 	movi	r3,9
81127674:	1cc0210e 	bge	r3,r19,811276fc <__s2b+0x100>
81127678:	80eb883a 	add	r21,r16,r3
8112767c:	a829883a 	mov	r20,r21
81127680:	84e1883a 	add	r16,r16,r19
81127684:	a1c00007 	ldb	r7,0(r20)
81127688:	01800284 	movi	r6,10
8112768c:	a5000044 	addi	r20,r20,1
81127690:	100b883a 	mov	r5,r2
81127694:	39fff404 	addi	r7,r7,-48
81127698:	8809883a 	mov	r4,r17
8112769c:	11274d40 	call	811274d4 <__multadd>
811276a0:	a43ff81e 	bne	r20,r16,81127684 <__reset+0xfb107684>
811276a4:	ace1883a 	add	r16,r21,r19
811276a8:	843ffe04 	addi	r16,r16,-8
811276ac:	9c800a0e 	bge	r19,r18,811276d8 <__s2b+0xdc>
811276b0:	94e5c83a 	sub	r18,r18,r19
811276b4:	84a5883a 	add	r18,r16,r18
811276b8:	81c00007 	ldb	r7,0(r16)
811276bc:	01800284 	movi	r6,10
811276c0:	84000044 	addi	r16,r16,1
811276c4:	100b883a 	mov	r5,r2
811276c8:	39fff404 	addi	r7,r7,-48
811276cc:	8809883a 	mov	r4,r17
811276d0:	11274d40 	call	811274d4 <__multadd>
811276d4:	84bff81e 	bne	r16,r18,811276b8 <__reset+0xfb1076b8>
811276d8:	dfc00617 	ldw	ra,24(sp)
811276dc:	dd400517 	ldw	r21,20(sp)
811276e0:	dd000417 	ldw	r20,16(sp)
811276e4:	dcc00317 	ldw	r19,12(sp)
811276e8:	dc800217 	ldw	r18,8(sp)
811276ec:	dc400117 	ldw	r17,4(sp)
811276f0:	dc000017 	ldw	r16,0(sp)
811276f4:	dec00704 	addi	sp,sp,28
811276f8:	f800283a 	ret
811276fc:	84000284 	addi	r16,r16,10
81127700:	1827883a 	mov	r19,r3
81127704:	003fe906 	br	811276ac <__reset+0xfb1076ac>

81127708 <__hi0bits>:
81127708:	20bfffec 	andhi	r2,r4,65535
8112770c:	1000141e 	bne	r2,zero,81127760 <__hi0bits+0x58>
81127710:	2008943a 	slli	r4,r4,16
81127714:	00800404 	movi	r2,16
81127718:	20ffc02c 	andhi	r3,r4,65280
8112771c:	1800021e 	bne	r3,zero,81127728 <__hi0bits+0x20>
81127720:	2008923a 	slli	r4,r4,8
81127724:	10800204 	addi	r2,r2,8
81127728:	20fc002c 	andhi	r3,r4,61440
8112772c:	1800021e 	bne	r3,zero,81127738 <__hi0bits+0x30>
81127730:	2008913a 	slli	r4,r4,4
81127734:	10800104 	addi	r2,r2,4
81127738:	20f0002c 	andhi	r3,r4,49152
8112773c:	1800031e 	bne	r3,zero,8112774c <__hi0bits+0x44>
81127740:	2109883a 	add	r4,r4,r4
81127744:	10800084 	addi	r2,r2,2
81127748:	2109883a 	add	r4,r4,r4
8112774c:	20000316 	blt	r4,zero,8112775c <__hi0bits+0x54>
81127750:	2110002c 	andhi	r4,r4,16384
81127754:	2000041e 	bne	r4,zero,81127768 <__hi0bits+0x60>
81127758:	00800804 	movi	r2,32
8112775c:	f800283a 	ret
81127760:	0005883a 	mov	r2,zero
81127764:	003fec06 	br	81127718 <__reset+0xfb107718>
81127768:	10800044 	addi	r2,r2,1
8112776c:	f800283a 	ret

81127770 <__lo0bits>:
81127770:	20c00017 	ldw	r3,0(r4)
81127774:	188001cc 	andi	r2,r3,7
81127778:	10000826 	beq	r2,zero,8112779c <__lo0bits+0x2c>
8112777c:	1880004c 	andi	r2,r3,1
81127780:	1000211e 	bne	r2,zero,81127808 <__lo0bits+0x98>
81127784:	1880008c 	andi	r2,r3,2
81127788:	1000211e 	bne	r2,zero,81127810 <__lo0bits+0xa0>
8112778c:	1806d0ba 	srli	r3,r3,2
81127790:	00800084 	movi	r2,2
81127794:	20c00015 	stw	r3,0(r4)
81127798:	f800283a 	ret
8112779c:	18bfffcc 	andi	r2,r3,65535
811277a0:	10001326 	beq	r2,zero,811277f0 <__lo0bits+0x80>
811277a4:	0005883a 	mov	r2,zero
811277a8:	19403fcc 	andi	r5,r3,255
811277ac:	2800021e 	bne	r5,zero,811277b8 <__lo0bits+0x48>
811277b0:	1806d23a 	srli	r3,r3,8
811277b4:	10800204 	addi	r2,r2,8
811277b8:	194003cc 	andi	r5,r3,15
811277bc:	2800021e 	bne	r5,zero,811277c8 <__lo0bits+0x58>
811277c0:	1806d13a 	srli	r3,r3,4
811277c4:	10800104 	addi	r2,r2,4
811277c8:	194000cc 	andi	r5,r3,3
811277cc:	2800021e 	bne	r5,zero,811277d8 <__lo0bits+0x68>
811277d0:	1806d0ba 	srli	r3,r3,2
811277d4:	10800084 	addi	r2,r2,2
811277d8:	1940004c 	andi	r5,r3,1
811277dc:	2800081e 	bne	r5,zero,81127800 <__lo0bits+0x90>
811277e0:	1806d07a 	srli	r3,r3,1
811277e4:	1800051e 	bne	r3,zero,811277fc <__lo0bits+0x8c>
811277e8:	00800804 	movi	r2,32
811277ec:	f800283a 	ret
811277f0:	1806d43a 	srli	r3,r3,16
811277f4:	00800404 	movi	r2,16
811277f8:	003feb06 	br	811277a8 <__reset+0xfb1077a8>
811277fc:	10800044 	addi	r2,r2,1
81127800:	20c00015 	stw	r3,0(r4)
81127804:	f800283a 	ret
81127808:	0005883a 	mov	r2,zero
8112780c:	f800283a 	ret
81127810:	1806d07a 	srli	r3,r3,1
81127814:	00800044 	movi	r2,1
81127818:	20c00015 	stw	r3,0(r4)
8112781c:	f800283a 	ret

81127820 <__i2b>:
81127820:	defffd04 	addi	sp,sp,-12
81127824:	de00012e 	bgeu	sp,et,8112782c <__i2b+0xc>
81127828:	003b68fa 	trap	3
8112782c:	dc000015 	stw	r16,0(sp)
81127830:	04000044 	movi	r16,1
81127834:	dc400115 	stw	r17,4(sp)
81127838:	2823883a 	mov	r17,r5
8112783c:	800b883a 	mov	r5,r16
81127840:	dfc00215 	stw	ra,8(sp)
81127844:	11273fc0 	call	811273fc <_Balloc>
81127848:	14400515 	stw	r17,20(r2)
8112784c:	14000415 	stw	r16,16(r2)
81127850:	dfc00217 	ldw	ra,8(sp)
81127854:	dc400117 	ldw	r17,4(sp)
81127858:	dc000017 	ldw	r16,0(sp)
8112785c:	dec00304 	addi	sp,sp,12
81127860:	f800283a 	ret

81127864 <__multiply>:
81127864:	defffa04 	addi	sp,sp,-24
81127868:	de00012e 	bgeu	sp,et,81127870 <__multiply+0xc>
8112786c:	003b68fa 	trap	3
81127870:	dcc00315 	stw	r19,12(sp)
81127874:	dc800215 	stw	r18,8(sp)
81127878:	34c00417 	ldw	r19,16(r6)
8112787c:	2c800417 	ldw	r18,16(r5)
81127880:	dd000415 	stw	r20,16(sp)
81127884:	dc400115 	stw	r17,4(sp)
81127888:	dfc00515 	stw	ra,20(sp)
8112788c:	dc000015 	stw	r16,0(sp)
81127890:	2829883a 	mov	r20,r5
81127894:	3023883a 	mov	r17,r6
81127898:	94c0050e 	bge	r18,r19,811278b0 <__multiply+0x4c>
8112789c:	9007883a 	mov	r3,r18
811278a0:	3029883a 	mov	r20,r6
811278a4:	9825883a 	mov	r18,r19
811278a8:	2823883a 	mov	r17,r5
811278ac:	1827883a 	mov	r19,r3
811278b0:	a0800217 	ldw	r2,8(r20)
811278b4:	94e1883a 	add	r16,r18,r19
811278b8:	a1400117 	ldw	r5,4(r20)
811278bc:	1400010e 	bge	r2,r16,811278c4 <__multiply+0x60>
811278c0:	29400044 	addi	r5,r5,1
811278c4:	11273fc0 	call	811273fc <_Balloc>
811278c8:	8415883a 	add	r10,r16,r16
811278cc:	12c00504 	addi	r11,r2,20
811278d0:	5295883a 	add	r10,r10,r10
811278d4:	5a95883a 	add	r10,r11,r10
811278d8:	5807883a 	mov	r3,r11
811278dc:	5a80032e 	bgeu	r11,r10,811278ec <__multiply+0x88>
811278e0:	18000015 	stw	zero,0(r3)
811278e4:	18c00104 	addi	r3,r3,4
811278e8:	1abffd36 	bltu	r3,r10,811278e0 <__reset+0xfb1078e0>
811278ec:	9ce7883a 	add	r19,r19,r19
811278f0:	94a5883a 	add	r18,r18,r18
811278f4:	89800504 	addi	r6,r17,20
811278f8:	9ce7883a 	add	r19,r19,r19
811278fc:	a3400504 	addi	r13,r20,20
81127900:	94a5883a 	add	r18,r18,r18
81127904:	34d9883a 	add	r12,r6,r19
81127908:	6c93883a 	add	r9,r13,r18
8112790c:	3300422e 	bgeu	r6,r12,81127a18 <__multiply+0x1b4>
81127910:	37c00017 	ldw	ra,0(r6)
81127914:	fbffffcc 	andi	r15,ra,65535
81127918:	78001b26 	beq	r15,zero,81127988 <__multiply+0x124>
8112791c:	5811883a 	mov	r8,r11
81127920:	681d883a 	mov	r14,r13
81127924:	000f883a 	mov	r7,zero
81127928:	71000017 	ldw	r4,0(r14)
8112792c:	40c00017 	ldw	r3,0(r8)
81127930:	73800104 	addi	r14,r14,4
81127934:	217fffcc 	andi	r5,r4,65535
81127938:	2bcb383a 	mul	r5,r5,r15
8112793c:	2008d43a 	srli	r4,r4,16
81127940:	1c7fffcc 	andi	r17,r3,65535
81127944:	2c4b883a 	add	r5,r5,r17
81127948:	29cb883a 	add	r5,r5,r7
8112794c:	23c9383a 	mul	r4,r4,r15
81127950:	1806d43a 	srli	r3,r3,16
81127954:	280ed43a 	srli	r7,r5,16
81127958:	297fffcc 	andi	r5,r5,65535
8112795c:	20c7883a 	add	r3,r4,r3
81127960:	19c7883a 	add	r3,r3,r7
81127964:	1808943a 	slli	r4,r3,16
81127968:	4023883a 	mov	r17,r8
8112796c:	180ed43a 	srli	r7,r3,16
81127970:	214ab03a 	or	r5,r4,r5
81127974:	41400015 	stw	r5,0(r8)
81127978:	42000104 	addi	r8,r8,4
8112797c:	727fea36 	bltu	r14,r9,81127928 <__reset+0xfb107928>
81127980:	89c00115 	stw	r7,4(r17)
81127984:	37c00017 	ldw	ra,0(r6)
81127988:	f83ed43a 	srli	ra,ra,16
8112798c:	f8001f26 	beq	ra,zero,81127a0c <__multiply+0x1a8>
81127990:	58c00017 	ldw	r3,0(r11)
81127994:	681d883a 	mov	r14,r13
81127998:	581f883a 	mov	r15,r11
8112799c:	1811883a 	mov	r8,r3
811279a0:	5825883a 	mov	r18,r11
811279a4:	000f883a 	mov	r7,zero
811279a8:	00000106 	br	811279b0 <__multiply+0x14c>
811279ac:	8825883a 	mov	r18,r17
811279b0:	7140000b 	ldhu	r5,0(r14)
811279b4:	4010d43a 	srli	r8,r8,16
811279b8:	193fffcc 	andi	r4,r3,65535
811279bc:	2fcb383a 	mul	r5,r5,ra
811279c0:	7bc00104 	addi	r15,r15,4
811279c4:	73800104 	addi	r14,r14,4
811279c8:	2a0b883a 	add	r5,r5,r8
811279cc:	29cb883a 	add	r5,r5,r7
811279d0:	2806943a 	slli	r3,r5,16
811279d4:	94400104 	addi	r17,r18,4
811279d8:	280ad43a 	srli	r5,r5,16
811279dc:	1908b03a 	or	r4,r3,r4
811279e0:	793fff15 	stw	r4,-4(r15)
811279e4:	70ffff17 	ldw	r3,-4(r14)
811279e8:	8a000017 	ldw	r8,0(r17)
811279ec:	1806d43a 	srli	r3,r3,16
811279f0:	413fffcc 	andi	r4,r8,65535
811279f4:	1fc7383a 	mul	r3,r3,ra
811279f8:	1907883a 	add	r3,r3,r4
811279fc:	1947883a 	add	r3,r3,r5
81127a00:	180ed43a 	srli	r7,r3,16
81127a04:	727fe936 	bltu	r14,r9,811279ac <__reset+0xfb1079ac>
81127a08:	90c00115 	stw	r3,4(r18)
81127a0c:	31800104 	addi	r6,r6,4
81127a10:	5ac00104 	addi	r11,r11,4
81127a14:	333fbe36 	bltu	r6,r12,81127910 <__reset+0xfb107910>
81127a18:	0400090e 	bge	zero,r16,81127a40 <__multiply+0x1dc>
81127a1c:	50ffff17 	ldw	r3,-4(r10)
81127a20:	52bfff04 	addi	r10,r10,-4
81127a24:	18000326 	beq	r3,zero,81127a34 <__multiply+0x1d0>
81127a28:	00000506 	br	81127a40 <__multiply+0x1dc>
81127a2c:	50c00017 	ldw	r3,0(r10)
81127a30:	1800031e 	bne	r3,zero,81127a40 <__multiply+0x1dc>
81127a34:	843fffc4 	addi	r16,r16,-1
81127a38:	52bfff04 	addi	r10,r10,-4
81127a3c:	803ffb1e 	bne	r16,zero,81127a2c <__reset+0xfb107a2c>
81127a40:	14000415 	stw	r16,16(r2)
81127a44:	dfc00517 	ldw	ra,20(sp)
81127a48:	dd000417 	ldw	r20,16(sp)
81127a4c:	dcc00317 	ldw	r19,12(sp)
81127a50:	dc800217 	ldw	r18,8(sp)
81127a54:	dc400117 	ldw	r17,4(sp)
81127a58:	dc000017 	ldw	r16,0(sp)
81127a5c:	dec00604 	addi	sp,sp,24
81127a60:	f800283a 	ret

81127a64 <__pow5mult>:
81127a64:	defffa04 	addi	sp,sp,-24
81127a68:	de00012e 	bgeu	sp,et,81127a70 <__pow5mult+0xc>
81127a6c:	003b68fa 	trap	3
81127a70:	308000cc 	andi	r2,r6,3
81127a74:	dcc00315 	stw	r19,12(sp)
81127a78:	dc000015 	stw	r16,0(sp)
81127a7c:	dfc00515 	stw	ra,20(sp)
81127a80:	dd000415 	stw	r20,16(sp)
81127a84:	dc800215 	stw	r18,8(sp)
81127a88:	dc400115 	stw	r17,4(sp)
81127a8c:	3021883a 	mov	r16,r6
81127a90:	2027883a 	mov	r19,r4
81127a94:	10002f1e 	bne	r2,zero,81127b54 <__pow5mult+0xf0>
81127a98:	2825883a 	mov	r18,r5
81127a9c:	8021d0ba 	srai	r16,r16,2
81127aa0:	80001a26 	beq	r16,zero,81127b0c <__pow5mult+0xa8>
81127aa4:	9c401217 	ldw	r17,72(r19)
81127aa8:	8800061e 	bne	r17,zero,81127ac4 <__pow5mult+0x60>
81127aac:	00003406 	br	81127b80 <__pow5mult+0x11c>
81127ab0:	8021d07a 	srai	r16,r16,1
81127ab4:	80001526 	beq	r16,zero,81127b0c <__pow5mult+0xa8>
81127ab8:	88800017 	ldw	r2,0(r17)
81127abc:	10001c26 	beq	r2,zero,81127b30 <__pow5mult+0xcc>
81127ac0:	1023883a 	mov	r17,r2
81127ac4:	8080004c 	andi	r2,r16,1
81127ac8:	103ff926 	beq	r2,zero,81127ab0 <__reset+0xfb107ab0>
81127acc:	880d883a 	mov	r6,r17
81127ad0:	900b883a 	mov	r5,r18
81127ad4:	9809883a 	mov	r4,r19
81127ad8:	11278640 	call	81127864 <__multiply>
81127adc:	90001b26 	beq	r18,zero,81127b4c <__pow5mult+0xe8>
81127ae0:	91000117 	ldw	r4,4(r18)
81127ae4:	98c01317 	ldw	r3,76(r19)
81127ae8:	8021d07a 	srai	r16,r16,1
81127aec:	2109883a 	add	r4,r4,r4
81127af0:	2109883a 	add	r4,r4,r4
81127af4:	1907883a 	add	r3,r3,r4
81127af8:	19000017 	ldw	r4,0(r3)
81127afc:	91000015 	stw	r4,0(r18)
81127b00:	1c800015 	stw	r18,0(r3)
81127b04:	1025883a 	mov	r18,r2
81127b08:	803feb1e 	bne	r16,zero,81127ab8 <__reset+0xfb107ab8>
81127b0c:	9005883a 	mov	r2,r18
81127b10:	dfc00517 	ldw	ra,20(sp)
81127b14:	dd000417 	ldw	r20,16(sp)
81127b18:	dcc00317 	ldw	r19,12(sp)
81127b1c:	dc800217 	ldw	r18,8(sp)
81127b20:	dc400117 	ldw	r17,4(sp)
81127b24:	dc000017 	ldw	r16,0(sp)
81127b28:	dec00604 	addi	sp,sp,24
81127b2c:	f800283a 	ret
81127b30:	880d883a 	mov	r6,r17
81127b34:	880b883a 	mov	r5,r17
81127b38:	9809883a 	mov	r4,r19
81127b3c:	11278640 	call	81127864 <__multiply>
81127b40:	88800015 	stw	r2,0(r17)
81127b44:	10000015 	stw	zero,0(r2)
81127b48:	003fdd06 	br	81127ac0 <__reset+0xfb107ac0>
81127b4c:	1025883a 	mov	r18,r2
81127b50:	003fd706 	br	81127ab0 <__reset+0xfb107ab0>
81127b54:	10bfffc4 	addi	r2,r2,-1
81127b58:	1085883a 	add	r2,r2,r2
81127b5c:	00e04574 	movhi	r3,33045
81127b60:	18ee3004 	addi	r3,r3,-18240
81127b64:	1085883a 	add	r2,r2,r2
81127b68:	1885883a 	add	r2,r3,r2
81127b6c:	11800017 	ldw	r6,0(r2)
81127b70:	000f883a 	mov	r7,zero
81127b74:	11274d40 	call	811274d4 <__multadd>
81127b78:	1025883a 	mov	r18,r2
81127b7c:	003fc706 	br	81127a9c <__reset+0xfb107a9c>
81127b80:	05000044 	movi	r20,1
81127b84:	a00b883a 	mov	r5,r20
81127b88:	9809883a 	mov	r4,r19
81127b8c:	11273fc0 	call	811273fc <_Balloc>
81127b90:	1023883a 	mov	r17,r2
81127b94:	00809c44 	movi	r2,625
81127b98:	88800515 	stw	r2,20(r17)
81127b9c:	8d000415 	stw	r20,16(r17)
81127ba0:	9c401215 	stw	r17,72(r19)
81127ba4:	88000015 	stw	zero,0(r17)
81127ba8:	003fc606 	br	81127ac4 <__reset+0xfb107ac4>

81127bac <__lshift>:
81127bac:	defff904 	addi	sp,sp,-28
81127bb0:	de00012e 	bgeu	sp,et,81127bb8 <__lshift+0xc>
81127bb4:	003b68fa 	trap	3
81127bb8:	dd400515 	stw	r21,20(sp)
81127bbc:	dcc00315 	stw	r19,12(sp)
81127bc0:	302bd17a 	srai	r21,r6,5
81127bc4:	2cc00417 	ldw	r19,16(r5)
81127bc8:	28800217 	ldw	r2,8(r5)
81127bcc:	dd000415 	stw	r20,16(sp)
81127bd0:	ace7883a 	add	r19,r21,r19
81127bd4:	dc800215 	stw	r18,8(sp)
81127bd8:	dc400115 	stw	r17,4(sp)
81127bdc:	dc000015 	stw	r16,0(sp)
81127be0:	dfc00615 	stw	ra,24(sp)
81127be4:	9c000044 	addi	r16,r19,1
81127be8:	2823883a 	mov	r17,r5
81127bec:	3029883a 	mov	r20,r6
81127bf0:	2025883a 	mov	r18,r4
81127bf4:	29400117 	ldw	r5,4(r5)
81127bf8:	1400030e 	bge	r2,r16,81127c08 <__lshift+0x5c>
81127bfc:	1085883a 	add	r2,r2,r2
81127c00:	29400044 	addi	r5,r5,1
81127c04:	143ffd16 	blt	r2,r16,81127bfc <__reset+0xfb107bfc>
81127c08:	9009883a 	mov	r4,r18
81127c0c:	11273fc0 	call	811273fc <_Balloc>
81127c10:	10c00504 	addi	r3,r2,20
81127c14:	0540070e 	bge	zero,r21,81127c34 <__lshift+0x88>
81127c18:	ad6b883a 	add	r21,r21,r21
81127c1c:	ad6b883a 	add	r21,r21,r21
81127c20:	1809883a 	mov	r4,r3
81127c24:	1d47883a 	add	r3,r3,r21
81127c28:	20000015 	stw	zero,0(r4)
81127c2c:	21000104 	addi	r4,r4,4
81127c30:	193ffd1e 	bne	r3,r4,81127c28 <__reset+0xfb107c28>
81127c34:	8a000417 	ldw	r8,16(r17)
81127c38:	89000504 	addi	r4,r17,20
81127c3c:	a18007cc 	andi	r6,r20,31
81127c40:	4211883a 	add	r8,r8,r8
81127c44:	4211883a 	add	r8,r8,r8
81127c48:	2211883a 	add	r8,r4,r8
81127c4c:	30002326 	beq	r6,zero,81127cdc <__lshift+0x130>
81127c50:	02400804 	movi	r9,32
81127c54:	4993c83a 	sub	r9,r9,r6
81127c58:	000b883a 	mov	r5,zero
81127c5c:	21c00017 	ldw	r7,0(r4)
81127c60:	1815883a 	mov	r10,r3
81127c64:	18c00104 	addi	r3,r3,4
81127c68:	398e983a 	sll	r7,r7,r6
81127c6c:	21000104 	addi	r4,r4,4
81127c70:	394ab03a 	or	r5,r7,r5
81127c74:	197fff15 	stw	r5,-4(r3)
81127c78:	217fff17 	ldw	r5,-4(r4)
81127c7c:	2a4ad83a 	srl	r5,r5,r9
81127c80:	223ff636 	bltu	r4,r8,81127c5c <__reset+0xfb107c5c>
81127c84:	51400115 	stw	r5,4(r10)
81127c88:	28001a1e 	bne	r5,zero,81127cf4 <__lshift+0x148>
81127c8c:	843fffc4 	addi	r16,r16,-1
81127c90:	14000415 	stw	r16,16(r2)
81127c94:	88000826 	beq	r17,zero,81127cb8 <__lshift+0x10c>
81127c98:	89000117 	ldw	r4,4(r17)
81127c9c:	90c01317 	ldw	r3,76(r18)
81127ca0:	2109883a 	add	r4,r4,r4
81127ca4:	2109883a 	add	r4,r4,r4
81127ca8:	1907883a 	add	r3,r3,r4
81127cac:	19000017 	ldw	r4,0(r3)
81127cb0:	89000015 	stw	r4,0(r17)
81127cb4:	1c400015 	stw	r17,0(r3)
81127cb8:	dfc00617 	ldw	ra,24(sp)
81127cbc:	dd400517 	ldw	r21,20(sp)
81127cc0:	dd000417 	ldw	r20,16(sp)
81127cc4:	dcc00317 	ldw	r19,12(sp)
81127cc8:	dc800217 	ldw	r18,8(sp)
81127ccc:	dc400117 	ldw	r17,4(sp)
81127cd0:	dc000017 	ldw	r16,0(sp)
81127cd4:	dec00704 	addi	sp,sp,28
81127cd8:	f800283a 	ret
81127cdc:	21400017 	ldw	r5,0(r4)
81127ce0:	18c00104 	addi	r3,r3,4
81127ce4:	21000104 	addi	r4,r4,4
81127ce8:	197fff15 	stw	r5,-4(r3)
81127cec:	223ffb36 	bltu	r4,r8,81127cdc <__reset+0xfb107cdc>
81127cf0:	003fe606 	br	81127c8c <__reset+0xfb107c8c>
81127cf4:	9c000084 	addi	r16,r19,2
81127cf8:	003fe406 	br	81127c8c <__reset+0xfb107c8c>

81127cfc <__mcmp>:
81127cfc:	20800417 	ldw	r2,16(r4)
81127d00:	28c00417 	ldw	r3,16(r5)
81127d04:	10c5c83a 	sub	r2,r2,r3
81127d08:	1000111e 	bne	r2,zero,81127d50 <__mcmp+0x54>
81127d0c:	18c7883a 	add	r3,r3,r3
81127d10:	18c7883a 	add	r3,r3,r3
81127d14:	21000504 	addi	r4,r4,20
81127d18:	29400504 	addi	r5,r5,20
81127d1c:	20c5883a 	add	r2,r4,r3
81127d20:	28cb883a 	add	r5,r5,r3
81127d24:	00000106 	br	81127d2c <__mcmp+0x30>
81127d28:	20800a2e 	bgeu	r4,r2,81127d54 <__mcmp+0x58>
81127d2c:	10bfff04 	addi	r2,r2,-4
81127d30:	297fff04 	addi	r5,r5,-4
81127d34:	11800017 	ldw	r6,0(r2)
81127d38:	28c00017 	ldw	r3,0(r5)
81127d3c:	30fffa26 	beq	r6,r3,81127d28 <__reset+0xfb107d28>
81127d40:	30c00236 	bltu	r6,r3,81127d4c <__mcmp+0x50>
81127d44:	00800044 	movi	r2,1
81127d48:	f800283a 	ret
81127d4c:	00bfffc4 	movi	r2,-1
81127d50:	f800283a 	ret
81127d54:	0005883a 	mov	r2,zero
81127d58:	f800283a 	ret

81127d5c <__mdiff>:
81127d5c:	defffa04 	addi	sp,sp,-24
81127d60:	de00012e 	bgeu	sp,et,81127d68 <__mdiff+0xc>
81127d64:	003b68fa 	trap	3
81127d68:	28c00417 	ldw	r3,16(r5)
81127d6c:	30800417 	ldw	r2,16(r6)
81127d70:	dcc00315 	stw	r19,12(sp)
81127d74:	dc800215 	stw	r18,8(sp)
81127d78:	dfc00515 	stw	ra,20(sp)
81127d7c:	dd000415 	stw	r20,16(sp)
81127d80:	dc400115 	stw	r17,4(sp)
81127d84:	dc000015 	stw	r16,0(sp)
81127d88:	1887c83a 	sub	r3,r3,r2
81127d8c:	2825883a 	mov	r18,r5
81127d90:	3027883a 	mov	r19,r6
81127d94:	1800141e 	bne	r3,zero,81127de8 <__mdiff+0x8c>
81127d98:	1085883a 	add	r2,r2,r2
81127d9c:	1085883a 	add	r2,r2,r2
81127da0:	2a000504 	addi	r8,r5,20
81127da4:	34000504 	addi	r16,r6,20
81127da8:	4087883a 	add	r3,r8,r2
81127dac:	8085883a 	add	r2,r16,r2
81127db0:	00000106 	br	81127db8 <__mdiff+0x5c>
81127db4:	40c0592e 	bgeu	r8,r3,81127f1c <__mdiff+0x1c0>
81127db8:	18ffff04 	addi	r3,r3,-4
81127dbc:	10bfff04 	addi	r2,r2,-4
81127dc0:	19c00017 	ldw	r7,0(r3)
81127dc4:	11400017 	ldw	r5,0(r2)
81127dc8:	397ffa26 	beq	r7,r5,81127db4 <__reset+0xfb107db4>
81127dcc:	3940592e 	bgeu	r7,r5,81127f34 <__mdiff+0x1d8>
81127dd0:	9005883a 	mov	r2,r18
81127dd4:	4023883a 	mov	r17,r8
81127dd8:	9825883a 	mov	r18,r19
81127ddc:	05000044 	movi	r20,1
81127de0:	1027883a 	mov	r19,r2
81127de4:	00000406 	br	81127df8 <__mdiff+0x9c>
81127de8:	18005616 	blt	r3,zero,81127f44 <__mdiff+0x1e8>
81127dec:	34400504 	addi	r17,r6,20
81127df0:	2c000504 	addi	r16,r5,20
81127df4:	0029883a 	mov	r20,zero
81127df8:	91400117 	ldw	r5,4(r18)
81127dfc:	11273fc0 	call	811273fc <_Balloc>
81127e00:	92400417 	ldw	r9,16(r18)
81127e04:	9b000417 	ldw	r12,16(r19)
81127e08:	12c00504 	addi	r11,r2,20
81127e0c:	4a51883a 	add	r8,r9,r9
81127e10:	6319883a 	add	r12,r12,r12
81127e14:	4211883a 	add	r8,r8,r8
81127e18:	6319883a 	add	r12,r12,r12
81127e1c:	15000315 	stw	r20,12(r2)
81127e20:	8211883a 	add	r8,r16,r8
81127e24:	8b19883a 	add	r12,r17,r12
81127e28:	0007883a 	mov	r3,zero
81127e2c:	81400017 	ldw	r5,0(r16)
81127e30:	89c00017 	ldw	r7,0(r17)
81127e34:	59800104 	addi	r6,r11,4
81127e38:	293fffcc 	andi	r4,r5,65535
81127e3c:	20c7883a 	add	r3,r4,r3
81127e40:	393fffcc 	andi	r4,r7,65535
81127e44:	1909c83a 	sub	r4,r3,r4
81127e48:	280ad43a 	srli	r5,r5,16
81127e4c:	380ed43a 	srli	r7,r7,16
81127e50:	2007d43a 	srai	r3,r4,16
81127e54:	213fffcc 	andi	r4,r4,65535
81127e58:	29cbc83a 	sub	r5,r5,r7
81127e5c:	28c7883a 	add	r3,r5,r3
81127e60:	180a943a 	slli	r5,r3,16
81127e64:	8c400104 	addi	r17,r17,4
81127e68:	84000104 	addi	r16,r16,4
81127e6c:	2908b03a 	or	r4,r5,r4
81127e70:	59000015 	stw	r4,0(r11)
81127e74:	1807d43a 	srai	r3,r3,16
81127e78:	3015883a 	mov	r10,r6
81127e7c:	3017883a 	mov	r11,r6
81127e80:	8b3fea36 	bltu	r17,r12,81127e2c <__reset+0xfb107e2c>
81127e84:	8200162e 	bgeu	r16,r8,81127ee0 <__mdiff+0x184>
81127e88:	8017883a 	mov	r11,r16
81127e8c:	59400017 	ldw	r5,0(r11)
81127e90:	31800104 	addi	r6,r6,4
81127e94:	5ac00104 	addi	r11,r11,4
81127e98:	293fffcc 	andi	r4,r5,65535
81127e9c:	20c7883a 	add	r3,r4,r3
81127ea0:	280ed43a 	srli	r7,r5,16
81127ea4:	180bd43a 	srai	r5,r3,16
81127ea8:	193fffcc 	andi	r4,r3,65535
81127eac:	3947883a 	add	r3,r7,r5
81127eb0:	180a943a 	slli	r5,r3,16
81127eb4:	1807d43a 	srai	r3,r3,16
81127eb8:	2908b03a 	or	r4,r5,r4
81127ebc:	313fff15 	stw	r4,-4(r6)
81127ec0:	5a3ff236 	bltu	r11,r8,81127e8c <__reset+0xfb107e8c>
81127ec4:	0406303a 	nor	r3,zero,r16
81127ec8:	1a07883a 	add	r3,r3,r8
81127ecc:	1806d0ba 	srli	r3,r3,2
81127ed0:	18c00044 	addi	r3,r3,1
81127ed4:	18c7883a 	add	r3,r3,r3
81127ed8:	18c7883a 	add	r3,r3,r3
81127edc:	50d5883a 	add	r10,r10,r3
81127ee0:	50ffff04 	addi	r3,r10,-4
81127ee4:	2000041e 	bne	r4,zero,81127ef8 <__mdiff+0x19c>
81127ee8:	18ffff04 	addi	r3,r3,-4
81127eec:	19000017 	ldw	r4,0(r3)
81127ef0:	4a7fffc4 	addi	r9,r9,-1
81127ef4:	203ffc26 	beq	r4,zero,81127ee8 <__reset+0xfb107ee8>
81127ef8:	12400415 	stw	r9,16(r2)
81127efc:	dfc00517 	ldw	ra,20(sp)
81127f00:	dd000417 	ldw	r20,16(sp)
81127f04:	dcc00317 	ldw	r19,12(sp)
81127f08:	dc800217 	ldw	r18,8(sp)
81127f0c:	dc400117 	ldw	r17,4(sp)
81127f10:	dc000017 	ldw	r16,0(sp)
81127f14:	dec00604 	addi	sp,sp,24
81127f18:	f800283a 	ret
81127f1c:	000b883a 	mov	r5,zero
81127f20:	11273fc0 	call	811273fc <_Balloc>
81127f24:	00c00044 	movi	r3,1
81127f28:	10c00415 	stw	r3,16(r2)
81127f2c:	10000515 	stw	zero,20(r2)
81127f30:	003ff206 	br	81127efc <__reset+0xfb107efc>
81127f34:	8023883a 	mov	r17,r16
81127f38:	0029883a 	mov	r20,zero
81127f3c:	4021883a 	mov	r16,r8
81127f40:	003fad06 	br	81127df8 <__reset+0xfb107df8>
81127f44:	9005883a 	mov	r2,r18
81127f48:	94400504 	addi	r17,r18,20
81127f4c:	9c000504 	addi	r16,r19,20
81127f50:	9825883a 	mov	r18,r19
81127f54:	05000044 	movi	r20,1
81127f58:	1027883a 	mov	r19,r2
81127f5c:	003fa606 	br	81127df8 <__reset+0xfb107df8>

81127f60 <__ulp>:
81127f60:	295ffc2c 	andhi	r5,r5,32752
81127f64:	00bf3034 	movhi	r2,64704
81127f68:	2887883a 	add	r3,r5,r2
81127f6c:	00c0020e 	bge	zero,r3,81127f78 <__ulp+0x18>
81127f70:	0005883a 	mov	r2,zero
81127f74:	f800283a 	ret
81127f78:	00c7c83a 	sub	r3,zero,r3
81127f7c:	1807d53a 	srai	r3,r3,20
81127f80:	008004c4 	movi	r2,19
81127f84:	10c00b0e 	bge	r2,r3,81127fb4 <__ulp+0x54>
81127f88:	18bffb04 	addi	r2,r3,-20
81127f8c:	01000784 	movi	r4,30
81127f90:	0007883a 	mov	r3,zero
81127f94:	20800516 	blt	r4,r2,81127fac <__ulp+0x4c>
81127f98:	010007c4 	movi	r4,31
81127f9c:	2089c83a 	sub	r4,r4,r2
81127fa0:	00800044 	movi	r2,1
81127fa4:	1104983a 	sll	r2,r2,r4
81127fa8:	f800283a 	ret
81127fac:	00800044 	movi	r2,1
81127fb0:	f800283a 	ret
81127fb4:	01400234 	movhi	r5,8
81127fb8:	28c7d83a 	sra	r3,r5,r3
81127fbc:	0005883a 	mov	r2,zero
81127fc0:	f800283a 	ret

81127fc4 <__b2d>:
81127fc4:	defffa04 	addi	sp,sp,-24
81127fc8:	de00012e 	bgeu	sp,et,81127fd0 <__b2d+0xc>
81127fcc:	003b68fa 	trap	3
81127fd0:	dc000015 	stw	r16,0(sp)
81127fd4:	24000417 	ldw	r16,16(r4)
81127fd8:	dc400115 	stw	r17,4(sp)
81127fdc:	24400504 	addi	r17,r4,20
81127fe0:	8421883a 	add	r16,r16,r16
81127fe4:	8421883a 	add	r16,r16,r16
81127fe8:	8c21883a 	add	r16,r17,r16
81127fec:	dc800215 	stw	r18,8(sp)
81127ff0:	84bfff17 	ldw	r18,-4(r16)
81127ff4:	dd000415 	stw	r20,16(sp)
81127ff8:	dcc00315 	stw	r19,12(sp)
81127ffc:	9009883a 	mov	r4,r18
81128000:	2829883a 	mov	r20,r5
81128004:	dfc00515 	stw	ra,20(sp)
81128008:	11277080 	call	81127708 <__hi0bits>
8112800c:	00c00804 	movi	r3,32
81128010:	1889c83a 	sub	r4,r3,r2
81128014:	a1000015 	stw	r4,0(r20)
81128018:	01000284 	movi	r4,10
8112801c:	84ffff04 	addi	r19,r16,-4
81128020:	20801216 	blt	r4,r2,8112806c <__b2d+0xa8>
81128024:	018002c4 	movi	r6,11
81128028:	308dc83a 	sub	r6,r6,r2
8112802c:	9186d83a 	srl	r3,r18,r6
81128030:	18cffc34 	orhi	r3,r3,16368
81128034:	8cc0212e 	bgeu	r17,r19,811280bc <__b2d+0xf8>
81128038:	813ffe17 	ldw	r4,-8(r16)
8112803c:	218cd83a 	srl	r6,r4,r6
81128040:	10800544 	addi	r2,r2,21
81128044:	9084983a 	sll	r2,r18,r2
81128048:	1184b03a 	or	r2,r2,r6
8112804c:	dfc00517 	ldw	ra,20(sp)
81128050:	dd000417 	ldw	r20,16(sp)
81128054:	dcc00317 	ldw	r19,12(sp)
81128058:	dc800217 	ldw	r18,8(sp)
8112805c:	dc400117 	ldw	r17,4(sp)
81128060:	dc000017 	ldw	r16,0(sp)
81128064:	dec00604 	addi	sp,sp,24
81128068:	f800283a 	ret
8112806c:	8cc00f2e 	bgeu	r17,r19,811280ac <__b2d+0xe8>
81128070:	117ffd44 	addi	r5,r2,-11
81128074:	80bffe17 	ldw	r2,-8(r16)
81128078:	28000e26 	beq	r5,zero,811280b4 <__b2d+0xf0>
8112807c:	1949c83a 	sub	r4,r3,r5
81128080:	9164983a 	sll	r18,r18,r5
81128084:	1106d83a 	srl	r3,r2,r4
81128088:	81bffe04 	addi	r6,r16,-8
8112808c:	948ffc34 	orhi	r18,r18,16368
81128090:	90c6b03a 	or	r3,r18,r3
81128094:	89800e2e 	bgeu	r17,r6,811280d0 <__b2d+0x10c>
81128098:	81bffd17 	ldw	r6,-12(r16)
8112809c:	1144983a 	sll	r2,r2,r5
811280a0:	310ad83a 	srl	r5,r6,r4
811280a4:	2884b03a 	or	r2,r5,r2
811280a8:	003fe806 	br	8112804c <__reset+0xfb10804c>
811280ac:	10bffd44 	addi	r2,r2,-11
811280b0:	1000041e 	bne	r2,zero,811280c4 <__b2d+0x100>
811280b4:	90cffc34 	orhi	r3,r18,16368
811280b8:	003fe406 	br	8112804c <__reset+0xfb10804c>
811280bc:	000d883a 	mov	r6,zero
811280c0:	003fdf06 	br	81128040 <__reset+0xfb108040>
811280c4:	90a4983a 	sll	r18,r18,r2
811280c8:	0005883a 	mov	r2,zero
811280cc:	003ff906 	br	811280b4 <__reset+0xfb1080b4>
811280d0:	1144983a 	sll	r2,r2,r5
811280d4:	003fdd06 	br	8112804c <__reset+0xfb10804c>

811280d8 <__d2b>:
811280d8:	defff804 	addi	sp,sp,-32
811280dc:	de00012e 	bgeu	sp,et,811280e4 <__d2b+0xc>
811280e0:	003b68fa 	trap	3
811280e4:	dc000215 	stw	r16,8(sp)
811280e8:	3021883a 	mov	r16,r6
811280ec:	dc400315 	stw	r17,12(sp)
811280f0:	8022907a 	slli	r17,r16,1
811280f4:	dd000615 	stw	r20,24(sp)
811280f8:	2829883a 	mov	r20,r5
811280fc:	01400044 	movi	r5,1
81128100:	dcc00515 	stw	r19,20(sp)
81128104:	dc800415 	stw	r18,16(sp)
81128108:	dfc00715 	stw	ra,28(sp)
8112810c:	3825883a 	mov	r18,r7
81128110:	8822d57a 	srli	r17,r17,21
81128114:	11273fc0 	call	811273fc <_Balloc>
81128118:	1027883a 	mov	r19,r2
8112811c:	00800434 	movhi	r2,16
81128120:	10bfffc4 	addi	r2,r2,-1
81128124:	808c703a 	and	r6,r16,r2
81128128:	88000126 	beq	r17,zero,81128130 <__d2b+0x58>
8112812c:	31800434 	orhi	r6,r6,16
81128130:	d9800015 	stw	r6,0(sp)
81128134:	a0002426 	beq	r20,zero,811281c8 <__d2b+0xf0>
81128138:	d9000104 	addi	r4,sp,4
8112813c:	dd000115 	stw	r20,4(sp)
81128140:	11277700 	call	81127770 <__lo0bits>
81128144:	d8c00017 	ldw	r3,0(sp)
81128148:	10002f1e 	bne	r2,zero,81128208 <__d2b+0x130>
8112814c:	d9000117 	ldw	r4,4(sp)
81128150:	99000515 	stw	r4,20(r19)
81128154:	1821003a 	cmpeq	r16,r3,zero
81128158:	01000084 	movi	r4,2
8112815c:	2421c83a 	sub	r16,r4,r16
81128160:	98c00615 	stw	r3,24(r19)
81128164:	9c000415 	stw	r16,16(r19)
81128168:	88001f1e 	bne	r17,zero,811281e8 <__d2b+0x110>
8112816c:	10bef384 	addi	r2,r2,-1074
81128170:	90800015 	stw	r2,0(r18)
81128174:	00900034 	movhi	r2,16384
81128178:	10bfffc4 	addi	r2,r2,-1
8112817c:	8085883a 	add	r2,r16,r2
81128180:	1085883a 	add	r2,r2,r2
81128184:	1085883a 	add	r2,r2,r2
81128188:	9885883a 	add	r2,r19,r2
8112818c:	11000517 	ldw	r4,20(r2)
81128190:	8020917a 	slli	r16,r16,5
81128194:	11277080 	call	81127708 <__hi0bits>
81128198:	d8c00817 	ldw	r3,32(sp)
8112819c:	8085c83a 	sub	r2,r16,r2
811281a0:	18800015 	stw	r2,0(r3)
811281a4:	9805883a 	mov	r2,r19
811281a8:	dfc00717 	ldw	ra,28(sp)
811281ac:	dd000617 	ldw	r20,24(sp)
811281b0:	dcc00517 	ldw	r19,20(sp)
811281b4:	dc800417 	ldw	r18,16(sp)
811281b8:	dc400317 	ldw	r17,12(sp)
811281bc:	dc000217 	ldw	r16,8(sp)
811281c0:	dec00804 	addi	sp,sp,32
811281c4:	f800283a 	ret
811281c8:	d809883a 	mov	r4,sp
811281cc:	11277700 	call	81127770 <__lo0bits>
811281d0:	d8c00017 	ldw	r3,0(sp)
811281d4:	04000044 	movi	r16,1
811281d8:	9c000415 	stw	r16,16(r19)
811281dc:	98c00515 	stw	r3,20(r19)
811281e0:	10800804 	addi	r2,r2,32
811281e4:	883fe126 	beq	r17,zero,8112816c <__reset+0xfb10816c>
811281e8:	00c00d44 	movi	r3,53
811281ec:	8c7ef344 	addi	r17,r17,-1075
811281f0:	88a3883a 	add	r17,r17,r2
811281f4:	1885c83a 	sub	r2,r3,r2
811281f8:	d8c00817 	ldw	r3,32(sp)
811281fc:	94400015 	stw	r17,0(r18)
81128200:	18800015 	stw	r2,0(r3)
81128204:	003fe706 	br	811281a4 <__reset+0xfb1081a4>
81128208:	01000804 	movi	r4,32
8112820c:	2089c83a 	sub	r4,r4,r2
81128210:	1908983a 	sll	r4,r3,r4
81128214:	d9400117 	ldw	r5,4(sp)
81128218:	1886d83a 	srl	r3,r3,r2
8112821c:	2148b03a 	or	r4,r4,r5
81128220:	99000515 	stw	r4,20(r19)
81128224:	d8c00015 	stw	r3,0(sp)
81128228:	003fca06 	br	81128154 <__reset+0xfb108154>

8112822c <__ratio>:
8112822c:	defff904 	addi	sp,sp,-28
81128230:	de00012e 	bgeu	sp,et,81128238 <__ratio+0xc>
81128234:	003b68fa 	trap	3
81128238:	dc400315 	stw	r17,12(sp)
8112823c:	2823883a 	mov	r17,r5
81128240:	d9400104 	addi	r5,sp,4
81128244:	dfc00615 	stw	ra,24(sp)
81128248:	dcc00515 	stw	r19,20(sp)
8112824c:	dc800415 	stw	r18,16(sp)
81128250:	2027883a 	mov	r19,r4
81128254:	dc000215 	stw	r16,8(sp)
81128258:	1127fc40 	call	81127fc4 <__b2d>
8112825c:	d80b883a 	mov	r5,sp
81128260:	8809883a 	mov	r4,r17
81128264:	1025883a 	mov	r18,r2
81128268:	1821883a 	mov	r16,r3
8112826c:	1127fc40 	call	81127fc4 <__b2d>
81128270:	8a000417 	ldw	r8,16(r17)
81128274:	99000417 	ldw	r4,16(r19)
81128278:	d9400117 	ldw	r5,4(sp)
8112827c:	2209c83a 	sub	r4,r4,r8
81128280:	2010917a 	slli	r8,r4,5
81128284:	d9000017 	ldw	r4,0(sp)
81128288:	2909c83a 	sub	r4,r5,r4
8112828c:	4109883a 	add	r4,r8,r4
81128290:	01000e0e 	bge	zero,r4,811282cc <__ratio+0xa0>
81128294:	2008953a 	slli	r4,r4,20
81128298:	2421883a 	add	r16,r4,r16
8112829c:	100d883a 	mov	r6,r2
811282a0:	180f883a 	mov	r7,r3
811282a4:	9009883a 	mov	r4,r18
811282a8:	800b883a 	mov	r5,r16
811282ac:	11303200 	call	81130320 <__divdf3>
811282b0:	dfc00617 	ldw	ra,24(sp)
811282b4:	dcc00517 	ldw	r19,20(sp)
811282b8:	dc800417 	ldw	r18,16(sp)
811282bc:	dc400317 	ldw	r17,12(sp)
811282c0:	dc000217 	ldw	r16,8(sp)
811282c4:	dec00704 	addi	sp,sp,28
811282c8:	f800283a 	ret
811282cc:	2008953a 	slli	r4,r4,20
811282d0:	1907c83a 	sub	r3,r3,r4
811282d4:	003ff106 	br	8112829c <__reset+0xfb10829c>

811282d8 <_mprec_log10>:
811282d8:	defffe04 	addi	sp,sp,-8
811282dc:	de00012e 	bgeu	sp,et,811282e4 <_mprec_log10+0xc>
811282e0:	003b68fa 	trap	3
811282e4:	008005c4 	movi	r2,23
811282e8:	dc000015 	stw	r16,0(sp)
811282ec:	dfc00115 	stw	ra,4(sp)
811282f0:	2021883a 	mov	r16,r4
811282f4:	11000d0e 	bge	r2,r4,8112832c <_mprec_log10+0x54>
811282f8:	0005883a 	mov	r2,zero
811282fc:	00cffc34 	movhi	r3,16368
81128300:	843fffc4 	addi	r16,r16,-1
81128304:	000d883a 	mov	r6,zero
81128308:	01d00934 	movhi	r7,16420
8112830c:	1009883a 	mov	r4,r2
81128310:	180b883a 	mov	r5,r3
81128314:	111b57c0 	call	8111b57c <__muldf3>
81128318:	803ff91e 	bne	r16,zero,81128300 <__reset+0xfb108300>
8112831c:	dfc00117 	ldw	ra,4(sp)
81128320:	dc000017 	ldw	r16,0(sp)
81128324:	dec00204 	addi	sp,sp,8
81128328:	f800283a 	ret
8112832c:	202090fa 	slli	r16,r4,3
81128330:	00a04574 	movhi	r2,33045
81128334:	10ae4704 	addi	r2,r2,-18148
81128338:	1421883a 	add	r16,r2,r16
8112833c:	80800017 	ldw	r2,0(r16)
81128340:	80c00117 	ldw	r3,4(r16)
81128344:	dfc00117 	ldw	ra,4(sp)
81128348:	dc000017 	ldw	r16,0(sp)
8112834c:	dec00204 	addi	sp,sp,8
81128350:	f800283a 	ret

81128354 <__copybits>:
81128354:	297fffc4 	addi	r5,r5,-1
81128358:	280fd17a 	srai	r7,r5,5
8112835c:	30c00417 	ldw	r3,16(r6)
81128360:	30800504 	addi	r2,r6,20
81128364:	39c00044 	addi	r7,r7,1
81128368:	18c7883a 	add	r3,r3,r3
8112836c:	39cf883a 	add	r7,r7,r7
81128370:	18c7883a 	add	r3,r3,r3
81128374:	39cf883a 	add	r7,r7,r7
81128378:	10c7883a 	add	r3,r2,r3
8112837c:	21cf883a 	add	r7,r4,r7
81128380:	10c00d2e 	bgeu	r2,r3,811283b8 <__copybits+0x64>
81128384:	200b883a 	mov	r5,r4
81128388:	12000017 	ldw	r8,0(r2)
8112838c:	29400104 	addi	r5,r5,4
81128390:	10800104 	addi	r2,r2,4
81128394:	2a3fff15 	stw	r8,-4(r5)
81128398:	10fffb36 	bltu	r2,r3,81128388 <__reset+0xfb108388>
8112839c:	1985c83a 	sub	r2,r3,r6
811283a0:	10bffac4 	addi	r2,r2,-21
811283a4:	1004d0ba 	srli	r2,r2,2
811283a8:	10800044 	addi	r2,r2,1
811283ac:	1085883a 	add	r2,r2,r2
811283b0:	1085883a 	add	r2,r2,r2
811283b4:	2089883a 	add	r4,r4,r2
811283b8:	21c0032e 	bgeu	r4,r7,811283c8 <__copybits+0x74>
811283bc:	20000015 	stw	zero,0(r4)
811283c0:	21000104 	addi	r4,r4,4
811283c4:	21fffd36 	bltu	r4,r7,811283bc <__reset+0xfb1083bc>
811283c8:	f800283a 	ret

811283cc <__any_on>:
811283cc:	20c00417 	ldw	r3,16(r4)
811283d0:	2805d17a 	srai	r2,r5,5
811283d4:	21000504 	addi	r4,r4,20
811283d8:	18800d0e 	bge	r3,r2,81128410 <__any_on+0x44>
811283dc:	18c7883a 	add	r3,r3,r3
811283e0:	18c7883a 	add	r3,r3,r3
811283e4:	20c7883a 	add	r3,r4,r3
811283e8:	20c0192e 	bgeu	r4,r3,81128450 <__any_on+0x84>
811283ec:	18bfff17 	ldw	r2,-4(r3)
811283f0:	18ffff04 	addi	r3,r3,-4
811283f4:	1000041e 	bne	r2,zero,81128408 <__any_on+0x3c>
811283f8:	20c0142e 	bgeu	r4,r3,8112844c <__any_on+0x80>
811283fc:	18ffff04 	addi	r3,r3,-4
81128400:	19400017 	ldw	r5,0(r3)
81128404:	283ffc26 	beq	r5,zero,811283f8 <__reset+0xfb1083f8>
81128408:	00800044 	movi	r2,1
8112840c:	f800283a 	ret
81128410:	10c00a0e 	bge	r2,r3,8112843c <__any_on+0x70>
81128414:	1085883a 	add	r2,r2,r2
81128418:	1085883a 	add	r2,r2,r2
8112841c:	294007cc 	andi	r5,r5,31
81128420:	2087883a 	add	r3,r4,r2
81128424:	283ff026 	beq	r5,zero,811283e8 <__reset+0xfb1083e8>
81128428:	19800017 	ldw	r6,0(r3)
8112842c:	3144d83a 	srl	r2,r6,r5
81128430:	114a983a 	sll	r5,r2,r5
81128434:	317ff41e 	bne	r6,r5,81128408 <__reset+0xfb108408>
81128438:	003feb06 	br	811283e8 <__reset+0xfb1083e8>
8112843c:	1085883a 	add	r2,r2,r2
81128440:	1085883a 	add	r2,r2,r2
81128444:	2087883a 	add	r3,r4,r2
81128448:	003fe706 	br	811283e8 <__reset+0xfb1083e8>
8112844c:	f800283a 	ret
81128450:	0005883a 	mov	r2,zero
81128454:	f800283a 	ret

81128458 <_read_r>:
81128458:	defffd04 	addi	sp,sp,-12
8112845c:	de00012e 	bgeu	sp,et,81128464 <_read_r+0xc>
81128460:	003b68fa 	trap	3
81128464:	2805883a 	mov	r2,r5
81128468:	dc000015 	stw	r16,0(sp)
8112846c:	04204574 	movhi	r16,33045
81128470:	dc400115 	stw	r17,4(sp)
81128474:	300b883a 	mov	r5,r6
81128478:	84384404 	addi	r16,r16,-7920
8112847c:	2023883a 	mov	r17,r4
81128480:	380d883a 	mov	r6,r7
81128484:	1009883a 	mov	r4,r2
81128488:	dfc00215 	stw	ra,8(sp)
8112848c:	80000015 	stw	zero,0(r16)
81128490:	1132fd40 	call	81132fd4 <read>
81128494:	00ffffc4 	movi	r3,-1
81128498:	10c00526 	beq	r2,r3,811284b0 <_read_r+0x58>
8112849c:	dfc00217 	ldw	ra,8(sp)
811284a0:	dc400117 	ldw	r17,4(sp)
811284a4:	dc000017 	ldw	r16,0(sp)
811284a8:	dec00304 	addi	sp,sp,12
811284ac:	f800283a 	ret
811284b0:	80c00017 	ldw	r3,0(r16)
811284b4:	183ff926 	beq	r3,zero,8112849c <__reset+0xfb10849c>
811284b8:	88c00015 	stw	r3,0(r17)
811284bc:	003ff706 	br	8112849c <__reset+0xfb10849c>

811284c0 <_realloc_r>:
811284c0:	defff604 	addi	sp,sp,-40
811284c4:	de00012e 	bgeu	sp,et,811284cc <_realloc_r+0xc>
811284c8:	003b68fa 	trap	3
811284cc:	dc800215 	stw	r18,8(sp)
811284d0:	dfc00915 	stw	ra,36(sp)
811284d4:	df000815 	stw	fp,32(sp)
811284d8:	ddc00715 	stw	r23,28(sp)
811284dc:	dd800615 	stw	r22,24(sp)
811284e0:	dd400515 	stw	r21,20(sp)
811284e4:	dd000415 	stw	r20,16(sp)
811284e8:	dcc00315 	stw	r19,12(sp)
811284ec:	dc400115 	stw	r17,4(sp)
811284f0:	dc000015 	stw	r16,0(sp)
811284f4:	3025883a 	mov	r18,r6
811284f8:	2800b726 	beq	r5,zero,811287d8 <_realloc_r+0x318>
811284fc:	282b883a 	mov	r21,r5
81128500:	2029883a 	mov	r20,r4
81128504:	11337b40 	call	811337b4 <__malloc_lock>
81128508:	a8bfff17 	ldw	r2,-4(r21)
8112850c:	043fff04 	movi	r16,-4
81128510:	90c002c4 	addi	r3,r18,11
81128514:	01000584 	movi	r4,22
81128518:	acfffe04 	addi	r19,r21,-8
8112851c:	1420703a 	and	r16,r2,r16
81128520:	20c0332e 	bgeu	r4,r3,811285f0 <_realloc_r+0x130>
81128524:	047ffe04 	movi	r17,-8
81128528:	1c62703a 	and	r17,r3,r17
8112852c:	8807883a 	mov	r3,r17
81128530:	88005816 	blt	r17,zero,81128694 <_realloc_r+0x1d4>
81128534:	8c805736 	bltu	r17,r18,81128694 <_realloc_r+0x1d4>
81128538:	80c0300e 	bge	r16,r3,811285fc <_realloc_r+0x13c>
8112853c:	07204574 	movhi	fp,33045
81128540:	e7319404 	addi	fp,fp,-14768
81128544:	e1c00217 	ldw	r7,8(fp)
81128548:	9c09883a 	add	r4,r19,r16
8112854c:	22000117 	ldw	r8,4(r4)
81128550:	21c06326 	beq	r4,r7,811286e0 <_realloc_r+0x220>
81128554:	017fff84 	movi	r5,-2
81128558:	414a703a 	and	r5,r8,r5
8112855c:	214b883a 	add	r5,r4,r5
81128560:	29800117 	ldw	r6,4(r5)
81128564:	3180004c 	andi	r6,r6,1
81128568:	30003f26 	beq	r6,zero,81128668 <_realloc_r+0x1a8>
8112856c:	1080004c 	andi	r2,r2,1
81128570:	10008326 	beq	r2,zero,81128780 <_realloc_r+0x2c0>
81128574:	900b883a 	mov	r5,r18
81128578:	a009883a 	mov	r4,r20
8112857c:	111c9b80 	call	8111c9b8 <_malloc_r>
81128580:	1025883a 	mov	r18,r2
81128584:	10011e26 	beq	r2,zero,81128a00 <_realloc_r+0x540>
81128588:	a93fff17 	ldw	r4,-4(r21)
8112858c:	10fffe04 	addi	r3,r2,-8
81128590:	00bfff84 	movi	r2,-2
81128594:	2084703a 	and	r2,r4,r2
81128598:	9885883a 	add	r2,r19,r2
8112859c:	1880ee26 	beq	r3,r2,81128958 <_realloc_r+0x498>
811285a0:	81bfff04 	addi	r6,r16,-4
811285a4:	00800904 	movi	r2,36
811285a8:	1180b836 	bltu	r2,r6,8112888c <_realloc_r+0x3cc>
811285ac:	00c004c4 	movi	r3,19
811285b0:	19809636 	bltu	r3,r6,8112880c <_realloc_r+0x34c>
811285b4:	9005883a 	mov	r2,r18
811285b8:	a807883a 	mov	r3,r21
811285bc:	19000017 	ldw	r4,0(r3)
811285c0:	11000015 	stw	r4,0(r2)
811285c4:	19000117 	ldw	r4,4(r3)
811285c8:	11000115 	stw	r4,4(r2)
811285cc:	18c00217 	ldw	r3,8(r3)
811285d0:	10c00215 	stw	r3,8(r2)
811285d4:	a80b883a 	mov	r5,r21
811285d8:	a009883a 	mov	r4,r20
811285dc:	112642c0 	call	8112642c <_free_r>
811285e0:	a009883a 	mov	r4,r20
811285e4:	11338dc0 	call	811338dc <__malloc_unlock>
811285e8:	9005883a 	mov	r2,r18
811285ec:	00001206 	br	81128638 <_realloc_r+0x178>
811285f0:	00c00404 	movi	r3,16
811285f4:	1823883a 	mov	r17,r3
811285f8:	003fce06 	br	81128534 <__reset+0xfb108534>
811285fc:	a825883a 	mov	r18,r21
81128600:	8445c83a 	sub	r2,r16,r17
81128604:	00c003c4 	movi	r3,15
81128608:	18802636 	bltu	r3,r2,811286a4 <_realloc_r+0x1e4>
8112860c:	99800117 	ldw	r6,4(r19)
81128610:	9c07883a 	add	r3,r19,r16
81128614:	3180004c 	andi	r6,r6,1
81128618:	3420b03a 	or	r16,r6,r16
8112861c:	9c000115 	stw	r16,4(r19)
81128620:	18800117 	ldw	r2,4(r3)
81128624:	10800054 	ori	r2,r2,1
81128628:	18800115 	stw	r2,4(r3)
8112862c:	a009883a 	mov	r4,r20
81128630:	11338dc0 	call	811338dc <__malloc_unlock>
81128634:	9005883a 	mov	r2,r18
81128638:	dfc00917 	ldw	ra,36(sp)
8112863c:	df000817 	ldw	fp,32(sp)
81128640:	ddc00717 	ldw	r23,28(sp)
81128644:	dd800617 	ldw	r22,24(sp)
81128648:	dd400517 	ldw	r21,20(sp)
8112864c:	dd000417 	ldw	r20,16(sp)
81128650:	dcc00317 	ldw	r19,12(sp)
81128654:	dc800217 	ldw	r18,8(sp)
81128658:	dc400117 	ldw	r17,4(sp)
8112865c:	dc000017 	ldw	r16,0(sp)
81128660:	dec00a04 	addi	sp,sp,40
81128664:	f800283a 	ret
81128668:	017fff04 	movi	r5,-4
8112866c:	414a703a 	and	r5,r8,r5
81128670:	814d883a 	add	r6,r16,r5
81128674:	30c01f16 	blt	r6,r3,811286f4 <_realloc_r+0x234>
81128678:	20800317 	ldw	r2,12(r4)
8112867c:	20c00217 	ldw	r3,8(r4)
81128680:	a825883a 	mov	r18,r21
81128684:	3021883a 	mov	r16,r6
81128688:	18800315 	stw	r2,12(r3)
8112868c:	10c00215 	stw	r3,8(r2)
81128690:	003fdb06 	br	81128600 <__reset+0xfb108600>
81128694:	00800304 	movi	r2,12
81128698:	a0800015 	stw	r2,0(r20)
8112869c:	0005883a 	mov	r2,zero
811286a0:	003fe506 	br	81128638 <__reset+0xfb108638>
811286a4:	98c00117 	ldw	r3,4(r19)
811286a8:	9c4b883a 	add	r5,r19,r17
811286ac:	11000054 	ori	r4,r2,1
811286b0:	18c0004c 	andi	r3,r3,1
811286b4:	1c62b03a 	or	r17,r3,r17
811286b8:	9c400115 	stw	r17,4(r19)
811286bc:	29000115 	stw	r4,4(r5)
811286c0:	2885883a 	add	r2,r5,r2
811286c4:	10c00117 	ldw	r3,4(r2)
811286c8:	29400204 	addi	r5,r5,8
811286cc:	a009883a 	mov	r4,r20
811286d0:	18c00054 	ori	r3,r3,1
811286d4:	10c00115 	stw	r3,4(r2)
811286d8:	112642c0 	call	8112642c <_free_r>
811286dc:	003fd306 	br	8112862c <__reset+0xfb10862c>
811286e0:	017fff04 	movi	r5,-4
811286e4:	414a703a 	and	r5,r8,r5
811286e8:	89800404 	addi	r6,r17,16
811286ec:	8151883a 	add	r8,r16,r5
811286f0:	4180590e 	bge	r8,r6,81128858 <_realloc_r+0x398>
811286f4:	1080004c 	andi	r2,r2,1
811286f8:	103f9e1e 	bne	r2,zero,81128574 <__reset+0xfb108574>
811286fc:	adbffe17 	ldw	r22,-8(r21)
81128700:	00bfff04 	movi	r2,-4
81128704:	9dadc83a 	sub	r22,r19,r22
81128708:	b1800117 	ldw	r6,4(r22)
8112870c:	3084703a 	and	r2,r6,r2
81128710:	20002026 	beq	r4,zero,81128794 <_realloc_r+0x2d4>
81128714:	80af883a 	add	r23,r16,r2
81128718:	b96f883a 	add	r23,r23,r5
8112871c:	21c05f26 	beq	r4,r7,8112889c <_realloc_r+0x3dc>
81128720:	b8c01c16 	blt	r23,r3,81128794 <_realloc_r+0x2d4>
81128724:	20800317 	ldw	r2,12(r4)
81128728:	20c00217 	ldw	r3,8(r4)
8112872c:	81bfff04 	addi	r6,r16,-4
81128730:	01000904 	movi	r4,36
81128734:	18800315 	stw	r2,12(r3)
81128738:	10c00215 	stw	r3,8(r2)
8112873c:	b0c00217 	ldw	r3,8(r22)
81128740:	b0800317 	ldw	r2,12(r22)
81128744:	b4800204 	addi	r18,r22,8
81128748:	18800315 	stw	r2,12(r3)
8112874c:	10c00215 	stw	r3,8(r2)
81128750:	21801b36 	bltu	r4,r6,811287c0 <_realloc_r+0x300>
81128754:	008004c4 	movi	r2,19
81128758:	1180352e 	bgeu	r2,r6,81128830 <_realloc_r+0x370>
8112875c:	a8800017 	ldw	r2,0(r21)
81128760:	b0800215 	stw	r2,8(r22)
81128764:	a8800117 	ldw	r2,4(r21)
81128768:	b0800315 	stw	r2,12(r22)
8112876c:	008006c4 	movi	r2,27
81128770:	11807f36 	bltu	r2,r6,81128970 <_realloc_r+0x4b0>
81128774:	b0800404 	addi	r2,r22,16
81128778:	ad400204 	addi	r21,r21,8
8112877c:	00002d06 	br	81128834 <_realloc_r+0x374>
81128780:	adbffe17 	ldw	r22,-8(r21)
81128784:	00bfff04 	movi	r2,-4
81128788:	9dadc83a 	sub	r22,r19,r22
8112878c:	b1000117 	ldw	r4,4(r22)
81128790:	2084703a 	and	r2,r4,r2
81128794:	b03f7726 	beq	r22,zero,81128574 <__reset+0xfb108574>
81128798:	80af883a 	add	r23,r16,r2
8112879c:	b8ff7516 	blt	r23,r3,81128574 <__reset+0xfb108574>
811287a0:	b0800317 	ldw	r2,12(r22)
811287a4:	b0c00217 	ldw	r3,8(r22)
811287a8:	81bfff04 	addi	r6,r16,-4
811287ac:	01000904 	movi	r4,36
811287b0:	18800315 	stw	r2,12(r3)
811287b4:	10c00215 	stw	r3,8(r2)
811287b8:	b4800204 	addi	r18,r22,8
811287bc:	21bfe52e 	bgeu	r4,r6,81128754 <__reset+0xfb108754>
811287c0:	a80b883a 	mov	r5,r21
811287c4:	9009883a 	mov	r4,r18
811287c8:	11272a00 	call	811272a0 <memmove>
811287cc:	b821883a 	mov	r16,r23
811287d0:	b027883a 	mov	r19,r22
811287d4:	003f8a06 	br	81128600 <__reset+0xfb108600>
811287d8:	300b883a 	mov	r5,r6
811287dc:	dfc00917 	ldw	ra,36(sp)
811287e0:	df000817 	ldw	fp,32(sp)
811287e4:	ddc00717 	ldw	r23,28(sp)
811287e8:	dd800617 	ldw	r22,24(sp)
811287ec:	dd400517 	ldw	r21,20(sp)
811287f0:	dd000417 	ldw	r20,16(sp)
811287f4:	dcc00317 	ldw	r19,12(sp)
811287f8:	dc800217 	ldw	r18,8(sp)
811287fc:	dc400117 	ldw	r17,4(sp)
81128800:	dc000017 	ldw	r16,0(sp)
81128804:	dec00a04 	addi	sp,sp,40
81128808:	111c9b81 	jmpi	8111c9b8 <_malloc_r>
8112880c:	a8c00017 	ldw	r3,0(r21)
81128810:	90c00015 	stw	r3,0(r18)
81128814:	a8c00117 	ldw	r3,4(r21)
81128818:	90c00115 	stw	r3,4(r18)
8112881c:	00c006c4 	movi	r3,27
81128820:	19804536 	bltu	r3,r6,81128938 <_realloc_r+0x478>
81128824:	90800204 	addi	r2,r18,8
81128828:	a8c00204 	addi	r3,r21,8
8112882c:	003f6306 	br	811285bc <__reset+0xfb1085bc>
81128830:	9005883a 	mov	r2,r18
81128834:	a8c00017 	ldw	r3,0(r21)
81128838:	b821883a 	mov	r16,r23
8112883c:	b027883a 	mov	r19,r22
81128840:	10c00015 	stw	r3,0(r2)
81128844:	a8c00117 	ldw	r3,4(r21)
81128848:	10c00115 	stw	r3,4(r2)
8112884c:	a8c00217 	ldw	r3,8(r21)
81128850:	10c00215 	stw	r3,8(r2)
81128854:	003f6a06 	br	81128600 <__reset+0xfb108600>
81128858:	9c67883a 	add	r19,r19,r17
8112885c:	4445c83a 	sub	r2,r8,r17
81128860:	e4c00215 	stw	r19,8(fp)
81128864:	10800054 	ori	r2,r2,1
81128868:	98800115 	stw	r2,4(r19)
8112886c:	a8bfff17 	ldw	r2,-4(r21)
81128870:	a009883a 	mov	r4,r20
81128874:	1080004c 	andi	r2,r2,1
81128878:	1462b03a 	or	r17,r2,r17
8112887c:	ac7fff15 	stw	r17,-4(r21)
81128880:	11338dc0 	call	811338dc <__malloc_unlock>
81128884:	a805883a 	mov	r2,r21
81128888:	003f6b06 	br	81128638 <__reset+0xfb108638>
8112888c:	a80b883a 	mov	r5,r21
81128890:	9009883a 	mov	r4,r18
81128894:	11272a00 	call	811272a0 <memmove>
81128898:	003f4e06 	br	811285d4 <__reset+0xfb1085d4>
8112889c:	89000404 	addi	r4,r17,16
811288a0:	b93fbc16 	blt	r23,r4,81128794 <__reset+0xfb108794>
811288a4:	b0800317 	ldw	r2,12(r22)
811288a8:	b0c00217 	ldw	r3,8(r22)
811288ac:	81bfff04 	addi	r6,r16,-4
811288b0:	01000904 	movi	r4,36
811288b4:	18800315 	stw	r2,12(r3)
811288b8:	10c00215 	stw	r3,8(r2)
811288bc:	b4800204 	addi	r18,r22,8
811288c0:	21804336 	bltu	r4,r6,811289d0 <_realloc_r+0x510>
811288c4:	008004c4 	movi	r2,19
811288c8:	11803f2e 	bgeu	r2,r6,811289c8 <_realloc_r+0x508>
811288cc:	a8800017 	ldw	r2,0(r21)
811288d0:	b0800215 	stw	r2,8(r22)
811288d4:	a8800117 	ldw	r2,4(r21)
811288d8:	b0800315 	stw	r2,12(r22)
811288dc:	008006c4 	movi	r2,27
811288e0:	11803f36 	bltu	r2,r6,811289e0 <_realloc_r+0x520>
811288e4:	b0800404 	addi	r2,r22,16
811288e8:	ad400204 	addi	r21,r21,8
811288ec:	a8c00017 	ldw	r3,0(r21)
811288f0:	10c00015 	stw	r3,0(r2)
811288f4:	a8c00117 	ldw	r3,4(r21)
811288f8:	10c00115 	stw	r3,4(r2)
811288fc:	a8c00217 	ldw	r3,8(r21)
81128900:	10c00215 	stw	r3,8(r2)
81128904:	b447883a 	add	r3,r22,r17
81128908:	bc45c83a 	sub	r2,r23,r17
8112890c:	e0c00215 	stw	r3,8(fp)
81128910:	10800054 	ori	r2,r2,1
81128914:	18800115 	stw	r2,4(r3)
81128918:	b0800117 	ldw	r2,4(r22)
8112891c:	a009883a 	mov	r4,r20
81128920:	1080004c 	andi	r2,r2,1
81128924:	1462b03a 	or	r17,r2,r17
81128928:	b4400115 	stw	r17,4(r22)
8112892c:	11338dc0 	call	811338dc <__malloc_unlock>
81128930:	9005883a 	mov	r2,r18
81128934:	003f4006 	br	81128638 <__reset+0xfb108638>
81128938:	a8c00217 	ldw	r3,8(r21)
8112893c:	90c00215 	stw	r3,8(r18)
81128940:	a8c00317 	ldw	r3,12(r21)
81128944:	90c00315 	stw	r3,12(r18)
81128948:	30801126 	beq	r6,r2,81128990 <_realloc_r+0x4d0>
8112894c:	90800404 	addi	r2,r18,16
81128950:	a8c00404 	addi	r3,r21,16
81128954:	003f1906 	br	811285bc <__reset+0xfb1085bc>
81128958:	90ffff17 	ldw	r3,-4(r18)
8112895c:	00bfff04 	movi	r2,-4
81128960:	a825883a 	mov	r18,r21
81128964:	1884703a 	and	r2,r3,r2
81128968:	80a1883a 	add	r16,r16,r2
8112896c:	003f2406 	br	81128600 <__reset+0xfb108600>
81128970:	a8800217 	ldw	r2,8(r21)
81128974:	b0800415 	stw	r2,16(r22)
81128978:	a8800317 	ldw	r2,12(r21)
8112897c:	b0800515 	stw	r2,20(r22)
81128980:	31000a26 	beq	r6,r4,811289ac <_realloc_r+0x4ec>
81128984:	b0800604 	addi	r2,r22,24
81128988:	ad400404 	addi	r21,r21,16
8112898c:	003fa906 	br	81128834 <__reset+0xfb108834>
81128990:	a9000417 	ldw	r4,16(r21)
81128994:	90800604 	addi	r2,r18,24
81128998:	a8c00604 	addi	r3,r21,24
8112899c:	91000415 	stw	r4,16(r18)
811289a0:	a9000517 	ldw	r4,20(r21)
811289a4:	91000515 	stw	r4,20(r18)
811289a8:	003f0406 	br	811285bc <__reset+0xfb1085bc>
811289ac:	a8c00417 	ldw	r3,16(r21)
811289b0:	ad400604 	addi	r21,r21,24
811289b4:	b0800804 	addi	r2,r22,32
811289b8:	b0c00615 	stw	r3,24(r22)
811289bc:	a8ffff17 	ldw	r3,-4(r21)
811289c0:	b0c00715 	stw	r3,28(r22)
811289c4:	003f9b06 	br	81128834 <__reset+0xfb108834>
811289c8:	9005883a 	mov	r2,r18
811289cc:	003fc706 	br	811288ec <__reset+0xfb1088ec>
811289d0:	a80b883a 	mov	r5,r21
811289d4:	9009883a 	mov	r4,r18
811289d8:	11272a00 	call	811272a0 <memmove>
811289dc:	003fc906 	br	81128904 <__reset+0xfb108904>
811289e0:	a8800217 	ldw	r2,8(r21)
811289e4:	b0800415 	stw	r2,16(r22)
811289e8:	a8800317 	ldw	r2,12(r21)
811289ec:	b0800515 	stw	r2,20(r22)
811289f0:	31000726 	beq	r6,r4,81128a10 <_realloc_r+0x550>
811289f4:	b0800604 	addi	r2,r22,24
811289f8:	ad400404 	addi	r21,r21,16
811289fc:	003fbb06 	br	811288ec <__reset+0xfb1088ec>
81128a00:	a009883a 	mov	r4,r20
81128a04:	11338dc0 	call	811338dc <__malloc_unlock>
81128a08:	0005883a 	mov	r2,zero
81128a0c:	003f0a06 	br	81128638 <__reset+0xfb108638>
81128a10:	a8c00417 	ldw	r3,16(r21)
81128a14:	ad400604 	addi	r21,r21,24
81128a18:	b0800804 	addi	r2,r22,32
81128a1c:	b0c00615 	stw	r3,24(r22)
81128a20:	a8ffff17 	ldw	r3,-4(r21)
81128a24:	b0c00715 	stw	r3,28(r22)
81128a28:	003fb006 	br	811288ec <__reset+0xfb1088ec>

81128a2c <__fpclassifyd>:
81128a2c:	00a00034 	movhi	r2,32768
81128a30:	10bfffc4 	addi	r2,r2,-1
81128a34:	2884703a 	and	r2,r5,r2
81128a38:	10000726 	beq	r2,zero,81128a58 <__fpclassifyd+0x2c>
81128a3c:	00fffc34 	movhi	r3,65520
81128a40:	019ff834 	movhi	r6,32736
81128a44:	28c7883a 	add	r3,r5,r3
81128a48:	31bfffc4 	addi	r6,r6,-1
81128a4c:	30c00536 	bltu	r6,r3,81128a64 <__fpclassifyd+0x38>
81128a50:	00800104 	movi	r2,4
81128a54:	f800283a 	ret
81128a58:	2000021e 	bne	r4,zero,81128a64 <__fpclassifyd+0x38>
81128a5c:	00800084 	movi	r2,2
81128a60:	f800283a 	ret
81128a64:	00dffc34 	movhi	r3,32752
81128a68:	019ff834 	movhi	r6,32736
81128a6c:	28cb883a 	add	r5,r5,r3
81128a70:	31bfffc4 	addi	r6,r6,-1
81128a74:	317ff62e 	bgeu	r6,r5,81128a50 <__reset+0xfb108a50>
81128a78:	01400434 	movhi	r5,16
81128a7c:	297fffc4 	addi	r5,r5,-1
81128a80:	28800236 	bltu	r5,r2,81128a8c <__fpclassifyd+0x60>
81128a84:	008000c4 	movi	r2,3
81128a88:	f800283a 	ret
81128a8c:	10c00226 	beq	r2,r3,81128a98 <__fpclassifyd+0x6c>
81128a90:	0005883a 	mov	r2,zero
81128a94:	f800283a 	ret
81128a98:	2005003a 	cmpeq	r2,r4,zero
81128a9c:	f800283a 	ret

81128aa0 <__sccl>:
81128aa0:	2a000003 	ldbu	r8,0(r5)
81128aa4:	00801784 	movi	r2,94
81128aa8:	40802a26 	beq	r8,r2,81128b54 <__sccl+0xb4>
81128aac:	29400044 	addi	r5,r5,1
81128ab0:	000f883a 	mov	r7,zero
81128ab4:	0013883a 	mov	r9,zero
81128ab8:	2007883a 	mov	r3,r4
81128abc:	21804004 	addi	r6,r4,256
81128ac0:	19c00005 	stb	r7,0(r3)
81128ac4:	18c00044 	addi	r3,r3,1
81128ac8:	19bffd1e 	bne	r3,r6,81128ac0 <__reset+0xfb108ac0>
81128acc:	40001126 	beq	r8,zero,81128b14 <__sccl+0x74>
81128ad0:	00800044 	movi	r2,1
81128ad4:	124fc83a 	sub	r7,r2,r9
81128ad8:	02800b44 	movi	r10,45
81128adc:	02c01744 	movi	r11,93
81128ae0:	2205883a 	add	r2,r4,r8
81128ae4:	11c00005 	stb	r7,0(r2)
81128ae8:	28800044 	addi	r2,r5,1
81128aec:	28c00003 	ldbu	r3,0(r5)
81128af0:	1a800a26 	beq	r3,r10,81128b1c <__sccl+0x7c>
81128af4:	1ac00426 	beq	r3,r11,81128b08 <__sccl+0x68>
81128af8:	18000426 	beq	r3,zero,81128b0c <__sccl+0x6c>
81128afc:	1811883a 	mov	r8,r3
81128b00:	100b883a 	mov	r5,r2
81128b04:	003ff606 	br	81128ae0 <__reset+0xfb108ae0>
81128b08:	f800283a 	ret
81128b0c:	2805883a 	mov	r2,r5
81128b10:	f800283a 	ret
81128b14:	28bfffc4 	addi	r2,r5,-1
81128b18:	f800283a 	ret
81128b1c:	12400003 	ldbu	r9,0(r2)
81128b20:	4ac01126 	beq	r9,r11,81128b68 <__sccl+0xc8>
81128b24:	4a001016 	blt	r9,r8,81128b68 <__sccl+0xc8>
81128b28:	41800044 	addi	r6,r8,1
81128b2c:	29400084 	addi	r5,r5,2
81128b30:	2187883a 	add	r3,r4,r6
81128b34:	00000106 	br	81128b3c <__sccl+0x9c>
81128b38:	31800044 	addi	r6,r6,1
81128b3c:	19c00005 	stb	r7,0(r3)
81128b40:	3011883a 	mov	r8,r6
81128b44:	18c00044 	addi	r3,r3,1
81128b48:	327ffb16 	blt	r6,r9,81128b38 <__reset+0xfb108b38>
81128b4c:	10800084 	addi	r2,r2,2
81128b50:	003fe606 	br	81128aec <__reset+0xfb108aec>
81128b54:	2a000043 	ldbu	r8,1(r5)
81128b58:	01c00044 	movi	r7,1
81128b5c:	29400084 	addi	r5,r5,2
81128b60:	02400044 	movi	r9,1
81128b64:	003fd406 	br	81128ab8 <__reset+0xfb108ab8>
81128b68:	5011883a 	mov	r8,r10
81128b6c:	003fe406 	br	81128b00 <__reset+0xfb108b00>

81128b70 <nanf>:
81128b70:	009ff034 	movhi	r2,32704
81128b74:	f800283a 	ret

81128b78 <strcmp>:
81128b78:	2144b03a 	or	r2,r4,r5
81128b7c:	108000cc 	andi	r2,r2,3
81128b80:	1000171e 	bne	r2,zero,81128be0 <strcmp+0x68>
81128b84:	20800017 	ldw	r2,0(r4)
81128b88:	28c00017 	ldw	r3,0(r5)
81128b8c:	10c0141e 	bne	r2,r3,81128be0 <strcmp+0x68>
81128b90:	027fbff4 	movhi	r9,65279
81128b94:	4a7fbfc4 	addi	r9,r9,-257
81128b98:	0086303a 	nor	r3,zero,r2
81128b9c:	02202074 	movhi	r8,32897
81128ba0:	1245883a 	add	r2,r2,r9
81128ba4:	42202004 	addi	r8,r8,-32640
81128ba8:	10c4703a 	and	r2,r2,r3
81128bac:	1204703a 	and	r2,r2,r8
81128bb0:	10000226 	beq	r2,zero,81128bbc <strcmp+0x44>
81128bb4:	00002306 	br	81128c44 <strcmp+0xcc>
81128bb8:	1000221e 	bne	r2,zero,81128c44 <strcmp+0xcc>
81128bbc:	21000104 	addi	r4,r4,4
81128bc0:	20c00017 	ldw	r3,0(r4)
81128bc4:	29400104 	addi	r5,r5,4
81128bc8:	29800017 	ldw	r6,0(r5)
81128bcc:	1a4f883a 	add	r7,r3,r9
81128bd0:	00c4303a 	nor	r2,zero,r3
81128bd4:	3884703a 	and	r2,r7,r2
81128bd8:	1204703a 	and	r2,r2,r8
81128bdc:	19bff626 	beq	r3,r6,81128bb8 <__reset+0xfb108bb8>
81128be0:	20800003 	ldbu	r2,0(r4)
81128be4:	10c03fcc 	andi	r3,r2,255
81128be8:	18c0201c 	xori	r3,r3,128
81128bec:	18ffe004 	addi	r3,r3,-128
81128bf0:	18000c26 	beq	r3,zero,81128c24 <strcmp+0xac>
81128bf4:	29800007 	ldb	r6,0(r5)
81128bf8:	19800326 	beq	r3,r6,81128c08 <strcmp+0x90>
81128bfc:	00001306 	br	81128c4c <strcmp+0xd4>
81128c00:	29800007 	ldb	r6,0(r5)
81128c04:	11800b1e 	bne	r2,r6,81128c34 <strcmp+0xbc>
81128c08:	21000044 	addi	r4,r4,1
81128c0c:	20c00003 	ldbu	r3,0(r4)
81128c10:	29400044 	addi	r5,r5,1
81128c14:	18803fcc 	andi	r2,r3,255
81128c18:	1080201c 	xori	r2,r2,128
81128c1c:	10bfe004 	addi	r2,r2,-128
81128c20:	103ff71e 	bne	r2,zero,81128c00 <__reset+0xfb108c00>
81128c24:	0007883a 	mov	r3,zero
81128c28:	28800003 	ldbu	r2,0(r5)
81128c2c:	1885c83a 	sub	r2,r3,r2
81128c30:	f800283a 	ret
81128c34:	28800003 	ldbu	r2,0(r5)
81128c38:	18c03fcc 	andi	r3,r3,255
81128c3c:	1885c83a 	sub	r2,r3,r2
81128c40:	f800283a 	ret
81128c44:	0005883a 	mov	r2,zero
81128c48:	f800283a 	ret
81128c4c:	10c03fcc 	andi	r3,r2,255
81128c50:	003ff506 	br	81128c28 <__reset+0xfb108c28>

81128c54 <sulp>:
81128c54:	defffd04 	addi	sp,sp,-12
81128c58:	de00012e 	bgeu	sp,et,81128c60 <sulp+0xc>
81128c5c:	003b68fa 	trap	3
81128c60:	dc400115 	stw	r17,4(sp)
81128c64:	3023883a 	mov	r17,r6
81128c68:	dc000015 	stw	r16,0(sp)
81128c6c:	dfc00215 	stw	ra,8(sp)
81128c70:	2821883a 	mov	r16,r5
81128c74:	1127f600 	call	81127f60 <__ulp>
81128c78:	88000c26 	beq	r17,zero,81128cac <sulp+0x58>
81128c7c:	841ffc2c 	andhi	r16,r16,32752
81128c80:	8020d53a 	srli	r16,r16,20
81128c84:	01c01ac4 	movi	r7,107
81128c88:	3c21c83a 	sub	r16,r7,r16
81128c8c:	0400070e 	bge	zero,r16,81128cac <sulp+0x58>
81128c90:	8020953a 	slli	r16,r16,20
81128c94:	01cffc34 	movhi	r7,16368
81128c98:	000d883a 	mov	r6,zero
81128c9c:	81cf883a 	add	r7,r16,r7
81128ca0:	1009883a 	mov	r4,r2
81128ca4:	180b883a 	mov	r5,r3
81128ca8:	111b57c0 	call	8111b57c <__muldf3>
81128cac:	dfc00217 	ldw	ra,8(sp)
81128cb0:	dc400117 	ldw	r17,4(sp)
81128cb4:	dc000017 	ldw	r16,0(sp)
81128cb8:	dec00304 	addi	sp,sp,12
81128cbc:	f800283a 	ret

81128cc0 <_strtod_r>:
81128cc0:	deffe204 	addi	sp,sp,-120
81128cc4:	de00012e 	bgeu	sp,et,81128ccc <_strtod_r+0xc>
81128cc8:	003b68fa 	trap	3
81128ccc:	ddc01b15 	stw	r23,108(sp)
81128cd0:	dd001815 	stw	r20,96(sp)
81128cd4:	dc801615 	stw	r18,88(sp)
81128cd8:	dc401515 	stw	r17,84(sp)
81128cdc:	dc001415 	stw	r16,80(sp)
81128ce0:	d9400615 	stw	r5,24(sp)
81128ce4:	dfc01d15 	stw	ra,116(sp)
81128ce8:	df001c15 	stw	fp,112(sp)
81128cec:	dd801a15 	stw	r22,104(sp)
81128cf0:	dd401915 	stw	r21,100(sp)
81128cf4:	dcc01715 	stw	r19,92(sp)
81128cf8:	2021883a 	mov	r16,r4
81128cfc:	d8000515 	stw	zero,20(sp)
81128d00:	2809883a 	mov	r4,r5
81128d04:	20800003 	ldbu	r2,0(r4)
81128d08:	01e044f4 	movhi	r7,33043
81128d0c:	282f883a 	mov	r23,r5
81128d10:	10c03fcc 	andi	r3,r2,255
81128d14:	01400b44 	movi	r5,45
81128d18:	39e34f04 	addi	r7,r7,-29380
81128d1c:	3029883a 	mov	r20,r6
81128d20:	0025883a 	mov	r18,zero
81128d24:	0023883a 	mov	r17,zero
81128d28:	28c0ba36 	bltu	r5,r3,81129014 <_strtod_r+0x354>
81128d2c:	180690ba 	slli	r3,r3,2
81128d30:	19c7883a 	add	r3,r3,r7
81128d34:	18c00017 	ldw	r3,0(r3)
81128d38:	1800683a 	jmp	r3
81128d3c:	81128dfc 	xorhi	r4,r16,18999
81128d40:	81129014 	ori	r4,r16,19008
81128d44:	81129014 	ori	r4,r16,19008
81128d48:	81129014 	ori	r4,r16,19008
81128d4c:	81129014 	ori	r4,r16,19008
81128d50:	81129014 	ori	r4,r16,19008
81128d54:	81129014 	ori	r4,r16,19008
81128d58:	81129014 	ori	r4,r16,19008
81128d5c:	81129014 	ori	r4,r16,19008
81128d60:	81129000 	call	88112900 <__reset+0x20f2900>
81128d64:	81129000 	call	88112900 <__reset+0x20f2900>
81128d68:	81129000 	call	88112900 <__reset+0x20f2900>
81128d6c:	81129000 	call	88112900 <__reset+0x20f2900>
81128d70:	81129000 	call	88112900 <__reset+0x20f2900>
81128d74:	81129014 	ori	r4,r16,19008
81128d78:	81129014 	ori	r4,r16,19008
81128d7c:	81129014 	ori	r4,r16,19008
81128d80:	81129014 	ori	r4,r16,19008
81128d84:	81129014 	ori	r4,r16,19008
81128d88:	81129014 	ori	r4,r16,19008
81128d8c:	81129014 	ori	r4,r16,19008
81128d90:	81129014 	ori	r4,r16,19008
81128d94:	81129014 	ori	r4,r16,19008
81128d98:	81129014 	ori	r4,r16,19008
81128d9c:	81129014 	ori	r4,r16,19008
81128da0:	81129014 	ori	r4,r16,19008
81128da4:	81129014 	ori	r4,r16,19008
81128da8:	81129014 	ori	r4,r16,19008
81128dac:	81129014 	ori	r4,r16,19008
81128db0:	81129014 	ori	r4,r16,19008
81128db4:	81129014 	ori	r4,r16,19008
81128db8:	81129014 	ori	r4,r16,19008
81128dbc:	81129000 	call	88112900 <__reset+0x20f2900>
81128dc0:	81129014 	ori	r4,r16,19008
81128dc4:	81129014 	ori	r4,r16,19008
81128dc8:	81129014 	ori	r4,r16,19008
81128dcc:	81129014 	ori	r4,r16,19008
81128dd0:	81129014 	ori	r4,r16,19008
81128dd4:	81129014 	ori	r4,r16,19008
81128dd8:	81129014 	ori	r4,r16,19008
81128ddc:	81129014 	ori	r4,r16,19008
81128de0:	81129014 	ori	r4,r16,19008
81128de4:	81129014 	ori	r4,r16,19008
81128de8:	81128e54 	ori	r4,r16,19001
81128dec:	81129014 	ori	r4,r16,19008
81128df0:	81128ff4 	orhi	r4,r16,19007
81128df4:	00801244 	movi	r2,73
81128df8:	88843526 	beq	r17,r2,81129ed0 <_strtod_r+0x1210>
81128dfc:	002b883a 	mov	r21,zero
81128e00:	002d883a 	mov	r22,zero
81128e04:	a0000526 	beq	r20,zero,81128e1c <_strtod_r+0x15c>
81128e08:	d8000715 	stw	zero,28(sp)
81128e0c:	a5c00015 	stw	r23,0(r20)
81128e10:	d9000717 	ldw	r4,28(sp)
81128e14:	20000126 	beq	r4,zero,81128e1c <_strtod_r+0x15c>
81128e18:	b5a0003c 	xorhi	r22,r22,32768
81128e1c:	a805883a 	mov	r2,r21
81128e20:	b007883a 	mov	r3,r22
81128e24:	dfc01d17 	ldw	ra,116(sp)
81128e28:	df001c17 	ldw	fp,112(sp)
81128e2c:	ddc01b17 	ldw	r23,108(sp)
81128e30:	dd801a17 	ldw	r22,104(sp)
81128e34:	dd401917 	ldw	r21,100(sp)
81128e38:	dd001817 	ldw	r20,96(sp)
81128e3c:	dcc01717 	ldw	r19,92(sp)
81128e40:	dc801617 	ldw	r18,88(sp)
81128e44:	dc401517 	ldw	r17,84(sp)
81128e48:	dc001417 	ldw	r16,80(sp)
81128e4c:	dec01e04 	addi	sp,sp,120
81128e50:	f800283a 	ret
81128e54:	d8000715 	stw	zero,28(sp)
81128e58:	24c00044 	addi	r19,r4,1
81128e5c:	dcc00615 	stw	r19,24(sp)
81128e60:	20800043 	ldbu	r2,1(r4)
81128e64:	10c03fcc 	andi	r3,r2,255
81128e68:	18c0201c 	xori	r3,r3,128
81128e6c:	18ffe004 	addi	r3,r3,-128
81128e70:	183fe226 	beq	r3,zero,81128dfc <__reset+0xfb108dfc>
81128e74:	11403fcc 	andi	r5,r2,255
81128e78:	2940201c 	xori	r5,r5,128
81128e7c:	297fe004 	addi	r5,r5,-128
81128e80:	00c00c04 	movi	r3,48
81128e84:	28c0e526 	beq	r5,r3,8112921c <_strtod_r+0x55c>
81128e88:	dcc00815 	stw	r19,32(sp)
81128e8c:	0025883a 	mov	r18,zero
81128e90:	10fff404 	addi	r3,r2,-48
81128e94:	18c03fcc 	andi	r3,r3,255
81128e98:	01000244 	movi	r4,9
81128e9c:	20c37536 	bltu	r4,r3,81129c74 <_strtod_r+0xfb4>
81128ea0:	dd400817 	ldw	r21,32(sp)
81128ea4:	0027883a 	mov	r19,zero
81128ea8:	0039883a 	mov	fp,zero
81128eac:	002d883a 	mov	r22,zero
81128eb0:	01400204 	movi	r5,8
81128eb4:	2d805a16 	blt	r5,r22,81129020 <_strtod_r+0x360>
81128eb8:	e70002a4 	muli	fp,fp,10
81128ebc:	10c03fcc 	andi	r3,r2,255
81128ec0:	18c0201c 	xori	r3,r3,128
81128ec4:	18ffe004 	addi	r3,r3,-128
81128ec8:	e0f9883a 	add	fp,fp,r3
81128ecc:	e73ff404 	addi	fp,fp,-48
81128ed0:	ad400044 	addi	r21,r21,1
81128ed4:	dd400615 	stw	r21,24(sp)
81128ed8:	a8800003 	ldbu	r2,0(r21)
81128edc:	b5800044 	addi	r22,r22,1
81128ee0:	10fff404 	addi	r3,r2,-48
81128ee4:	18c03fcc 	andi	r3,r3,255
81128ee8:	20fff22e 	bgeu	r4,r3,81128eb4 <__reset+0xfb108eb4>
81128eec:	14403fcc 	andi	r17,r2,255
81128ef0:	8c40201c 	xori	r17,r17,128
81128ef4:	8c7fe004 	addi	r17,r17,-128
81128ef8:	8009883a 	mov	r4,r16
81128efc:	1126ee00 	call	81126ee0 <_localeconv_r>
81128f00:	11400017 	ldw	r5,0(r2)
81128f04:	8009883a 	mov	r4,r16
81128f08:	d9401315 	stw	r5,76(sp)
81128f0c:	1126ee00 	call	81126ee0 <_localeconv_r>
81128f10:	11000017 	ldw	r4,0(r2)
81128f14:	111dcc00 	call	8111dcc0 <strlen>
81128f18:	d9401317 	ldw	r5,76(sp)
81128f1c:	100d883a 	mov	r6,r2
81128f20:	a809883a 	mov	r4,r21
81128f24:	112e8b00 	call	8112e8b0 <strncmp>
81128f28:	1000ce26 	beq	r2,zero,81129264 <_strtod_r+0x5a4>
81128f2c:	b013883a 	mov	r9,r22
81128f30:	000b883a 	mov	r5,zero
81128f34:	0015883a 	mov	r10,zero
81128f38:	0017883a 	mov	r11,zero
81128f3c:	00801944 	movi	r2,101
81128f40:	88807826 	beq	r17,r2,81129124 <_strtod_r+0x464>
81128f44:	00801144 	movi	r2,69
81128f48:	88807626 	beq	r17,r2,81129124 <_strtod_r+0x464>
81128f4c:	002b883a 	mov	r21,zero
81128f50:	48003d1e 	bne	r9,zero,81129048 <_strtod_r+0x388>
81128f54:	2800391e 	bne	r5,zero,8112903c <_strtod_r+0x37c>
81128f58:	9000381e 	bne	r18,zero,8112903c <_strtod_r+0x37c>
81128f5c:	583fa71e 	bne	r11,zero,81128dfc <__reset+0xfb108dfc>
81128f60:	00801384 	movi	r2,78
81128f64:	88800526 	beq	r17,r2,81128f7c <_strtod_r+0x2bc>
81128f68:	147fa20e 	bge	r2,r17,81128df4 <__reset+0xfb108df4>
81128f6c:	00801a44 	movi	r2,105
81128f70:	8883d726 	beq	r17,r2,81129ed0 <_strtod_r+0x1210>
81128f74:	00801b84 	movi	r2,110
81128f78:	88bfa01e 	bne	r17,r2,81128dfc <__reset+0xfb108dfc>
81128f7c:	01604574 	movhi	r5,33045
81128f80:	d9000617 	ldw	r4,24(sp)
81128f84:	296e7c04 	addi	r5,r5,-17936
81128f88:	01c00644 	movi	r7,25
81128f8c:	00000b06 	br	81128fbc <_strtod_r+0x2fc>
81128f90:	21000044 	addi	r4,r4,1
81128f94:	20800003 	ldbu	r2,0(r4)
81128f98:	10ffefc4 	addi	r3,r2,-65
81128f9c:	10803fcc 	andi	r2,r2,255
81128fa0:	1080201c 	xori	r2,r2,128
81128fa4:	18c03fcc 	andi	r3,r3,255
81128fa8:	10bfe004 	addi	r2,r2,-128
81128fac:	38c00136 	bltu	r7,r3,81128fb4 <_strtod_r+0x2f4>
81128fb0:	10800804 	addi	r2,r2,32
81128fb4:	29400044 	addi	r5,r5,1
81128fb8:	11bf901e 	bne	r2,r6,81128dfc <__reset+0xfb108dfc>
81128fbc:	29800007 	ldb	r6,0(r5)
81128fc0:	303ff31e 	bne	r6,zero,81128f90 <__reset+0xfb108f90>
81128fc4:	20800044 	addi	r2,r4,1
81128fc8:	d8800615 	stw	r2,24(sp)
81128fcc:	20c00047 	ldb	r3,1(r4)
81128fd0:	00800a04 	movi	r2,40
81128fd4:	18849d26 	beq	r3,r2,8112a24c <_strtod_r+0x158c>
81128fd8:	047ffe34 	movhi	r17,65528
81128fdc:	0025883a 	mov	r18,zero
81128fe0:	902b883a 	mov	r21,r18
81128fe4:	882d883a 	mov	r22,r17
81128fe8:	a03f8926 	beq	r20,zero,81128e10 <__reset+0xfb108e10>
81128fec:	ddc00617 	ldw	r23,24(sp)
81128ff0:	003f8606 	br	81128e0c <__reset+0xfb108e0c>
81128ff4:	00800044 	movi	r2,1
81128ff8:	d8800715 	stw	r2,28(sp)
81128ffc:	003f9606 	br	81128e58 <__reset+0xfb108e58>
81129000:	21000044 	addi	r4,r4,1
81129004:	d9000615 	stw	r4,24(sp)
81129008:	20800003 	ldbu	r2,0(r4)
8112900c:	10c03fcc 	andi	r3,r2,255
81129010:	28ff462e 	bgeu	r5,r3,81128d2c <__reset+0xfb108d2c>
81129014:	2027883a 	mov	r19,r4
81129018:	d8000715 	stw	zero,28(sp)
8112901c:	003f9506 	br	81128e74 <__reset+0xfb108e74>
81129020:	9cc002a4 	muli	r19,r19,10
81129024:	10803fcc 	andi	r2,r2,255
81129028:	1080201c 	xori	r2,r2,128
8112902c:	10bfe004 	addi	r2,r2,-128
81129030:	9885883a 	add	r2,r19,r2
81129034:	14fff404 	addi	r19,r2,-48
81129038:	003fa506 	br	81128ed0 <__reset+0xfb108ed0>
8112903c:	002b883a 	mov	r21,zero
81129040:	002d883a 	mov	r22,zero
81129044:	003fe806 	br	81128fe8 <__reset+0xfb108fe8>
81129048:	aaabc83a 	sub	r21,r21,r10
8112904c:	b000011e 	bne	r22,zero,81129054 <_strtod_r+0x394>
81129050:	482d883a 	mov	r22,r9
81129054:	00800404 	movi	r2,16
81129058:	482f883a 	mov	r23,r9
8112905c:	1240010e 	bge	r2,r9,81129064 <_strtod_r+0x3a4>
81129060:	102f883a 	mov	r23,r2
81129064:	e009883a 	mov	r4,fp
81129068:	da401315 	stw	r9,76(sp)
8112906c:	11318d00 	call	811318d0 <__floatunsidf>
81129070:	1025883a 	mov	r18,r2
81129074:	00800244 	movi	r2,9
81129078:	1823883a 	mov	r17,r3
8112907c:	da401317 	ldw	r9,76(sp)
81129080:	15c0160e 	bge	r2,r23,811290dc <_strtod_r+0x41c>
81129084:	b8bffdc4 	addi	r2,r23,-9
81129088:	100490fa 	slli	r2,r2,3
8112908c:	180b883a 	mov	r5,r3
81129090:	00e04574 	movhi	r3,33045
81129094:	18ee4704 	addi	r3,r3,-18148
81129098:	1885883a 	add	r2,r3,r2
8112909c:	11800017 	ldw	r6,0(r2)
811290a0:	11c00117 	ldw	r7,4(r2)
811290a4:	9009883a 	mov	r4,r18
811290a8:	111b57c0 	call	8111b57c <__muldf3>
811290ac:	9809883a 	mov	r4,r19
811290b0:	1025883a 	mov	r18,r2
811290b4:	1823883a 	mov	r17,r3
811290b8:	11318d00 	call	811318d0 <__floatunsidf>
811290bc:	9009883a 	mov	r4,r18
811290c0:	880b883a 	mov	r5,r17
811290c4:	100d883a 	mov	r6,r2
811290c8:	180f883a 	mov	r7,r3
811290cc:	112fa6c0 	call	8112fa6c <__adddf3>
811290d0:	da401317 	ldw	r9,76(sp)
811290d4:	1025883a 	mov	r18,r2
811290d8:	1823883a 	mov	r17,r3
811290dc:	008003c4 	movi	r2,15
811290e0:	12407b16 	blt	r2,r9,811292d0 <_strtod_r+0x610>
811290e4:	a83fbe26 	beq	r21,zero,81128fe0 <__reset+0xfb108fe0>
811290e8:	0543670e 	bge	zero,r21,81129e88 <_strtod_r+0x11c8>
811290ec:	00c00584 	movi	r3,22
811290f0:	1d42e816 	blt	r3,r21,81129c94 <_strtod_r+0xfd4>
811290f4:	a82a90fa 	slli	r21,r21,3
811290f8:	00a04574 	movhi	r2,33045
811290fc:	10ae4704 	addi	r2,r2,-18148
81129100:	1545883a 	add	r2,r2,r21
81129104:	11000017 	ldw	r4,0(r2)
81129108:	11400117 	ldw	r5,4(r2)
8112910c:	900d883a 	mov	r6,r18
81129110:	880f883a 	mov	r7,r17
81129114:	111b57c0 	call	8111b57c <__muldf3>
81129118:	102b883a 	mov	r21,r2
8112911c:	182d883a 	mov	r22,r3
81129120:	003fb106 	br	81128fe8 <__reset+0xfb108fe8>
81129124:	4801b526 	beq	r9,zero,811297fc <_strtod_r+0xb3c>
81129128:	ddc00617 	ldw	r23,24(sp)
8112912c:	00c00ac4 	movi	r3,43
81129130:	b8800044 	addi	r2,r23,1
81129134:	d8800615 	stw	r2,24(sp)
81129138:	b8800047 	ldb	r2,1(r23)
8112913c:	10c1e926 	beq	r2,r3,811298e4 <_strtod_r+0xc24>
81129140:	00c00b44 	movi	r3,45
81129144:	10c1ec26 	beq	r2,r3,811298f8 <_strtod_r+0xc38>
81129148:	1023883a 	mov	r17,r2
8112914c:	0019883a 	mov	r12,zero
81129150:	88bff404 	addi	r2,r17,-48
81129154:	00c00244 	movi	r3,9
81129158:	1881b736 	bltu	r3,r2,81129838 <_strtod_r+0xb78>
8112915c:	00800c04 	movi	r2,48
81129160:	8880071e 	bne	r17,r2,81129180 <_strtod_r+0x4c0>
81129164:	d8800617 	ldw	r2,24(sp)
81129168:	8807883a 	mov	r3,r17
8112916c:	10800044 	addi	r2,r2,1
81129170:	d8800615 	stw	r2,24(sp)
81129174:	14400007 	ldb	r17,0(r2)
81129178:	10800044 	addi	r2,r2,1
8112917c:	88fffc26 	beq	r17,r3,81129170 <__reset+0xfb109170>
81129180:	88bff3c4 	addi	r2,r17,-49
81129184:	00c00204 	movi	r3,8
81129188:	18bf7036 	bltu	r3,r2,81128f4c <__reset+0xfb108f4c>
8112918c:	db800617 	ldw	r14,24(sp)
81129190:	88bff404 	addi	r2,r17,-48
81129194:	03400244 	movi	r13,9
81129198:	71c00044 	addi	r7,r14,1
8112919c:	d9c00615 	stw	r7,24(sp)
811291a0:	74400043 	ldbu	r17,1(r14)
811291a4:	88fff404 	addi	r3,r17,-48
811291a8:	8c403fcc 	andi	r17,r17,255
811291ac:	8c40201c 	xori	r17,r17,128
811291b0:	18c03fcc 	andi	r3,r3,255
811291b4:	8c7fe004 	addi	r17,r17,-128
811291b8:	68c00e36 	bltu	r13,r3,811291f4 <_strtod_r+0x534>
811291bc:	71000084 	addi	r4,r14,2
811291c0:	d9000615 	stw	r4,24(sp)
811291c4:	108002a4 	muli	r2,r2,10
811291c8:	21800003 	ldbu	r6,0(r4)
811291cc:	200f883a 	mov	r7,r4
811291d0:	1463883a 	add	r17,r2,r17
811291d4:	30fff404 	addi	r3,r6,-48
811291d8:	88bff404 	addi	r2,r17,-48
811291dc:	34403fcc 	andi	r17,r6,255
811291e0:	8c40201c 	xori	r17,r17,128
811291e4:	18c03fcc 	andi	r3,r3,255
811291e8:	8c7fe004 	addi	r17,r17,-128
811291ec:	21000044 	addi	r4,r4,1
811291f0:	68fff32e 	bgeu	r13,r3,811291c0 <__reset+0xfb1091c0>
811291f4:	3b8fc83a 	sub	r7,r7,r14
811291f8:	00c00204 	movi	r3,8
811291fc:	19c29716 	blt	r3,r7,81129c5c <_strtod_r+0xf9c>
81129200:	102b883a 	mov	r21,r2
81129204:	009387c4 	movi	r2,19999
81129208:	1540010e 	bge	r2,r21,81129210 <_strtod_r+0x550>
8112920c:	102b883a 	mov	r21,r2
81129210:	603f4f26 	beq	r12,zero,81128f50 <__reset+0xfb108f50>
81129214:	056bc83a 	sub	r21,zero,r21
81129218:	003f4d06 	br	81128f50 <__reset+0xfb108f50>
8112921c:	98800047 	ldb	r2,1(r19)
81129220:	00c01604 	movi	r3,88
81129224:	10c1de26 	beq	r2,r3,811299a0 <_strtod_r+0xce0>
81129228:	00c01e04 	movi	r3,120
8112922c:	10c1dc26 	beq	r2,r3,811299a0 <_strtod_r+0xce0>
81129230:	98c00044 	addi	r3,r19,1
81129234:	1827883a 	mov	r19,r3
81129238:	d8c00615 	stw	r3,24(sp)
8112923c:	18c00044 	addi	r3,r3,1
81129240:	18bfffc3 	ldbu	r2,-1(r3)
81129244:	11003fcc 	andi	r4,r2,255
81129248:	2100201c 	xori	r4,r4,128
8112924c:	213fe004 	addi	r4,r4,-128
81129250:	217ff826 	beq	r4,r5,81129234 <__reset+0xfb109234>
81129254:	203f7926 	beq	r4,zero,8112903c <__reset+0xfb10903c>
81129258:	dcc00815 	stw	r19,32(sp)
8112925c:	04800044 	movi	r18,1
81129260:	003f0b06 	br	81128e90 <__reset+0xfb108e90>
81129264:	8009883a 	mov	r4,r16
81129268:	1126ee00 	call	81126ee0 <_localeconv_r>
8112926c:	11000017 	ldw	r4,0(r2)
81129270:	111dcc00 	call	8111dcc0 <strlen>
81129274:	d8c00617 	ldw	r3,24(sp)
81129278:	1885883a 	add	r2,r3,r2
8112927c:	d8800615 	stw	r2,24(sp)
81129280:	14400007 	ldb	r17,0(r2)
81129284:	b001881e 	bne	r22,zero,811298a8 <_strtod_r+0xbe8>
81129288:	00c00c04 	movi	r3,48
8112928c:	88c3391e 	bne	r17,r3,81129f74 <_strtod_r+0x12b4>
81129290:	10c00044 	addi	r3,r2,1
81129294:	8809883a 	mov	r4,r17
81129298:	d8c00615 	stw	r3,24(sp)
8112929c:	1c400007 	ldb	r17,0(r3)
811292a0:	188bc83a 	sub	r5,r3,r2
811292a4:	18c00044 	addi	r3,r3,1
811292a8:	893ffb26 	beq	r17,r4,81129298 <__reset+0xfb109298>
811292ac:	88bff3c4 	addi	r2,r17,-49
811292b0:	00c00204 	movi	r3,8
811292b4:	1882e72e 	bgeu	r3,r2,81129e54 <_strtod_r+0x1194>
811292b8:	00801944 	movi	r2,101
811292bc:	88814d26 	beq	r17,r2,811297f4 <_strtod_r+0xb34>
811292c0:	0013883a 	mov	r9,zero
811292c4:	0015883a 	mov	r10,zero
811292c8:	02c00044 	movi	r11,1
811292cc:	003f1d06 	br	81128f44 <__reset+0xfb108f44>
811292d0:	4defc83a 	sub	r23,r9,r23
811292d4:	bd6f883a 	add	r23,r23,r21
811292d8:	05c21e0e 	bge	zero,r23,81129b54 <_strtod_r+0xe94>
811292dc:	b88003cc 	andi	r2,r23,15
811292e0:	10000d26 	beq	r2,zero,81129318 <_strtod_r+0x658>
811292e4:	100490fa 	slli	r2,r2,3
811292e8:	00e04574 	movhi	r3,33045
811292ec:	18ee4704 	addi	r3,r3,-18148
811292f0:	1885883a 	add	r2,r3,r2
811292f4:	11000017 	ldw	r4,0(r2)
811292f8:	11400117 	ldw	r5,4(r2)
811292fc:	900d883a 	mov	r6,r18
81129300:	880f883a 	mov	r7,r17
81129304:	da401315 	stw	r9,76(sp)
81129308:	111b57c0 	call	8111b57c <__muldf3>
8112930c:	da401317 	ldw	r9,76(sp)
81129310:	1025883a 	mov	r18,r2
81129314:	1823883a 	mov	r17,r3
81129318:	023ffc04 	movi	r8,-16
8112931c:	ba10703a 	and	r8,r23,r8
81129320:	40003c26 	beq	r8,zero,81129414 <_strtod_r+0x754>
81129324:	00804d04 	movi	r2,308
81129328:	1201cd16 	blt	r2,r8,81129a60 <_strtod_r+0xda0>
8112932c:	4011d13a 	srai	r8,r8,4
81129330:	03000044 	movi	r12,1
81129334:	62037c0e 	bge	r12,r8,8112a128 <_strtod_r+0x1468>
81129338:	01204574 	movhi	r4,33045
8112933c:	212e3d04 	addi	r4,r4,-18188
81129340:	2015883a 	mov	r10,r4
81129344:	0027883a 	mov	r19,zero
81129348:	d9000915 	stw	r4,36(sp)
8112934c:	9005883a 	mov	r2,r18
81129350:	8807883a 	mov	r3,r17
81129354:	dc000c15 	stw	r16,48(sp)
81129358:	dc800e15 	stw	r18,56(sp)
8112935c:	9821883a 	mov	r16,r19
81129360:	0009883a 	mov	r4,zero
81129364:	8827883a 	mov	r19,r17
81129368:	602f883a 	mov	r23,r12
8112936c:	da400a15 	stw	r9,40(sp)
81129370:	5025883a 	mov	r18,r10
81129374:	4023883a 	mov	r17,r8
81129378:	8980004c 	andi	r6,r17,1
8112937c:	30000626 	beq	r6,zero,81129398 <_strtod_r+0x6d8>
81129380:	91800017 	ldw	r6,0(r18)
81129384:	91c00117 	ldw	r7,4(r18)
81129388:	1009883a 	mov	r4,r2
8112938c:	180b883a 	mov	r5,r3
81129390:	111b57c0 	call	8111b57c <__muldf3>
81129394:	01000044 	movi	r4,1
81129398:	8823d07a 	srai	r17,r17,1
8112939c:	84000044 	addi	r16,r16,1
811293a0:	94800204 	addi	r18,r18,8
811293a4:	8dfff41e 	bne	r17,r23,81129378 <__reset+0xfb109378>
811293a8:	21003fcc 	andi	r4,r4,255
811293ac:	9823883a 	mov	r17,r19
811293b0:	da400a17 	ldw	r9,40(sp)
811293b4:	8027883a 	mov	r19,r16
811293b8:	dc800e17 	ldw	r18,56(sp)
811293bc:	dc000c17 	ldw	r16,48(sp)
811293c0:	2003b11e 	bne	r4,zero,8112a288 <_strtod_r+0x15c8>
811293c4:	981690fa 	slli	r11,r19,3
811293c8:	d8800917 	ldw	r2,36(sp)
811293cc:	01ff2c34 	movhi	r7,64688
811293d0:	900d883a 	mov	r6,r18
811293d4:	12ef883a 	add	r23,r2,r11
811293d8:	b9000017 	ldw	r4,0(r23)
811293dc:	b9400117 	ldw	r5,4(r23)
811293e0:	89cf883a 	add	r7,r17,r7
811293e4:	da401315 	stw	r9,76(sp)
811293e8:	111b57c0 	call	8111b57c <__muldf3>
811293ec:	1025883a 	mov	r18,r2
811293f0:	011f2834 	movhi	r4,31904
811293f4:	189ffc2c 	andhi	r2,r3,32752
811293f8:	da401317 	ldw	r9,76(sp)
811293fc:	20819836 	bltu	r4,r2,81129a60 <_strtod_r+0xda0>
81129400:	011f2434 	movhi	r4,31888
81129404:	2083382e 	bgeu	r4,r2,8112a0e8 <_strtod_r+0x1428>
81129408:	045ffc34 	movhi	r17,32752
8112940c:	8c7fffc4 	addi	r17,r17,-1
81129410:	04bfffc4 	movi	r18,-1
81129414:	d8000915 	stw	zero,36(sp)
81129418:	d9400817 	ldw	r5,32(sp)
8112941c:	df000015 	stw	fp,0(sp)
81129420:	480f883a 	mov	r7,r9
81129424:	b00d883a 	mov	r6,r22
81129428:	8009883a 	mov	r4,r16
8112942c:	11275fc0 	call	811275fc <__s2b>
81129430:	d8800815 	stw	r2,32(sp)
81129434:	10018a26 	beq	r2,zero,81129a60 <_strtod_r+0xda0>
81129438:	a807d7fa 	srai	r3,r21,31
8112943c:	0545c83a 	sub	r2,zero,r21
81129440:	dd400a15 	stw	r21,40(sp)
81129444:	1886703a 	and	r3,r3,r2
81129448:	d8c00c15 	stw	r3,48(sp)
8112944c:	a8013516 	blt	r21,zero,81129924 <_strtod_r+0xc64>
81129450:	d9400817 	ldw	r5,32(sp)
81129454:	0011883a 	mov	r8,zero
81129458:	0027883a 	mov	r19,zero
8112945c:	29400304 	addi	r5,r5,12
81129460:	d9400f15 	stw	r5,60(sp)
81129464:	402b883a 	mov	r21,r8
81129468:	dd001215 	stw	r20,72(sp)
8112946c:	d8800817 	ldw	r2,32(sp)
81129470:	8009883a 	mov	r4,r16
81129474:	11400117 	ldw	r5,4(r2)
81129478:	11273fc0 	call	811273fc <_Balloc>
8112947c:	1029883a 	mov	r20,r2
81129480:	10012d26 	beq	r2,zero,81129938 <_strtod_r+0xc78>
81129484:	d8c00817 	ldw	r3,32(sp)
81129488:	d9400f17 	ldw	r5,60(sp)
8112948c:	11000304 	addi	r4,r2,12
81129490:	19800417 	ldw	r6,16(r3)
81129494:	31800084 	addi	r6,r6,2
81129498:	318d883a 	add	r6,r6,r6
8112949c:	318d883a 	add	r6,r6,r6
811294a0:	111d1cc0 	call	8111d1cc <memcpy>
811294a4:	d9000204 	addi	r4,sp,8
811294a8:	d9000015 	stw	r4,0(sp)
811294ac:	d9c00404 	addi	r7,sp,16
811294b0:	900b883a 	mov	r5,r18
811294b4:	880d883a 	mov	r6,r17
811294b8:	8009883a 	mov	r4,r16
811294bc:	11280d80 	call	811280d8 <__d2b>
811294c0:	d8800515 	stw	r2,20(sp)
811294c4:	dc801115 	stw	r18,68(sp)
811294c8:	dc401015 	stw	r17,64(sp)
811294cc:	10027c26 	beq	r2,zero,81129ec0 <_strtod_r+0x1200>
811294d0:	01400044 	movi	r5,1
811294d4:	8009883a 	mov	r4,r16
811294d8:	11278200 	call	81127820 <__i2b>
811294dc:	1027883a 	mov	r19,r2
811294e0:	10011526 	beq	r2,zero,81129938 <_strtod_r+0xc78>
811294e4:	d8800417 	ldw	r2,16(sp)
811294e8:	1000c816 	blt	r2,zero,8112980c <_strtod_r+0xb4c>
811294ec:	d9400c17 	ldw	r5,48(sp)
811294f0:	d9000a17 	ldw	r4,40(sp)
811294f4:	28ad883a 	add	r22,r5,r2
811294f8:	d9400917 	ldw	r5,36(sp)
811294fc:	df000217 	ldw	fp,8(sp)
81129500:	05ff0084 	movi	r23,-1022
81129504:	1147c83a 	sub	r3,r2,r5
81129508:	1f07883a 	add	r3,r3,fp
8112950c:	00800d84 	movi	r2,54
81129510:	18ffffc4 	addi	r3,r3,-1
81129514:	1739c83a 	sub	fp,r2,fp
81129518:	1dc0a50e 	bge	r3,r23,811297b0 <_strtod_r+0xaf0>
8112951c:	b8efc83a 	sub	r23,r23,r3
81129520:	008007c4 	movi	r2,31
81129524:	e5f9c83a 	sub	fp,fp,r23
81129528:	15c0bc16 	blt	r2,r23,8112981c <_strtod_r+0xb5c>
8112952c:	00800044 	movi	r2,1
81129530:	15c4983a 	sll	r2,r2,r23
81129534:	d8000b15 	stw	zero,44(sp)
81129538:	d8800d15 	stw	r2,52(sp)
8112953c:	2707883a 	add	r3,r4,fp
81129540:	d9000917 	ldw	r4,36(sp)
81129544:	b739883a 	add	fp,r22,fp
81129548:	20ef883a 	add	r23,r4,r3
8112954c:	b009883a 	mov	r4,r22
81129550:	e580010e 	bge	fp,r22,81129558 <_strtod_r+0x898>
81129554:	e009883a 	mov	r4,fp
81129558:	b805883a 	mov	r2,r23
8112955c:	25c0010e 	bge	r4,r23,81129564 <_strtod_r+0x8a4>
81129560:	2005883a 	mov	r2,r4
81129564:	0080030e 	bge	zero,r2,81129574 <_strtod_r+0x8b4>
81129568:	e0b9c83a 	sub	fp,fp,r2
8112956c:	b8afc83a 	sub	r23,r23,r2
81129570:	b0adc83a 	sub	r22,r22,r2
81129574:	d9400c17 	ldw	r5,48(sp)
81129578:	28001126 	beq	r5,zero,811295c0 <_strtod_r+0x900>
8112957c:	280d883a 	mov	r6,r5
81129580:	8009883a 	mov	r4,r16
81129584:	980b883a 	mov	r5,r19
81129588:	1127a640 	call	81127a64 <__pow5mult>
8112958c:	1027883a 	mov	r19,r2
81129590:	1000e926 	beq	r2,zero,81129938 <_strtod_r+0xc78>
81129594:	d9800517 	ldw	r6,20(sp)
81129598:	100b883a 	mov	r5,r2
8112959c:	8009883a 	mov	r4,r16
811295a0:	11278640 	call	81127864 <__multiply>
811295a4:	1000e426 	beq	r2,zero,81129938 <_strtod_r+0xc78>
811295a8:	d9400517 	ldw	r5,20(sp)
811295ac:	8009883a 	mov	r4,r16
811295b0:	d8801315 	stw	r2,76(sp)
811295b4:	11274ac0 	call	811274ac <_Bfree>
811295b8:	d8801317 	ldw	r2,76(sp)
811295bc:	d8800515 	stw	r2,20(sp)
811295c0:	0700060e 	bge	zero,fp,811295dc <_strtod_r+0x91c>
811295c4:	d9400517 	ldw	r5,20(sp)
811295c8:	e00d883a 	mov	r6,fp
811295cc:	8009883a 	mov	r4,r16
811295d0:	1127bac0 	call	81127bac <__lshift>
811295d4:	d8800515 	stw	r2,20(sp)
811295d8:	10023926 	beq	r2,zero,81129ec0 <_strtod_r+0x1200>
811295dc:	d8800a17 	ldw	r2,40(sp)
811295e0:	10000626 	beq	r2,zero,811295fc <_strtod_r+0x93c>
811295e4:	d9800a17 	ldw	r6,40(sp)
811295e8:	a00b883a 	mov	r5,r20
811295ec:	8009883a 	mov	r4,r16
811295f0:	1127a640 	call	81127a64 <__pow5mult>
811295f4:	1029883a 	mov	r20,r2
811295f8:	1000cf26 	beq	r2,zero,81129938 <_strtod_r+0xc78>
811295fc:	05c0060e 	bge	zero,r23,81129618 <_strtod_r+0x958>
81129600:	a00b883a 	mov	r5,r20
81129604:	b80d883a 	mov	r6,r23
81129608:	8009883a 	mov	r4,r16
8112960c:	1127bac0 	call	81127bac <__lshift>
81129610:	1029883a 	mov	r20,r2
81129614:	1000c826 	beq	r2,zero,81129938 <_strtod_r+0xc78>
81129618:	0580060e 	bge	zero,r22,81129634 <_strtod_r+0x974>
8112961c:	980b883a 	mov	r5,r19
81129620:	b00d883a 	mov	r6,r22
81129624:	8009883a 	mov	r4,r16
81129628:	1127bac0 	call	81127bac <__lshift>
8112962c:	1027883a 	mov	r19,r2
81129630:	1000c126 	beq	r2,zero,81129938 <_strtod_r+0xc78>
81129634:	d9400517 	ldw	r5,20(sp)
81129638:	a00d883a 	mov	r6,r20
8112963c:	8009883a 	mov	r4,r16
81129640:	1127d5c0 	call	81127d5c <__mdiff>
81129644:	102b883a 	mov	r21,r2
81129648:	1000bb26 	beq	r2,zero,81129938 <_strtod_r+0xc78>
8112964c:	10c00317 	ldw	r3,12(r2)
81129650:	980b883a 	mov	r5,r19
81129654:	10000315 	stw	zero,12(r2)
81129658:	1009883a 	mov	r4,r2
8112965c:	d8c00e15 	stw	r3,56(sp)
81129660:	1127cfc0 	call	81127cfc <__mcmp>
81129664:	10027616 	blt	r2,zero,8112a040 <_strtod_r+0x1380>
81129668:	10024426 	beq	r2,zero,81129f7c <_strtod_r+0x12bc>
8112966c:	980b883a 	mov	r5,r19
81129670:	a809883a 	mov	r4,r21
81129674:	112822c0 	call	8112822c <__ratio>
81129678:	000d883a 	mov	r6,zero
8112967c:	01d00034 	movhi	r7,16384
81129680:	1009883a 	mov	r4,r2
81129684:	180b883a 	mov	r5,r3
81129688:	102f883a 	mov	r23,r2
8112968c:	182d883a 	mov	r22,r3
81129690:	1130d740 	call	81130d74 <__ledf2>
81129694:	00804a16 	blt	zero,r2,811297c0 <_strtod_r+0xb00>
81129698:	d9400e17 	ldw	r5,56(sp)
8112969c:	28006b26 	beq	r5,zero,8112984c <_strtod_r+0xb8c>
811296a0:	058ffc34 	movhi	r22,16368
811296a4:	d8000b15 	stw	zero,44(sp)
811296a8:	d8000d15 	stw	zero,52(sp)
811296ac:	b02f883a 	mov	r23,r22
811296b0:	8f1ffc2c 	andhi	fp,r17,32752
811296b4:	009ff834 	movhi	r2,32736
811296b8:	e080cd26 	beq	fp,r2,811299f0 <_strtod_r+0xd30>
811296bc:	d9400917 	ldw	r5,36(sp)
811296c0:	28001a26 	beq	r5,zero,8112972c <_strtod_r+0xa6c>
811296c4:	0081a834 	movhi	r2,1696
811296c8:	17001836 	bltu	r2,fp,8112972c <_strtod_r+0xa6c>
811296cc:	d9000d17 	ldw	r4,52(sp)
811296d0:	01d07834 	movhi	r7,16864
811296d4:	39ffffc4 	addi	r7,r7,-1
811296d8:	01bff034 	movhi	r6,65472
811296dc:	b80b883a 	mov	r5,r23
811296e0:	1130d740 	call	81130d74 <__ledf2>
811296e4:	00800e16 	blt	zero,r2,81129720 <_strtod_r+0xa60>
811296e8:	d9000d17 	ldw	r4,52(sp)
811296ec:	b80b883a 	mov	r5,r23
811296f0:	112eb800 	call	8112eb80 <__fixunsdfsi>
811296f4:	10018126 	beq	r2,zero,81129cfc <_strtod_r+0x103c>
811296f8:	1009883a 	mov	r4,r2
811296fc:	11318d00 	call	811318d0 <__floatunsidf>
81129700:	d8800d15 	stw	r2,52(sp)
81129704:	182f883a 	mov	r23,r3
81129708:	d8800e17 	ldw	r2,56(sp)
8112970c:	1001791e 	bne	r2,zero,81129cf4 <_strtod_r+0x1034>
81129710:	ba20003c 	xorhi	r8,r23,32768
81129714:	d8c00d17 	ldw	r3,52(sp)
81129718:	402d883a 	mov	r22,r8
8112971c:	d8c00b15 	stw	r3,44(sp)
81129720:	0081ac34 	movhi	r2,1712
81129724:	b091883a 	add	r8,r22,r2
81129728:	472dc83a 	sub	r22,r8,fp
8112972c:	9009883a 	mov	r4,r18
81129730:	880b883a 	mov	r5,r17
81129734:	1127f600 	call	81127f60 <__ulp>
81129738:	d9000b17 	ldw	r4,44(sp)
8112973c:	b00b883a 	mov	r5,r22
81129740:	100d883a 	mov	r6,r2
81129744:	180f883a 	mov	r7,r3
81129748:	111b57c0 	call	8111b57c <__muldf3>
8112974c:	900d883a 	mov	r6,r18
81129750:	880f883a 	mov	r7,r17
81129754:	1009883a 	mov	r4,r2
81129758:	180b883a 	mov	r5,r3
8112975c:	112fa6c0 	call	8112fa6c <__adddf3>
81129760:	1025883a 	mov	r18,r2
81129764:	1823883a 	mov	r17,r3
81129768:	182d883a 	mov	r22,r3
8112976c:	d9000917 	ldw	r4,36(sp)
81129770:	2000021e 	bne	r4,zero,8112977c <_strtod_r+0xabc>
81129774:	b09ffc2c 	andhi	r2,r22,32752
81129778:	e080be26 	beq	fp,r2,81129a74 <_strtod_r+0xdb4>
8112977c:	d9400517 	ldw	r5,20(sp)
81129780:	8009883a 	mov	r4,r16
81129784:	11274ac0 	call	811274ac <_Bfree>
81129788:	a00b883a 	mov	r5,r20
8112978c:	8009883a 	mov	r4,r16
81129790:	11274ac0 	call	811274ac <_Bfree>
81129794:	980b883a 	mov	r5,r19
81129798:	8009883a 	mov	r4,r16
8112979c:	11274ac0 	call	811274ac <_Bfree>
811297a0:	a80b883a 	mov	r5,r21
811297a4:	8009883a 	mov	r4,r16
811297a8:	11274ac0 	call	811274ac <_Bfree>
811297ac:	003f2f06 	br	8112946c <__reset+0xfb10946c>
811297b0:	00c00044 	movi	r3,1
811297b4:	d8000b15 	stw	zero,44(sp)
811297b8:	d8c00d15 	stw	r3,52(sp)
811297bc:	003f5f06 	br	8112953c <__reset+0xfb10953c>
811297c0:	b809883a 	mov	r4,r23
811297c4:	000d883a 	mov	r6,zero
811297c8:	01cff834 	movhi	r7,16352
811297cc:	b00b883a 	mov	r5,r22
811297d0:	111b57c0 	call	8111b57c <__muldf3>
811297d4:	d9000e17 	ldw	r4,56(sp)
811297d8:	d8800d15 	stw	r2,52(sp)
811297dc:	182f883a 	mov	r23,r3
811297e0:	2000181e 	bne	r4,zero,81129844 <_strtod_r+0xb84>
811297e4:	1a20003c 	xorhi	r8,r3,32768
811297e8:	d8800b15 	stw	r2,44(sp)
811297ec:	402d883a 	mov	r22,r8
811297f0:	003faf06 	br	811296b0 <__reset+0xfb1096b0>
811297f4:	0015883a 	mov	r10,zero
811297f8:	02c00044 	movi	r11,1
811297fc:	2800011e 	bne	r5,zero,81129804 <_strtod_r+0xb44>
81129800:	903d7e26 	beq	r18,zero,81128dfc <__reset+0xfb108dfc>
81129804:	0013883a 	mov	r9,zero
81129808:	003e4706 	br	81129128 <__reset+0xfb109128>
8112980c:	d8c00a17 	ldw	r3,40(sp)
81129810:	dd800c17 	ldw	r22,48(sp)
81129814:	1889c83a 	sub	r4,r3,r2
81129818:	003f3706 	br	811294f8 <__reset+0xfb1094f8>
8112981c:	00bef884 	movi	r2,-1054
81129820:	05c00044 	movi	r23,1
81129824:	10c5c83a 	sub	r2,r2,r3
81129828:	b884983a 	sll	r2,r23,r2
8112982c:	ddc00d15 	stw	r23,52(sp)
81129830:	d8800b15 	stw	r2,44(sp)
81129834:	003f4106 	br	8112953c <__reset+0xfb10953c>
81129838:	ddc00615 	stw	r23,24(sp)
8112983c:	002b883a 	mov	r21,zero
81129840:	003dc306 	br	81128f50 <__reset+0xfb108f50>
81129844:	1811883a 	mov	r8,r3
81129848:	003fe706 	br	811297e8 <__reset+0xfb1097e8>
8112984c:	90002e1e 	bne	r18,zero,81129908 <_strtod_r+0xc48>
81129850:	00c00434 	movhi	r3,16
81129854:	18ffffc4 	addi	r3,r3,-1
81129858:	88c4703a 	and	r2,r17,r3
8112985c:	10002c1e 	bne	r2,zero,81129910 <_strtod_r+0xc50>
81129860:	000d883a 	mov	r6,zero
81129864:	01cffc34 	movhi	r7,16368
81129868:	b809883a 	mov	r4,r23
8112986c:	b00b883a 	mov	r5,r22
81129870:	1130d740 	call	81130d74 <__ledf2>
81129874:	10021716 	blt	r2,zero,8112a0d4 <_strtod_r+0x1414>
81129878:	b809883a 	mov	r4,r23
8112987c:	b00b883a 	mov	r5,r22
81129880:	000d883a 	mov	r6,zero
81129884:	01cff834 	movhi	r7,16352
81129888:	111b57c0 	call	8111b57c <__muldf3>
8112988c:	d8800d15 	stw	r2,52(sp)
81129890:	182f883a 	mov	r23,r3
81129894:	102d883a 	mov	r22,r2
81129898:	1a20003c 	xorhi	r8,r3,32768
8112989c:	dd800b15 	stw	r22,44(sp)
811298a0:	402d883a 	mov	r22,r8
811298a4:	003f8206 	br	811296b0 <__reset+0xfb1096b0>
811298a8:	b013883a 	mov	r9,r22
811298ac:	000b883a 	mov	r5,zero
811298b0:	0015883a 	mov	r10,zero
811298b4:	893ff404 	addi	r4,r17,-48
811298b8:	00800244 	movi	r2,9
811298bc:	11001036 	bltu	r2,r4,81129900 <_strtod_r+0xc40>
811298c0:	28c00044 	addi	r3,r5,1
811298c4:	2023883a 	mov	r17,r4
811298c8:	20014d1e 	bne	r4,zero,81129e00 <_strtod_r+0x1140>
811298cc:	d9800617 	ldw	r6,24(sp)
811298d0:	180b883a 	mov	r5,r3
811298d4:	30800044 	addi	r2,r6,1
811298d8:	d8800615 	stw	r2,24(sp)
811298dc:	34400047 	ldb	r17,1(r6)
811298e0:	003ff406 	br	811298b4 <__reset+0xfb1098b4>
811298e4:	0019883a 	mov	r12,zero
811298e8:	b8800084 	addi	r2,r23,2
811298ec:	d8800615 	stw	r2,24(sp)
811298f0:	bc400087 	ldb	r17,2(r23)
811298f4:	003e1606 	br	81129150 <__reset+0xfb109150>
811298f8:	03000044 	movi	r12,1
811298fc:	003ffa06 	br	811298e8 <__reset+0xfb1098e8>
81129900:	02c00044 	movi	r11,1
81129904:	003d8d06 	br	81128f3c <__reset+0xfb108f3c>
81129908:	00800044 	movi	r2,1
8112990c:	9080fe26 	beq	r18,r2,81129d08 <_strtod_r+0x1048>
81129910:	d8000b15 	stw	zero,44(sp)
81129914:	05affc34 	movhi	r22,49136
81129918:	d8000d15 	stw	zero,52(sp)
8112991c:	05cffc34 	movhi	r23,16368
81129920:	003f6306 	br	811296b0 <__reset+0xfb1096b0>
81129924:	d8000a15 	stw	zero,40(sp)
81129928:	003ec906 	br	81129450 <__reset+0xfb109450>
8112992c:	d9001117 	ldw	r4,68(sp)
81129930:	00bfffc4 	movi	r2,-1
81129934:	2080461e 	bne	r4,r2,81129a50 <_strtod_r+0xd90>
81129938:	dd000a15 	stw	r20,40(sp)
8112993c:	dd001217 	ldw	r20,72(sp)
81129940:	a811883a 	mov	r8,r21
81129944:	d8800517 	ldw	r2,20(sp)
81129948:	00c00884 	movi	r3,34
8112994c:	80c00015 	stw	r3,0(r16)
81129950:	002b883a 	mov	r21,zero
81129954:	059ffc34 	movhi	r22,32752
81129958:	100b883a 	mov	r5,r2
8112995c:	8009883a 	mov	r4,r16
81129960:	da001315 	stw	r8,76(sp)
81129964:	11274ac0 	call	811274ac <_Bfree>
81129968:	d9400a17 	ldw	r5,40(sp)
8112996c:	8009883a 	mov	r4,r16
81129970:	11274ac0 	call	811274ac <_Bfree>
81129974:	980b883a 	mov	r5,r19
81129978:	8009883a 	mov	r4,r16
8112997c:	11274ac0 	call	811274ac <_Bfree>
81129980:	d9400817 	ldw	r5,32(sp)
81129984:	8009883a 	mov	r4,r16
81129988:	11274ac0 	call	811274ac <_Bfree>
8112998c:	da001317 	ldw	r8,76(sp)
81129990:	8009883a 	mov	r4,r16
81129994:	400b883a 	mov	r5,r8
81129998:	11274ac0 	call	811274ac <_Bfree>
8112999c:	003d9206 	br	81128fe8 <__reset+0xfb108fe8>
811299a0:	d8c00717 	ldw	r3,28(sp)
811299a4:	d8800504 	addi	r2,sp,20
811299a8:	01a04574 	movhi	r6,33045
811299ac:	31ae8204 	addi	r6,r6,-17912
811299b0:	d8c00115 	stw	r3,4(sp)
811299b4:	d8800015 	stw	r2,0(sp)
811299b8:	d9c00404 	addi	r7,sp,16
811299bc:	d9400604 	addi	r5,sp,24
811299c0:	8009883a 	mov	r4,r16
811299c4:	112de140 	call	8112de14 <__gethex>
811299c8:	154001cc 	andi	r21,r2,7
811299cc:	a83d9b26 	beq	r21,zero,8112903c <__reset+0xfb10903c>
811299d0:	00c00184 	movi	r3,6
811299d4:	a8c0d61e 	bne	r21,r3,81129d30 <_strtod_r+0x1070>
811299d8:	9cc00044 	addi	r19,r19,1
811299dc:	dcc00615 	stw	r19,24(sp)
811299e0:	002b883a 	mov	r21,zero
811299e4:	002d883a 	mov	r22,zero
811299e8:	d8000715 	stw	zero,28(sp)
811299ec:	003d7e06 	br	81128fe8 <__reset+0xfb108fe8>
811299f0:	00bf2c34 	movhi	r2,64688
811299f4:	88a3883a 	add	r17,r17,r2
811299f8:	9009883a 	mov	r4,r18
811299fc:	880b883a 	mov	r5,r17
81129a00:	1127f600 	call	81127f60 <__ulp>
81129a04:	d9000b17 	ldw	r4,44(sp)
81129a08:	100d883a 	mov	r6,r2
81129a0c:	180f883a 	mov	r7,r3
81129a10:	b00b883a 	mov	r5,r22
81129a14:	111b57c0 	call	8111b57c <__muldf3>
81129a18:	900d883a 	mov	r6,r18
81129a1c:	180b883a 	mov	r5,r3
81129a20:	880f883a 	mov	r7,r17
81129a24:	1009883a 	mov	r4,r2
81129a28:	112fa6c0 	call	8112fa6c <__adddf3>
81129a2c:	015f2834 	movhi	r5,31904
81129a30:	1025883a 	mov	r18,r2
81129a34:	297fffc4 	addi	r5,r5,-1
81129a38:	189ffc2c 	andhi	r2,r3,32752
81129a3c:	2880892e 	bgeu	r5,r2,81129c64 <_strtod_r+0xfa4>
81129a40:	d8801017 	ldw	r2,64(sp)
81129a44:	00dffc34 	movhi	r3,32752
81129a48:	18ffffc4 	addi	r3,r3,-1
81129a4c:	10ffb726 	beq	r2,r3,8112992c <__reset+0xfb10992c>
81129a50:	045ffc34 	movhi	r17,32752
81129a54:	8c7fffc4 	addi	r17,r17,-1
81129a58:	04bfffc4 	movi	r18,-1
81129a5c:	003f4706 	br	8112977c <__reset+0xfb10977c>
81129a60:	00800884 	movi	r2,34
81129a64:	80800015 	stw	r2,0(r16)
81129a68:	002b883a 	mov	r21,zero
81129a6c:	059ffc34 	movhi	r22,32752
81129a70:	003d5d06 	br	81128fe8 <__reset+0xfb108fe8>
81129a74:	d9000d17 	ldw	r4,52(sp)
81129a78:	b80b883a 	mov	r5,r23
81129a7c:	113176c0 	call	8113176c <__fixdfsi>
81129a80:	1009883a 	mov	r4,r2
81129a84:	11317ec0 	call	811317ec <__floatsidf>
81129a88:	d9000d17 	ldw	r4,52(sp)
81129a8c:	b80b883a 	mov	r5,r23
81129a90:	100d883a 	mov	r6,r2
81129a94:	180f883a 	mov	r7,r3
81129a98:	1130e680 	call	81130e68 <__subdf3>
81129a9c:	d9400e17 	ldw	r5,56(sp)
81129aa0:	1039883a 	mov	fp,r2
81129aa4:	182f883a 	mov	r23,r3
81129aa8:	2800141e 	bne	r5,zero,81129afc <_strtod_r+0xe3c>
81129aac:	9000131e 	bne	r18,zero,81129afc <_strtod_r+0xe3c>
81129ab0:	00800434 	movhi	r2,16
81129ab4:	10bfffc4 	addi	r2,r2,-1
81129ab8:	b0ac703a 	and	r22,r22,r2
81129abc:	b0000f1e 	bne	r22,zero,81129afc <_strtod_r+0xe3c>
81129ac0:	01a52834 	movhi	r6,38048
81129ac4:	01cff434 	movhi	r7,16336
81129ac8:	318d6544 	addi	r6,r6,13717
81129acc:	39ffffc4 	addi	r7,r7,-1
81129ad0:	e009883a 	mov	r4,fp
81129ad4:	180b883a 	mov	r5,r3
81129ad8:	1130d740 	call	81130d74 <__ledf2>
81129adc:	103f270e 	bge	r2,zero,8112977c <__reset+0xfb10977c>
81129ae0:	dd000a15 	stw	r20,40(sp)
81129ae4:	a811883a 	mov	r8,r21
81129ae8:	dd001217 	ldw	r20,72(sp)
81129aec:	d8800517 	ldw	r2,20(sp)
81129af0:	002b883a 	mov	r21,zero
81129af4:	882d883a 	mov	r22,r17
81129af8:	003f9706 	br	81129958 <__reset+0xfb109958>
81129afc:	01a52834 	movhi	r6,38048
81129b00:	01cff834 	movhi	r7,16352
81129b04:	318d6544 	addi	r6,r6,13717
81129b08:	39ffffc4 	addi	r7,r7,-1
81129b0c:	e009883a 	mov	r4,fp
81129b10:	b80b883a 	mov	r5,r23
81129b14:	1130d740 	call	81130d74 <__ledf2>
81129b18:	10000716 	blt	r2,zero,81129b38 <_strtod_r+0xe78>
81129b1c:	018d6c34 	movhi	r6,13744
81129b20:	31b94d44 	addi	r6,r6,-6859
81129b24:	01cff834 	movhi	r7,16352
81129b28:	e009883a 	mov	r4,fp
81129b2c:	b80b883a 	mov	r5,r23
81129b30:	1130c980 	call	81130c98 <__gedf2>
81129b34:	00bf110e 	bge	zero,r2,8112977c <__reset+0xfb10977c>
81129b38:	dd000a15 	stw	r20,40(sp)
81129b3c:	a811883a 	mov	r8,r21
81129b40:	dd001217 	ldw	r20,72(sp)
81129b44:	d8800517 	ldw	r2,20(sp)
81129b48:	902b883a 	mov	r21,r18
81129b4c:	882d883a 	mov	r22,r17
81129b50:	003f8106 	br	81129958 <__reset+0xfb109958>
81129b54:	b83e2f26 	beq	r23,zero,81129414 <__reset+0xfb109414>
81129b58:	05efc83a 	sub	r23,zero,r23
81129b5c:	b88003cc 	andi	r2,r23,15
81129b60:	10000d26 	beq	r2,zero,81129b98 <_strtod_r+0xed8>
81129b64:	100490fa 	slli	r2,r2,3
81129b68:	00e04574 	movhi	r3,33045
81129b6c:	18ee4704 	addi	r3,r3,-18148
81129b70:	1885883a 	add	r2,r3,r2
81129b74:	11800017 	ldw	r6,0(r2)
81129b78:	11c00117 	ldw	r7,4(r2)
81129b7c:	9009883a 	mov	r4,r18
81129b80:	880b883a 	mov	r5,r17
81129b84:	da401315 	stw	r9,76(sp)
81129b88:	11303200 	call	81130320 <__divdf3>
81129b8c:	da401317 	ldw	r9,76(sp)
81129b90:	1025883a 	mov	r18,r2
81129b94:	1823883a 	mov	r17,r3
81129b98:	b82fd13a 	srai	r23,r23,4
81129b9c:	b83e1d26 	beq	r23,zero,81129414 <__reset+0xfb109414>
81129ba0:	008007c4 	movi	r2,31
81129ba4:	15c02816 	blt	r2,r23,81129c48 <_strtod_r+0xf88>
81129ba8:	b880040c 	andi	r2,r23,16
81129bac:	10019726 	beq	r2,zero,8112a20c <_strtod_r+0x154c>
81129bb0:	05c1880e 	bge	zero,r23,8112a1d4 <_strtod_r+0x1514>
81129bb4:	00c01a84 	movi	r3,106
81129bb8:	d8c00915 	stw	r3,36(sp)
81129bbc:	04e04574 	movhi	r19,33045
81129bc0:	9cee8704 	addi	r19,r19,-17892
81129bc4:	8807883a 	mov	r3,r17
81129bc8:	9005883a 	mov	r2,r18
81129bcc:	8023883a 	mov	r17,r16
81129bd0:	0009883a 	mov	r4,zero
81129bd4:	9821883a 	mov	r16,r19
81129bd8:	da400a15 	stw	r9,40(sp)
81129bdc:	1827883a 	mov	r19,r3
81129be0:	b980004c 	andi	r6,r23,1
81129be4:	30000626 	beq	r6,zero,81129c00 <_strtod_r+0xf40>
81129be8:	81800017 	ldw	r6,0(r16)
81129bec:	81c00117 	ldw	r7,4(r16)
81129bf0:	1009883a 	mov	r4,r2
81129bf4:	180b883a 	mov	r5,r3
81129bf8:	111b57c0 	call	8111b57c <__muldf3>
81129bfc:	01000044 	movi	r4,1
81129c00:	b82fd07a 	srai	r23,r23,1
81129c04:	84000204 	addi	r16,r16,8
81129c08:	b83ff51e 	bne	r23,zero,81129be0 <__reset+0xfb109be0>
81129c0c:	21003fcc 	andi	r4,r4,255
81129c10:	8821883a 	mov	r16,r17
81129c14:	da400a17 	ldw	r9,40(sp)
81129c18:	9823883a 	mov	r17,r19
81129c1c:	2001a51e 	bne	r4,zero,8112a2b4 <_strtod_r+0x15f4>
81129c20:	d9000917 	ldw	r4,36(sp)
81129c24:	20016d1e 	bne	r4,zero,8112a1dc <_strtod_r+0x151c>
81129c28:	000d883a 	mov	r6,zero
81129c2c:	000f883a 	mov	r7,zero
81129c30:	9009883a 	mov	r4,r18
81129c34:	880b883a 	mov	r5,r17
81129c38:	da401315 	stw	r9,76(sp)
81129c3c:	1130c100 	call	81130c10 <__eqdf2>
81129c40:	da401317 	ldw	r9,76(sp)
81129c44:	103df41e 	bne	r2,zero,81129418 <__reset+0xfb109418>
81129c48:	00800884 	movi	r2,34
81129c4c:	80800015 	stw	r2,0(r16)
81129c50:	002b883a 	mov	r21,zero
81129c54:	002d883a 	mov	r22,zero
81129c58:	003ce306 	br	81128fe8 <__reset+0xfb108fe8>
81129c5c:	055387c4 	movi	r21,19999
81129c60:	003d6b06 	br	81129210 <__reset+0xfb109210>
81129c64:	0440d434 	movhi	r17,848
81129c68:	1c63883a 	add	r17,r3,r17
81129c6c:	882d883a 	mov	r22,r17
81129c70:	003ebe06 	br	8112976c <__reset+0xfb10976c>
81129c74:	14403fcc 	andi	r17,r2,255
81129c78:	8c40201c 	xori	r17,r17,128
81129c7c:	8c7fe004 	addi	r17,r17,-128
81129c80:	dd400817 	ldw	r21,32(sp)
81129c84:	0027883a 	mov	r19,zero
81129c88:	0039883a 	mov	fp,zero
81129c8c:	002d883a 	mov	r22,zero
81129c90:	003c9906 	br	81128ef8 <__reset+0xfb108ef8>
81129c94:	00c00944 	movi	r3,37
81129c98:	1a47c83a 	sub	r3,r3,r9
81129c9c:	1d7d8c16 	blt	r3,r21,811292d0 <__reset+0xfb1092d0>
81129ca0:	1261c83a 	sub	r16,r2,r9
81129ca4:	800490fa 	slli	r2,r16,3
81129ca8:	04e04574 	movhi	r19,33045
81129cac:	9cee4704 	addi	r19,r19,-18148
81129cb0:	9885883a 	add	r2,r19,r2
81129cb4:	11000017 	ldw	r4,0(r2)
81129cb8:	11400117 	ldw	r5,4(r2)
81129cbc:	900d883a 	mov	r6,r18
81129cc0:	880f883a 	mov	r7,r17
81129cc4:	111b57c0 	call	8111b57c <__muldf3>
81129cc8:	ac0dc83a 	sub	r6,r21,r16
81129ccc:	300c90fa 	slli	r6,r6,3
81129cd0:	1009883a 	mov	r4,r2
81129cd4:	180b883a 	mov	r5,r3
81129cd8:	9985883a 	add	r2,r19,r6
81129cdc:	11800017 	ldw	r6,0(r2)
81129ce0:	11c00117 	ldw	r7,4(r2)
81129ce4:	111b57c0 	call	8111b57c <__muldf3>
81129ce8:	102b883a 	mov	r21,r2
81129cec:	182d883a 	mov	r22,r3
81129cf0:	003cbd06 	br	81128fe8 <__reset+0xfb108fe8>
81129cf4:	b811883a 	mov	r8,r23
81129cf8:	003e8606 	br	81129714 <__reset+0xfb109714>
81129cfc:	d8000d15 	stw	zero,52(sp)
81129d00:	05cffc34 	movhi	r23,16368
81129d04:	003e8006 	br	81129708 <__reset+0xfb109708>
81129d08:	883f011e 	bne	r17,zero,81129910 <__reset+0xfb109910>
81129d0c:	dd000a15 	stw	r20,40(sp)
81129d10:	dd001217 	ldw	r20,72(sp)
81129d14:	a811883a 	mov	r8,r21
81129d18:	00800884 	movi	r2,34
81129d1c:	80800015 	stw	r2,0(r16)
81129d20:	002b883a 	mov	r21,zero
81129d24:	d8800517 	ldw	r2,20(sp)
81129d28:	002d883a 	mov	r22,zero
81129d2c:	003f0a06 	br	81129958 <__reset+0xfb109958>
81129d30:	d9800517 	ldw	r6,20(sp)
81129d34:	30000826 	beq	r6,zero,81129d58 <_strtod_r+0x1098>
81129d38:	01400d44 	movi	r5,53
81129d3c:	d9000204 	addi	r4,sp,8
81129d40:	d8801315 	stw	r2,76(sp)
81129d44:	11283540 	call	81128354 <__copybits>
81129d48:	d9400517 	ldw	r5,20(sp)
81129d4c:	8009883a 	mov	r4,r16
81129d50:	11274ac0 	call	811274ac <_Bfree>
81129d54:	d8801317 	ldw	r2,76(sp)
81129d58:	00c00184 	movi	r3,6
81129d5c:	1d400f36 	bltu	r3,r21,81129d9c <_strtod_r+0x10dc>
81129d60:	a82a90ba 	slli	r21,r21,2
81129d64:	00e044f4 	movhi	r3,33043
81129d68:	18e75e04 	addi	r3,r3,-25224
81129d6c:	a8eb883a 	add	r21,r21,r3
81129d70:	a8c00017 	ldw	r3,0(r21)
81129d74:	1800683a 	jmp	r3
81129d78:	81129df4 	orhi	r4,r16,19063
81129d7c:	81129dcc 	andi	r4,r16,19063
81129d80:	81129db0 	cmpltui	r4,r16,19062
81129d84:	81129d94 	ori	r4,r16,19062
81129d88:	81129dbc 	xorhi	r4,r16,19062
81129d8c:	81129dcc 	andi	r4,r16,19063
81129d90:	81129df4 	orhi	r4,r16,19063
81129d94:	045ffc34 	movhi	r17,32752
81129d98:	0025883a 	mov	r18,zero
81129d9c:	1080020c 	andi	r2,r2,8
81129da0:	902b883a 	mov	r21,r18
81129da4:	103c8f26 	beq	r2,zero,81128fe4 <__reset+0xfb108fe4>
81129da8:	8da00034 	orhi	r22,r17,32768
81129dac:	003c8e06 	br	81128fe8 <__reset+0xfb108fe8>
81129db0:	dc800217 	ldw	r18,8(sp)
81129db4:	dc400317 	ldw	r17,12(sp)
81129db8:	003ff806 	br	81129d9c <__reset+0xfb109d9c>
81129dbc:	04600034 	movhi	r17,32768
81129dc0:	8c7fffc4 	addi	r17,r17,-1
81129dc4:	04bfffc4 	movi	r18,-1
81129dc8:	003ff406 	br	81129d9c <__reset+0xfb109d9c>
81129dcc:	d8c00417 	ldw	r3,16(sp)
81129dd0:	dc400317 	ldw	r17,12(sp)
81129dd4:	013ffc34 	movhi	r4,65520
81129dd8:	18c10cc4 	addi	r3,r3,1075
81129ddc:	1806953a 	slli	r3,r3,20
81129de0:	213fffc4 	addi	r4,r4,-1
81129de4:	8922703a 	and	r17,r17,r4
81129de8:	dc800217 	ldw	r18,8(sp)
81129dec:	88e2b03a 	or	r17,r17,r3
81129df0:	003fea06 	br	81129d9c <__reset+0xfb109d9c>
81129df4:	0023883a 	mov	r17,zero
81129df8:	0025883a 	mov	r18,zero
81129dfc:	003fe706 	br	81129d9c <__reset+0xfb109d9c>
81129e00:	01800044 	movi	r6,1
81129e04:	50d5883a 	add	r10,r10,r3
81129e08:	2a4b883a 	add	r5,r5,r9
81129e0c:	19811a26 	beq	r3,r6,8112a278 <_strtod_r+0x15b8>
81129e10:	01800204 	movi	r6,8
81129e14:	01c00404 	movi	r7,16
81129e18:	4a400044 	addi	r9,r9,1
81129e1c:	48bfffc4 	addi	r2,r9,-1
81129e20:	30801616 	blt	r6,r2,81129e7c <_strtod_r+0x11bc>
81129e24:	e70002a4 	muli	fp,fp,10
81129e28:	497ffb1e 	bne	r9,r5,81129e18 <__reset+0xfb109e18>
81129e2c:	d9800617 	ldw	r6,24(sp)
81129e30:	4a400044 	addi	r9,r9,1
81129e34:	00c00204 	movi	r3,8
81129e38:	19400c0e 	bge	r3,r5,81129e6c <_strtod_r+0x11ac>
81129e3c:	00800404 	movi	r2,16
81129e40:	000b883a 	mov	r5,zero
81129e44:	127ea316 	blt	r2,r9,811298d4 <__reset+0xfb1098d4>
81129e48:	988002a4 	muli	r2,r19,10
81129e4c:	20a7883a 	add	r19,r4,r2
81129e50:	003ea006 	br	811298d4 <__reset+0xfb1098d4>
81129e54:	d8800617 	ldw	r2,24(sp)
81129e58:	8c7ff404 	addi	r17,r17,-48
81129e5c:	2a800044 	addi	r10,r5,1
81129e60:	d8800815 	stw	r2,32(sp)
81129e64:	100d883a 	mov	r6,r2
81129e68:	02400044 	movi	r9,1
81129e6c:	e08002a4 	muli	r2,fp,10
81129e70:	000b883a 	mov	r5,zero
81129e74:	88b9883a 	add	fp,r17,r2
81129e78:	003e9606 	br	811298d4 <__reset+0xfb1098d4>
81129e7c:	3a7fea16 	blt	r7,r9,81129e28 <__reset+0xfb109e28>
81129e80:	9cc002a4 	muli	r19,r19,10
81129e84:	003fe806 	br	81129e28 <__reset+0xfb109e28>
81129e88:	00bffa84 	movi	r2,-22
81129e8c:	a8bd1016 	blt	r21,r2,811292d0 <__reset+0xfb1092d0>
81129e90:	a82a90fa 	slli	r21,r21,3
81129e94:	00a04574 	movhi	r2,33045
81129e98:	10ae4704 	addi	r2,r2,-18148
81129e9c:	1545c83a 	sub	r2,r2,r21
81129ea0:	11800017 	ldw	r6,0(r2)
81129ea4:	11c00117 	ldw	r7,4(r2)
81129ea8:	9009883a 	mov	r4,r18
81129eac:	880b883a 	mov	r5,r17
81129eb0:	11303200 	call	81130320 <__divdf3>
81129eb4:	102b883a 	mov	r21,r2
81129eb8:	182d883a 	mov	r22,r3
81129ebc:	003c4a06 	br	81128fe8 <__reset+0xfb108fe8>
81129ec0:	dd000a15 	stw	r20,40(sp)
81129ec4:	a811883a 	mov	r8,r21
81129ec8:	dd001217 	ldw	r20,72(sp)
81129ecc:	003e9e06 	br	81129948 <__reset+0xfb109948>
81129ed0:	01604574 	movhi	r5,33045
81129ed4:	d9000617 	ldw	r4,24(sp)
81129ed8:	296e7904 	addi	r5,r5,-17948
81129edc:	01c00644 	movi	r7,25
81129ee0:	00000b06 	br	81129f10 <_strtod_r+0x1250>
81129ee4:	21000044 	addi	r4,r4,1
81129ee8:	20800003 	ldbu	r2,0(r4)
81129eec:	10ffefc4 	addi	r3,r2,-65
81129ef0:	10803fcc 	andi	r2,r2,255
81129ef4:	1080201c 	xori	r2,r2,128
81129ef8:	18c03fcc 	andi	r3,r3,255
81129efc:	10bfe004 	addi	r2,r2,-128
81129f00:	38c00136 	bltu	r7,r3,81129f08 <_strtod_r+0x1248>
81129f04:	10800804 	addi	r2,r2,32
81129f08:	29400044 	addi	r5,r5,1
81129f0c:	11bbbb1e 	bne	r2,r6,81128dfc <__reset+0xfb108dfc>
81129f10:	29800007 	ldb	r6,0(r5)
81129f14:	303ff31e 	bne	r6,zero,81129ee4 <__reset+0xfb109ee4>
81129f18:	01a04574 	movhi	r6,33045
81129f1c:	d9000615 	stw	r4,24(sp)
81129f20:	31ae7a04 	addi	r6,r6,-17944
81129f24:	200b883a 	mov	r5,r4
81129f28:	02000644 	movi	r8,25
81129f2c:	00000a06 	br	81129f58 <_strtod_r+0x1298>
81129f30:	28800003 	ldbu	r2,0(r5)
81129f34:	10ffefc4 	addi	r3,r2,-65
81129f38:	10803fcc 	andi	r2,r2,255
81129f3c:	1080201c 	xori	r2,r2,128
81129f40:	18c03fcc 	andi	r3,r3,255
81129f44:	10bfe004 	addi	r2,r2,-128
81129f48:	40c00136 	bltu	r8,r3,81129f50 <_strtod_r+0x1290>
81129f4c:	10800804 	addi	r2,r2,32
81129f50:	31800044 	addi	r6,r6,1
81129f54:	11c0711e 	bne	r2,r7,8112a11c <_strtod_r+0x145c>
81129f58:	31c00007 	ldb	r7,0(r6)
81129f5c:	29400044 	addi	r5,r5,1
81129f60:	383ff31e 	bne	r7,zero,81129f30 <__reset+0xfb109f30>
81129f64:	d9400615 	stw	r5,24(sp)
81129f68:	045ffc34 	movhi	r17,32752
81129f6c:	0025883a 	mov	r18,zero
81129f70:	003c1b06 	br	81128fe0 <__reset+0xfb108fe0>
81129f74:	000b883a 	mov	r5,zero
81129f78:	003ccc06 	br	811292ac <__reset+0xfb1092ac>
81129f7c:	d9400e17 	ldw	r5,56(sp)
81129f80:	dd000a15 	stw	r20,40(sp)
81129f84:	00800434 	movhi	r2,16
81129f88:	a811883a 	mov	r8,r21
81129f8c:	dd001217 	ldw	r20,72(sp)
81129f90:	dd401117 	ldw	r21,68(sp)
81129f94:	dd801017 	ldw	r22,64(sp)
81129f98:	10bfffc4 	addi	r2,r2,-1
81129f9c:	28005626 	beq	r5,zero,8112a0f8 <_strtod_r+0x1438>
81129fa0:	8886703a 	and	r3,r17,r2
81129fa4:	18807826 	beq	r3,r2,8112a188 <_strtod_r+0x14c8>
81129fa8:	d8c00b17 	ldw	r3,44(sp)
81129fac:	18005726 	beq	r3,zero,8112a10c <_strtod_r+0x144c>
81129fb0:	1c44703a 	and	r2,r3,r17
81129fb4:	10000f26 	beq	r2,zero,81129ff4 <_strtod_r+0x1334>
81129fb8:	d9000e17 	ldw	r4,56(sp)
81129fbc:	d9800917 	ldw	r6,36(sp)
81129fc0:	20005e26 	beq	r4,zero,8112a13c <_strtod_r+0x147c>
81129fc4:	9009883a 	mov	r4,r18
81129fc8:	880b883a 	mov	r5,r17
81129fcc:	da001315 	stw	r8,76(sp)
81129fd0:	1128c540 	call	81128c54 <sulp>
81129fd4:	100d883a 	mov	r6,r2
81129fd8:	180f883a 	mov	r7,r3
81129fdc:	9009883a 	mov	r4,r18
81129fe0:	880b883a 	mov	r5,r17
81129fe4:	112fa6c0 	call	8112fa6c <__adddf3>
81129fe8:	da001317 	ldw	r8,76(sp)
81129fec:	102b883a 	mov	r21,r2
81129ff0:	182d883a 	mov	r22,r3
81129ff4:	d8c00917 	ldw	r3,36(sp)
81129ff8:	18000f26 	beq	r3,zero,8112a038 <_strtod_r+0x1378>
81129ffc:	a809883a 	mov	r4,r21
8112a000:	b00b883a 	mov	r5,r22
8112a004:	000d883a 	mov	r6,zero
8112a008:	01ce5434 	movhi	r7,14672
8112a00c:	da001315 	stw	r8,76(sp)
8112a010:	111b57c0 	call	8111b57c <__muldf3>
8112a014:	102b883a 	mov	r21,r2
8112a018:	182d883a 	mov	r22,r3
8112a01c:	da001317 	ldw	r8,76(sp)
8112a020:	1800051e 	bne	r3,zero,8112a038 <_strtod_r+0x1378>
8112a024:	d8800517 	ldw	r2,20(sp)
8112a028:	a83e4b1e 	bne	r21,zero,81129958 <__reset+0xfb109958>
8112a02c:	00c00884 	movi	r3,34
8112a030:	80c00015 	stw	r3,0(r16)
8112a034:	003e4806 	br	81129958 <__reset+0xfb109958>
8112a038:	d8800517 	ldw	r2,20(sp)
8112a03c:	003e4606 	br	81129958 <__reset+0xfb109958>
8112a040:	d9000e17 	ldw	r4,56(sp)
8112a044:	dd000a15 	stw	r20,40(sp)
8112a048:	a811883a 	mov	r8,r21
8112a04c:	dd001217 	ldw	r20,72(sp)
8112a050:	dd401117 	ldw	r21,68(sp)
8112a054:	dd801017 	ldw	r22,64(sp)
8112a058:	203fe61e 	bne	r4,zero,81129ff4 <__reset+0xfb109ff4>
8112a05c:	903fe51e 	bne	r18,zero,81129ff4 <__reset+0xfb109ff4>
8112a060:	00800434 	movhi	r2,16
8112a064:	10bfffc4 	addi	r2,r2,-1
8112a068:	8884703a 	and	r2,r17,r2
8112a06c:	103fe11e 	bne	r2,zero,81129ff4 <__reset+0xfb109ff4>
8112a070:	8ddffc2c 	andhi	r23,r17,32752
8112a074:	0081ac34 	movhi	r2,1712
8112a078:	15ffde2e 	bgeu	r2,r23,81129ff4 <__reset+0xfb109ff4>
8112a07c:	40800517 	ldw	r2,20(r8)
8112a080:	1000031e 	bne	r2,zero,8112a090 <_strtod_r+0x13d0>
8112a084:	40800417 	ldw	r2,16(r8)
8112a088:	00c00044 	movi	r3,1
8112a08c:	18bfd90e 	bge	r3,r2,81129ff4 <__reset+0xfb109ff4>
8112a090:	400b883a 	mov	r5,r8
8112a094:	01800044 	movi	r6,1
8112a098:	8009883a 	mov	r4,r16
8112a09c:	1127bac0 	call	81127bac <__lshift>
8112a0a0:	980b883a 	mov	r5,r19
8112a0a4:	1009883a 	mov	r4,r2
8112a0a8:	d8801315 	stw	r2,76(sp)
8112a0ac:	1127cfc0 	call	81127cfc <__mcmp>
8112a0b0:	da001317 	ldw	r8,76(sp)
8112a0b4:	00bfcf0e 	bge	zero,r2,81129ff4 <__reset+0xfb109ff4>
8112a0b8:	d8c00917 	ldw	r3,36(sp)
8112a0bc:	18005c26 	beq	r3,zero,8112a230 <_strtod_r+0x1570>
8112a0c0:	0081ac34 	movhi	r2,1712
8112a0c4:	15c05a16 	blt	r2,r23,8112a230 <_strtod_r+0x1570>
8112a0c8:	0080dc34 	movhi	r2,880
8112a0cc:	15ffcb16 	blt	r2,r23,81129ffc <__reset+0xfb109ffc>
8112a0d0:	003f1106 	br	81129d18 <__reset+0xfb109d18>
8112a0d4:	002d883a 	mov	r22,zero
8112a0d8:	022ff834 	movhi	r8,49120
8112a0dc:	d8000d15 	stw	zero,52(sp)
8112a0e0:	05cff834 	movhi	r23,16352
8112a0e4:	003ded06 	br	8112989c <__reset+0xfb10989c>
8112a0e8:	0440d434 	movhi	r17,848
8112a0ec:	1c63883a 	add	r17,r3,r17
8112a0f0:	d8000915 	stw	zero,36(sp)
8112a0f4:	003cc806 	br	81129418 <__reset+0xfb109418>
8112a0f8:	8884703a 	and	r2,r17,r2
8112a0fc:	103faa1e 	bne	r2,zero,81129fa8 <__reset+0xfb109fa8>
8112a100:	903fa91e 	bne	r18,zero,81129fa8 <__reset+0xfb109fa8>
8112a104:	8ddffc2c 	andhi	r23,r17,32752
8112a108:	003feb06 	br	8112a0b8 <__reset+0xfb10a0b8>
8112a10c:	d8c00d17 	ldw	r3,52(sp)
8112a110:	1cae703a 	and	r23,r3,r18
8112a114:	b83fb726 	beq	r23,zero,81129ff4 <__reset+0xfb109ff4>
8112a118:	003fa706 	br	81129fb8 <__reset+0xfb109fb8>
8112a11c:	21000044 	addi	r4,r4,1
8112a120:	d9000615 	stw	r4,24(sp)
8112a124:	003f9006 	br	81129f68 <__reset+0xfb109f68>
8112a128:	01604574 	movhi	r5,33045
8112a12c:	296e3d04 	addi	r5,r5,-18188
8112a130:	d9400915 	stw	r5,36(sp)
8112a134:	0027883a 	mov	r19,zero
8112a138:	003ca206 	br	811293c4 <__reset+0xfb1093c4>
8112a13c:	9009883a 	mov	r4,r18
8112a140:	880b883a 	mov	r5,r17
8112a144:	da001315 	stw	r8,76(sp)
8112a148:	1128c540 	call	81128c54 <sulp>
8112a14c:	100d883a 	mov	r6,r2
8112a150:	180f883a 	mov	r7,r3
8112a154:	9009883a 	mov	r4,r18
8112a158:	880b883a 	mov	r5,r17
8112a15c:	1130e680 	call	81130e68 <__subdf3>
8112a160:	000d883a 	mov	r6,zero
8112a164:	000f883a 	mov	r7,zero
8112a168:	1009883a 	mov	r4,r2
8112a16c:	180b883a 	mov	r5,r3
8112a170:	102b883a 	mov	r21,r2
8112a174:	182d883a 	mov	r22,r3
8112a178:	1130c100 	call	81130c10 <__eqdf2>
8112a17c:	da001317 	ldw	r8,76(sp)
8112a180:	103ee526 	beq	r2,zero,81129d18 <__reset+0xfb109d18>
8112a184:	003f9b06 	br	81129ff4 <__reset+0xfb109ff4>
8112a188:	d8800917 	ldw	r2,36(sp)
8112a18c:	10002226 	beq	r2,zero,8112a218 <_strtod_r+0x1558>
8112a190:	889ffc2c 	andhi	r2,r17,32752
8112a194:	00c1a834 	movhi	r3,1696
8112a198:	18801f36 	bltu	r3,r2,8112a218 <_strtod_r+0x1558>
8112a19c:	1004d53a 	srli	r2,r2,20
8112a1a0:	00c01ac4 	movi	r3,107
8112a1a4:	1887c83a 	sub	r3,r3,r2
8112a1a8:	00bfffc4 	movi	r2,-1
8112a1ac:	10c4983a 	sll	r2,r2,r3
8112a1b0:	14bf7d1e 	bne	r2,r18,81129fa8 <__reset+0xfb109fa8>
8112a1b4:	00dffc34 	movhi	r3,32752
8112a1b8:	18ffffc4 	addi	r3,r3,-1
8112a1bc:	88c03526 	beq	r17,r3,8112a294 <_strtod_r+0x15d4>
8112a1c0:	8c5ffc2c 	andhi	r17,r17,32752
8112a1c4:	00800434 	movhi	r2,16
8112a1c8:	002b883a 	mov	r21,zero
8112a1cc:	88ad883a 	add	r22,r17,r2
8112a1d0:	003f8806 	br	81129ff4 <__reset+0xfb109ff4>
8112a1d4:	01401a84 	movi	r5,106
8112a1d8:	d9400915 	stw	r5,36(sp)
8112a1dc:	8ddffc2c 	andhi	r23,r17,32752
8112a1e0:	b82ed53a 	srli	r23,r23,20
8112a1e4:	00801ac4 	movi	r2,107
8112a1e8:	15c5c83a 	sub	r2,r2,r23
8112a1ec:	00be8e0e 	bge	zero,r2,81129c28 <__reset+0xfb109c28>
8112a1f0:	00c007c4 	movi	r3,31
8112a1f4:	18800a0e 	bge	r3,r2,8112a220 <_strtod_r+0x1560>
8112a1f8:	00c00d04 	movi	r3,52
8112a1fc:	0025883a 	mov	r18,zero
8112a200:	1880270e 	bge	r3,r2,8112a2a0 <_strtod_r+0x15e0>
8112a204:	0440dc34 	movhi	r17,880
8112a208:	003e8706 	br	81129c28 <__reset+0xfb109c28>
8112a20c:	d8000915 	stw	zero,36(sp)
8112a210:	05fe6a16 	blt	zero,r23,81129bbc <__reset+0xfb109bbc>
8112a214:	003e8406 	br	81129c28 <__reset+0xfb109c28>
8112a218:	00bfffc4 	movi	r2,-1
8112a21c:	003fe406 	br	8112a1b0 <__reset+0xfb10a1b0>
8112a220:	00ffffc4 	movi	r3,-1
8112a224:	1884983a 	sll	r2,r3,r2
8112a228:	14a4703a 	and	r18,r2,r18
8112a22c:	003e7e06 	br	81129c28 <__reset+0xfb109c28>
8112a230:	00bffc34 	movhi	r2,65520
8112a234:	b8af883a 	add	r23,r23,r2
8112a238:	057fffc4 	movi	r21,-1
8112a23c:	00800434 	movhi	r2,16
8112a240:	1545883a 	add	r2,r2,r21
8112a244:	b8acb03a 	or	r22,r23,r2
8112a248:	003f6a06 	br	81129ff4 <__reset+0xfb109ff4>
8112a24c:	01604574 	movhi	r5,33045
8112a250:	296e7d04 	addi	r5,r5,-17932
8112a254:	d9800204 	addi	r6,sp,8
8112a258:	d9000604 	addi	r4,sp,24
8112a25c:	112e64c0 	call	8112e64c <__hexnan>
8112a260:	00c00144 	movi	r3,5
8112a264:	10fb5c1e 	bne	r2,r3,81128fd8 <__reset+0xfb108fd8>
8112a268:	dc400317 	ldw	r17,12(sp)
8112a26c:	dc800217 	ldw	r18,8(sp)
8112a270:	8c5ffc34 	orhi	r17,r17,32752
8112a274:	003b5a06 	br	81128fe0 <__reset+0xfb108fe0>
8112a278:	480b883a 	mov	r5,r9
8112a27c:	d9800617 	ldw	r6,24(sp)
8112a280:	4a400044 	addi	r9,r9,1
8112a284:	003eeb06 	br	81129e34 <__reset+0xfb109e34>
8112a288:	1025883a 	mov	r18,r2
8112a28c:	1823883a 	mov	r17,r3
8112a290:	003c4c06 	br	811293c4 <__reset+0xfb1093c4>
8112a294:	00ffffc4 	movi	r3,-1
8112a298:	10ffc91e 	bne	r2,r3,8112a1c0 <__reset+0xfb10a1c0>
8112a29c:	003da906 	br	81129944 <__reset+0xfb109944>
8112a2a0:	10bff804 	addi	r2,r2,-32
8112a2a4:	00ffffc4 	movi	r3,-1
8112a2a8:	1884983a 	sll	r2,r3,r2
8112a2ac:	1462703a 	and	r17,r2,r17
8112a2b0:	003e5d06 	br	81129c28 <__reset+0xfb109c28>
8112a2b4:	1025883a 	mov	r18,r2
8112a2b8:	1823883a 	mov	r17,r3
8112a2bc:	003e5806 	br	81129c20 <__reset+0xfb109c20>

8112a2c0 <strtod>:
8112a2c0:	00a04574 	movhi	r2,33045
8112a2c4:	10b7d604 	addi	r2,r2,-8360
8112a2c8:	280d883a 	mov	r6,r5
8112a2cc:	200b883a 	mov	r5,r4
8112a2d0:	11000017 	ldw	r4,0(r2)
8112a2d4:	1128cc01 	jmpi	81128cc0 <_strtod_r>

8112a2d8 <strtof>:
8112a2d8:	defffb04 	addi	sp,sp,-20
8112a2dc:	de00012e 	bgeu	sp,et,8112a2e4 <strtof+0xc>
8112a2e0:	003b68fa 	trap	3
8112a2e4:	dcc00315 	stw	r19,12(sp)
8112a2e8:	04e04574 	movhi	r19,33045
8112a2ec:	9cf7d604 	addi	r19,r19,-8360
8112a2f0:	280d883a 	mov	r6,r5
8112a2f4:	200b883a 	mov	r5,r4
8112a2f8:	99000017 	ldw	r4,0(r19)
8112a2fc:	dfc00415 	stw	ra,16(sp)
8112a300:	dc800215 	stw	r18,8(sp)
8112a304:	dc400115 	stw	r17,4(sp)
8112a308:	dc000015 	stw	r16,0(sp)
8112a30c:	1128cc00 	call	81128cc0 <_strtod_r>
8112a310:	1009883a 	mov	r4,r2
8112a314:	180b883a 	mov	r5,r3
8112a318:	1025883a 	mov	r18,r2
8112a31c:	1823883a 	mov	r17,r3
8112a320:	111bdb40 	call	8111bdb4 <__truncdfsf2>
8112a324:	000b883a 	mov	r5,zero
8112a328:	1009883a 	mov	r4,r2
8112a32c:	1021883a 	mov	r16,r2
8112a330:	112f8700 	call	8112f870 <__eqsf2>
8112a334:	1000111e 	bne	r2,zero,8112a37c <strtof+0xa4>
8112a338:	000d883a 	mov	r6,zero
8112a33c:	000f883a 	mov	r7,zero
8112a340:	9009883a 	mov	r4,r18
8112a344:	880b883a 	mov	r5,r17
8112a348:	1130c100 	call	81130c10 <__eqdf2>
8112a34c:	10000b26 	beq	r2,zero,8112a37c <strtof+0xa4>
8112a350:	98800017 	ldw	r2,0(r19)
8112a354:	00c00884 	movi	r3,34
8112a358:	10c00015 	stw	r3,0(r2)
8112a35c:	8005883a 	mov	r2,r16
8112a360:	dfc00417 	ldw	ra,16(sp)
8112a364:	dcc00317 	ldw	r19,12(sp)
8112a368:	dc800217 	ldw	r18,8(sp)
8112a36c:	dc400117 	ldw	r17,4(sp)
8112a370:	dc000017 	ldw	r16,0(sp)
8112a374:	dec00504 	addi	sp,sp,20
8112a378:	f800283a 	ret
8112a37c:	015fe034 	movhi	r5,32640
8112a380:	297fffc4 	addi	r5,r5,-1
8112a384:	8009883a 	mov	r4,r16
8112a388:	112f8e80 	call	8112f8e8 <__gesf2>
8112a38c:	0080070e 	bge	zero,r2,8112a3ac <strtof+0xd4>
8112a390:	01dffc34 	movhi	r7,32752
8112a394:	39ffffc4 	addi	r7,r7,-1
8112a398:	01bfffc4 	movi	r6,-1
8112a39c:	9009883a 	mov	r4,r18
8112a3a0:	880b883a 	mov	r5,r17
8112a3a4:	1130c980 	call	81130c98 <__gedf2>
8112a3a8:	00bfe90e 	bge	zero,r2,8112a350 <__reset+0xfb10a350>
8112a3ac:	017fe034 	movhi	r5,65408
8112a3b0:	297fffc4 	addi	r5,r5,-1
8112a3b4:	8009883a 	mov	r4,r16
8112a3b8:	112f9a40 	call	8112f9a4 <__lesf2>
8112a3bc:	103fe70e 	bge	r2,zero,8112a35c <__reset+0xfb10a35c>
8112a3c0:	01fffc34 	movhi	r7,65520
8112a3c4:	39ffffc4 	addi	r7,r7,-1
8112a3c8:	01bfffc4 	movi	r6,-1
8112a3cc:	9009883a 	mov	r4,r18
8112a3d0:	880b883a 	mov	r5,r17
8112a3d4:	1130d740 	call	81130d74 <__ledf2>
8112a3d8:	103fdd0e 	bge	r2,zero,8112a350 <__reset+0xfb10a350>
8112a3dc:	003fdf06 	br	8112a35c <__reset+0xfb10a35c>

8112a3e0 <_strtoll_r>:
8112a3e0:	00a04574 	movhi	r2,33045
8112a3e4:	defff304 	addi	sp,sp,-52
8112a3e8:	10b7d404 	addi	r2,r2,-8368
8112a3ec:	de00012e 	bgeu	sp,et,8112a3f4 <_strtoll_r+0x14>
8112a3f0:	003b68fa 	trap	3
8112a3f4:	dc800515 	stw	r18,20(sp)
8112a3f8:	14800017 	ldw	r18,0(r2)
8112a3fc:	dd800915 	stw	r22,36(sp)
8112a400:	dd400815 	stw	r21,32(sp)
8112a404:	dcc00615 	stw	r19,24(sp)
8112a408:	d9000015 	stw	r4,0(sp)
8112a40c:	dfc00c15 	stw	ra,48(sp)
8112a410:	df000b15 	stw	fp,44(sp)
8112a414:	ddc00a15 	stw	r23,40(sp)
8112a418:	dd000715 	stw	r20,28(sp)
8112a41c:	dc400415 	stw	r17,16(sp)
8112a420:	dc000315 	stw	r16,12(sp)
8112a424:	282d883a 	mov	r22,r5
8112a428:	302b883a 	mov	r21,r6
8112a42c:	3827883a 	mov	r19,r7
8112a430:	2809883a 	mov	r4,r5
8112a434:	24000003 	ldbu	r16,0(r4)
8112a438:	24400044 	addi	r17,r4,1
8112a43c:	2007883a 	mov	r3,r4
8112a440:	9405883a 	add	r2,r18,r16
8112a444:	10800043 	ldbu	r2,1(r2)
8112a448:	8809883a 	mov	r4,r17
8112a44c:	1080020c 	andi	r2,r2,8
8112a450:	103ff81e 	bne	r2,zero,8112a434 <__reset+0xfb10a434>
8112a454:	00800b44 	movi	r2,45
8112a458:	80807826 	beq	r16,r2,8112a63c <_strtoll_r+0x25c>
8112a45c:	00800ac4 	movi	r2,43
8112a460:	80807a26 	beq	r16,r2,8112a64c <_strtoll_r+0x26c>
8112a464:	0039883a 	mov	fp,zero
8112a468:	98004e26 	beq	r19,zero,8112a5a4 <_strtoll_r+0x1c4>
8112a46c:	00800404 	movi	r2,16
8112a470:	98808226 	beq	r19,r2,8112a67c <_strtoll_r+0x29c>
8112a474:	982fd7fa 	srai	r23,r19,31
8112a478:	9829883a 	mov	r20,r19
8112a47c:	e0004f26 	beq	fp,zero,8112a5bc <_strtoll_r+0x1dc>
8112a480:	0017883a 	mov	r11,zero
8112a484:	02a00034 	movhi	r10,32768
8112a488:	5809883a 	mov	r4,r11
8112a48c:	500b883a 	mov	r5,r10
8112a490:	a00d883a 	mov	r6,r20
8112a494:	b80f883a 	mov	r7,r23
8112a498:	da800215 	stw	r10,8(sp)
8112a49c:	dac00115 	stw	r11,4(sp)
8112a4a0:	112f17c0 	call	8112f17c <__umoddi3>
8112a4a4:	dac00117 	ldw	r11,4(sp)
8112a4a8:	da800217 	ldw	r10,8(sp)
8112a4ac:	a00d883a 	mov	r6,r20
8112a4b0:	5809883a 	mov	r4,r11
8112a4b4:	500b883a 	mov	r5,r10
8112a4b8:	b80f883a 	mov	r7,r23
8112a4bc:	d8800115 	stw	r2,4(sp)
8112a4c0:	112ebfc0 	call	8112ebfc <__udivdi3>
8112a4c4:	9409883a 	add	r4,r18,r16
8112a4c8:	21000043 	ldbu	r4,1(r4)
8112a4cc:	1019883a 	mov	r12,r2
8112a4d0:	880b883a 	mov	r5,r17
8112a4d4:	2240010c 	andi	r9,r4,4
8112a4d8:	0015883a 	mov	r10,zero
8112a4dc:	000d883a 	mov	r6,zero
8112a4e0:	000f883a 	mov	r7,zero
8112a4e4:	03400044 	movi	r13,1
8112a4e8:	02ffffc4 	movi	r11,-1
8112a4ec:	da000117 	ldw	r8,4(sp)
8112a4f0:	48000d26 	beq	r9,zero,8112a528 <_strtoll_r+0x148>
8112a4f4:	843ff404 	addi	r16,r16,-48
8112a4f8:	84c0110e 	bge	r16,r19,8112a540 <_strtoll_r+0x160>
8112a4fc:	52c00426 	beq	r10,r11,8112a510 <_strtoll_r+0x130>
8112a500:	19c00236 	bltu	r3,r7,8112a50c <_strtoll_r+0x12c>
8112a504:	38c0311e 	bne	r7,r3,8112a5cc <_strtoll_r+0x1ec>
8112a508:	6180302e 	bgeu	r12,r6,8112a5cc <_strtoll_r+0x1ec>
8112a50c:	02bfffc4 	movi	r10,-1
8112a510:	2c000003 	ldbu	r16,0(r5)
8112a514:	29400044 	addi	r5,r5,1
8112a518:	9409883a 	add	r4,r18,r16
8112a51c:	21000043 	ldbu	r4,1(r4)
8112a520:	2240010c 	andi	r9,r4,4
8112a524:	483ff31e 	bne	r9,zero,8112a4f4 <__reset+0xfb10a4f4>
8112a528:	210000cc 	andi	r4,r4,3
8112a52c:	20000426 	beq	r4,zero,8112a540 <_strtoll_r+0x160>
8112a530:	23403426 	beq	r4,r13,8112a604 <_strtoll_r+0x224>
8112a534:	008015c4 	movi	r2,87
8112a538:	80a1c83a 	sub	r16,r16,r2
8112a53c:	84ffef16 	blt	r16,r19,8112a4fc <__reset+0xfb10a4fc>
8112a540:	00bfffc4 	movi	r2,-1
8112a544:	50803426 	beq	r10,r2,8112a618 <_strtoll_r+0x238>
8112a548:	e0000426 	beq	fp,zero,8112a55c <_strtoll_r+0x17c>
8112a54c:	018dc83a 	sub	r6,zero,r6
8112a550:	3004c03a 	cmpne	r2,r6,zero
8112a554:	01e1c83a 	sub	r16,zero,r7
8112a558:	808fc83a 	sub	r7,r16,r2
8112a55c:	3005883a 	mov	r2,r6
8112a560:	3807883a 	mov	r3,r7
8112a564:	a8000326 	beq	r21,zero,8112a574 <_strtoll_r+0x194>
8112a568:	5000321e 	bne	r10,zero,8112a634 <_strtoll_r+0x254>
8112a56c:	b00b883a 	mov	r5,r22
8112a570:	a9400015 	stw	r5,0(r21)
8112a574:	dfc00c17 	ldw	ra,48(sp)
8112a578:	df000b17 	ldw	fp,44(sp)
8112a57c:	ddc00a17 	ldw	r23,40(sp)
8112a580:	dd800917 	ldw	r22,36(sp)
8112a584:	dd400817 	ldw	r21,32(sp)
8112a588:	dd000717 	ldw	r20,28(sp)
8112a58c:	dcc00617 	ldw	r19,24(sp)
8112a590:	dc800517 	ldw	r18,20(sp)
8112a594:	dc400417 	ldw	r17,16(sp)
8112a598:	dc000317 	ldw	r16,12(sp)
8112a59c:	dec00d04 	addi	sp,sp,52
8112a5a0:	f800283a 	ret
8112a5a4:	00800c04 	movi	r2,48
8112a5a8:	80802c26 	beq	r16,r2,8112a65c <_strtoll_r+0x27c>
8112a5ac:	05000284 	movi	r20,10
8112a5b0:	002f883a 	mov	r23,zero
8112a5b4:	a027883a 	mov	r19,r20
8112a5b8:	e03fb11e 	bne	fp,zero,8112a480 <__reset+0xfb10a480>
8112a5bc:	02a00034 	movhi	r10,32768
8112a5c0:	52bfffc4 	addi	r10,r10,-1
8112a5c4:	02ffffc4 	movi	r11,-1
8112a5c8:	003faf06 	br	8112a488 <__reset+0xfb10a488>
8112a5cc:	33000f26 	beq	r6,r12,8112a60c <_strtoll_r+0x22c>
8112a5d0:	b985383a 	mul	r2,r23,r6
8112a5d4:	3d0f383a 	mul	r7,r7,r20
8112a5d8:	3508383a 	mulxuu	r4,r6,r20
8112a5dc:	350d383a 	mul	r6,r6,r20
8112a5e0:	8013d7fa 	srai	r9,r16,31
8112a5e4:	388f883a 	add	r7,r7,r2
8112a5e8:	818d883a 	add	r6,r16,r6
8112a5ec:	390f883a 	add	r7,r7,r4
8112a5f0:	3421803a 	cmpltu	r16,r6,r16
8112a5f4:	49cf883a 	add	r7,r9,r7
8112a5f8:	81cf883a 	add	r7,r16,r7
8112a5fc:	02800044 	movi	r10,1
8112a600:	003fc306 	br	8112a510 <__reset+0xfb10a510>
8112a604:	00800dc4 	movi	r2,55
8112a608:	003fcb06 	br	8112a538 <__reset+0xfb10a538>
8112a60c:	38fff01e 	bne	r7,r3,8112a5d0 <__reset+0xfb10a5d0>
8112a610:	443fbe16 	blt	r8,r16,8112a50c <__reset+0xfb10a50c>
8112a614:	003fee06 	br	8112a5d0 <__reset+0xfb10a5d0>
8112a618:	e0002426 	beq	fp,zero,8112a6ac <_strtoll_r+0x2cc>
8112a61c:	0005883a 	mov	r2,zero
8112a620:	00e00034 	movhi	r3,32768
8112a624:	d9800017 	ldw	r6,0(sp)
8112a628:	01000884 	movi	r4,34
8112a62c:	31000015 	stw	r4,0(r6)
8112a630:	a83fd026 	beq	r21,zero,8112a574 <__reset+0xfb10a574>
8112a634:	297fffc4 	addi	r5,r5,-1
8112a638:	003fcd06 	br	8112a570 <__reset+0xfb10a570>
8112a63c:	1c400084 	addi	r17,r3,2
8112a640:	1c000043 	ldbu	r16,1(r3)
8112a644:	07000044 	movi	fp,1
8112a648:	003f8706 	br	8112a468 <__reset+0xfb10a468>
8112a64c:	1c400084 	addi	r17,r3,2
8112a650:	1c000043 	ldbu	r16,1(r3)
8112a654:	0039883a 	mov	fp,zero
8112a658:	003f8306 	br	8112a468 <__reset+0xfb10a468>
8112a65c:	88800003 	ldbu	r2,0(r17)
8112a660:	00c01604 	movi	r3,88
8112a664:	108037cc 	andi	r2,r2,223
8112a668:	10c00a26 	beq	r2,r3,8112a694 <_strtoll_r+0x2b4>
8112a66c:	05000204 	movi	r20,8
8112a670:	002f883a 	mov	r23,zero
8112a674:	a027883a 	mov	r19,r20
8112a678:	003f8006 	br	8112a47c <__reset+0xfb10a47c>
8112a67c:	00800c04 	movi	r2,48
8112a680:	80800e1e 	bne	r16,r2,8112a6bc <_strtoll_r+0x2dc>
8112a684:	88800003 	ldbu	r2,0(r17)
8112a688:	00c01604 	movi	r3,88
8112a68c:	108037cc 	andi	r2,r2,223
8112a690:	10c00a1e 	bne	r2,r3,8112a6bc <_strtoll_r+0x2dc>
8112a694:	05000404 	movi	r20,16
8112a698:	8c000043 	ldbu	r16,1(r17)
8112a69c:	002f883a 	mov	r23,zero
8112a6a0:	8c400084 	addi	r17,r17,2
8112a6a4:	a027883a 	mov	r19,r20
8112a6a8:	003f7406 	br	8112a47c <__reset+0xfb10a47c>
8112a6ac:	00e00034 	movhi	r3,32768
8112a6b0:	18ffffc4 	addi	r3,r3,-1
8112a6b4:	5005883a 	mov	r2,r10
8112a6b8:	003fda06 	br	8112a624 <__reset+0xfb10a624>
8112a6bc:	9829883a 	mov	r20,r19
8112a6c0:	002f883a 	mov	r23,zero
8112a6c4:	003f6d06 	br	8112a47c <__reset+0xfb10a47c>

8112a6c8 <_strtoul_r>:
8112a6c8:	00a04574 	movhi	r2,33045
8112a6cc:	defff604 	addi	sp,sp,-40
8112a6d0:	10b7d404 	addi	r2,r2,-8368
8112a6d4:	de00012e 	bgeu	sp,et,8112a6dc <_strtoul_r+0x14>
8112a6d8:	003b68fa 	trap	3
8112a6dc:	dc800315 	stw	r18,12(sp)
8112a6e0:	14800017 	ldw	r18,0(r2)
8112a6e4:	dd400615 	stw	r21,24(sp)
8112a6e8:	dd000515 	stw	r20,20(sp)
8112a6ec:	dcc00415 	stw	r19,16(sp)
8112a6f0:	2029883a 	mov	r20,r4
8112a6f4:	dfc00915 	stw	ra,36(sp)
8112a6f8:	ddc00815 	stw	r23,32(sp)
8112a6fc:	dd800715 	stw	r22,28(sp)
8112a700:	dc400215 	stw	r17,8(sp)
8112a704:	dc000115 	stw	r16,4(sp)
8112a708:	2827883a 	mov	r19,r5
8112a70c:	382b883a 	mov	r21,r7
8112a710:	2809883a 	mov	r4,r5
8112a714:	24000003 	ldbu	r16,0(r4)
8112a718:	24400044 	addi	r17,r4,1
8112a71c:	2007883a 	mov	r3,r4
8112a720:	9405883a 	add	r2,r18,r16
8112a724:	10800043 	ldbu	r2,1(r2)
8112a728:	8809883a 	mov	r4,r17
8112a72c:	1080020c 	andi	r2,r2,8
8112a730:	103ff81e 	bne	r2,zero,8112a714 <__reset+0xfb10a714>
8112a734:	00800b44 	movi	r2,45
8112a738:	80805326 	beq	r16,r2,8112a888 <_strtoul_r+0x1c0>
8112a73c:	00800ac4 	movi	r2,43
8112a740:	80805526 	beq	r16,r2,8112a898 <_strtoul_r+0x1d0>
8112a744:	002f883a 	mov	r23,zero
8112a748:	a8000f26 	beq	r21,zero,8112a788 <_strtoul_r+0xc0>
8112a74c:	00800404 	movi	r2,16
8112a750:	a8805f26 	beq	r21,r2,8112a8d0 <_strtoul_r+0x208>
8112a754:	013fffc4 	movi	r4,-1
8112a758:	a80b883a 	mov	r5,r21
8112a75c:	d9800015 	stw	r6,0(sp)
8112a760:	112f7b40 	call	8112f7b4 <__udivsi3>
8112a764:	a80b883a 	mov	r5,r21
8112a768:	013fffc4 	movi	r4,-1
8112a76c:	102d883a 	mov	r22,r2
8112a770:	112f8180 	call	8112f818 <__umodsi3>
8112a774:	d9800017 	ldw	r6,0(sp)
8112a778:	1019883a 	mov	r12,r2
8112a77c:	a817883a 	mov	r11,r21
8112a780:	b00f883a 	mov	r7,r22
8112a784:	00000706 	br	8112a7a4 <_strtoul_r+0xdc>
8112a788:	00800c04 	movi	r2,48
8112a78c:	80804626 	beq	r16,r2,8112a8a8 <_strtoul_r+0x1e0>
8112a790:	05400284 	movi	r21,10
8112a794:	01c666b4 	movhi	r7,6554
8112a798:	03000144 	movi	r12,5
8112a79c:	39e66644 	addi	r7,r7,-26215
8112a7a0:	a817883a 	mov	r11,r21
8112a7a4:	9407883a 	add	r3,r18,r16
8112a7a8:	18c00043 	ldbu	r3,1(r3)
8112a7ac:	8809883a 	mov	r4,r17
8112a7b0:	0011883a 	mov	r8,zero
8112a7b4:	1940010c 	andi	r5,r3,4
8112a7b8:	0005883a 	mov	r2,zero
8112a7bc:	02800044 	movi	r10,1
8112a7c0:	027fffc4 	movi	r9,-1
8112a7c4:	28000e26 	beq	r5,zero,8112a800 <_strtoul_r+0x138>
8112a7c8:	843ff404 	addi	r16,r16,-48
8112a7cc:	8540120e 	bge	r16,r21,8112a818 <_strtoul_r+0x150>
8112a7d0:	42400526 	beq	r8,r9,8112a7e8 <_strtoul_r+0x120>
8112a7d4:	38802236 	bltu	r7,r2,8112a860 <_strtoul_r+0x198>
8112a7d8:	11c02026 	beq	r2,r7,8112a85c <_strtoul_r+0x194>
8112a7dc:	12c5383a 	mul	r2,r2,r11
8112a7e0:	02000044 	movi	r8,1
8112a7e4:	8085883a 	add	r2,r16,r2
8112a7e8:	24000003 	ldbu	r16,0(r4)
8112a7ec:	21000044 	addi	r4,r4,1
8112a7f0:	9407883a 	add	r3,r18,r16
8112a7f4:	18c00043 	ldbu	r3,1(r3)
8112a7f8:	1940010c 	andi	r5,r3,4
8112a7fc:	283ff21e 	bne	r5,zero,8112a7c8 <__reset+0xfb10a7c8>
8112a800:	18c000cc 	andi	r3,r3,3
8112a804:	18000426 	beq	r3,zero,8112a818 <_strtoul_r+0x150>
8112a808:	1a801726 	beq	r3,r10,8112a868 <_strtoul_r+0x1a0>
8112a80c:	00c015c4 	movi	r3,87
8112a810:	80e1c83a 	sub	r16,r16,r3
8112a814:	857fee16 	blt	r16,r21,8112a7d0 <__reset+0xfb10a7d0>
8112a818:	40001516 	blt	r8,zero,8112a870 <_strtoul_r+0x1a8>
8112a81c:	b8000126 	beq	r23,zero,8112a824 <_strtoul_r+0x15c>
8112a820:	0085c83a 	sub	r2,zero,r2
8112a824:	30000226 	beq	r6,zero,8112a830 <_strtoul_r+0x168>
8112a828:	4000151e 	bne	r8,zero,8112a880 <_strtoul_r+0x1b8>
8112a82c:	34c00015 	stw	r19,0(r6)
8112a830:	dfc00917 	ldw	ra,36(sp)
8112a834:	ddc00817 	ldw	r23,32(sp)
8112a838:	dd800717 	ldw	r22,28(sp)
8112a83c:	dd400617 	ldw	r21,24(sp)
8112a840:	dd000517 	ldw	r20,20(sp)
8112a844:	dcc00417 	ldw	r19,16(sp)
8112a848:	dc800317 	ldw	r18,12(sp)
8112a84c:	dc400217 	ldw	r17,8(sp)
8112a850:	dc000117 	ldw	r16,4(sp)
8112a854:	dec00a04 	addi	sp,sp,40
8112a858:	f800283a 	ret
8112a85c:	643fdf0e 	bge	r12,r16,8112a7dc <__reset+0xfb10a7dc>
8112a860:	023fffc4 	movi	r8,-1
8112a864:	003fe006 	br	8112a7e8 <__reset+0xfb10a7e8>
8112a868:	00c00dc4 	movi	r3,55
8112a86c:	003fe806 	br	8112a810 <__reset+0xfb10a810>
8112a870:	00800884 	movi	r2,34
8112a874:	a0800015 	stw	r2,0(r20)
8112a878:	00bfffc4 	movi	r2,-1
8112a87c:	303fec26 	beq	r6,zero,8112a830 <__reset+0xfb10a830>
8112a880:	24ffffc4 	addi	r19,r4,-1
8112a884:	003fe906 	br	8112a82c <__reset+0xfb10a82c>
8112a888:	1c400084 	addi	r17,r3,2
8112a88c:	1c000043 	ldbu	r16,1(r3)
8112a890:	05c00044 	movi	r23,1
8112a894:	003fac06 	br	8112a748 <__reset+0xfb10a748>
8112a898:	1c400084 	addi	r17,r3,2
8112a89c:	1c000043 	ldbu	r16,1(r3)
8112a8a0:	002f883a 	mov	r23,zero
8112a8a4:	003fa806 	br	8112a748 <__reset+0xfb10a748>
8112a8a8:	88800003 	ldbu	r2,0(r17)
8112a8ac:	00c01604 	movi	r3,88
8112a8b0:	108037cc 	andi	r2,r2,223
8112a8b4:	10c00c26 	beq	r2,r3,8112a8e8 <_strtoul_r+0x220>
8112a8b8:	05400204 	movi	r21,8
8112a8bc:	01c80034 	movhi	r7,8192
8112a8c0:	030001c4 	movi	r12,7
8112a8c4:	39ffffc4 	addi	r7,r7,-1
8112a8c8:	a817883a 	mov	r11,r21
8112a8cc:	003fb506 	br	8112a7a4 <__reset+0xfb10a7a4>
8112a8d0:	00800c04 	movi	r2,48
8112a8d4:	80800c1e 	bne	r16,r2,8112a908 <_strtoul_r+0x240>
8112a8d8:	88800003 	ldbu	r2,0(r17)
8112a8dc:	00c01604 	movi	r3,88
8112a8e0:	108037cc 	andi	r2,r2,223
8112a8e4:	10c0081e 	bne	r2,r3,8112a908 <_strtoul_r+0x240>
8112a8e8:	02c00404 	movi	r11,16
8112a8ec:	05840034 	movhi	r22,4096
8112a8f0:	8c000043 	ldbu	r16,1(r17)
8112a8f4:	030003c4 	movi	r12,15
8112a8f8:	8c400084 	addi	r17,r17,2
8112a8fc:	b5bfffc4 	addi	r22,r22,-1
8112a900:	582b883a 	mov	r21,r11
8112a904:	003f9e06 	br	8112a780 <__reset+0xfb10a780>
8112a908:	01c40034 	movhi	r7,4096
8112a90c:	030003c4 	movi	r12,15
8112a910:	39ffffc4 	addi	r7,r7,-1
8112a914:	a817883a 	mov	r11,r21
8112a918:	003fa206 	br	8112a7a4 <__reset+0xfb10a7a4>

8112a91c <strtoul>:
8112a91c:	00a04574 	movhi	r2,33045
8112a920:	10b7d604 	addi	r2,r2,-8360
8112a924:	300f883a 	mov	r7,r6
8112a928:	280d883a 	mov	r6,r5
8112a92c:	200b883a 	mov	r5,r4
8112a930:	11000017 	ldw	r4,0(r2)
8112a934:	112a6c81 	jmpi	8112a6c8 <_strtoul_r>

8112a938 <_strtoull_r>:
8112a938:	00a04574 	movhi	r2,33045
8112a93c:	defff404 	addi	sp,sp,-48
8112a940:	10b7d404 	addi	r2,r2,-8368
8112a944:	de00012e 	bgeu	sp,et,8112a94c <_strtoull_r+0x14>
8112a948:	003b68fa 	trap	3
8112a94c:	dc400315 	stw	r17,12(sp)
8112a950:	14400017 	ldw	r17,0(r2)
8112a954:	dd400715 	stw	r21,28(sp)
8112a958:	dd000615 	stw	r20,24(sp)
8112a95c:	dcc00515 	stw	r19,20(sp)
8112a960:	dc800415 	stw	r18,16(sp)
8112a964:	dfc00b15 	stw	ra,44(sp)
8112a968:	df000a15 	stw	fp,40(sp)
8112a96c:	ddc00915 	stw	r23,36(sp)
8112a970:	dd800815 	stw	r22,32(sp)
8112a974:	dc000215 	stw	r16,8(sp)
8112a978:	2827883a 	mov	r19,r5
8112a97c:	202b883a 	mov	r21,r4
8112a980:	3029883a 	mov	r20,r6
8112a984:	3825883a 	mov	r18,r7
8112a988:	2807883a 	mov	r3,r5
8112a98c:	1c000003 	ldbu	r16,0(r3)
8112a990:	1f000044 	addi	fp,r3,1
8112a994:	1809883a 	mov	r4,r3
8112a998:	8c05883a 	add	r2,r17,r16
8112a99c:	10800043 	ldbu	r2,1(r2)
8112a9a0:	e007883a 	mov	r3,fp
8112a9a4:	1080020c 	andi	r2,r2,8
8112a9a8:	103ff81e 	bne	r2,zero,8112a98c <__reset+0xfb10a98c>
8112a9ac:	00800b44 	movi	r2,45
8112a9b0:	80806e26 	beq	r16,r2,8112ab6c <_strtoull_r+0x234>
8112a9b4:	00800ac4 	movi	r2,43
8112a9b8:	80807026 	beq	r16,r2,8112ab7c <_strtoull_r+0x244>
8112a9bc:	002f883a 	mov	r23,zero
8112a9c0:	90001426 	beq	r18,zero,8112aa14 <_strtoull_r+0xdc>
8112a9c4:	00800404 	movi	r2,16
8112a9c8:	90807c26 	beq	r18,r2,8112abbc <_strtoull_r+0x284>
8112a9cc:	902dd7fa 	srai	r22,r18,31
8112a9d0:	013fffc4 	movi	r4,-1
8112a9d4:	200b883a 	mov	r5,r4
8112a9d8:	900d883a 	mov	r6,r18
8112a9dc:	b00f883a 	mov	r7,r22
8112a9e0:	112ebfc0 	call	8112ebfc <__udivdi3>
8112a9e4:	013fffc4 	movi	r4,-1
8112a9e8:	900d883a 	mov	r6,r18
8112a9ec:	b00f883a 	mov	r7,r22
8112a9f0:	200b883a 	mov	r5,r4
8112a9f4:	d8c00115 	stw	r3,4(sp)
8112a9f8:	d8800015 	stw	r2,0(sp)
8112a9fc:	112f17c0 	call	8112f17c <__umoddi3>
8112aa00:	101b883a 	mov	r13,r2
8112aa04:	9015883a 	mov	r10,r18
8112aa08:	dac00017 	ldw	r11,0(sp)
8112aa0c:	da000117 	ldw	r8,4(sp)
8112aa10:	00000a06 	br	8112aa3c <_strtoull_r+0x104>
8112aa14:	00800c04 	movi	r2,48
8112aa18:	80805c26 	beq	r16,r2,8112ab8c <_strtoull_r+0x254>
8112aa1c:	02800284 	movi	r10,10
8112aa20:	02e666b4 	movhi	r11,39322
8112aa24:	020666b4 	movhi	r8,6554
8112aa28:	03400144 	movi	r13,5
8112aa2c:	5ae66644 	addi	r11,r11,-26215
8112aa30:	42266644 	addi	r8,r8,-26215
8112aa34:	002d883a 	mov	r22,zero
8112aa38:	5025883a 	mov	r18,r10
8112aa3c:	8c0b883a 	add	r5,r17,r16
8112aa40:	29400043 	ldbu	r5,1(r5)
8112aa44:	e009883a 	mov	r4,fp
8112aa48:	000f883a 	mov	r7,zero
8112aa4c:	2980010c 	andi	r6,r5,4
8112aa50:	0005883a 	mov	r2,zero
8112aa54:	0007883a 	mov	r3,zero
8112aa58:	03000044 	movi	r12,1
8112aa5c:	027fffc4 	movi	r9,-1
8112aa60:	30000d26 	beq	r6,zero,8112aa98 <_strtoull_r+0x160>
8112aa64:	843ff404 	addi	r16,r16,-48
8112aa68:	8480110e 	bge	r16,r18,8112aab0 <_strtoull_r+0x178>
8112aa6c:	3a400426 	beq	r7,r9,8112aa80 <_strtoull_r+0x148>
8112aa70:	40c00236 	bltu	r8,r3,8112aa7c <_strtoull_r+0x144>
8112aa74:	1a00231e 	bne	r3,r8,8112ab04 <_strtoull_r+0x1cc>
8112aa78:	5880222e 	bgeu	r11,r2,8112ab04 <_strtoull_r+0x1cc>
8112aa7c:	01ffffc4 	movi	r7,-1
8112aa80:	24000003 	ldbu	r16,0(r4)
8112aa84:	21000044 	addi	r4,r4,1
8112aa88:	8c0b883a 	add	r5,r17,r16
8112aa8c:	29400043 	ldbu	r5,1(r5)
8112aa90:	2980010c 	andi	r6,r5,4
8112aa94:	303ff31e 	bne	r6,zero,8112aa64 <__reset+0xfb10aa64>
8112aa98:	294000cc 	andi	r5,r5,3
8112aa9c:	28000426 	beq	r5,zero,8112aab0 <_strtoull_r+0x178>
8112aaa0:	2b002626 	beq	r5,r12,8112ab3c <_strtoull_r+0x204>
8112aaa4:	014015c4 	movi	r5,87
8112aaa8:	8161c83a 	sub	r16,r16,r5
8112aaac:	84bfef16 	blt	r16,r18,8112aa6c <__reset+0xfb10aa6c>
8112aab0:	38002716 	blt	r7,zero,8112ab50 <_strtoull_r+0x218>
8112aab4:	b8000426 	beq	r23,zero,8112aac8 <_strtoull_r+0x190>
8112aab8:	0085c83a 	sub	r2,zero,r2
8112aabc:	100ac03a 	cmpne	r5,r2,zero
8112aac0:	00e1c83a 	sub	r16,zero,r3
8112aac4:	8147c83a 	sub	r3,r16,r5
8112aac8:	a0000226 	beq	r20,zero,8112aad4 <_strtoull_r+0x19c>
8112aacc:	3800251e 	bne	r7,zero,8112ab64 <_strtoull_r+0x22c>
8112aad0:	a4c00015 	stw	r19,0(r20)
8112aad4:	dfc00b17 	ldw	ra,44(sp)
8112aad8:	df000a17 	ldw	fp,40(sp)
8112aadc:	ddc00917 	ldw	r23,36(sp)
8112aae0:	dd800817 	ldw	r22,32(sp)
8112aae4:	dd400717 	ldw	r21,28(sp)
8112aae8:	dd000617 	ldw	r20,24(sp)
8112aaec:	dcc00517 	ldw	r19,20(sp)
8112aaf0:	dc800417 	ldw	r18,16(sp)
8112aaf4:	dc400317 	ldw	r17,12(sp)
8112aaf8:	dc000217 	ldw	r16,8(sp)
8112aafc:	dec00c04 	addi	sp,sp,48
8112ab00:	f800283a 	ret
8112ab04:	12c00f26 	beq	r2,r11,8112ab44 <_strtoull_r+0x20c>
8112ab08:	b08d383a 	mul	r6,r22,r2
8112ab0c:	1a87383a 	mul	r3,r3,r10
8112ab10:	128a383a 	mulxuu	r5,r2,r10
8112ab14:	1285383a 	mul	r2,r2,r10
8112ab18:	800fd7fa 	srai	r7,r16,31
8112ab1c:	1987883a 	add	r3,r3,r6
8112ab20:	8085883a 	add	r2,r16,r2
8112ab24:	1947883a 	add	r3,r3,r5
8112ab28:	38c7883a 	add	r3,r7,r3
8112ab2c:	1421803a 	cmpltu	r16,r2,r16
8112ab30:	80c7883a 	add	r3,r16,r3
8112ab34:	01c00044 	movi	r7,1
8112ab38:	003fd106 	br	8112aa80 <__reset+0xfb10aa80>
8112ab3c:	01400dc4 	movi	r5,55
8112ab40:	003fd906 	br	8112aaa8 <__reset+0xfb10aaa8>
8112ab44:	1a3ff01e 	bne	r3,r8,8112ab08 <__reset+0xfb10ab08>
8112ab48:	6c3fcc16 	blt	r13,r16,8112aa7c <__reset+0xfb10aa7c>
8112ab4c:	003fee06 	br	8112ab08 <__reset+0xfb10ab08>
8112ab50:	00800884 	movi	r2,34
8112ab54:	a8800015 	stw	r2,0(r21)
8112ab58:	00bfffc4 	movi	r2,-1
8112ab5c:	1007883a 	mov	r3,r2
8112ab60:	a03fdc26 	beq	r20,zero,8112aad4 <__reset+0xfb10aad4>
8112ab64:	24ffffc4 	addi	r19,r4,-1
8112ab68:	003fd906 	br	8112aad0 <__reset+0xfb10aad0>
8112ab6c:	27000084 	addi	fp,r4,2
8112ab70:	24000043 	ldbu	r16,1(r4)
8112ab74:	05c00044 	movi	r23,1
8112ab78:	003f9106 	br	8112a9c0 <__reset+0xfb10a9c0>
8112ab7c:	27000084 	addi	fp,r4,2
8112ab80:	24000043 	ldbu	r16,1(r4)
8112ab84:	002f883a 	mov	r23,zero
8112ab88:	003f8d06 	br	8112a9c0 <__reset+0xfb10a9c0>
8112ab8c:	e0800003 	ldbu	r2,0(fp)
8112ab90:	00c01604 	movi	r3,88
8112ab94:	108037cc 	andi	r2,r2,223
8112ab98:	10c00e26 	beq	r2,r3,8112abd4 <_strtoull_r+0x29c>
8112ab9c:	02800204 	movi	r10,8
8112aba0:	02ffffc4 	movi	r11,-1
8112aba4:	02080034 	movhi	r8,8192
8112aba8:	034001c4 	movi	r13,7
8112abac:	42d1883a 	add	r8,r8,r11
8112abb0:	002d883a 	mov	r22,zero
8112abb4:	5025883a 	mov	r18,r10
8112abb8:	003fa006 	br	8112aa3c <__reset+0xfb10aa3c>
8112abbc:	00800c04 	movi	r2,48
8112abc0:	80800e1e 	bne	r16,r2,8112abfc <_strtoull_r+0x2c4>
8112abc4:	e0800003 	ldbu	r2,0(fp)
8112abc8:	00c01604 	movi	r3,88
8112abcc:	108037cc 	andi	r2,r2,223
8112abd0:	10c00a1e 	bne	r2,r3,8112abfc <_strtoull_r+0x2c4>
8112abd4:	02800404 	movi	r10,16
8112abd8:	02ffffc4 	movi	r11,-1
8112abdc:	02040034 	movhi	r8,4096
8112abe0:	e4000043 	ldbu	r16,1(fp)
8112abe4:	034003c4 	movi	r13,15
8112abe8:	e7000084 	addi	fp,fp,2
8112abec:	42d1883a 	add	r8,r8,r11
8112abf0:	002d883a 	mov	r22,zero
8112abf4:	5025883a 	mov	r18,r10
8112abf8:	003f9006 	br	8112aa3c <__reset+0xfb10aa3c>
8112abfc:	02ffffc4 	movi	r11,-1
8112ac00:	02040034 	movhi	r8,4096
8112ac04:	034003c4 	movi	r13,15
8112ac08:	42d1883a 	add	r8,r8,r11
8112ac0c:	9015883a 	mov	r10,r18
8112ac10:	002d883a 	mov	r22,zero
8112ac14:	003f8906 	br	8112aa3c <__reset+0xfb10aa3c>

8112ac18 <__ssprint_r>:
8112ac18:	defff604 	addi	sp,sp,-40
8112ac1c:	de00012e 	bgeu	sp,et,8112ac24 <__ssprint_r+0xc>
8112ac20:	003b68fa 	trap	3
8112ac24:	30800217 	ldw	r2,8(r6)
8112ac28:	dc800215 	stw	r18,8(sp)
8112ac2c:	dfc00915 	stw	ra,36(sp)
8112ac30:	df000815 	stw	fp,32(sp)
8112ac34:	ddc00715 	stw	r23,28(sp)
8112ac38:	dd800615 	stw	r22,24(sp)
8112ac3c:	dd400515 	stw	r21,20(sp)
8112ac40:	dd000415 	stw	r20,16(sp)
8112ac44:	dcc00315 	stw	r19,12(sp)
8112ac48:	dc400115 	stw	r17,4(sp)
8112ac4c:	dc000015 	stw	r16,0(sp)
8112ac50:	3025883a 	mov	r18,r6
8112ac54:	10005826 	beq	r2,zero,8112adb8 <__ssprint_r+0x1a0>
8112ac58:	2027883a 	mov	r19,r4
8112ac5c:	35c00017 	ldw	r23,0(r6)
8112ac60:	29000017 	ldw	r4,0(r5)
8112ac64:	28800217 	ldw	r2,8(r5)
8112ac68:	2823883a 	mov	r17,r5
8112ac6c:	0039883a 	mov	fp,zero
8112ac70:	0021883a 	mov	r16,zero
8112ac74:	80003926 	beq	r16,zero,8112ad5c <__ssprint_r+0x144>
8112ac78:	102b883a 	mov	r21,r2
8112ac7c:	102d883a 	mov	r22,r2
8112ac80:	80803a36 	bltu	r16,r2,8112ad6c <__ssprint_r+0x154>
8112ac84:	88c0030b 	ldhu	r3,12(r17)
8112ac88:	1881200c 	andi	r2,r3,1152
8112ac8c:	10002626 	beq	r2,zero,8112ad28 <__ssprint_r+0x110>
8112ac90:	88800517 	ldw	r2,20(r17)
8112ac94:	89400417 	ldw	r5,16(r17)
8112ac98:	81800044 	addi	r6,r16,1
8112ac9c:	108f883a 	add	r7,r2,r2
8112aca0:	3885883a 	add	r2,r7,r2
8112aca4:	100ed7fa 	srli	r7,r2,31
8112aca8:	216dc83a 	sub	r22,r4,r5
8112acac:	3589883a 	add	r4,r6,r22
8112acb0:	3885883a 	add	r2,r7,r2
8112acb4:	102bd07a 	srai	r21,r2,1
8112acb8:	a80d883a 	mov	r6,r21
8112acbc:	a900022e 	bgeu	r21,r4,8112acc8 <__ssprint_r+0xb0>
8112acc0:	202b883a 	mov	r21,r4
8112acc4:	200d883a 	mov	r6,r4
8112acc8:	18c1000c 	andi	r3,r3,1024
8112accc:	18002a26 	beq	r3,zero,8112ad78 <__ssprint_r+0x160>
8112acd0:	300b883a 	mov	r5,r6
8112acd4:	9809883a 	mov	r4,r19
8112acd8:	111c9b80 	call	8111c9b8 <_malloc_r>
8112acdc:	1029883a 	mov	r20,r2
8112ace0:	10002c26 	beq	r2,zero,8112ad94 <__ssprint_r+0x17c>
8112ace4:	89400417 	ldw	r5,16(r17)
8112ace8:	b00d883a 	mov	r6,r22
8112acec:	1009883a 	mov	r4,r2
8112acf0:	111d1cc0 	call	8111d1cc <memcpy>
8112acf4:	8880030b 	ldhu	r2,12(r17)
8112acf8:	00fedfc4 	movi	r3,-1153
8112acfc:	10c4703a 	and	r2,r2,r3
8112ad00:	10802014 	ori	r2,r2,128
8112ad04:	8880030d 	sth	r2,12(r17)
8112ad08:	a589883a 	add	r4,r20,r22
8112ad0c:	adadc83a 	sub	r22,r21,r22
8112ad10:	8d400515 	stw	r21,20(r17)
8112ad14:	8d800215 	stw	r22,8(r17)
8112ad18:	8d000415 	stw	r20,16(r17)
8112ad1c:	89000015 	stw	r4,0(r17)
8112ad20:	802b883a 	mov	r21,r16
8112ad24:	802d883a 	mov	r22,r16
8112ad28:	b00d883a 	mov	r6,r22
8112ad2c:	e00b883a 	mov	r5,fp
8112ad30:	11272a00 	call	811272a0 <memmove>
8112ad34:	88800217 	ldw	r2,8(r17)
8112ad38:	89000017 	ldw	r4,0(r17)
8112ad3c:	90c00217 	ldw	r3,8(r18)
8112ad40:	1545c83a 	sub	r2,r2,r21
8112ad44:	2589883a 	add	r4,r4,r22
8112ad48:	88800215 	stw	r2,8(r17)
8112ad4c:	89000015 	stw	r4,0(r17)
8112ad50:	1c21c83a 	sub	r16,r3,r16
8112ad54:	94000215 	stw	r16,8(r18)
8112ad58:	80001726 	beq	r16,zero,8112adb8 <__ssprint_r+0x1a0>
8112ad5c:	bf000017 	ldw	fp,0(r23)
8112ad60:	bc000117 	ldw	r16,4(r23)
8112ad64:	bdc00204 	addi	r23,r23,8
8112ad68:	003fc206 	br	8112ac74 <__reset+0xfb10ac74>
8112ad6c:	802b883a 	mov	r21,r16
8112ad70:	802d883a 	mov	r22,r16
8112ad74:	003fec06 	br	8112ad28 <__reset+0xfb10ad28>
8112ad78:	9809883a 	mov	r4,r19
8112ad7c:	11284c00 	call	811284c0 <_realloc_r>
8112ad80:	1029883a 	mov	r20,r2
8112ad84:	103fe01e 	bne	r2,zero,8112ad08 <__reset+0xfb10ad08>
8112ad88:	89400417 	ldw	r5,16(r17)
8112ad8c:	9809883a 	mov	r4,r19
8112ad90:	112642c0 	call	8112642c <_free_r>
8112ad94:	88c0030b 	ldhu	r3,12(r17)
8112ad98:	00800304 	movi	r2,12
8112ad9c:	98800015 	stw	r2,0(r19)
8112ada0:	18c01014 	ori	r3,r3,64
8112ada4:	88c0030d 	sth	r3,12(r17)
8112ada8:	00bfffc4 	movi	r2,-1
8112adac:	90000215 	stw	zero,8(r18)
8112adb0:	90000115 	stw	zero,4(r18)
8112adb4:	00000206 	br	8112adc0 <__ssprint_r+0x1a8>
8112adb8:	90000115 	stw	zero,4(r18)
8112adbc:	0005883a 	mov	r2,zero
8112adc0:	dfc00917 	ldw	ra,36(sp)
8112adc4:	df000817 	ldw	fp,32(sp)
8112adc8:	ddc00717 	ldw	r23,28(sp)
8112adcc:	dd800617 	ldw	r22,24(sp)
8112add0:	dd400517 	ldw	r21,20(sp)
8112add4:	dd000417 	ldw	r20,16(sp)
8112add8:	dcc00317 	ldw	r19,12(sp)
8112addc:	dc800217 	ldw	r18,8(sp)
8112ade0:	dc400117 	ldw	r17,4(sp)
8112ade4:	dc000017 	ldw	r16,0(sp)
8112ade8:	dec00a04 	addi	sp,sp,40
8112adec:	f800283a 	ret

8112adf0 <___svfiprintf_internal_r>:
8112adf0:	deffc804 	addi	sp,sp,-224
8112adf4:	de00012e 	bgeu	sp,et,8112adfc <___svfiprintf_internal_r+0xc>
8112adf8:	003b68fa 	trap	3
8112adfc:	2880030b 	ldhu	r2,12(r5)
8112ae00:	dcc03115 	stw	r19,196(sp)
8112ae04:	dfc03715 	stw	ra,220(sp)
8112ae08:	df003615 	stw	fp,216(sp)
8112ae0c:	ddc03515 	stw	r23,212(sp)
8112ae10:	dd803415 	stw	r22,208(sp)
8112ae14:	dd403315 	stw	r21,204(sp)
8112ae18:	dd003215 	stw	r20,200(sp)
8112ae1c:	dc803015 	stw	r18,192(sp)
8112ae20:	dc402f15 	stw	r17,188(sp)
8112ae24:	dc002e15 	stw	r16,184(sp)
8112ae28:	d9402715 	stw	r5,156(sp)
8112ae2c:	d9002a15 	stw	r4,168(sp)
8112ae30:	1080200c 	andi	r2,r2,128
8112ae34:	d9c02315 	stw	r7,140(sp)
8112ae38:	3027883a 	mov	r19,r6
8112ae3c:	10000226 	beq	r2,zero,8112ae48 <___svfiprintf_internal_r+0x58>
8112ae40:	28800417 	ldw	r2,16(r5)
8112ae44:	10041d26 	beq	r2,zero,8112bebc <___svfiprintf_internal_r+0x10cc>
8112ae48:	dac01a04 	addi	r11,sp,104
8112ae4c:	dac01e15 	stw	r11,120(sp)
8112ae50:	d8801e17 	ldw	r2,120(sp)
8112ae54:	dac019c4 	addi	r11,sp,103
8112ae58:	dd402a17 	ldw	r21,168(sp)
8112ae5c:	ddc02717 	ldw	r23,156(sp)
8112ae60:	05a04574 	movhi	r22,33045
8112ae64:	05204574 	movhi	r20,33045
8112ae68:	dac01f15 	stw	r11,124(sp)
8112ae6c:	12d7c83a 	sub	r11,r2,r11
8112ae70:	b5ae9504 	addi	r22,r22,-17836
8112ae74:	a52e9104 	addi	r20,r20,-17852
8112ae78:	dec01a15 	stw	sp,104(sp)
8112ae7c:	d8001c15 	stw	zero,112(sp)
8112ae80:	d8001b15 	stw	zero,108(sp)
8112ae84:	d811883a 	mov	r8,sp
8112ae88:	d8002915 	stw	zero,164(sp)
8112ae8c:	d8002515 	stw	zero,148(sp)
8112ae90:	dac02b15 	stw	r11,172(sp)
8112ae94:	98800007 	ldb	r2,0(r19)
8112ae98:	1002dd26 	beq	r2,zero,8112ba10 <___svfiprintf_internal_r+0xc20>
8112ae9c:	00c00944 	movi	r3,37
8112aea0:	9823883a 	mov	r17,r19
8112aea4:	10c0021e 	bne	r2,r3,8112aeb0 <___svfiprintf_internal_r+0xc0>
8112aea8:	00001406 	br	8112aefc <___svfiprintf_internal_r+0x10c>
8112aeac:	10c00326 	beq	r2,r3,8112aebc <___svfiprintf_internal_r+0xcc>
8112aeb0:	8c400044 	addi	r17,r17,1
8112aeb4:	88800007 	ldb	r2,0(r17)
8112aeb8:	103ffc1e 	bne	r2,zero,8112aeac <__reset+0xfb10aeac>
8112aebc:	8ce1c83a 	sub	r16,r17,r19
8112aec0:	80000e26 	beq	r16,zero,8112aefc <___svfiprintf_internal_r+0x10c>
8112aec4:	d8c01c17 	ldw	r3,112(sp)
8112aec8:	d8801b17 	ldw	r2,108(sp)
8112aecc:	44c00015 	stw	r19,0(r8)
8112aed0:	1c07883a 	add	r3,r3,r16
8112aed4:	10800044 	addi	r2,r2,1
8112aed8:	d8c01c15 	stw	r3,112(sp)
8112aedc:	44000115 	stw	r16,4(r8)
8112aee0:	d8801b15 	stw	r2,108(sp)
8112aee4:	00c001c4 	movi	r3,7
8112aee8:	18831e16 	blt	r3,r2,8112bb64 <___svfiprintf_internal_r+0xd74>
8112aeec:	42000204 	addi	r8,r8,8
8112aef0:	dac02517 	ldw	r11,148(sp)
8112aef4:	5c17883a 	add	r11,r11,r16
8112aef8:	dac02515 	stw	r11,148(sp)
8112aefc:	88800007 	ldb	r2,0(r17)
8112af00:	1002c526 	beq	r2,zero,8112ba18 <___svfiprintf_internal_r+0xc28>
8112af04:	88c00047 	ldb	r3,1(r17)
8112af08:	8cc00044 	addi	r19,r17,1
8112af0c:	d8001d85 	stb	zero,118(sp)
8112af10:	0009883a 	mov	r4,zero
8112af14:	000f883a 	mov	r7,zero
8112af18:	043fffc4 	movi	r16,-1
8112af1c:	d8002415 	stw	zero,144(sp)
8112af20:	0025883a 	mov	r18,zero
8112af24:	01401604 	movi	r5,88
8112af28:	01800244 	movi	r6,9
8112af2c:	02800a84 	movi	r10,42
8112af30:	02401b04 	movi	r9,108
8112af34:	9cc00044 	addi	r19,r19,1
8112af38:	18bff804 	addi	r2,r3,-32
8112af3c:	2881dd36 	bltu	r5,r2,8112b6b4 <___svfiprintf_internal_r+0x8c4>
8112af40:	100490ba 	slli	r2,r2,2
8112af44:	02e044f4 	movhi	r11,33043
8112af48:	5aebd604 	addi	r11,r11,-20648
8112af4c:	12c5883a 	add	r2,r2,r11
8112af50:	10800017 	ldw	r2,0(r2)
8112af54:	1000683a 	jmp	r2
8112af58:	8112b154 	ori	r4,r16,19141
8112af5c:	8112b6b4 	orhi	r4,r16,19162
8112af60:	8112b6b4 	orhi	r4,r16,19162
8112af64:	8112b148 	cmpgei	r4,r16,19141
8112af68:	8112b6b4 	orhi	r4,r16,19162
8112af6c:	8112b6b4 	orhi	r4,r16,19162
8112af70:	8112b6b4 	orhi	r4,r16,19162
8112af74:	8112b6b4 	orhi	r4,r16,19162
8112af78:	8112b6b4 	orhi	r4,r16,19162
8112af7c:	8112b6b4 	orhi	r4,r16,19162
8112af80:	8112b0bc 	xorhi	r4,r16,19138
8112af84:	8112b298 	cmpnei	r4,r16,19146
8112af88:	8112b6b4 	orhi	r4,r16,19162
8112af8c:	8112b0e8 	cmpgeui	r4,r16,19139
8112af90:	8112b6e8 	cmpgeui	r4,r16,19163
8112af94:	8112b6b4 	orhi	r4,r16,19162
8112af98:	8112b6dc 	xori	r4,r16,19163
8112af9c:	8112b67c 	xorhi	r4,r16,19161
8112afa0:	8112b67c 	xorhi	r4,r16,19161
8112afa4:	8112b67c 	xorhi	r4,r16,19161
8112afa8:	8112b67c 	xorhi	r4,r16,19161
8112afac:	8112b67c 	xorhi	r4,r16,19161
8112afb0:	8112b67c 	xorhi	r4,r16,19161
8112afb4:	8112b67c 	xorhi	r4,r16,19161
8112afb8:	8112b67c 	xorhi	r4,r16,19161
8112afbc:	8112b67c 	xorhi	r4,r16,19161
8112afc0:	8112b6b4 	orhi	r4,r16,19162
8112afc4:	8112b6b4 	orhi	r4,r16,19162
8112afc8:	8112b6b4 	orhi	r4,r16,19162
8112afcc:	8112b6b4 	orhi	r4,r16,19162
8112afd0:	8112b6b4 	orhi	r4,r16,19162
8112afd4:	8112b6b4 	orhi	r4,r16,19162
8112afd8:	8112b6b4 	orhi	r4,r16,19162
8112afdc:	8112b6b4 	orhi	r4,r16,19162
8112afe0:	8112b6b4 	orhi	r4,r16,19162
8112afe4:	8112b6b4 	orhi	r4,r16,19162
8112afe8:	8112b618 	cmpnei	r4,r16,19160
8112afec:	8112b6b4 	orhi	r4,r16,19162
8112aff0:	8112b6b4 	orhi	r4,r16,19162
8112aff4:	8112b6b4 	orhi	r4,r16,19162
8112aff8:	8112b6b4 	orhi	r4,r16,19162
8112affc:	8112b6b4 	orhi	r4,r16,19162
8112b000:	8112b6b4 	orhi	r4,r16,19162
8112b004:	8112b6b4 	orhi	r4,r16,19162
8112b008:	8112b6b4 	orhi	r4,r16,19162
8112b00c:	8112b6b4 	orhi	r4,r16,19162
8112b010:	8112b6b4 	orhi	r4,r16,19162
8112b014:	8112b790 	cmplti	r4,r16,19166
8112b018:	8112b6b4 	orhi	r4,r16,19162
8112b01c:	8112b6b4 	orhi	r4,r16,19162
8112b020:	8112b6b4 	orhi	r4,r16,19162
8112b024:	8112b6b4 	orhi	r4,r16,19162
8112b028:	8112b6b4 	orhi	r4,r16,19162
8112b02c:	8112b728 	cmpgeui	r4,r16,19164
8112b030:	8112b6b4 	orhi	r4,r16,19162
8112b034:	8112b6b4 	orhi	r4,r16,19162
8112b038:	8112b45c 	xori	r4,r16,19153
8112b03c:	8112b6b4 	orhi	r4,r16,19162
8112b040:	8112b6b4 	orhi	r4,r16,19162
8112b044:	8112b6b4 	orhi	r4,r16,19162
8112b048:	8112b6b4 	orhi	r4,r16,19162
8112b04c:	8112b6b4 	orhi	r4,r16,19162
8112b050:	8112b6b4 	orhi	r4,r16,19162
8112b054:	8112b6b4 	orhi	r4,r16,19162
8112b058:	8112b6b4 	orhi	r4,r16,19162
8112b05c:	8112b6b4 	orhi	r4,r16,19162
8112b060:	8112b6b4 	orhi	r4,r16,19162
8112b064:	8112b34c 	andi	r4,r16,19149
8112b068:	8112b4f8 	rdprs	r4,r16,19155
8112b06c:	8112b6b4 	orhi	r4,r16,19162
8112b070:	8112b6b4 	orhi	r4,r16,19162
8112b074:	8112b6b4 	orhi	r4,r16,19162
8112b078:	8112b4ec 	andhi	r4,r16,19155
8112b07c:	8112b4f8 	rdprs	r4,r16,19155
8112b080:	8112b6b4 	orhi	r4,r16,19162
8112b084:	8112b6b4 	orhi	r4,r16,19162
8112b088:	8112b4dc 	xori	r4,r16,19155
8112b08c:	8112b6b4 	orhi	r4,r16,19162
8112b090:	8112b4a0 	cmpeqi	r4,r16,19154
8112b094:	8112b2a8 	cmpgeui	r4,r16,19146
8112b098:	8112b0f4 	orhi	r4,r16,19139
8112b09c:	8112b60c 	andi	r4,r16,19160
8112b0a0:	8112b6b4 	orhi	r4,r16,19162
8112b0a4:	8112b5c0 	call	88112b5c <__reset+0x20f2b5c>
8112b0a8:	8112b6b4 	orhi	r4,r16,19162
8112b0ac:	8112b218 	cmpnei	r4,r16,19144
8112b0b0:	8112b6b4 	orhi	r4,r16,19162
8112b0b4:	8112b6b4 	orhi	r4,r16,19162
8112b0b8:	8112b174 	orhi	r4,r16,19141
8112b0bc:	dac02317 	ldw	r11,140(sp)
8112b0c0:	5ac00017 	ldw	r11,0(r11)
8112b0c4:	dac02415 	stw	r11,144(sp)
8112b0c8:	dac02317 	ldw	r11,140(sp)
8112b0cc:	58800104 	addi	r2,r11,4
8112b0d0:	dac02417 	ldw	r11,144(sp)
8112b0d4:	5802e90e 	bge	r11,zero,8112bc7c <___svfiprintf_internal_r+0xe8c>
8112b0d8:	dac02417 	ldw	r11,144(sp)
8112b0dc:	d8802315 	stw	r2,140(sp)
8112b0e0:	02d7c83a 	sub	r11,zero,r11
8112b0e4:	dac02415 	stw	r11,144(sp)
8112b0e8:	94800114 	ori	r18,r18,4
8112b0ec:	98c00007 	ldb	r3,0(r19)
8112b0f0:	003f9006 	br	8112af34 <__reset+0xfb10af34>
8112b0f4:	00800c04 	movi	r2,48
8112b0f8:	dac02317 	ldw	r11,140(sp)
8112b0fc:	d8801d05 	stb	r2,116(sp)
8112b100:	00801e04 	movi	r2,120
8112b104:	d8801d45 	stb	r2,117(sp)
8112b108:	d8001d85 	stb	zero,118(sp)
8112b10c:	58c00104 	addi	r3,r11,4
8112b110:	5f000017 	ldw	fp,0(r11)
8112b114:	0013883a 	mov	r9,zero
8112b118:	90800094 	ori	r2,r18,2
8112b11c:	80032b16 	blt	r16,zero,8112bdcc <___svfiprintf_internal_r+0xfdc>
8112b120:	00bfdfc4 	movi	r2,-129
8112b124:	90a4703a 	and	r18,r18,r2
8112b128:	d8c02315 	stw	r3,140(sp)
8112b12c:	94800094 	ori	r18,r18,2
8112b130:	e002dc26 	beq	fp,zero,8112bca4 <___svfiprintf_internal_r+0xeb4>
8112b134:	01204574 	movhi	r4,33045
8112b138:	212e0704 	addi	r4,r4,-18404
8112b13c:	0015883a 	mov	r10,zero
8112b140:	d9002915 	stw	r4,164(sp)
8112b144:	00002306 	br	8112b1d4 <___svfiprintf_internal_r+0x3e4>
8112b148:	94800054 	ori	r18,r18,1
8112b14c:	98c00007 	ldb	r3,0(r19)
8112b150:	003f7806 	br	8112af34 <__reset+0xfb10af34>
8112b154:	38803fcc 	andi	r2,r7,255
8112b158:	1080201c 	xori	r2,r2,128
8112b15c:	10bfe004 	addi	r2,r2,-128
8112b160:	1002f31e 	bne	r2,zero,8112bd30 <___svfiprintf_internal_r+0xf40>
8112b164:	01000044 	movi	r4,1
8112b168:	01c00804 	movi	r7,32
8112b16c:	98c00007 	ldb	r3,0(r19)
8112b170:	003f7006 	br	8112af34 <__reset+0xfb10af34>
8112b174:	21003fcc 	andi	r4,r4,255
8112b178:	2003aa1e 	bne	r4,zero,8112c024 <___svfiprintf_internal_r+0x1234>
8112b17c:	00a04574 	movhi	r2,33045
8112b180:	10ae0704 	addi	r2,r2,-18404
8112b184:	d8802915 	stw	r2,164(sp)
8112b188:	9080080c 	andi	r2,r18,32
8112b18c:	1000ba26 	beq	r2,zero,8112b478 <___svfiprintf_internal_r+0x688>
8112b190:	dac02317 	ldw	r11,140(sp)
8112b194:	5f000017 	ldw	fp,0(r11)
8112b198:	5a400117 	ldw	r9,4(r11)
8112b19c:	5ac00204 	addi	r11,r11,8
8112b1a0:	dac02315 	stw	r11,140(sp)
8112b1a4:	9080004c 	andi	r2,r18,1
8112b1a8:	10029026 	beq	r2,zero,8112bbec <___svfiprintf_internal_r+0xdfc>
8112b1ac:	e244b03a 	or	r2,fp,r9
8112b1b0:	1002d41e 	bne	r2,zero,8112bd04 <___svfiprintf_internal_r+0xf14>
8112b1b4:	d8001d85 	stb	zero,118(sp)
8112b1b8:	80030b16 	blt	r16,zero,8112bde8 <___svfiprintf_internal_r+0xff8>
8112b1bc:	00bfdfc4 	movi	r2,-129
8112b1c0:	90a4703a 	and	r18,r18,r2
8112b1c4:	0015883a 	mov	r10,zero
8112b1c8:	80002426 	beq	r16,zero,8112b25c <___svfiprintf_internal_r+0x46c>
8112b1cc:	0039883a 	mov	fp,zero
8112b1d0:	0013883a 	mov	r9,zero
8112b1d4:	d9002917 	ldw	r4,164(sp)
8112b1d8:	dc401a04 	addi	r17,sp,104
8112b1dc:	e08003cc 	andi	r2,fp,15
8112b1e0:	4806973a 	slli	r3,r9,28
8112b1e4:	2085883a 	add	r2,r4,r2
8112b1e8:	e038d13a 	srli	fp,fp,4
8112b1ec:	10800003 	ldbu	r2,0(r2)
8112b1f0:	4812d13a 	srli	r9,r9,4
8112b1f4:	8c7fffc4 	addi	r17,r17,-1
8112b1f8:	1f38b03a 	or	fp,r3,fp
8112b1fc:	88800005 	stb	r2,0(r17)
8112b200:	e244b03a 	or	r2,fp,r9
8112b204:	103ff51e 	bne	r2,zero,8112b1dc <__reset+0xfb10b1dc>
8112b208:	dac01e17 	ldw	r11,120(sp)
8112b20c:	5c57c83a 	sub	r11,r11,r17
8112b210:	dac02115 	stw	r11,132(sp)
8112b214:	00001406 	br	8112b268 <___svfiprintf_internal_r+0x478>
8112b218:	21003fcc 	andi	r4,r4,255
8112b21c:	2003741e 	bne	r4,zero,8112bff0 <___svfiprintf_internal_r+0x1200>
8112b220:	9080080c 	andi	r2,r18,32
8112b224:	10014526 	beq	r2,zero,8112b73c <___svfiprintf_internal_r+0x94c>
8112b228:	dac02317 	ldw	r11,140(sp)
8112b22c:	d8001d85 	stb	zero,118(sp)
8112b230:	58c00204 	addi	r3,r11,8
8112b234:	5f000017 	ldw	fp,0(r11)
8112b238:	5a400117 	ldw	r9,4(r11)
8112b23c:	8002d916 	blt	r16,zero,8112bda4 <___svfiprintf_internal_r+0xfb4>
8112b240:	013fdfc4 	movi	r4,-129
8112b244:	e244b03a 	or	r2,fp,r9
8112b248:	d8c02315 	stw	r3,140(sp)
8112b24c:	9124703a 	and	r18,r18,r4
8112b250:	0015883a 	mov	r10,zero
8112b254:	1000b91e 	bne	r2,zero,8112b53c <___svfiprintf_internal_r+0x74c>
8112b258:	8002e61e 	bne	r16,zero,8112bdf4 <___svfiprintf_internal_r+0x1004>
8112b25c:	0021883a 	mov	r16,zero
8112b260:	d8002115 	stw	zero,132(sp)
8112b264:	dc401a04 	addi	r17,sp,104
8112b268:	d8c02117 	ldw	r3,132(sp)
8112b26c:	dc002015 	stw	r16,128(sp)
8112b270:	80c0010e 	bge	r16,r3,8112b278 <___svfiprintf_internal_r+0x488>
8112b274:	d8c02015 	stw	r3,128(sp)
8112b278:	52803fcc 	andi	r10,r10,255
8112b27c:	5280201c 	xori	r10,r10,128
8112b280:	52bfe004 	addi	r10,r10,-128
8112b284:	50003c26 	beq	r10,zero,8112b378 <___svfiprintf_internal_r+0x588>
8112b288:	dac02017 	ldw	r11,128(sp)
8112b28c:	5ac00044 	addi	r11,r11,1
8112b290:	dac02015 	stw	r11,128(sp)
8112b294:	00003806 	br	8112b378 <___svfiprintf_internal_r+0x588>
8112b298:	01000044 	movi	r4,1
8112b29c:	01c00ac4 	movi	r7,43
8112b2a0:	98c00007 	ldb	r3,0(r19)
8112b2a4:	003f2306 	br	8112af34 <__reset+0xfb10af34>
8112b2a8:	21003fcc 	andi	r4,r4,255
8112b2ac:	2003481e 	bne	r4,zero,8112bfd0 <___svfiprintf_internal_r+0x11e0>
8112b2b0:	9080080c 	andi	r2,r18,32
8112b2b4:	10013b26 	beq	r2,zero,8112b7a4 <___svfiprintf_internal_r+0x9b4>
8112b2b8:	dac02317 	ldw	r11,140(sp)
8112b2bc:	d8001d85 	stb	zero,118(sp)
8112b2c0:	58800204 	addi	r2,r11,8
8112b2c4:	5f000017 	ldw	fp,0(r11)
8112b2c8:	5a400117 	ldw	r9,4(r11)
8112b2cc:	8002a816 	blt	r16,zero,8112bd70 <___svfiprintf_internal_r+0xf80>
8112b2d0:	013fdfc4 	movi	r4,-129
8112b2d4:	e246b03a 	or	r3,fp,r9
8112b2d8:	d8802315 	stw	r2,140(sp)
8112b2dc:	9124703a 	and	r18,r18,r4
8112b2e0:	18013c26 	beq	r3,zero,8112b7d4 <___svfiprintf_internal_r+0x9e4>
8112b2e4:	0015883a 	mov	r10,zero
8112b2e8:	dc401a04 	addi	r17,sp,104
8112b2ec:	e006d0fa 	srli	r3,fp,3
8112b2f0:	4808977a 	slli	r4,r9,29
8112b2f4:	4812d0fa 	srli	r9,r9,3
8112b2f8:	e70001cc 	andi	fp,fp,7
8112b2fc:	e0800c04 	addi	r2,fp,48
8112b300:	8c7fffc4 	addi	r17,r17,-1
8112b304:	20f8b03a 	or	fp,r4,r3
8112b308:	88800005 	stb	r2,0(r17)
8112b30c:	e246b03a 	or	r3,fp,r9
8112b310:	183ff61e 	bne	r3,zero,8112b2ec <__reset+0xfb10b2ec>
8112b314:	90c0004c 	andi	r3,r18,1
8112b318:	1800a526 	beq	r3,zero,8112b5b0 <___svfiprintf_internal_r+0x7c0>
8112b31c:	10803fcc 	andi	r2,r2,255
8112b320:	1080201c 	xori	r2,r2,128
8112b324:	10bfe004 	addi	r2,r2,-128
8112b328:	00c00c04 	movi	r3,48
8112b32c:	10ffb626 	beq	r2,r3,8112b208 <__reset+0xfb10b208>
8112b330:	88ffffc5 	stb	r3,-1(r17)
8112b334:	d8c01e17 	ldw	r3,120(sp)
8112b338:	88bfffc4 	addi	r2,r17,-1
8112b33c:	1023883a 	mov	r17,r2
8112b340:	1887c83a 	sub	r3,r3,r2
8112b344:	d8c02115 	stw	r3,132(sp)
8112b348:	003fc706 	br	8112b268 <__reset+0xfb10b268>
8112b34c:	dac02317 	ldw	r11,140(sp)
8112b350:	00c00044 	movi	r3,1
8112b354:	d8c02015 	stw	r3,128(sp)
8112b358:	58800017 	ldw	r2,0(r11)
8112b35c:	5ac00104 	addi	r11,r11,4
8112b360:	d8001d85 	stb	zero,118(sp)
8112b364:	d8801005 	stb	r2,64(sp)
8112b368:	dac02315 	stw	r11,140(sp)
8112b36c:	d8c02115 	stw	r3,132(sp)
8112b370:	dc401004 	addi	r17,sp,64
8112b374:	0021883a 	mov	r16,zero
8112b378:	90c0008c 	andi	r3,r18,2
8112b37c:	d8c02215 	stw	r3,136(sp)
8112b380:	18000326 	beq	r3,zero,8112b390 <___svfiprintf_internal_r+0x5a0>
8112b384:	dac02017 	ldw	r11,128(sp)
8112b388:	5ac00084 	addi	r11,r11,2
8112b38c:	dac02015 	stw	r11,128(sp)
8112b390:	90c0210c 	andi	r3,r18,132
8112b394:	d8c02615 	stw	r3,152(sp)
8112b398:	1801131e 	bne	r3,zero,8112b7e8 <___svfiprintf_internal_r+0x9f8>
8112b39c:	dac02417 	ldw	r11,144(sp)
8112b3a0:	d8c02017 	ldw	r3,128(sp)
8112b3a4:	58f9c83a 	sub	fp,r11,r3
8112b3a8:	07010f0e 	bge	zero,fp,8112b7e8 <___svfiprintf_internal_r+0x9f8>
8112b3ac:	02400404 	movi	r9,16
8112b3b0:	d8c01c17 	ldw	r3,112(sp)
8112b3b4:	d8801b17 	ldw	r2,108(sp)
8112b3b8:	4f02d60e 	bge	r9,fp,8112bf14 <___svfiprintf_internal_r+0x1124>
8112b3bc:	01604574 	movhi	r5,33045
8112b3c0:	296e9504 	addi	r5,r5,-17836
8112b3c4:	d9402815 	stw	r5,160(sp)
8112b3c8:	028001c4 	movi	r10,7
8112b3cc:	00000306 	br	8112b3dc <___svfiprintf_internal_r+0x5ec>
8112b3d0:	e73ffc04 	addi	fp,fp,-16
8112b3d4:	42000204 	addi	r8,r8,8
8112b3d8:	4f00150e 	bge	r9,fp,8112b430 <___svfiprintf_internal_r+0x640>
8112b3dc:	18c00404 	addi	r3,r3,16
8112b3e0:	10800044 	addi	r2,r2,1
8112b3e4:	45800015 	stw	r22,0(r8)
8112b3e8:	42400115 	stw	r9,4(r8)
8112b3ec:	d8c01c15 	stw	r3,112(sp)
8112b3f0:	d8801b15 	stw	r2,108(sp)
8112b3f4:	50bff60e 	bge	r10,r2,8112b3d0 <__reset+0xfb10b3d0>
8112b3f8:	d9801a04 	addi	r6,sp,104
8112b3fc:	b80b883a 	mov	r5,r23
8112b400:	a809883a 	mov	r4,r21
8112b404:	da402c15 	stw	r9,176(sp)
8112b408:	da802d15 	stw	r10,180(sp)
8112b40c:	112ac180 	call	8112ac18 <__ssprint_r>
8112b410:	da402c17 	ldw	r9,176(sp)
8112b414:	da802d17 	ldw	r10,180(sp)
8112b418:	1001851e 	bne	r2,zero,8112ba30 <___svfiprintf_internal_r+0xc40>
8112b41c:	e73ffc04 	addi	fp,fp,-16
8112b420:	d8c01c17 	ldw	r3,112(sp)
8112b424:	d8801b17 	ldw	r2,108(sp)
8112b428:	d811883a 	mov	r8,sp
8112b42c:	4f3feb16 	blt	r9,fp,8112b3dc <__reset+0xfb10b3dc>
8112b430:	dac02817 	ldw	r11,160(sp)
8112b434:	e0c7883a 	add	r3,fp,r3
8112b438:	10800044 	addi	r2,r2,1
8112b43c:	42c00015 	stw	r11,0(r8)
8112b440:	47000115 	stw	fp,4(r8)
8112b444:	d8c01c15 	stw	r3,112(sp)
8112b448:	d8801b15 	stw	r2,108(sp)
8112b44c:	010001c4 	movi	r4,7
8112b450:	2081ee16 	blt	r4,r2,8112bc0c <___svfiprintf_internal_r+0xe1c>
8112b454:	42000204 	addi	r8,r8,8
8112b458:	0000e506 	br	8112b7f0 <___svfiprintf_internal_r+0xa00>
8112b45c:	21003fcc 	andi	r4,r4,255
8112b460:	2002dd1e 	bne	r4,zero,8112bfd8 <___svfiprintf_internal_r+0x11e8>
8112b464:	00a04574 	movhi	r2,33045
8112b468:	10ae0204 	addi	r2,r2,-18424
8112b46c:	d8802915 	stw	r2,164(sp)
8112b470:	9080080c 	andi	r2,r18,32
8112b474:	103f461e 	bne	r2,zero,8112b190 <__reset+0xfb10b190>
8112b478:	9080040c 	andi	r2,r18,16
8112b47c:	10022e1e 	bne	r2,zero,8112bd38 <___svfiprintf_internal_r+0xf48>
8112b480:	9080100c 	andi	r2,r18,64
8112b484:	dac02317 	ldw	r11,140(sp)
8112b488:	10027326 	beq	r2,zero,8112be58 <___svfiprintf_internal_r+0x1068>
8112b48c:	5f00000b 	ldhu	fp,0(r11)
8112b490:	5ac00104 	addi	r11,r11,4
8112b494:	0013883a 	mov	r9,zero
8112b498:	dac02315 	stw	r11,140(sp)
8112b49c:	003f4106 	br	8112b1a4 <__reset+0xfb10b1a4>
8112b4a0:	21003fcc 	andi	r4,r4,255
8112b4a4:	2002e11e 	bne	r4,zero,8112c02c <___svfiprintf_internal_r+0x123c>
8112b4a8:	9080080c 	andi	r2,r18,32
8112b4ac:	1002011e 	bne	r2,zero,8112bcb4 <___svfiprintf_internal_r+0xec4>
8112b4b0:	9080040c 	andi	r2,r18,16
8112b4b4:	10023e1e 	bne	r2,zero,8112bdb0 <___svfiprintf_internal_r+0xfc0>
8112b4b8:	9480100c 	andi	r18,r18,64
8112b4bc:	90023c26 	beq	r18,zero,8112bdb0 <___svfiprintf_internal_r+0xfc0>
8112b4c0:	dac02317 	ldw	r11,140(sp)
8112b4c4:	58800017 	ldw	r2,0(r11)
8112b4c8:	5ac00104 	addi	r11,r11,4
8112b4cc:	dac02315 	stw	r11,140(sp)
8112b4d0:	dac02517 	ldw	r11,148(sp)
8112b4d4:	12c0000d 	sth	r11,0(r2)
8112b4d8:	003e6e06 	br	8112ae94 <__reset+0xfb10ae94>
8112b4dc:	98c00007 	ldb	r3,0(r19)
8112b4e0:	1a422926 	beq	r3,r9,8112bd88 <___svfiprintf_internal_r+0xf98>
8112b4e4:	94800414 	ori	r18,r18,16
8112b4e8:	003e9206 	br	8112af34 <__reset+0xfb10af34>
8112b4ec:	94801014 	ori	r18,r18,64
8112b4f0:	98c00007 	ldb	r3,0(r19)
8112b4f4:	003e8f06 	br	8112af34 <__reset+0xfb10af34>
8112b4f8:	21003fcc 	andi	r4,r4,255
8112b4fc:	2002c71e 	bne	r4,zero,8112c01c <___svfiprintf_internal_r+0x122c>
8112b500:	9080080c 	andi	r2,r18,32
8112b504:	10004926 	beq	r2,zero,8112b62c <___svfiprintf_internal_r+0x83c>
8112b508:	dac02317 	ldw	r11,140(sp)
8112b50c:	58800117 	ldw	r2,4(r11)
8112b510:	5f000017 	ldw	fp,0(r11)
8112b514:	5ac00204 	addi	r11,r11,8
8112b518:	dac02315 	stw	r11,140(sp)
8112b51c:	1013883a 	mov	r9,r2
8112b520:	10004b16 	blt	r2,zero,8112b650 <___svfiprintf_internal_r+0x860>
8112b524:	da801d83 	ldbu	r10,118(sp)
8112b528:	8001cb16 	blt	r16,zero,8112bc58 <___svfiprintf_internal_r+0xe68>
8112b52c:	00ffdfc4 	movi	r3,-129
8112b530:	e244b03a 	or	r2,fp,r9
8112b534:	90e4703a 	and	r18,r18,r3
8112b538:	103f4726 	beq	r2,zero,8112b258 <__reset+0xfb10b258>
8112b53c:	48008c26 	beq	r9,zero,8112b770 <___svfiprintf_internal_r+0x980>
8112b540:	dc802015 	stw	r18,128(sp)
8112b544:	dc002115 	stw	r16,132(sp)
8112b548:	dc401a04 	addi	r17,sp,104
8112b54c:	e021883a 	mov	r16,fp
8112b550:	da002215 	stw	r8,136(sp)
8112b554:	5039883a 	mov	fp,r10
8112b558:	4825883a 	mov	r18,r9
8112b55c:	8009883a 	mov	r4,r16
8112b560:	900b883a 	mov	r5,r18
8112b564:	01800284 	movi	r6,10
8112b568:	000f883a 	mov	r7,zero
8112b56c:	112f17c0 	call	8112f17c <__umoddi3>
8112b570:	10800c04 	addi	r2,r2,48
8112b574:	8c7fffc4 	addi	r17,r17,-1
8112b578:	8009883a 	mov	r4,r16
8112b57c:	900b883a 	mov	r5,r18
8112b580:	88800005 	stb	r2,0(r17)
8112b584:	01800284 	movi	r6,10
8112b588:	000f883a 	mov	r7,zero
8112b58c:	112ebfc0 	call	8112ebfc <__udivdi3>
8112b590:	1021883a 	mov	r16,r2
8112b594:	10c4b03a 	or	r2,r2,r3
8112b598:	1825883a 	mov	r18,r3
8112b59c:	103fef1e 	bne	r2,zero,8112b55c <__reset+0xfb10b55c>
8112b5a0:	dc802017 	ldw	r18,128(sp)
8112b5a4:	dc002117 	ldw	r16,132(sp)
8112b5a8:	da002217 	ldw	r8,136(sp)
8112b5ac:	e015883a 	mov	r10,fp
8112b5b0:	d8c01e17 	ldw	r3,120(sp)
8112b5b4:	1c47c83a 	sub	r3,r3,r17
8112b5b8:	d8c02115 	stw	r3,132(sp)
8112b5bc:	003f2a06 	br	8112b268 <__reset+0xfb10b268>
8112b5c0:	dac02317 	ldw	r11,140(sp)
8112b5c4:	d8001d85 	stb	zero,118(sp)
8112b5c8:	5c400017 	ldw	r17,0(r11)
8112b5cc:	5f000104 	addi	fp,r11,4
8112b5d0:	88022f26 	beq	r17,zero,8112be90 <___svfiprintf_internal_r+0x10a0>
8112b5d4:	80022516 	blt	r16,zero,8112be6c <___svfiprintf_internal_r+0x107c>
8112b5d8:	800d883a 	mov	r6,r16
8112b5dc:	000b883a 	mov	r5,zero
8112b5e0:	8809883a 	mov	r4,r17
8112b5e4:	da002c15 	stw	r8,176(sp)
8112b5e8:	11271bc0 	call	811271bc <memchr>
8112b5ec:	da002c17 	ldw	r8,176(sp)
8112b5f0:	10026426 	beq	r2,zero,8112bf84 <___svfiprintf_internal_r+0x1194>
8112b5f4:	1445c83a 	sub	r2,r2,r17
8112b5f8:	d8802115 	stw	r2,132(sp)
8112b5fc:	da801d83 	ldbu	r10,118(sp)
8112b600:	df002315 	stw	fp,140(sp)
8112b604:	0021883a 	mov	r16,zero
8112b608:	003f1706 	br	8112b268 <__reset+0xfb10b268>
8112b60c:	94800814 	ori	r18,r18,32
8112b610:	98c00007 	ldb	r3,0(r19)
8112b614:	003e4706 	br	8112af34 <__reset+0xfb10af34>
8112b618:	21003fcc 	andi	r4,r4,255
8112b61c:	2002701e 	bne	r4,zero,8112bfe0 <___svfiprintf_internal_r+0x11f0>
8112b620:	94800414 	ori	r18,r18,16
8112b624:	9080080c 	andi	r2,r18,32
8112b628:	103fb71e 	bne	r2,zero,8112b508 <__reset+0xfb10b508>
8112b62c:	9080040c 	andi	r2,r18,16
8112b630:	1001ab26 	beq	r2,zero,8112bce0 <___svfiprintf_internal_r+0xef0>
8112b634:	dac02317 	ldw	r11,140(sp)
8112b638:	5f000017 	ldw	fp,0(r11)
8112b63c:	5ac00104 	addi	r11,r11,4
8112b640:	dac02315 	stw	r11,140(sp)
8112b644:	e013d7fa 	srai	r9,fp,31
8112b648:	4805883a 	mov	r2,r9
8112b64c:	103fb50e 	bge	r2,zero,8112b524 <__reset+0xfb10b524>
8112b650:	0739c83a 	sub	fp,zero,fp
8112b654:	02800b44 	movi	r10,45
8112b658:	e004c03a 	cmpne	r2,fp,zero
8112b65c:	0253c83a 	sub	r9,zero,r9
8112b660:	da801d85 	stb	r10,118(sp)
8112b664:	4893c83a 	sub	r9,r9,r2
8112b668:	80023016 	blt	r16,zero,8112bf2c <___svfiprintf_internal_r+0x113c>
8112b66c:	00bfdfc4 	movi	r2,-129
8112b670:	90a4703a 	and	r18,r18,r2
8112b674:	483fb21e 	bne	r9,zero,8112b540 <__reset+0xfb10b540>
8112b678:	00003d06 	br	8112b770 <___svfiprintf_internal_r+0x980>
8112b67c:	9817883a 	mov	r11,r19
8112b680:	d8002415 	stw	zero,144(sp)
8112b684:	18bff404 	addi	r2,r3,-48
8112b688:	0019883a 	mov	r12,zero
8112b68c:	58c00007 	ldb	r3,0(r11)
8112b690:	630002a4 	muli	r12,r12,10
8112b694:	9cc00044 	addi	r19,r19,1
8112b698:	9817883a 	mov	r11,r19
8112b69c:	1319883a 	add	r12,r2,r12
8112b6a0:	18bff404 	addi	r2,r3,-48
8112b6a4:	30bff92e 	bgeu	r6,r2,8112b68c <__reset+0xfb10b68c>
8112b6a8:	db002415 	stw	r12,144(sp)
8112b6ac:	18bff804 	addi	r2,r3,-32
8112b6b0:	28be232e 	bgeu	r5,r2,8112af40 <__reset+0xfb10af40>
8112b6b4:	21003fcc 	andi	r4,r4,255
8112b6b8:	20024b1e 	bne	r4,zero,8112bfe8 <___svfiprintf_internal_r+0x11f8>
8112b6bc:	1800d626 	beq	r3,zero,8112ba18 <___svfiprintf_internal_r+0xc28>
8112b6c0:	02c00044 	movi	r11,1
8112b6c4:	dac02015 	stw	r11,128(sp)
8112b6c8:	d8c01005 	stb	r3,64(sp)
8112b6cc:	d8001d85 	stb	zero,118(sp)
8112b6d0:	dac02115 	stw	r11,132(sp)
8112b6d4:	dc401004 	addi	r17,sp,64
8112b6d8:	003f2606 	br	8112b374 <__reset+0xfb10b374>
8112b6dc:	94802014 	ori	r18,r18,128
8112b6e0:	98c00007 	ldb	r3,0(r19)
8112b6e4:	003e1306 	br	8112af34 <__reset+0xfb10af34>
8112b6e8:	98c00007 	ldb	r3,0(r19)
8112b6ec:	9ac00044 	addi	r11,r19,1
8112b6f0:	1a822b26 	beq	r3,r10,8112bfa0 <___svfiprintf_internal_r+0x11b0>
8112b6f4:	18bff404 	addi	r2,r3,-48
8112b6f8:	0021883a 	mov	r16,zero
8112b6fc:	30821e36 	bltu	r6,r2,8112bf78 <___svfiprintf_internal_r+0x1188>
8112b700:	58c00007 	ldb	r3,0(r11)
8112b704:	840002a4 	muli	r16,r16,10
8112b708:	5cc00044 	addi	r19,r11,1
8112b70c:	9817883a 	mov	r11,r19
8112b710:	80a1883a 	add	r16,r16,r2
8112b714:	18bff404 	addi	r2,r3,-48
8112b718:	30bff92e 	bgeu	r6,r2,8112b700 <__reset+0xfb10b700>
8112b71c:	803e060e 	bge	r16,zero,8112af38 <__reset+0xfb10af38>
8112b720:	043fffc4 	movi	r16,-1
8112b724:	003e0406 	br	8112af38 <__reset+0xfb10af38>
8112b728:	21003fcc 	andi	r4,r4,255
8112b72c:	2002371e 	bne	r4,zero,8112c00c <___svfiprintf_internal_r+0x121c>
8112b730:	94800414 	ori	r18,r18,16
8112b734:	9080080c 	andi	r2,r18,32
8112b738:	103ebb1e 	bne	r2,zero,8112b228 <__reset+0xfb10b228>
8112b73c:	9080040c 	andi	r2,r18,16
8112b740:	10013b26 	beq	r2,zero,8112bc30 <___svfiprintf_internal_r+0xe40>
8112b744:	dac02317 	ldw	r11,140(sp)
8112b748:	d8001d85 	stb	zero,118(sp)
8112b74c:	0013883a 	mov	r9,zero
8112b750:	58800104 	addi	r2,r11,4
8112b754:	5f000017 	ldw	fp,0(r11)
8112b758:	80013d16 	blt	r16,zero,8112bc50 <___svfiprintf_internal_r+0xe60>
8112b75c:	00ffdfc4 	movi	r3,-129
8112b760:	d8802315 	stw	r2,140(sp)
8112b764:	90e4703a 	and	r18,r18,r3
8112b768:	0015883a 	mov	r10,zero
8112b76c:	e03eba26 	beq	fp,zero,8112b258 <__reset+0xfb10b258>
8112b770:	00800244 	movi	r2,9
8112b774:	173f7236 	bltu	r2,fp,8112b540 <__reset+0xfb10b540>
8112b778:	dac02b17 	ldw	r11,172(sp)
8112b77c:	e7000c04 	addi	fp,fp,48
8112b780:	df0019c5 	stb	fp,103(sp)
8112b784:	dac02115 	stw	r11,132(sp)
8112b788:	dc4019c4 	addi	r17,sp,103
8112b78c:	003eb606 	br	8112b268 <__reset+0xfb10b268>
8112b790:	21003fcc 	andi	r4,r4,255
8112b794:	20021f1e 	bne	r4,zero,8112c014 <___svfiprintf_internal_r+0x1224>
8112b798:	94800414 	ori	r18,r18,16
8112b79c:	9080080c 	andi	r2,r18,32
8112b7a0:	103ec51e 	bne	r2,zero,8112b2b8 <__reset+0xfb10b2b8>
8112b7a4:	9080040c 	andi	r2,r18,16
8112b7a8:	10016926 	beq	r2,zero,8112bd50 <___svfiprintf_internal_r+0xf60>
8112b7ac:	dac02317 	ldw	r11,140(sp)
8112b7b0:	d8001d85 	stb	zero,118(sp)
8112b7b4:	0013883a 	mov	r9,zero
8112b7b8:	58800104 	addi	r2,r11,4
8112b7bc:	5f000017 	ldw	fp,0(r11)
8112b7c0:	80016b16 	blt	r16,zero,8112bd70 <___svfiprintf_internal_r+0xf80>
8112b7c4:	00ffdfc4 	movi	r3,-129
8112b7c8:	d8802315 	stw	r2,140(sp)
8112b7cc:	90e4703a 	and	r18,r18,r3
8112b7d0:	e03ec41e 	bne	fp,zero,8112b2e4 <__reset+0xfb10b2e4>
8112b7d4:	0015883a 	mov	r10,zero
8112b7d8:	8001c226 	beq	r16,zero,8112bee4 <___svfiprintf_internal_r+0x10f4>
8112b7dc:	0039883a 	mov	fp,zero
8112b7e0:	0013883a 	mov	r9,zero
8112b7e4:	003ec006 	br	8112b2e8 <__reset+0xfb10b2e8>
8112b7e8:	d8c01c17 	ldw	r3,112(sp)
8112b7ec:	d8801b17 	ldw	r2,108(sp)
8112b7f0:	d9001d87 	ldb	r4,118(sp)
8112b7f4:	20000b26 	beq	r4,zero,8112b824 <___svfiprintf_internal_r+0xa34>
8112b7f8:	d9001d84 	addi	r4,sp,118
8112b7fc:	18c00044 	addi	r3,r3,1
8112b800:	10800044 	addi	r2,r2,1
8112b804:	41000015 	stw	r4,0(r8)
8112b808:	01000044 	movi	r4,1
8112b80c:	41000115 	stw	r4,4(r8)
8112b810:	d8c01c15 	stw	r3,112(sp)
8112b814:	d8801b15 	stw	r2,108(sp)
8112b818:	010001c4 	movi	r4,7
8112b81c:	2080e116 	blt	r4,r2,8112bba4 <___svfiprintf_internal_r+0xdb4>
8112b820:	42000204 	addi	r8,r8,8
8112b824:	dac02217 	ldw	r11,136(sp)
8112b828:	58000b26 	beq	r11,zero,8112b858 <___svfiprintf_internal_r+0xa68>
8112b82c:	d9001d04 	addi	r4,sp,116
8112b830:	18c00084 	addi	r3,r3,2
8112b834:	10800044 	addi	r2,r2,1
8112b838:	41000015 	stw	r4,0(r8)
8112b83c:	01000084 	movi	r4,2
8112b840:	41000115 	stw	r4,4(r8)
8112b844:	d8c01c15 	stw	r3,112(sp)
8112b848:	d8801b15 	stw	r2,108(sp)
8112b84c:	010001c4 	movi	r4,7
8112b850:	2080dd16 	blt	r4,r2,8112bbc8 <___svfiprintf_internal_r+0xdd8>
8112b854:	42000204 	addi	r8,r8,8
8112b858:	dac02617 	ldw	r11,152(sp)
8112b85c:	01002004 	movi	r4,128
8112b860:	59008426 	beq	r11,r4,8112ba74 <___svfiprintf_internal_r+0xc84>
8112b864:	dac02117 	ldw	r11,132(sp)
8112b868:	82e1c83a 	sub	r16,r16,r11
8112b86c:	0400270e 	bge	zero,r16,8112b90c <___svfiprintf_internal_r+0xb1c>
8112b870:	01c00404 	movi	r7,16
8112b874:	3c016a0e 	bge	r7,r16,8112be20 <___svfiprintf_internal_r+0x1030>
8112b878:	01604574 	movhi	r5,33045
8112b87c:	296e9104 	addi	r5,r5,-17852
8112b880:	d9402215 	stw	r5,136(sp)
8112b884:	070001c4 	movi	fp,7
8112b888:	00000306 	br	8112b898 <___svfiprintf_internal_r+0xaa8>
8112b88c:	843ffc04 	addi	r16,r16,-16
8112b890:	42000204 	addi	r8,r8,8
8112b894:	3c00130e 	bge	r7,r16,8112b8e4 <___svfiprintf_internal_r+0xaf4>
8112b898:	18c00404 	addi	r3,r3,16
8112b89c:	10800044 	addi	r2,r2,1
8112b8a0:	45000015 	stw	r20,0(r8)
8112b8a4:	41c00115 	stw	r7,4(r8)
8112b8a8:	d8c01c15 	stw	r3,112(sp)
8112b8ac:	d8801b15 	stw	r2,108(sp)
8112b8b0:	e0bff60e 	bge	fp,r2,8112b88c <__reset+0xfb10b88c>
8112b8b4:	d9801a04 	addi	r6,sp,104
8112b8b8:	b80b883a 	mov	r5,r23
8112b8bc:	a809883a 	mov	r4,r21
8112b8c0:	d9c02c15 	stw	r7,176(sp)
8112b8c4:	112ac180 	call	8112ac18 <__ssprint_r>
8112b8c8:	d9c02c17 	ldw	r7,176(sp)
8112b8cc:	1000581e 	bne	r2,zero,8112ba30 <___svfiprintf_internal_r+0xc40>
8112b8d0:	843ffc04 	addi	r16,r16,-16
8112b8d4:	d8c01c17 	ldw	r3,112(sp)
8112b8d8:	d8801b17 	ldw	r2,108(sp)
8112b8dc:	d811883a 	mov	r8,sp
8112b8e0:	3c3fed16 	blt	r7,r16,8112b898 <__reset+0xfb10b898>
8112b8e4:	dac02217 	ldw	r11,136(sp)
8112b8e8:	1c07883a 	add	r3,r3,r16
8112b8ec:	10800044 	addi	r2,r2,1
8112b8f0:	42c00015 	stw	r11,0(r8)
8112b8f4:	44000115 	stw	r16,4(r8)
8112b8f8:	d8c01c15 	stw	r3,112(sp)
8112b8fc:	d8801b15 	stw	r2,108(sp)
8112b900:	010001c4 	movi	r4,7
8112b904:	20809e16 	blt	r4,r2,8112bb80 <___svfiprintf_internal_r+0xd90>
8112b908:	42000204 	addi	r8,r8,8
8112b90c:	dac02117 	ldw	r11,132(sp)
8112b910:	10800044 	addi	r2,r2,1
8112b914:	44400015 	stw	r17,0(r8)
8112b918:	58c7883a 	add	r3,r11,r3
8112b91c:	42c00115 	stw	r11,4(r8)
8112b920:	d8c01c15 	stw	r3,112(sp)
8112b924:	d8801b15 	stw	r2,108(sp)
8112b928:	010001c4 	movi	r4,7
8112b92c:	20807f16 	blt	r4,r2,8112bb2c <___svfiprintf_internal_r+0xd3c>
8112b930:	42000204 	addi	r8,r8,8
8112b934:	9480010c 	andi	r18,r18,4
8112b938:	90002926 	beq	r18,zero,8112b9e0 <___svfiprintf_internal_r+0xbf0>
8112b93c:	dac02417 	ldw	r11,144(sp)
8112b940:	d8802017 	ldw	r2,128(sp)
8112b944:	58a1c83a 	sub	r16,r11,r2
8112b948:	0400250e 	bge	zero,r16,8112b9e0 <___svfiprintf_internal_r+0xbf0>
8112b94c:	04400404 	movi	r17,16
8112b950:	d8801b17 	ldw	r2,108(sp)
8112b954:	8c017c0e 	bge	r17,r16,8112bf48 <___svfiprintf_internal_r+0x1158>
8112b958:	01604574 	movhi	r5,33045
8112b95c:	296e9504 	addi	r5,r5,-17836
8112b960:	d9402815 	stw	r5,160(sp)
8112b964:	048001c4 	movi	r18,7
8112b968:	00000306 	br	8112b978 <___svfiprintf_internal_r+0xb88>
8112b96c:	843ffc04 	addi	r16,r16,-16
8112b970:	42000204 	addi	r8,r8,8
8112b974:	8c00110e 	bge	r17,r16,8112b9bc <___svfiprintf_internal_r+0xbcc>
8112b978:	18c00404 	addi	r3,r3,16
8112b97c:	10800044 	addi	r2,r2,1
8112b980:	45800015 	stw	r22,0(r8)
8112b984:	44400115 	stw	r17,4(r8)
8112b988:	d8c01c15 	stw	r3,112(sp)
8112b98c:	d8801b15 	stw	r2,108(sp)
8112b990:	90bff60e 	bge	r18,r2,8112b96c <__reset+0xfb10b96c>
8112b994:	d9801a04 	addi	r6,sp,104
8112b998:	b80b883a 	mov	r5,r23
8112b99c:	a809883a 	mov	r4,r21
8112b9a0:	112ac180 	call	8112ac18 <__ssprint_r>
8112b9a4:	1000221e 	bne	r2,zero,8112ba30 <___svfiprintf_internal_r+0xc40>
8112b9a8:	843ffc04 	addi	r16,r16,-16
8112b9ac:	d8c01c17 	ldw	r3,112(sp)
8112b9b0:	d8801b17 	ldw	r2,108(sp)
8112b9b4:	d811883a 	mov	r8,sp
8112b9b8:	8c3fef16 	blt	r17,r16,8112b978 <__reset+0xfb10b978>
8112b9bc:	dac02817 	ldw	r11,160(sp)
8112b9c0:	1c07883a 	add	r3,r3,r16
8112b9c4:	10800044 	addi	r2,r2,1
8112b9c8:	42c00015 	stw	r11,0(r8)
8112b9cc:	44000115 	stw	r16,4(r8)
8112b9d0:	d8c01c15 	stw	r3,112(sp)
8112b9d4:	d8801b15 	stw	r2,108(sp)
8112b9d8:	010001c4 	movi	r4,7
8112b9dc:	2080aa16 	blt	r4,r2,8112bc88 <___svfiprintf_internal_r+0xe98>
8112b9e0:	d8802417 	ldw	r2,144(sp)
8112b9e4:	dac02017 	ldw	r11,128(sp)
8112b9e8:	12c0010e 	bge	r2,r11,8112b9f0 <___svfiprintf_internal_r+0xc00>
8112b9ec:	5805883a 	mov	r2,r11
8112b9f0:	dac02517 	ldw	r11,148(sp)
8112b9f4:	5897883a 	add	r11,r11,r2
8112b9f8:	dac02515 	stw	r11,148(sp)
8112b9fc:	1800531e 	bne	r3,zero,8112bb4c <___svfiprintf_internal_r+0xd5c>
8112ba00:	98800007 	ldb	r2,0(r19)
8112ba04:	d8001b15 	stw	zero,108(sp)
8112ba08:	d811883a 	mov	r8,sp
8112ba0c:	103d231e 	bne	r2,zero,8112ae9c <__reset+0xfb10ae9c>
8112ba10:	9823883a 	mov	r17,r19
8112ba14:	003d3906 	br	8112aefc <__reset+0xfb10aefc>
8112ba18:	d8801c17 	ldw	r2,112(sp)
8112ba1c:	10000426 	beq	r2,zero,8112ba30 <___svfiprintf_internal_r+0xc40>
8112ba20:	d9402717 	ldw	r5,156(sp)
8112ba24:	d9002a17 	ldw	r4,168(sp)
8112ba28:	d9801a04 	addi	r6,sp,104
8112ba2c:	112ac180 	call	8112ac18 <__ssprint_r>
8112ba30:	dac02717 	ldw	r11,156(sp)
8112ba34:	d8802517 	ldw	r2,148(sp)
8112ba38:	58c0030b 	ldhu	r3,12(r11)
8112ba3c:	18c0100c 	andi	r3,r3,64
8112ba40:	1801381e 	bne	r3,zero,8112bf24 <___svfiprintf_internal_r+0x1134>
8112ba44:	dfc03717 	ldw	ra,220(sp)
8112ba48:	df003617 	ldw	fp,216(sp)
8112ba4c:	ddc03517 	ldw	r23,212(sp)
8112ba50:	dd803417 	ldw	r22,208(sp)
8112ba54:	dd403317 	ldw	r21,204(sp)
8112ba58:	dd003217 	ldw	r20,200(sp)
8112ba5c:	dcc03117 	ldw	r19,196(sp)
8112ba60:	dc803017 	ldw	r18,192(sp)
8112ba64:	dc402f17 	ldw	r17,188(sp)
8112ba68:	dc002e17 	ldw	r16,184(sp)
8112ba6c:	dec03804 	addi	sp,sp,224
8112ba70:	f800283a 	ret
8112ba74:	dac02417 	ldw	r11,144(sp)
8112ba78:	d9002017 	ldw	r4,128(sp)
8112ba7c:	5939c83a 	sub	fp,r11,r4
8112ba80:	073f780e 	bge	zero,fp,8112b864 <__reset+0xfb10b864>
8112ba84:	02400404 	movi	r9,16
8112ba88:	4f01370e 	bge	r9,fp,8112bf68 <___svfiprintf_internal_r+0x1178>
8112ba8c:	02e04574 	movhi	r11,33045
8112ba90:	5aee9104 	addi	r11,r11,-17852
8112ba94:	dac02215 	stw	r11,136(sp)
8112ba98:	028001c4 	movi	r10,7
8112ba9c:	00000306 	br	8112baac <___svfiprintf_internal_r+0xcbc>
8112baa0:	e73ffc04 	addi	fp,fp,-16
8112baa4:	42000204 	addi	r8,r8,8
8112baa8:	4f00150e 	bge	r9,fp,8112bb00 <___svfiprintf_internal_r+0xd10>
8112baac:	18c00404 	addi	r3,r3,16
8112bab0:	10800044 	addi	r2,r2,1
8112bab4:	45000015 	stw	r20,0(r8)
8112bab8:	42400115 	stw	r9,4(r8)
8112babc:	d8c01c15 	stw	r3,112(sp)
8112bac0:	d8801b15 	stw	r2,108(sp)
8112bac4:	50bff60e 	bge	r10,r2,8112baa0 <__reset+0xfb10baa0>
8112bac8:	d9801a04 	addi	r6,sp,104
8112bacc:	b80b883a 	mov	r5,r23
8112bad0:	a809883a 	mov	r4,r21
8112bad4:	da402c15 	stw	r9,176(sp)
8112bad8:	da802d15 	stw	r10,180(sp)
8112badc:	112ac180 	call	8112ac18 <__ssprint_r>
8112bae0:	da402c17 	ldw	r9,176(sp)
8112bae4:	da802d17 	ldw	r10,180(sp)
8112bae8:	103fd11e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112baec:	e73ffc04 	addi	fp,fp,-16
8112baf0:	d8c01c17 	ldw	r3,112(sp)
8112baf4:	d8801b17 	ldw	r2,108(sp)
8112baf8:	d811883a 	mov	r8,sp
8112bafc:	4f3feb16 	blt	r9,fp,8112baac <__reset+0xfb10baac>
8112bb00:	dac02217 	ldw	r11,136(sp)
8112bb04:	1f07883a 	add	r3,r3,fp
8112bb08:	10800044 	addi	r2,r2,1
8112bb0c:	42c00015 	stw	r11,0(r8)
8112bb10:	47000115 	stw	fp,4(r8)
8112bb14:	d8c01c15 	stw	r3,112(sp)
8112bb18:	d8801b15 	stw	r2,108(sp)
8112bb1c:	010001c4 	movi	r4,7
8112bb20:	2080b616 	blt	r4,r2,8112bdfc <___svfiprintf_internal_r+0x100c>
8112bb24:	42000204 	addi	r8,r8,8
8112bb28:	003f4e06 	br	8112b864 <__reset+0xfb10b864>
8112bb2c:	d9801a04 	addi	r6,sp,104
8112bb30:	b80b883a 	mov	r5,r23
8112bb34:	a809883a 	mov	r4,r21
8112bb38:	112ac180 	call	8112ac18 <__ssprint_r>
8112bb3c:	103fbc1e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112bb40:	d8c01c17 	ldw	r3,112(sp)
8112bb44:	d811883a 	mov	r8,sp
8112bb48:	003f7a06 	br	8112b934 <__reset+0xfb10b934>
8112bb4c:	d9801a04 	addi	r6,sp,104
8112bb50:	b80b883a 	mov	r5,r23
8112bb54:	a809883a 	mov	r4,r21
8112bb58:	112ac180 	call	8112ac18 <__ssprint_r>
8112bb5c:	103fa826 	beq	r2,zero,8112ba00 <__reset+0xfb10ba00>
8112bb60:	003fb306 	br	8112ba30 <__reset+0xfb10ba30>
8112bb64:	d9801a04 	addi	r6,sp,104
8112bb68:	b80b883a 	mov	r5,r23
8112bb6c:	a809883a 	mov	r4,r21
8112bb70:	112ac180 	call	8112ac18 <__ssprint_r>
8112bb74:	103fae1e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112bb78:	d811883a 	mov	r8,sp
8112bb7c:	003cdc06 	br	8112aef0 <__reset+0xfb10aef0>
8112bb80:	d9801a04 	addi	r6,sp,104
8112bb84:	b80b883a 	mov	r5,r23
8112bb88:	a809883a 	mov	r4,r21
8112bb8c:	112ac180 	call	8112ac18 <__ssprint_r>
8112bb90:	103fa71e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112bb94:	d8c01c17 	ldw	r3,112(sp)
8112bb98:	d8801b17 	ldw	r2,108(sp)
8112bb9c:	d811883a 	mov	r8,sp
8112bba0:	003f5a06 	br	8112b90c <__reset+0xfb10b90c>
8112bba4:	d9801a04 	addi	r6,sp,104
8112bba8:	b80b883a 	mov	r5,r23
8112bbac:	a809883a 	mov	r4,r21
8112bbb0:	112ac180 	call	8112ac18 <__ssprint_r>
8112bbb4:	103f9e1e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112bbb8:	d8c01c17 	ldw	r3,112(sp)
8112bbbc:	d8801b17 	ldw	r2,108(sp)
8112bbc0:	d811883a 	mov	r8,sp
8112bbc4:	003f1706 	br	8112b824 <__reset+0xfb10b824>
8112bbc8:	d9801a04 	addi	r6,sp,104
8112bbcc:	b80b883a 	mov	r5,r23
8112bbd0:	a809883a 	mov	r4,r21
8112bbd4:	112ac180 	call	8112ac18 <__ssprint_r>
8112bbd8:	103f951e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112bbdc:	d8c01c17 	ldw	r3,112(sp)
8112bbe0:	d8801b17 	ldw	r2,108(sp)
8112bbe4:	d811883a 	mov	r8,sp
8112bbe8:	003f1b06 	br	8112b858 <__reset+0xfb10b858>
8112bbec:	d8001d85 	stb	zero,118(sp)
8112bbf0:	80007b16 	blt	r16,zero,8112bde0 <___svfiprintf_internal_r+0xff0>
8112bbf4:	00ffdfc4 	movi	r3,-129
8112bbf8:	e244b03a 	or	r2,fp,r9
8112bbfc:	90e4703a 	and	r18,r18,r3
8112bc00:	103d7026 	beq	r2,zero,8112b1c4 <__reset+0xfb10b1c4>
8112bc04:	0015883a 	mov	r10,zero
8112bc08:	003d7206 	br	8112b1d4 <__reset+0xfb10b1d4>
8112bc0c:	d9801a04 	addi	r6,sp,104
8112bc10:	b80b883a 	mov	r5,r23
8112bc14:	a809883a 	mov	r4,r21
8112bc18:	112ac180 	call	8112ac18 <__ssprint_r>
8112bc1c:	103f841e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112bc20:	d8c01c17 	ldw	r3,112(sp)
8112bc24:	d8801b17 	ldw	r2,108(sp)
8112bc28:	d811883a 	mov	r8,sp
8112bc2c:	003ef006 	br	8112b7f0 <__reset+0xfb10b7f0>
8112bc30:	9080100c 	andi	r2,r18,64
8112bc34:	d8001d85 	stb	zero,118(sp)
8112bc38:	dac02317 	ldw	r11,140(sp)
8112bc3c:	10008126 	beq	r2,zero,8112be44 <___svfiprintf_internal_r+0x1054>
8112bc40:	58800104 	addi	r2,r11,4
8112bc44:	5f00000b 	ldhu	fp,0(r11)
8112bc48:	0013883a 	mov	r9,zero
8112bc4c:	803ec30e 	bge	r16,zero,8112b75c <__reset+0xfb10b75c>
8112bc50:	d8802315 	stw	r2,140(sp)
8112bc54:	0015883a 	mov	r10,zero
8112bc58:	e244b03a 	or	r2,fp,r9
8112bc5c:	103e371e 	bne	r2,zero,8112b53c <__reset+0xfb10b53c>
8112bc60:	00800044 	movi	r2,1
8112bc64:	10803fcc 	andi	r2,r2,255
8112bc68:	00c00044 	movi	r3,1
8112bc6c:	10c06126 	beq	r2,r3,8112bdf4 <___svfiprintf_internal_r+0x1004>
8112bc70:	00c00084 	movi	r3,2
8112bc74:	10fd5526 	beq	r2,r3,8112b1cc <__reset+0xfb10b1cc>
8112bc78:	003ed806 	br	8112b7dc <__reset+0xfb10b7dc>
8112bc7c:	d8802315 	stw	r2,140(sp)
8112bc80:	98c00007 	ldb	r3,0(r19)
8112bc84:	003cab06 	br	8112af34 <__reset+0xfb10af34>
8112bc88:	d9801a04 	addi	r6,sp,104
8112bc8c:	b80b883a 	mov	r5,r23
8112bc90:	a809883a 	mov	r4,r21
8112bc94:	112ac180 	call	8112ac18 <__ssprint_r>
8112bc98:	103f651e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112bc9c:	d8c01c17 	ldw	r3,112(sp)
8112bca0:	003f4f06 	br	8112b9e0 <__reset+0xfb10b9e0>
8112bca4:	00a04574 	movhi	r2,33045
8112bca8:	10ae0704 	addi	r2,r2,-18404
8112bcac:	d8802915 	stw	r2,164(sp)
8112bcb0:	003d4406 	br	8112b1c4 <__reset+0xfb10b1c4>
8112bcb4:	dac02317 	ldw	r11,140(sp)
8112bcb8:	58800017 	ldw	r2,0(r11)
8112bcbc:	dac02517 	ldw	r11,148(sp)
8112bcc0:	5807d7fa 	srai	r3,r11,31
8112bcc4:	dac02317 	ldw	r11,140(sp)
8112bcc8:	10c00115 	stw	r3,4(r2)
8112bccc:	5ac00104 	addi	r11,r11,4
8112bcd0:	dac02315 	stw	r11,140(sp)
8112bcd4:	dac02517 	ldw	r11,148(sp)
8112bcd8:	12c00015 	stw	r11,0(r2)
8112bcdc:	003c6d06 	br	8112ae94 <__reset+0xfb10ae94>
8112bce0:	9080100c 	andi	r2,r18,64
8112bce4:	dac02317 	ldw	r11,140(sp)
8112bce8:	103e5326 	beq	r2,zero,8112b638 <__reset+0xfb10b638>
8112bcec:	5f00000f 	ldh	fp,0(r11)
8112bcf0:	5ac00104 	addi	r11,r11,4
8112bcf4:	dac02315 	stw	r11,140(sp)
8112bcf8:	e013d7fa 	srai	r9,fp,31
8112bcfc:	4805883a 	mov	r2,r9
8112bd00:	003e0706 	br	8112b520 <__reset+0xfb10b520>
8112bd04:	00800c04 	movi	r2,48
8112bd08:	d8801d05 	stb	r2,116(sp)
8112bd0c:	d8c01d45 	stb	r3,117(sp)
8112bd10:	d8001d85 	stb	zero,118(sp)
8112bd14:	90800094 	ori	r2,r18,2
8112bd18:	80008f16 	blt	r16,zero,8112bf58 <___svfiprintf_internal_r+0x1168>
8112bd1c:	00bfdfc4 	movi	r2,-129
8112bd20:	90a4703a 	and	r18,r18,r2
8112bd24:	94800094 	ori	r18,r18,2
8112bd28:	0015883a 	mov	r10,zero
8112bd2c:	003d2906 	br	8112b1d4 <__reset+0xfb10b1d4>
8112bd30:	98c00007 	ldb	r3,0(r19)
8112bd34:	003c7f06 	br	8112af34 <__reset+0xfb10af34>
8112bd38:	dac02317 	ldw	r11,140(sp)
8112bd3c:	0013883a 	mov	r9,zero
8112bd40:	5f000017 	ldw	fp,0(r11)
8112bd44:	5ac00104 	addi	r11,r11,4
8112bd48:	dac02315 	stw	r11,140(sp)
8112bd4c:	003d1506 	br	8112b1a4 <__reset+0xfb10b1a4>
8112bd50:	9080100c 	andi	r2,r18,64
8112bd54:	d8001d85 	stb	zero,118(sp)
8112bd58:	dac02317 	ldw	r11,140(sp)
8112bd5c:	10003426 	beq	r2,zero,8112be30 <___svfiprintf_internal_r+0x1040>
8112bd60:	58800104 	addi	r2,r11,4
8112bd64:	5f00000b 	ldhu	fp,0(r11)
8112bd68:	0013883a 	mov	r9,zero
8112bd6c:	803e950e 	bge	r16,zero,8112b7c4 <__reset+0xfb10b7c4>
8112bd70:	e246b03a 	or	r3,fp,r9
8112bd74:	d8802315 	stw	r2,140(sp)
8112bd78:	183d5a1e 	bne	r3,zero,8112b2e4 <__reset+0xfb10b2e4>
8112bd7c:	0015883a 	mov	r10,zero
8112bd80:	0005883a 	mov	r2,zero
8112bd84:	003fb706 	br	8112bc64 <__reset+0xfb10bc64>
8112bd88:	98c00043 	ldbu	r3,1(r19)
8112bd8c:	94800814 	ori	r18,r18,32
8112bd90:	9cc00044 	addi	r19,r19,1
8112bd94:	18c03fcc 	andi	r3,r3,255
8112bd98:	18c0201c 	xori	r3,r3,128
8112bd9c:	18ffe004 	addi	r3,r3,-128
8112bda0:	003c6406 	br	8112af34 <__reset+0xfb10af34>
8112bda4:	d8c02315 	stw	r3,140(sp)
8112bda8:	0015883a 	mov	r10,zero
8112bdac:	003faa06 	br	8112bc58 <__reset+0xfb10bc58>
8112bdb0:	dac02317 	ldw	r11,140(sp)
8112bdb4:	58800017 	ldw	r2,0(r11)
8112bdb8:	5ac00104 	addi	r11,r11,4
8112bdbc:	dac02315 	stw	r11,140(sp)
8112bdc0:	dac02517 	ldw	r11,148(sp)
8112bdc4:	12c00015 	stw	r11,0(r2)
8112bdc8:	003c3206 	br	8112ae94 <__reset+0xfb10ae94>
8112bdcc:	01204574 	movhi	r4,33045
8112bdd0:	212e0704 	addi	r4,r4,-18404
8112bdd4:	d9002915 	stw	r4,164(sp)
8112bdd8:	d8c02315 	stw	r3,140(sp)
8112bddc:	1025883a 	mov	r18,r2
8112bde0:	e244b03a 	or	r2,fp,r9
8112bde4:	103f871e 	bne	r2,zero,8112bc04 <__reset+0xfb10bc04>
8112bde8:	0015883a 	mov	r10,zero
8112bdec:	00800084 	movi	r2,2
8112bdf0:	003f9c06 	br	8112bc64 <__reset+0xfb10bc64>
8112bdf4:	0039883a 	mov	fp,zero
8112bdf8:	003e5f06 	br	8112b778 <__reset+0xfb10b778>
8112bdfc:	d9801a04 	addi	r6,sp,104
8112be00:	b80b883a 	mov	r5,r23
8112be04:	a809883a 	mov	r4,r21
8112be08:	112ac180 	call	8112ac18 <__ssprint_r>
8112be0c:	103f081e 	bne	r2,zero,8112ba30 <__reset+0xfb10ba30>
8112be10:	d8c01c17 	ldw	r3,112(sp)
8112be14:	d8801b17 	ldw	r2,108(sp)
8112be18:	d811883a 	mov	r8,sp
8112be1c:	003e9106 	br	8112b864 <__reset+0xfb10b864>
8112be20:	01204574 	movhi	r4,33045
8112be24:	212e9104 	addi	r4,r4,-17852
8112be28:	d9002215 	stw	r4,136(sp)
8112be2c:	003ead06 	br	8112b8e4 <__reset+0xfb10b8e4>
8112be30:	58800104 	addi	r2,r11,4
8112be34:	5f000017 	ldw	fp,0(r11)
8112be38:	0013883a 	mov	r9,zero
8112be3c:	803e610e 	bge	r16,zero,8112b7c4 <__reset+0xfb10b7c4>
8112be40:	003fcb06 	br	8112bd70 <__reset+0xfb10bd70>
8112be44:	58800104 	addi	r2,r11,4
8112be48:	5f000017 	ldw	fp,0(r11)
8112be4c:	0013883a 	mov	r9,zero
8112be50:	803e420e 	bge	r16,zero,8112b75c <__reset+0xfb10b75c>
8112be54:	003f7e06 	br	8112bc50 <__reset+0xfb10bc50>
8112be58:	5f000017 	ldw	fp,0(r11)
8112be5c:	5ac00104 	addi	r11,r11,4
8112be60:	0013883a 	mov	r9,zero
8112be64:	dac02315 	stw	r11,140(sp)
8112be68:	003cce06 	br	8112b1a4 <__reset+0xfb10b1a4>
8112be6c:	8809883a 	mov	r4,r17
8112be70:	da002c15 	stw	r8,176(sp)
8112be74:	111dcc00 	call	8111dcc0 <strlen>
8112be78:	d8802115 	stw	r2,132(sp)
8112be7c:	da801d83 	ldbu	r10,118(sp)
8112be80:	df002315 	stw	fp,140(sp)
8112be84:	0021883a 	mov	r16,zero
8112be88:	da002c17 	ldw	r8,176(sp)
8112be8c:	003cf606 	br	8112b268 <__reset+0xfb10b268>
8112be90:	00800184 	movi	r2,6
8112be94:	1400012e 	bgeu	r2,r16,8112be9c <___svfiprintf_internal_r+0x10ac>
8112be98:	1021883a 	mov	r16,r2
8112be9c:	dc002115 	stw	r16,132(sp)
8112bea0:	8005883a 	mov	r2,r16
8112bea4:	80003c16 	blt	r16,zero,8112bf98 <___svfiprintf_internal_r+0x11a8>
8112bea8:	04604574 	movhi	r17,33045
8112beac:	d8802015 	stw	r2,128(sp)
8112beb0:	df002315 	stw	fp,140(sp)
8112beb4:	8c6e0c04 	addi	r17,r17,-18384
8112beb8:	003d2e06 	br	8112b374 <__reset+0xfb10b374>
8112bebc:	04001004 	movi	r16,64
8112bec0:	800b883a 	mov	r5,r16
8112bec4:	111c9b80 	call	8111c9b8 <_malloc_r>
8112bec8:	dac02717 	ldw	r11,156(sp)
8112becc:	58800015 	stw	r2,0(r11)
8112bed0:	58800415 	stw	r2,16(r11)
8112bed4:	10004826 	beq	r2,zero,8112bff8 <___svfiprintf_internal_r+0x1208>
8112bed8:	dac02717 	ldw	r11,156(sp)
8112bedc:	5c000515 	stw	r16,20(r11)
8112bee0:	003bd906 	br	8112ae48 <__reset+0xfb10ae48>
8112bee4:	9080004c 	andi	r2,r18,1
8112bee8:	0015883a 	mov	r10,zero
8112beec:	10000626 	beq	r2,zero,8112bf08 <___svfiprintf_internal_r+0x1118>
8112bef0:	dac02b17 	ldw	r11,172(sp)
8112bef4:	00800c04 	movi	r2,48
8112bef8:	d88019c5 	stb	r2,103(sp)
8112befc:	dac02115 	stw	r11,132(sp)
8112bf00:	dc4019c4 	addi	r17,sp,103
8112bf04:	003cd806 	br	8112b268 <__reset+0xfb10b268>
8112bf08:	d8002115 	stw	zero,132(sp)
8112bf0c:	dc401a04 	addi	r17,sp,104
8112bf10:	003cd506 	br	8112b268 <__reset+0xfb10b268>
8112bf14:	01204574 	movhi	r4,33045
8112bf18:	212e9504 	addi	r4,r4,-17836
8112bf1c:	d9002815 	stw	r4,160(sp)
8112bf20:	003d4306 	br	8112b430 <__reset+0xfb10b430>
8112bf24:	00bfffc4 	movi	r2,-1
8112bf28:	003ec606 	br	8112ba44 <__reset+0xfb10ba44>
8112bf2c:	00800044 	movi	r2,1
8112bf30:	10803fcc 	andi	r2,r2,255
8112bf34:	00c00044 	movi	r3,1
8112bf38:	10fd8026 	beq	r2,r3,8112b53c <__reset+0xfb10b53c>
8112bf3c:	00c00084 	movi	r3,2
8112bf40:	10fca426 	beq	r2,r3,8112b1d4 <__reset+0xfb10b1d4>
8112bf44:	003ce806 	br	8112b2e8 <__reset+0xfb10b2e8>
8112bf48:	01204574 	movhi	r4,33045
8112bf4c:	212e9504 	addi	r4,r4,-17836
8112bf50:	d9002815 	stw	r4,160(sp)
8112bf54:	003e9906 	br	8112b9bc <__reset+0xfb10b9bc>
8112bf58:	1025883a 	mov	r18,r2
8112bf5c:	0015883a 	mov	r10,zero
8112bf60:	00800084 	movi	r2,2
8112bf64:	003ff206 	br	8112bf30 <__reset+0xfb10bf30>
8112bf68:	01604574 	movhi	r5,33045
8112bf6c:	296e9104 	addi	r5,r5,-17852
8112bf70:	d9402215 	stw	r5,136(sp)
8112bf74:	003ee206 	br	8112bb00 <__reset+0xfb10bb00>
8112bf78:	5827883a 	mov	r19,r11
8112bf7c:	0021883a 	mov	r16,zero
8112bf80:	003bed06 	br	8112af38 <__reset+0xfb10af38>
8112bf84:	dc002115 	stw	r16,132(sp)
8112bf88:	da801d83 	ldbu	r10,118(sp)
8112bf8c:	df002315 	stw	fp,140(sp)
8112bf90:	0021883a 	mov	r16,zero
8112bf94:	003cb406 	br	8112b268 <__reset+0xfb10b268>
8112bf98:	0005883a 	mov	r2,zero
8112bf9c:	003fc206 	br	8112bea8 <__reset+0xfb10bea8>
8112bfa0:	d8802317 	ldw	r2,140(sp)
8112bfa4:	98c00043 	ldbu	r3,1(r19)
8112bfa8:	5827883a 	mov	r19,r11
8112bfac:	14000017 	ldw	r16,0(r2)
8112bfb0:	10800104 	addi	r2,r2,4
8112bfb4:	d8802315 	stw	r2,140(sp)
8112bfb8:	803f760e 	bge	r16,zero,8112bd94 <__reset+0xfb10bd94>
8112bfbc:	18c03fcc 	andi	r3,r3,255
8112bfc0:	18c0201c 	xori	r3,r3,128
8112bfc4:	043fffc4 	movi	r16,-1
8112bfc8:	18ffe004 	addi	r3,r3,-128
8112bfcc:	003bd906 	br	8112af34 <__reset+0xfb10af34>
8112bfd0:	d9c01d85 	stb	r7,118(sp)
8112bfd4:	003cb606 	br	8112b2b0 <__reset+0xfb10b2b0>
8112bfd8:	d9c01d85 	stb	r7,118(sp)
8112bfdc:	003d2106 	br	8112b464 <__reset+0xfb10b464>
8112bfe0:	d9c01d85 	stb	r7,118(sp)
8112bfe4:	003d8e06 	br	8112b620 <__reset+0xfb10b620>
8112bfe8:	d9c01d85 	stb	r7,118(sp)
8112bfec:	003db306 	br	8112b6bc <__reset+0xfb10b6bc>
8112bff0:	d9c01d85 	stb	r7,118(sp)
8112bff4:	003c8a06 	br	8112b220 <__reset+0xfb10b220>
8112bff8:	dac02a17 	ldw	r11,168(sp)
8112bffc:	00800304 	movi	r2,12
8112c000:	58800015 	stw	r2,0(r11)
8112c004:	00bfffc4 	movi	r2,-1
8112c008:	003e8e06 	br	8112ba44 <__reset+0xfb10ba44>
8112c00c:	d9c01d85 	stb	r7,118(sp)
8112c010:	003dc706 	br	8112b730 <__reset+0xfb10b730>
8112c014:	d9c01d85 	stb	r7,118(sp)
8112c018:	003ddf06 	br	8112b798 <__reset+0xfb10b798>
8112c01c:	d9c01d85 	stb	r7,118(sp)
8112c020:	003d3706 	br	8112b500 <__reset+0xfb10b500>
8112c024:	d9c01d85 	stb	r7,118(sp)
8112c028:	003c5406 	br	8112b17c <__reset+0xfb10b17c>
8112c02c:	d9c01d85 	stb	r7,118(sp)
8112c030:	003d1d06 	br	8112b4a8 <__reset+0xfb10b4a8>

8112c034 <__submore>:
8112c034:	defffa04 	addi	sp,sp,-24
8112c038:	de00012e 	bgeu	sp,et,8112c040 <__submore+0xc>
8112c03c:	003b68fa 	trap	3
8112c040:	dc000015 	stw	r16,0(sp)
8112c044:	2821883a 	mov	r16,r5
8112c048:	29400c17 	ldw	r5,48(r5)
8112c04c:	dfc00515 	stw	ra,20(sp)
8112c050:	dd000415 	stw	r20,16(sp)
8112c054:	dcc00315 	stw	r19,12(sp)
8112c058:	dc800215 	stw	r18,8(sp)
8112c05c:	dc400115 	stw	r17,4(sp)
8112c060:	80801004 	addi	r2,r16,64
8112c064:	28801726 	beq	r5,r2,8112c0c4 <__submore+0x90>
8112c068:	84400d17 	ldw	r17,52(r16)
8112c06c:	8c67883a 	add	r19,r17,r17
8112c070:	980d883a 	mov	r6,r19
8112c074:	11284c00 	call	811284c0 <_realloc_r>
8112c078:	1025883a 	mov	r18,r2
8112c07c:	10002226 	beq	r2,zero,8112c108 <__submore+0xd4>
8112c080:	1469883a 	add	r20,r2,r17
8112c084:	880d883a 	mov	r6,r17
8112c088:	100b883a 	mov	r5,r2
8112c08c:	a009883a 	mov	r4,r20
8112c090:	111d1cc0 	call	8111d1cc <memcpy>
8112c094:	0005883a 	mov	r2,zero
8112c098:	85000015 	stw	r20,0(r16)
8112c09c:	84800c15 	stw	r18,48(r16)
8112c0a0:	84c00d15 	stw	r19,52(r16)
8112c0a4:	dfc00517 	ldw	ra,20(sp)
8112c0a8:	dd000417 	ldw	r20,16(sp)
8112c0ac:	dcc00317 	ldw	r19,12(sp)
8112c0b0:	dc800217 	ldw	r18,8(sp)
8112c0b4:	dc400117 	ldw	r17,4(sp)
8112c0b8:	dc000017 	ldw	r16,0(sp)
8112c0bc:	dec00604 	addi	sp,sp,24
8112c0c0:	f800283a 	ret
8112c0c4:	04410004 	movi	r17,1024
8112c0c8:	880b883a 	mov	r5,r17
8112c0cc:	111c9b80 	call	8111c9b8 <_malloc_r>
8112c0d0:	1007883a 	mov	r3,r2
8112c0d4:	10000c26 	beq	r2,zero,8112c108 <__submore+0xd4>
8112c0d8:	80801083 	ldbu	r2,66(r16)
8112c0dc:	80c00c15 	stw	r3,48(r16)
8112c0e0:	84400d15 	stw	r17,52(r16)
8112c0e4:	1880ffc5 	stb	r2,1023(r3)
8112c0e8:	81401043 	ldbu	r5,65(r16)
8112c0ec:	1900ff44 	addi	r4,r3,1021
8112c0f0:	0005883a 	mov	r2,zero
8112c0f4:	1940ff85 	stb	r5,1022(r3)
8112c0f8:	81401003 	ldbu	r5,64(r16)
8112c0fc:	1940ff45 	stb	r5,1021(r3)
8112c100:	81000015 	stw	r4,0(r16)
8112c104:	003fe706 	br	8112c0a4 <__reset+0xfb10c0a4>
8112c108:	00bfffc4 	movi	r2,-1
8112c10c:	003fe506 	br	8112c0a4 <__reset+0xfb10c0a4>

8112c110 <_ungetc_r>:
8112c110:	00bfffc4 	movi	r2,-1
8112c114:	28806326 	beq	r5,r2,8112c2a4 <_ungetc_r+0x194>
8112c118:	defffb04 	addi	sp,sp,-20
8112c11c:	de00012e 	bgeu	sp,et,8112c124 <_ungetc_r+0x14>
8112c120:	003b68fa 	trap	3
8112c124:	dcc00315 	stw	r19,12(sp)
8112c128:	dc400115 	stw	r17,4(sp)
8112c12c:	dc000015 	stw	r16,0(sp)
8112c130:	dfc00415 	stw	ra,16(sp)
8112c134:	dc800215 	stw	r18,8(sp)
8112c138:	2023883a 	mov	r17,r4
8112c13c:	3021883a 	mov	r16,r6
8112c140:	2827883a 	mov	r19,r5
8112c144:	20000226 	beq	r4,zero,8112c150 <_ungetc_r+0x40>
8112c148:	20800e17 	ldw	r2,56(r4)
8112c14c:	10002e26 	beq	r2,zero,8112c208 <_ungetc_r+0xf8>
8112c150:	80c0030b 	ldhu	r3,12(r16)
8112c154:	1888000c 	andi	r2,r3,8192
8112c158:	1000051e 	bne	r2,zero,8112c170 <_ungetc_r+0x60>
8112c15c:	81001917 	ldw	r4,100(r16)
8112c160:	00b7ffc4 	movi	r2,-8193
8112c164:	18c80014 	ori	r3,r3,8192
8112c168:	2084703a 	and	r2,r4,r2
8112c16c:	80801915 	stw	r2,100(r16)
8112c170:	00bff7c4 	movi	r2,-33
8112c174:	1884703a 	and	r2,r3,r2
8112c178:	8080030d 	sth	r2,12(r16)
8112c17c:	1900010c 	andi	r4,r3,4
8112c180:	2000061e 	bne	r4,zero,8112c19c <_ungetc_r+0x8c>
8112c184:	1900040c 	andi	r4,r3,16
8112c188:	20001d26 	beq	r4,zero,8112c200 <_ungetc_r+0xf0>
8112c18c:	18c0020c 	andi	r3,r3,8
8112c190:	1800331e 	bne	r3,zero,8112c260 <_ungetc_r+0x150>
8112c194:	10800114 	ori	r2,r2,4
8112c198:	8080030d 	sth	r2,12(r16)
8112c19c:	80800c17 	ldw	r2,48(r16)
8112c1a0:	9c803fcc 	andi	r18,r19,255
8112c1a4:	10001a26 	beq	r2,zero,8112c210 <_ungetc_r+0x100>
8112c1a8:	80c00117 	ldw	r3,4(r16)
8112c1ac:	80800d17 	ldw	r2,52(r16)
8112c1b0:	18800f0e 	bge	r3,r2,8112c1f0 <_ungetc_r+0xe0>
8112c1b4:	80c00017 	ldw	r3,0(r16)
8112c1b8:	9005883a 	mov	r2,r18
8112c1bc:	193fffc4 	addi	r4,r3,-1
8112c1c0:	81000015 	stw	r4,0(r16)
8112c1c4:	1cffffc5 	stb	r19,-1(r3)
8112c1c8:	80c00117 	ldw	r3,4(r16)
8112c1cc:	18c00044 	addi	r3,r3,1
8112c1d0:	80c00115 	stw	r3,4(r16)
8112c1d4:	dfc00417 	ldw	ra,16(sp)
8112c1d8:	dcc00317 	ldw	r19,12(sp)
8112c1dc:	dc800217 	ldw	r18,8(sp)
8112c1e0:	dc400117 	ldw	r17,4(sp)
8112c1e4:	dc000017 	ldw	r16,0(sp)
8112c1e8:	dec00504 	addi	sp,sp,20
8112c1ec:	f800283a 	ret
8112c1f0:	800b883a 	mov	r5,r16
8112c1f4:	8809883a 	mov	r4,r17
8112c1f8:	112c0340 	call	8112c034 <__submore>
8112c1fc:	103fed26 	beq	r2,zero,8112c1b4 <__reset+0xfb10c1b4>
8112c200:	00bfffc4 	movi	r2,-1
8112c204:	003ff306 	br	8112c1d4 <__reset+0xfb10c1d4>
8112c208:	1125f940 	call	81125f94 <__sinit>
8112c20c:	003fd006 	br	8112c150 <__reset+0xfb10c150>
8112c210:	80c00417 	ldw	r3,16(r16)
8112c214:	80800017 	ldw	r2,0(r16)
8112c218:	18000326 	beq	r3,zero,8112c228 <_ungetc_r+0x118>
8112c21c:	1880022e 	bgeu	r3,r2,8112c228 <_ungetc_r+0x118>
8112c220:	10ffffc3 	ldbu	r3,-1(r2)
8112c224:	90c01826 	beq	r18,r3,8112c288 <_ungetc_r+0x178>
8112c228:	81400117 	ldw	r5,4(r16)
8112c22c:	80800e15 	stw	r2,56(r16)
8112c230:	008000c4 	movi	r2,3
8112c234:	81001004 	addi	r4,r16,64
8112c238:	80c01084 	addi	r3,r16,66
8112c23c:	80800d15 	stw	r2,52(r16)
8112c240:	00800044 	movi	r2,1
8112c244:	80800115 	stw	r2,4(r16)
8112c248:	81400f15 	stw	r5,60(r16)
8112c24c:	81000c15 	stw	r4,48(r16)
8112c250:	84c01085 	stb	r19,66(r16)
8112c254:	80c00015 	stw	r3,0(r16)
8112c258:	9005883a 	mov	r2,r18
8112c25c:	003fdd06 	br	8112c1d4 <__reset+0xfb10c1d4>
8112c260:	800b883a 	mov	r5,r16
8112c264:	8809883a 	mov	r4,r17
8112c268:	1125b980 	call	81125b98 <_fflush_r>
8112c26c:	103fe41e 	bne	r2,zero,8112c200 <__reset+0xfb10c200>
8112c270:	8080030b 	ldhu	r2,12(r16)
8112c274:	00fffdc4 	movi	r3,-9
8112c278:	80000215 	stw	zero,8(r16)
8112c27c:	1884703a 	and	r2,r3,r2
8112c280:	80000615 	stw	zero,24(r16)
8112c284:	003fc306 	br	8112c194 <__reset+0xfb10c194>
8112c288:	80c00117 	ldw	r3,4(r16)
8112c28c:	10bfffc4 	addi	r2,r2,-1
8112c290:	80800015 	stw	r2,0(r16)
8112c294:	18800044 	addi	r2,r3,1
8112c298:	80800115 	stw	r2,4(r16)
8112c29c:	9005883a 	mov	r2,r18
8112c2a0:	003fcc06 	br	8112c1d4 <__reset+0xfb10c1d4>
8112c2a4:	00bfffc4 	movi	r2,-1
8112c2a8:	f800283a 	ret

8112c2ac <ungetc>:
8112c2ac:	00a04574 	movhi	r2,33045
8112c2b0:	10b7d604 	addi	r2,r2,-8360
8112c2b4:	280d883a 	mov	r6,r5
8112c2b8:	200b883a 	mov	r5,r4
8112c2bc:	11000017 	ldw	r4,0(r2)
8112c2c0:	112c1101 	jmpi	8112c110 <_ungetc_r>

8112c2c4 <__sprint_r.part.0>:
8112c2c4:	defff604 	addi	sp,sp,-40
8112c2c8:	de00012e 	bgeu	sp,et,8112c2d0 <__sprint_r.part.0+0xc>
8112c2cc:	003b68fa 	trap	3
8112c2d0:	28801917 	ldw	r2,100(r5)
8112c2d4:	dd400515 	stw	r21,20(sp)
8112c2d8:	dfc00915 	stw	ra,36(sp)
8112c2dc:	df000815 	stw	fp,32(sp)
8112c2e0:	ddc00715 	stw	r23,28(sp)
8112c2e4:	dd800615 	stw	r22,24(sp)
8112c2e8:	dd000415 	stw	r20,16(sp)
8112c2ec:	dcc00315 	stw	r19,12(sp)
8112c2f0:	dc800215 	stw	r18,8(sp)
8112c2f4:	dc400115 	stw	r17,4(sp)
8112c2f8:	dc000015 	stw	r16,0(sp)
8112c2fc:	1088000c 	andi	r2,r2,8192
8112c300:	302b883a 	mov	r21,r6
8112c304:	10002e26 	beq	r2,zero,8112c3c0 <__sprint_r.part.0+0xfc>
8112c308:	30800217 	ldw	r2,8(r6)
8112c30c:	35800017 	ldw	r22,0(r6)
8112c310:	10002926 	beq	r2,zero,8112c3b8 <__sprint_r.part.0+0xf4>
8112c314:	2827883a 	mov	r19,r5
8112c318:	2029883a 	mov	r20,r4
8112c31c:	b5c00104 	addi	r23,r22,4
8112c320:	04bfffc4 	movi	r18,-1
8112c324:	bc400017 	ldw	r17,0(r23)
8112c328:	b4000017 	ldw	r16,0(r22)
8112c32c:	0039883a 	mov	fp,zero
8112c330:	8822d0ba 	srli	r17,r17,2
8112c334:	8800031e 	bne	r17,zero,8112c344 <__sprint_r.part.0+0x80>
8112c338:	00001806 	br	8112c39c <__sprint_r.part.0+0xd8>
8112c33c:	84000104 	addi	r16,r16,4
8112c340:	8f001526 	beq	r17,fp,8112c398 <__sprint_r.part.0+0xd4>
8112c344:	81400017 	ldw	r5,0(r16)
8112c348:	980d883a 	mov	r6,r19
8112c34c:	a009883a 	mov	r4,r20
8112c350:	112dc680 	call	8112dc68 <_fputwc_r>
8112c354:	e7000044 	addi	fp,fp,1
8112c358:	14bff81e 	bne	r2,r18,8112c33c <__reset+0xfb10c33c>
8112c35c:	9005883a 	mov	r2,r18
8112c360:	a8000215 	stw	zero,8(r21)
8112c364:	a8000115 	stw	zero,4(r21)
8112c368:	dfc00917 	ldw	ra,36(sp)
8112c36c:	df000817 	ldw	fp,32(sp)
8112c370:	ddc00717 	ldw	r23,28(sp)
8112c374:	dd800617 	ldw	r22,24(sp)
8112c378:	dd400517 	ldw	r21,20(sp)
8112c37c:	dd000417 	ldw	r20,16(sp)
8112c380:	dcc00317 	ldw	r19,12(sp)
8112c384:	dc800217 	ldw	r18,8(sp)
8112c388:	dc400117 	ldw	r17,4(sp)
8112c38c:	dc000017 	ldw	r16,0(sp)
8112c390:	dec00a04 	addi	sp,sp,40
8112c394:	f800283a 	ret
8112c398:	a8800217 	ldw	r2,8(r21)
8112c39c:	8c63883a 	add	r17,r17,r17
8112c3a0:	8c63883a 	add	r17,r17,r17
8112c3a4:	1445c83a 	sub	r2,r2,r17
8112c3a8:	a8800215 	stw	r2,8(r21)
8112c3ac:	b5800204 	addi	r22,r22,8
8112c3b0:	bdc00204 	addi	r23,r23,8
8112c3b4:	103fdb1e 	bne	r2,zero,8112c324 <__reset+0xfb10c324>
8112c3b8:	0005883a 	mov	r2,zero
8112c3bc:	003fe806 	br	8112c360 <__reset+0xfb10c360>
8112c3c0:	11267440 	call	81126744 <__sfvwrite_r>
8112c3c4:	003fe606 	br	8112c360 <__reset+0xfb10c360>

8112c3c8 <__sprint_r>:
8112c3c8:	30c00217 	ldw	r3,8(r6)
8112c3cc:	18000126 	beq	r3,zero,8112c3d4 <__sprint_r+0xc>
8112c3d0:	112c2c41 	jmpi	8112c2c4 <__sprint_r.part.0>
8112c3d4:	30000115 	stw	zero,4(r6)
8112c3d8:	0005883a 	mov	r2,zero
8112c3dc:	f800283a 	ret

8112c3e0 <___vfiprintf_internal_r>:
8112c3e0:	deffc904 	addi	sp,sp,-220
8112c3e4:	de00012e 	bgeu	sp,et,8112c3ec <___vfiprintf_internal_r+0xc>
8112c3e8:	003b68fa 	trap	3
8112c3ec:	df003515 	stw	fp,212(sp)
8112c3f0:	dd003115 	stw	r20,196(sp)
8112c3f4:	dfc03615 	stw	ra,216(sp)
8112c3f8:	ddc03415 	stw	r23,208(sp)
8112c3fc:	dd803315 	stw	r22,204(sp)
8112c400:	dd403215 	stw	r21,200(sp)
8112c404:	dcc03015 	stw	r19,192(sp)
8112c408:	dc802f15 	stw	r18,188(sp)
8112c40c:	dc402e15 	stw	r17,184(sp)
8112c410:	dc002d15 	stw	r16,180(sp)
8112c414:	d9002015 	stw	r4,128(sp)
8112c418:	d9c02215 	stw	r7,136(sp)
8112c41c:	2829883a 	mov	r20,r5
8112c420:	3039883a 	mov	fp,r6
8112c424:	20000226 	beq	r4,zero,8112c430 <___vfiprintf_internal_r+0x50>
8112c428:	20800e17 	ldw	r2,56(r4)
8112c42c:	1000cf26 	beq	r2,zero,8112c76c <___vfiprintf_internal_r+0x38c>
8112c430:	a080030b 	ldhu	r2,12(r20)
8112c434:	10c8000c 	andi	r3,r2,8192
8112c438:	1800061e 	bne	r3,zero,8112c454 <___vfiprintf_internal_r+0x74>
8112c43c:	a1001917 	ldw	r4,100(r20)
8112c440:	00f7ffc4 	movi	r3,-8193
8112c444:	10880014 	ori	r2,r2,8192
8112c448:	20c6703a 	and	r3,r4,r3
8112c44c:	a080030d 	sth	r2,12(r20)
8112c450:	a0c01915 	stw	r3,100(r20)
8112c454:	10c0020c 	andi	r3,r2,8
8112c458:	1800a926 	beq	r3,zero,8112c700 <___vfiprintf_internal_r+0x320>
8112c45c:	a0c00417 	ldw	r3,16(r20)
8112c460:	1800a726 	beq	r3,zero,8112c700 <___vfiprintf_internal_r+0x320>
8112c464:	1080068c 	andi	r2,r2,26
8112c468:	00c00284 	movi	r3,10
8112c46c:	10c0ac26 	beq	r2,r3,8112c720 <___vfiprintf_internal_r+0x340>
8112c470:	da801a04 	addi	r10,sp,104
8112c474:	da801e15 	stw	r10,120(sp)
8112c478:	d8801e17 	ldw	r2,120(sp)
8112c47c:	da8019c4 	addi	r10,sp,103
8112c480:	05a04574 	movhi	r22,33045
8112c484:	05e04574 	movhi	r23,33045
8112c488:	da801f15 	stw	r10,124(sp)
8112c48c:	1295c83a 	sub	r10,r2,r10
8112c490:	b5ae9d04 	addi	r22,r22,-17804
8112c494:	bdee9904 	addi	r23,r23,-17820
8112c498:	dec01a15 	stw	sp,104(sp)
8112c49c:	d8001c15 	stw	zero,112(sp)
8112c4a0:	d8001b15 	stw	zero,108(sp)
8112c4a4:	d8002615 	stw	zero,152(sp)
8112c4a8:	d8002315 	stw	zero,140(sp)
8112c4ac:	da802715 	stw	r10,156(sp)
8112c4b0:	d811883a 	mov	r8,sp
8112c4b4:	dd002115 	stw	r20,132(sp)
8112c4b8:	e021883a 	mov	r16,fp
8112c4bc:	80800007 	ldb	r2,0(r16)
8112c4c0:	1003ea26 	beq	r2,zero,8112d46c <___vfiprintf_internal_r+0x108c>
8112c4c4:	00c00944 	movi	r3,37
8112c4c8:	8025883a 	mov	r18,r16
8112c4cc:	10c0021e 	bne	r2,r3,8112c4d8 <___vfiprintf_internal_r+0xf8>
8112c4d0:	00001606 	br	8112c52c <___vfiprintf_internal_r+0x14c>
8112c4d4:	10c00326 	beq	r2,r3,8112c4e4 <___vfiprintf_internal_r+0x104>
8112c4d8:	94800044 	addi	r18,r18,1
8112c4dc:	90800007 	ldb	r2,0(r18)
8112c4e0:	103ffc1e 	bne	r2,zero,8112c4d4 <__reset+0xfb10c4d4>
8112c4e4:	9423c83a 	sub	r17,r18,r16
8112c4e8:	88001026 	beq	r17,zero,8112c52c <___vfiprintf_internal_r+0x14c>
8112c4ec:	d8c01c17 	ldw	r3,112(sp)
8112c4f0:	d8801b17 	ldw	r2,108(sp)
8112c4f4:	44000015 	stw	r16,0(r8)
8112c4f8:	88c7883a 	add	r3,r17,r3
8112c4fc:	10800044 	addi	r2,r2,1
8112c500:	44400115 	stw	r17,4(r8)
8112c504:	d8c01c15 	stw	r3,112(sp)
8112c508:	d8801b15 	stw	r2,108(sp)
8112c50c:	010001c4 	movi	r4,7
8112c510:	2080760e 	bge	r4,r2,8112c6ec <___vfiprintf_internal_r+0x30c>
8112c514:	1803821e 	bne	r3,zero,8112d320 <___vfiprintf_internal_r+0xf40>
8112c518:	da802317 	ldw	r10,140(sp)
8112c51c:	d8001b15 	stw	zero,108(sp)
8112c520:	d811883a 	mov	r8,sp
8112c524:	5455883a 	add	r10,r10,r17
8112c528:	da802315 	stw	r10,140(sp)
8112c52c:	90800007 	ldb	r2,0(r18)
8112c530:	10044626 	beq	r2,zero,8112d64c <___vfiprintf_internal_r+0x126c>
8112c534:	90c00047 	ldb	r3,1(r18)
8112c538:	94000044 	addi	r16,r18,1
8112c53c:	d8001d85 	stb	zero,118(sp)
8112c540:	0009883a 	mov	r4,zero
8112c544:	000f883a 	mov	r7,zero
8112c548:	027fffc4 	movi	r9,-1
8112c54c:	0023883a 	mov	r17,zero
8112c550:	0029883a 	mov	r20,zero
8112c554:	01401604 	movi	r5,88
8112c558:	01800244 	movi	r6,9
8112c55c:	03400a84 	movi	r13,42
8112c560:	03001b04 	movi	r12,108
8112c564:	84000044 	addi	r16,r16,1
8112c568:	18bff804 	addi	r2,r3,-32
8112c56c:	28827336 	bltu	r5,r2,8112cf3c <___vfiprintf_internal_r+0xb5c>
8112c570:	100490ba 	slli	r2,r2,2
8112c574:	02a044f4 	movhi	r10,33043
8112c578:	52b16204 	addi	r10,r10,-14968
8112c57c:	1285883a 	add	r2,r2,r10
8112c580:	10800017 	ldw	r2,0(r2)
8112c584:	1000683a 	jmp	r2
8112c588:	8112cc70 	cmpltui	r4,r16,19249
8112c58c:	8112cf3c 	xorhi	r4,r16,19260
8112c590:	8112cf3c 	xorhi	r4,r16,19260
8112c594:	8112cc90 	cmplti	r4,r16,19250
8112c598:	8112cf3c 	xorhi	r4,r16,19260
8112c59c:	8112cf3c 	xorhi	r4,r16,19260
8112c5a0:	8112cf3c 	xorhi	r4,r16,19260
8112c5a4:	8112cf3c 	xorhi	r4,r16,19260
8112c5a8:	8112cf3c 	xorhi	r4,r16,19260
8112c5ac:	8112cf3c 	xorhi	r4,r16,19260
8112c5b0:	8112ce78 	rdprs	r4,r16,19257
8112c5b4:	8112ce94 	ori	r4,r16,19258
8112c5b8:	8112cf3c 	xorhi	r4,r16,19260
8112c5bc:	8112c77c 	xorhi	r4,r16,19229
8112c5c0:	8112cea4 	muli	r4,r16,19258
8112c5c4:	8112cf3c 	xorhi	r4,r16,19260
8112c5c8:	8112cc9c 	xori	r4,r16,19250
8112c5cc:	8112cca8 	cmpgeui	r4,r16,19250
8112c5d0:	8112cca8 	cmpgeui	r4,r16,19250
8112c5d4:	8112cca8 	cmpgeui	r4,r16,19250
8112c5d8:	8112cca8 	cmpgeui	r4,r16,19250
8112c5dc:	8112cca8 	cmpgeui	r4,r16,19250
8112c5e0:	8112cca8 	cmpgeui	r4,r16,19250
8112c5e4:	8112cca8 	cmpgeui	r4,r16,19250
8112c5e8:	8112cca8 	cmpgeui	r4,r16,19250
8112c5ec:	8112cca8 	cmpgeui	r4,r16,19250
8112c5f0:	8112cf3c 	xorhi	r4,r16,19260
8112c5f4:	8112cf3c 	xorhi	r4,r16,19260
8112c5f8:	8112cf3c 	xorhi	r4,r16,19260
8112c5fc:	8112cf3c 	xorhi	r4,r16,19260
8112c600:	8112cf3c 	xorhi	r4,r16,19260
8112c604:	8112cf3c 	xorhi	r4,r16,19260
8112c608:	8112cf3c 	xorhi	r4,r16,19260
8112c60c:	8112cf3c 	xorhi	r4,r16,19260
8112c610:	8112cf3c 	xorhi	r4,r16,19260
8112c614:	8112cf3c 	xorhi	r4,r16,19260
8112c618:	8112ccd4 	ori	r4,r16,19251
8112c61c:	8112cf3c 	xorhi	r4,r16,19260
8112c620:	8112cf3c 	xorhi	r4,r16,19260
8112c624:	8112cf3c 	xorhi	r4,r16,19260
8112c628:	8112cf3c 	xorhi	r4,r16,19260
8112c62c:	8112cf3c 	xorhi	r4,r16,19260
8112c630:	8112cf3c 	xorhi	r4,r16,19260
8112c634:	8112cf3c 	xorhi	r4,r16,19260
8112c638:	8112cf3c 	xorhi	r4,r16,19260
8112c63c:	8112cf3c 	xorhi	r4,r16,19260
8112c640:	8112cf3c 	xorhi	r4,r16,19260
8112c644:	8112cd0c 	andi	r4,r16,19252
8112c648:	8112cf3c 	xorhi	r4,r16,19260
8112c64c:	8112cf3c 	xorhi	r4,r16,19260
8112c650:	8112cf3c 	xorhi	r4,r16,19260
8112c654:	8112cf3c 	xorhi	r4,r16,19260
8112c658:	8112cf3c 	xorhi	r4,r16,19260
8112c65c:	8112cd64 	muli	r4,r16,19253
8112c660:	8112cf3c 	xorhi	r4,r16,19260
8112c664:	8112cf3c 	xorhi	r4,r16,19260
8112c668:	8112cdd4 	ori	r4,r16,19255
8112c66c:	8112cf3c 	xorhi	r4,r16,19260
8112c670:	8112cf3c 	xorhi	r4,r16,19260
8112c674:	8112cf3c 	xorhi	r4,r16,19260
8112c678:	8112cf3c 	xorhi	r4,r16,19260
8112c67c:	8112cf3c 	xorhi	r4,r16,19260
8112c680:	8112cf3c 	xorhi	r4,r16,19260
8112c684:	8112cf3c 	xorhi	r4,r16,19260
8112c688:	8112cf3c 	xorhi	r4,r16,19260
8112c68c:	8112cf3c 	xorhi	r4,r16,19260
8112c690:	8112cf3c 	xorhi	r4,r16,19260
8112c694:	8112cb80 	call	88112cb8 <__reset+0x20f2cb8>
8112c698:	8112cbac 	andhi	r4,r16,19246
8112c69c:	8112cf3c 	xorhi	r4,r16,19260
8112c6a0:	8112cf3c 	xorhi	r4,r16,19260
8112c6a4:	8112cf3c 	xorhi	r4,r16,19260
8112c6a8:	8112cee4 	muli	r4,r16,19259
8112c6ac:	8112cbac 	andhi	r4,r16,19246
8112c6b0:	8112cf3c 	xorhi	r4,r16,19260
8112c6b4:	8112cf3c 	xorhi	r4,r16,19260
8112c6b8:	8112ca40 	call	88112ca4 <__reset+0x20f2ca4>
8112c6bc:	8112cf3c 	xorhi	r4,r16,19260
8112c6c0:	8112ca50 	cmplti	r4,r16,19241
8112c6c4:	8112ca8c 	andi	r4,r16,19242
8112c6c8:	8112c788 	cmpgei	r4,r16,19230
8112c6cc:	8112ca34 	orhi	r4,r16,19240
8112c6d0:	8112cf3c 	xorhi	r4,r16,19260
8112c6d4:	8112ce10 	cmplti	r4,r16,19256
8112c6d8:	8112cf3c 	xorhi	r4,r16,19260
8112c6dc:	8112ce68 	cmpgeui	r4,r16,19257
8112c6e0:	8112cf3c 	xorhi	r4,r16,19260
8112c6e4:	8112cf3c 	xorhi	r4,r16,19260
8112c6e8:	8112cb2c 	andhi	r4,r16,19244
8112c6ec:	42000204 	addi	r8,r8,8
8112c6f0:	da802317 	ldw	r10,140(sp)
8112c6f4:	5455883a 	add	r10,r10,r17
8112c6f8:	da802315 	stw	r10,140(sp)
8112c6fc:	003f8b06 	br	8112c52c <__reset+0xfb10c52c>
8112c700:	d9002017 	ldw	r4,128(sp)
8112c704:	a00b883a 	mov	r5,r20
8112c708:	1123f240 	call	81123f24 <__swsetup_r>
8112c70c:	1003b11e 	bne	r2,zero,8112d5d4 <___vfiprintf_internal_r+0x11f4>
8112c710:	a080030b 	ldhu	r2,12(r20)
8112c714:	00c00284 	movi	r3,10
8112c718:	1080068c 	andi	r2,r2,26
8112c71c:	10ff541e 	bne	r2,r3,8112c470 <__reset+0xfb10c470>
8112c720:	a080038f 	ldh	r2,14(r20)
8112c724:	103f5216 	blt	r2,zero,8112c470 <__reset+0xfb10c470>
8112c728:	d9c02217 	ldw	r7,136(sp)
8112c72c:	d9002017 	ldw	r4,128(sp)
8112c730:	e00d883a 	mov	r6,fp
8112c734:	a00b883a 	mov	r5,r20
8112c738:	112d8600 	call	8112d860 <__sbprintf>
8112c73c:	dfc03617 	ldw	ra,216(sp)
8112c740:	df003517 	ldw	fp,212(sp)
8112c744:	ddc03417 	ldw	r23,208(sp)
8112c748:	dd803317 	ldw	r22,204(sp)
8112c74c:	dd403217 	ldw	r21,200(sp)
8112c750:	dd003117 	ldw	r20,196(sp)
8112c754:	dcc03017 	ldw	r19,192(sp)
8112c758:	dc802f17 	ldw	r18,188(sp)
8112c75c:	dc402e17 	ldw	r17,184(sp)
8112c760:	dc002d17 	ldw	r16,180(sp)
8112c764:	dec03704 	addi	sp,sp,220
8112c768:	f800283a 	ret
8112c76c:	1125f940 	call	81125f94 <__sinit>
8112c770:	003f2f06 	br	8112c430 <__reset+0xfb10c430>
8112c774:	0463c83a 	sub	r17,zero,r17
8112c778:	d8802215 	stw	r2,136(sp)
8112c77c:	a5000114 	ori	r20,r20,4
8112c780:	80c00007 	ldb	r3,0(r16)
8112c784:	003f7706 	br	8112c564 <__reset+0xfb10c564>
8112c788:	00800c04 	movi	r2,48
8112c78c:	da802217 	ldw	r10,136(sp)
8112c790:	d8801d05 	stb	r2,116(sp)
8112c794:	00801e04 	movi	r2,120
8112c798:	d8801d45 	stb	r2,117(sp)
8112c79c:	d8001d85 	stb	zero,118(sp)
8112c7a0:	50c00104 	addi	r3,r10,4
8112c7a4:	54800017 	ldw	r18,0(r10)
8112c7a8:	0027883a 	mov	r19,zero
8112c7ac:	a0800094 	ori	r2,r20,2
8112c7b0:	48030b16 	blt	r9,zero,8112d3e0 <___vfiprintf_internal_r+0x1000>
8112c7b4:	00bfdfc4 	movi	r2,-129
8112c7b8:	a096703a 	and	r11,r20,r2
8112c7bc:	d8c02215 	stw	r3,136(sp)
8112c7c0:	5d000094 	ori	r20,r11,2
8112c7c4:	90032b1e 	bne	r18,zero,8112d474 <___vfiprintf_internal_r+0x1094>
8112c7c8:	00a04574 	movhi	r2,33045
8112c7cc:	10ae0704 	addi	r2,r2,-18404
8112c7d0:	d8802615 	stw	r2,152(sp)
8112c7d4:	0039883a 	mov	fp,zero
8112c7d8:	48017b1e 	bne	r9,zero,8112cdc8 <___vfiprintf_internal_r+0x9e8>
8112c7dc:	0013883a 	mov	r9,zero
8112c7e0:	0027883a 	mov	r19,zero
8112c7e4:	dd401a04 	addi	r21,sp,104
8112c7e8:	4825883a 	mov	r18,r9
8112c7ec:	4cc0010e 	bge	r9,r19,8112c7f4 <___vfiprintf_internal_r+0x414>
8112c7f0:	9825883a 	mov	r18,r19
8112c7f4:	e7003fcc 	andi	fp,fp,255
8112c7f8:	e700201c 	xori	fp,fp,128
8112c7fc:	e73fe004 	addi	fp,fp,-128
8112c800:	e0000126 	beq	fp,zero,8112c808 <___vfiprintf_internal_r+0x428>
8112c804:	94800044 	addi	r18,r18,1
8112c808:	a380008c 	andi	r14,r20,2
8112c80c:	70000126 	beq	r14,zero,8112c814 <___vfiprintf_internal_r+0x434>
8112c810:	94800084 	addi	r18,r18,2
8112c814:	a700210c 	andi	fp,r20,132
8112c818:	e001df1e 	bne	fp,zero,8112cf98 <___vfiprintf_internal_r+0xbb8>
8112c81c:	8c87c83a 	sub	r3,r17,r18
8112c820:	00c1dd0e 	bge	zero,r3,8112cf98 <___vfiprintf_internal_r+0xbb8>
8112c824:	01c00404 	movi	r7,16
8112c828:	d8801c17 	ldw	r2,112(sp)
8112c82c:	38c3ad0e 	bge	r7,r3,8112d6e4 <___vfiprintf_internal_r+0x1304>
8112c830:	02a04574 	movhi	r10,33045
8112c834:	52ae9d04 	addi	r10,r10,-17804
8112c838:	dc002915 	stw	r16,164(sp)
8112c83c:	d9801b17 	ldw	r6,108(sp)
8112c840:	da802415 	stw	r10,144(sp)
8112c844:	03c001c4 	movi	r15,7
8112c848:	da402515 	stw	r9,148(sp)
8112c84c:	db802815 	stw	r14,160(sp)
8112c850:	1821883a 	mov	r16,r3
8112c854:	00000506 	br	8112c86c <___vfiprintf_internal_r+0x48c>
8112c858:	31400084 	addi	r5,r6,2
8112c85c:	42000204 	addi	r8,r8,8
8112c860:	200d883a 	mov	r6,r4
8112c864:	843ffc04 	addi	r16,r16,-16
8112c868:	3c000d0e 	bge	r7,r16,8112c8a0 <___vfiprintf_internal_r+0x4c0>
8112c86c:	10800404 	addi	r2,r2,16
8112c870:	31000044 	addi	r4,r6,1
8112c874:	45800015 	stw	r22,0(r8)
8112c878:	41c00115 	stw	r7,4(r8)
8112c87c:	d8801c15 	stw	r2,112(sp)
8112c880:	d9001b15 	stw	r4,108(sp)
8112c884:	793ff40e 	bge	r15,r4,8112c858 <__reset+0xfb10c858>
8112c888:	1001b51e 	bne	r2,zero,8112cf60 <___vfiprintf_internal_r+0xb80>
8112c88c:	843ffc04 	addi	r16,r16,-16
8112c890:	000d883a 	mov	r6,zero
8112c894:	01400044 	movi	r5,1
8112c898:	d811883a 	mov	r8,sp
8112c89c:	3c3ff316 	blt	r7,r16,8112c86c <__reset+0xfb10c86c>
8112c8a0:	8007883a 	mov	r3,r16
8112c8a4:	da402517 	ldw	r9,148(sp)
8112c8a8:	db802817 	ldw	r14,160(sp)
8112c8ac:	dc002917 	ldw	r16,164(sp)
8112c8b0:	da802417 	ldw	r10,144(sp)
8112c8b4:	1885883a 	add	r2,r3,r2
8112c8b8:	40c00115 	stw	r3,4(r8)
8112c8bc:	42800015 	stw	r10,0(r8)
8112c8c0:	d8801c15 	stw	r2,112(sp)
8112c8c4:	d9401b15 	stw	r5,108(sp)
8112c8c8:	00c001c4 	movi	r3,7
8112c8cc:	19426016 	blt	r3,r5,8112d250 <___vfiprintf_internal_r+0xe70>
8112c8d0:	d8c01d87 	ldb	r3,118(sp)
8112c8d4:	42000204 	addi	r8,r8,8
8112c8d8:	29000044 	addi	r4,r5,1
8112c8dc:	1801b31e 	bne	r3,zero,8112cfac <___vfiprintf_internal_r+0xbcc>
8112c8e0:	7001c026 	beq	r14,zero,8112cfe4 <___vfiprintf_internal_r+0xc04>
8112c8e4:	d8c01d04 	addi	r3,sp,116
8112c8e8:	10800084 	addi	r2,r2,2
8112c8ec:	40c00015 	stw	r3,0(r8)
8112c8f0:	00c00084 	movi	r3,2
8112c8f4:	40c00115 	stw	r3,4(r8)
8112c8f8:	d8801c15 	stw	r2,112(sp)
8112c8fc:	d9001b15 	stw	r4,108(sp)
8112c900:	00c001c4 	movi	r3,7
8112c904:	1902650e 	bge	r3,r4,8112d29c <___vfiprintf_internal_r+0xebc>
8112c908:	10029a1e 	bne	r2,zero,8112d374 <___vfiprintf_internal_r+0xf94>
8112c90c:	00c02004 	movi	r3,128
8112c910:	01000044 	movi	r4,1
8112c914:	000b883a 	mov	r5,zero
8112c918:	d811883a 	mov	r8,sp
8112c91c:	e0c1b31e 	bne	fp,r3,8112cfec <___vfiprintf_internal_r+0xc0c>
8112c920:	8cb9c83a 	sub	fp,r17,r18
8112c924:	0701b10e 	bge	zero,fp,8112cfec <___vfiprintf_internal_r+0xc0c>
8112c928:	01c00404 	movi	r7,16
8112c92c:	3f03890e 	bge	r7,fp,8112d754 <___vfiprintf_internal_r+0x1374>
8112c930:	00e04574 	movhi	r3,33045
8112c934:	18ee9904 	addi	r3,r3,-17820
8112c938:	d8c02415 	stw	r3,144(sp)
8112c93c:	8007883a 	mov	r3,r16
8112c940:	034001c4 	movi	r13,7
8112c944:	e021883a 	mov	r16,fp
8112c948:	da402515 	stw	r9,148(sp)
8112c94c:	1839883a 	mov	fp,r3
8112c950:	00000506 	br	8112c968 <___vfiprintf_internal_r+0x588>
8112c954:	29800084 	addi	r6,r5,2
8112c958:	42000204 	addi	r8,r8,8
8112c95c:	180b883a 	mov	r5,r3
8112c960:	843ffc04 	addi	r16,r16,-16
8112c964:	3c000d0e 	bge	r7,r16,8112c99c <___vfiprintf_internal_r+0x5bc>
8112c968:	10800404 	addi	r2,r2,16
8112c96c:	28c00044 	addi	r3,r5,1
8112c970:	45c00015 	stw	r23,0(r8)
8112c974:	41c00115 	stw	r7,4(r8)
8112c978:	d8801c15 	stw	r2,112(sp)
8112c97c:	d8c01b15 	stw	r3,108(sp)
8112c980:	68fff40e 	bge	r13,r3,8112c954 <__reset+0xfb10c954>
8112c984:	1002241e 	bne	r2,zero,8112d218 <___vfiprintf_internal_r+0xe38>
8112c988:	843ffc04 	addi	r16,r16,-16
8112c98c:	01800044 	movi	r6,1
8112c990:	000b883a 	mov	r5,zero
8112c994:	d811883a 	mov	r8,sp
8112c998:	3c3ff316 	blt	r7,r16,8112c968 <__reset+0xfb10c968>
8112c99c:	da402517 	ldw	r9,148(sp)
8112c9a0:	e007883a 	mov	r3,fp
8112c9a4:	8039883a 	mov	fp,r16
8112c9a8:	1821883a 	mov	r16,r3
8112c9ac:	d8c02417 	ldw	r3,144(sp)
8112c9b0:	1705883a 	add	r2,r2,fp
8112c9b4:	47000115 	stw	fp,4(r8)
8112c9b8:	40c00015 	stw	r3,0(r8)
8112c9bc:	d8801c15 	stw	r2,112(sp)
8112c9c0:	d9801b15 	stw	r6,108(sp)
8112c9c4:	00c001c4 	movi	r3,7
8112c9c8:	19827616 	blt	r3,r6,8112d3a4 <___vfiprintf_internal_r+0xfc4>
8112c9cc:	4cf9c83a 	sub	fp,r9,r19
8112c9d0:	42000204 	addi	r8,r8,8
8112c9d4:	31000044 	addi	r4,r6,1
8112c9d8:	300b883a 	mov	r5,r6
8112c9dc:	07018516 	blt	zero,fp,8112cff4 <___vfiprintf_internal_r+0xc14>
8112c9e0:	9885883a 	add	r2,r19,r2
8112c9e4:	45400015 	stw	r21,0(r8)
8112c9e8:	44c00115 	stw	r19,4(r8)
8112c9ec:	d8801c15 	stw	r2,112(sp)
8112c9f0:	d9001b15 	stw	r4,108(sp)
8112c9f4:	00c001c4 	movi	r3,7
8112c9f8:	1901dd0e 	bge	r3,r4,8112d170 <___vfiprintf_internal_r+0xd90>
8112c9fc:	1002401e 	bne	r2,zero,8112d300 <___vfiprintf_internal_r+0xf20>
8112ca00:	d8001b15 	stw	zero,108(sp)
8112ca04:	a2c0010c 	andi	r11,r20,4
8112ca08:	58000226 	beq	r11,zero,8112ca14 <___vfiprintf_internal_r+0x634>
8112ca0c:	8ca7c83a 	sub	r19,r17,r18
8112ca10:	04c2f216 	blt	zero,r19,8112d5dc <___vfiprintf_internal_r+0x11fc>
8112ca14:	8c80010e 	bge	r17,r18,8112ca1c <___vfiprintf_internal_r+0x63c>
8112ca18:	9023883a 	mov	r17,r18
8112ca1c:	da802317 	ldw	r10,140(sp)
8112ca20:	5455883a 	add	r10,r10,r17
8112ca24:	da802315 	stw	r10,140(sp)
8112ca28:	d8001b15 	stw	zero,108(sp)
8112ca2c:	d811883a 	mov	r8,sp
8112ca30:	003ea206 	br	8112c4bc <__reset+0xfb10c4bc>
8112ca34:	a5000814 	ori	r20,r20,32
8112ca38:	80c00007 	ldb	r3,0(r16)
8112ca3c:	003ec906 	br	8112c564 <__reset+0xfb10c564>
8112ca40:	80c00007 	ldb	r3,0(r16)
8112ca44:	1b030926 	beq	r3,r12,8112d66c <___vfiprintf_internal_r+0x128c>
8112ca48:	a5000414 	ori	r20,r20,16
8112ca4c:	003ec506 	br	8112c564 <__reset+0xfb10c564>
8112ca50:	21003fcc 	andi	r4,r4,255
8112ca54:	20035e1e 	bne	r4,zero,8112d7d0 <___vfiprintf_internal_r+0x13f0>
8112ca58:	a080080c 	andi	r2,r20,32
8112ca5c:	1002a526 	beq	r2,zero,8112d4f4 <___vfiprintf_internal_r+0x1114>
8112ca60:	da802217 	ldw	r10,136(sp)
8112ca64:	50800017 	ldw	r2,0(r10)
8112ca68:	da802317 	ldw	r10,140(sp)
8112ca6c:	5007d7fa 	srai	r3,r10,31
8112ca70:	da802217 	ldw	r10,136(sp)
8112ca74:	10c00115 	stw	r3,4(r2)
8112ca78:	52800104 	addi	r10,r10,4
8112ca7c:	da802215 	stw	r10,136(sp)
8112ca80:	da802317 	ldw	r10,140(sp)
8112ca84:	12800015 	stw	r10,0(r2)
8112ca88:	003e8c06 	br	8112c4bc <__reset+0xfb10c4bc>
8112ca8c:	21003fcc 	andi	r4,r4,255
8112ca90:	2003511e 	bne	r4,zero,8112d7d8 <___vfiprintf_internal_r+0x13f8>
8112ca94:	a080080c 	andi	r2,r20,32
8112ca98:	1000a126 	beq	r2,zero,8112cd20 <___vfiprintf_internal_r+0x940>
8112ca9c:	da802217 	ldw	r10,136(sp)
8112caa0:	d8001d85 	stb	zero,118(sp)
8112caa4:	50800204 	addi	r2,r10,8
8112caa8:	54800017 	ldw	r18,0(r10)
8112caac:	54c00117 	ldw	r19,4(r10)
8112cab0:	4802b416 	blt	r9,zero,8112d584 <___vfiprintf_internal_r+0x11a4>
8112cab4:	013fdfc4 	movi	r4,-129
8112cab8:	94c6b03a 	or	r3,r18,r19
8112cabc:	d8802215 	stw	r2,136(sp)
8112cac0:	a128703a 	and	r20,r20,r4
8112cac4:	1800a226 	beq	r3,zero,8112cd50 <___vfiprintf_internal_r+0x970>
8112cac8:	0039883a 	mov	fp,zero
8112cacc:	dd401a04 	addi	r21,sp,104
8112cad0:	9006d0fa 	srli	r3,r18,3
8112cad4:	9808977a 	slli	r4,r19,29
8112cad8:	9826d0fa 	srli	r19,r19,3
8112cadc:	948001cc 	andi	r18,r18,7
8112cae0:	90800c04 	addi	r2,r18,48
8112cae4:	ad7fffc4 	addi	r21,r21,-1
8112cae8:	20e4b03a 	or	r18,r4,r3
8112caec:	a8800005 	stb	r2,0(r21)
8112caf0:	94c6b03a 	or	r3,r18,r19
8112caf4:	183ff61e 	bne	r3,zero,8112cad0 <__reset+0xfb10cad0>
8112caf8:	a0c0004c 	andi	r3,r20,1
8112cafc:	18005926 	beq	r3,zero,8112cc64 <___vfiprintf_internal_r+0x884>
8112cb00:	10803fcc 	andi	r2,r2,255
8112cb04:	1080201c 	xori	r2,r2,128
8112cb08:	10bfe004 	addi	r2,r2,-128
8112cb0c:	00c00c04 	movi	r3,48
8112cb10:	10c05426 	beq	r2,r3,8112cc64 <___vfiprintf_internal_r+0x884>
8112cb14:	da801e17 	ldw	r10,120(sp)
8112cb18:	a8bfffc4 	addi	r2,r21,-1
8112cb1c:	a8ffffc5 	stb	r3,-1(r21)
8112cb20:	50a7c83a 	sub	r19,r10,r2
8112cb24:	102b883a 	mov	r21,r2
8112cb28:	003f2f06 	br	8112c7e8 <__reset+0xfb10c7e8>
8112cb2c:	21003fcc 	andi	r4,r4,255
8112cb30:	2003421e 	bne	r4,zero,8112d83c <___vfiprintf_internal_r+0x145c>
8112cb34:	00a04574 	movhi	r2,33045
8112cb38:	10ae0704 	addi	r2,r2,-18404
8112cb3c:	d8802615 	stw	r2,152(sp)
8112cb40:	a080080c 	andi	r2,r20,32
8112cb44:	1000aa26 	beq	r2,zero,8112cdf0 <___vfiprintf_internal_r+0xa10>
8112cb48:	da802217 	ldw	r10,136(sp)
8112cb4c:	54800017 	ldw	r18,0(r10)
8112cb50:	54c00117 	ldw	r19,4(r10)
8112cb54:	52800204 	addi	r10,r10,8
8112cb58:	da802215 	stw	r10,136(sp)
8112cb5c:	a080004c 	andi	r2,r20,1
8112cb60:	1001d226 	beq	r2,zero,8112d2ac <___vfiprintf_internal_r+0xecc>
8112cb64:	94c4b03a 	or	r2,r18,r19
8112cb68:	1002351e 	bne	r2,zero,8112d440 <___vfiprintf_internal_r+0x1060>
8112cb6c:	d8001d85 	stb	zero,118(sp)
8112cb70:	48022216 	blt	r9,zero,8112d3fc <___vfiprintf_internal_r+0x101c>
8112cb74:	00bfdfc4 	movi	r2,-129
8112cb78:	a0a8703a 	and	r20,r20,r2
8112cb7c:	003f1506 	br	8112c7d4 <__reset+0xfb10c7d4>
8112cb80:	da802217 	ldw	r10,136(sp)
8112cb84:	04800044 	movi	r18,1
8112cb88:	d8001d85 	stb	zero,118(sp)
8112cb8c:	50800017 	ldw	r2,0(r10)
8112cb90:	52800104 	addi	r10,r10,4
8112cb94:	da802215 	stw	r10,136(sp)
8112cb98:	d8801005 	stb	r2,64(sp)
8112cb9c:	9027883a 	mov	r19,r18
8112cba0:	dd401004 	addi	r21,sp,64
8112cba4:	0013883a 	mov	r9,zero
8112cba8:	003f1706 	br	8112c808 <__reset+0xfb10c808>
8112cbac:	21003fcc 	andi	r4,r4,255
8112cbb0:	2003201e 	bne	r4,zero,8112d834 <___vfiprintf_internal_r+0x1454>
8112cbb4:	a080080c 	andi	r2,r20,32
8112cbb8:	10004b26 	beq	r2,zero,8112cce8 <___vfiprintf_internal_r+0x908>
8112cbbc:	da802217 	ldw	r10,136(sp)
8112cbc0:	50800117 	ldw	r2,4(r10)
8112cbc4:	54800017 	ldw	r18,0(r10)
8112cbc8:	52800204 	addi	r10,r10,8
8112cbcc:	da802215 	stw	r10,136(sp)
8112cbd0:	1027883a 	mov	r19,r2
8112cbd4:	10022c16 	blt	r2,zero,8112d488 <___vfiprintf_internal_r+0x10a8>
8112cbd8:	df001d83 	ldbu	fp,118(sp)
8112cbdc:	48007216 	blt	r9,zero,8112cda8 <___vfiprintf_internal_r+0x9c8>
8112cbe0:	00ffdfc4 	movi	r3,-129
8112cbe4:	94c4b03a 	or	r2,r18,r19
8112cbe8:	a0e8703a 	and	r20,r20,r3
8112cbec:	1000cc26 	beq	r2,zero,8112cf20 <___vfiprintf_internal_r+0xb40>
8112cbf0:	98021026 	beq	r19,zero,8112d434 <___vfiprintf_internal_r+0x1054>
8112cbf4:	dc402415 	stw	r17,144(sp)
8112cbf8:	dc002515 	stw	r16,148(sp)
8112cbfc:	9823883a 	mov	r17,r19
8112cc00:	9021883a 	mov	r16,r18
8112cc04:	dd401a04 	addi	r21,sp,104
8112cc08:	4825883a 	mov	r18,r9
8112cc0c:	4027883a 	mov	r19,r8
8112cc10:	8009883a 	mov	r4,r16
8112cc14:	880b883a 	mov	r5,r17
8112cc18:	01800284 	movi	r6,10
8112cc1c:	000f883a 	mov	r7,zero
8112cc20:	112f17c0 	call	8112f17c <__umoddi3>
8112cc24:	10800c04 	addi	r2,r2,48
8112cc28:	ad7fffc4 	addi	r21,r21,-1
8112cc2c:	8009883a 	mov	r4,r16
8112cc30:	880b883a 	mov	r5,r17
8112cc34:	a8800005 	stb	r2,0(r21)
8112cc38:	01800284 	movi	r6,10
8112cc3c:	000f883a 	mov	r7,zero
8112cc40:	112ebfc0 	call	8112ebfc <__udivdi3>
8112cc44:	1021883a 	mov	r16,r2
8112cc48:	10c4b03a 	or	r2,r2,r3
8112cc4c:	1823883a 	mov	r17,r3
8112cc50:	103fef1e 	bne	r2,zero,8112cc10 <__reset+0xfb10cc10>
8112cc54:	dc402417 	ldw	r17,144(sp)
8112cc58:	dc002517 	ldw	r16,148(sp)
8112cc5c:	9013883a 	mov	r9,r18
8112cc60:	9811883a 	mov	r8,r19
8112cc64:	da801e17 	ldw	r10,120(sp)
8112cc68:	5567c83a 	sub	r19,r10,r21
8112cc6c:	003ede06 	br	8112c7e8 <__reset+0xfb10c7e8>
8112cc70:	38803fcc 	andi	r2,r7,255
8112cc74:	1080201c 	xori	r2,r2,128
8112cc78:	10bfe004 	addi	r2,r2,-128
8112cc7c:	1002371e 	bne	r2,zero,8112d55c <___vfiprintf_internal_r+0x117c>
8112cc80:	01000044 	movi	r4,1
8112cc84:	01c00804 	movi	r7,32
8112cc88:	80c00007 	ldb	r3,0(r16)
8112cc8c:	003e3506 	br	8112c564 <__reset+0xfb10c564>
8112cc90:	a5000054 	ori	r20,r20,1
8112cc94:	80c00007 	ldb	r3,0(r16)
8112cc98:	003e3206 	br	8112c564 <__reset+0xfb10c564>
8112cc9c:	a5002014 	ori	r20,r20,128
8112cca0:	80c00007 	ldb	r3,0(r16)
8112cca4:	003e2f06 	br	8112c564 <__reset+0xfb10c564>
8112cca8:	8015883a 	mov	r10,r16
8112ccac:	0023883a 	mov	r17,zero
8112ccb0:	18bff404 	addi	r2,r3,-48
8112ccb4:	50c00007 	ldb	r3,0(r10)
8112ccb8:	8c4002a4 	muli	r17,r17,10
8112ccbc:	84000044 	addi	r16,r16,1
8112ccc0:	8015883a 	mov	r10,r16
8112ccc4:	1463883a 	add	r17,r2,r17
8112ccc8:	18bff404 	addi	r2,r3,-48
8112cccc:	30bff92e 	bgeu	r6,r2,8112ccb4 <__reset+0xfb10ccb4>
8112ccd0:	003e2506 	br	8112c568 <__reset+0xfb10c568>
8112ccd4:	21003fcc 	andi	r4,r4,255
8112ccd8:	2002d41e 	bne	r4,zero,8112d82c <___vfiprintf_internal_r+0x144c>
8112ccdc:	a5000414 	ori	r20,r20,16
8112cce0:	a080080c 	andi	r2,r20,32
8112cce4:	103fb51e 	bne	r2,zero,8112cbbc <__reset+0xfb10cbbc>
8112cce8:	a080040c 	andi	r2,r20,16
8112ccec:	1001f826 	beq	r2,zero,8112d4d0 <___vfiprintf_internal_r+0x10f0>
8112ccf0:	da802217 	ldw	r10,136(sp)
8112ccf4:	54800017 	ldw	r18,0(r10)
8112ccf8:	52800104 	addi	r10,r10,4
8112ccfc:	da802215 	stw	r10,136(sp)
8112cd00:	9027d7fa 	srai	r19,r18,31
8112cd04:	9805883a 	mov	r2,r19
8112cd08:	003fb206 	br	8112cbd4 <__reset+0xfb10cbd4>
8112cd0c:	21003fcc 	andi	r4,r4,255
8112cd10:	2002c41e 	bne	r4,zero,8112d824 <___vfiprintf_internal_r+0x1444>
8112cd14:	a5000414 	ori	r20,r20,16
8112cd18:	a080080c 	andi	r2,r20,32
8112cd1c:	103f5f1e 	bne	r2,zero,8112ca9c <__reset+0xfb10ca9c>
8112cd20:	a080040c 	andi	r2,r20,16
8112cd24:	10020f26 	beq	r2,zero,8112d564 <___vfiprintf_internal_r+0x1184>
8112cd28:	da802217 	ldw	r10,136(sp)
8112cd2c:	d8001d85 	stb	zero,118(sp)
8112cd30:	0027883a 	mov	r19,zero
8112cd34:	50800104 	addi	r2,r10,4
8112cd38:	54800017 	ldw	r18,0(r10)
8112cd3c:	48021116 	blt	r9,zero,8112d584 <___vfiprintf_internal_r+0x11a4>
8112cd40:	00ffdfc4 	movi	r3,-129
8112cd44:	d8802215 	stw	r2,136(sp)
8112cd48:	a0e8703a 	and	r20,r20,r3
8112cd4c:	903f5e1e 	bne	r18,zero,8112cac8 <__reset+0xfb10cac8>
8112cd50:	0039883a 	mov	fp,zero
8112cd54:	4802a626 	beq	r9,zero,8112d7f0 <___vfiprintf_internal_r+0x1410>
8112cd58:	0025883a 	mov	r18,zero
8112cd5c:	0027883a 	mov	r19,zero
8112cd60:	003f5a06 	br	8112cacc <__reset+0xfb10cacc>
8112cd64:	21003fcc 	andi	r4,r4,255
8112cd68:	20029f1e 	bne	r4,zero,8112d7e8 <___vfiprintf_internal_r+0x1408>
8112cd6c:	a5000414 	ori	r20,r20,16
8112cd70:	a080080c 	andi	r2,r20,32
8112cd74:	10005e1e 	bne	r2,zero,8112cef0 <___vfiprintf_internal_r+0xb10>
8112cd78:	a080040c 	andi	r2,r20,16
8112cd7c:	1001a21e 	bne	r2,zero,8112d408 <___vfiprintf_internal_r+0x1028>
8112cd80:	a080100c 	andi	r2,r20,64
8112cd84:	d8001d85 	stb	zero,118(sp)
8112cd88:	da802217 	ldw	r10,136(sp)
8112cd8c:	1002231e 	bne	r2,zero,8112d61c <___vfiprintf_internal_r+0x123c>
8112cd90:	50800104 	addi	r2,r10,4
8112cd94:	54800017 	ldw	r18,0(r10)
8112cd98:	0027883a 	mov	r19,zero
8112cd9c:	4801a00e 	bge	r9,zero,8112d420 <___vfiprintf_internal_r+0x1040>
8112cda0:	d8802215 	stw	r2,136(sp)
8112cda4:	0039883a 	mov	fp,zero
8112cda8:	94c4b03a 	or	r2,r18,r19
8112cdac:	103f901e 	bne	r2,zero,8112cbf0 <__reset+0xfb10cbf0>
8112cdb0:	00800044 	movi	r2,1
8112cdb4:	10803fcc 	andi	r2,r2,255
8112cdb8:	00c00044 	movi	r3,1
8112cdbc:	10c05926 	beq	r2,r3,8112cf24 <___vfiprintf_internal_r+0xb44>
8112cdc0:	00c00084 	movi	r3,2
8112cdc4:	10ffe41e 	bne	r2,r3,8112cd58 <__reset+0xfb10cd58>
8112cdc8:	0025883a 	mov	r18,zero
8112cdcc:	0027883a 	mov	r19,zero
8112cdd0:	00013d06 	br	8112d2c8 <___vfiprintf_internal_r+0xee8>
8112cdd4:	21003fcc 	andi	r4,r4,255
8112cdd8:	2002811e 	bne	r4,zero,8112d7e0 <___vfiprintf_internal_r+0x1400>
8112cddc:	00a04574 	movhi	r2,33045
8112cde0:	10ae0204 	addi	r2,r2,-18424
8112cde4:	d8802615 	stw	r2,152(sp)
8112cde8:	a080080c 	andi	r2,r20,32
8112cdec:	103f561e 	bne	r2,zero,8112cb48 <__reset+0xfb10cb48>
8112cdf0:	a080040c 	andi	r2,r20,16
8112cdf4:	1001d126 	beq	r2,zero,8112d53c <___vfiprintf_internal_r+0x115c>
8112cdf8:	da802217 	ldw	r10,136(sp)
8112cdfc:	0027883a 	mov	r19,zero
8112ce00:	54800017 	ldw	r18,0(r10)
8112ce04:	52800104 	addi	r10,r10,4
8112ce08:	da802215 	stw	r10,136(sp)
8112ce0c:	003f5306 	br	8112cb5c <__reset+0xfb10cb5c>
8112ce10:	da802217 	ldw	r10,136(sp)
8112ce14:	d8001d85 	stb	zero,118(sp)
8112ce18:	55400017 	ldw	r21,0(r10)
8112ce1c:	50c00104 	addi	r3,r10,4
8112ce20:	a8024226 	beq	r21,zero,8112d72c <___vfiprintf_internal_r+0x134c>
8112ce24:	48021816 	blt	r9,zero,8112d688 <___vfiprintf_internal_r+0x12a8>
8112ce28:	480d883a 	mov	r6,r9
8112ce2c:	000b883a 	mov	r5,zero
8112ce30:	a809883a 	mov	r4,r21
8112ce34:	d8c02a15 	stw	r3,168(sp)
8112ce38:	da002b15 	stw	r8,172(sp)
8112ce3c:	da402c15 	stw	r9,176(sp)
8112ce40:	11271bc0 	call	811271bc <memchr>
8112ce44:	d8c02a17 	ldw	r3,168(sp)
8112ce48:	da002b17 	ldw	r8,172(sp)
8112ce4c:	da402c17 	ldw	r9,176(sp)
8112ce50:	10024826 	beq	r2,zero,8112d774 <___vfiprintf_internal_r+0x1394>
8112ce54:	1567c83a 	sub	r19,r2,r21
8112ce58:	df001d83 	ldbu	fp,118(sp)
8112ce5c:	d8c02215 	stw	r3,136(sp)
8112ce60:	0013883a 	mov	r9,zero
8112ce64:	003e6006 	br	8112c7e8 <__reset+0xfb10c7e8>
8112ce68:	21003fcc 	andi	r4,r4,255
8112ce6c:	203fc026 	beq	r4,zero,8112cd70 <__reset+0xfb10cd70>
8112ce70:	d9c01d85 	stb	r7,118(sp)
8112ce74:	003fbe06 	br	8112cd70 <__reset+0xfb10cd70>
8112ce78:	da802217 	ldw	r10,136(sp)
8112ce7c:	54400017 	ldw	r17,0(r10)
8112ce80:	50800104 	addi	r2,r10,4
8112ce84:	883e3b16 	blt	r17,zero,8112c774 <__reset+0xfb10c774>
8112ce88:	d8802215 	stw	r2,136(sp)
8112ce8c:	80c00007 	ldb	r3,0(r16)
8112ce90:	003db406 	br	8112c564 <__reset+0xfb10c564>
8112ce94:	01000044 	movi	r4,1
8112ce98:	01c00ac4 	movi	r7,43
8112ce9c:	80c00007 	ldb	r3,0(r16)
8112cea0:	003db006 	br	8112c564 <__reset+0xfb10c564>
8112cea4:	80c00007 	ldb	r3,0(r16)
8112cea8:	82800044 	addi	r10,r16,1
8112ceac:	1b423c26 	beq	r3,r13,8112d7a0 <___vfiprintf_internal_r+0x13c0>
8112ceb0:	18bff404 	addi	r2,r3,-48
8112ceb4:	0013883a 	mov	r9,zero
8112ceb8:	30822b36 	bltu	r6,r2,8112d768 <___vfiprintf_internal_r+0x1388>
8112cebc:	50c00007 	ldb	r3,0(r10)
8112cec0:	4a4002a4 	muli	r9,r9,10
8112cec4:	54000044 	addi	r16,r10,1
8112cec8:	8015883a 	mov	r10,r16
8112cecc:	4893883a 	add	r9,r9,r2
8112ced0:	18bff404 	addi	r2,r3,-48
8112ced4:	30bff92e 	bgeu	r6,r2,8112cebc <__reset+0xfb10cebc>
8112ced8:	483da30e 	bge	r9,zero,8112c568 <__reset+0xfb10c568>
8112cedc:	027fffc4 	movi	r9,-1
8112cee0:	003da106 	br	8112c568 <__reset+0xfb10c568>
8112cee4:	a5001014 	ori	r20,r20,64
8112cee8:	80c00007 	ldb	r3,0(r16)
8112ceec:	003d9d06 	br	8112c564 <__reset+0xfb10c564>
8112cef0:	da802217 	ldw	r10,136(sp)
8112cef4:	d8001d85 	stb	zero,118(sp)
8112cef8:	50c00204 	addi	r3,r10,8
8112cefc:	54800017 	ldw	r18,0(r10)
8112cf00:	54c00117 	ldw	r19,4(r10)
8112cf04:	4801ca16 	blt	r9,zero,8112d630 <___vfiprintf_internal_r+0x1250>
8112cf08:	013fdfc4 	movi	r4,-129
8112cf0c:	94c4b03a 	or	r2,r18,r19
8112cf10:	d8c02215 	stw	r3,136(sp)
8112cf14:	a128703a 	and	r20,r20,r4
8112cf18:	0039883a 	mov	fp,zero
8112cf1c:	103f341e 	bne	r2,zero,8112cbf0 <__reset+0xfb10cbf0>
8112cf20:	483e2e26 	beq	r9,zero,8112c7dc <__reset+0xfb10c7dc>
8112cf24:	0025883a 	mov	r18,zero
8112cf28:	94800c04 	addi	r18,r18,48
8112cf2c:	dc8019c5 	stb	r18,103(sp)
8112cf30:	dcc02717 	ldw	r19,156(sp)
8112cf34:	dd4019c4 	addi	r21,sp,103
8112cf38:	003e2b06 	br	8112c7e8 <__reset+0xfb10c7e8>
8112cf3c:	21003fcc 	andi	r4,r4,255
8112cf40:	2002361e 	bne	r4,zero,8112d81c <___vfiprintf_internal_r+0x143c>
8112cf44:	1801c126 	beq	r3,zero,8112d64c <___vfiprintf_internal_r+0x126c>
8112cf48:	04800044 	movi	r18,1
8112cf4c:	d8c01005 	stb	r3,64(sp)
8112cf50:	d8001d85 	stb	zero,118(sp)
8112cf54:	9027883a 	mov	r19,r18
8112cf58:	dd401004 	addi	r21,sp,64
8112cf5c:	003f1106 	br	8112cba4 <__reset+0xfb10cba4>
8112cf60:	d9402117 	ldw	r5,132(sp)
8112cf64:	d9002017 	ldw	r4,128(sp)
8112cf68:	d9801a04 	addi	r6,sp,104
8112cf6c:	d9c02b15 	stw	r7,172(sp)
8112cf70:	dbc02a15 	stw	r15,168(sp)
8112cf74:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112cf78:	d9c02b17 	ldw	r7,172(sp)
8112cf7c:	dbc02a17 	ldw	r15,168(sp)
8112cf80:	10006d1e 	bne	r2,zero,8112d138 <___vfiprintf_internal_r+0xd58>
8112cf84:	d9801b17 	ldw	r6,108(sp)
8112cf88:	d8801c17 	ldw	r2,112(sp)
8112cf8c:	d811883a 	mov	r8,sp
8112cf90:	31400044 	addi	r5,r6,1
8112cf94:	003e3306 	br	8112c864 <__reset+0xfb10c864>
8112cf98:	d9401b17 	ldw	r5,108(sp)
8112cf9c:	d8801c17 	ldw	r2,112(sp)
8112cfa0:	29000044 	addi	r4,r5,1
8112cfa4:	d8c01d87 	ldb	r3,118(sp)
8112cfa8:	183e4d26 	beq	r3,zero,8112c8e0 <__reset+0xfb10c8e0>
8112cfac:	00c00044 	movi	r3,1
8112cfb0:	d9401d84 	addi	r5,sp,118
8112cfb4:	10c5883a 	add	r2,r2,r3
8112cfb8:	41400015 	stw	r5,0(r8)
8112cfbc:	40c00115 	stw	r3,4(r8)
8112cfc0:	d8801c15 	stw	r2,112(sp)
8112cfc4:	d9001b15 	stw	r4,108(sp)
8112cfc8:	014001c4 	movi	r5,7
8112cfcc:	2900a90e 	bge	r5,r4,8112d274 <___vfiprintf_internal_r+0xe94>
8112cfd0:	1000da1e 	bne	r2,zero,8112d33c <___vfiprintf_internal_r+0xf5c>
8112cfd4:	7000ab1e 	bne	r14,zero,8112d284 <___vfiprintf_internal_r+0xea4>
8112cfd8:	000b883a 	mov	r5,zero
8112cfdc:	1809883a 	mov	r4,r3
8112cfe0:	d811883a 	mov	r8,sp
8112cfe4:	00c02004 	movi	r3,128
8112cfe8:	e0fe4d26 	beq	fp,r3,8112c920 <__reset+0xfb10c920>
8112cfec:	4cf9c83a 	sub	fp,r9,r19
8112cff0:	073e7b0e 	bge	zero,fp,8112c9e0 <__reset+0xfb10c9e0>
8112cff4:	01c00404 	movi	r7,16
8112cff8:	3f01900e 	bge	r7,fp,8112d63c <___vfiprintf_internal_r+0x125c>
8112cffc:	00e04574 	movhi	r3,33045
8112d000:	18ee9904 	addi	r3,r3,-17820
8112d004:	d8c02415 	stw	r3,144(sp)
8112d008:	034001c4 	movi	r13,7
8112d00c:	00000506 	br	8112d024 <___vfiprintf_internal_r+0xc44>
8112d010:	29000084 	addi	r4,r5,2
8112d014:	42000204 	addi	r8,r8,8
8112d018:	180b883a 	mov	r5,r3
8112d01c:	e73ffc04 	addi	fp,fp,-16
8112d020:	3f000d0e 	bge	r7,fp,8112d058 <___vfiprintf_internal_r+0xc78>
8112d024:	10800404 	addi	r2,r2,16
8112d028:	28c00044 	addi	r3,r5,1
8112d02c:	45c00015 	stw	r23,0(r8)
8112d030:	41c00115 	stw	r7,4(r8)
8112d034:	d8801c15 	stw	r2,112(sp)
8112d038:	d8c01b15 	stw	r3,108(sp)
8112d03c:	68fff40e 	bge	r13,r3,8112d010 <__reset+0xfb10d010>
8112d040:	1000101e 	bne	r2,zero,8112d084 <___vfiprintf_internal_r+0xca4>
8112d044:	e73ffc04 	addi	fp,fp,-16
8112d048:	01000044 	movi	r4,1
8112d04c:	000b883a 	mov	r5,zero
8112d050:	d811883a 	mov	r8,sp
8112d054:	3f3ff316 	blt	r7,fp,8112d024 <__reset+0xfb10d024>
8112d058:	da802417 	ldw	r10,144(sp)
8112d05c:	1705883a 	add	r2,r2,fp
8112d060:	47000115 	stw	fp,4(r8)
8112d064:	42800015 	stw	r10,0(r8)
8112d068:	d8801c15 	stw	r2,112(sp)
8112d06c:	d9001b15 	stw	r4,108(sp)
8112d070:	00c001c4 	movi	r3,7
8112d074:	19003616 	blt	r3,r4,8112d150 <___vfiprintf_internal_r+0xd70>
8112d078:	42000204 	addi	r8,r8,8
8112d07c:	21000044 	addi	r4,r4,1
8112d080:	003e5706 	br	8112c9e0 <__reset+0xfb10c9e0>
8112d084:	d9402117 	ldw	r5,132(sp)
8112d088:	d9002017 	ldw	r4,128(sp)
8112d08c:	d9801a04 	addi	r6,sp,104
8112d090:	d9c02b15 	stw	r7,172(sp)
8112d094:	db402a15 	stw	r13,168(sp)
8112d098:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d09c:	d9c02b17 	ldw	r7,172(sp)
8112d0a0:	db402a17 	ldw	r13,168(sp)
8112d0a4:	1000241e 	bne	r2,zero,8112d138 <___vfiprintf_internal_r+0xd58>
8112d0a8:	d9401b17 	ldw	r5,108(sp)
8112d0ac:	d8801c17 	ldw	r2,112(sp)
8112d0b0:	d811883a 	mov	r8,sp
8112d0b4:	29000044 	addi	r4,r5,1
8112d0b8:	003fd806 	br	8112d01c <__reset+0xfb10d01c>
8112d0bc:	d9401b17 	ldw	r5,108(sp)
8112d0c0:	00e04574 	movhi	r3,33045
8112d0c4:	18ee9d04 	addi	r3,r3,-17804
8112d0c8:	d8c02415 	stw	r3,144(sp)
8112d0cc:	29400044 	addi	r5,r5,1
8112d0d0:	d8c02417 	ldw	r3,144(sp)
8112d0d4:	14c5883a 	add	r2,r2,r19
8112d0d8:	44c00115 	stw	r19,4(r8)
8112d0dc:	40c00015 	stw	r3,0(r8)
8112d0e0:	d8801c15 	stw	r2,112(sp)
8112d0e4:	d9401b15 	stw	r5,108(sp)
8112d0e8:	00c001c4 	movi	r3,7
8112d0ec:	1940070e 	bge	r3,r5,8112d10c <___vfiprintf_internal_r+0xd2c>
8112d0f0:	103e4826 	beq	r2,zero,8112ca14 <__reset+0xfb10ca14>
8112d0f4:	d9402117 	ldw	r5,132(sp)
8112d0f8:	d9002017 	ldw	r4,128(sp)
8112d0fc:	d9801a04 	addi	r6,sp,104
8112d100:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d104:	10000c1e 	bne	r2,zero,8112d138 <___vfiprintf_internal_r+0xd58>
8112d108:	d8801c17 	ldw	r2,112(sp)
8112d10c:	8c80010e 	bge	r17,r18,8112d114 <___vfiprintf_internal_r+0xd34>
8112d110:	9023883a 	mov	r17,r18
8112d114:	da802317 	ldw	r10,140(sp)
8112d118:	5455883a 	add	r10,r10,r17
8112d11c:	da802315 	stw	r10,140(sp)
8112d120:	103e4126 	beq	r2,zero,8112ca28 <__reset+0xfb10ca28>
8112d124:	d9402117 	ldw	r5,132(sp)
8112d128:	d9002017 	ldw	r4,128(sp)
8112d12c:	d9801a04 	addi	r6,sp,104
8112d130:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d134:	103e3c26 	beq	r2,zero,8112ca28 <__reset+0xfb10ca28>
8112d138:	dd002117 	ldw	r20,132(sp)
8112d13c:	a080030b 	ldhu	r2,12(r20)
8112d140:	1080100c 	andi	r2,r2,64
8112d144:	1001231e 	bne	r2,zero,8112d5d4 <___vfiprintf_internal_r+0x11f4>
8112d148:	d8802317 	ldw	r2,140(sp)
8112d14c:	003d7b06 	br	8112c73c <__reset+0xfb10c73c>
8112d150:	1000991e 	bne	r2,zero,8112d3b8 <___vfiprintf_internal_r+0xfd8>
8112d154:	00c00044 	movi	r3,1
8112d158:	9805883a 	mov	r2,r19
8112d15c:	dd400015 	stw	r21,0(sp)
8112d160:	dcc00115 	stw	r19,4(sp)
8112d164:	dcc01c15 	stw	r19,112(sp)
8112d168:	d8c01b15 	stw	r3,108(sp)
8112d16c:	d811883a 	mov	r8,sp
8112d170:	42000204 	addi	r8,r8,8
8112d174:	a2c0010c 	andi	r11,r20,4
8112d178:	583fe426 	beq	r11,zero,8112d10c <__reset+0xfb10d10c>
8112d17c:	8ca7c83a 	sub	r19,r17,r18
8112d180:	04ffe20e 	bge	zero,r19,8112d10c <__reset+0xfb10d10c>
8112d184:	01c00404 	movi	r7,16
8112d188:	3cffcc0e 	bge	r7,r19,8112d0bc <__reset+0xfb10d0bc>
8112d18c:	02a04574 	movhi	r10,33045
8112d190:	52ae9d04 	addi	r10,r10,-17804
8112d194:	d9001b17 	ldw	r4,108(sp)
8112d198:	da802415 	stw	r10,144(sp)
8112d19c:	382b883a 	mov	r21,r7
8112d1a0:	050001c4 	movi	r20,7
8112d1a4:	df002017 	ldw	fp,128(sp)
8112d1a8:	00000506 	br	8112d1c0 <___vfiprintf_internal_r+0xde0>
8112d1ac:	21400084 	addi	r5,r4,2
8112d1b0:	42000204 	addi	r8,r8,8
8112d1b4:	1809883a 	mov	r4,r3
8112d1b8:	9cfffc04 	addi	r19,r19,-16
8112d1bc:	acffc40e 	bge	r21,r19,8112d0d0 <__reset+0xfb10d0d0>
8112d1c0:	10800404 	addi	r2,r2,16
8112d1c4:	20c00044 	addi	r3,r4,1
8112d1c8:	45800015 	stw	r22,0(r8)
8112d1cc:	45400115 	stw	r21,4(r8)
8112d1d0:	d8801c15 	stw	r2,112(sp)
8112d1d4:	d8c01b15 	stw	r3,108(sp)
8112d1d8:	a0fff40e 	bge	r20,r3,8112d1ac <__reset+0xfb10d1ac>
8112d1dc:	1000041e 	bne	r2,zero,8112d1f0 <___vfiprintf_internal_r+0xe10>
8112d1e0:	01400044 	movi	r5,1
8112d1e4:	0009883a 	mov	r4,zero
8112d1e8:	d811883a 	mov	r8,sp
8112d1ec:	003ff206 	br	8112d1b8 <__reset+0xfb10d1b8>
8112d1f0:	d9402117 	ldw	r5,132(sp)
8112d1f4:	d9801a04 	addi	r6,sp,104
8112d1f8:	e009883a 	mov	r4,fp
8112d1fc:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d200:	103fcd1e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d204:	d9001b17 	ldw	r4,108(sp)
8112d208:	d8801c17 	ldw	r2,112(sp)
8112d20c:	d811883a 	mov	r8,sp
8112d210:	21400044 	addi	r5,r4,1
8112d214:	003fe806 	br	8112d1b8 <__reset+0xfb10d1b8>
8112d218:	d9402117 	ldw	r5,132(sp)
8112d21c:	d9002017 	ldw	r4,128(sp)
8112d220:	d9801a04 	addi	r6,sp,104
8112d224:	d9c02b15 	stw	r7,172(sp)
8112d228:	db402a15 	stw	r13,168(sp)
8112d22c:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d230:	d9c02b17 	ldw	r7,172(sp)
8112d234:	db402a17 	ldw	r13,168(sp)
8112d238:	103fbf1e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d23c:	d9401b17 	ldw	r5,108(sp)
8112d240:	d8801c17 	ldw	r2,112(sp)
8112d244:	d811883a 	mov	r8,sp
8112d248:	29800044 	addi	r6,r5,1
8112d24c:	003dc406 	br	8112c960 <__reset+0xfb10c960>
8112d250:	1000d21e 	bne	r2,zero,8112d59c <___vfiprintf_internal_r+0x11bc>
8112d254:	d8c01d87 	ldb	r3,118(sp)
8112d258:	18009526 	beq	r3,zero,8112d4b0 <___vfiprintf_internal_r+0x10d0>
8112d25c:	00800044 	movi	r2,1
8112d260:	d8c01d84 	addi	r3,sp,118
8112d264:	1009883a 	mov	r4,r2
8112d268:	d8c00015 	stw	r3,0(sp)
8112d26c:	d8800115 	stw	r2,4(sp)
8112d270:	d811883a 	mov	r8,sp
8112d274:	200b883a 	mov	r5,r4
8112d278:	42000204 	addi	r8,r8,8
8112d27c:	21000044 	addi	r4,r4,1
8112d280:	003d9706 	br	8112c8e0 <__reset+0xfb10c8e0>
8112d284:	d9001d04 	addi	r4,sp,116
8112d288:	00800084 	movi	r2,2
8112d28c:	d9000015 	stw	r4,0(sp)
8112d290:	d8800115 	stw	r2,4(sp)
8112d294:	1809883a 	mov	r4,r3
8112d298:	d811883a 	mov	r8,sp
8112d29c:	200b883a 	mov	r5,r4
8112d2a0:	42000204 	addi	r8,r8,8
8112d2a4:	21000044 	addi	r4,r4,1
8112d2a8:	003f4e06 	br	8112cfe4 <__reset+0xfb10cfe4>
8112d2ac:	d8001d85 	stb	zero,118(sp)
8112d2b0:	48005016 	blt	r9,zero,8112d3f4 <___vfiprintf_internal_r+0x1014>
8112d2b4:	00ffdfc4 	movi	r3,-129
8112d2b8:	94c4b03a 	or	r2,r18,r19
8112d2bc:	a0e8703a 	and	r20,r20,r3
8112d2c0:	103d4426 	beq	r2,zero,8112c7d4 <__reset+0xfb10c7d4>
8112d2c4:	0039883a 	mov	fp,zero
8112d2c8:	d9002617 	ldw	r4,152(sp)
8112d2cc:	dd401a04 	addi	r21,sp,104
8112d2d0:	908003cc 	andi	r2,r18,15
8112d2d4:	9806973a 	slli	r3,r19,28
8112d2d8:	2085883a 	add	r2,r4,r2
8112d2dc:	9024d13a 	srli	r18,r18,4
8112d2e0:	10800003 	ldbu	r2,0(r2)
8112d2e4:	9826d13a 	srli	r19,r19,4
8112d2e8:	ad7fffc4 	addi	r21,r21,-1
8112d2ec:	1ca4b03a 	or	r18,r3,r18
8112d2f0:	a8800005 	stb	r2,0(r21)
8112d2f4:	94c4b03a 	or	r2,r18,r19
8112d2f8:	103ff51e 	bne	r2,zero,8112d2d0 <__reset+0xfb10d2d0>
8112d2fc:	003e5906 	br	8112cc64 <__reset+0xfb10cc64>
8112d300:	d9402117 	ldw	r5,132(sp)
8112d304:	d9002017 	ldw	r4,128(sp)
8112d308:	d9801a04 	addi	r6,sp,104
8112d30c:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d310:	103f891e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d314:	d8801c17 	ldw	r2,112(sp)
8112d318:	d811883a 	mov	r8,sp
8112d31c:	003f9506 	br	8112d174 <__reset+0xfb10d174>
8112d320:	d9402117 	ldw	r5,132(sp)
8112d324:	d9002017 	ldw	r4,128(sp)
8112d328:	d9801a04 	addi	r6,sp,104
8112d32c:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d330:	103f811e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d334:	d811883a 	mov	r8,sp
8112d338:	003ced06 	br	8112c6f0 <__reset+0xfb10c6f0>
8112d33c:	d9402117 	ldw	r5,132(sp)
8112d340:	d9002017 	ldw	r4,128(sp)
8112d344:	d9801a04 	addi	r6,sp,104
8112d348:	da402c15 	stw	r9,176(sp)
8112d34c:	db802a15 	stw	r14,168(sp)
8112d350:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d354:	da402c17 	ldw	r9,176(sp)
8112d358:	db802a17 	ldw	r14,168(sp)
8112d35c:	103f761e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d360:	d9401b17 	ldw	r5,108(sp)
8112d364:	d8801c17 	ldw	r2,112(sp)
8112d368:	d811883a 	mov	r8,sp
8112d36c:	29000044 	addi	r4,r5,1
8112d370:	003d5b06 	br	8112c8e0 <__reset+0xfb10c8e0>
8112d374:	d9402117 	ldw	r5,132(sp)
8112d378:	d9002017 	ldw	r4,128(sp)
8112d37c:	d9801a04 	addi	r6,sp,104
8112d380:	da402c15 	stw	r9,176(sp)
8112d384:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d388:	da402c17 	ldw	r9,176(sp)
8112d38c:	103f6a1e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d390:	d9401b17 	ldw	r5,108(sp)
8112d394:	d8801c17 	ldw	r2,112(sp)
8112d398:	d811883a 	mov	r8,sp
8112d39c:	29000044 	addi	r4,r5,1
8112d3a0:	003f1006 	br	8112cfe4 <__reset+0xfb10cfe4>
8112d3a4:	1000c31e 	bne	r2,zero,8112d6b4 <___vfiprintf_internal_r+0x12d4>
8112d3a8:	01000044 	movi	r4,1
8112d3ac:	000b883a 	mov	r5,zero
8112d3b0:	d811883a 	mov	r8,sp
8112d3b4:	003f0d06 	br	8112cfec <__reset+0xfb10cfec>
8112d3b8:	d9402117 	ldw	r5,132(sp)
8112d3bc:	d9002017 	ldw	r4,128(sp)
8112d3c0:	d9801a04 	addi	r6,sp,104
8112d3c4:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d3c8:	103f5b1e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d3cc:	d9001b17 	ldw	r4,108(sp)
8112d3d0:	d8801c17 	ldw	r2,112(sp)
8112d3d4:	d811883a 	mov	r8,sp
8112d3d8:	21000044 	addi	r4,r4,1
8112d3dc:	003d8006 	br	8112c9e0 <__reset+0xfb10c9e0>
8112d3e0:	01204574 	movhi	r4,33045
8112d3e4:	212e0704 	addi	r4,r4,-18404
8112d3e8:	d9002615 	stw	r4,152(sp)
8112d3ec:	d8c02215 	stw	r3,136(sp)
8112d3f0:	1029883a 	mov	r20,r2
8112d3f4:	94c4b03a 	or	r2,r18,r19
8112d3f8:	103fb21e 	bne	r2,zero,8112d2c4 <__reset+0xfb10d2c4>
8112d3fc:	0039883a 	mov	fp,zero
8112d400:	00800084 	movi	r2,2
8112d404:	003e6b06 	br	8112cdb4 <__reset+0xfb10cdb4>
8112d408:	da802217 	ldw	r10,136(sp)
8112d40c:	d8001d85 	stb	zero,118(sp)
8112d410:	0027883a 	mov	r19,zero
8112d414:	50800104 	addi	r2,r10,4
8112d418:	54800017 	ldw	r18,0(r10)
8112d41c:	483e6016 	blt	r9,zero,8112cda0 <__reset+0xfb10cda0>
8112d420:	00ffdfc4 	movi	r3,-129
8112d424:	d8802215 	stw	r2,136(sp)
8112d428:	a0e8703a 	and	r20,r20,r3
8112d42c:	0039883a 	mov	fp,zero
8112d430:	903ebb26 	beq	r18,zero,8112cf20 <__reset+0xfb10cf20>
8112d434:	00800244 	movi	r2,9
8112d438:	14bdee36 	bltu	r2,r18,8112cbf4 <__reset+0xfb10cbf4>
8112d43c:	003eba06 	br	8112cf28 <__reset+0xfb10cf28>
8112d440:	00800c04 	movi	r2,48
8112d444:	d8c01d45 	stb	r3,117(sp)
8112d448:	d8801d05 	stb	r2,116(sp)
8112d44c:	d8001d85 	stb	zero,118(sp)
8112d450:	a0c00094 	ori	r3,r20,2
8112d454:	4800a916 	blt	r9,zero,8112d6fc <___vfiprintf_internal_r+0x131c>
8112d458:	00bfdfc4 	movi	r2,-129
8112d45c:	a096703a 	and	r11,r20,r2
8112d460:	5d000094 	ori	r20,r11,2
8112d464:	0039883a 	mov	fp,zero
8112d468:	003f9706 	br	8112d2c8 <__reset+0xfb10d2c8>
8112d46c:	8025883a 	mov	r18,r16
8112d470:	003c2e06 	br	8112c52c <__reset+0xfb10c52c>
8112d474:	00a04574 	movhi	r2,33045
8112d478:	10ae0704 	addi	r2,r2,-18404
8112d47c:	0039883a 	mov	fp,zero
8112d480:	d8802615 	stw	r2,152(sp)
8112d484:	003f9006 	br	8112d2c8 <__reset+0xfb10d2c8>
8112d488:	04a5c83a 	sub	r18,zero,r18
8112d48c:	07000b44 	movi	fp,45
8112d490:	9004c03a 	cmpne	r2,r18,zero
8112d494:	04e7c83a 	sub	r19,zero,r19
8112d498:	df001d85 	stb	fp,118(sp)
8112d49c:	98a7c83a 	sub	r19,r19,r2
8112d4a0:	48009f16 	blt	r9,zero,8112d720 <___vfiprintf_internal_r+0x1340>
8112d4a4:	00bfdfc4 	movi	r2,-129
8112d4a8:	a0a8703a 	and	r20,r20,r2
8112d4ac:	003dd006 	br	8112cbf0 <__reset+0xfb10cbf0>
8112d4b0:	70004c26 	beq	r14,zero,8112d5e4 <___vfiprintf_internal_r+0x1204>
8112d4b4:	00800084 	movi	r2,2
8112d4b8:	d8c01d04 	addi	r3,sp,116
8112d4bc:	d8c00015 	stw	r3,0(sp)
8112d4c0:	d8800115 	stw	r2,4(sp)
8112d4c4:	01000044 	movi	r4,1
8112d4c8:	d811883a 	mov	r8,sp
8112d4cc:	003f7306 	br	8112d29c <__reset+0xfb10d29c>
8112d4d0:	a080100c 	andi	r2,r20,64
8112d4d4:	da802217 	ldw	r10,136(sp)
8112d4d8:	103e0626 	beq	r2,zero,8112ccf4 <__reset+0xfb10ccf4>
8112d4dc:	5480000f 	ldh	r18,0(r10)
8112d4e0:	52800104 	addi	r10,r10,4
8112d4e4:	da802215 	stw	r10,136(sp)
8112d4e8:	9027d7fa 	srai	r19,r18,31
8112d4ec:	9805883a 	mov	r2,r19
8112d4f0:	003db806 	br	8112cbd4 <__reset+0xfb10cbd4>
8112d4f4:	a080040c 	andi	r2,r20,16
8112d4f8:	1000091e 	bne	r2,zero,8112d520 <___vfiprintf_internal_r+0x1140>
8112d4fc:	a2c0100c 	andi	r11,r20,64
8112d500:	58000726 	beq	r11,zero,8112d520 <___vfiprintf_internal_r+0x1140>
8112d504:	da802217 	ldw	r10,136(sp)
8112d508:	50800017 	ldw	r2,0(r10)
8112d50c:	52800104 	addi	r10,r10,4
8112d510:	da802215 	stw	r10,136(sp)
8112d514:	da802317 	ldw	r10,140(sp)
8112d518:	1280000d 	sth	r10,0(r2)
8112d51c:	003be706 	br	8112c4bc <__reset+0xfb10c4bc>
8112d520:	da802217 	ldw	r10,136(sp)
8112d524:	50800017 	ldw	r2,0(r10)
8112d528:	52800104 	addi	r10,r10,4
8112d52c:	da802215 	stw	r10,136(sp)
8112d530:	da802317 	ldw	r10,140(sp)
8112d534:	12800015 	stw	r10,0(r2)
8112d538:	003be006 	br	8112c4bc <__reset+0xfb10c4bc>
8112d53c:	a080100c 	andi	r2,r20,64
8112d540:	da802217 	ldw	r10,136(sp)
8112d544:	10003026 	beq	r2,zero,8112d608 <___vfiprintf_internal_r+0x1228>
8112d548:	5480000b 	ldhu	r18,0(r10)
8112d54c:	52800104 	addi	r10,r10,4
8112d550:	0027883a 	mov	r19,zero
8112d554:	da802215 	stw	r10,136(sp)
8112d558:	003d8006 	br	8112cb5c <__reset+0xfb10cb5c>
8112d55c:	80c00007 	ldb	r3,0(r16)
8112d560:	003c0006 	br	8112c564 <__reset+0xfb10c564>
8112d564:	a080100c 	andi	r2,r20,64
8112d568:	d8001d85 	stb	zero,118(sp)
8112d56c:	da802217 	ldw	r10,136(sp)
8112d570:	1000201e 	bne	r2,zero,8112d5f4 <___vfiprintf_internal_r+0x1214>
8112d574:	50800104 	addi	r2,r10,4
8112d578:	54800017 	ldw	r18,0(r10)
8112d57c:	0027883a 	mov	r19,zero
8112d580:	483def0e 	bge	r9,zero,8112cd40 <__reset+0xfb10cd40>
8112d584:	94c6b03a 	or	r3,r18,r19
8112d588:	d8802215 	stw	r2,136(sp)
8112d58c:	183d4e1e 	bne	r3,zero,8112cac8 <__reset+0xfb10cac8>
8112d590:	0039883a 	mov	fp,zero
8112d594:	0005883a 	mov	r2,zero
8112d598:	003e0606 	br	8112cdb4 <__reset+0xfb10cdb4>
8112d59c:	d9402117 	ldw	r5,132(sp)
8112d5a0:	d9002017 	ldw	r4,128(sp)
8112d5a4:	d9801a04 	addi	r6,sp,104
8112d5a8:	da402c15 	stw	r9,176(sp)
8112d5ac:	db802a15 	stw	r14,168(sp)
8112d5b0:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d5b4:	da402c17 	ldw	r9,176(sp)
8112d5b8:	db802a17 	ldw	r14,168(sp)
8112d5bc:	103ede1e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d5c0:	d9401b17 	ldw	r5,108(sp)
8112d5c4:	d8801c17 	ldw	r2,112(sp)
8112d5c8:	d811883a 	mov	r8,sp
8112d5cc:	29000044 	addi	r4,r5,1
8112d5d0:	003e7406 	br	8112cfa4 <__reset+0xfb10cfa4>
8112d5d4:	00bfffc4 	movi	r2,-1
8112d5d8:	003c5806 	br	8112c73c <__reset+0xfb10c73c>
8112d5dc:	d811883a 	mov	r8,sp
8112d5e0:	003ee806 	br	8112d184 <__reset+0xfb10d184>
8112d5e4:	000b883a 	mov	r5,zero
8112d5e8:	01000044 	movi	r4,1
8112d5ec:	d811883a 	mov	r8,sp
8112d5f0:	003e7c06 	br	8112cfe4 <__reset+0xfb10cfe4>
8112d5f4:	50800104 	addi	r2,r10,4
8112d5f8:	5480000b 	ldhu	r18,0(r10)
8112d5fc:	0027883a 	mov	r19,zero
8112d600:	483dcf0e 	bge	r9,zero,8112cd40 <__reset+0xfb10cd40>
8112d604:	003fdf06 	br	8112d584 <__reset+0xfb10d584>
8112d608:	54800017 	ldw	r18,0(r10)
8112d60c:	52800104 	addi	r10,r10,4
8112d610:	0027883a 	mov	r19,zero
8112d614:	da802215 	stw	r10,136(sp)
8112d618:	003d5006 	br	8112cb5c <__reset+0xfb10cb5c>
8112d61c:	50800104 	addi	r2,r10,4
8112d620:	5480000b 	ldhu	r18,0(r10)
8112d624:	0027883a 	mov	r19,zero
8112d628:	483f7d0e 	bge	r9,zero,8112d420 <__reset+0xfb10d420>
8112d62c:	003ddc06 	br	8112cda0 <__reset+0xfb10cda0>
8112d630:	d8c02215 	stw	r3,136(sp)
8112d634:	0039883a 	mov	fp,zero
8112d638:	003ddb06 	br	8112cda8 <__reset+0xfb10cda8>
8112d63c:	02a04574 	movhi	r10,33045
8112d640:	52ae9904 	addi	r10,r10,-17820
8112d644:	da802415 	stw	r10,144(sp)
8112d648:	003e8306 	br	8112d058 <__reset+0xfb10d058>
8112d64c:	d8801c17 	ldw	r2,112(sp)
8112d650:	dd002117 	ldw	r20,132(sp)
8112d654:	103eb926 	beq	r2,zero,8112d13c <__reset+0xfb10d13c>
8112d658:	d9002017 	ldw	r4,128(sp)
8112d65c:	d9801a04 	addi	r6,sp,104
8112d660:	a00b883a 	mov	r5,r20
8112d664:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d668:	003eb406 	br	8112d13c <__reset+0xfb10d13c>
8112d66c:	80c00043 	ldbu	r3,1(r16)
8112d670:	a5000814 	ori	r20,r20,32
8112d674:	84000044 	addi	r16,r16,1
8112d678:	18c03fcc 	andi	r3,r3,255
8112d67c:	18c0201c 	xori	r3,r3,128
8112d680:	18ffe004 	addi	r3,r3,-128
8112d684:	003bb706 	br	8112c564 <__reset+0xfb10c564>
8112d688:	a809883a 	mov	r4,r21
8112d68c:	d8c02a15 	stw	r3,168(sp)
8112d690:	da002b15 	stw	r8,172(sp)
8112d694:	111dcc00 	call	8111dcc0 <strlen>
8112d698:	d8c02a17 	ldw	r3,168(sp)
8112d69c:	1027883a 	mov	r19,r2
8112d6a0:	df001d83 	ldbu	fp,118(sp)
8112d6a4:	d8c02215 	stw	r3,136(sp)
8112d6a8:	0013883a 	mov	r9,zero
8112d6ac:	da002b17 	ldw	r8,172(sp)
8112d6b0:	003c4d06 	br	8112c7e8 <__reset+0xfb10c7e8>
8112d6b4:	d9402117 	ldw	r5,132(sp)
8112d6b8:	d9002017 	ldw	r4,128(sp)
8112d6bc:	d9801a04 	addi	r6,sp,104
8112d6c0:	da402c15 	stw	r9,176(sp)
8112d6c4:	112c2c40 	call	8112c2c4 <__sprint_r.part.0>
8112d6c8:	da402c17 	ldw	r9,176(sp)
8112d6cc:	103e9a1e 	bne	r2,zero,8112d138 <__reset+0xfb10d138>
8112d6d0:	d9401b17 	ldw	r5,108(sp)
8112d6d4:	d8801c17 	ldw	r2,112(sp)
8112d6d8:	d811883a 	mov	r8,sp
8112d6dc:	29000044 	addi	r4,r5,1
8112d6e0:	003e4206 	br	8112cfec <__reset+0xfb10cfec>
8112d6e4:	d9401b17 	ldw	r5,108(sp)
8112d6e8:	01204574 	movhi	r4,33045
8112d6ec:	212e9d04 	addi	r4,r4,-17804
8112d6f0:	d9002415 	stw	r4,144(sp)
8112d6f4:	29400044 	addi	r5,r5,1
8112d6f8:	003c6d06 	br	8112c8b0 <__reset+0xfb10c8b0>
8112d6fc:	0039883a 	mov	fp,zero
8112d700:	00800084 	movi	r2,2
8112d704:	10803fcc 	andi	r2,r2,255
8112d708:	01000044 	movi	r4,1
8112d70c:	11001e26 	beq	r2,r4,8112d788 <___vfiprintf_internal_r+0x13a8>
8112d710:	01000084 	movi	r4,2
8112d714:	11001e1e 	bne	r2,r4,8112d790 <___vfiprintf_internal_r+0x13b0>
8112d718:	1829883a 	mov	r20,r3
8112d71c:	003eea06 	br	8112d2c8 <__reset+0xfb10d2c8>
8112d720:	a007883a 	mov	r3,r20
8112d724:	00800044 	movi	r2,1
8112d728:	003ff606 	br	8112d704 <__reset+0xfb10d704>
8112d72c:	00800184 	movi	r2,6
8112d730:	1240012e 	bgeu	r2,r9,8112d738 <___vfiprintf_internal_r+0x1358>
8112d734:	1013883a 	mov	r9,r2
8112d738:	4827883a 	mov	r19,r9
8112d73c:	4825883a 	mov	r18,r9
8112d740:	48001516 	blt	r9,zero,8112d798 <___vfiprintf_internal_r+0x13b8>
8112d744:	05604574 	movhi	r21,33045
8112d748:	d8c02215 	stw	r3,136(sp)
8112d74c:	ad6e0c04 	addi	r21,r21,-18384
8112d750:	003d1406 	br	8112cba4 <__reset+0xfb10cba4>
8112d754:	02a04574 	movhi	r10,33045
8112d758:	52ae9904 	addi	r10,r10,-17820
8112d75c:	da802415 	stw	r10,144(sp)
8112d760:	200d883a 	mov	r6,r4
8112d764:	003c9106 	br	8112c9ac <__reset+0xfb10c9ac>
8112d768:	5021883a 	mov	r16,r10
8112d76c:	0013883a 	mov	r9,zero
8112d770:	003b7d06 	br	8112c568 <__reset+0xfb10c568>
8112d774:	4827883a 	mov	r19,r9
8112d778:	df001d83 	ldbu	fp,118(sp)
8112d77c:	d8c02215 	stw	r3,136(sp)
8112d780:	0013883a 	mov	r9,zero
8112d784:	003c1806 	br	8112c7e8 <__reset+0xfb10c7e8>
8112d788:	1829883a 	mov	r20,r3
8112d78c:	003d1806 	br	8112cbf0 <__reset+0xfb10cbf0>
8112d790:	1829883a 	mov	r20,r3
8112d794:	003ccd06 	br	8112cacc <__reset+0xfb10cacc>
8112d798:	0025883a 	mov	r18,zero
8112d79c:	003fe906 	br	8112d744 <__reset+0xfb10d744>
8112d7a0:	d8802217 	ldw	r2,136(sp)
8112d7a4:	80c00043 	ldbu	r3,1(r16)
8112d7a8:	5021883a 	mov	r16,r10
8112d7ac:	12400017 	ldw	r9,0(r2)
8112d7b0:	10800104 	addi	r2,r2,4
8112d7b4:	d8802215 	stw	r2,136(sp)
8112d7b8:	483faf0e 	bge	r9,zero,8112d678 <__reset+0xfb10d678>
8112d7bc:	18c03fcc 	andi	r3,r3,255
8112d7c0:	18c0201c 	xori	r3,r3,128
8112d7c4:	027fffc4 	movi	r9,-1
8112d7c8:	18ffe004 	addi	r3,r3,-128
8112d7cc:	003b6506 	br	8112c564 <__reset+0xfb10c564>
8112d7d0:	d9c01d85 	stb	r7,118(sp)
8112d7d4:	003ca006 	br	8112ca58 <__reset+0xfb10ca58>
8112d7d8:	d9c01d85 	stb	r7,118(sp)
8112d7dc:	003cad06 	br	8112ca94 <__reset+0xfb10ca94>
8112d7e0:	d9c01d85 	stb	r7,118(sp)
8112d7e4:	003d7d06 	br	8112cddc <__reset+0xfb10cddc>
8112d7e8:	d9c01d85 	stb	r7,118(sp)
8112d7ec:	003d5f06 	br	8112cd6c <__reset+0xfb10cd6c>
8112d7f0:	a080004c 	andi	r2,r20,1
8112d7f4:	0039883a 	mov	fp,zero
8112d7f8:	10000526 	beq	r2,zero,8112d810 <___vfiprintf_internal_r+0x1430>
8112d7fc:	00800c04 	movi	r2,48
8112d800:	d88019c5 	stb	r2,103(sp)
8112d804:	dcc02717 	ldw	r19,156(sp)
8112d808:	dd4019c4 	addi	r21,sp,103
8112d80c:	003bf606 	br	8112c7e8 <__reset+0xfb10c7e8>
8112d810:	0027883a 	mov	r19,zero
8112d814:	dd401a04 	addi	r21,sp,104
8112d818:	003bf306 	br	8112c7e8 <__reset+0xfb10c7e8>
8112d81c:	d9c01d85 	stb	r7,118(sp)
8112d820:	003dc806 	br	8112cf44 <__reset+0xfb10cf44>
8112d824:	d9c01d85 	stb	r7,118(sp)
8112d828:	003d3a06 	br	8112cd14 <__reset+0xfb10cd14>
8112d82c:	d9c01d85 	stb	r7,118(sp)
8112d830:	003d2a06 	br	8112ccdc <__reset+0xfb10ccdc>
8112d834:	d9c01d85 	stb	r7,118(sp)
8112d838:	003cde06 	br	8112cbb4 <__reset+0xfb10cbb4>
8112d83c:	d9c01d85 	stb	r7,118(sp)
8112d840:	003cbc06 	br	8112cb34 <__reset+0xfb10cb34>

8112d844 <__vfiprintf_internal>:
8112d844:	00a04574 	movhi	r2,33045
8112d848:	10b7d604 	addi	r2,r2,-8360
8112d84c:	300f883a 	mov	r7,r6
8112d850:	280d883a 	mov	r6,r5
8112d854:	200b883a 	mov	r5,r4
8112d858:	11000017 	ldw	r4,0(r2)
8112d85c:	112c3e01 	jmpi	8112c3e0 <___vfiprintf_internal_r>

8112d860 <__sbprintf>:
8112d860:	defee204 	addi	sp,sp,-1144
8112d864:	de00012e 	bgeu	sp,et,8112d86c <__sbprintf+0xc>
8112d868:	003b68fa 	trap	3
8112d86c:	2880030b 	ldhu	r2,12(r5)
8112d870:	2ac01917 	ldw	r11,100(r5)
8112d874:	2a80038b 	ldhu	r10,14(r5)
8112d878:	2a400717 	ldw	r9,28(r5)
8112d87c:	2a000917 	ldw	r8,36(r5)
8112d880:	00c10004 	movi	r3,1024
8112d884:	dc011a15 	stw	r16,1128(sp)
8112d888:	10bfff4c 	andi	r2,r2,65533
8112d88c:	2821883a 	mov	r16,r5
8112d890:	d8cb883a 	add	r5,sp,r3
8112d894:	dc811c15 	stw	r18,1136(sp)
8112d898:	dc411b15 	stw	r17,1132(sp)
8112d89c:	dfc11d15 	stw	ra,1140(sp)
8112d8a0:	2025883a 	mov	r18,r4
8112d8a4:	d881030d 	sth	r2,1036(sp)
8112d8a8:	dac11915 	stw	r11,1124(sp)
8112d8ac:	da81038d 	sth	r10,1038(sp)
8112d8b0:	da410715 	stw	r9,1052(sp)
8112d8b4:	da010915 	stw	r8,1060(sp)
8112d8b8:	dec10015 	stw	sp,1024(sp)
8112d8bc:	dec10415 	stw	sp,1040(sp)
8112d8c0:	d8c10215 	stw	r3,1032(sp)
8112d8c4:	d8c10515 	stw	r3,1044(sp)
8112d8c8:	d8010615 	stw	zero,1048(sp)
8112d8cc:	112c3e00 	call	8112c3e0 <___vfiprintf_internal_r>
8112d8d0:	1023883a 	mov	r17,r2
8112d8d4:	10000416 	blt	r2,zero,8112d8e8 <__sbprintf+0x88>
8112d8d8:	d9410004 	addi	r5,sp,1024
8112d8dc:	9009883a 	mov	r4,r18
8112d8e0:	1125b980 	call	81125b98 <_fflush_r>
8112d8e4:	10000d1e 	bne	r2,zero,8112d91c <__sbprintf+0xbc>
8112d8e8:	d881030b 	ldhu	r2,1036(sp)
8112d8ec:	1080100c 	andi	r2,r2,64
8112d8f0:	10000326 	beq	r2,zero,8112d900 <__sbprintf+0xa0>
8112d8f4:	8080030b 	ldhu	r2,12(r16)
8112d8f8:	10801014 	ori	r2,r2,64
8112d8fc:	8080030d 	sth	r2,12(r16)
8112d900:	8805883a 	mov	r2,r17
8112d904:	dfc11d17 	ldw	ra,1140(sp)
8112d908:	dc811c17 	ldw	r18,1136(sp)
8112d90c:	dc411b17 	ldw	r17,1132(sp)
8112d910:	dc011a17 	ldw	r16,1128(sp)
8112d914:	dec11e04 	addi	sp,sp,1144
8112d918:	f800283a 	ret
8112d91c:	047fffc4 	movi	r17,-1
8112d920:	003ff106 	br	8112d8e8 <__reset+0xfb10d8e8>

8112d924 <_calloc_r>:
8112d924:	298b383a 	mul	r5,r5,r6
8112d928:	defffe04 	addi	sp,sp,-8
8112d92c:	de00012e 	bgeu	sp,et,8112d934 <_calloc_r+0x10>
8112d930:	003b68fa 	trap	3
8112d934:	dfc00115 	stw	ra,4(sp)
8112d938:	dc000015 	stw	r16,0(sp)
8112d93c:	111c9b80 	call	8111c9b8 <_malloc_r>
8112d940:	10002926 	beq	r2,zero,8112d9e8 <_calloc_r+0xc4>
8112d944:	11bfff17 	ldw	r6,-4(r2)
8112d948:	1021883a 	mov	r16,r2
8112d94c:	00bfff04 	movi	r2,-4
8112d950:	308c703a 	and	r6,r6,r2
8112d954:	00c00904 	movi	r3,36
8112d958:	308d883a 	add	r6,r6,r2
8112d95c:	19801636 	bltu	r3,r6,8112d9b8 <_calloc_r+0x94>
8112d960:	008004c4 	movi	r2,19
8112d964:	11800b2e 	bgeu	r2,r6,8112d994 <_calloc_r+0x70>
8112d968:	80000015 	stw	zero,0(r16)
8112d96c:	80000115 	stw	zero,4(r16)
8112d970:	008006c4 	movi	r2,27
8112d974:	11801a2e 	bgeu	r2,r6,8112d9e0 <_calloc_r+0xbc>
8112d978:	80000215 	stw	zero,8(r16)
8112d97c:	80000315 	stw	zero,12(r16)
8112d980:	30c0151e 	bne	r6,r3,8112d9d8 <_calloc_r+0xb4>
8112d984:	80000415 	stw	zero,16(r16)
8112d988:	80800604 	addi	r2,r16,24
8112d98c:	80000515 	stw	zero,20(r16)
8112d990:	00000106 	br	8112d998 <_calloc_r+0x74>
8112d994:	8005883a 	mov	r2,r16
8112d998:	10000015 	stw	zero,0(r2)
8112d99c:	10000115 	stw	zero,4(r2)
8112d9a0:	10000215 	stw	zero,8(r2)
8112d9a4:	8005883a 	mov	r2,r16
8112d9a8:	dfc00117 	ldw	ra,4(sp)
8112d9ac:	dc000017 	ldw	r16,0(sp)
8112d9b0:	dec00204 	addi	sp,sp,8
8112d9b4:	f800283a 	ret
8112d9b8:	000b883a 	mov	r5,zero
8112d9bc:	8009883a 	mov	r4,r16
8112d9c0:	111d31c0 	call	8111d31c <memset>
8112d9c4:	8005883a 	mov	r2,r16
8112d9c8:	dfc00117 	ldw	ra,4(sp)
8112d9cc:	dc000017 	ldw	r16,0(sp)
8112d9d0:	dec00204 	addi	sp,sp,8
8112d9d4:	f800283a 	ret
8112d9d8:	80800404 	addi	r2,r16,16
8112d9dc:	003fee06 	br	8112d998 <__reset+0xfb10d998>
8112d9e0:	80800204 	addi	r2,r16,8
8112d9e4:	003fec06 	br	8112d998 <__reset+0xfb10d998>
8112d9e8:	0005883a 	mov	r2,zero
8112d9ec:	003fee06 	br	8112d9a8 <__reset+0xfb10d9a8>

8112d9f0 <_fclose_r>:
8112d9f0:	28003b26 	beq	r5,zero,8112dae0 <_fclose_r+0xf0>
8112d9f4:	defffc04 	addi	sp,sp,-16
8112d9f8:	de00012e 	bgeu	sp,et,8112da00 <_fclose_r+0x10>
8112d9fc:	003b68fa 	trap	3
8112da00:	dc400115 	stw	r17,4(sp)
8112da04:	dc000015 	stw	r16,0(sp)
8112da08:	dfc00315 	stw	ra,12(sp)
8112da0c:	dc800215 	stw	r18,8(sp)
8112da10:	2023883a 	mov	r17,r4
8112da14:	2821883a 	mov	r16,r5
8112da18:	20000226 	beq	r4,zero,8112da24 <_fclose_r+0x34>
8112da1c:	20800e17 	ldw	r2,56(r4)
8112da20:	10002726 	beq	r2,zero,8112dac0 <_fclose_r+0xd0>
8112da24:	8080030f 	ldh	r2,12(r16)
8112da28:	1000071e 	bne	r2,zero,8112da48 <_fclose_r+0x58>
8112da2c:	0005883a 	mov	r2,zero
8112da30:	dfc00317 	ldw	ra,12(sp)
8112da34:	dc800217 	ldw	r18,8(sp)
8112da38:	dc400117 	ldw	r17,4(sp)
8112da3c:	dc000017 	ldw	r16,0(sp)
8112da40:	dec00404 	addi	sp,sp,16
8112da44:	f800283a 	ret
8112da48:	800b883a 	mov	r5,r16
8112da4c:	8809883a 	mov	r4,r17
8112da50:	11259740 	call	81125974 <__sflush_r>
8112da54:	1025883a 	mov	r18,r2
8112da58:	80800b17 	ldw	r2,44(r16)
8112da5c:	10000426 	beq	r2,zero,8112da70 <_fclose_r+0x80>
8112da60:	81400717 	ldw	r5,28(r16)
8112da64:	8809883a 	mov	r4,r17
8112da68:	103ee83a 	callr	r2
8112da6c:	10001616 	blt	r2,zero,8112dac8 <_fclose_r+0xd8>
8112da70:	8080030b 	ldhu	r2,12(r16)
8112da74:	1080200c 	andi	r2,r2,128
8112da78:	1000151e 	bne	r2,zero,8112dad0 <_fclose_r+0xe0>
8112da7c:	81400c17 	ldw	r5,48(r16)
8112da80:	28000526 	beq	r5,zero,8112da98 <_fclose_r+0xa8>
8112da84:	80801004 	addi	r2,r16,64
8112da88:	28800226 	beq	r5,r2,8112da94 <_fclose_r+0xa4>
8112da8c:	8809883a 	mov	r4,r17
8112da90:	112642c0 	call	8112642c <_free_r>
8112da94:	80000c15 	stw	zero,48(r16)
8112da98:	81401117 	ldw	r5,68(r16)
8112da9c:	28000326 	beq	r5,zero,8112daac <_fclose_r+0xbc>
8112daa0:	8809883a 	mov	r4,r17
8112daa4:	112642c0 	call	8112642c <_free_r>
8112daa8:	80001115 	stw	zero,68(r16)
8112daac:	1125fa40 	call	81125fa4 <__sfp_lock_acquire>
8112dab0:	8000030d 	sth	zero,12(r16)
8112dab4:	1125fa80 	call	81125fa8 <__sfp_lock_release>
8112dab8:	9005883a 	mov	r2,r18
8112dabc:	003fdc06 	br	8112da30 <__reset+0xfb10da30>
8112dac0:	1125f940 	call	81125f94 <__sinit>
8112dac4:	003fd706 	br	8112da24 <__reset+0xfb10da24>
8112dac8:	04bfffc4 	movi	r18,-1
8112dacc:	003fe806 	br	8112da70 <__reset+0xfb10da70>
8112dad0:	81400417 	ldw	r5,16(r16)
8112dad4:	8809883a 	mov	r4,r17
8112dad8:	112642c0 	call	8112642c <_free_r>
8112dadc:	003fe706 	br	8112da7c <__reset+0xfb10da7c>
8112dae0:	0005883a 	mov	r2,zero
8112dae4:	f800283a 	ret

8112dae8 <fclose>:
8112dae8:	00a04574 	movhi	r2,33045
8112daec:	10b7d604 	addi	r2,r2,-8360
8112daf0:	200b883a 	mov	r5,r4
8112daf4:	11000017 	ldw	r4,0(r2)
8112daf8:	112d9f01 	jmpi	8112d9f0 <_fclose_r>

8112dafc <__fputwc>:
8112dafc:	defff804 	addi	sp,sp,-32
8112db00:	de00012e 	bgeu	sp,et,8112db08 <__fputwc+0xc>
8112db04:	003b68fa 	trap	3
8112db08:	dcc00415 	stw	r19,16(sp)
8112db0c:	dc800315 	stw	r18,12(sp)
8112db10:	dc000115 	stw	r16,4(sp)
8112db14:	dfc00715 	stw	ra,28(sp)
8112db18:	dd400615 	stw	r21,24(sp)
8112db1c:	dd000515 	stw	r20,20(sp)
8112db20:	dc400215 	stw	r17,8(sp)
8112db24:	2027883a 	mov	r19,r4
8112db28:	2825883a 	mov	r18,r5
8112db2c:	3021883a 	mov	r16,r6
8112db30:	1126ebc0 	call	81126ebc <__locale_mb_cur_max>
8112db34:	00c00044 	movi	r3,1
8112db38:	10c03e26 	beq	r2,r3,8112dc34 <__fputwc+0x138>
8112db3c:	81c01704 	addi	r7,r16,92
8112db40:	900d883a 	mov	r6,r18
8112db44:	d80b883a 	mov	r5,sp
8112db48:	9809883a 	mov	r4,r19
8112db4c:	112e9800 	call	8112e980 <_wcrtomb_r>
8112db50:	1029883a 	mov	r20,r2
8112db54:	00bfffc4 	movi	r2,-1
8112db58:	a0802026 	beq	r20,r2,8112dbdc <__fputwc+0xe0>
8112db5c:	d9400003 	ldbu	r5,0(sp)
8112db60:	a0001c26 	beq	r20,zero,8112dbd4 <__fputwc+0xd8>
8112db64:	0023883a 	mov	r17,zero
8112db68:	05400284 	movi	r21,10
8112db6c:	00000906 	br	8112db94 <__fputwc+0x98>
8112db70:	80800017 	ldw	r2,0(r16)
8112db74:	11400005 	stb	r5,0(r2)
8112db78:	80c00017 	ldw	r3,0(r16)
8112db7c:	18c00044 	addi	r3,r3,1
8112db80:	80c00015 	stw	r3,0(r16)
8112db84:	8c400044 	addi	r17,r17,1
8112db88:	dc45883a 	add	r2,sp,r17
8112db8c:	8d00112e 	bgeu	r17,r20,8112dbd4 <__fputwc+0xd8>
8112db90:	11400003 	ldbu	r5,0(r2)
8112db94:	80c00217 	ldw	r3,8(r16)
8112db98:	18ffffc4 	addi	r3,r3,-1
8112db9c:	80c00215 	stw	r3,8(r16)
8112dba0:	183ff30e 	bge	r3,zero,8112db70 <__reset+0xfb10db70>
8112dba4:	80800617 	ldw	r2,24(r16)
8112dba8:	18801916 	blt	r3,r2,8112dc10 <__fputwc+0x114>
8112dbac:	80800017 	ldw	r2,0(r16)
8112dbb0:	11400005 	stb	r5,0(r2)
8112dbb4:	80800017 	ldw	r2,0(r16)
8112dbb8:	10c00003 	ldbu	r3,0(r2)
8112dbbc:	10800044 	addi	r2,r2,1
8112dbc0:	1d402326 	beq	r3,r21,8112dc50 <__fputwc+0x154>
8112dbc4:	80800015 	stw	r2,0(r16)
8112dbc8:	8c400044 	addi	r17,r17,1
8112dbcc:	dc45883a 	add	r2,sp,r17
8112dbd0:	8d3fef36 	bltu	r17,r20,8112db90 <__reset+0xfb10db90>
8112dbd4:	9005883a 	mov	r2,r18
8112dbd8:	00000406 	br	8112dbec <__fputwc+0xf0>
8112dbdc:	80c0030b 	ldhu	r3,12(r16)
8112dbe0:	a005883a 	mov	r2,r20
8112dbe4:	18c01014 	ori	r3,r3,64
8112dbe8:	80c0030d 	sth	r3,12(r16)
8112dbec:	dfc00717 	ldw	ra,28(sp)
8112dbf0:	dd400617 	ldw	r21,24(sp)
8112dbf4:	dd000517 	ldw	r20,20(sp)
8112dbf8:	dcc00417 	ldw	r19,16(sp)
8112dbfc:	dc800317 	ldw	r18,12(sp)
8112dc00:	dc400217 	ldw	r17,8(sp)
8112dc04:	dc000117 	ldw	r16,4(sp)
8112dc08:	dec00804 	addi	sp,sp,32
8112dc0c:	f800283a 	ret
8112dc10:	800d883a 	mov	r6,r16
8112dc14:	29403fcc 	andi	r5,r5,255
8112dc18:	9809883a 	mov	r4,r19
8112dc1c:	1123d5c0 	call	81123d5c <__swbuf_r>
8112dc20:	10bfffe0 	cmpeqi	r2,r2,-1
8112dc24:	10803fcc 	andi	r2,r2,255
8112dc28:	103fd626 	beq	r2,zero,8112db84 <__reset+0xfb10db84>
8112dc2c:	00bfffc4 	movi	r2,-1
8112dc30:	003fee06 	br	8112dbec <__reset+0xfb10dbec>
8112dc34:	90ffffc4 	addi	r3,r18,-1
8112dc38:	01003f84 	movi	r4,254
8112dc3c:	20ffbf36 	bltu	r4,r3,8112db3c <__reset+0xfb10db3c>
8112dc40:	900b883a 	mov	r5,r18
8112dc44:	dc800005 	stb	r18,0(sp)
8112dc48:	1029883a 	mov	r20,r2
8112dc4c:	003fc506 	br	8112db64 <__reset+0xfb10db64>
8112dc50:	800d883a 	mov	r6,r16
8112dc54:	a80b883a 	mov	r5,r21
8112dc58:	9809883a 	mov	r4,r19
8112dc5c:	1123d5c0 	call	81123d5c <__swbuf_r>
8112dc60:	10bfffe0 	cmpeqi	r2,r2,-1
8112dc64:	003fef06 	br	8112dc24 <__reset+0xfb10dc24>

8112dc68 <_fputwc_r>:
8112dc68:	3080030b 	ldhu	r2,12(r6)
8112dc6c:	10c8000c 	andi	r3,r2,8192
8112dc70:	1800051e 	bne	r3,zero,8112dc88 <_fputwc_r+0x20>
8112dc74:	30c01917 	ldw	r3,100(r6)
8112dc78:	10880014 	ori	r2,r2,8192
8112dc7c:	3080030d 	sth	r2,12(r6)
8112dc80:	18880014 	ori	r2,r3,8192
8112dc84:	30801915 	stw	r2,100(r6)
8112dc88:	112dafc1 	jmpi	8112dafc <__fputwc>

8112dc8c <fputwc>:
8112dc8c:	00a04574 	movhi	r2,33045
8112dc90:	defffc04 	addi	sp,sp,-16
8112dc94:	10b7d604 	addi	r2,r2,-8360
8112dc98:	de00012e 	bgeu	sp,et,8112dca0 <fputwc+0x14>
8112dc9c:	003b68fa 	trap	3
8112dca0:	dc000115 	stw	r16,4(sp)
8112dca4:	14000017 	ldw	r16,0(r2)
8112dca8:	dc400215 	stw	r17,8(sp)
8112dcac:	dfc00315 	stw	ra,12(sp)
8112dcb0:	2023883a 	mov	r17,r4
8112dcb4:	80000226 	beq	r16,zero,8112dcc0 <fputwc+0x34>
8112dcb8:	80800e17 	ldw	r2,56(r16)
8112dcbc:	10001026 	beq	r2,zero,8112dd00 <fputwc+0x74>
8112dcc0:	2880030b 	ldhu	r2,12(r5)
8112dcc4:	10c8000c 	andi	r3,r2,8192
8112dcc8:	1800051e 	bne	r3,zero,8112dce0 <fputwc+0x54>
8112dccc:	28c01917 	ldw	r3,100(r5)
8112dcd0:	10880014 	ori	r2,r2,8192
8112dcd4:	2880030d 	sth	r2,12(r5)
8112dcd8:	18880014 	ori	r2,r3,8192
8112dcdc:	28801915 	stw	r2,100(r5)
8112dce0:	280d883a 	mov	r6,r5
8112dce4:	8009883a 	mov	r4,r16
8112dce8:	880b883a 	mov	r5,r17
8112dcec:	dfc00317 	ldw	ra,12(sp)
8112dcf0:	dc400217 	ldw	r17,8(sp)
8112dcf4:	dc000117 	ldw	r16,4(sp)
8112dcf8:	dec00404 	addi	sp,sp,16
8112dcfc:	112dafc1 	jmpi	8112dafc <__fputwc>
8112dd00:	8009883a 	mov	r4,r16
8112dd04:	d9400015 	stw	r5,0(sp)
8112dd08:	1125f940 	call	81125f94 <__sinit>
8112dd0c:	d9400017 	ldw	r5,0(sp)
8112dd10:	003feb06 	br	8112dcc0 <__reset+0xfb10dcc0>

8112dd14 <rshift>:
8112dd14:	2807d17a 	srai	r3,r5,5
8112dd18:	20800417 	ldw	r2,16(r4)
8112dd1c:	22000504 	addi	r8,r4,20
8112dd20:	1880250e 	bge	r3,r2,8112ddb8 <rshift+0xa4>
8112dd24:	1085883a 	add	r2,r2,r2
8112dd28:	18c7883a 	add	r3,r3,r3
8112dd2c:	1085883a 	add	r2,r2,r2
8112dd30:	18c7883a 	add	r3,r3,r3
8112dd34:	294007cc 	andi	r5,r5,31
8112dd38:	4085883a 	add	r2,r8,r2
8112dd3c:	40c7883a 	add	r3,r8,r3
8112dd40:	28002026 	beq	r5,zero,8112ddc4 <rshift+0xb0>
8112dd44:	19800017 	ldw	r6,0(r3)
8112dd48:	02c00804 	movi	r11,32
8112dd4c:	19c00104 	addi	r7,r3,4
8112dd50:	5957c83a 	sub	r11,r11,r5
8112dd54:	314cd83a 	srl	r6,r6,r5
8112dd58:	38802c2e 	bgeu	r7,r2,8112de0c <rshift+0xf8>
8112dd5c:	4015883a 	mov	r10,r8
8112dd60:	3a400017 	ldw	r9,0(r7)
8112dd64:	52800104 	addi	r10,r10,4
8112dd68:	39c00104 	addi	r7,r7,4
8112dd6c:	4ad2983a 	sll	r9,r9,r11
8112dd70:	498cb03a 	or	r6,r9,r6
8112dd74:	51bfff15 	stw	r6,-4(r10)
8112dd78:	39bfff17 	ldw	r6,-4(r7)
8112dd7c:	314cd83a 	srl	r6,r6,r5
8112dd80:	38bff736 	bltu	r7,r2,8112dd60 <__reset+0xfb10dd60>
8112dd84:	10c7c83a 	sub	r3,r2,r3
8112dd88:	18fffec4 	addi	r3,r3,-5
8112dd8c:	1806d0ba 	srli	r3,r3,2
8112dd90:	18c00044 	addi	r3,r3,1
8112dd94:	18c7883a 	add	r3,r3,r3
8112dd98:	18c7883a 	add	r3,r3,r3
8112dd9c:	40c7883a 	add	r3,r8,r3
8112dda0:	19800015 	stw	r6,0(r3)
8112dda4:	30000126 	beq	r6,zero,8112ddac <rshift+0x98>
8112dda8:	18c00104 	addi	r3,r3,4
8112ddac:	1a05c83a 	sub	r2,r3,r8
8112ddb0:	1005d0ba 	srai	r2,r2,2
8112ddb4:	00001206 	br	8112de00 <rshift+0xec>
8112ddb8:	20000415 	stw	zero,16(r4)
8112ddbc:	20000515 	stw	zero,20(r4)
8112ddc0:	f800283a 	ret
8112ddc4:	18bffc2e 	bgeu	r3,r2,8112ddb8 <__reset+0xfb10ddb8>
8112ddc8:	180d883a 	mov	r6,r3
8112ddcc:	400b883a 	mov	r5,r8
8112ddd0:	31c00017 	ldw	r7,0(r6)
8112ddd4:	29400104 	addi	r5,r5,4
8112ddd8:	31800104 	addi	r6,r6,4
8112dddc:	29ffff15 	stw	r7,-4(r5)
8112dde0:	30bffb36 	bltu	r6,r2,8112ddd0 <__reset+0xfb10ddd0>
8112dde4:	00c6303a 	nor	r3,zero,r3
8112dde8:	1885883a 	add	r2,r3,r2
8112ddec:	1004d0ba 	srli	r2,r2,2
8112ddf0:	10800044 	addi	r2,r2,1
8112ddf4:	1085883a 	add	r2,r2,r2
8112ddf8:	1085883a 	add	r2,r2,r2
8112ddfc:	1005d0ba 	srai	r2,r2,2
8112de00:	20800415 	stw	r2,16(r4)
8112de04:	103fed26 	beq	r2,zero,8112ddbc <__reset+0xfb10ddbc>
8112de08:	f800283a 	ret
8112de0c:	4007883a 	mov	r3,r8
8112de10:	003fe306 	br	8112dda0 <__reset+0xfb10dda0>

8112de14 <__gethex>:
8112de14:	deffeb04 	addi	sp,sp,-84
8112de18:	de00012e 	bgeu	sp,et,8112de20 <__gethex+0xc>
8112de1c:	003b68fa 	trap	3
8112de20:	dfc01415 	stw	ra,80(sp)
8112de24:	dd801115 	stw	r22,68(sp)
8112de28:	dcc00e15 	stw	r19,56(sp)
8112de2c:	dc800d15 	stw	r18,52(sp)
8112de30:	2827883a 	mov	r19,r5
8112de34:	d9000115 	stw	r4,4(sp)
8112de38:	d9800015 	stw	r6,0(sp)
8112de3c:	d9c00415 	stw	r7,16(sp)
8112de40:	df001315 	stw	fp,76(sp)
8112de44:	ddc01215 	stw	r23,72(sp)
8112de48:	dd401015 	stw	r21,64(sp)
8112de4c:	dd000f15 	stw	r20,60(sp)
8112de50:	dc400c15 	stw	r17,48(sp)
8112de54:	dc000b15 	stw	r16,44(sp)
8112de58:	1126ee00 	call	81126ee0 <_localeconv_r>
8112de5c:	14800017 	ldw	r18,0(r2)
8112de60:	9009883a 	mov	r4,r18
8112de64:	111dcc00 	call	8111dcc0 <strlen>
8112de68:	98c00017 	ldw	r3,0(r19)
8112de6c:	102d883a 	mov	r22,r2
8112de70:	9085883a 	add	r2,r18,r2
8112de74:	10bfffc3 	ldbu	r2,-1(r2)
8112de78:	19000083 	ldbu	r4,2(r3)
8112de7c:	d8800305 	stb	r2,12(sp)
8112de80:	00800c04 	movi	r2,48
8112de84:	2081521e 	bne	r4,r2,8112e3d0 <__gethex+0x5bc>
8112de88:	017fff84 	movi	r5,-2
8112de8c:	188000c4 	addi	r2,r3,3
8112de90:	28cbc83a 	sub	r5,r5,r3
8112de94:	200d883a 	mov	r6,r4
8112de98:	28a3883a 	add	r17,r5,r2
8112de9c:	102b883a 	mov	r21,r2
8112dea0:	10800044 	addi	r2,r2,1
8112dea4:	113fffc3 	ldbu	r4,-1(r2)
8112dea8:	21bffb26 	beq	r4,r6,8112de98 <__reset+0xfb10de98>
8112deac:	05204574 	movhi	r20,33045
8112deb0:	a52ea104 	addi	r20,r20,-17788
8112deb4:	a109883a 	add	r4,r20,r4
8112deb8:	20800003 	ldbu	r2,0(r4)
8112debc:	10008826 	beq	r2,zero,8112e0e0 <__gethex+0x2cc>
8112dec0:	a8800003 	ldbu	r2,0(r21)
8112dec4:	0015883a 	mov	r10,zero
8112dec8:	002f883a 	mov	r23,zero
8112decc:	a085883a 	add	r2,r20,r2
8112ded0:	10800003 	ldbu	r2,0(r2)
8112ded4:	a821883a 	mov	r16,r21
8112ded8:	10000526 	beq	r2,zero,8112def0 <__gethex+0xdc>
8112dedc:	84000044 	addi	r16,r16,1
8112dee0:	80800003 	ldbu	r2,0(r16)
8112dee4:	a085883a 	add	r2,r20,r2
8112dee8:	10800003 	ldbu	r2,0(r2)
8112deec:	103ffb1e 	bne	r2,zero,8112dedc <__reset+0xfb10dedc>
8112def0:	b00d883a 	mov	r6,r22
8112def4:	900b883a 	mov	r5,r18
8112def8:	8009883a 	mov	r4,r16
8112defc:	da800a15 	stw	r10,40(sp)
8112df00:	112e8b00 	call	8112e8b0 <strncmp>
8112df04:	da800a17 	ldw	r10,40(sp)
8112df08:	1000031e 	bne	r2,zero,8112df18 <__gethex+0x104>
8112df0c:	b8015226 	beq	r23,zero,8112e458 <__gethex+0x644>
8112df10:	80800003 	ldbu	r2,0(r16)
8112df14:	00000206 	br	8112df20 <__gethex+0x10c>
8112df18:	80800003 	ldbu	r2,0(r16)
8112df1c:	b8011f26 	beq	r23,zero,8112e39c <__gethex+0x588>
8112df20:	85efc83a 	sub	r23,r16,r23
8112df24:	bdef883a 	add	r23,r23,r23
8112df28:	bdef883a 	add	r23,r23,r23
8112df2c:	05efc83a 	sub	r23,zero,r23
8112df30:	10803fcc 	andi	r2,r2,255
8112df34:	01001404 	movi	r4,80
8112df38:	11008626 	beq	r2,r4,8112e154 <__gethex+0x340>
8112df3c:	01001c04 	movi	r4,112
8112df40:	11008426 	beq	r2,r4,8112e154 <__gethex+0x340>
8112df44:	8039883a 	mov	fp,r16
8112df48:	9c000015 	stw	r16,0(r19)
8112df4c:	5000711e 	bne	r10,zero,8112e114 <__gethex+0x300>
8112df50:	e545c83a 	sub	r2,fp,r21
8112df54:	10bfffc4 	addi	r2,r2,-1
8112df58:	010001c4 	movi	r4,7
8112df5c:	000b883a 	mov	r5,zero
8112df60:	2080030e 	bge	r4,r2,8112df70 <__gethex+0x15c>
8112df64:	1005d07a 	srai	r2,r2,1
8112df68:	29400044 	addi	r5,r5,1
8112df6c:	20bffd16 	blt	r4,r2,8112df64 <__reset+0xfb10df64>
8112df70:	d9000117 	ldw	r4,4(sp)
8112df74:	11273fc0 	call	811273fc <_Balloc>
8112df78:	10c00504 	addi	r3,r2,20
8112df7c:	d8c00215 	stw	r3,8(sp)
8112df80:	1021883a 	mov	r16,r2
8112df84:	af01732e 	bgeu	r21,fp,8112e554 <__gethex+0x740>
8112df88:	dc400303 	ldbu	r17,12(sp)
8112df8c:	03400044 	movi	r13,1
8112df90:	1815883a 	mov	r10,r3
8112df94:	0013883a 	mov	r9,zero
8112df98:	0027883a 	mov	r19,zero
8112df9c:	6d9bc83a 	sub	r13,r13,r22
8112dfa0:	02c00804 	movi	r11,32
8112dfa4:	e0bfffc3 	ldbu	r2,-1(fp)
8112dfa8:	e3bfffc4 	addi	r14,fp,-1
8112dfac:	88803026 	beq	r17,r2,8112e070 <__gethex+0x25c>
8112dfb0:	9ac04526 	beq	r19,r11,8112e0c8 <__gethex+0x2b4>
8112dfb4:	980b883a 	mov	r5,r19
8112dfb8:	9cc00104 	addi	r19,r19,4
8112dfbc:	e13fffc3 	ldbu	r4,-1(fp)
8112dfc0:	7039883a 	mov	fp,r14
8112dfc4:	a109883a 	add	r4,r20,r4
8112dfc8:	20800003 	ldbu	r2,0(r4)
8112dfcc:	108003cc 	andi	r2,r2,15
8112dfd0:	1144983a 	sll	r2,r2,r5
8112dfd4:	4892b03a 	or	r9,r9,r2
8112dfd8:	af3ff236 	bltu	r21,fp,8112dfa4 <__reset+0xfb10dfa4>
8112dfdc:	d8c00217 	ldw	r3,8(sp)
8112dfe0:	50800104 	addi	r2,r10,4
8112dfe4:	52400015 	stw	r9,0(r10)
8112dfe8:	10c5c83a 	sub	r2,r2,r3
8112dfec:	1005d0ba 	srai	r2,r2,2
8112dff0:	4809883a 	mov	r4,r9
8112dff4:	80800415 	stw	r2,16(r16)
8112dff8:	1022917a 	slli	r17,r2,5
8112dffc:	11277080 	call	81127708 <__hi0bits>
8112e000:	d8c00017 	ldw	r3,0(sp)
8112e004:	8885c83a 	sub	r2,r17,r2
8112e008:	1c800017 	ldw	r18,0(r3)
8112e00c:	9080c716 	blt	r18,r2,8112e32c <__gethex+0x518>
8112e010:	1480e416 	blt	r2,r18,8112e3a4 <__gethex+0x590>
8112e014:	0027883a 	mov	r19,zero
8112e018:	d8c00017 	ldw	r3,0(sp)
8112e01c:	18800217 	ldw	r2,8(r3)
8112e020:	15c08d16 	blt	r2,r23,8112e258 <__gethex+0x444>
8112e024:	d8c00017 	ldw	r3,0(sp)
8112e028:	18800117 	ldw	r2,4(r3)
8112e02c:	b880aa0e 	bge	r23,r2,8112e2d8 <__gethex+0x4c4>
8112e030:	15efc83a 	sub	r23,r2,r23
8112e034:	bc80ed16 	blt	r23,r18,8112e3ec <__gethex+0x5d8>
8112e038:	18c00317 	ldw	r3,12(r3)
8112e03c:	01000084 	movi	r4,2
8112e040:	19014926 	beq	r3,r4,8112e568 <__gethex+0x754>
8112e044:	010000c4 	movi	r4,3
8112e048:	19012e26 	beq	r3,r4,8112e504 <__gethex+0x6f0>
8112e04c:	01000044 	movi	r4,1
8112e050:	19014826 	beq	r3,r4,8112e574 <__gethex+0x760>
8112e054:	d9000117 	ldw	r4,4(sp)
8112e058:	800b883a 	mov	r5,r16
8112e05c:	11274ac0 	call	811274ac <_Bfree>
8112e060:	d8801517 	ldw	r2,84(sp)
8112e064:	10000015 	stw	zero,0(r2)
8112e068:	00801404 	movi	r2,80
8112e06c:	00002b06 	br	8112e11c <__gethex+0x308>
8112e070:	735f883a 	add	r15,r14,r13
8112e074:	7d7fce36 	bltu	r15,r21,8112dfb0 <__reset+0xfb10dfb0>
8112e078:	7809883a 	mov	r4,r15
8112e07c:	b00d883a 	mov	r6,r22
8112e080:	900b883a 	mov	r5,r18
8112e084:	da400515 	stw	r9,20(sp)
8112e088:	da800a15 	stw	r10,40(sp)
8112e08c:	dac00915 	stw	r11,36(sp)
8112e090:	db400815 	stw	r13,32(sp)
8112e094:	db800615 	stw	r14,24(sp)
8112e098:	dbc00715 	stw	r15,28(sp)
8112e09c:	112e8b00 	call	8112e8b0 <strncmp>
8112e0a0:	da400517 	ldw	r9,20(sp)
8112e0a4:	da800a17 	ldw	r10,40(sp)
8112e0a8:	dac00917 	ldw	r11,36(sp)
8112e0ac:	db400817 	ldw	r13,32(sp)
8112e0b0:	db800617 	ldw	r14,24(sp)
8112e0b4:	dbc00717 	ldw	r15,28(sp)
8112e0b8:	103fbd1e 	bne	r2,zero,8112dfb0 <__reset+0xfb10dfb0>
8112e0bc:	7839883a 	mov	fp,r15
8112e0c0:	af3fb836 	bltu	r21,fp,8112dfa4 <__reset+0xfb10dfa4>
8112e0c4:	003fc506 	br	8112dfdc <__reset+0xfb10dfdc>
8112e0c8:	04c00104 	movi	r19,4
8112e0cc:	52400015 	stw	r9,0(r10)
8112e0d0:	000b883a 	mov	r5,zero
8112e0d4:	54d5883a 	add	r10,r10,r19
8112e0d8:	0013883a 	mov	r9,zero
8112e0dc:	003fb706 	br	8112dfbc <__reset+0xfb10dfbc>
8112e0e0:	b00d883a 	mov	r6,r22
8112e0e4:	900b883a 	mov	r5,r18
8112e0e8:	a809883a 	mov	r4,r21
8112e0ec:	112e8b00 	call	8112e8b0 <strncmp>
8112e0f0:	10006426 	beq	r2,zero,8112e284 <__gethex+0x470>
8112e0f4:	a8800003 	ldbu	r2,0(r21)
8112e0f8:	a821883a 	mov	r16,r21
8112e0fc:	10803fcc 	andi	r2,r2,255
8112e100:	01001404 	movi	r4,80
8112e104:	11001126 	beq	r2,r4,8112e14c <__gethex+0x338>
8112e108:	01001c04 	movi	r4,112
8112e10c:	11000f26 	beq	r2,r4,8112e14c <__gethex+0x338>
8112e110:	9c000015 	stw	r16,0(r19)
8112e114:	8800831e 	bne	r17,zero,8112e324 <__gethex+0x510>
8112e118:	00800184 	movi	r2,6
8112e11c:	dfc01417 	ldw	ra,80(sp)
8112e120:	df001317 	ldw	fp,76(sp)
8112e124:	ddc01217 	ldw	r23,72(sp)
8112e128:	dd801117 	ldw	r22,68(sp)
8112e12c:	dd401017 	ldw	r21,64(sp)
8112e130:	dd000f17 	ldw	r20,60(sp)
8112e134:	dcc00e17 	ldw	r19,56(sp)
8112e138:	dc800d17 	ldw	r18,52(sp)
8112e13c:	dc400c17 	ldw	r17,48(sp)
8112e140:	dc000b17 	ldw	r16,44(sp)
8112e144:	dec01504 	addi	sp,sp,84
8112e148:	f800283a 	ret
8112e14c:	002f883a 	mov	r23,zero
8112e150:	02800044 	movi	r10,1
8112e154:	80800043 	ldbu	r2,1(r16)
8112e158:	01400ac4 	movi	r5,43
8112e15c:	11003fcc 	andi	r4,r2,255
8112e160:	21406e26 	beq	r4,r5,8112e31c <__gethex+0x508>
8112e164:	01400b44 	movi	r5,45
8112e168:	21404226 	beq	r4,r5,8112e274 <__gethex+0x460>
8112e16c:	81400044 	addi	r5,r16,1
8112e170:	000d883a 	mov	r6,zero
8112e174:	10803fcc 	andi	r2,r2,255
8112e178:	a085883a 	add	r2,r20,r2
8112e17c:	11000003 	ldbu	r4,0(r2)
8112e180:	03000604 	movi	r12,24
8112e184:	20bfffc4 	addi	r2,r4,-1
8112e188:	10803fcc 	andi	r2,r2,255
8112e18c:	60bf6d36 	bltu	r12,r2,8112df44 <__reset+0xfb10df44>
8112e190:	2ac00043 	ldbu	r11,1(r5)
8112e194:	20803fcc 	andi	r2,r4,255
8112e198:	01204574 	movhi	r4,33045
8112e19c:	212ea104 	addi	r4,r4,-17788
8112e1a0:	22c9883a 	add	r4,r4,r11
8112e1a4:	23400003 	ldbu	r13,0(r4)
8112e1a8:	10bffc04 	addi	r2,r2,-16
8112e1ac:	29400044 	addi	r5,r5,1
8112e1b0:	693fffc4 	addi	r4,r13,-1
8112e1b4:	21003fcc 	andi	r4,r4,255
8112e1b8:	6b403fcc 	andi	r13,r13,255
8112e1bc:	61000b36 	bltu	r12,r4,8112e1ec <__gethex+0x3d8>
8112e1c0:	29400044 	addi	r5,r5,1
8112e1c4:	29000003 	ldbu	r4,0(r5)
8112e1c8:	108002a4 	muli	r2,r2,10
8112e1cc:	a109883a 	add	r4,r20,r4
8112e1d0:	22c00003 	ldbu	r11,0(r4)
8112e1d4:	1345883a 	add	r2,r2,r13
8112e1d8:	10bffc04 	addi	r2,r2,-16
8112e1dc:	593fffc4 	addi	r4,r11,-1
8112e1e0:	21003fcc 	andi	r4,r4,255
8112e1e4:	5b403fcc 	andi	r13,r11,255
8112e1e8:	613ff52e 	bgeu	r12,r4,8112e1c0 <__reset+0xfb10e1c0>
8112e1ec:	30000126 	beq	r6,zero,8112e1f4 <__gethex+0x3e0>
8112e1f0:	0085c83a 	sub	r2,zero,r2
8112e1f4:	8039883a 	mov	fp,r16
8112e1f8:	b8af883a 	add	r23,r23,r2
8112e1fc:	2821883a 	mov	r16,r5
8112e200:	003f5106 	br	8112df48 <__reset+0xfb10df48>
8112e204:	80800217 	ldw	r2,8(r16)
8112e208:	e080f00e 	bge	fp,r2,8112e5cc <__gethex+0x7b8>
8112e20c:	e007883a 	mov	r3,fp
8112e210:	18800144 	addi	r2,r3,5
8112e214:	1085883a 	add	r2,r2,r2
8112e218:	18c00044 	addi	r3,r3,1
8112e21c:	1085883a 	add	r2,r2,r2
8112e220:	8085883a 	add	r2,r16,r2
8112e224:	80c00415 	stw	r3,16(r16)
8112e228:	01000044 	movi	r4,1
8112e22c:	11000015 	stw	r4,0(r2)
8112e230:	00800084 	movi	r2,2
8112e234:	8880d826 	beq	r17,r2,8112e598 <__gethex+0x784>
8112e238:	e0c0ac0e 	bge	fp,r3,8112e4ec <__gethex+0x6d8>
8112e23c:	01400044 	movi	r5,1
8112e240:	8009883a 	mov	r4,r16
8112e244:	112dd140 	call	8112dd14 <rshift>
8112e248:	d8c00017 	ldw	r3,0(sp)
8112e24c:	bdc00044 	addi	r23,r23,1
8112e250:	18800217 	ldw	r2,8(r3)
8112e254:	15c0a70e 	bge	r2,r23,8112e4f4 <__gethex+0x6e0>
8112e258:	d9000117 	ldw	r4,4(sp)
8112e25c:	800b883a 	mov	r5,r16
8112e260:	11274ac0 	call	811274ac <_Bfree>
8112e264:	d9001517 	ldw	r4,84(sp)
8112e268:	008028c4 	movi	r2,163
8112e26c:	20000015 	stw	zero,0(r4)
8112e270:	003faa06 	br	8112e11c <__reset+0xfb10e11c>
8112e274:	01800044 	movi	r6,1
8112e278:	80800083 	ldbu	r2,2(r16)
8112e27c:	81400084 	addi	r5,r16,2
8112e280:	003fbc06 	br	8112e174 <__reset+0xfb10e174>
8112e284:	ada1883a 	add	r16,r21,r22
8112e288:	81000003 	ldbu	r4,0(r16)
8112e28c:	21403fcc 	andi	r5,r4,255
8112e290:	a145883a 	add	r2,r20,r5
8112e294:	10800003 	ldbu	r2,0(r2)
8112e298:	11803fcc 	andi	r6,r2,255
8112e29c:	30004f26 	beq	r6,zero,8112e3dc <__gethex+0x5c8>
8112e2a0:	00c00c04 	movi	r3,48
8112e2a4:	802b883a 	mov	r21,r16
8112e2a8:	28c0061e 	bne	r5,r3,8112e2c4 <__gethex+0x4b0>
8112e2ac:	2809883a 	mov	r4,r5
8112e2b0:	ad400044 	addi	r21,r21,1
8112e2b4:	a8800003 	ldbu	r2,0(r21)
8112e2b8:	113ffd26 	beq	r2,r4,8112e2b0 <__reset+0xfb10e2b0>
8112e2bc:	a085883a 	add	r2,r20,r2
8112e2c0:	10800003 	ldbu	r2,0(r2)
8112e2c4:	10803fcc 	andi	r2,r2,255
8112e2c8:	1015003a 	cmpeq	r10,r2,zero
8112e2cc:	802f883a 	mov	r23,r16
8112e2d0:	04400044 	movi	r17,1
8112e2d4:	003eff06 	br	8112ded4 <__reset+0xfb10ded4>
8112e2d8:	04400044 	movi	r17,1
8112e2dc:	98000926 	beq	r19,zero,8112e304 <__gethex+0x4f0>
8112e2e0:	d8c00017 	ldw	r3,0(sp)
8112e2e4:	18800317 	ldw	r2,12(r3)
8112e2e8:	00c00084 	movi	r3,2
8112e2ec:	10c06826 	beq	r2,r3,8112e490 <__gethex+0x67c>
8112e2f0:	00c000c4 	movi	r3,3
8112e2f4:	10c06a26 	beq	r2,r3,8112e4a0 <__gethex+0x68c>
8112e2f8:	00c00044 	movi	r3,1
8112e2fc:	10c08d26 	beq	r2,r3,8112e534 <__gethex+0x720>
8112e300:	8c400414 	ori	r17,r17,16
8112e304:	d9001517 	ldw	r4,84(sp)
8112e308:	d8c00417 	ldw	r3,16(sp)
8112e30c:	8805883a 	mov	r2,r17
8112e310:	24000015 	stw	r16,0(r4)
8112e314:	1dc00015 	stw	r23,0(r3)
8112e318:	003f8006 	br	8112e11c <__reset+0xfb10e11c>
8112e31c:	000d883a 	mov	r6,zero
8112e320:	003fd506 	br	8112e278 <__reset+0xfb10e278>
8112e324:	0005883a 	mov	r2,zero
8112e328:	003f7c06 	br	8112e11c <__reset+0xfb10e11c>
8112e32c:	14a3c83a 	sub	r17,r2,r18
8112e330:	880b883a 	mov	r5,r17
8112e334:	8009883a 	mov	r4,r16
8112e338:	11283cc0 	call	811283cc <__any_on>
8112e33c:	10002926 	beq	r2,zero,8112e3e4 <__gethex+0x5d0>
8112e340:	897fffc4 	addi	r5,r17,-1
8112e344:	2807d17a 	srai	r3,r5,5
8112e348:	d8800217 	ldw	r2,8(sp)
8112e34c:	290007cc 	andi	r4,r5,31
8112e350:	18c7883a 	add	r3,r3,r3
8112e354:	18c7883a 	add	r3,r3,r3
8112e358:	04c00044 	movi	r19,1
8112e35c:	10c7883a 	add	r3,r2,r3
8112e360:	9908983a 	sll	r4,r19,r4
8112e364:	18c00017 	ldw	r3,0(r3)
8112e368:	20c6703a 	and	r3,r4,r3
8112e36c:	18000626 	beq	r3,zero,8112e388 <__gethex+0x574>
8112e370:	99407b0e 	bge	r19,r5,8112e560 <__gethex+0x74c>
8112e374:	897fff84 	addi	r5,r17,-2
8112e378:	8009883a 	mov	r4,r16
8112e37c:	11283cc0 	call	811283cc <__any_on>
8112e380:	10007726 	beq	r2,zero,8112e560 <__gethex+0x74c>
8112e384:	04c000c4 	movi	r19,3
8112e388:	880b883a 	mov	r5,r17
8112e38c:	8009883a 	mov	r4,r16
8112e390:	112dd140 	call	8112dd14 <rshift>
8112e394:	bc6f883a 	add	r23,r23,r17
8112e398:	003f1f06 	br	8112e018 <__reset+0xfb10e018>
8112e39c:	002f883a 	mov	r23,zero
8112e3a0:	003ee306 	br	8112df30 <__reset+0xfb10df30>
8112e3a4:	d9000117 	ldw	r4,4(sp)
8112e3a8:	90a3c83a 	sub	r17,r18,r2
8112e3ac:	800b883a 	mov	r5,r16
8112e3b0:	880d883a 	mov	r6,r17
8112e3b4:	1127bac0 	call	81127bac <__lshift>
8112e3b8:	10c00504 	addi	r3,r2,20
8112e3bc:	1021883a 	mov	r16,r2
8112e3c0:	bc6fc83a 	sub	r23,r23,r17
8112e3c4:	d8c00215 	stw	r3,8(sp)
8112e3c8:	0027883a 	mov	r19,zero
8112e3cc:	003f1206 	br	8112e018 <__reset+0xfb10e018>
8112e3d0:	1d400084 	addi	r21,r3,2
8112e3d4:	0023883a 	mov	r17,zero
8112e3d8:	003eb406 	br	8112deac <__reset+0xfb10deac>
8112e3dc:	2005883a 	mov	r2,r4
8112e3e0:	003f4606 	br	8112e0fc <__reset+0xfb10e0fc>
8112e3e4:	0027883a 	mov	r19,zero
8112e3e8:	003fe706 	br	8112e388 <__reset+0xfb10e388>
8112e3ec:	bc7fffc4 	addi	r17,r23,-1
8112e3f0:	9800421e 	bne	r19,zero,8112e4fc <__gethex+0x6e8>
8112e3f4:	88000426 	beq	r17,zero,8112e408 <__gethex+0x5f4>
8112e3f8:	880b883a 	mov	r5,r17
8112e3fc:	8009883a 	mov	r4,r16
8112e400:	11283cc0 	call	811283cc <__any_on>
8112e404:	1027883a 	mov	r19,r2
8112e408:	8805d17a 	srai	r2,r17,5
8112e40c:	d8c00217 	ldw	r3,8(sp)
8112e410:	8c4007cc 	andi	r17,r17,31
8112e414:	1085883a 	add	r2,r2,r2
8112e418:	1085883a 	add	r2,r2,r2
8112e41c:	1885883a 	add	r2,r3,r2
8112e420:	00c00044 	movi	r3,1
8112e424:	1c62983a 	sll	r17,r3,r17
8112e428:	10800017 	ldw	r2,0(r2)
8112e42c:	8884703a 	and	r2,r17,r2
8112e430:	10000126 	beq	r2,zero,8112e438 <__gethex+0x624>
8112e434:	9cc00094 	ori	r19,r19,2
8112e438:	b80b883a 	mov	r5,r23
8112e43c:	8009883a 	mov	r4,r16
8112e440:	112dd140 	call	8112dd14 <rshift>
8112e444:	d8c00017 	ldw	r3,0(sp)
8112e448:	95e5c83a 	sub	r18,r18,r23
8112e44c:	04400084 	movi	r17,2
8112e450:	1dc00117 	ldw	r23,4(r3)
8112e454:	003fa106 	br	8112e2dc <__reset+0xfb10e2dc>
8112e458:	85af883a 	add	r23,r16,r22
8112e45c:	b8800003 	ldbu	r2,0(r23)
8112e460:	b821883a 	mov	r16,r23
8112e464:	11003fcc 	andi	r4,r2,255
8112e468:	a109883a 	add	r4,r20,r4
8112e46c:	21000003 	ldbu	r4,0(r4)
8112e470:	203eaa26 	beq	r4,zero,8112df1c <__reset+0xfb10df1c>
8112e474:	84000044 	addi	r16,r16,1
8112e478:	80800003 	ldbu	r2,0(r16)
8112e47c:	11003fcc 	andi	r4,r2,255
8112e480:	a109883a 	add	r4,r20,r4
8112e484:	21000003 	ldbu	r4,0(r4)
8112e488:	203ffa1e 	bne	r4,zero,8112e474 <__reset+0xfb10e474>
8112e48c:	003ea306 	br	8112df1c <__reset+0xfb10df1c>
8112e490:	d9001617 	ldw	r4,88(sp)
8112e494:	00800044 	movi	r2,1
8112e498:	1109c83a 	sub	r4,r2,r4
8112e49c:	d9001615 	stw	r4,88(sp)
8112e4a0:	d8801617 	ldw	r2,88(sp)
8112e4a4:	103f9626 	beq	r2,zero,8112e300 <__reset+0xfb10e300>
8112e4a8:	87000417 	ldw	fp,16(r16)
8112e4ac:	d9800217 	ldw	r6,8(sp)
8112e4b0:	013fffc4 	movi	r4,-1
8112e4b4:	e727883a 	add	r19,fp,fp
8112e4b8:	9ce7883a 	add	r19,r19,r19
8112e4bc:	3005883a 	mov	r2,r6
8112e4c0:	34cb883a 	add	r5,r6,r19
8112e4c4:	00000306 	br	8112e4d4 <__gethex+0x6c0>
8112e4c8:	10000015 	stw	zero,0(r2)
8112e4cc:	10800104 	addi	r2,r2,4
8112e4d0:	117f4c2e 	bgeu	r2,r5,8112e204 <__reset+0xfb10e204>
8112e4d4:	10c00017 	ldw	r3,0(r2)
8112e4d8:	193ffb26 	beq	r3,r4,8112e4c8 <__reset+0xfb10e4c8>
8112e4dc:	18c00044 	addi	r3,r3,1
8112e4e0:	10c00015 	stw	r3,0(r2)
8112e4e4:	00800084 	movi	r2,2
8112e4e8:	88802b26 	beq	r17,r2,8112e598 <__gethex+0x784>
8112e4ec:	948007cc 	andi	r18,r18,31
8112e4f0:	90002f1e 	bne	r18,zero,8112e5b0 <__gethex+0x79c>
8112e4f4:	04400844 	movi	r17,33
8112e4f8:	003f8206 	br	8112e304 <__reset+0xfb10e304>
8112e4fc:	04c00044 	movi	r19,1
8112e500:	003fc106 	br	8112e408 <__reset+0xfb10e408>
8112e504:	d8c01617 	ldw	r3,88(sp)
8112e508:	183ed226 	beq	r3,zero,8112e054 <__reset+0xfb10e054>
8112e50c:	d8c00417 	ldw	r3,16(sp)
8112e510:	d9001517 	ldw	r4,84(sp)
8112e514:	18800015 	stw	r2,0(r3)
8112e518:	d8c00217 	ldw	r3,8(sp)
8112e51c:	00800044 	movi	r2,1
8112e520:	80800415 	stw	r2,16(r16)
8112e524:	18800015 	stw	r2,0(r3)
8112e528:	24000015 	stw	r16,0(r4)
8112e52c:	00801884 	movi	r2,98
8112e530:	003efa06 	br	8112e11c <__reset+0xfb10e11c>
8112e534:	9880008c 	andi	r2,r19,2
8112e538:	103f7126 	beq	r2,zero,8112e300 <__reset+0xfb10e300>
8112e53c:	d8c00217 	ldw	r3,8(sp)
8112e540:	18800017 	ldw	r2,0(r3)
8112e544:	9884b03a 	or	r2,r19,r2
8112e548:	1080004c 	andi	r2,r2,1
8112e54c:	103fd61e 	bne	r2,zero,8112e4a8 <__reset+0xfb10e4a8>
8112e550:	003f6b06 	br	8112e300 <__reset+0xfb10e300>
8112e554:	da800217 	ldw	r10,8(sp)
8112e558:	0013883a 	mov	r9,zero
8112e55c:	003e9f06 	br	8112dfdc <__reset+0xfb10dfdc>
8112e560:	04c00084 	movi	r19,2
8112e564:	003f8806 	br	8112e388 <__reset+0xfb10e388>
8112e568:	d9001617 	ldw	r4,88(sp)
8112e56c:	203fe726 	beq	r4,zero,8112e50c <__reset+0xfb10e50c>
8112e570:	003eb806 	br	8112e054 <__reset+0xfb10e054>
8112e574:	95feb71e 	bne	r18,r23,8112e054 <__reset+0xfb10e054>
8112e578:	1cbfe40e 	bge	r3,r18,8112e50c <__reset+0xfb10e50c>
8112e57c:	917fffc4 	addi	r5,r18,-1
8112e580:	8009883a 	mov	r4,r16
8112e584:	11283cc0 	call	811283cc <__any_on>
8112e588:	103eb226 	beq	r2,zero,8112e054 <__reset+0xfb10e054>
8112e58c:	d8c00017 	ldw	r3,0(sp)
8112e590:	18800117 	ldw	r2,4(r3)
8112e594:	003fdd06 	br	8112e50c <__reset+0xfb10e50c>
8112e598:	d8c00017 	ldw	r3,0(sp)
8112e59c:	18800017 	ldw	r2,0(r3)
8112e5a0:	10bfffc4 	addi	r2,r2,-1
8112e5a4:	90801c26 	beq	r18,r2,8112e618 <__gethex+0x804>
8112e5a8:	04400884 	movi	r17,34
8112e5ac:	003f5506 	br	8112e304 <__reset+0xfb10e304>
8112e5b0:	34c5883a 	add	r2,r6,r19
8112e5b4:	113fff17 	ldw	r4,-4(r2)
8112e5b8:	11277080 	call	81127708 <__hi0bits>
8112e5bc:	00c00804 	movi	r3,32
8112e5c0:	1ca5c83a 	sub	r18,r3,r18
8112e5c4:	14bfcb0e 	bge	r2,r18,8112e4f4 <__reset+0xfb10e4f4>
8112e5c8:	003f1c06 	br	8112e23c <__reset+0xfb10e23c>
8112e5cc:	81400117 	ldw	r5,4(r16)
8112e5d0:	d9000117 	ldw	r4,4(sp)
8112e5d4:	29400044 	addi	r5,r5,1
8112e5d8:	11273fc0 	call	811273fc <_Balloc>
8112e5dc:	81800417 	ldw	r6,16(r16)
8112e5e0:	81400304 	addi	r5,r16,12
8112e5e4:	11000304 	addi	r4,r2,12
8112e5e8:	31800084 	addi	r6,r6,2
8112e5ec:	318d883a 	add	r6,r6,r6
8112e5f0:	318d883a 	add	r6,r6,r6
8112e5f4:	1029883a 	mov	r20,r2
8112e5f8:	111d1cc0 	call	8111d1cc <memcpy>
8112e5fc:	d9000117 	ldw	r4,4(sp)
8112e600:	800b883a 	mov	r5,r16
8112e604:	a021883a 	mov	r16,r20
8112e608:	11274ac0 	call	811274ac <_Bfree>
8112e60c:	a0c00417 	ldw	r3,16(r20)
8112e610:	a1800504 	addi	r6,r20,20
8112e614:	003efe06 	br	8112e210 <__reset+0xfb10e210>
8112e618:	9005d17a 	srai	r2,r18,5
8112e61c:	944007cc 	andi	r17,r18,31
8112e620:	1085883a 	add	r2,r2,r2
8112e624:	1085883a 	add	r2,r2,r2
8112e628:	3087883a 	add	r3,r6,r2
8112e62c:	00800044 	movi	r2,1
8112e630:	1462983a 	sll	r17,r2,r17
8112e634:	18800017 	ldw	r2,0(r3)
8112e638:	8884703a 	and	r2,r17,r2
8112e63c:	1022c03a 	cmpne	r17,r2,zero
8112e640:	00800884 	movi	r2,34
8112e644:	1463c83a 	sub	r17,r2,r17
8112e648:	003f2e06 	br	8112e304 <__reset+0xfb10e304>

8112e64c <__hexnan>:
8112e64c:	defff904 	addi	sp,sp,-28
8112e650:	de00012e 	bgeu	sp,et,8112e658 <__hexnan+0xc>
8112e654:	003b68fa 	trap	3
8112e658:	dc800215 	stw	r18,8(sp)
8112e65c:	2c800017 	ldw	r18,0(r5)
8112e660:	dfc00615 	stw	ra,24(sp)
8112e664:	dd400515 	stw	r21,20(sp)
8112e668:	901fd17a 	srai	r15,r18,5
8112e66c:	dd000415 	stw	r20,16(sp)
8112e670:	dcc00315 	stw	r19,12(sp)
8112e674:	7bdf883a 	add	r15,r15,r15
8112e678:	7bdf883a 	add	r15,r15,r15
8112e67c:	dc400115 	stw	r17,4(sp)
8112e680:	dc000015 	stw	r16,0(sp)
8112e684:	948007cc 	andi	r18,r18,31
8112e688:	33df883a 	add	r15,r6,r15
8112e68c:	90000126 	beq	r18,zero,8112e694 <__hexnan+0x48>
8112e690:	7bc00104 	addi	r15,r15,4
8112e694:	22000017 	ldw	r8,0(r4)
8112e698:	7affff04 	addi	r11,r15,-4
8112e69c:	03a04574 	movhi	r14,33045
8112e6a0:	783fff15 	stw	zero,-4(r15)
8112e6a4:	581b883a 	mov	r13,r11
8112e6a8:	580b883a 	mov	r5,r11
8112e6ac:	000f883a 	mov	r7,zero
8112e6b0:	003f883a 	mov	ra,zero
8112e6b4:	0019883a 	mov	r12,zero
8112e6b8:	73aea104 	addi	r14,r14,-17788
8112e6bc:	04400204 	movi	r17,8
8112e6c0:	04000804 	movi	r16,32
8112e6c4:	04c001c4 	movi	r19,7
8112e6c8:	42000044 	addi	r8,r8,1
8112e6cc:	40c00003 	ldbu	r3,0(r8)
8112e6d0:	18001d26 	beq	r3,zero,8112e748 <__hexnan+0xfc>
8112e6d4:	70c5883a 	add	r2,r14,r3
8112e6d8:	10800003 	ldbu	r2,0(r2)
8112e6dc:	12403fcc 	andi	r9,r2,255
8112e6e0:	4800301e 	bne	r9,zero,8112e7a4 <__hexnan+0x158>
8112e6e4:	80c04236 	bltu	r16,r3,8112e7f0 <__hexnan+0x1a4>
8112e6e8:	fb3ff70e 	bge	ra,r12,8112e6c8 <__reset+0xfb10e6c8>
8112e6ec:	2b40112e 	bgeu	r5,r13,8112e734 <__hexnan+0xe8>
8112e6f0:	99c01016 	blt	r19,r7,8112e734 <__hexnan+0xe8>
8112e6f4:	89e9c83a 	sub	r20,r17,r7
8112e6f8:	a529883a 	add	r20,r20,r20
8112e6fc:	2a800017 	ldw	r10,0(r5)
8112e700:	a529883a 	add	r20,r20,r20
8112e704:	852bc83a 	sub	r21,r16,r20
8112e708:	28c00104 	addi	r3,r5,4
8112e70c:	2805883a 	mov	r2,r5
8112e710:	19c00017 	ldw	r7,0(r3)
8112e714:	10800104 	addi	r2,r2,4
8112e718:	18c00104 	addi	r3,r3,4
8112e71c:	3d52983a 	sll	r9,r7,r21
8112e720:	4a92b03a 	or	r9,r9,r10
8112e724:	3d14d83a 	srl	r10,r7,r20
8112e728:	127fff15 	stw	r9,-4(r2)
8112e72c:	1abfff15 	stw	r10,-4(r3)
8112e730:	137ff736 	bltu	r2,r13,8112e710 <__reset+0xfb10e710>
8112e734:	31402836 	bltu	r6,r5,8112e7d8 <__hexnan+0x18c>
8112e738:	42000044 	addi	r8,r8,1
8112e73c:	40c00003 	ldbu	r3,0(r8)
8112e740:	01c00204 	movi	r7,8
8112e744:	183fe31e 	bne	r3,zero,8112e6d4 <__reset+0xfb10e6d4>
8112e748:	60002b26 	beq	r12,zero,8112e7f8 <__hexnan+0x1ac>
8112e74c:	2b40022e 	bgeu	r5,r13,8112e758 <__hexnan+0x10c>
8112e750:	008001c4 	movi	r2,7
8112e754:	11c0430e 	bge	r2,r7,8112e864 <__hexnan+0x218>
8112e758:	3140312e 	bgeu	r6,r5,8112e820 <__hexnan+0x1d4>
8112e75c:	3007883a 	mov	r3,r6
8112e760:	29000017 	ldw	r4,0(r5)
8112e764:	18800104 	addi	r2,r3,4
8112e768:	29400104 	addi	r5,r5,4
8112e76c:	19000015 	stw	r4,0(r3)
8112e770:	1007883a 	mov	r3,r2
8112e774:	597ffa2e 	bgeu	r11,r5,8112e760 <__reset+0xfb10e760>
8112e778:	10000015 	stw	zero,0(r2)
8112e77c:	10800104 	addi	r2,r2,4
8112e780:	58bffd2e 	bgeu	r11,r2,8112e778 <__reset+0xfb10e778>
8112e784:	78bfff17 	ldw	r2,-4(r15)
8112e788:	1000041e 	bne	r2,zero,8112e79c <__hexnan+0x150>
8112e78c:	32c02d26 	beq	r6,r11,8112e844 <__hexnan+0x1f8>
8112e790:	5affff04 	addi	r11,r11,-4
8112e794:	58800017 	ldw	r2,0(r11)
8112e798:	103ffc26 	beq	r2,zero,8112e78c <__reset+0xfb10e78c>
8112e79c:	00800144 	movi	r2,5
8112e7a0:	00001606 	br	8112e7fc <__hexnan+0x1b0>
8112e7a4:	39c00044 	addi	r7,r7,1
8112e7a8:	63000044 	addi	r12,r12,1
8112e7ac:	89c0040e 	bge	r17,r7,8112e7c0 <__hexnan+0x174>
8112e7b0:	317fc52e 	bgeu	r6,r5,8112e6c8 <__reset+0xfb10e6c8>
8112e7b4:	283fff15 	stw	zero,-4(r5)
8112e7b8:	01c00044 	movi	r7,1
8112e7bc:	297fff04 	addi	r5,r5,-4
8112e7c0:	28c00017 	ldw	r3,0(r5)
8112e7c4:	108003cc 	andi	r2,r2,15
8112e7c8:	1806913a 	slli	r3,r3,4
8112e7cc:	1884b03a 	or	r2,r3,r2
8112e7d0:	28800015 	stw	r2,0(r5)
8112e7d4:	003fbc06 	br	8112e6c8 <__reset+0xfb10e6c8>
8112e7d8:	2b7fff04 	addi	r13,r5,-4
8112e7dc:	283fff15 	stw	zero,-4(r5)
8112e7e0:	603f883a 	mov	ra,r12
8112e7e4:	680b883a 	mov	r5,r13
8112e7e8:	000f883a 	mov	r7,zero
8112e7ec:	003fb606 	br	8112e6c8 <__reset+0xfb10e6c8>
8112e7f0:	00800a44 	movi	r2,41
8112e7f4:	18801726 	beq	r3,r2,8112e854 <__hexnan+0x208>
8112e7f8:	00800104 	movi	r2,4
8112e7fc:	dfc00617 	ldw	ra,24(sp)
8112e800:	dd400517 	ldw	r21,20(sp)
8112e804:	dd000417 	ldw	r20,16(sp)
8112e808:	dcc00317 	ldw	r19,12(sp)
8112e80c:	dc800217 	ldw	r18,8(sp)
8112e810:	dc400117 	ldw	r17,4(sp)
8112e814:	dc000017 	ldw	r16,0(sp)
8112e818:	dec00704 	addi	sp,sp,28
8112e81c:	f800283a 	ret
8112e820:	903fd826 	beq	r18,zero,8112e784 <__reset+0xfb10e784>
8112e824:	00c00804 	movi	r3,32
8112e828:	1ca5c83a 	sub	r18,r3,r18
8112e82c:	00ffffc4 	movi	r3,-1
8112e830:	78bfff17 	ldw	r2,-4(r15)
8112e834:	1c86d83a 	srl	r3,r3,r18
8112e838:	1884703a 	and	r2,r3,r2
8112e83c:	78bfff15 	stw	r2,-4(r15)
8112e840:	003fd106 	br	8112e788 <__reset+0xfb10e788>
8112e844:	00800044 	movi	r2,1
8112e848:	58800015 	stw	r2,0(r11)
8112e84c:	00800144 	movi	r2,5
8112e850:	003fea06 	br	8112e7fc <__reset+0xfb10e7fc>
8112e854:	42000044 	addi	r8,r8,1
8112e858:	22000015 	stw	r8,0(r4)
8112e85c:	603fbb1e 	bne	r12,zero,8112e74c <__reset+0xfb10e74c>
8112e860:	003fe506 	br	8112e7f8 <__reset+0xfb10e7f8>
8112e864:	02400204 	movi	r9,8
8112e868:	49d3c83a 	sub	r9,r9,r7
8112e86c:	4a53883a 	add	r9,r9,r9
8112e870:	2a000017 	ldw	r8,0(r5)
8112e874:	4a53883a 	add	r9,r9,r9
8112e878:	02800804 	movi	r10,32
8112e87c:	5255c83a 	sub	r10,r10,r9
8112e880:	28c00104 	addi	r3,r5,4
8112e884:	2805883a 	mov	r2,r5
8112e888:	19c00017 	ldw	r7,0(r3)
8112e88c:	10800104 	addi	r2,r2,4
8112e890:	18c00104 	addi	r3,r3,4
8112e894:	3a88983a 	sll	r4,r7,r10
8112e898:	2208b03a 	or	r4,r4,r8
8112e89c:	3a50d83a 	srl	r8,r7,r9
8112e8a0:	113fff15 	stw	r4,-4(r2)
8112e8a4:	1a3fff15 	stw	r8,-4(r3)
8112e8a8:	137ff736 	bltu	r2,r13,8112e888 <__reset+0xfb10e888>
8112e8ac:	003faa06 	br	8112e758 <__reset+0xfb10e758>

8112e8b0 <strncmp>:
8112e8b0:	30003126 	beq	r6,zero,8112e978 <strncmp+0xc8>
8112e8b4:	2144b03a 	or	r2,r4,r5
8112e8b8:	108000cc 	andi	r2,r2,3
8112e8bc:	10001e1e 	bne	r2,zero,8112e938 <strncmp+0x88>
8112e8c0:	024000c4 	movi	r9,3
8112e8c4:	49801c2e 	bgeu	r9,r6,8112e938 <strncmp+0x88>
8112e8c8:	20800017 	ldw	r2,0(r4)
8112e8cc:	28c00017 	ldw	r3,0(r5)
8112e8d0:	10c0191e 	bne	r2,r3,8112e938 <strncmp+0x88>
8112e8d4:	31bfff04 	addi	r6,r6,-4
8112e8d8:	30002726 	beq	r6,zero,8112e978 <strncmp+0xc8>
8112e8dc:	02ffbff4 	movhi	r11,65279
8112e8e0:	5affbfc4 	addi	r11,r11,-257
8112e8e4:	0086303a 	nor	r3,zero,r2
8112e8e8:	02a02074 	movhi	r10,32897
8112e8ec:	12c5883a 	add	r2,r2,r11
8112e8f0:	52a02004 	addi	r10,r10,-32640
8112e8f4:	10c4703a 	and	r2,r2,r3
8112e8f8:	1284703a 	and	r2,r2,r10
8112e8fc:	10000b26 	beq	r2,zero,8112e92c <strncmp+0x7c>
8112e900:	00001d06 	br	8112e978 <strncmp+0xc8>
8112e904:	20c00017 	ldw	r3,0(r4)
8112e908:	29c00017 	ldw	r7,0(r5)
8112e90c:	1ad1883a 	add	r8,r3,r11
8112e910:	00c4303a 	nor	r2,zero,r3
8112e914:	4084703a 	and	r2,r8,r2
8112e918:	1284703a 	and	r2,r2,r10
8112e91c:	19c0061e 	bne	r3,r7,8112e938 <strncmp+0x88>
8112e920:	31bfff04 	addi	r6,r6,-4
8112e924:	30001426 	beq	r6,zero,8112e978 <strncmp+0xc8>
8112e928:	1000131e 	bne	r2,zero,8112e978 <strncmp+0xc8>
8112e92c:	21000104 	addi	r4,r4,4
8112e930:	29400104 	addi	r5,r5,4
8112e934:	49bff336 	bltu	r9,r6,8112e904 <__reset+0xfb10e904>
8112e938:	28800007 	ldb	r2,0(r5)
8112e93c:	20c00007 	ldb	r3,0(r4)
8112e940:	31bfffc4 	addi	r6,r6,-1
8112e944:	10c0081e 	bne	r2,r3,8112e968 <strncmp+0xb8>
8112e948:	30000b26 	beq	r6,zero,8112e978 <strncmp+0xc8>
8112e94c:	10000a26 	beq	r2,zero,8112e978 <strncmp+0xc8>
8112e950:	21000044 	addi	r4,r4,1
8112e954:	29400044 	addi	r5,r5,1
8112e958:	20800007 	ldb	r2,0(r4)
8112e95c:	28c00007 	ldb	r3,0(r5)
8112e960:	31bfffc4 	addi	r6,r6,-1
8112e964:	10fff826 	beq	r2,r3,8112e948 <__reset+0xfb10e948>
8112e968:	20800003 	ldbu	r2,0(r4)
8112e96c:	28c00003 	ldbu	r3,0(r5)
8112e970:	10c5c83a 	sub	r2,r2,r3
8112e974:	f800283a 	ret
8112e978:	0005883a 	mov	r2,zero
8112e97c:	f800283a 	ret

8112e980 <_wcrtomb_r>:
8112e980:	defff604 	addi	sp,sp,-40
8112e984:	00a04574 	movhi	r2,33045
8112e988:	de00012e 	bgeu	sp,et,8112e990 <_wcrtomb_r+0x10>
8112e98c:	003b68fa 	trap	3
8112e990:	10b7db04 	addi	r2,r2,-8340
8112e994:	dc800815 	stw	r18,32(sp)
8112e998:	dc400715 	stw	r17,28(sp)
8112e99c:	dc000615 	stw	r16,24(sp)
8112e9a0:	dfc00915 	stw	ra,36(sp)
8112e9a4:	2021883a 	mov	r16,r4
8112e9a8:	3823883a 	mov	r17,r7
8112e9ac:	14800017 	ldw	r18,0(r2)
8112e9b0:	28001426 	beq	r5,zero,8112ea04 <_wcrtomb_r+0x84>
8112e9b4:	d9400415 	stw	r5,16(sp)
8112e9b8:	d9800515 	stw	r6,20(sp)
8112e9bc:	1126eb00 	call	81126eb0 <__locale_charset>
8112e9c0:	d9800517 	ldw	r6,20(sp)
8112e9c4:	d9400417 	ldw	r5,16(sp)
8112e9c8:	100f883a 	mov	r7,r2
8112e9cc:	dc400015 	stw	r17,0(sp)
8112e9d0:	8009883a 	mov	r4,r16
8112e9d4:	903ee83a 	callr	r18
8112e9d8:	00ffffc4 	movi	r3,-1
8112e9dc:	10c0031e 	bne	r2,r3,8112e9ec <_wcrtomb_r+0x6c>
8112e9e0:	88000015 	stw	zero,0(r17)
8112e9e4:	00c02284 	movi	r3,138
8112e9e8:	80c00015 	stw	r3,0(r16)
8112e9ec:	dfc00917 	ldw	ra,36(sp)
8112e9f0:	dc800817 	ldw	r18,32(sp)
8112e9f4:	dc400717 	ldw	r17,28(sp)
8112e9f8:	dc000617 	ldw	r16,24(sp)
8112e9fc:	dec00a04 	addi	sp,sp,40
8112ea00:	f800283a 	ret
8112ea04:	1126eb00 	call	81126eb0 <__locale_charset>
8112ea08:	100f883a 	mov	r7,r2
8112ea0c:	dc400015 	stw	r17,0(sp)
8112ea10:	000d883a 	mov	r6,zero
8112ea14:	d9400104 	addi	r5,sp,4
8112ea18:	8009883a 	mov	r4,r16
8112ea1c:	903ee83a 	callr	r18
8112ea20:	003fed06 	br	8112e9d8 <__reset+0xfb10e9d8>

8112ea24 <wcrtomb>:
8112ea24:	defff604 	addi	sp,sp,-40
8112ea28:	00a04574 	movhi	r2,33045
8112ea2c:	de00012e 	bgeu	sp,et,8112ea34 <wcrtomb+0x10>
8112ea30:	003b68fa 	trap	3
8112ea34:	10b7d604 	addi	r2,r2,-8360
8112ea38:	dc800615 	stw	r18,24(sp)
8112ea3c:	dc400515 	stw	r17,20(sp)
8112ea40:	dfc00915 	stw	ra,36(sp)
8112ea44:	dd000815 	stw	r20,32(sp)
8112ea48:	dcc00715 	stw	r19,28(sp)
8112ea4c:	dc000415 	stw	r16,16(sp)
8112ea50:	3025883a 	mov	r18,r6
8112ea54:	14400017 	ldw	r17,0(r2)
8112ea58:	20001926 	beq	r4,zero,8112eac0 <wcrtomb+0x9c>
8112ea5c:	00a04574 	movhi	r2,33045
8112ea60:	10b7db04 	addi	r2,r2,-8340
8112ea64:	15000017 	ldw	r20,0(r2)
8112ea68:	2021883a 	mov	r16,r4
8112ea6c:	2827883a 	mov	r19,r5
8112ea70:	1126eb00 	call	81126eb0 <__locale_charset>
8112ea74:	100f883a 	mov	r7,r2
8112ea78:	dc800015 	stw	r18,0(sp)
8112ea7c:	980d883a 	mov	r6,r19
8112ea80:	800b883a 	mov	r5,r16
8112ea84:	8809883a 	mov	r4,r17
8112ea88:	a03ee83a 	callr	r20
8112ea8c:	00ffffc4 	movi	r3,-1
8112ea90:	10c0031e 	bne	r2,r3,8112eaa0 <wcrtomb+0x7c>
8112ea94:	90000015 	stw	zero,0(r18)
8112ea98:	00c02284 	movi	r3,138
8112ea9c:	88c00015 	stw	r3,0(r17)
8112eaa0:	dfc00917 	ldw	ra,36(sp)
8112eaa4:	dd000817 	ldw	r20,32(sp)
8112eaa8:	dcc00717 	ldw	r19,28(sp)
8112eaac:	dc800617 	ldw	r18,24(sp)
8112eab0:	dc400517 	ldw	r17,20(sp)
8112eab4:	dc000417 	ldw	r16,16(sp)
8112eab8:	dec00a04 	addi	sp,sp,40
8112eabc:	f800283a 	ret
8112eac0:	00a04574 	movhi	r2,33045
8112eac4:	10b7db04 	addi	r2,r2,-8340
8112eac8:	14000017 	ldw	r16,0(r2)
8112eacc:	1126eb00 	call	81126eb0 <__locale_charset>
8112ead0:	100f883a 	mov	r7,r2
8112ead4:	dc800015 	stw	r18,0(sp)
8112ead8:	000d883a 	mov	r6,zero
8112eadc:	d9400104 	addi	r5,sp,4
8112eae0:	8809883a 	mov	r4,r17
8112eae4:	803ee83a 	callr	r16
8112eae8:	003fe806 	br	8112ea8c <__reset+0xfb10ea8c>

8112eaec <__ascii_wctomb>:
8112eaec:	28000526 	beq	r5,zero,8112eb04 <__ascii_wctomb+0x18>
8112eaf0:	00803fc4 	movi	r2,255
8112eaf4:	11800536 	bltu	r2,r6,8112eb0c <__ascii_wctomb+0x20>
8112eaf8:	29800005 	stb	r6,0(r5)
8112eafc:	00800044 	movi	r2,1
8112eb00:	f800283a 	ret
8112eb04:	0005883a 	mov	r2,zero
8112eb08:	f800283a 	ret
8112eb0c:	00802284 	movi	r2,138
8112eb10:	20800015 	stw	r2,0(r4)
8112eb14:	00bfffc4 	movi	r2,-1
8112eb18:	f800283a 	ret

8112eb1c <_wctomb_r>:
8112eb1c:	00a04574 	movhi	r2,33045
8112eb20:	defff904 	addi	sp,sp,-28
8112eb24:	10b7db04 	addi	r2,r2,-8340
8112eb28:	de00012e 	bgeu	sp,et,8112eb30 <_wctomb_r+0x14>
8112eb2c:	003b68fa 	trap	3
8112eb30:	dfc00615 	stw	ra,24(sp)
8112eb34:	dc400515 	stw	r17,20(sp)
8112eb38:	dc000415 	stw	r16,16(sp)
8112eb3c:	3823883a 	mov	r17,r7
8112eb40:	14000017 	ldw	r16,0(r2)
8112eb44:	d9000115 	stw	r4,4(sp)
8112eb48:	d9400215 	stw	r5,8(sp)
8112eb4c:	d9800315 	stw	r6,12(sp)
8112eb50:	1126eb00 	call	81126eb0 <__locale_charset>
8112eb54:	d9800317 	ldw	r6,12(sp)
8112eb58:	d9400217 	ldw	r5,8(sp)
8112eb5c:	d9000117 	ldw	r4,4(sp)
8112eb60:	100f883a 	mov	r7,r2
8112eb64:	dc400015 	stw	r17,0(sp)
8112eb68:	803ee83a 	callr	r16
8112eb6c:	dfc00617 	ldw	ra,24(sp)
8112eb70:	dc400517 	ldw	r17,20(sp)
8112eb74:	dc000417 	ldw	r16,16(sp)
8112eb78:	dec00704 	addi	sp,sp,28
8112eb7c:	f800283a 	ret

8112eb80 <__fixunsdfsi>:
8112eb80:	defffd04 	addi	sp,sp,-12
8112eb84:	000d883a 	mov	r6,zero
8112eb88:	01d07834 	movhi	r7,16864
8112eb8c:	de00012e 	bgeu	sp,et,8112eb94 <__fixunsdfsi+0x14>
8112eb90:	003b68fa 	trap	3
8112eb94:	dc400115 	stw	r17,4(sp)
8112eb98:	dc000015 	stw	r16,0(sp)
8112eb9c:	dfc00215 	stw	ra,8(sp)
8112eba0:	2023883a 	mov	r17,r4
8112eba4:	2821883a 	mov	r16,r5
8112eba8:	1130c980 	call	81130c98 <__gedf2>
8112ebac:	1000080e 	bge	r2,zero,8112ebd0 <__fixunsdfsi+0x50>
8112ebb0:	8809883a 	mov	r4,r17
8112ebb4:	800b883a 	mov	r5,r16
8112ebb8:	113176c0 	call	8113176c <__fixdfsi>
8112ebbc:	dfc00217 	ldw	ra,8(sp)
8112ebc0:	dc400117 	ldw	r17,4(sp)
8112ebc4:	dc000017 	ldw	r16,0(sp)
8112ebc8:	dec00304 	addi	sp,sp,12
8112ebcc:	f800283a 	ret
8112ebd0:	000d883a 	mov	r6,zero
8112ebd4:	01d07834 	movhi	r7,16864
8112ebd8:	8809883a 	mov	r4,r17
8112ebdc:	800b883a 	mov	r5,r16
8112ebe0:	1130e680 	call	81130e68 <__subdf3>
8112ebe4:	180b883a 	mov	r5,r3
8112ebe8:	1009883a 	mov	r4,r2
8112ebec:	113176c0 	call	8113176c <__fixdfsi>
8112ebf0:	00e00034 	movhi	r3,32768
8112ebf4:	10c5883a 	add	r2,r2,r3
8112ebf8:	003ff006 	br	8112ebbc <__reset+0xfb10ebbc>

8112ebfc <__udivdi3>:
8112ebfc:	defff504 	addi	sp,sp,-44
8112ec00:	de00012e 	bgeu	sp,et,8112ec08 <__udivdi3+0xc>
8112ec04:	003b68fa 	trap	3
8112ec08:	dcc00415 	stw	r19,16(sp)
8112ec0c:	dc000115 	stw	r16,4(sp)
8112ec10:	dfc00a15 	stw	ra,40(sp)
8112ec14:	df000915 	stw	fp,36(sp)
8112ec18:	ddc00815 	stw	r23,32(sp)
8112ec1c:	dd800715 	stw	r22,28(sp)
8112ec20:	dd400615 	stw	r21,24(sp)
8112ec24:	dd000515 	stw	r20,20(sp)
8112ec28:	dc800315 	stw	r18,12(sp)
8112ec2c:	dc400215 	stw	r17,8(sp)
8112ec30:	2027883a 	mov	r19,r4
8112ec34:	2821883a 	mov	r16,r5
8112ec38:	3800411e 	bne	r7,zero,8112ed40 <__udivdi3+0x144>
8112ec3c:	3023883a 	mov	r17,r6
8112ec40:	2025883a 	mov	r18,r4
8112ec44:	2980522e 	bgeu	r5,r6,8112ed90 <__udivdi3+0x194>
8112ec48:	00bfffd4 	movui	r2,65535
8112ec4c:	282d883a 	mov	r22,r5
8112ec50:	1180a836 	bltu	r2,r6,8112eef4 <__udivdi3+0x2f8>
8112ec54:	00803fc4 	movi	r2,255
8112ec58:	1185803a 	cmpltu	r2,r2,r6
8112ec5c:	100490fa 	slli	r2,r2,3
8112ec60:	3086d83a 	srl	r3,r6,r2
8112ec64:	01204574 	movhi	r4,33045
8112ec68:	212d1b04 	addi	r4,r4,-19348
8112ec6c:	20c7883a 	add	r3,r4,r3
8112ec70:	18c00003 	ldbu	r3,0(r3)
8112ec74:	1885883a 	add	r2,r3,r2
8112ec78:	00c00804 	movi	r3,32
8112ec7c:	1887c83a 	sub	r3,r3,r2
8112ec80:	18000526 	beq	r3,zero,8112ec98 <__udivdi3+0x9c>
8112ec84:	80e0983a 	sll	r16,r16,r3
8112ec88:	9884d83a 	srl	r2,r19,r2
8112ec8c:	30e2983a 	sll	r17,r6,r3
8112ec90:	98e4983a 	sll	r18,r19,r3
8112ec94:	142cb03a 	or	r22,r2,r16
8112ec98:	882ad43a 	srli	r21,r17,16
8112ec9c:	b009883a 	mov	r4,r22
8112eca0:	8d3fffcc 	andi	r20,r17,65535
8112eca4:	a80b883a 	mov	r5,r21
8112eca8:	112f8180 	call	8112f818 <__umodsi3>
8112ecac:	b009883a 	mov	r4,r22
8112ecb0:	a80b883a 	mov	r5,r21
8112ecb4:	1027883a 	mov	r19,r2
8112ecb8:	112f7b40 	call	8112f7b4 <__udivsi3>
8112ecbc:	102d883a 	mov	r22,r2
8112ecc0:	9826943a 	slli	r19,r19,16
8112ecc4:	9004d43a 	srli	r2,r18,16
8112ecc8:	a5a1383a 	mul	r16,r20,r22
8112eccc:	14c4b03a 	or	r2,r2,r19
8112ecd0:	1400052e 	bgeu	r2,r16,8112ece8 <__udivdi3+0xec>
8112ecd4:	1445883a 	add	r2,r2,r17
8112ecd8:	b0ffffc4 	addi	r3,r22,-1
8112ecdc:	14400136 	bltu	r2,r17,8112ece4 <__udivdi3+0xe8>
8112ece0:	14012336 	bltu	r2,r16,8112f170 <__udivdi3+0x574>
8112ece4:	182d883a 	mov	r22,r3
8112ece8:	1421c83a 	sub	r16,r2,r16
8112ecec:	a80b883a 	mov	r5,r21
8112ecf0:	8009883a 	mov	r4,r16
8112ecf4:	112f8180 	call	8112f818 <__umodsi3>
8112ecf8:	1027883a 	mov	r19,r2
8112ecfc:	a80b883a 	mov	r5,r21
8112ed00:	8009883a 	mov	r4,r16
8112ed04:	112f7b40 	call	8112f7b4 <__udivsi3>
8112ed08:	9826943a 	slli	r19,r19,16
8112ed0c:	a0a9383a 	mul	r20,r20,r2
8112ed10:	94bfffcc 	andi	r18,r18,65535
8112ed14:	94e4b03a 	or	r18,r18,r19
8112ed18:	9500052e 	bgeu	r18,r20,8112ed30 <__udivdi3+0x134>
8112ed1c:	8ca5883a 	add	r18,r17,r18
8112ed20:	10ffffc4 	addi	r3,r2,-1
8112ed24:	9440f136 	bltu	r18,r17,8112f0ec <__udivdi3+0x4f0>
8112ed28:	9500f02e 	bgeu	r18,r20,8112f0ec <__udivdi3+0x4f0>
8112ed2c:	10bfff84 	addi	r2,r2,-2
8112ed30:	b00c943a 	slli	r6,r22,16
8112ed34:	0007883a 	mov	r3,zero
8112ed38:	3084b03a 	or	r2,r6,r2
8112ed3c:	00005906 	br	8112eea4 <__udivdi3+0x2a8>
8112ed40:	29c05636 	bltu	r5,r7,8112ee9c <__udivdi3+0x2a0>
8112ed44:	00bfffd4 	movui	r2,65535
8112ed48:	11c0622e 	bgeu	r2,r7,8112eed4 <__udivdi3+0x2d8>
8112ed4c:	00804034 	movhi	r2,256
8112ed50:	10bfffc4 	addi	r2,r2,-1
8112ed54:	11c0ee36 	bltu	r2,r7,8112f110 <__udivdi3+0x514>
8112ed58:	00800404 	movi	r2,16
8112ed5c:	3886d83a 	srl	r3,r7,r2
8112ed60:	01204574 	movhi	r4,33045
8112ed64:	212d1b04 	addi	r4,r4,-19348
8112ed68:	20c7883a 	add	r3,r4,r3
8112ed6c:	18c00003 	ldbu	r3,0(r3)
8112ed70:	05400804 	movi	r21,32
8112ed74:	1885883a 	add	r2,r3,r2
8112ed78:	a8abc83a 	sub	r21,r21,r2
8112ed7c:	a800621e 	bne	r21,zero,8112ef08 <__udivdi3+0x30c>
8112ed80:	3c00e936 	bltu	r7,r16,8112f128 <__udivdi3+0x52c>
8112ed84:	9985403a 	cmpgeu	r2,r19,r6
8112ed88:	0007883a 	mov	r3,zero
8112ed8c:	00004506 	br	8112eea4 <__udivdi3+0x2a8>
8112ed90:	3000041e 	bne	r6,zero,8112eda4 <__udivdi3+0x1a8>
8112ed94:	000b883a 	mov	r5,zero
8112ed98:	01000044 	movi	r4,1
8112ed9c:	112f7b40 	call	8112f7b4 <__udivsi3>
8112eda0:	1023883a 	mov	r17,r2
8112eda4:	00bfffd4 	movui	r2,65535
8112eda8:	14404e2e 	bgeu	r2,r17,8112eee4 <__udivdi3+0x2e8>
8112edac:	00804034 	movhi	r2,256
8112edb0:	10bfffc4 	addi	r2,r2,-1
8112edb4:	1440d836 	bltu	r2,r17,8112f118 <__udivdi3+0x51c>
8112edb8:	00800404 	movi	r2,16
8112edbc:	8886d83a 	srl	r3,r17,r2
8112edc0:	01204574 	movhi	r4,33045
8112edc4:	212d1b04 	addi	r4,r4,-19348
8112edc8:	20c7883a 	add	r3,r4,r3
8112edcc:	18c00003 	ldbu	r3,0(r3)
8112edd0:	1885883a 	add	r2,r3,r2
8112edd4:	00c00804 	movi	r3,32
8112edd8:	1887c83a 	sub	r3,r3,r2
8112eddc:	18008f1e 	bne	r3,zero,8112f01c <__udivdi3+0x420>
8112ede0:	882ad43a 	srli	r21,r17,16
8112ede4:	8461c83a 	sub	r16,r16,r17
8112ede8:	8d3fffcc 	andi	r20,r17,65535
8112edec:	00c00044 	movi	r3,1
8112edf0:	8009883a 	mov	r4,r16
8112edf4:	a80b883a 	mov	r5,r21
8112edf8:	d8c00015 	stw	r3,0(sp)
8112edfc:	112f8180 	call	8112f818 <__umodsi3>
8112ee00:	8009883a 	mov	r4,r16
8112ee04:	a80b883a 	mov	r5,r21
8112ee08:	1027883a 	mov	r19,r2
8112ee0c:	112f7b40 	call	8112f7b4 <__udivsi3>
8112ee10:	9826943a 	slli	r19,r19,16
8112ee14:	9008d43a 	srli	r4,r18,16
8112ee18:	1521383a 	mul	r16,r2,r20
8112ee1c:	102d883a 	mov	r22,r2
8112ee20:	24c8b03a 	or	r4,r4,r19
8112ee24:	d8c00017 	ldw	r3,0(sp)
8112ee28:	2400052e 	bgeu	r4,r16,8112ee40 <__udivdi3+0x244>
8112ee2c:	2449883a 	add	r4,r4,r17
8112ee30:	b0bfffc4 	addi	r2,r22,-1
8112ee34:	24400136 	bltu	r4,r17,8112ee3c <__udivdi3+0x240>
8112ee38:	2400ca36 	bltu	r4,r16,8112f164 <__udivdi3+0x568>
8112ee3c:	102d883a 	mov	r22,r2
8112ee40:	2421c83a 	sub	r16,r4,r16
8112ee44:	a80b883a 	mov	r5,r21
8112ee48:	8009883a 	mov	r4,r16
8112ee4c:	d8c00015 	stw	r3,0(sp)
8112ee50:	112f8180 	call	8112f818 <__umodsi3>
8112ee54:	1027883a 	mov	r19,r2
8112ee58:	a80b883a 	mov	r5,r21
8112ee5c:	8009883a 	mov	r4,r16
8112ee60:	112f7b40 	call	8112f7b4 <__udivsi3>
8112ee64:	9826943a 	slli	r19,r19,16
8112ee68:	1529383a 	mul	r20,r2,r20
8112ee6c:	94bfffcc 	andi	r18,r18,65535
8112ee70:	94e4b03a 	or	r18,r18,r19
8112ee74:	d8c00017 	ldw	r3,0(sp)
8112ee78:	9500052e 	bgeu	r18,r20,8112ee90 <__udivdi3+0x294>
8112ee7c:	8ca5883a 	add	r18,r17,r18
8112ee80:	113fffc4 	addi	r4,r2,-1
8112ee84:	94409736 	bltu	r18,r17,8112f0e4 <__udivdi3+0x4e8>
8112ee88:	9500962e 	bgeu	r18,r20,8112f0e4 <__udivdi3+0x4e8>
8112ee8c:	10bfff84 	addi	r2,r2,-2
8112ee90:	b00c943a 	slli	r6,r22,16
8112ee94:	3084b03a 	or	r2,r6,r2
8112ee98:	00000206 	br	8112eea4 <__udivdi3+0x2a8>
8112ee9c:	0007883a 	mov	r3,zero
8112eea0:	0005883a 	mov	r2,zero
8112eea4:	dfc00a17 	ldw	ra,40(sp)
8112eea8:	df000917 	ldw	fp,36(sp)
8112eeac:	ddc00817 	ldw	r23,32(sp)
8112eeb0:	dd800717 	ldw	r22,28(sp)
8112eeb4:	dd400617 	ldw	r21,24(sp)
8112eeb8:	dd000517 	ldw	r20,20(sp)
8112eebc:	dcc00417 	ldw	r19,16(sp)
8112eec0:	dc800317 	ldw	r18,12(sp)
8112eec4:	dc400217 	ldw	r17,8(sp)
8112eec8:	dc000117 	ldw	r16,4(sp)
8112eecc:	dec00b04 	addi	sp,sp,44
8112eed0:	f800283a 	ret
8112eed4:	00803fc4 	movi	r2,255
8112eed8:	11c5803a 	cmpltu	r2,r2,r7
8112eedc:	100490fa 	slli	r2,r2,3
8112eee0:	003f9e06 	br	8112ed5c <__reset+0xfb10ed5c>
8112eee4:	00803fc4 	movi	r2,255
8112eee8:	1445803a 	cmpltu	r2,r2,r17
8112eeec:	100490fa 	slli	r2,r2,3
8112eef0:	003fb206 	br	8112edbc <__reset+0xfb10edbc>
8112eef4:	00804034 	movhi	r2,256
8112eef8:	10bfffc4 	addi	r2,r2,-1
8112eefc:	11808836 	bltu	r2,r6,8112f120 <__udivdi3+0x524>
8112ef00:	00800404 	movi	r2,16
8112ef04:	003f5606 	br	8112ec60 <__reset+0xfb10ec60>
8112ef08:	30aed83a 	srl	r23,r6,r2
8112ef0c:	3d4e983a 	sll	r7,r7,r21
8112ef10:	80acd83a 	srl	r22,r16,r2
8112ef14:	9884d83a 	srl	r2,r19,r2
8112ef18:	3deeb03a 	or	r23,r7,r23
8112ef1c:	b824d43a 	srli	r18,r23,16
8112ef20:	8560983a 	sll	r16,r16,r21
8112ef24:	b009883a 	mov	r4,r22
8112ef28:	900b883a 	mov	r5,r18
8112ef2c:	3568983a 	sll	r20,r6,r21
8112ef30:	1420b03a 	or	r16,r2,r16
8112ef34:	112f8180 	call	8112f818 <__umodsi3>
8112ef38:	b009883a 	mov	r4,r22
8112ef3c:	900b883a 	mov	r5,r18
8112ef40:	1023883a 	mov	r17,r2
8112ef44:	112f7b40 	call	8112f7b4 <__udivsi3>
8112ef48:	8808943a 	slli	r4,r17,16
8112ef4c:	bf3fffcc 	andi	fp,r23,65535
8112ef50:	8006d43a 	srli	r3,r16,16
8112ef54:	e0a3383a 	mul	r17,fp,r2
8112ef58:	100d883a 	mov	r6,r2
8112ef5c:	1906b03a 	or	r3,r3,r4
8112ef60:	1c40042e 	bgeu	r3,r17,8112ef74 <__udivdi3+0x378>
8112ef64:	1dc7883a 	add	r3,r3,r23
8112ef68:	10bfffc4 	addi	r2,r2,-1
8112ef6c:	1dc0752e 	bgeu	r3,r23,8112f144 <__udivdi3+0x548>
8112ef70:	100d883a 	mov	r6,r2
8112ef74:	1c63c83a 	sub	r17,r3,r17
8112ef78:	900b883a 	mov	r5,r18
8112ef7c:	8809883a 	mov	r4,r17
8112ef80:	d9800015 	stw	r6,0(sp)
8112ef84:	112f8180 	call	8112f818 <__umodsi3>
8112ef88:	102d883a 	mov	r22,r2
8112ef8c:	8809883a 	mov	r4,r17
8112ef90:	900b883a 	mov	r5,r18
8112ef94:	112f7b40 	call	8112f7b4 <__udivsi3>
8112ef98:	b02c943a 	slli	r22,r22,16
8112ef9c:	e089383a 	mul	r4,fp,r2
8112efa0:	843fffcc 	andi	r16,r16,65535
8112efa4:	85a0b03a 	or	r16,r16,r22
8112efa8:	d9800017 	ldw	r6,0(sp)
8112efac:	8100042e 	bgeu	r16,r4,8112efc0 <__udivdi3+0x3c4>
8112efb0:	85e1883a 	add	r16,r16,r23
8112efb4:	10ffffc4 	addi	r3,r2,-1
8112efb8:	85c05e2e 	bgeu	r16,r23,8112f134 <__udivdi3+0x538>
8112efbc:	1805883a 	mov	r2,r3
8112efc0:	300c943a 	slli	r6,r6,16
8112efc4:	a17fffcc 	andi	r5,r20,65535
8112efc8:	a028d43a 	srli	r20,r20,16
8112efcc:	3084b03a 	or	r2,r6,r2
8112efd0:	10ffffcc 	andi	r3,r2,65535
8112efd4:	100cd43a 	srli	r6,r2,16
8112efd8:	194f383a 	mul	r7,r3,r5
8112efdc:	1d07383a 	mul	r3,r3,r20
8112efe0:	314b383a 	mul	r5,r6,r5
8112efe4:	3810d43a 	srli	r8,r7,16
8112efe8:	8121c83a 	sub	r16,r16,r4
8112efec:	1947883a 	add	r3,r3,r5
8112eff0:	40c7883a 	add	r3,r8,r3
8112eff4:	350d383a 	mul	r6,r6,r20
8112eff8:	1940022e 	bgeu	r3,r5,8112f004 <__udivdi3+0x408>
8112effc:	01000074 	movhi	r4,1
8112f000:	310d883a 	add	r6,r6,r4
8112f004:	1828d43a 	srli	r20,r3,16
8112f008:	a18d883a 	add	r6,r20,r6
8112f00c:	81803e36 	bltu	r16,r6,8112f108 <__udivdi3+0x50c>
8112f010:	81803826 	beq	r16,r6,8112f0f4 <__udivdi3+0x4f8>
8112f014:	0007883a 	mov	r3,zero
8112f018:	003fa206 	br	8112eea4 <__reset+0xfb10eea4>
8112f01c:	88e2983a 	sll	r17,r17,r3
8112f020:	80a8d83a 	srl	r20,r16,r2
8112f024:	80e0983a 	sll	r16,r16,r3
8112f028:	882ad43a 	srli	r21,r17,16
8112f02c:	9884d83a 	srl	r2,r19,r2
8112f030:	a009883a 	mov	r4,r20
8112f034:	a80b883a 	mov	r5,r21
8112f038:	142eb03a 	or	r23,r2,r16
8112f03c:	98e4983a 	sll	r18,r19,r3
8112f040:	112f8180 	call	8112f818 <__umodsi3>
8112f044:	a009883a 	mov	r4,r20
8112f048:	a80b883a 	mov	r5,r21
8112f04c:	1021883a 	mov	r16,r2
8112f050:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f054:	1039883a 	mov	fp,r2
8112f058:	8d3fffcc 	andi	r20,r17,65535
8112f05c:	8020943a 	slli	r16,r16,16
8112f060:	b804d43a 	srli	r2,r23,16
8112f064:	a72d383a 	mul	r22,r20,fp
8112f068:	1404b03a 	or	r2,r2,r16
8112f06c:	1580062e 	bgeu	r2,r22,8112f088 <__udivdi3+0x48c>
8112f070:	1445883a 	add	r2,r2,r17
8112f074:	e0ffffc4 	addi	r3,fp,-1
8112f078:	14403836 	bltu	r2,r17,8112f15c <__udivdi3+0x560>
8112f07c:	1580372e 	bgeu	r2,r22,8112f15c <__udivdi3+0x560>
8112f080:	e73fff84 	addi	fp,fp,-2
8112f084:	1445883a 	add	r2,r2,r17
8112f088:	15adc83a 	sub	r22,r2,r22
8112f08c:	a80b883a 	mov	r5,r21
8112f090:	b009883a 	mov	r4,r22
8112f094:	112f8180 	call	8112f818 <__umodsi3>
8112f098:	1027883a 	mov	r19,r2
8112f09c:	b009883a 	mov	r4,r22
8112f0a0:	a80b883a 	mov	r5,r21
8112f0a4:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f0a8:	9826943a 	slli	r19,r19,16
8112f0ac:	a0a1383a 	mul	r16,r20,r2
8112f0b0:	b93fffcc 	andi	r4,r23,65535
8112f0b4:	24c8b03a 	or	r4,r4,r19
8112f0b8:	2400062e 	bgeu	r4,r16,8112f0d4 <__udivdi3+0x4d8>
8112f0bc:	2449883a 	add	r4,r4,r17
8112f0c0:	10ffffc4 	addi	r3,r2,-1
8112f0c4:	24402336 	bltu	r4,r17,8112f154 <__udivdi3+0x558>
8112f0c8:	2400222e 	bgeu	r4,r16,8112f154 <__udivdi3+0x558>
8112f0cc:	10bfff84 	addi	r2,r2,-2
8112f0d0:	2449883a 	add	r4,r4,r17
8112f0d4:	e038943a 	slli	fp,fp,16
8112f0d8:	2421c83a 	sub	r16,r4,r16
8112f0dc:	e086b03a 	or	r3,fp,r2
8112f0e0:	003f4306 	br	8112edf0 <__reset+0xfb10edf0>
8112f0e4:	2005883a 	mov	r2,r4
8112f0e8:	003f6906 	br	8112ee90 <__reset+0xfb10ee90>
8112f0ec:	1805883a 	mov	r2,r3
8112f0f0:	003f0f06 	br	8112ed30 <__reset+0xfb10ed30>
8112f0f4:	1806943a 	slli	r3,r3,16
8112f0f8:	9d66983a 	sll	r19,r19,r21
8112f0fc:	39ffffcc 	andi	r7,r7,65535
8112f100:	19c7883a 	add	r3,r3,r7
8112f104:	98ffc32e 	bgeu	r19,r3,8112f014 <__reset+0xfb10f014>
8112f108:	10bfffc4 	addi	r2,r2,-1
8112f10c:	003fc106 	br	8112f014 <__reset+0xfb10f014>
8112f110:	00800604 	movi	r2,24
8112f114:	003f1106 	br	8112ed5c <__reset+0xfb10ed5c>
8112f118:	00800604 	movi	r2,24
8112f11c:	003f2706 	br	8112edbc <__reset+0xfb10edbc>
8112f120:	00800604 	movi	r2,24
8112f124:	003ece06 	br	8112ec60 <__reset+0xfb10ec60>
8112f128:	0007883a 	mov	r3,zero
8112f12c:	00800044 	movi	r2,1
8112f130:	003f5c06 	br	8112eea4 <__reset+0xfb10eea4>
8112f134:	813fa12e 	bgeu	r16,r4,8112efbc <__reset+0xfb10efbc>
8112f138:	10bfff84 	addi	r2,r2,-2
8112f13c:	85e1883a 	add	r16,r16,r23
8112f140:	003f9f06 	br	8112efc0 <__reset+0xfb10efc0>
8112f144:	1c7f8a2e 	bgeu	r3,r17,8112ef70 <__reset+0xfb10ef70>
8112f148:	31bfff84 	addi	r6,r6,-2
8112f14c:	1dc7883a 	add	r3,r3,r23
8112f150:	003f8806 	br	8112ef74 <__reset+0xfb10ef74>
8112f154:	1805883a 	mov	r2,r3
8112f158:	003fde06 	br	8112f0d4 <__reset+0xfb10f0d4>
8112f15c:	1839883a 	mov	fp,r3
8112f160:	003fc906 	br	8112f088 <__reset+0xfb10f088>
8112f164:	b5bfff84 	addi	r22,r22,-2
8112f168:	2449883a 	add	r4,r4,r17
8112f16c:	003f3406 	br	8112ee40 <__reset+0xfb10ee40>
8112f170:	b5bfff84 	addi	r22,r22,-2
8112f174:	1445883a 	add	r2,r2,r17
8112f178:	003edb06 	br	8112ece8 <__reset+0xfb10ece8>

8112f17c <__umoddi3>:
8112f17c:	defff404 	addi	sp,sp,-48
8112f180:	de00012e 	bgeu	sp,et,8112f188 <__umoddi3+0xc>
8112f184:	003b68fa 	trap	3
8112f188:	df000a15 	stw	fp,40(sp)
8112f18c:	dc400315 	stw	r17,12(sp)
8112f190:	dc000215 	stw	r16,8(sp)
8112f194:	dfc00b15 	stw	ra,44(sp)
8112f198:	ddc00915 	stw	r23,36(sp)
8112f19c:	dd800815 	stw	r22,32(sp)
8112f1a0:	dd400715 	stw	r21,28(sp)
8112f1a4:	dd000615 	stw	r20,24(sp)
8112f1a8:	dcc00515 	stw	r19,20(sp)
8112f1ac:	dc800415 	stw	r18,16(sp)
8112f1b0:	2021883a 	mov	r16,r4
8112f1b4:	2823883a 	mov	r17,r5
8112f1b8:	2839883a 	mov	fp,r5
8112f1bc:	38003c1e 	bne	r7,zero,8112f2b0 <__umoddi3+0x134>
8112f1c0:	3027883a 	mov	r19,r6
8112f1c4:	2029883a 	mov	r20,r4
8112f1c8:	2980512e 	bgeu	r5,r6,8112f310 <__umoddi3+0x194>
8112f1cc:	00bfffd4 	movui	r2,65535
8112f1d0:	11809a36 	bltu	r2,r6,8112f43c <__umoddi3+0x2c0>
8112f1d4:	01003fc4 	movi	r4,255
8112f1d8:	2189803a 	cmpltu	r4,r4,r6
8112f1dc:	200890fa 	slli	r4,r4,3
8112f1e0:	3104d83a 	srl	r2,r6,r4
8112f1e4:	00e04574 	movhi	r3,33045
8112f1e8:	18ed1b04 	addi	r3,r3,-19348
8112f1ec:	1885883a 	add	r2,r3,r2
8112f1f0:	10c00003 	ldbu	r3,0(r2)
8112f1f4:	00800804 	movi	r2,32
8112f1f8:	1909883a 	add	r4,r3,r4
8112f1fc:	1125c83a 	sub	r18,r2,r4
8112f200:	90000526 	beq	r18,zero,8112f218 <__umoddi3+0x9c>
8112f204:	8ca2983a 	sll	r17,r17,r18
8112f208:	8108d83a 	srl	r4,r16,r4
8112f20c:	34a6983a 	sll	r19,r6,r18
8112f210:	84a8983a 	sll	r20,r16,r18
8112f214:	2478b03a 	or	fp,r4,r17
8112f218:	982ed43a 	srli	r23,r19,16
8112f21c:	e009883a 	mov	r4,fp
8112f220:	9dbfffcc 	andi	r22,r19,65535
8112f224:	b80b883a 	mov	r5,r23
8112f228:	112f8180 	call	8112f818 <__umodsi3>
8112f22c:	e009883a 	mov	r4,fp
8112f230:	b80b883a 	mov	r5,r23
8112f234:	102b883a 	mov	r21,r2
8112f238:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f23c:	a806943a 	slli	r3,r21,16
8112f240:	a008d43a 	srli	r4,r20,16
8112f244:	b085383a 	mul	r2,r22,r2
8112f248:	20c8b03a 	or	r4,r4,r3
8112f24c:	2080032e 	bgeu	r4,r2,8112f25c <__umoddi3+0xe0>
8112f250:	24c9883a 	add	r4,r4,r19
8112f254:	24c00136 	bltu	r4,r19,8112f25c <__umoddi3+0xe0>
8112f258:	20811036 	bltu	r4,r2,8112f69c <__umoddi3+0x520>
8112f25c:	20abc83a 	sub	r21,r4,r2
8112f260:	b80b883a 	mov	r5,r23
8112f264:	a809883a 	mov	r4,r21
8112f268:	112f8180 	call	8112f818 <__umodsi3>
8112f26c:	1023883a 	mov	r17,r2
8112f270:	b80b883a 	mov	r5,r23
8112f274:	a809883a 	mov	r4,r21
8112f278:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f27c:	8822943a 	slli	r17,r17,16
8112f280:	b085383a 	mul	r2,r22,r2
8112f284:	a0ffffcc 	andi	r3,r20,65535
8112f288:	1c46b03a 	or	r3,r3,r17
8112f28c:	1880042e 	bgeu	r3,r2,8112f2a0 <__umoddi3+0x124>
8112f290:	1cc7883a 	add	r3,r3,r19
8112f294:	1cc00236 	bltu	r3,r19,8112f2a0 <__umoddi3+0x124>
8112f298:	1880012e 	bgeu	r3,r2,8112f2a0 <__umoddi3+0x124>
8112f29c:	1cc7883a 	add	r3,r3,r19
8112f2a0:	1885c83a 	sub	r2,r3,r2
8112f2a4:	1484d83a 	srl	r2,r2,r18
8112f2a8:	0007883a 	mov	r3,zero
8112f2ac:	00004f06 	br	8112f3ec <__umoddi3+0x270>
8112f2b0:	29c04c36 	bltu	r5,r7,8112f3e4 <__umoddi3+0x268>
8112f2b4:	00bfffd4 	movui	r2,65535
8112f2b8:	11c0582e 	bgeu	r2,r7,8112f41c <__umoddi3+0x2a0>
8112f2bc:	00804034 	movhi	r2,256
8112f2c0:	10bfffc4 	addi	r2,r2,-1
8112f2c4:	11c0e736 	bltu	r2,r7,8112f664 <__umoddi3+0x4e8>
8112f2c8:	01000404 	movi	r4,16
8112f2cc:	3904d83a 	srl	r2,r7,r4
8112f2d0:	00e04574 	movhi	r3,33045
8112f2d4:	18ed1b04 	addi	r3,r3,-19348
8112f2d8:	1885883a 	add	r2,r3,r2
8112f2dc:	14c00003 	ldbu	r19,0(r2)
8112f2e0:	00c00804 	movi	r3,32
8112f2e4:	9927883a 	add	r19,r19,r4
8112f2e8:	1ce9c83a 	sub	r20,r3,r19
8112f2ec:	a000581e 	bne	r20,zero,8112f450 <__umoddi3+0x2d4>
8112f2f0:	3c400136 	bltu	r7,r17,8112f2f8 <__umoddi3+0x17c>
8112f2f4:	8180eb36 	bltu	r16,r6,8112f6a4 <__umoddi3+0x528>
8112f2f8:	8185c83a 	sub	r2,r16,r6
8112f2fc:	89e3c83a 	sub	r17,r17,r7
8112f300:	8089803a 	cmpltu	r4,r16,r2
8112f304:	8939c83a 	sub	fp,r17,r4
8112f308:	e007883a 	mov	r3,fp
8112f30c:	00003706 	br	8112f3ec <__umoddi3+0x270>
8112f310:	3000041e 	bne	r6,zero,8112f324 <__umoddi3+0x1a8>
8112f314:	000b883a 	mov	r5,zero
8112f318:	01000044 	movi	r4,1
8112f31c:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f320:	1027883a 	mov	r19,r2
8112f324:	00bfffd4 	movui	r2,65535
8112f328:	14c0402e 	bgeu	r2,r19,8112f42c <__umoddi3+0x2b0>
8112f32c:	00804034 	movhi	r2,256
8112f330:	10bfffc4 	addi	r2,r2,-1
8112f334:	14c0cd36 	bltu	r2,r19,8112f66c <__umoddi3+0x4f0>
8112f338:	00800404 	movi	r2,16
8112f33c:	9886d83a 	srl	r3,r19,r2
8112f340:	01204574 	movhi	r4,33045
8112f344:	212d1b04 	addi	r4,r4,-19348
8112f348:	20c7883a 	add	r3,r4,r3
8112f34c:	18c00003 	ldbu	r3,0(r3)
8112f350:	1887883a 	add	r3,r3,r2
8112f354:	00800804 	movi	r2,32
8112f358:	10e5c83a 	sub	r18,r2,r3
8112f35c:	9000901e 	bne	r18,zero,8112f5a0 <__umoddi3+0x424>
8112f360:	982cd43a 	srli	r22,r19,16
8112f364:	8ce3c83a 	sub	r17,r17,r19
8112f368:	9d7fffcc 	andi	r21,r19,65535
8112f36c:	b00b883a 	mov	r5,r22
8112f370:	8809883a 	mov	r4,r17
8112f374:	112f8180 	call	8112f818 <__umodsi3>
8112f378:	8809883a 	mov	r4,r17
8112f37c:	b00b883a 	mov	r5,r22
8112f380:	1021883a 	mov	r16,r2
8112f384:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f388:	8006943a 	slli	r3,r16,16
8112f38c:	a008d43a 	srli	r4,r20,16
8112f390:	1545383a 	mul	r2,r2,r21
8112f394:	20c8b03a 	or	r4,r4,r3
8112f398:	2080042e 	bgeu	r4,r2,8112f3ac <__umoddi3+0x230>
8112f39c:	24c9883a 	add	r4,r4,r19
8112f3a0:	24c00236 	bltu	r4,r19,8112f3ac <__umoddi3+0x230>
8112f3a4:	2080012e 	bgeu	r4,r2,8112f3ac <__umoddi3+0x230>
8112f3a8:	24c9883a 	add	r4,r4,r19
8112f3ac:	20a1c83a 	sub	r16,r4,r2
8112f3b0:	b00b883a 	mov	r5,r22
8112f3b4:	8009883a 	mov	r4,r16
8112f3b8:	112f8180 	call	8112f818 <__umodsi3>
8112f3bc:	1023883a 	mov	r17,r2
8112f3c0:	b00b883a 	mov	r5,r22
8112f3c4:	8009883a 	mov	r4,r16
8112f3c8:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f3cc:	8822943a 	slli	r17,r17,16
8112f3d0:	1545383a 	mul	r2,r2,r21
8112f3d4:	a53fffcc 	andi	r20,r20,65535
8112f3d8:	a446b03a 	or	r3,r20,r17
8112f3dc:	18bfb02e 	bgeu	r3,r2,8112f2a0 <__reset+0xfb10f2a0>
8112f3e0:	003fab06 	br	8112f290 <__reset+0xfb10f290>
8112f3e4:	2005883a 	mov	r2,r4
8112f3e8:	2807883a 	mov	r3,r5
8112f3ec:	dfc00b17 	ldw	ra,44(sp)
8112f3f0:	df000a17 	ldw	fp,40(sp)
8112f3f4:	ddc00917 	ldw	r23,36(sp)
8112f3f8:	dd800817 	ldw	r22,32(sp)
8112f3fc:	dd400717 	ldw	r21,28(sp)
8112f400:	dd000617 	ldw	r20,24(sp)
8112f404:	dcc00517 	ldw	r19,20(sp)
8112f408:	dc800417 	ldw	r18,16(sp)
8112f40c:	dc400317 	ldw	r17,12(sp)
8112f410:	dc000217 	ldw	r16,8(sp)
8112f414:	dec00c04 	addi	sp,sp,48
8112f418:	f800283a 	ret
8112f41c:	04c03fc4 	movi	r19,255
8112f420:	99c9803a 	cmpltu	r4,r19,r7
8112f424:	200890fa 	slli	r4,r4,3
8112f428:	003fa806 	br	8112f2cc <__reset+0xfb10f2cc>
8112f42c:	00803fc4 	movi	r2,255
8112f430:	14c5803a 	cmpltu	r2,r2,r19
8112f434:	100490fa 	slli	r2,r2,3
8112f438:	003fc006 	br	8112f33c <__reset+0xfb10f33c>
8112f43c:	00804034 	movhi	r2,256
8112f440:	10bfffc4 	addi	r2,r2,-1
8112f444:	11808b36 	bltu	r2,r6,8112f674 <__umoddi3+0x4f8>
8112f448:	01000404 	movi	r4,16
8112f44c:	003f6406 	br	8112f1e0 <__reset+0xfb10f1e0>
8112f450:	34c4d83a 	srl	r2,r6,r19
8112f454:	3d0e983a 	sll	r7,r7,r20
8112f458:	8cf8d83a 	srl	fp,r17,r19
8112f45c:	8d10983a 	sll	r8,r17,r20
8112f460:	38aab03a 	or	r21,r7,r2
8112f464:	a82cd43a 	srli	r22,r21,16
8112f468:	84e2d83a 	srl	r17,r16,r19
8112f46c:	e009883a 	mov	r4,fp
8112f470:	b00b883a 	mov	r5,r22
8112f474:	8a22b03a 	or	r17,r17,r8
8112f478:	3524983a 	sll	r18,r6,r20
8112f47c:	112f8180 	call	8112f818 <__umodsi3>
8112f480:	e009883a 	mov	r4,fp
8112f484:	b00b883a 	mov	r5,r22
8112f488:	102f883a 	mov	r23,r2
8112f48c:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f490:	100d883a 	mov	r6,r2
8112f494:	b808943a 	slli	r4,r23,16
8112f498:	aa3fffcc 	andi	r8,r21,65535
8112f49c:	8804d43a 	srli	r2,r17,16
8112f4a0:	41af383a 	mul	r23,r8,r6
8112f4a4:	8520983a 	sll	r16,r16,r20
8112f4a8:	1104b03a 	or	r2,r2,r4
8112f4ac:	15c0042e 	bgeu	r2,r23,8112f4c0 <__umoddi3+0x344>
8112f4b0:	1545883a 	add	r2,r2,r21
8112f4b4:	30ffffc4 	addi	r3,r6,-1
8112f4b8:	1540742e 	bgeu	r2,r21,8112f68c <__umoddi3+0x510>
8112f4bc:	180d883a 	mov	r6,r3
8112f4c0:	15efc83a 	sub	r23,r2,r23
8112f4c4:	b00b883a 	mov	r5,r22
8112f4c8:	b809883a 	mov	r4,r23
8112f4cc:	d9800115 	stw	r6,4(sp)
8112f4d0:	da000015 	stw	r8,0(sp)
8112f4d4:	112f8180 	call	8112f818 <__umodsi3>
8112f4d8:	b00b883a 	mov	r5,r22
8112f4dc:	b809883a 	mov	r4,r23
8112f4e0:	1039883a 	mov	fp,r2
8112f4e4:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f4e8:	da000017 	ldw	r8,0(sp)
8112f4ec:	e038943a 	slli	fp,fp,16
8112f4f0:	100b883a 	mov	r5,r2
8112f4f4:	4089383a 	mul	r4,r8,r2
8112f4f8:	8a3fffcc 	andi	r8,r17,65535
8112f4fc:	4710b03a 	or	r8,r8,fp
8112f500:	d9800117 	ldw	r6,4(sp)
8112f504:	4100042e 	bgeu	r8,r4,8112f518 <__umoddi3+0x39c>
8112f508:	4551883a 	add	r8,r8,r21
8112f50c:	10bfffc4 	addi	r2,r2,-1
8112f510:	45405a2e 	bgeu	r8,r21,8112f67c <__umoddi3+0x500>
8112f514:	100b883a 	mov	r5,r2
8112f518:	300c943a 	slli	r6,r6,16
8112f51c:	91ffffcc 	andi	r7,r18,65535
8112f520:	9004d43a 	srli	r2,r18,16
8112f524:	314cb03a 	or	r6,r6,r5
8112f528:	317fffcc 	andi	r5,r6,65535
8112f52c:	300cd43a 	srli	r6,r6,16
8112f530:	29d3383a 	mul	r9,r5,r7
8112f534:	288b383a 	mul	r5,r5,r2
8112f538:	31cf383a 	mul	r7,r6,r7
8112f53c:	4806d43a 	srli	r3,r9,16
8112f540:	4111c83a 	sub	r8,r8,r4
8112f544:	29cb883a 	add	r5,r5,r7
8112f548:	194b883a 	add	r5,r3,r5
8112f54c:	3085383a 	mul	r2,r6,r2
8112f550:	29c0022e 	bgeu	r5,r7,8112f55c <__umoddi3+0x3e0>
8112f554:	00c00074 	movhi	r3,1
8112f558:	10c5883a 	add	r2,r2,r3
8112f55c:	2808d43a 	srli	r4,r5,16
8112f560:	280a943a 	slli	r5,r5,16
8112f564:	4a7fffcc 	andi	r9,r9,65535
8112f568:	2085883a 	add	r2,r4,r2
8112f56c:	2a4b883a 	add	r5,r5,r9
8112f570:	40803636 	bltu	r8,r2,8112f64c <__umoddi3+0x4d0>
8112f574:	40804d26 	beq	r8,r2,8112f6ac <__umoddi3+0x530>
8112f578:	4089c83a 	sub	r4,r8,r2
8112f57c:	280f883a 	mov	r7,r5
8112f580:	81cfc83a 	sub	r7,r16,r7
8112f584:	81c7803a 	cmpltu	r3,r16,r7
8112f588:	20c7c83a 	sub	r3,r4,r3
8112f58c:	1cc4983a 	sll	r2,r3,r19
8112f590:	3d0ed83a 	srl	r7,r7,r20
8112f594:	1d06d83a 	srl	r3,r3,r20
8112f598:	11c4b03a 	or	r2,r2,r7
8112f59c:	003f9306 	br	8112f3ec <__reset+0xfb10f3ec>
8112f5a0:	9ca6983a 	sll	r19,r19,r18
8112f5a4:	88e8d83a 	srl	r20,r17,r3
8112f5a8:	80c4d83a 	srl	r2,r16,r3
8112f5ac:	982cd43a 	srli	r22,r19,16
8112f5b0:	8ca2983a 	sll	r17,r17,r18
8112f5b4:	a009883a 	mov	r4,r20
8112f5b8:	b00b883a 	mov	r5,r22
8112f5bc:	1478b03a 	or	fp,r2,r17
8112f5c0:	112f8180 	call	8112f818 <__umodsi3>
8112f5c4:	a009883a 	mov	r4,r20
8112f5c8:	b00b883a 	mov	r5,r22
8112f5cc:	1023883a 	mov	r17,r2
8112f5d0:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f5d4:	9d7fffcc 	andi	r21,r19,65535
8112f5d8:	880a943a 	slli	r5,r17,16
8112f5dc:	e008d43a 	srli	r4,fp,16
8112f5e0:	a885383a 	mul	r2,r21,r2
8112f5e4:	84a8983a 	sll	r20,r16,r18
8112f5e8:	2148b03a 	or	r4,r4,r5
8112f5ec:	2080042e 	bgeu	r4,r2,8112f600 <__umoddi3+0x484>
8112f5f0:	24c9883a 	add	r4,r4,r19
8112f5f4:	24c00236 	bltu	r4,r19,8112f600 <__umoddi3+0x484>
8112f5f8:	2080012e 	bgeu	r4,r2,8112f600 <__umoddi3+0x484>
8112f5fc:	24c9883a 	add	r4,r4,r19
8112f600:	20a3c83a 	sub	r17,r4,r2
8112f604:	b00b883a 	mov	r5,r22
8112f608:	8809883a 	mov	r4,r17
8112f60c:	112f8180 	call	8112f818 <__umodsi3>
8112f610:	102f883a 	mov	r23,r2
8112f614:	8809883a 	mov	r4,r17
8112f618:	b00b883a 	mov	r5,r22
8112f61c:	112f7b40 	call	8112f7b4 <__udivsi3>
8112f620:	b82e943a 	slli	r23,r23,16
8112f624:	a885383a 	mul	r2,r21,r2
8112f628:	e13fffcc 	andi	r4,fp,65535
8112f62c:	25c8b03a 	or	r4,r4,r23
8112f630:	2080042e 	bgeu	r4,r2,8112f644 <__umoddi3+0x4c8>
8112f634:	24c9883a 	add	r4,r4,r19
8112f638:	24c00236 	bltu	r4,r19,8112f644 <__umoddi3+0x4c8>
8112f63c:	2080012e 	bgeu	r4,r2,8112f644 <__umoddi3+0x4c8>
8112f640:	24c9883a 	add	r4,r4,r19
8112f644:	20a3c83a 	sub	r17,r4,r2
8112f648:	003f4806 	br	8112f36c <__reset+0xfb10f36c>
8112f64c:	2c8fc83a 	sub	r7,r5,r18
8112f650:	1545c83a 	sub	r2,r2,r21
8112f654:	29cb803a 	cmpltu	r5,r5,r7
8112f658:	1145c83a 	sub	r2,r2,r5
8112f65c:	4089c83a 	sub	r4,r8,r2
8112f660:	003fc706 	br	8112f580 <__reset+0xfb10f580>
8112f664:	01000604 	movi	r4,24
8112f668:	003f1806 	br	8112f2cc <__reset+0xfb10f2cc>
8112f66c:	00800604 	movi	r2,24
8112f670:	003f3206 	br	8112f33c <__reset+0xfb10f33c>
8112f674:	01000604 	movi	r4,24
8112f678:	003ed906 	br	8112f1e0 <__reset+0xfb10f1e0>
8112f67c:	413fa52e 	bgeu	r8,r4,8112f514 <__reset+0xfb10f514>
8112f680:	297fff84 	addi	r5,r5,-2
8112f684:	4551883a 	add	r8,r8,r21
8112f688:	003fa306 	br	8112f518 <__reset+0xfb10f518>
8112f68c:	15ff8b2e 	bgeu	r2,r23,8112f4bc <__reset+0xfb10f4bc>
8112f690:	31bfff84 	addi	r6,r6,-2
8112f694:	1545883a 	add	r2,r2,r21
8112f698:	003f8906 	br	8112f4c0 <__reset+0xfb10f4c0>
8112f69c:	24c9883a 	add	r4,r4,r19
8112f6a0:	003eee06 	br	8112f25c <__reset+0xfb10f25c>
8112f6a4:	8005883a 	mov	r2,r16
8112f6a8:	003f1706 	br	8112f308 <__reset+0xfb10f308>
8112f6ac:	817fe736 	bltu	r16,r5,8112f64c <__reset+0xfb10f64c>
8112f6b0:	280f883a 	mov	r7,r5
8112f6b4:	0009883a 	mov	r4,zero
8112f6b8:	003fb106 	br	8112f580 <__reset+0xfb10f580>

8112f6bc <__divsi3>:
8112f6bc:	20001b16 	blt	r4,zero,8112f72c <__divsi3+0x70>
8112f6c0:	000f883a 	mov	r7,zero
8112f6c4:	28001616 	blt	r5,zero,8112f720 <__divsi3+0x64>
8112f6c8:	200d883a 	mov	r6,r4
8112f6cc:	29001a2e 	bgeu	r5,r4,8112f738 <__divsi3+0x7c>
8112f6d0:	00800804 	movi	r2,32
8112f6d4:	00c00044 	movi	r3,1
8112f6d8:	00000106 	br	8112f6e0 <__divsi3+0x24>
8112f6dc:	10000d26 	beq	r2,zero,8112f714 <__divsi3+0x58>
8112f6e0:	294b883a 	add	r5,r5,r5
8112f6e4:	10bfffc4 	addi	r2,r2,-1
8112f6e8:	18c7883a 	add	r3,r3,r3
8112f6ec:	293ffb36 	bltu	r5,r4,8112f6dc <__reset+0xfb10f6dc>
8112f6f0:	0005883a 	mov	r2,zero
8112f6f4:	18000726 	beq	r3,zero,8112f714 <__divsi3+0x58>
8112f6f8:	0005883a 	mov	r2,zero
8112f6fc:	31400236 	bltu	r6,r5,8112f708 <__divsi3+0x4c>
8112f700:	314dc83a 	sub	r6,r6,r5
8112f704:	10c4b03a 	or	r2,r2,r3
8112f708:	1806d07a 	srli	r3,r3,1
8112f70c:	280ad07a 	srli	r5,r5,1
8112f710:	183ffa1e 	bne	r3,zero,8112f6fc <__reset+0xfb10f6fc>
8112f714:	38000126 	beq	r7,zero,8112f71c <__divsi3+0x60>
8112f718:	0085c83a 	sub	r2,zero,r2
8112f71c:	f800283a 	ret
8112f720:	014bc83a 	sub	r5,zero,r5
8112f724:	39c0005c 	xori	r7,r7,1
8112f728:	003fe706 	br	8112f6c8 <__reset+0xfb10f6c8>
8112f72c:	0109c83a 	sub	r4,zero,r4
8112f730:	01c00044 	movi	r7,1
8112f734:	003fe306 	br	8112f6c4 <__reset+0xfb10f6c4>
8112f738:	00c00044 	movi	r3,1
8112f73c:	003fee06 	br	8112f6f8 <__reset+0xfb10f6f8>

8112f740 <__modsi3>:
8112f740:	20001716 	blt	r4,zero,8112f7a0 <__modsi3+0x60>
8112f744:	000f883a 	mov	r7,zero
8112f748:	2005883a 	mov	r2,r4
8112f74c:	28001216 	blt	r5,zero,8112f798 <__modsi3+0x58>
8112f750:	2900162e 	bgeu	r5,r4,8112f7ac <__modsi3+0x6c>
8112f754:	01800804 	movi	r6,32
8112f758:	00c00044 	movi	r3,1
8112f75c:	00000106 	br	8112f764 <__modsi3+0x24>
8112f760:	30000a26 	beq	r6,zero,8112f78c <__modsi3+0x4c>
8112f764:	294b883a 	add	r5,r5,r5
8112f768:	31bfffc4 	addi	r6,r6,-1
8112f76c:	18c7883a 	add	r3,r3,r3
8112f770:	293ffb36 	bltu	r5,r4,8112f760 <__reset+0xfb10f760>
8112f774:	18000526 	beq	r3,zero,8112f78c <__modsi3+0x4c>
8112f778:	1806d07a 	srli	r3,r3,1
8112f77c:	11400136 	bltu	r2,r5,8112f784 <__modsi3+0x44>
8112f780:	1145c83a 	sub	r2,r2,r5
8112f784:	280ad07a 	srli	r5,r5,1
8112f788:	183ffb1e 	bne	r3,zero,8112f778 <__reset+0xfb10f778>
8112f78c:	38000126 	beq	r7,zero,8112f794 <__modsi3+0x54>
8112f790:	0085c83a 	sub	r2,zero,r2
8112f794:	f800283a 	ret
8112f798:	014bc83a 	sub	r5,zero,r5
8112f79c:	003fec06 	br	8112f750 <__reset+0xfb10f750>
8112f7a0:	0109c83a 	sub	r4,zero,r4
8112f7a4:	01c00044 	movi	r7,1
8112f7a8:	003fe706 	br	8112f748 <__reset+0xfb10f748>
8112f7ac:	00c00044 	movi	r3,1
8112f7b0:	003ff106 	br	8112f778 <__reset+0xfb10f778>

8112f7b4 <__udivsi3>:
8112f7b4:	200d883a 	mov	r6,r4
8112f7b8:	2900152e 	bgeu	r5,r4,8112f810 <__udivsi3+0x5c>
8112f7bc:	28001416 	blt	r5,zero,8112f810 <__udivsi3+0x5c>
8112f7c0:	00800804 	movi	r2,32
8112f7c4:	00c00044 	movi	r3,1
8112f7c8:	00000206 	br	8112f7d4 <__udivsi3+0x20>
8112f7cc:	10000e26 	beq	r2,zero,8112f808 <__udivsi3+0x54>
8112f7d0:	28000516 	blt	r5,zero,8112f7e8 <__udivsi3+0x34>
8112f7d4:	294b883a 	add	r5,r5,r5
8112f7d8:	10bfffc4 	addi	r2,r2,-1
8112f7dc:	18c7883a 	add	r3,r3,r3
8112f7e0:	293ffa36 	bltu	r5,r4,8112f7cc <__reset+0xfb10f7cc>
8112f7e4:	18000826 	beq	r3,zero,8112f808 <__udivsi3+0x54>
8112f7e8:	0005883a 	mov	r2,zero
8112f7ec:	31400236 	bltu	r6,r5,8112f7f8 <__udivsi3+0x44>
8112f7f0:	314dc83a 	sub	r6,r6,r5
8112f7f4:	10c4b03a 	or	r2,r2,r3
8112f7f8:	1806d07a 	srli	r3,r3,1
8112f7fc:	280ad07a 	srli	r5,r5,1
8112f800:	183ffa1e 	bne	r3,zero,8112f7ec <__reset+0xfb10f7ec>
8112f804:	f800283a 	ret
8112f808:	0005883a 	mov	r2,zero
8112f80c:	f800283a 	ret
8112f810:	00c00044 	movi	r3,1
8112f814:	003ff406 	br	8112f7e8 <__reset+0xfb10f7e8>

8112f818 <__umodsi3>:
8112f818:	2005883a 	mov	r2,r4
8112f81c:	2900122e 	bgeu	r5,r4,8112f868 <__umodsi3+0x50>
8112f820:	28001116 	blt	r5,zero,8112f868 <__umodsi3+0x50>
8112f824:	01800804 	movi	r6,32
8112f828:	00c00044 	movi	r3,1
8112f82c:	00000206 	br	8112f838 <__umodsi3+0x20>
8112f830:	30000c26 	beq	r6,zero,8112f864 <__umodsi3+0x4c>
8112f834:	28000516 	blt	r5,zero,8112f84c <__umodsi3+0x34>
8112f838:	294b883a 	add	r5,r5,r5
8112f83c:	31bfffc4 	addi	r6,r6,-1
8112f840:	18c7883a 	add	r3,r3,r3
8112f844:	293ffa36 	bltu	r5,r4,8112f830 <__reset+0xfb10f830>
8112f848:	18000626 	beq	r3,zero,8112f864 <__umodsi3+0x4c>
8112f84c:	1806d07a 	srli	r3,r3,1
8112f850:	11400136 	bltu	r2,r5,8112f858 <__umodsi3+0x40>
8112f854:	1145c83a 	sub	r2,r2,r5
8112f858:	280ad07a 	srli	r5,r5,1
8112f85c:	183ffb1e 	bne	r3,zero,8112f84c <__reset+0xfb10f84c>
8112f860:	f800283a 	ret
8112f864:	f800283a 	ret
8112f868:	00c00044 	movi	r3,1
8112f86c:	003ff706 	br	8112f84c <__reset+0xfb10f84c>

8112f870 <__eqsf2>:
8112f870:	2006d5fa 	srli	r3,r4,23
8112f874:	280cd5fa 	srli	r6,r5,23
8112f878:	01c02034 	movhi	r7,128
8112f87c:	39ffffc4 	addi	r7,r7,-1
8112f880:	18c03fcc 	andi	r3,r3,255
8112f884:	02003fc4 	movi	r8,255
8112f888:	3904703a 	and	r2,r7,r4
8112f88c:	31803fcc 	andi	r6,r6,255
8112f890:	394e703a 	and	r7,r7,r5
8112f894:	2008d7fa 	srli	r4,r4,31
8112f898:	280ad7fa 	srli	r5,r5,31
8112f89c:	1a000d26 	beq	r3,r8,8112f8d4 <__eqsf2+0x64>
8112f8a0:	02003fc4 	movi	r8,255
8112f8a4:	32000826 	beq	r6,r8,8112f8c8 <__eqsf2+0x58>
8112f8a8:	19800226 	beq	r3,r6,8112f8b4 <__eqsf2+0x44>
8112f8ac:	00800044 	movi	r2,1
8112f8b0:	f800283a 	ret
8112f8b4:	11fffd1e 	bne	r2,r7,8112f8ac <__reset+0xfb10f8ac>
8112f8b8:	21400926 	beq	r4,r5,8112f8e0 <__eqsf2+0x70>
8112f8bc:	183ffb1e 	bne	r3,zero,8112f8ac <__reset+0xfb10f8ac>
8112f8c0:	1004c03a 	cmpne	r2,r2,zero
8112f8c4:	f800283a 	ret
8112f8c8:	383ff726 	beq	r7,zero,8112f8a8 <__reset+0xfb10f8a8>
8112f8cc:	00800044 	movi	r2,1
8112f8d0:	f800283a 	ret
8112f8d4:	103ff226 	beq	r2,zero,8112f8a0 <__reset+0xfb10f8a0>
8112f8d8:	00800044 	movi	r2,1
8112f8dc:	f800283a 	ret
8112f8e0:	0005883a 	mov	r2,zero
8112f8e4:	f800283a 	ret

8112f8e8 <__gesf2>:
8112f8e8:	2004d5fa 	srli	r2,r4,23
8112f8ec:	2806d5fa 	srli	r3,r5,23
8112f8f0:	01802034 	movhi	r6,128
8112f8f4:	31bfffc4 	addi	r6,r6,-1
8112f8f8:	10803fcc 	andi	r2,r2,255
8112f8fc:	01c03fc4 	movi	r7,255
8112f900:	3110703a 	and	r8,r6,r4
8112f904:	18c03fcc 	andi	r3,r3,255
8112f908:	314c703a 	and	r6,r6,r5
8112f90c:	2008d7fa 	srli	r4,r4,31
8112f910:	280ad7fa 	srli	r5,r5,31
8112f914:	11c01926 	beq	r2,r7,8112f97c <__gesf2+0x94>
8112f918:	01c03fc4 	movi	r7,255
8112f91c:	19c00f26 	beq	r3,r7,8112f95c <__gesf2+0x74>
8112f920:	1000061e 	bne	r2,zero,8112f93c <__gesf2+0x54>
8112f924:	400f003a 	cmpeq	r7,r8,zero
8112f928:	1800071e 	bne	r3,zero,8112f948 <__gesf2+0x60>
8112f92c:	3000061e 	bne	r6,zero,8112f948 <__gesf2+0x60>
8112f930:	0005883a 	mov	r2,zero
8112f934:	40000e1e 	bne	r8,zero,8112f970 <__gesf2+0x88>
8112f938:	f800283a 	ret
8112f93c:	18000a1e 	bne	r3,zero,8112f968 <__gesf2+0x80>
8112f940:	30000b26 	beq	r6,zero,8112f970 <__gesf2+0x88>
8112f944:	000f883a 	mov	r7,zero
8112f948:	29403fcc 	andi	r5,r5,255
8112f94c:	38000726 	beq	r7,zero,8112f96c <__gesf2+0x84>
8112f950:	28000826 	beq	r5,zero,8112f974 <__gesf2+0x8c>
8112f954:	00800044 	movi	r2,1
8112f958:	f800283a 	ret
8112f95c:	303ff026 	beq	r6,zero,8112f920 <__reset+0xfb10f920>
8112f960:	00bfff84 	movi	r2,-2
8112f964:	f800283a 	ret
8112f968:	29403fcc 	andi	r5,r5,255
8112f96c:	21400526 	beq	r4,r5,8112f984 <__gesf2+0x9c>
8112f970:	203ff826 	beq	r4,zero,8112f954 <__reset+0xfb10f954>
8112f974:	00bfffc4 	movi	r2,-1
8112f978:	f800283a 	ret
8112f97c:	403fe626 	beq	r8,zero,8112f918 <__reset+0xfb10f918>
8112f980:	003ff706 	br	8112f960 <__reset+0xfb10f960>
8112f984:	18bffa16 	blt	r3,r2,8112f970 <__reset+0xfb10f970>
8112f988:	10c00216 	blt	r2,r3,8112f994 <__gesf2+0xac>
8112f98c:	323ff836 	bltu	r6,r8,8112f970 <__reset+0xfb10f970>
8112f990:	4180022e 	bgeu	r8,r6,8112f99c <__gesf2+0xb4>
8112f994:	203fef1e 	bne	r4,zero,8112f954 <__reset+0xfb10f954>
8112f998:	003ff606 	br	8112f974 <__reset+0xfb10f974>
8112f99c:	0005883a 	mov	r2,zero
8112f9a0:	f800283a 	ret

8112f9a4 <__lesf2>:
8112f9a4:	2004d5fa 	srli	r2,r4,23
8112f9a8:	280cd5fa 	srli	r6,r5,23
8112f9ac:	00c02034 	movhi	r3,128
8112f9b0:	18ffffc4 	addi	r3,r3,-1
8112f9b4:	10803fcc 	andi	r2,r2,255
8112f9b8:	01c03fc4 	movi	r7,255
8112f9bc:	1910703a 	and	r8,r3,r4
8112f9c0:	31803fcc 	andi	r6,r6,255
8112f9c4:	1946703a 	and	r3,r3,r5
8112f9c8:	2008d7fa 	srli	r4,r4,31
8112f9cc:	280ad7fa 	srli	r5,r5,31
8112f9d0:	11c01b26 	beq	r2,r7,8112fa40 <__lesf2+0x9c>
8112f9d4:	01c03fc4 	movi	r7,255
8112f9d8:	31c01126 	beq	r6,r7,8112fa20 <__lesf2+0x7c>
8112f9dc:	1000071e 	bne	r2,zero,8112f9fc <__lesf2+0x58>
8112f9e0:	400f003a 	cmpeq	r7,r8,zero
8112f9e4:	21003fcc 	andi	r4,r4,255
8112f9e8:	3000081e 	bne	r6,zero,8112fa0c <__lesf2+0x68>
8112f9ec:	1800071e 	bne	r3,zero,8112fa0c <__lesf2+0x68>
8112f9f0:	0005883a 	mov	r2,zero
8112f9f4:	40000f1e 	bne	r8,zero,8112fa34 <__lesf2+0x90>
8112f9f8:	f800283a 	ret
8112f9fc:	21003fcc 	andi	r4,r4,255
8112fa00:	30000a1e 	bne	r6,zero,8112fa2c <__lesf2+0x88>
8112fa04:	18000b26 	beq	r3,zero,8112fa34 <__lesf2+0x90>
8112fa08:	000f883a 	mov	r7,zero
8112fa0c:	29403fcc 	andi	r5,r5,255
8112fa10:	38000726 	beq	r7,zero,8112fa30 <__lesf2+0x8c>
8112fa14:	28000826 	beq	r5,zero,8112fa38 <__lesf2+0x94>
8112fa18:	00800044 	movi	r2,1
8112fa1c:	f800283a 	ret
8112fa20:	183fee26 	beq	r3,zero,8112f9dc <__reset+0xfb10f9dc>
8112fa24:	00800084 	movi	r2,2
8112fa28:	f800283a 	ret
8112fa2c:	29403fcc 	andi	r5,r5,255
8112fa30:	21400626 	beq	r4,r5,8112fa4c <__lesf2+0xa8>
8112fa34:	203ff826 	beq	r4,zero,8112fa18 <__reset+0xfb10fa18>
8112fa38:	00bfffc4 	movi	r2,-1
8112fa3c:	f800283a 	ret
8112fa40:	403fe426 	beq	r8,zero,8112f9d4 <__reset+0xfb10f9d4>
8112fa44:	00800084 	movi	r2,2
8112fa48:	f800283a 	ret
8112fa4c:	30bff916 	blt	r6,r2,8112fa34 <__reset+0xfb10fa34>
8112fa50:	11800216 	blt	r2,r6,8112fa5c <__lesf2+0xb8>
8112fa54:	1a3ff736 	bltu	r3,r8,8112fa34 <__reset+0xfb10fa34>
8112fa58:	40c0022e 	bgeu	r8,r3,8112fa64 <__lesf2+0xc0>
8112fa5c:	203fee1e 	bne	r4,zero,8112fa18 <__reset+0xfb10fa18>
8112fa60:	003ff506 	br	8112fa38 <__reset+0xfb10fa38>
8112fa64:	0005883a 	mov	r2,zero
8112fa68:	f800283a 	ret

8112fa6c <__adddf3>:
8112fa6c:	02c00434 	movhi	r11,16
8112fa70:	5affffc4 	addi	r11,r11,-1
8112fa74:	2806d7fa 	srli	r3,r5,31
8112fa78:	2ad4703a 	and	r10,r5,r11
8112fa7c:	3ad2703a 	and	r9,r7,r11
8112fa80:	3804d53a 	srli	r2,r7,20
8112fa84:	3018d77a 	srli	r12,r6,29
8112fa88:	280ad53a 	srli	r5,r5,20
8112fa8c:	501490fa 	slli	r10,r10,3
8112fa90:	2010d77a 	srli	r8,r4,29
8112fa94:	481290fa 	slli	r9,r9,3
8112fa98:	380ed7fa 	srli	r7,r7,31
8112fa9c:	defffb04 	addi	sp,sp,-20
8112faa0:	de00012e 	bgeu	sp,et,8112faa8 <__adddf3+0x3c>
8112faa4:	003b68fa 	trap	3
8112faa8:	dc800215 	stw	r18,8(sp)
8112faac:	dc400115 	stw	r17,4(sp)
8112fab0:	dc000015 	stw	r16,0(sp)
8112fab4:	dfc00415 	stw	ra,16(sp)
8112fab8:	dcc00315 	stw	r19,12(sp)
8112fabc:	1c803fcc 	andi	r18,r3,255
8112fac0:	2c01ffcc 	andi	r16,r5,2047
8112fac4:	5210b03a 	or	r8,r10,r8
8112fac8:	202290fa 	slli	r17,r4,3
8112facc:	1081ffcc 	andi	r2,r2,2047
8112fad0:	4b12b03a 	or	r9,r9,r12
8112fad4:	300c90fa 	slli	r6,r6,3
8112fad8:	91c07526 	beq	r18,r7,8112fcb0 <__adddf3+0x244>
8112fadc:	8087c83a 	sub	r3,r16,r2
8112fae0:	00c0ab0e 	bge	zero,r3,8112fd90 <__adddf3+0x324>
8112fae4:	10002a1e 	bne	r2,zero,8112fb90 <__adddf3+0x124>
8112fae8:	4984b03a 	or	r2,r9,r6
8112faec:	1000961e 	bne	r2,zero,8112fd48 <__adddf3+0x2dc>
8112faf0:	888001cc 	andi	r2,r17,7
8112faf4:	10000726 	beq	r2,zero,8112fb14 <__adddf3+0xa8>
8112faf8:	888003cc 	andi	r2,r17,15
8112fafc:	00c00104 	movi	r3,4
8112fb00:	10c00426 	beq	r2,r3,8112fb14 <__adddf3+0xa8>
8112fb04:	88c7883a 	add	r3,r17,r3
8112fb08:	1c63803a 	cmpltu	r17,r3,r17
8112fb0c:	4451883a 	add	r8,r8,r17
8112fb10:	1823883a 	mov	r17,r3
8112fb14:	4080202c 	andhi	r2,r8,128
8112fb18:	10005926 	beq	r2,zero,8112fc80 <__adddf3+0x214>
8112fb1c:	84000044 	addi	r16,r16,1
8112fb20:	0081ffc4 	movi	r2,2047
8112fb24:	8080ba26 	beq	r16,r2,8112fe10 <__adddf3+0x3a4>
8112fb28:	00bfe034 	movhi	r2,65408
8112fb2c:	10bfffc4 	addi	r2,r2,-1
8112fb30:	4090703a 	and	r8,r8,r2
8112fb34:	4004977a 	slli	r2,r8,29
8112fb38:	4010927a 	slli	r8,r8,9
8112fb3c:	8822d0fa 	srli	r17,r17,3
8112fb40:	8401ffcc 	andi	r16,r16,2047
8112fb44:	4010d33a 	srli	r8,r8,12
8112fb48:	9007883a 	mov	r3,r18
8112fb4c:	1444b03a 	or	r2,r2,r17
8112fb50:	8401ffcc 	andi	r16,r16,2047
8112fb54:	8020953a 	slli	r16,r16,20
8112fb58:	18c03fcc 	andi	r3,r3,255
8112fb5c:	01000434 	movhi	r4,16
8112fb60:	213fffc4 	addi	r4,r4,-1
8112fb64:	180697fa 	slli	r3,r3,31
8112fb68:	4110703a 	and	r8,r8,r4
8112fb6c:	4410b03a 	or	r8,r8,r16
8112fb70:	40c6b03a 	or	r3,r8,r3
8112fb74:	dfc00417 	ldw	ra,16(sp)
8112fb78:	dcc00317 	ldw	r19,12(sp)
8112fb7c:	dc800217 	ldw	r18,8(sp)
8112fb80:	dc400117 	ldw	r17,4(sp)
8112fb84:	dc000017 	ldw	r16,0(sp)
8112fb88:	dec00504 	addi	sp,sp,20
8112fb8c:	f800283a 	ret
8112fb90:	0081ffc4 	movi	r2,2047
8112fb94:	80bfd626 	beq	r16,r2,8112faf0 <__reset+0xfb10faf0>
8112fb98:	4a402034 	orhi	r9,r9,128
8112fb9c:	00800e04 	movi	r2,56
8112fba0:	10c09f16 	blt	r2,r3,8112fe20 <__adddf3+0x3b4>
8112fba4:	008007c4 	movi	r2,31
8112fba8:	10c0c216 	blt	r2,r3,8112feb4 <__adddf3+0x448>
8112fbac:	00800804 	movi	r2,32
8112fbb0:	10c5c83a 	sub	r2,r2,r3
8112fbb4:	488a983a 	sll	r5,r9,r2
8112fbb8:	30c8d83a 	srl	r4,r6,r3
8112fbbc:	3084983a 	sll	r2,r6,r2
8112fbc0:	48c6d83a 	srl	r3,r9,r3
8112fbc4:	290cb03a 	or	r6,r5,r4
8112fbc8:	1004c03a 	cmpne	r2,r2,zero
8112fbcc:	308cb03a 	or	r6,r6,r2
8112fbd0:	898dc83a 	sub	r6,r17,r6
8112fbd4:	89a3803a 	cmpltu	r17,r17,r6
8112fbd8:	40d1c83a 	sub	r8,r8,r3
8112fbdc:	4451c83a 	sub	r8,r8,r17
8112fbe0:	3023883a 	mov	r17,r6
8112fbe4:	4080202c 	andhi	r2,r8,128
8112fbe8:	10002326 	beq	r2,zero,8112fc78 <__adddf3+0x20c>
8112fbec:	04c02034 	movhi	r19,128
8112fbf0:	9cffffc4 	addi	r19,r19,-1
8112fbf4:	44e6703a 	and	r19,r8,r19
8112fbf8:	98007626 	beq	r19,zero,8112fdd4 <__adddf3+0x368>
8112fbfc:	9809883a 	mov	r4,r19
8112fc00:	111bf5c0 	call	8111bf5c <__clzsi2>
8112fc04:	10fffe04 	addi	r3,r2,-8
8112fc08:	010007c4 	movi	r4,31
8112fc0c:	20c07716 	blt	r4,r3,8112fdec <__adddf3+0x380>
8112fc10:	00800804 	movi	r2,32
8112fc14:	10c5c83a 	sub	r2,r2,r3
8112fc18:	8884d83a 	srl	r2,r17,r2
8112fc1c:	98d0983a 	sll	r8,r19,r3
8112fc20:	88e2983a 	sll	r17,r17,r3
8112fc24:	1204b03a 	or	r2,r2,r8
8112fc28:	1c007416 	blt	r3,r16,8112fdfc <__adddf3+0x390>
8112fc2c:	1c21c83a 	sub	r16,r3,r16
8112fc30:	82000044 	addi	r8,r16,1
8112fc34:	00c007c4 	movi	r3,31
8112fc38:	1a009116 	blt	r3,r8,8112fe80 <__adddf3+0x414>
8112fc3c:	00c00804 	movi	r3,32
8112fc40:	1a07c83a 	sub	r3,r3,r8
8112fc44:	8a08d83a 	srl	r4,r17,r8
8112fc48:	88e2983a 	sll	r17,r17,r3
8112fc4c:	10c6983a 	sll	r3,r2,r3
8112fc50:	1210d83a 	srl	r8,r2,r8
8112fc54:	8804c03a 	cmpne	r2,r17,zero
8112fc58:	1906b03a 	or	r3,r3,r4
8112fc5c:	18a2b03a 	or	r17,r3,r2
8112fc60:	0021883a 	mov	r16,zero
8112fc64:	003fa206 	br	8112faf0 <__reset+0xfb10faf0>
8112fc68:	1890b03a 	or	r8,r3,r2
8112fc6c:	40017d26 	beq	r8,zero,81130264 <__adddf3+0x7f8>
8112fc70:	1011883a 	mov	r8,r2
8112fc74:	1823883a 	mov	r17,r3
8112fc78:	888001cc 	andi	r2,r17,7
8112fc7c:	103f9e1e 	bne	r2,zero,8112faf8 <__reset+0xfb10faf8>
8112fc80:	4004977a 	slli	r2,r8,29
8112fc84:	8822d0fa 	srli	r17,r17,3
8112fc88:	4010d0fa 	srli	r8,r8,3
8112fc8c:	9007883a 	mov	r3,r18
8112fc90:	1444b03a 	or	r2,r2,r17
8112fc94:	0101ffc4 	movi	r4,2047
8112fc98:	81002426 	beq	r16,r4,8112fd2c <__adddf3+0x2c0>
8112fc9c:	8120703a 	and	r16,r16,r4
8112fca0:	01000434 	movhi	r4,16
8112fca4:	213fffc4 	addi	r4,r4,-1
8112fca8:	4110703a 	and	r8,r8,r4
8112fcac:	003fa806 	br	8112fb50 <__reset+0xfb10fb50>
8112fcb0:	8089c83a 	sub	r4,r16,r2
8112fcb4:	01005e0e 	bge	zero,r4,8112fe30 <__adddf3+0x3c4>
8112fcb8:	10002b26 	beq	r2,zero,8112fd68 <__adddf3+0x2fc>
8112fcbc:	0081ffc4 	movi	r2,2047
8112fcc0:	80bf8b26 	beq	r16,r2,8112faf0 <__reset+0xfb10faf0>
8112fcc4:	4a402034 	orhi	r9,r9,128
8112fcc8:	00800e04 	movi	r2,56
8112fccc:	1100a40e 	bge	r2,r4,8112ff60 <__adddf3+0x4f4>
8112fcd0:	498cb03a 	or	r6,r9,r6
8112fcd4:	300ac03a 	cmpne	r5,r6,zero
8112fcd8:	0013883a 	mov	r9,zero
8112fcdc:	2c4b883a 	add	r5,r5,r17
8112fce0:	2c63803a 	cmpltu	r17,r5,r17
8112fce4:	4a11883a 	add	r8,r9,r8
8112fce8:	8a11883a 	add	r8,r17,r8
8112fcec:	2823883a 	mov	r17,r5
8112fcf0:	4080202c 	andhi	r2,r8,128
8112fcf4:	103fe026 	beq	r2,zero,8112fc78 <__reset+0xfb10fc78>
8112fcf8:	84000044 	addi	r16,r16,1
8112fcfc:	0081ffc4 	movi	r2,2047
8112fd00:	8080d226 	beq	r16,r2,8113004c <__adddf3+0x5e0>
8112fd04:	00bfe034 	movhi	r2,65408
8112fd08:	10bfffc4 	addi	r2,r2,-1
8112fd0c:	4090703a 	and	r8,r8,r2
8112fd10:	880ad07a 	srli	r5,r17,1
8112fd14:	400897fa 	slli	r4,r8,31
8112fd18:	88c0004c 	andi	r3,r17,1
8112fd1c:	28e2b03a 	or	r17,r5,r3
8112fd20:	4010d07a 	srli	r8,r8,1
8112fd24:	2462b03a 	or	r17,r4,r17
8112fd28:	003f7106 	br	8112faf0 <__reset+0xfb10faf0>
8112fd2c:	4088b03a 	or	r4,r8,r2
8112fd30:	20014526 	beq	r4,zero,81130248 <__adddf3+0x7dc>
8112fd34:	01000434 	movhi	r4,16
8112fd38:	42000234 	orhi	r8,r8,8
8112fd3c:	213fffc4 	addi	r4,r4,-1
8112fd40:	4110703a 	and	r8,r8,r4
8112fd44:	003f8206 	br	8112fb50 <__reset+0xfb10fb50>
8112fd48:	18ffffc4 	addi	r3,r3,-1
8112fd4c:	1800491e 	bne	r3,zero,8112fe74 <__adddf3+0x408>
8112fd50:	898bc83a 	sub	r5,r17,r6
8112fd54:	8963803a 	cmpltu	r17,r17,r5
8112fd58:	4251c83a 	sub	r8,r8,r9
8112fd5c:	4451c83a 	sub	r8,r8,r17
8112fd60:	2823883a 	mov	r17,r5
8112fd64:	003f9f06 	br	8112fbe4 <__reset+0xfb10fbe4>
8112fd68:	4984b03a 	or	r2,r9,r6
8112fd6c:	103f6026 	beq	r2,zero,8112faf0 <__reset+0xfb10faf0>
8112fd70:	213fffc4 	addi	r4,r4,-1
8112fd74:	2000931e 	bne	r4,zero,8112ffc4 <__adddf3+0x558>
8112fd78:	898d883a 	add	r6,r17,r6
8112fd7c:	3463803a 	cmpltu	r17,r6,r17
8112fd80:	4251883a 	add	r8,r8,r9
8112fd84:	8a11883a 	add	r8,r17,r8
8112fd88:	3023883a 	mov	r17,r6
8112fd8c:	003fd806 	br	8112fcf0 <__reset+0xfb10fcf0>
8112fd90:	1800541e 	bne	r3,zero,8112fee4 <__adddf3+0x478>
8112fd94:	80800044 	addi	r2,r16,1
8112fd98:	1081ffcc 	andi	r2,r2,2047
8112fd9c:	00c00044 	movi	r3,1
8112fda0:	1880a00e 	bge	r3,r2,81130024 <__adddf3+0x5b8>
8112fda4:	8989c83a 	sub	r4,r17,r6
8112fda8:	8905803a 	cmpltu	r2,r17,r4
8112fdac:	4267c83a 	sub	r19,r8,r9
8112fdb0:	98a7c83a 	sub	r19,r19,r2
8112fdb4:	9880202c 	andhi	r2,r19,128
8112fdb8:	10006326 	beq	r2,zero,8112ff48 <__adddf3+0x4dc>
8112fdbc:	3463c83a 	sub	r17,r6,r17
8112fdc0:	4a07c83a 	sub	r3,r9,r8
8112fdc4:	344d803a 	cmpltu	r6,r6,r17
8112fdc8:	19a7c83a 	sub	r19,r3,r6
8112fdcc:	3825883a 	mov	r18,r7
8112fdd0:	983f8a1e 	bne	r19,zero,8112fbfc <__reset+0xfb10fbfc>
8112fdd4:	8809883a 	mov	r4,r17
8112fdd8:	111bf5c0 	call	8111bf5c <__clzsi2>
8112fddc:	10800804 	addi	r2,r2,32
8112fde0:	10fffe04 	addi	r3,r2,-8
8112fde4:	010007c4 	movi	r4,31
8112fde8:	20ff890e 	bge	r4,r3,8112fc10 <__reset+0xfb10fc10>
8112fdec:	10bff604 	addi	r2,r2,-40
8112fdf0:	8884983a 	sll	r2,r17,r2
8112fdf4:	0023883a 	mov	r17,zero
8112fdf8:	1c3f8c0e 	bge	r3,r16,8112fc2c <__reset+0xfb10fc2c>
8112fdfc:	023fe034 	movhi	r8,65408
8112fe00:	423fffc4 	addi	r8,r8,-1
8112fe04:	80e1c83a 	sub	r16,r16,r3
8112fe08:	1210703a 	and	r8,r2,r8
8112fe0c:	003f3806 	br	8112faf0 <__reset+0xfb10faf0>
8112fe10:	9007883a 	mov	r3,r18
8112fe14:	0011883a 	mov	r8,zero
8112fe18:	0005883a 	mov	r2,zero
8112fe1c:	003f4c06 	br	8112fb50 <__reset+0xfb10fb50>
8112fe20:	498cb03a 	or	r6,r9,r6
8112fe24:	300cc03a 	cmpne	r6,r6,zero
8112fe28:	0007883a 	mov	r3,zero
8112fe2c:	003f6806 	br	8112fbd0 <__reset+0xfb10fbd0>
8112fe30:	20009c1e 	bne	r4,zero,811300a4 <__adddf3+0x638>
8112fe34:	80800044 	addi	r2,r16,1
8112fe38:	1141ffcc 	andi	r5,r2,2047
8112fe3c:	01000044 	movi	r4,1
8112fe40:	2140670e 	bge	r4,r5,8112ffe0 <__adddf3+0x574>
8112fe44:	0101ffc4 	movi	r4,2047
8112fe48:	11007f26 	beq	r2,r4,81130048 <__adddf3+0x5dc>
8112fe4c:	898d883a 	add	r6,r17,r6
8112fe50:	4247883a 	add	r3,r8,r9
8112fe54:	3451803a 	cmpltu	r8,r6,r17
8112fe58:	40d1883a 	add	r8,r8,r3
8112fe5c:	402297fa 	slli	r17,r8,31
8112fe60:	300cd07a 	srli	r6,r6,1
8112fe64:	4010d07a 	srli	r8,r8,1
8112fe68:	1021883a 	mov	r16,r2
8112fe6c:	89a2b03a 	or	r17,r17,r6
8112fe70:	003f1f06 	br	8112faf0 <__reset+0xfb10faf0>
8112fe74:	0081ffc4 	movi	r2,2047
8112fe78:	80bf481e 	bne	r16,r2,8112fb9c <__reset+0xfb10fb9c>
8112fe7c:	003f1c06 	br	8112faf0 <__reset+0xfb10faf0>
8112fe80:	843ff844 	addi	r16,r16,-31
8112fe84:	01000804 	movi	r4,32
8112fe88:	1406d83a 	srl	r3,r2,r16
8112fe8c:	41005026 	beq	r8,r4,8112ffd0 <__adddf3+0x564>
8112fe90:	01001004 	movi	r4,64
8112fe94:	2211c83a 	sub	r8,r4,r8
8112fe98:	1204983a 	sll	r2,r2,r8
8112fe9c:	88a2b03a 	or	r17,r17,r2
8112fea0:	8822c03a 	cmpne	r17,r17,zero
8112fea4:	1c62b03a 	or	r17,r3,r17
8112fea8:	0011883a 	mov	r8,zero
8112feac:	0021883a 	mov	r16,zero
8112feb0:	003f7106 	br	8112fc78 <__reset+0xfb10fc78>
8112feb4:	193ff804 	addi	r4,r3,-32
8112feb8:	00800804 	movi	r2,32
8112febc:	4908d83a 	srl	r4,r9,r4
8112fec0:	18804526 	beq	r3,r2,8112ffd8 <__adddf3+0x56c>
8112fec4:	00801004 	movi	r2,64
8112fec8:	10c5c83a 	sub	r2,r2,r3
8112fecc:	4886983a 	sll	r3,r9,r2
8112fed0:	198cb03a 	or	r6,r3,r6
8112fed4:	300cc03a 	cmpne	r6,r6,zero
8112fed8:	218cb03a 	or	r6,r4,r6
8112fedc:	0007883a 	mov	r3,zero
8112fee0:	003f3b06 	br	8112fbd0 <__reset+0xfb10fbd0>
8112fee4:	80002a26 	beq	r16,zero,8112ff90 <__adddf3+0x524>
8112fee8:	0101ffc4 	movi	r4,2047
8112feec:	11006826 	beq	r2,r4,81130090 <__adddf3+0x624>
8112fef0:	00c7c83a 	sub	r3,zero,r3
8112fef4:	42002034 	orhi	r8,r8,128
8112fef8:	01000e04 	movi	r4,56
8112fefc:	20c07c16 	blt	r4,r3,811300f0 <__adddf3+0x684>
8112ff00:	010007c4 	movi	r4,31
8112ff04:	20c0da16 	blt	r4,r3,81130270 <__adddf3+0x804>
8112ff08:	01000804 	movi	r4,32
8112ff0c:	20c9c83a 	sub	r4,r4,r3
8112ff10:	4114983a 	sll	r10,r8,r4
8112ff14:	88cad83a 	srl	r5,r17,r3
8112ff18:	8908983a 	sll	r4,r17,r4
8112ff1c:	40c6d83a 	srl	r3,r8,r3
8112ff20:	5162b03a 	or	r17,r10,r5
8112ff24:	2008c03a 	cmpne	r4,r4,zero
8112ff28:	8922b03a 	or	r17,r17,r4
8112ff2c:	3463c83a 	sub	r17,r6,r17
8112ff30:	48c7c83a 	sub	r3,r9,r3
8112ff34:	344d803a 	cmpltu	r6,r6,r17
8112ff38:	1991c83a 	sub	r8,r3,r6
8112ff3c:	1021883a 	mov	r16,r2
8112ff40:	3825883a 	mov	r18,r7
8112ff44:	003f2706 	br	8112fbe4 <__reset+0xfb10fbe4>
8112ff48:	24d0b03a 	or	r8,r4,r19
8112ff4c:	40001b1e 	bne	r8,zero,8112ffbc <__adddf3+0x550>
8112ff50:	0005883a 	mov	r2,zero
8112ff54:	0007883a 	mov	r3,zero
8112ff58:	0021883a 	mov	r16,zero
8112ff5c:	003f4d06 	br	8112fc94 <__reset+0xfb10fc94>
8112ff60:	008007c4 	movi	r2,31
8112ff64:	11003c16 	blt	r2,r4,81130058 <__adddf3+0x5ec>
8112ff68:	00800804 	movi	r2,32
8112ff6c:	1105c83a 	sub	r2,r2,r4
8112ff70:	488e983a 	sll	r7,r9,r2
8112ff74:	310ad83a 	srl	r5,r6,r4
8112ff78:	3084983a 	sll	r2,r6,r2
8112ff7c:	4912d83a 	srl	r9,r9,r4
8112ff80:	394ab03a 	or	r5,r7,r5
8112ff84:	1004c03a 	cmpne	r2,r2,zero
8112ff88:	288ab03a 	or	r5,r5,r2
8112ff8c:	003f5306 	br	8112fcdc <__reset+0xfb10fcdc>
8112ff90:	4448b03a 	or	r4,r8,r17
8112ff94:	20003e26 	beq	r4,zero,81130090 <__adddf3+0x624>
8112ff98:	00c6303a 	nor	r3,zero,r3
8112ff9c:	18003a1e 	bne	r3,zero,81130088 <__adddf3+0x61c>
8112ffa0:	3463c83a 	sub	r17,r6,r17
8112ffa4:	4a07c83a 	sub	r3,r9,r8
8112ffa8:	344d803a 	cmpltu	r6,r6,r17
8112ffac:	1991c83a 	sub	r8,r3,r6
8112ffb0:	1021883a 	mov	r16,r2
8112ffb4:	3825883a 	mov	r18,r7
8112ffb8:	003f0a06 	br	8112fbe4 <__reset+0xfb10fbe4>
8112ffbc:	2023883a 	mov	r17,r4
8112ffc0:	003f0d06 	br	8112fbf8 <__reset+0xfb10fbf8>
8112ffc4:	0081ffc4 	movi	r2,2047
8112ffc8:	80bf3f1e 	bne	r16,r2,8112fcc8 <__reset+0xfb10fcc8>
8112ffcc:	003ec806 	br	8112faf0 <__reset+0xfb10faf0>
8112ffd0:	0005883a 	mov	r2,zero
8112ffd4:	003fb106 	br	8112fe9c <__reset+0xfb10fe9c>
8112ffd8:	0007883a 	mov	r3,zero
8112ffdc:	003fbc06 	br	8112fed0 <__reset+0xfb10fed0>
8112ffe0:	4444b03a 	or	r2,r8,r17
8112ffe4:	8000871e 	bne	r16,zero,81130204 <__adddf3+0x798>
8112ffe8:	1000ba26 	beq	r2,zero,811302d4 <__adddf3+0x868>
8112ffec:	4984b03a 	or	r2,r9,r6
8112fff0:	103ebf26 	beq	r2,zero,8112faf0 <__reset+0xfb10faf0>
8112fff4:	8985883a 	add	r2,r17,r6
8112fff8:	4247883a 	add	r3,r8,r9
8112fffc:	1451803a 	cmpltu	r8,r2,r17
81130000:	40d1883a 	add	r8,r8,r3
81130004:	40c0202c 	andhi	r3,r8,128
81130008:	1023883a 	mov	r17,r2
8113000c:	183f1a26 	beq	r3,zero,8112fc78 <__reset+0xfb10fc78>
81130010:	00bfe034 	movhi	r2,65408
81130014:	10bfffc4 	addi	r2,r2,-1
81130018:	2021883a 	mov	r16,r4
8113001c:	4090703a 	and	r8,r8,r2
81130020:	003eb306 	br	8112faf0 <__reset+0xfb10faf0>
81130024:	4444b03a 	or	r2,r8,r17
81130028:	8000291e 	bne	r16,zero,811300d0 <__adddf3+0x664>
8113002c:	10004b1e 	bne	r2,zero,8113015c <__adddf3+0x6f0>
81130030:	4990b03a 	or	r8,r9,r6
81130034:	40008b26 	beq	r8,zero,81130264 <__adddf3+0x7f8>
81130038:	4811883a 	mov	r8,r9
8113003c:	3023883a 	mov	r17,r6
81130040:	3825883a 	mov	r18,r7
81130044:	003eaa06 	br	8112faf0 <__reset+0xfb10faf0>
81130048:	1021883a 	mov	r16,r2
8113004c:	0011883a 	mov	r8,zero
81130050:	0005883a 	mov	r2,zero
81130054:	003f0f06 	br	8112fc94 <__reset+0xfb10fc94>
81130058:	217ff804 	addi	r5,r4,-32
8113005c:	00800804 	movi	r2,32
81130060:	494ad83a 	srl	r5,r9,r5
81130064:	20807d26 	beq	r4,r2,8113025c <__adddf3+0x7f0>
81130068:	00801004 	movi	r2,64
8113006c:	1109c83a 	sub	r4,r2,r4
81130070:	4912983a 	sll	r9,r9,r4
81130074:	498cb03a 	or	r6,r9,r6
81130078:	300cc03a 	cmpne	r6,r6,zero
8113007c:	298ab03a 	or	r5,r5,r6
81130080:	0013883a 	mov	r9,zero
81130084:	003f1506 	br	8112fcdc <__reset+0xfb10fcdc>
81130088:	0101ffc4 	movi	r4,2047
8113008c:	113f9a1e 	bne	r2,r4,8112fef8 <__reset+0xfb10fef8>
81130090:	4811883a 	mov	r8,r9
81130094:	3023883a 	mov	r17,r6
81130098:	1021883a 	mov	r16,r2
8113009c:	3825883a 	mov	r18,r7
811300a0:	003e9306 	br	8112faf0 <__reset+0xfb10faf0>
811300a4:	8000161e 	bne	r16,zero,81130100 <__adddf3+0x694>
811300a8:	444ab03a 	or	r5,r8,r17
811300ac:	28005126 	beq	r5,zero,811301f4 <__adddf3+0x788>
811300b0:	0108303a 	nor	r4,zero,r4
811300b4:	20004d1e 	bne	r4,zero,811301ec <__adddf3+0x780>
811300b8:	89a3883a 	add	r17,r17,r6
811300bc:	4253883a 	add	r9,r8,r9
811300c0:	898d803a 	cmpltu	r6,r17,r6
811300c4:	3251883a 	add	r8,r6,r9
811300c8:	1021883a 	mov	r16,r2
811300cc:	003f0806 	br	8112fcf0 <__reset+0xfb10fcf0>
811300d0:	1000301e 	bne	r2,zero,81130194 <__adddf3+0x728>
811300d4:	4984b03a 	or	r2,r9,r6
811300d8:	10007126 	beq	r2,zero,811302a0 <__adddf3+0x834>
811300dc:	4811883a 	mov	r8,r9
811300e0:	3023883a 	mov	r17,r6
811300e4:	3825883a 	mov	r18,r7
811300e8:	0401ffc4 	movi	r16,2047
811300ec:	003e8006 	br	8112faf0 <__reset+0xfb10faf0>
811300f0:	4462b03a 	or	r17,r8,r17
811300f4:	8822c03a 	cmpne	r17,r17,zero
811300f8:	0007883a 	mov	r3,zero
811300fc:	003f8b06 	br	8112ff2c <__reset+0xfb10ff2c>
81130100:	0141ffc4 	movi	r5,2047
81130104:	11403b26 	beq	r2,r5,811301f4 <__adddf3+0x788>
81130108:	0109c83a 	sub	r4,zero,r4
8113010c:	42002034 	orhi	r8,r8,128
81130110:	01400e04 	movi	r5,56
81130114:	29006716 	blt	r5,r4,811302b4 <__adddf3+0x848>
81130118:	014007c4 	movi	r5,31
8113011c:	29007016 	blt	r5,r4,811302e0 <__adddf3+0x874>
81130120:	01400804 	movi	r5,32
81130124:	290bc83a 	sub	r5,r5,r4
81130128:	4154983a 	sll	r10,r8,r5
8113012c:	890ed83a 	srl	r7,r17,r4
81130130:	894a983a 	sll	r5,r17,r5
81130134:	4108d83a 	srl	r4,r8,r4
81130138:	51e2b03a 	or	r17,r10,r7
8113013c:	280ac03a 	cmpne	r5,r5,zero
81130140:	8962b03a 	or	r17,r17,r5
81130144:	89a3883a 	add	r17,r17,r6
81130148:	2253883a 	add	r9,r4,r9
8113014c:	898d803a 	cmpltu	r6,r17,r6
81130150:	3251883a 	add	r8,r6,r9
81130154:	1021883a 	mov	r16,r2
81130158:	003ee506 	br	8112fcf0 <__reset+0xfb10fcf0>
8113015c:	4984b03a 	or	r2,r9,r6
81130160:	103e6326 	beq	r2,zero,8112faf0 <__reset+0xfb10faf0>
81130164:	8987c83a 	sub	r3,r17,r6
81130168:	88c9803a 	cmpltu	r4,r17,r3
8113016c:	4245c83a 	sub	r2,r8,r9
81130170:	1105c83a 	sub	r2,r2,r4
81130174:	1100202c 	andhi	r4,r2,128
81130178:	203ebb26 	beq	r4,zero,8112fc68 <__reset+0xfb10fc68>
8113017c:	3463c83a 	sub	r17,r6,r17
81130180:	4a07c83a 	sub	r3,r9,r8
81130184:	344d803a 	cmpltu	r6,r6,r17
81130188:	1991c83a 	sub	r8,r3,r6
8113018c:	3825883a 	mov	r18,r7
81130190:	003e5706 	br	8112faf0 <__reset+0xfb10faf0>
81130194:	4984b03a 	or	r2,r9,r6
81130198:	10002e26 	beq	r2,zero,81130254 <__adddf3+0x7e8>
8113019c:	4004d0fa 	srli	r2,r8,3
811301a0:	8822d0fa 	srli	r17,r17,3
811301a4:	4010977a 	slli	r8,r8,29
811301a8:	10c0022c 	andhi	r3,r2,8
811301ac:	4462b03a 	or	r17,r8,r17
811301b0:	18000826 	beq	r3,zero,811301d4 <__adddf3+0x768>
811301b4:	4808d0fa 	srli	r4,r9,3
811301b8:	20c0022c 	andhi	r3,r4,8
811301bc:	1800051e 	bne	r3,zero,811301d4 <__adddf3+0x768>
811301c0:	300cd0fa 	srli	r6,r6,3
811301c4:	4806977a 	slli	r3,r9,29
811301c8:	2005883a 	mov	r2,r4
811301cc:	3825883a 	mov	r18,r7
811301d0:	19a2b03a 	or	r17,r3,r6
811301d4:	8810d77a 	srli	r8,r17,29
811301d8:	100490fa 	slli	r2,r2,3
811301dc:	882290fa 	slli	r17,r17,3
811301e0:	0401ffc4 	movi	r16,2047
811301e4:	4090b03a 	or	r8,r8,r2
811301e8:	003e4106 	br	8112faf0 <__reset+0xfb10faf0>
811301ec:	0141ffc4 	movi	r5,2047
811301f0:	117fc71e 	bne	r2,r5,81130110 <__reset+0xfb110110>
811301f4:	4811883a 	mov	r8,r9
811301f8:	3023883a 	mov	r17,r6
811301fc:	1021883a 	mov	r16,r2
81130200:	003e3b06 	br	8112faf0 <__reset+0xfb10faf0>
81130204:	10002f26 	beq	r2,zero,811302c4 <__adddf3+0x858>
81130208:	4984b03a 	or	r2,r9,r6
8113020c:	10001126 	beq	r2,zero,81130254 <__adddf3+0x7e8>
81130210:	4004d0fa 	srli	r2,r8,3
81130214:	8822d0fa 	srli	r17,r17,3
81130218:	4010977a 	slli	r8,r8,29
8113021c:	10c0022c 	andhi	r3,r2,8
81130220:	4462b03a 	or	r17,r8,r17
81130224:	183feb26 	beq	r3,zero,811301d4 <__reset+0xfb1101d4>
81130228:	4808d0fa 	srli	r4,r9,3
8113022c:	20c0022c 	andhi	r3,r4,8
81130230:	183fe81e 	bne	r3,zero,811301d4 <__reset+0xfb1101d4>
81130234:	300cd0fa 	srli	r6,r6,3
81130238:	4806977a 	slli	r3,r9,29
8113023c:	2005883a 	mov	r2,r4
81130240:	19a2b03a 	or	r17,r3,r6
81130244:	003fe306 	br	811301d4 <__reset+0xfb1101d4>
81130248:	0011883a 	mov	r8,zero
8113024c:	0005883a 	mov	r2,zero
81130250:	003e3f06 	br	8112fb50 <__reset+0xfb10fb50>
81130254:	0401ffc4 	movi	r16,2047
81130258:	003e2506 	br	8112faf0 <__reset+0xfb10faf0>
8113025c:	0013883a 	mov	r9,zero
81130260:	003f8406 	br	81130074 <__reset+0xfb110074>
81130264:	0005883a 	mov	r2,zero
81130268:	0007883a 	mov	r3,zero
8113026c:	003e8906 	br	8112fc94 <__reset+0xfb10fc94>
81130270:	197ff804 	addi	r5,r3,-32
81130274:	01000804 	movi	r4,32
81130278:	414ad83a 	srl	r5,r8,r5
8113027c:	19002426 	beq	r3,r4,81130310 <__adddf3+0x8a4>
81130280:	01001004 	movi	r4,64
81130284:	20c7c83a 	sub	r3,r4,r3
81130288:	40c6983a 	sll	r3,r8,r3
8113028c:	1c46b03a 	or	r3,r3,r17
81130290:	1806c03a 	cmpne	r3,r3,zero
81130294:	28e2b03a 	or	r17,r5,r3
81130298:	0007883a 	mov	r3,zero
8113029c:	003f2306 	br	8112ff2c <__reset+0xfb10ff2c>
811302a0:	0007883a 	mov	r3,zero
811302a4:	5811883a 	mov	r8,r11
811302a8:	00bfffc4 	movi	r2,-1
811302ac:	0401ffc4 	movi	r16,2047
811302b0:	003e7806 	br	8112fc94 <__reset+0xfb10fc94>
811302b4:	4462b03a 	or	r17,r8,r17
811302b8:	8822c03a 	cmpne	r17,r17,zero
811302bc:	0009883a 	mov	r4,zero
811302c0:	003fa006 	br	81130144 <__reset+0xfb110144>
811302c4:	4811883a 	mov	r8,r9
811302c8:	3023883a 	mov	r17,r6
811302cc:	0401ffc4 	movi	r16,2047
811302d0:	003e0706 	br	8112faf0 <__reset+0xfb10faf0>
811302d4:	4811883a 	mov	r8,r9
811302d8:	3023883a 	mov	r17,r6
811302dc:	003e0406 	br	8112faf0 <__reset+0xfb10faf0>
811302e0:	21fff804 	addi	r7,r4,-32
811302e4:	01400804 	movi	r5,32
811302e8:	41ced83a 	srl	r7,r8,r7
811302ec:	21400a26 	beq	r4,r5,81130318 <__adddf3+0x8ac>
811302f0:	01401004 	movi	r5,64
811302f4:	2909c83a 	sub	r4,r5,r4
811302f8:	4108983a 	sll	r4,r8,r4
811302fc:	2448b03a 	or	r4,r4,r17
81130300:	2008c03a 	cmpne	r4,r4,zero
81130304:	3922b03a 	or	r17,r7,r4
81130308:	0009883a 	mov	r4,zero
8113030c:	003f8d06 	br	81130144 <__reset+0xfb110144>
81130310:	0007883a 	mov	r3,zero
81130314:	003fdd06 	br	8113028c <__reset+0xfb11028c>
81130318:	0009883a 	mov	r4,zero
8113031c:	003ff706 	br	811302fc <__reset+0xfb1102fc>

81130320 <__divdf3>:
81130320:	defff204 	addi	sp,sp,-56
81130324:	de00012e 	bgeu	sp,et,8113032c <__divdf3+0xc>
81130328:	003b68fa 	trap	3
8113032c:	dd400915 	stw	r21,36(sp)
81130330:	282ad53a 	srli	r21,r5,20
81130334:	dd000815 	stw	r20,32(sp)
81130338:	2828d7fa 	srli	r20,r5,31
8113033c:	dc000415 	stw	r16,16(sp)
81130340:	04000434 	movhi	r16,16
81130344:	df000c15 	stw	fp,48(sp)
81130348:	843fffc4 	addi	r16,r16,-1
8113034c:	dfc00d15 	stw	ra,52(sp)
81130350:	ddc00b15 	stw	r23,44(sp)
81130354:	dd800a15 	stw	r22,40(sp)
81130358:	dcc00715 	stw	r19,28(sp)
8113035c:	dc800615 	stw	r18,24(sp)
81130360:	dc400515 	stw	r17,20(sp)
81130364:	ad41ffcc 	andi	r21,r21,2047
81130368:	2c20703a 	and	r16,r5,r16
8113036c:	a7003fcc 	andi	fp,r20,255
81130370:	a8006126 	beq	r21,zero,811304f8 <__divdf3+0x1d8>
81130374:	0081ffc4 	movi	r2,2047
81130378:	2025883a 	mov	r18,r4
8113037c:	a8803726 	beq	r21,r2,8113045c <__divdf3+0x13c>
81130380:	80800434 	orhi	r2,r16,16
81130384:	100490fa 	slli	r2,r2,3
81130388:	2020d77a 	srli	r16,r4,29
8113038c:	202490fa 	slli	r18,r4,3
81130390:	ad7f0044 	addi	r21,r21,-1023
81130394:	80a0b03a 	or	r16,r16,r2
81130398:	0027883a 	mov	r19,zero
8113039c:	0013883a 	mov	r9,zero
811303a0:	3804d53a 	srli	r2,r7,20
811303a4:	382cd7fa 	srli	r22,r7,31
811303a8:	04400434 	movhi	r17,16
811303ac:	8c7fffc4 	addi	r17,r17,-1
811303b0:	1081ffcc 	andi	r2,r2,2047
811303b4:	3011883a 	mov	r8,r6
811303b8:	3c62703a 	and	r17,r7,r17
811303bc:	b5c03fcc 	andi	r23,r22,255
811303c0:	10006c26 	beq	r2,zero,81130574 <__divdf3+0x254>
811303c4:	00c1ffc4 	movi	r3,2047
811303c8:	10c06426 	beq	r2,r3,8113055c <__divdf3+0x23c>
811303cc:	88c00434 	orhi	r3,r17,16
811303d0:	180690fa 	slli	r3,r3,3
811303d4:	3022d77a 	srli	r17,r6,29
811303d8:	301090fa 	slli	r8,r6,3
811303dc:	10bf0044 	addi	r2,r2,-1023
811303e0:	88e2b03a 	or	r17,r17,r3
811303e4:	000f883a 	mov	r7,zero
811303e8:	a58cf03a 	xor	r6,r20,r22
811303ec:	3cc8b03a 	or	r4,r7,r19
811303f0:	a8abc83a 	sub	r21,r21,r2
811303f4:	008003c4 	movi	r2,15
811303f8:	3007883a 	mov	r3,r6
811303fc:	34c03fcc 	andi	r19,r6,255
81130400:	11009036 	bltu	r2,r4,81130644 <__divdf3+0x324>
81130404:	200890ba 	slli	r4,r4,2
81130408:	00a044f4 	movhi	r2,33043
8113040c:	10810704 	addi	r2,r2,1052
81130410:	2089883a 	add	r4,r4,r2
81130414:	20800017 	ldw	r2,0(r4)
81130418:	1000683a 	jmp	r2
8113041c:	81130644 	addi	r4,r16,19481
81130420:	81130494 	ori	r4,r16,19474
81130424:	81130634 	orhi	r4,r16,19480
81130428:	81130488 	cmpgei	r4,r16,19474
8113042c:	81130634 	orhi	r4,r16,19480
81130430:	81130608 	cmpgei	r4,r16,19480
81130434:	81130634 	orhi	r4,r16,19480
81130438:	81130488 	cmpgei	r4,r16,19474
8113043c:	81130494 	ori	r4,r16,19474
81130440:	81130494 	ori	r4,r16,19474
81130444:	81130608 	cmpgei	r4,r16,19480
81130448:	81130488 	cmpgei	r4,r16,19474
8113044c:	81130478 	rdprs	r4,r16,19473
81130450:	81130478 	rdprs	r4,r16,19473
81130454:	81130478 	rdprs	r4,r16,19473
81130458:	81130928 	cmpgeui	r4,r16,19492
8113045c:	2404b03a 	or	r2,r4,r16
81130460:	1000661e 	bne	r2,zero,811305fc <__divdf3+0x2dc>
81130464:	04c00204 	movi	r19,8
81130468:	0021883a 	mov	r16,zero
8113046c:	0025883a 	mov	r18,zero
81130470:	02400084 	movi	r9,2
81130474:	003fca06 	br	811303a0 <__reset+0xfb1103a0>
81130478:	8023883a 	mov	r17,r16
8113047c:	9011883a 	mov	r8,r18
81130480:	e02f883a 	mov	r23,fp
81130484:	480f883a 	mov	r7,r9
81130488:	00800084 	movi	r2,2
8113048c:	3881311e 	bne	r7,r2,81130954 <__divdf3+0x634>
81130490:	b827883a 	mov	r19,r23
81130494:	98c0004c 	andi	r3,r19,1
81130498:	0081ffc4 	movi	r2,2047
8113049c:	000b883a 	mov	r5,zero
811304a0:	0025883a 	mov	r18,zero
811304a4:	1004953a 	slli	r2,r2,20
811304a8:	18c03fcc 	andi	r3,r3,255
811304ac:	04400434 	movhi	r17,16
811304b0:	8c7fffc4 	addi	r17,r17,-1
811304b4:	180697fa 	slli	r3,r3,31
811304b8:	2c4a703a 	and	r5,r5,r17
811304bc:	288ab03a 	or	r5,r5,r2
811304c0:	28c6b03a 	or	r3,r5,r3
811304c4:	9005883a 	mov	r2,r18
811304c8:	dfc00d17 	ldw	ra,52(sp)
811304cc:	df000c17 	ldw	fp,48(sp)
811304d0:	ddc00b17 	ldw	r23,44(sp)
811304d4:	dd800a17 	ldw	r22,40(sp)
811304d8:	dd400917 	ldw	r21,36(sp)
811304dc:	dd000817 	ldw	r20,32(sp)
811304e0:	dcc00717 	ldw	r19,28(sp)
811304e4:	dc800617 	ldw	r18,24(sp)
811304e8:	dc400517 	ldw	r17,20(sp)
811304ec:	dc000417 	ldw	r16,16(sp)
811304f0:	dec00e04 	addi	sp,sp,56
811304f4:	f800283a 	ret
811304f8:	2404b03a 	or	r2,r4,r16
811304fc:	2027883a 	mov	r19,r4
81130500:	10003926 	beq	r2,zero,811305e8 <__divdf3+0x2c8>
81130504:	80012e26 	beq	r16,zero,811309c0 <__divdf3+0x6a0>
81130508:	8009883a 	mov	r4,r16
8113050c:	d9800315 	stw	r6,12(sp)
81130510:	d9c00215 	stw	r7,8(sp)
81130514:	111bf5c0 	call	8111bf5c <__clzsi2>
81130518:	d9800317 	ldw	r6,12(sp)
8113051c:	d9c00217 	ldw	r7,8(sp)
81130520:	113ffd44 	addi	r4,r2,-11
81130524:	00c00704 	movi	r3,28
81130528:	19012116 	blt	r3,r4,811309b0 <__divdf3+0x690>
8113052c:	00c00744 	movi	r3,29
81130530:	147ffe04 	addi	r17,r2,-8
81130534:	1907c83a 	sub	r3,r3,r4
81130538:	8460983a 	sll	r16,r16,r17
8113053c:	98c6d83a 	srl	r3,r19,r3
81130540:	9c64983a 	sll	r18,r19,r17
81130544:	1c20b03a 	or	r16,r3,r16
81130548:	1080fcc4 	addi	r2,r2,1011
8113054c:	00abc83a 	sub	r21,zero,r2
81130550:	0027883a 	mov	r19,zero
81130554:	0013883a 	mov	r9,zero
81130558:	003f9106 	br	811303a0 <__reset+0xfb1103a0>
8113055c:	3446b03a 	or	r3,r6,r17
81130560:	18001f1e 	bne	r3,zero,811305e0 <__divdf3+0x2c0>
81130564:	0023883a 	mov	r17,zero
81130568:	0011883a 	mov	r8,zero
8113056c:	01c00084 	movi	r7,2
81130570:	003f9d06 	br	811303e8 <__reset+0xfb1103e8>
81130574:	3446b03a 	or	r3,r6,r17
81130578:	18001526 	beq	r3,zero,811305d0 <__divdf3+0x2b0>
8113057c:	88011b26 	beq	r17,zero,811309ec <__divdf3+0x6cc>
81130580:	8809883a 	mov	r4,r17
81130584:	d9800315 	stw	r6,12(sp)
81130588:	da400115 	stw	r9,4(sp)
8113058c:	111bf5c0 	call	8111bf5c <__clzsi2>
81130590:	d9800317 	ldw	r6,12(sp)
81130594:	da400117 	ldw	r9,4(sp)
81130598:	113ffd44 	addi	r4,r2,-11
8113059c:	00c00704 	movi	r3,28
811305a0:	19010e16 	blt	r3,r4,811309dc <__divdf3+0x6bc>
811305a4:	00c00744 	movi	r3,29
811305a8:	123ffe04 	addi	r8,r2,-8
811305ac:	1907c83a 	sub	r3,r3,r4
811305b0:	8a22983a 	sll	r17,r17,r8
811305b4:	30c6d83a 	srl	r3,r6,r3
811305b8:	3210983a 	sll	r8,r6,r8
811305bc:	1c62b03a 	or	r17,r3,r17
811305c0:	1080fcc4 	addi	r2,r2,1011
811305c4:	0085c83a 	sub	r2,zero,r2
811305c8:	000f883a 	mov	r7,zero
811305cc:	003f8606 	br	811303e8 <__reset+0xfb1103e8>
811305d0:	0023883a 	mov	r17,zero
811305d4:	0011883a 	mov	r8,zero
811305d8:	01c00044 	movi	r7,1
811305dc:	003f8206 	br	811303e8 <__reset+0xfb1103e8>
811305e0:	01c000c4 	movi	r7,3
811305e4:	003f8006 	br	811303e8 <__reset+0xfb1103e8>
811305e8:	04c00104 	movi	r19,4
811305ec:	0021883a 	mov	r16,zero
811305f0:	0025883a 	mov	r18,zero
811305f4:	02400044 	movi	r9,1
811305f8:	003f6906 	br	811303a0 <__reset+0xfb1103a0>
811305fc:	04c00304 	movi	r19,12
81130600:	024000c4 	movi	r9,3
81130604:	003f6606 	br	811303a0 <__reset+0xfb1103a0>
81130608:	01400434 	movhi	r5,16
8113060c:	0007883a 	mov	r3,zero
81130610:	297fffc4 	addi	r5,r5,-1
81130614:	04bfffc4 	movi	r18,-1
81130618:	0081ffc4 	movi	r2,2047
8113061c:	003fa106 	br	811304a4 <__reset+0xfb1104a4>
81130620:	00c00044 	movi	r3,1
81130624:	1887c83a 	sub	r3,r3,r2
81130628:	01000e04 	movi	r4,56
8113062c:	20c1210e 	bge	r4,r3,81130ab4 <__divdf3+0x794>
81130630:	98c0004c 	andi	r3,r19,1
81130634:	0005883a 	mov	r2,zero
81130638:	000b883a 	mov	r5,zero
8113063c:	0025883a 	mov	r18,zero
81130640:	003f9806 	br	811304a4 <__reset+0xfb1104a4>
81130644:	8c00fd36 	bltu	r17,r16,81130a3c <__divdf3+0x71c>
81130648:	8440fb26 	beq	r16,r17,81130a38 <__divdf3+0x718>
8113064c:	8007883a 	mov	r3,r16
81130650:	ad7fffc4 	addi	r21,r21,-1
81130654:	0021883a 	mov	r16,zero
81130658:	4004d63a 	srli	r2,r8,24
8113065c:	8822923a 	slli	r17,r17,8
81130660:	1809883a 	mov	r4,r3
81130664:	402c923a 	slli	r22,r8,8
81130668:	88b8b03a 	or	fp,r17,r2
8113066c:	e028d43a 	srli	r20,fp,16
81130670:	d8c00015 	stw	r3,0(sp)
81130674:	e5ffffcc 	andi	r23,fp,65535
81130678:	a00b883a 	mov	r5,r20
8113067c:	112f7b40 	call	8112f7b4 <__udivsi3>
81130680:	d8c00017 	ldw	r3,0(sp)
81130684:	a00b883a 	mov	r5,r20
81130688:	d8800315 	stw	r2,12(sp)
8113068c:	1809883a 	mov	r4,r3
81130690:	112f8180 	call	8112f818 <__umodsi3>
81130694:	d9800317 	ldw	r6,12(sp)
81130698:	1006943a 	slli	r3,r2,16
8113069c:	9004d43a 	srli	r2,r18,16
811306a0:	b9a3383a 	mul	r17,r23,r6
811306a4:	10c4b03a 	or	r2,r2,r3
811306a8:	1440062e 	bgeu	r2,r17,811306c4 <__divdf3+0x3a4>
811306ac:	1705883a 	add	r2,r2,fp
811306b0:	30ffffc4 	addi	r3,r6,-1
811306b4:	1700ee36 	bltu	r2,fp,81130a70 <__divdf3+0x750>
811306b8:	1440ed2e 	bgeu	r2,r17,81130a70 <__divdf3+0x750>
811306bc:	31bfff84 	addi	r6,r6,-2
811306c0:	1705883a 	add	r2,r2,fp
811306c4:	1463c83a 	sub	r17,r2,r17
811306c8:	a00b883a 	mov	r5,r20
811306cc:	8809883a 	mov	r4,r17
811306d0:	d9800315 	stw	r6,12(sp)
811306d4:	112f7b40 	call	8112f7b4 <__udivsi3>
811306d8:	a00b883a 	mov	r5,r20
811306dc:	8809883a 	mov	r4,r17
811306e0:	d8800215 	stw	r2,8(sp)
811306e4:	112f8180 	call	8112f818 <__umodsi3>
811306e8:	d9c00217 	ldw	r7,8(sp)
811306ec:	1004943a 	slli	r2,r2,16
811306f0:	94bfffcc 	andi	r18,r18,65535
811306f4:	b9d1383a 	mul	r8,r23,r7
811306f8:	90a4b03a 	or	r18,r18,r2
811306fc:	d9800317 	ldw	r6,12(sp)
81130700:	9200062e 	bgeu	r18,r8,8113071c <__divdf3+0x3fc>
81130704:	9725883a 	add	r18,r18,fp
81130708:	38bfffc4 	addi	r2,r7,-1
8113070c:	9700d636 	bltu	r18,fp,81130a68 <__divdf3+0x748>
81130710:	9200d52e 	bgeu	r18,r8,81130a68 <__divdf3+0x748>
81130714:	39ffff84 	addi	r7,r7,-2
81130718:	9725883a 	add	r18,r18,fp
8113071c:	3004943a 	slli	r2,r6,16
81130720:	b012d43a 	srli	r9,r22,16
81130724:	b1bfffcc 	andi	r6,r22,65535
81130728:	11e2b03a 	or	r17,r2,r7
8113072c:	8806d43a 	srli	r3,r17,16
81130730:	893fffcc 	andi	r4,r17,65535
81130734:	218b383a 	mul	r5,r4,r6
81130738:	30c5383a 	mul	r2,r6,r3
8113073c:	2249383a 	mul	r4,r4,r9
81130740:	280ed43a 	srli	r7,r5,16
81130744:	9225c83a 	sub	r18,r18,r8
81130748:	2089883a 	add	r4,r4,r2
8113074c:	3909883a 	add	r4,r7,r4
81130750:	1a47383a 	mul	r3,r3,r9
81130754:	2080022e 	bgeu	r4,r2,81130760 <__divdf3+0x440>
81130758:	00800074 	movhi	r2,1
8113075c:	1887883a 	add	r3,r3,r2
81130760:	2004d43a 	srli	r2,r4,16
81130764:	2008943a 	slli	r4,r4,16
81130768:	297fffcc 	andi	r5,r5,65535
8113076c:	10c7883a 	add	r3,r2,r3
81130770:	2149883a 	add	r4,r4,r5
81130774:	90c0a536 	bltu	r18,r3,81130a0c <__divdf3+0x6ec>
81130778:	90c0bf26 	beq	r18,r3,81130a78 <__divdf3+0x758>
8113077c:	90c7c83a 	sub	r3,r18,r3
81130780:	810fc83a 	sub	r7,r16,r4
81130784:	81e5803a 	cmpltu	r18,r16,r7
81130788:	1ca5c83a 	sub	r18,r3,r18
8113078c:	e480c126 	beq	fp,r18,81130a94 <__divdf3+0x774>
81130790:	a00b883a 	mov	r5,r20
81130794:	9009883a 	mov	r4,r18
81130798:	d9800315 	stw	r6,12(sp)
8113079c:	d9c00215 	stw	r7,8(sp)
811307a0:	da400115 	stw	r9,4(sp)
811307a4:	112f7b40 	call	8112f7b4 <__udivsi3>
811307a8:	a00b883a 	mov	r5,r20
811307ac:	9009883a 	mov	r4,r18
811307b0:	d8800015 	stw	r2,0(sp)
811307b4:	112f8180 	call	8112f818 <__umodsi3>
811307b8:	d9c00217 	ldw	r7,8(sp)
811307bc:	da000017 	ldw	r8,0(sp)
811307c0:	1006943a 	slli	r3,r2,16
811307c4:	3804d43a 	srli	r2,r7,16
811307c8:	ba21383a 	mul	r16,r23,r8
811307cc:	d9800317 	ldw	r6,12(sp)
811307d0:	10c4b03a 	or	r2,r2,r3
811307d4:	da400117 	ldw	r9,4(sp)
811307d8:	1400062e 	bgeu	r2,r16,811307f4 <__divdf3+0x4d4>
811307dc:	1705883a 	add	r2,r2,fp
811307e0:	40ffffc4 	addi	r3,r8,-1
811307e4:	1700ad36 	bltu	r2,fp,81130a9c <__divdf3+0x77c>
811307e8:	1400ac2e 	bgeu	r2,r16,81130a9c <__divdf3+0x77c>
811307ec:	423fff84 	addi	r8,r8,-2
811307f0:	1705883a 	add	r2,r2,fp
811307f4:	1421c83a 	sub	r16,r2,r16
811307f8:	a00b883a 	mov	r5,r20
811307fc:	8009883a 	mov	r4,r16
81130800:	d9800315 	stw	r6,12(sp)
81130804:	d9c00215 	stw	r7,8(sp)
81130808:	da000015 	stw	r8,0(sp)
8113080c:	da400115 	stw	r9,4(sp)
81130810:	112f7b40 	call	8112f7b4 <__udivsi3>
81130814:	8009883a 	mov	r4,r16
81130818:	a00b883a 	mov	r5,r20
8113081c:	1025883a 	mov	r18,r2
81130820:	112f8180 	call	8112f818 <__umodsi3>
81130824:	d9c00217 	ldw	r7,8(sp)
81130828:	1004943a 	slli	r2,r2,16
8113082c:	bcaf383a 	mul	r23,r23,r18
81130830:	393fffcc 	andi	r4,r7,65535
81130834:	2088b03a 	or	r4,r4,r2
81130838:	d9800317 	ldw	r6,12(sp)
8113083c:	da000017 	ldw	r8,0(sp)
81130840:	da400117 	ldw	r9,4(sp)
81130844:	25c0062e 	bgeu	r4,r23,81130860 <__divdf3+0x540>
81130848:	2709883a 	add	r4,r4,fp
8113084c:	90bfffc4 	addi	r2,r18,-1
81130850:	27009436 	bltu	r4,fp,81130aa4 <__divdf3+0x784>
81130854:	25c0932e 	bgeu	r4,r23,81130aa4 <__divdf3+0x784>
81130858:	94bfff84 	addi	r18,r18,-2
8113085c:	2709883a 	add	r4,r4,fp
81130860:	4004943a 	slli	r2,r8,16
81130864:	25efc83a 	sub	r23,r4,r23
81130868:	1490b03a 	or	r8,r2,r18
8113086c:	4008d43a 	srli	r4,r8,16
81130870:	40ffffcc 	andi	r3,r8,65535
81130874:	30c5383a 	mul	r2,r6,r3
81130878:	1a47383a 	mul	r3,r3,r9
8113087c:	310d383a 	mul	r6,r6,r4
81130880:	100ad43a 	srli	r5,r2,16
81130884:	4913383a 	mul	r9,r9,r4
81130888:	1987883a 	add	r3,r3,r6
8113088c:	28c7883a 	add	r3,r5,r3
81130890:	1980022e 	bgeu	r3,r6,8113089c <__divdf3+0x57c>
81130894:	01000074 	movhi	r4,1
81130898:	4913883a 	add	r9,r9,r4
8113089c:	1808d43a 	srli	r4,r3,16
811308a0:	1806943a 	slli	r3,r3,16
811308a4:	10bfffcc 	andi	r2,r2,65535
811308a8:	2253883a 	add	r9,r4,r9
811308ac:	1887883a 	add	r3,r3,r2
811308b0:	ba403836 	bltu	r23,r9,81130994 <__divdf3+0x674>
811308b4:	ba403626 	beq	r23,r9,81130990 <__divdf3+0x670>
811308b8:	42000054 	ori	r8,r8,1
811308bc:	a880ffc4 	addi	r2,r21,1023
811308c0:	00bf570e 	bge	zero,r2,81130620 <__reset+0xfb110620>
811308c4:	40c001cc 	andi	r3,r8,7
811308c8:	18000726 	beq	r3,zero,811308e8 <__divdf3+0x5c8>
811308cc:	40c003cc 	andi	r3,r8,15
811308d0:	01000104 	movi	r4,4
811308d4:	19000426 	beq	r3,r4,811308e8 <__divdf3+0x5c8>
811308d8:	4107883a 	add	r3,r8,r4
811308dc:	1a11803a 	cmpltu	r8,r3,r8
811308e0:	8a23883a 	add	r17,r17,r8
811308e4:	1811883a 	mov	r8,r3
811308e8:	88c0402c 	andhi	r3,r17,256
811308ec:	18000426 	beq	r3,zero,81130900 <__divdf3+0x5e0>
811308f0:	00ffc034 	movhi	r3,65280
811308f4:	18ffffc4 	addi	r3,r3,-1
811308f8:	a8810004 	addi	r2,r21,1024
811308fc:	88e2703a 	and	r17,r17,r3
81130900:	00c1ff84 	movi	r3,2046
81130904:	18bee316 	blt	r3,r2,81130494 <__reset+0xfb110494>
81130908:	8824977a 	slli	r18,r17,29
8113090c:	4010d0fa 	srli	r8,r8,3
81130910:	8822927a 	slli	r17,r17,9
81130914:	1081ffcc 	andi	r2,r2,2047
81130918:	9224b03a 	or	r18,r18,r8
8113091c:	880ad33a 	srli	r5,r17,12
81130920:	98c0004c 	andi	r3,r19,1
81130924:	003edf06 	br	811304a4 <__reset+0xfb1104a4>
81130928:	8080022c 	andhi	r2,r16,8
8113092c:	10001226 	beq	r2,zero,81130978 <__divdf3+0x658>
81130930:	8880022c 	andhi	r2,r17,8
81130934:	1000101e 	bne	r2,zero,81130978 <__divdf3+0x658>
81130938:	00800434 	movhi	r2,16
8113093c:	89400234 	orhi	r5,r17,8
81130940:	10bfffc4 	addi	r2,r2,-1
81130944:	b007883a 	mov	r3,r22
81130948:	288a703a 	and	r5,r5,r2
8113094c:	4025883a 	mov	r18,r8
81130950:	003f3106 	br	81130618 <__reset+0xfb110618>
81130954:	008000c4 	movi	r2,3
81130958:	3880a626 	beq	r7,r2,81130bf4 <__divdf3+0x8d4>
8113095c:	00800044 	movi	r2,1
81130960:	3880521e 	bne	r7,r2,81130aac <__divdf3+0x78c>
81130964:	b807883a 	mov	r3,r23
81130968:	0005883a 	mov	r2,zero
8113096c:	000b883a 	mov	r5,zero
81130970:	0025883a 	mov	r18,zero
81130974:	003ecb06 	br	811304a4 <__reset+0xfb1104a4>
81130978:	00800434 	movhi	r2,16
8113097c:	81400234 	orhi	r5,r16,8
81130980:	10bfffc4 	addi	r2,r2,-1
81130984:	a007883a 	mov	r3,r20
81130988:	288a703a 	and	r5,r5,r2
8113098c:	003f2206 	br	81130618 <__reset+0xfb110618>
81130990:	183fca26 	beq	r3,zero,811308bc <__reset+0xfb1108bc>
81130994:	e5ef883a 	add	r23,fp,r23
81130998:	40bfffc4 	addi	r2,r8,-1
8113099c:	bf00392e 	bgeu	r23,fp,81130a84 <__divdf3+0x764>
811309a0:	1011883a 	mov	r8,r2
811309a4:	ba7fc41e 	bne	r23,r9,811308b8 <__reset+0xfb1108b8>
811309a8:	b0ffc31e 	bne	r22,r3,811308b8 <__reset+0xfb1108b8>
811309ac:	003fc306 	br	811308bc <__reset+0xfb1108bc>
811309b0:	143ff604 	addi	r16,r2,-40
811309b4:	9c20983a 	sll	r16,r19,r16
811309b8:	0025883a 	mov	r18,zero
811309bc:	003ee206 	br	81130548 <__reset+0xfb110548>
811309c0:	d9800315 	stw	r6,12(sp)
811309c4:	d9c00215 	stw	r7,8(sp)
811309c8:	111bf5c0 	call	8111bf5c <__clzsi2>
811309cc:	10800804 	addi	r2,r2,32
811309d0:	d9c00217 	ldw	r7,8(sp)
811309d4:	d9800317 	ldw	r6,12(sp)
811309d8:	003ed106 	br	81130520 <__reset+0xfb110520>
811309dc:	147ff604 	addi	r17,r2,-40
811309e0:	3462983a 	sll	r17,r6,r17
811309e4:	0011883a 	mov	r8,zero
811309e8:	003ef506 	br	811305c0 <__reset+0xfb1105c0>
811309ec:	3009883a 	mov	r4,r6
811309f0:	d9800315 	stw	r6,12(sp)
811309f4:	da400115 	stw	r9,4(sp)
811309f8:	111bf5c0 	call	8111bf5c <__clzsi2>
811309fc:	10800804 	addi	r2,r2,32
81130a00:	da400117 	ldw	r9,4(sp)
81130a04:	d9800317 	ldw	r6,12(sp)
81130a08:	003ee306 	br	81130598 <__reset+0xfb110598>
81130a0c:	85a1883a 	add	r16,r16,r22
81130a10:	8585803a 	cmpltu	r2,r16,r22
81130a14:	1705883a 	add	r2,r2,fp
81130a18:	14a5883a 	add	r18,r2,r18
81130a1c:	88bfffc4 	addi	r2,r17,-1
81130a20:	e4800c2e 	bgeu	fp,r18,81130a54 <__divdf3+0x734>
81130a24:	90c03e36 	bltu	r18,r3,81130b20 <__divdf3+0x800>
81130a28:	1c806926 	beq	r3,r18,81130bd0 <__divdf3+0x8b0>
81130a2c:	90c7c83a 	sub	r3,r18,r3
81130a30:	1023883a 	mov	r17,r2
81130a34:	003f5206 	br	81130780 <__reset+0xfb110780>
81130a38:	923f0436 	bltu	r18,r8,8113064c <__reset+0xfb11064c>
81130a3c:	800897fa 	slli	r4,r16,31
81130a40:	9004d07a 	srli	r2,r18,1
81130a44:	8006d07a 	srli	r3,r16,1
81130a48:	902097fa 	slli	r16,r18,31
81130a4c:	20a4b03a 	or	r18,r4,r2
81130a50:	003f0106 	br	81130658 <__reset+0xfb110658>
81130a54:	e4bff51e 	bne	fp,r18,81130a2c <__reset+0xfb110a2c>
81130a58:	85bff22e 	bgeu	r16,r22,81130a24 <__reset+0xfb110a24>
81130a5c:	e0c7c83a 	sub	r3,fp,r3
81130a60:	1023883a 	mov	r17,r2
81130a64:	003f4606 	br	81130780 <__reset+0xfb110780>
81130a68:	100f883a 	mov	r7,r2
81130a6c:	003f2b06 	br	8113071c <__reset+0xfb11071c>
81130a70:	180d883a 	mov	r6,r3
81130a74:	003f1306 	br	811306c4 <__reset+0xfb1106c4>
81130a78:	813fe436 	bltu	r16,r4,81130a0c <__reset+0xfb110a0c>
81130a7c:	0007883a 	mov	r3,zero
81130a80:	003f3f06 	br	81130780 <__reset+0xfb110780>
81130a84:	ba402c36 	bltu	r23,r9,81130b38 <__divdf3+0x818>
81130a88:	4dc05426 	beq	r9,r23,81130bdc <__divdf3+0x8bc>
81130a8c:	1011883a 	mov	r8,r2
81130a90:	003f8906 	br	811308b8 <__reset+0xfb1108b8>
81130a94:	023fffc4 	movi	r8,-1
81130a98:	003f8806 	br	811308bc <__reset+0xfb1108bc>
81130a9c:	1811883a 	mov	r8,r3
81130aa0:	003f5406 	br	811307f4 <__reset+0xfb1107f4>
81130aa4:	1025883a 	mov	r18,r2
81130aa8:	003f6d06 	br	81130860 <__reset+0xfb110860>
81130aac:	b827883a 	mov	r19,r23
81130ab0:	003f8206 	br	811308bc <__reset+0xfb1108bc>
81130ab4:	010007c4 	movi	r4,31
81130ab8:	20c02616 	blt	r4,r3,81130b54 <__divdf3+0x834>
81130abc:	00800804 	movi	r2,32
81130ac0:	10c5c83a 	sub	r2,r2,r3
81130ac4:	888a983a 	sll	r5,r17,r2
81130ac8:	40c8d83a 	srl	r4,r8,r3
81130acc:	4084983a 	sll	r2,r8,r2
81130ad0:	88e2d83a 	srl	r17,r17,r3
81130ad4:	2906b03a 	or	r3,r5,r4
81130ad8:	1004c03a 	cmpne	r2,r2,zero
81130adc:	1886b03a 	or	r3,r3,r2
81130ae0:	188001cc 	andi	r2,r3,7
81130ae4:	10000726 	beq	r2,zero,81130b04 <__divdf3+0x7e4>
81130ae8:	188003cc 	andi	r2,r3,15
81130aec:	01000104 	movi	r4,4
81130af0:	11000426 	beq	r2,r4,81130b04 <__divdf3+0x7e4>
81130af4:	1805883a 	mov	r2,r3
81130af8:	10c00104 	addi	r3,r2,4
81130afc:	1885803a 	cmpltu	r2,r3,r2
81130b00:	88a3883a 	add	r17,r17,r2
81130b04:	8880202c 	andhi	r2,r17,128
81130b08:	10002726 	beq	r2,zero,81130ba8 <__divdf3+0x888>
81130b0c:	98c0004c 	andi	r3,r19,1
81130b10:	00800044 	movi	r2,1
81130b14:	000b883a 	mov	r5,zero
81130b18:	0025883a 	mov	r18,zero
81130b1c:	003e6106 	br	811304a4 <__reset+0xfb1104a4>
81130b20:	85a1883a 	add	r16,r16,r22
81130b24:	8585803a 	cmpltu	r2,r16,r22
81130b28:	1705883a 	add	r2,r2,fp
81130b2c:	14a5883a 	add	r18,r2,r18
81130b30:	8c7fff84 	addi	r17,r17,-2
81130b34:	003f1106 	br	8113077c <__reset+0xfb11077c>
81130b38:	b589883a 	add	r4,r22,r22
81130b3c:	25ad803a 	cmpltu	r22,r4,r22
81130b40:	b739883a 	add	fp,r22,fp
81130b44:	40bfff84 	addi	r2,r8,-2
81130b48:	bf2f883a 	add	r23,r23,fp
81130b4c:	202d883a 	mov	r22,r4
81130b50:	003f9306 	br	811309a0 <__reset+0xfb1109a0>
81130b54:	013ff844 	movi	r4,-31
81130b58:	2085c83a 	sub	r2,r4,r2
81130b5c:	8888d83a 	srl	r4,r17,r2
81130b60:	00800804 	movi	r2,32
81130b64:	18802126 	beq	r3,r2,81130bec <__divdf3+0x8cc>
81130b68:	00801004 	movi	r2,64
81130b6c:	10c5c83a 	sub	r2,r2,r3
81130b70:	8884983a 	sll	r2,r17,r2
81130b74:	1204b03a 	or	r2,r2,r8
81130b78:	1004c03a 	cmpne	r2,r2,zero
81130b7c:	2084b03a 	or	r2,r4,r2
81130b80:	144001cc 	andi	r17,r2,7
81130b84:	88000d1e 	bne	r17,zero,81130bbc <__divdf3+0x89c>
81130b88:	000b883a 	mov	r5,zero
81130b8c:	1024d0fa 	srli	r18,r2,3
81130b90:	98c0004c 	andi	r3,r19,1
81130b94:	0005883a 	mov	r2,zero
81130b98:	9464b03a 	or	r18,r18,r17
81130b9c:	003e4106 	br	811304a4 <__reset+0xfb1104a4>
81130ba0:	1007883a 	mov	r3,r2
81130ba4:	0023883a 	mov	r17,zero
81130ba8:	880a927a 	slli	r5,r17,9
81130bac:	1805883a 	mov	r2,r3
81130bb0:	8822977a 	slli	r17,r17,29
81130bb4:	280ad33a 	srli	r5,r5,12
81130bb8:	003ff406 	br	81130b8c <__reset+0xfb110b8c>
81130bbc:	10c003cc 	andi	r3,r2,15
81130bc0:	01000104 	movi	r4,4
81130bc4:	193ff626 	beq	r3,r4,81130ba0 <__reset+0xfb110ba0>
81130bc8:	0023883a 	mov	r17,zero
81130bcc:	003fca06 	br	81130af8 <__reset+0xfb110af8>
81130bd0:	813fd336 	bltu	r16,r4,81130b20 <__reset+0xfb110b20>
81130bd4:	1023883a 	mov	r17,r2
81130bd8:	003fa806 	br	81130a7c <__reset+0xfb110a7c>
81130bdc:	b0ffd636 	bltu	r22,r3,81130b38 <__reset+0xfb110b38>
81130be0:	1011883a 	mov	r8,r2
81130be4:	b0ff341e 	bne	r22,r3,811308b8 <__reset+0xfb1108b8>
81130be8:	003f3406 	br	811308bc <__reset+0xfb1108bc>
81130bec:	0005883a 	mov	r2,zero
81130bf0:	003fe006 	br	81130b74 <__reset+0xfb110b74>
81130bf4:	00800434 	movhi	r2,16
81130bf8:	89400234 	orhi	r5,r17,8
81130bfc:	10bfffc4 	addi	r2,r2,-1
81130c00:	b807883a 	mov	r3,r23
81130c04:	288a703a 	and	r5,r5,r2
81130c08:	4025883a 	mov	r18,r8
81130c0c:	003e8206 	br	81130618 <__reset+0xfb110618>

81130c10 <__eqdf2>:
81130c10:	2804d53a 	srli	r2,r5,20
81130c14:	3806d53a 	srli	r3,r7,20
81130c18:	02000434 	movhi	r8,16
81130c1c:	423fffc4 	addi	r8,r8,-1
81130c20:	1081ffcc 	andi	r2,r2,2047
81130c24:	0281ffc4 	movi	r10,2047
81130c28:	2a12703a 	and	r9,r5,r8
81130c2c:	18c1ffcc 	andi	r3,r3,2047
81130c30:	3a10703a 	and	r8,r7,r8
81130c34:	280ad7fa 	srli	r5,r5,31
81130c38:	380ed7fa 	srli	r7,r7,31
81130c3c:	12801026 	beq	r2,r10,81130c80 <__eqdf2+0x70>
81130c40:	0281ffc4 	movi	r10,2047
81130c44:	1a800a26 	beq	r3,r10,81130c70 <__eqdf2+0x60>
81130c48:	10c00226 	beq	r2,r3,81130c54 <__eqdf2+0x44>
81130c4c:	00800044 	movi	r2,1
81130c50:	f800283a 	ret
81130c54:	4a3ffd1e 	bne	r9,r8,81130c4c <__reset+0xfb110c4c>
81130c58:	21bffc1e 	bne	r4,r6,81130c4c <__reset+0xfb110c4c>
81130c5c:	29c00c26 	beq	r5,r7,81130c90 <__eqdf2+0x80>
81130c60:	103ffa1e 	bne	r2,zero,81130c4c <__reset+0xfb110c4c>
81130c64:	2244b03a 	or	r2,r4,r9
81130c68:	1004c03a 	cmpne	r2,r2,zero
81130c6c:	f800283a 	ret
81130c70:	3214b03a 	or	r10,r6,r8
81130c74:	503ff426 	beq	r10,zero,81130c48 <__reset+0xfb110c48>
81130c78:	00800044 	movi	r2,1
81130c7c:	f800283a 	ret
81130c80:	2254b03a 	or	r10,r4,r9
81130c84:	503fee26 	beq	r10,zero,81130c40 <__reset+0xfb110c40>
81130c88:	00800044 	movi	r2,1
81130c8c:	f800283a 	ret
81130c90:	0005883a 	mov	r2,zero
81130c94:	f800283a 	ret

81130c98 <__gedf2>:
81130c98:	2804d53a 	srli	r2,r5,20
81130c9c:	3806d53a 	srli	r3,r7,20
81130ca0:	02000434 	movhi	r8,16
81130ca4:	423fffc4 	addi	r8,r8,-1
81130ca8:	1081ffcc 	andi	r2,r2,2047
81130cac:	0241ffc4 	movi	r9,2047
81130cb0:	2a14703a 	and	r10,r5,r8
81130cb4:	18c1ffcc 	andi	r3,r3,2047
81130cb8:	3a10703a 	and	r8,r7,r8
81130cbc:	280ad7fa 	srli	r5,r5,31
81130cc0:	380ed7fa 	srli	r7,r7,31
81130cc4:	12401d26 	beq	r2,r9,81130d3c <__gedf2+0xa4>
81130cc8:	0241ffc4 	movi	r9,2047
81130ccc:	1a401226 	beq	r3,r9,81130d18 <__gedf2+0x80>
81130cd0:	1000081e 	bne	r2,zero,81130cf4 <__gedf2+0x5c>
81130cd4:	2296b03a 	or	r11,r4,r10
81130cd8:	5813003a 	cmpeq	r9,r11,zero
81130cdc:	1800091e 	bne	r3,zero,81130d04 <__gedf2+0x6c>
81130ce0:	3218b03a 	or	r12,r6,r8
81130ce4:	6000071e 	bne	r12,zero,81130d04 <__gedf2+0x6c>
81130ce8:	0005883a 	mov	r2,zero
81130cec:	5800101e 	bne	r11,zero,81130d30 <__gedf2+0x98>
81130cf0:	f800283a 	ret
81130cf4:	18000c1e 	bne	r3,zero,81130d28 <__gedf2+0x90>
81130cf8:	3212b03a 	or	r9,r6,r8
81130cfc:	48000c26 	beq	r9,zero,81130d30 <__gedf2+0x98>
81130d00:	0013883a 	mov	r9,zero
81130d04:	39c03fcc 	andi	r7,r7,255
81130d08:	48000826 	beq	r9,zero,81130d2c <__gedf2+0x94>
81130d0c:	38000926 	beq	r7,zero,81130d34 <__gedf2+0x9c>
81130d10:	00800044 	movi	r2,1
81130d14:	f800283a 	ret
81130d18:	3212b03a 	or	r9,r6,r8
81130d1c:	483fec26 	beq	r9,zero,81130cd0 <__reset+0xfb110cd0>
81130d20:	00bfff84 	movi	r2,-2
81130d24:	f800283a 	ret
81130d28:	39c03fcc 	andi	r7,r7,255
81130d2c:	29c00626 	beq	r5,r7,81130d48 <__gedf2+0xb0>
81130d30:	283ff726 	beq	r5,zero,81130d10 <__reset+0xfb110d10>
81130d34:	00bfffc4 	movi	r2,-1
81130d38:	f800283a 	ret
81130d3c:	2292b03a 	or	r9,r4,r10
81130d40:	483fe126 	beq	r9,zero,81130cc8 <__reset+0xfb110cc8>
81130d44:	003ff606 	br	81130d20 <__reset+0xfb110d20>
81130d48:	18bff916 	blt	r3,r2,81130d30 <__reset+0xfb110d30>
81130d4c:	10c00316 	blt	r2,r3,81130d5c <__gedf2+0xc4>
81130d50:	42bff736 	bltu	r8,r10,81130d30 <__reset+0xfb110d30>
81130d54:	52000326 	beq	r10,r8,81130d64 <__gedf2+0xcc>
81130d58:	5200042e 	bgeu	r10,r8,81130d6c <__gedf2+0xd4>
81130d5c:	283fec1e 	bne	r5,zero,81130d10 <__reset+0xfb110d10>
81130d60:	003ff406 	br	81130d34 <__reset+0xfb110d34>
81130d64:	313ff236 	bltu	r6,r4,81130d30 <__reset+0xfb110d30>
81130d68:	21bffc36 	bltu	r4,r6,81130d5c <__reset+0xfb110d5c>
81130d6c:	0005883a 	mov	r2,zero
81130d70:	f800283a 	ret

81130d74 <__ledf2>:
81130d74:	2804d53a 	srli	r2,r5,20
81130d78:	3810d53a 	srli	r8,r7,20
81130d7c:	00c00434 	movhi	r3,16
81130d80:	18ffffc4 	addi	r3,r3,-1
81130d84:	1081ffcc 	andi	r2,r2,2047
81130d88:	0241ffc4 	movi	r9,2047
81130d8c:	28d4703a 	and	r10,r5,r3
81130d90:	4201ffcc 	andi	r8,r8,2047
81130d94:	38c6703a 	and	r3,r7,r3
81130d98:	280ad7fa 	srli	r5,r5,31
81130d9c:	380ed7fa 	srli	r7,r7,31
81130da0:	12401f26 	beq	r2,r9,81130e20 <__ledf2+0xac>
81130da4:	0241ffc4 	movi	r9,2047
81130da8:	42401426 	beq	r8,r9,81130dfc <__ledf2+0x88>
81130dac:	1000091e 	bne	r2,zero,81130dd4 <__ledf2+0x60>
81130db0:	2296b03a 	or	r11,r4,r10
81130db4:	5813003a 	cmpeq	r9,r11,zero
81130db8:	29403fcc 	andi	r5,r5,255
81130dbc:	40000a1e 	bne	r8,zero,81130de8 <__ledf2+0x74>
81130dc0:	30d8b03a 	or	r12,r6,r3
81130dc4:	6000081e 	bne	r12,zero,81130de8 <__ledf2+0x74>
81130dc8:	0005883a 	mov	r2,zero
81130dcc:	5800111e 	bne	r11,zero,81130e14 <__ledf2+0xa0>
81130dd0:	f800283a 	ret
81130dd4:	29403fcc 	andi	r5,r5,255
81130dd8:	40000c1e 	bne	r8,zero,81130e0c <__ledf2+0x98>
81130ddc:	30d2b03a 	or	r9,r6,r3
81130de0:	48000c26 	beq	r9,zero,81130e14 <__ledf2+0xa0>
81130de4:	0013883a 	mov	r9,zero
81130de8:	39c03fcc 	andi	r7,r7,255
81130dec:	48000826 	beq	r9,zero,81130e10 <__ledf2+0x9c>
81130df0:	38001126 	beq	r7,zero,81130e38 <__ledf2+0xc4>
81130df4:	00800044 	movi	r2,1
81130df8:	f800283a 	ret
81130dfc:	30d2b03a 	or	r9,r6,r3
81130e00:	483fea26 	beq	r9,zero,81130dac <__reset+0xfb110dac>
81130e04:	00800084 	movi	r2,2
81130e08:	f800283a 	ret
81130e0c:	39c03fcc 	andi	r7,r7,255
81130e10:	39400726 	beq	r7,r5,81130e30 <__ledf2+0xbc>
81130e14:	2800081e 	bne	r5,zero,81130e38 <__ledf2+0xc4>
81130e18:	00800044 	movi	r2,1
81130e1c:	f800283a 	ret
81130e20:	2292b03a 	or	r9,r4,r10
81130e24:	483fdf26 	beq	r9,zero,81130da4 <__reset+0xfb110da4>
81130e28:	00800084 	movi	r2,2
81130e2c:	f800283a 	ret
81130e30:	4080030e 	bge	r8,r2,81130e40 <__ledf2+0xcc>
81130e34:	383fef26 	beq	r7,zero,81130df4 <__reset+0xfb110df4>
81130e38:	00bfffc4 	movi	r2,-1
81130e3c:	f800283a 	ret
81130e40:	123feb16 	blt	r2,r8,81130df0 <__reset+0xfb110df0>
81130e44:	1abff336 	bltu	r3,r10,81130e14 <__reset+0xfb110e14>
81130e48:	50c00326 	beq	r10,r3,81130e58 <__ledf2+0xe4>
81130e4c:	50c0042e 	bgeu	r10,r3,81130e60 <__ledf2+0xec>
81130e50:	283fe81e 	bne	r5,zero,81130df4 <__reset+0xfb110df4>
81130e54:	003ff806 	br	81130e38 <__reset+0xfb110e38>
81130e58:	313fee36 	bltu	r6,r4,81130e14 <__reset+0xfb110e14>
81130e5c:	21bffc36 	bltu	r4,r6,81130e50 <__reset+0xfb110e50>
81130e60:	0005883a 	mov	r2,zero
81130e64:	f800283a 	ret

81130e68 <__subdf3>:
81130e68:	02000434 	movhi	r8,16
81130e6c:	423fffc4 	addi	r8,r8,-1
81130e70:	defffb04 	addi	sp,sp,-20
81130e74:	2a14703a 	and	r10,r5,r8
81130e78:	3812d53a 	srli	r9,r7,20
81130e7c:	3a10703a 	and	r8,r7,r8
81130e80:	de00012e 	bgeu	sp,et,81130e88 <__subdf3+0x20>
81130e84:	003b68fa 	trap	3
81130e88:	2006d77a 	srli	r3,r4,29
81130e8c:	3004d77a 	srli	r2,r6,29
81130e90:	dc000015 	stw	r16,0(sp)
81130e94:	501490fa 	slli	r10,r10,3
81130e98:	2820d53a 	srli	r16,r5,20
81130e9c:	401090fa 	slli	r8,r8,3
81130ea0:	dc800215 	stw	r18,8(sp)
81130ea4:	dc400115 	stw	r17,4(sp)
81130ea8:	dfc00415 	stw	ra,16(sp)
81130eac:	202290fa 	slli	r17,r4,3
81130eb0:	dcc00315 	stw	r19,12(sp)
81130eb4:	4a41ffcc 	andi	r9,r9,2047
81130eb8:	0101ffc4 	movi	r4,2047
81130ebc:	2824d7fa 	srli	r18,r5,31
81130ec0:	8401ffcc 	andi	r16,r16,2047
81130ec4:	50c6b03a 	or	r3,r10,r3
81130ec8:	380ed7fa 	srli	r7,r7,31
81130ecc:	408ab03a 	or	r5,r8,r2
81130ed0:	300c90fa 	slli	r6,r6,3
81130ed4:	49009626 	beq	r9,r4,81131130 <__subdf3+0x2c8>
81130ed8:	39c0005c 	xori	r7,r7,1
81130edc:	8245c83a 	sub	r2,r16,r9
81130ee0:	3c807426 	beq	r7,r18,811310b4 <__subdf3+0x24c>
81130ee4:	0080af0e 	bge	zero,r2,811311a4 <__subdf3+0x33c>
81130ee8:	48002a1e 	bne	r9,zero,81130f94 <__subdf3+0x12c>
81130eec:	2988b03a 	or	r4,r5,r6
81130ef0:	20009a1e 	bne	r4,zero,8113115c <__subdf3+0x2f4>
81130ef4:	888001cc 	andi	r2,r17,7
81130ef8:	10000726 	beq	r2,zero,81130f18 <__subdf3+0xb0>
81130efc:	888003cc 	andi	r2,r17,15
81130f00:	01000104 	movi	r4,4
81130f04:	11000426 	beq	r2,r4,81130f18 <__subdf3+0xb0>
81130f08:	890b883a 	add	r5,r17,r4
81130f0c:	2c63803a 	cmpltu	r17,r5,r17
81130f10:	1c47883a 	add	r3,r3,r17
81130f14:	2823883a 	mov	r17,r5
81130f18:	1880202c 	andhi	r2,r3,128
81130f1c:	10005926 	beq	r2,zero,81131084 <__subdf3+0x21c>
81130f20:	84000044 	addi	r16,r16,1
81130f24:	0081ffc4 	movi	r2,2047
81130f28:	8080be26 	beq	r16,r2,81131224 <__subdf3+0x3bc>
81130f2c:	017fe034 	movhi	r5,65408
81130f30:	297fffc4 	addi	r5,r5,-1
81130f34:	1946703a 	and	r3,r3,r5
81130f38:	1804977a 	slli	r2,r3,29
81130f3c:	1806927a 	slli	r3,r3,9
81130f40:	8822d0fa 	srli	r17,r17,3
81130f44:	8401ffcc 	andi	r16,r16,2047
81130f48:	180ad33a 	srli	r5,r3,12
81130f4c:	9100004c 	andi	r4,r18,1
81130f50:	1444b03a 	or	r2,r2,r17
81130f54:	80c1ffcc 	andi	r3,r16,2047
81130f58:	1820953a 	slli	r16,r3,20
81130f5c:	20c03fcc 	andi	r3,r4,255
81130f60:	180897fa 	slli	r4,r3,31
81130f64:	00c00434 	movhi	r3,16
81130f68:	18ffffc4 	addi	r3,r3,-1
81130f6c:	28c6703a 	and	r3,r5,r3
81130f70:	1c06b03a 	or	r3,r3,r16
81130f74:	1906b03a 	or	r3,r3,r4
81130f78:	dfc00417 	ldw	ra,16(sp)
81130f7c:	dcc00317 	ldw	r19,12(sp)
81130f80:	dc800217 	ldw	r18,8(sp)
81130f84:	dc400117 	ldw	r17,4(sp)
81130f88:	dc000017 	ldw	r16,0(sp)
81130f8c:	dec00504 	addi	sp,sp,20
81130f90:	f800283a 	ret
81130f94:	0101ffc4 	movi	r4,2047
81130f98:	813fd626 	beq	r16,r4,81130ef4 <__reset+0xfb110ef4>
81130f9c:	29402034 	orhi	r5,r5,128
81130fa0:	01000e04 	movi	r4,56
81130fa4:	2080a316 	blt	r4,r2,81131234 <__subdf3+0x3cc>
81130fa8:	010007c4 	movi	r4,31
81130fac:	2080c616 	blt	r4,r2,811312c8 <__subdf3+0x460>
81130fb0:	01000804 	movi	r4,32
81130fb4:	2089c83a 	sub	r4,r4,r2
81130fb8:	2910983a 	sll	r8,r5,r4
81130fbc:	308ed83a 	srl	r7,r6,r2
81130fc0:	3108983a 	sll	r4,r6,r4
81130fc4:	2884d83a 	srl	r2,r5,r2
81130fc8:	41ccb03a 	or	r6,r8,r7
81130fcc:	2008c03a 	cmpne	r4,r4,zero
81130fd0:	310cb03a 	or	r6,r6,r4
81130fd4:	898dc83a 	sub	r6,r17,r6
81130fd8:	89a3803a 	cmpltu	r17,r17,r6
81130fdc:	1887c83a 	sub	r3,r3,r2
81130fe0:	1c47c83a 	sub	r3,r3,r17
81130fe4:	3023883a 	mov	r17,r6
81130fe8:	1880202c 	andhi	r2,r3,128
81130fec:	10002326 	beq	r2,zero,8113107c <__subdf3+0x214>
81130ff0:	04c02034 	movhi	r19,128
81130ff4:	9cffffc4 	addi	r19,r19,-1
81130ff8:	1ce6703a 	and	r19,r3,r19
81130ffc:	98007a26 	beq	r19,zero,811311e8 <__subdf3+0x380>
81131000:	9809883a 	mov	r4,r19
81131004:	111bf5c0 	call	8111bf5c <__clzsi2>
81131008:	113ffe04 	addi	r4,r2,-8
8113100c:	00c007c4 	movi	r3,31
81131010:	19007b16 	blt	r3,r4,81131200 <__subdf3+0x398>
81131014:	00800804 	movi	r2,32
81131018:	1105c83a 	sub	r2,r2,r4
8113101c:	8884d83a 	srl	r2,r17,r2
81131020:	9906983a 	sll	r3,r19,r4
81131024:	8922983a 	sll	r17,r17,r4
81131028:	10c4b03a 	or	r2,r2,r3
8113102c:	24007816 	blt	r4,r16,81131210 <__subdf3+0x3a8>
81131030:	2421c83a 	sub	r16,r4,r16
81131034:	80c00044 	addi	r3,r16,1
81131038:	010007c4 	movi	r4,31
8113103c:	20c09516 	blt	r4,r3,81131294 <__subdf3+0x42c>
81131040:	01400804 	movi	r5,32
81131044:	28cbc83a 	sub	r5,r5,r3
81131048:	88c8d83a 	srl	r4,r17,r3
8113104c:	8962983a 	sll	r17,r17,r5
81131050:	114a983a 	sll	r5,r2,r5
81131054:	10c6d83a 	srl	r3,r2,r3
81131058:	8804c03a 	cmpne	r2,r17,zero
8113105c:	290ab03a 	or	r5,r5,r4
81131060:	28a2b03a 	or	r17,r5,r2
81131064:	0021883a 	mov	r16,zero
81131068:	003fa206 	br	81130ef4 <__reset+0xfb110ef4>
8113106c:	2090b03a 	or	r8,r4,r2
81131070:	40018e26 	beq	r8,zero,811316ac <__subdf3+0x844>
81131074:	1007883a 	mov	r3,r2
81131078:	2023883a 	mov	r17,r4
8113107c:	888001cc 	andi	r2,r17,7
81131080:	103f9e1e 	bne	r2,zero,81130efc <__reset+0xfb110efc>
81131084:	1804977a 	slli	r2,r3,29
81131088:	8822d0fa 	srli	r17,r17,3
8113108c:	1810d0fa 	srli	r8,r3,3
81131090:	9100004c 	andi	r4,r18,1
81131094:	1444b03a 	or	r2,r2,r17
81131098:	00c1ffc4 	movi	r3,2047
8113109c:	80c02826 	beq	r16,r3,81131140 <__subdf3+0x2d8>
811310a0:	01400434 	movhi	r5,16
811310a4:	297fffc4 	addi	r5,r5,-1
811310a8:	80e0703a 	and	r16,r16,r3
811310ac:	414a703a 	and	r5,r8,r5
811310b0:	003fa806 	br	81130f54 <__reset+0xfb110f54>
811310b4:	0080630e 	bge	zero,r2,81131244 <__subdf3+0x3dc>
811310b8:	48003026 	beq	r9,zero,8113117c <__subdf3+0x314>
811310bc:	0101ffc4 	movi	r4,2047
811310c0:	813f8c26 	beq	r16,r4,81130ef4 <__reset+0xfb110ef4>
811310c4:	29402034 	orhi	r5,r5,128
811310c8:	01000e04 	movi	r4,56
811310cc:	2080a90e 	bge	r4,r2,81131374 <__subdf3+0x50c>
811310d0:	298cb03a 	or	r6,r5,r6
811310d4:	3012c03a 	cmpne	r9,r6,zero
811310d8:	0005883a 	mov	r2,zero
811310dc:	4c53883a 	add	r9,r9,r17
811310e0:	4c63803a 	cmpltu	r17,r9,r17
811310e4:	10c7883a 	add	r3,r2,r3
811310e8:	88c7883a 	add	r3,r17,r3
811310ec:	4823883a 	mov	r17,r9
811310f0:	1880202c 	andhi	r2,r3,128
811310f4:	1000d026 	beq	r2,zero,81131438 <__subdf3+0x5d0>
811310f8:	84000044 	addi	r16,r16,1
811310fc:	0081ffc4 	movi	r2,2047
81131100:	8080fe26 	beq	r16,r2,811314fc <__subdf3+0x694>
81131104:	00bfe034 	movhi	r2,65408
81131108:	10bfffc4 	addi	r2,r2,-1
8113110c:	1886703a 	and	r3,r3,r2
81131110:	880ad07a 	srli	r5,r17,1
81131114:	180497fa 	slli	r2,r3,31
81131118:	8900004c 	andi	r4,r17,1
8113111c:	2922b03a 	or	r17,r5,r4
81131120:	1806d07a 	srli	r3,r3,1
81131124:	1462b03a 	or	r17,r2,r17
81131128:	3825883a 	mov	r18,r7
8113112c:	003f7106 	br	81130ef4 <__reset+0xfb110ef4>
81131130:	2984b03a 	or	r2,r5,r6
81131134:	103f6826 	beq	r2,zero,81130ed8 <__reset+0xfb110ed8>
81131138:	39c03fcc 	andi	r7,r7,255
8113113c:	003f6706 	br	81130edc <__reset+0xfb110edc>
81131140:	4086b03a 	or	r3,r8,r2
81131144:	18015226 	beq	r3,zero,81131690 <__subdf3+0x828>
81131148:	00c00434 	movhi	r3,16
8113114c:	41400234 	orhi	r5,r8,8
81131150:	18ffffc4 	addi	r3,r3,-1
81131154:	28ca703a 	and	r5,r5,r3
81131158:	003f7e06 	br	81130f54 <__reset+0xfb110f54>
8113115c:	10bfffc4 	addi	r2,r2,-1
81131160:	1000491e 	bne	r2,zero,81131288 <__subdf3+0x420>
81131164:	898fc83a 	sub	r7,r17,r6
81131168:	89e3803a 	cmpltu	r17,r17,r7
8113116c:	1947c83a 	sub	r3,r3,r5
81131170:	1c47c83a 	sub	r3,r3,r17
81131174:	3823883a 	mov	r17,r7
81131178:	003f9b06 	br	81130fe8 <__reset+0xfb110fe8>
8113117c:	2988b03a 	or	r4,r5,r6
81131180:	203f5c26 	beq	r4,zero,81130ef4 <__reset+0xfb110ef4>
81131184:	10bfffc4 	addi	r2,r2,-1
81131188:	1000931e 	bne	r2,zero,811313d8 <__subdf3+0x570>
8113118c:	898d883a 	add	r6,r17,r6
81131190:	3463803a 	cmpltu	r17,r6,r17
81131194:	1947883a 	add	r3,r3,r5
81131198:	88c7883a 	add	r3,r17,r3
8113119c:	3023883a 	mov	r17,r6
811311a0:	003fd306 	br	811310f0 <__reset+0xfb1110f0>
811311a4:	1000541e 	bne	r2,zero,811312f8 <__subdf3+0x490>
811311a8:	80800044 	addi	r2,r16,1
811311ac:	1081ffcc 	andi	r2,r2,2047
811311b0:	01000044 	movi	r4,1
811311b4:	2080a20e 	bge	r4,r2,81131440 <__subdf3+0x5d8>
811311b8:	8989c83a 	sub	r4,r17,r6
811311bc:	8905803a 	cmpltu	r2,r17,r4
811311c0:	1967c83a 	sub	r19,r3,r5
811311c4:	98a7c83a 	sub	r19,r19,r2
811311c8:	9880202c 	andhi	r2,r19,128
811311cc:	10006326 	beq	r2,zero,8113135c <__subdf3+0x4f4>
811311d0:	3463c83a 	sub	r17,r6,r17
811311d4:	28c7c83a 	sub	r3,r5,r3
811311d8:	344d803a 	cmpltu	r6,r6,r17
811311dc:	19a7c83a 	sub	r19,r3,r6
811311e0:	3825883a 	mov	r18,r7
811311e4:	983f861e 	bne	r19,zero,81131000 <__reset+0xfb111000>
811311e8:	8809883a 	mov	r4,r17
811311ec:	111bf5c0 	call	8111bf5c <__clzsi2>
811311f0:	10800804 	addi	r2,r2,32
811311f4:	113ffe04 	addi	r4,r2,-8
811311f8:	00c007c4 	movi	r3,31
811311fc:	193f850e 	bge	r3,r4,81131014 <__reset+0xfb111014>
81131200:	10bff604 	addi	r2,r2,-40
81131204:	8884983a 	sll	r2,r17,r2
81131208:	0023883a 	mov	r17,zero
8113120c:	243f880e 	bge	r4,r16,81131030 <__reset+0xfb111030>
81131210:	00ffe034 	movhi	r3,65408
81131214:	18ffffc4 	addi	r3,r3,-1
81131218:	8121c83a 	sub	r16,r16,r4
8113121c:	10c6703a 	and	r3,r2,r3
81131220:	003f3406 	br	81130ef4 <__reset+0xfb110ef4>
81131224:	9100004c 	andi	r4,r18,1
81131228:	000b883a 	mov	r5,zero
8113122c:	0005883a 	mov	r2,zero
81131230:	003f4806 	br	81130f54 <__reset+0xfb110f54>
81131234:	298cb03a 	or	r6,r5,r6
81131238:	300cc03a 	cmpne	r6,r6,zero
8113123c:	0005883a 	mov	r2,zero
81131240:	003f6406 	br	81130fd4 <__reset+0xfb110fd4>
81131244:	10009a1e 	bne	r2,zero,811314b0 <__subdf3+0x648>
81131248:	82400044 	addi	r9,r16,1
8113124c:	4881ffcc 	andi	r2,r9,2047
81131250:	02800044 	movi	r10,1
81131254:	5080670e 	bge	r10,r2,811313f4 <__subdf3+0x58c>
81131258:	0081ffc4 	movi	r2,2047
8113125c:	4880af26 	beq	r9,r2,8113151c <__subdf3+0x6b4>
81131260:	898d883a 	add	r6,r17,r6
81131264:	1945883a 	add	r2,r3,r5
81131268:	3447803a 	cmpltu	r3,r6,r17
8113126c:	1887883a 	add	r3,r3,r2
81131270:	182297fa 	slli	r17,r3,31
81131274:	300cd07a 	srli	r6,r6,1
81131278:	1806d07a 	srli	r3,r3,1
8113127c:	4821883a 	mov	r16,r9
81131280:	89a2b03a 	or	r17,r17,r6
81131284:	003f1b06 	br	81130ef4 <__reset+0xfb110ef4>
81131288:	0101ffc4 	movi	r4,2047
8113128c:	813f441e 	bne	r16,r4,81130fa0 <__reset+0xfb110fa0>
81131290:	003f1806 	br	81130ef4 <__reset+0xfb110ef4>
81131294:	843ff844 	addi	r16,r16,-31
81131298:	01400804 	movi	r5,32
8113129c:	1408d83a 	srl	r4,r2,r16
811312a0:	19405026 	beq	r3,r5,811313e4 <__subdf3+0x57c>
811312a4:	01401004 	movi	r5,64
811312a8:	28c7c83a 	sub	r3,r5,r3
811312ac:	10c4983a 	sll	r2,r2,r3
811312b0:	88a2b03a 	or	r17,r17,r2
811312b4:	8822c03a 	cmpne	r17,r17,zero
811312b8:	2462b03a 	or	r17,r4,r17
811312bc:	0007883a 	mov	r3,zero
811312c0:	0021883a 	mov	r16,zero
811312c4:	003f6d06 	br	8113107c <__reset+0xfb11107c>
811312c8:	11fff804 	addi	r7,r2,-32
811312cc:	01000804 	movi	r4,32
811312d0:	29ced83a 	srl	r7,r5,r7
811312d4:	11004526 	beq	r2,r4,811313ec <__subdf3+0x584>
811312d8:	01001004 	movi	r4,64
811312dc:	2089c83a 	sub	r4,r4,r2
811312e0:	2904983a 	sll	r2,r5,r4
811312e4:	118cb03a 	or	r6,r2,r6
811312e8:	300cc03a 	cmpne	r6,r6,zero
811312ec:	398cb03a 	or	r6,r7,r6
811312f0:	0005883a 	mov	r2,zero
811312f4:	003f3706 	br	81130fd4 <__reset+0xfb110fd4>
811312f8:	80002a26 	beq	r16,zero,811313a4 <__subdf3+0x53c>
811312fc:	0101ffc4 	movi	r4,2047
81131300:	49006626 	beq	r9,r4,8113149c <__subdf3+0x634>
81131304:	0085c83a 	sub	r2,zero,r2
81131308:	18c02034 	orhi	r3,r3,128
8113130c:	01000e04 	movi	r4,56
81131310:	20807e16 	blt	r4,r2,8113150c <__subdf3+0x6a4>
81131314:	010007c4 	movi	r4,31
81131318:	2080e716 	blt	r4,r2,811316b8 <__subdf3+0x850>
8113131c:	01000804 	movi	r4,32
81131320:	2089c83a 	sub	r4,r4,r2
81131324:	1914983a 	sll	r10,r3,r4
81131328:	8890d83a 	srl	r8,r17,r2
8113132c:	8908983a 	sll	r4,r17,r4
81131330:	1884d83a 	srl	r2,r3,r2
81131334:	5222b03a 	or	r17,r10,r8
81131338:	2006c03a 	cmpne	r3,r4,zero
8113133c:	88e2b03a 	or	r17,r17,r3
81131340:	3463c83a 	sub	r17,r6,r17
81131344:	2885c83a 	sub	r2,r5,r2
81131348:	344d803a 	cmpltu	r6,r6,r17
8113134c:	1187c83a 	sub	r3,r2,r6
81131350:	4821883a 	mov	r16,r9
81131354:	3825883a 	mov	r18,r7
81131358:	003f2306 	br	81130fe8 <__reset+0xfb110fe8>
8113135c:	24d0b03a 	or	r8,r4,r19
81131360:	40001b1e 	bne	r8,zero,811313d0 <__subdf3+0x568>
81131364:	0005883a 	mov	r2,zero
81131368:	0009883a 	mov	r4,zero
8113136c:	0021883a 	mov	r16,zero
81131370:	003f4906 	br	81131098 <__reset+0xfb111098>
81131374:	010007c4 	movi	r4,31
81131378:	20803a16 	blt	r4,r2,81131464 <__subdf3+0x5fc>
8113137c:	01000804 	movi	r4,32
81131380:	2089c83a 	sub	r4,r4,r2
81131384:	2912983a 	sll	r9,r5,r4
81131388:	3090d83a 	srl	r8,r6,r2
8113138c:	3108983a 	sll	r4,r6,r4
81131390:	2884d83a 	srl	r2,r5,r2
81131394:	4a12b03a 	or	r9,r9,r8
81131398:	2008c03a 	cmpne	r4,r4,zero
8113139c:	4912b03a 	or	r9,r9,r4
811313a0:	003f4e06 	br	811310dc <__reset+0xfb1110dc>
811313a4:	1c48b03a 	or	r4,r3,r17
811313a8:	20003c26 	beq	r4,zero,8113149c <__subdf3+0x634>
811313ac:	0084303a 	nor	r2,zero,r2
811313b0:	1000381e 	bne	r2,zero,81131494 <__subdf3+0x62c>
811313b4:	3463c83a 	sub	r17,r6,r17
811313b8:	28c5c83a 	sub	r2,r5,r3
811313bc:	344d803a 	cmpltu	r6,r6,r17
811313c0:	1187c83a 	sub	r3,r2,r6
811313c4:	4821883a 	mov	r16,r9
811313c8:	3825883a 	mov	r18,r7
811313cc:	003f0606 	br	81130fe8 <__reset+0xfb110fe8>
811313d0:	2023883a 	mov	r17,r4
811313d4:	003f0906 	br	81130ffc <__reset+0xfb110ffc>
811313d8:	0101ffc4 	movi	r4,2047
811313dc:	813f3a1e 	bne	r16,r4,811310c8 <__reset+0xfb1110c8>
811313e0:	003ec406 	br	81130ef4 <__reset+0xfb110ef4>
811313e4:	0005883a 	mov	r2,zero
811313e8:	003fb106 	br	811312b0 <__reset+0xfb1112b0>
811313ec:	0005883a 	mov	r2,zero
811313f0:	003fbc06 	br	811312e4 <__reset+0xfb1112e4>
811313f4:	1c44b03a 	or	r2,r3,r17
811313f8:	80008e1e 	bne	r16,zero,81131634 <__subdf3+0x7cc>
811313fc:	1000c826 	beq	r2,zero,81131720 <__subdf3+0x8b8>
81131400:	2984b03a 	or	r2,r5,r6
81131404:	103ebb26 	beq	r2,zero,81130ef4 <__reset+0xfb110ef4>
81131408:	8989883a 	add	r4,r17,r6
8113140c:	1945883a 	add	r2,r3,r5
81131410:	2447803a 	cmpltu	r3,r4,r17
81131414:	1887883a 	add	r3,r3,r2
81131418:	1880202c 	andhi	r2,r3,128
8113141c:	2023883a 	mov	r17,r4
81131420:	103f1626 	beq	r2,zero,8113107c <__reset+0xfb11107c>
81131424:	00bfe034 	movhi	r2,65408
81131428:	10bfffc4 	addi	r2,r2,-1
8113142c:	5021883a 	mov	r16,r10
81131430:	1886703a 	and	r3,r3,r2
81131434:	003eaf06 	br	81130ef4 <__reset+0xfb110ef4>
81131438:	3825883a 	mov	r18,r7
8113143c:	003f0f06 	br	8113107c <__reset+0xfb11107c>
81131440:	1c44b03a 	or	r2,r3,r17
81131444:	8000251e 	bne	r16,zero,811314dc <__subdf3+0x674>
81131448:	1000661e 	bne	r2,zero,811315e4 <__subdf3+0x77c>
8113144c:	2990b03a 	or	r8,r5,r6
81131450:	40009626 	beq	r8,zero,811316ac <__subdf3+0x844>
81131454:	2807883a 	mov	r3,r5
81131458:	3023883a 	mov	r17,r6
8113145c:	3825883a 	mov	r18,r7
81131460:	003ea406 	br	81130ef4 <__reset+0xfb110ef4>
81131464:	127ff804 	addi	r9,r2,-32
81131468:	01000804 	movi	r4,32
8113146c:	2a52d83a 	srl	r9,r5,r9
81131470:	11008c26 	beq	r2,r4,811316a4 <__subdf3+0x83c>
81131474:	01001004 	movi	r4,64
81131478:	2085c83a 	sub	r2,r4,r2
8113147c:	2884983a 	sll	r2,r5,r2
81131480:	118cb03a 	or	r6,r2,r6
81131484:	300cc03a 	cmpne	r6,r6,zero
81131488:	4992b03a 	or	r9,r9,r6
8113148c:	0005883a 	mov	r2,zero
81131490:	003f1206 	br	811310dc <__reset+0xfb1110dc>
81131494:	0101ffc4 	movi	r4,2047
81131498:	493f9c1e 	bne	r9,r4,8113130c <__reset+0xfb11130c>
8113149c:	2807883a 	mov	r3,r5
811314a0:	3023883a 	mov	r17,r6
811314a4:	4821883a 	mov	r16,r9
811314a8:	3825883a 	mov	r18,r7
811314ac:	003e9106 	br	81130ef4 <__reset+0xfb110ef4>
811314b0:	80001f1e 	bne	r16,zero,81131530 <__subdf3+0x6c8>
811314b4:	1c48b03a 	or	r4,r3,r17
811314b8:	20005a26 	beq	r4,zero,81131624 <__subdf3+0x7bc>
811314bc:	0084303a 	nor	r2,zero,r2
811314c0:	1000561e 	bne	r2,zero,8113161c <__subdf3+0x7b4>
811314c4:	89a3883a 	add	r17,r17,r6
811314c8:	1945883a 	add	r2,r3,r5
811314cc:	898d803a 	cmpltu	r6,r17,r6
811314d0:	3087883a 	add	r3,r6,r2
811314d4:	4821883a 	mov	r16,r9
811314d8:	003f0506 	br	811310f0 <__reset+0xfb1110f0>
811314dc:	10002b1e 	bne	r2,zero,8113158c <__subdf3+0x724>
811314e0:	2984b03a 	or	r2,r5,r6
811314e4:	10008026 	beq	r2,zero,811316e8 <__subdf3+0x880>
811314e8:	2807883a 	mov	r3,r5
811314ec:	3023883a 	mov	r17,r6
811314f0:	3825883a 	mov	r18,r7
811314f4:	0401ffc4 	movi	r16,2047
811314f8:	003e7e06 	br	81130ef4 <__reset+0xfb110ef4>
811314fc:	3809883a 	mov	r4,r7
81131500:	0011883a 	mov	r8,zero
81131504:	0005883a 	mov	r2,zero
81131508:	003ee306 	br	81131098 <__reset+0xfb111098>
8113150c:	1c62b03a 	or	r17,r3,r17
81131510:	8822c03a 	cmpne	r17,r17,zero
81131514:	0005883a 	mov	r2,zero
81131518:	003f8906 	br	81131340 <__reset+0xfb111340>
8113151c:	3809883a 	mov	r4,r7
81131520:	4821883a 	mov	r16,r9
81131524:	0011883a 	mov	r8,zero
81131528:	0005883a 	mov	r2,zero
8113152c:	003eda06 	br	81131098 <__reset+0xfb111098>
81131530:	0101ffc4 	movi	r4,2047
81131534:	49003b26 	beq	r9,r4,81131624 <__subdf3+0x7bc>
81131538:	0085c83a 	sub	r2,zero,r2
8113153c:	18c02034 	orhi	r3,r3,128
81131540:	01000e04 	movi	r4,56
81131544:	20806e16 	blt	r4,r2,81131700 <__subdf3+0x898>
81131548:	010007c4 	movi	r4,31
8113154c:	20807716 	blt	r4,r2,8113172c <__subdf3+0x8c4>
81131550:	01000804 	movi	r4,32
81131554:	2089c83a 	sub	r4,r4,r2
81131558:	1914983a 	sll	r10,r3,r4
8113155c:	8890d83a 	srl	r8,r17,r2
81131560:	8908983a 	sll	r4,r17,r4
81131564:	1884d83a 	srl	r2,r3,r2
81131568:	5222b03a 	or	r17,r10,r8
8113156c:	2006c03a 	cmpne	r3,r4,zero
81131570:	88e2b03a 	or	r17,r17,r3
81131574:	89a3883a 	add	r17,r17,r6
81131578:	1145883a 	add	r2,r2,r5
8113157c:	898d803a 	cmpltu	r6,r17,r6
81131580:	3087883a 	add	r3,r6,r2
81131584:	4821883a 	mov	r16,r9
81131588:	003ed906 	br	811310f0 <__reset+0xfb1110f0>
8113158c:	2984b03a 	or	r2,r5,r6
81131590:	10004226 	beq	r2,zero,8113169c <__subdf3+0x834>
81131594:	1808d0fa 	srli	r4,r3,3
81131598:	8822d0fa 	srli	r17,r17,3
8113159c:	1806977a 	slli	r3,r3,29
811315a0:	2080022c 	andhi	r2,r4,8
811315a4:	1c62b03a 	or	r17,r3,r17
811315a8:	10000826 	beq	r2,zero,811315cc <__subdf3+0x764>
811315ac:	2812d0fa 	srli	r9,r5,3
811315b0:	4880022c 	andhi	r2,r9,8
811315b4:	1000051e 	bne	r2,zero,811315cc <__subdf3+0x764>
811315b8:	300cd0fa 	srli	r6,r6,3
811315bc:	2804977a 	slli	r2,r5,29
811315c0:	4809883a 	mov	r4,r9
811315c4:	3825883a 	mov	r18,r7
811315c8:	11a2b03a 	or	r17,r2,r6
811315cc:	8806d77a 	srli	r3,r17,29
811315d0:	200890fa 	slli	r4,r4,3
811315d4:	882290fa 	slli	r17,r17,3
811315d8:	0401ffc4 	movi	r16,2047
811315dc:	1906b03a 	or	r3,r3,r4
811315e0:	003e4406 	br	81130ef4 <__reset+0xfb110ef4>
811315e4:	2984b03a 	or	r2,r5,r6
811315e8:	103e4226 	beq	r2,zero,81130ef4 <__reset+0xfb110ef4>
811315ec:	8989c83a 	sub	r4,r17,r6
811315f0:	8911803a 	cmpltu	r8,r17,r4
811315f4:	1945c83a 	sub	r2,r3,r5
811315f8:	1205c83a 	sub	r2,r2,r8
811315fc:	1200202c 	andhi	r8,r2,128
81131600:	403e9a26 	beq	r8,zero,8113106c <__reset+0xfb11106c>
81131604:	3463c83a 	sub	r17,r6,r17
81131608:	28c5c83a 	sub	r2,r5,r3
8113160c:	344d803a 	cmpltu	r6,r6,r17
81131610:	1187c83a 	sub	r3,r2,r6
81131614:	3825883a 	mov	r18,r7
81131618:	003e3606 	br	81130ef4 <__reset+0xfb110ef4>
8113161c:	0101ffc4 	movi	r4,2047
81131620:	493fc71e 	bne	r9,r4,81131540 <__reset+0xfb111540>
81131624:	2807883a 	mov	r3,r5
81131628:	3023883a 	mov	r17,r6
8113162c:	4821883a 	mov	r16,r9
81131630:	003e3006 	br	81130ef4 <__reset+0xfb110ef4>
81131634:	10003626 	beq	r2,zero,81131710 <__subdf3+0x8a8>
81131638:	2984b03a 	or	r2,r5,r6
8113163c:	10001726 	beq	r2,zero,8113169c <__subdf3+0x834>
81131640:	1808d0fa 	srli	r4,r3,3
81131644:	8822d0fa 	srli	r17,r17,3
81131648:	1806977a 	slli	r3,r3,29
8113164c:	2080022c 	andhi	r2,r4,8
81131650:	1c62b03a 	or	r17,r3,r17
81131654:	10000726 	beq	r2,zero,81131674 <__subdf3+0x80c>
81131658:	2812d0fa 	srli	r9,r5,3
8113165c:	4880022c 	andhi	r2,r9,8
81131660:	1000041e 	bne	r2,zero,81131674 <__subdf3+0x80c>
81131664:	300cd0fa 	srli	r6,r6,3
81131668:	2804977a 	slli	r2,r5,29
8113166c:	4809883a 	mov	r4,r9
81131670:	11a2b03a 	or	r17,r2,r6
81131674:	8806d77a 	srli	r3,r17,29
81131678:	200890fa 	slli	r4,r4,3
8113167c:	882290fa 	slli	r17,r17,3
81131680:	3825883a 	mov	r18,r7
81131684:	1906b03a 	or	r3,r3,r4
81131688:	0401ffc4 	movi	r16,2047
8113168c:	003e1906 	br	81130ef4 <__reset+0xfb110ef4>
81131690:	000b883a 	mov	r5,zero
81131694:	0005883a 	mov	r2,zero
81131698:	003e2e06 	br	81130f54 <__reset+0xfb110f54>
8113169c:	0401ffc4 	movi	r16,2047
811316a0:	003e1406 	br	81130ef4 <__reset+0xfb110ef4>
811316a4:	0005883a 	mov	r2,zero
811316a8:	003f7506 	br	81131480 <__reset+0xfb111480>
811316ac:	0005883a 	mov	r2,zero
811316b0:	0009883a 	mov	r4,zero
811316b4:	003e7806 	br	81131098 <__reset+0xfb111098>
811316b8:	123ff804 	addi	r8,r2,-32
811316bc:	01000804 	movi	r4,32
811316c0:	1a10d83a 	srl	r8,r3,r8
811316c4:	11002526 	beq	r2,r4,8113175c <__subdf3+0x8f4>
811316c8:	01001004 	movi	r4,64
811316cc:	2085c83a 	sub	r2,r4,r2
811316d0:	1884983a 	sll	r2,r3,r2
811316d4:	1444b03a 	or	r2,r2,r17
811316d8:	1004c03a 	cmpne	r2,r2,zero
811316dc:	40a2b03a 	or	r17,r8,r2
811316e0:	0005883a 	mov	r2,zero
811316e4:	003f1606 	br	81131340 <__reset+0xfb111340>
811316e8:	02000434 	movhi	r8,16
811316ec:	0009883a 	mov	r4,zero
811316f0:	423fffc4 	addi	r8,r8,-1
811316f4:	00bfffc4 	movi	r2,-1
811316f8:	0401ffc4 	movi	r16,2047
811316fc:	003e6606 	br	81131098 <__reset+0xfb111098>
81131700:	1c62b03a 	or	r17,r3,r17
81131704:	8822c03a 	cmpne	r17,r17,zero
81131708:	0005883a 	mov	r2,zero
8113170c:	003f9906 	br	81131574 <__reset+0xfb111574>
81131710:	2807883a 	mov	r3,r5
81131714:	3023883a 	mov	r17,r6
81131718:	0401ffc4 	movi	r16,2047
8113171c:	003df506 	br	81130ef4 <__reset+0xfb110ef4>
81131720:	2807883a 	mov	r3,r5
81131724:	3023883a 	mov	r17,r6
81131728:	003df206 	br	81130ef4 <__reset+0xfb110ef4>
8113172c:	123ff804 	addi	r8,r2,-32
81131730:	01000804 	movi	r4,32
81131734:	1a10d83a 	srl	r8,r3,r8
81131738:	11000a26 	beq	r2,r4,81131764 <__subdf3+0x8fc>
8113173c:	01001004 	movi	r4,64
81131740:	2085c83a 	sub	r2,r4,r2
81131744:	1884983a 	sll	r2,r3,r2
81131748:	1444b03a 	or	r2,r2,r17
8113174c:	1004c03a 	cmpne	r2,r2,zero
81131750:	40a2b03a 	or	r17,r8,r2
81131754:	0005883a 	mov	r2,zero
81131758:	003f8606 	br	81131574 <__reset+0xfb111574>
8113175c:	0005883a 	mov	r2,zero
81131760:	003fdc06 	br	811316d4 <__reset+0xfb1116d4>
81131764:	0005883a 	mov	r2,zero
81131768:	003ff706 	br	81131748 <__reset+0xfb111748>

8113176c <__fixdfsi>:
8113176c:	280cd53a 	srli	r6,r5,20
81131770:	00c00434 	movhi	r3,16
81131774:	18ffffc4 	addi	r3,r3,-1
81131778:	3181ffcc 	andi	r6,r6,2047
8113177c:	01c0ff84 	movi	r7,1022
81131780:	28c6703a 	and	r3,r5,r3
81131784:	280ad7fa 	srli	r5,r5,31
81131788:	3980120e 	bge	r7,r6,811317d4 <__fixdfsi+0x68>
8113178c:	00810744 	movi	r2,1053
81131790:	11800c16 	blt	r2,r6,811317c4 <__fixdfsi+0x58>
81131794:	00810cc4 	movi	r2,1075
81131798:	1185c83a 	sub	r2,r2,r6
8113179c:	01c007c4 	movi	r7,31
811317a0:	18c00434 	orhi	r3,r3,16
811317a4:	38800d16 	blt	r7,r2,811317dc <__fixdfsi+0x70>
811317a8:	31befb44 	addi	r6,r6,-1043
811317ac:	2084d83a 	srl	r2,r4,r2
811317b0:	1986983a 	sll	r3,r3,r6
811317b4:	1884b03a 	or	r2,r3,r2
811317b8:	28000726 	beq	r5,zero,811317d8 <__fixdfsi+0x6c>
811317bc:	0085c83a 	sub	r2,zero,r2
811317c0:	f800283a 	ret
811317c4:	00a00034 	movhi	r2,32768
811317c8:	10bfffc4 	addi	r2,r2,-1
811317cc:	2885883a 	add	r2,r5,r2
811317d0:	f800283a 	ret
811317d4:	0005883a 	mov	r2,zero
811317d8:	f800283a 	ret
811317dc:	008104c4 	movi	r2,1043
811317e0:	1185c83a 	sub	r2,r2,r6
811317e4:	1884d83a 	srl	r2,r3,r2
811317e8:	003ff306 	br	811317b8 <__reset+0xfb1117b8>

811317ec <__floatsidf>:
811317ec:	defffd04 	addi	sp,sp,-12
811317f0:	de00012e 	bgeu	sp,et,811317f8 <__floatsidf+0xc>
811317f4:	003b68fa 	trap	3
811317f8:	dfc00215 	stw	ra,8(sp)
811317fc:	dc400115 	stw	r17,4(sp)
81131800:	dc000015 	stw	r16,0(sp)
81131804:	20002b26 	beq	r4,zero,811318b4 <__floatsidf+0xc8>
81131808:	2023883a 	mov	r17,r4
8113180c:	2020d7fa 	srli	r16,r4,31
81131810:	20002d16 	blt	r4,zero,811318c8 <__floatsidf+0xdc>
81131814:	8809883a 	mov	r4,r17
81131818:	111bf5c0 	call	8111bf5c <__clzsi2>
8113181c:	01410784 	movi	r5,1054
81131820:	288bc83a 	sub	r5,r5,r2
81131824:	01010cc4 	movi	r4,1075
81131828:	2149c83a 	sub	r4,r4,r5
8113182c:	00c007c4 	movi	r3,31
81131830:	1900160e 	bge	r3,r4,8113188c <__floatsidf+0xa0>
81131834:	00c104c4 	movi	r3,1043
81131838:	1947c83a 	sub	r3,r3,r5
8113183c:	88c6983a 	sll	r3,r17,r3
81131840:	00800434 	movhi	r2,16
81131844:	10bfffc4 	addi	r2,r2,-1
81131848:	1886703a 	and	r3,r3,r2
8113184c:	2941ffcc 	andi	r5,r5,2047
81131850:	800d883a 	mov	r6,r16
81131854:	0005883a 	mov	r2,zero
81131858:	280a953a 	slli	r5,r5,20
8113185c:	31803fcc 	andi	r6,r6,255
81131860:	01000434 	movhi	r4,16
81131864:	300c97fa 	slli	r6,r6,31
81131868:	213fffc4 	addi	r4,r4,-1
8113186c:	1906703a 	and	r3,r3,r4
81131870:	1946b03a 	or	r3,r3,r5
81131874:	1986b03a 	or	r3,r3,r6
81131878:	dfc00217 	ldw	ra,8(sp)
8113187c:	dc400117 	ldw	r17,4(sp)
81131880:	dc000017 	ldw	r16,0(sp)
81131884:	dec00304 	addi	sp,sp,12
81131888:	f800283a 	ret
8113188c:	00c002c4 	movi	r3,11
81131890:	1887c83a 	sub	r3,r3,r2
81131894:	88c6d83a 	srl	r3,r17,r3
81131898:	8904983a 	sll	r2,r17,r4
8113189c:	01000434 	movhi	r4,16
811318a0:	213fffc4 	addi	r4,r4,-1
811318a4:	2941ffcc 	andi	r5,r5,2047
811318a8:	1906703a 	and	r3,r3,r4
811318ac:	800d883a 	mov	r6,r16
811318b0:	003fe906 	br	81131858 <__reset+0xfb111858>
811318b4:	000d883a 	mov	r6,zero
811318b8:	000b883a 	mov	r5,zero
811318bc:	0007883a 	mov	r3,zero
811318c0:	0005883a 	mov	r2,zero
811318c4:	003fe406 	br	81131858 <__reset+0xfb111858>
811318c8:	0123c83a 	sub	r17,zero,r4
811318cc:	003fd106 	br	81131814 <__reset+0xfb111814>

811318d0 <__floatunsidf>:
811318d0:	defffe04 	addi	sp,sp,-8
811318d4:	de00012e 	bgeu	sp,et,811318dc <__floatunsidf+0xc>
811318d8:	003b68fa 	trap	3
811318dc:	dc000015 	stw	r16,0(sp)
811318e0:	dfc00115 	stw	ra,4(sp)
811318e4:	2021883a 	mov	r16,r4
811318e8:	20002226 	beq	r4,zero,81131974 <__floatunsidf+0xa4>
811318ec:	111bf5c0 	call	8111bf5c <__clzsi2>
811318f0:	01010784 	movi	r4,1054
811318f4:	2089c83a 	sub	r4,r4,r2
811318f8:	01810cc4 	movi	r6,1075
811318fc:	310dc83a 	sub	r6,r6,r4
81131900:	00c007c4 	movi	r3,31
81131904:	1980120e 	bge	r3,r6,81131950 <__floatunsidf+0x80>
81131908:	00c104c4 	movi	r3,1043
8113190c:	1907c83a 	sub	r3,r3,r4
81131910:	80ca983a 	sll	r5,r16,r3
81131914:	00800434 	movhi	r2,16
81131918:	10bfffc4 	addi	r2,r2,-1
8113191c:	2101ffcc 	andi	r4,r4,2047
81131920:	0021883a 	mov	r16,zero
81131924:	288a703a 	and	r5,r5,r2
81131928:	2008953a 	slli	r4,r4,20
8113192c:	00c00434 	movhi	r3,16
81131930:	18ffffc4 	addi	r3,r3,-1
81131934:	28c6703a 	and	r3,r5,r3
81131938:	8005883a 	mov	r2,r16
8113193c:	1906b03a 	or	r3,r3,r4
81131940:	dfc00117 	ldw	ra,4(sp)
81131944:	dc000017 	ldw	r16,0(sp)
81131948:	dec00204 	addi	sp,sp,8
8113194c:	f800283a 	ret
81131950:	00c002c4 	movi	r3,11
81131954:	188bc83a 	sub	r5,r3,r2
81131958:	814ad83a 	srl	r5,r16,r5
8113195c:	00c00434 	movhi	r3,16
81131960:	18ffffc4 	addi	r3,r3,-1
81131964:	81a0983a 	sll	r16,r16,r6
81131968:	2101ffcc 	andi	r4,r4,2047
8113196c:	28ca703a 	and	r5,r5,r3
81131970:	003fed06 	br	81131928 <__reset+0xfb111928>
81131974:	0009883a 	mov	r4,zero
81131978:	000b883a 	mov	r5,zero
8113197c:	003fea06 	br	81131928 <__reset+0xfb111928>

81131980 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81131980:	defffb04 	addi	sp,sp,-20
81131984:	de00012e 	bgeu	sp,et,8113198c <alt_busy_sleep+0xc>
81131988:	003b68fa 	trap	3
8113198c:	df000415 	stw	fp,16(sp)
81131990:	df000404 	addi	fp,sp,16
81131994:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81131998:	008000c4 	movi	r2,3
8113199c:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
811319a0:	e0fffd17 	ldw	r3,-12(fp)
811319a4:	008003f4 	movhi	r2,15
811319a8:	10909004 	addi	r2,r2,16960
811319ac:	1887383a 	mul	r3,r3,r2
811319b0:	00817db4 	movhi	r2,1526
811319b4:	10b84004 	addi	r2,r2,-7936
811319b8:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
811319bc:	00a00034 	movhi	r2,32768
811319c0:	10bfffc4 	addi	r2,r2,-1
811319c4:	10c5203a 	divu	r2,r2,r3
811319c8:	e0ffff17 	ldw	r3,-4(fp)
811319cc:	1885203a 	divu	r2,r3,r2
811319d0:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
811319d4:	e0bffe17 	ldw	r2,-8(fp)
811319d8:	10002526 	beq	r2,zero,81131a70 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
811319dc:	e03ffc15 	stw	zero,-16(fp)
811319e0:	00001406 	br	81131a34 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
811319e4:	00a00034 	movhi	r2,32768
811319e8:	10bfffc4 	addi	r2,r2,-1
811319ec:	10bfffc4 	addi	r2,r2,-1
811319f0:	103ffe1e 	bne	r2,zero,811319ec <__reset+0xfb1119ec>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
811319f4:	e0fffd17 	ldw	r3,-12(fp)
811319f8:	008003f4 	movhi	r2,15
811319fc:	10909004 	addi	r2,r2,16960
81131a00:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81131a04:	00817db4 	movhi	r2,1526
81131a08:	10b84004 	addi	r2,r2,-7936
81131a0c:	10c7203a 	divu	r3,r2,r3
81131a10:	00a00034 	movhi	r2,32768
81131a14:	10bfffc4 	addi	r2,r2,-1
81131a18:	10c5203a 	divu	r2,r2,r3
81131a1c:	e0ffff17 	ldw	r3,-4(fp)
81131a20:	1885c83a 	sub	r2,r3,r2
81131a24:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81131a28:	e0bffc17 	ldw	r2,-16(fp)
81131a2c:	10800044 	addi	r2,r2,1
81131a30:	e0bffc15 	stw	r2,-16(fp)
81131a34:	e0fffc17 	ldw	r3,-16(fp)
81131a38:	e0bffe17 	ldw	r2,-8(fp)
81131a3c:	18bfe916 	blt	r3,r2,811319e4 <__reset+0xfb1119e4>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81131a40:	e0fffd17 	ldw	r3,-12(fp)
81131a44:	008003f4 	movhi	r2,15
81131a48:	10909004 	addi	r2,r2,16960
81131a4c:	1887383a 	mul	r3,r3,r2
81131a50:	00817db4 	movhi	r2,1526
81131a54:	10b84004 	addi	r2,r2,-7936
81131a58:	10c7203a 	divu	r3,r2,r3
81131a5c:	e0bfff17 	ldw	r2,-4(fp)
81131a60:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81131a64:	10bfffc4 	addi	r2,r2,-1
81131a68:	103ffe1e 	bne	r2,zero,81131a64 <__reset+0xfb111a64>
81131a6c:	00000b06 	br	81131a9c <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81131a70:	e0fffd17 	ldw	r3,-12(fp)
81131a74:	008003f4 	movhi	r2,15
81131a78:	10909004 	addi	r2,r2,16960
81131a7c:	1887383a 	mul	r3,r3,r2
81131a80:	00817db4 	movhi	r2,1526
81131a84:	10b84004 	addi	r2,r2,-7936
81131a88:	10c7203a 	divu	r3,r2,r3
81131a8c:	e0bfff17 	ldw	r2,-4(fp)
81131a90:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81131a94:	10bfffc4 	addi	r2,r2,-1
81131a98:	00bffe16 	blt	zero,r2,81131a94 <__reset+0xfb111a94>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81131a9c:	0005883a 	mov	r2,zero
}
81131aa0:	e037883a 	mov	sp,fp
81131aa4:	df000017 	ldw	fp,0(sp)
81131aa8:	dec00104 	addi	sp,sp,4
81131aac:	f800283a 	ret

81131ab0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131ab0:	defffe04 	addi	sp,sp,-8
81131ab4:	de00012e 	bgeu	sp,et,81131abc <alt_get_errno+0xc>
81131ab8:	003b68fa 	trap	3
81131abc:	dfc00115 	stw	ra,4(sp)
81131ac0:	df000015 	stw	fp,0(sp)
81131ac4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131ac8:	d0a01017 	ldw	r2,-32704(gp)
81131acc:	10000326 	beq	r2,zero,81131adc <alt_get_errno+0x2c>
81131ad0:	d0a01017 	ldw	r2,-32704(gp)
81131ad4:	103ee83a 	callr	r2
81131ad8:	00000106 	br	81131ae0 <alt_get_errno+0x30>
81131adc:	d0a07304 	addi	r2,gp,-32308
}
81131ae0:	e037883a 	mov	sp,fp
81131ae4:	dfc00117 	ldw	ra,4(sp)
81131ae8:	df000017 	ldw	fp,0(sp)
81131aec:	dec00204 	addi	sp,sp,8
81131af0:	f800283a 	ret

81131af4 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81131af4:	defffb04 	addi	sp,sp,-20
81131af8:	de00012e 	bgeu	sp,et,81131b00 <close+0xc>
81131afc:	003b68fa 	trap	3
81131b00:	dfc00415 	stw	ra,16(sp)
81131b04:	df000315 	stw	fp,12(sp)
81131b08:	df000304 	addi	fp,sp,12
81131b0c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81131b10:	e0bfff17 	ldw	r2,-4(fp)
81131b14:	10000616 	blt	r2,zero,81131b30 <close+0x3c>
81131b18:	e0bfff17 	ldw	r2,-4(fp)
81131b1c:	10c00324 	muli	r3,r2,12
81131b20:	00a04574 	movhi	r2,33045
81131b24:	10b2be04 	addi	r2,r2,-13576
81131b28:	1885883a 	add	r2,r3,r2
81131b2c:	00000106 	br	81131b34 <close+0x40>
81131b30:	0005883a 	mov	r2,zero
81131b34:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81131b38:	e0bffd17 	ldw	r2,-12(fp)
81131b3c:	10001926 	beq	r2,zero,81131ba4 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81131b40:	e0bffd17 	ldw	r2,-12(fp)
81131b44:	10800017 	ldw	r2,0(r2)
81131b48:	10800417 	ldw	r2,16(r2)
81131b4c:	10000626 	beq	r2,zero,81131b68 <close+0x74>
81131b50:	e0bffd17 	ldw	r2,-12(fp)
81131b54:	10800017 	ldw	r2,0(r2)
81131b58:	10800417 	ldw	r2,16(r2)
81131b5c:	e13ffd17 	ldw	r4,-12(fp)
81131b60:	103ee83a 	callr	r2
81131b64:	00000106 	br	81131b6c <close+0x78>
81131b68:	0005883a 	mov	r2,zero
81131b6c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81131b70:	e13fff17 	ldw	r4,-4(fp)
81131b74:	11330d80 	call	811330d8 <alt_release_fd>
    if (rval < 0)
81131b78:	e0bffe17 	ldw	r2,-8(fp)
81131b7c:	1000070e 	bge	r2,zero,81131b9c <close+0xa8>
    {
      ALT_ERRNO = -rval;
81131b80:	1131ab00 	call	81131ab0 <alt_get_errno>
81131b84:	1007883a 	mov	r3,r2
81131b88:	e0bffe17 	ldw	r2,-8(fp)
81131b8c:	0085c83a 	sub	r2,zero,r2
81131b90:	18800015 	stw	r2,0(r3)
      return -1;
81131b94:	00bfffc4 	movi	r2,-1
81131b98:	00000706 	br	81131bb8 <close+0xc4>
    }
    return 0;
81131b9c:	0005883a 	mov	r2,zero
81131ba0:	00000506 	br	81131bb8 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81131ba4:	1131ab00 	call	81131ab0 <alt_get_errno>
81131ba8:	1007883a 	mov	r3,r2
81131bac:	00801444 	movi	r2,81
81131bb0:	18800015 	stw	r2,0(r3)
    return -1;
81131bb4:	00bfffc4 	movi	r2,-1
  }
}
81131bb8:	e037883a 	mov	sp,fp
81131bbc:	dfc00117 	ldw	ra,4(sp)
81131bc0:	df000017 	ldw	fp,0(sp)
81131bc4:	dec00204 	addi	sp,sp,8
81131bc8:	f800283a 	ret

81131bcc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
81131bcc:	deffff04 	addi	sp,sp,-4
81131bd0:	de00012e 	bgeu	sp,et,81131bd8 <alt_dcache_flush_all+0xc>
81131bd4:	003b68fa 	trap	3
81131bd8:	df000015 	stw	fp,0(sp)
81131bdc:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81131be0:	0001883a 	nop
81131be4:	e037883a 	mov	sp,fp
81131be8:	df000017 	ldw	fp,0(sp)
81131bec:	dec00104 	addi	sp,sp,4
81131bf0:	f800283a 	ret

81131bf4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81131bf4:	defffc04 	addi	sp,sp,-16
81131bf8:	de00012e 	bgeu	sp,et,81131c00 <alt_dev_null_write+0xc>
81131bfc:	003b68fa 	trap	3
81131c00:	df000315 	stw	fp,12(sp)
81131c04:	df000304 	addi	fp,sp,12
81131c08:	e13ffd15 	stw	r4,-12(fp)
81131c0c:	e17ffe15 	stw	r5,-8(fp)
81131c10:	e1bfff15 	stw	r6,-4(fp)
  return len;
81131c14:	e0bfff17 	ldw	r2,-4(fp)
}
81131c18:	e037883a 	mov	sp,fp
81131c1c:	df000017 	ldw	fp,0(sp)
81131c20:	dec00104 	addi	sp,sp,4
81131c24:	f800283a 	ret

81131c28 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131c28:	defffe04 	addi	sp,sp,-8
81131c2c:	de00012e 	bgeu	sp,et,81131c34 <alt_get_errno+0xc>
81131c30:	003b68fa 	trap	3
81131c34:	dfc00115 	stw	ra,4(sp)
81131c38:	df000015 	stw	fp,0(sp)
81131c3c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131c40:	d0a01017 	ldw	r2,-32704(gp)
81131c44:	10000326 	beq	r2,zero,81131c54 <alt_get_errno+0x2c>
81131c48:	d0a01017 	ldw	r2,-32704(gp)
81131c4c:	103ee83a 	callr	r2
81131c50:	00000106 	br	81131c58 <alt_get_errno+0x30>
81131c54:	d0a07304 	addi	r2,gp,-32308
}
81131c58:	e037883a 	mov	sp,fp
81131c5c:	dfc00117 	ldw	ra,4(sp)
81131c60:	df000017 	ldw	fp,0(sp)
81131c64:	dec00204 	addi	sp,sp,8
81131c68:	f800283a 	ret

81131c6c <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81131c6c:	defffb04 	addi	sp,sp,-20
81131c70:	de00012e 	bgeu	sp,et,81131c78 <fstat+0xc>
81131c74:	003b68fa 	trap	3
81131c78:	dfc00415 	stw	ra,16(sp)
81131c7c:	df000315 	stw	fp,12(sp)
81131c80:	df000304 	addi	fp,sp,12
81131c84:	e13ffe15 	stw	r4,-8(fp)
81131c88:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81131c8c:	e0bffe17 	ldw	r2,-8(fp)
81131c90:	10000616 	blt	r2,zero,81131cac <fstat+0x40>
81131c94:	e0bffe17 	ldw	r2,-8(fp)
81131c98:	10c00324 	muli	r3,r2,12
81131c9c:	00a04574 	movhi	r2,33045
81131ca0:	10b2be04 	addi	r2,r2,-13576
81131ca4:	1885883a 	add	r2,r3,r2
81131ca8:	00000106 	br	81131cb0 <fstat+0x44>
81131cac:	0005883a 	mov	r2,zero
81131cb0:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81131cb4:	e0bffd17 	ldw	r2,-12(fp)
81131cb8:	10001026 	beq	r2,zero,81131cfc <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81131cbc:	e0bffd17 	ldw	r2,-12(fp)
81131cc0:	10800017 	ldw	r2,0(r2)
81131cc4:	10800817 	ldw	r2,32(r2)
81131cc8:	10000726 	beq	r2,zero,81131ce8 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
81131ccc:	e0bffd17 	ldw	r2,-12(fp)
81131cd0:	10800017 	ldw	r2,0(r2)
81131cd4:	10800817 	ldw	r2,32(r2)
81131cd8:	e17fff17 	ldw	r5,-4(fp)
81131cdc:	e13ffd17 	ldw	r4,-12(fp)
81131ce0:	103ee83a 	callr	r2
81131ce4:	00000a06 	br	81131d10 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
81131ce8:	e0bfff17 	ldw	r2,-4(fp)
81131cec:	00c80004 	movi	r3,8192
81131cf0:	10c00115 	stw	r3,4(r2)
      return 0;
81131cf4:	0005883a 	mov	r2,zero
81131cf8:	00000506 	br	81131d10 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81131cfc:	1131c280 	call	81131c28 <alt_get_errno>
81131d00:	1007883a 	mov	r3,r2
81131d04:	00801444 	movi	r2,81
81131d08:	18800015 	stw	r2,0(r3)
    return -1;
81131d0c:	00bfffc4 	movi	r2,-1
  }
}
81131d10:	e037883a 	mov	sp,fp
81131d14:	dfc00117 	ldw	ra,4(sp)
81131d18:	df000017 	ldw	fp,0(sp)
81131d1c:	dec00204 	addi	sp,sp,8
81131d20:	f800283a 	ret

81131d24 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81131d24:	defff004 	addi	sp,sp,-64
81131d28:	de00012e 	bgeu	sp,et,81131d30 <alt_irq_register+0xc>
81131d2c:	003b68fa 	trap	3
81131d30:	df000f15 	stw	fp,60(sp)
81131d34:	df000f04 	addi	fp,sp,60
81131d38:	e13ffd15 	stw	r4,-12(fp)
81131d3c:	e17ffe15 	stw	r5,-8(fp)
81131d40:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81131d44:	00bffa84 	movi	r2,-22
81131d48:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81131d4c:	e0bffd17 	ldw	r2,-12(fp)
81131d50:	10800828 	cmpgeui	r2,r2,32
81131d54:	1000501e 	bne	r2,zero,81131e98 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131d58:	0005303a 	rdctl	r2,status
81131d5c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131d60:	e0fff617 	ldw	r3,-40(fp)
81131d64:	00bfff84 	movi	r2,-2
81131d68:	1884703a 	and	r2,r3,r2
81131d6c:	1001703a 	wrctl	status,r2
  
  return context;
81131d70:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81131d74:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81131d78:	00a045b4 	movhi	r2,33046
81131d7c:	109f9204 	addi	r2,r2,32328
81131d80:	e0fffd17 	ldw	r3,-12(fp)
81131d84:	180690fa 	slli	r3,r3,3
81131d88:	10c5883a 	add	r2,r2,r3
81131d8c:	e0ffff17 	ldw	r3,-4(fp)
81131d90:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
81131d94:	00a045b4 	movhi	r2,33046
81131d98:	109f9204 	addi	r2,r2,32328
81131d9c:	e0fffd17 	ldw	r3,-12(fp)
81131da0:	180690fa 	slli	r3,r3,3
81131da4:	10c5883a 	add	r2,r2,r3
81131da8:	10800104 	addi	r2,r2,4
81131dac:	e0fffe17 	ldw	r3,-8(fp)
81131db0:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
81131db4:	e0bfff17 	ldw	r2,-4(fp)
81131db8:	10001926 	beq	r2,zero,81131e20 <alt_irq_register+0xfc>
81131dbc:	e0bffd17 	ldw	r2,-12(fp)
81131dc0:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131dc4:	0005303a 	rdctl	r2,status
81131dc8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131dcc:	e0fff717 	ldw	r3,-36(fp)
81131dd0:	00bfff84 	movi	r2,-2
81131dd4:	1884703a 	and	r2,r3,r2
81131dd8:	1001703a 	wrctl	status,r2
  
  return context;
81131ddc:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81131de0:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81131de4:	00c00044 	movi	r3,1
81131de8:	e0bff217 	ldw	r2,-56(fp)
81131dec:	1884983a 	sll	r2,r3,r2
81131df0:	1007883a 	mov	r3,r2
81131df4:	d0a07b17 	ldw	r2,-32276(gp)
81131df8:	1884b03a 	or	r2,r3,r2
81131dfc:	d0a07b15 	stw	r2,-32276(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81131e00:	d0a07b17 	ldw	r2,-32276(gp)
81131e04:	100170fa 	wrctl	ienable,r2
81131e08:	e0bff817 	ldw	r2,-32(fp)
81131e0c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131e10:	e0bff917 	ldw	r2,-28(fp)
81131e14:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81131e18:	0005883a 	mov	r2,zero
81131e1c:	00001906 	br	81131e84 <alt_irq_register+0x160>
81131e20:	e0bffd17 	ldw	r2,-12(fp)
81131e24:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131e28:	0005303a 	rdctl	r2,status
81131e2c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131e30:	e0fffa17 	ldw	r3,-24(fp)
81131e34:	00bfff84 	movi	r2,-2
81131e38:	1884703a 	and	r2,r3,r2
81131e3c:	1001703a 	wrctl	status,r2
  
  return context;
81131e40:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81131e44:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81131e48:	00c00044 	movi	r3,1
81131e4c:	e0bff417 	ldw	r2,-48(fp)
81131e50:	1884983a 	sll	r2,r3,r2
81131e54:	0084303a 	nor	r2,zero,r2
81131e58:	1007883a 	mov	r3,r2
81131e5c:	d0a07b17 	ldw	r2,-32276(gp)
81131e60:	1884703a 	and	r2,r3,r2
81131e64:	d0a07b15 	stw	r2,-32276(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81131e68:	d0a07b17 	ldw	r2,-32276(gp)
81131e6c:	100170fa 	wrctl	ienable,r2
81131e70:	e0bffb17 	ldw	r2,-20(fp)
81131e74:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131e78:	e0bffc17 	ldw	r2,-16(fp)
81131e7c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81131e80:	0005883a 	mov	r2,zero
81131e84:	e0bff115 	stw	r2,-60(fp)
81131e88:	e0bff317 	ldw	r2,-52(fp)
81131e8c:	e0bff515 	stw	r2,-44(fp)
81131e90:	e0bff517 	ldw	r2,-44(fp)
81131e94:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81131e98:	e0bff117 	ldw	r2,-60(fp)
}
81131e9c:	e037883a 	mov	sp,fp
81131ea0:	df000017 	ldw	fp,0(sp)
81131ea4:	dec00104 	addi	sp,sp,4
81131ea8:	f800283a 	ret

81131eac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131eac:	defffe04 	addi	sp,sp,-8
81131eb0:	de00012e 	bgeu	sp,et,81131eb8 <alt_get_errno+0xc>
81131eb4:	003b68fa 	trap	3
81131eb8:	dfc00115 	stw	ra,4(sp)
81131ebc:	df000015 	stw	fp,0(sp)
81131ec0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131ec4:	d0a01017 	ldw	r2,-32704(gp)
81131ec8:	10000326 	beq	r2,zero,81131ed8 <alt_get_errno+0x2c>
81131ecc:	d0a01017 	ldw	r2,-32704(gp)
81131ed0:	103ee83a 	callr	r2
81131ed4:	00000106 	br	81131edc <alt_get_errno+0x30>
81131ed8:	d0a07304 	addi	r2,gp,-32308
}
81131edc:	e037883a 	mov	sp,fp
81131ee0:	dfc00117 	ldw	ra,4(sp)
81131ee4:	df000017 	ldw	fp,0(sp)
81131ee8:	dec00204 	addi	sp,sp,8
81131eec:	f800283a 	ret

81131ef0 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81131ef0:	deffed04 	addi	sp,sp,-76
81131ef4:	de00012e 	bgeu	sp,et,81131efc <isatty+0xc>
81131ef8:	003b68fa 	trap	3
81131efc:	dfc01215 	stw	ra,72(sp)
81131f00:	df001115 	stw	fp,68(sp)
81131f04:	df001104 	addi	fp,sp,68
81131f08:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81131f0c:	e0bfff17 	ldw	r2,-4(fp)
81131f10:	10000616 	blt	r2,zero,81131f2c <isatty+0x3c>
81131f14:	e0bfff17 	ldw	r2,-4(fp)
81131f18:	10c00324 	muli	r3,r2,12
81131f1c:	00a04574 	movhi	r2,33045
81131f20:	10b2be04 	addi	r2,r2,-13576
81131f24:	1885883a 	add	r2,r3,r2
81131f28:	00000106 	br	81131f30 <isatty+0x40>
81131f2c:	0005883a 	mov	r2,zero
81131f30:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81131f34:	e0bfef17 	ldw	r2,-68(fp)
81131f38:	10000e26 	beq	r2,zero,81131f74 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81131f3c:	e0bfef17 	ldw	r2,-68(fp)
81131f40:	10800017 	ldw	r2,0(r2)
81131f44:	10800817 	ldw	r2,32(r2)
81131f48:	1000021e 	bne	r2,zero,81131f54 <isatty+0x64>
    {
      return 1;
81131f4c:	00800044 	movi	r2,1
81131f50:	00000d06 	br	81131f88 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81131f54:	e0bff004 	addi	r2,fp,-64
81131f58:	100b883a 	mov	r5,r2
81131f5c:	e13fff17 	ldw	r4,-4(fp)
81131f60:	1131c6c0 	call	81131c6c <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81131f64:	e0bff117 	ldw	r2,-60(fp)
81131f68:	10880020 	cmpeqi	r2,r2,8192
81131f6c:	10803fcc 	andi	r2,r2,255
81131f70:	00000506 	br	81131f88 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81131f74:	1131eac0 	call	81131eac <alt_get_errno>
81131f78:	1007883a 	mov	r3,r2
81131f7c:	00801444 	movi	r2,81
81131f80:	18800015 	stw	r2,0(r3)
    return 0;
81131f84:	0005883a 	mov	r2,zero
  }
}
81131f88:	e037883a 	mov	sp,fp
81131f8c:	dfc00117 	ldw	ra,4(sp)
81131f90:	df000017 	ldw	fp,0(sp)
81131f94:	dec00204 	addi	sp,sp,8
81131f98:	f800283a 	ret

81131f9c <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81131f9c:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81131fa0:	318c2404 	addi	r6,r6,12432

81131fa4 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
81131fa4:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
81131fa8:	01c00826 	beq	zero,r7,81131fcc <end_tx>

81131fac <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
81131fac:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81131fb0:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
81131fb4:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
81131fb8:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81131fbc:	283ffb26 	beq	r5,zero,81131fac <__reset+0xfb111fac>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81131fc0:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81131fc4:	21000044 	addi	r4,r4,1
	br tx_next_char
81131fc8:	003ff606 	br	81131fa4 <__reset+0xfb111fa4>

81131fcc <end_tx>:
end_tx:	
        ret
81131fcc:	f800283a 	ret

81131fd0 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81131fd0:	defffd04 	addi	sp,sp,-12
81131fd4:	de00012e 	bgeu	sp,et,81131fdc <alt_log_txchar+0xc>
81131fd8:	003b68fa 	trap	3
81131fdc:	df000215 	stw	fp,8(sp)
81131fe0:	df000204 	addi	fp,sp,8
81131fe4:	e13ffe15 	stw	r4,-8(fp)
81131fe8:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81131fec:	0001883a 	nop
81131ff0:	e0bfff17 	ldw	r2,-4(fp)
81131ff4:	10800104 	addi	r2,r2,4
81131ff8:	10800037 	ldwio	r2,0(r2)
81131ffc:	10bfffec 	andhi	r2,r2,65535
81132000:	103ffb26 	beq	r2,zero,81131ff0 <__reset+0xfb111ff0>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81132004:	e0bfff17 	ldw	r2,-4(fp)
81132008:	e0fffe17 	ldw	r3,-8(fp)
8113200c:	10c00035 	stwio	r3,0(r2)
}
81132010:	0001883a 	nop
81132014:	e037883a 	mov	sp,fp
81132018:	df000017 	ldw	fp,0(sp)
8113201c:	dec00104 	addi	sp,sp,4
81132020:	f800283a 	ret

81132024 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81132024:	defffb04 	addi	sp,sp,-20
81132028:	de00012e 	bgeu	sp,et,81132030 <alt_log_repchar+0xc>
8113202c:	003b68fa 	trap	3
81132030:	dfc00415 	stw	ra,16(sp)
81132034:	df000315 	stw	fp,12(sp)
81132038:	df000304 	addi	fp,sp,12
8113203c:	2005883a 	mov	r2,r4
81132040:	e17ffe15 	stw	r5,-8(fp)
81132044:	e1bfff15 	stw	r6,-4(fp)
81132048:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
8113204c:	00000506 	br	81132064 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81132050:	e0bffd07 	ldb	r2,-12(fp)
81132054:	e0ffff17 	ldw	r3,-4(fp)
81132058:	180b883a 	mov	r5,r3
8113205c:	1009883a 	mov	r4,r2
81132060:	1131fd00 	call	81131fd0 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
81132064:	e0bffe17 	ldw	r2,-8(fp)
81132068:	10ffffc4 	addi	r3,r2,-1
8113206c:	e0fffe15 	stw	r3,-8(fp)
81132070:	00bff716 	blt	zero,r2,81132050 <__reset+0xfb112050>
    alt_log_txchar(c,(char*) base);
}
81132074:	0001883a 	nop
81132078:	e037883a 	mov	sp,fp
8113207c:	dfc00117 	ldw	ra,4(sp)
81132080:	df000017 	ldw	fp,0(sp)
81132084:	dec00204 	addi	sp,sp,8
81132088:	f800283a 	ret

8113208c <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
8113208c:	deffe904 	addi	sp,sp,-92
81132090:	de00012e 	bgeu	sp,et,81132098 <alt_log_private_printf+0xc>
81132094:	003b68fa 	trap	3
81132098:	dfc01615 	stw	ra,88(sp)
8113209c:	df001515 	stw	fp,84(sp)
811320a0:	dc001415 	stw	r16,80(sp)
811320a4:	df001504 	addi	fp,sp,84
811320a8:	e13ffc15 	stw	r4,-16(fp)
811320ac:	e17ffd15 	stw	r5,-12(fp)
811320b0:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
811320b4:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
811320b8:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
811320bc:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
811320c0:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
811320c4:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
811320c8:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
811320cc:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
811320d0:	e0bffc17 	ldw	r2,-16(fp)
811320d4:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
811320d8:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
811320dc:	00014b06 	br	8113260c <alt_log_private_printf+0x580>
    {
    switch(state)
811320e0:	e0bfec17 	ldw	r2,-80(fp)
811320e4:	10c00060 	cmpeqi	r3,r2,1
811320e8:	18001b1e 	bne	r3,zero,81132158 <alt_log_private_printf+0xcc>
811320ec:	10c000a0 	cmpeqi	r3,r2,2
811320f0:	18002d1e 	bne	r3,zero,811321a8 <alt_log_private_printf+0x11c>
811320f4:	10000126 	beq	r2,zero,811320fc <alt_log_private_printf+0x70>
811320f8:	00014406 	br	8113260c <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
811320fc:	e0bffb07 	ldb	r2,-20(fp)
81132100:	10800958 	cmpnei	r2,r2,37
81132104:	10000e1e 	bne	r2,zero,81132140 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81132108:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
8113210c:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81132110:	00800284 	movi	r2,10
81132114:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81132118:	00800044 	movi	r2,1
8113211c:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81132120:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81132124:	00bfffc4 	movi	r2,-1
81132128:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
8113212c:	00bfffc4 	movi	r2,-1
81132130:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81132134:	00800044 	movi	r2,1
81132138:	e0bfec15 	stw	r2,-80(fp)
8113213c:	00013306 	br	8113260c <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81132140:	e0bffb07 	ldb	r2,-20(fp)
81132144:	e0fffd17 	ldw	r3,-12(fp)
81132148:	180b883a 	mov	r5,r3
8113214c:	1009883a 	mov	r4,r2
81132150:	1131fd00 	call	81131fd0 <alt_log_txchar>
        }
        break;
81132154:	00012d06 	br	8113260c <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81132158:	e0bffb07 	ldb	r2,-20(fp)
8113215c:	10800c18 	cmpnei	r2,r2,48
81132160:	1000051e 	bne	r2,zero,81132178 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81132164:	00800044 	movi	r2,1
81132168:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
8113216c:	00800084 	movi	r2,2
81132170:	e0bfec15 	stw	r2,-80(fp)
81132174:	00012506 	br	8113260c <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81132178:	e0bffb07 	ldb	r2,-20(fp)
8113217c:	10800958 	cmpnei	r2,r2,37
81132180:	1000071e 	bne	r2,zero,811321a0 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81132184:	e0bffb07 	ldb	r2,-20(fp)
81132188:	e0fffd17 	ldw	r3,-12(fp)
8113218c:	180b883a 	mov	r5,r3
81132190:	1009883a 	mov	r4,r2
81132194:	1131fd00 	call	81131fd0 <alt_log_txchar>
          state = pfState_chars;
81132198:	e03fec15 	stw	zero,-80(fp)
8113219c:	00011b06 	br	8113260c <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
811321a0:	00800084 	movi	r2,2
811321a4:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
811321a8:	e0bffb07 	ldb	r2,-20(fp)
811321ac:	10800b98 	cmpnei	r2,r2,46
811321b0:	1000021e 	bne	r2,zero,811321bc <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
811321b4:	e03ff015 	stw	zero,-64(fp)
811321b8:	00011306 	br	81132608 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
811321bc:	e0bffb07 	ldb	r2,-20(fp)
811321c0:	10800c10 	cmplti	r2,r2,48
811321c4:	10001a1e 	bne	r2,zero,81132230 <alt_log_private_printf+0x1a4>
811321c8:	e0bffb07 	ldb	r2,-20(fp)
811321cc:	10800e88 	cmpgei	r2,r2,58
811321d0:	1000171e 	bne	r2,zero,81132230 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
811321d4:	e0bffb03 	ldbu	r2,-20(fp)
811321d8:	10bff404 	addi	r2,r2,-48
811321dc:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
811321e0:	e0bff017 	ldw	r2,-64(fp)
811321e4:	10000c0e 	bge	r2,zero,81132218 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
811321e8:	e0bfef17 	ldw	r2,-68(fp)
811321ec:	1000020e 	bge	r2,zero,811321f8 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
811321f0:	e03fef15 	stw	zero,-68(fp)
811321f4:	00000306 	br	81132204 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
811321f8:	e0bfef17 	ldw	r2,-68(fp)
811321fc:	108002a4 	muli	r2,r2,10
81132200:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81132204:	e0bffb07 	ldb	r2,-20(fp)
81132208:	e0ffef17 	ldw	r3,-68(fp)
8113220c:	1885883a 	add	r2,r3,r2
81132210:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81132214:	0000fc06 	br	81132608 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81132218:	e0bff017 	ldw	r2,-64(fp)
8113221c:	10c002a4 	muli	r3,r2,10
81132220:	e0bffb07 	ldb	r2,-20(fp)
81132224:	1885883a 	add	r2,r3,r2
81132228:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8113222c:	0000f606 	br	81132608 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81132230:	e0bffb07 	ldb	r2,-20(fp)
81132234:	10801b18 	cmpnei	r2,r2,108
81132238:	1000031e 	bne	r2,zero,81132248 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
8113223c:	00800044 	movi	r2,1
81132240:	e0bfee15 	stw	r2,-72(fp)
81132244:	0000f006 	br	81132608 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81132248:	e0bffb07 	ldb	r2,-20(fp)
8113224c:	10bfea04 	addi	r2,r2,-88
81132250:	10c00868 	cmpgeui	r3,r2,33
81132254:	1800eb1e 	bne	r3,zero,81132604 <alt_log_private_printf+0x578>
81132258:	100690ba 	slli	r3,r2,2
8113225c:	00a044f4 	movhi	r2,33043
81132260:	10889c04 	addi	r2,r2,8816
81132264:	1885883a 	add	r2,r3,r2
81132268:	10800017 	ldw	r2,0(r2)
8113226c:	1000683a 	jmp	r2
81132270:	81132530 	cmpltui	r4,r16,19604
81132274:	81132604 	addi	r4,r16,19608
81132278:	81132604 	addi	r4,r16,19608
8113227c:	81132604 	addi	r4,r16,19608
81132280:	81132604 	addi	r4,r16,19608
81132284:	81132604 	addi	r4,r16,19608
81132288:	81132604 	addi	r4,r16,19608
8113228c:	81132604 	addi	r4,r16,19608
81132290:	81132604 	addi	r4,r16,19608
81132294:	81132604 	addi	r4,r16,19608
81132298:	81132604 	addi	r4,r16,19608
8113229c:	81132548 	cmpgei	r4,r16,19605
811322a0:	811322f4 	orhi	r4,r16,19595
811322a4:	81132604 	addi	r4,r16,19608
811322a8:	81132604 	addi	r4,r16,19608
811322ac:	81132604 	addi	r4,r16,19608
811322b0:	81132604 	addi	r4,r16,19608
811322b4:	811322f4 	orhi	r4,r16,19595
811322b8:	81132604 	addi	r4,r16,19608
811322bc:	81132604 	addi	r4,r16,19608
811322c0:	81132604 	addi	r4,r16,19608
811322c4:	81132604 	addi	r4,r16,19608
811322c8:	81132604 	addi	r4,r16,19608
811322cc:	81132510 	cmplti	r4,r16,19604
811322d0:	81132604 	addi	r4,r16,19608
811322d4:	81132604 	addi	r4,r16,19608
811322d8:	81132604 	addi	r4,r16,19608
811322dc:	81132584 	addi	r4,r16,19606
811322e0:	81132604 	addi	r4,r16,19608
811322e4:	81132508 	cmpgei	r4,r16,19604
811322e8:	81132604 	addi	r4,r16,19608
811322ec:	81132604 	addi	r4,r16,19608
811322f0:	81132520 	cmpeqi	r4,r16,19604
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
811322f4:	e0bfee17 	ldw	r2,-72(fp)
811322f8:	10000e26 	beq	r2,zero,81132334 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
811322fc:	e0bff217 	ldw	r2,-56(fp)
81132300:	10000626 	beq	r2,zero,8113231c <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81132304:	e0bffe17 	ldw	r2,-8(fp)
81132308:	10c00104 	addi	r3,r2,4
8113230c:	e0fffe15 	stw	r3,-8(fp)
81132310:	10800017 	ldw	r2,0(r2)
81132314:	e0bff415 	stw	r2,-48(fp)
81132318:	00001306 	br	81132368 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
8113231c:	e0bffe17 	ldw	r2,-8(fp)
81132320:	10c00104 	addi	r3,r2,4
81132324:	e0fffe15 	stw	r3,-8(fp)
81132328:	10800017 	ldw	r2,0(r2)
8113232c:	e0bff415 	stw	r2,-48(fp)
81132330:	00000d06 	br	81132368 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81132334:	e0bff217 	ldw	r2,-56(fp)
81132338:	10000626 	beq	r2,zero,81132354 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
8113233c:	e0bffe17 	ldw	r2,-8(fp)
81132340:	10c00104 	addi	r3,r2,4
81132344:	e0fffe15 	stw	r3,-8(fp)
81132348:	10800017 	ldw	r2,0(r2)
8113234c:	e0bff415 	stw	r2,-48(fp)
81132350:	00000506 	br	81132368 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81132354:	e0bffe17 	ldw	r2,-8(fp)
81132358:	10c00104 	addi	r3,r2,4
8113235c:	e0fffe15 	stw	r3,-8(fp)
81132360:	10800017 	ldw	r2,0(r2)
81132364:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81132368:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
8113236c:	e0bff217 	ldw	r2,-56(fp)
81132370:	10000726 	beq	r2,zero,81132390 <alt_log_private_printf+0x304>
81132374:	e0bff417 	ldw	r2,-48(fp)
81132378:	1000050e 	bge	r2,zero,81132390 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
8113237c:	e0bff417 	ldw	r2,-48(fp)
81132380:	0085c83a 	sub	r2,zero,r2
81132384:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81132388:	00800044 	movi	r2,1
8113238c:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81132390:	e0bff417 	ldw	r2,-48(fp)
81132394:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81132398:	00800044 	movi	r2,1
8113239c:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
811323a0:	00800044 	movi	r2,1
811323a4:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
811323a8:	00000706 	br	811323c8 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
811323ac:	e0bff817 	ldw	r2,-32(fp)
811323b0:	10800044 	addi	r2,r2,1
811323b4:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
811323b8:	e0bff117 	ldw	r2,-60(fp)
811323bc:	e0fff517 	ldw	r3,-44(fp)
811323c0:	1885383a 	mul	r2,r3,r2
811323c4:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
811323c8:	e0bff117 	ldw	r2,-60(fp)
811323cc:	e0fff617 	ldw	r3,-40(fp)
811323d0:	1885203a 	divu	r2,r3,r2
811323d4:	e0bff615 	stw	r2,-40(fp)
811323d8:	e0bff617 	ldw	r2,-40(fp)
811323dc:	103ff31e 	bne	r2,zero,811323ac <__reset+0xfb1123ac>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
811323e0:	e0ffef17 	ldw	r3,-68(fp)
811323e4:	e0bff817 	ldw	r2,-32(fp)
811323e8:	1885c83a 	sub	r2,r3,r2
811323ec:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
811323f0:	e0bfed17 	ldw	r2,-76(fp)
811323f4:	10000e26 	beq	r2,zero,81132430 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
811323f8:	e0bff717 	ldw	r2,-36(fp)
811323fc:	10000726 	beq	r2,zero,8113241c <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81132400:	e0bffd17 	ldw	r2,-12(fp)
81132404:	100b883a 	mov	r5,r2
81132408:	01000b44 	movi	r4,45
8113240c:	1131fd00 	call	81131fd0 <alt_log_txchar>
                    fmtBeforeDecimal--;
81132410:	e0bfef17 	ldw	r2,-68(fp)
81132414:	10bfffc4 	addi	r2,r2,-1
81132418:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
8113241c:	e1bffd17 	ldw	r6,-12(fp)
81132420:	e17fef17 	ldw	r5,-68(fp)
81132424:	01000c04 	movi	r4,48
81132428:	11320240 	call	81132024 <alt_log_repchar>
8113242c:	00003206 	br	811324f8 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81132430:	e0bff717 	ldw	r2,-36(fp)
81132434:	10000326 	beq	r2,zero,81132444 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81132438:	e0bfef17 	ldw	r2,-68(fp)
8113243c:	10bfffc4 	addi	r2,r2,-1
81132440:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81132444:	e1bffd17 	ldw	r6,-12(fp)
81132448:	e17fef17 	ldw	r5,-68(fp)
8113244c:	01000804 	movi	r4,32
81132450:	11320240 	call	81132024 <alt_log_repchar>
                    if(sign)
81132454:	e0bff717 	ldw	r2,-36(fp)
81132458:	10002726 	beq	r2,zero,811324f8 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
8113245c:	e0bffd17 	ldw	r2,-12(fp)
81132460:	100b883a 	mov	r5,r2
81132464:	01000b44 	movi	r4,45
81132468:	1131fd00 	call	81131fd0 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
8113246c:	00002206 	br	811324f8 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81132470:	e0fff417 	ldw	r3,-48(fp)
81132474:	e0bff517 	ldw	r2,-44(fp)
81132478:	1885203a 	divu	r2,r3,r2
8113247c:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81132480:	e0bff903 	ldbu	r2,-28(fp)
81132484:	10800c04 	addi	r2,r2,48
81132488:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
8113248c:	e0bff903 	ldbu	r2,-28(fp)
81132490:	10800eb0 	cmpltui	r2,r2,58
81132494:	1000081e 	bne	r2,zero,811324b8 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81132498:	e0bff317 	ldw	r2,-52(fp)
8113249c:	10000226 	beq	r2,zero,811324a8 <alt_log_private_printf+0x41c>
811324a0:	008001c4 	movi	r2,7
811324a4:	00000106 	br	811324ac <alt_log_private_printf+0x420>
811324a8:	008009c4 	movi	r2,39
811324ac:	e0fff903 	ldbu	r3,-28(fp)
811324b0:	10c5883a 	add	r2,r2,r3
811324b4:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
811324b8:	e0bff903 	ldbu	r2,-28(fp)
811324bc:	e0fffd17 	ldw	r3,-12(fp)
811324c0:	180b883a 	mov	r5,r3
811324c4:	1009883a 	mov	r4,r2
811324c8:	1131fd00 	call	81131fd0 <alt_log_txchar>

                  v = v % p;
811324cc:	e0bff417 	ldw	r2,-48(fp)
811324d0:	e0fff517 	ldw	r3,-44(fp)
811324d4:	10c9203a 	divu	r4,r2,r3
811324d8:	e0fff517 	ldw	r3,-44(fp)
811324dc:	20c7383a 	mul	r3,r4,r3
811324e0:	10c5c83a 	sub	r2,r2,r3
811324e4:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
811324e8:	e0bff117 	ldw	r2,-60(fp)
811324ec:	e0fff517 	ldw	r3,-44(fp)
811324f0:	1885203a 	divu	r2,r3,r2
811324f4:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
811324f8:	e0bff517 	ldw	r2,-44(fp)
811324fc:	103fdc1e 	bne	r2,zero,81132470 <__reset+0xfb112470>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81132500:	e03fec15 	stw	zero,-80(fp)
              break;
81132504:	00003f06 	br	81132604 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81132508:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
8113250c:	003f7906 	br	811322f4 <__reset+0xfb1122f4>
            case 'o':
              fmtSigned = 0;
81132510:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81132514:	00800204 	movi	r2,8
81132518:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8113251c:	003f7506 	br	811322f4 <__reset+0xfb1122f4>
            case 'x':
              fmtSigned = 0;
81132520:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81132524:	00800404 	movi	r2,16
81132528:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8113252c:	003f7106 	br	811322f4 <__reset+0xfb1122f4>
            case 'X':
              fmtSigned = 0;
81132530:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81132534:	00800404 	movi	r2,16
81132538:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
8113253c:	00800044 	movi	r2,1
81132540:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81132544:	003f6b06 	br	811322f4 <__reset+0xfb1122f4>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81132548:	e0bfef17 	ldw	r2,-68(fp)
8113254c:	10bfffc4 	addi	r2,r2,-1
81132550:	e1bffd17 	ldw	r6,-12(fp)
81132554:	100b883a 	mov	r5,r2
81132558:	01000804 	movi	r4,32
8113255c:	11320240 	call	81132024 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81132560:	e0bffe17 	ldw	r2,-8(fp)
81132564:	10c00104 	addi	r3,r2,4
81132568:	e0fffe15 	stw	r3,-8(fp)
8113256c:	10800017 	ldw	r2,0(r2)
81132570:	e0fffd17 	ldw	r3,-12(fp)
81132574:	180b883a 	mov	r5,r3
81132578:	1009883a 	mov	r4,r2
8113257c:	1131fd00 	call	81131fd0 <alt_log_txchar>
              break;
81132580:	00002006 	br	81132604 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81132584:	e0bffe17 	ldw	r2,-8(fp)
81132588:	10c00104 	addi	r3,r2,4
8113258c:	e0fffe15 	stw	r3,-8(fp)
81132590:	10800017 	ldw	r2,0(r2)
81132594:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81132598:	e43fef17 	ldw	r16,-68(fp)
8113259c:	e13ffa17 	ldw	r4,-24(fp)
811325a0:	111dcc00 	call	8111dcc0 <strlen>
811325a4:	8085c83a 	sub	r2,r16,r2
811325a8:	e1bffd17 	ldw	r6,-12(fp)
811325ac:	100b883a 	mov	r5,r2
811325b0:	01000804 	movi	r4,32
811325b4:	11320240 	call	81132024 <alt_log_repchar>

                while(*s)
811325b8:	00000b06 	br	811325e8 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
811325bc:	e0bffa17 	ldw	r2,-24(fp)
811325c0:	10c00044 	addi	r3,r2,1
811325c4:	e0fffa15 	stw	r3,-24(fp)
811325c8:	10800003 	ldbu	r2,0(r2)
811325cc:	10803fcc 	andi	r2,r2,255
811325d0:	1080201c 	xori	r2,r2,128
811325d4:	10bfe004 	addi	r2,r2,-128
811325d8:	e0fffd17 	ldw	r3,-12(fp)
811325dc:	180b883a 	mov	r5,r3
811325e0:	1009883a 	mov	r4,r2
811325e4:	1131fd00 	call	81131fd0 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
811325e8:	e0bffa17 	ldw	r2,-24(fp)
811325ec:	10800003 	ldbu	r2,0(r2)
811325f0:	10803fcc 	andi	r2,r2,255
811325f4:	1080201c 	xori	r2,r2,128
811325f8:	10bfe004 	addi	r2,r2,-128
811325fc:	103fef1e 	bne	r2,zero,811325bc <__reset+0xfb1125bc>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81132600:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81132604:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81132608:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
8113260c:	e0bfeb17 	ldw	r2,-84(fp)
81132610:	10c00044 	addi	r3,r2,1
81132614:	e0ffeb15 	stw	r3,-84(fp)
81132618:	10800003 	ldbu	r2,0(r2)
8113261c:	e0bffb05 	stb	r2,-20(fp)
81132620:	e0bffb07 	ldb	r2,-20(fp)
81132624:	103eae1e 	bne	r2,zero,811320e0 <__reset+0xfb1120e0>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81132628:	0001883a 	nop
8113262c:	e6ffff04 	addi	sp,fp,-4
81132630:	dfc00217 	ldw	ra,8(sp)
81132634:	df000117 	ldw	fp,4(sp)
81132638:	dc000017 	ldw	r16,0(sp)
8113263c:	dec00304 	addi	sp,sp,12
81132640:	f800283a 	ret

81132644 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81132644:	defff904 	addi	sp,sp,-28
81132648:	de00012e 	bgeu	sp,et,81132650 <alt_log_printf_proc+0xc>
8113264c:	003b68fa 	trap	3
81132650:	dfc00315 	stw	ra,12(sp)
81132654:	df000215 	stw	fp,8(sp)
81132658:	df000204 	addi	fp,sp,8
8113265c:	e13fff15 	stw	r4,-4(fp)
81132660:	e1400215 	stw	r5,8(fp)
81132664:	e1800315 	stw	r6,12(fp)
81132668:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
8113266c:	e0800204 	addi	r2,fp,8
81132670:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81132674:	e0bffe17 	ldw	r2,-8(fp)
81132678:	100d883a 	mov	r6,r2
8113267c:	01604834 	movhi	r5,33056
81132680:	294c2404 	addi	r5,r5,12432
81132684:	e13fff17 	ldw	r4,-4(fp)
81132688:	113208c0 	call	8113208c <alt_log_private_printf>
    return (0);
8113268c:	0005883a 	mov	r2,zero
}
81132690:	e037883a 	mov	sp,fp
81132694:	dfc00117 	ldw	ra,4(sp)
81132698:	df000017 	ldw	fp,0(sp)
8113269c:	dec00504 	addi	sp,sp,20
811326a0:	f800283a 	ret

811326a4 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
811326a4:	defff904 	addi	sp,sp,-28
811326a8:	de00012e 	bgeu	sp,et,811326b0 <altera_avalon_jtag_uart_report_log+0xc>
811326ac:	003b68fa 	trap	3
811326b0:	dfc00615 	stw	ra,24(sp)
811326b4:	df000515 	stw	fp,20(sp)
811326b8:	dc400415 	stw	r17,16(sp)
811326bc:	dc000315 	stw	r16,12(sp)
811326c0:	df000504 	addi	fp,sp,20
811326c4:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
811326c8:	d0a07c83 	ldbu	r2,-32270(gp)
811326cc:	10803fcc 	andi	r2,r2,255
811326d0:	10001426 	beq	r2,zero,81132724 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
811326d4:	e0bffd17 	ldw	r2,-12(fp)
811326d8:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
811326dc:	00a04574 	movhi	r2,33045
811326e0:	10aee404 	addi	r2,r2,-17520
811326e4:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
811326e8:	e0bffb17 	ldw	r2,-20(fp)
811326ec:	10800017 	ldw	r2,0(r2)
811326f0:	e1bffc17 	ldw	r6,-16(fp)
811326f4:	100b883a 	mov	r5,r2
811326f8:	e13ffb17 	ldw	r4,-20(fp)
811326fc:	11327440 	call	81132744 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81132700:	d0e08317 	ldw	r3,-32244(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81132704:	00b33374 	movhi	r2,52429
81132708:	10b33344 	addi	r2,r2,-13107
8113270c:	1888383a 	mulxuu	r4,r3,r2
81132710:	1885383a 	mul	r2,r3,r2
81132714:	1021883a 	mov	r16,r2
81132718:	2023883a 	mov	r17,r4
8113271c:	8804d0fa 	srli	r2,r17,3
81132720:	00000106 	br	81132728 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81132724:	0005883a 	mov	r2,zero
    }
}
81132728:	e6fffe04 	addi	sp,fp,-8
8113272c:	dfc00317 	ldw	ra,12(sp)
81132730:	df000217 	ldw	fp,8(sp)
81132734:	dc400117 	ldw	r17,4(sp)
81132738:	dc000017 	ldw	r16,0(sp)
8113273c:	dec00404 	addi	sp,sp,16
81132740:	f800283a 	ret

81132744 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81132744:	deffef04 	addi	sp,sp,-68
81132748:	de00012e 	bgeu	sp,et,81132750 <alt_log_jtag_uart_print_control_reg+0xc>
8113274c:	003b68fa 	trap	3
81132750:	dfc01015 	stw	ra,64(sp)
81132754:	df000f15 	stw	fp,60(sp)
81132758:	df000f04 	addi	fp,sp,60
8113275c:	e13ffd15 	stw	r4,-12(fp)
81132760:	e17ffe15 	stw	r5,-8(fp)
81132764:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81132768:	e0bffe17 	ldw	r2,-8(fp)
8113276c:	10800104 	addi	r2,r2,4
81132770:	10800037 	ldwio	r2,0(r2)
81132774:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81132778:	e0bff617 	ldw	r2,-40(fp)
8113277c:	1004d43a 	srli	r2,r2,16
81132780:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81132784:	e0bff617 	ldw	r2,-40(fp)
81132788:	1080008c 	andi	r2,r2,2
8113278c:	1004d07a 	srli	r2,r2,1
81132790:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81132794:	e0bff617 	ldw	r2,-40(fp)
81132798:	1080004c 	andi	r2,r2,1
8113279c:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
811327a0:	e0bff617 	ldw	r2,-40(fp)
811327a4:	1080400c 	andi	r2,r2,256
811327a8:	1004d23a 	srli	r2,r2,8
811327ac:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
811327b0:	e0bff617 	ldw	r2,-40(fp)
811327b4:	1080800c 	andi	r2,r2,512
811327b8:	1004d27a 	srli	r2,r2,9
811327bc:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
811327c0:	e0bff617 	ldw	r2,-40(fp)
811327c4:	1081000c 	andi	r2,r2,1024
811327c8:	1004d2ba 	srli	r2,r2,10
811327cc:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
811327d0:	e0bffd17 	ldw	r2,-12(fp)
811327d4:	10c01017 	ldw	r3,64(r2)
811327d8:	e0bffd17 	ldw	r2,-12(fp)
811327dc:	10800f17 	ldw	r2,60(r2)
811327e0:	1887c83a 	sub	r3,r3,r2
811327e4:	e0bff917 	ldw	r2,-28(fp)
811327e8:	d8800415 	stw	r2,16(sp)
811327ec:	e0bff817 	ldw	r2,-32(fp)
811327f0:	d8800315 	stw	r2,12(sp)
811327f4:	e0bffa17 	ldw	r2,-24(fp)
811327f8:	d8800215 	stw	r2,8(sp)
811327fc:	e0bffb17 	ldw	r2,-20(fp)
81132800:	d8800115 	stw	r2,4(sp)
81132804:	e0bffc17 	ldw	r2,-16(fp)
81132808:	d8800015 	stw	r2,0(sp)
8113280c:	e1fff717 	ldw	r7,-36(fp)
81132810:	180d883a 	mov	r6,r3
81132814:	e17fff17 	ldw	r5,-4(fp)
81132818:	01204574 	movhi	r4,33045
8113281c:	212ee704 	addi	r4,r4,-17508
81132820:	11326440 	call	81132644 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81132824:	0001883a 	nop

}
81132828:	e037883a 	mov	sp,fp
8113282c:	dfc00117 	ldw	ra,4(sp)
81132830:	df000017 	ldw	fp,0(sp)
81132834:	dec00204 	addi	sp,sp,8
81132838:	f800283a 	ret

8113283c <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
8113283c:	defffb04 	addi	sp,sp,-20
81132840:	de00012e 	bgeu	sp,et,81132848 <alt_log_jtag_uart_startup_info+0xc>
81132844:	003b68fa 	trap	3
81132848:	dfc00415 	stw	ra,16(sp)
8113284c:	df000315 	stw	fp,12(sp)
81132850:	df000304 	addi	fp,sp,12
81132854:	e13ffe15 	stw	r4,-8(fp)
81132858:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
8113285c:	00a04574 	movhi	r2,33045
81132860:	10aef904 	addi	r2,r2,-17436
81132864:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81132868:	e1bffd17 	ldw	r6,-12(fp)
8113286c:	e17fff17 	ldw	r5,-4(fp)
81132870:	e13ffe17 	ldw	r4,-8(fp)
81132874:	11327440 	call	81132744 <alt_log_jtag_uart_print_control_reg>
     return;
81132878:	0001883a 	nop
}
8113287c:	e037883a 	mov	sp,fp
81132880:	dfc00117 	ldw	ra,4(sp)
81132884:	df000017 	ldw	fp,0(sp)
81132888:	dec00204 	addi	sp,sp,8
8113288c:	f800283a 	ret

81132890 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
81132890:	defffb04 	addi	sp,sp,-20
81132894:	de00012e 	bgeu	sp,et,8113289c <alt_log_jtag_uart_isr_proc+0xc>
81132898:	003b68fa 	trap	3
8113289c:	dfc00415 	stw	ra,16(sp)
811328a0:	df000315 	stw	fp,12(sp)
811328a4:	df000304 	addi	fp,sp,12
811328a8:	e13ffe15 	stw	r4,-8(fp)
811328ac:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
811328b0:	d0a07cc3 	ldbu	r2,-32269(gp)
811328b4:	10803fcc 	andi	r2,r2,255
811328b8:	10000826 	beq	r2,zero,811328dc <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
811328bc:	00a04574 	movhi	r2,33045
811328c0:	10aefe04 	addi	r2,r2,-17416
811328c4:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
811328c8:	e1bffd17 	ldw	r6,-12(fp)
811328cc:	e17ffe17 	ldw	r5,-8(fp)
811328d0:	e13fff17 	ldw	r4,-4(fp)
811328d4:	11327440 	call	81132744 <alt_log_jtag_uart_print_control_reg>
    }
    return;
811328d8:	0001883a 	nop
811328dc:	0001883a 	nop
}
811328e0:	e037883a 	mov	sp,fp
811328e4:	dfc00117 	ldw	ra,4(sp)
811328e8:	df000017 	ldw	fp,0(sp)
811328ec:	dec00204 	addi	sp,sp,8
811328f0:	f800283a 	ret

811328f4 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
811328f4:	defffa04 	addi	sp,sp,-24
811328f8:	de00012e 	bgeu	sp,et,81132900 <alt_log_write+0xc>
811328fc:	003b68fa 	trap	3
81132900:	dfc00515 	stw	ra,20(sp)
81132904:	df000415 	stw	fp,16(sp)
81132908:	df000404 	addi	fp,sp,16
8113290c:	e13ffe15 	stw	r4,-8(fp)
81132910:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81132914:	d0a07c03 	ldbu	r2,-32272(gp)
81132918:	10803fcc 	andi	r2,r2,255
8113291c:	10004026 	beq	r2,zero,81132a20 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81132920:	e0bfff17 	ldw	r2,-4(fp)
81132924:	10c00430 	cmpltui	r3,r2,16
81132928:	1800011e 	bne	r3,zero,81132930 <alt_log_write+0x3c>
8113292c:	008003c4 	movi	r2,15
81132930:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81132934:	e0bffd17 	ldw	r2,-12(fp)
81132938:	10800088 	cmpgei	r2,r2,2
8113293c:	10003726 	beq	r2,zero,81132a1c <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81132940:	e0bffd17 	ldw	r2,-12(fp)
81132944:	100d883a 	mov	r6,r2
81132948:	e17ffe17 	ldw	r5,-8(fp)
8113294c:	012045b4 	movhi	r4,33046
81132950:	21060c04 	addi	r4,r4,6192
81132954:	11468c00 	call	811468c0 <strncpy>
    alt_log_write_buf[length-1]='\n';
81132958:	e0bffd17 	ldw	r2,-12(fp)
8113295c:	10ffffc4 	addi	r3,r2,-1
81132960:	00a045b4 	movhi	r2,33046
81132964:	10860c04 	addi	r2,r2,6192
81132968:	10c5883a 	add	r2,r2,r3
8113296c:	00c00284 	movi	r3,10
81132970:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81132974:	00a045b4 	movhi	r2,33046
81132978:	10860c04 	addi	r2,r2,6192
8113297c:	e0fffd17 	ldw	r3,-12(fp)
81132980:	10c5883a 	add	r2,r2,r3
81132984:	00c00344 	movi	r3,13
81132988:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
8113298c:	e0bffd17 	ldw	r2,-12(fp)
81132990:	10c00044 	addi	r3,r2,1
81132994:	00a045b4 	movhi	r2,33046
81132998:	10860c04 	addi	r2,r2,6192
8113299c:	10c5883a 	add	r2,r2,r3
811329a0:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811329a4:	e03ffc15 	stw	zero,-16(fp)
811329a8:	00001306 	br	811329f8 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
811329ac:	00a045b4 	movhi	r2,33046
811329b0:	10860c04 	addi	r2,r2,6192
811329b4:	e0fffc17 	ldw	r3,-16(fp)
811329b8:	10c5883a 	add	r2,r2,r3
811329bc:	10800003 	ldbu	r2,0(r2)
811329c0:	10803fcc 	andi	r2,r2,255
811329c4:	1080201c 	xori	r2,r2,128
811329c8:	10bfe004 	addi	r2,r2,-128
811329cc:	10800118 	cmpnei	r2,r2,4
811329d0:	1000061e 	bne	r2,zero,811329ec <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
811329d4:	00a045b4 	movhi	r2,33046
811329d8:	10860c04 	addi	r2,r2,6192
811329dc:	e0fffc17 	ldw	r3,-16(fp)
811329e0:	10c5883a 	add	r2,r2,r3
811329e4:	00c01104 	movi	r3,68
811329e8:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811329ec:	e0bffc17 	ldw	r2,-16(fp)
811329f0:	10800044 	addi	r2,r2,1
811329f4:	e0bffc15 	stw	r2,-16(fp)
811329f8:	e0fffc17 	ldw	r3,-16(fp)
811329fc:	e0bffd17 	ldw	r2,-12(fp)
81132a00:	18bfea16 	blt	r3,r2,811329ac <__reset+0xfb1129ac>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81132a04:	016045b4 	movhi	r5,33046
81132a08:	29460c04 	addi	r5,r5,6192
81132a0c:	01204574 	movhi	r4,33045
81132a10:	212f0104 	addi	r4,r4,-17404
81132a14:	11326440 	call	81132644 <alt_log_printf_proc>
81132a18:	00000106 	br	81132a20 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81132a1c:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81132a20:	e037883a 	mov	sp,fp
81132a24:	dfc00117 	ldw	ra,4(sp)
81132a28:	df000017 	ldw	fp,0(sp)
81132a2c:	dec00204 	addi	sp,sp,8
81132a30:	f800283a 	ret

81132a34 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81132a34:	defffe04 	addi	sp,sp,-8
81132a38:	de00012e 	bgeu	sp,et,81132a40 <alt_log_system_clock+0xc>
81132a3c:	003b68fa 	trap	3
81132a40:	dfc00115 	stw	ra,4(sp)
81132a44:	df000015 	stw	fp,0(sp)
81132a48:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81132a4c:	d0a07c43 	ldbu	r2,-32271(gp)
81132a50:	10803fcc 	andi	r2,r2,255
81132a54:	10000e26 	beq	r2,zero,81132a90 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81132a58:	d0a07f17 	ldw	r2,-32260(gp)
81132a5c:	10800044 	addi	r2,r2,1
81132a60:	d0a07f15 	stw	r2,-32260(gp)
81132a64:	d0a08317 	ldw	r2,-32244(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81132a68:	d0e07f17 	ldw	r3,-32260(gp)
81132a6c:	10c0082e 	bgeu	r2,r3,81132a90 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81132a70:	d0207f15 	stw	zero,-32260(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81132a74:	d0a07e17 	ldw	r2,-32264(gp)
81132a78:	10c00044 	addi	r3,r2,1
81132a7c:	d0e07e15 	stw	r3,-32264(gp)
81132a80:	100b883a 	mov	r5,r2
81132a84:	01204574 	movhi	r4,33045
81132a88:	212f0504 	addi	r4,r4,-17388
81132a8c:	11326440 	call	81132644 <alt_log_printf_proc>
        }
    }
}
81132a90:	0001883a 	nop
81132a94:	e037883a 	mov	sp,fp
81132a98:	dfc00117 	ldw	ra,4(sp)
81132a9c:	df000017 	ldw	fp,0(sp)
81132aa0:	dec00204 	addi	sp,sp,8
81132aa4:	f800283a 	ret

81132aa8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132aa8:	defffe04 	addi	sp,sp,-8
81132aac:	de00012e 	bgeu	sp,et,81132ab4 <alt_get_errno+0xc>
81132ab0:	003b68fa 	trap	3
81132ab4:	dfc00115 	stw	ra,4(sp)
81132ab8:	df000015 	stw	fp,0(sp)
81132abc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81132ac0:	d0a01017 	ldw	r2,-32704(gp)
81132ac4:	10000326 	beq	r2,zero,81132ad4 <alt_get_errno+0x2c>
81132ac8:	d0a01017 	ldw	r2,-32704(gp)
81132acc:	103ee83a 	callr	r2
81132ad0:	00000106 	br	81132ad8 <alt_get_errno+0x30>
81132ad4:	d0a07304 	addi	r2,gp,-32308
}
81132ad8:	e037883a 	mov	sp,fp
81132adc:	dfc00117 	ldw	ra,4(sp)
81132ae0:	df000017 	ldw	fp,0(sp)
81132ae4:	dec00204 	addi	sp,sp,8
81132ae8:	f800283a 	ret

81132aec <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81132aec:	defff904 	addi	sp,sp,-28
81132af0:	de00012e 	bgeu	sp,et,81132af8 <lseek+0xc>
81132af4:	003b68fa 	trap	3
81132af8:	dfc00615 	stw	ra,24(sp)
81132afc:	df000515 	stw	fp,20(sp)
81132b00:	df000504 	addi	fp,sp,20
81132b04:	e13ffd15 	stw	r4,-12(fp)
81132b08:	e17ffe15 	stw	r5,-8(fp)
81132b0c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81132b10:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81132b14:	e0bffd17 	ldw	r2,-12(fp)
81132b18:	10000616 	blt	r2,zero,81132b34 <lseek+0x48>
81132b1c:	e0bffd17 	ldw	r2,-12(fp)
81132b20:	10c00324 	muli	r3,r2,12
81132b24:	00a04574 	movhi	r2,33045
81132b28:	10b2be04 	addi	r2,r2,-13576
81132b2c:	1885883a 	add	r2,r3,r2
81132b30:	00000106 	br	81132b38 <lseek+0x4c>
81132b34:	0005883a 	mov	r2,zero
81132b38:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81132b3c:	e0bffc17 	ldw	r2,-16(fp)
81132b40:	10001026 	beq	r2,zero,81132b84 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81132b44:	e0bffc17 	ldw	r2,-16(fp)
81132b48:	10800017 	ldw	r2,0(r2)
81132b4c:	10800717 	ldw	r2,28(r2)
81132b50:	10000926 	beq	r2,zero,81132b78 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81132b54:	e0bffc17 	ldw	r2,-16(fp)
81132b58:	10800017 	ldw	r2,0(r2)
81132b5c:	10800717 	ldw	r2,28(r2)
81132b60:	e1bfff17 	ldw	r6,-4(fp)
81132b64:	e17ffe17 	ldw	r5,-8(fp)
81132b68:	e13ffc17 	ldw	r4,-16(fp)
81132b6c:	103ee83a 	callr	r2
81132b70:	e0bffb15 	stw	r2,-20(fp)
81132b74:	00000506 	br	81132b8c <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81132b78:	00bfde84 	movi	r2,-134
81132b7c:	e0bffb15 	stw	r2,-20(fp)
81132b80:	00000206 	br	81132b8c <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81132b84:	00bfebc4 	movi	r2,-81
81132b88:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81132b8c:	e0bffb17 	ldw	r2,-20(fp)
81132b90:	1000070e 	bge	r2,zero,81132bb0 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81132b94:	1132aa80 	call	81132aa8 <alt_get_errno>
81132b98:	1007883a 	mov	r3,r2
81132b9c:	e0bffb17 	ldw	r2,-20(fp)
81132ba0:	0085c83a 	sub	r2,zero,r2
81132ba4:	18800015 	stw	r2,0(r3)
    rc = -1;
81132ba8:	00bfffc4 	movi	r2,-1
81132bac:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
81132bb0:	e0bffb17 	ldw	r2,-20(fp)
}
81132bb4:	e037883a 	mov	sp,fp
81132bb8:	dfc00117 	ldw	ra,4(sp)
81132bbc:	df000017 	ldw	fp,0(sp)
81132bc0:	dec00204 	addi	sp,sp,8
81132bc4:	f800283a 	ret

81132bc8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
81132bc8:	defff904 	addi	sp,sp,-28
81132bcc:	de00012e 	bgeu	sp,et,81132bd4 <alt_main+0xc>
81132bd0:	003b68fa 	trap	3
81132bd4:	dfc00615 	stw	ra,24(sp)
81132bd8:	df000515 	stw	fp,20(sp)
81132bdc:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81132be0:	d0a01217 	ldw	r2,-32696(gp)
81132be4:	10800058 	cmpnei	r2,r2,1
81132be8:	1000031e 	bne	r2,zero,81132bf8 <alt_main+0x30>
81132bec:	01204574 	movhi	r4,33045
81132bf0:	212f0b04 	addi	r4,r4,-17364
81132bf4:	11326440 	call	81132644 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
81132bf8:	0009883a 	mov	r4,zero
81132bfc:	113d7200 	call	8113d720 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81132c00:	d0a01217 	ldw	r2,-32696(gp)
81132c04:	10800058 	cmpnei	r2,r2,1
81132c08:	1000031e 	bne	r2,zero,81132c18 <alt_main+0x50>
81132c0c:	01204574 	movhi	r4,33045
81132c10:	212f1904 	addi	r4,r4,-17308
81132c14:	11326440 	call	81132644 <alt_log_printf_proc>
  ALT_OS_INIT();
81132c18:	11341b40 	call	811341b4 <OSInit>
81132c1c:	01000044 	movi	r4,1
81132c20:	1139ed00 	call	81139ed0 <OSSemCreate>
81132c24:	d0a08615 	stw	r2,-32232(gp)
81132c28:	01000044 	movi	r4,1
81132c2c:	1139ed00 	call	81139ed0 <OSSemCreate>
81132c30:	d0a08815 	stw	r2,-32224(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81132c34:	d0a01217 	ldw	r2,-32696(gp)
81132c38:	10800058 	cmpnei	r2,r2,1
81132c3c:	1000031e 	bne	r2,zero,81132c4c <alt_main+0x84>
81132c40:	01204574 	movhi	r4,33045
81132c44:	212f2704 	addi	r4,r4,-17252
81132c48:	11326440 	call	81132644 <alt_log_printf_proc>
81132c4c:	d0a07a04 	addi	r2,gp,-32280
81132c50:	e0bffc15 	stw	r2,-16(fp)
81132c54:	00800044 	movi	r2,1
81132c58:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81132c5c:	e0bffd0b 	ldhu	r2,-12(fp)
81132c60:	1009883a 	mov	r4,r2
81132c64:	1139ed00 	call	81139ed0 <OSSemCreate>
81132c68:	1007883a 	mov	r3,r2
81132c6c:	e0bffc17 	ldw	r2,-16(fp)
81132c70:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81132c74:	d0a01217 	ldw	r2,-32696(gp)
81132c78:	10800058 	cmpnei	r2,r2,1
81132c7c:	1000031e 	bne	r2,zero,81132c8c <alt_main+0xc4>
81132c80:	01204574 	movhi	r4,33045
81132c84:	212f3504 	addi	r4,r4,-17196
81132c88:	11326440 	call	81132644 <alt_log_printf_proc>
  alt_sys_init();
81132c8c:	113d7600 	call	8113d760 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
81132c90:	d0a01217 	ldw	r2,-32696(gp)
81132c94:	10800058 	cmpnei	r2,r2,1
81132c98:	1000031e 	bne	r2,zero,81132ca8 <alt_main+0xe0>
81132c9c:	01204574 	movhi	r4,33045
81132ca0:	212f3f04 	addi	r4,r4,-17156
81132ca4:	11326440 	call	81132644 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
81132ca8:	d0a01217 	ldw	r2,-32696(gp)
81132cac:	10800058 	cmpnei	r2,r2,1
81132cb0:	1000031e 	bne	r2,zero,81132cc0 <alt_main+0xf8>
81132cb4:	01204574 	movhi	r4,33045
81132cb8:	212f4804 	addi	r4,r4,-17120
81132cbc:	11326440 	call	81132644 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
81132cc0:	01a04574 	movhi	r6,33045
81132cc4:	31af5004 	addi	r6,r6,-17088
81132cc8:	01604574 	movhi	r5,33045
81132ccc:	296f5504 	addi	r5,r5,-17068
81132cd0:	01204574 	movhi	r4,33045
81132cd4:	212f5504 	addi	r4,r4,-17068
81132cd8:	11460500 	call	81146050 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
81132cdc:	d0a01217 	ldw	r2,-32696(gp)
81132ce0:	10800058 	cmpnei	r2,r2,1
81132ce4:	1000031e 	bne	r2,zero,81132cf4 <alt_main+0x12c>
81132ce8:	01204574 	movhi	r4,33045
81132cec:	212f5904 	addi	r4,r4,-17052
81132cf0:	11326440 	call	81132644 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81132cf4:	d0a08017 	ldw	r2,-32256(gp)
81132cf8:	d0e08117 	ldw	r3,-32252(gp)
81132cfc:	d1208217 	ldw	r4,-32248(gp)
81132d00:	200d883a 	mov	r6,r4
81132d04:	180b883a 	mov	r5,r3
81132d08:	1009883a 	mov	r4,r2
81132d0c:	11148180 	call	81114818 <main>
81132d10:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81132d14:	01000044 	movi	r4,1
81132d18:	1131af40 	call	81131af4 <close>
  exit (result);
81132d1c:	e13ffb17 	ldw	r4,-20(fp)
81132d20:	11468040 	call	81146804 <exit>

81132d24 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132d24:	defffe04 	addi	sp,sp,-8
81132d28:	de00012e 	bgeu	sp,et,81132d30 <alt_get_errno+0xc>
81132d2c:	003b68fa 	trap	3
81132d30:	dfc00115 	stw	ra,4(sp)
81132d34:	df000015 	stw	fp,0(sp)
81132d38:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81132d3c:	d0a01017 	ldw	r2,-32704(gp)
81132d40:	10000326 	beq	r2,zero,81132d50 <alt_get_errno+0x2c>
81132d44:	d0a01017 	ldw	r2,-32704(gp)
81132d48:	103ee83a 	callr	r2
81132d4c:	00000106 	br	81132d54 <alt_get_errno+0x30>
81132d50:	d0a07304 	addi	r2,gp,-32308
}
81132d54:	e037883a 	mov	sp,fp
81132d58:	dfc00117 	ldw	ra,4(sp)
81132d5c:	df000017 	ldw	fp,0(sp)
81132d60:	dec00204 	addi	sp,sp,8
81132d64:	f800283a 	ret

81132d68 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81132d68:	defffd04 	addi	sp,sp,-12
81132d6c:	de00012e 	bgeu	sp,et,81132d74 <alt_file_locked+0xc>
81132d70:	003b68fa 	trap	3
81132d74:	df000215 	stw	fp,8(sp)
81132d78:	df000204 	addi	fp,sp,8
81132d7c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81132d80:	e0bfff17 	ldw	r2,-4(fp)
81132d84:	10800217 	ldw	r2,8(r2)
81132d88:	10d00034 	orhi	r3,r2,16384
81132d8c:	e0bfff17 	ldw	r2,-4(fp)
81132d90:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81132d94:	e03ffe15 	stw	zero,-8(fp)
81132d98:	00001d06 	br	81132e10 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81132d9c:	00a04574 	movhi	r2,33045
81132da0:	10b2be04 	addi	r2,r2,-13576
81132da4:	e0fffe17 	ldw	r3,-8(fp)
81132da8:	18c00324 	muli	r3,r3,12
81132dac:	10c5883a 	add	r2,r2,r3
81132db0:	10c00017 	ldw	r3,0(r2)
81132db4:	e0bfff17 	ldw	r2,-4(fp)
81132db8:	10800017 	ldw	r2,0(r2)
81132dbc:	1880111e 	bne	r3,r2,81132e04 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81132dc0:	00a04574 	movhi	r2,33045
81132dc4:	10b2be04 	addi	r2,r2,-13576
81132dc8:	e0fffe17 	ldw	r3,-8(fp)
81132dcc:	18c00324 	muli	r3,r3,12
81132dd0:	10c5883a 	add	r2,r2,r3
81132dd4:	10800204 	addi	r2,r2,8
81132dd8:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81132ddc:	1000090e 	bge	r2,zero,81132e04 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81132de0:	e0bffe17 	ldw	r2,-8(fp)
81132de4:	10c00324 	muli	r3,r2,12
81132de8:	00a04574 	movhi	r2,33045
81132dec:	10b2be04 	addi	r2,r2,-13576
81132df0:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81132df4:	e0bfff17 	ldw	r2,-4(fp)
81132df8:	18800226 	beq	r3,r2,81132e04 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
81132dfc:	00bffcc4 	movi	r2,-13
81132e00:	00000806 	br	81132e24 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81132e04:	e0bffe17 	ldw	r2,-8(fp)
81132e08:	10800044 	addi	r2,r2,1
81132e0c:	e0bffe15 	stw	r2,-8(fp)
81132e10:	d0a00f17 	ldw	r2,-32708(gp)
81132e14:	1007883a 	mov	r3,r2
81132e18:	e0bffe17 	ldw	r2,-8(fp)
81132e1c:	18bfdf2e 	bgeu	r3,r2,81132d9c <__reset+0xfb112d9c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81132e20:	0005883a 	mov	r2,zero
}
81132e24:	e037883a 	mov	sp,fp
81132e28:	df000017 	ldw	fp,0(sp)
81132e2c:	dec00104 	addi	sp,sp,4
81132e30:	f800283a 	ret

81132e34 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81132e34:	defff604 	addi	sp,sp,-40
81132e38:	de00012e 	bgeu	sp,et,81132e40 <open+0xc>
81132e3c:	003b68fa 	trap	3
81132e40:	dfc00915 	stw	ra,36(sp)
81132e44:	df000815 	stw	fp,32(sp)
81132e48:	df000804 	addi	fp,sp,32
81132e4c:	e13ffd15 	stw	r4,-12(fp)
81132e50:	e17ffe15 	stw	r5,-8(fp)
81132e54:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81132e58:	00bfffc4 	movi	r2,-1
81132e5c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81132e60:	00bffb44 	movi	r2,-19
81132e64:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81132e68:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81132e6c:	d1600d04 	addi	r5,gp,-32716
81132e70:	e13ffd17 	ldw	r4,-12(fp)
81132e74:	1145a300 	call	81145a30 <alt_find_dev>
81132e78:	e0bff815 	stw	r2,-32(fp)
81132e7c:	e0bff817 	ldw	r2,-32(fp)
81132e80:	1000051e 	bne	r2,zero,81132e98 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
81132e84:	e13ffd17 	ldw	r4,-12(fp)
81132e88:	1145ac80 	call	81145ac8 <alt_find_file>
81132e8c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81132e90:	00800044 	movi	r2,1
81132e94:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81132e98:	e0bff817 	ldw	r2,-32(fp)
81132e9c:	10002926 	beq	r2,zero,81132f44 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81132ea0:	e13ff817 	ldw	r4,-32(fp)
81132ea4:	1145bd80 	call	81145bd8 <alt_get_fd>
81132ea8:	e0bff915 	stw	r2,-28(fp)
81132eac:	e0bff917 	ldw	r2,-28(fp)
81132eb0:	1000030e 	bge	r2,zero,81132ec0 <open+0x8c>
    {
      status = index;
81132eb4:	e0bff917 	ldw	r2,-28(fp)
81132eb8:	e0bffa15 	stw	r2,-24(fp)
81132ebc:	00002306 	br	81132f4c <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81132ec0:	e0bff917 	ldw	r2,-28(fp)
81132ec4:	10c00324 	muli	r3,r2,12
81132ec8:	00a04574 	movhi	r2,33045
81132ecc:	10b2be04 	addi	r2,r2,-13576
81132ed0:	1885883a 	add	r2,r3,r2
81132ed4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
81132ed8:	e0fffe17 	ldw	r3,-8(fp)
81132edc:	00900034 	movhi	r2,16384
81132ee0:	10bfffc4 	addi	r2,r2,-1
81132ee4:	1886703a 	and	r3,r3,r2
81132ee8:	e0bffc17 	ldw	r2,-16(fp)
81132eec:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81132ef0:	e0bffb17 	ldw	r2,-20(fp)
81132ef4:	1000051e 	bne	r2,zero,81132f0c <open+0xd8>
81132ef8:	e13ffc17 	ldw	r4,-16(fp)
81132efc:	1132d680 	call	81132d68 <alt_file_locked>
81132f00:	e0bffa15 	stw	r2,-24(fp)
81132f04:	e0bffa17 	ldw	r2,-24(fp)
81132f08:	10001016 	blt	r2,zero,81132f4c <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81132f0c:	e0bff817 	ldw	r2,-32(fp)
81132f10:	10800317 	ldw	r2,12(r2)
81132f14:	10000826 	beq	r2,zero,81132f38 <open+0x104>
81132f18:	e0bff817 	ldw	r2,-32(fp)
81132f1c:	10800317 	ldw	r2,12(r2)
81132f20:	e1ffff17 	ldw	r7,-4(fp)
81132f24:	e1bffe17 	ldw	r6,-8(fp)
81132f28:	e17ffd17 	ldw	r5,-12(fp)
81132f2c:	e13ffc17 	ldw	r4,-16(fp)
81132f30:	103ee83a 	callr	r2
81132f34:	00000106 	br	81132f3c <open+0x108>
81132f38:	0005883a 	mov	r2,zero
81132f3c:	e0bffa15 	stw	r2,-24(fp)
81132f40:	00000206 	br	81132f4c <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81132f44:	00bffb44 	movi	r2,-19
81132f48:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81132f4c:	e0bffa17 	ldw	r2,-24(fp)
81132f50:	1000090e 	bge	r2,zero,81132f78 <open+0x144>
  {
    alt_release_fd (index);  
81132f54:	e13ff917 	ldw	r4,-28(fp)
81132f58:	11330d80 	call	811330d8 <alt_release_fd>
    ALT_ERRNO = -status;
81132f5c:	1132d240 	call	81132d24 <alt_get_errno>
81132f60:	1007883a 	mov	r3,r2
81132f64:	e0bffa17 	ldw	r2,-24(fp)
81132f68:	0085c83a 	sub	r2,zero,r2
81132f6c:	18800015 	stw	r2,0(r3)
    return -1;
81132f70:	00bfffc4 	movi	r2,-1
81132f74:	00000106 	br	81132f7c <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81132f78:	e0bff917 	ldw	r2,-28(fp)
}
81132f7c:	e037883a 	mov	sp,fp
81132f80:	dfc00117 	ldw	ra,4(sp)
81132f84:	df000017 	ldw	fp,0(sp)
81132f88:	dec00204 	addi	sp,sp,8
81132f8c:	f800283a 	ret

81132f90 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132f90:	defffe04 	addi	sp,sp,-8
81132f94:	de00012e 	bgeu	sp,et,81132f9c <alt_get_errno+0xc>
81132f98:	003b68fa 	trap	3
81132f9c:	dfc00115 	stw	ra,4(sp)
81132fa0:	df000015 	stw	fp,0(sp)
81132fa4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81132fa8:	d0a01017 	ldw	r2,-32704(gp)
81132fac:	10000326 	beq	r2,zero,81132fbc <alt_get_errno+0x2c>
81132fb0:	d0a01017 	ldw	r2,-32704(gp)
81132fb4:	103ee83a 	callr	r2
81132fb8:	00000106 	br	81132fc0 <alt_get_errno+0x30>
81132fbc:	d0a07304 	addi	r2,gp,-32308
}
81132fc0:	e037883a 	mov	sp,fp
81132fc4:	dfc00117 	ldw	ra,4(sp)
81132fc8:	df000017 	ldw	fp,0(sp)
81132fcc:	dec00204 	addi	sp,sp,8
81132fd0:	f800283a 	ret

81132fd4 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81132fd4:	defff904 	addi	sp,sp,-28
81132fd8:	de00012e 	bgeu	sp,et,81132fe0 <read+0xc>
81132fdc:	003b68fa 	trap	3
81132fe0:	dfc00615 	stw	ra,24(sp)
81132fe4:	df000515 	stw	fp,20(sp)
81132fe8:	df000504 	addi	fp,sp,20
81132fec:	e13ffd15 	stw	r4,-12(fp)
81132ff0:	e17ffe15 	stw	r5,-8(fp)
81132ff4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81132ff8:	e0bffd17 	ldw	r2,-12(fp)
81132ffc:	10000616 	blt	r2,zero,81133018 <read+0x44>
81133000:	e0bffd17 	ldw	r2,-12(fp)
81133004:	10c00324 	muli	r3,r2,12
81133008:	00a04574 	movhi	r2,33045
8113300c:	10b2be04 	addi	r2,r2,-13576
81133010:	1885883a 	add	r2,r3,r2
81133014:	00000106 	br	8113301c <read+0x48>
81133018:	0005883a 	mov	r2,zero
8113301c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81133020:	e0bffb17 	ldw	r2,-20(fp)
81133024:	10002226 	beq	r2,zero,811330b0 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81133028:	e0bffb17 	ldw	r2,-20(fp)
8113302c:	10800217 	ldw	r2,8(r2)
81133030:	108000cc 	andi	r2,r2,3
81133034:	10800060 	cmpeqi	r2,r2,1
81133038:	1000181e 	bne	r2,zero,8113309c <read+0xc8>
        (fd->dev->read))
8113303c:	e0bffb17 	ldw	r2,-20(fp)
81133040:	10800017 	ldw	r2,0(r2)
81133044:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81133048:	10001426 	beq	r2,zero,8113309c <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
8113304c:	e0bffb17 	ldw	r2,-20(fp)
81133050:	10800017 	ldw	r2,0(r2)
81133054:	10800517 	ldw	r2,20(r2)
81133058:	e0ffff17 	ldw	r3,-4(fp)
8113305c:	180d883a 	mov	r6,r3
81133060:	e17ffe17 	ldw	r5,-8(fp)
81133064:	e13ffb17 	ldw	r4,-20(fp)
81133068:	103ee83a 	callr	r2
8113306c:	e0bffc15 	stw	r2,-16(fp)
81133070:	e0bffc17 	ldw	r2,-16(fp)
81133074:	1000070e 	bge	r2,zero,81133094 <read+0xc0>
        {
          ALT_ERRNO = -rval;
81133078:	1132f900 	call	81132f90 <alt_get_errno>
8113307c:	1007883a 	mov	r3,r2
81133080:	e0bffc17 	ldw	r2,-16(fp)
81133084:	0085c83a 	sub	r2,zero,r2
81133088:	18800015 	stw	r2,0(r3)
          return -1;
8113308c:	00bfffc4 	movi	r2,-1
81133090:	00000c06 	br	811330c4 <read+0xf0>
        }
        return rval;
81133094:	e0bffc17 	ldw	r2,-16(fp)
81133098:	00000a06 	br	811330c4 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
8113309c:	1132f900 	call	81132f90 <alt_get_errno>
811330a0:	1007883a 	mov	r3,r2
811330a4:	00800344 	movi	r2,13
811330a8:	18800015 	stw	r2,0(r3)
811330ac:	00000406 	br	811330c0 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
811330b0:	1132f900 	call	81132f90 <alt_get_errno>
811330b4:	1007883a 	mov	r3,r2
811330b8:	00801444 	movi	r2,81
811330bc:	18800015 	stw	r2,0(r3)
  }
  return -1;
811330c0:	00bfffc4 	movi	r2,-1
}
811330c4:	e037883a 	mov	sp,fp
811330c8:	dfc00117 	ldw	ra,4(sp)
811330cc:	df000017 	ldw	fp,0(sp)
811330d0:	dec00204 	addi	sp,sp,8
811330d4:	f800283a 	ret

811330d8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
811330d8:	defffe04 	addi	sp,sp,-8
811330dc:	de00012e 	bgeu	sp,et,811330e4 <alt_release_fd+0xc>
811330e0:	003b68fa 	trap	3
811330e4:	df000115 	stw	fp,4(sp)
811330e8:	df000104 	addi	fp,sp,4
811330ec:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
811330f0:	e0bfff17 	ldw	r2,-4(fp)
811330f4:	108000d0 	cmplti	r2,r2,3
811330f8:	10000d1e 	bne	r2,zero,81133130 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
811330fc:	00a04574 	movhi	r2,33045
81133100:	10b2be04 	addi	r2,r2,-13576
81133104:	e0ffff17 	ldw	r3,-4(fp)
81133108:	18c00324 	muli	r3,r3,12
8113310c:	10c5883a 	add	r2,r2,r3
81133110:	10800204 	addi	r2,r2,8
81133114:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81133118:	00a04574 	movhi	r2,33045
8113311c:	10b2be04 	addi	r2,r2,-13576
81133120:	e0ffff17 	ldw	r3,-4(fp)
81133124:	18c00324 	muli	r3,r3,12
81133128:	10c5883a 	add	r2,r2,r3
8113312c:	10000015 	stw	zero,0(r2)
  }
}
81133130:	0001883a 	nop
81133134:	e037883a 	mov	sp,fp
81133138:	df000017 	ldw	fp,0(sp)
8113313c:	dec00104 	addi	sp,sp,4
81133140:	f800283a 	ret

81133144 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81133144:	defff604 	addi	sp,sp,-40
81133148:	de00012e 	bgeu	sp,et,81133150 <sbrk+0xc>
8113314c:	003b68fa 	trap	3
81133150:	df000915 	stw	fp,36(sp)
81133154:	df000904 	addi	fp,sp,36
81133158:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113315c:	0005303a 	rdctl	r2,status
81133160:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133164:	e0fffe17 	ldw	r3,-8(fp)
81133168:	00bfff84 	movi	r2,-2
8113316c:	1884703a 	and	r2,r3,r2
81133170:	1001703a 	wrctl	status,r2
  
  return context;
81133174:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81133178:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
8113317c:	d0a01317 	ldw	r2,-32692(gp)
81133180:	10c000c4 	addi	r3,r2,3
81133184:	00bfff04 	movi	r2,-4
81133188:	1884703a 	and	r2,r3,r2
8113318c:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81133190:	d0e01317 	ldw	r3,-32692(gp)
81133194:	e0bfff17 	ldw	r2,-4(fp)
81133198:	1887883a 	add	r3,r3,r2
8113319c:	00a04834 	movhi	r2,33056
811331a0:	10a80004 	addi	r2,r2,-24576
811331a4:	10c0062e 	bgeu	r2,r3,811331c0 <sbrk+0x7c>
811331a8:	e0bff817 	ldw	r2,-32(fp)
811331ac:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811331b0:	e0bff717 	ldw	r2,-36(fp)
811331b4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
811331b8:	00bfffc4 	movi	r2,-1
811331bc:	00001c06 	br	81133230 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
811331c0:	d0a01317 	ldw	r2,-32692(gp)
811331c4:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
811331c8:	d0e01317 	ldw	r3,-32692(gp)
811331cc:	e0bfff17 	ldw	r2,-4(fp)
811331d0:	1885883a 	add	r2,r3,r2
811331d4:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
811331d8:	c005883a 	mov	r2,et
811331dc:	e0bff915 	stw	r2,-28(fp)

  return limit; 
811331e0:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
811331e4:	e0bffa17 	ldw	r2,-24(fp)
811331e8:	18800c1e 	bne	r3,r2,8113321c <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
811331ec:	d805883a 	mov	r2,sp
811331f0:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
811331f4:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
811331f8:	d0e01317 	ldw	r3,-32692(gp)
811331fc:	18800136 	bltu	r3,r2,81133204 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81133200:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81133204:	d0a01317 	ldw	r2,-32692(gp)
81133208:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
8113320c:	e0bffc17 	ldw	r2,-16(fp)
81133210:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81133214:	e0bffc17 	ldw	r2,-16(fp)
81133218:	1031883a 	mov	et,r2
8113321c:	e0bff817 	ldw	r2,-32(fp)
81133220:	e0bffd15 	stw	r2,-12(fp)
81133224:	e0bffd17 	ldw	r2,-12(fp)
81133228:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
8113322c:	e0bffa17 	ldw	r2,-24(fp)
} 
81133230:	e037883a 	mov	sp,fp
81133234:	df000017 	ldw	fp,0(sp)
81133238:	dec00104 	addi	sp,sp,4
8113323c:	f800283a 	ret

81133240 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81133240:	defffa04 	addi	sp,sp,-24
81133244:	de00012e 	bgeu	sp,et,8113324c <alt_alarm_stop+0xc>
81133248:	003b68fa 	trap	3
8113324c:	df000515 	stw	fp,20(sp)
81133250:	df000504 	addi	fp,sp,20
81133254:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133258:	0005303a 	rdctl	r2,status
8113325c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133260:	e0fffc17 	ldw	r3,-16(fp)
81133264:	00bfff84 	movi	r2,-2
81133268:	1884703a 	and	r2,r3,r2
8113326c:	1001703a 	wrctl	status,r2
  
  return context;
81133270:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81133274:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81133278:	e0bfff17 	ldw	r2,-4(fp)
8113327c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81133280:	e0bffd17 	ldw	r2,-12(fp)
81133284:	10800017 	ldw	r2,0(r2)
81133288:	e0fffd17 	ldw	r3,-12(fp)
8113328c:	18c00117 	ldw	r3,4(r3)
81133290:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81133294:	e0bffd17 	ldw	r2,-12(fp)
81133298:	10800117 	ldw	r2,4(r2)
8113329c:	e0fffd17 	ldw	r3,-12(fp)
811332a0:	18c00017 	ldw	r3,0(r3)
811332a4:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
811332a8:	e0bffd17 	ldw	r2,-12(fp)
811332ac:	e0fffd17 	ldw	r3,-12(fp)
811332b0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
811332b4:	e0bffd17 	ldw	r2,-12(fp)
811332b8:	e0fffd17 	ldw	r3,-12(fp)
811332bc:	10c00015 	stw	r3,0(r2)
811332c0:	e0bffb17 	ldw	r2,-20(fp)
811332c4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811332c8:	e0bffe17 	ldw	r2,-8(fp)
811332cc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
811332d0:	0001883a 	nop
811332d4:	e037883a 	mov	sp,fp
811332d8:	df000017 	ldw	fp,0(sp)
811332dc:	dec00104 	addi	sp,sp,4
811332e0:	f800283a 	ret

811332e4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
811332e4:	defffb04 	addi	sp,sp,-20
811332e8:	de00012e 	bgeu	sp,et,811332f0 <alt_tick+0xc>
811332ec:	003b68fa 	trap	3
811332f0:	dfc00415 	stw	ra,16(sp)
811332f4:	df000315 	stw	fp,12(sp)
811332f8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
811332fc:	d0a01417 	ldw	r2,-32688(gp)
81133300:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81133304:	d0a08417 	ldw	r2,-32240(gp)
81133308:	10800044 	addi	r2,r2,1
8113330c:	d0a08415 	stw	r2,-32240(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81133310:	00002e06 	br	811333cc <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81133314:	e0bffd17 	ldw	r2,-12(fp)
81133318:	10800017 	ldw	r2,0(r2)
8113331c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81133320:	e0bffd17 	ldw	r2,-12(fp)
81133324:	10800403 	ldbu	r2,16(r2)
81133328:	10803fcc 	andi	r2,r2,255
8113332c:	10000426 	beq	r2,zero,81133340 <alt_tick+0x5c>
81133330:	d0a08417 	ldw	r2,-32240(gp)
81133334:	1000021e 	bne	r2,zero,81133340 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81133338:	e0bffd17 	ldw	r2,-12(fp)
8113333c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81133340:	e0bffd17 	ldw	r2,-12(fp)
81133344:	10800217 	ldw	r2,8(r2)
81133348:	d0e08417 	ldw	r3,-32240(gp)
8113334c:	18801d36 	bltu	r3,r2,811333c4 <alt_tick+0xe0>
81133350:	e0bffd17 	ldw	r2,-12(fp)
81133354:	10800403 	ldbu	r2,16(r2)
81133358:	10803fcc 	andi	r2,r2,255
8113335c:	1000191e 	bne	r2,zero,811333c4 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81133360:	e0bffd17 	ldw	r2,-12(fp)
81133364:	10800317 	ldw	r2,12(r2)
81133368:	e0fffd17 	ldw	r3,-12(fp)
8113336c:	18c00517 	ldw	r3,20(r3)
81133370:	1809883a 	mov	r4,r3
81133374:	103ee83a 	callr	r2
81133378:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
8113337c:	e0bfff17 	ldw	r2,-4(fp)
81133380:	1000031e 	bne	r2,zero,81133390 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81133384:	e13ffd17 	ldw	r4,-12(fp)
81133388:	11332400 	call	81133240 <alt_alarm_stop>
8113338c:	00000d06 	br	811333c4 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81133390:	e0bffd17 	ldw	r2,-12(fp)
81133394:	10c00217 	ldw	r3,8(r2)
81133398:	e0bfff17 	ldw	r2,-4(fp)
8113339c:	1887883a 	add	r3,r3,r2
811333a0:	e0bffd17 	ldw	r2,-12(fp)
811333a4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
811333a8:	e0bffd17 	ldw	r2,-12(fp)
811333ac:	10c00217 	ldw	r3,8(r2)
811333b0:	d0a08417 	ldw	r2,-32240(gp)
811333b4:	1880032e 	bgeu	r3,r2,811333c4 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
811333b8:	e0bffd17 	ldw	r2,-12(fp)
811333bc:	00c00044 	movi	r3,1
811333c0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
811333c4:	e0bffe17 	ldw	r2,-8(fp)
811333c8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
811333cc:	e0fffd17 	ldw	r3,-12(fp)
811333d0:	d0a01404 	addi	r2,gp,-32688
811333d4:	18bfcf1e 	bne	r3,r2,81133314 <__reset+0xfb113314>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
811333d8:	11346140 	call	81134614 <OSTimeTick>
}
811333dc:	0001883a 	nop
811333e0:	e037883a 	mov	sp,fp
811333e4:	dfc00117 	ldw	ra,4(sp)
811333e8:	df000017 	ldw	fp,0(sp)
811333ec:	dec00204 	addi	sp,sp,8
811333f0:	f800283a 	ret

811333f4 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
811333f4:	defffb04 	addi	sp,sp,-20
811333f8:	de00012e 	bgeu	sp,et,81133400 <usleep+0xc>
811333fc:	003b68fa 	trap	3
81133400:	dfc00415 	stw	ra,16(sp)
81133404:	df000315 	stw	fp,12(sp)
81133408:	df000304 	addi	fp,sp,12
8113340c:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81133410:	d0a08c03 	ldbu	r2,-32208(gp)
81133414:	10803fcc 	andi	r2,r2,255
81133418:	1000031e 	bne	r2,zero,81133428 <usleep+0x34>
  {
    return alt_busy_sleep (us);
8113341c:	e13fff17 	ldw	r4,-4(fp)
81133420:	11319800 	call	81131980 <alt_busy_sleep>
81133424:	00003d06 	br	8113351c <usleep+0x128>
81133428:	d0a08317 	ldw	r2,-32244(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
8113342c:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81133430:	e0ffff17 	ldw	r3,-4(fp)
81133434:	0090c734 	movhi	r2,17180
81133438:	10b7a0c4 	addi	r2,r2,-8573
8113343c:	1888383a 	mulxuu	r4,r3,r2
81133440:	1885383a 	mul	r2,r3,r2
81133444:	1013883a 	mov	r9,r2
81133448:	2015883a 	mov	r10,r4
8113344c:	5006d4ba 	srli	r3,r10,18
81133450:	e0bffe17 	ldw	r2,-8(fp)
81133454:	1893383a 	mul	r9,r3,r2
81133458:	e0ffff17 	ldw	r3,-4(fp)
8113345c:	0090c734 	movhi	r2,17180
81133460:	10b7a0c4 	addi	r2,r2,-8573
81133464:	1888383a 	mulxuu	r4,r3,r2
81133468:	1885383a 	mul	r2,r3,r2
8113346c:	100f883a 	mov	r7,r2
81133470:	2011883a 	mov	r8,r4
81133474:	4004d4ba 	srli	r2,r8,18
81133478:	010003f4 	movhi	r4,15
8113347c:	21109004 	addi	r4,r4,16960
81133480:	1105383a 	mul	r2,r2,r4
81133484:	1885c83a 	sub	r2,r3,r2
81133488:	e0fffe17 	ldw	r3,-8(fp)
8113348c:	10c7383a 	mul	r3,r2,r3
81133490:	0090c734 	movhi	r2,17180
81133494:	10b7a0c4 	addi	r2,r2,-8573
81133498:	1888383a 	mulxuu	r4,r3,r2
8113349c:	1885383a 	mul	r2,r3,r2
811334a0:	100b883a 	mov	r5,r2
811334a4:	200d883a 	mov	r6,r4
811334a8:	3004d4ba 	srli	r2,r6,18
811334ac:	4885883a 	add	r2,r9,r2
811334b0:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
811334b4:	00000706 	br	811334d4 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
811334b8:	013fffd4 	movui	r4,65535
811334bc:	113c0840 	call	8113c084 <OSTimeDly>
    ticks -= 0xffff;
811334c0:	e0fffd17 	ldw	r3,-12(fp)
811334c4:	00bffff4 	movhi	r2,65535
811334c8:	10800044 	addi	r2,r2,1
811334cc:	1885883a 	add	r2,r3,r2
811334d0:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
811334d4:	e0bffd17 	ldw	r2,-12(fp)
811334d8:	00ffffd4 	movui	r3,65535
811334dc:	18bff636 	bltu	r3,r2,811334b8 <__reset+0xfb1134b8>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
811334e0:	e0bffd17 	ldw	r2,-12(fp)
811334e4:	10bfffcc 	andi	r2,r2,65535
811334e8:	1009883a 	mov	r4,r2
811334ec:	113c0840 	call	8113c084 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
811334f0:	008003f4 	movhi	r2,15
811334f4:	10909004 	addi	r2,r2,16960
811334f8:	e0fffe17 	ldw	r3,-8(fp)
811334fc:	10c7203a 	divu	r3,r2,r3
81133500:	e0bfff17 	ldw	r2,-4(fp)
81133504:	10c9203a 	divu	r4,r2,r3
81133508:	20c7383a 	mul	r3,r4,r3
8113350c:	10c5c83a 	sub	r2,r2,r3
81133510:	1009883a 	mov	r4,r2
81133514:	11319800 	call	81131980 <alt_busy_sleep>

  return 0;  
81133518:	0005883a 	mov	r2,zero
}
8113351c:	e037883a 	mov	sp,fp
81133520:	dfc00117 	ldw	ra,4(sp)
81133524:	df000017 	ldw	fp,0(sp)
81133528:	dec00204 	addi	sp,sp,8
8113352c:	f800283a 	ret

81133530 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81133530:	defffe04 	addi	sp,sp,-8
81133534:	de00012e 	bgeu	sp,et,8113353c <alt_get_errno+0xc>
81133538:	003b68fa 	trap	3
8113353c:	dfc00115 	stw	ra,4(sp)
81133540:	df000015 	stw	fp,0(sp)
81133544:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81133548:	d0a01017 	ldw	r2,-32704(gp)
8113354c:	10000326 	beq	r2,zero,8113355c <alt_get_errno+0x2c>
81133550:	d0a01017 	ldw	r2,-32704(gp)
81133554:	103ee83a 	callr	r2
81133558:	00000106 	br	81133560 <alt_get_errno+0x30>
8113355c:	d0a07304 	addi	r2,gp,-32308
}
81133560:	e037883a 	mov	sp,fp
81133564:	dfc00117 	ldw	ra,4(sp)
81133568:	df000017 	ldw	fp,0(sp)
8113356c:	dec00204 	addi	sp,sp,8
81133570:	f800283a 	ret

81133574 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81133574:	defff904 	addi	sp,sp,-28
81133578:	de00012e 	bgeu	sp,et,81133580 <write+0xc>
8113357c:	003b68fa 	trap	3
81133580:	dfc00615 	stw	ra,24(sp)
81133584:	df000515 	stw	fp,20(sp)
81133588:	df000504 	addi	fp,sp,20
8113358c:	e13ffd15 	stw	r4,-12(fp)
81133590:	e17ffe15 	stw	r5,-8(fp)
81133594:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81133598:	e0bffd17 	ldw	r2,-12(fp)
8113359c:	10000616 	blt	r2,zero,811335b8 <write+0x44>
811335a0:	e0bffd17 	ldw	r2,-12(fp)
811335a4:	10c00324 	muli	r3,r2,12
811335a8:	00a04574 	movhi	r2,33045
811335ac:	10b2be04 	addi	r2,r2,-13576
811335b0:	1885883a 	add	r2,r3,r2
811335b4:	00000106 	br	811335bc <write+0x48>
811335b8:	0005883a 	mov	r2,zero
811335bc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
811335c0:	e0bffb17 	ldw	r2,-20(fp)
811335c4:	10002426 	beq	r2,zero,81133658 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
811335c8:	e0bffb17 	ldw	r2,-20(fp)
811335cc:	10800217 	ldw	r2,8(r2)
811335d0:	108000cc 	andi	r2,r2,3
811335d4:	10001b26 	beq	r2,zero,81133644 <write+0xd0>
811335d8:	e0bffb17 	ldw	r2,-20(fp)
811335dc:	10800017 	ldw	r2,0(r2)
811335e0:	10800617 	ldw	r2,24(r2)
811335e4:	10001726 	beq	r2,zero,81133644 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
811335e8:	e17fff17 	ldw	r5,-4(fp)
811335ec:	e13ffe17 	ldw	r4,-8(fp)
811335f0:	11328f40 	call	811328f4 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
811335f4:	e0bffb17 	ldw	r2,-20(fp)
811335f8:	10800017 	ldw	r2,0(r2)
811335fc:	10800617 	ldw	r2,24(r2)
81133600:	e0ffff17 	ldw	r3,-4(fp)
81133604:	180d883a 	mov	r6,r3
81133608:	e17ffe17 	ldw	r5,-8(fp)
8113360c:	e13ffb17 	ldw	r4,-20(fp)
81133610:	103ee83a 	callr	r2
81133614:	e0bffc15 	stw	r2,-16(fp)
81133618:	e0bffc17 	ldw	r2,-16(fp)
8113361c:	1000070e 	bge	r2,zero,8113363c <write+0xc8>
      {
        ALT_ERRNO = -rval;
81133620:	11335300 	call	81133530 <alt_get_errno>
81133624:	1007883a 	mov	r3,r2
81133628:	e0bffc17 	ldw	r2,-16(fp)
8113362c:	0085c83a 	sub	r2,zero,r2
81133630:	18800015 	stw	r2,0(r3)
        return -1;
81133634:	00bfffc4 	movi	r2,-1
81133638:	00000c06 	br	8113366c <write+0xf8>
      }
      return rval;
8113363c:	e0bffc17 	ldw	r2,-16(fp)
81133640:	00000a06 	br	8113366c <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81133644:	11335300 	call	81133530 <alt_get_errno>
81133648:	1007883a 	mov	r3,r2
8113364c:	00800344 	movi	r2,13
81133650:	18800015 	stw	r2,0(r3)
81133654:	00000406 	br	81133668 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81133658:	11335300 	call	81133530 <alt_get_errno>
8113365c:	1007883a 	mov	r3,r2
81133660:	00801444 	movi	r2,81
81133664:	18800015 	stw	r2,0(r3)
  }
  return -1;
81133668:	00bfffc4 	movi	r2,-1
}
8113366c:	e037883a 	mov	sp,fp
81133670:	dfc00117 	ldw	ra,4(sp)
81133674:	df000017 	ldw	fp,0(sp)
81133678:	dec00204 	addi	sp,sp,8
8113367c:	f800283a 	ret

81133680 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81133680:	deffde04 	addi	sp,sp,-136
81133684:	de00012e 	bgeu	sp,et,8113368c <__env_lock+0xc>
81133688:	003b68fa 	trap	3
8113368c:	dfc02115 	stw	ra,132(sp)
81133690:	df002015 	stw	fp,128(sp)
81133694:	df002004 	addi	fp,sp,128
81133698:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
8113369c:	e0bfe104 	addi	r2,fp,-124
811336a0:	100b883a 	mov	r5,r2
811336a4:	01003fc4 	movi	r4,255
811336a8:	113bee00 	call	8113bee0 <OSTaskQuery>
811336ac:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
811336b0:	e0bffe83 	ldbu	r2,-6(fp)
811336b4:	10803fcc 	andi	r2,r2,255
811336b8:	10001e1e 	bne	r2,zero,81133734 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
811336bc:	e0bfed83 	ldbu	r2,-74(fp)
811336c0:	10803fcc 	andi	r2,r2,255
811336c4:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
811336c8:	d0a08617 	ldw	r2,-32232(gp)
811336cc:	e0fffc04 	addi	r3,fp,-16
811336d0:	180b883a 	mov	r5,r3
811336d4:	1009883a 	mov	r4,r2
811336d8:	113a6980 	call	8113a698 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
811336dc:	e0bffe03 	ldbu	r2,-8(fp)
811336e0:	10803fcc 	andi	r2,r2,255
811336e4:	10000726 	beq	r2,zero,81133704 <__env_lock+0x84>
811336e8:	d0a01617 	ldw	r2,-32680(gp)
811336ec:	e0ffe017 	ldw	r3,-128(fp)
811336f0:	1880041e 	bne	r3,r2,81133704 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
811336f4:	d0a08517 	ldw	r2,-32236(gp)
811336f8:	10800044 	addi	r2,r2,1
811336fc:	d0a08515 	stw	r2,-32236(gp)
81133700:	00000a06 	br	8113372c <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81133704:	d0a08617 	ldw	r2,-32232(gp)
81133708:	e0fffe84 	addi	r3,fp,-6
8113370c:	180d883a 	mov	r6,r3
81133710:	000b883a 	mov	r5,zero
81133714:	1009883a 	mov	r4,r2
81133718:	113a1f80 	call	8113a1f8 <OSSemPend>
    locks  = 1;
8113371c:	00800044 	movi	r2,1
81133720:	d0a08515 	stw	r2,-32236(gp)
    lockid = id;
81133724:	e0bfe017 	ldw	r2,-128(fp)
81133728:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8113372c:	0001883a 	nop
81133730:	00000106 	br	81133738 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81133734:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81133738:	e037883a 	mov	sp,fp
8113373c:	dfc00117 	ldw	ra,4(sp)
81133740:	df000017 	ldw	fp,0(sp)
81133744:	dec00204 	addi	sp,sp,8
81133748:	f800283a 	ret

8113374c <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
8113374c:	defffd04 	addi	sp,sp,-12
81133750:	de00012e 	bgeu	sp,et,81133758 <__env_unlock+0xc>
81133754:	003b68fa 	trap	3
81133758:	dfc00215 	stw	ra,8(sp)
8113375c:	df000115 	stw	fp,4(sp)
81133760:	df000104 	addi	fp,sp,4
81133764:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81133768:	d0a08517 	ldw	r2,-32236(gp)
8113376c:	10000b26 	beq	r2,zero,8113379c <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81133770:	d0a08517 	ldw	r2,-32236(gp)
81133774:	10bfffc4 	addi	r2,r2,-1
81133778:	d0a08515 	stw	r2,-32236(gp)
8113377c:	d0a08517 	ldw	r2,-32236(gp)
81133780:	1000071e 	bne	r2,zero,811337a0 <__env_unlock+0x54>
  {
    lockid = -1;
81133784:	00bfffc4 	movi	r2,-1
81133788:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
8113378c:	d0a08617 	ldw	r2,-32232(gp)
81133790:	1009883a 	mov	r4,r2
81133794:	113a5800 	call	8113a580 <OSSemPost>
81133798:	00000106 	br	811337a0 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
8113379c:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
811337a0:	e037883a 	mov	sp,fp
811337a4:	dfc00117 	ldw	ra,4(sp)
811337a8:	df000017 	ldw	fp,0(sp)
811337ac:	dec00204 	addi	sp,sp,8
811337b0:	f800283a 	ret

811337b4 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
811337b4:	deffda04 	addi	sp,sp,-152
811337b8:	de00012e 	bgeu	sp,et,811337c0 <__malloc_lock+0xc>
811337bc:	003b68fa 	trap	3
811337c0:	dfc02515 	stw	ra,148(sp)
811337c4:	df002415 	stw	fp,144(sp)
811337c8:	df002404 	addi	fp,sp,144
811337cc:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811337d0:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
811337d4:	d0a08c03 	ldbu	r2,-32208(gp)
811337d8:	10803fcc 	andi	r2,r2,255
811337dc:	10800060 	cmpeqi	r2,r2,1
811337e0:	10003626 	beq	r2,zero,811338bc <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
811337e4:	e0bfe104 	addi	r2,fp,-124
811337e8:	100b883a 	mov	r5,r2
811337ec:	01003fc4 	movi	r4,255
811337f0:	113bee00 	call	8113bee0 <OSTaskQuery>
811337f4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
811337f8:	e0bffe83 	ldbu	r2,-6(fp)
811337fc:	10803fcc 	andi	r2,r2,255
81133800:	1000301e 	bne	r2,zero,811338c4 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81133804:	e0bfed83 	ldbu	r2,-74(fp)
81133808:	10803fcc 	andi	r2,r2,255
8113380c:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81133810:	d0a08817 	ldw	r2,-32224(gp)
81133814:	e0fffc04 	addi	r3,fp,-16
81133818:	180b883a 	mov	r5,r3
8113381c:	1009883a 	mov	r4,r2
81133820:	113a6980 	call	8113a698 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133824:	0005303a 	rdctl	r2,status
81133828:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113382c:	e0ffe017 	ldw	r3,-128(fp)
81133830:	00bfff84 	movi	r2,-2
81133834:	1884703a 	and	r2,r3,r2
81133838:	1001703a 	wrctl	status,r2
  
  return context;
8113383c:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81133840:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81133844:	e0bffc0b 	ldhu	r2,-16(fp)
81133848:	10bfffcc 	andi	r2,r2,65535
8113384c:	10000b1e 	bne	r2,zero,8113387c <__malloc_lock+0xc8>
81133850:	d0a01717 	ldw	r2,-32676(gp)
81133854:	e0ffdd17 	ldw	r3,-140(fp)
81133858:	1880081e 	bne	r3,r2,8113387c <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
8113385c:	d0a08717 	ldw	r2,-32228(gp)
81133860:	10800044 	addi	r2,r2,1
81133864:	d0a08715 	stw	r2,-32228(gp)
81133868:	e0bfdc17 	ldw	r2,-144(fp)
8113386c:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133870:	e0bfde17 	ldw	r2,-136(fp)
81133874:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81133878:	00000e06 	br	811338b4 <__malloc_lock+0x100>
8113387c:	e0bfdc17 	ldw	r2,-144(fp)
81133880:	e0bfdf15 	stw	r2,-132(fp)
81133884:	e0bfdf17 	ldw	r2,-132(fp)
81133888:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
8113388c:	d0a08817 	ldw	r2,-32224(gp)
81133890:	e0fffe84 	addi	r3,fp,-6
81133894:	180d883a 	mov	r6,r3
81133898:	000b883a 	mov	r5,zero
8113389c:	1009883a 	mov	r4,r2
811338a0:	113a1f80 	call	8113a1f8 <OSSemPend>
    locks  = 1;
811338a4:	00800044 	movi	r2,1
811338a8:	d0a08715 	stw	r2,-32228(gp)
    lockid = id;
811338ac:	e0bfdd17 	ldw	r2,-140(fp)
811338b0:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811338b4:	0001883a 	nop
811338b8:	00000306 	br	811338c8 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
811338bc:	0001883a 	nop
811338c0:	00000106 	br	811338c8 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811338c4:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
811338c8:	e037883a 	mov	sp,fp
811338cc:	dfc00117 	ldw	ra,4(sp)
811338d0:	df000017 	ldw	fp,0(sp)
811338d4:	dec00204 	addi	sp,sp,8
811338d8:	f800283a 	ret

811338dc <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
811338dc:	defff804 	addi	sp,sp,-32
811338e0:	de00012e 	bgeu	sp,et,811338e8 <__malloc_unlock+0xc>
811338e4:	003b68fa 	trap	3
811338e8:	dfc00715 	stw	ra,28(sp)
811338ec:	df000615 	stw	fp,24(sp)
811338f0:	df000604 	addi	fp,sp,24
811338f4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811338f8:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
811338fc:	d0a08c03 	ldbu	r2,-32208(gp)
81133900:	10803fcc 	andi	r2,r2,255
81133904:	10800060 	cmpeqi	r2,r2,1
81133908:	10002326 	beq	r2,zero,81133998 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113390c:	0005303a 	rdctl	r2,status
81133910:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133914:	e0fffe17 	ldw	r3,-8(fp)
81133918:	00bfff84 	movi	r2,-2
8113391c:	1884703a 	and	r2,r3,r2
81133920:	1001703a 	wrctl	status,r2
  
  return context;
81133924:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81133928:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
8113392c:	d0a08717 	ldw	r2,-32228(gp)
81133930:	1000051e 	bne	r2,zero,81133948 <__malloc_unlock+0x6c>
81133934:	e0bffa17 	ldw	r2,-24(fp)
81133938:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113393c:	e0bffb17 	ldw	r2,-20(fp)
81133940:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81133944:	00001506 	br	8113399c <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81133948:	d0a08717 	ldw	r2,-32228(gp)
8113394c:	10bfffc4 	addi	r2,r2,-1
81133950:	d0a08715 	stw	r2,-32228(gp)
81133954:	d0a08717 	ldw	r2,-32228(gp)
81133958:	10000a1e 	bne	r2,zero,81133984 <__malloc_unlock+0xa8>
  {
    lockid = -1;
8113395c:	00bfffc4 	movi	r2,-1
81133960:	d0a01715 	stw	r2,-32676(gp)
81133964:	e0bffa17 	ldw	r2,-24(fp)
81133968:	e0bffc15 	stw	r2,-16(fp)
8113396c:	e0bffc17 	ldw	r2,-16(fp)
81133970:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81133974:	d0a08817 	ldw	r2,-32224(gp)
81133978:	1009883a 	mov	r4,r2
8113397c:	113a5800 	call	8113a580 <OSSemPost>
81133980:	00000606 	br	8113399c <__malloc_unlock+0xc0>
81133984:	e0bffa17 	ldw	r2,-24(fp)
81133988:	e0bffd15 	stw	r2,-12(fp)
8113398c:	e0bffd17 	ldw	r2,-12(fp)
81133990:	1001703a 	wrctl	status,r2
81133994:	00000106 	br	8113399c <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81133998:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8113399c:	e037883a 	mov	sp,fp
811339a0:	dfc00117 	ldw	ra,4(sp)
811339a4:	df000017 	ldw	fp,0(sp)
811339a8:	dec00204 	addi	sp,sp,8
811339ac:	f800283a 	ret

811339b0 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811339b0:	defff704 	addi	sp,sp,-36
811339b4:	de00012e 	bgeu	sp,et,811339bc <OSEventNameGet+0xc>
811339b8:	003b68fa 	trap	3
811339bc:	dfc00815 	stw	ra,32(sp)
811339c0:	df000715 	stw	fp,28(sp)
811339c4:	df000704 	addi	fp,sp,28
811339c8:	e13ffd15 	stw	r4,-12(fp)
811339cc:	e17ffe15 	stw	r5,-8(fp)
811339d0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811339d4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811339d8:	e0bfff17 	ldw	r2,-4(fp)
811339dc:	1000021e 	bne	r2,zero,811339e8 <OSEventNameGet+0x38>
        return (0);
811339e0:	0005883a 	mov	r2,zero
811339e4:	00003706 	br	81133ac4 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
811339e8:	e0bffd17 	ldw	r2,-12(fp)
811339ec:	1000051e 	bne	r2,zero,81133a04 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
811339f0:	e0bfff17 	ldw	r2,-4(fp)
811339f4:	00c00104 	movi	r3,4
811339f8:	10c00005 	stb	r3,0(r2)
        return (0);
811339fc:	0005883a 	mov	r2,zero
81133a00:	00003006 	br	81133ac4 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81133a04:	e0bffe17 	ldw	r2,-8(fp)
81133a08:	1000051e 	bne	r2,zero,81133a20 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81133a0c:	e0bfff17 	ldw	r2,-4(fp)
81133a10:	00c00304 	movi	r3,12
81133a14:	10c00005 	stb	r3,0(r2)
        return (0);
81133a18:	0005883a 	mov	r2,zero
81133a1c:	00002906 	br	81133ac4 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81133a20:	d0a09c03 	ldbu	r2,-32144(gp)
81133a24:	10803fcc 	andi	r2,r2,255
81133a28:	10000526 	beq	r2,zero,81133a40 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81133a2c:	e0bfff17 	ldw	r2,-4(fp)
81133a30:	00c00444 	movi	r3,17
81133a34:	10c00005 	stb	r3,0(r2)
        return (0);
81133a38:	0005883a 	mov	r2,zero
81133a3c:	00002106 	br	81133ac4 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81133a40:	e0bffd17 	ldw	r2,-12(fp)
81133a44:	10800003 	ldbu	r2,0(r2)
81133a48:	10803fcc 	andi	r2,r2,255
81133a4c:	10bfffc4 	addi	r2,r2,-1
81133a50:	10800128 	cmpgeui	r2,r2,4
81133a54:	10000526 	beq	r2,zero,81133a6c <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81133a58:	e0bfff17 	ldw	r2,-4(fp)
81133a5c:	00c00044 	movi	r3,1
81133a60:	10c00005 	stb	r3,0(r2)
             return (0);
81133a64:	0005883a 	mov	r2,zero
81133a68:	00001606 	br	81133ac4 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81133a6c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133a70:	0005303a 	rdctl	r2,status
81133a74:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133a78:	e0fffb17 	ldw	r3,-20(fp)
81133a7c:	00bfff84 	movi	r2,-2
81133a80:	1884703a 	and	r2,r3,r2
81133a84:	1001703a 	wrctl	status,r2
  
  return context;
81133a88:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81133a8c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81133a90:	e0bffd17 	ldw	r2,-12(fp)
81133a94:	10800444 	addi	r2,r2,17
81133a98:	100b883a 	mov	r5,r2
81133a9c:	e13ffe17 	ldw	r4,-8(fp)
81133aa0:	113549c0 	call	8113549c <OS_StrCopy>
81133aa4:	e0bffa05 	stb	r2,-24(fp)
81133aa8:	e0bff917 	ldw	r2,-28(fp)
81133aac:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133ab0:	e0bffc17 	ldw	r2,-16(fp)
81133ab4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81133ab8:	e0bfff17 	ldw	r2,-4(fp)
81133abc:	10000005 	stb	zero,0(r2)
    return (len);
81133ac0:	e0bffa03 	ldbu	r2,-24(fp)
}
81133ac4:	e037883a 	mov	sp,fp
81133ac8:	dfc00117 	ldw	ra,4(sp)
81133acc:	df000017 	ldw	fp,0(sp)
81133ad0:	dec00204 	addi	sp,sp,8
81133ad4:	f800283a 	ret

81133ad8 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81133ad8:	defff604 	addi	sp,sp,-40
81133adc:	de00012e 	bgeu	sp,et,81133ae4 <OSEventNameSet+0xc>
81133ae0:	003b68fa 	trap	3
81133ae4:	dfc00915 	stw	ra,36(sp)
81133ae8:	df000815 	stw	fp,32(sp)
81133aec:	df000804 	addi	fp,sp,32
81133af0:	e13ffd15 	stw	r4,-12(fp)
81133af4:	e17ffe15 	stw	r5,-8(fp)
81133af8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133afc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81133b00:	e0bfff17 	ldw	r2,-4(fp)
81133b04:	10004026 	beq	r2,zero,81133c08 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81133b08:	e0bffd17 	ldw	r2,-12(fp)
81133b0c:	1000041e 	bne	r2,zero,81133b20 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81133b10:	e0bfff17 	ldw	r2,-4(fp)
81133b14:	00c00104 	movi	r3,4
81133b18:	10c00005 	stb	r3,0(r2)
        return;
81133b1c:	00003b06 	br	81133c0c <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81133b20:	e0bffe17 	ldw	r2,-8(fp)
81133b24:	1000041e 	bne	r2,zero,81133b38 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81133b28:	e0bfff17 	ldw	r2,-4(fp)
81133b2c:	00c00304 	movi	r3,12
81133b30:	10c00005 	stb	r3,0(r2)
        return;
81133b34:	00003506 	br	81133c0c <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81133b38:	d0a09c03 	ldbu	r2,-32144(gp)
81133b3c:	10803fcc 	andi	r2,r2,255
81133b40:	10000426 	beq	r2,zero,81133b54 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81133b44:	e0bfff17 	ldw	r2,-4(fp)
81133b48:	00c00484 	movi	r3,18
81133b4c:	10c00005 	stb	r3,0(r2)
        return;
81133b50:	00002e06 	br	81133c0c <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81133b54:	e0bffd17 	ldw	r2,-12(fp)
81133b58:	10800003 	ldbu	r2,0(r2)
81133b5c:	10803fcc 	andi	r2,r2,255
81133b60:	10bfffc4 	addi	r2,r2,-1
81133b64:	10800128 	cmpgeui	r2,r2,4
81133b68:	10000426 	beq	r2,zero,81133b7c <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81133b6c:	e0bfff17 	ldw	r2,-4(fp)
81133b70:	00c00044 	movi	r3,1
81133b74:	10c00005 	stb	r3,0(r2)
             return;
81133b78:	00002406 	br	81133c0c <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81133b7c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133b80:	0005303a 	rdctl	r2,status
81133b84:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133b88:	e0fffc17 	ldw	r3,-16(fp)
81133b8c:	00bfff84 	movi	r2,-2
81133b90:	1884703a 	and	r2,r3,r2
81133b94:	1001703a 	wrctl	status,r2
  
  return context;
81133b98:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81133b9c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
81133ba0:	e13ffe17 	ldw	r4,-8(fp)
81133ba4:	11355180 	call	81135518 <OS_StrLen>
81133ba8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
81133bac:	e0bffa03 	ldbu	r2,-24(fp)
81133bb0:	10800830 	cmpltui	r2,r2,32
81133bb4:	1000081e 	bne	r2,zero,81133bd8 <OSEventNameSet+0x100>
81133bb8:	e0bff817 	ldw	r2,-32(fp)
81133bbc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133bc0:	e0bff917 	ldw	r2,-28(fp)
81133bc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
81133bc8:	e0bfff17 	ldw	r2,-4(fp)
81133bcc:	00c002c4 	movi	r3,11
81133bd0:	10c00005 	stb	r3,0(r2)
        return;
81133bd4:	00000d06 	br	81133c0c <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
81133bd8:	e0bffd17 	ldw	r2,-12(fp)
81133bdc:	10800444 	addi	r2,r2,17
81133be0:	e17ffe17 	ldw	r5,-8(fp)
81133be4:	1009883a 	mov	r4,r2
81133be8:	113549c0 	call	8113549c <OS_StrCopy>
81133bec:	e0bff817 	ldw	r2,-32(fp)
81133bf0:	e0bffb15 	stw	r2,-20(fp)
81133bf4:	e0bffb17 	ldw	r2,-20(fp)
81133bf8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81133bfc:	e0bfff17 	ldw	r2,-4(fp)
81133c00:	10000005 	stb	zero,0(r2)
81133c04:	00000106 	br	81133c0c <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81133c08:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81133c0c:	e037883a 	mov	sp,fp
81133c10:	dfc00117 	ldw	ra,4(sp)
81133c14:	df000017 	ldw	fp,0(sp)
81133c18:	dec00204 	addi	sp,sp,8
81133c1c:	f800283a 	ret

81133c20 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
81133c20:	deffed04 	addi	sp,sp,-76
81133c24:	de00012e 	bgeu	sp,et,81133c2c <OSEventPendMulti+0xc>
81133c28:	003b68fa 	trap	3
81133c2c:	dfc01215 	stw	ra,72(sp)
81133c30:	df001115 	stw	fp,68(sp)
81133c34:	df001104 	addi	fp,sp,68
81133c38:	e13ffc15 	stw	r4,-16(fp)
81133c3c:	e17ffd15 	stw	r5,-12(fp)
81133c40:	e1bffe15 	stw	r6,-8(fp)
81133c44:	3805883a 	mov	r2,r7
81133c48:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81133c4c:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81133c50:	e0800217 	ldw	r2,8(fp)
81133c54:	1000021e 	bne	r2,zero,81133c60 <OSEventPendMulti+0x40>
        return (0);
81133c58:	0005883a 	mov	r2,zero
81133c5c:	00015006 	br	811341a0 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
81133c60:	e0bffc17 	ldw	r2,-16(fp)
81133c64:	1000051e 	bne	r2,zero,81133c7c <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81133c68:	e0800217 	ldw	r2,8(fp)
81133c6c:	00c00104 	movi	r3,4
81133c70:	10c00005 	stb	r3,0(r2)
        return (0);
81133c74:	0005883a 	mov	r2,zero
81133c78:	00014906 	br	811341a0 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81133c7c:	e0bffd17 	ldw	r2,-12(fp)
81133c80:	1000051e 	bne	r2,zero,81133c98 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81133c84:	e0800217 	ldw	r2,8(fp)
81133c88:	00c00104 	movi	r3,4
81133c8c:	10c00005 	stb	r3,0(r2)
        return (0);
81133c90:	0005883a 	mov	r2,zero
81133c94:	00014206 	br	811341a0 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81133c98:	e0bffe17 	ldw	r2,-8(fp)
81133c9c:	1000051e 	bne	r2,zero,81133cb4 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
81133ca0:	e0800217 	ldw	r2,8(fp)
81133ca4:	00c00104 	movi	r3,4
81133ca8:	10c00005 	stb	r3,0(r2)
        return (0);
81133cac:	0005883a 	mov	r2,zero
81133cb0:	00013b06 	br	811341a0 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
81133cb4:	e0bffd17 	ldw	r2,-12(fp)
81133cb8:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
81133cbc:	e0bffc17 	ldw	r2,-16(fp)
81133cc0:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81133cc4:	e0bfef17 	ldw	r2,-68(fp)
81133cc8:	10800017 	ldw	r2,0(r2)
81133ccc:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
81133cd0:	00001506 	br	81133d28 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
81133cd4:	e0bff017 	ldw	r2,-64(fp)
81133cd8:	10800003 	ldbu	r2,0(r2)
81133cdc:	10803fcc 	andi	r2,r2,255
81133ce0:	10c000a0 	cmpeqi	r3,r2,2
81133ce4:	1800071e 	bne	r3,zero,81133d04 <OSEventPendMulti+0xe4>
81133ce8:	108000e0 	cmpeqi	r2,r2,3
81133cec:	1000071e 	bne	r2,zero,81133d0c <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81133cf0:	e0800217 	ldw	r2,8(fp)
81133cf4:	00c00044 	movi	r3,1
81133cf8:	10c00005 	stb	r3,0(r2)
                 return (0);
81133cfc:	0005883a 	mov	r2,zero
81133d00:	00012706 	br	811341a0 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81133d04:	0001883a 	nop
81133d08:	00000106 	br	81133d10 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81133d0c:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81133d10:	e0bfef17 	ldw	r2,-68(fp)
81133d14:	10800104 	addi	r2,r2,4
81133d18:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81133d1c:	e0bfef17 	ldw	r2,-68(fp)
81133d20:	10800017 	ldw	r2,0(r2)
81133d24:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81133d28:	e0bff017 	ldw	r2,-64(fp)
81133d2c:	103fe91e 	bne	r2,zero,81133cd4 <__reset+0xfb113cd4>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
81133d30:	d0a09c03 	ldbu	r2,-32144(gp)
81133d34:	10803fcc 	andi	r2,r2,255
81133d38:	10000526 	beq	r2,zero,81133d50 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81133d3c:	e0800217 	ldw	r2,8(fp)
81133d40:	00c00084 	movi	r3,2
81133d44:	10c00005 	stb	r3,0(r2)
        return (0);
81133d48:	0005883a 	mov	r2,zero
81133d4c:	00011406 	br	811341a0 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
81133d50:	d0a08a03 	ldbu	r2,-32216(gp)
81133d54:	10803fcc 	andi	r2,r2,255
81133d58:	10000526 	beq	r2,zero,81133d70 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81133d5c:	e0800217 	ldw	r2,8(fp)
81133d60:	00c00344 	movi	r3,13
81133d64:	10c00005 	stb	r3,0(r2)
        return (0);
81133d68:	0005883a 	mov	r2,zero
81133d6c:	00010c06 	br	811341a0 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133d70:	0005303a 	rdctl	r2,status
81133d74:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133d78:	e0fffb17 	ldw	r3,-20(fp)
81133d7c:	00bfff84 	movi	r2,-2
81133d80:	1884703a 	and	r2,r3,r2
81133d84:	1001703a 	wrctl	status,r2
  
  return context;
81133d88:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81133d8c:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
81133d90:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81133d94:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
81133d98:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81133d9c:	e0bffc17 	ldw	r2,-16(fp)
81133da0:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
81133da4:	e0bfef17 	ldw	r2,-68(fp)
81133da8:	10800017 	ldw	r2,0(r2)
81133dac:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81133db0:	00006406 	br	81133f44 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
81133db4:	e0bff017 	ldw	r2,-64(fp)
81133db8:	10800003 	ldbu	r2,0(r2)
81133dbc:	10803fcc 	andi	r2,r2,255
81133dc0:	10c000a0 	cmpeqi	r3,r2,2
81133dc4:	18001f1e 	bne	r3,zero,81133e44 <OSEventPendMulti+0x224>
81133dc8:	108000e0 	cmpeqi	r2,r2,3
81133dcc:	10004c26 	beq	r2,zero,81133f00 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
81133dd0:	e0bff017 	ldw	r2,-64(fp)
81133dd4:	1080020b 	ldhu	r2,8(r2)
81133dd8:	10bfffcc 	andi	r2,r2,65535
81133ddc:	10001526 	beq	r2,zero,81133e34 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81133de0:	e0bff017 	ldw	r2,-64(fp)
81133de4:	1080020b 	ldhu	r2,8(r2)
81133de8:	10bfffc4 	addi	r2,r2,-1
81133dec:	1007883a 	mov	r3,r2
81133df0:	e0bff017 	ldw	r2,-64(fp)
81133df4:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
81133df8:	e0bffd17 	ldw	r2,-12(fp)
81133dfc:	10c00104 	addi	r3,r2,4
81133e00:	e0fffd15 	stw	r3,-12(fp)
81133e04:	e0fff017 	ldw	r3,-64(fp)
81133e08:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
81133e0c:	00800044 	movi	r2,1
81133e10:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81133e14:	e0bffe17 	ldw	r2,-8(fp)
81133e18:	10c00104 	addi	r3,r2,4
81133e1c:	e0fffe15 	stw	r3,-8(fp)
81133e20:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
81133e24:	e0bff18b 	ldhu	r2,-58(fp)
81133e28:	10800044 	addi	r2,r2,1
81133e2c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
81133e30:	00003e06 	br	81133f2c <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
81133e34:	e0bff203 	ldbu	r2,-56(fp)
81133e38:	10800054 	ori	r2,r2,1
81133e3c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81133e40:	00003a06 	br	81133f2c <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
81133e44:	e0bff017 	ldw	r2,-64(fp)
81133e48:	10800117 	ldw	r2,4(r2)
81133e4c:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
81133e50:	e0bff517 	ldw	r2,-44(fp)
81133e54:	1080058b 	ldhu	r2,22(r2)
81133e58:	10bfffcc 	andi	r2,r2,65535
81133e5c:	10002426 	beq	r2,zero,81133ef0 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
81133e60:	e0bffe17 	ldw	r2,-8(fp)
81133e64:	10c00104 	addi	r3,r2,4
81133e68:	e0fffe15 	stw	r3,-8(fp)
81133e6c:	e0fff517 	ldw	r3,-44(fp)
81133e70:	18c00417 	ldw	r3,16(r3)
81133e74:	19400104 	addi	r5,r3,4
81133e78:	e13ff517 	ldw	r4,-44(fp)
81133e7c:	21400415 	stw	r5,16(r4)
81133e80:	18c00017 	ldw	r3,0(r3)
81133e84:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81133e88:	e0bff517 	ldw	r2,-44(fp)
81133e8c:	10c00417 	ldw	r3,16(r2)
81133e90:	e0bff517 	ldw	r2,-44(fp)
81133e94:	10800217 	ldw	r2,8(r2)
81133e98:	1880041e 	bne	r3,r2,81133eac <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81133e9c:	e0bff517 	ldw	r2,-44(fp)
81133ea0:	10c00117 	ldw	r3,4(r2)
81133ea4:	e0bff517 	ldw	r2,-44(fp)
81133ea8:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
81133eac:	e0bff517 	ldw	r2,-44(fp)
81133eb0:	1080058b 	ldhu	r2,22(r2)
81133eb4:	10bfffc4 	addi	r2,r2,-1
81133eb8:	1007883a 	mov	r3,r2
81133ebc:	e0bff517 	ldw	r2,-44(fp)
81133ec0:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81133ec4:	e0bffd17 	ldw	r2,-12(fp)
81133ec8:	10c00104 	addi	r3,r2,4
81133ecc:	e0fffd15 	stw	r3,-12(fp)
81133ed0:	e0fff017 	ldw	r3,-64(fp)
81133ed4:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
81133ed8:	00800044 	movi	r2,1
81133edc:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81133ee0:	e0bff18b 	ldhu	r2,-58(fp)
81133ee4:	10800044 	addi	r2,r2,1
81133ee8:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
81133eec:	00000f06 	br	81133f2c <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81133ef0:	e0bff203 	ldbu	r2,-56(fp)
81133ef4:	10800114 	ori	r2,r2,4
81133ef8:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81133efc:	00000b06 	br	81133f2c <OSEventPendMulti+0x30c>
81133f00:	e0bff317 	ldw	r2,-52(fp)
81133f04:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133f08:	e0bff417 	ldw	r2,-48(fp)
81133f0c:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81133f10:	e0bffd17 	ldw	r2,-12(fp)
81133f14:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81133f18:	e0800217 	ldw	r2,8(fp)
81133f1c:	00c00044 	movi	r3,1
81133f20:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81133f24:	e0bff18b 	ldhu	r2,-58(fp)
81133f28:	00009d06 	br	811341a0 <OSEventPendMulti+0x580>
        }
        pevents++;
81133f2c:	e0bfef17 	ldw	r2,-68(fp)
81133f30:	10800104 	addi	r2,r2,4
81133f34:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81133f38:	e0bfef17 	ldw	r2,-68(fp)
81133f3c:	10800017 	ldw	r2,0(r2)
81133f40:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81133f44:	e0bff017 	ldw	r2,-64(fp)
81133f48:	103f9a1e 	bne	r2,zero,81133db4 <__reset+0xfb113db4>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
81133f4c:	e0bff103 	ldbu	r2,-60(fp)
81133f50:	10800058 	cmpnei	r2,r2,1
81133f54:	10000a1e 	bne	r2,zero,81133f80 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81133f58:	e0bffd17 	ldw	r2,-12(fp)
81133f5c:	10000015 	stw	zero,0(r2)
81133f60:	e0bff317 	ldw	r2,-52(fp)
81133f64:	e0bff615 	stw	r2,-40(fp)
81133f68:	e0bff617 	ldw	r2,-40(fp)
81133f6c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
81133f70:	e0800217 	ldw	r2,8(fp)
81133f74:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81133f78:	e0bff18b 	ldhu	r2,-58(fp)
81133f7c:	00008806 	br	811341a0 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81133f80:	d0a09d17 	ldw	r2,-32140(gp)
81133f84:	d0e09d17 	ldw	r3,-32140(gp)
81133f88:	19000c03 	ldbu	r4,48(r3)
81133f8c:	e0fff203 	ldbu	r3,-56(fp)
81133f90:	20c6b03a 	or	r3,r4,r3
81133f94:	1809883a 	mov	r4,r3
81133f98:	00ffe004 	movi	r3,-128
81133f9c:	20c6b03a 	or	r3,r4,r3
81133fa0:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81133fa4:	d0a09d17 	ldw	r2,-32140(gp)
81133fa8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
81133fac:	d0a09d17 	ldw	r2,-32140(gp)
81133fb0:	e0ffff0b 	ldhu	r3,-4(fp)
81133fb4:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
81133fb8:	e13ffc17 	ldw	r4,-16(fp)
81133fbc:	1134b440 	call	81134b44 <OS_EventTaskWaitMulti>
81133fc0:	e0bff317 	ldw	r2,-52(fp)
81133fc4:	e0bff915 	stw	r2,-28(fp)
81133fc8:	e0bff917 	ldw	r2,-28(fp)
81133fcc:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81133fd0:	11353480 	call	81135348 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133fd4:	0005303a 	rdctl	r2,status
81133fd8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133fdc:	e0fff717 	ldw	r3,-36(fp)
81133fe0:	00bfff84 	movi	r2,-2
81133fe4:	1884703a 	and	r2,r3,r2
81133fe8:	1001703a 	wrctl	status,r2
  
  return context;
81133fec:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81133ff0:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81133ff4:	d0a09d17 	ldw	r2,-32140(gp)
81133ff8:	10800c43 	ldbu	r2,49(r2)
81133ffc:	10803fcc 	andi	r2,r2,255
81134000:	10000226 	beq	r2,zero,8113400c <OSEventPendMulti+0x3ec>
81134004:	108000a0 	cmpeqi	r2,r2,2
81134008:	10001826 	beq	r2,zero,8113406c <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8113400c:	d0a09d17 	ldw	r2,-32140(gp)
81134010:	10800717 	ldw	r2,28(r2)
81134014:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81134018:	e0bff017 	ldw	r2,-64(fp)
8113401c:	10000b26 	beq	r2,zero,8113404c <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81134020:	e0bffd17 	ldw	r2,-12(fp)
81134024:	10c00104 	addi	r3,r2,4
81134028:	e0fffd15 	stw	r3,-12(fp)
8113402c:	e0fff017 	ldw	r3,-64(fp)
81134030:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
81134034:	e0bffd17 	ldw	r2,-12(fp)
81134038:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
8113403c:	e0bff18b 	ldhu	r2,-58(fp)
81134040:	10800044 	addi	r2,r2,1
81134044:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81134048:	00000d06 	br	81134080 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
8113404c:	d0a09d17 	ldw	r2,-32140(gp)
81134050:	00c00044 	movi	r3,1
81134054:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81134058:	d0a09d17 	ldw	r2,-32140(gp)
8113405c:	e17ffc17 	ldw	r5,-16(fp)
81134060:	1009883a 	mov	r4,r2
81134064:	1134d5c0 	call	81134d5c <OS_EventTaskRemoveMulti>
             }
			 break;
81134068:	00000506 	br	81134080 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8113406c:	d0a09d17 	ldw	r2,-32140(gp)
81134070:	e17ffc17 	ldw	r5,-16(fp)
81134074:	1009883a 	mov	r4,r2
81134078:	1134d5c0 	call	81134d5c <OS_EventTaskRemoveMulti>
             break;
8113407c:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81134080:	d0a09d17 	ldw	r2,-32140(gp)
81134084:	10800c43 	ldbu	r2,49(r2)
81134088:	10803fcc 	andi	r2,r2,255
8113408c:	10000326 	beq	r2,zero,8113409c <OSEventPendMulti+0x47c>
81134090:	108000a0 	cmpeqi	r2,r2,2
81134094:	1000231e 	bne	r2,zero,81134124 <OSEventPendMulti+0x504>
81134098:	00002a06 	br	81134144 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
8113409c:	e0bff017 	ldw	r2,-64(fp)
811340a0:	10800003 	ldbu	r2,0(r2)
811340a4:	10803fcc 	andi	r2,r2,255
811340a8:	0080100e 	bge	zero,r2,811340ec <OSEventPendMulti+0x4cc>
811340ac:	10c000d0 	cmplti	r3,r2,3
811340b0:	1800071e 	bne	r3,zero,811340d0 <OSEventPendMulti+0x4b0>
811340b4:	108000e0 	cmpeqi	r2,r2,3
811340b8:	10000c26 	beq	r2,zero,811340ec <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
811340bc:	e0bffe17 	ldw	r2,-8(fp)
811340c0:	10c00104 	addi	r3,r2,4
811340c4:	e0fffe15 	stw	r3,-8(fp)
811340c8:	10000015 	stw	zero,0(r2)
                      break;
811340cc:	00001206 	br	81134118 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
811340d0:	e0bffe17 	ldw	r2,-8(fp)
811340d4:	10c00104 	addi	r3,r2,4
811340d8:	e0fffe15 	stw	r3,-8(fp)
811340dc:	d0e09d17 	ldw	r3,-32140(gp)
811340e0:	18c00917 	ldw	r3,36(r3)
811340e4:	10c00015 	stw	r3,0(r2)
                      break;
811340e8:	00000b06 	br	81134118 <OSEventPendMulti+0x4f8>
811340ec:	e0bff317 	ldw	r2,-52(fp)
811340f0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811340f4:	e0bff817 	ldw	r2,-32(fp)
811340f8:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
811340fc:	e0bffd17 	ldw	r2,-12(fp)
81134100:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81134104:	e0800217 	ldw	r2,8(fp)
81134108:	00c00044 	movi	r3,1
8113410c:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81134110:	e0bff18b 	ldhu	r2,-58(fp)
81134114:	00002206 	br	811341a0 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81134118:	e0800217 	ldw	r2,8(fp)
8113411c:	10000005 	stb	zero,0(r2)
             break;
81134120:	00001006 	br	81134164 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81134124:	e0bffe17 	ldw	r2,-8(fp)
81134128:	10c00104 	addi	r3,r2,4
8113412c:	e0fffe15 	stw	r3,-8(fp)
81134130:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81134134:	e0800217 	ldw	r2,8(fp)
81134138:	00c00384 	movi	r3,14
8113413c:	10c00005 	stb	r3,0(r2)
             break;
81134140:	00000806 	br	81134164 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81134144:	e0bffe17 	ldw	r2,-8(fp)
81134148:	10c00104 	addi	r3,r2,4
8113414c:	e0fffe15 	stw	r3,-8(fp)
81134150:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81134154:	e0800217 	ldw	r2,8(fp)
81134158:	00c00284 	movi	r3,10
8113415c:	10c00005 	stb	r3,0(r2)
             break;
81134160:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
81134164:	d0a09d17 	ldw	r2,-32140(gp)
81134168:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
8113416c:	d0a09d17 	ldw	r2,-32140(gp)
81134170:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
81134174:	d0a09d17 	ldw	r2,-32140(gp)
81134178:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113417c:	d0a09d17 	ldw	r2,-32140(gp)
81134180:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81134184:	d0a09d17 	ldw	r2,-32140(gp)
81134188:	10000915 	stw	zero,36(r2)
8113418c:	e0bff317 	ldw	r2,-52(fp)
81134190:	e0bffa15 	stw	r2,-24(fp)
81134194:	e0bffa17 	ldw	r2,-24(fp)
81134198:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
8113419c:	e0bff18b 	ldhu	r2,-58(fp)
}
811341a0:	e037883a 	mov	sp,fp
811341a4:	dfc00117 	ldw	ra,4(sp)
811341a8:	df000017 	ldw	fp,0(sp)
811341ac:	dec00204 	addi	sp,sp,8
811341b0:	f800283a 	ret

811341b4 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
811341b4:	defffe04 	addi	sp,sp,-8
811341b8:	de00012e 	bgeu	sp,et,811341c0 <OSInit+0xc>
811341bc:	003b68fa 	trap	3
811341c0:	dfc00115 	stw	ra,4(sp)
811341c4:	df000015 	stw	fp,0(sp)
811341c8:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
811341cc:	11466b80 	call	811466b8 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
811341d0:	1134fbc0 	call	81134fbc <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
811341d4:	113500c0 	call	8113500c <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
811341d8:	11351900 	call	81135190 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
811341dc:	1134ed40 	call	81134ed4 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
811341e0:	11371500 	call	81137150 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
811341e4:	1137a980 	call	81137a98 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
811341e8:	1139d680 	call	81139d68 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
811341ec:	11350800 	call	81135080 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
811341f0:	11351080 	call	81135108 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
811341f4:	113d10c0 	call	8113d10c <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
811341f8:	11466e40 	call	811466e4 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
811341fc:	1135a6c0 	call	81135a6c <OSDebugInit>
#endif
}
81134200:	0001883a 	nop
81134204:	e037883a 	mov	sp,fp
81134208:	dfc00117 	ldw	ra,4(sp)
8113420c:	df000017 	ldw	fp,0(sp)
81134210:	dec00204 	addi	sp,sp,8
81134214:	f800283a 	ret

81134218 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81134218:	deffff04 	addi	sp,sp,-4
8113421c:	de00012e 	bgeu	sp,et,81134224 <OSIntEnter+0xc>
81134220:	003b68fa 	trap	3
81134224:	df000015 	stw	fp,0(sp)
81134228:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
8113422c:	d0a08c03 	ldbu	r2,-32208(gp)
81134230:	10803fcc 	andi	r2,r2,255
81134234:	10800058 	cmpnei	r2,r2,1
81134238:	1000071e 	bne	r2,zero,81134258 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
8113423c:	d0a09c03 	ldbu	r2,-32144(gp)
81134240:	10803fcc 	andi	r2,r2,255
81134244:	10803fe0 	cmpeqi	r2,r2,255
81134248:	1000031e 	bne	r2,zero,81134258 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
8113424c:	d0a09c03 	ldbu	r2,-32144(gp)
81134250:	10800044 	addi	r2,r2,1
81134254:	d0a09c05 	stb	r2,-32144(gp)
        }
    }
}
81134258:	0001883a 	nop
8113425c:	e037883a 	mov	sp,fp
81134260:	df000017 	ldw	fp,0(sp)
81134264:	dec00104 	addi	sp,sp,4
81134268:	f800283a 	ret

8113426c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
8113426c:	defffb04 	addi	sp,sp,-20
81134270:	de00012e 	bgeu	sp,et,81134278 <OSIntExit+0xc>
81134274:	003b68fa 	trap	3
81134278:	dfc00415 	stw	ra,16(sp)
8113427c:	df000315 	stw	fp,12(sp)
81134280:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81134284:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81134288:	d0a08c03 	ldbu	r2,-32208(gp)
8113428c:	10803fcc 	andi	r2,r2,255
81134290:	10800058 	cmpnei	r2,r2,1
81134294:	10002f1e 	bne	r2,zero,81134354 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134298:	0005303a 	rdctl	r2,status
8113429c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811342a0:	e0ffff17 	ldw	r3,-4(fp)
811342a4:	00bfff84 	movi	r2,-2
811342a8:	1884703a 	and	r2,r3,r2
811342ac:	1001703a 	wrctl	status,r2
  
  return context;
811342b0:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
811342b4:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
811342b8:	d0a09c03 	ldbu	r2,-32144(gp)
811342bc:	10803fcc 	andi	r2,r2,255
811342c0:	10000326 	beq	r2,zero,811342d0 <OSIntExit+0x64>
            OSIntNesting--;
811342c4:	d0a09c03 	ldbu	r2,-32144(gp)
811342c8:	10bfffc4 	addi	r2,r2,-1
811342cc:	d0a09c05 	stb	r2,-32144(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
811342d0:	d0a09c03 	ldbu	r2,-32144(gp)
811342d4:	10803fcc 	andi	r2,r2,255
811342d8:	10001a1e 	bne	r2,zero,81134344 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
811342dc:	d0a08a03 	ldbu	r2,-32216(gp)
811342e0:	10803fcc 	andi	r2,r2,255
811342e4:	1000171e 	bne	r2,zero,81134344 <OSIntExit+0xd8>
                OS_SchedNew();
811342e8:	11354200 	call	81135420 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
811342ec:	d0e08e83 	ldbu	r3,-32198(gp)
811342f0:	d0a08ec3 	ldbu	r2,-32197(gp)
811342f4:	18c03fcc 	andi	r3,r3,255
811342f8:	10803fcc 	andi	r2,r2,255
811342fc:	18801126 	beq	r3,r2,81134344 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81134300:	d0a08e83 	ldbu	r2,-32198(gp)
81134304:	10c03fcc 	andi	r3,r2,255
81134308:	00a045b4 	movhi	r2,33046
8113430c:	109e0d04 	addi	r2,r2,30772
81134310:	18c7883a 	add	r3,r3,r3
81134314:	18c7883a 	add	r3,r3,r3
81134318:	10c5883a 	add	r2,r2,r3
8113431c:	10800017 	ldw	r2,0(r2)
81134320:	d0a09715 	stw	r2,-32164(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81134324:	d0a09717 	ldw	r2,-32164(gp)
81134328:	10c00e17 	ldw	r3,56(r2)
8113432c:	18c00044 	addi	r3,r3,1
81134330:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81134334:	d0a09117 	ldw	r2,-32188(gp)
81134338:	10800044 	addi	r2,r2,1
8113433c:	d0a09115 	stw	r2,-32188(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81134340:	11463780 	call	81146378 <OSCtxSw>
81134344:	e0bffd17 	ldw	r2,-12(fp)
81134348:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113434c:	e0bffe17 	ldw	r2,-8(fp)
81134350:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81134354:	0001883a 	nop
81134358:	e037883a 	mov	sp,fp
8113435c:	dfc00117 	ldw	ra,4(sp)
81134360:	df000017 	ldw	fp,0(sp)
81134364:	dec00204 	addi	sp,sp,8
81134368:	f800283a 	ret

8113436c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
8113436c:	defffc04 	addi	sp,sp,-16
81134370:	de00012e 	bgeu	sp,et,81134378 <OSSchedLock+0xc>
81134374:	003b68fa 	trap	3
81134378:	df000315 	stw	fp,12(sp)
8113437c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134380:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81134384:	d0a08c03 	ldbu	r2,-32208(gp)
81134388:	10803fcc 	andi	r2,r2,255
8113438c:	10800058 	cmpnei	r2,r2,1
81134390:	1000161e 	bne	r2,zero,811343ec <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134394:	0005303a 	rdctl	r2,status
81134398:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113439c:	e0ffff17 	ldw	r3,-4(fp)
811343a0:	00bfff84 	movi	r2,-2
811343a4:	1884703a 	and	r2,r3,r2
811343a8:	1001703a 	wrctl	status,r2
  
  return context;
811343ac:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
811343b0:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
811343b4:	d0a09c03 	ldbu	r2,-32144(gp)
811343b8:	10803fcc 	andi	r2,r2,255
811343bc:	1000071e 	bne	r2,zero,811343dc <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
811343c0:	d0a08a03 	ldbu	r2,-32216(gp)
811343c4:	10803fcc 	andi	r2,r2,255
811343c8:	10803fe0 	cmpeqi	r2,r2,255
811343cc:	1000031e 	bne	r2,zero,811343dc <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
811343d0:	d0a08a03 	ldbu	r2,-32216(gp)
811343d4:	10800044 	addi	r2,r2,1
811343d8:	d0a08a05 	stb	r2,-32216(gp)
811343dc:	e0bffd17 	ldw	r2,-12(fp)
811343e0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811343e4:	e0bffe17 	ldw	r2,-8(fp)
811343e8:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
811343ec:	0001883a 	nop
811343f0:	e037883a 	mov	sp,fp
811343f4:	df000017 	ldw	fp,0(sp)
811343f8:	dec00104 	addi	sp,sp,4
811343fc:	f800283a 	ret

81134400 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81134400:	defff804 	addi	sp,sp,-32
81134404:	de00012e 	bgeu	sp,et,8113440c <OSSchedUnlock+0xc>
81134408:	003b68fa 	trap	3
8113440c:	dfc00715 	stw	ra,28(sp)
81134410:	df000615 	stw	fp,24(sp)
81134414:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81134418:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
8113441c:	d0a08c03 	ldbu	r2,-32208(gp)
81134420:	10803fcc 	andi	r2,r2,255
81134424:	10800058 	cmpnei	r2,r2,1
81134428:	1000281e 	bne	r2,zero,811344cc <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113442c:	0005303a 	rdctl	r2,status
81134430:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134434:	e0ffff17 	ldw	r3,-4(fp)
81134438:	00bfff84 	movi	r2,-2
8113443c:	1884703a 	and	r2,r3,r2
81134440:	1001703a 	wrctl	status,r2
  
  return context;
81134444:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81134448:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
8113444c:	d0a08a03 	ldbu	r2,-32216(gp)
81134450:	10803fcc 	andi	r2,r2,255
81134454:	10001926 	beq	r2,zero,811344bc <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81134458:	d0a08a03 	ldbu	r2,-32216(gp)
8113445c:	10bfffc4 	addi	r2,r2,-1
81134460:	d0a08a05 	stb	r2,-32216(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81134464:	d0a08a03 	ldbu	r2,-32216(gp)
81134468:	10803fcc 	andi	r2,r2,255
8113446c:	10000e1e 	bne	r2,zero,811344a8 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81134470:	d0a09c03 	ldbu	r2,-32144(gp)
81134474:	10803fcc 	andi	r2,r2,255
81134478:	1000061e 	bne	r2,zero,81134494 <OSSchedUnlock+0x94>
8113447c:	e0bffa17 	ldw	r2,-24(fp)
81134480:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134484:	e0bffb17 	ldw	r2,-20(fp)
81134488:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
8113448c:	11353480 	call	81135348 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81134490:	00000e06 	br	811344cc <OSSchedUnlock+0xcc>
81134494:	e0bffa17 	ldw	r2,-24(fp)
81134498:	e0bffc15 	stw	r2,-16(fp)
8113449c:	e0bffc17 	ldw	r2,-16(fp)
811344a0:	1001703a 	wrctl	status,r2
811344a4:	00000906 	br	811344cc <OSSchedUnlock+0xcc>
811344a8:	e0bffa17 	ldw	r2,-24(fp)
811344ac:	e0bffd15 	stw	r2,-12(fp)
811344b0:	e0bffd17 	ldw	r2,-12(fp)
811344b4:	1001703a 	wrctl	status,r2
811344b8:	00000406 	br	811344cc <OSSchedUnlock+0xcc>
811344bc:	e0bffa17 	ldw	r2,-24(fp)
811344c0:	e0bffe15 	stw	r2,-8(fp)
811344c4:	e0bffe17 	ldw	r2,-8(fp)
811344c8:	1001703a 	wrctl	status,r2
811344cc:	0001883a 	nop
811344d0:	e037883a 	mov	sp,fp
811344d4:	dfc00117 	ldw	ra,4(sp)
811344d8:	df000017 	ldw	fp,0(sp)
811344dc:	dec00204 	addi	sp,sp,8
811344e0:	f800283a 	ret

811344e4 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
811344e4:	defffe04 	addi	sp,sp,-8
811344e8:	de00012e 	bgeu	sp,et,811344f0 <OSStart+0xc>
811344ec:	003b68fa 	trap	3
811344f0:	dfc00115 	stw	ra,4(sp)
811344f4:	df000015 	stw	fp,0(sp)
811344f8:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
811344fc:	d0a08c03 	ldbu	r2,-32208(gp)
81134500:	10803fcc 	andi	r2,r2,255
81134504:	10000f1e 	bne	r2,zero,81134544 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81134508:	11354200 	call	81135420 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
8113450c:	d0a08e83 	ldbu	r2,-32198(gp)
81134510:	d0a08ec5 	stb	r2,-32197(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81134514:	d0a08e83 	ldbu	r2,-32198(gp)
81134518:	10c03fcc 	andi	r3,r2,255
8113451c:	00a045b4 	movhi	r2,33046
81134520:	109e0d04 	addi	r2,r2,30772
81134524:	18c7883a 	add	r3,r3,r3
81134528:	18c7883a 	add	r3,r3,r3
8113452c:	10c5883a 	add	r2,r2,r3
81134530:	10800017 	ldw	r2,0(r2)
81134534:	d0a09715 	stw	r2,-32164(gp)
        OSTCBCur      = OSTCBHighRdy;
81134538:	d0a09717 	ldw	r2,-32164(gp)
8113453c:	d0a09d15 	stw	r2,-32140(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81134540:	11464140 	call	81146414 <OSStartHighRdy>
    }
}
81134544:	0001883a 	nop
81134548:	e037883a 	mov	sp,fp
8113454c:	dfc00117 	ldw	ra,4(sp)
81134550:	df000017 	ldw	fp,0(sp)
81134554:	dec00204 	addi	sp,sp,8
81134558:	f800283a 	ret

8113455c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
8113455c:	defff904 	addi	sp,sp,-28
81134560:	de00012e 	bgeu	sp,et,81134568 <OSStatInit+0xc>
81134564:	003b68fa 	trap	3
81134568:	dfc00615 	stw	ra,24(sp)
8113456c:	df000515 	stw	fp,20(sp)
81134570:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134574:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81134578:	01000084 	movi	r4,2
8113457c:	113c0840 	call	8113c084 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134580:	0005303a 	rdctl	r2,status
81134584:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134588:	e0fffc17 	ldw	r3,-16(fp)
8113458c:	00bfff84 	movi	r2,-2
81134590:	1884703a 	and	r2,r3,r2
81134594:	1001703a 	wrctl	status,r2
  
  return context;
81134598:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
8113459c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
811345a0:	d0208d15 	stw	zero,-32204(gp)
811345a4:	e0bffb17 	ldw	r2,-20(fp)
811345a8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811345ac:	e0bffd17 	ldw	r2,-12(fp)
811345b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
811345b4:	01001904 	movi	r4,100
811345b8:	113c0840 	call	8113c084 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811345bc:	0005303a 	rdctl	r2,status
811345c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811345c4:	e0fffe17 	ldw	r3,-8(fp)
811345c8:	00bfff84 	movi	r2,-2
811345cc:	1884703a 	and	r2,r3,r2
811345d0:	1001703a 	wrctl	status,r2
  
  return context;
811345d4:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
811345d8:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
811345dc:	d0a08d17 	ldw	r2,-32204(gp)
811345e0:	d0a09315 	stw	r2,-32180(gp)
    OSStatRdy    = OS_TRUE;
811345e4:	00800044 	movi	r2,1
811345e8:	d0a0a205 	stb	r2,-32120(gp)
811345ec:	e0bffb17 	ldw	r2,-20(fp)
811345f0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811345f4:	e0bfff17 	ldw	r2,-4(fp)
811345f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
811345fc:	0001883a 	nop
81134600:	e037883a 	mov	sp,fp
81134604:	dfc00117 	ldw	ra,4(sp)
81134608:	df000017 	ldw	fp,0(sp)
8113460c:	dec00204 	addi	sp,sp,8
81134610:	f800283a 	ret

81134614 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81134614:	defff704 	addi	sp,sp,-36
81134618:	de00012e 	bgeu	sp,et,81134620 <OSTimeTick+0xc>
8113461c:	003b68fa 	trap	3
81134620:	dfc00815 	stw	ra,32(sp)
81134624:	df000715 	stw	fp,28(sp)
81134628:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113462c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81134630:	11466640 	call	81146664 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134634:	0005303a 	rdctl	r2,status
81134638:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113463c:	e0fffd17 	ldw	r3,-12(fp)
81134640:	00bfff84 	movi	r2,-2
81134644:	1884703a 	and	r2,r3,r2
81134648:	1001703a 	wrctl	status,r2
  
  return context;
8113464c:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81134650:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81134654:	d0a09f17 	ldw	r2,-32132(gp)
81134658:	10800044 	addi	r2,r2,1
8113465c:	d0a09f15 	stw	r2,-32132(gp)
81134660:	e0bffb17 	ldw	r2,-20(fp)
81134664:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134668:	e0bfff17 	ldw	r2,-4(fp)
8113466c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81134670:	d0a08c03 	ldbu	r2,-32208(gp)
81134674:	10803fcc 	andi	r2,r2,255
81134678:	10800058 	cmpnei	r2,r2,1
8113467c:	10006a1e 	bne	r2,zero,81134828 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81134680:	d0a09003 	ldbu	r2,-32192(gp)
81134684:	10803fcc 	andi	r2,r2,255
81134688:	10c00060 	cmpeqi	r3,r2,1
8113468c:	1800061e 	bne	r3,zero,811346a8 <OSTimeTick+0x94>
81134690:	10c000a0 	cmpeqi	r3,r2,2
81134694:	1800061e 	bne	r3,zero,811346b0 <OSTimeTick+0x9c>
81134698:	10000a1e 	bne	r2,zero,811346c4 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
8113469c:	00800044 	movi	r2,1
811346a0:	e0bffa05 	stb	r2,-24(fp)
                 break;
811346a4:	00000b06 	br	811346d4 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
811346a8:	e03ffa05 	stb	zero,-24(fp)
                 break;
811346ac:	00000906 	br	811346d4 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
811346b0:	00800044 	movi	r2,1
811346b4:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
811346b8:	00800044 	movi	r2,1
811346bc:	d0a09005 	stb	r2,-32192(gp)
                 break;
811346c0:	00000406 	br	811346d4 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
811346c4:	00800044 	movi	r2,1
811346c8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
811346cc:	d0209005 	stb	zero,-32192(gp)
                 break;
811346d0:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
811346d4:	e0bffa03 	ldbu	r2,-24(fp)
811346d8:	10005226 	beq	r2,zero,81134824 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
811346dc:	d0a08f17 	ldw	r2,-32196(gp)
811346e0:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
811346e4:	00004906 	br	8113480c <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811346e8:	0005303a 	rdctl	r2,status
811346ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811346f0:	e0fffc17 	ldw	r3,-16(fp)
811346f4:	00bfff84 	movi	r2,-2
811346f8:	1884703a 	and	r2,r3,r2
811346fc:	1001703a 	wrctl	status,r2
  
  return context;
81134700:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81134704:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81134708:	e0bff917 	ldw	r2,-28(fp)
8113470c:	10800b8b 	ldhu	r2,46(r2)
81134710:	10bfffcc 	andi	r2,r2,65535
81134714:	10003626 	beq	r2,zero,811347f0 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81134718:	e0bff917 	ldw	r2,-28(fp)
8113471c:	10800b8b 	ldhu	r2,46(r2)
81134720:	10bfffc4 	addi	r2,r2,-1
81134724:	1007883a 	mov	r3,r2
81134728:	e0bff917 	ldw	r2,-28(fp)
8113472c:	10c00b8d 	sth	r3,46(r2)
81134730:	e0bff917 	ldw	r2,-28(fp)
81134734:	10800b8b 	ldhu	r2,46(r2)
81134738:	10bfffcc 	andi	r2,r2,65535
8113473c:	10002c1e 	bne	r2,zero,811347f0 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81134740:	e0bff917 	ldw	r2,-28(fp)
81134744:	10800c03 	ldbu	r2,48(r2)
81134748:	10803fcc 	andi	r2,r2,255
8113474c:	10800dcc 	andi	r2,r2,55
81134750:	10000b26 	beq	r2,zero,81134780 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81134754:	e0bff917 	ldw	r2,-28(fp)
81134758:	10c00c03 	ldbu	r3,48(r2)
8113475c:	00bff204 	movi	r2,-56
81134760:	1884703a 	and	r2,r3,r2
81134764:	1007883a 	mov	r3,r2
81134768:	e0bff917 	ldw	r2,-28(fp)
8113476c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81134770:	e0bff917 	ldw	r2,-28(fp)
81134774:	00c00044 	movi	r3,1
81134778:	10c00c45 	stb	r3,49(r2)
8113477c:	00000206 	br	81134788 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81134780:	e0bff917 	ldw	r2,-28(fp)
81134784:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81134788:	e0bff917 	ldw	r2,-28(fp)
8113478c:	10800c03 	ldbu	r2,48(r2)
81134790:	10803fcc 	andi	r2,r2,255
81134794:	1080020c 	andi	r2,r2,8
81134798:	1000151e 	bne	r2,zero,811347f0 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8113479c:	e0bff917 	ldw	r2,-28(fp)
811347a0:	10c00d83 	ldbu	r3,54(r2)
811347a4:	d0a09903 	ldbu	r2,-32156(gp)
811347a8:	1884b03a 	or	r2,r3,r2
811347ac:	d0a09905 	stb	r2,-32156(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811347b0:	e0bff917 	ldw	r2,-28(fp)
811347b4:	10800d03 	ldbu	r2,52(r2)
811347b8:	10c03fcc 	andi	r3,r2,255
811347bc:	e0bff917 	ldw	r2,-28(fp)
811347c0:	10800d03 	ldbu	r2,52(r2)
811347c4:	11003fcc 	andi	r4,r2,255
811347c8:	d0a09944 	addi	r2,gp,-32155
811347cc:	2085883a 	add	r2,r4,r2
811347d0:	11000003 	ldbu	r4,0(r2)
811347d4:	e0bff917 	ldw	r2,-28(fp)
811347d8:	10800d43 	ldbu	r2,53(r2)
811347dc:	2084b03a 	or	r2,r4,r2
811347e0:	1009883a 	mov	r4,r2
811347e4:	d0a09944 	addi	r2,gp,-32155
811347e8:	1885883a 	add	r2,r3,r2
811347ec:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
811347f0:	e0bff917 	ldw	r2,-28(fp)
811347f4:	10800517 	ldw	r2,20(r2)
811347f8:	e0bff915 	stw	r2,-28(fp)
811347fc:	e0bffb17 	ldw	r2,-20(fp)
81134800:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134804:	e0bffe17 	ldw	r2,-8(fp)
81134808:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113480c:	e0bff917 	ldw	r2,-28(fp)
81134810:	10800c83 	ldbu	r2,50(r2)
81134814:	10803fcc 	andi	r2,r2,255
81134818:	10800a98 	cmpnei	r2,r2,42
8113481c:	103fb21e 	bne	r2,zero,811346e8 <__reset+0xfb1146e8>
81134820:	00000106 	br	81134828 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81134824:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81134828:	e037883a 	mov	sp,fp
8113482c:	dfc00117 	ldw	ra,4(sp)
81134830:	df000017 	ldw	fp,0(sp)
81134834:	dec00204 	addi	sp,sp,8
81134838:	f800283a 	ret

8113483c <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8113483c:	deffff04 	addi	sp,sp,-4
81134840:	de00012e 	bgeu	sp,et,81134848 <OSVersion+0xc>
81134844:	003b68fa 	trap	3
81134848:	df000015 	stw	fp,0(sp)
8113484c:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81134850:	00804784 	movi	r2,286
}
81134854:	e037883a 	mov	sp,fp
81134858:	df000017 	ldw	fp,0(sp)
8113485c:	dec00104 	addi	sp,sp,4
81134860:	f800283a 	ret

81134864 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81134864:	deffff04 	addi	sp,sp,-4
81134868:	de00012e 	bgeu	sp,et,81134870 <OS_Dummy+0xc>
8113486c:	003b68fa 	trap	3
81134870:	df000015 	stw	fp,0(sp)
81134874:	d839883a 	mov	fp,sp
}
81134878:	0001883a 	nop
8113487c:	e037883a 	mov	sp,fp
81134880:	df000017 	ldw	fp,0(sp)
81134884:	dec00104 	addi	sp,sp,4
81134888:	f800283a 	ret

8113488c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8113488c:	defff804 	addi	sp,sp,-32
81134890:	de00012e 	bgeu	sp,et,81134898 <OS_EventTaskRdy+0xc>
81134894:	003b68fa 	trap	3
81134898:	dfc00715 	stw	ra,28(sp)
8113489c:	df000615 	stw	fp,24(sp)
811348a0:	df000604 	addi	fp,sp,24
811348a4:	e13ffc15 	stw	r4,-16(fp)
811348a8:	e17ffd15 	stw	r5,-12(fp)
811348ac:	3007883a 	mov	r3,r6
811348b0:	3805883a 	mov	r2,r7
811348b4:	e0fffe05 	stb	r3,-8(fp)
811348b8:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
811348bc:	e0bffc17 	ldw	r2,-16(fp)
811348c0:	10800283 	ldbu	r2,10(r2)
811348c4:	10c03fcc 	andi	r3,r2,255
811348c8:	00a04574 	movhi	r2,33045
811348cc:	10af6104 	addi	r2,r2,-17020
811348d0:	10c5883a 	add	r2,r2,r3
811348d4:	10800003 	ldbu	r2,0(r2)
811348d8:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
811348dc:	e0bffa03 	ldbu	r2,-24(fp)
811348e0:	e0fffc17 	ldw	r3,-16(fp)
811348e4:	1885883a 	add	r2,r3,r2
811348e8:	108002c4 	addi	r2,r2,11
811348ec:	10800003 	ldbu	r2,0(r2)
811348f0:	10c03fcc 	andi	r3,r2,255
811348f4:	00a04574 	movhi	r2,33045
811348f8:	10af6104 	addi	r2,r2,-17020
811348fc:	10c5883a 	add	r2,r2,r3
81134900:	10800003 	ldbu	r2,0(r2)
81134904:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81134908:	e0bffa03 	ldbu	r2,-24(fp)
8113490c:	100490fa 	slli	r2,r2,3
81134910:	1007883a 	mov	r3,r2
81134914:	e0bffa43 	ldbu	r2,-23(fp)
81134918:	1885883a 	add	r2,r3,r2
8113491c:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81134920:	e0fffa83 	ldbu	r3,-22(fp)
81134924:	00a045b4 	movhi	r2,33046
81134928:	109e0d04 	addi	r2,r2,30772
8113492c:	18c7883a 	add	r3,r3,r3
81134930:	18c7883a 	add	r3,r3,r3
81134934:	10c5883a 	add	r2,r2,r3
81134938:	10800017 	ldw	r2,0(r2)
8113493c:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81134940:	e0bffb17 	ldw	r2,-20(fp)
81134944:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81134948:	e0bffb17 	ldw	r2,-20(fp)
8113494c:	e0fffd17 	ldw	r3,-12(fp)
81134950:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81134954:	e0bffb17 	ldw	r2,-20(fp)
81134958:	10800c03 	ldbu	r2,48(r2)
8113495c:	1007883a 	mov	r3,r2
81134960:	e0bffe03 	ldbu	r2,-8(fp)
81134964:	0084303a 	nor	r2,zero,r2
81134968:	1884703a 	and	r2,r3,r2
8113496c:	1007883a 	mov	r3,r2
81134970:	e0bffb17 	ldw	r2,-20(fp)
81134974:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81134978:	e0bffb17 	ldw	r2,-20(fp)
8113497c:	e0ffff03 	ldbu	r3,-4(fp)
81134980:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81134984:	e0bffb17 	ldw	r2,-20(fp)
81134988:	10800c03 	ldbu	r2,48(r2)
8113498c:	10803fcc 	andi	r2,r2,255
81134990:	1080020c 	andi	r2,r2,8
81134994:	1000111e 	bne	r2,zero,811349dc <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
81134998:	e0bffb17 	ldw	r2,-20(fp)
8113499c:	10c00d83 	ldbu	r3,54(r2)
811349a0:	d0a09903 	ldbu	r2,-32156(gp)
811349a4:	1884b03a 	or	r2,r3,r2
811349a8:	d0a09905 	stb	r2,-32156(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
811349ac:	e0fffa03 	ldbu	r3,-24(fp)
811349b0:	e13ffa03 	ldbu	r4,-24(fp)
811349b4:	d0a09944 	addi	r2,gp,-32155
811349b8:	2085883a 	add	r2,r4,r2
811349bc:	11000003 	ldbu	r4,0(r2)
811349c0:	e0bffb17 	ldw	r2,-20(fp)
811349c4:	10800d43 	ldbu	r2,53(r2)
811349c8:	2084b03a 	or	r2,r4,r2
811349cc:	1009883a 	mov	r4,r2
811349d0:	d0a09944 	addi	r2,gp,-32155
811349d4:	1885883a 	add	r2,r3,r2
811349d8:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
811349dc:	e17ffc17 	ldw	r5,-16(fp)
811349e0:	e13ffb17 	ldw	r4,-20(fp)
811349e4:	1134c9c0 	call	81134c9c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
811349e8:	e0bffb17 	ldw	r2,-20(fp)
811349ec:	10800817 	ldw	r2,32(r2)
811349f0:	10000826 	beq	r2,zero,81134a14 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
811349f4:	e0bffb17 	ldw	r2,-20(fp)
811349f8:	10800817 	ldw	r2,32(r2)
811349fc:	100b883a 	mov	r5,r2
81134a00:	e13ffb17 	ldw	r4,-20(fp)
81134a04:	1134d5c0 	call	81134d5c <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81134a08:	e0bffb17 	ldw	r2,-20(fp)
81134a0c:	e0fffc17 	ldw	r3,-16(fp)
81134a10:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81134a14:	e0bffa83 	ldbu	r2,-22(fp)
}
81134a18:	e037883a 	mov	sp,fp
81134a1c:	dfc00117 	ldw	ra,4(sp)
81134a20:	df000017 	ldw	fp,0(sp)
81134a24:	dec00204 	addi	sp,sp,8
81134a28:	f800283a 	ret

81134a2c <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
81134a2c:	defffd04 	addi	sp,sp,-12
81134a30:	de00012e 	bgeu	sp,et,81134a38 <OS_EventTaskWait+0xc>
81134a34:	003b68fa 	trap	3
81134a38:	df000215 	stw	fp,8(sp)
81134a3c:	df000204 	addi	fp,sp,8
81134a40:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81134a44:	d0a09d17 	ldw	r2,-32140(gp)
81134a48:	e0ffff17 	ldw	r3,-4(fp)
81134a4c:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
81134a50:	d0a09d17 	ldw	r2,-32140(gp)
81134a54:	10800d03 	ldbu	r2,52(r2)
81134a58:	10803fcc 	andi	r2,r2,255
81134a5c:	d0e09d17 	ldw	r3,-32140(gp)
81134a60:	18c00d03 	ldbu	r3,52(r3)
81134a64:	18c03fcc 	andi	r3,r3,255
81134a68:	e13fff17 	ldw	r4,-4(fp)
81134a6c:	20c7883a 	add	r3,r4,r3
81134a70:	18c002c4 	addi	r3,r3,11
81134a74:	19000003 	ldbu	r4,0(r3)
81134a78:	d0e09d17 	ldw	r3,-32140(gp)
81134a7c:	18c00d43 	ldbu	r3,53(r3)
81134a80:	20c6b03a 	or	r3,r4,r3
81134a84:	1809883a 	mov	r4,r3
81134a88:	e0ffff17 	ldw	r3,-4(fp)
81134a8c:	1885883a 	add	r2,r3,r2
81134a90:	108002c4 	addi	r2,r2,11
81134a94:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81134a98:	e0bfff17 	ldw	r2,-4(fp)
81134a9c:	10c00283 	ldbu	r3,10(r2)
81134aa0:	d0a09d17 	ldw	r2,-32140(gp)
81134aa4:	10800d83 	ldbu	r2,54(r2)
81134aa8:	1884b03a 	or	r2,r3,r2
81134aac:	1007883a 	mov	r3,r2
81134ab0:	e0bfff17 	ldw	r2,-4(fp)
81134ab4:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81134ab8:	d0a09d17 	ldw	r2,-32140(gp)
81134abc:	10800d03 	ldbu	r2,52(r2)
81134ac0:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81134ac4:	e0fffe03 	ldbu	r3,-8(fp)
81134ac8:	e13ffe03 	ldbu	r4,-8(fp)
81134acc:	d0a09944 	addi	r2,gp,-32155
81134ad0:	2085883a 	add	r2,r4,r2
81134ad4:	10800003 	ldbu	r2,0(r2)
81134ad8:	1009883a 	mov	r4,r2
81134adc:	d0a09d17 	ldw	r2,-32140(gp)
81134ae0:	10800d43 	ldbu	r2,53(r2)
81134ae4:	0084303a 	nor	r2,zero,r2
81134ae8:	2084703a 	and	r2,r4,r2
81134aec:	1009883a 	mov	r4,r2
81134af0:	d0a09944 	addi	r2,gp,-32155
81134af4:	1885883a 	add	r2,r3,r2
81134af8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81134afc:	e0fffe03 	ldbu	r3,-8(fp)
81134b00:	d0a09944 	addi	r2,gp,-32155
81134b04:	1885883a 	add	r2,r3,r2
81134b08:	10800003 	ldbu	r2,0(r2)
81134b0c:	10803fcc 	andi	r2,r2,255
81134b10:	1000071e 	bne	r2,zero,81134b30 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81134b14:	d0a09d17 	ldw	r2,-32140(gp)
81134b18:	10800d83 	ldbu	r2,54(r2)
81134b1c:	0084303a 	nor	r2,zero,r2
81134b20:	1007883a 	mov	r3,r2
81134b24:	d0a09903 	ldbu	r2,-32156(gp)
81134b28:	1884703a 	and	r2,r3,r2
81134b2c:	d0a09905 	stb	r2,-32156(gp)
    }
}
81134b30:	0001883a 	nop
81134b34:	e037883a 	mov	sp,fp
81134b38:	df000017 	ldw	fp,0(sp)
81134b3c:	dec00104 	addi	sp,sp,4
81134b40:	f800283a 	ret

81134b44 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81134b44:	defffb04 	addi	sp,sp,-20
81134b48:	de00012e 	bgeu	sp,et,81134b50 <OS_EventTaskWaitMulti+0xc>
81134b4c:	003b68fa 	trap	3
81134b50:	df000415 	stw	fp,16(sp)
81134b54:	df000404 	addi	fp,sp,16
81134b58:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
81134b5c:	d0a09d17 	ldw	r2,-32140(gp)
81134b60:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
81134b64:	d0a09d17 	ldw	r2,-32140(gp)
81134b68:	e0ffff17 	ldw	r3,-4(fp)
81134b6c:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
81134b70:	e0bfff17 	ldw	r2,-4(fp)
81134b74:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81134b78:	e0bffc17 	ldw	r2,-16(fp)
81134b7c:	10800017 	ldw	r2,0(r2)
81134b80:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81134b84:	00002006 	br	81134c08 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
81134b88:	d0a09d17 	ldw	r2,-32140(gp)
81134b8c:	10800d03 	ldbu	r2,52(r2)
81134b90:	10803fcc 	andi	r2,r2,255
81134b94:	d0e09d17 	ldw	r3,-32140(gp)
81134b98:	18c00d03 	ldbu	r3,52(r3)
81134b9c:	18c03fcc 	andi	r3,r3,255
81134ba0:	e13ffd17 	ldw	r4,-12(fp)
81134ba4:	20c7883a 	add	r3,r4,r3
81134ba8:	18c002c4 	addi	r3,r3,11
81134bac:	19000003 	ldbu	r4,0(r3)
81134bb0:	d0e09d17 	ldw	r3,-32140(gp)
81134bb4:	18c00d43 	ldbu	r3,53(r3)
81134bb8:	20c6b03a 	or	r3,r4,r3
81134bbc:	1809883a 	mov	r4,r3
81134bc0:	e0fffd17 	ldw	r3,-12(fp)
81134bc4:	1885883a 	add	r2,r3,r2
81134bc8:	108002c4 	addi	r2,r2,11
81134bcc:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81134bd0:	e0bffd17 	ldw	r2,-12(fp)
81134bd4:	10c00283 	ldbu	r3,10(r2)
81134bd8:	d0a09d17 	ldw	r2,-32140(gp)
81134bdc:	10800d83 	ldbu	r2,54(r2)
81134be0:	1884b03a 	or	r2,r3,r2
81134be4:	1007883a 	mov	r3,r2
81134be8:	e0bffd17 	ldw	r2,-12(fp)
81134bec:	10c00285 	stb	r3,10(r2)
        pevents++;
81134bf0:	e0bffc17 	ldw	r2,-16(fp)
81134bf4:	10800104 	addi	r2,r2,4
81134bf8:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
81134bfc:	e0bffc17 	ldw	r2,-16(fp)
81134c00:	10800017 	ldw	r2,0(r2)
81134c04:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81134c08:	e0bffd17 	ldw	r2,-12(fp)
81134c0c:	103fde1e 	bne	r2,zero,81134b88 <__reset+0xfb114b88>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81134c10:	d0a09d17 	ldw	r2,-32140(gp)
81134c14:	10800d03 	ldbu	r2,52(r2)
81134c18:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81134c1c:	e0fffe03 	ldbu	r3,-8(fp)
81134c20:	e13ffe03 	ldbu	r4,-8(fp)
81134c24:	d0a09944 	addi	r2,gp,-32155
81134c28:	2085883a 	add	r2,r4,r2
81134c2c:	10800003 	ldbu	r2,0(r2)
81134c30:	1009883a 	mov	r4,r2
81134c34:	d0a09d17 	ldw	r2,-32140(gp)
81134c38:	10800d43 	ldbu	r2,53(r2)
81134c3c:	0084303a 	nor	r2,zero,r2
81134c40:	2084703a 	and	r2,r4,r2
81134c44:	1009883a 	mov	r4,r2
81134c48:	d0a09944 	addi	r2,gp,-32155
81134c4c:	1885883a 	add	r2,r3,r2
81134c50:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81134c54:	e0fffe03 	ldbu	r3,-8(fp)
81134c58:	d0a09944 	addi	r2,gp,-32155
81134c5c:	1885883a 	add	r2,r3,r2
81134c60:	10800003 	ldbu	r2,0(r2)
81134c64:	10803fcc 	andi	r2,r2,255
81134c68:	1000071e 	bne	r2,zero,81134c88 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81134c6c:	d0a09d17 	ldw	r2,-32140(gp)
81134c70:	10800d83 	ldbu	r2,54(r2)
81134c74:	0084303a 	nor	r2,zero,r2
81134c78:	1007883a 	mov	r3,r2
81134c7c:	d0a09903 	ldbu	r2,-32156(gp)
81134c80:	1884703a 	and	r2,r3,r2
81134c84:	d0a09905 	stb	r2,-32156(gp)
    }
}
81134c88:	0001883a 	nop
81134c8c:	e037883a 	mov	sp,fp
81134c90:	df000017 	ldw	fp,0(sp)
81134c94:	dec00104 	addi	sp,sp,4
81134c98:	f800283a 	ret

81134c9c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
81134c9c:	defffc04 	addi	sp,sp,-16
81134ca0:	de00012e 	bgeu	sp,et,81134ca8 <OS_EventTaskRemove+0xc>
81134ca4:	003b68fa 	trap	3
81134ca8:	df000315 	stw	fp,12(sp)
81134cac:	df000304 	addi	fp,sp,12
81134cb0:	e13ffe15 	stw	r4,-8(fp)
81134cb4:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
81134cb8:	e0bffe17 	ldw	r2,-8(fp)
81134cbc:	10800d03 	ldbu	r2,52(r2)
81134cc0:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
81134cc4:	e0bffd03 	ldbu	r2,-12(fp)
81134cc8:	e0fffd03 	ldbu	r3,-12(fp)
81134ccc:	e13fff17 	ldw	r4,-4(fp)
81134cd0:	20c7883a 	add	r3,r4,r3
81134cd4:	18c002c4 	addi	r3,r3,11
81134cd8:	18c00003 	ldbu	r3,0(r3)
81134cdc:	1809883a 	mov	r4,r3
81134ce0:	e0fffe17 	ldw	r3,-8(fp)
81134ce4:	18c00d43 	ldbu	r3,53(r3)
81134ce8:	00c6303a 	nor	r3,zero,r3
81134cec:	20c6703a 	and	r3,r4,r3
81134cf0:	1809883a 	mov	r4,r3
81134cf4:	e0ffff17 	ldw	r3,-4(fp)
81134cf8:	1885883a 	add	r2,r3,r2
81134cfc:	108002c4 	addi	r2,r2,11
81134d00:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81134d04:	e0bffd03 	ldbu	r2,-12(fp)
81134d08:	e0ffff17 	ldw	r3,-4(fp)
81134d0c:	1885883a 	add	r2,r3,r2
81134d10:	108002c4 	addi	r2,r2,11
81134d14:	10800003 	ldbu	r2,0(r2)
81134d18:	10803fcc 	andi	r2,r2,255
81134d1c:	10000a1e 	bne	r2,zero,81134d48 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
81134d20:	e0bfff17 	ldw	r2,-4(fp)
81134d24:	10800283 	ldbu	r2,10(r2)
81134d28:	1007883a 	mov	r3,r2
81134d2c:	e0bffe17 	ldw	r2,-8(fp)
81134d30:	10800d83 	ldbu	r2,54(r2)
81134d34:	0084303a 	nor	r2,zero,r2
81134d38:	1884703a 	and	r2,r3,r2
81134d3c:	1007883a 	mov	r3,r2
81134d40:	e0bfff17 	ldw	r2,-4(fp)
81134d44:	10c00285 	stb	r3,10(r2)
    }
}
81134d48:	0001883a 	nop
81134d4c:	e037883a 	mov	sp,fp
81134d50:	df000017 	ldw	fp,0(sp)
81134d54:	dec00104 	addi	sp,sp,4
81134d58:	f800283a 	ret

81134d5c <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
81134d5c:	defffa04 	addi	sp,sp,-24
81134d60:	de00012e 	bgeu	sp,et,81134d68 <OS_EventTaskRemoveMulti+0xc>
81134d64:	003b68fa 	trap	3
81134d68:	df000515 	stw	fp,20(sp)
81134d6c:	df000504 	addi	fp,sp,20
81134d70:	e13ffe15 	stw	r4,-8(fp)
81134d74:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
81134d78:	e0bffe17 	ldw	r2,-8(fp)
81134d7c:	10800d03 	ldbu	r2,52(r2)
81134d80:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
81134d84:	e0bffe17 	ldw	r2,-8(fp)
81134d88:	10800d83 	ldbu	r2,54(r2)
81134d8c:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
81134d90:	e0bffe17 	ldw	r2,-8(fp)
81134d94:	10800d43 	ldbu	r2,53(r2)
81134d98:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
81134d9c:	e0bfff17 	ldw	r2,-4(fp)
81134da0:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
81134da4:	e0bffb17 	ldw	r2,-20(fp)
81134da8:	10800017 	ldw	r2,0(r2)
81134dac:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81134db0:	00002506 	br	81134e48 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
81134db4:	e0bffd03 	ldbu	r2,-12(fp)
81134db8:	e0fffd03 	ldbu	r3,-12(fp)
81134dbc:	e13ffc17 	ldw	r4,-16(fp)
81134dc0:	20c7883a 	add	r3,r4,r3
81134dc4:	18c002c4 	addi	r3,r3,11
81134dc8:	18c00003 	ldbu	r3,0(r3)
81134dcc:	1809883a 	mov	r4,r3
81134dd0:	e0fffd83 	ldbu	r3,-10(fp)
81134dd4:	00c6303a 	nor	r3,zero,r3
81134dd8:	20c6703a 	and	r3,r4,r3
81134ddc:	1809883a 	mov	r4,r3
81134de0:	e0fffc17 	ldw	r3,-16(fp)
81134de4:	1885883a 	add	r2,r3,r2
81134de8:	108002c4 	addi	r2,r2,11
81134dec:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
81134df0:	e0bffd03 	ldbu	r2,-12(fp)
81134df4:	e0fffc17 	ldw	r3,-16(fp)
81134df8:	1885883a 	add	r2,r3,r2
81134dfc:	108002c4 	addi	r2,r2,11
81134e00:	10800003 	ldbu	r2,0(r2)
81134e04:	10803fcc 	andi	r2,r2,255
81134e08:	1000091e 	bne	r2,zero,81134e30 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
81134e0c:	e0bffc17 	ldw	r2,-16(fp)
81134e10:	10800283 	ldbu	r2,10(r2)
81134e14:	1007883a 	mov	r3,r2
81134e18:	e0bffd43 	ldbu	r2,-11(fp)
81134e1c:	0084303a 	nor	r2,zero,r2
81134e20:	1884703a 	and	r2,r3,r2
81134e24:	1007883a 	mov	r3,r2
81134e28:	e0bffc17 	ldw	r2,-16(fp)
81134e2c:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
81134e30:	e0bffb17 	ldw	r2,-20(fp)
81134e34:	10800104 	addi	r2,r2,4
81134e38:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
81134e3c:	e0bffb17 	ldw	r2,-20(fp)
81134e40:	10800017 	ldw	r2,0(r2)
81134e44:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81134e48:	e0bffc17 	ldw	r2,-16(fp)
81134e4c:	103fd91e 	bne	r2,zero,81134db4 <__reset+0xfb114db4>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
81134e50:	0001883a 	nop
81134e54:	e037883a 	mov	sp,fp
81134e58:	df000017 	ldw	fp,0(sp)
81134e5c:	dec00104 	addi	sp,sp,4
81134e60:	f800283a 	ret

81134e64 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
81134e64:	defffc04 	addi	sp,sp,-16
81134e68:	de00012e 	bgeu	sp,et,81134e70 <OS_EventWaitListInit+0xc>
81134e6c:	003b68fa 	trap	3
81134e70:	df000315 	stw	fp,12(sp)
81134e74:	df000304 	addi	fp,sp,12
81134e78:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
81134e7c:	e0bfff17 	ldw	r2,-4(fp)
81134e80:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
81134e84:	e0bfff17 	ldw	r2,-4(fp)
81134e88:	108002c4 	addi	r2,r2,11
81134e8c:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81134e90:	e03ffe05 	stb	zero,-8(fp)
81134e94:	00000706 	br	81134eb4 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
81134e98:	e0bffd17 	ldw	r2,-12(fp)
81134e9c:	10c00044 	addi	r3,r2,1
81134ea0:	e0fffd15 	stw	r3,-12(fp)
81134ea4:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81134ea8:	e0bffe03 	ldbu	r2,-8(fp)
81134eac:	10800044 	addi	r2,r2,1
81134eb0:	e0bffe05 	stb	r2,-8(fp)
81134eb4:	e0bffe03 	ldbu	r2,-8(fp)
81134eb8:	108001b0 	cmpltui	r2,r2,6
81134ebc:	103ff61e 	bne	r2,zero,81134e98 <__reset+0xfb114e98>
        *ptbl++ = 0;
    }
}
81134ec0:	0001883a 	nop
81134ec4:	e037883a 	mov	sp,fp
81134ec8:	df000017 	ldw	fp,0(sp)
81134ecc:	dec00104 	addi	sp,sp,4
81134ed0:	f800283a 	ret

81134ed4 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
81134ed4:	defffb04 	addi	sp,sp,-20
81134ed8:	de00012e 	bgeu	sp,et,81134ee0 <OS_InitEventList+0xc>
81134edc:	003b68fa 	trap	3
81134ee0:	dfc00415 	stw	ra,16(sp)
81134ee4:	df000315 	stw	fp,12(sp)
81134ee8:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
81134eec:	01434004 	movi	r5,3328
81134ef0:	012045b4 	movhi	r4,33046
81134ef4:	21165f04 	addi	r4,r4,22908
81134ef8:	113527c0 	call	8113527c <OS_MemClr>
    pevent1 = &OSEventTbl[0];
81134efc:	00a045b4 	movhi	r2,33046
81134f00:	10965f04 	addi	r2,r2,22908
81134f04:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
81134f08:	00a045b4 	movhi	r2,33046
81134f0c:	10966c04 	addi	r2,r2,22960
81134f10:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81134f14:	e03ffd0d 	sth	zero,-12(fp)
81134f18:	00001306 	br	81134f68 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
81134f1c:	e0bffe17 	ldw	r2,-8(fp)
81134f20:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
81134f24:	e0bffe17 	ldw	r2,-8(fp)
81134f28:	e0ffff17 	ldw	r3,-4(fp)
81134f2c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
81134f30:	e0bffe17 	ldw	r2,-8(fp)
81134f34:	00c00fc4 	movi	r3,63
81134f38:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
81134f3c:	e0bffe17 	ldw	r2,-8(fp)
81134f40:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
81134f44:	e0bffe17 	ldw	r2,-8(fp)
81134f48:	10800d04 	addi	r2,r2,52
81134f4c:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
81134f50:	e0bfff17 	ldw	r2,-4(fp)
81134f54:	10800d04 	addi	r2,r2,52
81134f58:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81134f5c:	e0bffd0b 	ldhu	r2,-12(fp)
81134f60:	10800044 	addi	r2,r2,1
81134f64:	e0bffd0d 	sth	r2,-12(fp)
81134f68:	e0bffd0b 	ldhu	r2,-12(fp)
81134f6c:	10800ff0 	cmpltui	r2,r2,63
81134f70:	103fea1e 	bne	r2,zero,81134f1c <__reset+0xfb114f1c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
81134f74:	e0bffe17 	ldw	r2,-8(fp)
81134f78:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
81134f7c:	e0bffe17 	ldw	r2,-8(fp)
81134f80:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
81134f84:	e0bffe17 	ldw	r2,-8(fp)
81134f88:	00c00fc4 	movi	r3,63
81134f8c:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
81134f90:	e0bffe17 	ldw	r2,-8(fp)
81134f94:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
81134f98:	00a045b4 	movhi	r2,33046
81134f9c:	10965f04 	addi	r2,r2,22908
81134fa0:	d0a09b15 	stw	r2,-32148(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
81134fa4:	0001883a 	nop
81134fa8:	e037883a 	mov	sp,fp
81134fac:	dfc00117 	ldw	ra,4(sp)
81134fb0:	df000017 	ldw	fp,0(sp)
81134fb4:	dec00204 	addi	sp,sp,8
81134fb8:	f800283a 	ret

81134fbc <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
81134fbc:	deffff04 	addi	sp,sp,-4
81134fc0:	de00012e 	bgeu	sp,et,81134fc8 <OS_InitMisc+0xc>
81134fc4:	003b68fa 	trap	3
81134fc8:	df000015 	stw	fp,0(sp)
81134fcc:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
81134fd0:	d0209f15 	stw	zero,-32132(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
81134fd4:	d0209c05 	stb	zero,-32144(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
81134fd8:	d0208a05 	stb	zero,-32216(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
81134fdc:	d0209545 	stb	zero,-32171(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81134fe0:	d0208c05 	stb	zero,-32208(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81134fe4:	d0209115 	stw	zero,-32188(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
81134fe8:	d0208d15 	stw	zero,-32204(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
81134fec:	d020a315 	stw	zero,-32116(gp)
    OSIdleCtrMax  = 0L;
81134ff0:	d0209315 	stw	zero,-32180(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81134ff4:	d020a205 	stb	zero,-32120(gp)
#endif
}
81134ff8:	0001883a 	nop
81134ffc:	e037883a 	mov	sp,fp
81135000:	df000017 	ldw	fp,0(sp)
81135004:	dec00104 	addi	sp,sp,4
81135008:	f800283a 	ret

8113500c <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113500c:	defffd04 	addi	sp,sp,-12
81135010:	de00012e 	bgeu	sp,et,81135018 <OS_InitRdyList+0xc>
81135014:	003b68fa 	trap	3
81135018:	df000215 	stw	fp,8(sp)
8113501c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
81135020:	d0209905 	stb	zero,-32156(gp)
    prdytbl       = &OSRdyTbl[0];
81135024:	d0a09944 	addi	r2,gp,-32155
81135028:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113502c:	e03ffe05 	stb	zero,-8(fp)
81135030:	00000706 	br	81135050 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
81135034:	e0bfff17 	ldw	r2,-4(fp)
81135038:	10c00044 	addi	r3,r2,1
8113503c:	e0ffff15 	stw	r3,-4(fp)
81135040:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81135044:	e0bffe03 	ldbu	r2,-8(fp)
81135048:	10800044 	addi	r2,r2,1
8113504c:	e0bffe05 	stb	r2,-8(fp)
81135050:	e0bffe03 	ldbu	r2,-8(fp)
81135054:	108001b0 	cmpltui	r2,r2,6
81135058:	103ff61e 	bne	r2,zero,81135034 <__reset+0xfb115034>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8113505c:	d0208ec5 	stb	zero,-32197(gp)
    OSPrioHighRdy = 0;
81135060:	d0208e85 	stb	zero,-32198(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
81135064:	d0209715 	stw	zero,-32164(gp)
    OSTCBCur      = (OS_TCB *)0;
81135068:	d0209d15 	stw	zero,-32140(gp)
}
8113506c:	0001883a 	nop
81135070:	e037883a 	mov	sp,fp
81135074:	df000017 	ldw	fp,0(sp)
81135078:	dec00104 	addi	sp,sp,4
8113507c:	f800283a 	ret

81135080 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
81135080:	defff804 	addi	sp,sp,-32
81135084:	de00012e 	bgeu	sp,et,8113508c <OS_InitTaskIdle+0xc>
81135088:	003b68fa 	trap	3
8113508c:	dfc00715 	stw	ra,28(sp)
81135090:	df000615 	stw	fp,24(sp)
81135094:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
81135098:	008000c4 	movi	r2,3
8113509c:	d8800415 	stw	r2,16(sp)
811350a0:	d8000315 	stw	zero,12(sp)
811350a4:	00810004 	movi	r2,1024
811350a8:	d8800215 	stw	r2,8(sp)
811350ac:	00a045b4 	movhi	r2,33046
811350b0:	10925f04 	addi	r2,r2,18812
811350b4:	d8800115 	stw	r2,4(sp)
811350b8:	00bfffd4 	movui	r2,65535
811350bc:	d8800015 	stw	r2,0(sp)
811350c0:	01c00a84 	movi	r7,42
811350c4:	01a045b4 	movhi	r6,33046
811350c8:	31965e04 	addi	r6,r6,22904
811350cc:	000b883a 	mov	r5,zero
811350d0:	012044f4 	movhi	r4,33043
811350d4:	21155d04 	addi	r4,r4,21876
811350d8:	113af640 	call	8113af64 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
811350dc:	e1bfff04 	addi	r6,fp,-4
811350e0:	01604574 	movhi	r5,33045
811350e4:	296fa104 	addi	r5,r5,-16764
811350e8:	01000a84 	movi	r4,42
811350ec:	113b7940 	call	8113b794 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
811350f0:	0001883a 	nop
811350f4:	e037883a 	mov	sp,fp
811350f8:	dfc00117 	ldw	ra,4(sp)
811350fc:	df000017 	ldw	fp,0(sp)
81135100:	dec00204 	addi	sp,sp,8
81135104:	f800283a 	ret

81135108 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
81135108:	defff804 	addi	sp,sp,-32
8113510c:	de00012e 	bgeu	sp,et,81135114 <OS_InitTaskStat+0xc>
81135110:	003b68fa 	trap	3
81135114:	dfc00715 	stw	ra,28(sp)
81135118:	df000615 	stw	fp,24(sp)
8113511c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81135120:	008000c4 	movi	r2,3
81135124:	d8800415 	stw	r2,16(sp)
81135128:	d8000315 	stw	zero,12(sp)
8113512c:	00810004 	movi	r2,1024
81135130:	d8800215 	stw	r2,8(sp)
81135134:	00a045b4 	movhi	r2,33046
81135138:	108b9f04 	addi	r2,r2,11900
8113513c:	d8800115 	stw	r2,4(sp)
81135140:	00bfff94 	movui	r2,65534
81135144:	d8800015 	stw	r2,0(sp)
81135148:	01c00a44 	movi	r7,41
8113514c:	01a045b4 	movhi	r6,33046
81135150:	318f9e04 	addi	r6,r6,15992
81135154:	000b883a 	mov	r5,zero
81135158:	012044f4 	movhi	r4,33043
8113515c:	21157604 	addi	r4,r4,21976
81135160:	113af640 	call	8113af64 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
81135164:	e1bfff04 	addi	r6,fp,-4
81135168:	01604574 	movhi	r5,33045
8113516c:	296fa504 	addi	r5,r5,-16748
81135170:	01000a44 	movi	r4,41
81135174:	113b7940 	call	8113b794 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
81135178:	0001883a 	nop
8113517c:	e037883a 	mov	sp,fp
81135180:	dfc00117 	ldw	ra,4(sp)
81135184:	df000017 	ldw	fp,0(sp)
81135188:	dec00204 	addi	sp,sp,8
8113518c:	f800283a 	ret

81135190 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81135190:	defffb04 	addi	sp,sp,-20
81135194:	de00012e 	bgeu	sp,et,8113519c <OS_InitTCBList+0xc>
81135198:	003b68fa 	trap	3
8113519c:	dfc00415 	stw	ra,16(sp)
811351a0:	df000315 	stw	fp,12(sp)
811351a4:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
811351a8:	01446e04 	movi	r5,4536
811351ac:	012045b4 	movhi	r4,33046
811351b0:	21199f04 	addi	r4,r4,26236
811351b4:	113527c0 	call	8113527c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
811351b8:	01402b04 	movi	r5,172
811351bc:	012045b4 	movhi	r4,33046
811351c0:	211e0d04 	addi	r4,r4,30772
811351c4:	113527c0 	call	8113527c <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
811351c8:	00a045b4 	movhi	r2,33046
811351cc:	10999f04 	addi	r2,r2,26236
811351d0:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
811351d4:	00a045b4 	movhi	r2,33046
811351d8:	1099ba04 	addi	r2,r2,26344
811351dc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
811351e0:	e03ffd05 	stb	zero,-12(fp)
811351e4:	00001106 	br	8113522c <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
811351e8:	e0bffe17 	ldw	r2,-8(fp)
811351ec:	e0ffff17 	ldw	r3,-4(fp)
811351f0:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
811351f4:	e0bffe17 	ldw	r2,-8(fp)
811351f8:	00c00fc4 	movi	r3,63
811351fc:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81135200:	e0bffe17 	ldw	r2,-8(fp)
81135204:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81135208:	e0bffe17 	ldw	r2,-8(fp)
8113520c:	10801b04 	addi	r2,r2,108
81135210:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81135214:	e0bfff17 	ldw	r2,-4(fp)
81135218:	10801b04 	addi	r2,r2,108
8113521c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81135220:	e0bffd03 	ldbu	r2,-12(fp)
81135224:	10800044 	addi	r2,r2,1
81135228:	e0bffd05 	stb	r2,-12(fp)
8113522c:	e0bffd03 	ldbu	r2,-12(fp)
81135230:	10800a70 	cmpltui	r2,r2,41
81135234:	103fec1e 	bne	r2,zero,811351e8 <__reset+0xfb1151e8>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81135238:	e0bffe17 	ldw	r2,-8(fp)
8113523c:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81135240:	e0bffe17 	ldw	r2,-8(fp)
81135244:	00c00fc4 	movi	r3,63
81135248:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113524c:	e0bffe17 	ldw	r2,-8(fp)
81135250:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
81135254:	d0208f15 	stw	zero,-32196(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81135258:	00a045b4 	movhi	r2,33046
8113525c:	10999f04 	addi	r2,r2,26236
81135260:	d0a09415 	stw	r2,-32176(gp)
}
81135264:	0001883a 	nop
81135268:	e037883a 	mov	sp,fp
8113526c:	dfc00117 	ldw	ra,4(sp)
81135270:	df000017 	ldw	fp,0(sp)
81135274:	dec00204 	addi	sp,sp,8
81135278:	f800283a 	ret

8113527c <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
8113527c:	defffd04 	addi	sp,sp,-12
81135280:	de00012e 	bgeu	sp,et,81135288 <OS_MemClr+0xc>
81135284:	003b68fa 	trap	3
81135288:	df000215 	stw	fp,8(sp)
8113528c:	df000204 	addi	fp,sp,8
81135290:	e13ffe15 	stw	r4,-8(fp)
81135294:	2805883a 	mov	r2,r5
81135298:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113529c:	00000706 	br	811352bc <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
811352a0:	e0bffe17 	ldw	r2,-8(fp)
811352a4:	10c00044 	addi	r3,r2,1
811352a8:	e0fffe15 	stw	r3,-8(fp)
811352ac:	10000005 	stb	zero,0(r2)
        size--;
811352b0:	e0bfff0b 	ldhu	r2,-4(fp)
811352b4:	10bfffc4 	addi	r2,r2,-1
811352b8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
811352bc:	e0bfff0b 	ldhu	r2,-4(fp)
811352c0:	103ff71e 	bne	r2,zero,811352a0 <__reset+0xfb1152a0>
        *pdest++ = (INT8U)0;
        size--;
    }
}
811352c4:	0001883a 	nop
811352c8:	e037883a 	mov	sp,fp
811352cc:	df000017 	ldw	fp,0(sp)
811352d0:	dec00104 	addi	sp,sp,4
811352d4:	f800283a 	ret

811352d8 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
811352d8:	defffc04 	addi	sp,sp,-16
811352dc:	de00012e 	bgeu	sp,et,811352e4 <OS_MemCopy+0xc>
811352e0:	003b68fa 	trap	3
811352e4:	df000315 	stw	fp,12(sp)
811352e8:	df000304 	addi	fp,sp,12
811352ec:	e13ffd15 	stw	r4,-12(fp)
811352f0:	e17ffe15 	stw	r5,-8(fp)
811352f4:	3005883a 	mov	r2,r6
811352f8:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
811352fc:	00000b06 	br	8113532c <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81135300:	e0bffd17 	ldw	r2,-12(fp)
81135304:	10c00044 	addi	r3,r2,1
81135308:	e0fffd15 	stw	r3,-12(fp)
8113530c:	e0fffe17 	ldw	r3,-8(fp)
81135310:	19000044 	addi	r4,r3,1
81135314:	e13ffe15 	stw	r4,-8(fp)
81135318:	18c00003 	ldbu	r3,0(r3)
8113531c:	10c00005 	stb	r3,0(r2)
        size--;
81135320:	e0bfff0b 	ldhu	r2,-4(fp)
81135324:	10bfffc4 	addi	r2,r2,-1
81135328:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
8113532c:	e0bfff0b 	ldhu	r2,-4(fp)
81135330:	103ff31e 	bne	r2,zero,81135300 <__reset+0xfb115300>
        *pdest++ = *psrc++;
        size--;
    }
}
81135334:	0001883a 	nop
81135338:	e037883a 	mov	sp,fp
8113533c:	df000017 	ldw	fp,0(sp)
81135340:	dec00104 	addi	sp,sp,4
81135344:	f800283a 	ret

81135348 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81135348:	defffb04 	addi	sp,sp,-20
8113534c:	de00012e 	bgeu	sp,et,81135354 <OS_Sched+0xc>
81135350:	003b68fa 	trap	3
81135354:	dfc00415 	stw	ra,16(sp)
81135358:	df000315 	stw	fp,12(sp)
8113535c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81135360:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135364:	0005303a 	rdctl	r2,status
81135368:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113536c:	e0ffff17 	ldw	r3,-4(fp)
81135370:	00bfff84 	movi	r2,-2
81135374:	1884703a 	and	r2,r3,r2
81135378:	1001703a 	wrctl	status,r2
  
  return context;
8113537c:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81135380:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81135384:	d0a09c03 	ldbu	r2,-32144(gp)
81135388:	10803fcc 	andi	r2,r2,255
8113538c:	10001a1e 	bne	r2,zero,811353f8 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81135390:	d0a08a03 	ldbu	r2,-32216(gp)
81135394:	10803fcc 	andi	r2,r2,255
81135398:	1000171e 	bne	r2,zero,811353f8 <OS_Sched+0xb0>
            OS_SchedNew();
8113539c:	11354200 	call	81135420 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
811353a0:	d0e08e83 	ldbu	r3,-32198(gp)
811353a4:	d0a08ec3 	ldbu	r2,-32197(gp)
811353a8:	18c03fcc 	andi	r3,r3,255
811353ac:	10803fcc 	andi	r2,r2,255
811353b0:	18801126 	beq	r3,r2,811353f8 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
811353b4:	d0a08e83 	ldbu	r2,-32198(gp)
811353b8:	10c03fcc 	andi	r3,r2,255
811353bc:	00a045b4 	movhi	r2,33046
811353c0:	109e0d04 	addi	r2,r2,30772
811353c4:	18c7883a 	add	r3,r3,r3
811353c8:	18c7883a 	add	r3,r3,r3
811353cc:	10c5883a 	add	r2,r2,r3
811353d0:	10800017 	ldw	r2,0(r2)
811353d4:	d0a09715 	stw	r2,-32164(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
811353d8:	d0a09717 	ldw	r2,-32164(gp)
811353dc:	10c00e17 	ldw	r3,56(r2)
811353e0:	18c00044 	addi	r3,r3,1
811353e4:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
811353e8:	d0a09117 	ldw	r2,-32188(gp)
811353ec:	10800044 	addi	r2,r2,1
811353f0:	d0a09115 	stw	r2,-32188(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
811353f4:	11463780 	call	81146378 <OSCtxSw>
811353f8:	e0bffd17 	ldw	r2,-12(fp)
811353fc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135400:	e0bffe17 	ldw	r2,-8(fp)
81135404:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81135408:	0001883a 	nop
8113540c:	e037883a 	mov	sp,fp
81135410:	dfc00117 	ldw	ra,4(sp)
81135414:	df000017 	ldw	fp,0(sp)
81135418:	dec00204 	addi	sp,sp,8
8113541c:	f800283a 	ret

81135420 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81135420:	defffe04 	addi	sp,sp,-8
81135424:	de00012e 	bgeu	sp,et,8113542c <OS_SchedNew+0xc>
81135428:	003b68fa 	trap	3
8113542c:	df000115 	stw	fp,4(sp)
81135430:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
81135434:	d0a09903 	ldbu	r2,-32156(gp)
81135438:	10c03fcc 	andi	r3,r2,255
8113543c:	00a04574 	movhi	r2,33045
81135440:	10af6104 	addi	r2,r2,-17020
81135444:	10c5883a 	add	r2,r2,r3
81135448:	10800003 	ldbu	r2,0(r2)
8113544c:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81135450:	e0bfff03 	ldbu	r2,-4(fp)
81135454:	100490fa 	slli	r2,r2,3
81135458:	1009883a 	mov	r4,r2
8113545c:	e0ffff03 	ldbu	r3,-4(fp)
81135460:	d0a09944 	addi	r2,gp,-32155
81135464:	1885883a 	add	r2,r3,r2
81135468:	10800003 	ldbu	r2,0(r2)
8113546c:	10c03fcc 	andi	r3,r2,255
81135470:	00a04574 	movhi	r2,33045
81135474:	10af6104 	addi	r2,r2,-17020
81135478:	10c5883a 	add	r2,r2,r3
8113547c:	10800003 	ldbu	r2,0(r2)
81135480:	2085883a 	add	r2,r4,r2
81135484:	d0a08e85 	stb	r2,-32198(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81135488:	0001883a 	nop
8113548c:	e037883a 	mov	sp,fp
81135490:	df000017 	ldw	fp,0(sp)
81135494:	dec00104 	addi	sp,sp,4
81135498:	f800283a 	ret

8113549c <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8113549c:	defffc04 	addi	sp,sp,-16
811354a0:	de00012e 	bgeu	sp,et,811354a8 <OS_StrCopy+0xc>
811354a4:	003b68fa 	trap	3
811354a8:	df000315 	stw	fp,12(sp)
811354ac:	df000304 	addi	fp,sp,12
811354b0:	e13ffe15 	stw	r4,-8(fp)
811354b4:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
811354b8:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
811354bc:	00000b06 	br	811354ec <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
811354c0:	e0bffe17 	ldw	r2,-8(fp)
811354c4:	10c00044 	addi	r3,r2,1
811354c8:	e0fffe15 	stw	r3,-8(fp)
811354cc:	e0ffff17 	ldw	r3,-4(fp)
811354d0:	19000044 	addi	r4,r3,1
811354d4:	e13fff15 	stw	r4,-4(fp)
811354d8:	18c00003 	ldbu	r3,0(r3)
811354dc:	10c00005 	stb	r3,0(r2)
        len++;
811354e0:	e0bffd03 	ldbu	r2,-12(fp)
811354e4:	10800044 	addi	r2,r2,1
811354e8:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
811354ec:	e0bfff17 	ldw	r2,-4(fp)
811354f0:	10800003 	ldbu	r2,0(r2)
811354f4:	10803fcc 	andi	r2,r2,255
811354f8:	103ff11e 	bne	r2,zero,811354c0 <__reset+0xfb1154c0>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
811354fc:	e0bffe17 	ldw	r2,-8(fp)
81135500:	10000005 	stb	zero,0(r2)
    return (len);
81135504:	e0bffd03 	ldbu	r2,-12(fp)
}
81135508:	e037883a 	mov	sp,fp
8113550c:	df000017 	ldw	fp,0(sp)
81135510:	dec00104 	addi	sp,sp,4
81135514:	f800283a 	ret

81135518 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81135518:	defffd04 	addi	sp,sp,-12
8113551c:	de00012e 	bgeu	sp,et,81135524 <OS_StrLen+0xc>
81135520:	003b68fa 	trap	3
81135524:	df000215 	stw	fp,8(sp)
81135528:	df000204 	addi	fp,sp,8
8113552c:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81135530:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81135534:	00000606 	br	81135550 <OS_StrLen+0x38>
        psrc++;
81135538:	e0bfff17 	ldw	r2,-4(fp)
8113553c:	10800044 	addi	r2,r2,1
81135540:	e0bfff15 	stw	r2,-4(fp)
        len++;
81135544:	e0bffe03 	ldbu	r2,-8(fp)
81135548:	10800044 	addi	r2,r2,1
8113554c:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81135550:	e0bfff17 	ldw	r2,-4(fp)
81135554:	10800003 	ldbu	r2,0(r2)
81135558:	10803fcc 	andi	r2,r2,255
8113555c:	103ff61e 	bne	r2,zero,81135538 <__reset+0xfb115538>
        psrc++;
        len++;
    }
    return (len);
81135560:	e0bffe03 	ldbu	r2,-8(fp)
}
81135564:	e037883a 	mov	sp,fp
81135568:	df000017 	ldw	fp,0(sp)
8113556c:	dec00104 	addi	sp,sp,4
81135570:	f800283a 	ret

81135574 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81135574:	defffa04 	addi	sp,sp,-24
81135578:	de00012e 	bgeu	sp,et,81135580 <OS_TaskIdle+0xc>
8113557c:	003b68fa 	trap	3
81135580:	dfc00515 	stw	ra,20(sp)
81135584:	df000415 	stw	fp,16(sp)
81135588:	df000404 	addi	fp,sp,16
8113558c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135590:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135594:	0005303a 	rdctl	r2,status
81135598:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113559c:	e0fffd17 	ldw	r3,-12(fp)
811355a0:	00bfff84 	movi	r2,-2
811355a4:	1884703a 	and	r2,r3,r2
811355a8:	1001703a 	wrctl	status,r2
  
  return context;
811355ac:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
811355b0:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
811355b4:	d0a08d17 	ldw	r2,-32204(gp)
811355b8:	10800044 	addi	r2,r2,1
811355bc:	d0a08d15 	stw	r2,-32204(gp)
811355c0:	e0bffc17 	ldw	r2,-16(fp)
811355c4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811355c8:	e0bffe17 	ldw	r2,-8(fp)
811355cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
811355d0:	114670c0 	call	8114670c <OSTaskIdleHook>
    }
811355d4:	003fef06 	br	81135594 <__reset+0xfb115594>

811355d8 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
811355d8:	defff804 	addi	sp,sp,-32
811355dc:	de00012e 	bgeu	sp,et,811355e4 <OS_TaskStat+0xc>
811355e0:	003b68fa 	trap	3
811355e4:	dfc00715 	stw	ra,28(sp)
811355e8:	df000615 	stw	fp,24(sp)
811355ec:	dc400515 	stw	r17,20(sp)
811355f0:	dc000415 	stw	r16,16(sp)
811355f4:	df000604 	addi	fp,sp,24
811355f8:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811355fc:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81135600:	00000206 	br	8113560c <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81135604:	01003204 	movi	r4,200
81135608:	113c0840 	call	8113c084 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113560c:	d0a0a203 	ldbu	r2,-32120(gp)
81135610:	10803fcc 	andi	r2,r2,255
81135614:	103ffb26 	beq	r2,zero,81135604 <__reset+0xfb115604>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81135618:	d0e09317 	ldw	r3,-32180(gp)
8113561c:	00947b34 	movhi	r2,20972
81135620:	10a147c4 	addi	r2,r2,-31457
81135624:	1888383a 	mulxuu	r4,r3,r2
81135628:	1885383a 	mul	r2,r3,r2
8113562c:	1021883a 	mov	r16,r2
81135630:	2023883a 	mov	r17,r4
81135634:	8804d17a 	srli	r2,r17,5
81135638:	d0a09315 	stw	r2,-32180(gp)
    if (OSIdleCtrMax == 0L) {
8113563c:	d0a09317 	ldw	r2,-32180(gp)
81135640:	1000031e 	bne	r2,zero,81135650 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81135644:	d0209505 	stb	zero,-32172(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81135648:	01003fc4 	movi	r4,255
8113564c:	113bcf40 	call	8113bcf4 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135650:	0005303a 	rdctl	r2,status
81135654:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135658:	e0fffb17 	ldw	r3,-20(fp)
8113565c:	00bfff84 	movi	r2,-2
81135660:	1884703a 	and	r2,r3,r2
81135664:	1001703a 	wrctl	status,r2
  
  return context;
81135668:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
8113566c:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81135670:	d0a08d17 	ldw	r2,-32204(gp)
81135674:	d0a0a315 	stw	r2,-32116(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81135678:	d0208d15 	stw	zero,-32204(gp)
8113567c:	e0bffa17 	ldw	r2,-24(fp)
81135680:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135684:	e0bffc17 	ldw	r2,-16(fp)
81135688:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8113568c:	d0e0a317 	ldw	r3,-32116(gp)
81135690:	d0a09317 	ldw	r2,-32180(gp)
81135694:	1885203a 	divu	r2,r3,r2
81135698:	1007883a 	mov	r3,r2
8113569c:	00801904 	movi	r2,100
811356a0:	10c5c83a 	sub	r2,r2,r3
811356a4:	d0a09505 	stb	r2,-32172(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
811356a8:	114663c0 	call	8114663c <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
811356ac:	11356bc0 	call	811356bc <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
811356b0:	01001904 	movi	r4,100
811356b4:	113c0840 	call	8113c084 <OSTimeDly>
    }
811356b8:	003fe506 	br	81135650 <__reset+0xfb115650>

811356bc <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
811356bc:	defffa04 	addi	sp,sp,-24
811356c0:	de00012e 	bgeu	sp,et,811356c8 <OS_TaskStatStkChk+0xc>
811356c4:	003b68fa 	trap	3
811356c8:	dfc00515 	stw	ra,20(sp)
811356cc:	df000415 	stw	fp,16(sp)
811356d0:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
811356d4:	e03ffc05 	stb	zero,-16(fp)
811356d8:	00002406 	br	8113576c <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
811356dc:	e0bffc03 	ldbu	r2,-16(fp)
811356e0:	e0fffe04 	addi	r3,fp,-8
811356e4:	180b883a 	mov	r5,r3
811356e8:	1009883a 	mov	r4,r2
811356ec:	113bb2c0 	call	8113bb2c <OSTaskStkChk>
811356f0:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
811356f4:	e0bffc43 	ldbu	r2,-15(fp)
811356f8:	1000191e 	bne	r2,zero,81135760 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
811356fc:	e0fffc03 	ldbu	r3,-16(fp)
81135700:	00a045b4 	movhi	r2,33046
81135704:	109e0d04 	addi	r2,r2,30772
81135708:	18c7883a 	add	r3,r3,r3
8113570c:	18c7883a 	add	r3,r3,r3
81135710:	10c5883a 	add	r2,r2,r3
81135714:	10800017 	ldw	r2,0(r2)
81135718:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113571c:	e0bffd17 	ldw	r2,-12(fp)
81135720:	10000f26 	beq	r2,zero,81135760 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81135724:	e0bffd17 	ldw	r2,-12(fp)
81135728:	10800060 	cmpeqi	r2,r2,1
8113572c:	10000c1e 	bne	r2,zero,81135760 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
81135730:	e0bffd17 	ldw	r2,-12(fp)
81135734:	10c00217 	ldw	r3,8(r2)
81135738:	e0bffd17 	ldw	r2,-12(fp)
8113573c:	10800317 	ldw	r2,12(r2)
81135740:	1085883a 	add	r2,r2,r2
81135744:	1085883a 	add	r2,r2,r2
81135748:	1887883a 	add	r3,r3,r2
8113574c:	e0bffd17 	ldw	r2,-12(fp)
81135750:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81135754:	e0ffff17 	ldw	r3,-4(fp)
81135758:	e0bffd17 	ldw	r2,-12(fp)
8113575c:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81135760:	e0bffc03 	ldbu	r2,-16(fp)
81135764:	10800044 	addi	r2,r2,1
81135768:	e0bffc05 	stb	r2,-16(fp)
8113576c:	e0bffc03 	ldbu	r2,-16(fp)
81135770:	10800af0 	cmpltui	r2,r2,43
81135774:	103fd91e 	bne	r2,zero,811356dc <__reset+0xfb1156dc>
#endif
                }
            }
        }
    }
}
81135778:	0001883a 	nop
8113577c:	e037883a 	mov	sp,fp
81135780:	dfc00117 	ldw	ra,4(sp)
81135784:	df000017 	ldw	fp,0(sp)
81135788:	dec00204 	addi	sp,sp,8
8113578c:	f800283a 	ret

81135790 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81135790:	defff204 	addi	sp,sp,-56
81135794:	de00012e 	bgeu	sp,et,8113579c <OS_TCBInit+0xc>
81135798:	003b68fa 	trap	3
8113579c:	dfc00d15 	stw	ra,52(sp)
811357a0:	df000c15 	stw	fp,48(sp)
811357a4:	df000c04 	addi	fp,sp,48
811357a8:	e17ffc15 	stw	r5,-16(fp)
811357ac:	e1bffd15 	stw	r6,-12(fp)
811357b0:	3807883a 	mov	r3,r7
811357b4:	e0800417 	ldw	r2,16(fp)
811357b8:	e13ffb05 	stb	r4,-20(fp)
811357bc:	e0fffe0d 	sth	r3,-8(fp)
811357c0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811357c4:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811357c8:	0005303a 	rdctl	r2,status
811357cc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811357d0:	e0fffa17 	ldw	r3,-24(fp)
811357d4:	00bfff84 	movi	r2,-2
811357d8:	1884703a 	and	r2,r3,r2
811357dc:	1001703a 	wrctl	status,r2
  
  return context;
811357e0:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
811357e4:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
811357e8:	d0a09417 	ldw	r2,-32176(gp)
811357ec:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
811357f0:	e0bff617 	ldw	r2,-40(fp)
811357f4:	10009326 	beq	r2,zero,81135a44 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
811357f8:	e0bff617 	ldw	r2,-40(fp)
811357fc:	10800517 	ldw	r2,20(r2)
81135800:	d0a09415 	stw	r2,-32176(gp)
81135804:	e0bff417 	ldw	r2,-48(fp)
81135808:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113580c:	e0bff817 	ldw	r2,-32(fp)
81135810:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81135814:	e0bff617 	ldw	r2,-40(fp)
81135818:	e0fffc17 	ldw	r3,-16(fp)
8113581c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81135820:	e0bff617 	ldw	r2,-40(fp)
81135824:	e0fffb03 	ldbu	r3,-20(fp)
81135828:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8113582c:	e0bff617 	ldw	r2,-40(fp)
81135830:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81135834:	e0bff617 	ldw	r2,-40(fp)
81135838:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8113583c:	e0bff617 	ldw	r2,-40(fp)
81135840:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81135844:	e0bff617 	ldw	r2,-40(fp)
81135848:	e0c00317 	ldw	r3,12(fp)
8113584c:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81135850:	e0bff617 	ldw	r2,-40(fp)
81135854:	e0c00217 	ldw	r3,8(fp)
81135858:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8113585c:	e0bff617 	ldw	r2,-40(fp)
81135860:	e0fffd17 	ldw	r3,-12(fp)
81135864:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81135868:	e0bff617 	ldw	r2,-40(fp)
8113586c:	e0ffff0b 	ldhu	r3,-4(fp)
81135870:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81135874:	e0bff617 	ldw	r2,-40(fp)
81135878:	e0fffe0b 	ldhu	r3,-8(fp)
8113587c:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
81135880:	e0bff617 	ldw	r2,-40(fp)
81135884:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81135888:	e0bffb03 	ldbu	r2,-20(fp)
8113588c:	1004d0fa 	srli	r2,r2,3
81135890:	1007883a 	mov	r3,r2
81135894:	e0bff617 	ldw	r2,-40(fp)
81135898:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8113589c:	e0bffb03 	ldbu	r2,-20(fp)
811358a0:	108001cc 	andi	r2,r2,7
811358a4:	1007883a 	mov	r3,r2
811358a8:	e0bff617 	ldw	r2,-40(fp)
811358ac:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
811358b0:	e0bff617 	ldw	r2,-40(fp)
811358b4:	10800d03 	ldbu	r2,52(r2)
811358b8:	10803fcc 	andi	r2,r2,255
811358bc:	00c00044 	movi	r3,1
811358c0:	1884983a 	sll	r2,r3,r2
811358c4:	1007883a 	mov	r3,r2
811358c8:	e0bff617 	ldw	r2,-40(fp)
811358cc:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
811358d0:	e0bff617 	ldw	r2,-40(fp)
811358d4:	10800cc3 	ldbu	r2,51(r2)
811358d8:	10803fcc 	andi	r2,r2,255
811358dc:	00c00044 	movi	r3,1
811358e0:	1884983a 	sll	r2,r3,r2
811358e4:	1007883a 	mov	r3,r2
811358e8:	e0bff617 	ldw	r2,-40(fp)
811358ec:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
811358f0:	e0bff617 	ldw	r2,-40(fp)
811358f4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
811358f8:	e0bff617 	ldw	r2,-40(fp)
811358fc:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81135900:	e0bff617 	ldw	r2,-40(fp)
81135904:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81135908:	e0bff617 	ldw	r2,-40(fp)
8113590c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81135910:	e0bff617 	ldw	r2,-40(fp)
81135914:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81135918:	e0bff617 	ldw	r2,-40(fp)
8113591c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81135920:	e0bff617 	ldw	r2,-40(fp)
81135924:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81135928:	e0bff617 	ldw	r2,-40(fp)
8113592c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81135930:	e0bff617 	ldw	r2,-40(fp)
81135934:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81135938:	e0bff617 	ldw	r2,-40(fp)
8113593c:	00c00fc4 	movi	r3,63
81135940:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81135944:	e0bff617 	ldw	r2,-40(fp)
81135948:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8113594c:	e13ff617 	ldw	r4,-40(fp)
81135950:	11467340 	call	81146734 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81135954:	e13ff617 	ldw	r4,-40(fp)
81135958:	11465bc0 	call	811465bc <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113595c:	0005303a 	rdctl	r2,status
81135960:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135964:	e0fff517 	ldw	r3,-44(fp)
81135968:	00bfff84 	movi	r2,-2
8113596c:	1884703a 	and	r2,r3,r2
81135970:	1001703a 	wrctl	status,r2
  
  return context;
81135974:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81135978:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113597c:	e0fffb03 	ldbu	r3,-20(fp)
81135980:	00a045b4 	movhi	r2,33046
81135984:	109e0d04 	addi	r2,r2,30772
81135988:	18c7883a 	add	r3,r3,r3
8113598c:	18c7883a 	add	r3,r3,r3
81135990:	10c5883a 	add	r2,r2,r3
81135994:	e0fff617 	ldw	r3,-40(fp)
81135998:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113599c:	d0e08f17 	ldw	r3,-32196(gp)
811359a0:	e0bff617 	ldw	r2,-40(fp)
811359a4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
811359a8:	e0bff617 	ldw	r2,-40(fp)
811359ac:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
811359b0:	d0a08f17 	ldw	r2,-32196(gp)
811359b4:	10000326 	beq	r2,zero,811359c4 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
811359b8:	d0a08f17 	ldw	r2,-32196(gp)
811359bc:	e0fff617 	ldw	r3,-40(fp)
811359c0:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
811359c4:	e0bff617 	ldw	r2,-40(fp)
811359c8:	d0a08f15 	stw	r2,-32196(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
811359cc:	e0bff617 	ldw	r2,-40(fp)
811359d0:	10c00d83 	ldbu	r3,54(r2)
811359d4:	d0a09903 	ldbu	r2,-32156(gp)
811359d8:	1884b03a 	or	r2,r3,r2
811359dc:	d0a09905 	stb	r2,-32156(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811359e0:	e0bff617 	ldw	r2,-40(fp)
811359e4:	10800d03 	ldbu	r2,52(r2)
811359e8:	10c03fcc 	andi	r3,r2,255
811359ec:	e0bff617 	ldw	r2,-40(fp)
811359f0:	10800d03 	ldbu	r2,52(r2)
811359f4:	11003fcc 	andi	r4,r2,255
811359f8:	d0a09944 	addi	r2,gp,-32155
811359fc:	2085883a 	add	r2,r4,r2
81135a00:	11000003 	ldbu	r4,0(r2)
81135a04:	e0bff617 	ldw	r2,-40(fp)
81135a08:	10800d43 	ldbu	r2,53(r2)
81135a0c:	2084b03a 	or	r2,r4,r2
81135a10:	1009883a 	mov	r4,r2
81135a14:	d0a09944 	addi	r2,gp,-32155
81135a18:	1885883a 	add	r2,r3,r2
81135a1c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
81135a20:	d0a09543 	ldbu	r2,-32171(gp)
81135a24:	10800044 	addi	r2,r2,1
81135a28:	d0a09545 	stb	r2,-32171(gp)
81135a2c:	e0bff417 	ldw	r2,-48(fp)
81135a30:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135a34:	e0bff717 	ldw	r2,-36(fp)
81135a38:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81135a3c:	0005883a 	mov	r2,zero
81135a40:	00000506 	br	81135a58 <OS_TCBInit+0x2c8>
81135a44:	e0bff417 	ldw	r2,-48(fp)
81135a48:	e0bff915 	stw	r2,-28(fp)
81135a4c:	e0bff917 	ldw	r2,-28(fp)
81135a50:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81135a54:	00801084 	movi	r2,66
}
81135a58:	e037883a 	mov	sp,fp
81135a5c:	dfc00117 	ldw	ra,4(sp)
81135a60:	df000017 	ldw	fp,0(sp)
81135a64:	dec00204 	addi	sp,sp,8
81135a68:	f800283a 	ret

81135a6c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
81135a6c:	defffe04 	addi	sp,sp,-8
81135a70:	de00012e 	bgeu	sp,et,81135a78 <OSDebugInit+0xc>
81135a74:	003b68fa 	trap	3
81135a78:	df000115 	stw	fp,4(sp)
81135a7c:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
81135a80:	d0a01804 	addi	r2,gp,-32672
81135a84:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81135a88:	d0a01904 	addi	r2,gp,-32668
81135a8c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
81135a90:	d0a01a84 	addi	r2,gp,-32662
81135a94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81135a98:	d0a01b04 	addi	r2,gp,-32660
81135a9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
81135aa0:	d0a01a04 	addi	r2,gp,-32664
81135aa4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
81135aa8:	d0a01b84 	addi	r2,gp,-32658
81135aac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
81135ab0:	d0a01c04 	addi	r2,gp,-32656
81135ab4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
81135ab8:	d0a01c84 	addi	r2,gp,-32654
81135abc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
81135ac0:	d0a01d04 	addi	r2,gp,-32652
81135ac4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
81135ac8:	d0a01d84 	addi	r2,gp,-32650
81135acc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
81135ad0:	d0a01e04 	addi	r2,gp,-32648
81135ad4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
81135ad8:	d0a01e84 	addi	r2,gp,-32646
81135adc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
81135ae0:	d0a01f04 	addi	r2,gp,-32644
81135ae4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
81135ae8:	d0a01f84 	addi	r2,gp,-32642
81135aec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
81135af0:	d0a02004 	addi	r2,gp,-32640
81135af4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
81135af8:	d0a02084 	addi	r2,gp,-32638
81135afc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81135b00:	d0a02104 	addi	r2,gp,-32636
81135b04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81135b08:	d0a02184 	addi	r2,gp,-32634
81135b0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81135b10:	d0a02204 	addi	r2,gp,-32632
81135b14:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81135b18:	d0a02284 	addi	r2,gp,-32630
81135b1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
81135b20:	d0a02304 	addi	r2,gp,-32628
81135b24:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81135b28:	d0a02384 	addi	r2,gp,-32626
81135b2c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
81135b30:	d0a02404 	addi	r2,gp,-32624
81135b34:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81135b38:	d0a02484 	addi	r2,gp,-32622
81135b3c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
81135b40:	d0a02504 	addi	r2,gp,-32620
81135b44:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81135b48:	d0a02584 	addi	r2,gp,-32618
81135b4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
81135b50:	d0a02604 	addi	r2,gp,-32616
81135b54:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81135b58:	d0a02684 	addi	r2,gp,-32614
81135b5c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
81135b60:	d0a02704 	addi	r2,gp,-32612
81135b64:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81135b68:	d0a02784 	addi	r2,gp,-32610
81135b6c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
81135b70:	d0a02804 	addi	r2,gp,-32608
81135b74:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81135b78:	d0a02884 	addi	r2,gp,-32606
81135b7c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
81135b80:	d0a02904 	addi	r2,gp,-32604
81135b84:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81135b88:	d0a02984 	addi	r2,gp,-32602
81135b8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
81135b90:	d0a02a04 	addi	r2,gp,-32600
81135b94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81135b98:	d0a02a84 	addi	r2,gp,-32598
81135b9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
81135ba0:	d0a02b04 	addi	r2,gp,-32596
81135ba4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
81135ba8:	d0a02b84 	addi	r2,gp,-32594
81135bac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
81135bb0:	d0a02c04 	addi	r2,gp,-32592
81135bb4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
81135bb8:	d0a02c84 	addi	r2,gp,-32590
81135bbc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
81135bc0:	d0a02d04 	addi	r2,gp,-32588
81135bc4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
81135bc8:	d0a02d84 	addi	r2,gp,-32586
81135bcc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
81135bd0:	d0a02e04 	addi	r2,gp,-32584
81135bd4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
81135bd8:	d0a02e84 	addi	r2,gp,-32582
81135bdc:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
81135be0:	00a045b4 	movhi	r2,33046
81135be4:	10882b04 	addi	r2,r2,8364
81135be8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
81135bec:	00a045b4 	movhi	r2,33046
81135bf0:	10861704 	addi	r2,r2,6236
81135bf4:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
81135bf8:	d0a02f84 	addi	r2,gp,-32578
81135bfc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
81135c00:	d0a03004 	addi	r2,gp,-32576
81135c04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81135c08:	d0a03084 	addi	r2,gp,-32574
81135c0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81135c10:	d0a03104 	addi	r2,gp,-32572
81135c14:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81135c18:	d0a03184 	addi	r2,gp,-32570
81135c1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
81135c20:	d0a03204 	addi	r2,gp,-32568
81135c24:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81135c28:	d0a03284 	addi	r2,gp,-32566
81135c2c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
81135c30:	d0a03304 	addi	r2,gp,-32564
81135c34:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81135c38:	d0a03384 	addi	r2,gp,-32562
81135c3c:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
81135c40:	d0a02f04 	addi	r2,gp,-32580
81135c44:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81135c48:	d0a03404 	addi	r2,gp,-32560
81135c4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
81135c50:	0001883a 	nop
81135c54:	e037883a 	mov	sp,fp
81135c58:	df000017 	ldw	fp,0(sp)
81135c5c:	dec00104 	addi	sp,sp,4
81135c60:	f800283a 	ret

81135c64 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
81135c64:	defff204 	addi	sp,sp,-56
81135c68:	de00012e 	bgeu	sp,et,81135c70 <OSFlagAccept+0xc>
81135c6c:	003b68fa 	trap	3
81135c70:	df000d15 	stw	fp,52(sp)
81135c74:	df000d04 	addi	fp,sp,52
81135c78:	e13ffc15 	stw	r4,-16(fp)
81135c7c:	2807883a 	mov	r3,r5
81135c80:	3005883a 	mov	r2,r6
81135c84:	e1ffff15 	stw	r7,-4(fp)
81135c88:	e0fffd0d 	sth	r3,-12(fp)
81135c8c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81135c90:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81135c94:	e0bfff17 	ldw	r2,-4(fp)
81135c98:	1000021e 	bne	r2,zero,81135ca4 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
81135c9c:	0005883a 	mov	r2,zero
81135ca0:	0000b006 	br	81135f64 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81135ca4:	e0bffc17 	ldw	r2,-16(fp)
81135ca8:	1000051e 	bne	r2,zero,81135cc0 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135cac:	e0bfff17 	ldw	r2,-4(fp)
81135cb0:	00c01b84 	movi	r3,110
81135cb4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135cb8:	0005883a 	mov	r2,zero
81135cbc:	0000a906 	br	81135f64 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81135cc0:	e0bffc17 	ldw	r2,-16(fp)
81135cc4:	10800003 	ldbu	r2,0(r2)
81135cc8:	10803fcc 	andi	r2,r2,255
81135ccc:	10800160 	cmpeqi	r2,r2,5
81135cd0:	1000051e 	bne	r2,zero,81135ce8 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
81135cd4:	e0bfff17 	ldw	r2,-4(fp)
81135cd8:	00c00044 	movi	r3,1
81135cdc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135ce0:	0005883a 	mov	r2,zero
81135ce4:	00009f06 	br	81135f64 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81135ce8:	e0fffe03 	ldbu	r3,-8(fp)
81135cec:	00bfe004 	movi	r2,-128
81135cf0:	1884703a 	and	r2,r3,r2
81135cf4:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
81135cf8:	e0bff503 	ldbu	r2,-44(fp)
81135cfc:	10000626 	beq	r2,zero,81135d18 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
81135d00:	e0bffe03 	ldbu	r2,-8(fp)
81135d04:	10801fcc 	andi	r2,r2,127
81135d08:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81135d0c:	00800044 	movi	r2,1
81135d10:	e0bff385 	stb	r2,-50(fp)
81135d14:	00000106 	br	81135d1c <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81135d18:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
81135d1c:	e0bfff17 	ldw	r2,-4(fp)
81135d20:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135d24:	0005303a 	rdctl	r2,status
81135d28:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135d2c:	e0fffb17 	ldw	r3,-20(fp)
81135d30:	00bfff84 	movi	r2,-2
81135d34:	1884703a 	and	r2,r3,r2
81135d38:	1001703a 	wrctl	status,r2
  
  return context;
81135d3c:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
81135d40:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
81135d44:	e0bffe03 	ldbu	r2,-8(fp)
81135d48:	10c00060 	cmpeqi	r3,r2,1
81135d4c:	18005f1e 	bne	r3,zero,81135ecc <OSFlagAccept+0x268>
81135d50:	10c00088 	cmpgei	r3,r2,2
81135d54:	1800021e 	bne	r3,zero,81135d60 <OSFlagAccept+0xfc>
81135d58:	10003f26 	beq	r2,zero,81135e58 <OSFlagAccept+0x1f4>
81135d5c:	00007706 	br	81135f3c <OSFlagAccept+0x2d8>
81135d60:	10c000a0 	cmpeqi	r3,r2,2
81135d64:	1800031e 	bne	r3,zero,81135d74 <OSFlagAccept+0x110>
81135d68:	108000e0 	cmpeqi	r2,r2,3
81135d6c:	10001e1e 	bne	r2,zero,81135de8 <OSFlagAccept+0x184>
81135d70:	00007206 	br	81135f3c <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81135d74:	e0bffc17 	ldw	r2,-16(fp)
81135d78:	10c0020b 	ldhu	r3,8(r2)
81135d7c:	e0bffd0b 	ldhu	r2,-12(fp)
81135d80:	1884703a 	and	r2,r3,r2
81135d84:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81135d88:	e0fff30b 	ldhu	r3,-52(fp)
81135d8c:	e0bffd0b 	ldhu	r2,-12(fp)
81135d90:	18800d1e 	bne	r3,r2,81135dc8 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135d94:	e0bff383 	ldbu	r2,-50(fp)
81135d98:	10800058 	cmpnei	r2,r2,1
81135d9c:	10000d1e 	bne	r2,zero,81135dd4 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81135da0:	e0bffc17 	ldw	r2,-16(fp)
81135da4:	1080020b 	ldhu	r2,8(r2)
81135da8:	1007883a 	mov	r3,r2
81135dac:	e0bff30b 	ldhu	r2,-52(fp)
81135db0:	0084303a 	nor	r2,zero,r2
81135db4:	1884703a 	and	r2,r3,r2
81135db8:	1007883a 	mov	r3,r2
81135dbc:	e0bffc17 	ldw	r2,-16(fp)
81135dc0:	10c0020d 	sth	r3,8(r2)
81135dc4:	00000306 	br	81135dd4 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81135dc8:	e0bfff17 	ldw	r2,-4(fp)
81135dcc:	00c01c04 	movi	r3,112
81135dd0:	10c00005 	stb	r3,0(r2)
81135dd4:	e0bff417 	ldw	r2,-48(fp)
81135dd8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135ddc:	e0bff617 	ldw	r2,-40(fp)
81135de0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81135de4:	00005e06 	br	81135f60 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81135de8:	e0bffc17 	ldw	r2,-16(fp)
81135dec:	10c0020b 	ldhu	r3,8(r2)
81135df0:	e0bffd0b 	ldhu	r2,-12(fp)
81135df4:	1884703a 	and	r2,r3,r2
81135df8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81135dfc:	e0bff30b 	ldhu	r2,-52(fp)
81135e00:	10000d26 	beq	r2,zero,81135e38 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135e04:	e0bff383 	ldbu	r2,-50(fp)
81135e08:	10800058 	cmpnei	r2,r2,1
81135e0c:	10000d1e 	bne	r2,zero,81135e44 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81135e10:	e0bffc17 	ldw	r2,-16(fp)
81135e14:	1080020b 	ldhu	r2,8(r2)
81135e18:	1007883a 	mov	r3,r2
81135e1c:	e0bff30b 	ldhu	r2,-52(fp)
81135e20:	0084303a 	nor	r2,zero,r2
81135e24:	1884703a 	and	r2,r3,r2
81135e28:	1007883a 	mov	r3,r2
81135e2c:	e0bffc17 	ldw	r2,-16(fp)
81135e30:	10c0020d 	sth	r3,8(r2)
81135e34:	00000306 	br	81135e44 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81135e38:	e0bfff17 	ldw	r2,-4(fp)
81135e3c:	00c01c04 	movi	r3,112
81135e40:	10c00005 	stb	r3,0(r2)
81135e44:	e0bff417 	ldw	r2,-48(fp)
81135e48:	e0bff715 	stw	r2,-36(fp)
81135e4c:	e0bff717 	ldw	r2,-36(fp)
81135e50:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81135e54:	00004206 	br	81135f60 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81135e58:	e0bffc17 	ldw	r2,-16(fp)
81135e5c:	1080020b 	ldhu	r2,8(r2)
81135e60:	0084303a 	nor	r2,zero,r2
81135e64:	1007883a 	mov	r3,r2
81135e68:	e0bffd0b 	ldhu	r2,-12(fp)
81135e6c:	1884703a 	and	r2,r3,r2
81135e70:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81135e74:	e0fff30b 	ldhu	r3,-52(fp)
81135e78:	e0bffd0b 	ldhu	r2,-12(fp)
81135e7c:	18800b1e 	bne	r3,r2,81135eac <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135e80:	e0bff383 	ldbu	r2,-50(fp)
81135e84:	10800058 	cmpnei	r2,r2,1
81135e88:	10000b1e 	bne	r2,zero,81135eb8 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81135e8c:	e0bffc17 	ldw	r2,-16(fp)
81135e90:	10c0020b 	ldhu	r3,8(r2)
81135e94:	e0bff30b 	ldhu	r2,-52(fp)
81135e98:	1884b03a 	or	r2,r3,r2
81135e9c:	1007883a 	mov	r3,r2
81135ea0:	e0bffc17 	ldw	r2,-16(fp)
81135ea4:	10c0020d 	sth	r3,8(r2)
81135ea8:	00000306 	br	81135eb8 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81135eac:	e0bfff17 	ldw	r2,-4(fp)
81135eb0:	00c01c04 	movi	r3,112
81135eb4:	10c00005 	stb	r3,0(r2)
81135eb8:	e0bff417 	ldw	r2,-48(fp)
81135ebc:	e0bff815 	stw	r2,-32(fp)
81135ec0:	e0bff817 	ldw	r2,-32(fp)
81135ec4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81135ec8:	00002506 	br	81135f60 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
81135ecc:	e0bffc17 	ldw	r2,-16(fp)
81135ed0:	1080020b 	ldhu	r2,8(r2)
81135ed4:	0084303a 	nor	r2,zero,r2
81135ed8:	1007883a 	mov	r3,r2
81135edc:	e0bffd0b 	ldhu	r2,-12(fp)
81135ee0:	1884703a 	and	r2,r3,r2
81135ee4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81135ee8:	e0bff30b 	ldhu	r2,-52(fp)
81135eec:	10000b26 	beq	r2,zero,81135f1c <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135ef0:	e0bff383 	ldbu	r2,-50(fp)
81135ef4:	10800058 	cmpnei	r2,r2,1
81135ef8:	10000b1e 	bne	r2,zero,81135f28 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
81135efc:	e0bffc17 	ldw	r2,-16(fp)
81135f00:	10c0020b 	ldhu	r3,8(r2)
81135f04:	e0bff30b 	ldhu	r2,-52(fp)
81135f08:	1884b03a 	or	r2,r3,r2
81135f0c:	1007883a 	mov	r3,r2
81135f10:	e0bffc17 	ldw	r2,-16(fp)
81135f14:	10c0020d 	sth	r3,8(r2)
81135f18:	00000306 	br	81135f28 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81135f1c:	e0bfff17 	ldw	r2,-4(fp)
81135f20:	00c01c04 	movi	r3,112
81135f24:	10c00005 	stb	r3,0(r2)
81135f28:	e0bff417 	ldw	r2,-48(fp)
81135f2c:	e0bff915 	stw	r2,-28(fp)
81135f30:	e0bff917 	ldw	r2,-28(fp)
81135f34:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81135f38:	00000906 	br	81135f60 <OSFlagAccept+0x2fc>
81135f3c:	e0bff417 	ldw	r2,-48(fp)
81135f40:	e0bffa15 	stw	r2,-24(fp)
81135f44:	e0bffa17 	ldw	r2,-24(fp)
81135f48:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81135f4c:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
81135f50:	e0bfff17 	ldw	r2,-4(fp)
81135f54:	00c01bc4 	movi	r3,111
81135f58:	10c00005 	stb	r3,0(r2)
             break;
81135f5c:	0001883a 	nop
    }
    return (flags_rdy);
81135f60:	e0bff30b 	ldhu	r2,-52(fp)
}
81135f64:	e037883a 	mov	sp,fp
81135f68:	df000017 	ldw	fp,0(sp)
81135f6c:	dec00104 	addi	sp,sp,4
81135f70:	f800283a 	ret

81135f74 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
81135f74:	defff804 	addi	sp,sp,-32
81135f78:	de00012e 	bgeu	sp,et,81135f80 <OSFlagCreate+0xc>
81135f7c:	003b68fa 	trap	3
81135f80:	df000715 	stw	fp,28(sp)
81135f84:	df000704 	addi	fp,sp,28
81135f88:	2005883a 	mov	r2,r4
81135f8c:	e17fff15 	stw	r5,-4(fp)
81135f90:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
81135f94:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
81135f98:	e0bfff17 	ldw	r2,-4(fp)
81135f9c:	1000021e 	bne	r2,zero,81135fa8 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
81135fa0:	0005883a 	mov	r2,zero
81135fa4:	00003306 	br	81136074 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
81135fa8:	d0a09c03 	ldbu	r2,-32144(gp)
81135fac:	10803fcc 	andi	r2,r2,255
81135fb0:	10000526 	beq	r2,zero,81135fc8 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
81135fb4:	e0bfff17 	ldw	r2,-4(fp)
81135fb8:	00c00404 	movi	r3,16
81135fbc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
81135fc0:	0005883a 	mov	r2,zero
81135fc4:	00002b06 	br	81136074 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135fc8:	0005303a 	rdctl	r2,status
81135fcc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135fd0:	e0fffd17 	ldw	r3,-12(fp)
81135fd4:	00bfff84 	movi	r2,-2
81135fd8:	1884703a 	and	r2,r3,r2
81135fdc:	1001703a 	wrctl	status,r2
  
  return context;
81135fe0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81135fe4:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
81135fe8:	d0a0a117 	ldw	r2,-32124(gp)
81135fec:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
81135ff0:	e0bffb17 	ldw	r2,-20(fp)
81135ff4:	10001726 	beq	r2,zero,81136054 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
81135ff8:	d0a0a117 	ldw	r2,-32124(gp)
81135ffc:	10800117 	ldw	r2,4(r2)
81136000:	d0a0a115 	stw	r2,-32124(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81136004:	e0bffb17 	ldw	r2,-20(fp)
81136008:	00c00144 	movi	r3,5
8113600c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81136010:	e0bffb17 	ldw	r2,-20(fp)
81136014:	e0fffe0b 	ldhu	r3,-8(fp)
81136018:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113601c:	e0bffb17 	ldw	r2,-20(fp)
81136020:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
81136024:	e0bffb17 	ldw	r2,-20(fp)
81136028:	00c00fc4 	movi	r3,63
8113602c:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81136030:	e0bffb17 	ldw	r2,-20(fp)
81136034:	100002c5 	stb	zero,11(r2)
81136038:	e0bff917 	ldw	r2,-28(fp)
8113603c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136040:	e0bffa17 	ldw	r2,-24(fp)
81136044:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
81136048:	e0bfff17 	ldw	r2,-4(fp)
8113604c:	10000005 	stb	zero,0(r2)
81136050:	00000706 	br	81136070 <OSFlagCreate+0xfc>
81136054:	e0bff917 	ldw	r2,-28(fp)
81136058:	e0bffc15 	stw	r2,-16(fp)
8113605c:	e0bffc17 	ldw	r2,-16(fp)
81136060:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
81136064:	e0bfff17 	ldw	r2,-4(fp)
81136068:	00c01c84 	movi	r3,114
8113606c:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
81136070:	e0bffb17 	ldw	r2,-20(fp)
}
81136074:	e037883a 	mov	sp,fp
81136078:	df000017 	ldw	fp,0(sp)
8113607c:	dec00104 	addi	sp,sp,4
81136080:	f800283a 	ret

81136084 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
81136084:	defff204 	addi	sp,sp,-56
81136088:	de00012e 	bgeu	sp,et,81136090 <OSFlagDel+0xc>
8113608c:	003b68fa 	trap	3
81136090:	dfc00d15 	stw	ra,52(sp)
81136094:	df000c15 	stw	fp,48(sp)
81136098:	df000c04 	addi	fp,sp,48
8113609c:	e13ffd15 	stw	r4,-12(fp)
811360a0:	2805883a 	mov	r2,r5
811360a4:	e1bfff15 	stw	r6,-4(fp)
811360a8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
811360ac:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811360b0:	e0bfff17 	ldw	r2,-4(fp)
811360b4:	1000021e 	bne	r2,zero,811360c0 <OSFlagDel+0x3c>
        return (pgrp);
811360b8:	e0bffd17 	ldw	r2,-12(fp)
811360bc:	00008006 	br	811362c0 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811360c0:	e0bffd17 	ldw	r2,-12(fp)
811360c4:	1000051e 	bne	r2,zero,811360dc <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811360c8:	e0bfff17 	ldw	r2,-4(fp)
811360cc:	00c01b84 	movi	r3,110
811360d0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
811360d4:	e0bffd17 	ldw	r2,-12(fp)
811360d8:	00007906 	br	811362c0 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811360dc:	d0a09c03 	ldbu	r2,-32144(gp)
811360e0:	10803fcc 	andi	r2,r2,255
811360e4:	10000526 	beq	r2,zero,811360fc <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
811360e8:	e0bfff17 	ldw	r2,-4(fp)
811360ec:	00c003c4 	movi	r3,15
811360f0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
811360f4:	e0bffd17 	ldw	r2,-12(fp)
811360f8:	00007106 	br	811362c0 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
811360fc:	e0bffd17 	ldw	r2,-12(fp)
81136100:	10800003 	ldbu	r2,0(r2)
81136104:	10803fcc 	andi	r2,r2,255
81136108:	10800160 	cmpeqi	r2,r2,5
8113610c:	1000051e 	bne	r2,zero,81136124 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81136110:	e0bfff17 	ldw	r2,-4(fp)
81136114:	00c00044 	movi	r3,1
81136118:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113611c:	e0bffd17 	ldw	r2,-12(fp)
81136120:	00006706 	br	811362c0 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136124:	0005303a 	rdctl	r2,status
81136128:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113612c:	e0fffc17 	ldw	r3,-16(fp)
81136130:	00bfff84 	movi	r2,-2
81136134:	1884703a 	and	r2,r3,r2
81136138:	1001703a 	wrctl	status,r2
  
  return context;
8113613c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136140:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
81136144:	e0bffd17 	ldw	r2,-12(fp)
81136148:	10800117 	ldw	r2,4(r2)
8113614c:	10000326 	beq	r2,zero,8113615c <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81136150:	00800044 	movi	r2,1
81136154:	e0bff405 	stb	r2,-48(fp)
81136158:	00000106 	br	81136160 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113615c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81136160:	e0bffe03 	ldbu	r2,-8(fp)
81136164:	10000326 	beq	r2,zero,81136174 <OSFlagDel+0xf0>
81136168:	10800060 	cmpeqi	r2,r2,1
8113616c:	1000231e 	bne	r2,zero,811361fc <OSFlagDel+0x178>
81136170:	00004806 	br	81136294 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
81136174:	e0bff403 	ldbu	r2,-48(fp)
81136178:	1000161e 	bne	r2,zero,811361d4 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8113617c:	e0bffd17 	ldw	r2,-12(fp)
81136180:	00c00fc4 	movi	r3,63
81136184:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81136188:	e0bffd17 	ldw	r2,-12(fp)
8113618c:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81136190:	e0bffd17 	ldw	r2,-12(fp)
81136194:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
81136198:	d0e0a117 	ldw	r3,-32124(gp)
8113619c:	e0bffd17 	ldw	r2,-12(fp)
811361a0:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
811361a4:	e0bffd17 	ldw	r2,-12(fp)
811361a8:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
811361ac:	e0bffd17 	ldw	r2,-12(fp)
811361b0:	d0a0a115 	stw	r2,-32124(gp)
811361b4:	e0bff717 	ldw	r2,-36(fp)
811361b8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811361bc:	e0bff817 	ldw	r2,-32(fp)
811361c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
811361c4:	e0bfff17 	ldw	r2,-4(fp)
811361c8:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
811361cc:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
811361d0:	00003a06 	br	811362bc <OSFlagDel+0x238>
811361d4:	e0bff717 	ldw	r2,-36(fp)
811361d8:	e0bff915 	stw	r2,-28(fp)
811361dc:	e0bff917 	ldw	r2,-28(fp)
811361e0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
811361e4:	e0bfff17 	ldw	r2,-4(fp)
811361e8:	00c01244 	movi	r3,73
811361ec:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
811361f0:	e0bffd17 	ldw	r2,-12(fp)
811361f4:	e0bff615 	stw	r2,-40(fp)
             }
             break;
811361f8:	00003006 	br	811362bc <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811361fc:	e0bffd17 	ldw	r2,-12(fp)
81136200:	10800117 	ldw	r2,4(r2)
81136204:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81136208:	00000606 	br	81136224 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113620c:	000b883a 	mov	r5,zero
81136210:	e13ff517 	ldw	r4,-44(fp)
81136214:	11372380 	call	81137238 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81136218:	e0bff517 	ldw	r2,-44(fp)
8113621c:	10800017 	ldw	r2,0(r2)
81136220:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81136224:	e0bff517 	ldw	r2,-44(fp)
81136228:	103ff81e 	bne	r2,zero,8113620c <__reset+0xfb11620c>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8113622c:	e0bffd17 	ldw	r2,-12(fp)
81136230:	00c00fc4 	movi	r3,63
81136234:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81136238:	e0bffd17 	ldw	r2,-12(fp)
8113623c:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81136240:	e0bffd17 	ldw	r2,-12(fp)
81136244:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
81136248:	d0e0a117 	ldw	r3,-32124(gp)
8113624c:	e0bffd17 	ldw	r2,-12(fp)
81136250:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
81136254:	e0bffd17 	ldw	r2,-12(fp)
81136258:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8113625c:	e0bffd17 	ldw	r2,-12(fp)
81136260:	d0a0a115 	stw	r2,-32124(gp)
81136264:	e0bff717 	ldw	r2,-36(fp)
81136268:	e0bffa15 	stw	r2,-24(fp)
8113626c:	e0bffa17 	ldw	r2,-24(fp)
81136270:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81136274:	e0bff403 	ldbu	r2,-48(fp)
81136278:	10800058 	cmpnei	r2,r2,1
8113627c:	1000011e 	bne	r2,zero,81136284 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81136280:	11353480 	call	81135348 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
81136284:	e0bfff17 	ldw	r2,-4(fp)
81136288:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113628c:	e03ff615 	stw	zero,-40(fp)
             break;
81136290:	00000a06 	br	811362bc <OSFlagDel+0x238>
81136294:	e0bff717 	ldw	r2,-36(fp)
81136298:	e0bffb15 	stw	r2,-20(fp)
8113629c:	e0bffb17 	ldw	r2,-20(fp)
811362a0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
811362a4:	e0bfff17 	ldw	r2,-4(fp)
811362a8:	00c001c4 	movi	r3,7
811362ac:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
811362b0:	e0bffd17 	ldw	r2,-12(fp)
811362b4:	e0bff615 	stw	r2,-40(fp)
             break;
811362b8:	0001883a 	nop
    }
    return (pgrp_return);
811362bc:	e0bff617 	ldw	r2,-40(fp)
}
811362c0:	e037883a 	mov	sp,fp
811362c4:	dfc00117 	ldw	ra,4(sp)
811362c8:	df000017 	ldw	fp,0(sp)
811362cc:	dec00204 	addi	sp,sp,8
811362d0:	f800283a 	ret

811362d4 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
811362d4:	defff604 	addi	sp,sp,-40
811362d8:	de00012e 	bgeu	sp,et,811362e0 <OSFlagNameGet+0xc>
811362dc:	003b68fa 	trap	3
811362e0:	dfc00915 	stw	ra,36(sp)
811362e4:	df000815 	stw	fp,32(sp)
811362e8:	df000804 	addi	fp,sp,32
811362ec:	e13ffd15 	stw	r4,-12(fp)
811362f0:	e17ffe15 	stw	r5,-8(fp)
811362f4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811362f8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811362fc:	e0bfff17 	ldw	r2,-4(fp)
81136300:	1000021e 	bne	r2,zero,8113630c <OSFlagNameGet+0x38>
        return (0);
81136304:	0005883a 	mov	r2,zero
81136308:	00003906 	br	811363f0 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113630c:	e0bffd17 	ldw	r2,-12(fp)
81136310:	1000051e 	bne	r2,zero,81136328 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81136314:	e0bfff17 	ldw	r2,-4(fp)
81136318:	00c01b84 	movi	r3,110
8113631c:	10c00005 	stb	r3,0(r2)
        return (0);
81136320:	0005883a 	mov	r2,zero
81136324:	00003206 	br	811363f0 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81136328:	e0bffe17 	ldw	r2,-8(fp)
8113632c:	1000051e 	bne	r2,zero,81136344 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81136330:	e0bfff17 	ldw	r2,-4(fp)
81136334:	00c00304 	movi	r3,12
81136338:	10c00005 	stb	r3,0(r2)
        return (0);
8113633c:	0005883a 	mov	r2,zero
81136340:	00002b06 	br	811363f0 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136344:	d0a09c03 	ldbu	r2,-32144(gp)
81136348:	10803fcc 	andi	r2,r2,255
8113634c:	10000526 	beq	r2,zero,81136364 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81136350:	e0bfff17 	ldw	r2,-4(fp)
81136354:	00c00444 	movi	r3,17
81136358:	10c00005 	stb	r3,0(r2)
        return (0);
8113635c:	0005883a 	mov	r2,zero
81136360:	00002306 	br	811363f0 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136364:	0005303a 	rdctl	r2,status
81136368:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113636c:	e0fffc17 	ldw	r3,-16(fp)
81136370:	00bfff84 	movi	r2,-2
81136374:	1884703a 	and	r2,r3,r2
81136378:	1001703a 	wrctl	status,r2
  
  return context;
8113637c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136380:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81136384:	e0bffd17 	ldw	r2,-12(fp)
81136388:	10800003 	ldbu	r2,0(r2)
8113638c:	10803fcc 	andi	r2,r2,255
81136390:	10800160 	cmpeqi	r2,r2,5
81136394:	1000091e 	bne	r2,zero,811363bc <OSFlagNameGet+0xe8>
81136398:	e0bff817 	ldw	r2,-32(fp)
8113639c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811363a0:	e0bff917 	ldw	r2,-28(fp)
811363a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
811363a8:	e0bfff17 	ldw	r2,-4(fp)
811363ac:	00c00044 	movi	r3,1
811363b0:	10c00005 	stb	r3,0(r2)
        return (0);
811363b4:	0005883a 	mov	r2,zero
811363b8:	00000d06 	br	811363f0 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
811363bc:	e0bffd17 	ldw	r2,-12(fp)
811363c0:	10800284 	addi	r2,r2,10
811363c4:	100b883a 	mov	r5,r2
811363c8:	e13ffe17 	ldw	r4,-8(fp)
811363cc:	113549c0 	call	8113549c <OS_StrCopy>
811363d0:	e0bffb05 	stb	r2,-20(fp)
811363d4:	e0bff817 	ldw	r2,-32(fp)
811363d8:	e0bffa15 	stw	r2,-24(fp)
811363dc:	e0bffa17 	ldw	r2,-24(fp)
811363e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811363e4:	e0bfff17 	ldw	r2,-4(fp)
811363e8:	10000005 	stb	zero,0(r2)
    return (len);
811363ec:	e0bffb03 	ldbu	r2,-20(fp)
}
811363f0:	e037883a 	mov	sp,fp
811363f4:	dfc00117 	ldw	ra,4(sp)
811363f8:	df000017 	ldw	fp,0(sp)
811363fc:	dec00204 	addi	sp,sp,8
81136400:	f800283a 	ret

81136404 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81136404:	defff504 	addi	sp,sp,-44
81136408:	de00012e 	bgeu	sp,et,81136410 <OSFlagNameSet+0xc>
8113640c:	003b68fa 	trap	3
81136410:	dfc00a15 	stw	ra,40(sp)
81136414:	df000915 	stw	fp,36(sp)
81136418:	df000904 	addi	fp,sp,36
8113641c:	e13ffd15 	stw	r4,-12(fp)
81136420:	e17ffe15 	stw	r5,-8(fp)
81136424:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136428:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113642c:	e0bfff17 	ldw	r2,-4(fp)
81136430:	10004326 	beq	r2,zero,81136540 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81136434:	e0bffd17 	ldw	r2,-12(fp)
81136438:	1000041e 	bne	r2,zero,8113644c <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113643c:	e0bfff17 	ldw	r2,-4(fp)
81136440:	00c01b84 	movi	r3,110
81136444:	10c00005 	stb	r3,0(r2)
        return;
81136448:	00003e06 	br	81136544 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113644c:	e0bffe17 	ldw	r2,-8(fp)
81136450:	1000041e 	bne	r2,zero,81136464 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81136454:	e0bfff17 	ldw	r2,-4(fp)
81136458:	00c00304 	movi	r3,12
8113645c:	10c00005 	stb	r3,0(r2)
        return;
81136460:	00003806 	br	81136544 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136464:	d0a09c03 	ldbu	r2,-32144(gp)
81136468:	10803fcc 	andi	r2,r2,255
8113646c:	10000426 	beq	r2,zero,81136480 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81136470:	e0bfff17 	ldw	r2,-4(fp)
81136474:	00c00484 	movi	r3,18
81136478:	10c00005 	stb	r3,0(r2)
        return;
8113647c:	00003106 	br	81136544 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136480:	0005303a 	rdctl	r2,status
81136484:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136488:	e0fffc17 	ldw	r3,-16(fp)
8113648c:	00bfff84 	movi	r2,-2
81136490:	1884703a 	and	r2,r3,r2
81136494:	1001703a 	wrctl	status,r2
  
  return context;
81136498:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113649c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
811364a0:	e0bffd17 	ldw	r2,-12(fp)
811364a4:	10800003 	ldbu	r2,0(r2)
811364a8:	10803fcc 	andi	r2,r2,255
811364ac:	10800160 	cmpeqi	r2,r2,5
811364b0:	1000081e 	bne	r2,zero,811364d4 <OSFlagNameSet+0xd0>
811364b4:	e0bff717 	ldw	r2,-36(fp)
811364b8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811364bc:	e0bff817 	ldw	r2,-32(fp)
811364c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
811364c4:	e0bfff17 	ldw	r2,-4(fp)
811364c8:	00c00044 	movi	r3,1
811364cc:	10c00005 	stb	r3,0(r2)
        return;
811364d0:	00001c06 	br	81136544 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
811364d4:	e13ffe17 	ldw	r4,-8(fp)
811364d8:	11355180 	call	81135518 <OS_StrLen>
811364dc:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
811364e0:	e0bffa03 	ldbu	r2,-24(fp)
811364e4:	10800830 	cmpltui	r2,r2,32
811364e8:	1000081e 	bne	r2,zero,8113650c <OSFlagNameSet+0x108>
811364ec:	e0bff717 	ldw	r2,-36(fp)
811364f0:	e0bff915 	stw	r2,-28(fp)
811364f4:	e0bff917 	ldw	r2,-28(fp)
811364f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
811364fc:	e0bfff17 	ldw	r2,-4(fp)
81136500:	00c01cc4 	movi	r3,115
81136504:	10c00005 	stb	r3,0(r2)
        return;
81136508:	00000e06 	br	81136544 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113650c:	e0bffd17 	ldw	r2,-12(fp)
81136510:	10800284 	addi	r2,r2,10
81136514:	e17ffe17 	ldw	r5,-8(fp)
81136518:	1009883a 	mov	r4,r2
8113651c:	113549c0 	call	8113549c <OS_StrCopy>
81136520:	e0bff717 	ldw	r2,-36(fp)
81136524:	e0bffb15 	stw	r2,-20(fp)
81136528:	e0bffb17 	ldw	r2,-20(fp)
8113652c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136530:	e0bfff17 	ldw	r2,-4(fp)
81136534:	10000005 	stb	zero,0(r2)
    return;
81136538:	0001883a 	nop
8113653c:	00000106 	br	81136544 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81136540:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
81136544:	e037883a 	mov	sp,fp
81136548:	dfc00117 	ldw	ra,4(sp)
8113654c:	df000017 	ldw	fp,0(sp)
81136550:	dec00204 	addi	sp,sp,8
81136554:	f800283a 	ret

81136558 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
81136558:	deffe104 	addi	sp,sp,-124
8113655c:	de00012e 	bgeu	sp,et,81136564 <OSFlagPend+0xc>
81136560:	003b68fa 	trap	3
81136564:	dfc01e15 	stw	ra,120(sp)
81136568:	df001d15 	stw	fp,116(sp)
8113656c:	df001d04 	addi	fp,sp,116
81136570:	e13ffc15 	stw	r4,-16(fp)
81136574:	2809883a 	mov	r4,r5
81136578:	3007883a 	mov	r3,r6
8113657c:	3805883a 	mov	r2,r7
81136580:	e13ffd0d 	sth	r4,-12(fp)
81136584:	e0fffe05 	stb	r3,-8(fp)
81136588:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113658c:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136590:	e0800217 	ldw	r2,8(fp)
81136594:	1000021e 	bne	r2,zero,811365a0 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
81136598:	0005883a 	mov	r2,zero
8113659c:	00015906 	br	81136b04 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811365a0:	e0bffc17 	ldw	r2,-16(fp)
811365a4:	1000051e 	bne	r2,zero,811365bc <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811365a8:	e0800217 	ldw	r2,8(fp)
811365ac:	00c01b84 	movi	r3,110
811365b0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811365b4:	0005883a 	mov	r2,zero
811365b8:	00015206 	br	81136b04 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811365bc:	d0a09c03 	ldbu	r2,-32144(gp)
811365c0:	10803fcc 	andi	r2,r2,255
811365c4:	10000526 	beq	r2,zero,811365dc <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
811365c8:	e0800217 	ldw	r2,8(fp)
811365cc:	00c00084 	movi	r3,2
811365d0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811365d4:	0005883a 	mov	r2,zero
811365d8:	00014a06 	br	81136b04 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
811365dc:	d0a08a03 	ldbu	r2,-32216(gp)
811365e0:	10803fcc 	andi	r2,r2,255
811365e4:	10000526 	beq	r2,zero,811365fc <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
811365e8:	e0800217 	ldw	r2,8(fp)
811365ec:	00c00344 	movi	r3,13
811365f0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811365f4:	0005883a 	mov	r2,zero
811365f8:	00014206 	br	81136b04 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
811365fc:	e0bffc17 	ldw	r2,-16(fp)
81136600:	10800003 	ldbu	r2,0(r2)
81136604:	10803fcc 	andi	r2,r2,255
81136608:	10800160 	cmpeqi	r2,r2,5
8113660c:	1000051e 	bne	r2,zero,81136624 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81136610:	e0800217 	ldw	r2,8(fp)
81136614:	00c00044 	movi	r3,1
81136618:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113661c:	0005883a 	mov	r2,zero
81136620:	00013806 	br	81136b04 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81136624:	e0fffe03 	ldbu	r3,-8(fp)
81136628:	00bfe004 	movi	r2,-128
8113662c:	1884703a 	and	r2,r3,r2
81136630:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
81136634:	e0bfe603 	ldbu	r2,-104(fp)
81136638:	10000626 	beq	r2,zero,81136654 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113663c:	e0bffe03 	ldbu	r2,-8(fp)
81136640:	10801fcc 	andi	r2,r2,127
81136644:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81136648:	00800044 	movi	r2,1
8113664c:	e0bfe405 	stb	r2,-112(fp)
81136650:	00000106 	br	81136658 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
81136654:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136658:	0005303a 	rdctl	r2,status
8113665c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136660:	e0fff617 	ldw	r3,-40(fp)
81136664:	00bfff84 	movi	r2,-2
81136668:	1884703a 	and	r2,r3,r2
8113666c:	1001703a 	wrctl	status,r2
  
  return context;
81136670:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81136674:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
81136678:	e0bffe03 	ldbu	r2,-8(fp)
8113667c:	10c00060 	cmpeqi	r3,r2,1
81136680:	1800921e 	bne	r3,zero,811368cc <OSFlagPend+0x374>
81136684:	10c00088 	cmpgei	r3,r2,2
81136688:	1800021e 	bne	r3,zero,81136694 <OSFlagPend+0x13c>
8113668c:	10006126 	beq	r2,zero,81136814 <OSFlagPend+0x2bc>
81136690:	0000bb06 	br	81136980 <OSFlagPend+0x428>
81136694:	10c000a0 	cmpeqi	r3,r2,2
81136698:	1800031e 	bne	r3,zero,811366a8 <OSFlagPend+0x150>
8113669c:	108000e0 	cmpeqi	r2,r2,3
811366a0:	10002f1e 	bne	r2,zero,81136760 <OSFlagPend+0x208>
811366a4:	0000b606 	br	81136980 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
811366a8:	e0bffc17 	ldw	r2,-16(fp)
811366ac:	10c0020b 	ldhu	r3,8(r2)
811366b0:	e0bffd0b 	ldhu	r2,-12(fp)
811366b4:	1884703a 	and	r2,r3,r2
811366b8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811366bc:	e0ffe80b 	ldhu	r3,-96(fp)
811366c0:	e0bffd0b 	ldhu	r2,-12(fp)
811366c4:	1880171e 	bne	r3,r2,81136724 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811366c8:	e0bfe403 	ldbu	r2,-112(fp)
811366cc:	10800058 	cmpnei	r2,r2,1
811366d0:	1000091e 	bne	r2,zero,811366f8 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
811366d4:	e0bffc17 	ldw	r2,-16(fp)
811366d8:	1080020b 	ldhu	r2,8(r2)
811366dc:	1007883a 	mov	r3,r2
811366e0:	e0bfe80b 	ldhu	r2,-96(fp)
811366e4:	0084303a 	nor	r2,zero,r2
811366e8:	1884703a 	and	r2,r3,r2
811366ec:	1007883a 	mov	r3,r2
811366f0:	e0bffc17 	ldw	r2,-16(fp)
811366f4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
811366f8:	d0a09d17 	ldw	r2,-32140(gp)
811366fc:	e0ffe80b 	ldhu	r3,-96(fp)
81136700:	10c00b0d 	sth	r3,44(r2)
81136704:	e0bfe517 	ldw	r2,-108(fp)
81136708:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113670c:	e0bfe717 	ldw	r2,-100(fp)
81136710:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81136714:	e0800217 	ldw	r2,8(fp)
81136718:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113671c:	e0bfe80b 	ldhu	r2,-96(fp)
81136720:	0000f806 	br	81136b04 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81136724:	e13ffd0b 	ldhu	r4,-12(fp)
81136728:	e17ffe03 	ldbu	r5,-8(fp)
8113672c:	e0bfff0b 	ldhu	r2,-4(fp)
81136730:	e0fff704 	addi	r3,fp,-36
81136734:	d8800015 	stw	r2,0(sp)
81136738:	280f883a 	mov	r7,r5
8113673c:	200d883a 	mov	r6,r4
81136740:	180b883a 	mov	r5,r3
81136744:	e13ffc17 	ldw	r4,-16(fp)
81136748:	1136fe80 	call	81136fe8 <OS_FlagBlock>
8113674c:	e0bfe517 	ldw	r2,-108(fp)
81136750:	e0bfe915 	stw	r2,-92(fp)
81136754:	e0bfe917 	ldw	r2,-92(fp)
81136758:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113675c:	00009206 	br	811369a8 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
81136760:	e0bffc17 	ldw	r2,-16(fp)
81136764:	10c0020b 	ldhu	r3,8(r2)
81136768:	e0bffd0b 	ldhu	r2,-12(fp)
8113676c:	1884703a 	and	r2,r3,r2
81136770:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81136774:	e0bfe80b 	ldhu	r2,-96(fp)
81136778:	10001726 	beq	r2,zero,811367d8 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113677c:	e0bfe403 	ldbu	r2,-112(fp)
81136780:	10800058 	cmpnei	r2,r2,1
81136784:	1000091e 	bne	r2,zero,811367ac <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81136788:	e0bffc17 	ldw	r2,-16(fp)
8113678c:	1080020b 	ldhu	r2,8(r2)
81136790:	1007883a 	mov	r3,r2
81136794:	e0bfe80b 	ldhu	r2,-96(fp)
81136798:	0084303a 	nor	r2,zero,r2
8113679c:	1884703a 	and	r2,r3,r2
811367a0:	1007883a 	mov	r3,r2
811367a4:	e0bffc17 	ldw	r2,-16(fp)
811367a8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
811367ac:	d0a09d17 	ldw	r2,-32140(gp)
811367b0:	e0ffe80b 	ldhu	r3,-96(fp)
811367b4:	10c00b0d 	sth	r3,44(r2)
811367b8:	e0bfe517 	ldw	r2,-108(fp)
811367bc:	e0bfea15 	stw	r2,-88(fp)
811367c0:	e0bfea17 	ldw	r2,-88(fp)
811367c4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
811367c8:	e0800217 	ldw	r2,8(fp)
811367cc:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
811367d0:	e0bfe80b 	ldhu	r2,-96(fp)
811367d4:	0000cb06 	br	81136b04 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
811367d8:	e13ffd0b 	ldhu	r4,-12(fp)
811367dc:	e17ffe03 	ldbu	r5,-8(fp)
811367e0:	e0bfff0b 	ldhu	r2,-4(fp)
811367e4:	e0fff704 	addi	r3,fp,-36
811367e8:	d8800015 	stw	r2,0(sp)
811367ec:	280f883a 	mov	r7,r5
811367f0:	200d883a 	mov	r6,r4
811367f4:	180b883a 	mov	r5,r3
811367f8:	e13ffc17 	ldw	r4,-16(fp)
811367fc:	1136fe80 	call	81136fe8 <OS_FlagBlock>
81136800:	e0bfe517 	ldw	r2,-108(fp)
81136804:	e0bfeb15 	stw	r2,-84(fp)
81136808:	e0bfeb17 	ldw	r2,-84(fp)
8113680c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81136810:	00006506 	br	811369a8 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81136814:	e0bffc17 	ldw	r2,-16(fp)
81136818:	1080020b 	ldhu	r2,8(r2)
8113681c:	0084303a 	nor	r2,zero,r2
81136820:	1007883a 	mov	r3,r2
81136824:	e0bffd0b 	ldhu	r2,-12(fp)
81136828:	1884703a 	and	r2,r3,r2
8113682c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81136830:	e0ffe80b 	ldhu	r3,-96(fp)
81136834:	e0bffd0b 	ldhu	r2,-12(fp)
81136838:	1880151e 	bne	r3,r2,81136890 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113683c:	e0bfe403 	ldbu	r2,-112(fp)
81136840:	10800058 	cmpnei	r2,r2,1
81136844:	1000071e 	bne	r2,zero,81136864 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81136848:	e0bffc17 	ldw	r2,-16(fp)
8113684c:	10c0020b 	ldhu	r3,8(r2)
81136850:	e0bfe80b 	ldhu	r2,-96(fp)
81136854:	1884b03a 	or	r2,r3,r2
81136858:	1007883a 	mov	r3,r2
8113685c:	e0bffc17 	ldw	r2,-16(fp)
81136860:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81136864:	d0a09d17 	ldw	r2,-32140(gp)
81136868:	e0ffe80b 	ldhu	r3,-96(fp)
8113686c:	10c00b0d 	sth	r3,44(r2)
81136870:	e0bfe517 	ldw	r2,-108(fp)
81136874:	e0bfec15 	stw	r2,-80(fp)
81136878:	e0bfec17 	ldw	r2,-80(fp)
8113687c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81136880:	e0800217 	ldw	r2,8(fp)
81136884:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81136888:	e0bfe80b 	ldhu	r2,-96(fp)
8113688c:	00009d06 	br	81136b04 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81136890:	e13ffd0b 	ldhu	r4,-12(fp)
81136894:	e17ffe03 	ldbu	r5,-8(fp)
81136898:	e0bfff0b 	ldhu	r2,-4(fp)
8113689c:	e0fff704 	addi	r3,fp,-36
811368a0:	d8800015 	stw	r2,0(sp)
811368a4:	280f883a 	mov	r7,r5
811368a8:	200d883a 	mov	r6,r4
811368ac:	180b883a 	mov	r5,r3
811368b0:	e13ffc17 	ldw	r4,-16(fp)
811368b4:	1136fe80 	call	81136fe8 <OS_FlagBlock>
811368b8:	e0bfe517 	ldw	r2,-108(fp)
811368bc:	e0bfed15 	stw	r2,-76(fp)
811368c0:	e0bfed17 	ldw	r2,-76(fp)
811368c4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
811368c8:	00003706 	br	811369a8 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811368cc:	e0bffc17 	ldw	r2,-16(fp)
811368d0:	1080020b 	ldhu	r2,8(r2)
811368d4:	0084303a 	nor	r2,zero,r2
811368d8:	1007883a 	mov	r3,r2
811368dc:	e0bffd0b 	ldhu	r2,-12(fp)
811368e0:	1884703a 	and	r2,r3,r2
811368e4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
811368e8:	e0bfe80b 	ldhu	r2,-96(fp)
811368ec:	10001526 	beq	r2,zero,81136944 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811368f0:	e0bfe403 	ldbu	r2,-112(fp)
811368f4:	10800058 	cmpnei	r2,r2,1
811368f8:	1000071e 	bne	r2,zero,81136918 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
811368fc:	e0bffc17 	ldw	r2,-16(fp)
81136900:	10c0020b 	ldhu	r3,8(r2)
81136904:	e0bfe80b 	ldhu	r2,-96(fp)
81136908:	1884b03a 	or	r2,r3,r2
8113690c:	1007883a 	mov	r3,r2
81136910:	e0bffc17 	ldw	r2,-16(fp)
81136914:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81136918:	d0a09d17 	ldw	r2,-32140(gp)
8113691c:	e0ffe80b 	ldhu	r3,-96(fp)
81136920:	10c00b0d 	sth	r3,44(r2)
81136924:	e0bfe517 	ldw	r2,-108(fp)
81136928:	e0bfee15 	stw	r2,-72(fp)
8113692c:	e0bfee17 	ldw	r2,-72(fp)
81136930:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81136934:	e0800217 	ldw	r2,8(fp)
81136938:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113693c:	e0bfe80b 	ldhu	r2,-96(fp)
81136940:	00007006 	br	81136b04 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81136944:	e13ffd0b 	ldhu	r4,-12(fp)
81136948:	e17ffe03 	ldbu	r5,-8(fp)
8113694c:	e0bfff0b 	ldhu	r2,-4(fp)
81136950:	e0fff704 	addi	r3,fp,-36
81136954:	d8800015 	stw	r2,0(sp)
81136958:	280f883a 	mov	r7,r5
8113695c:	200d883a 	mov	r6,r4
81136960:	180b883a 	mov	r5,r3
81136964:	e13ffc17 	ldw	r4,-16(fp)
81136968:	1136fe80 	call	81136fe8 <OS_FlagBlock>
8113696c:	e0bfe517 	ldw	r2,-108(fp)
81136970:	e0bfef15 	stw	r2,-68(fp)
81136974:	e0bfef17 	ldw	r2,-68(fp)
81136978:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113697c:	00000a06 	br	811369a8 <OSFlagPend+0x450>
81136980:	e0bfe517 	ldw	r2,-108(fp)
81136984:	e0bff015 	stw	r2,-64(fp)
81136988:	e0bff017 	ldw	r2,-64(fp)
8113698c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81136990:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
81136994:	e0800217 	ldw	r2,8(fp)
81136998:	00c01bc4 	movi	r3,111
8113699c:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
811369a0:	e0bfe80b 	ldhu	r2,-96(fp)
811369a4:	00005706 	br	81136b04 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
811369a8:	11353480 	call	81135348 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811369ac:	0005303a 	rdctl	r2,status
811369b0:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811369b4:	e0fff117 	ldw	r3,-60(fp)
811369b8:	00bfff84 	movi	r2,-2
811369bc:	1884703a 	and	r2,r3,r2
811369c0:	1001703a 	wrctl	status,r2
  
  return context;
811369c4:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
811369c8:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
811369cc:	d0a09d17 	ldw	r2,-32140(gp)
811369d0:	10800c43 	ldbu	r2,49(r2)
811369d4:	10803fcc 	andi	r2,r2,255
811369d8:	10001c26 	beq	r2,zero,81136a4c <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
811369dc:	d0a09d17 	ldw	r2,-32140(gp)
811369e0:	10800c43 	ldbu	r2,49(r2)
811369e4:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811369e8:	d0a09d17 	ldw	r2,-32140(gp)
811369ec:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
811369f0:	e0bff704 	addi	r2,fp,-36
811369f4:	1009883a 	mov	r4,r2
811369f8:	11373340 	call	81137334 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
811369fc:	d0a09d17 	ldw	r2,-32140(gp)
81136a00:	10000c05 	stb	zero,48(r2)
81136a04:	e0bfe517 	ldw	r2,-108(fp)
81136a08:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136a0c:	e0bff217 	ldw	r2,-56(fp)
81136a10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81136a14:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
81136a18:	e0bff303 	ldbu	r2,-52(fp)
81136a1c:	108000a0 	cmpeqi	r2,r2,2
81136a20:	10000426 	beq	r2,zero,81136a34 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
81136a24:	e0800217 	ldw	r2,8(fp)
81136a28:	00c00384 	movi	r3,14
81136a2c:	10c00005 	stb	r3,0(r2)
                 break;
81136a30:	00000406 	br	81136a44 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
81136a34:	e0800217 	ldw	r2,8(fp)
81136a38:	00c00284 	movi	r3,10
81136a3c:	10c00005 	stb	r3,0(r2)
                 break;
81136a40:	0001883a 	nop
        }
        return (flags_rdy);
81136a44:	e0bfe80b 	ldhu	r2,-96(fp)
81136a48:	00002e06 	br	81136b04 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
81136a4c:	d0a09d17 	ldw	r2,-32140(gp)
81136a50:	10800b0b 	ldhu	r2,44(r2)
81136a54:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
81136a58:	e0bfe403 	ldbu	r2,-112(fp)
81136a5c:	10800058 	cmpnei	r2,r2,1
81136a60:	1000211e 	bne	r2,zero,81136ae8 <OSFlagPend+0x590>
        switch (wait_type) {
81136a64:	e0bffe03 	ldbu	r2,-8(fp)
81136a68:	10001616 	blt	r2,zero,81136ac4 <OSFlagPend+0x56c>
81136a6c:	10c00090 	cmplti	r3,r2,2
81136a70:	18000c1e 	bne	r3,zero,81136aa4 <OSFlagPend+0x54c>
81136a74:	10800108 	cmpgei	r2,r2,4
81136a78:	1000121e 	bne	r2,zero,81136ac4 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
81136a7c:	e0bffc17 	ldw	r2,-16(fp)
81136a80:	1080020b 	ldhu	r2,8(r2)
81136a84:	1007883a 	mov	r3,r2
81136a88:	e0bfe80b 	ldhu	r2,-96(fp)
81136a8c:	0084303a 	nor	r2,zero,r2
81136a90:	1884703a 	and	r2,r3,r2
81136a94:	1007883a 	mov	r3,r2
81136a98:	e0bffc17 	ldw	r2,-16(fp)
81136a9c:	10c0020d 	sth	r3,8(r2)
                 break;
81136aa0:	00001106 	br	81136ae8 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
81136aa4:	e0bffc17 	ldw	r2,-16(fp)
81136aa8:	10c0020b 	ldhu	r3,8(r2)
81136aac:	e0bfe80b 	ldhu	r2,-96(fp)
81136ab0:	1884b03a 	or	r2,r3,r2
81136ab4:	1007883a 	mov	r3,r2
81136ab8:	e0bffc17 	ldw	r2,-16(fp)
81136abc:	10c0020d 	sth	r3,8(r2)
                 break;
81136ac0:	00000906 	br	81136ae8 <OSFlagPend+0x590>
81136ac4:	e0bfe517 	ldw	r2,-108(fp)
81136ac8:	e0bff415 	stw	r2,-48(fp)
81136acc:	e0bff417 	ldw	r2,-48(fp)
81136ad0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81136ad4:	e0800217 	ldw	r2,8(fp)
81136ad8:	00c01bc4 	movi	r3,111
81136adc:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81136ae0:	0005883a 	mov	r2,zero
81136ae4:	00000706 	br	81136b04 <OSFlagPend+0x5ac>
81136ae8:	e0bfe517 	ldw	r2,-108(fp)
81136aec:	e0bff515 	stw	r2,-44(fp)
81136af0:	e0bff517 	ldw	r2,-44(fp)
81136af4:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
81136af8:	e0800217 	ldw	r2,8(fp)
81136afc:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81136b00:	e0bfe80b 	ldhu	r2,-96(fp)
}
81136b04:	e037883a 	mov	sp,fp
81136b08:	dfc00117 	ldw	ra,4(sp)
81136b0c:	df000017 	ldw	fp,0(sp)
81136b10:	dec00204 	addi	sp,sp,8
81136b14:	f800283a 	ret

81136b18 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81136b18:	defffb04 	addi	sp,sp,-20
81136b1c:	de00012e 	bgeu	sp,et,81136b24 <OSFlagPendGetFlagsRdy+0xc>
81136b20:	003b68fa 	trap	3
81136b24:	df000415 	stw	fp,16(sp)
81136b28:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81136b2c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136b30:	0005303a 	rdctl	r2,status
81136b34:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136b38:	e0fffe17 	ldw	r3,-8(fp)
81136b3c:	00bfff84 	movi	r2,-2
81136b40:	1884703a 	and	r2,r3,r2
81136b44:	1001703a 	wrctl	status,r2
  
  return context;
81136b48:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81136b4c:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
81136b50:	d0a09d17 	ldw	r2,-32140(gp)
81136b54:	10800b0b 	ldhu	r2,44(r2)
81136b58:	e0bffd0d 	sth	r2,-12(fp)
81136b5c:	e0bffc17 	ldw	r2,-16(fp)
81136b60:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136b64:	e0bfff17 	ldw	r2,-4(fp)
81136b68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
81136b6c:	e0bffd0b 	ldhu	r2,-12(fp)
}
81136b70:	e037883a 	mov	sp,fp
81136b74:	df000017 	ldw	fp,0(sp)
81136b78:	dec00104 	addi	sp,sp,4
81136b7c:	f800283a 	ret

81136b80 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
81136b80:	deffef04 	addi	sp,sp,-68
81136b84:	de00012e 	bgeu	sp,et,81136b8c <OSFlagPost+0xc>
81136b88:	003b68fa 	trap	3
81136b8c:	dfc01015 	stw	ra,64(sp)
81136b90:	df000f15 	stw	fp,60(sp)
81136b94:	df000f04 	addi	fp,sp,60
81136b98:	e13ffc15 	stw	r4,-16(fp)
81136b9c:	2807883a 	mov	r3,r5
81136ba0:	3005883a 	mov	r2,r6
81136ba4:	e1ffff15 	stw	r7,-4(fp)
81136ba8:	e0fffd0d 	sth	r3,-12(fp)
81136bac:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
81136bb0:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81136bb4:	e0bfff17 	ldw	r2,-4(fp)
81136bb8:	1000021e 	bne	r2,zero,81136bc4 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
81136bbc:	0005883a 	mov	r2,zero
81136bc0:	0000d106 	br	81136f08 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
81136bc4:	e0bffc17 	ldw	r2,-16(fp)
81136bc8:	1000051e 	bne	r2,zero,81136be0 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81136bcc:	e0bfff17 	ldw	r2,-4(fp)
81136bd0:	00c01b84 	movi	r3,110
81136bd4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136bd8:	0005883a 	mov	r2,zero
81136bdc:	0000ca06 	br	81136f08 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
81136be0:	e0bffc17 	ldw	r2,-16(fp)
81136be4:	10800003 	ldbu	r2,0(r2)
81136be8:	10803fcc 	andi	r2,r2,255
81136bec:	10800160 	cmpeqi	r2,r2,5
81136bf0:	1000051e 	bne	r2,zero,81136c08 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
81136bf4:	e0bfff17 	ldw	r2,-4(fp)
81136bf8:	00c00044 	movi	r3,1
81136bfc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136c00:	0005883a 	mov	r2,zero
81136c04:	0000c006 	br	81136f08 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136c08:	0005303a 	rdctl	r2,status
81136c0c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136c10:	e0fffb17 	ldw	r3,-20(fp)
81136c14:	00bfff84 	movi	r2,-2
81136c18:	1884703a 	and	r2,r3,r2
81136c1c:	1001703a 	wrctl	status,r2
  
  return context;
81136c20:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81136c24:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
81136c28:	e0bffe03 	ldbu	r2,-8(fp)
81136c2c:	10000326 	beq	r2,zero,81136c3c <OSFlagPost+0xbc>
81136c30:	10800060 	cmpeqi	r2,r2,1
81136c34:	10000b1e 	bne	r2,zero,81136c64 <OSFlagPost+0xe4>
81136c38:	00001206 	br	81136c84 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
81136c3c:	e0bffc17 	ldw	r2,-16(fp)
81136c40:	1080020b 	ldhu	r2,8(r2)
81136c44:	1007883a 	mov	r3,r2
81136c48:	e0bffd0b 	ldhu	r2,-12(fp)
81136c4c:	0084303a 	nor	r2,zero,r2
81136c50:	1884703a 	and	r2,r3,r2
81136c54:	1007883a 	mov	r3,r2
81136c58:	e0bffc17 	ldw	r2,-16(fp)
81136c5c:	10c0020d 	sth	r3,8(r2)
             break;
81136c60:	00001106 	br	81136ca8 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
81136c64:	e0bffc17 	ldw	r2,-16(fp)
81136c68:	10c0020b 	ldhu	r3,8(r2)
81136c6c:	e0bffd0b 	ldhu	r2,-12(fp)
81136c70:	1884b03a 	or	r2,r3,r2
81136c74:	1007883a 	mov	r3,r2
81136c78:	e0bffc17 	ldw	r2,-16(fp)
81136c7c:	10c0020d 	sth	r3,8(r2)
             break;
81136c80:	00000906 	br	81136ca8 <OSFlagPost+0x128>
81136c84:	e0bff317 	ldw	r2,-52(fp)
81136c88:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136c8c:	e0bff417 	ldw	r2,-48(fp)
81136c90:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
81136c94:	e0bfff17 	ldw	r2,-4(fp)
81136c98:	00c01c44 	movi	r3,113
81136c9c:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
81136ca0:	0005883a 	mov	r2,zero
81136ca4:	00009806 	br	81136f08 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
81136ca8:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81136cac:	e0bffc17 	ldw	r2,-16(fp)
81136cb0:	10800117 	ldw	r2,4(r2)
81136cb4:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81136cb8:	00007706 	br	81136e98 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
81136cbc:	e0bff117 	ldw	r2,-60(fp)
81136cc0:	10800483 	ldbu	r2,18(r2)
81136cc4:	10803fcc 	andi	r2,r2,255
81136cc8:	10c00060 	cmpeqi	r3,r2,1
81136ccc:	18004a1e 	bne	r3,zero,81136df8 <OSFlagPost+0x278>
81136cd0:	10c00088 	cmpgei	r3,r2,2
81136cd4:	1800021e 	bne	r3,zero,81136ce0 <OSFlagPost+0x160>
81136cd8:	10002f26 	beq	r2,zero,81136d98 <OSFlagPost+0x218>
81136cdc:	00005b06 	br	81136e4c <OSFlagPost+0x2cc>
81136ce0:	10c000a0 	cmpeqi	r3,r2,2
81136ce4:	1800031e 	bne	r3,zero,81136cf4 <OSFlagPost+0x174>
81136ce8:	108000e0 	cmpeqi	r2,r2,3
81136cec:	1000171e 	bne	r2,zero,81136d4c <OSFlagPost+0x1cc>
81136cf0:	00005606 	br	81136e4c <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81136cf4:	e0bffc17 	ldw	r2,-16(fp)
81136cf8:	10c0020b 	ldhu	r3,8(r2)
81136cfc:	e0bff117 	ldw	r2,-60(fp)
81136d00:	1080040b 	ldhu	r2,16(r2)
81136d04:	1884703a 	and	r2,r3,r2
81136d08:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81136d0c:	e0bff117 	ldw	r2,-60(fp)
81136d10:	1080040b 	ldhu	r2,16(r2)
81136d14:	10ffffcc 	andi	r3,r2,65535
81136d18:	e0bff60b 	ldhu	r2,-40(fp)
81136d1c:	1880541e 	bne	r3,r2,81136e70 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81136d20:	e0bff60b 	ldhu	r2,-40(fp)
81136d24:	100b883a 	mov	r5,r2
81136d28:	e13ff117 	ldw	r4,-60(fp)
81136d2c:	11372380 	call	81137238 <OS_FlagTaskRdy>
81136d30:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81136d34:	e0bff683 	ldbu	r2,-38(fp)
81136d38:	10800058 	cmpnei	r2,r2,1
81136d3c:	10004c1e 	bne	r2,zero,81136e70 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81136d40:	00800044 	movi	r2,1
81136d44:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81136d48:	00004906 	br	81136e70 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81136d4c:	e0bffc17 	ldw	r2,-16(fp)
81136d50:	10c0020b 	ldhu	r3,8(r2)
81136d54:	e0bff117 	ldw	r2,-60(fp)
81136d58:	1080040b 	ldhu	r2,16(r2)
81136d5c:	1884703a 	and	r2,r3,r2
81136d60:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81136d64:	e0bff60b 	ldhu	r2,-40(fp)
81136d68:	10004326 	beq	r2,zero,81136e78 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81136d6c:	e0bff60b 	ldhu	r2,-40(fp)
81136d70:	100b883a 	mov	r5,r2
81136d74:	e13ff117 	ldw	r4,-60(fp)
81136d78:	11372380 	call	81137238 <OS_FlagTaskRdy>
81136d7c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81136d80:	e0bff683 	ldbu	r2,-38(fp)
81136d84:	10800058 	cmpnei	r2,r2,1
81136d88:	10003b1e 	bne	r2,zero,81136e78 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81136d8c:	00800044 	movi	r2,1
81136d90:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81136d94:	00003806 	br	81136e78 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81136d98:	e0bffc17 	ldw	r2,-16(fp)
81136d9c:	1080020b 	ldhu	r2,8(r2)
81136da0:	0084303a 	nor	r2,zero,r2
81136da4:	1007883a 	mov	r3,r2
81136da8:	e0bff117 	ldw	r2,-60(fp)
81136dac:	1080040b 	ldhu	r2,16(r2)
81136db0:	1884703a 	and	r2,r3,r2
81136db4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81136db8:	e0bff117 	ldw	r2,-60(fp)
81136dbc:	1080040b 	ldhu	r2,16(r2)
81136dc0:	10ffffcc 	andi	r3,r2,65535
81136dc4:	e0bff60b 	ldhu	r2,-40(fp)
81136dc8:	18802d1e 	bne	r3,r2,81136e80 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81136dcc:	e0bff60b 	ldhu	r2,-40(fp)
81136dd0:	100b883a 	mov	r5,r2
81136dd4:	e13ff117 	ldw	r4,-60(fp)
81136dd8:	11372380 	call	81137238 <OS_FlagTaskRdy>
81136ddc:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81136de0:	e0bff683 	ldbu	r2,-38(fp)
81136de4:	10800058 	cmpnei	r2,r2,1
81136de8:	1000251e 	bne	r2,zero,81136e80 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81136dec:	00800044 	movi	r2,1
81136df0:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81136df4:	00002206 	br	81136e80 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81136df8:	e0bffc17 	ldw	r2,-16(fp)
81136dfc:	1080020b 	ldhu	r2,8(r2)
81136e00:	0084303a 	nor	r2,zero,r2
81136e04:	1007883a 	mov	r3,r2
81136e08:	e0bff117 	ldw	r2,-60(fp)
81136e0c:	1080040b 	ldhu	r2,16(r2)
81136e10:	1884703a 	and	r2,r3,r2
81136e14:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81136e18:	e0bff60b 	ldhu	r2,-40(fp)
81136e1c:	10001a26 	beq	r2,zero,81136e88 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81136e20:	e0bff60b 	ldhu	r2,-40(fp)
81136e24:	100b883a 	mov	r5,r2
81136e28:	e13ff117 	ldw	r4,-60(fp)
81136e2c:	11372380 	call	81137238 <OS_FlagTaskRdy>
81136e30:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81136e34:	e0bff683 	ldbu	r2,-38(fp)
81136e38:	10800058 	cmpnei	r2,r2,1
81136e3c:	1000121e 	bne	r2,zero,81136e88 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81136e40:	00800044 	movi	r2,1
81136e44:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81136e48:	00000f06 	br	81136e88 <OSFlagPost+0x308>
81136e4c:	e0bff317 	ldw	r2,-52(fp)
81136e50:	e0bff515 	stw	r2,-44(fp)
81136e54:	e0bff517 	ldw	r2,-44(fp)
81136e58:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81136e5c:	e0bfff17 	ldw	r2,-4(fp)
81136e60:	00c01bc4 	movi	r3,111
81136e64:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81136e68:	0005883a 	mov	r2,zero
81136e6c:	00002606 	br	81136f08 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81136e70:	0001883a 	nop
81136e74:	00000506 	br	81136e8c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81136e78:	0001883a 	nop
81136e7c:	00000306 	br	81136e8c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81136e80:	0001883a 	nop
81136e84:	00000106 	br	81136e8c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81136e88:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
81136e8c:	e0bff117 	ldw	r2,-60(fp)
81136e90:	10800017 	ldw	r2,0(r2)
81136e94:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81136e98:	e0bff117 	ldw	r2,-60(fp)
81136e9c:	103f871e 	bne	r2,zero,81136cbc <__reset+0xfb116cbc>
81136ea0:	e0bff317 	ldw	r2,-52(fp)
81136ea4:	e0bff715 	stw	r2,-36(fp)
81136ea8:	e0bff717 	ldw	r2,-36(fp)
81136eac:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
81136eb0:	e0bff203 	ldbu	r2,-56(fp)
81136eb4:	10800058 	cmpnei	r2,r2,1
81136eb8:	1000011e 	bne	r2,zero,81136ec0 <OSFlagPost+0x340>
        OS_Sched();
81136ebc:	11353480 	call	81135348 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136ec0:	0005303a 	rdctl	r2,status
81136ec4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136ec8:	e0fffa17 	ldw	r3,-24(fp)
81136ecc:	00bfff84 	movi	r2,-2
81136ed0:	1884703a 	and	r2,r3,r2
81136ed4:	1001703a 	wrctl	status,r2
  
  return context;
81136ed8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
81136edc:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
81136ee0:	e0bffc17 	ldw	r2,-16(fp)
81136ee4:	1080020b 	ldhu	r2,8(r2)
81136ee8:	e0bff90d 	sth	r2,-28(fp)
81136eec:	e0bff317 	ldw	r2,-52(fp)
81136ef0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136ef4:	e0bff817 	ldw	r2,-32(fp)
81136ef8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
81136efc:	e0bfff17 	ldw	r2,-4(fp)
81136f00:	10000005 	stb	zero,0(r2)
    return (flags_cur);
81136f04:	e0bff90b 	ldhu	r2,-28(fp)
}
81136f08:	e037883a 	mov	sp,fp
81136f0c:	dfc00117 	ldw	ra,4(sp)
81136f10:	df000017 	ldw	fp,0(sp)
81136f14:	dec00204 	addi	sp,sp,8
81136f18:	f800283a 	ret

81136f1c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
81136f1c:	defff904 	addi	sp,sp,-28
81136f20:	de00012e 	bgeu	sp,et,81136f28 <OSFlagQuery+0xc>
81136f24:	003b68fa 	trap	3
81136f28:	df000615 	stw	fp,24(sp)
81136f2c:	df000604 	addi	fp,sp,24
81136f30:	e13ffe15 	stw	r4,-8(fp)
81136f34:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
81136f38:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
81136f3c:	e0bfff17 	ldw	r2,-4(fp)
81136f40:	1000021e 	bne	r2,zero,81136f4c <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
81136f44:	0005883a 	mov	r2,zero
81136f48:	00002306 	br	81136fd8 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
81136f4c:	e0bffe17 	ldw	r2,-8(fp)
81136f50:	1000051e 	bne	r2,zero,81136f68 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81136f54:	e0bfff17 	ldw	r2,-4(fp)
81136f58:	00c01b84 	movi	r3,110
81136f5c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136f60:	0005883a 	mov	r2,zero
81136f64:	00001c06 	br	81136fd8 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
81136f68:	e0bffe17 	ldw	r2,-8(fp)
81136f6c:	10800003 	ldbu	r2,0(r2)
81136f70:	10803fcc 	andi	r2,r2,255
81136f74:	10800160 	cmpeqi	r2,r2,5
81136f78:	1000051e 	bne	r2,zero,81136f90 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81136f7c:	e0bfff17 	ldw	r2,-4(fp)
81136f80:	00c00044 	movi	r3,1
81136f84:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136f88:	0005883a 	mov	r2,zero
81136f8c:	00001206 	br	81136fd8 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136f90:	0005303a 	rdctl	r2,status
81136f94:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136f98:	e0fffc17 	ldw	r3,-16(fp)
81136f9c:	00bfff84 	movi	r2,-2
81136fa0:	1884703a 	and	r2,r3,r2
81136fa4:	1001703a 	wrctl	status,r2
  
  return context;
81136fa8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136fac:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
81136fb0:	e0bffe17 	ldw	r2,-8(fp)
81136fb4:	1080020b 	ldhu	r2,8(r2)
81136fb8:	e0bffb0d 	sth	r2,-20(fp)
81136fbc:	e0bffa17 	ldw	r2,-24(fp)
81136fc0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136fc4:	e0bffd17 	ldw	r2,-12(fp)
81136fc8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136fcc:	e0bfff17 	ldw	r2,-4(fp)
81136fd0:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
81136fd4:	e0bffb0b 	ldhu	r2,-20(fp)
}
81136fd8:	e037883a 	mov	sp,fp
81136fdc:	df000017 	ldw	fp,0(sp)
81136fe0:	dec00104 	addi	sp,sp,4
81136fe4:	f800283a 	ret

81136fe8 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
81136fe8:	defff804 	addi	sp,sp,-32
81136fec:	de00012e 	bgeu	sp,et,81136ff4 <OS_FlagBlock+0xc>
81136ff0:	003b68fa 	trap	3
81136ff4:	df000715 	stw	fp,28(sp)
81136ff8:	df000704 	addi	fp,sp,28
81136ffc:	e13ffb15 	stw	r4,-20(fp)
81137000:	e17ffc15 	stw	r5,-16(fp)
81137004:	3009883a 	mov	r4,r6
81137008:	3807883a 	mov	r3,r7
8113700c:	e0800117 	ldw	r2,4(fp)
81137010:	e13ffd0d 	sth	r4,-12(fp)
81137014:	e0fffe05 	stb	r3,-8(fp)
81137018:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113701c:	d0a09d17 	ldw	r2,-32140(gp)
81137020:	d0e09d17 	ldw	r3,-32140(gp)
81137024:	18c00c03 	ldbu	r3,48(r3)
81137028:	18c00814 	ori	r3,r3,32
8113702c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
81137030:	d0a09d17 	ldw	r2,-32140(gp)
81137034:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
81137038:	d0a09d17 	ldw	r2,-32140(gp)
8113703c:	e0ffff0b 	ldhu	r3,-4(fp)
81137040:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
81137044:	d0a09d17 	ldw	r2,-32140(gp)
81137048:	e0fffc17 	ldw	r3,-16(fp)
8113704c:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
81137050:	e0bffc17 	ldw	r2,-16(fp)
81137054:	e0fffd0b 	ldhu	r3,-12(fp)
81137058:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113705c:	e0bffc17 	ldw	r2,-16(fp)
81137060:	e0fffe03 	ldbu	r3,-8(fp)
81137064:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
81137068:	d0e09d17 	ldw	r3,-32140(gp)
8113706c:	e0bffc17 	ldw	r2,-16(fp)
81137070:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
81137074:	e0bffb17 	ldw	r2,-20(fp)
81137078:	10c00117 	ldw	r3,4(r2)
8113707c:	e0bffc17 	ldw	r2,-16(fp)
81137080:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
81137084:	e0bffc17 	ldw	r2,-16(fp)
81137088:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113708c:	e0bffc17 	ldw	r2,-16(fp)
81137090:	e0fffb17 	ldw	r3,-20(fp)
81137094:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81137098:	e0bffb17 	ldw	r2,-20(fp)
8113709c:	10800117 	ldw	r2,4(r2)
811370a0:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
811370a4:	e0bff917 	ldw	r2,-28(fp)
811370a8:	10000326 	beq	r2,zero,811370b8 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
811370ac:	e0bff917 	ldw	r2,-28(fp)
811370b0:	e0fffc17 	ldw	r3,-16(fp)
811370b4:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
811370b8:	e0bffb17 	ldw	r2,-20(fp)
811370bc:	e0fffc17 	ldw	r3,-16(fp)
811370c0:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
811370c4:	d0a09d17 	ldw	r2,-32140(gp)
811370c8:	10800d03 	ldbu	r2,52(r2)
811370cc:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
811370d0:	e0fffa03 	ldbu	r3,-24(fp)
811370d4:	e13ffa03 	ldbu	r4,-24(fp)
811370d8:	d0a09944 	addi	r2,gp,-32155
811370dc:	2085883a 	add	r2,r4,r2
811370e0:	10800003 	ldbu	r2,0(r2)
811370e4:	1009883a 	mov	r4,r2
811370e8:	d0a09d17 	ldw	r2,-32140(gp)
811370ec:	10800d43 	ldbu	r2,53(r2)
811370f0:	0084303a 	nor	r2,zero,r2
811370f4:	2084703a 	and	r2,r4,r2
811370f8:	1009883a 	mov	r4,r2
811370fc:	d0a09944 	addi	r2,gp,-32155
81137100:	1885883a 	add	r2,r3,r2
81137104:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
81137108:	e0fffa03 	ldbu	r3,-24(fp)
8113710c:	d0a09944 	addi	r2,gp,-32155
81137110:	1885883a 	add	r2,r3,r2
81137114:	10800003 	ldbu	r2,0(r2)
81137118:	10803fcc 	andi	r2,r2,255
8113711c:	1000071e 	bne	r2,zero,8113713c <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81137120:	d0a09d17 	ldw	r2,-32140(gp)
81137124:	10800d83 	ldbu	r2,54(r2)
81137128:	0084303a 	nor	r2,zero,r2
8113712c:	1007883a 	mov	r3,r2
81137130:	d0a09903 	ldbu	r2,-32156(gp)
81137134:	1884703a 	and	r2,r3,r2
81137138:	d0a09905 	stb	r2,-32156(gp)
    }
}
8113713c:	0001883a 	nop
81137140:	e037883a 	mov	sp,fp
81137144:	df000017 	ldw	fp,0(sp)
81137148:	dec00104 	addi	sp,sp,4
8113714c:	f800283a 	ret

81137150 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
81137150:	defffb04 	addi	sp,sp,-20
81137154:	de00012e 	bgeu	sp,et,8113715c <OS_FlagInit+0xc>
81137158:	003b68fa 	trap	3
8113715c:	dfc00415 	stw	ra,16(sp)
81137160:	df000315 	stw	fp,12(sp)
81137164:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
81137168:	01421004 	movi	r5,2112
8113716c:	012045b4 	movhi	r4,33046
81137170:	21061b04 	addi	r4,r4,6252
81137174:	113527c0 	call	8113527c <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
81137178:	00a045b4 	movhi	r2,33046
8113717c:	10861b04 	addi	r2,r2,6252
81137180:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
81137184:	00a045b4 	movhi	r2,33046
81137188:	10862604 	addi	r2,r2,6296
8113718c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81137190:	e03ffd0d 	sth	zero,-12(fp)
81137194:	00001306 	br	811371e4 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81137198:	e0bffe17 	ldw	r2,-8(fp)
8113719c:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
811371a0:	e0bffe17 	ldw	r2,-8(fp)
811371a4:	e0ffff17 	ldw	r3,-4(fp)
811371a8:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
811371ac:	e0bffe17 	ldw	r2,-8(fp)
811371b0:	00c00fc4 	movi	r3,63
811371b4:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
811371b8:	e0bffe17 	ldw	r2,-8(fp)
811371bc:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
811371c0:	e0bffe17 	ldw	r2,-8(fp)
811371c4:	10800b04 	addi	r2,r2,44
811371c8:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
811371cc:	e0bfff17 	ldw	r2,-4(fp)
811371d0:	10800b04 	addi	r2,r2,44
811371d4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
811371d8:	e0bffd0b 	ldhu	r2,-12(fp)
811371dc:	10800044 	addi	r2,r2,1
811371e0:	e0bffd0d 	sth	r2,-12(fp)
811371e4:	e0bffd0b 	ldhu	r2,-12(fp)
811371e8:	10800bf0 	cmpltui	r2,r2,47
811371ec:	103fea1e 	bne	r2,zero,81137198 <__reset+0xfb117198>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
811371f0:	e0bffe17 	ldw	r2,-8(fp)
811371f4:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
811371f8:	e0bffe17 	ldw	r2,-8(fp)
811371fc:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81137200:	e0bffe17 	ldw	r2,-8(fp)
81137204:	00c00fc4 	movi	r3,63
81137208:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113720c:	e0bffe17 	ldw	r2,-8(fp)
81137210:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
81137214:	00a045b4 	movhi	r2,33046
81137218:	10861b04 	addi	r2,r2,6252
8113721c:	d0a0a115 	stw	r2,-32124(gp)
#endif
}
81137220:	0001883a 	nop
81137224:	e037883a 	mov	sp,fp
81137228:	dfc00117 	ldw	ra,4(sp)
8113722c:	df000017 	ldw	fp,0(sp)
81137230:	dec00204 	addi	sp,sp,8
81137234:	f800283a 	ret

81137238 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
81137238:	defffa04 	addi	sp,sp,-24
8113723c:	de00012e 	bgeu	sp,et,81137244 <OS_FlagTaskRdy+0xc>
81137240:	003b68fa 	trap	3
81137244:	dfc00515 	stw	ra,20(sp)
81137248:	df000415 	stw	fp,16(sp)
8113724c:	df000404 	addi	fp,sp,16
81137250:	e13ffe15 	stw	r4,-8(fp)
81137254:	2805883a 	mov	r2,r5
81137258:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113725c:	e0bffe17 	ldw	r2,-8(fp)
81137260:	10800217 	ldw	r2,8(r2)
81137264:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
81137268:	e0bffd17 	ldw	r2,-12(fp)
8113726c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
81137270:	e0bffd17 	ldw	r2,-12(fp)
81137274:	e0ffff0b 	ldhu	r3,-4(fp)
81137278:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113727c:	e0bffd17 	ldw	r2,-12(fp)
81137280:	10c00c03 	ldbu	r3,48(r2)
81137284:	00bff7c4 	movi	r2,-33
81137288:	1884703a 	and	r2,r3,r2
8113728c:	1007883a 	mov	r3,r2
81137290:	e0bffd17 	ldw	r2,-12(fp)
81137294:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81137298:	e0bffd17 	ldw	r2,-12(fp)
8113729c:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
811372a0:	e0bffd17 	ldw	r2,-12(fp)
811372a4:	10800c03 	ldbu	r2,48(r2)
811372a8:	10803fcc 	andi	r2,r2,255
811372ac:	1000181e 	bne	r2,zero,81137310 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
811372b0:	e0bffd17 	ldw	r2,-12(fp)
811372b4:	10c00d83 	ldbu	r3,54(r2)
811372b8:	d0a09903 	ldbu	r2,-32156(gp)
811372bc:	1884b03a 	or	r2,r3,r2
811372c0:	d0a09905 	stb	r2,-32156(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811372c4:	e0bffd17 	ldw	r2,-12(fp)
811372c8:	10800d03 	ldbu	r2,52(r2)
811372cc:	10c03fcc 	andi	r3,r2,255
811372d0:	e0bffd17 	ldw	r2,-12(fp)
811372d4:	10800d03 	ldbu	r2,52(r2)
811372d8:	11003fcc 	andi	r4,r2,255
811372dc:	d0a09944 	addi	r2,gp,-32155
811372e0:	2085883a 	add	r2,r4,r2
811372e4:	11000003 	ldbu	r4,0(r2)
811372e8:	e0bffd17 	ldw	r2,-12(fp)
811372ec:	10800d43 	ldbu	r2,53(r2)
811372f0:	2084b03a 	or	r2,r4,r2
811372f4:	1009883a 	mov	r4,r2
811372f8:	d0a09944 	addi	r2,gp,-32155
811372fc:	1885883a 	add	r2,r3,r2
81137300:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
81137304:	00800044 	movi	r2,1
81137308:	e0bffc05 	stb	r2,-16(fp)
8113730c:	00000106 	br	81137314 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81137310:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
81137314:	e13ffe17 	ldw	r4,-8(fp)
81137318:	11373340 	call	81137334 <OS_FlagUnlink>
    return (sched);
8113731c:	e0bffc03 	ldbu	r2,-16(fp)
}
81137320:	e037883a 	mov	sp,fp
81137324:	dfc00117 	ldw	ra,4(sp)
81137328:	df000017 	ldw	fp,0(sp)
8113732c:	dec00204 	addi	sp,sp,8
81137330:	f800283a 	ret

81137334 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
81137334:	defffa04 	addi	sp,sp,-24
81137338:	de00012e 	bgeu	sp,et,81137340 <OS_FlagUnlink+0xc>
8113733c:	003b68fa 	trap	3
81137340:	df000515 	stw	fp,20(sp)
81137344:	df000504 	addi	fp,sp,20
81137348:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113734c:	e0bfff17 	ldw	r2,-4(fp)
81137350:	10800117 	ldw	r2,4(r2)
81137354:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81137358:	e0bfff17 	ldw	r2,-4(fp)
8113735c:	10800017 	ldw	r2,0(r2)
81137360:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
81137364:	e0bffb17 	ldw	r2,-20(fp)
81137368:	10000b1e 	bne	r2,zero,81137398 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113736c:	e0bfff17 	ldw	r2,-4(fp)
81137370:	10800317 	ldw	r2,12(r2)
81137374:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
81137378:	e0bffd17 	ldw	r2,-12(fp)
8113737c:	e0fffc17 	ldw	r3,-16(fp)
81137380:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
81137384:	e0bffc17 	ldw	r2,-16(fp)
81137388:	10000b26 	beq	r2,zero,811373b8 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113738c:	e0bffc17 	ldw	r2,-16(fp)
81137390:	10000115 	stw	zero,4(r2)
81137394:	00000806 	br	811373b8 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81137398:	e0bffb17 	ldw	r2,-20(fp)
8113739c:	e0fffc17 	ldw	r3,-16(fp)
811373a0:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
811373a4:	e0bffc17 	ldw	r2,-16(fp)
811373a8:	10000326 	beq	r2,zero,811373b8 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
811373ac:	e0bffc17 	ldw	r2,-16(fp)
811373b0:	e0fffb17 	ldw	r3,-20(fp)
811373b4:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
811373b8:	e0bfff17 	ldw	r2,-4(fp)
811373bc:	10800217 	ldw	r2,8(r2)
811373c0:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
811373c4:	e0bffe17 	ldw	r2,-8(fp)
811373c8:	10000a15 	stw	zero,40(r2)
#endif
}
811373cc:	0001883a 	nop
811373d0:	e037883a 	mov	sp,fp
811373d4:	df000017 	ldw	fp,0(sp)
811373d8:	dec00104 	addi	sp,sp,4
811373dc:	f800283a 	ret

811373e0 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
811373e0:	defff404 	addi	sp,sp,-48
811373e4:	de00012e 	bgeu	sp,et,811373ec <OSMemCreate+0xc>
811373e8:	003b68fa 	trap	3
811373ec:	df000b15 	stw	fp,44(sp)
811373f0:	df000b04 	addi	fp,sp,44
811373f4:	e13ffc15 	stw	r4,-16(fp)
811373f8:	e17ffd15 	stw	r5,-12(fp)
811373fc:	e1bffe15 	stw	r6,-8(fp)
81137400:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81137404:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81137408:	e0bfff17 	ldw	r2,-4(fp)
8113740c:	1000021e 	bne	r2,zero,81137418 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81137410:	0005883a 	mov	r2,zero
81137414:	00006506 	br	811375ac <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81137418:	e0bffc17 	ldw	r2,-16(fp)
8113741c:	1000051e 	bne	r2,zero,81137434 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81137420:	e0bfff17 	ldw	r2,-4(fp)
81137424:	00c01884 	movi	r3,98
81137428:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113742c:	0005883a 	mov	r2,zero
81137430:	00005e06 	br	811375ac <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
81137434:	e0bffc17 	ldw	r2,-16(fp)
81137438:	108000cc 	andi	r2,r2,3
8113743c:	10000526 	beq	r2,zero,81137454 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81137440:	e0bfff17 	ldw	r2,-4(fp)
81137444:	00c01884 	movi	r3,98
81137448:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113744c:	0005883a 	mov	r2,zero
81137450:	00005606 	br	811375ac <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
81137454:	e0bffd17 	ldw	r2,-12(fp)
81137458:	108000a8 	cmpgeui	r2,r2,2
8113745c:	1000051e 	bne	r2,zero,81137474 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
81137460:	e0bfff17 	ldw	r2,-4(fp)
81137464:	00c016c4 	movi	r3,91
81137468:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113746c:	0005883a 	mov	r2,zero
81137470:	00004e06 	br	811375ac <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
81137474:	e0bffe17 	ldw	r2,-8(fp)
81137478:	10800128 	cmpgeui	r2,r2,4
8113747c:	1000051e 	bne	r2,zero,81137494 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
81137480:	e0bfff17 	ldw	r2,-4(fp)
81137484:	00c01704 	movi	r3,92
81137488:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113748c:	0005883a 	mov	r2,zero
81137490:	00004606 	br	811375ac <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137494:	0005303a 	rdctl	r2,status
81137498:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113749c:	e0fffb17 	ldw	r3,-20(fp)
811374a0:	00bfff84 	movi	r2,-2
811374a4:	1884703a 	and	r2,r3,r2
811374a8:	1001703a 	wrctl	status,r2
  
  return context;
811374ac:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811374b0:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
811374b4:	d0a09617 	ldw	r2,-32168(gp)
811374b8:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
811374bc:	d0a09617 	ldw	r2,-32168(gp)
811374c0:	10000326 	beq	r2,zero,811374d0 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
811374c4:	d0a09617 	ldw	r2,-32168(gp)
811374c8:	10800117 	ldw	r2,4(r2)
811374cc:	d0a09615 	stw	r2,-32168(gp)
811374d0:	e0bff817 	ldw	r2,-32(fp)
811374d4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811374d8:	e0bff917 	ldw	r2,-28(fp)
811374dc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
811374e0:	e0bffa17 	ldw	r2,-24(fp)
811374e4:	1000051e 	bne	r2,zero,811374fc <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
811374e8:	e0bfff17 	ldw	r2,-4(fp)
811374ec:	00c01684 	movi	r3,90
811374f0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811374f4:	0005883a 	mov	r2,zero
811374f8:	00002c06 	br	811375ac <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
811374fc:	e0bffc17 	ldw	r2,-16(fp)
81137500:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81137504:	e0fffc17 	ldw	r3,-16(fp)
81137508:	e0bffe17 	ldw	r2,-8(fp)
8113750c:	1885883a 	add	r2,r3,r2
81137510:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81137514:	e03ff715 	stw	zero,-36(fp)
81137518:	00000c06 	br	8113754c <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113751c:	e0bff617 	ldw	r2,-40(fp)
81137520:	e0fff517 	ldw	r3,-44(fp)
81137524:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
81137528:	e0bff517 	ldw	r2,-44(fp)
8113752c:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
81137530:	e0fff517 	ldw	r3,-44(fp)
81137534:	e0bffe17 	ldw	r2,-8(fp)
81137538:	1885883a 	add	r2,r3,r2
8113753c:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
81137540:	e0bff717 	ldw	r2,-36(fp)
81137544:	10800044 	addi	r2,r2,1
81137548:	e0bff715 	stw	r2,-36(fp)
8113754c:	e0bffd17 	ldw	r2,-12(fp)
81137550:	10bfffc4 	addi	r2,r2,-1
81137554:	e0fff717 	ldw	r3,-36(fp)
81137558:	18bff036 	bltu	r3,r2,8113751c <__reset+0xfb11751c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113755c:	e0bff617 	ldw	r2,-40(fp)
81137560:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
81137564:	e0bffa17 	ldw	r2,-24(fp)
81137568:	e0fffc17 	ldw	r3,-16(fp)
8113756c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
81137570:	e0bffa17 	ldw	r2,-24(fp)
81137574:	e0fffc17 	ldw	r3,-16(fp)
81137578:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113757c:	e0bffa17 	ldw	r2,-24(fp)
81137580:	e0fffd17 	ldw	r3,-12(fp)
81137584:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81137588:	e0bffa17 	ldw	r2,-24(fp)
8113758c:	e0fffd17 	ldw	r3,-12(fp)
81137590:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81137594:	e0bffa17 	ldw	r2,-24(fp)
81137598:	e0fffe17 	ldw	r3,-8(fp)
8113759c:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
811375a0:	e0bfff17 	ldw	r2,-4(fp)
811375a4:	10000005 	stb	zero,0(r2)
    return (pmem);
811375a8:	e0bffa17 	ldw	r2,-24(fp)
}
811375ac:	e037883a 	mov	sp,fp
811375b0:	df000017 	ldw	fp,0(sp)
811375b4:	dec00104 	addi	sp,sp,4
811375b8:	f800283a 	ret

811375bc <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
811375bc:	defff804 	addi	sp,sp,-32
811375c0:	de00012e 	bgeu	sp,et,811375c8 <OSMemGet+0xc>
811375c4:	003b68fa 	trap	3
811375c8:	df000715 	stw	fp,28(sp)
811375cc:	df000704 	addi	fp,sp,28
811375d0:	e13ffe15 	stw	r4,-8(fp)
811375d4:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811375d8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811375dc:	e0bfff17 	ldw	r2,-4(fp)
811375e0:	1000021e 	bne	r2,zero,811375ec <OSMemGet+0x30>
        return ((void *)0);
811375e4:	0005883a 	mov	r2,zero
811375e8:	00002e06 	br	811376a4 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
811375ec:	e0bffe17 	ldw	r2,-8(fp)
811375f0:	1000051e 	bne	r2,zero,81137608 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
811375f4:	e0bfff17 	ldw	r2,-4(fp)
811375f8:	00c01804 	movi	r3,96
811375fc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137600:	0005883a 	mov	r2,zero
81137604:	00002706 	br	811376a4 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137608:	0005303a 	rdctl	r2,status
8113760c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137610:	e0fffd17 	ldw	r3,-12(fp)
81137614:	00bfff84 	movi	r2,-2
81137618:	1884703a 	and	r2,r3,r2
8113761c:	1001703a 	wrctl	status,r2
  
  return context;
81137620:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81137624:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
81137628:	e0bffe17 	ldw	r2,-8(fp)
8113762c:	10800417 	ldw	r2,16(r2)
81137630:	10001426 	beq	r2,zero,81137684 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
81137634:	e0bffe17 	ldw	r2,-8(fp)
81137638:	10800117 	ldw	r2,4(r2)
8113763c:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
81137640:	e0bffb17 	ldw	r2,-20(fp)
81137644:	10c00017 	ldw	r3,0(r2)
81137648:	e0bffe17 	ldw	r2,-8(fp)
8113764c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
81137650:	e0bffe17 	ldw	r2,-8(fp)
81137654:	10800417 	ldw	r2,16(r2)
81137658:	10ffffc4 	addi	r3,r2,-1
8113765c:	e0bffe17 	ldw	r2,-8(fp)
81137660:	10c00415 	stw	r3,16(r2)
81137664:	e0bff917 	ldw	r2,-28(fp)
81137668:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113766c:	e0bffa17 	ldw	r2,-24(fp)
81137670:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
81137674:	e0bfff17 	ldw	r2,-4(fp)
81137678:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113767c:	e0bffb17 	ldw	r2,-20(fp)
81137680:	00000806 	br	811376a4 <OSMemGet+0xe8>
81137684:	e0bff917 	ldw	r2,-28(fp)
81137688:	e0bffc15 	stw	r2,-16(fp)
8113768c:	e0bffc17 	ldw	r2,-16(fp)
81137690:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81137694:	e0bfff17 	ldw	r2,-4(fp)
81137698:	00c01744 	movi	r3,93
8113769c:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
811376a0:	0005883a 	mov	r2,zero
}
811376a4:	e037883a 	mov	sp,fp
811376a8:	df000017 	ldw	fp,0(sp)
811376ac:	dec00104 	addi	sp,sp,4
811376b0:	f800283a 	ret

811376b4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
811376b4:	defff704 	addi	sp,sp,-36
811376b8:	de00012e 	bgeu	sp,et,811376c0 <OSMemNameGet+0xc>
811376bc:	003b68fa 	trap	3
811376c0:	dfc00815 	stw	ra,32(sp)
811376c4:	df000715 	stw	fp,28(sp)
811376c8:	df000704 	addi	fp,sp,28
811376cc:	e13ffd15 	stw	r4,-12(fp)
811376d0:	e17ffe15 	stw	r5,-8(fp)
811376d4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811376d8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811376dc:	e0bfff17 	ldw	r2,-4(fp)
811376e0:	1000021e 	bne	r2,zero,811376ec <OSMemNameGet+0x38>
        return (0);
811376e4:	0005883a 	mov	r2,zero
811376e8:	00002b06 	br	81137798 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
811376ec:	e0bffd17 	ldw	r2,-12(fp)
811376f0:	1000051e 	bne	r2,zero,81137708 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
811376f4:	e0bfff17 	ldw	r2,-4(fp)
811376f8:	00c01804 	movi	r3,96
811376fc:	10c00005 	stb	r3,0(r2)
        return (0);
81137700:	0005883a 	mov	r2,zero
81137704:	00002406 	br	81137798 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81137708:	e0bffe17 	ldw	r2,-8(fp)
8113770c:	1000051e 	bne	r2,zero,81137724 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81137710:	e0bfff17 	ldw	r2,-4(fp)
81137714:	00c00304 	movi	r3,12
81137718:	10c00005 	stb	r3,0(r2)
        return (0);
8113771c:	0005883a 	mov	r2,zero
81137720:	00001d06 	br	81137798 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81137724:	d0a09c03 	ldbu	r2,-32144(gp)
81137728:	10803fcc 	andi	r2,r2,255
8113772c:	10000526 	beq	r2,zero,81137744 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81137730:	e0bfff17 	ldw	r2,-4(fp)
81137734:	00c00444 	movi	r3,17
81137738:	10c00005 	stb	r3,0(r2)
        return (0);
8113773c:	0005883a 	mov	r2,zero
81137740:	00001506 	br	81137798 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137744:	0005303a 	rdctl	r2,status
81137748:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113774c:	e0fffb17 	ldw	r3,-20(fp)
81137750:	00bfff84 	movi	r2,-2
81137754:	1884703a 	and	r2,r3,r2
81137758:	1001703a 	wrctl	status,r2
  
  return context;
8113775c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
81137760:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
81137764:	e0bffd17 	ldw	r2,-12(fp)
81137768:	10800504 	addi	r2,r2,20
8113776c:	100b883a 	mov	r5,r2
81137770:	e13ffe17 	ldw	r4,-8(fp)
81137774:	113549c0 	call	8113549c <OS_StrCopy>
81137778:	e0bffa05 	stb	r2,-24(fp)
8113777c:	e0bff917 	ldw	r2,-28(fp)
81137780:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137784:	e0bffc17 	ldw	r2,-16(fp)
81137788:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113778c:	e0bfff17 	ldw	r2,-4(fp)
81137790:	10000005 	stb	zero,0(r2)
    return (len);
81137794:	e0bffa03 	ldbu	r2,-24(fp)
}
81137798:	e037883a 	mov	sp,fp
8113779c:	dfc00117 	ldw	ra,4(sp)
811377a0:	df000017 	ldw	fp,0(sp)
811377a4:	dec00204 	addi	sp,sp,8
811377a8:	f800283a 	ret

811377ac <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
811377ac:	defff604 	addi	sp,sp,-40
811377b0:	de00012e 	bgeu	sp,et,811377b8 <OSMemNameSet+0xc>
811377b4:	003b68fa 	trap	3
811377b8:	dfc00915 	stw	ra,36(sp)
811377bc:	df000815 	stw	fp,32(sp)
811377c0:	df000804 	addi	fp,sp,32
811377c4:	e13ffd15 	stw	r4,-12(fp)
811377c8:	e17ffe15 	stw	r5,-8(fp)
811377cc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811377d0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811377d4:	e0bfff17 	ldw	r2,-4(fp)
811377d8:	10003526 	beq	r2,zero,811378b0 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
811377dc:	e0bffd17 	ldw	r2,-12(fp)
811377e0:	1000041e 	bne	r2,zero,811377f4 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
811377e4:	e0bfff17 	ldw	r2,-4(fp)
811377e8:	00c01804 	movi	r3,96
811377ec:	10c00005 	stb	r3,0(r2)
        return;
811377f0:	00003006 	br	811378b4 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811377f4:	e0bffe17 	ldw	r2,-8(fp)
811377f8:	1000041e 	bne	r2,zero,8113780c <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
811377fc:	e0bfff17 	ldw	r2,-4(fp)
81137800:	00c00304 	movi	r3,12
81137804:	10c00005 	stb	r3,0(r2)
        return;
81137808:	00002a06 	br	811378b4 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113780c:	d0a09c03 	ldbu	r2,-32144(gp)
81137810:	10803fcc 	andi	r2,r2,255
81137814:	10000426 	beq	r2,zero,81137828 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81137818:	e0bfff17 	ldw	r2,-4(fp)
8113781c:	00c00484 	movi	r3,18
81137820:	10c00005 	stb	r3,0(r2)
        return;
81137824:	00002306 	br	811378b4 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137828:	0005303a 	rdctl	r2,status
8113782c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137830:	e0fffc17 	ldw	r3,-16(fp)
81137834:	00bfff84 	movi	r2,-2
81137838:	1884703a 	and	r2,r3,r2
8113783c:	1001703a 	wrctl	status,r2
  
  return context;
81137840:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137844:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81137848:	e13ffe17 	ldw	r4,-8(fp)
8113784c:	11355180 	call	81135518 <OS_StrLen>
81137850:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
81137854:	e0bffa03 	ldbu	r2,-24(fp)
81137858:	10800830 	cmpltui	r2,r2,32
8113785c:	1000081e 	bne	r2,zero,81137880 <OSMemNameSet+0xd4>
81137860:	e0bff817 	ldw	r2,-32(fp)
81137864:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137868:	e0bff917 	ldw	r2,-28(fp)
8113786c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
81137870:	e0bfff17 	ldw	r2,-4(fp)
81137874:	00c018c4 	movi	r3,99
81137878:	10c00005 	stb	r3,0(r2)
        return;
8113787c:	00000d06 	br	811378b4 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
81137880:	e0bffd17 	ldw	r2,-12(fp)
81137884:	10800504 	addi	r2,r2,20
81137888:	e17ffe17 	ldw	r5,-8(fp)
8113788c:	1009883a 	mov	r4,r2
81137890:	113549c0 	call	8113549c <OS_StrCopy>
81137894:	e0bff817 	ldw	r2,-32(fp)
81137898:	e0bffb15 	stw	r2,-20(fp)
8113789c:	e0bffb17 	ldw	r2,-20(fp)
811378a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811378a4:	e0bfff17 	ldw	r2,-4(fp)
811378a8:	10000005 	stb	zero,0(r2)
811378ac:	00000106 	br	811378b4 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811378b0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
811378b4:	e037883a 	mov	sp,fp
811378b8:	dfc00117 	ldw	ra,4(sp)
811378bc:	df000017 	ldw	fp,0(sp)
811378c0:	dec00204 	addi	sp,sp,8
811378c4:	f800283a 	ret

811378c8 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
811378c8:	defff904 	addi	sp,sp,-28
811378cc:	de00012e 	bgeu	sp,et,811378d4 <OSMemPut+0xc>
811378d0:	003b68fa 	trap	3
811378d4:	df000615 	stw	fp,24(sp)
811378d8:	df000604 	addi	fp,sp,24
811378dc:	e13ffe15 	stw	r4,-8(fp)
811378e0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811378e4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
811378e8:	e0bffe17 	ldw	r2,-8(fp)
811378ec:	1000021e 	bne	r2,zero,811378f8 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
811378f0:	00801804 	movi	r2,96
811378f4:	00002806 	br	81137998 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
811378f8:	e0bfff17 	ldw	r2,-4(fp)
811378fc:	1000021e 	bne	r2,zero,81137908 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
81137900:	008017c4 	movi	r2,95
81137904:	00002406 	br	81137998 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137908:	0005303a 	rdctl	r2,status
8113790c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137910:	e0fffd17 	ldw	r3,-12(fp)
81137914:	00bfff84 	movi	r2,-2
81137918:	1884703a 	and	r2,r3,r2
8113791c:	1001703a 	wrctl	status,r2
  
  return context;
81137920:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81137924:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
81137928:	e0bffe17 	ldw	r2,-8(fp)
8113792c:	10c00417 	ldw	r3,16(r2)
81137930:	e0bffe17 	ldw	r2,-8(fp)
81137934:	10800317 	ldw	r2,12(r2)
81137938:	18800636 	bltu	r3,r2,81137954 <OSMemPut+0x8c>
8113793c:	e0bffa17 	ldw	r2,-24(fp)
81137940:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137944:	e0bffb17 	ldw	r2,-20(fp)
81137948:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113794c:	00801784 	movi	r2,94
81137950:	00001106 	br	81137998 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
81137954:	e0bffe17 	ldw	r2,-8(fp)
81137958:	10c00117 	ldw	r3,4(r2)
8113795c:	e0bfff17 	ldw	r2,-4(fp)
81137960:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
81137964:	e0bffe17 	ldw	r2,-8(fp)
81137968:	e0ffff17 	ldw	r3,-4(fp)
8113796c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
81137970:	e0bffe17 	ldw	r2,-8(fp)
81137974:	10800417 	ldw	r2,16(r2)
81137978:	10c00044 	addi	r3,r2,1
8113797c:	e0bffe17 	ldw	r2,-8(fp)
81137980:	10c00415 	stw	r3,16(r2)
81137984:	e0bffa17 	ldw	r2,-24(fp)
81137988:	e0bffc15 	stw	r2,-16(fp)
8113798c:	e0bffc17 	ldw	r2,-16(fp)
81137990:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
81137994:	0005883a 	mov	r2,zero
}
81137998:	e037883a 	mov	sp,fp
8113799c:	df000017 	ldw	fp,0(sp)
811379a0:	dec00104 	addi	sp,sp,4
811379a4:	f800283a 	ret

811379a8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
811379a8:	defffa04 	addi	sp,sp,-24
811379ac:	de00012e 	bgeu	sp,et,811379b4 <OSMemQuery+0xc>
811379b0:	003b68fa 	trap	3
811379b4:	df000515 	stw	fp,20(sp)
811379b8:	df000504 	addi	fp,sp,20
811379bc:	e13ffe15 	stw	r4,-8(fp)
811379c0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811379c4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
811379c8:	e0bffe17 	ldw	r2,-8(fp)
811379cc:	1000021e 	bne	r2,zero,811379d8 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
811379d0:	00801804 	movi	r2,96
811379d4:	00002c06 	br	81137a88 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
811379d8:	e0bfff17 	ldw	r2,-4(fp)
811379dc:	1000021e 	bne	r2,zero,811379e8 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
811379e0:	00801844 	movi	r2,97
811379e4:	00002806 	br	81137a88 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811379e8:	0005303a 	rdctl	r2,status
811379ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811379f0:	e0fffc17 	ldw	r3,-16(fp)
811379f4:	00bfff84 	movi	r2,-2
811379f8:	1884703a 	and	r2,r3,r2
811379fc:	1001703a 	wrctl	status,r2
  
  return context;
81137a00:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81137a04:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
81137a08:	e0bffe17 	ldw	r2,-8(fp)
81137a0c:	10c00017 	ldw	r3,0(r2)
81137a10:	e0bfff17 	ldw	r2,-4(fp)
81137a14:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
81137a18:	e0bffe17 	ldw	r2,-8(fp)
81137a1c:	10c00117 	ldw	r3,4(r2)
81137a20:	e0bfff17 	ldw	r2,-4(fp)
81137a24:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
81137a28:	e0bffe17 	ldw	r2,-8(fp)
81137a2c:	10c00217 	ldw	r3,8(r2)
81137a30:	e0bfff17 	ldw	r2,-4(fp)
81137a34:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
81137a38:	e0bffe17 	ldw	r2,-8(fp)
81137a3c:	10c00317 	ldw	r3,12(r2)
81137a40:	e0bfff17 	ldw	r2,-4(fp)
81137a44:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
81137a48:	e0bffe17 	ldw	r2,-8(fp)
81137a4c:	10c00417 	ldw	r3,16(r2)
81137a50:	e0bfff17 	ldw	r2,-4(fp)
81137a54:	10c00415 	stw	r3,16(r2)
81137a58:	e0bffb17 	ldw	r2,-20(fp)
81137a5c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137a60:	e0bffd17 	ldw	r2,-12(fp)
81137a64:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
81137a68:	e0bfff17 	ldw	r2,-4(fp)
81137a6c:	10c00317 	ldw	r3,12(r2)
81137a70:	e0bfff17 	ldw	r2,-4(fp)
81137a74:	10800417 	ldw	r2,16(r2)
81137a78:	1887c83a 	sub	r3,r3,r2
81137a7c:	e0bfff17 	ldw	r2,-4(fp)
81137a80:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
81137a84:	0005883a 	mov	r2,zero
}
81137a88:	e037883a 	mov	sp,fp
81137a8c:	df000017 	ldw	fp,0(sp)
81137a90:	dec00104 	addi	sp,sp,4
81137a94:	f800283a 	ret

81137a98 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
81137a98:	defffc04 	addi	sp,sp,-16
81137a9c:	de00012e 	bgeu	sp,et,81137aa4 <OS_MemInit+0xc>
81137aa0:	003b68fa 	trap	3
81137aa4:	dfc00315 	stw	ra,12(sp)
81137aa8:	df000215 	stw	fp,8(sp)
81137aac:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
81137ab0:	01430c04 	movi	r5,3120
81137ab4:	012045b4 	movhi	r4,33046
81137ab8:	21089304 	addi	r4,r4,8780
81137abc:	113527c0 	call	8113527c <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
81137ac0:	00a045b4 	movhi	r2,33046
81137ac4:	10889304 	addi	r2,r2,8780
81137ac8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81137acc:	e03fff0d 	sth	zero,-4(fp)
81137ad0:	00001306 	br	81137b20 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
81137ad4:	e0bfff0b 	ldhu	r2,-4(fp)
81137ad8:	10800044 	addi	r2,r2,1
81137adc:	10c00d24 	muli	r3,r2,52
81137ae0:	00a045b4 	movhi	r2,33046
81137ae4:	10889304 	addi	r2,r2,8780
81137ae8:	1887883a 	add	r3,r3,r2
81137aec:	e0bffe17 	ldw	r2,-8(fp)
81137af0:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
81137af4:	e0bffe17 	ldw	r2,-8(fp)
81137af8:	00c00fc4 	movi	r3,63
81137afc:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
81137b00:	e0bffe17 	ldw	r2,-8(fp)
81137b04:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
81137b08:	e0bffe17 	ldw	r2,-8(fp)
81137b0c:	10800d04 	addi	r2,r2,52
81137b10:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81137b14:	e0bfff0b 	ldhu	r2,-4(fp)
81137b18:	10800044 	addi	r2,r2,1
81137b1c:	e0bfff0d 	sth	r2,-4(fp)
81137b20:	e0bfff0b 	ldhu	r2,-4(fp)
81137b24:	10800ef0 	cmpltui	r2,r2,59
81137b28:	103fea1e 	bne	r2,zero,81137ad4 <__reset+0xfb117ad4>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
81137b2c:	e0bffe17 	ldw	r2,-8(fp)
81137b30:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
81137b34:	e0bffe17 	ldw	r2,-8(fp)
81137b38:	00c00fc4 	movi	r3,63
81137b3c:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
81137b40:	e0bffe17 	ldw	r2,-8(fp)
81137b44:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
81137b48:	00a045b4 	movhi	r2,33046
81137b4c:	10889304 	addi	r2,r2,8780
81137b50:	d0a09615 	stw	r2,-32168(gp)
#endif
}
81137b54:	0001883a 	nop
81137b58:	e037883a 	mov	sp,fp
81137b5c:	dfc00117 	ldw	ra,4(sp)
81137b60:	df000017 	ldw	fp,0(sp)
81137b64:	dec00204 	addi	sp,sp,8
81137b68:	f800283a 	ret

81137b6c <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
81137b6c:	defff704 	addi	sp,sp,-36
81137b70:	de00012e 	bgeu	sp,et,81137b78 <OSMutexAccept+0xc>
81137b74:	003b68fa 	trap	3
81137b78:	df000815 	stw	fp,32(sp)
81137b7c:	df000804 	addi	fp,sp,32
81137b80:	e13ffe15 	stw	r4,-8(fp)
81137b84:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81137b88:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
81137b8c:	e0bfff17 	ldw	r2,-4(fp)
81137b90:	1000021e 	bne	r2,zero,81137b9c <OSMutexAccept+0x30>
        return (OS_FALSE);
81137b94:	0005883a 	mov	r2,zero
81137b98:	00005b06 	br	81137d08 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81137b9c:	e0bffe17 	ldw	r2,-8(fp)
81137ba0:	1000051e 	bne	r2,zero,81137bb8 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81137ba4:	e0bfff17 	ldw	r2,-4(fp)
81137ba8:	00c00104 	movi	r3,4
81137bac:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137bb0:	0005883a 	mov	r2,zero
81137bb4:	00005406 	br	81137d08 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
81137bb8:	e0bffe17 	ldw	r2,-8(fp)
81137bbc:	10800003 	ldbu	r2,0(r2)
81137bc0:	10803fcc 	andi	r2,r2,255
81137bc4:	10800120 	cmpeqi	r2,r2,4
81137bc8:	1000051e 	bne	r2,zero,81137be0 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81137bcc:	e0bfff17 	ldw	r2,-4(fp)
81137bd0:	00c00044 	movi	r3,1
81137bd4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137bd8:	0005883a 	mov	r2,zero
81137bdc:	00004a06 	br	81137d08 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
81137be0:	d0a09c03 	ldbu	r2,-32144(gp)
81137be4:	10803fcc 	andi	r2,r2,255
81137be8:	10000526 	beq	r2,zero,81137c00 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
81137bec:	e0bfff17 	ldw	r2,-4(fp)
81137bf0:	00c00084 	movi	r3,2
81137bf4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137bf8:	0005883a 	mov	r2,zero
81137bfc:	00004206 	br	81137d08 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137c00:	0005303a 	rdctl	r2,status
81137c04:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137c08:	e0fffd17 	ldw	r3,-12(fp)
81137c0c:	00bfff84 	movi	r2,-2
81137c10:	1884703a 	and	r2,r3,r2
81137c14:	1001703a 	wrctl	status,r2
  
  return context;
81137c18:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
81137c1c:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
81137c20:	e0bffe17 	ldw	r2,-8(fp)
81137c24:	1080020b 	ldhu	r2,8(r2)
81137c28:	10bfffcc 	andi	r2,r2,65535
81137c2c:	1004d23a 	srli	r2,r2,8
81137c30:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81137c34:	e0bffe17 	ldw	r2,-8(fp)
81137c38:	1080020b 	ldhu	r2,8(r2)
81137c3c:	10bfffcc 	andi	r2,r2,65535
81137c40:	10803fcc 	andi	r2,r2,255
81137c44:	10803fd8 	cmpnei	r2,r2,255
81137c48:	1000281e 	bne	r2,zero,81137cec <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
81137c4c:	e0bffe17 	ldw	r2,-8(fp)
81137c50:	10c0020b 	ldhu	r3,8(r2)
81137c54:	00bfc004 	movi	r2,-256
81137c58:	1884703a 	and	r2,r3,r2
81137c5c:	1007883a 	mov	r3,r2
81137c60:	e0bffe17 	ldw	r2,-8(fp)
81137c64:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
81137c68:	e0bffe17 	ldw	r2,-8(fp)
81137c6c:	10c0020b 	ldhu	r3,8(r2)
81137c70:	d0a09d17 	ldw	r2,-32140(gp)
81137c74:	10800c83 	ldbu	r2,50(r2)
81137c78:	10803fcc 	andi	r2,r2,255
81137c7c:	1884b03a 	or	r2,r3,r2
81137c80:	1007883a 	mov	r3,r2
81137c84:	e0bffe17 	ldw	r2,-8(fp)
81137c88:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
81137c8c:	d0e09d17 	ldw	r3,-32140(gp)
81137c90:	e0bffe17 	ldw	r2,-8(fp)
81137c94:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
81137c98:	d0a09d17 	ldw	r2,-32140(gp)
81137c9c:	10800c83 	ldbu	r2,50(r2)
81137ca0:	10803fcc 	andi	r2,r2,255
81137ca4:	e0fffa03 	ldbu	r3,-24(fp)
81137ca8:	18800836 	bltu	r3,r2,81137ccc <OSMutexAccept+0x160>
81137cac:	e0bff817 	ldw	r2,-32(fp)
81137cb0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137cb4:	e0bff917 	ldw	r2,-28(fp)
81137cb8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
81137cbc:	e0bfff17 	ldw	r2,-4(fp)
81137cc0:	00c01e04 	movi	r3,120
81137cc4:	10c00005 	stb	r3,0(r2)
81137cc8:	00000606 	br	81137ce4 <OSMutexAccept+0x178>
81137ccc:	e0bff817 	ldw	r2,-32(fp)
81137cd0:	e0bffb15 	stw	r2,-20(fp)
81137cd4:	e0bffb17 	ldw	r2,-20(fp)
81137cd8:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81137cdc:	e0bfff17 	ldw	r2,-4(fp)
81137ce0:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
81137ce4:	00800044 	movi	r2,1
81137ce8:	00000706 	br	81137d08 <OSMutexAccept+0x19c>
81137cec:	e0bff817 	ldw	r2,-32(fp)
81137cf0:	e0bffc15 	stw	r2,-16(fp)
81137cf4:	e0bffc17 	ldw	r2,-16(fp)
81137cf8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81137cfc:	e0bfff17 	ldw	r2,-4(fp)
81137d00:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
81137d04:	0005883a 	mov	r2,zero
}
81137d08:	e037883a 	mov	sp,fp
81137d0c:	df000017 	ldw	fp,0(sp)
81137d10:	dec00104 	addi	sp,sp,4
81137d14:	f800283a 	ret

81137d18 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
81137d18:	defff604 	addi	sp,sp,-40
81137d1c:	de00012e 	bgeu	sp,et,81137d24 <OSMutexCreate+0xc>
81137d20:	003b68fa 	trap	3
81137d24:	dfc00915 	stw	ra,36(sp)
81137d28:	df000815 	stw	fp,32(sp)
81137d2c:	df000804 	addi	fp,sp,32
81137d30:	2005883a 	mov	r2,r4
81137d34:	e17fff15 	stw	r5,-4(fp)
81137d38:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137d3c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81137d40:	e0bfff17 	ldw	r2,-4(fp)
81137d44:	1000021e 	bne	r2,zero,81137d50 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
81137d48:	0005883a 	mov	r2,zero
81137d4c:	00006106 	br	81137ed4 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
81137d50:	e0bffe03 	ldbu	r2,-8(fp)
81137d54:	10800ab0 	cmpltui	r2,r2,42
81137d58:	1000051e 	bne	r2,zero,81137d70 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
81137d5c:	e0bfff17 	ldw	r2,-4(fp)
81137d60:	00c00a84 	movi	r3,42
81137d64:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81137d68:	0005883a 	mov	r2,zero
81137d6c:	00005906 	br	81137ed4 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81137d70:	d0a09c03 	ldbu	r2,-32144(gp)
81137d74:	10803fcc 	andi	r2,r2,255
81137d78:	10000526 	beq	r2,zero,81137d90 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
81137d7c:	e0bfff17 	ldw	r2,-4(fp)
81137d80:	00c00404 	movi	r3,16
81137d84:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81137d88:	0005883a 	mov	r2,zero
81137d8c:	00005106 	br	81137ed4 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137d90:	0005303a 	rdctl	r2,status
81137d94:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137d98:	e0fffd17 	ldw	r3,-12(fp)
81137d9c:	00bfff84 	movi	r2,-2
81137da0:	1884703a 	and	r2,r3,r2
81137da4:	1001703a 	wrctl	status,r2
  
  return context;
81137da8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81137dac:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
81137db0:	e0fffe03 	ldbu	r3,-8(fp)
81137db4:	00a045b4 	movhi	r2,33046
81137db8:	109e0d04 	addi	r2,r2,30772
81137dbc:	18c7883a 	add	r3,r3,r3
81137dc0:	18c7883a 	add	r3,r3,r3
81137dc4:	10c5883a 	add	r2,r2,r3
81137dc8:	10800017 	ldw	r2,0(r2)
81137dcc:	10000926 	beq	r2,zero,81137df4 <OSMutexCreate+0xdc>
81137dd0:	e0bff817 	ldw	r2,-32(fp)
81137dd4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137dd8:	e0bff917 	ldw	r2,-28(fp)
81137ddc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
81137de0:	e0bfff17 	ldw	r2,-4(fp)
81137de4:	00c00a04 	movi	r3,40
81137de8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81137dec:	0005883a 	mov	r2,zero
81137df0:	00003806 	br	81137ed4 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
81137df4:	e0fffe03 	ldbu	r3,-8(fp)
81137df8:	00a045b4 	movhi	r2,33046
81137dfc:	109e0d04 	addi	r2,r2,30772
81137e00:	18c7883a 	add	r3,r3,r3
81137e04:	18c7883a 	add	r3,r3,r3
81137e08:	10c5883a 	add	r2,r2,r3
81137e0c:	00c00044 	movi	r3,1
81137e10:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
81137e14:	d0a09b17 	ldw	r2,-32148(gp)
81137e18:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
81137e1c:	e0bffb17 	ldw	r2,-20(fp)
81137e20:	1000101e 	bne	r2,zero,81137e64 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
81137e24:	e0fffe03 	ldbu	r3,-8(fp)
81137e28:	00a045b4 	movhi	r2,33046
81137e2c:	109e0d04 	addi	r2,r2,30772
81137e30:	18c7883a 	add	r3,r3,r3
81137e34:	18c7883a 	add	r3,r3,r3
81137e38:	10c5883a 	add	r2,r2,r3
81137e3c:	10000015 	stw	zero,0(r2)
81137e40:	e0bff817 	ldw	r2,-32(fp)
81137e44:	e0bffa15 	stw	r2,-24(fp)
81137e48:	e0bffa17 	ldw	r2,-24(fp)
81137e4c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
81137e50:	e0bfff17 	ldw	r2,-4(fp)
81137e54:	00c00104 	movi	r3,4
81137e58:	10c00005 	stb	r3,0(r2)
        return (pevent);
81137e5c:	e0bffb17 	ldw	r2,-20(fp)
81137e60:	00001c06 	br	81137ed4 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
81137e64:	d0a09b17 	ldw	r2,-32148(gp)
81137e68:	10800117 	ldw	r2,4(r2)
81137e6c:	d0a09b15 	stw	r2,-32148(gp)
81137e70:	e0bff817 	ldw	r2,-32(fp)
81137e74:	e0bffc15 	stw	r2,-16(fp)
81137e78:	e0bffc17 	ldw	r2,-16(fp)
81137e7c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
81137e80:	e0bffb17 	ldw	r2,-20(fp)
81137e84:	00c00104 	movi	r3,4
81137e88:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
81137e8c:	e0bffe03 	ldbu	r2,-8(fp)
81137e90:	1004923a 	slli	r2,r2,8
81137e94:	10803fd4 	ori	r2,r2,255
81137e98:	1007883a 	mov	r3,r2
81137e9c:	e0bffb17 	ldw	r2,-20(fp)
81137ea0:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
81137ea4:	e0bffb17 	ldw	r2,-20(fp)
81137ea8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
81137eac:	e0bffb17 	ldw	r2,-20(fp)
81137eb0:	00c00fc4 	movi	r3,63
81137eb4:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
81137eb8:	e0bffb17 	ldw	r2,-20(fp)
81137ebc:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
81137ec0:	e13ffb17 	ldw	r4,-20(fp)
81137ec4:	1134e640 	call	81134e64 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
81137ec8:	e0bfff17 	ldw	r2,-4(fp)
81137ecc:	10000005 	stb	zero,0(r2)
    return (pevent);
81137ed0:	e0bffb17 	ldw	r2,-20(fp)
}
81137ed4:	e037883a 	mov	sp,fp
81137ed8:	dfc00117 	ldw	ra,4(sp)
81137edc:	df000017 	ldw	fp,0(sp)
81137ee0:	dec00204 	addi	sp,sp,8
81137ee4:	f800283a 	ret

81137ee8 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81137ee8:	defff004 	addi	sp,sp,-64
81137eec:	de00012e 	bgeu	sp,et,81137ef4 <OSMutexDel+0xc>
81137ef0:	003b68fa 	trap	3
81137ef4:	dfc00f15 	stw	ra,60(sp)
81137ef8:	df000e15 	stw	fp,56(sp)
81137efc:	df000e04 	addi	fp,sp,56
81137f00:	e13ffd15 	stw	r4,-12(fp)
81137f04:	2805883a 	mov	r2,r5
81137f08:	e1bfff15 	stw	r6,-4(fp)
81137f0c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137f10:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81137f14:	e0bfff17 	ldw	r2,-4(fp)
81137f18:	1000021e 	bne	r2,zero,81137f24 <OSMutexDel+0x3c>
        return (pevent);
81137f1c:	e0bffd17 	ldw	r2,-12(fp)
81137f20:	0000ad06 	br	811381d8 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137f24:	e0bffd17 	ldw	r2,-12(fp)
81137f28:	1000051e 	bne	r2,zero,81137f40 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81137f2c:	e0bfff17 	ldw	r2,-4(fp)
81137f30:	00c00104 	movi	r3,4
81137f34:	10c00005 	stb	r3,0(r2)
        return (pevent);
81137f38:	e0bffd17 	ldw	r2,-12(fp)
81137f3c:	0000a606 	br	811381d8 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81137f40:	e0bffd17 	ldw	r2,-12(fp)
81137f44:	10800003 	ldbu	r2,0(r2)
81137f48:	10803fcc 	andi	r2,r2,255
81137f4c:	10800120 	cmpeqi	r2,r2,4
81137f50:	1000051e 	bne	r2,zero,81137f68 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81137f54:	e0bfff17 	ldw	r2,-4(fp)
81137f58:	00c00044 	movi	r3,1
81137f5c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81137f60:	e0bffd17 	ldw	r2,-12(fp)
81137f64:	00009c06 	br	811381d8 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81137f68:	d0a09c03 	ldbu	r2,-32144(gp)
81137f6c:	10803fcc 	andi	r2,r2,255
81137f70:	10000526 	beq	r2,zero,81137f88 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
81137f74:	e0bfff17 	ldw	r2,-4(fp)
81137f78:	00c003c4 	movi	r3,15
81137f7c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81137f80:	e0bffd17 	ldw	r2,-12(fp)
81137f84:	00009406 	br	811381d8 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137f88:	0005303a 	rdctl	r2,status
81137f8c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137f90:	e0fffc17 	ldw	r3,-16(fp)
81137f94:	00bfff84 	movi	r2,-2
81137f98:	1884703a 	and	r2,r3,r2
81137f9c:	1001703a 	wrctl	status,r2
  
  return context;
81137fa0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137fa4:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
81137fa8:	e0bffd17 	ldw	r2,-12(fp)
81137fac:	10800283 	ldbu	r2,10(r2)
81137fb0:	10803fcc 	andi	r2,r2,255
81137fb4:	10000326 	beq	r2,zero,81137fc4 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81137fb8:	00800044 	movi	r2,1
81137fbc:	e0bff205 	stb	r2,-56(fp)
81137fc0:	00000106 	br	81137fc8 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81137fc4:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
81137fc8:	e0bffe03 	ldbu	r2,-8(fp)
81137fcc:	10000326 	beq	r2,zero,81137fdc <OSMutexDel+0xf4>
81137fd0:	10800060 	cmpeqi	r2,r2,1
81137fd4:	10002f1e 	bne	r2,zero,81138094 <OSMutexDel+0x1ac>
81137fd8:	00007406 	br	811381ac <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
81137fdc:	e0bff203 	ldbu	r2,-56(fp)
81137fe0:	1000221e 	bne	r2,zero,8113806c <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81137fe4:	e0bffd17 	ldw	r2,-12(fp)
81137fe8:	00c00fc4 	movi	r3,63
81137fec:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81137ff0:	e0bffd17 	ldw	r2,-12(fp)
81137ff4:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81137ff8:	e0bffd17 	ldw	r2,-12(fp)
81137ffc:	1080020b 	ldhu	r2,8(r2)
81138000:	10bfffcc 	andi	r2,r2,65535
81138004:	1004d23a 	srli	r2,r2,8
81138008:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113800c:	e0fff603 	ldbu	r3,-40(fp)
81138010:	00a045b4 	movhi	r2,33046
81138014:	109e0d04 	addi	r2,r2,30772
81138018:	18c7883a 	add	r3,r3,r3
8113801c:	18c7883a 	add	r3,r3,r3
81138020:	10c5883a 	add	r2,r2,r3
81138024:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81138028:	e0bffd17 	ldw	r2,-12(fp)
8113802c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
81138030:	d0e09b17 	ldw	r3,-32148(gp)
81138034:	e0bffd17 	ldw	r2,-12(fp)
81138038:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113803c:	e0bffd17 	ldw	r2,-12(fp)
81138040:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
81138044:	e0bffd17 	ldw	r2,-12(fp)
81138048:	d0a09b15 	stw	r2,-32148(gp)
8113804c:	e0bff417 	ldw	r2,-48(fp)
81138050:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138054:	e0bff517 	ldw	r2,-44(fp)
81138058:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113805c:	e0bfff17 	ldw	r2,-4(fp)
81138060:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
81138064:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
81138068:	00005a06 	br	811381d4 <OSMutexDel+0x2ec>
8113806c:	e0bff417 	ldw	r2,-48(fp)
81138070:	e0bff715 	stw	r2,-36(fp)
81138074:	e0bff717 	ldw	r2,-36(fp)
81138078:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113807c:	e0bfff17 	ldw	r2,-4(fp)
81138080:	00c01244 	movi	r3,73
81138084:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
81138088:	e0bffd17 	ldw	r2,-12(fp)
8113808c:	e0bff315 	stw	r2,-52(fp)
             }
             break;
81138090:	00005006 	br	811381d4 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
81138094:	e0bffd17 	ldw	r2,-12(fp)
81138098:	1080020b 	ldhu	r2,8(r2)
8113809c:	10bfffcc 	andi	r2,r2,65535
811380a0:	1004d23a 	srli	r2,r2,8
811380a4:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
811380a8:	e0bffd17 	ldw	r2,-12(fp)
811380ac:	1080020b 	ldhu	r2,8(r2)
811380b0:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
811380b4:	e0bffd17 	ldw	r2,-12(fp)
811380b8:	10800117 	ldw	r2,4(r2)
811380bc:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
811380c0:	e0bffa17 	ldw	r2,-24(fp)
811380c4:	10000f26 	beq	r2,zero,81138104 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
811380c8:	e0bffa17 	ldw	r2,-24(fp)
811380cc:	10800c83 	ldbu	r2,50(r2)
811380d0:	10c03fcc 	andi	r3,r2,255
811380d4:	e0bff603 	ldbu	r2,-40(fp)
811380d8:	18800a1e 	bne	r3,r2,81138104 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
811380dc:	e0bff903 	ldbu	r2,-28(fp)
811380e0:	100b883a 	mov	r5,r2
811380e4:	e13ffa17 	ldw	r4,-24(fp)
811380e8:	1138b240 	call	81138b24 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
811380ec:	00000506 	br	81138104 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
811380f0:	000f883a 	mov	r7,zero
811380f4:	01800404 	movi	r6,16
811380f8:	000b883a 	mov	r5,zero
811380fc:	e13ffd17 	ldw	r4,-12(fp)
81138100:	113488c0 	call	8113488c <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81138104:	e0bffd17 	ldw	r2,-12(fp)
81138108:	10800283 	ldbu	r2,10(r2)
8113810c:	10803fcc 	andi	r2,r2,255
81138110:	103ff71e 	bne	r2,zero,811380f0 <__reset+0xfb1180f0>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81138114:	e0bffd17 	ldw	r2,-12(fp)
81138118:	00c00fc4 	movi	r3,63
8113811c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81138120:	e0bffd17 	ldw	r2,-12(fp)
81138124:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81138128:	e0bffd17 	ldw	r2,-12(fp)
8113812c:	1080020b 	ldhu	r2,8(r2)
81138130:	10bfffcc 	andi	r2,r2,65535
81138134:	1004d23a 	srli	r2,r2,8
81138138:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113813c:	e0fff603 	ldbu	r3,-40(fp)
81138140:	00a045b4 	movhi	r2,33046
81138144:	109e0d04 	addi	r2,r2,30772
81138148:	18c7883a 	add	r3,r3,r3
8113814c:	18c7883a 	add	r3,r3,r3
81138150:	10c5883a 	add	r2,r2,r3
81138154:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81138158:	e0bffd17 	ldw	r2,-12(fp)
8113815c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
81138160:	d0e09b17 	ldw	r3,-32148(gp)
81138164:	e0bffd17 	ldw	r2,-12(fp)
81138168:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113816c:	e0bffd17 	ldw	r2,-12(fp)
81138170:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
81138174:	e0bffd17 	ldw	r2,-12(fp)
81138178:	d0a09b15 	stw	r2,-32148(gp)
8113817c:	e0bff417 	ldw	r2,-48(fp)
81138180:	e0bff815 	stw	r2,-32(fp)
81138184:	e0bff817 	ldw	r2,-32(fp)
81138188:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113818c:	e0bff203 	ldbu	r2,-56(fp)
81138190:	10800058 	cmpnei	r2,r2,1
81138194:	1000011e 	bne	r2,zero,8113819c <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81138198:	11353480 	call	81135348 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113819c:	e0bfff17 	ldw	r2,-4(fp)
811381a0:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
811381a4:	e03ff315 	stw	zero,-52(fp)
             break;
811381a8:	00000a06 	br	811381d4 <OSMutexDel+0x2ec>
811381ac:	e0bff417 	ldw	r2,-48(fp)
811381b0:	e0bffb15 	stw	r2,-20(fp)
811381b4:	e0bffb17 	ldw	r2,-20(fp)
811381b8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
811381bc:	e0bfff17 	ldw	r2,-4(fp)
811381c0:	00c001c4 	movi	r3,7
811381c4:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
811381c8:	e0bffd17 	ldw	r2,-12(fp)
811381cc:	e0bff315 	stw	r2,-52(fp)
             break;
811381d0:	0001883a 	nop
    }
    return (pevent_return);
811381d4:	e0bff317 	ldw	r2,-52(fp)
}
811381d8:	e037883a 	mov	sp,fp
811381dc:	dfc00117 	ldw	ra,4(sp)
811381e0:	df000017 	ldw	fp,0(sp)
811381e4:	dec00204 	addi	sp,sp,8
811381e8:	f800283a 	ret

811381ec <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
811381ec:	deffee04 	addi	sp,sp,-72
811381f0:	de00012e 	bgeu	sp,et,811381f8 <OSMutexPend+0xc>
811381f4:	003b68fa 	trap	3
811381f8:	dfc01115 	stw	ra,68(sp)
811381fc:	df001015 	stw	fp,64(sp)
81138200:	df001004 	addi	fp,sp,64
81138204:	e13ffd15 	stw	r4,-12(fp)
81138208:	2805883a 	mov	r2,r5
8113820c:	e1bfff15 	stw	r6,-4(fp)
81138210:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138214:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138218:	e0bfff17 	ldw	r2,-4(fp)
8113821c:	10015626 	beq	r2,zero,81138778 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138220:	e0bffd17 	ldw	r2,-12(fp)
81138224:	1000041e 	bne	r2,zero,81138238 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81138228:	e0bfff17 	ldw	r2,-4(fp)
8113822c:	00c00104 	movi	r3,4
81138230:	10c00005 	stb	r3,0(r2)
        return;
81138234:	00015106 	br	8113877c <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81138238:	e0bffd17 	ldw	r2,-12(fp)
8113823c:	10800003 	ldbu	r2,0(r2)
81138240:	10803fcc 	andi	r2,r2,255
81138244:	10800120 	cmpeqi	r2,r2,4
81138248:	1000041e 	bne	r2,zero,8113825c <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113824c:	e0bfff17 	ldw	r2,-4(fp)
81138250:	00c00044 	movi	r3,1
81138254:	10c00005 	stb	r3,0(r2)
        return;
81138258:	00014806 	br	8113877c <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113825c:	d0a09c03 	ldbu	r2,-32144(gp)
81138260:	10803fcc 	andi	r2,r2,255
81138264:	10000426 	beq	r2,zero,81138278 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81138268:	e0bfff17 	ldw	r2,-4(fp)
8113826c:	00c00084 	movi	r3,2
81138270:	10c00005 	stb	r3,0(r2)
        return;
81138274:	00014106 	br	8113877c <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81138278:	d0a08a03 	ldbu	r2,-32216(gp)
8113827c:	10803fcc 	andi	r2,r2,255
81138280:	10000426 	beq	r2,zero,81138294 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81138284:	e0bfff17 	ldw	r2,-4(fp)
81138288:	00c00344 	movi	r3,13
8113828c:	10c00005 	stb	r3,0(r2)
        return;
81138290:	00013a06 	br	8113877c <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138294:	0005303a 	rdctl	r2,status
81138298:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113829c:	e0fffc17 	ldw	r3,-16(fp)
811382a0:	00bfff84 	movi	r2,-2
811382a4:	1884703a 	and	r2,r3,r2
811382a8:	1001703a 	wrctl	status,r2
  
  return context;
811382ac:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
811382b0:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
811382b4:	e0bffd17 	ldw	r2,-12(fp)
811382b8:	1080020b 	ldhu	r2,8(r2)
811382bc:	10bfffcc 	andi	r2,r2,65535
811382c0:	1004d23a 	srli	r2,r2,8
811382c4:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
811382c8:	e0bffd17 	ldw	r2,-12(fp)
811382cc:	1080020b 	ldhu	r2,8(r2)
811382d0:	10803fcc 	andi	r2,r2,255
811382d4:	10803fd8 	cmpnei	r2,r2,255
811382d8:	1000271e 	bne	r2,zero,81138378 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
811382dc:	e0bffd17 	ldw	r2,-12(fp)
811382e0:	10c0020b 	ldhu	r3,8(r2)
811382e4:	00bfc004 	movi	r2,-256
811382e8:	1884703a 	and	r2,r3,r2
811382ec:	1007883a 	mov	r3,r2
811382f0:	e0bffd17 	ldw	r2,-12(fp)
811382f4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
811382f8:	e0bffd17 	ldw	r2,-12(fp)
811382fc:	10c0020b 	ldhu	r3,8(r2)
81138300:	d0a09d17 	ldw	r2,-32140(gp)
81138304:	10800c83 	ldbu	r2,50(r2)
81138308:	10803fcc 	andi	r2,r2,255
8113830c:	1884b03a 	or	r2,r3,r2
81138310:	1007883a 	mov	r3,r2
81138314:	e0bffd17 	ldw	r2,-12(fp)
81138318:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113831c:	d0e09d17 	ldw	r3,-32140(gp)
81138320:	e0bffd17 	ldw	r2,-12(fp)
81138324:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
81138328:	d0a09d17 	ldw	r2,-32140(gp)
8113832c:	10800c83 	ldbu	r2,50(r2)
81138330:	10803fcc 	andi	r2,r2,255
81138334:	e0fff303 	ldbu	r3,-52(fp)
81138338:	18800836 	bltu	r3,r2,8113835c <OSMutexPend+0x170>
8113833c:	e0bff117 	ldw	r2,-60(fp)
81138340:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138344:	e0bff217 	ldw	r2,-56(fp)
81138348:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113834c:	e0bfff17 	ldw	r2,-4(fp)
81138350:	00c01e04 	movi	r3,120
81138354:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
81138358:	00010806 	br	8113877c <OSMutexPend+0x590>
8113835c:	e0bff117 	ldw	r2,-60(fp)
81138360:	e0bff415 	stw	r2,-48(fp)
81138364:	e0bff417 	ldw	r2,-48(fp)
81138368:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113836c:	e0bfff17 	ldw	r2,-4(fp)
81138370:	10000005 	stb	zero,0(r2)
        }
        return;
81138374:	00010106 	br	8113877c <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
81138378:	e0bffd17 	ldw	r2,-12(fp)
8113837c:	1080020b 	ldhu	r2,8(r2)
81138380:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
81138384:	e0bffd17 	ldw	r2,-12(fp)
81138388:	10800117 	ldw	r2,4(r2)
8113838c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
81138390:	e0bff717 	ldw	r2,-36(fp)
81138394:	10800c83 	ldbu	r2,50(r2)
81138398:	10803fcc 	andi	r2,r2,255
8113839c:	e0fff303 	ldbu	r3,-52(fp)
811383a0:	1880b92e 	bgeu	r3,r2,81138688 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
811383a4:	d0a09d17 	ldw	r2,-32140(gp)
811383a8:	10800c83 	ldbu	r2,50(r2)
811383ac:	10c03fcc 	andi	r3,r2,255
811383b0:	e0bff603 	ldbu	r2,-40(fp)
811383b4:	1880b42e 	bgeu	r3,r2,81138688 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
811383b8:	e0bff717 	ldw	r2,-36(fp)
811383bc:	10800d03 	ldbu	r2,52(r2)
811383c0:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
811383c4:	e0fff803 	ldbu	r3,-32(fp)
811383c8:	d0a09944 	addi	r2,gp,-32155
811383cc:	1885883a 	add	r2,r3,r2
811383d0:	10c00003 	ldbu	r3,0(r2)
811383d4:	e0bff717 	ldw	r2,-36(fp)
811383d8:	10800d43 	ldbu	r2,53(r2)
811383dc:	1884703a 	and	r2,r3,r2
811383e0:	10803fcc 	andi	r2,r2,255
811383e4:	10001e26 	beq	r2,zero,81138460 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
811383e8:	e0fff803 	ldbu	r3,-32(fp)
811383ec:	e13ff803 	ldbu	r4,-32(fp)
811383f0:	d0a09944 	addi	r2,gp,-32155
811383f4:	2085883a 	add	r2,r4,r2
811383f8:	10800003 	ldbu	r2,0(r2)
811383fc:	1009883a 	mov	r4,r2
81138400:	e0bff717 	ldw	r2,-36(fp)
81138404:	10800d43 	ldbu	r2,53(r2)
81138408:	0084303a 	nor	r2,zero,r2
8113840c:	2084703a 	and	r2,r4,r2
81138410:	1009883a 	mov	r4,r2
81138414:	d0a09944 	addi	r2,gp,-32155
81138418:	1885883a 	add	r2,r3,r2
8113841c:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
81138420:	e0fff803 	ldbu	r3,-32(fp)
81138424:	d0a09944 	addi	r2,gp,-32155
81138428:	1885883a 	add	r2,r3,r2
8113842c:	10800003 	ldbu	r2,0(r2)
81138430:	10803fcc 	andi	r2,r2,255
81138434:	1000071e 	bne	r2,zero,81138454 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
81138438:	e0bff717 	ldw	r2,-36(fp)
8113843c:	10800d83 	ldbu	r2,54(r2)
81138440:	0084303a 	nor	r2,zero,r2
81138444:	1007883a 	mov	r3,r2
81138448:	d0a09903 	ldbu	r2,-32156(gp)
8113844c:	1884703a 	and	r2,r3,r2
81138450:	d0a09905 	stb	r2,-32156(gp)
                }
                rdy = OS_TRUE;
81138454:	00800044 	movi	r2,1
81138458:	e0bff005 	stb	r2,-64(fp)
8113845c:	00002a06 	br	81138508 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81138460:	e0bff717 	ldw	r2,-36(fp)
81138464:	10800717 	ldw	r2,28(r2)
81138468:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113846c:	e0bff917 	ldw	r2,-28(fp)
81138470:	10002426 	beq	r2,zero,81138504 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
81138474:	e0bff717 	ldw	r2,-36(fp)
81138478:	10800d03 	ldbu	r2,52(r2)
8113847c:	10803fcc 	andi	r2,r2,255
81138480:	e0fff717 	ldw	r3,-36(fp)
81138484:	18c00d03 	ldbu	r3,52(r3)
81138488:	18c03fcc 	andi	r3,r3,255
8113848c:	e13ff917 	ldw	r4,-28(fp)
81138490:	20c7883a 	add	r3,r4,r3
81138494:	18c002c4 	addi	r3,r3,11
81138498:	18c00003 	ldbu	r3,0(r3)
8113849c:	1809883a 	mov	r4,r3
811384a0:	e0fff717 	ldw	r3,-36(fp)
811384a4:	18c00d43 	ldbu	r3,53(r3)
811384a8:	00c6303a 	nor	r3,zero,r3
811384ac:	20c6703a 	and	r3,r4,r3
811384b0:	1809883a 	mov	r4,r3
811384b4:	e0fff917 	ldw	r3,-28(fp)
811384b8:	1887883a 	add	r3,r3,r2
811384bc:	18c002c4 	addi	r3,r3,11
811384c0:	19000005 	stb	r4,0(r3)
811384c4:	e0fff917 	ldw	r3,-28(fp)
811384c8:	1885883a 	add	r2,r3,r2
811384cc:	108002c4 	addi	r2,r2,11
811384d0:	10800003 	ldbu	r2,0(r2)
811384d4:	10803fcc 	andi	r2,r2,255
811384d8:	10000a1e 	bne	r2,zero,81138504 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
811384dc:	e0bff917 	ldw	r2,-28(fp)
811384e0:	10800283 	ldbu	r2,10(r2)
811384e4:	1007883a 	mov	r3,r2
811384e8:	e0bff717 	ldw	r2,-36(fp)
811384ec:	10800d83 	ldbu	r2,54(r2)
811384f0:	0084303a 	nor	r2,zero,r2
811384f4:	1884703a 	and	r2,r3,r2
811384f8:	1007883a 	mov	r3,r2
811384fc:	e0bff917 	ldw	r2,-28(fp)
81138500:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
81138504:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
81138508:	e0bff717 	ldw	r2,-36(fp)
8113850c:	e0fff303 	ldbu	r3,-52(fp)
81138510:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81138514:	e0bff717 	ldw	r2,-36(fp)
81138518:	10800c83 	ldbu	r2,50(r2)
8113851c:	10803fcc 	andi	r2,r2,255
81138520:	1004d0fa 	srli	r2,r2,3
81138524:	1007883a 	mov	r3,r2
81138528:	e0bff717 	ldw	r2,-36(fp)
8113852c:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
81138530:	e0bff717 	ldw	r2,-36(fp)
81138534:	10800c83 	ldbu	r2,50(r2)
81138538:	108001cc 	andi	r2,r2,7
8113853c:	1007883a 	mov	r3,r2
81138540:	e0bff717 	ldw	r2,-36(fp)
81138544:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
81138548:	e0bff717 	ldw	r2,-36(fp)
8113854c:	10800d03 	ldbu	r2,52(r2)
81138550:	10803fcc 	andi	r2,r2,255
81138554:	00c00044 	movi	r3,1
81138558:	1884983a 	sll	r2,r3,r2
8113855c:	1007883a 	mov	r3,r2
81138560:	e0bff717 	ldw	r2,-36(fp)
81138564:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
81138568:	e0bff717 	ldw	r2,-36(fp)
8113856c:	10800cc3 	ldbu	r2,51(r2)
81138570:	10803fcc 	andi	r2,r2,255
81138574:	00c00044 	movi	r3,1
81138578:	1884983a 	sll	r2,r3,r2
8113857c:	1007883a 	mov	r3,r2
81138580:	e0bff717 	ldw	r2,-36(fp)
81138584:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
81138588:	e0bff003 	ldbu	r2,-64(fp)
8113858c:	10800058 	cmpnei	r2,r2,1
81138590:	1000161e 	bne	r2,zero,811385ec <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81138594:	e0bff717 	ldw	r2,-36(fp)
81138598:	10c00d83 	ldbu	r3,54(r2)
8113859c:	d0a09903 	ldbu	r2,-32156(gp)
811385a0:	1884b03a 	or	r2,r3,r2
811385a4:	d0a09905 	stb	r2,-32156(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811385a8:	e0bff717 	ldw	r2,-36(fp)
811385ac:	10800d03 	ldbu	r2,52(r2)
811385b0:	10c03fcc 	andi	r3,r2,255
811385b4:	e0bff717 	ldw	r2,-36(fp)
811385b8:	10800d03 	ldbu	r2,52(r2)
811385bc:	11003fcc 	andi	r4,r2,255
811385c0:	d0a09944 	addi	r2,gp,-32155
811385c4:	2085883a 	add	r2,r4,r2
811385c8:	11000003 	ldbu	r4,0(r2)
811385cc:	e0bff717 	ldw	r2,-36(fp)
811385d0:	10800d43 	ldbu	r2,53(r2)
811385d4:	2084b03a 	or	r2,r4,r2
811385d8:	1009883a 	mov	r4,r2
811385dc:	d0a09944 	addi	r2,gp,-32155
811385e0:	1885883a 	add	r2,r3,r2
811385e4:	11000005 	stb	r4,0(r2)
811385e8:	00001f06 	br	81138668 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
811385ec:	e0bff717 	ldw	r2,-36(fp)
811385f0:	10800717 	ldw	r2,28(r2)
811385f4:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
811385f8:	e0bff917 	ldw	r2,-28(fp)
811385fc:	10001a26 	beq	r2,zero,81138668 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81138600:	e0bff917 	ldw	r2,-28(fp)
81138604:	10c00283 	ldbu	r3,10(r2)
81138608:	e0bff717 	ldw	r2,-36(fp)
8113860c:	10800d83 	ldbu	r2,54(r2)
81138610:	1884b03a 	or	r2,r3,r2
81138614:	1007883a 	mov	r3,r2
81138618:	e0bff917 	ldw	r2,-28(fp)
8113861c:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81138620:	e0bff717 	ldw	r2,-36(fp)
81138624:	10800d03 	ldbu	r2,52(r2)
81138628:	10803fcc 	andi	r2,r2,255
8113862c:	e0fff717 	ldw	r3,-36(fp)
81138630:	18c00d03 	ldbu	r3,52(r3)
81138634:	18c03fcc 	andi	r3,r3,255
81138638:	e13ff917 	ldw	r4,-28(fp)
8113863c:	20c7883a 	add	r3,r4,r3
81138640:	18c002c4 	addi	r3,r3,11
81138644:	19000003 	ldbu	r4,0(r3)
81138648:	e0fff717 	ldw	r3,-36(fp)
8113864c:	18c00d43 	ldbu	r3,53(r3)
81138650:	20c6b03a 	or	r3,r4,r3
81138654:	1809883a 	mov	r4,r3
81138658:	e0fff917 	ldw	r3,-28(fp)
8113865c:	1885883a 	add	r2,r3,r2
81138660:	108002c4 	addi	r2,r2,11
81138664:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
81138668:	e0fff303 	ldbu	r3,-52(fp)
8113866c:	00a045b4 	movhi	r2,33046
81138670:	109e0d04 	addi	r2,r2,30772
81138674:	18c7883a 	add	r3,r3,r3
81138678:	18c7883a 	add	r3,r3,r3
8113867c:	10c5883a 	add	r2,r2,r3
81138680:	e0fff717 	ldw	r3,-36(fp)
81138684:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
81138688:	d0a09d17 	ldw	r2,-32140(gp)
8113868c:	d0e09d17 	ldw	r3,-32140(gp)
81138690:	18c00c03 	ldbu	r3,48(r3)
81138694:	18c00414 	ori	r3,r3,16
81138698:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113869c:	d0a09d17 	ldw	r2,-32140(gp)
811386a0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
811386a4:	d0a09d17 	ldw	r2,-32140(gp)
811386a8:	e0fffe0b 	ldhu	r3,-8(fp)
811386ac:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
811386b0:	e13ffd17 	ldw	r4,-12(fp)
811386b4:	1134a2c0 	call	81134a2c <OS_EventTaskWait>
811386b8:	e0bff117 	ldw	r2,-60(fp)
811386bc:	e0bffb15 	stw	r2,-20(fp)
811386c0:	e0bffb17 	ldw	r2,-20(fp)
811386c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
811386c8:	11353480 	call	81135348 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811386cc:	0005303a 	rdctl	r2,status
811386d0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811386d4:	e0fff517 	ldw	r3,-44(fp)
811386d8:	00bfff84 	movi	r2,-2
811386dc:	1884703a 	and	r2,r3,r2
811386e0:	1001703a 	wrctl	status,r2
  
  return context;
811386e4:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
811386e8:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
811386ec:	d0a09d17 	ldw	r2,-32140(gp)
811386f0:	10800c43 	ldbu	r2,49(r2)
811386f4:	10803fcc 	andi	r2,r2,255
811386f8:	10000326 	beq	r2,zero,81138708 <OSMutexPend+0x51c>
811386fc:	108000a0 	cmpeqi	r2,r2,2
81138700:	1000041e 	bne	r2,zero,81138714 <OSMutexPend+0x528>
81138704:	00000706 	br	81138724 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81138708:	e0bfff17 	ldw	r2,-4(fp)
8113870c:	10000005 	stb	zero,0(r2)
             break;
81138710:	00000c06 	br	81138744 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81138714:	e0bfff17 	ldw	r2,-4(fp)
81138718:	00c00384 	movi	r3,14
8113871c:	10c00005 	stb	r3,0(r2)
             break;
81138720:	00000806 	br	81138744 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81138724:	d0a09d17 	ldw	r2,-32140(gp)
81138728:	e17ffd17 	ldw	r5,-12(fp)
8113872c:	1009883a 	mov	r4,r2
81138730:	1134c9c0 	call	81134c9c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
81138734:	e0bfff17 	ldw	r2,-4(fp)
81138738:	00c00284 	movi	r3,10
8113873c:	10c00005 	stb	r3,0(r2)
             break;
81138740:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81138744:	d0a09d17 	ldw	r2,-32140(gp)
81138748:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113874c:	d0a09d17 	ldw	r2,-32140(gp)
81138750:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81138754:	d0a09d17 	ldw	r2,-32140(gp)
81138758:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113875c:	d0a09d17 	ldw	r2,-32140(gp)
81138760:	10000815 	stw	zero,32(r2)
81138764:	e0bff117 	ldw	r2,-60(fp)
81138768:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113876c:	e0bffa17 	ldw	r2,-24(fp)
81138770:	1001703a 	wrctl	status,r2
81138774:	00000106 	br	8113877c <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
81138778:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113877c:	e037883a 	mov	sp,fp
81138780:	dfc00117 	ldw	ra,4(sp)
81138784:	df000017 	ldw	fp,0(sp)
81138788:	dec00204 	addi	sp,sp,8
8113878c:	f800283a 	ret

81138790 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
81138790:	defff604 	addi	sp,sp,-40
81138794:	de00012e 	bgeu	sp,et,8113879c <OSMutexPost+0xc>
81138798:	003b68fa 	trap	3
8113879c:	dfc00915 	stw	ra,36(sp)
811387a0:	df000815 	stw	fp,32(sp)
811387a4:	df000804 	addi	fp,sp,32
811387a8:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811387ac:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
811387b0:	d0a09c03 	ldbu	r2,-32144(gp)
811387b4:	10803fcc 	andi	r2,r2,255
811387b8:	10000226 	beq	r2,zero,811387c4 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
811387bc:	00800144 	movi	r2,5
811387c0:	00007606 	br	8113899c <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811387c4:	e0bfff17 	ldw	r2,-4(fp)
811387c8:	1000021e 	bne	r2,zero,811387d4 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
811387cc:	00800104 	movi	r2,4
811387d0:	00007206 	br	8113899c <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
811387d4:	e0bfff17 	ldw	r2,-4(fp)
811387d8:	10800003 	ldbu	r2,0(r2)
811387dc:	10803fcc 	andi	r2,r2,255
811387e0:	10800120 	cmpeqi	r2,r2,4
811387e4:	1000021e 	bne	r2,zero,811387f0 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
811387e8:	00800044 	movi	r2,1
811387ec:	00006b06 	br	8113899c <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811387f0:	0005303a 	rdctl	r2,status
811387f4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811387f8:	e0fffe17 	ldw	r3,-8(fp)
811387fc:	00bfff84 	movi	r2,-2
81138800:	1884703a 	and	r2,r3,r2
81138804:	1001703a 	wrctl	status,r2
  
  return context;
81138808:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113880c:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
81138810:	e0bfff17 	ldw	r2,-4(fp)
81138814:	1080020b 	ldhu	r2,8(r2)
81138818:	10bfffcc 	andi	r2,r2,65535
8113881c:	1004d23a 	srli	r2,r2,8
81138820:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
81138824:	e0bfff17 	ldw	r2,-4(fp)
81138828:	1080020b 	ldhu	r2,8(r2)
8113882c:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
81138830:	e0bfff17 	ldw	r2,-4(fp)
81138834:	10c00117 	ldw	r3,4(r2)
81138838:	d0a09d17 	ldw	r2,-32140(gp)
8113883c:	18800626 	beq	r3,r2,81138858 <OSMutexPost+0xc8>
81138840:	e0bff817 	ldw	r2,-32(fp)
81138844:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138848:	e0bff917 	ldw	r2,-28(fp)
8113884c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
81138850:	00801904 	movi	r2,100
81138854:	00005106 	br	8113899c <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
81138858:	d0a09d17 	ldw	r2,-32140(gp)
8113885c:	10800c83 	ldbu	r2,50(r2)
81138860:	10c03fcc 	andi	r3,r2,255
81138864:	e0bffa03 	ldbu	r2,-24(fp)
81138868:	1880051e 	bne	r3,r2,81138880 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113886c:	d0a09d17 	ldw	r2,-32140(gp)
81138870:	e0fffa43 	ldbu	r3,-23(fp)
81138874:	180b883a 	mov	r5,r3
81138878:	1009883a 	mov	r4,r2
8113887c:	1138b240 	call	81138b24 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
81138880:	e0fffa03 	ldbu	r3,-24(fp)
81138884:	00a045b4 	movhi	r2,33046
81138888:	109e0d04 	addi	r2,r2,30772
8113888c:	18c7883a 	add	r3,r3,r3
81138890:	18c7883a 	add	r3,r3,r3
81138894:	10c5883a 	add	r2,r2,r3
81138898:	00c00044 	movi	r3,1
8113889c:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
811388a0:	e0bfff17 	ldw	r2,-4(fp)
811388a4:	10800283 	ldbu	r2,10(r2)
811388a8:	10803fcc 	andi	r2,r2,255
811388ac:	10002e26 	beq	r2,zero,81138968 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
811388b0:	000f883a 	mov	r7,zero
811388b4:	01800404 	movi	r6,16
811388b8:	000b883a 	mov	r5,zero
811388bc:	e13fff17 	ldw	r4,-4(fp)
811388c0:	113488c0 	call	8113488c <OS_EventTaskRdy>
811388c4:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
811388c8:	e0bfff17 	ldw	r2,-4(fp)
811388cc:	10c0020b 	ldhu	r3,8(r2)
811388d0:	00bfc004 	movi	r2,-256
811388d4:	1884703a 	and	r2,r3,r2
811388d8:	1007883a 	mov	r3,r2
811388dc:	e0bfff17 	ldw	r2,-4(fp)
811388e0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
811388e4:	e0bfff17 	ldw	r2,-4(fp)
811388e8:	10c0020b 	ldhu	r3,8(r2)
811388ec:	e0bffa43 	ldbu	r2,-23(fp)
811388f0:	1884b03a 	or	r2,r3,r2
811388f4:	1007883a 	mov	r3,r2
811388f8:	e0bfff17 	ldw	r2,-4(fp)
811388fc:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
81138900:	e0fffa43 	ldbu	r3,-23(fp)
81138904:	00a045b4 	movhi	r2,33046
81138908:	109e0d04 	addi	r2,r2,30772
8113890c:	18c7883a 	add	r3,r3,r3
81138910:	18c7883a 	add	r3,r3,r3
81138914:	10c5883a 	add	r2,r2,r3
81138918:	10c00017 	ldw	r3,0(r2)
8113891c:	e0bfff17 	ldw	r2,-4(fp)
81138920:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
81138924:	e0bffa43 	ldbu	r2,-23(fp)
81138928:	e0fffa03 	ldbu	r3,-24(fp)
8113892c:	18800736 	bltu	r3,r2,8113894c <OSMutexPost+0x1bc>
81138930:	e0bff817 	ldw	r2,-32(fp)
81138934:	e0bffb15 	stw	r2,-20(fp)
81138938:	e0bffb17 	ldw	r2,-20(fp)
8113893c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
81138940:	11353480 	call	81135348 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
81138944:	00801e04 	movi	r2,120
81138948:	00001406 	br	8113899c <OSMutexPost+0x20c>
8113894c:	e0bff817 	ldw	r2,-32(fp)
81138950:	e0bffc15 	stw	r2,-16(fp)
81138954:	e0bffc17 	ldw	r2,-16(fp)
81138958:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113895c:	11353480 	call	81135348 <OS_Sched>
            return (OS_ERR_NONE);
81138960:	0005883a 	mov	r2,zero
81138964:	00000d06 	br	8113899c <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
81138968:	e0bfff17 	ldw	r2,-4(fp)
8113896c:	1080020b 	ldhu	r2,8(r2)
81138970:	10803fd4 	ori	r2,r2,255
81138974:	1007883a 	mov	r3,r2
81138978:	e0bfff17 	ldw	r2,-4(fp)
8113897c:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
81138980:	e0bfff17 	ldw	r2,-4(fp)
81138984:	10000115 	stw	zero,4(r2)
81138988:	e0bff817 	ldw	r2,-32(fp)
8113898c:	e0bffd15 	stw	r2,-12(fp)
81138990:	e0bffd17 	ldw	r2,-12(fp)
81138994:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138998:	0005883a 	mov	r2,zero
}
8113899c:	e037883a 	mov	sp,fp
811389a0:	dfc00117 	ldw	ra,4(sp)
811389a4:	df000017 	ldw	fp,0(sp)
811389a8:	dec00204 	addi	sp,sp,8
811389ac:	f800283a 	ret

811389b0 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
811389b0:	defff704 	addi	sp,sp,-36
811389b4:	de00012e 	bgeu	sp,et,811389bc <OSMutexQuery+0xc>
811389b8:	003b68fa 	trap	3
811389bc:	df000815 	stw	fp,32(sp)
811389c0:	df000804 	addi	fp,sp,32
811389c4:	e13ffe15 	stw	r4,-8(fp)
811389c8:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811389cc:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811389d0:	d0a09c03 	ldbu	r2,-32144(gp)
811389d4:	10803fcc 	andi	r2,r2,255
811389d8:	10000226 	beq	r2,zero,811389e4 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
811389dc:	00800184 	movi	r2,6
811389e0:	00004c06 	br	81138b14 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811389e4:	e0bffe17 	ldw	r2,-8(fp)
811389e8:	1000021e 	bne	r2,zero,811389f4 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
811389ec:	00800104 	movi	r2,4
811389f0:	00004806 	br	81138b14 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
811389f4:	e0bfff17 	ldw	r2,-4(fp)
811389f8:	1000021e 	bne	r2,zero,81138a04 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
811389fc:	00800244 	movi	r2,9
81138a00:	00004406 	br	81138b14 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81138a04:	e0bffe17 	ldw	r2,-8(fp)
81138a08:	10800003 	ldbu	r2,0(r2)
81138a0c:	10803fcc 	andi	r2,r2,255
81138a10:	10800120 	cmpeqi	r2,r2,4
81138a14:	1000021e 	bne	r2,zero,81138a20 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
81138a18:	00800044 	movi	r2,1
81138a1c:	00003d06 	br	81138b14 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138a20:	0005303a 	rdctl	r2,status
81138a24:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138a28:	e0fffd17 	ldw	r3,-12(fp)
81138a2c:	00bfff84 	movi	r2,-2
81138a30:	1884703a 	and	r2,r3,r2
81138a34:	1001703a 	wrctl	status,r2
  
  return context;
81138a38:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81138a3c:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
81138a40:	e0bffe17 	ldw	r2,-8(fp)
81138a44:	1080020b 	ldhu	r2,8(r2)
81138a48:	10bfffcc 	andi	r2,r2,65535
81138a4c:	1004d23a 	srli	r2,r2,8
81138a50:	1007883a 	mov	r3,r2
81138a54:	e0bfff17 	ldw	r2,-4(fp)
81138a58:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
81138a5c:	e0bffe17 	ldw	r2,-8(fp)
81138a60:	1080020b 	ldhu	r2,8(r2)
81138a64:	1007883a 	mov	r3,r2
81138a68:	e0bfff17 	ldw	r2,-4(fp)
81138a6c:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
81138a70:	e0bfff17 	ldw	r2,-4(fp)
81138a74:	10800203 	ldbu	r2,8(r2)
81138a78:	10803fcc 	andi	r2,r2,255
81138a7c:	10803fd8 	cmpnei	r2,r2,255
81138a80:	1000041e 	bne	r2,zero,81138a94 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
81138a84:	e0bfff17 	ldw	r2,-4(fp)
81138a88:	00c00044 	movi	r3,1
81138a8c:	10c001c5 	stb	r3,7(r2)
81138a90:	00000206 	br	81138a9c <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
81138a94:	e0bfff17 	ldw	r2,-4(fp)
81138a98:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
81138a9c:	e0bffe17 	ldw	r2,-8(fp)
81138aa0:	10c00283 	ldbu	r3,10(r2)
81138aa4:	e0bfff17 	ldw	r2,-4(fp)
81138aa8:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
81138aac:	e0bffe17 	ldw	r2,-8(fp)
81138ab0:	108002c4 	addi	r2,r2,11
81138ab4:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
81138ab8:	e0bfff17 	ldw	r2,-4(fp)
81138abc:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138ac0:	e03ff805 	stb	zero,-32(fp)
81138ac4:	00000b06 	br	81138af4 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
81138ac8:	e0bffa17 	ldw	r2,-24(fp)
81138acc:	10c00044 	addi	r3,r2,1
81138ad0:	e0fffa15 	stw	r3,-24(fp)
81138ad4:	e0fff917 	ldw	r3,-28(fp)
81138ad8:	19000044 	addi	r4,r3,1
81138adc:	e13ff915 	stw	r4,-28(fp)
81138ae0:	18c00003 	ldbu	r3,0(r3)
81138ae4:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138ae8:	e0bff803 	ldbu	r2,-32(fp)
81138aec:	10800044 	addi	r2,r2,1
81138af0:	e0bff805 	stb	r2,-32(fp)
81138af4:	e0bff803 	ldbu	r2,-32(fp)
81138af8:	108001b0 	cmpltui	r2,r2,6
81138afc:	103ff21e 	bne	r2,zero,81138ac8 <__reset+0xfb118ac8>
81138b00:	e0bffb17 	ldw	r2,-20(fp)
81138b04:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138b08:	e0bffc17 	ldw	r2,-16(fp)
81138b0c:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138b10:	0005883a 	mov	r2,zero
}
81138b14:	e037883a 	mov	sp,fp
81138b18:	df000017 	ldw	fp,0(sp)
81138b1c:	dec00104 	addi	sp,sp,4
81138b20:	f800283a 	ret

81138b24 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
81138b24:	defffc04 	addi	sp,sp,-16
81138b28:	de00012e 	bgeu	sp,et,81138b30 <OSMutex_RdyAtPrio+0xc>
81138b2c:	003b68fa 	trap	3
81138b30:	df000315 	stw	fp,12(sp)
81138b34:	df000304 	addi	fp,sp,12
81138b38:	e13ffe15 	stw	r4,-8(fp)
81138b3c:	2805883a 	mov	r2,r5
81138b40:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
81138b44:	e0bffe17 	ldw	r2,-8(fp)
81138b48:	10800d03 	ldbu	r2,52(r2)
81138b4c:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
81138b50:	e0fffd03 	ldbu	r3,-12(fp)
81138b54:	e13ffd03 	ldbu	r4,-12(fp)
81138b58:	d0a09944 	addi	r2,gp,-32155
81138b5c:	2085883a 	add	r2,r4,r2
81138b60:	10800003 	ldbu	r2,0(r2)
81138b64:	1009883a 	mov	r4,r2
81138b68:	e0bffe17 	ldw	r2,-8(fp)
81138b6c:	10800d43 	ldbu	r2,53(r2)
81138b70:	0084303a 	nor	r2,zero,r2
81138b74:	2084703a 	and	r2,r4,r2
81138b78:	1009883a 	mov	r4,r2
81138b7c:	d0a09944 	addi	r2,gp,-32155
81138b80:	1885883a 	add	r2,r3,r2
81138b84:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81138b88:	e0fffd03 	ldbu	r3,-12(fp)
81138b8c:	d0a09944 	addi	r2,gp,-32155
81138b90:	1885883a 	add	r2,r3,r2
81138b94:	10800003 	ldbu	r2,0(r2)
81138b98:	10803fcc 	andi	r2,r2,255
81138b9c:	1000071e 	bne	r2,zero,81138bbc <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81138ba0:	e0bffe17 	ldw	r2,-8(fp)
81138ba4:	10800d83 	ldbu	r2,54(r2)
81138ba8:	0084303a 	nor	r2,zero,r2
81138bac:	1007883a 	mov	r3,r2
81138bb0:	d0a09903 	ldbu	r2,-32156(gp)
81138bb4:	1884703a 	and	r2,r3,r2
81138bb8:	d0a09905 	stb	r2,-32156(gp)
    }
    ptcb->OSTCBPrio         = prio;
81138bbc:	e0bffe17 	ldw	r2,-8(fp)
81138bc0:	e0ffff03 	ldbu	r3,-4(fp)
81138bc4:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
81138bc8:	e0bfff03 	ldbu	r2,-4(fp)
81138bcc:	1004d0fa 	srli	r2,r2,3
81138bd0:	108001cc 	andi	r2,r2,7
81138bd4:	1007883a 	mov	r3,r2
81138bd8:	e0bffe17 	ldw	r2,-8(fp)
81138bdc:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
81138be0:	e0bfff03 	ldbu	r2,-4(fp)
81138be4:	108001cc 	andi	r2,r2,7
81138be8:	1007883a 	mov	r3,r2
81138bec:	e0bffe17 	ldw	r2,-8(fp)
81138bf0:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
81138bf4:	e0bffe17 	ldw	r2,-8(fp)
81138bf8:	10800d03 	ldbu	r2,52(r2)
81138bfc:	10803fcc 	andi	r2,r2,255
81138c00:	00c00044 	movi	r3,1
81138c04:	1884983a 	sll	r2,r3,r2
81138c08:	1007883a 	mov	r3,r2
81138c0c:	e0bffe17 	ldw	r2,-8(fp)
81138c10:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
81138c14:	e0bffe17 	ldw	r2,-8(fp)
81138c18:	10800cc3 	ldbu	r2,51(r2)
81138c1c:	10803fcc 	andi	r2,r2,255
81138c20:	00c00044 	movi	r3,1
81138c24:	1884983a 	sll	r2,r3,r2
81138c28:	1007883a 	mov	r3,r2
81138c2c:	e0bffe17 	ldw	r2,-8(fp)
81138c30:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
81138c34:	e0bffe17 	ldw	r2,-8(fp)
81138c38:	10c00d83 	ldbu	r3,54(r2)
81138c3c:	d0a09903 	ldbu	r2,-32156(gp)
81138c40:	1884b03a 	or	r2,r3,r2
81138c44:	d0a09905 	stb	r2,-32156(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81138c48:	e0bffe17 	ldw	r2,-8(fp)
81138c4c:	10800d03 	ldbu	r2,52(r2)
81138c50:	10c03fcc 	andi	r3,r2,255
81138c54:	e0bffe17 	ldw	r2,-8(fp)
81138c58:	10800d03 	ldbu	r2,52(r2)
81138c5c:	11003fcc 	andi	r4,r2,255
81138c60:	d0a09944 	addi	r2,gp,-32155
81138c64:	2085883a 	add	r2,r4,r2
81138c68:	11000003 	ldbu	r4,0(r2)
81138c6c:	e0bffe17 	ldw	r2,-8(fp)
81138c70:	10800d43 	ldbu	r2,53(r2)
81138c74:	2084b03a 	or	r2,r4,r2
81138c78:	1009883a 	mov	r4,r2
81138c7c:	d0a09944 	addi	r2,gp,-32155
81138c80:	1885883a 	add	r2,r3,r2
81138c84:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
81138c88:	e0ffff03 	ldbu	r3,-4(fp)
81138c8c:	00a045b4 	movhi	r2,33046
81138c90:	109e0d04 	addi	r2,r2,30772
81138c94:	18c7883a 	add	r3,r3,r3
81138c98:	18c7883a 	add	r3,r3,r3
81138c9c:	10c5883a 	add	r2,r2,r3
81138ca0:	e0fffe17 	ldw	r3,-8(fp)
81138ca4:	10c00015 	stw	r3,0(r2)
}
81138ca8:	0001883a 	nop
81138cac:	e037883a 	mov	sp,fp
81138cb0:	df000017 	ldw	fp,0(sp)
81138cb4:	dec00104 	addi	sp,sp,4
81138cb8:	f800283a 	ret

81138cbc <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
81138cbc:	defff804 	addi	sp,sp,-32
81138cc0:	de00012e 	bgeu	sp,et,81138cc8 <OSQAccept+0xc>
81138cc4:	003b68fa 	trap	3
81138cc8:	df000715 	stw	fp,28(sp)
81138ccc:	df000704 	addi	fp,sp,28
81138cd0:	e13ffe15 	stw	r4,-8(fp)
81138cd4:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138cd8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81138cdc:	e0bfff17 	ldw	r2,-4(fp)
81138ce0:	1000021e 	bne	r2,zero,81138cec <OSQAccept+0x30>
        return ((void *)0);
81138ce4:	0005883a 	mov	r2,zero
81138ce8:	00004206 	br	81138df4 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
81138cec:	e0bffe17 	ldw	r2,-8(fp)
81138cf0:	1000051e 	bne	r2,zero,81138d08 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81138cf4:	e0bfff17 	ldw	r2,-4(fp)
81138cf8:	00c00104 	movi	r3,4
81138cfc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81138d00:	0005883a 	mov	r2,zero
81138d04:	00003b06 	br	81138df4 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81138d08:	e0bffe17 	ldw	r2,-8(fp)
81138d0c:	10800003 	ldbu	r2,0(r2)
81138d10:	10803fcc 	andi	r2,r2,255
81138d14:	108000a0 	cmpeqi	r2,r2,2
81138d18:	1000051e 	bne	r2,zero,81138d30 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81138d1c:	e0bfff17 	ldw	r2,-4(fp)
81138d20:	00c00044 	movi	r3,1
81138d24:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81138d28:	0005883a 	mov	r2,zero
81138d2c:	00003106 	br	81138df4 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d30:	0005303a 	rdctl	r2,status
81138d34:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138d38:	e0fffd17 	ldw	r3,-12(fp)
81138d3c:	00bfff84 	movi	r2,-2
81138d40:	1884703a 	and	r2,r3,r2
81138d44:	1001703a 	wrctl	status,r2
  
  return context;
81138d48:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81138d4c:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81138d50:	e0bffe17 	ldw	r2,-8(fp)
81138d54:	10800117 	ldw	r2,4(r2)
81138d58:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81138d5c:	e0bffc17 	ldw	r2,-16(fp)
81138d60:	1080058b 	ldhu	r2,22(r2)
81138d64:	10bfffcc 	andi	r2,r2,65535
81138d68:	10001926 	beq	r2,zero,81138dd0 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81138d6c:	e0bffc17 	ldw	r2,-16(fp)
81138d70:	10800417 	ldw	r2,16(r2)
81138d74:	11000104 	addi	r4,r2,4
81138d78:	e0fffc17 	ldw	r3,-16(fp)
81138d7c:	19000415 	stw	r4,16(r3)
81138d80:	10800017 	ldw	r2,0(r2)
81138d84:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81138d88:	e0bffc17 	ldw	r2,-16(fp)
81138d8c:	1080058b 	ldhu	r2,22(r2)
81138d90:	10bfffc4 	addi	r2,r2,-1
81138d94:	1007883a 	mov	r3,r2
81138d98:	e0bffc17 	ldw	r2,-16(fp)
81138d9c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81138da0:	e0bffc17 	ldw	r2,-16(fp)
81138da4:	10c00417 	ldw	r3,16(r2)
81138da8:	e0bffc17 	ldw	r2,-16(fp)
81138dac:	10800217 	ldw	r2,8(r2)
81138db0:	1880041e 	bne	r3,r2,81138dc4 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
81138db4:	e0bffc17 	ldw	r2,-16(fp)
81138db8:	10c00117 	ldw	r3,4(r2)
81138dbc:	e0bffc17 	ldw	r2,-16(fp)
81138dc0:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
81138dc4:	e0bfff17 	ldw	r2,-4(fp)
81138dc8:	10000005 	stb	zero,0(r2)
81138dcc:	00000406 	br	81138de0 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
81138dd0:	e0bfff17 	ldw	r2,-4(fp)
81138dd4:	00c007c4 	movi	r3,31
81138dd8:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
81138ddc:	e03ff915 	stw	zero,-28(fp)
81138de0:	e0bffa17 	ldw	r2,-24(fp)
81138de4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138de8:	e0bffb17 	ldw	r2,-20(fp)
81138dec:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
81138df0:	e0bff917 	ldw	r2,-28(fp)
}
81138df4:	e037883a 	mov	sp,fp
81138df8:	df000017 	ldw	fp,0(sp)
81138dfc:	dec00104 	addi	sp,sp,4
81138e00:	f800283a 	ret

81138e04 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
81138e04:	defff404 	addi	sp,sp,-48
81138e08:	de00012e 	bgeu	sp,et,81138e10 <OSQCreate+0xc>
81138e0c:	003b68fa 	trap	3
81138e10:	dfc00b15 	stw	ra,44(sp)
81138e14:	df000a15 	stw	fp,40(sp)
81138e18:	df000a04 	addi	fp,sp,40
81138e1c:	e13ffe15 	stw	r4,-8(fp)
81138e20:	2805883a 	mov	r2,r5
81138e24:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138e28:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81138e2c:	d0a09c03 	ldbu	r2,-32144(gp)
81138e30:	10803fcc 	andi	r2,r2,255
81138e34:	10000226 	beq	r2,zero,81138e40 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
81138e38:	0005883a 	mov	r2,zero
81138e3c:	00005906 	br	81138fa4 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e40:	0005303a 	rdctl	r2,status
81138e44:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e48:	e0fffd17 	ldw	r3,-12(fp)
81138e4c:	00bfff84 	movi	r2,-2
81138e50:	1884703a 	and	r2,r3,r2
81138e54:	1001703a 	wrctl	status,r2
  
  return context;
81138e58:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81138e5c:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
81138e60:	d0a09b17 	ldw	r2,-32148(gp)
81138e64:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
81138e68:	d0a09b17 	ldw	r2,-32148(gp)
81138e6c:	10000326 	beq	r2,zero,81138e7c <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
81138e70:	d0a09b17 	ldw	r2,-32148(gp)
81138e74:	10800117 	ldw	r2,4(r2)
81138e78:	d0a09b15 	stw	r2,-32148(gp)
81138e7c:	e0bff717 	ldw	r2,-36(fp)
81138e80:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138e84:	e0bff817 	ldw	r2,-32(fp)
81138e88:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
81138e8c:	e0bff617 	ldw	r2,-40(fp)
81138e90:	10004326 	beq	r2,zero,81138fa0 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e94:	0005303a 	rdctl	r2,status
81138e98:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e9c:	e0fff917 	ldw	r3,-28(fp)
81138ea0:	00bfff84 	movi	r2,-2
81138ea4:	1884703a 	and	r2,r3,r2
81138ea8:	1001703a 	wrctl	status,r2
  
  return context;
81138eac:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
81138eb0:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
81138eb4:	d0a09817 	ldw	r2,-32160(gp)
81138eb8:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
81138ebc:	e0bffb17 	ldw	r2,-20(fp)
81138ec0:	10002d26 	beq	r2,zero,81138f78 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
81138ec4:	d0a09817 	ldw	r2,-32160(gp)
81138ec8:	10800017 	ldw	r2,0(r2)
81138ecc:	d0a09815 	stw	r2,-32160(gp)
81138ed0:	e0bff717 	ldw	r2,-36(fp)
81138ed4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138ed8:	e0bffa17 	ldw	r2,-24(fp)
81138edc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
81138ee0:	e0bffb17 	ldw	r2,-20(fp)
81138ee4:	e0fffe17 	ldw	r3,-8(fp)
81138ee8:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
81138eec:	e0bfff0b 	ldhu	r2,-4(fp)
81138ef0:	1085883a 	add	r2,r2,r2
81138ef4:	1085883a 	add	r2,r2,r2
81138ef8:	1007883a 	mov	r3,r2
81138efc:	e0bffe17 	ldw	r2,-8(fp)
81138f00:	10c7883a 	add	r3,r2,r3
81138f04:	e0bffb17 	ldw	r2,-20(fp)
81138f08:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
81138f0c:	e0bffb17 	ldw	r2,-20(fp)
81138f10:	e0fffe17 	ldw	r3,-8(fp)
81138f14:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
81138f18:	e0bffb17 	ldw	r2,-20(fp)
81138f1c:	e0fffe17 	ldw	r3,-8(fp)
81138f20:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
81138f24:	e0bffb17 	ldw	r2,-20(fp)
81138f28:	e0ffff0b 	ldhu	r3,-4(fp)
81138f2c:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
81138f30:	e0bffb17 	ldw	r2,-20(fp)
81138f34:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
81138f38:	e0bff617 	ldw	r2,-40(fp)
81138f3c:	00c00084 	movi	r3,2
81138f40:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
81138f44:	e0bff617 	ldw	r2,-40(fp)
81138f48:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
81138f4c:	e0bff617 	ldw	r2,-40(fp)
81138f50:	e0fffb17 	ldw	r3,-20(fp)
81138f54:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
81138f58:	e0bff617 	ldw	r2,-40(fp)
81138f5c:	00c00fc4 	movi	r3,63
81138f60:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
81138f64:	e0bff617 	ldw	r2,-40(fp)
81138f68:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
81138f6c:	e13ff617 	ldw	r4,-40(fp)
81138f70:	1134e640 	call	81134e64 <OS_EventWaitListInit>
81138f74:	00000a06 	br	81138fa0 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
81138f78:	d0e09b17 	ldw	r3,-32148(gp)
81138f7c:	e0bff617 	ldw	r2,-40(fp)
81138f80:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
81138f84:	e0bff617 	ldw	r2,-40(fp)
81138f88:	d0a09b15 	stw	r2,-32148(gp)
81138f8c:	e0bff717 	ldw	r2,-36(fp)
81138f90:	e0bffc15 	stw	r2,-16(fp)
81138f94:	e0bffc17 	ldw	r2,-16(fp)
81138f98:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
81138f9c:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
81138fa0:	e0bff617 	ldw	r2,-40(fp)
}
81138fa4:	e037883a 	mov	sp,fp
81138fa8:	dfc00117 	ldw	ra,4(sp)
81138fac:	df000017 	ldw	fp,0(sp)
81138fb0:	dec00204 	addi	sp,sp,8
81138fb4:	f800283a 	ret

81138fb8 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81138fb8:	defff204 	addi	sp,sp,-56
81138fbc:	de00012e 	bgeu	sp,et,81138fc4 <OSQDel+0xc>
81138fc0:	003b68fa 	trap	3
81138fc4:	dfc00d15 	stw	ra,52(sp)
81138fc8:	df000c15 	stw	fp,48(sp)
81138fcc:	df000c04 	addi	fp,sp,48
81138fd0:	e13ffd15 	stw	r4,-12(fp)
81138fd4:	2805883a 	mov	r2,r5
81138fd8:	e1bfff15 	stw	r6,-4(fp)
81138fdc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138fe0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138fe4:	e0bfff17 	ldw	r2,-4(fp)
81138fe8:	1000021e 	bne	r2,zero,81138ff4 <OSQDel+0x3c>
        return (pevent);
81138fec:	e0bffd17 	ldw	r2,-12(fp)
81138ff0:	00008e06 	br	8113922c <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138ff4:	e0bffd17 	ldw	r2,-12(fp)
81138ff8:	1000051e 	bne	r2,zero,81139010 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81138ffc:	e0bfff17 	ldw	r2,-4(fp)
81139000:	00c00104 	movi	r3,4
81139004:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139008:	e0bffd17 	ldw	r2,-12(fp)
8113900c:	00008706 	br	8113922c <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81139010:	e0bffd17 	ldw	r2,-12(fp)
81139014:	10800003 	ldbu	r2,0(r2)
81139018:	10803fcc 	andi	r2,r2,255
8113901c:	108000a0 	cmpeqi	r2,r2,2
81139020:	1000051e 	bne	r2,zero,81139038 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81139024:	e0bfff17 	ldw	r2,-4(fp)
81139028:	00c00044 	movi	r3,1
8113902c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139030:	e0bffd17 	ldw	r2,-12(fp)
81139034:	00007d06 	br	8113922c <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139038:	d0a09c03 	ldbu	r2,-32144(gp)
8113903c:	10803fcc 	andi	r2,r2,255
81139040:	10000526 	beq	r2,zero,81139058 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81139044:	e0bfff17 	ldw	r2,-4(fp)
81139048:	00c003c4 	movi	r3,15
8113904c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139050:	e0bffd17 	ldw	r2,-12(fp)
81139054:	00007506 	br	8113922c <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139058:	0005303a 	rdctl	r2,status
8113905c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139060:	e0fffc17 	ldw	r3,-16(fp)
81139064:	00bfff84 	movi	r2,-2
81139068:	1884703a 	and	r2,r3,r2
8113906c:	1001703a 	wrctl	status,r2
  
  return context;
81139070:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139074:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
81139078:	e0bffd17 	ldw	r2,-12(fp)
8113907c:	10800283 	ldbu	r2,10(r2)
81139080:	10803fcc 	andi	r2,r2,255
81139084:	10000326 	beq	r2,zero,81139094 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81139088:	00800044 	movi	r2,1
8113908c:	e0bff405 	stb	r2,-48(fp)
81139090:	00000106 	br	81139098 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81139094:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81139098:	e0bffe03 	ldbu	r2,-8(fp)
8113909c:	10000326 	beq	r2,zero,811390ac <OSQDel+0xf4>
811390a0:	10800060 	cmpeqi	r2,r2,1
811390a4:	1000301e 	bne	r2,zero,81139168 <OSQDel+0x1b0>
811390a8:	00005506 	br	81139200 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
811390ac:	e0bff403 	ldbu	r2,-48(fp)
811390b0:	10001e1e 	bne	r2,zero,8113912c <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
811390b4:	e0bffd17 	ldw	r2,-12(fp)
811390b8:	00c00fc4 	movi	r3,63
811390bc:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
811390c0:	e0bffd17 	ldw	r2,-12(fp)
811390c4:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
811390c8:	e0bffd17 	ldw	r2,-12(fp)
811390cc:	10800117 	ldw	r2,4(r2)
811390d0:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
811390d4:	d0e09817 	ldw	r3,-32160(gp)
811390d8:	e0bff817 	ldw	r2,-32(fp)
811390dc:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
811390e0:	e0bff817 	ldw	r2,-32(fp)
811390e4:	d0a09815 	stw	r2,-32160(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811390e8:	e0bffd17 	ldw	r2,-12(fp)
811390ec:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
811390f0:	d0e09b17 	ldw	r3,-32148(gp)
811390f4:	e0bffd17 	ldw	r2,-12(fp)
811390f8:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
811390fc:	e0bffd17 	ldw	r2,-12(fp)
81139100:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81139104:	e0bffd17 	ldw	r2,-12(fp)
81139108:	d0a09b15 	stw	r2,-32148(gp)
8113910c:	e0bff617 	ldw	r2,-40(fp)
81139110:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139114:	e0bff717 	ldw	r2,-36(fp)
81139118:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113911c:	e0bfff17 	ldw	r2,-4(fp)
81139120:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
81139124:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81139128:	00003f06 	br	81139228 <OSQDel+0x270>
8113912c:	e0bff617 	ldw	r2,-40(fp)
81139130:	e0bff915 	stw	r2,-28(fp)
81139134:	e0bff917 	ldw	r2,-28(fp)
81139138:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113913c:	e0bfff17 	ldw	r2,-4(fp)
81139140:	00c01244 	movi	r3,73
81139144:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81139148:	e0bffd17 	ldw	r2,-12(fp)
8113914c:	e0bff515 	stw	r2,-44(fp)
             }
             break;
81139150:	00003506 	br	81139228 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
81139154:	000f883a 	mov	r7,zero
81139158:	01800104 	movi	r6,4
8113915c:	000b883a 	mov	r5,zero
81139160:	e13ffd17 	ldw	r4,-12(fp)
81139164:	113488c0 	call	8113488c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
81139168:	e0bffd17 	ldw	r2,-12(fp)
8113916c:	10800283 	ldbu	r2,10(r2)
81139170:	10803fcc 	andi	r2,r2,255
81139174:	103ff71e 	bne	r2,zero,81139154 <__reset+0xfb119154>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81139178:	e0bffd17 	ldw	r2,-12(fp)
8113917c:	00c00fc4 	movi	r3,63
81139180:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81139184:	e0bffd17 	ldw	r2,-12(fp)
81139188:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113918c:	e0bffd17 	ldw	r2,-12(fp)
81139190:	10800117 	ldw	r2,4(r2)
81139194:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
81139198:	d0e09817 	ldw	r3,-32160(gp)
8113919c:	e0bff817 	ldw	r2,-32(fp)
811391a0:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
811391a4:	e0bff817 	ldw	r2,-32(fp)
811391a8:	d0a09815 	stw	r2,-32160(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811391ac:	e0bffd17 	ldw	r2,-12(fp)
811391b0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
811391b4:	d0e09b17 	ldw	r3,-32148(gp)
811391b8:	e0bffd17 	ldw	r2,-12(fp)
811391bc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
811391c0:	e0bffd17 	ldw	r2,-12(fp)
811391c4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
811391c8:	e0bffd17 	ldw	r2,-12(fp)
811391cc:	d0a09b15 	stw	r2,-32148(gp)
811391d0:	e0bff617 	ldw	r2,-40(fp)
811391d4:	e0bffa15 	stw	r2,-24(fp)
811391d8:	e0bffa17 	ldw	r2,-24(fp)
811391dc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
811391e0:	e0bff403 	ldbu	r2,-48(fp)
811391e4:	10800058 	cmpnei	r2,r2,1
811391e8:	1000011e 	bne	r2,zero,811391f0 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
811391ec:	11353480 	call	81135348 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
811391f0:	e0bfff17 	ldw	r2,-4(fp)
811391f4:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
811391f8:	e03ff515 	stw	zero,-44(fp)
             break;
811391fc:	00000a06 	br	81139228 <OSQDel+0x270>
81139200:	e0bff617 	ldw	r2,-40(fp)
81139204:	e0bffb15 	stw	r2,-20(fp)
81139208:	e0bffb17 	ldw	r2,-20(fp)
8113920c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81139210:	e0bfff17 	ldw	r2,-4(fp)
81139214:	00c001c4 	movi	r3,7
81139218:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113921c:	e0bffd17 	ldw	r2,-12(fp)
81139220:	e0bff515 	stw	r2,-44(fp)
             break;
81139224:	0001883a 	nop
    }
    return (pevent_return);
81139228:	e0bff517 	ldw	r2,-44(fp)
}
8113922c:	e037883a 	mov	sp,fp
81139230:	dfc00117 	ldw	ra,4(sp)
81139234:	df000017 	ldw	fp,0(sp)
81139238:	dec00204 	addi	sp,sp,8
8113923c:	f800283a 	ret

81139240 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
81139240:	defffa04 	addi	sp,sp,-24
81139244:	de00012e 	bgeu	sp,et,8113924c <OSQFlush+0xc>
81139248:	003b68fa 	trap	3
8113924c:	df000515 	stw	fp,20(sp)
81139250:	df000504 	addi	fp,sp,20
81139254:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139258:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113925c:	e0bfff17 	ldw	r2,-4(fp)
81139260:	1000021e 	bne	r2,zero,8113926c <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
81139264:	00800104 	movi	r2,4
81139268:	00002106 	br	811392f0 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113926c:	e0bfff17 	ldw	r2,-4(fp)
81139270:	10800003 	ldbu	r2,0(r2)
81139274:	10803fcc 	andi	r2,r2,255
81139278:	108000a0 	cmpeqi	r2,r2,2
8113927c:	1000021e 	bne	r2,zero,81139288 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
81139280:	00800044 	movi	r2,1
81139284:	00001a06 	br	811392f0 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139288:	0005303a 	rdctl	r2,status
8113928c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139290:	e0fffd17 	ldw	r3,-12(fp)
81139294:	00bfff84 	movi	r2,-2
81139298:	1884703a 	and	r2,r3,r2
8113929c:	1001703a 	wrctl	status,r2
  
  return context;
811392a0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811392a4:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
811392a8:	e0bfff17 	ldw	r2,-4(fp)
811392ac:	10800117 	ldw	r2,4(r2)
811392b0:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
811392b4:	e0bffc17 	ldw	r2,-16(fp)
811392b8:	10c00117 	ldw	r3,4(r2)
811392bc:	e0bffc17 	ldw	r2,-16(fp)
811392c0:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
811392c4:	e0bffc17 	ldw	r2,-16(fp)
811392c8:	10c00117 	ldw	r3,4(r2)
811392cc:	e0bffc17 	ldw	r2,-16(fp)
811392d0:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
811392d4:	e0bffc17 	ldw	r2,-16(fp)
811392d8:	1000058d 	sth	zero,22(r2)
811392dc:	e0bffb17 	ldw	r2,-20(fp)
811392e0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811392e4:	e0bffe17 	ldw	r2,-8(fp)
811392e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811392ec:	0005883a 	mov	r2,zero
}
811392f0:	e037883a 	mov	sp,fp
811392f4:	df000017 	ldw	fp,0(sp)
811392f8:	dec00104 	addi	sp,sp,4
811392fc:	f800283a 	ret

81139300 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81139300:	defff304 	addi	sp,sp,-52
81139304:	de00012e 	bgeu	sp,et,8113930c <OSQPend+0xc>
81139308:	003b68fa 	trap	3
8113930c:	dfc00c15 	stw	ra,48(sp)
81139310:	df000b15 	stw	fp,44(sp)
81139314:	df000b04 	addi	fp,sp,44
81139318:	e13ffd15 	stw	r4,-12(fp)
8113931c:	2805883a 	mov	r2,r5
81139320:	e1bfff15 	stw	r6,-4(fp)
81139324:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139328:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113932c:	e0bfff17 	ldw	r2,-4(fp)
81139330:	1000021e 	bne	r2,zero,8113933c <OSQPend+0x3c>
        return ((void *)0);
81139334:	0005883a 	mov	r2,zero
81139338:	00009106 	br	81139580 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113933c:	e0bffd17 	ldw	r2,-12(fp)
81139340:	1000051e 	bne	r2,zero,81139358 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81139344:	e0bfff17 	ldw	r2,-4(fp)
81139348:	00c00104 	movi	r3,4
8113934c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139350:	0005883a 	mov	r2,zero
81139354:	00008a06 	br	81139580 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81139358:	e0bffd17 	ldw	r2,-12(fp)
8113935c:	10800003 	ldbu	r2,0(r2)
81139360:	10803fcc 	andi	r2,r2,255
81139364:	108000a0 	cmpeqi	r2,r2,2
81139368:	1000051e 	bne	r2,zero,81139380 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113936c:	e0bfff17 	ldw	r2,-4(fp)
81139370:	00c00044 	movi	r3,1
81139374:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139378:	0005883a 	mov	r2,zero
8113937c:	00008006 	br	81139580 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81139380:	d0a09c03 	ldbu	r2,-32144(gp)
81139384:	10803fcc 	andi	r2,r2,255
81139388:	10000526 	beq	r2,zero,811393a0 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113938c:	e0bfff17 	ldw	r2,-4(fp)
81139390:	00c00084 	movi	r3,2
81139394:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139398:	0005883a 	mov	r2,zero
8113939c:	00007806 	br	81139580 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
811393a0:	d0a08a03 	ldbu	r2,-32216(gp)
811393a4:	10803fcc 	andi	r2,r2,255
811393a8:	10000526 	beq	r2,zero,811393c0 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
811393ac:	e0bfff17 	ldw	r2,-4(fp)
811393b0:	00c00344 	movi	r3,13
811393b4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811393b8:	0005883a 	mov	r2,zero
811393bc:	00007006 	br	81139580 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811393c0:	0005303a 	rdctl	r2,status
811393c4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811393c8:	e0fffc17 	ldw	r3,-16(fp)
811393cc:	00bfff84 	movi	r2,-2
811393d0:	1884703a 	and	r2,r3,r2
811393d4:	1001703a 	wrctl	status,r2
  
  return context;
811393d8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811393dc:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
811393e0:	e0bffd17 	ldw	r2,-12(fp)
811393e4:	10800117 	ldw	r2,4(r2)
811393e8:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
811393ec:	e0bff817 	ldw	r2,-32(fp)
811393f0:	1080058b 	ldhu	r2,22(r2)
811393f4:	10bfffcc 	andi	r2,r2,65535
811393f8:	10001e26 	beq	r2,zero,81139474 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
811393fc:	e0bff817 	ldw	r2,-32(fp)
81139400:	10800417 	ldw	r2,16(r2)
81139404:	11000104 	addi	r4,r2,4
81139408:	e0fff817 	ldw	r3,-32(fp)
8113940c:	19000415 	stw	r4,16(r3)
81139410:	10800017 	ldw	r2,0(r2)
81139414:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81139418:	e0bff817 	ldw	r2,-32(fp)
8113941c:	1080058b 	ldhu	r2,22(r2)
81139420:	10bfffc4 	addi	r2,r2,-1
81139424:	1007883a 	mov	r3,r2
81139428:	e0bff817 	ldw	r2,-32(fp)
8113942c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81139430:	e0bff817 	ldw	r2,-32(fp)
81139434:	10c00417 	ldw	r3,16(r2)
81139438:	e0bff817 	ldw	r2,-32(fp)
8113943c:	10800217 	ldw	r2,8(r2)
81139440:	1880041e 	bne	r3,r2,81139454 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
81139444:	e0bff817 	ldw	r2,-32(fp)
81139448:	10c00117 	ldw	r3,4(r2)
8113944c:	e0bff817 	ldw	r2,-32(fp)
81139450:	10c00415 	stw	r3,16(r2)
81139454:	e0bff617 	ldw	r2,-40(fp)
81139458:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113945c:	e0bff717 	ldw	r2,-36(fp)
81139460:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81139464:	e0bfff17 	ldw	r2,-4(fp)
81139468:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113946c:	e0bff517 	ldw	r2,-44(fp)
81139470:	00004306 	br	81139580 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
81139474:	d0a09d17 	ldw	r2,-32140(gp)
81139478:	d0e09d17 	ldw	r3,-32140(gp)
8113947c:	18c00c03 	ldbu	r3,48(r3)
81139480:	18c00114 	ori	r3,r3,4
81139484:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81139488:	d0a09d17 	ldw	r2,-32140(gp)
8113948c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
81139490:	d0a09d17 	ldw	r2,-32140(gp)
81139494:	e0fffe0b 	ldhu	r3,-8(fp)
81139498:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113949c:	e13ffd17 	ldw	r4,-12(fp)
811394a0:	1134a2c0 	call	81134a2c <OS_EventTaskWait>
811394a4:	e0bff617 	ldw	r2,-40(fp)
811394a8:	e0bffb15 	stw	r2,-20(fp)
811394ac:	e0bffb17 	ldw	r2,-20(fp)
811394b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
811394b4:	11353480 	call	81135348 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811394b8:	0005303a 	rdctl	r2,status
811394bc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811394c0:	e0fff917 	ldw	r3,-28(fp)
811394c4:	00bfff84 	movi	r2,-2
811394c8:	1884703a 	and	r2,r3,r2
811394cc:	1001703a 	wrctl	status,r2
  
  return context;
811394d0:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
811394d4:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
811394d8:	d0a09d17 	ldw	r2,-32140(gp)
811394dc:	10800c43 	ldbu	r2,49(r2)
811394e0:	10803fcc 	andi	r2,r2,255
811394e4:	10000326 	beq	r2,zero,811394f4 <OSQPend+0x1f4>
811394e8:	108000a0 	cmpeqi	r2,r2,2
811394ec:	1000071e 	bne	r2,zero,8113950c <OSQPend+0x20c>
811394f0:	00000b06 	br	81139520 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
811394f4:	d0a09d17 	ldw	r2,-32140(gp)
811394f8:	10800917 	ldw	r2,36(r2)
811394fc:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
81139500:	e0bfff17 	ldw	r2,-4(fp)
81139504:	10000005 	stb	zero,0(r2)
             break;
81139508:	00000e06 	br	81139544 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113950c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81139510:	e0bfff17 	ldw	r2,-4(fp)
81139514:	00c00384 	movi	r3,14
81139518:	10c00005 	stb	r3,0(r2)
             break;
8113951c:	00000906 	br	81139544 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81139520:	d0a09d17 	ldw	r2,-32140(gp)
81139524:	e17ffd17 	ldw	r5,-12(fp)
81139528:	1009883a 	mov	r4,r2
8113952c:	1134c9c0 	call	81134c9c <OS_EventTaskRemove>
             pmsg = (void *)0;
81139530:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81139534:	e0bfff17 	ldw	r2,-4(fp)
81139538:	00c00284 	movi	r3,10
8113953c:	10c00005 	stb	r3,0(r2)
             break;
81139540:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81139544:	d0a09d17 	ldw	r2,-32140(gp)
81139548:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113954c:	d0a09d17 	ldw	r2,-32140(gp)
81139550:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81139554:	d0a09d17 	ldw	r2,-32140(gp)
81139558:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113955c:	d0a09d17 	ldw	r2,-32140(gp)
81139560:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
81139564:	d0a09d17 	ldw	r2,-32140(gp)
81139568:	10000915 	stw	zero,36(r2)
8113956c:	e0bff617 	ldw	r2,-40(fp)
81139570:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139574:	e0bffa17 	ldw	r2,-24(fp)
81139578:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113957c:	e0bff517 	ldw	r2,-44(fp)
}
81139580:	e037883a 	mov	sp,fp
81139584:	dfc00117 	ldw	ra,4(sp)
81139588:	df000017 	ldw	fp,0(sp)
8113958c:	dec00204 	addi	sp,sp,8
81139590:	f800283a 	ret

81139594 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81139594:	defff604 	addi	sp,sp,-40
81139598:	de00012e 	bgeu	sp,et,811395a0 <OSQPendAbort+0xc>
8113959c:	003b68fa 	trap	3
811395a0:	dfc00915 	stw	ra,36(sp)
811395a4:	df000815 	stw	fp,32(sp)
811395a8:	df000804 	addi	fp,sp,32
811395ac:	e13ffd15 	stw	r4,-12(fp)
811395b0:	2805883a 	mov	r2,r5
811395b4:	e1bfff15 	stw	r6,-4(fp)
811395b8:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811395bc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811395c0:	e0bfff17 	ldw	r2,-4(fp)
811395c4:	1000021e 	bne	r2,zero,811395d0 <OSQPendAbort+0x3c>
        return (0);
811395c8:	0005883a 	mov	r2,zero
811395cc:	00004906 	br	811396f4 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811395d0:	e0bffd17 	ldw	r2,-12(fp)
811395d4:	1000051e 	bne	r2,zero,811395ec <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811395d8:	e0bfff17 	ldw	r2,-4(fp)
811395dc:	00c00104 	movi	r3,4
811395e0:	10c00005 	stb	r3,0(r2)
        return (0);
811395e4:	0005883a 	mov	r2,zero
811395e8:	00004206 	br	811396f4 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
811395ec:	e0bffd17 	ldw	r2,-12(fp)
811395f0:	10800003 	ldbu	r2,0(r2)
811395f4:	10803fcc 	andi	r2,r2,255
811395f8:	108000a0 	cmpeqi	r2,r2,2
811395fc:	1000051e 	bne	r2,zero,81139614 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81139600:	e0bfff17 	ldw	r2,-4(fp)
81139604:	00c00044 	movi	r3,1
81139608:	10c00005 	stb	r3,0(r2)
        return (0);
8113960c:	0005883a 	mov	r2,zero
81139610:	00003806 	br	811396f4 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139614:	0005303a 	rdctl	r2,status
81139618:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113961c:	e0fffc17 	ldw	r3,-16(fp)
81139620:	00bfff84 	movi	r2,-2
81139624:	1884703a 	and	r2,r3,r2
81139628:	1001703a 	wrctl	status,r2
  
  return context;
8113962c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139630:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
81139634:	e0bffd17 	ldw	r2,-12(fp)
81139638:	10800283 	ldbu	r2,10(r2)
8113963c:	10803fcc 	andi	r2,r2,255
81139640:	10002526 	beq	r2,zero,811396d8 <OSQPendAbort+0x144>
        nbr_tasks = 0;
81139644:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81139648:	e0bffe03 	ldbu	r2,-8(fp)
8113964c:	10800060 	cmpeqi	r2,r2,1
81139650:	10000e26 	beq	r2,zero,8113968c <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81139654:	00000806 	br	81139678 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81139658:	01c00084 	movi	r7,2
8113965c:	01800104 	movi	r6,4
81139660:	000b883a 	mov	r5,zero
81139664:	e13ffd17 	ldw	r4,-12(fp)
81139668:	113488c0 	call	8113488c <OS_EventTaskRdy>
                     nbr_tasks++;
8113966c:	e0bff803 	ldbu	r2,-32(fp)
81139670:	10800044 	addi	r2,r2,1
81139674:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81139678:	e0bffd17 	ldw	r2,-12(fp)
8113967c:	10800283 	ldbu	r2,10(r2)
81139680:	10803fcc 	andi	r2,r2,255
81139684:	103ff41e 	bne	r2,zero,81139658 <__reset+0xfb119658>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81139688:	00000906 	br	811396b0 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113968c:	01c00084 	movi	r7,2
81139690:	01800104 	movi	r6,4
81139694:	000b883a 	mov	r5,zero
81139698:	e13ffd17 	ldw	r4,-12(fp)
8113969c:	113488c0 	call	8113488c <OS_EventTaskRdy>
                 nbr_tasks++;
811396a0:	e0bff803 	ldbu	r2,-32(fp)
811396a4:	10800044 	addi	r2,r2,1
811396a8:	e0bff805 	stb	r2,-32(fp)
                 break;
811396ac:	0001883a 	nop
811396b0:	e0bff917 	ldw	r2,-28(fp)
811396b4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811396b8:	e0bffa17 	ldw	r2,-24(fp)
811396bc:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
811396c0:	11353480 	call	81135348 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
811396c4:	e0bfff17 	ldw	r2,-4(fp)
811396c8:	00c00384 	movi	r3,14
811396cc:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
811396d0:	e0bff803 	ldbu	r2,-32(fp)
811396d4:	00000706 	br	811396f4 <OSQPendAbort+0x160>
811396d8:	e0bff917 	ldw	r2,-28(fp)
811396dc:	e0bffb15 	stw	r2,-20(fp)
811396e0:	e0bffb17 	ldw	r2,-20(fp)
811396e4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811396e8:	e0bfff17 	ldw	r2,-4(fp)
811396ec:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
811396f0:	0005883a 	mov	r2,zero
}
811396f4:	e037883a 	mov	sp,fp
811396f8:	dfc00117 	ldw	ra,4(sp)
811396fc:	df000017 	ldw	fp,0(sp)
81139700:	dec00204 	addi	sp,sp,8
81139704:	f800283a 	ret

81139708 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
81139708:	defff604 	addi	sp,sp,-40
8113970c:	de00012e 	bgeu	sp,et,81139714 <OSQPost+0xc>
81139710:	003b68fa 	trap	3
81139714:	dfc00915 	stw	ra,36(sp)
81139718:	df000815 	stw	fp,32(sp)
8113971c:	df000804 	addi	fp,sp,32
81139720:	e13ffe15 	stw	r4,-8(fp)
81139724:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81139728:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113972c:	e0bffe17 	ldw	r2,-8(fp)
81139730:	1000021e 	bne	r2,zero,8113973c <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
81139734:	00800104 	movi	r2,4
81139738:	00004a06 	br	81139864 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113973c:	e0bffe17 	ldw	r2,-8(fp)
81139740:	10800003 	ldbu	r2,0(r2)
81139744:	10803fcc 	andi	r2,r2,255
81139748:	108000a0 	cmpeqi	r2,r2,2
8113974c:	1000021e 	bne	r2,zero,81139758 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
81139750:	00800044 	movi	r2,1
81139754:	00004306 	br	81139864 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139758:	0005303a 	rdctl	r2,status
8113975c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139760:	e0fffd17 	ldw	r3,-12(fp)
81139764:	00bfff84 	movi	r2,-2
81139768:	1884703a 	and	r2,r3,r2
8113976c:	1001703a 	wrctl	status,r2
  
  return context;
81139770:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139774:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
81139778:	e0bffe17 	ldw	r2,-8(fp)
8113977c:	10800283 	ldbu	r2,10(r2)
81139780:	10803fcc 	andi	r2,r2,255
81139784:	10000c26 	beq	r2,zero,811397b8 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81139788:	000f883a 	mov	r7,zero
8113978c:	01800104 	movi	r6,4
81139790:	e17fff17 	ldw	r5,-4(fp)
81139794:	e13ffe17 	ldw	r4,-8(fp)
81139798:	113488c0 	call	8113488c <OS_EventTaskRdy>
8113979c:	e0bff817 	ldw	r2,-32(fp)
811397a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811397a4:	e0bff917 	ldw	r2,-28(fp)
811397a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
811397ac:	11353480 	call	81135348 <OS_Sched>
        return (OS_ERR_NONE);
811397b0:	0005883a 	mov	r2,zero
811397b4:	00002b06 	br	81139864 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
811397b8:	e0bffe17 	ldw	r2,-8(fp)
811397bc:	10800117 	ldw	r2,4(r2)
811397c0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
811397c4:	e0bffb17 	ldw	r2,-20(fp)
811397c8:	10c0058b 	ldhu	r3,22(r2)
811397cc:	e0bffb17 	ldw	r2,-20(fp)
811397d0:	1080050b 	ldhu	r2,20(r2)
811397d4:	18ffffcc 	andi	r3,r3,65535
811397d8:	10bfffcc 	andi	r2,r2,65535
811397dc:	18800636 	bltu	r3,r2,811397f8 <OSQPost+0xf0>
811397e0:	e0bff817 	ldw	r2,-32(fp)
811397e4:	e0bffa15 	stw	r2,-24(fp)
811397e8:	e0bffa17 	ldw	r2,-24(fp)
811397ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
811397f0:	00800784 	movi	r2,30
811397f4:	00001b06 	br	81139864 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
811397f8:	e0bffb17 	ldw	r2,-20(fp)
811397fc:	10800317 	ldw	r2,12(r2)
81139800:	11000104 	addi	r4,r2,4
81139804:	e0fffb17 	ldw	r3,-20(fp)
81139808:	19000315 	stw	r4,12(r3)
8113980c:	e0ffff17 	ldw	r3,-4(fp)
81139810:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
81139814:	e0bffb17 	ldw	r2,-20(fp)
81139818:	1080058b 	ldhu	r2,22(r2)
8113981c:	10800044 	addi	r2,r2,1
81139820:	1007883a 	mov	r3,r2
81139824:	e0bffb17 	ldw	r2,-20(fp)
81139828:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113982c:	e0bffb17 	ldw	r2,-20(fp)
81139830:	10c00317 	ldw	r3,12(r2)
81139834:	e0bffb17 	ldw	r2,-20(fp)
81139838:	10800217 	ldw	r2,8(r2)
8113983c:	1880041e 	bne	r3,r2,81139850 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
81139840:	e0bffb17 	ldw	r2,-20(fp)
81139844:	10c00117 	ldw	r3,4(r2)
81139848:	e0bffb17 	ldw	r2,-20(fp)
8113984c:	10c00315 	stw	r3,12(r2)
81139850:	e0bff817 	ldw	r2,-32(fp)
81139854:	e0bffc15 	stw	r2,-16(fp)
81139858:	e0bffc17 	ldw	r2,-16(fp)
8113985c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139860:	0005883a 	mov	r2,zero
}
81139864:	e037883a 	mov	sp,fp
81139868:	dfc00117 	ldw	ra,4(sp)
8113986c:	df000017 	ldw	fp,0(sp)
81139870:	dec00204 	addi	sp,sp,8
81139874:	f800283a 	ret

81139878 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
81139878:	defff604 	addi	sp,sp,-40
8113987c:	de00012e 	bgeu	sp,et,81139884 <OSQPostFront+0xc>
81139880:	003b68fa 	trap	3
81139884:	dfc00915 	stw	ra,36(sp)
81139888:	df000815 	stw	fp,32(sp)
8113988c:	df000804 	addi	fp,sp,32
81139890:	e13ffe15 	stw	r4,-8(fp)
81139894:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139898:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113989c:	e0bffe17 	ldw	r2,-8(fp)
811398a0:	1000021e 	bne	r2,zero,811398ac <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
811398a4:	00800104 	movi	r2,4
811398a8:	00004c06 	br	811399dc <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
811398ac:	e0bffe17 	ldw	r2,-8(fp)
811398b0:	10800003 	ldbu	r2,0(r2)
811398b4:	10803fcc 	andi	r2,r2,255
811398b8:	108000a0 	cmpeqi	r2,r2,2
811398bc:	1000021e 	bne	r2,zero,811398c8 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
811398c0:	00800044 	movi	r2,1
811398c4:	00004506 	br	811399dc <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811398c8:	0005303a 	rdctl	r2,status
811398cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811398d0:	e0fffd17 	ldw	r3,-12(fp)
811398d4:	00bfff84 	movi	r2,-2
811398d8:	1884703a 	and	r2,r3,r2
811398dc:	1001703a 	wrctl	status,r2
  
  return context;
811398e0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811398e4:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
811398e8:	e0bffe17 	ldw	r2,-8(fp)
811398ec:	10800283 	ldbu	r2,10(r2)
811398f0:	10803fcc 	andi	r2,r2,255
811398f4:	10000c26 	beq	r2,zero,81139928 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
811398f8:	000f883a 	mov	r7,zero
811398fc:	01800104 	movi	r6,4
81139900:	e17fff17 	ldw	r5,-4(fp)
81139904:	e13ffe17 	ldw	r4,-8(fp)
81139908:	113488c0 	call	8113488c <OS_EventTaskRdy>
8113990c:	e0bff817 	ldw	r2,-32(fp)
81139910:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139914:	e0bff917 	ldw	r2,-28(fp)
81139918:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113991c:	11353480 	call	81135348 <OS_Sched>
        return (OS_ERR_NONE);
81139920:	0005883a 	mov	r2,zero
81139924:	00002d06 	br	811399dc <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81139928:	e0bffe17 	ldw	r2,-8(fp)
8113992c:	10800117 	ldw	r2,4(r2)
81139930:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81139934:	e0bffb17 	ldw	r2,-20(fp)
81139938:	10c0058b 	ldhu	r3,22(r2)
8113993c:	e0bffb17 	ldw	r2,-20(fp)
81139940:	1080050b 	ldhu	r2,20(r2)
81139944:	18ffffcc 	andi	r3,r3,65535
81139948:	10bfffcc 	andi	r2,r2,65535
8113994c:	18800636 	bltu	r3,r2,81139968 <OSQPostFront+0xf0>
81139950:	e0bff817 	ldw	r2,-32(fp)
81139954:	e0bffa15 	stw	r2,-24(fp)
81139958:	e0bffa17 	ldw	r2,-24(fp)
8113995c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81139960:	00800784 	movi	r2,30
81139964:	00001d06 	br	811399dc <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
81139968:	e0bffb17 	ldw	r2,-20(fp)
8113996c:	10c00417 	ldw	r3,16(r2)
81139970:	e0bffb17 	ldw	r2,-20(fp)
81139974:	10800117 	ldw	r2,4(r2)
81139978:	1880041e 	bne	r3,r2,8113998c <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113997c:	e0bffb17 	ldw	r2,-20(fp)
81139980:	10c00217 	ldw	r3,8(r2)
81139984:	e0bffb17 	ldw	r2,-20(fp)
81139988:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113998c:	e0bffb17 	ldw	r2,-20(fp)
81139990:	10800417 	ldw	r2,16(r2)
81139994:	10ffff04 	addi	r3,r2,-4
81139998:	e0bffb17 	ldw	r2,-20(fp)
8113999c:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
811399a0:	e0bffb17 	ldw	r2,-20(fp)
811399a4:	10800417 	ldw	r2,16(r2)
811399a8:	e0ffff17 	ldw	r3,-4(fp)
811399ac:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
811399b0:	e0bffb17 	ldw	r2,-20(fp)
811399b4:	1080058b 	ldhu	r2,22(r2)
811399b8:	10800044 	addi	r2,r2,1
811399bc:	1007883a 	mov	r3,r2
811399c0:	e0bffb17 	ldw	r2,-20(fp)
811399c4:	10c0058d 	sth	r3,22(r2)
811399c8:	e0bff817 	ldw	r2,-32(fp)
811399cc:	e0bffc15 	stw	r2,-16(fp)
811399d0:	e0bffc17 	ldw	r2,-16(fp)
811399d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811399d8:	0005883a 	mov	r2,zero
}
811399dc:	e037883a 	mov	sp,fp
811399e0:	dfc00117 	ldw	ra,4(sp)
811399e4:	df000017 	ldw	fp,0(sp)
811399e8:	dec00204 	addi	sp,sp,8
811399ec:	f800283a 	ret

811399f0 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
811399f0:	defff504 	addi	sp,sp,-44
811399f4:	de00012e 	bgeu	sp,et,811399fc <OSQPostOpt+0xc>
811399f8:	003b68fa 	trap	3
811399fc:	dfc00a15 	stw	ra,40(sp)
81139a00:	df000915 	stw	fp,36(sp)
81139a04:	df000904 	addi	fp,sp,36
81139a08:	e13ffd15 	stw	r4,-12(fp)
81139a0c:	e17ffe15 	stw	r5,-8(fp)
81139a10:	3005883a 	mov	r2,r6
81139a14:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139a18:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139a1c:	e0bffd17 	ldw	r2,-12(fp)
81139a20:	1000021e 	bne	r2,zero,81139a2c <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
81139a24:	00800104 	movi	r2,4
81139a28:	00007106 	br	81139bf0 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81139a2c:	e0bffd17 	ldw	r2,-12(fp)
81139a30:	10800003 	ldbu	r2,0(r2)
81139a34:	10803fcc 	andi	r2,r2,255
81139a38:	108000a0 	cmpeqi	r2,r2,2
81139a3c:	1000021e 	bne	r2,zero,81139a48 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
81139a40:	00800044 	movi	r2,1
81139a44:	00006a06 	br	81139bf0 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139a48:	0005303a 	rdctl	r2,status
81139a4c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139a50:	e0fffc17 	ldw	r3,-16(fp)
81139a54:	00bfff84 	movi	r2,-2
81139a58:	1884703a 	and	r2,r3,r2
81139a5c:	1001703a 	wrctl	status,r2
  
  return context;
81139a60:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139a64:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
81139a68:	e0bffd17 	ldw	r2,-12(fp)
81139a6c:	10800283 	ldbu	r2,10(r2)
81139a70:	10803fcc 	andi	r2,r2,255
81139a74:	10001d26 	beq	r2,zero,81139aec <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
81139a78:	e0bfff03 	ldbu	r2,-4(fp)
81139a7c:	1080004c 	andi	r2,r2,1
81139a80:	10000b26 	beq	r2,zero,81139ab0 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81139a84:	00000506 	br	81139a9c <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81139a88:	000f883a 	mov	r7,zero
81139a8c:	01800104 	movi	r6,4
81139a90:	e17ffe17 	ldw	r5,-8(fp)
81139a94:	e13ffd17 	ldw	r4,-12(fp)
81139a98:	113488c0 	call	8113488c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81139a9c:	e0bffd17 	ldw	r2,-12(fp)
81139aa0:	10800283 	ldbu	r2,10(r2)
81139aa4:	10803fcc 	andi	r2,r2,255
81139aa8:	103ff71e 	bne	r2,zero,81139a88 <__reset+0xfb119a88>
81139aac:	00000506 	br	81139ac4 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81139ab0:	000f883a 	mov	r7,zero
81139ab4:	01800104 	movi	r6,4
81139ab8:	e17ffe17 	ldw	r5,-8(fp)
81139abc:	e13ffd17 	ldw	r4,-12(fp)
81139ac0:	113488c0 	call	8113488c <OS_EventTaskRdy>
81139ac4:	e0bff717 	ldw	r2,-36(fp)
81139ac8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139acc:	e0bff817 	ldw	r2,-32(fp)
81139ad0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
81139ad4:	e0bfff03 	ldbu	r2,-4(fp)
81139ad8:	1080010c 	andi	r2,r2,4
81139adc:	1000011e 	bne	r2,zero,81139ae4 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
81139ae0:	11353480 	call	81135348 <OS_Sched>
        }
        return (OS_ERR_NONE);
81139ae4:	0005883a 	mov	r2,zero
81139ae8:	00004106 	br	81139bf0 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81139aec:	e0bffd17 	ldw	r2,-12(fp)
81139af0:	10800117 	ldw	r2,4(r2)
81139af4:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81139af8:	e0bffa17 	ldw	r2,-24(fp)
81139afc:	10c0058b 	ldhu	r3,22(r2)
81139b00:	e0bffa17 	ldw	r2,-24(fp)
81139b04:	1080050b 	ldhu	r2,20(r2)
81139b08:	18ffffcc 	andi	r3,r3,65535
81139b0c:	10bfffcc 	andi	r2,r2,65535
81139b10:	18800636 	bltu	r3,r2,81139b2c <OSQPostOpt+0x13c>
81139b14:	e0bff717 	ldw	r2,-36(fp)
81139b18:	e0bff915 	stw	r2,-28(fp)
81139b1c:	e0bff917 	ldw	r2,-28(fp)
81139b20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81139b24:	00800784 	movi	r2,30
81139b28:	00003106 	br	81139bf0 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
81139b2c:	e0bfff03 	ldbu	r2,-4(fp)
81139b30:	1080008c 	andi	r2,r2,2
81139b34:	10001326 	beq	r2,zero,81139b84 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
81139b38:	e0bffa17 	ldw	r2,-24(fp)
81139b3c:	10c00417 	ldw	r3,16(r2)
81139b40:	e0bffa17 	ldw	r2,-24(fp)
81139b44:	10800117 	ldw	r2,4(r2)
81139b48:	1880041e 	bne	r3,r2,81139b5c <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
81139b4c:	e0bffa17 	ldw	r2,-24(fp)
81139b50:	10c00217 	ldw	r3,8(r2)
81139b54:	e0bffa17 	ldw	r2,-24(fp)
81139b58:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
81139b5c:	e0bffa17 	ldw	r2,-24(fp)
81139b60:	10800417 	ldw	r2,16(r2)
81139b64:	10ffff04 	addi	r3,r2,-4
81139b68:	e0bffa17 	ldw	r2,-24(fp)
81139b6c:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
81139b70:	e0bffa17 	ldw	r2,-24(fp)
81139b74:	10800417 	ldw	r2,16(r2)
81139b78:	e0fffe17 	ldw	r3,-8(fp)
81139b7c:	10c00015 	stw	r3,0(r2)
81139b80:	00001006 	br	81139bc4 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
81139b84:	e0bffa17 	ldw	r2,-24(fp)
81139b88:	10800317 	ldw	r2,12(r2)
81139b8c:	11000104 	addi	r4,r2,4
81139b90:	e0fffa17 	ldw	r3,-24(fp)
81139b94:	19000315 	stw	r4,12(r3)
81139b98:	e0fffe17 	ldw	r3,-8(fp)
81139b9c:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
81139ba0:	e0bffa17 	ldw	r2,-24(fp)
81139ba4:	10c00317 	ldw	r3,12(r2)
81139ba8:	e0bffa17 	ldw	r2,-24(fp)
81139bac:	10800217 	ldw	r2,8(r2)
81139bb0:	1880041e 	bne	r3,r2,81139bc4 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
81139bb4:	e0bffa17 	ldw	r2,-24(fp)
81139bb8:	10c00117 	ldw	r3,4(r2)
81139bbc:	e0bffa17 	ldw	r2,-24(fp)
81139bc0:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81139bc4:	e0bffa17 	ldw	r2,-24(fp)
81139bc8:	1080058b 	ldhu	r2,22(r2)
81139bcc:	10800044 	addi	r2,r2,1
81139bd0:	1007883a 	mov	r3,r2
81139bd4:	e0bffa17 	ldw	r2,-24(fp)
81139bd8:	10c0058d 	sth	r3,22(r2)
81139bdc:	e0bff717 	ldw	r2,-36(fp)
81139be0:	e0bffb15 	stw	r2,-20(fp)
81139be4:	e0bffb17 	ldw	r2,-20(fp)
81139be8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139bec:	0005883a 	mov	r2,zero
}
81139bf0:	e037883a 	mov	sp,fp
81139bf4:	dfc00117 	ldw	ra,4(sp)
81139bf8:	df000017 	ldw	fp,0(sp)
81139bfc:	dec00204 	addi	sp,sp,8
81139c00:	f800283a 	ret

81139c04 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
81139c04:	defff604 	addi	sp,sp,-40
81139c08:	de00012e 	bgeu	sp,et,81139c10 <OSQQuery+0xc>
81139c0c:	003b68fa 	trap	3
81139c10:	df000915 	stw	fp,36(sp)
81139c14:	df000904 	addi	fp,sp,36
81139c18:	e13ffe15 	stw	r4,-8(fp)
81139c1c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81139c20:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81139c24:	e0bffe17 	ldw	r2,-8(fp)
81139c28:	1000021e 	bne	r2,zero,81139c34 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81139c2c:	00800104 	movi	r2,4
81139c30:	00004906 	br	81139d58 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
81139c34:	e0bfff17 	ldw	r2,-4(fp)
81139c38:	1000021e 	bne	r2,zero,81139c44 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81139c3c:	00800244 	movi	r2,9
81139c40:	00004506 	br	81139d58 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81139c44:	e0bffe17 	ldw	r2,-8(fp)
81139c48:	10800003 	ldbu	r2,0(r2)
81139c4c:	10803fcc 	andi	r2,r2,255
81139c50:	108000a0 	cmpeqi	r2,r2,2
81139c54:	1000021e 	bne	r2,zero,81139c60 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81139c58:	00800044 	movi	r2,1
81139c5c:	00003e06 	br	81139d58 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139c60:	0005303a 	rdctl	r2,status
81139c64:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139c68:	e0fffd17 	ldw	r3,-12(fp)
81139c6c:	00bfff84 	movi	r2,-2
81139c70:	1884703a 	and	r2,r3,r2
81139c74:	1001703a 	wrctl	status,r2
  
  return context;
81139c78:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139c7c:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
81139c80:	e0bffe17 	ldw	r2,-8(fp)
81139c84:	10c00283 	ldbu	r3,10(r2)
81139c88:	e0bfff17 	ldw	r2,-4(fp)
81139c8c:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
81139c90:	e0bffe17 	ldw	r2,-8(fp)
81139c94:	108002c4 	addi	r2,r2,11
81139c98:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
81139c9c:	e0bfff17 	ldw	r2,-4(fp)
81139ca0:	10800204 	addi	r2,r2,8
81139ca4:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139ca8:	e03ff705 	stb	zero,-36(fp)
81139cac:	00000b06 	br	81139cdc <OSQQuery+0xd8>
        *pdest++ = *psrc++;
81139cb0:	e0bff917 	ldw	r2,-28(fp)
81139cb4:	10c00044 	addi	r3,r2,1
81139cb8:	e0fff915 	stw	r3,-28(fp)
81139cbc:	e0fff817 	ldw	r3,-32(fp)
81139cc0:	19000044 	addi	r4,r3,1
81139cc4:	e13ff815 	stw	r4,-32(fp)
81139cc8:	18c00003 	ldbu	r3,0(r3)
81139ccc:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139cd0:	e0bff703 	ldbu	r2,-36(fp)
81139cd4:	10800044 	addi	r2,r2,1
81139cd8:	e0bff705 	stb	r2,-36(fp)
81139cdc:	e0bff703 	ldbu	r2,-36(fp)
81139ce0:	108001b0 	cmpltui	r2,r2,6
81139ce4:	103ff21e 	bne	r2,zero,81139cb0 <__reset+0xfb119cb0>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
81139ce8:	e0bffe17 	ldw	r2,-8(fp)
81139cec:	10800117 	ldw	r2,4(r2)
81139cf0:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
81139cf4:	e0bffc17 	ldw	r2,-16(fp)
81139cf8:	1080058b 	ldhu	r2,22(r2)
81139cfc:	10bfffcc 	andi	r2,r2,65535
81139d00:	10000626 	beq	r2,zero,81139d1c <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
81139d04:	e0bffc17 	ldw	r2,-16(fp)
81139d08:	10800417 	ldw	r2,16(r2)
81139d0c:	10c00017 	ldw	r3,0(r2)
81139d10:	e0bfff17 	ldw	r2,-4(fp)
81139d14:	10c00015 	stw	r3,0(r2)
81139d18:	00000206 	br	81139d24 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
81139d1c:	e0bfff17 	ldw	r2,-4(fp)
81139d20:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
81139d24:	e0bffc17 	ldw	r2,-16(fp)
81139d28:	10c0058b 	ldhu	r3,22(r2)
81139d2c:	e0bfff17 	ldw	r2,-4(fp)
81139d30:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
81139d34:	e0bffc17 	ldw	r2,-16(fp)
81139d38:	10c0050b 	ldhu	r3,20(r2)
81139d3c:	e0bfff17 	ldw	r2,-4(fp)
81139d40:	10c0018d 	sth	r3,6(r2)
81139d44:	e0bffa17 	ldw	r2,-24(fp)
81139d48:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139d4c:	e0bffb17 	ldw	r2,-20(fp)
81139d50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139d54:	0005883a 	mov	r2,zero
}
81139d58:	e037883a 	mov	sp,fp
81139d5c:	df000017 	ldw	fp,0(sp)
81139d60:	dec00104 	addi	sp,sp,4
81139d64:	f800283a 	ret

81139d68 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
81139d68:	defffb04 	addi	sp,sp,-20
81139d6c:	de00012e 	bgeu	sp,et,81139d74 <OS_QInit+0xc>
81139d70:	003b68fa 	trap	3
81139d74:	dfc00415 	stw	ra,16(sp)
81139d78:	df000315 	stw	fp,12(sp)
81139d7c:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
81139d80:	0140c004 	movi	r5,768
81139d84:	012045b4 	movhi	r4,33046
81139d88:	210f9f04 	addi	r4,r4,15996
81139d8c:	113527c0 	call	8113527c <OS_MemClr>
    pq1 = &OSQTbl[0];
81139d90:	00a045b4 	movhi	r2,33046
81139d94:	108f9f04 	addi	r2,r2,15996
81139d98:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
81139d9c:	00a045b4 	movhi	r2,33046
81139da0:	108fa504 	addi	r2,r2,16020
81139da4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81139da8:	e03ffd0d 	sth	zero,-12(fp)
81139dac:	00000c06 	br	81139de0 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
81139db0:	e0bffe17 	ldw	r2,-8(fp)
81139db4:	e0ffff17 	ldw	r3,-4(fp)
81139db8:	10c00015 	stw	r3,0(r2)
        pq1++;
81139dbc:	e0bffe17 	ldw	r2,-8(fp)
81139dc0:	10800604 	addi	r2,r2,24
81139dc4:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
81139dc8:	e0bfff17 	ldw	r2,-4(fp)
81139dcc:	10800604 	addi	r2,r2,24
81139dd0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81139dd4:	e0bffd0b 	ldhu	r2,-12(fp)
81139dd8:	10800044 	addi	r2,r2,1
81139ddc:	e0bffd0d 	sth	r2,-12(fp)
81139de0:	e0bffd0b 	ldhu	r2,-12(fp)
81139de4:	108007f0 	cmpltui	r2,r2,31
81139de8:	103ff11e 	bne	r2,zero,81139db0 <__reset+0xfb119db0>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
81139dec:	e0bffe17 	ldw	r2,-8(fp)
81139df0:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
81139df4:	00a045b4 	movhi	r2,33046
81139df8:	108f9f04 	addi	r2,r2,15996
81139dfc:	d0a09815 	stw	r2,-32160(gp)
#endif
}
81139e00:	0001883a 	nop
81139e04:	e037883a 	mov	sp,fp
81139e08:	dfc00117 	ldw	ra,4(sp)
81139e0c:	df000017 	ldw	fp,0(sp)
81139e10:	dec00204 	addi	sp,sp,8
81139e14:	f800283a 	ret

81139e18 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
81139e18:	defffa04 	addi	sp,sp,-24
81139e1c:	de00012e 	bgeu	sp,et,81139e24 <OSSemAccept+0xc>
81139e20:	003b68fa 	trap	3
81139e24:	df000515 	stw	fp,20(sp)
81139e28:	df000504 	addi	fp,sp,20
81139e2c:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139e30:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139e34:	e0bfff17 	ldw	r2,-4(fp)
81139e38:	1000021e 	bne	r2,zero,81139e44 <OSSemAccept+0x2c>
        return (0);
81139e3c:	0005883a 	mov	r2,zero
81139e40:	00001f06 	br	81139ec0 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81139e44:	e0bfff17 	ldw	r2,-4(fp)
81139e48:	10800003 	ldbu	r2,0(r2)
81139e4c:	10803fcc 	andi	r2,r2,255
81139e50:	108000e0 	cmpeqi	r2,r2,3
81139e54:	1000021e 	bne	r2,zero,81139e60 <OSSemAccept+0x48>
        return (0);
81139e58:	0005883a 	mov	r2,zero
81139e5c:	00001806 	br	81139ec0 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139e60:	0005303a 	rdctl	r2,status
81139e64:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139e68:	e0fffe17 	ldw	r3,-8(fp)
81139e6c:	00bfff84 	movi	r2,-2
81139e70:	1884703a 	and	r2,r3,r2
81139e74:	1001703a 	wrctl	status,r2
  
  return context;
81139e78:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81139e7c:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
81139e80:	e0bfff17 	ldw	r2,-4(fp)
81139e84:	1080020b 	ldhu	r2,8(r2)
81139e88:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
81139e8c:	e0bffd0b 	ldhu	r2,-12(fp)
81139e90:	10000626 	beq	r2,zero,81139eac <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
81139e94:	e0bfff17 	ldw	r2,-4(fp)
81139e98:	1080020b 	ldhu	r2,8(r2)
81139e9c:	10bfffc4 	addi	r2,r2,-1
81139ea0:	1007883a 	mov	r3,r2
81139ea4:	e0bfff17 	ldw	r2,-4(fp)
81139ea8:	10c0020d 	sth	r3,8(r2)
81139eac:	e0bffb17 	ldw	r2,-20(fp)
81139eb0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139eb4:	e0bffc17 	ldw	r2,-16(fp)
81139eb8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
81139ebc:	e0bffd0b 	ldhu	r2,-12(fp)
}
81139ec0:	e037883a 	mov	sp,fp
81139ec4:	df000017 	ldw	fp,0(sp)
81139ec8:	dec00104 	addi	sp,sp,4
81139ecc:	f800283a 	ret

81139ed0 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
81139ed0:	defff904 	addi	sp,sp,-28
81139ed4:	de00012e 	bgeu	sp,et,81139edc <OSSemCreate+0xc>
81139ed8:	003b68fa 	trap	3
81139edc:	dfc00615 	stw	ra,24(sp)
81139ee0:	df000515 	stw	fp,20(sp)
81139ee4:	df000504 	addi	fp,sp,20
81139ee8:	2005883a 	mov	r2,r4
81139eec:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139ef0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139ef4:	d0a09c03 	ldbu	r2,-32144(gp)
81139ef8:	10803fcc 	andi	r2,r2,255
81139efc:	10000226 	beq	r2,zero,81139f08 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81139f00:	0005883a 	mov	r2,zero
81139f04:	00002506 	br	81139f9c <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139f08:	0005303a 	rdctl	r2,status
81139f0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139f10:	e0fffe17 	ldw	r3,-8(fp)
81139f14:	00bfff84 	movi	r2,-2
81139f18:	1884703a 	and	r2,r3,r2
81139f1c:	1001703a 	wrctl	status,r2
  
  return context;
81139f20:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81139f24:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
81139f28:	d0a09b17 	ldw	r2,-32148(gp)
81139f2c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
81139f30:	d0a09b17 	ldw	r2,-32148(gp)
81139f34:	10000326 	beq	r2,zero,81139f44 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
81139f38:	d0a09b17 	ldw	r2,-32148(gp)
81139f3c:	10800117 	ldw	r2,4(r2)
81139f40:	d0a09b15 	stw	r2,-32148(gp)
81139f44:	e0bffb17 	ldw	r2,-20(fp)
81139f48:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139f4c:	e0bffc17 	ldw	r2,-16(fp)
81139f50:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
81139f54:	e0bffd17 	ldw	r2,-12(fp)
81139f58:	10000f26 	beq	r2,zero,81139f98 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
81139f5c:	e0bffd17 	ldw	r2,-12(fp)
81139f60:	00c000c4 	movi	r3,3
81139f64:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
81139f68:	e0bffd17 	ldw	r2,-12(fp)
81139f6c:	e0ffff0b 	ldhu	r3,-4(fp)
81139f70:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
81139f74:	e0bffd17 	ldw	r2,-12(fp)
81139f78:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
81139f7c:	e0bffd17 	ldw	r2,-12(fp)
81139f80:	00c00fc4 	movi	r3,63
81139f84:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
81139f88:	e0bffd17 	ldw	r2,-12(fp)
81139f8c:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
81139f90:	e13ffd17 	ldw	r4,-12(fp)
81139f94:	1134e640 	call	81134e64 <OS_EventWaitListInit>
    }
    return (pevent);
81139f98:	e0bffd17 	ldw	r2,-12(fp)
}
81139f9c:	e037883a 	mov	sp,fp
81139fa0:	dfc00117 	ldw	ra,4(sp)
81139fa4:	df000017 	ldw	fp,0(sp)
81139fa8:	dec00204 	addi	sp,sp,8
81139fac:	f800283a 	ret

81139fb0 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81139fb0:	defff304 	addi	sp,sp,-52
81139fb4:	de00012e 	bgeu	sp,et,81139fbc <OSSemDel+0xc>
81139fb8:	003b68fa 	trap	3
81139fbc:	dfc00c15 	stw	ra,48(sp)
81139fc0:	df000b15 	stw	fp,44(sp)
81139fc4:	df000b04 	addi	fp,sp,44
81139fc8:	e13ffd15 	stw	r4,-12(fp)
81139fcc:	2805883a 	mov	r2,r5
81139fd0:	e1bfff15 	stw	r6,-4(fp)
81139fd4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139fd8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81139fdc:	e0bfff17 	ldw	r2,-4(fp)
81139fe0:	1000021e 	bne	r2,zero,81139fec <OSSemDel+0x3c>
        return (pevent);
81139fe4:	e0bffd17 	ldw	r2,-12(fp)
81139fe8:	00007e06 	br	8113a1e4 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81139fec:	e0bffd17 	ldw	r2,-12(fp)
81139ff0:	1000051e 	bne	r2,zero,8113a008 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81139ff4:	e0bfff17 	ldw	r2,-4(fp)
81139ff8:	00c00104 	movi	r3,4
81139ffc:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a000:	e0bffd17 	ldw	r2,-12(fp)
8113a004:	00007706 	br	8113a1e4 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113a008:	e0bffd17 	ldw	r2,-12(fp)
8113a00c:	10800003 	ldbu	r2,0(r2)
8113a010:	10803fcc 	andi	r2,r2,255
8113a014:	108000e0 	cmpeqi	r2,r2,3
8113a018:	1000051e 	bne	r2,zero,8113a030 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113a01c:	e0bfff17 	ldw	r2,-4(fp)
8113a020:	00c00044 	movi	r3,1
8113a024:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a028:	e0bffd17 	ldw	r2,-12(fp)
8113a02c:	00006d06 	br	8113a1e4 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a030:	d0a09c03 	ldbu	r2,-32144(gp)
8113a034:	10803fcc 	andi	r2,r2,255
8113a038:	10000526 	beq	r2,zero,8113a050 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113a03c:	e0bfff17 	ldw	r2,-4(fp)
8113a040:	00c003c4 	movi	r3,15
8113a044:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a048:	e0bffd17 	ldw	r2,-12(fp)
8113a04c:	00006506 	br	8113a1e4 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a050:	0005303a 	rdctl	r2,status
8113a054:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a058:	e0fffc17 	ldw	r3,-16(fp)
8113a05c:	00bfff84 	movi	r2,-2
8113a060:	1884703a 	and	r2,r3,r2
8113a064:	1001703a 	wrctl	status,r2
  
  return context;
8113a068:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a06c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113a070:	e0bffd17 	ldw	r2,-12(fp)
8113a074:	10800283 	ldbu	r2,10(r2)
8113a078:	10803fcc 	andi	r2,r2,255
8113a07c:	10000326 	beq	r2,zero,8113a08c <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113a080:	00800044 	movi	r2,1
8113a084:	e0bff505 	stb	r2,-44(fp)
8113a088:	00000106 	br	8113a090 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113a08c:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113a090:	e0bffe03 	ldbu	r2,-8(fp)
8113a094:	10000326 	beq	r2,zero,8113a0a4 <OSSemDel+0xf4>
8113a098:	10800060 	cmpeqi	r2,r2,1
8113a09c:	1000281e 	bne	r2,zero,8113a140 <OSSemDel+0x190>
8113a0a0:	00004506 	br	8113a1b8 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113a0a4:	e0bff503 	ldbu	r2,-44(fp)
8113a0a8:	1000161e 	bne	r2,zero,8113a104 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113a0ac:	e0bffd17 	ldw	r2,-12(fp)
8113a0b0:	00c00fc4 	movi	r3,63
8113a0b4:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113a0b8:	e0bffd17 	ldw	r2,-12(fp)
8113a0bc:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113a0c0:	e0bffd17 	ldw	r2,-12(fp)
8113a0c4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113a0c8:	d0e09b17 	ldw	r3,-32148(gp)
8113a0cc:	e0bffd17 	ldw	r2,-12(fp)
8113a0d0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113a0d4:	e0bffd17 	ldw	r2,-12(fp)
8113a0d8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113a0dc:	e0bffd17 	ldw	r2,-12(fp)
8113a0e0:	d0a09b15 	stw	r2,-32148(gp)
8113a0e4:	e0bff717 	ldw	r2,-36(fp)
8113a0e8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a0ec:	e0bff817 	ldw	r2,-32(fp)
8113a0f0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113a0f4:	e0bfff17 	ldw	r2,-4(fp)
8113a0f8:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113a0fc:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113a100:	00003706 	br	8113a1e0 <OSSemDel+0x230>
8113a104:	e0bff717 	ldw	r2,-36(fp)
8113a108:	e0bff915 	stw	r2,-28(fp)
8113a10c:	e0bff917 	ldw	r2,-28(fp)
8113a110:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113a114:	e0bfff17 	ldw	r2,-4(fp)
8113a118:	00c01244 	movi	r3,73
8113a11c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113a120:	e0bffd17 	ldw	r2,-12(fp)
8113a124:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113a128:	00002d06 	br	8113a1e0 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113a12c:	000f883a 	mov	r7,zero
8113a130:	01800044 	movi	r6,1
8113a134:	000b883a 	mov	r5,zero
8113a138:	e13ffd17 	ldw	r4,-12(fp)
8113a13c:	113488c0 	call	8113488c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113a140:	e0bffd17 	ldw	r2,-12(fp)
8113a144:	10800283 	ldbu	r2,10(r2)
8113a148:	10803fcc 	andi	r2,r2,255
8113a14c:	103ff71e 	bne	r2,zero,8113a12c <__reset+0xfb11a12c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113a150:	e0bffd17 	ldw	r2,-12(fp)
8113a154:	00c00fc4 	movi	r3,63
8113a158:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113a15c:	e0bffd17 	ldw	r2,-12(fp)
8113a160:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113a164:	e0bffd17 	ldw	r2,-12(fp)
8113a168:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113a16c:	d0e09b17 	ldw	r3,-32148(gp)
8113a170:	e0bffd17 	ldw	r2,-12(fp)
8113a174:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113a178:	e0bffd17 	ldw	r2,-12(fp)
8113a17c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113a180:	e0bffd17 	ldw	r2,-12(fp)
8113a184:	d0a09b15 	stw	r2,-32148(gp)
8113a188:	e0bff717 	ldw	r2,-36(fp)
8113a18c:	e0bffa15 	stw	r2,-24(fp)
8113a190:	e0bffa17 	ldw	r2,-24(fp)
8113a194:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113a198:	e0bff503 	ldbu	r2,-44(fp)
8113a19c:	10800058 	cmpnei	r2,r2,1
8113a1a0:	1000011e 	bne	r2,zero,8113a1a8 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113a1a4:	11353480 	call	81135348 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113a1a8:	e0bfff17 	ldw	r2,-4(fp)
8113a1ac:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113a1b0:	e03ff615 	stw	zero,-40(fp)
             break;
8113a1b4:	00000a06 	br	8113a1e0 <OSSemDel+0x230>
8113a1b8:	e0bff717 	ldw	r2,-36(fp)
8113a1bc:	e0bffb15 	stw	r2,-20(fp)
8113a1c0:	e0bffb17 	ldw	r2,-20(fp)
8113a1c4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113a1c8:	e0bfff17 	ldw	r2,-4(fp)
8113a1cc:	00c001c4 	movi	r3,7
8113a1d0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113a1d4:	e0bffd17 	ldw	r2,-12(fp)
8113a1d8:	e0bff615 	stw	r2,-40(fp)
             break;
8113a1dc:	0001883a 	nop
    }
    return (pevent_return);
8113a1e0:	e0bff617 	ldw	r2,-40(fp)
}
8113a1e4:	e037883a 	mov	sp,fp
8113a1e8:	dfc00117 	ldw	ra,4(sp)
8113a1ec:	df000017 	ldw	fp,0(sp)
8113a1f0:	dec00204 	addi	sp,sp,8
8113a1f4:	f800283a 	ret

8113a1f8 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113a1f8:	defff504 	addi	sp,sp,-44
8113a1fc:	de00012e 	bgeu	sp,et,8113a204 <OSSemPend+0xc>
8113a200:	003b68fa 	trap	3
8113a204:	dfc00a15 	stw	ra,40(sp)
8113a208:	df000915 	stw	fp,36(sp)
8113a20c:	df000904 	addi	fp,sp,36
8113a210:	e13ffd15 	stw	r4,-12(fp)
8113a214:	2805883a 	mov	r2,r5
8113a218:	e1bfff15 	stw	r6,-4(fp)
8113a21c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a220:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113a224:	e0bfff17 	ldw	r2,-4(fp)
8113a228:	10007226 	beq	r2,zero,8113a3f4 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a22c:	e0bffd17 	ldw	r2,-12(fp)
8113a230:	1000041e 	bne	r2,zero,8113a244 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113a234:	e0bfff17 	ldw	r2,-4(fp)
8113a238:	00c00104 	movi	r3,4
8113a23c:	10c00005 	stb	r3,0(r2)
        return;
8113a240:	00006d06 	br	8113a3f8 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113a244:	e0bffd17 	ldw	r2,-12(fp)
8113a248:	10800003 	ldbu	r2,0(r2)
8113a24c:	10803fcc 	andi	r2,r2,255
8113a250:	108000e0 	cmpeqi	r2,r2,3
8113a254:	1000041e 	bne	r2,zero,8113a268 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113a258:	e0bfff17 	ldw	r2,-4(fp)
8113a25c:	00c00044 	movi	r3,1
8113a260:	10c00005 	stb	r3,0(r2)
        return;
8113a264:	00006406 	br	8113a3f8 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113a268:	d0a09c03 	ldbu	r2,-32144(gp)
8113a26c:	10803fcc 	andi	r2,r2,255
8113a270:	10000426 	beq	r2,zero,8113a284 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113a274:	e0bfff17 	ldw	r2,-4(fp)
8113a278:	00c00084 	movi	r3,2
8113a27c:	10c00005 	stb	r3,0(r2)
        return;
8113a280:	00005d06 	br	8113a3f8 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113a284:	d0a08a03 	ldbu	r2,-32216(gp)
8113a288:	10803fcc 	andi	r2,r2,255
8113a28c:	10000426 	beq	r2,zero,8113a2a0 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113a290:	e0bfff17 	ldw	r2,-4(fp)
8113a294:	00c00344 	movi	r3,13
8113a298:	10c00005 	stb	r3,0(r2)
        return;
8113a29c:	00005606 	br	8113a3f8 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a2a0:	0005303a 	rdctl	r2,status
8113a2a4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a2a8:	e0fffc17 	ldw	r3,-16(fp)
8113a2ac:	00bfff84 	movi	r2,-2
8113a2b0:	1884703a 	and	r2,r3,r2
8113a2b4:	1001703a 	wrctl	status,r2
  
  return context;
8113a2b8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a2bc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113a2c0:	e0bffd17 	ldw	r2,-12(fp)
8113a2c4:	1080020b 	ldhu	r2,8(r2)
8113a2c8:	10bfffcc 	andi	r2,r2,65535
8113a2cc:	10000d26 	beq	r2,zero,8113a304 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113a2d0:	e0bffd17 	ldw	r2,-12(fp)
8113a2d4:	1080020b 	ldhu	r2,8(r2)
8113a2d8:	10bfffc4 	addi	r2,r2,-1
8113a2dc:	1007883a 	mov	r3,r2
8113a2e0:	e0bffd17 	ldw	r2,-12(fp)
8113a2e4:	10c0020d 	sth	r3,8(r2)
8113a2e8:	e0bff717 	ldw	r2,-36(fp)
8113a2ec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a2f0:	e0bff817 	ldw	r2,-32(fp)
8113a2f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113a2f8:	e0bfff17 	ldw	r2,-4(fp)
8113a2fc:	10000005 	stb	zero,0(r2)
        return;
8113a300:	00003d06 	br	8113a3f8 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113a304:	d0a09d17 	ldw	r2,-32140(gp)
8113a308:	d0e09d17 	ldw	r3,-32140(gp)
8113a30c:	18c00c03 	ldbu	r3,48(r3)
8113a310:	18c00054 	ori	r3,r3,1
8113a314:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113a318:	d0a09d17 	ldw	r2,-32140(gp)
8113a31c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113a320:	d0a09d17 	ldw	r2,-32140(gp)
8113a324:	e0fffe0b 	ldhu	r3,-8(fp)
8113a328:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113a32c:	e13ffd17 	ldw	r4,-12(fp)
8113a330:	1134a2c0 	call	81134a2c <OS_EventTaskWait>
8113a334:	e0bff717 	ldw	r2,-36(fp)
8113a338:	e0bffb15 	stw	r2,-20(fp)
8113a33c:	e0bffb17 	ldw	r2,-20(fp)
8113a340:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113a344:	11353480 	call	81135348 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a348:	0005303a 	rdctl	r2,status
8113a34c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a350:	e0fff917 	ldw	r3,-28(fp)
8113a354:	00bfff84 	movi	r2,-2
8113a358:	1884703a 	and	r2,r3,r2
8113a35c:	1001703a 	wrctl	status,r2
  
  return context;
8113a360:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113a364:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113a368:	d0a09d17 	ldw	r2,-32140(gp)
8113a36c:	10800c43 	ldbu	r2,49(r2)
8113a370:	10803fcc 	andi	r2,r2,255
8113a374:	10000326 	beq	r2,zero,8113a384 <OSSemPend+0x18c>
8113a378:	108000a0 	cmpeqi	r2,r2,2
8113a37c:	1000041e 	bne	r2,zero,8113a390 <OSSemPend+0x198>
8113a380:	00000706 	br	8113a3a0 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113a384:	e0bfff17 	ldw	r2,-4(fp)
8113a388:	10000005 	stb	zero,0(r2)
             break;
8113a38c:	00000c06 	br	8113a3c0 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113a390:	e0bfff17 	ldw	r2,-4(fp)
8113a394:	00c00384 	movi	r3,14
8113a398:	10c00005 	stb	r3,0(r2)
             break;
8113a39c:	00000806 	br	8113a3c0 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113a3a0:	d0a09d17 	ldw	r2,-32140(gp)
8113a3a4:	e17ffd17 	ldw	r5,-12(fp)
8113a3a8:	1009883a 	mov	r4,r2
8113a3ac:	1134c9c0 	call	81134c9c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113a3b0:	e0bfff17 	ldw	r2,-4(fp)
8113a3b4:	00c00284 	movi	r3,10
8113a3b8:	10c00005 	stb	r3,0(r2)
             break;
8113a3bc:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113a3c0:	d0a09d17 	ldw	r2,-32140(gp)
8113a3c4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113a3c8:	d0a09d17 	ldw	r2,-32140(gp)
8113a3cc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113a3d0:	d0a09d17 	ldw	r2,-32140(gp)
8113a3d4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113a3d8:	d0a09d17 	ldw	r2,-32140(gp)
8113a3dc:	10000815 	stw	zero,32(r2)
8113a3e0:	e0bff717 	ldw	r2,-36(fp)
8113a3e4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a3e8:	e0bffa17 	ldw	r2,-24(fp)
8113a3ec:	1001703a 	wrctl	status,r2
8113a3f0:	00000106 	br	8113a3f8 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113a3f4:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113a3f8:	e037883a 	mov	sp,fp
8113a3fc:	dfc00117 	ldw	ra,4(sp)
8113a400:	df000017 	ldw	fp,0(sp)
8113a404:	dec00204 	addi	sp,sp,8
8113a408:	f800283a 	ret

8113a40c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113a40c:	defff604 	addi	sp,sp,-40
8113a410:	de00012e 	bgeu	sp,et,8113a418 <OSSemPendAbort+0xc>
8113a414:	003b68fa 	trap	3
8113a418:	dfc00915 	stw	ra,36(sp)
8113a41c:	df000815 	stw	fp,32(sp)
8113a420:	df000804 	addi	fp,sp,32
8113a424:	e13ffd15 	stw	r4,-12(fp)
8113a428:	2805883a 	mov	r2,r5
8113a42c:	e1bfff15 	stw	r6,-4(fp)
8113a430:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a434:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113a438:	e0bfff17 	ldw	r2,-4(fp)
8113a43c:	1000021e 	bne	r2,zero,8113a448 <OSSemPendAbort+0x3c>
        return (0);
8113a440:	0005883a 	mov	r2,zero
8113a444:	00004906 	br	8113a56c <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a448:	e0bffd17 	ldw	r2,-12(fp)
8113a44c:	1000051e 	bne	r2,zero,8113a464 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113a450:	e0bfff17 	ldw	r2,-4(fp)
8113a454:	00c00104 	movi	r3,4
8113a458:	10c00005 	stb	r3,0(r2)
        return (0);
8113a45c:	0005883a 	mov	r2,zero
8113a460:	00004206 	br	8113a56c <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113a464:	e0bffd17 	ldw	r2,-12(fp)
8113a468:	10800003 	ldbu	r2,0(r2)
8113a46c:	10803fcc 	andi	r2,r2,255
8113a470:	108000e0 	cmpeqi	r2,r2,3
8113a474:	1000051e 	bne	r2,zero,8113a48c <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113a478:	e0bfff17 	ldw	r2,-4(fp)
8113a47c:	00c00044 	movi	r3,1
8113a480:	10c00005 	stb	r3,0(r2)
        return (0);
8113a484:	0005883a 	mov	r2,zero
8113a488:	00003806 	br	8113a56c <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a48c:	0005303a 	rdctl	r2,status
8113a490:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a494:	e0fffc17 	ldw	r3,-16(fp)
8113a498:	00bfff84 	movi	r2,-2
8113a49c:	1884703a 	and	r2,r3,r2
8113a4a0:	1001703a 	wrctl	status,r2
  
  return context;
8113a4a4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a4a8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113a4ac:	e0bffd17 	ldw	r2,-12(fp)
8113a4b0:	10800283 	ldbu	r2,10(r2)
8113a4b4:	10803fcc 	andi	r2,r2,255
8113a4b8:	10002526 	beq	r2,zero,8113a550 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113a4bc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113a4c0:	e0bffe03 	ldbu	r2,-8(fp)
8113a4c4:	10800060 	cmpeqi	r2,r2,1
8113a4c8:	10000e26 	beq	r2,zero,8113a504 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113a4cc:	00000806 	br	8113a4f0 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113a4d0:	01c00084 	movi	r7,2
8113a4d4:	01800044 	movi	r6,1
8113a4d8:	000b883a 	mov	r5,zero
8113a4dc:	e13ffd17 	ldw	r4,-12(fp)
8113a4e0:	113488c0 	call	8113488c <OS_EventTaskRdy>
                     nbr_tasks++;
8113a4e4:	e0bff803 	ldbu	r2,-32(fp)
8113a4e8:	10800044 	addi	r2,r2,1
8113a4ec:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113a4f0:	e0bffd17 	ldw	r2,-12(fp)
8113a4f4:	10800283 	ldbu	r2,10(r2)
8113a4f8:	10803fcc 	andi	r2,r2,255
8113a4fc:	103ff41e 	bne	r2,zero,8113a4d0 <__reset+0xfb11a4d0>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113a500:	00000906 	br	8113a528 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113a504:	01c00084 	movi	r7,2
8113a508:	01800044 	movi	r6,1
8113a50c:	000b883a 	mov	r5,zero
8113a510:	e13ffd17 	ldw	r4,-12(fp)
8113a514:	113488c0 	call	8113488c <OS_EventTaskRdy>
                 nbr_tasks++;
8113a518:	e0bff803 	ldbu	r2,-32(fp)
8113a51c:	10800044 	addi	r2,r2,1
8113a520:	e0bff805 	stb	r2,-32(fp)
                 break;
8113a524:	0001883a 	nop
8113a528:	e0bff917 	ldw	r2,-28(fp)
8113a52c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a530:	e0bffa17 	ldw	r2,-24(fp)
8113a534:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113a538:	11353480 	call	81135348 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113a53c:	e0bfff17 	ldw	r2,-4(fp)
8113a540:	00c00384 	movi	r3,14
8113a544:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113a548:	e0bff803 	ldbu	r2,-32(fp)
8113a54c:	00000706 	br	8113a56c <OSSemPendAbort+0x160>
8113a550:	e0bff917 	ldw	r2,-28(fp)
8113a554:	e0bffb15 	stw	r2,-20(fp)
8113a558:	e0bffb17 	ldw	r2,-20(fp)
8113a55c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a560:	e0bfff17 	ldw	r2,-4(fp)
8113a564:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8113a568:	0005883a 	mov	r2,zero
}
8113a56c:	e037883a 	mov	sp,fp
8113a570:	dfc00117 	ldw	ra,4(sp)
8113a574:	df000017 	ldw	fp,0(sp)
8113a578:	dec00204 	addi	sp,sp,8
8113a57c:	f800283a 	ret

8113a580 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8113a580:	defff804 	addi	sp,sp,-32
8113a584:	de00012e 	bgeu	sp,et,8113a58c <OSSemPost+0xc>
8113a588:	003b68fa 	trap	3
8113a58c:	dfc00715 	stw	ra,28(sp)
8113a590:	df000615 	stw	fp,24(sp)
8113a594:	df000604 	addi	fp,sp,24
8113a598:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a59c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a5a0:	e0bfff17 	ldw	r2,-4(fp)
8113a5a4:	1000021e 	bne	r2,zero,8113a5b0 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113a5a8:	00800104 	movi	r2,4
8113a5ac:	00003506 	br	8113a684 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113a5b0:	e0bfff17 	ldw	r2,-4(fp)
8113a5b4:	10800003 	ldbu	r2,0(r2)
8113a5b8:	10803fcc 	andi	r2,r2,255
8113a5bc:	108000e0 	cmpeqi	r2,r2,3
8113a5c0:	1000021e 	bne	r2,zero,8113a5cc <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8113a5c4:	00800044 	movi	r2,1
8113a5c8:	00002e06 	br	8113a684 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a5cc:	0005303a 	rdctl	r2,status
8113a5d0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a5d4:	e0fffe17 	ldw	r3,-8(fp)
8113a5d8:	00bfff84 	movi	r2,-2
8113a5dc:	1884703a 	and	r2,r3,r2
8113a5e0:	1001703a 	wrctl	status,r2
  
  return context;
8113a5e4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113a5e8:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113a5ec:	e0bfff17 	ldw	r2,-4(fp)
8113a5f0:	10800283 	ldbu	r2,10(r2)
8113a5f4:	10803fcc 	andi	r2,r2,255
8113a5f8:	10000c26 	beq	r2,zero,8113a62c <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113a5fc:	000f883a 	mov	r7,zero
8113a600:	01800044 	movi	r6,1
8113a604:	000b883a 	mov	r5,zero
8113a608:	e13fff17 	ldw	r4,-4(fp)
8113a60c:	113488c0 	call	8113488c <OS_EventTaskRdy>
8113a610:	e0bffa17 	ldw	r2,-24(fp)
8113a614:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a618:	e0bffb17 	ldw	r2,-20(fp)
8113a61c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113a620:	11353480 	call	81135348 <OS_Sched>
        return (OS_ERR_NONE);
8113a624:	0005883a 	mov	r2,zero
8113a628:	00001606 	br	8113a684 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113a62c:	e0bfff17 	ldw	r2,-4(fp)
8113a630:	1080020b 	ldhu	r2,8(r2)
8113a634:	10ffffcc 	andi	r3,r2,65535
8113a638:	00bfffd4 	movui	r2,65535
8113a63c:	18800c26 	beq	r3,r2,8113a670 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8113a640:	e0bfff17 	ldw	r2,-4(fp)
8113a644:	1080020b 	ldhu	r2,8(r2)
8113a648:	10800044 	addi	r2,r2,1
8113a64c:	1007883a 	mov	r3,r2
8113a650:	e0bfff17 	ldw	r2,-4(fp)
8113a654:	10c0020d 	sth	r3,8(r2)
8113a658:	e0bffa17 	ldw	r2,-24(fp)
8113a65c:	e0bffc15 	stw	r2,-16(fp)
8113a660:	e0bffc17 	ldw	r2,-16(fp)
8113a664:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113a668:	0005883a 	mov	r2,zero
8113a66c:	00000506 	br	8113a684 <OSSemPost+0x104>
8113a670:	e0bffa17 	ldw	r2,-24(fp)
8113a674:	e0bffd15 	stw	r2,-12(fp)
8113a678:	e0bffd17 	ldw	r2,-12(fp)
8113a67c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113a680:	00800c84 	movi	r2,50
}
8113a684:	e037883a 	mov	sp,fp
8113a688:	dfc00117 	ldw	ra,4(sp)
8113a68c:	df000017 	ldw	fp,0(sp)
8113a690:	dec00204 	addi	sp,sp,8
8113a694:	f800283a 	ret

8113a698 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113a698:	defff704 	addi	sp,sp,-36
8113a69c:	de00012e 	bgeu	sp,et,8113a6a4 <OSSemQuery+0xc>
8113a6a0:	003b68fa 	trap	3
8113a6a4:	df000815 	stw	fp,32(sp)
8113a6a8:	df000804 	addi	fp,sp,32
8113a6ac:	e13ffe15 	stw	r4,-8(fp)
8113a6b0:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a6b4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113a6b8:	e0bffe17 	ldw	r2,-8(fp)
8113a6bc:	1000021e 	bne	r2,zero,8113a6c8 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113a6c0:	00800104 	movi	r2,4
8113a6c4:	00003606 	br	8113a7a0 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113a6c8:	e0bfff17 	ldw	r2,-4(fp)
8113a6cc:	1000021e 	bne	r2,zero,8113a6d8 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113a6d0:	00800244 	movi	r2,9
8113a6d4:	00003206 	br	8113a7a0 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113a6d8:	e0bffe17 	ldw	r2,-8(fp)
8113a6dc:	10800003 	ldbu	r2,0(r2)
8113a6e0:	10803fcc 	andi	r2,r2,255
8113a6e4:	108000e0 	cmpeqi	r2,r2,3
8113a6e8:	1000021e 	bne	r2,zero,8113a6f4 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113a6ec:	00800044 	movi	r2,1
8113a6f0:	00002b06 	br	8113a7a0 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a6f4:	0005303a 	rdctl	r2,status
8113a6f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a6fc:	e0fffd17 	ldw	r3,-12(fp)
8113a700:	00bfff84 	movi	r2,-2
8113a704:	1884703a 	and	r2,r3,r2
8113a708:	1001703a 	wrctl	status,r2
  
  return context;
8113a70c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a710:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113a714:	e0bffe17 	ldw	r2,-8(fp)
8113a718:	10c00283 	ldbu	r3,10(r2)
8113a71c:	e0bfff17 	ldw	r2,-4(fp)
8113a720:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113a724:	e0bffe17 	ldw	r2,-8(fp)
8113a728:	108002c4 	addi	r2,r2,11
8113a72c:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113a730:	e0bfff17 	ldw	r2,-4(fp)
8113a734:	10800084 	addi	r2,r2,2
8113a738:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113a73c:	e03ffa05 	stb	zero,-24(fp)
8113a740:	00000b06 	br	8113a770 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113a744:	e0bff917 	ldw	r2,-28(fp)
8113a748:	10c00044 	addi	r3,r2,1
8113a74c:	e0fff915 	stw	r3,-28(fp)
8113a750:	e0fff817 	ldw	r3,-32(fp)
8113a754:	19000044 	addi	r4,r3,1
8113a758:	e13ff815 	stw	r4,-32(fp)
8113a75c:	18c00003 	ldbu	r3,0(r3)
8113a760:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113a764:	e0bffa03 	ldbu	r2,-24(fp)
8113a768:	10800044 	addi	r2,r2,1
8113a76c:	e0bffa05 	stb	r2,-24(fp)
8113a770:	e0bffa03 	ldbu	r2,-24(fp)
8113a774:	108001b0 	cmpltui	r2,r2,6
8113a778:	103ff21e 	bne	r2,zero,8113a744 <__reset+0xfb11a744>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113a77c:	e0bffe17 	ldw	r2,-8(fp)
8113a780:	10c0020b 	ldhu	r3,8(r2)
8113a784:	e0bfff17 	ldw	r2,-4(fp)
8113a788:	10c0000d 	sth	r3,0(r2)
8113a78c:	e0bffb17 	ldw	r2,-20(fp)
8113a790:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a794:	e0bffc17 	ldw	r2,-16(fp)
8113a798:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a79c:	0005883a 	mov	r2,zero
}
8113a7a0:	e037883a 	mov	sp,fp
8113a7a4:	df000017 	ldw	fp,0(sp)
8113a7a8:	dec00104 	addi	sp,sp,4
8113a7ac:	f800283a 	ret

8113a7b0 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113a7b0:	defff904 	addi	sp,sp,-28
8113a7b4:	de00012e 	bgeu	sp,et,8113a7bc <OSSemSet+0xc>
8113a7b8:	003b68fa 	trap	3
8113a7bc:	df000615 	stw	fp,24(sp)
8113a7c0:	df000604 	addi	fp,sp,24
8113a7c4:	e13ffd15 	stw	r4,-12(fp)
8113a7c8:	2805883a 	mov	r2,r5
8113a7cc:	e1bfff15 	stw	r6,-4(fp)
8113a7d0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a7d4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113a7d8:	e0bfff17 	ldw	r2,-4(fp)
8113a7dc:	10003126 	beq	r2,zero,8113a8a4 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a7e0:	e0bffd17 	ldw	r2,-12(fp)
8113a7e4:	1000041e 	bne	r2,zero,8113a7f8 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113a7e8:	e0bfff17 	ldw	r2,-4(fp)
8113a7ec:	00c00104 	movi	r3,4
8113a7f0:	10c00005 	stb	r3,0(r2)
        return;
8113a7f4:	00002c06 	br	8113a8a8 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113a7f8:	e0bffd17 	ldw	r2,-12(fp)
8113a7fc:	10800003 	ldbu	r2,0(r2)
8113a800:	10803fcc 	andi	r2,r2,255
8113a804:	108000e0 	cmpeqi	r2,r2,3
8113a808:	1000041e 	bne	r2,zero,8113a81c <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113a80c:	e0bfff17 	ldw	r2,-4(fp)
8113a810:	00c00044 	movi	r3,1
8113a814:	10c00005 	stb	r3,0(r2)
        return;
8113a818:	00002306 	br	8113a8a8 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a81c:	0005303a 	rdctl	r2,status
8113a820:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a824:	e0fffc17 	ldw	r3,-16(fp)
8113a828:	00bfff84 	movi	r2,-2
8113a82c:	1884703a 	and	r2,r3,r2
8113a830:	1001703a 	wrctl	status,r2
  
  return context;
8113a834:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a838:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113a83c:	e0bfff17 	ldw	r2,-4(fp)
8113a840:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113a844:	e0bffd17 	ldw	r2,-12(fp)
8113a848:	1080020b 	ldhu	r2,8(r2)
8113a84c:	10bfffcc 	andi	r2,r2,65535
8113a850:	10000426 	beq	r2,zero,8113a864 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113a854:	e0bffd17 	ldw	r2,-12(fp)
8113a858:	e0fffe0b 	ldhu	r3,-8(fp)
8113a85c:	10c0020d 	sth	r3,8(r2)
8113a860:	00000b06 	br	8113a890 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113a864:	e0bffd17 	ldw	r2,-12(fp)
8113a868:	10800283 	ldbu	r2,10(r2)
8113a86c:	10803fcc 	andi	r2,r2,255
8113a870:	1000041e 	bne	r2,zero,8113a884 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113a874:	e0bffd17 	ldw	r2,-12(fp)
8113a878:	e0fffe0b 	ldhu	r3,-8(fp)
8113a87c:	10c0020d 	sth	r3,8(r2)
8113a880:	00000306 	br	8113a890 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113a884:	e0bfff17 	ldw	r2,-4(fp)
8113a888:	00c01244 	movi	r3,73
8113a88c:	10c00005 	stb	r3,0(r2)
8113a890:	e0bffa17 	ldw	r2,-24(fp)
8113a894:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a898:	e0bffb17 	ldw	r2,-20(fp)
8113a89c:	1001703a 	wrctl	status,r2
8113a8a0:	00000106 	br	8113a8a8 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113a8a4:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113a8a8:	e037883a 	mov	sp,fp
8113a8ac:	df000017 	ldw	fp,0(sp)
8113a8b0:	dec00104 	addi	sp,sp,4
8113a8b4:	f800283a 	ret

8113a8b8 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113a8b8:	defff104 	addi	sp,sp,-60
8113a8bc:	de00012e 	bgeu	sp,et,8113a8c4 <OSTaskChangePrio+0xc>
8113a8c0:	003b68fa 	trap	3
8113a8c4:	dfc00e15 	stw	ra,56(sp)
8113a8c8:	df000d15 	stw	fp,52(sp)
8113a8cc:	df000d04 	addi	fp,sp,52
8113a8d0:	2007883a 	mov	r3,r4
8113a8d4:	2805883a 	mov	r2,r5
8113a8d8:	e0fffe05 	stb	r3,-8(fp)
8113a8dc:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113a8e0:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113a8e4:	e0bffe03 	ldbu	r2,-8(fp)
8113a8e8:	10800ab0 	cmpltui	r2,r2,42
8113a8ec:	1000051e 	bne	r2,zero,8113a904 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113a8f0:	e0bffe03 	ldbu	r2,-8(fp)
8113a8f4:	10803fe0 	cmpeqi	r2,r2,255
8113a8f8:	1000021e 	bne	r2,zero,8113a904 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113a8fc:	00800a84 	movi	r2,42
8113a900:	00012606 	br	8113ad9c <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113a904:	e0bfff03 	ldbu	r2,-4(fp)
8113a908:	10800ab0 	cmpltui	r2,r2,42
8113a90c:	1000021e 	bne	r2,zero,8113a918 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113a910:	00800a84 	movi	r2,42
8113a914:	00012106 	br	8113ad9c <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a918:	0005303a 	rdctl	r2,status
8113a91c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a920:	e0fffd17 	ldw	r3,-12(fp)
8113a924:	00bfff84 	movi	r2,-2
8113a928:	1884703a 	and	r2,r3,r2
8113a92c:	1001703a 	wrctl	status,r2
  
  return context;
8113a930:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a934:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113a938:	e0ffff03 	ldbu	r3,-4(fp)
8113a93c:	00a045b4 	movhi	r2,33046
8113a940:	109e0d04 	addi	r2,r2,30772
8113a944:	18c7883a 	add	r3,r3,r3
8113a948:	18c7883a 	add	r3,r3,r3
8113a94c:	10c5883a 	add	r2,r2,r3
8113a950:	10800017 	ldw	r2,0(r2)
8113a954:	10000626 	beq	r2,zero,8113a970 <OSTaskChangePrio+0xb8>
8113a958:	e0bff517 	ldw	r2,-44(fp)
8113a95c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a960:	e0bff617 	ldw	r2,-40(fp)
8113a964:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113a968:	00800a04 	movi	r2,40
8113a96c:	00010b06 	br	8113ad9c <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113a970:	e0bffe03 	ldbu	r2,-8(fp)
8113a974:	10803fd8 	cmpnei	r2,r2,255
8113a978:	1000031e 	bne	r2,zero,8113a988 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113a97c:	d0a09d17 	ldw	r2,-32140(gp)
8113a980:	10800c83 	ldbu	r2,50(r2)
8113a984:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113a988:	e0fffe03 	ldbu	r3,-8(fp)
8113a98c:	00a045b4 	movhi	r2,33046
8113a990:	109e0d04 	addi	r2,r2,30772
8113a994:	18c7883a 	add	r3,r3,r3
8113a998:	18c7883a 	add	r3,r3,r3
8113a99c:	10c5883a 	add	r2,r2,r3
8113a9a0:	10800017 	ldw	r2,0(r2)
8113a9a4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113a9a8:	e0bff817 	ldw	r2,-32(fp)
8113a9ac:	1000061e 	bne	r2,zero,8113a9c8 <OSTaskChangePrio+0x110>
8113a9b0:	e0bff517 	ldw	r2,-44(fp)
8113a9b4:	e0bff715 	stw	r2,-36(fp)
8113a9b8:	e0bff717 	ldw	r2,-36(fp)
8113a9bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113a9c0:	00800a44 	movi	r2,41
8113a9c4:	0000f506 	br	8113ad9c <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113a9c8:	e0bff817 	ldw	r2,-32(fp)
8113a9cc:	10800058 	cmpnei	r2,r2,1
8113a9d0:	1000061e 	bne	r2,zero,8113a9ec <OSTaskChangePrio+0x134>
8113a9d4:	e0bff517 	ldw	r2,-44(fp)
8113a9d8:	e0bff915 	stw	r2,-28(fp)
8113a9dc:	e0bff917 	ldw	r2,-28(fp)
8113a9e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113a9e4:	008010c4 	movi	r2,67
8113a9e8:	0000ec06 	br	8113ad9c <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113a9ec:	e0bfff03 	ldbu	r2,-4(fp)
8113a9f0:	1004d0fa 	srli	r2,r2,3
8113a9f4:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113a9f8:	e0bfff03 	ldbu	r2,-4(fp)
8113a9fc:	108001cc 	andi	r2,r2,7
8113aa00:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113aa04:	e0bffb03 	ldbu	r2,-20(fp)
8113aa08:	00c00044 	movi	r3,1
8113aa0c:	1884983a 	sll	r2,r3,r2
8113aa10:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113aa14:	e0bffb43 	ldbu	r2,-19(fp)
8113aa18:	00c00044 	movi	r3,1
8113aa1c:	1884983a 	sll	r2,r3,r2
8113aa20:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113aa24:	e0fffe03 	ldbu	r3,-8(fp)
8113aa28:	00a045b4 	movhi	r2,33046
8113aa2c:	109e0d04 	addi	r2,r2,30772
8113aa30:	18c7883a 	add	r3,r3,r3
8113aa34:	18c7883a 	add	r3,r3,r3
8113aa38:	10c5883a 	add	r2,r2,r3
8113aa3c:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113aa40:	e0ffff03 	ldbu	r3,-4(fp)
8113aa44:	00a045b4 	movhi	r2,33046
8113aa48:	109e0d04 	addi	r2,r2,30772
8113aa4c:	18c7883a 	add	r3,r3,r3
8113aa50:	18c7883a 	add	r3,r3,r3
8113aa54:	10c5883a 	add	r2,r2,r3
8113aa58:	e0fff817 	ldw	r3,-32(fp)
8113aa5c:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113aa60:	e0bff817 	ldw	r2,-32(fp)
8113aa64:	10800d03 	ldbu	r2,52(r2)
8113aa68:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113aa6c:	e0bff817 	ldw	r2,-32(fp)
8113aa70:	10800d83 	ldbu	r2,54(r2)
8113aa74:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113aa78:	e0bff817 	ldw	r2,-32(fp)
8113aa7c:	10800d43 	ldbu	r2,53(r2)
8113aa80:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113aa84:	e0fffc03 	ldbu	r3,-16(fp)
8113aa88:	d0a09944 	addi	r2,gp,-32155
8113aa8c:	1885883a 	add	r2,r3,r2
8113aa90:	10c00003 	ldbu	r3,0(r2)
8113aa94:	e0bffc83 	ldbu	r2,-14(fp)
8113aa98:	1884703a 	and	r2,r3,r2
8113aa9c:	10803fcc 	andi	r2,r2,255
8113aaa0:	10002826 	beq	r2,zero,8113ab44 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113aaa4:	e0fffc03 	ldbu	r3,-16(fp)
8113aaa8:	e13ffc03 	ldbu	r4,-16(fp)
8113aaac:	d0a09944 	addi	r2,gp,-32155
8113aab0:	2085883a 	add	r2,r4,r2
8113aab4:	10800003 	ldbu	r2,0(r2)
8113aab8:	1009883a 	mov	r4,r2
8113aabc:	e0bffc83 	ldbu	r2,-14(fp)
8113aac0:	0084303a 	nor	r2,zero,r2
8113aac4:	2084703a 	and	r2,r4,r2
8113aac8:	1009883a 	mov	r4,r2
8113aacc:	d0a09944 	addi	r2,gp,-32155
8113aad0:	1885883a 	add	r2,r3,r2
8113aad4:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113aad8:	e0fffc03 	ldbu	r3,-16(fp)
8113aadc:	d0a09944 	addi	r2,gp,-32155
8113aae0:	1885883a 	add	r2,r3,r2
8113aae4:	10800003 	ldbu	r2,0(r2)
8113aae8:	10803fcc 	andi	r2,r2,255
8113aaec:	1000061e 	bne	r2,zero,8113ab08 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113aaf0:	e0bffc43 	ldbu	r2,-15(fp)
8113aaf4:	0084303a 	nor	r2,zero,r2
8113aaf8:	1007883a 	mov	r3,r2
8113aafc:	d0a09903 	ldbu	r2,-32156(gp)
8113ab00:	1884703a 	and	r2,r3,r2
8113ab04:	d0a09905 	stb	r2,-32156(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113ab08:	d0e09903 	ldbu	r3,-32156(gp)
8113ab0c:	e0bffb83 	ldbu	r2,-18(fp)
8113ab10:	1884b03a 	or	r2,r3,r2
8113ab14:	d0a09905 	stb	r2,-32156(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113ab18:	e0fffb03 	ldbu	r3,-20(fp)
8113ab1c:	e13ffb03 	ldbu	r4,-20(fp)
8113ab20:	d0a09944 	addi	r2,gp,-32155
8113ab24:	2085883a 	add	r2,r4,r2
8113ab28:	11000003 	ldbu	r4,0(r2)
8113ab2c:	e0bffbc3 	ldbu	r2,-17(fp)
8113ab30:	2084b03a 	or	r2,r4,r2
8113ab34:	1009883a 	mov	r4,r2
8113ab38:	d0a09944 	addi	r2,gp,-32155
8113ab3c:	1885883a 	add	r2,r3,r2
8113ab40:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113ab44:	e0bff817 	ldw	r2,-32(fp)
8113ab48:	10800717 	ldw	r2,28(r2)
8113ab4c:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113ab50:	e0bff317 	ldw	r2,-52(fp)
8113ab54:	10003326 	beq	r2,zero,8113ac24 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113ab58:	e0bffc03 	ldbu	r2,-16(fp)
8113ab5c:	e0fffc03 	ldbu	r3,-16(fp)
8113ab60:	e13ff317 	ldw	r4,-52(fp)
8113ab64:	20c7883a 	add	r3,r4,r3
8113ab68:	18c002c4 	addi	r3,r3,11
8113ab6c:	18c00003 	ldbu	r3,0(r3)
8113ab70:	1809883a 	mov	r4,r3
8113ab74:	e0fffc83 	ldbu	r3,-14(fp)
8113ab78:	00c6303a 	nor	r3,zero,r3
8113ab7c:	20c6703a 	and	r3,r4,r3
8113ab80:	1809883a 	mov	r4,r3
8113ab84:	e0fff317 	ldw	r3,-52(fp)
8113ab88:	1885883a 	add	r2,r3,r2
8113ab8c:	108002c4 	addi	r2,r2,11
8113ab90:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113ab94:	e0bffc03 	ldbu	r2,-16(fp)
8113ab98:	e0fff317 	ldw	r3,-52(fp)
8113ab9c:	1885883a 	add	r2,r3,r2
8113aba0:	108002c4 	addi	r2,r2,11
8113aba4:	10800003 	ldbu	r2,0(r2)
8113aba8:	10803fcc 	andi	r2,r2,255
8113abac:	1000091e 	bne	r2,zero,8113abd4 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113abb0:	e0bff317 	ldw	r2,-52(fp)
8113abb4:	10800283 	ldbu	r2,10(r2)
8113abb8:	1007883a 	mov	r3,r2
8113abbc:	e0bffc43 	ldbu	r2,-15(fp)
8113abc0:	0084303a 	nor	r2,zero,r2
8113abc4:	1884703a 	and	r2,r3,r2
8113abc8:	1007883a 	mov	r3,r2
8113abcc:	e0bff317 	ldw	r2,-52(fp)
8113abd0:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113abd4:	e0bff317 	ldw	r2,-52(fp)
8113abd8:	10c00283 	ldbu	r3,10(r2)
8113abdc:	e0bffb83 	ldbu	r2,-18(fp)
8113abe0:	1884b03a 	or	r2,r3,r2
8113abe4:	1007883a 	mov	r3,r2
8113abe8:	e0bff317 	ldw	r2,-52(fp)
8113abec:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113abf0:	e0bffb03 	ldbu	r2,-20(fp)
8113abf4:	e0fffb03 	ldbu	r3,-20(fp)
8113abf8:	e13ff317 	ldw	r4,-52(fp)
8113abfc:	20c7883a 	add	r3,r4,r3
8113ac00:	18c002c4 	addi	r3,r3,11
8113ac04:	19000003 	ldbu	r4,0(r3)
8113ac08:	e0fffbc3 	ldbu	r3,-17(fp)
8113ac0c:	20c6b03a 	or	r3,r4,r3
8113ac10:	1809883a 	mov	r4,r3
8113ac14:	e0fff317 	ldw	r3,-52(fp)
8113ac18:	1885883a 	add	r2,r3,r2
8113ac1c:	108002c4 	addi	r2,r2,11
8113ac20:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113ac24:	e0bff817 	ldw	r2,-32(fp)
8113ac28:	10800817 	ldw	r2,32(r2)
8113ac2c:	10004226 	beq	r2,zero,8113ad38 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113ac30:	e0bff817 	ldw	r2,-32(fp)
8113ac34:	10800817 	ldw	r2,32(r2)
8113ac38:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113ac3c:	e0bff417 	ldw	r2,-48(fp)
8113ac40:	10800017 	ldw	r2,0(r2)
8113ac44:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113ac48:	00003906 	br	8113ad30 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113ac4c:	e0bffc03 	ldbu	r2,-16(fp)
8113ac50:	e0fffc03 	ldbu	r3,-16(fp)
8113ac54:	e13ff317 	ldw	r4,-52(fp)
8113ac58:	20c7883a 	add	r3,r4,r3
8113ac5c:	18c002c4 	addi	r3,r3,11
8113ac60:	18c00003 	ldbu	r3,0(r3)
8113ac64:	1809883a 	mov	r4,r3
8113ac68:	e0fffc83 	ldbu	r3,-14(fp)
8113ac6c:	00c6303a 	nor	r3,zero,r3
8113ac70:	20c6703a 	and	r3,r4,r3
8113ac74:	1809883a 	mov	r4,r3
8113ac78:	e0fff317 	ldw	r3,-52(fp)
8113ac7c:	1885883a 	add	r2,r3,r2
8113ac80:	108002c4 	addi	r2,r2,11
8113ac84:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113ac88:	e0bffc03 	ldbu	r2,-16(fp)
8113ac8c:	e0fff317 	ldw	r3,-52(fp)
8113ac90:	1885883a 	add	r2,r3,r2
8113ac94:	108002c4 	addi	r2,r2,11
8113ac98:	10800003 	ldbu	r2,0(r2)
8113ac9c:	10803fcc 	andi	r2,r2,255
8113aca0:	1000091e 	bne	r2,zero,8113acc8 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113aca4:	e0bff317 	ldw	r2,-52(fp)
8113aca8:	10800283 	ldbu	r2,10(r2)
8113acac:	1007883a 	mov	r3,r2
8113acb0:	e0bffc43 	ldbu	r2,-15(fp)
8113acb4:	0084303a 	nor	r2,zero,r2
8113acb8:	1884703a 	and	r2,r3,r2
8113acbc:	1007883a 	mov	r3,r2
8113acc0:	e0bff317 	ldw	r2,-52(fp)
8113acc4:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113acc8:	e0bff317 	ldw	r2,-52(fp)
8113accc:	10c00283 	ldbu	r3,10(r2)
8113acd0:	e0bffb83 	ldbu	r2,-18(fp)
8113acd4:	1884b03a 	or	r2,r3,r2
8113acd8:	1007883a 	mov	r3,r2
8113acdc:	e0bff317 	ldw	r2,-52(fp)
8113ace0:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113ace4:	e0bffb03 	ldbu	r2,-20(fp)
8113ace8:	e0fffb03 	ldbu	r3,-20(fp)
8113acec:	e13ff317 	ldw	r4,-52(fp)
8113acf0:	20c7883a 	add	r3,r4,r3
8113acf4:	18c002c4 	addi	r3,r3,11
8113acf8:	19000003 	ldbu	r4,0(r3)
8113acfc:	e0fffbc3 	ldbu	r3,-17(fp)
8113ad00:	20c6b03a 	or	r3,r4,r3
8113ad04:	1809883a 	mov	r4,r3
8113ad08:	e0fff317 	ldw	r3,-52(fp)
8113ad0c:	1885883a 	add	r2,r3,r2
8113ad10:	108002c4 	addi	r2,r2,11
8113ad14:	11000005 	stb	r4,0(r2)
            pevents++;
8113ad18:	e0bff417 	ldw	r2,-48(fp)
8113ad1c:	10800104 	addi	r2,r2,4
8113ad20:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113ad24:	e0bff417 	ldw	r2,-48(fp)
8113ad28:	10800017 	ldw	r2,0(r2)
8113ad2c:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113ad30:	e0bff317 	ldw	r2,-52(fp)
8113ad34:	103fc51e 	bne	r2,zero,8113ac4c <__reset+0xfb11ac4c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113ad38:	e0bff817 	ldw	r2,-32(fp)
8113ad3c:	e0ffff03 	ldbu	r3,-4(fp)
8113ad40:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113ad44:	e0bff817 	ldw	r2,-32(fp)
8113ad48:	e0fffb03 	ldbu	r3,-20(fp)
8113ad4c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113ad50:	e0bff817 	ldw	r2,-32(fp)
8113ad54:	e0fffb43 	ldbu	r3,-19(fp)
8113ad58:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113ad5c:	e0bff817 	ldw	r2,-32(fp)
8113ad60:	e0fffb83 	ldbu	r3,-18(fp)
8113ad64:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113ad68:	e0bff817 	ldw	r2,-32(fp)
8113ad6c:	e0fffbc3 	ldbu	r3,-17(fp)
8113ad70:	10c00d45 	stb	r3,53(r2)
8113ad74:	e0bff517 	ldw	r2,-44(fp)
8113ad78:	e0bffa15 	stw	r2,-24(fp)
8113ad7c:	e0bffa17 	ldw	r2,-24(fp)
8113ad80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113ad84:	d0a08c03 	ldbu	r2,-32208(gp)
8113ad88:	10803fcc 	andi	r2,r2,255
8113ad8c:	10800058 	cmpnei	r2,r2,1
8113ad90:	1000011e 	bne	r2,zero,8113ad98 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113ad94:	11353480 	call	81135348 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113ad98:	0005883a 	mov	r2,zero
}
8113ad9c:	e037883a 	mov	sp,fp
8113ada0:	dfc00117 	ldw	ra,4(sp)
8113ada4:	df000017 	ldw	fp,0(sp)
8113ada8:	dec00204 	addi	sp,sp,8
8113adac:	f800283a 	ret

8113adb0 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8113adb0:	deffee04 	addi	sp,sp,-72
8113adb4:	de00012e 	bgeu	sp,et,8113adbc <OSTaskCreate+0xc>
8113adb8:	003b68fa 	trap	3
8113adbc:	dfc01115 	stw	ra,68(sp)
8113adc0:	df001015 	stw	fp,64(sp)
8113adc4:	df001004 	addi	fp,sp,64
8113adc8:	e13ffc15 	stw	r4,-16(fp)
8113adcc:	e17ffd15 	stw	r5,-12(fp)
8113add0:	e1bffe15 	stw	r6,-8(fp)
8113add4:	3805883a 	mov	r2,r7
8113add8:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113addc:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113ade0:	e0bfff03 	ldbu	r2,-4(fp)
8113ade4:	10800af0 	cmpltui	r2,r2,43
8113ade8:	1000021e 	bne	r2,zero,8113adf4 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113adec:	00800a84 	movi	r2,42
8113adf0:	00005706 	br	8113af50 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113adf4:	0005303a 	rdctl	r2,status
8113adf8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113adfc:	e0fffb17 	ldw	r3,-20(fp)
8113ae00:	00bfff84 	movi	r2,-2
8113ae04:	1884703a 	and	r2,r3,r2
8113ae08:	1001703a 	wrctl	status,r2
  
  return context;
8113ae0c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113ae10:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113ae14:	d0a09c03 	ldbu	r2,-32144(gp)
8113ae18:	10803fcc 	andi	r2,r2,255
8113ae1c:	10000626 	beq	r2,zero,8113ae38 <OSTaskCreate+0x88>
8113ae20:	e0bff317 	ldw	r2,-52(fp)
8113ae24:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ae28:	e0bff417 	ldw	r2,-48(fp)
8113ae2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113ae30:	00800f04 	movi	r2,60
8113ae34:	00004606 	br	8113af50 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113ae38:	e0ffff03 	ldbu	r3,-4(fp)
8113ae3c:	00a045b4 	movhi	r2,33046
8113ae40:	109e0d04 	addi	r2,r2,30772
8113ae44:	18c7883a 	add	r3,r3,r3
8113ae48:	18c7883a 	add	r3,r3,r3
8113ae4c:	10c5883a 	add	r2,r2,r3
8113ae50:	10800017 	ldw	r2,0(r2)
8113ae54:	1000391e 	bne	r2,zero,8113af3c <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113ae58:	e0ffff03 	ldbu	r3,-4(fp)
8113ae5c:	00a045b4 	movhi	r2,33046
8113ae60:	109e0d04 	addi	r2,r2,30772
8113ae64:	18c7883a 	add	r3,r3,r3
8113ae68:	18c7883a 	add	r3,r3,r3
8113ae6c:	10c5883a 	add	r2,r2,r3
8113ae70:	00c00044 	movi	r3,1
8113ae74:	10c00015 	stw	r3,0(r2)
8113ae78:	e0bff317 	ldw	r2,-52(fp)
8113ae7c:	e0bff515 	stw	r2,-44(fp)
8113ae80:	e0bff517 	ldw	r2,-44(fp)
8113ae84:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8113ae88:	000f883a 	mov	r7,zero
8113ae8c:	e1bffe17 	ldw	r6,-8(fp)
8113ae90:	e17ffd17 	ldw	r5,-12(fp)
8113ae94:	e13ffc17 	ldw	r4,-16(fp)
8113ae98:	11464580 	call	81146458 <OSTaskStkInit>
8113ae9c:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8113aea0:	e0bfff03 	ldbu	r2,-4(fp)
8113aea4:	d8000215 	stw	zero,8(sp)
8113aea8:	d8000115 	stw	zero,4(sp)
8113aeac:	d8000015 	stw	zero,0(sp)
8113aeb0:	000f883a 	mov	r7,zero
8113aeb4:	000d883a 	mov	r6,zero
8113aeb8:	e17ff717 	ldw	r5,-36(fp)
8113aebc:	1009883a 	mov	r4,r2
8113aec0:	11357900 	call	81135790 <OS_TCBInit>
8113aec4:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8113aec8:	e0bff803 	ldbu	r2,-32(fp)
8113aecc:	1000061e 	bne	r2,zero,8113aee8 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8113aed0:	d0a08c03 	ldbu	r2,-32208(gp)
8113aed4:	10803fcc 	andi	r2,r2,255
8113aed8:	10800058 	cmpnei	r2,r2,1
8113aedc:	1000151e 	bne	r2,zero,8113af34 <OSTaskCreate+0x184>
                OS_Sched();
8113aee0:	11353480 	call	81135348 <OS_Sched>
8113aee4:	00001306 	br	8113af34 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aee8:	0005303a 	rdctl	r2,status
8113aeec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aef0:	e0fffa17 	ldw	r3,-24(fp)
8113aef4:	00bfff84 	movi	r2,-2
8113aef8:	1884703a 	and	r2,r3,r2
8113aefc:	1001703a 	wrctl	status,r2
  
  return context;
8113af00:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113af04:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8113af08:	e0ffff03 	ldbu	r3,-4(fp)
8113af0c:	00a045b4 	movhi	r2,33046
8113af10:	109e0d04 	addi	r2,r2,30772
8113af14:	18c7883a 	add	r3,r3,r3
8113af18:	18c7883a 	add	r3,r3,r3
8113af1c:	10c5883a 	add	r2,r2,r3
8113af20:	10000015 	stw	zero,0(r2)
8113af24:	e0bff317 	ldw	r2,-52(fp)
8113af28:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113af2c:	e0bff617 	ldw	r2,-40(fp)
8113af30:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113af34:	e0bff803 	ldbu	r2,-32(fp)
8113af38:	00000506 	br	8113af50 <OSTaskCreate+0x1a0>
8113af3c:	e0bff317 	ldw	r2,-52(fp)
8113af40:	e0bff915 	stw	r2,-28(fp)
8113af44:	e0bff917 	ldw	r2,-28(fp)
8113af48:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113af4c:	00800a04 	movi	r2,40
}
8113af50:	e037883a 	mov	sp,fp
8113af54:	dfc00117 	ldw	ra,4(sp)
8113af58:	df000017 	ldw	fp,0(sp)
8113af5c:	dec00204 	addi	sp,sp,8
8113af60:	f800283a 	ret

8113af64 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113af64:	deffec04 	addi	sp,sp,-80
8113af68:	de00012e 	bgeu	sp,et,8113af70 <OSTaskCreateExt+0xc>
8113af6c:	003b68fa 	trap	3
8113af70:	dfc01315 	stw	ra,76(sp)
8113af74:	df001215 	stw	fp,72(sp)
8113af78:	df001204 	addi	fp,sp,72
8113af7c:	e13ffa15 	stw	r4,-24(fp)
8113af80:	e17ffb15 	stw	r5,-20(fp)
8113af84:	e1bffc15 	stw	r6,-16(fp)
8113af88:	3809883a 	mov	r4,r7
8113af8c:	e0c00217 	ldw	r3,8(fp)
8113af90:	e0800617 	ldw	r2,24(fp)
8113af94:	e13ffd05 	stb	r4,-12(fp)
8113af98:	e0fffe0d 	sth	r3,-8(fp)
8113af9c:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113afa0:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113afa4:	e0bffd03 	ldbu	r2,-12(fp)
8113afa8:	10800af0 	cmpltui	r2,r2,43
8113afac:	1000021e 	bne	r2,zero,8113afb8 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113afb0:	00800a84 	movi	r2,42
8113afb4:	00006106 	br	8113b13c <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113afb8:	0005303a 	rdctl	r2,status
8113afbc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113afc0:	e0fff917 	ldw	r3,-28(fp)
8113afc4:	00bfff84 	movi	r2,-2
8113afc8:	1884703a 	and	r2,r3,r2
8113afcc:	1001703a 	wrctl	status,r2
  
  return context;
8113afd0:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113afd4:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113afd8:	d0a09c03 	ldbu	r2,-32144(gp)
8113afdc:	10803fcc 	andi	r2,r2,255
8113afe0:	10000626 	beq	r2,zero,8113affc <OSTaskCreateExt+0x98>
8113afe4:	e0bff117 	ldw	r2,-60(fp)
8113afe8:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113afec:	e0bff217 	ldw	r2,-56(fp)
8113aff0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113aff4:	00800f04 	movi	r2,60
8113aff8:	00005006 	br	8113b13c <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113affc:	e0fffd03 	ldbu	r3,-12(fp)
8113b000:	00a045b4 	movhi	r2,33046
8113b004:	109e0d04 	addi	r2,r2,30772
8113b008:	18c7883a 	add	r3,r3,r3
8113b00c:	18c7883a 	add	r3,r3,r3
8113b010:	10c5883a 	add	r2,r2,r3
8113b014:	10800017 	ldw	r2,0(r2)
8113b018:	1000431e 	bne	r2,zero,8113b128 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113b01c:	e0fffd03 	ldbu	r3,-12(fp)
8113b020:	00a045b4 	movhi	r2,33046
8113b024:	109e0d04 	addi	r2,r2,30772
8113b028:	18c7883a 	add	r3,r3,r3
8113b02c:	18c7883a 	add	r3,r3,r3
8113b030:	10c5883a 	add	r2,r2,r3
8113b034:	00c00044 	movi	r3,1
8113b038:	10c00015 	stw	r3,0(r2)
8113b03c:	e0bff117 	ldw	r2,-60(fp)
8113b040:	e0bff315 	stw	r2,-52(fp)
8113b044:	e0bff317 	ldw	r2,-52(fp)
8113b048:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113b04c:	e0bfff0b 	ldhu	r2,-4(fp)
8113b050:	100d883a 	mov	r6,r2
8113b054:	e1400417 	ldw	r5,16(fp)
8113b058:	e1000317 	ldw	r4,12(fp)
8113b05c:	113c00c0 	call	8113c00c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113b060:	e0bfff0b 	ldhu	r2,-4(fp)
8113b064:	100f883a 	mov	r7,r2
8113b068:	e1bffc17 	ldw	r6,-16(fp)
8113b06c:	e17ffb17 	ldw	r5,-20(fp)
8113b070:	e13ffa17 	ldw	r4,-24(fp)
8113b074:	11464580 	call	81146458 <OSTaskStkInit>
8113b078:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113b07c:	e0fffd03 	ldbu	r3,-12(fp)
8113b080:	e13ffe0b 	ldhu	r4,-8(fp)
8113b084:	e0bfff0b 	ldhu	r2,-4(fp)
8113b088:	d8800215 	stw	r2,8(sp)
8113b08c:	e0800517 	ldw	r2,20(fp)
8113b090:	d8800115 	stw	r2,4(sp)
8113b094:	e0800417 	ldw	r2,16(fp)
8113b098:	d8800015 	stw	r2,0(sp)
8113b09c:	200f883a 	mov	r7,r4
8113b0a0:	e1800317 	ldw	r6,12(fp)
8113b0a4:	e17ff517 	ldw	r5,-44(fp)
8113b0a8:	1809883a 	mov	r4,r3
8113b0ac:	11357900 	call	81135790 <OS_TCBInit>
8113b0b0:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113b0b4:	e0bff603 	ldbu	r2,-40(fp)
8113b0b8:	1000061e 	bne	r2,zero,8113b0d4 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113b0bc:	d0a08c03 	ldbu	r2,-32208(gp)
8113b0c0:	10803fcc 	andi	r2,r2,255
8113b0c4:	10800058 	cmpnei	r2,r2,1
8113b0c8:	1000151e 	bne	r2,zero,8113b120 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113b0cc:	11353480 	call	81135348 <OS_Sched>
8113b0d0:	00001306 	br	8113b120 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b0d4:	0005303a 	rdctl	r2,status
8113b0d8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b0dc:	e0fff817 	ldw	r3,-32(fp)
8113b0e0:	00bfff84 	movi	r2,-2
8113b0e4:	1884703a 	and	r2,r3,r2
8113b0e8:	1001703a 	wrctl	status,r2
  
  return context;
8113b0ec:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113b0f0:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113b0f4:	e0fffd03 	ldbu	r3,-12(fp)
8113b0f8:	00a045b4 	movhi	r2,33046
8113b0fc:	109e0d04 	addi	r2,r2,30772
8113b100:	18c7883a 	add	r3,r3,r3
8113b104:	18c7883a 	add	r3,r3,r3
8113b108:	10c5883a 	add	r2,r2,r3
8113b10c:	10000015 	stw	zero,0(r2)
8113b110:	e0bff117 	ldw	r2,-60(fp)
8113b114:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b118:	e0bff417 	ldw	r2,-48(fp)
8113b11c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113b120:	e0bff603 	ldbu	r2,-40(fp)
8113b124:	00000506 	br	8113b13c <OSTaskCreateExt+0x1d8>
8113b128:	e0bff117 	ldw	r2,-60(fp)
8113b12c:	e0bff715 	stw	r2,-36(fp)
8113b130:	e0bff717 	ldw	r2,-36(fp)
8113b134:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113b138:	00800a04 	movi	r2,40
}
8113b13c:	e037883a 	mov	sp,fp
8113b140:	dfc00117 	ldw	ra,4(sp)
8113b144:	df000017 	ldw	fp,0(sp)
8113b148:	dec00204 	addi	sp,sp,8
8113b14c:	f800283a 	ret

8113b150 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113b150:	defff404 	addi	sp,sp,-48
8113b154:	de00012e 	bgeu	sp,et,8113b15c <OSTaskDel+0xc>
8113b158:	003b68fa 	trap	3
8113b15c:	dfc00b15 	stw	ra,44(sp)
8113b160:	df000a15 	stw	fp,40(sp)
8113b164:	df000a04 	addi	fp,sp,40
8113b168:	2005883a 	mov	r2,r4
8113b16c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113b170:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113b174:	d0a09c03 	ldbu	r2,-32144(gp)
8113b178:	10803fcc 	andi	r2,r2,255
8113b17c:	10000226 	beq	r2,zero,8113b188 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113b180:	00801004 	movi	r2,64
8113b184:	0000c006 	br	8113b488 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113b188:	e0bfff03 	ldbu	r2,-4(fp)
8113b18c:	10800a98 	cmpnei	r2,r2,42
8113b190:	1000021e 	bne	r2,zero,8113b19c <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113b194:	00800f84 	movi	r2,62
8113b198:	0000bb06 	br	8113b488 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113b19c:	e0bfff03 	ldbu	r2,-4(fp)
8113b1a0:	10800ab0 	cmpltui	r2,r2,42
8113b1a4:	1000051e 	bne	r2,zero,8113b1bc <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113b1a8:	e0bfff03 	ldbu	r2,-4(fp)
8113b1ac:	10803fe0 	cmpeqi	r2,r2,255
8113b1b0:	1000021e 	bne	r2,zero,8113b1bc <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113b1b4:	00800a84 	movi	r2,42
8113b1b8:	0000b306 	br	8113b488 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b1bc:	0005303a 	rdctl	r2,status
8113b1c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b1c4:	e0fffe17 	ldw	r3,-8(fp)
8113b1c8:	00bfff84 	movi	r2,-2
8113b1cc:	1884703a 	and	r2,r3,r2
8113b1d0:	1001703a 	wrctl	status,r2
  
  return context;
8113b1d4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113b1d8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113b1dc:	e0bfff03 	ldbu	r2,-4(fp)
8113b1e0:	10803fd8 	cmpnei	r2,r2,255
8113b1e4:	1000031e 	bne	r2,zero,8113b1f4 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113b1e8:	d0a09d17 	ldw	r2,-32140(gp)
8113b1ec:	10800c83 	ldbu	r2,50(r2)
8113b1f0:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113b1f4:	e0ffff03 	ldbu	r3,-4(fp)
8113b1f8:	00a045b4 	movhi	r2,33046
8113b1fc:	109e0d04 	addi	r2,r2,30772
8113b200:	18c7883a 	add	r3,r3,r3
8113b204:	18c7883a 	add	r3,r3,r3
8113b208:	10c5883a 	add	r2,r2,r3
8113b20c:	10800017 	ldw	r2,0(r2)
8113b210:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113b214:	e0bff817 	ldw	r2,-32(fp)
8113b218:	1000061e 	bne	r2,zero,8113b234 <OSTaskDel+0xe4>
8113b21c:	e0bff617 	ldw	r2,-40(fp)
8113b220:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b224:	e0bff717 	ldw	r2,-36(fp)
8113b228:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113b22c:	008010c4 	movi	r2,67
8113b230:	00009506 	br	8113b488 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113b234:	e0bff817 	ldw	r2,-32(fp)
8113b238:	10800058 	cmpnei	r2,r2,1
8113b23c:	1000061e 	bne	r2,zero,8113b258 <OSTaskDel+0x108>
8113b240:	e0bff617 	ldw	r2,-40(fp)
8113b244:	e0bff915 	stw	r2,-28(fp)
8113b248:	e0bff917 	ldw	r2,-28(fp)
8113b24c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113b250:	00800f44 	movi	r2,61
8113b254:	00008c06 	br	8113b488 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113b258:	e0bff817 	ldw	r2,-32(fp)
8113b25c:	10800d03 	ldbu	r2,52(r2)
8113b260:	10c03fcc 	andi	r3,r2,255
8113b264:	e0bff817 	ldw	r2,-32(fp)
8113b268:	10800d03 	ldbu	r2,52(r2)
8113b26c:	11003fcc 	andi	r4,r2,255
8113b270:	d0a09944 	addi	r2,gp,-32155
8113b274:	2085883a 	add	r2,r4,r2
8113b278:	10800003 	ldbu	r2,0(r2)
8113b27c:	1009883a 	mov	r4,r2
8113b280:	e0bff817 	ldw	r2,-32(fp)
8113b284:	10800d43 	ldbu	r2,53(r2)
8113b288:	0084303a 	nor	r2,zero,r2
8113b28c:	2084703a 	and	r2,r4,r2
8113b290:	1009883a 	mov	r4,r2
8113b294:	d0a09944 	addi	r2,gp,-32155
8113b298:	1885883a 	add	r2,r3,r2
8113b29c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113b2a0:	e0bff817 	ldw	r2,-32(fp)
8113b2a4:	10800d03 	ldbu	r2,52(r2)
8113b2a8:	10c03fcc 	andi	r3,r2,255
8113b2ac:	d0a09944 	addi	r2,gp,-32155
8113b2b0:	1885883a 	add	r2,r3,r2
8113b2b4:	10800003 	ldbu	r2,0(r2)
8113b2b8:	10803fcc 	andi	r2,r2,255
8113b2bc:	1000071e 	bne	r2,zero,8113b2dc <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113b2c0:	e0bff817 	ldw	r2,-32(fp)
8113b2c4:	10800d83 	ldbu	r2,54(r2)
8113b2c8:	0084303a 	nor	r2,zero,r2
8113b2cc:	1007883a 	mov	r3,r2
8113b2d0:	d0a09903 	ldbu	r2,-32156(gp)
8113b2d4:	1884703a 	and	r2,r3,r2
8113b2d8:	d0a09905 	stb	r2,-32156(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113b2dc:	e0bff817 	ldw	r2,-32(fp)
8113b2e0:	10800717 	ldw	r2,28(r2)
8113b2e4:	10000526 	beq	r2,zero,8113b2fc <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113b2e8:	e0bff817 	ldw	r2,-32(fp)
8113b2ec:	10800717 	ldw	r2,28(r2)
8113b2f0:	100b883a 	mov	r5,r2
8113b2f4:	e13ff817 	ldw	r4,-32(fp)
8113b2f8:	1134c9c0 	call	81134c9c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113b2fc:	e0bff817 	ldw	r2,-32(fp)
8113b300:	10800817 	ldw	r2,32(r2)
8113b304:	10000526 	beq	r2,zero,8113b31c <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113b308:	e0bff817 	ldw	r2,-32(fp)
8113b30c:	10800817 	ldw	r2,32(r2)
8113b310:	100b883a 	mov	r5,r2
8113b314:	e13ff817 	ldw	r4,-32(fp)
8113b318:	1134d5c0 	call	81134d5c <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113b31c:	e0bff817 	ldw	r2,-32(fp)
8113b320:	10800a17 	ldw	r2,40(r2)
8113b324:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113b328:	e0bffb17 	ldw	r2,-20(fp)
8113b32c:	10000226 	beq	r2,zero,8113b338 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113b330:	e13ffb17 	ldw	r4,-20(fp)
8113b334:	11373340 	call	81137334 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113b338:	e0bff817 	ldw	r2,-32(fp)
8113b33c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113b340:	e0bff817 	ldw	r2,-32(fp)
8113b344:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113b348:	e0bff817 	ldw	r2,-32(fp)
8113b34c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113b350:	d0a08a03 	ldbu	r2,-32216(gp)
8113b354:	10803fcc 	andi	r2,r2,255
8113b358:	10803fe0 	cmpeqi	r2,r2,255
8113b35c:	1000031e 	bne	r2,zero,8113b36c <OSTaskDel+0x21c>
        OSLockNesting++;
8113b360:	d0a08a03 	ldbu	r2,-32216(gp)
8113b364:	10800044 	addi	r2,r2,1
8113b368:	d0a08a05 	stb	r2,-32216(gp)
8113b36c:	e0bff617 	ldw	r2,-40(fp)
8113b370:	e0bffd15 	stw	r2,-12(fp)
8113b374:	e0bffd17 	ldw	r2,-12(fp)
8113b378:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113b37c:	11348640 	call	81134864 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b380:	0005303a 	rdctl	r2,status
8113b384:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b388:	e0fffa17 	ldw	r3,-24(fp)
8113b38c:	00bfff84 	movi	r2,-2
8113b390:	1884703a 	and	r2,r3,r2
8113b394:	1001703a 	wrctl	status,r2
  
  return context;
8113b398:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113b39c:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113b3a0:	d0a08a03 	ldbu	r2,-32216(gp)
8113b3a4:	10803fcc 	andi	r2,r2,255
8113b3a8:	10000326 	beq	r2,zero,8113b3b8 <OSTaskDel+0x268>
        OSLockNesting--;
8113b3ac:	d0a08a03 	ldbu	r2,-32216(gp)
8113b3b0:	10bfffc4 	addi	r2,r2,-1
8113b3b4:	d0a08a05 	stb	r2,-32216(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113b3b8:	e13ff817 	ldw	r4,-32(fp)
8113b3bc:	11465e80 	call	811465e8 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113b3c0:	d0a09543 	ldbu	r2,-32171(gp)
8113b3c4:	10bfffc4 	addi	r2,r2,-1
8113b3c8:	d0a09545 	stb	r2,-32171(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113b3cc:	e0ffff03 	ldbu	r3,-4(fp)
8113b3d0:	00a045b4 	movhi	r2,33046
8113b3d4:	109e0d04 	addi	r2,r2,30772
8113b3d8:	18c7883a 	add	r3,r3,r3
8113b3dc:	18c7883a 	add	r3,r3,r3
8113b3e0:	10c5883a 	add	r2,r2,r3
8113b3e4:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113b3e8:	e0bff817 	ldw	r2,-32(fp)
8113b3ec:	10800617 	ldw	r2,24(r2)
8113b3f0:	1000071e 	bne	r2,zero,8113b410 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113b3f4:	e0bff817 	ldw	r2,-32(fp)
8113b3f8:	10800517 	ldw	r2,20(r2)
8113b3fc:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113b400:	e0bff817 	ldw	r2,-32(fp)
8113b404:	10800517 	ldw	r2,20(r2)
8113b408:	d0a08f15 	stw	r2,-32196(gp)
8113b40c:	00000a06 	br	8113b438 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113b410:	e0bff817 	ldw	r2,-32(fp)
8113b414:	10800617 	ldw	r2,24(r2)
8113b418:	e0fff817 	ldw	r3,-32(fp)
8113b41c:	18c00517 	ldw	r3,20(r3)
8113b420:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113b424:	e0bff817 	ldw	r2,-32(fp)
8113b428:	10800517 	ldw	r2,20(r2)
8113b42c:	e0fff817 	ldw	r3,-32(fp)
8113b430:	18c00617 	ldw	r3,24(r3)
8113b434:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113b438:	d0e09417 	ldw	r3,-32176(gp)
8113b43c:	e0bff817 	ldw	r2,-32(fp)
8113b440:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113b444:	e0bff817 	ldw	r2,-32(fp)
8113b448:	d0a09415 	stw	r2,-32176(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113b44c:	e0bff817 	ldw	r2,-32(fp)
8113b450:	00c00fc4 	movi	r3,63
8113b454:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113b458:	e0bff817 	ldw	r2,-32(fp)
8113b45c:	10001345 	stb	zero,77(r2)
8113b460:	e0bff617 	ldw	r2,-40(fp)
8113b464:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b468:	e0bffc17 	ldw	r2,-16(fp)
8113b46c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113b470:	d0a08c03 	ldbu	r2,-32208(gp)
8113b474:	10803fcc 	andi	r2,r2,255
8113b478:	10800058 	cmpnei	r2,r2,1
8113b47c:	1000011e 	bne	r2,zero,8113b484 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113b480:	11353480 	call	81135348 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113b484:	0005883a 	mov	r2,zero
}
8113b488:	e037883a 	mov	sp,fp
8113b48c:	dfc00117 	ldw	ra,4(sp)
8113b490:	df000017 	ldw	fp,0(sp)
8113b494:	dec00204 	addi	sp,sp,8
8113b498:	f800283a 	ret

8113b49c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113b49c:	defff504 	addi	sp,sp,-44
8113b4a0:	de00012e 	bgeu	sp,et,8113b4a8 <OSTaskDelReq+0xc>
8113b4a4:	003b68fa 	trap	3
8113b4a8:	df000a15 	stw	fp,40(sp)
8113b4ac:	df000a04 	addi	fp,sp,40
8113b4b0:	2005883a 	mov	r2,r4
8113b4b4:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b4b8:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113b4bc:	e0bfff03 	ldbu	r2,-4(fp)
8113b4c0:	10800a98 	cmpnei	r2,r2,42
8113b4c4:	1000021e 	bne	r2,zero,8113b4d0 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113b4c8:	00800f84 	movi	r2,62
8113b4cc:	00004506 	br	8113b5e4 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113b4d0:	e0bfff03 	ldbu	r2,-4(fp)
8113b4d4:	10800ab0 	cmpltui	r2,r2,42
8113b4d8:	1000051e 	bne	r2,zero,8113b4f0 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113b4dc:	e0bfff03 	ldbu	r2,-4(fp)
8113b4e0:	10803fe0 	cmpeqi	r2,r2,255
8113b4e4:	1000021e 	bne	r2,zero,8113b4f0 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113b4e8:	00800a84 	movi	r2,42
8113b4ec:	00003d06 	br	8113b5e4 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113b4f0:	e0bfff03 	ldbu	r2,-4(fp)
8113b4f4:	10803fd8 	cmpnei	r2,r2,255
8113b4f8:	1000111e 	bne	r2,zero,8113b540 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b4fc:	0005303a 	rdctl	r2,status
8113b500:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b504:	e0fff917 	ldw	r3,-28(fp)
8113b508:	00bfff84 	movi	r2,-2
8113b50c:	1884703a 	and	r2,r3,r2
8113b510:	1001703a 	wrctl	status,r2
  
  return context;
8113b514:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113b518:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113b51c:	d0a09d17 	ldw	r2,-32140(gp)
8113b520:	10800dc3 	ldbu	r2,55(r2)
8113b524:	e0bff805 	stb	r2,-32(fp)
8113b528:	e0bff617 	ldw	r2,-40(fp)
8113b52c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b530:	e0bffe17 	ldw	r2,-8(fp)
8113b534:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113b538:	e0bff803 	ldbu	r2,-32(fp)
8113b53c:	00002906 	br	8113b5e4 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b540:	0005303a 	rdctl	r2,status
8113b544:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b548:	e0fff717 	ldw	r3,-36(fp)
8113b54c:	00bfff84 	movi	r2,-2
8113b550:	1884703a 	and	r2,r3,r2
8113b554:	1001703a 	wrctl	status,r2
  
  return context;
8113b558:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113b55c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113b560:	e0ffff03 	ldbu	r3,-4(fp)
8113b564:	00a045b4 	movhi	r2,33046
8113b568:	109e0d04 	addi	r2,r2,30772
8113b56c:	18c7883a 	add	r3,r3,r3
8113b570:	18c7883a 	add	r3,r3,r3
8113b574:	10c5883a 	add	r2,r2,r3
8113b578:	10800017 	ldw	r2,0(r2)
8113b57c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113b580:	e0bffb17 	ldw	r2,-20(fp)
8113b584:	1000061e 	bne	r2,zero,8113b5a0 <OSTaskDelReq+0x104>
8113b588:	e0bff617 	ldw	r2,-40(fp)
8113b58c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b590:	e0bffa17 	ldw	r2,-24(fp)
8113b594:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113b598:	008010c4 	movi	r2,67
8113b59c:	00001106 	br	8113b5e4 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113b5a0:	e0bffb17 	ldw	r2,-20(fp)
8113b5a4:	10800058 	cmpnei	r2,r2,1
8113b5a8:	1000061e 	bne	r2,zero,8113b5c4 <OSTaskDelReq+0x128>
8113b5ac:	e0bff617 	ldw	r2,-40(fp)
8113b5b0:	e0bffc15 	stw	r2,-16(fp)
8113b5b4:	e0bffc17 	ldw	r2,-16(fp)
8113b5b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113b5bc:	00800f44 	movi	r2,61
8113b5c0:	00000806 	br	8113b5e4 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113b5c4:	e0bffb17 	ldw	r2,-20(fp)
8113b5c8:	00c00fc4 	movi	r3,63
8113b5cc:	10c00dc5 	stb	r3,55(r2)
8113b5d0:	e0bff617 	ldw	r2,-40(fp)
8113b5d4:	e0bffd15 	stw	r2,-12(fp)
8113b5d8:	e0bffd17 	ldw	r2,-12(fp)
8113b5dc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113b5e0:	0005883a 	mov	r2,zero
}
8113b5e4:	e037883a 	mov	sp,fp
8113b5e8:	df000017 	ldw	fp,0(sp)
8113b5ec:	dec00104 	addi	sp,sp,4
8113b5f0:	f800283a 	ret

8113b5f4 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113b5f4:	defff404 	addi	sp,sp,-48
8113b5f8:	de00012e 	bgeu	sp,et,8113b600 <OSTaskNameGet+0xc>
8113b5fc:	003b68fa 	trap	3
8113b600:	dfc00b15 	stw	ra,44(sp)
8113b604:	df000a15 	stw	fp,40(sp)
8113b608:	df000a04 	addi	fp,sp,40
8113b60c:	2005883a 	mov	r2,r4
8113b610:	e17ffe15 	stw	r5,-8(fp)
8113b614:	e1bfff15 	stw	r6,-4(fp)
8113b618:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113b61c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113b620:	e0bfff17 	ldw	r2,-4(fp)
8113b624:	1000021e 	bne	r2,zero,8113b630 <OSTaskNameGet+0x3c>
        return (0);
8113b628:	0005883a 	mov	r2,zero
8113b62c:	00005406 	br	8113b780 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113b630:	e0bffd03 	ldbu	r2,-12(fp)
8113b634:	10800af0 	cmpltui	r2,r2,43
8113b638:	1000081e 	bne	r2,zero,8113b65c <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113b63c:	e0bffd03 	ldbu	r2,-12(fp)
8113b640:	10803fe0 	cmpeqi	r2,r2,255
8113b644:	1000051e 	bne	r2,zero,8113b65c <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113b648:	e0bfff17 	ldw	r2,-4(fp)
8113b64c:	00c00a84 	movi	r3,42
8113b650:	10c00005 	stb	r3,0(r2)
            return (0);
8113b654:	0005883a 	mov	r2,zero
8113b658:	00004906 	br	8113b780 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113b65c:	e0bffe17 	ldw	r2,-8(fp)
8113b660:	1000051e 	bne	r2,zero,8113b678 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113b664:	e0bfff17 	ldw	r2,-4(fp)
8113b668:	00c00304 	movi	r3,12
8113b66c:	10c00005 	stb	r3,0(r2)
        return (0);
8113b670:	0005883a 	mov	r2,zero
8113b674:	00004206 	br	8113b780 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113b678:	d0a09c03 	ldbu	r2,-32144(gp)
8113b67c:	10803fcc 	andi	r2,r2,255
8113b680:	10000526 	beq	r2,zero,8113b698 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113b684:	e0bfff17 	ldw	r2,-4(fp)
8113b688:	00c00444 	movi	r3,17
8113b68c:	10c00005 	stb	r3,0(r2)
        return (0);
8113b690:	0005883a 	mov	r2,zero
8113b694:	00003a06 	br	8113b780 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b698:	0005303a 	rdctl	r2,status
8113b69c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b6a0:	e0fffc17 	ldw	r3,-16(fp)
8113b6a4:	00bfff84 	movi	r2,-2
8113b6a8:	1884703a 	and	r2,r3,r2
8113b6ac:	1001703a 	wrctl	status,r2
  
  return context;
8113b6b0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b6b4:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113b6b8:	e0bffd03 	ldbu	r2,-12(fp)
8113b6bc:	10803fd8 	cmpnei	r2,r2,255
8113b6c0:	1000031e 	bne	r2,zero,8113b6d0 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113b6c4:	d0a09d17 	ldw	r2,-32140(gp)
8113b6c8:	10800c83 	ldbu	r2,50(r2)
8113b6cc:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113b6d0:	e0fffd03 	ldbu	r3,-12(fp)
8113b6d4:	00a045b4 	movhi	r2,33046
8113b6d8:	109e0d04 	addi	r2,r2,30772
8113b6dc:	18c7883a 	add	r3,r3,r3
8113b6e0:	18c7883a 	add	r3,r3,r3
8113b6e4:	10c5883a 	add	r2,r2,r3
8113b6e8:	10800017 	ldw	r2,0(r2)
8113b6ec:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113b6f0:	e0bff817 	ldw	r2,-32(fp)
8113b6f4:	1000091e 	bne	r2,zero,8113b71c <OSTaskNameGet+0x128>
8113b6f8:	e0bff617 	ldw	r2,-40(fp)
8113b6fc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b700:	e0bff717 	ldw	r2,-36(fp)
8113b704:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113b708:	e0bfff17 	ldw	r2,-4(fp)
8113b70c:	00c010c4 	movi	r3,67
8113b710:	10c00005 	stb	r3,0(r2)
        return (0);
8113b714:	0005883a 	mov	r2,zero
8113b718:	00001906 	br	8113b780 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113b71c:	e0bff817 	ldw	r2,-32(fp)
8113b720:	10800058 	cmpnei	r2,r2,1
8113b724:	1000091e 	bne	r2,zero,8113b74c <OSTaskNameGet+0x158>
8113b728:	e0bff617 	ldw	r2,-40(fp)
8113b72c:	e0bff915 	stw	r2,-28(fp)
8113b730:	e0bff917 	ldw	r2,-28(fp)
8113b734:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113b738:	e0bfff17 	ldw	r2,-4(fp)
8113b73c:	00c010c4 	movi	r3,67
8113b740:	10c00005 	stb	r3,0(r2)
        return (0);
8113b744:	0005883a 	mov	r2,zero
8113b748:	00000d06 	br	8113b780 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113b74c:	e0bff817 	ldw	r2,-32(fp)
8113b750:	10801304 	addi	r2,r2,76
8113b754:	100b883a 	mov	r5,r2
8113b758:	e13ffe17 	ldw	r4,-8(fp)
8113b75c:	113549c0 	call	8113549c <OS_StrCopy>
8113b760:	e0bffb05 	stb	r2,-20(fp)
8113b764:	e0bff617 	ldw	r2,-40(fp)
8113b768:	e0bffa15 	stw	r2,-24(fp)
8113b76c:	e0bffa17 	ldw	r2,-24(fp)
8113b770:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b774:	e0bfff17 	ldw	r2,-4(fp)
8113b778:	10000005 	stb	zero,0(r2)
    return (len);
8113b77c:	e0bffb03 	ldbu	r2,-20(fp)
}
8113b780:	e037883a 	mov	sp,fp
8113b784:	dfc00117 	ldw	ra,4(sp)
8113b788:	df000017 	ldw	fp,0(sp)
8113b78c:	dec00204 	addi	sp,sp,8
8113b790:	f800283a 	ret

8113b794 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113b794:	defff304 	addi	sp,sp,-52
8113b798:	de00012e 	bgeu	sp,et,8113b7a0 <OSTaskNameSet+0xc>
8113b79c:	003b68fa 	trap	3
8113b7a0:	dfc00c15 	stw	ra,48(sp)
8113b7a4:	df000b15 	stw	fp,44(sp)
8113b7a8:	df000b04 	addi	fp,sp,44
8113b7ac:	2005883a 	mov	r2,r4
8113b7b0:	e17ffe15 	stw	r5,-8(fp)
8113b7b4:	e1bfff15 	stw	r6,-4(fp)
8113b7b8:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113b7bc:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113b7c0:	e0bfff17 	ldw	r2,-4(fp)
8113b7c4:	10005c26 	beq	r2,zero,8113b938 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113b7c8:	e0bffd03 	ldbu	r2,-12(fp)
8113b7cc:	10800af0 	cmpltui	r2,r2,43
8113b7d0:	1000071e 	bne	r2,zero,8113b7f0 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113b7d4:	e0bffd03 	ldbu	r2,-12(fp)
8113b7d8:	10803fe0 	cmpeqi	r2,r2,255
8113b7dc:	1000041e 	bne	r2,zero,8113b7f0 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113b7e0:	e0bfff17 	ldw	r2,-4(fp)
8113b7e4:	00c00a84 	movi	r3,42
8113b7e8:	10c00005 	stb	r3,0(r2)
            return;
8113b7ec:	00005306 	br	8113b93c <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113b7f0:	e0bffe17 	ldw	r2,-8(fp)
8113b7f4:	1000041e 	bne	r2,zero,8113b808 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113b7f8:	e0bfff17 	ldw	r2,-4(fp)
8113b7fc:	00c00304 	movi	r3,12
8113b800:	10c00005 	stb	r3,0(r2)
        return;
8113b804:	00004d06 	br	8113b93c <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113b808:	d0a09c03 	ldbu	r2,-32144(gp)
8113b80c:	10803fcc 	andi	r2,r2,255
8113b810:	10000426 	beq	r2,zero,8113b824 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113b814:	e0bfff17 	ldw	r2,-4(fp)
8113b818:	00c00484 	movi	r3,18
8113b81c:	10c00005 	stb	r3,0(r2)
        return;
8113b820:	00004606 	br	8113b93c <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b824:	0005303a 	rdctl	r2,status
8113b828:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b82c:	e0fffc17 	ldw	r3,-16(fp)
8113b830:	00bfff84 	movi	r2,-2
8113b834:	1884703a 	and	r2,r3,r2
8113b838:	1001703a 	wrctl	status,r2
  
  return context;
8113b83c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b840:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113b844:	e0bffd03 	ldbu	r2,-12(fp)
8113b848:	10803fd8 	cmpnei	r2,r2,255
8113b84c:	1000031e 	bne	r2,zero,8113b85c <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113b850:	d0a09d17 	ldw	r2,-32140(gp)
8113b854:	10800c83 	ldbu	r2,50(r2)
8113b858:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113b85c:	e0fffd03 	ldbu	r3,-12(fp)
8113b860:	00a045b4 	movhi	r2,33046
8113b864:	109e0d04 	addi	r2,r2,30772
8113b868:	18c7883a 	add	r3,r3,r3
8113b86c:	18c7883a 	add	r3,r3,r3
8113b870:	10c5883a 	add	r2,r2,r3
8113b874:	10800017 	ldw	r2,0(r2)
8113b878:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113b87c:	e0bff717 	ldw	r2,-36(fp)
8113b880:	1000081e 	bne	r2,zero,8113b8a4 <OSTaskNameSet+0x110>
8113b884:	e0bff517 	ldw	r2,-44(fp)
8113b888:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b88c:	e0bff617 	ldw	r2,-40(fp)
8113b890:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113b894:	e0bfff17 	ldw	r2,-4(fp)
8113b898:	00c010c4 	movi	r3,67
8113b89c:	10c00005 	stb	r3,0(r2)
        return;
8113b8a0:	00002606 	br	8113b93c <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113b8a4:	e0bff717 	ldw	r2,-36(fp)
8113b8a8:	10800058 	cmpnei	r2,r2,1
8113b8ac:	1000081e 	bne	r2,zero,8113b8d0 <OSTaskNameSet+0x13c>
8113b8b0:	e0bff517 	ldw	r2,-44(fp)
8113b8b4:	e0bff815 	stw	r2,-32(fp)
8113b8b8:	e0bff817 	ldw	r2,-32(fp)
8113b8bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113b8c0:	e0bfff17 	ldw	r2,-4(fp)
8113b8c4:	00c010c4 	movi	r3,67
8113b8c8:	10c00005 	stb	r3,0(r2)
        return;
8113b8cc:	00001b06 	br	8113b93c <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113b8d0:	e13ffe17 	ldw	r4,-8(fp)
8113b8d4:	11355180 	call	81135518 <OS_StrLen>
8113b8d8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113b8dc:	e0bffa03 	ldbu	r2,-24(fp)
8113b8e0:	10800830 	cmpltui	r2,r2,32
8113b8e4:	1000081e 	bne	r2,zero,8113b908 <OSTaskNameSet+0x174>
8113b8e8:	e0bff517 	ldw	r2,-44(fp)
8113b8ec:	e0bff915 	stw	r2,-28(fp)
8113b8f0:	e0bff917 	ldw	r2,-28(fp)
8113b8f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113b8f8:	e0bfff17 	ldw	r2,-4(fp)
8113b8fc:	00c01044 	movi	r3,65
8113b900:	10c00005 	stb	r3,0(r2)
        return;
8113b904:	00000d06 	br	8113b93c <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113b908:	e0bff717 	ldw	r2,-36(fp)
8113b90c:	10801304 	addi	r2,r2,76
8113b910:	e17ffe17 	ldw	r5,-8(fp)
8113b914:	1009883a 	mov	r4,r2
8113b918:	113549c0 	call	8113549c <OS_StrCopy>
8113b91c:	e0bff517 	ldw	r2,-44(fp)
8113b920:	e0bffb15 	stw	r2,-20(fp)
8113b924:	e0bffb17 	ldw	r2,-20(fp)
8113b928:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b92c:	e0bfff17 	ldw	r2,-4(fp)
8113b930:	10000005 	stb	zero,0(r2)
8113b934:	00000106 	br	8113b93c <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113b938:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113b93c:	e037883a 	mov	sp,fp
8113b940:	dfc00117 	ldw	ra,4(sp)
8113b944:	df000017 	ldw	fp,0(sp)
8113b948:	dec00204 	addi	sp,sp,8
8113b94c:	f800283a 	ret

8113b950 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113b950:	defff404 	addi	sp,sp,-48
8113b954:	de00012e 	bgeu	sp,et,8113b95c <OSTaskResume+0xc>
8113b958:	003b68fa 	trap	3
8113b95c:	dfc00b15 	stw	ra,44(sp)
8113b960:	df000a15 	stw	fp,40(sp)
8113b964:	df000a04 	addi	fp,sp,40
8113b968:	2005883a 	mov	r2,r4
8113b96c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113b970:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113b974:	e0bfff03 	ldbu	r2,-4(fp)
8113b978:	10800ab0 	cmpltui	r2,r2,42
8113b97c:	1000021e 	bne	r2,zero,8113b988 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113b980:	00800a84 	movi	r2,42
8113b984:	00006406 	br	8113bb18 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b988:	0005303a 	rdctl	r2,status
8113b98c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b990:	e0fffe17 	ldw	r3,-8(fp)
8113b994:	00bfff84 	movi	r2,-2
8113b998:	1884703a 	and	r2,r3,r2
8113b99c:	1001703a 	wrctl	status,r2
  
  return context;
8113b9a0:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b9a4:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113b9a8:	e0ffff03 	ldbu	r3,-4(fp)
8113b9ac:	00a045b4 	movhi	r2,33046
8113b9b0:	109e0d04 	addi	r2,r2,30772
8113b9b4:	18c7883a 	add	r3,r3,r3
8113b9b8:	18c7883a 	add	r3,r3,r3
8113b9bc:	10c5883a 	add	r2,r2,r3
8113b9c0:	10800017 	ldw	r2,0(r2)
8113b9c4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113b9c8:	e0bff817 	ldw	r2,-32(fp)
8113b9cc:	1000061e 	bne	r2,zero,8113b9e8 <OSTaskResume+0x98>
8113b9d0:	e0bff617 	ldw	r2,-40(fp)
8113b9d4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b9d8:	e0bff717 	ldw	r2,-36(fp)
8113b9dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113b9e0:	00801184 	movi	r2,70
8113b9e4:	00004c06 	br	8113bb18 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113b9e8:	e0bff817 	ldw	r2,-32(fp)
8113b9ec:	10800058 	cmpnei	r2,r2,1
8113b9f0:	1000061e 	bne	r2,zero,8113ba0c <OSTaskResume+0xbc>
8113b9f4:	e0bff617 	ldw	r2,-40(fp)
8113b9f8:	e0bff915 	stw	r2,-28(fp)
8113b9fc:	e0bff917 	ldw	r2,-28(fp)
8113ba00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113ba04:	008010c4 	movi	r2,67
8113ba08:	00004306 	br	8113bb18 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113ba0c:	e0bff817 	ldw	r2,-32(fp)
8113ba10:	10800c03 	ldbu	r2,48(r2)
8113ba14:	10803fcc 	andi	r2,r2,255
8113ba18:	1080020c 	andi	r2,r2,8
8113ba1c:	10003926 	beq	r2,zero,8113bb04 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113ba20:	e0bff817 	ldw	r2,-32(fp)
8113ba24:	10c00c03 	ldbu	r3,48(r2)
8113ba28:	00bffdc4 	movi	r2,-9
8113ba2c:	1884703a 	and	r2,r3,r2
8113ba30:	1007883a 	mov	r3,r2
8113ba34:	e0bff817 	ldw	r2,-32(fp)
8113ba38:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113ba3c:	e0bff817 	ldw	r2,-32(fp)
8113ba40:	10800c03 	ldbu	r2,48(r2)
8113ba44:	10803fcc 	andi	r2,r2,255
8113ba48:	1000281e 	bne	r2,zero,8113baec <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113ba4c:	e0bff817 	ldw	r2,-32(fp)
8113ba50:	10800b8b 	ldhu	r2,46(r2)
8113ba54:	10bfffcc 	andi	r2,r2,65535
8113ba58:	10001f1e 	bne	r2,zero,8113bad8 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113ba5c:	e0bff817 	ldw	r2,-32(fp)
8113ba60:	10c00d83 	ldbu	r3,54(r2)
8113ba64:	d0a09903 	ldbu	r2,-32156(gp)
8113ba68:	1884b03a 	or	r2,r3,r2
8113ba6c:	d0a09905 	stb	r2,-32156(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113ba70:	e0bff817 	ldw	r2,-32(fp)
8113ba74:	10800d03 	ldbu	r2,52(r2)
8113ba78:	10c03fcc 	andi	r3,r2,255
8113ba7c:	e0bff817 	ldw	r2,-32(fp)
8113ba80:	10800d03 	ldbu	r2,52(r2)
8113ba84:	11003fcc 	andi	r4,r2,255
8113ba88:	d0a09944 	addi	r2,gp,-32155
8113ba8c:	2085883a 	add	r2,r4,r2
8113ba90:	11000003 	ldbu	r4,0(r2)
8113ba94:	e0bff817 	ldw	r2,-32(fp)
8113ba98:	10800d43 	ldbu	r2,53(r2)
8113ba9c:	2084b03a 	or	r2,r4,r2
8113baa0:	1009883a 	mov	r4,r2
8113baa4:	d0a09944 	addi	r2,gp,-32155
8113baa8:	1885883a 	add	r2,r3,r2
8113baac:	11000005 	stb	r4,0(r2)
8113bab0:	e0bff617 	ldw	r2,-40(fp)
8113bab4:	e0bffa15 	stw	r2,-24(fp)
8113bab8:	e0bffa17 	ldw	r2,-24(fp)
8113babc:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113bac0:	d0a08c03 	ldbu	r2,-32208(gp)
8113bac4:	10803fcc 	andi	r2,r2,255
8113bac8:	10800058 	cmpnei	r2,r2,1
8113bacc:	10000b1e 	bne	r2,zero,8113bafc <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113bad0:	11353480 	call	81135348 <OS_Sched>
8113bad4:	00000906 	br	8113bafc <OSTaskResume+0x1ac>
8113bad8:	e0bff617 	ldw	r2,-40(fp)
8113badc:	e0bffb15 	stw	r2,-20(fp)
8113bae0:	e0bffb17 	ldw	r2,-20(fp)
8113bae4:	1001703a 	wrctl	status,r2
8113bae8:	00000406 	br	8113bafc <OSTaskResume+0x1ac>
8113baec:	e0bff617 	ldw	r2,-40(fp)
8113baf0:	e0bffc15 	stw	r2,-16(fp)
8113baf4:	e0bffc17 	ldw	r2,-16(fp)
8113baf8:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113bafc:	0005883a 	mov	r2,zero
8113bb00:	00000506 	br	8113bb18 <OSTaskResume+0x1c8>
8113bb04:	e0bff617 	ldw	r2,-40(fp)
8113bb08:	e0bffd15 	stw	r2,-12(fp)
8113bb0c:	e0bffd17 	ldw	r2,-12(fp)
8113bb10:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113bb14:	00801104 	movi	r2,68
}
8113bb18:	e037883a 	mov	sp,fp
8113bb1c:	dfc00117 	ldw	ra,4(sp)
8113bb20:	df000017 	ldw	fp,0(sp)
8113bb24:	dec00204 	addi	sp,sp,8
8113bb28:	f800283a 	ret

8113bb2c <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113bb2c:	defff304 	addi	sp,sp,-52
8113bb30:	de00012e 	bgeu	sp,et,8113bb38 <OSTaskStkChk+0xc>
8113bb34:	003b68fa 	trap	3
8113bb38:	df000c15 	stw	fp,48(sp)
8113bb3c:	df000c04 	addi	fp,sp,48
8113bb40:	2005883a 	mov	r2,r4
8113bb44:	e17fff15 	stw	r5,-4(fp)
8113bb48:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113bb4c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113bb50:	e0bffe03 	ldbu	r2,-8(fp)
8113bb54:	10800af0 	cmpltui	r2,r2,43
8113bb58:	1000051e 	bne	r2,zero,8113bb70 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113bb5c:	e0bffe03 	ldbu	r2,-8(fp)
8113bb60:	10803fe0 	cmpeqi	r2,r2,255
8113bb64:	1000021e 	bne	r2,zero,8113bb70 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113bb68:	00800a84 	movi	r2,42
8113bb6c:	00005d06 	br	8113bce4 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113bb70:	e0bfff17 	ldw	r2,-4(fp)
8113bb74:	1000021e 	bne	r2,zero,8113bb80 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113bb78:	00800244 	movi	r2,9
8113bb7c:	00005906 	br	8113bce4 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113bb80:	e0bfff17 	ldw	r2,-4(fp)
8113bb84:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113bb88:	e0bfff17 	ldw	r2,-4(fp)
8113bb8c:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bb90:	0005303a 	rdctl	r2,status
8113bb94:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bb98:	e0fffd17 	ldw	r3,-12(fp)
8113bb9c:	00bfff84 	movi	r2,-2
8113bba0:	1884703a 	and	r2,r3,r2
8113bba4:	1001703a 	wrctl	status,r2
  
  return context;
8113bba8:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113bbac:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113bbb0:	e0bffe03 	ldbu	r2,-8(fp)
8113bbb4:	10803fd8 	cmpnei	r2,r2,255
8113bbb8:	1000031e 	bne	r2,zero,8113bbc8 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113bbbc:	d0a09d17 	ldw	r2,-32140(gp)
8113bbc0:	10800c83 	ldbu	r2,50(r2)
8113bbc4:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113bbc8:	e0fffe03 	ldbu	r3,-8(fp)
8113bbcc:	00a045b4 	movhi	r2,33046
8113bbd0:	109e0d04 	addi	r2,r2,30772
8113bbd4:	18c7883a 	add	r3,r3,r3
8113bbd8:	18c7883a 	add	r3,r3,r3
8113bbdc:	10c5883a 	add	r2,r2,r3
8113bbe0:	10800017 	ldw	r2,0(r2)
8113bbe4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113bbe8:	e0bff817 	ldw	r2,-32(fp)
8113bbec:	1000061e 	bne	r2,zero,8113bc08 <OSTaskStkChk+0xdc>
8113bbf0:	e0bff617 	ldw	r2,-40(fp)
8113bbf4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bbf8:	e0bff717 	ldw	r2,-36(fp)
8113bbfc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113bc00:	008010c4 	movi	r2,67
8113bc04:	00003706 	br	8113bce4 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113bc08:	e0bff817 	ldw	r2,-32(fp)
8113bc0c:	10800058 	cmpnei	r2,r2,1
8113bc10:	1000061e 	bne	r2,zero,8113bc2c <OSTaskStkChk+0x100>
8113bc14:	e0bff617 	ldw	r2,-40(fp)
8113bc18:	e0bff915 	stw	r2,-28(fp)
8113bc1c:	e0bff917 	ldw	r2,-28(fp)
8113bc20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113bc24:	008010c4 	movi	r2,67
8113bc28:	00002e06 	br	8113bce4 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113bc2c:	e0bff817 	ldw	r2,-32(fp)
8113bc30:	1080040b 	ldhu	r2,16(r2)
8113bc34:	10bfffcc 	andi	r2,r2,65535
8113bc38:	1080004c 	andi	r2,r2,1
8113bc3c:	1000061e 	bne	r2,zero,8113bc58 <OSTaskStkChk+0x12c>
8113bc40:	e0bff617 	ldw	r2,-40(fp)
8113bc44:	e0bffa15 	stw	r2,-24(fp)
8113bc48:	e0bffa17 	ldw	r2,-24(fp)
8113bc4c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113bc50:	00801144 	movi	r2,69
8113bc54:	00002306 	br	8113bce4 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113bc58:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113bc5c:	e0bff817 	ldw	r2,-32(fp)
8113bc60:	10800317 	ldw	r2,12(r2)
8113bc64:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113bc68:	e0bff817 	ldw	r2,-32(fp)
8113bc6c:	10800217 	ldw	r2,8(r2)
8113bc70:	e0bff415 	stw	r2,-48(fp)
8113bc74:	e0bff617 	ldw	r2,-40(fp)
8113bc78:	e0bffb15 	stw	r2,-20(fp)
8113bc7c:	e0bffb17 	ldw	r2,-20(fp)
8113bc80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113bc84:	00000306 	br	8113bc94 <OSTaskStkChk+0x168>
        nfree++;
8113bc88:	e0bff517 	ldw	r2,-44(fp)
8113bc8c:	10800044 	addi	r2,r2,1
8113bc90:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113bc94:	e0bff417 	ldw	r2,-48(fp)
8113bc98:	10c00104 	addi	r3,r2,4
8113bc9c:	e0fff415 	stw	r3,-48(fp)
8113bca0:	10800017 	ldw	r2,0(r2)
8113bca4:	103ff826 	beq	r2,zero,8113bc88 <__reset+0xfb11bc88>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113bca8:	e0bff517 	ldw	r2,-44(fp)
8113bcac:	1085883a 	add	r2,r2,r2
8113bcb0:	1085883a 	add	r2,r2,r2
8113bcb4:	1007883a 	mov	r3,r2
8113bcb8:	e0bfff17 	ldw	r2,-4(fp)
8113bcbc:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113bcc0:	e0fffc17 	ldw	r3,-16(fp)
8113bcc4:	e0bff517 	ldw	r2,-44(fp)
8113bcc8:	1885c83a 	sub	r2,r3,r2
8113bccc:	1085883a 	add	r2,r2,r2
8113bcd0:	1085883a 	add	r2,r2,r2
8113bcd4:	1007883a 	mov	r3,r2
8113bcd8:	e0bfff17 	ldw	r2,-4(fp)
8113bcdc:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113bce0:	0005883a 	mov	r2,zero
}
8113bce4:	e037883a 	mov	sp,fp
8113bce8:	df000017 	ldw	fp,0(sp)
8113bcec:	dec00104 	addi	sp,sp,4
8113bcf0:	f800283a 	ret

8113bcf4 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113bcf4:	defff504 	addi	sp,sp,-44
8113bcf8:	de00012e 	bgeu	sp,et,8113bd00 <OSTaskSuspend+0xc>
8113bcfc:	003b68fa 	trap	3
8113bd00:	dfc00a15 	stw	ra,40(sp)
8113bd04:	df000915 	stw	fp,36(sp)
8113bd08:	df000904 	addi	fp,sp,36
8113bd0c:	2005883a 	mov	r2,r4
8113bd10:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bd14:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113bd18:	e0bfff03 	ldbu	r2,-4(fp)
8113bd1c:	10800a98 	cmpnei	r2,r2,42
8113bd20:	1000021e 	bne	r2,zero,8113bd2c <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113bd24:	008011c4 	movi	r2,71
8113bd28:	00006806 	br	8113becc <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113bd2c:	e0bfff03 	ldbu	r2,-4(fp)
8113bd30:	10800ab0 	cmpltui	r2,r2,42
8113bd34:	1000051e 	bne	r2,zero,8113bd4c <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8113bd38:	e0bfff03 	ldbu	r2,-4(fp)
8113bd3c:	10803fe0 	cmpeqi	r2,r2,255
8113bd40:	1000021e 	bne	r2,zero,8113bd4c <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8113bd44:	00800a84 	movi	r2,42
8113bd48:	00006006 	br	8113becc <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bd4c:	0005303a 	rdctl	r2,status
8113bd50:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bd54:	e0fffe17 	ldw	r3,-8(fp)
8113bd58:	00bfff84 	movi	r2,-2
8113bd5c:	1884703a 	and	r2,r3,r2
8113bd60:	1001703a 	wrctl	status,r2
  
  return context;
8113bd64:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113bd68:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8113bd6c:	e0bfff03 	ldbu	r2,-4(fp)
8113bd70:	10803fd8 	cmpnei	r2,r2,255
8113bd74:	1000061e 	bne	r2,zero,8113bd90 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113bd78:	d0a09d17 	ldw	r2,-32140(gp)
8113bd7c:	10800c83 	ldbu	r2,50(r2)
8113bd80:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8113bd84:	00800044 	movi	r2,1
8113bd88:	e0bff705 	stb	r2,-36(fp)
8113bd8c:	00000906 	br	8113bdb4 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8113bd90:	d0a09d17 	ldw	r2,-32140(gp)
8113bd94:	10800c83 	ldbu	r2,50(r2)
8113bd98:	10c03fcc 	andi	r3,r2,255
8113bd9c:	e0bfff03 	ldbu	r2,-4(fp)
8113bda0:	1880031e 	bne	r3,r2,8113bdb0 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8113bda4:	00800044 	movi	r2,1
8113bda8:	e0bff705 	stb	r2,-36(fp)
8113bdac:	00000106 	br	8113bdb4 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8113bdb0:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113bdb4:	e0ffff03 	ldbu	r3,-4(fp)
8113bdb8:	00a045b4 	movhi	r2,33046
8113bdbc:	109e0d04 	addi	r2,r2,30772
8113bdc0:	18c7883a 	add	r3,r3,r3
8113bdc4:	18c7883a 	add	r3,r3,r3
8113bdc8:	10c5883a 	add	r2,r2,r3
8113bdcc:	10800017 	ldw	r2,0(r2)
8113bdd0:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8113bdd4:	e0bffa17 	ldw	r2,-24(fp)
8113bdd8:	1000061e 	bne	r2,zero,8113bdf4 <OSTaskSuspend+0x100>
8113bddc:	e0bff817 	ldw	r2,-32(fp)
8113bde0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bde4:	e0bff917 	ldw	r2,-28(fp)
8113bde8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113bdec:	00801204 	movi	r2,72
8113bdf0:	00003606 	br	8113becc <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8113bdf4:	e0bffa17 	ldw	r2,-24(fp)
8113bdf8:	10800058 	cmpnei	r2,r2,1
8113bdfc:	1000061e 	bne	r2,zero,8113be18 <OSTaskSuspend+0x124>
8113be00:	e0bff817 	ldw	r2,-32(fp)
8113be04:	e0bffb15 	stw	r2,-20(fp)
8113be08:	e0bffb17 	ldw	r2,-20(fp)
8113be0c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113be10:	008010c4 	movi	r2,67
8113be14:	00002d06 	br	8113becc <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8113be18:	e0bffa17 	ldw	r2,-24(fp)
8113be1c:	10800d03 	ldbu	r2,52(r2)
8113be20:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8113be24:	e0fffd03 	ldbu	r3,-12(fp)
8113be28:	e13ffd03 	ldbu	r4,-12(fp)
8113be2c:	d0a09944 	addi	r2,gp,-32155
8113be30:	2085883a 	add	r2,r4,r2
8113be34:	10800003 	ldbu	r2,0(r2)
8113be38:	1009883a 	mov	r4,r2
8113be3c:	e0bffa17 	ldw	r2,-24(fp)
8113be40:	10800d43 	ldbu	r2,53(r2)
8113be44:	0084303a 	nor	r2,zero,r2
8113be48:	2084703a 	and	r2,r4,r2
8113be4c:	1009883a 	mov	r4,r2
8113be50:	d0a09944 	addi	r2,gp,-32155
8113be54:	1885883a 	add	r2,r3,r2
8113be58:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113be5c:	e0fffd03 	ldbu	r3,-12(fp)
8113be60:	d0a09944 	addi	r2,gp,-32155
8113be64:	1885883a 	add	r2,r3,r2
8113be68:	10800003 	ldbu	r2,0(r2)
8113be6c:	10803fcc 	andi	r2,r2,255
8113be70:	1000071e 	bne	r2,zero,8113be90 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113be74:	e0bffa17 	ldw	r2,-24(fp)
8113be78:	10800d83 	ldbu	r2,54(r2)
8113be7c:	0084303a 	nor	r2,zero,r2
8113be80:	1007883a 	mov	r3,r2
8113be84:	d0a09903 	ldbu	r2,-32156(gp)
8113be88:	1884703a 	and	r2,r3,r2
8113be8c:	d0a09905 	stb	r2,-32156(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8113be90:	e0bffa17 	ldw	r2,-24(fp)
8113be94:	10800c03 	ldbu	r2,48(r2)
8113be98:	10800214 	ori	r2,r2,8
8113be9c:	1007883a 	mov	r3,r2
8113bea0:	e0bffa17 	ldw	r2,-24(fp)
8113bea4:	10c00c05 	stb	r3,48(r2)
8113bea8:	e0bff817 	ldw	r2,-32(fp)
8113beac:	e0bffc15 	stw	r2,-16(fp)
8113beb0:	e0bffc17 	ldw	r2,-16(fp)
8113beb4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113beb8:	e0bff703 	ldbu	r2,-36(fp)
8113bebc:	10800058 	cmpnei	r2,r2,1
8113bec0:	1000011e 	bne	r2,zero,8113bec8 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8113bec4:	11353480 	call	81135348 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113bec8:	0005883a 	mov	r2,zero
}
8113becc:	e037883a 	mov	sp,fp
8113bed0:	dfc00117 	ldw	ra,4(sp)
8113bed4:	df000017 	ldw	fp,0(sp)
8113bed8:	dec00204 	addi	sp,sp,8
8113bedc:	f800283a 	ret

8113bee0 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113bee0:	defff604 	addi	sp,sp,-40
8113bee4:	de00012e 	bgeu	sp,et,8113beec <OSTaskQuery+0xc>
8113bee8:	003b68fa 	trap	3
8113beec:	dfc00915 	stw	ra,36(sp)
8113bef0:	df000815 	stw	fp,32(sp)
8113bef4:	df000804 	addi	fp,sp,32
8113bef8:	2005883a 	mov	r2,r4
8113befc:	e17fff15 	stw	r5,-4(fp)
8113bf00:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bf04:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8113bf08:	e0bffe03 	ldbu	r2,-8(fp)
8113bf0c:	10800af0 	cmpltui	r2,r2,43
8113bf10:	1000051e 	bne	r2,zero,8113bf28 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8113bf14:	e0bffe03 	ldbu	r2,-8(fp)
8113bf18:	10803fe0 	cmpeqi	r2,r2,255
8113bf1c:	1000021e 	bne	r2,zero,8113bf28 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113bf20:	00800a84 	movi	r2,42
8113bf24:	00003406 	br	8113bff8 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8113bf28:	e0bfff17 	ldw	r2,-4(fp)
8113bf2c:	1000021e 	bne	r2,zero,8113bf38 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113bf30:	00800244 	movi	r2,9
8113bf34:	00003006 	br	8113bff8 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bf38:	0005303a 	rdctl	r2,status
8113bf3c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bf40:	e0fffd17 	ldw	r3,-12(fp)
8113bf44:	00bfff84 	movi	r2,-2
8113bf48:	1884703a 	and	r2,r3,r2
8113bf4c:	1001703a 	wrctl	status,r2
  
  return context;
8113bf50:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bf54:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113bf58:	e0bffe03 	ldbu	r2,-8(fp)
8113bf5c:	10803fd8 	cmpnei	r2,r2,255
8113bf60:	1000031e 	bne	r2,zero,8113bf70 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8113bf64:	d0a09d17 	ldw	r2,-32140(gp)
8113bf68:	10800c83 	ldbu	r2,50(r2)
8113bf6c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113bf70:	e0fffe03 	ldbu	r3,-8(fp)
8113bf74:	00a045b4 	movhi	r2,33046
8113bf78:	109e0d04 	addi	r2,r2,30772
8113bf7c:	18c7883a 	add	r3,r3,r3
8113bf80:	18c7883a 	add	r3,r3,r3
8113bf84:	10c5883a 	add	r2,r2,r3
8113bf88:	10800017 	ldw	r2,0(r2)
8113bf8c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8113bf90:	e0bffa17 	ldw	r2,-24(fp)
8113bf94:	1000061e 	bne	r2,zero,8113bfb0 <OSTaskQuery+0xd0>
8113bf98:	e0bff817 	ldw	r2,-32(fp)
8113bf9c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bfa0:	e0bff917 	ldw	r2,-28(fp)
8113bfa4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113bfa8:	00800a44 	movi	r2,41
8113bfac:	00001206 	br	8113bff8 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8113bfb0:	e0bffa17 	ldw	r2,-24(fp)
8113bfb4:	10800058 	cmpnei	r2,r2,1
8113bfb8:	1000061e 	bne	r2,zero,8113bfd4 <OSTaskQuery+0xf4>
8113bfbc:	e0bff817 	ldw	r2,-32(fp)
8113bfc0:	e0bffb15 	stw	r2,-20(fp)
8113bfc4:	e0bffb17 	ldw	r2,-20(fp)
8113bfc8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113bfcc:	008010c4 	movi	r2,67
8113bfd0:	00000906 	br	8113bff8 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8113bfd4:	01801b04 	movi	r6,108
8113bfd8:	e17ffa17 	ldw	r5,-24(fp)
8113bfdc:	e13fff17 	ldw	r4,-4(fp)
8113bfe0:	11352d80 	call	811352d8 <OS_MemCopy>
8113bfe4:	e0bff817 	ldw	r2,-32(fp)
8113bfe8:	e0bffc15 	stw	r2,-16(fp)
8113bfec:	e0bffc17 	ldw	r2,-16(fp)
8113bff0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113bff4:	0005883a 	mov	r2,zero
}
8113bff8:	e037883a 	mov	sp,fp
8113bffc:	dfc00117 	ldw	ra,4(sp)
8113c000:	df000017 	ldw	fp,0(sp)
8113c004:	dec00204 	addi	sp,sp,8
8113c008:	f800283a 	ret

8113c00c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113c00c:	defffc04 	addi	sp,sp,-16
8113c010:	de00012e 	bgeu	sp,et,8113c018 <OS_TaskStkClr+0xc>
8113c014:	003b68fa 	trap	3
8113c018:	df000315 	stw	fp,12(sp)
8113c01c:	df000304 	addi	fp,sp,12
8113c020:	e13ffd15 	stw	r4,-12(fp)
8113c024:	e17ffe15 	stw	r5,-8(fp)
8113c028:	3005883a 	mov	r2,r6
8113c02c:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113c030:	e0bfff0b 	ldhu	r2,-4(fp)
8113c034:	1080004c 	andi	r2,r2,1
8113c038:	10000d26 	beq	r2,zero,8113c070 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8113c03c:	e0bfff0b 	ldhu	r2,-4(fp)
8113c040:	1080008c 	andi	r2,r2,2
8113c044:	10000a26 	beq	r2,zero,8113c070 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113c048:	00000706 	br	8113c068 <OS_TaskStkClr+0x5c>
                size--;
8113c04c:	e0bffe17 	ldw	r2,-8(fp)
8113c050:	10bfffc4 	addi	r2,r2,-1
8113c054:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113c058:	e0bffd17 	ldw	r2,-12(fp)
8113c05c:	10c00104 	addi	r3,r2,4
8113c060:	e0fffd15 	stw	r3,-12(fp)
8113c064:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113c068:	e0bffe17 	ldw	r2,-8(fp)
8113c06c:	103ff71e 	bne	r2,zero,8113c04c <__reset+0xfb11c04c>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8113c070:	0001883a 	nop
8113c074:	e037883a 	mov	sp,fp
8113c078:	df000017 	ldw	fp,0(sp)
8113c07c:	dec00104 	addi	sp,sp,4
8113c080:	f800283a 	ret

8113c084 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8113c084:	defff904 	addi	sp,sp,-28
8113c088:	de00012e 	bgeu	sp,et,8113c090 <OSTimeDly+0xc>
8113c08c:	003b68fa 	trap	3
8113c090:	dfc00615 	stw	ra,24(sp)
8113c094:	df000515 	stw	fp,20(sp)
8113c098:	df000504 	addi	fp,sp,20
8113c09c:	2005883a 	mov	r2,r4
8113c0a0:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c0a4:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c0a8:	d0a09c03 	ldbu	r2,-32144(gp)
8113c0ac:	10803fcc 	andi	r2,r2,255
8113c0b0:	1000311e 	bne	r2,zero,8113c178 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8113c0b4:	e0bfff0b 	ldhu	r2,-4(fp)
8113c0b8:	10003026 	beq	r2,zero,8113c17c <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c0bc:	0005303a 	rdctl	r2,status
8113c0c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c0c4:	e0fffe17 	ldw	r3,-8(fp)
8113c0c8:	00bfff84 	movi	r2,-2
8113c0cc:	1884703a 	and	r2,r3,r2
8113c0d0:	1001703a 	wrctl	status,r2
  
  return context;
8113c0d4:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113c0d8:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113c0dc:	d0a09d17 	ldw	r2,-32140(gp)
8113c0e0:	10800d03 	ldbu	r2,52(r2)
8113c0e4:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113c0e8:	e0fffd03 	ldbu	r3,-12(fp)
8113c0ec:	e13ffd03 	ldbu	r4,-12(fp)
8113c0f0:	d0a09944 	addi	r2,gp,-32155
8113c0f4:	2085883a 	add	r2,r4,r2
8113c0f8:	10800003 	ldbu	r2,0(r2)
8113c0fc:	1009883a 	mov	r4,r2
8113c100:	d0a09d17 	ldw	r2,-32140(gp)
8113c104:	10800d43 	ldbu	r2,53(r2)
8113c108:	0084303a 	nor	r2,zero,r2
8113c10c:	2084703a 	and	r2,r4,r2
8113c110:	1009883a 	mov	r4,r2
8113c114:	d0a09944 	addi	r2,gp,-32155
8113c118:	1885883a 	add	r2,r3,r2
8113c11c:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8113c120:	e0fffd03 	ldbu	r3,-12(fp)
8113c124:	d0a09944 	addi	r2,gp,-32155
8113c128:	1885883a 	add	r2,r3,r2
8113c12c:	10800003 	ldbu	r2,0(r2)
8113c130:	10803fcc 	andi	r2,r2,255
8113c134:	1000071e 	bne	r2,zero,8113c154 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113c138:	d0a09d17 	ldw	r2,-32140(gp)
8113c13c:	10800d83 	ldbu	r2,54(r2)
8113c140:	0084303a 	nor	r2,zero,r2
8113c144:	1007883a 	mov	r3,r2
8113c148:	d0a09903 	ldbu	r2,-32156(gp)
8113c14c:	1884703a 	and	r2,r3,r2
8113c150:	d0a09905 	stb	r2,-32156(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8113c154:	d0a09d17 	ldw	r2,-32140(gp)
8113c158:	e0ffff0b 	ldhu	r3,-4(fp)
8113c15c:	10c00b8d 	sth	r3,46(r2)
8113c160:	e0bffb17 	ldw	r2,-20(fp)
8113c164:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c168:	e0bffc17 	ldw	r2,-16(fp)
8113c16c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8113c170:	11353480 	call	81135348 <OS_Sched>
8113c174:	00000106 	br	8113c17c <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113c178:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8113c17c:	e037883a 	mov	sp,fp
8113c180:	dfc00117 	ldw	ra,4(sp)
8113c184:	df000017 	ldw	fp,0(sp)
8113c188:	dec00204 	addi	sp,sp,8
8113c18c:	f800283a 	ret

8113c190 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8113c190:	defff804 	addi	sp,sp,-32
8113c194:	de00012e 	bgeu	sp,et,8113c19c <OSTimeDlyHMSM+0xc>
8113c198:	003b68fa 	trap	3
8113c19c:	dfc00715 	stw	ra,28(sp)
8113c1a0:	df000615 	stw	fp,24(sp)
8113c1a4:	df000604 	addi	fp,sp,24
8113c1a8:	2015883a 	mov	r10,r4
8113c1ac:	2809883a 	mov	r4,r5
8113c1b0:	3007883a 	mov	r3,r6
8113c1b4:	3805883a 	mov	r2,r7
8113c1b8:	e2bffc05 	stb	r10,-16(fp)
8113c1bc:	e13ffd05 	stb	r4,-12(fp)
8113c1c0:	e0fffe05 	stb	r3,-8(fp)
8113c1c4:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c1c8:	d0a09c03 	ldbu	r2,-32144(gp)
8113c1cc:	10803fcc 	andi	r2,r2,255
8113c1d0:	10000226 	beq	r2,zero,8113c1dc <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8113c1d4:	00801544 	movi	r2,85
8113c1d8:	00004106 	br	8113c2e0 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113c1dc:	e0bffc03 	ldbu	r2,-16(fp)
8113c1e0:	1000081e 	bne	r2,zero,8113c204 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8113c1e4:	e0bffd03 	ldbu	r2,-12(fp)
8113c1e8:	1000061e 	bne	r2,zero,8113c204 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113c1ec:	e0bffe03 	ldbu	r2,-8(fp)
8113c1f0:	1000041e 	bne	r2,zero,8113c204 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8113c1f4:	e0bfff0b 	ldhu	r2,-4(fp)
8113c1f8:	1000021e 	bne	r2,zero,8113c204 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113c1fc:	00801504 	movi	r2,84
8113c200:	00003706 	br	8113c2e0 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8113c204:	e0bffd03 	ldbu	r2,-12(fp)
8113c208:	10800f30 	cmpltui	r2,r2,60
8113c20c:	1000021e 	bne	r2,zero,8113c218 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8113c210:	00801444 	movi	r2,81
8113c214:	00003206 	br	8113c2e0 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8113c218:	e0bffe03 	ldbu	r2,-8(fp)
8113c21c:	10800f30 	cmpltui	r2,r2,60
8113c220:	1000021e 	bne	r2,zero,8113c22c <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8113c224:	00801484 	movi	r2,82
8113c228:	00002d06 	br	8113c2e0 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8113c22c:	e0bfff0b 	ldhu	r2,-4(fp)
8113c230:	1080fa30 	cmpltui	r2,r2,1000
8113c234:	1000021e 	bne	r2,zero,8113c240 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8113c238:	008014c4 	movi	r2,83
8113c23c:	00002806 	br	8113c2e0 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113c240:	e0bffc03 	ldbu	r2,-16(fp)
8113c244:	10c38424 	muli	r3,r2,3600
8113c248:	e0bffd03 	ldbu	r2,-12(fp)
8113c24c:	10800f24 	muli	r2,r2,60
8113c250:	1887883a 	add	r3,r3,r2
8113c254:	e0bffe03 	ldbu	r2,-8(fp)
8113c258:	1885883a 	add	r2,r3,r2
8113c25c:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8113c260:	e0bfff0b 	ldhu	r2,-4(fp)
8113c264:	10c0fa24 	muli	r3,r2,1000
8113c268:	008418b4 	movhi	r2,4194
8113c26c:	109374c4 	addi	r2,r2,19923
8113c270:	188a383a 	mulxuu	r5,r3,r2
8113c274:	1885383a 	mul	r2,r3,r2
8113c278:	1011883a 	mov	r8,r2
8113c27c:	2813883a 	mov	r9,r5
8113c280:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113c284:	2085883a 	add	r2,r4,r2
8113c288:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113c28c:	e0bffb17 	ldw	r2,-20(fp)
8113c290:	1004d43a 	srli	r2,r2,16
8113c294:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113c298:	e0bffb17 	ldw	r2,-20(fp)
8113c29c:	10bfffcc 	andi	r2,r2,65535
8113c2a0:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8113c2a4:	e0bffb17 	ldw	r2,-20(fp)
8113c2a8:	10bfffcc 	andi	r2,r2,65535
8113c2ac:	1009883a 	mov	r4,r2
8113c2b0:	113c0840 	call	8113c084 <OSTimeDly>
    while (loops > 0) {
8113c2b4:	00000706 	br	8113c2d4 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113c2b8:	01200014 	movui	r4,32768
8113c2bc:	113c0840 	call	8113c084 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8113c2c0:	01200014 	movui	r4,32768
8113c2c4:	113c0840 	call	8113c084 <OSTimeDly>
        loops--;
8113c2c8:	e0bffa0b 	ldhu	r2,-24(fp)
8113c2cc:	10bfffc4 	addi	r2,r2,-1
8113c2d0:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8113c2d4:	e0bffa0b 	ldhu	r2,-24(fp)
8113c2d8:	103ff71e 	bne	r2,zero,8113c2b8 <__reset+0xfb11c2b8>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113c2dc:	0005883a 	mov	r2,zero
}
8113c2e0:	e037883a 	mov	sp,fp
8113c2e4:	dfc00117 	ldw	ra,4(sp)
8113c2e8:	df000017 	ldw	fp,0(sp)
8113c2ec:	dec00204 	addi	sp,sp,8
8113c2f0:	f800283a 	ret

8113c2f4 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8113c2f4:	defff504 	addi	sp,sp,-44
8113c2f8:	de00012e 	bgeu	sp,et,8113c300 <OSTimeDlyResume+0xc>
8113c2fc:	003b68fa 	trap	3
8113c300:	dfc00a15 	stw	ra,40(sp)
8113c304:	df000915 	stw	fp,36(sp)
8113c308:	df000904 	addi	fp,sp,36
8113c30c:	2005883a 	mov	r2,r4
8113c310:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113c314:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8113c318:	e0bfff03 	ldbu	r2,-4(fp)
8113c31c:	10800ab0 	cmpltui	r2,r2,42
8113c320:	1000021e 	bne	r2,zero,8113c32c <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113c324:	00800a84 	movi	r2,42
8113c328:	00006406 	br	8113c4bc <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c32c:	0005303a 	rdctl	r2,status
8113c330:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c334:	e0fffe17 	ldw	r3,-8(fp)
8113c338:	00bfff84 	movi	r2,-2
8113c33c:	1884703a 	and	r2,r3,r2
8113c340:	1001703a 	wrctl	status,r2
  
  return context;
8113c344:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113c348:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8113c34c:	e0ffff03 	ldbu	r3,-4(fp)
8113c350:	00a045b4 	movhi	r2,33046
8113c354:	109e0d04 	addi	r2,r2,30772
8113c358:	18c7883a 	add	r3,r3,r3
8113c35c:	18c7883a 	add	r3,r3,r3
8113c360:	10c5883a 	add	r2,r2,r3
8113c364:	10800017 	ldw	r2,0(r2)
8113c368:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8113c36c:	e0bff917 	ldw	r2,-28(fp)
8113c370:	1000061e 	bne	r2,zero,8113c38c <OSTimeDlyResume+0x98>
8113c374:	e0bff717 	ldw	r2,-36(fp)
8113c378:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c37c:	e0bff817 	ldw	r2,-32(fp)
8113c380:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113c384:	008010c4 	movi	r2,67
8113c388:	00004c06 	br	8113c4bc <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113c38c:	e0bff917 	ldw	r2,-28(fp)
8113c390:	10800058 	cmpnei	r2,r2,1
8113c394:	1000061e 	bne	r2,zero,8113c3b0 <OSTimeDlyResume+0xbc>
8113c398:	e0bff717 	ldw	r2,-36(fp)
8113c39c:	e0bffa15 	stw	r2,-24(fp)
8113c3a0:	e0bffa17 	ldw	r2,-24(fp)
8113c3a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113c3a8:	008010c4 	movi	r2,67
8113c3ac:	00004306 	br	8113c4bc <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8113c3b0:	e0bff917 	ldw	r2,-28(fp)
8113c3b4:	10800b8b 	ldhu	r2,46(r2)
8113c3b8:	10bfffcc 	andi	r2,r2,65535
8113c3bc:	1000061e 	bne	r2,zero,8113c3d8 <OSTimeDlyResume+0xe4>
8113c3c0:	e0bff717 	ldw	r2,-36(fp)
8113c3c4:	e0bffb15 	stw	r2,-20(fp)
8113c3c8:	e0bffb17 	ldw	r2,-20(fp)
8113c3cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8113c3d0:	00801404 	movi	r2,80
8113c3d4:	00003906 	br	8113c4bc <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113c3d8:	e0bff917 	ldw	r2,-28(fp)
8113c3dc:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113c3e0:	e0bff917 	ldw	r2,-28(fp)
8113c3e4:	10800c03 	ldbu	r2,48(r2)
8113c3e8:	10803fcc 	andi	r2,r2,255
8113c3ec:	10800dcc 	andi	r2,r2,55
8113c3f0:	10000b26 	beq	r2,zero,8113c420 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8113c3f4:	e0bff917 	ldw	r2,-28(fp)
8113c3f8:	10c00c03 	ldbu	r3,48(r2)
8113c3fc:	00bff204 	movi	r2,-56
8113c400:	1884703a 	and	r2,r3,r2
8113c404:	1007883a 	mov	r3,r2
8113c408:	e0bff917 	ldw	r2,-28(fp)
8113c40c:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8113c410:	e0bff917 	ldw	r2,-28(fp)
8113c414:	00c00044 	movi	r3,1
8113c418:	10c00c45 	stb	r3,49(r2)
8113c41c:	00000206 	br	8113c428 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8113c420:	e0bff917 	ldw	r2,-28(fp)
8113c424:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8113c428:	e0bff917 	ldw	r2,-28(fp)
8113c42c:	10800c03 	ldbu	r2,48(r2)
8113c430:	10803fcc 	andi	r2,r2,255
8113c434:	1080020c 	andi	r2,r2,8
8113c438:	10001b1e 	bne	r2,zero,8113c4a8 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8113c43c:	e0bff917 	ldw	r2,-28(fp)
8113c440:	10c00d83 	ldbu	r3,54(r2)
8113c444:	d0a09903 	ldbu	r2,-32156(gp)
8113c448:	1884b03a 	or	r2,r3,r2
8113c44c:	d0a09905 	stb	r2,-32156(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113c450:	e0bff917 	ldw	r2,-28(fp)
8113c454:	10800d03 	ldbu	r2,52(r2)
8113c458:	10c03fcc 	andi	r3,r2,255
8113c45c:	e0bff917 	ldw	r2,-28(fp)
8113c460:	10800d03 	ldbu	r2,52(r2)
8113c464:	11003fcc 	andi	r4,r2,255
8113c468:	d0a09944 	addi	r2,gp,-32155
8113c46c:	2085883a 	add	r2,r4,r2
8113c470:	11000003 	ldbu	r4,0(r2)
8113c474:	e0bff917 	ldw	r2,-28(fp)
8113c478:	10800d43 	ldbu	r2,53(r2)
8113c47c:	2084b03a 	or	r2,r4,r2
8113c480:	1009883a 	mov	r4,r2
8113c484:	d0a09944 	addi	r2,gp,-32155
8113c488:	1885883a 	add	r2,r3,r2
8113c48c:	11000005 	stb	r4,0(r2)
8113c490:	e0bff717 	ldw	r2,-36(fp)
8113c494:	e0bffc15 	stw	r2,-16(fp)
8113c498:	e0bffc17 	ldw	r2,-16(fp)
8113c49c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8113c4a0:	11353480 	call	81135348 <OS_Sched>
8113c4a4:	00000406 	br	8113c4b8 <OSTimeDlyResume+0x1c4>
8113c4a8:	e0bff717 	ldw	r2,-36(fp)
8113c4ac:	e0bffd15 	stw	r2,-12(fp)
8113c4b0:	e0bffd17 	ldw	r2,-12(fp)
8113c4b4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113c4b8:	0005883a 	mov	r2,zero
}
8113c4bc:	e037883a 	mov	sp,fp
8113c4c0:	dfc00117 	ldw	ra,4(sp)
8113c4c4:	df000017 	ldw	fp,0(sp)
8113c4c8:	dec00204 	addi	sp,sp,8
8113c4cc:	f800283a 	ret

8113c4d0 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8113c4d0:	defffb04 	addi	sp,sp,-20
8113c4d4:	de00012e 	bgeu	sp,et,8113c4dc <OSTimeGet+0xc>
8113c4d8:	003b68fa 	trap	3
8113c4dc:	df000415 	stw	fp,16(sp)
8113c4e0:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c4e4:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c4e8:	0005303a 	rdctl	r2,status
8113c4ec:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c4f0:	e0fffe17 	ldw	r3,-8(fp)
8113c4f4:	00bfff84 	movi	r2,-2
8113c4f8:	1884703a 	and	r2,r3,r2
8113c4fc:	1001703a 	wrctl	status,r2
  
  return context;
8113c500:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113c504:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8113c508:	d0a09f17 	ldw	r2,-32132(gp)
8113c50c:	e0bffd15 	stw	r2,-12(fp)
8113c510:	e0bffc17 	ldw	r2,-16(fp)
8113c514:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c518:	e0bfff17 	ldw	r2,-4(fp)
8113c51c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8113c520:	e0bffd17 	ldw	r2,-12(fp)
}
8113c524:	e037883a 	mov	sp,fp
8113c528:	df000017 	ldw	fp,0(sp)
8113c52c:	dec00104 	addi	sp,sp,4
8113c530:	f800283a 	ret

8113c534 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
8113c534:	defffb04 	addi	sp,sp,-20
8113c538:	de00012e 	bgeu	sp,et,8113c540 <OSTimeSet+0xc>
8113c53c:	003b68fa 	trap	3
8113c540:	df000415 	stw	fp,16(sp)
8113c544:	df000404 	addi	fp,sp,16
8113c548:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c54c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c550:	0005303a 	rdctl	r2,status
8113c554:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c558:	e0fffd17 	ldw	r3,-12(fp)
8113c55c:	00bfff84 	movi	r2,-2
8113c560:	1884703a 	and	r2,r3,r2
8113c564:	1001703a 	wrctl	status,r2
  
  return context;
8113c568:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
8113c56c:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8113c570:	e0bfff17 	ldw	r2,-4(fp)
8113c574:	d0a09f15 	stw	r2,-32132(gp)
8113c578:	e0bffc17 	ldw	r2,-16(fp)
8113c57c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c580:	e0bffe17 	ldw	r2,-8(fp)
8113c584:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113c588:	0001883a 	nop
8113c58c:	e037883a 	mov	sp,fp
8113c590:	df000017 	ldw	fp,0(sp)
8113c594:	dec00104 	addi	sp,sp,4
8113c598:	f800283a 	ret

8113c59c <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8113c59c:	defff804 	addi	sp,sp,-32
8113c5a0:	de00012e 	bgeu	sp,et,8113c5a8 <OSTmrCreate+0xc>
8113c5a4:	003b68fa 	trap	3
8113c5a8:	dfc00715 	stw	ra,28(sp)
8113c5ac:	df000615 	stw	fp,24(sp)
8113c5b0:	df000604 	addi	fp,sp,24
8113c5b4:	e13ffc15 	stw	r4,-16(fp)
8113c5b8:	e17ffd15 	stw	r5,-12(fp)
8113c5bc:	3005883a 	mov	r2,r6
8113c5c0:	e1ffff15 	stw	r7,-4(fp)
8113c5c4:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113c5c8:	e0800417 	ldw	r2,16(fp)
8113c5cc:	1000021e 	bne	r2,zero,8113c5d8 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8113c5d0:	0005883a 	mov	r2,zero
8113c5d4:	00005d06 	br	8113c74c <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8113c5d8:	e0bffe03 	ldbu	r2,-8(fp)
8113c5dc:	10c00060 	cmpeqi	r3,r2,1
8113c5e0:	1800091e 	bne	r3,zero,8113c608 <OSTmrCreate+0x6c>
8113c5e4:	108000a0 	cmpeqi	r2,r2,2
8113c5e8:	10000e26 	beq	r2,zero,8113c624 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8113c5ec:	e0bffd17 	ldw	r2,-12(fp)
8113c5f0:	1000111e 	bne	r2,zero,8113c638 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
8113c5f4:	e0800417 	ldw	r2,16(fp)
8113c5f8:	00ffe0c4 	movi	r3,-125
8113c5fc:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113c600:	0005883a 	mov	r2,zero
8113c604:	00005106 	br	8113c74c <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
8113c608:	e0bffc17 	ldw	r2,-16(fp)
8113c60c:	10000c1e 	bne	r2,zero,8113c640 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8113c610:	e0800417 	ldw	r2,16(fp)
8113c614:	00ffe084 	movi	r3,-126
8113c618:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113c61c:	0005883a 	mov	r2,zero
8113c620:	00004a06 	br	8113c74c <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
8113c624:	e0800417 	ldw	r2,16(fp)
8113c628:	00ffe104 	movi	r3,-124
8113c62c:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8113c630:	0005883a 	mov	r2,zero
8113c634:	00004506 	br	8113c74c <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8113c638:	0001883a 	nop
8113c63c:	00000106 	br	8113c644 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8113c640:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113c644:	d0a09c03 	ldbu	r2,-32144(gp)
8113c648:	10803fcc 	andi	r2,r2,255
8113c64c:	10000526 	beq	r2,zero,8113c664 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8113c650:	e0800417 	ldw	r2,16(fp)
8113c654:	00ffe2c4 	movi	r3,-117
8113c658:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113c65c:	0005883a 	mov	r2,zero
8113c660:	00003a06 	br	8113c74c <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8113c664:	113d5540 	call	8113d554 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8113c668:	113cff40 	call	8113cff4 <OSTmr_Alloc>
8113c66c:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8113c670:	e0bffa17 	ldw	r2,-24(fp)
8113c674:	1000061e 	bne	r2,zero,8113c690 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8113c678:	113d5980 	call	8113d598 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
8113c67c:	e0800417 	ldw	r2,16(fp)
8113c680:	00ffe184 	movi	r3,-122
8113c684:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113c688:	0005883a 	mov	r2,zero
8113c68c:	00002f06 	br	8113c74c <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8113c690:	e0bffa17 	ldw	r2,-24(fp)
8113c694:	00c00044 	movi	r3,1
8113c698:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
8113c69c:	e0bffa17 	ldw	r2,-24(fp)
8113c6a0:	e0fffc17 	ldw	r3,-16(fp)
8113c6a4:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8113c6a8:	e0bffa17 	ldw	r2,-24(fp)
8113c6ac:	e0fffd17 	ldw	r3,-12(fp)
8113c6b0:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8113c6b4:	e0bffa17 	ldw	r2,-24(fp)
8113c6b8:	e0fffe03 	ldbu	r3,-8(fp)
8113c6bc:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8113c6c0:	e0bffa17 	ldw	r2,-24(fp)
8113c6c4:	e0ffff17 	ldw	r3,-4(fp)
8113c6c8:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
8113c6cc:	e0bffa17 	ldw	r2,-24(fp)
8113c6d0:	e0c00217 	ldw	r3,8(fp)
8113c6d4:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
8113c6d8:	e0800317 	ldw	r2,12(fp)
8113c6dc:	10001726 	beq	r2,zero,8113c73c <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8113c6e0:	e1000317 	ldw	r4,12(fp)
8113c6e4:	11355180 	call	81135518 <OS_StrLen>
8113c6e8:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8113c6ec:	e0bffb03 	ldbu	r2,-20(fp)
8113c6f0:	10800428 	cmpgeui	r2,r2,16
8113c6f4:	1000061e 	bne	r2,zero,8113c710 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8113c6f8:	e0bffa17 	ldw	r2,-24(fp)
8113c6fc:	10800804 	addi	r2,r2,32
8113c700:	e1400317 	ldw	r5,12(fp)
8113c704:	1009883a 	mov	r4,r2
8113c708:	113549c0 	call	8113549c <OS_StrCopy>
8113c70c:	00000b06 	br	8113c73c <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8113c710:	e0bffa17 	ldw	r2,-24(fp)
8113c714:	00c008c4 	movi	r3,35
8113c718:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8113c71c:	e0bffa17 	ldw	r2,-24(fp)
8113c720:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
8113c724:	e0800417 	ldw	r2,16(fp)
8113c728:	00ffe304 	movi	r3,-116
8113c72c:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8113c730:	113d5980 	call	8113d598 <OSTmr_Unlock>
            return (ptmr);
8113c734:	e0bffa17 	ldw	r2,-24(fp)
8113c738:	00000406 	br	8113c74c <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8113c73c:	113d5980 	call	8113d598 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8113c740:	e0800417 	ldw	r2,16(fp)
8113c744:	10000005 	stb	zero,0(r2)
    return (ptmr);
8113c748:	e0bffa17 	ldw	r2,-24(fp)
}
8113c74c:	e037883a 	mov	sp,fp
8113c750:	dfc00117 	ldw	ra,4(sp)
8113c754:	df000017 	ldw	fp,0(sp)
8113c758:	dec00204 	addi	sp,sp,8
8113c75c:	f800283a 	ret

8113c760 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8113c760:	defffc04 	addi	sp,sp,-16
8113c764:	de00012e 	bgeu	sp,et,8113c76c <OSTmrDel+0xc>
8113c768:	003b68fa 	trap	3
8113c76c:	dfc00315 	stw	ra,12(sp)
8113c770:	df000215 	stw	fp,8(sp)
8113c774:	df000204 	addi	fp,sp,8
8113c778:	e13ffe15 	stw	r4,-8(fp)
8113c77c:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113c780:	e0bfff17 	ldw	r2,-4(fp)
8113c784:	1000021e 	bne	r2,zero,8113c790 <OSTmrDel+0x30>
        return (OS_FALSE);
8113c788:	0005883a 	mov	r2,zero
8113c78c:	00003f06 	br	8113c88c <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113c790:	e0bffe17 	ldw	r2,-8(fp)
8113c794:	1000051e 	bne	r2,zero,8113c7ac <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113c798:	e0bfff17 	ldw	r2,-4(fp)
8113c79c:	00ffe284 	movi	r3,-118
8113c7a0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c7a4:	0005883a 	mov	r2,zero
8113c7a8:	00003806 	br	8113c88c <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113c7ac:	e0bffe17 	ldw	r2,-8(fp)
8113c7b0:	10800003 	ldbu	r2,0(r2)
8113c7b4:	10803fcc 	andi	r2,r2,255
8113c7b8:	10801920 	cmpeqi	r2,r2,100
8113c7bc:	1000051e 	bne	r2,zero,8113c7d4 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113c7c0:	e0bfff17 	ldw	r2,-4(fp)
8113c7c4:	00ffe244 	movi	r3,-119
8113c7c8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c7cc:	0005883a 	mov	r2,zero
8113c7d0:	00002e06 	br	8113c88c <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113c7d4:	d0a09c03 	ldbu	r2,-32144(gp)
8113c7d8:	10803fcc 	andi	r2,r2,255
8113c7dc:	10000526 	beq	r2,zero,8113c7f4 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113c7e0:	e0bfff17 	ldw	r2,-4(fp)
8113c7e4:	00ffe2c4 	movi	r3,-117
8113c7e8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c7ec:	0005883a 	mov	r2,zero
8113c7f0:	00002606 	br	8113c88c <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
8113c7f4:	113d5540 	call	8113d554 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113c7f8:	e0bffe17 	ldw	r2,-8(fp)
8113c7fc:	10800c43 	ldbu	r2,49(r2)
8113c800:	10803fcc 	andi	r2,r2,255
8113c804:	10c000c8 	cmpgei	r3,r2,3
8113c808:	1800031e 	bne	r3,zero,8113c818 <OSTmrDel+0xb8>
8113c80c:	00800d16 	blt	zero,r2,8113c844 <OSTmrDel+0xe4>
8113c810:	10001326 	beq	r2,zero,8113c860 <OSTmrDel+0x100>
8113c814:	00001806 	br	8113c878 <OSTmrDel+0x118>
8113c818:	108000e0 	cmpeqi	r2,r2,3
8113c81c:	10001626 	beq	r2,zero,8113c878 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8113c820:	e13ffe17 	ldw	r4,-8(fp)
8113c824:	113d4580 	call	8113d458 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113c828:	e13ffe17 	ldw	r4,-8(fp)
8113c82c:	113d0680 	call	8113d068 <OSTmr_Free>
             OSTmr_Unlock();
8113c830:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c834:	e0bfff17 	ldw	r2,-4(fp)
8113c838:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113c83c:	00800044 	movi	r2,1
8113c840:	00001206 	br	8113c88c <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113c844:	e13ffe17 	ldw	r4,-8(fp)
8113c848:	113d0680 	call	8113d068 <OSTmr_Free>
             OSTmr_Unlock();
8113c84c:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c850:	e0bfff17 	ldw	r2,-4(fp)
8113c854:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113c858:	00800044 	movi	r2,1
8113c85c:	00000b06 	br	8113c88c <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8113c860:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113c864:	e0bfff17 	ldw	r2,-4(fp)
8113c868:	00ffe1c4 	movi	r3,-121
8113c86c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c870:	0005883a 	mov	r2,zero
8113c874:	00000506 	br	8113c88c <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8113c878:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c87c:	e0bfff17 	ldw	r2,-4(fp)
8113c880:	00ffe344 	movi	r3,-115
8113c884:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c888:	0005883a 	mov	r2,zero
    }
}
8113c88c:	e037883a 	mov	sp,fp
8113c890:	dfc00117 	ldw	ra,4(sp)
8113c894:	df000017 	ldw	fp,0(sp)
8113c898:	dec00204 	addi	sp,sp,8
8113c89c:	f800283a 	ret

8113c8a0 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8113c8a0:	defffa04 	addi	sp,sp,-24
8113c8a4:	de00012e 	bgeu	sp,et,8113c8ac <OSTmrNameGet+0xc>
8113c8a8:	003b68fa 	trap	3
8113c8ac:	dfc00515 	stw	ra,20(sp)
8113c8b0:	df000415 	stw	fp,16(sp)
8113c8b4:	df000404 	addi	fp,sp,16
8113c8b8:	e13ffd15 	stw	r4,-12(fp)
8113c8bc:	e17ffe15 	stw	r5,-8(fp)
8113c8c0:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113c8c4:	e0bfff17 	ldw	r2,-4(fp)
8113c8c8:	1000021e 	bne	r2,zero,8113c8d4 <OSTmrNameGet+0x34>
        return (0);
8113c8cc:	0005883a 	mov	r2,zero
8113c8d0:	00003e06 	br	8113c9cc <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
8113c8d4:	e0bffe17 	ldw	r2,-8(fp)
8113c8d8:	1000051e 	bne	r2,zero,8113c8f0 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8113c8dc:	e0bfff17 	ldw	r2,-4(fp)
8113c8e0:	00ffe204 	movi	r3,-120
8113c8e4:	10c00005 	stb	r3,0(r2)
        return (0);
8113c8e8:	0005883a 	mov	r2,zero
8113c8ec:	00003706 	br	8113c9cc <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113c8f0:	e0bffd17 	ldw	r2,-12(fp)
8113c8f4:	1000051e 	bne	r2,zero,8113c90c <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8113c8f8:	e0bfff17 	ldw	r2,-4(fp)
8113c8fc:	00ffe284 	movi	r3,-118
8113c900:	10c00005 	stb	r3,0(r2)
        return (0);
8113c904:	0005883a 	mov	r2,zero
8113c908:	00003006 	br	8113c9cc <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113c90c:	e0bffd17 	ldw	r2,-12(fp)
8113c910:	10800003 	ldbu	r2,0(r2)
8113c914:	10803fcc 	andi	r2,r2,255
8113c918:	10801920 	cmpeqi	r2,r2,100
8113c91c:	1000051e 	bne	r2,zero,8113c934 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113c920:	e0bfff17 	ldw	r2,-4(fp)
8113c924:	00ffe244 	movi	r3,-119
8113c928:	10c00005 	stb	r3,0(r2)
        return (0);
8113c92c:	0005883a 	mov	r2,zero
8113c930:	00002606 	br	8113c9cc <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113c934:	d0a09c03 	ldbu	r2,-32144(gp)
8113c938:	10803fcc 	andi	r2,r2,255
8113c93c:	10000526 	beq	r2,zero,8113c954 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8113c940:	e0bfff17 	ldw	r2,-4(fp)
8113c944:	00c00444 	movi	r3,17
8113c948:	10c00005 	stb	r3,0(r2)
        return (0);
8113c94c:	0005883a 	mov	r2,zero
8113c950:	00001e06 	br	8113c9cc <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
8113c954:	113d5540 	call	8113d554 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113c958:	e0bffd17 	ldw	r2,-12(fp)
8113c95c:	10800c43 	ldbu	r2,49(r2)
8113c960:	10803fcc 	andi	r2,r2,255
8113c964:	10000e26 	beq	r2,zero,8113c9a0 <OSTmrNameGet+0x100>
8113c968:	10001316 	blt	r2,zero,8113c9b8 <OSTmrNameGet+0x118>
8113c96c:	10800108 	cmpgei	r2,r2,4
8113c970:	1000111e 	bne	r2,zero,8113c9b8 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
8113c974:	e0bffd17 	ldw	r2,-12(fp)
8113c978:	10800804 	addi	r2,r2,32
8113c97c:	100b883a 	mov	r5,r2
8113c980:	e13ffe17 	ldw	r4,-8(fp)
8113c984:	113549c0 	call	8113549c <OS_StrCopy>
8113c988:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
8113c98c:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c990:	e0bfff17 	ldw	r2,-4(fp)
8113c994:	10000005 	stb	zero,0(r2)
             return (len);
8113c998:	e0bffc03 	ldbu	r2,-16(fp)
8113c99c:	00000b06 	br	8113c9cc <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8113c9a0:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113c9a4:	e0bfff17 	ldw	r2,-4(fp)
8113c9a8:	00ffe1c4 	movi	r3,-121
8113c9ac:	10c00005 	stb	r3,0(r2)
             return (0);
8113c9b0:	0005883a 	mov	r2,zero
8113c9b4:	00000506 	br	8113c9cc <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8113c9b8:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c9bc:	e0bfff17 	ldw	r2,-4(fp)
8113c9c0:	00ffe344 	movi	r3,-115
8113c9c4:	10c00005 	stb	r3,0(r2)
             return (0);
8113c9c8:	0005883a 	mov	r2,zero
    }
}
8113c9cc:	e037883a 	mov	sp,fp
8113c9d0:	dfc00117 	ldw	ra,4(sp)
8113c9d4:	df000017 	ldw	fp,0(sp)
8113c9d8:	dec00204 	addi	sp,sp,8
8113c9dc:	f800283a 	ret

8113c9e0 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8113c9e0:	defffb04 	addi	sp,sp,-20
8113c9e4:	de00012e 	bgeu	sp,et,8113c9ec <OSTmrRemainGet+0xc>
8113c9e8:	003b68fa 	trap	3
8113c9ec:	dfc00415 	stw	ra,16(sp)
8113c9f0:	df000315 	stw	fp,12(sp)
8113c9f4:	df000304 	addi	fp,sp,12
8113c9f8:	e13ffe15 	stw	r4,-8(fp)
8113c9fc:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113ca00:	e0bfff17 	ldw	r2,-4(fp)
8113ca04:	1000021e 	bne	r2,zero,8113ca10 <OSTmrRemainGet+0x30>
        return (0);
8113ca08:	0005883a 	mov	r2,zero
8113ca0c:	00005d06 	br	8113cb84 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8113ca10:	e0bffe17 	ldw	r2,-8(fp)
8113ca14:	1000051e 	bne	r2,zero,8113ca2c <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113ca18:	e0bfff17 	ldw	r2,-4(fp)
8113ca1c:	00ffe284 	movi	r3,-118
8113ca20:	10c00005 	stb	r3,0(r2)
        return (0);
8113ca24:	0005883a 	mov	r2,zero
8113ca28:	00005606 	br	8113cb84 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113ca2c:	e0bffe17 	ldw	r2,-8(fp)
8113ca30:	10800003 	ldbu	r2,0(r2)
8113ca34:	10803fcc 	andi	r2,r2,255
8113ca38:	10801920 	cmpeqi	r2,r2,100
8113ca3c:	1000051e 	bne	r2,zero,8113ca54 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113ca40:	e0bfff17 	ldw	r2,-4(fp)
8113ca44:	00ffe244 	movi	r3,-119
8113ca48:	10c00005 	stb	r3,0(r2)
        return (0);
8113ca4c:	0005883a 	mov	r2,zero
8113ca50:	00004c06 	br	8113cb84 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113ca54:	d0a09c03 	ldbu	r2,-32144(gp)
8113ca58:	10803fcc 	andi	r2,r2,255
8113ca5c:	10000526 	beq	r2,zero,8113ca74 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113ca60:	e0bfff17 	ldw	r2,-4(fp)
8113ca64:	00ffe2c4 	movi	r3,-117
8113ca68:	10c00005 	stb	r3,0(r2)
        return (0);
8113ca6c:	0005883a 	mov	r2,zero
8113ca70:	00004406 	br	8113cb84 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
8113ca74:	113d5540 	call	8113d554 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113ca78:	e0bffe17 	ldw	r2,-8(fp)
8113ca7c:	10800c43 	ldbu	r2,49(r2)
8113ca80:	10803fcc 	andi	r2,r2,255
8113ca84:	10c00060 	cmpeqi	r3,r2,1
8113ca88:	1800121e 	bne	r3,zero,8113cad4 <OSTmrRemainGet+0xf4>
8113ca8c:	10c00088 	cmpgei	r3,r2,2
8113ca90:	1800021e 	bne	r3,zero,8113ca9c <OSTmrRemainGet+0xbc>
8113ca94:	10003026 	beq	r2,zero,8113cb58 <OSTmrRemainGet+0x178>
8113ca98:	00003506 	br	8113cb70 <OSTmrRemainGet+0x190>
8113ca9c:	10c000a0 	cmpeqi	r3,r2,2
8113caa0:	1800281e 	bne	r3,zero,8113cb44 <OSTmrRemainGet+0x164>
8113caa4:	108000e0 	cmpeqi	r2,r2,3
8113caa8:	10003126 	beq	r2,zero,8113cb70 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8113caac:	e0bffe17 	ldw	r2,-8(fp)
8113cab0:	10c00517 	ldw	r3,20(r2)
8113cab4:	d0a09e17 	ldw	r2,-32136(gp)
8113cab8:	1885c83a 	sub	r2,r3,r2
8113cabc:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8113cac0:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
8113cac4:	e0bfff17 	ldw	r2,-4(fp)
8113cac8:	10000005 	stb	zero,0(r2)
             return (remain);
8113cacc:	e0bffd17 	ldw	r2,-12(fp)
8113cad0:	00002c06 	br	8113cb84 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
8113cad4:	e0bffe17 	ldw	r2,-8(fp)
8113cad8:	10800c03 	ldbu	r2,48(r2)
8113cadc:	10803fcc 	andi	r2,r2,255
8113cae0:	108000a0 	cmpeqi	r2,r2,2
8113cae4:	10000e26 	beq	r2,zero,8113cb20 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8113cae8:	e0bffe17 	ldw	r2,-8(fp)
8113caec:	10800617 	ldw	r2,24(r2)
8113caf0:	1000041e 	bne	r2,zero,8113cb04 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
8113caf4:	e0bffe17 	ldw	r2,-8(fp)
8113caf8:	10800717 	ldw	r2,28(r2)
8113cafc:	e0bffd15 	stw	r2,-12(fp)
8113cb00:	00000306 	br	8113cb10 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
8113cb04:	e0bffe17 	ldw	r2,-8(fp)
8113cb08:	10800617 	ldw	r2,24(r2)
8113cb0c:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8113cb10:	113d5980 	call	8113d598 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113cb14:	e0bfff17 	ldw	r2,-4(fp)
8113cb18:	10000005 	stb	zero,0(r2)
                      break;
8113cb1c:	00000706 	br	8113cb3c <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8113cb20:	e0bffe17 	ldw	r2,-8(fp)
8113cb24:	10800617 	ldw	r2,24(r2)
8113cb28:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8113cb2c:	113d5980 	call	8113d598 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113cb30:	e0bfff17 	ldw	r2,-4(fp)
8113cb34:	10000005 	stb	zero,0(r2)
                      break;
8113cb38:	0001883a 	nop
             }
             return (remain);
8113cb3c:	e0bffd17 	ldw	r2,-12(fp)
8113cb40:	00001006 	br	8113cb84 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
8113cb44:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113cb48:	e0bfff17 	ldw	r2,-4(fp)
8113cb4c:	10000005 	stb	zero,0(r2)
             return (0);
8113cb50:	0005883a 	mov	r2,zero
8113cb54:	00000b06 	br	8113cb84 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8113cb58:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113cb5c:	e0bfff17 	ldw	r2,-4(fp)
8113cb60:	00ffe1c4 	movi	r3,-121
8113cb64:	10c00005 	stb	r3,0(r2)
             return (0);
8113cb68:	0005883a 	mov	r2,zero
8113cb6c:	00000506 	br	8113cb84 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8113cb70:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113cb74:	e0bfff17 	ldw	r2,-4(fp)
8113cb78:	00ffe344 	movi	r3,-115
8113cb7c:	10c00005 	stb	r3,0(r2)
             return (0);
8113cb80:	0005883a 	mov	r2,zero
    }
}
8113cb84:	e037883a 	mov	sp,fp
8113cb88:	dfc00117 	ldw	ra,4(sp)
8113cb8c:	df000017 	ldw	fp,0(sp)
8113cb90:	dec00204 	addi	sp,sp,8
8113cb94:	f800283a 	ret

8113cb98 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8113cb98:	defffb04 	addi	sp,sp,-20
8113cb9c:	de00012e 	bgeu	sp,et,8113cba4 <OSTmrStateGet+0xc>
8113cba0:	003b68fa 	trap	3
8113cba4:	dfc00415 	stw	ra,16(sp)
8113cba8:	df000315 	stw	fp,12(sp)
8113cbac:	df000304 	addi	fp,sp,12
8113cbb0:	e13ffe15 	stw	r4,-8(fp)
8113cbb4:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113cbb8:	e0bfff17 	ldw	r2,-4(fp)
8113cbbc:	1000021e 	bne	r2,zero,8113cbc8 <OSTmrStateGet+0x30>
        return (0);
8113cbc0:	0005883a 	mov	r2,zero
8113cbc4:	00002a06 	br	8113cc70 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8113cbc8:	e0bffe17 	ldw	r2,-8(fp)
8113cbcc:	1000051e 	bne	r2,zero,8113cbe4 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113cbd0:	e0bfff17 	ldw	r2,-4(fp)
8113cbd4:	00ffe284 	movi	r3,-118
8113cbd8:	10c00005 	stb	r3,0(r2)
        return (0);
8113cbdc:	0005883a 	mov	r2,zero
8113cbe0:	00002306 	br	8113cc70 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113cbe4:	e0bffe17 	ldw	r2,-8(fp)
8113cbe8:	10800003 	ldbu	r2,0(r2)
8113cbec:	10803fcc 	andi	r2,r2,255
8113cbf0:	10801920 	cmpeqi	r2,r2,100
8113cbf4:	1000051e 	bne	r2,zero,8113cc0c <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113cbf8:	e0bfff17 	ldw	r2,-4(fp)
8113cbfc:	00ffe244 	movi	r3,-119
8113cc00:	10c00005 	stb	r3,0(r2)
        return (0);
8113cc04:	0005883a 	mov	r2,zero
8113cc08:	00001906 	br	8113cc70 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113cc0c:	d0a09c03 	ldbu	r2,-32144(gp)
8113cc10:	10803fcc 	andi	r2,r2,255
8113cc14:	10000526 	beq	r2,zero,8113cc2c <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113cc18:	e0bfff17 	ldw	r2,-4(fp)
8113cc1c:	00ffe2c4 	movi	r3,-117
8113cc20:	10c00005 	stb	r3,0(r2)
        return (0);
8113cc24:	0005883a 	mov	r2,zero
8113cc28:	00001106 	br	8113cc70 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8113cc2c:	113d5540 	call	8113d554 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8113cc30:	e0bffe17 	ldw	r2,-8(fp)
8113cc34:	10800c43 	ldbu	r2,49(r2)
8113cc38:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8113cc3c:	e0bffd03 	ldbu	r2,-12(fp)
8113cc40:	1005883a 	mov	r2,r2
8113cc44:	10800128 	cmpgeui	r2,r2,4
8113cc48:	1000031e 	bne	r2,zero,8113cc58 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8113cc4c:	e0bfff17 	ldw	r2,-4(fp)
8113cc50:	10000005 	stb	zero,0(r2)
             break;
8113cc54:	00000406 	br	8113cc68 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8113cc58:	e0bfff17 	ldw	r2,-4(fp)
8113cc5c:	00ffe344 	movi	r3,-115
8113cc60:	10c00005 	stb	r3,0(r2)
             break;
8113cc64:	0001883a 	nop
    }
    OSTmr_Unlock();
8113cc68:	113d5980 	call	8113d598 <OSTmr_Unlock>
    return (state);
8113cc6c:	e0bffd03 	ldbu	r2,-12(fp)
}
8113cc70:	e037883a 	mov	sp,fp
8113cc74:	dfc00117 	ldw	ra,4(sp)
8113cc78:	df000017 	ldw	fp,0(sp)
8113cc7c:	dec00204 	addi	sp,sp,8
8113cc80:	f800283a 	ret

8113cc84 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8113cc84:	defffc04 	addi	sp,sp,-16
8113cc88:	de00012e 	bgeu	sp,et,8113cc90 <OSTmrStart+0xc>
8113cc8c:	003b68fa 	trap	3
8113cc90:	dfc00315 	stw	ra,12(sp)
8113cc94:	df000215 	stw	fp,8(sp)
8113cc98:	df000204 	addi	fp,sp,8
8113cc9c:	e13ffe15 	stw	r4,-8(fp)
8113cca0:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113cca4:	e0bfff17 	ldw	r2,-4(fp)
8113cca8:	1000021e 	bne	r2,zero,8113ccb4 <OSTmrStart+0x30>
        return (OS_FALSE);
8113ccac:	0005883a 	mov	r2,zero
8113ccb0:	00004106 	br	8113cdb8 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8113ccb4:	e0bffe17 	ldw	r2,-8(fp)
8113ccb8:	1000051e 	bne	r2,zero,8113ccd0 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113ccbc:	e0bfff17 	ldw	r2,-4(fp)
8113ccc0:	00ffe284 	movi	r3,-118
8113ccc4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113ccc8:	0005883a 	mov	r2,zero
8113cccc:	00003a06 	br	8113cdb8 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113ccd0:	e0bffe17 	ldw	r2,-8(fp)
8113ccd4:	10800003 	ldbu	r2,0(r2)
8113ccd8:	10803fcc 	andi	r2,r2,255
8113ccdc:	10801920 	cmpeqi	r2,r2,100
8113cce0:	1000051e 	bne	r2,zero,8113ccf8 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113cce4:	e0bfff17 	ldw	r2,-4(fp)
8113cce8:	00ffe244 	movi	r3,-119
8113ccec:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113ccf0:	0005883a 	mov	r2,zero
8113ccf4:	00003006 	br	8113cdb8 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113ccf8:	d0a09c03 	ldbu	r2,-32144(gp)
8113ccfc:	10803fcc 	andi	r2,r2,255
8113cd00:	10000526 	beq	r2,zero,8113cd18 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113cd04:	e0bfff17 	ldw	r2,-4(fp)
8113cd08:	00ffe2c4 	movi	r3,-117
8113cd0c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113cd10:	0005883a 	mov	r2,zero
8113cd14:	00002806 	br	8113cdb8 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8113cd18:	113d5540 	call	8113d554 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113cd1c:	e0bffe17 	ldw	r2,-8(fp)
8113cd20:	10800c43 	ldbu	r2,49(r2)
8113cd24:	10803fcc 	andi	r2,r2,255
8113cd28:	10c000c8 	cmpgei	r3,r2,3
8113cd2c:	1800031e 	bne	r3,zero,8113cd3c <OSTmrStart+0xb8>
8113cd30:	00800e16 	blt	zero,r2,8113cd6c <OSTmrStart+0xe8>
8113cd34:	10001526 	beq	r2,zero,8113cd8c <OSTmrStart+0x108>
8113cd38:	00001a06 	br	8113cda4 <OSTmrStart+0x120>
8113cd3c:	108000e0 	cmpeqi	r2,r2,3
8113cd40:	10001826 	beq	r2,zero,8113cda4 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8113cd44:	e13ffe17 	ldw	r4,-8(fp)
8113cd48:	113d4580 	call	8113d458 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113cd4c:	000b883a 	mov	r5,zero
8113cd50:	e13ffe17 	ldw	r4,-8(fp)
8113cd54:	113d3080 	call	8113d308 <OSTmr_Link>
             OSTmr_Unlock();
8113cd58:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113cd5c:	e0bfff17 	ldw	r2,-4(fp)
8113cd60:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113cd64:	00800044 	movi	r2,1
8113cd68:	00001306 	br	8113cdb8 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113cd6c:	000b883a 	mov	r5,zero
8113cd70:	e13ffe17 	ldw	r4,-8(fp)
8113cd74:	113d3080 	call	8113d308 <OSTmr_Link>
             OSTmr_Unlock();
8113cd78:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113cd7c:	e0bfff17 	ldw	r2,-4(fp)
8113cd80:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113cd84:	00800044 	movi	r2,1
8113cd88:	00000b06 	br	8113cdb8 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8113cd8c:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113cd90:	e0bfff17 	ldw	r2,-4(fp)
8113cd94:	00ffe1c4 	movi	r3,-121
8113cd98:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113cd9c:	0005883a 	mov	r2,zero
8113cda0:	00000506 	br	8113cdb8 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8113cda4:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113cda8:	e0bfff17 	ldw	r2,-4(fp)
8113cdac:	00ffe344 	movi	r3,-115
8113cdb0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113cdb4:	0005883a 	mov	r2,zero
    }
}
8113cdb8:	e037883a 	mov	sp,fp
8113cdbc:	dfc00117 	ldw	ra,4(sp)
8113cdc0:	df000017 	ldw	fp,0(sp)
8113cdc4:	dec00204 	addi	sp,sp,8
8113cdc8:	f800283a 	ret

8113cdcc <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113cdcc:	defff904 	addi	sp,sp,-28
8113cdd0:	de00012e 	bgeu	sp,et,8113cdd8 <OSTmrStop+0xc>
8113cdd4:	003b68fa 	trap	3
8113cdd8:	dfc00615 	stw	ra,24(sp)
8113cddc:	df000515 	stw	fp,20(sp)
8113cde0:	df000504 	addi	fp,sp,20
8113cde4:	e13ffc15 	stw	r4,-16(fp)
8113cde8:	2805883a 	mov	r2,r5
8113cdec:	e1bffe15 	stw	r6,-8(fp)
8113cdf0:	e1ffff15 	stw	r7,-4(fp)
8113cdf4:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8113cdf8:	e0bfff17 	ldw	r2,-4(fp)
8113cdfc:	1000021e 	bne	r2,zero,8113ce08 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113ce00:	0005883a 	mov	r2,zero
8113ce04:	00006606 	br	8113cfa0 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8113ce08:	e0bffc17 	ldw	r2,-16(fp)
8113ce0c:	1000051e 	bne	r2,zero,8113ce24 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113ce10:	e0bfff17 	ldw	r2,-4(fp)
8113ce14:	00ffe284 	movi	r3,-118
8113ce18:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113ce1c:	0005883a 	mov	r2,zero
8113ce20:	00005f06 	br	8113cfa0 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8113ce24:	e0bffc17 	ldw	r2,-16(fp)
8113ce28:	10800003 	ldbu	r2,0(r2)
8113ce2c:	10803fcc 	andi	r2,r2,255
8113ce30:	10801920 	cmpeqi	r2,r2,100
8113ce34:	1000051e 	bne	r2,zero,8113ce4c <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113ce38:	e0bfff17 	ldw	r2,-4(fp)
8113ce3c:	00ffe244 	movi	r3,-119
8113ce40:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113ce44:	0005883a 	mov	r2,zero
8113ce48:	00005506 	br	8113cfa0 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8113ce4c:	d0a09c03 	ldbu	r2,-32144(gp)
8113ce50:	10803fcc 	andi	r2,r2,255
8113ce54:	10000526 	beq	r2,zero,8113ce6c <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113ce58:	e0bfff17 	ldw	r2,-4(fp)
8113ce5c:	00ffe2c4 	movi	r3,-117
8113ce60:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113ce64:	0005883a 	mov	r2,zero
8113ce68:	00004d06 	br	8113cfa0 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8113ce6c:	113d5540 	call	8113d554 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113ce70:	e0bffc17 	ldw	r2,-16(fp)
8113ce74:	10800c43 	ldbu	r2,49(r2)
8113ce78:	10803fcc 	andi	r2,r2,255
8113ce7c:	10c000c8 	cmpgei	r3,r2,3
8113ce80:	1800031e 	bne	r3,zero,8113ce90 <OSTmrStop+0xc4>
8113ce84:	00803516 	blt	zero,r2,8113cf5c <OSTmrStop+0x190>
8113ce88:	10003a26 	beq	r2,zero,8113cf74 <OSTmrStop+0x1a8>
8113ce8c:	00003f06 	br	8113cf8c <OSTmrStop+0x1c0>
8113ce90:	108000e0 	cmpeqi	r2,r2,3
8113ce94:	10003d26 	beq	r2,zero,8113cf8c <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113ce98:	e13ffc17 	ldw	r4,-16(fp)
8113ce9c:	113d4580 	call	8113d458 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8113cea0:	e0bfff17 	ldw	r2,-4(fp)
8113cea4:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113cea8:	e0bffd03 	ldbu	r2,-12(fp)
8113ceac:	10c000e0 	cmpeqi	r3,r2,3
8113ceb0:	1800041e 	bne	r3,zero,8113cec4 <OSTmrStop+0xf8>
8113ceb4:	10c00120 	cmpeqi	r3,r2,4
8113ceb8:	1800121e 	bne	r3,zero,8113cf04 <OSTmrStop+0x138>
8113cebc:	10002326 	beq	r2,zero,8113cf4c <OSTmrStop+0x180>
8113cec0:	00001e06 	br	8113cf3c <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113cec4:	e0bffc17 	ldw	r2,-16(fp)
8113cec8:	10800117 	ldw	r2,4(r2)
8113cecc:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113ced0:	e0bffb17 	ldw	r2,-20(fp)
8113ced4:	10000726 	beq	r2,zero,8113cef4 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113ced8:	e0bffc17 	ldw	r2,-16(fp)
8113cedc:	10c00217 	ldw	r3,8(r2)
8113cee0:	e0bffb17 	ldw	r2,-20(fp)
8113cee4:	180b883a 	mov	r5,r3
8113cee8:	e13ffc17 	ldw	r4,-16(fp)
8113ceec:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113cef0:	00001706 	br	8113cf50 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113cef4:	e0bfff17 	ldw	r2,-4(fp)
8113cef8:	00ffe3c4 	movi	r3,-113
8113cefc:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113cf00:	00001306 	br	8113cf50 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113cf04:	e0bffc17 	ldw	r2,-16(fp)
8113cf08:	10800117 	ldw	r2,4(r2)
8113cf0c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113cf10:	e0bffb17 	ldw	r2,-20(fp)
8113cf14:	10000526 	beq	r2,zero,8113cf2c <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8113cf18:	e0bffb17 	ldw	r2,-20(fp)
8113cf1c:	e17ffe17 	ldw	r5,-8(fp)
8113cf20:	e13ffc17 	ldw	r4,-16(fp)
8113cf24:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113cf28:	00000906 	br	8113cf50 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113cf2c:	e0bfff17 	ldw	r2,-4(fp)
8113cf30:	00ffe3c4 	movi	r3,-113
8113cf34:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113cf38:	00000506 	br	8113cf50 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8113cf3c:	e0bfff17 	ldw	r2,-4(fp)
8113cf40:	00ffe104 	movi	r3,-124
8113cf44:	10c00005 	stb	r3,0(r2)
                     break;
8113cf48:	00000106 	br	8113cf50 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8113cf4c:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113cf50:	113d5980 	call	8113d598 <OSTmr_Unlock>
             return (OS_TRUE);
8113cf54:	00800044 	movi	r2,1
8113cf58:	00001106 	br	8113cfa0 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8113cf5c:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8113cf60:	e0bfff17 	ldw	r2,-4(fp)
8113cf64:	00ffe384 	movi	r3,-114
8113cf68:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8113cf6c:	00800044 	movi	r2,1
8113cf70:	00000b06 	br	8113cfa0 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8113cf74:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113cf78:	e0bfff17 	ldw	r2,-4(fp)
8113cf7c:	00ffe1c4 	movi	r3,-121
8113cf80:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113cf84:	0005883a 	mov	r2,zero
8113cf88:	00000506 	br	8113cfa0 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8113cf8c:	113d5980 	call	8113d598 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113cf90:	e0bfff17 	ldw	r2,-4(fp)
8113cf94:	00ffe344 	movi	r3,-115
8113cf98:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113cf9c:	0005883a 	mov	r2,zero
    }
}
8113cfa0:	e037883a 	mov	sp,fp
8113cfa4:	dfc00117 	ldw	ra,4(sp)
8113cfa8:	df000017 	ldw	fp,0(sp)
8113cfac:	dec00204 	addi	sp,sp,8
8113cfb0:	f800283a 	ret

8113cfb4 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8113cfb4:	defffd04 	addi	sp,sp,-12
8113cfb8:	de00012e 	bgeu	sp,et,8113cfc0 <OSTmrSignal+0xc>
8113cfbc:	003b68fa 	trap	3
8113cfc0:	dfc00215 	stw	ra,8(sp)
8113cfc4:	df000115 	stw	fp,4(sp)
8113cfc8:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113cfcc:	d0a08b17 	ldw	r2,-32212(gp)
8113cfd0:	1009883a 	mov	r4,r2
8113cfd4:	113a5800 	call	8113a580 <OSSemPost>
8113cfd8:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113cfdc:	e0bfff03 	ldbu	r2,-4(fp)
}
8113cfe0:	e037883a 	mov	sp,fp
8113cfe4:	dfc00117 	ldw	ra,4(sp)
8113cfe8:	df000017 	ldw	fp,0(sp)
8113cfec:	dec00204 	addi	sp,sp,8
8113cff0:	f800283a 	ret

8113cff4 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8113cff4:	defffe04 	addi	sp,sp,-8
8113cff8:	de00012e 	bgeu	sp,et,8113d000 <OSTmr_Alloc+0xc>
8113cffc:	003b68fa 	trap	3
8113d000:	df000115 	stw	fp,4(sp)
8113d004:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8113d008:	d0a08917 	ldw	r2,-32220(gp)
8113d00c:	1000021e 	bne	r2,zero,8113d018 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113d010:	0005883a 	mov	r2,zero
8113d014:	00001006 	br	8113d058 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8113d018:	d0a08917 	ldw	r2,-32220(gp)
8113d01c:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113d020:	e0bfff17 	ldw	r2,-4(fp)
8113d024:	10800317 	ldw	r2,12(r2)
8113d028:	d0a08915 	stw	r2,-32220(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113d02c:	e0bfff17 	ldw	r2,-4(fp)
8113d030:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8113d034:	e0bfff17 	ldw	r2,-4(fp)
8113d038:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8113d03c:	d0a08e0b 	ldhu	r2,-32200(gp)
8113d040:	10800044 	addi	r2,r2,1
8113d044:	d0a08e0d 	sth	r2,-32200(gp)
    OSTmrFree--;
8113d048:	d0a0920b 	ldhu	r2,-32184(gp)
8113d04c:	10bfffc4 	addi	r2,r2,-1
8113d050:	d0a0920d 	sth	r2,-32184(gp)
    return (ptmr);
8113d054:	e0bfff17 	ldw	r2,-4(fp)
}
8113d058:	e037883a 	mov	sp,fp
8113d05c:	df000017 	ldw	fp,0(sp)
8113d060:	dec00104 	addi	sp,sp,4
8113d064:	f800283a 	ret

8113d068 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113d068:	defffe04 	addi	sp,sp,-8
8113d06c:	de00012e 	bgeu	sp,et,8113d074 <OSTmr_Free+0xc>
8113d070:	003b68fa 	trap	3
8113d074:	df000115 	stw	fp,4(sp)
8113d078:	df000104 	addi	fp,sp,4
8113d07c:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8113d080:	e0bfff17 	ldw	r2,-4(fp)
8113d084:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113d088:	e0bfff17 	ldw	r2,-4(fp)
8113d08c:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8113d090:	e0bfff17 	ldw	r2,-4(fp)
8113d094:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113d098:	e0bfff17 	ldw	r2,-4(fp)
8113d09c:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8113d0a0:	e0bfff17 	ldw	r2,-4(fp)
8113d0a4:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113d0a8:	e0bfff17 	ldw	r2,-4(fp)
8113d0ac:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8113d0b0:	e0bfff17 	ldw	r2,-4(fp)
8113d0b4:	00c00fc4 	movi	r3,63
8113d0b8:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113d0bc:	e0bfff17 	ldw	r2,-4(fp)
8113d0c0:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8113d0c4:	e0bfff17 	ldw	r2,-4(fp)
8113d0c8:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113d0cc:	d0e08917 	ldw	r3,-32220(gp)
8113d0d0:	e0bfff17 	ldw	r2,-4(fp)
8113d0d4:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113d0d8:	e0bfff17 	ldw	r2,-4(fp)
8113d0dc:	d0a08915 	stw	r2,-32220(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8113d0e0:	d0a08e0b 	ldhu	r2,-32200(gp)
8113d0e4:	10bfffc4 	addi	r2,r2,-1
8113d0e8:	d0a08e0d 	sth	r2,-32200(gp)
    OSTmrFree++;
8113d0ec:	d0a0920b 	ldhu	r2,-32184(gp)
8113d0f0:	10800044 	addi	r2,r2,1
8113d0f4:	d0a0920d 	sth	r2,-32184(gp)
}
8113d0f8:	0001883a 	nop
8113d0fc:	e037883a 	mov	sp,fp
8113d100:	df000017 	ldw	fp,0(sp)
8113d104:	dec00104 	addi	sp,sp,4
8113d108:	f800283a 	ret

8113d10c <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113d10c:	defffa04 	addi	sp,sp,-24
8113d110:	de00012e 	bgeu	sp,et,8113d118 <OSTmr_Init+0xc>
8113d114:	003b68fa 	trap	3
8113d118:	dfc00515 	stw	ra,20(sp)
8113d11c:	df000415 	stw	fp,16(sp)
8113d120:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8113d124:	01406804 	movi	r5,416
8113d128:	012045b4 	movhi	r4,33046
8113d12c:	21082b04 	addi	r4,r4,8364
8113d130:	113527c0 	call	8113527c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8113d134:	01400404 	movi	r5,16
8113d138:	012045b4 	movhi	r4,33046
8113d13c:	21061704 	addi	r4,r4,6236
8113d140:	113527c0 	call	8113527c <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8113d144:	00a045b4 	movhi	r2,33046
8113d148:	10882b04 	addi	r2,r2,8364
8113d14c:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8113d150:	00a045b4 	movhi	r2,33046
8113d154:	10883804 	addi	r2,r2,8416
8113d158:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113d15c:	e03ffc0d 	sth	zero,-16(fp)
8113d160:	00001606 	br	8113d1bc <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8113d164:	e0bffd17 	ldw	r2,-12(fp)
8113d168:	00c01904 	movi	r3,100
8113d16c:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8113d170:	e0bffd17 	ldw	r2,-12(fp)
8113d174:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113d178:	e0bffd17 	ldw	r2,-12(fp)
8113d17c:	e0fffe17 	ldw	r3,-8(fp)
8113d180:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8113d184:	e0bffd17 	ldw	r2,-12(fp)
8113d188:	00c00fc4 	movi	r3,63
8113d18c:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113d190:	e0bffd17 	ldw	r2,-12(fp)
8113d194:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113d198:	e0bffd17 	ldw	r2,-12(fp)
8113d19c:	10800d04 	addi	r2,r2,52
8113d1a0:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8113d1a4:	e0bffe17 	ldw	r2,-8(fp)
8113d1a8:	10800d04 	addi	r2,r2,52
8113d1ac:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113d1b0:	e0bffc0b 	ldhu	r2,-16(fp)
8113d1b4:	10800044 	addi	r2,r2,1
8113d1b8:	e0bffc0d 	sth	r2,-16(fp)
8113d1bc:	e0bffc0b 	ldhu	r2,-16(fp)
8113d1c0:	108001f0 	cmpltui	r2,r2,7
8113d1c4:	103fe71e 	bne	r2,zero,8113d164 <__reset+0xfb11d164>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113d1c8:	e0bffd17 	ldw	r2,-12(fp)
8113d1cc:	00c01904 	movi	r3,100
8113d1d0:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8113d1d4:	e0bffd17 	ldw	r2,-12(fp)
8113d1d8:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8113d1dc:	e0bffd17 	ldw	r2,-12(fp)
8113d1e0:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8113d1e4:	e0bffd17 	ldw	r2,-12(fp)
8113d1e8:	00c00fc4 	movi	r3,63
8113d1ec:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113d1f0:	e0bffd17 	ldw	r2,-12(fp)
8113d1f4:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8113d1f8:	d0209e15 	stw	zero,-32136(gp)
    OSTmrUsed           = 0;
8113d1fc:	d0208e0d 	sth	zero,-32200(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8113d200:	00800204 	movi	r2,8
8113d204:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8113d208:	00a045b4 	movhi	r2,33046
8113d20c:	10882b04 	addi	r2,r2,8364
8113d210:	d0a08915 	stw	r2,-32220(gp)
    OSTmrSem            = OSSemCreate(1);
8113d214:	01000044 	movi	r4,1
8113d218:	1139ed00 	call	81139ed0 <OSSemCreate>
8113d21c:	d0a0a015 	stw	r2,-32128(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8113d220:	0009883a 	mov	r4,zero
8113d224:	1139ed00 	call	81139ed0 <OSSemCreate>
8113d228:	d0a08b15 	stw	r2,-32212(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8113d22c:	d0a0a017 	ldw	r2,-32128(gp)
8113d230:	e0ffff04 	addi	r3,fp,-4
8113d234:	180d883a 	mov	r6,r3
8113d238:	01604574 	movhi	r5,33045
8113d23c:	296fa904 	addi	r5,r5,-16732
8113d240:	1009883a 	mov	r4,r2
8113d244:	1133ad80 	call	81133ad8 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8113d248:	d0a08b17 	ldw	r2,-32212(gp)
8113d24c:	e0ffff04 	addi	r3,fp,-4
8113d250:	180d883a 	mov	r6,r3
8113d254:	01604574 	movhi	r5,33045
8113d258:	296fae04 	addi	r5,r5,-16712
8113d25c:	1009883a 	mov	r4,r2
8113d260:	1133ad80 	call	81133ad8 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8113d264:	113d2800 	call	8113d280 <OSTmr_InitTask>
}
8113d268:	0001883a 	nop
8113d26c:	e037883a 	mov	sp,fp
8113d270:	dfc00117 	ldw	ra,4(sp)
8113d274:	df000017 	ldw	fp,0(sp)
8113d278:	dec00204 	addi	sp,sp,8
8113d27c:	f800283a 	ret

8113d280 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8113d280:	defff804 	addi	sp,sp,-32
8113d284:	de00012e 	bgeu	sp,et,8113d28c <OSTmr_InitTask+0xc>
8113d288:	003b68fa 	trap	3
8113d28c:	dfc00715 	stw	ra,28(sp)
8113d290:	df000615 	stw	fp,24(sp)
8113d294:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113d298:	008000c4 	movi	r2,3
8113d29c:	d8800415 	stw	r2,16(sp)
8113d2a0:	d8000315 	stw	zero,12(sp)
8113d2a4:	00808004 	movi	r2,512
8113d2a8:	d8800215 	stw	r2,8(sp)
8113d2ac:	00a045b4 	movhi	r2,33046
8113d2b0:	10905f04 	addi	r2,r2,16764
8113d2b4:	d8800115 	stw	r2,4(sp)
8113d2b8:	00bfff54 	movui	r2,65533
8113d2bc:	d8800015 	stw	r2,0(sp)
8113d2c0:	01c00744 	movi	r7,29
8113d2c4:	01a045b4 	movhi	r6,33046
8113d2c8:	31925e04 	addi	r6,r6,18808
8113d2cc:	000b883a 	mov	r5,zero
8113d2d0:	01204534 	movhi	r4,33044
8113d2d4:	21357504 	addi	r4,r4,-10796
8113d2d8:	113af640 	call	8113af64 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8113d2dc:	e1bfff04 	addi	r6,fp,-4
8113d2e0:	01604574 	movhi	r5,33045
8113d2e4:	296fb304 	addi	r5,r5,-16692
8113d2e8:	01000744 	movi	r4,29
8113d2ec:	113b7940 	call	8113b794 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8113d2f0:	0001883a 	nop
8113d2f4:	e037883a 	mov	sp,fp
8113d2f8:	dfc00117 	ldw	ra,4(sp)
8113d2fc:	df000017 	ldw	fp,0(sp)
8113d300:	dec00204 	addi	sp,sp,8
8113d304:	f800283a 	ret

8113d308 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8113d308:	defffa04 	addi	sp,sp,-24
8113d30c:	de00012e 	bgeu	sp,et,8113d314 <OSTmr_Link+0xc>
8113d310:	003b68fa 	trap	3
8113d314:	df000515 	stw	fp,20(sp)
8113d318:	df000504 	addi	fp,sp,20
8113d31c:	e13ffe15 	stw	r4,-8(fp)
8113d320:	2805883a 	mov	r2,r5
8113d324:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8113d328:	e0bffe17 	ldw	r2,-8(fp)
8113d32c:	00c000c4 	movi	r3,3
8113d330:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8113d334:	e0bfff03 	ldbu	r2,-4(fp)
8113d338:	10800058 	cmpnei	r2,r2,1
8113d33c:	1000071e 	bne	r2,zero,8113d35c <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113d340:	e0bffe17 	ldw	r2,-8(fp)
8113d344:	10c00717 	ldw	r3,28(r2)
8113d348:	d0a09e17 	ldw	r2,-32136(gp)
8113d34c:	1887883a 	add	r3,r3,r2
8113d350:	e0bffe17 	ldw	r2,-8(fp)
8113d354:	10c00515 	stw	r3,20(r2)
8113d358:	00001006 	br	8113d39c <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8113d35c:	e0bffe17 	ldw	r2,-8(fp)
8113d360:	10800617 	ldw	r2,24(r2)
8113d364:	1000071e 	bne	r2,zero,8113d384 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113d368:	e0bffe17 	ldw	r2,-8(fp)
8113d36c:	10c00717 	ldw	r3,28(r2)
8113d370:	d0a09e17 	ldw	r2,-32136(gp)
8113d374:	1887883a 	add	r3,r3,r2
8113d378:	e0bffe17 	ldw	r2,-8(fp)
8113d37c:	10c00515 	stw	r3,20(r2)
8113d380:	00000606 	br	8113d39c <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8113d384:	e0bffe17 	ldw	r2,-8(fp)
8113d388:	10c00617 	ldw	r3,24(r2)
8113d38c:	d0a09e17 	ldw	r2,-32136(gp)
8113d390:	1887883a 	add	r3,r3,r2
8113d394:	e0bffe17 	ldw	r2,-8(fp)
8113d398:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113d39c:	e0bffe17 	ldw	r2,-8(fp)
8113d3a0:	10800517 	ldw	r2,20(r2)
8113d3a4:	1080004c 	andi	r2,r2,1
8113d3a8:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113d3ac:	e0bffb0b 	ldhu	r2,-20(fp)
8113d3b0:	100690fa 	slli	r3,r2,3
8113d3b4:	00a045b4 	movhi	r2,33046
8113d3b8:	10861704 	addi	r2,r2,6236
8113d3bc:	1885883a 	add	r2,r3,r2
8113d3c0:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8113d3c4:	e0bffc17 	ldw	r2,-16(fp)
8113d3c8:	10800017 	ldw	r2,0(r2)
8113d3cc:	1000091e 	bne	r2,zero,8113d3f4 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8113d3d0:	e0bffc17 	ldw	r2,-16(fp)
8113d3d4:	e0fffe17 	ldw	r3,-8(fp)
8113d3d8:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8113d3dc:	e0bffe17 	ldw	r2,-8(fp)
8113d3e0:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8113d3e4:	e0bffc17 	ldw	r2,-16(fp)
8113d3e8:	00c00044 	movi	r3,1
8113d3ec:	10c0010d 	sth	r3,4(r2)
8113d3f0:	00001206 	br	8113d43c <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8113d3f4:	e0bffc17 	ldw	r2,-16(fp)
8113d3f8:	10800017 	ldw	r2,0(r2)
8113d3fc:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8113d400:	e0bffc17 	ldw	r2,-16(fp)
8113d404:	e0fffe17 	ldw	r3,-8(fp)
8113d408:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8113d40c:	e0bffe17 	ldw	r2,-8(fp)
8113d410:	e0fffd17 	ldw	r3,-12(fp)
8113d414:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8113d418:	e0bffd17 	ldw	r2,-12(fp)
8113d41c:	e0fffe17 	ldw	r3,-8(fp)
8113d420:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8113d424:	e0bffc17 	ldw	r2,-16(fp)
8113d428:	1080010b 	ldhu	r2,4(r2)
8113d42c:	10800044 	addi	r2,r2,1
8113d430:	1007883a 	mov	r3,r2
8113d434:	e0bffc17 	ldw	r2,-16(fp)
8113d438:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8113d43c:	e0bffe17 	ldw	r2,-8(fp)
8113d440:	10000415 	stw	zero,16(r2)
}
8113d444:	0001883a 	nop
8113d448:	e037883a 	mov	sp,fp
8113d44c:	df000017 	ldw	fp,0(sp)
8113d450:	dec00104 	addi	sp,sp,4
8113d454:	f800283a 	ret

8113d458 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113d458:	defffa04 	addi	sp,sp,-24
8113d45c:	de00012e 	bgeu	sp,et,8113d464 <OSTmr_Unlink+0xc>
8113d460:	003b68fa 	trap	3
8113d464:	df000515 	stw	fp,20(sp)
8113d468:	df000504 	addi	fp,sp,20
8113d46c:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113d470:	e0bfff17 	ldw	r2,-4(fp)
8113d474:	10800517 	ldw	r2,20(r2)
8113d478:	1080004c 	andi	r2,r2,1
8113d47c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113d480:	e0bffb0b 	ldhu	r2,-20(fp)
8113d484:	100690fa 	slli	r3,r2,3
8113d488:	00a045b4 	movhi	r2,33046
8113d48c:	10861704 	addi	r2,r2,6236
8113d490:	1885883a 	add	r2,r3,r2
8113d494:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113d498:	e0bffc17 	ldw	r2,-16(fp)
8113d49c:	10c00017 	ldw	r3,0(r2)
8113d4a0:	e0bfff17 	ldw	r2,-4(fp)
8113d4a4:	18800b1e 	bne	r3,r2,8113d4d4 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113d4a8:	e0bfff17 	ldw	r2,-4(fp)
8113d4ac:	10800317 	ldw	r2,12(r2)
8113d4b0:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8113d4b4:	e0bffc17 	ldw	r2,-16(fp)
8113d4b8:	e0fffd17 	ldw	r3,-12(fp)
8113d4bc:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8113d4c0:	e0bffd17 	ldw	r2,-12(fp)
8113d4c4:	10001126 	beq	r2,zero,8113d50c <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113d4c8:	e0bffd17 	ldw	r2,-12(fp)
8113d4cc:	10000415 	stw	zero,16(r2)
8113d4d0:	00000e06 	br	8113d50c <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8113d4d4:	e0bfff17 	ldw	r2,-4(fp)
8113d4d8:	10800417 	ldw	r2,16(r2)
8113d4dc:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8113d4e0:	e0bfff17 	ldw	r2,-4(fp)
8113d4e4:	10800317 	ldw	r2,12(r2)
8113d4e8:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8113d4ec:	e0bffd17 	ldw	r2,-12(fp)
8113d4f0:	e0fffe17 	ldw	r3,-8(fp)
8113d4f4:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8113d4f8:	e0bffe17 	ldw	r2,-8(fp)
8113d4fc:	10000326 	beq	r2,zero,8113d50c <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8113d500:	e0bffe17 	ldw	r2,-8(fp)
8113d504:	e0fffd17 	ldw	r3,-12(fp)
8113d508:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8113d50c:	e0bfff17 	ldw	r2,-4(fp)
8113d510:	00c00044 	movi	r3,1
8113d514:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8113d518:	e0bfff17 	ldw	r2,-4(fp)
8113d51c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8113d520:	e0bfff17 	ldw	r2,-4(fp)
8113d524:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8113d528:	e0bffc17 	ldw	r2,-16(fp)
8113d52c:	1080010b 	ldhu	r2,4(r2)
8113d530:	10bfffc4 	addi	r2,r2,-1
8113d534:	1007883a 	mov	r3,r2
8113d538:	e0bffc17 	ldw	r2,-16(fp)
8113d53c:	10c0010d 	sth	r3,4(r2)
}
8113d540:	0001883a 	nop
8113d544:	e037883a 	mov	sp,fp
8113d548:	df000017 	ldw	fp,0(sp)
8113d54c:	dec00104 	addi	sp,sp,4
8113d550:	f800283a 	ret

8113d554 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8113d554:	defffd04 	addi	sp,sp,-12
8113d558:	de00012e 	bgeu	sp,et,8113d560 <OSTmr_Lock+0xc>
8113d55c:	003b68fa 	trap	3
8113d560:	dfc00215 	stw	ra,8(sp)
8113d564:	df000115 	stw	fp,4(sp)
8113d568:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8113d56c:	d0a0a017 	ldw	r2,-32128(gp)
8113d570:	e1bfff04 	addi	r6,fp,-4
8113d574:	000b883a 	mov	r5,zero
8113d578:	1009883a 	mov	r4,r2
8113d57c:	113a1f80 	call	8113a1f8 <OSSemPend>
    (void)err;
}
8113d580:	0001883a 	nop
8113d584:	e037883a 	mov	sp,fp
8113d588:	dfc00117 	ldw	ra,4(sp)
8113d58c:	df000017 	ldw	fp,0(sp)
8113d590:	dec00204 	addi	sp,sp,8
8113d594:	f800283a 	ret

8113d598 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113d598:	defffe04 	addi	sp,sp,-8
8113d59c:	de00012e 	bgeu	sp,et,8113d5a4 <OSTmr_Unlock+0xc>
8113d5a0:	003b68fa 	trap	3
8113d5a4:	dfc00115 	stw	ra,4(sp)
8113d5a8:	df000015 	stw	fp,0(sp)
8113d5ac:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8113d5b0:	d0a0a017 	ldw	r2,-32128(gp)
8113d5b4:	1009883a 	mov	r4,r2
8113d5b8:	113a5800 	call	8113a580 <OSSemPost>
}
8113d5bc:	0001883a 	nop
8113d5c0:	e037883a 	mov	sp,fp
8113d5c4:	dfc00117 	ldw	ra,4(sp)
8113d5c8:	df000017 	ldw	fp,0(sp)
8113d5cc:	dec00204 	addi	sp,sp,8
8113d5d0:	f800283a 	ret

8113d5d4 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8113d5d4:	defff704 	addi	sp,sp,-36
8113d5d8:	de00012e 	bgeu	sp,et,8113d5e0 <OSTmr_Task+0xc>
8113d5dc:	003b68fa 	trap	3
8113d5e0:	dfc00815 	stw	ra,32(sp)
8113d5e4:	df000715 	stw	fp,28(sp)
8113d5e8:	df000704 	addi	fp,sp,28
8113d5ec:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8113d5f0:	d0a08b17 	ldw	r2,-32212(gp)
8113d5f4:	e0fffe04 	addi	r3,fp,-8
8113d5f8:	180d883a 	mov	r6,r3
8113d5fc:	000b883a 	mov	r5,zero
8113d600:	1009883a 	mov	r4,r2
8113d604:	113a1f80 	call	8113a1f8 <OSSemPend>
        OSTmr_Lock();
8113d608:	113d5540 	call	8113d554 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8113d60c:	d0a09e17 	ldw	r2,-32136(gp)
8113d610:	10800044 	addi	r2,r2,1
8113d614:	d0a09e15 	stw	r2,-32136(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8113d618:	d0a09e17 	ldw	r2,-32136(gp)
8113d61c:	1080004c 	andi	r2,r2,1
8113d620:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8113d624:	e0bffa0b 	ldhu	r2,-24(fp)
8113d628:	100690fa 	slli	r3,r2,3
8113d62c:	00a045b4 	movhi	r2,33046
8113d630:	10861704 	addi	r2,r2,6236
8113d634:	1885883a 	add	r2,r3,r2
8113d638:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8113d63c:	e0bffb17 	ldw	r2,-20(fp)
8113d640:	10800017 	ldw	r2,0(r2)
8113d644:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8113d648:	00002206 	br	8113d6d4 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8113d64c:	e0bff917 	ldw	r2,-28(fp)
8113d650:	10800317 	ldw	r2,12(r2)
8113d654:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8113d658:	e0bff917 	ldw	r2,-28(fp)
8113d65c:	10c00517 	ldw	r3,20(r2)
8113d660:	d0a09e17 	ldw	r2,-32136(gp)
8113d664:	1880191e 	bne	r3,r2,8113d6cc <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8113d668:	e0bff917 	ldw	r2,-28(fp)
8113d66c:	10800117 	ldw	r2,4(r2)
8113d670:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8113d674:	e0bffd17 	ldw	r2,-12(fp)
8113d678:	10000626 	beq	r2,zero,8113d694 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8113d67c:	e0bff917 	ldw	r2,-28(fp)
8113d680:	10c00217 	ldw	r3,8(r2)
8113d684:	e0bffd17 	ldw	r2,-12(fp)
8113d688:	180b883a 	mov	r5,r3
8113d68c:	e13ff917 	ldw	r4,-28(fp)
8113d690:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8113d694:	e13ff917 	ldw	r4,-28(fp)
8113d698:	113d4580 	call	8113d458 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8113d69c:	e0bff917 	ldw	r2,-28(fp)
8113d6a0:	10800c03 	ldbu	r2,48(r2)
8113d6a4:	10803fcc 	andi	r2,r2,255
8113d6a8:	10800098 	cmpnei	r2,r2,2
8113d6ac:	1000041e 	bne	r2,zero,8113d6c0 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8113d6b0:	01400044 	movi	r5,1
8113d6b4:	e13ff917 	ldw	r4,-28(fp)
8113d6b8:	113d3080 	call	8113d308 <OSTmr_Link>
8113d6bc:	00000306 	br	8113d6cc <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113d6c0:	e0bff917 	ldw	r2,-28(fp)
8113d6c4:	00c00084 	movi	r3,2
8113d6c8:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8113d6cc:	e0bffc17 	ldw	r2,-16(fp)
8113d6d0:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8113d6d4:	e0bff917 	ldw	r2,-28(fp)
8113d6d8:	103fdc1e 	bne	r2,zero,8113d64c <__reset+0xfb11d64c>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8113d6dc:	113d5980 	call	8113d598 <OSTmr_Unlock>
    }
8113d6e0:	003fc306 	br	8113d5f0 <__reset+0xfb11d5f0>

8113d6e4 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
8113d6e4:	defffd04 	addi	sp,sp,-12
8113d6e8:	de00012e 	bgeu	sp,et,8113d6f0 <alt_dev_reg+0xc>
8113d6ec:	003b68fa 	trap	3
8113d6f0:	dfc00215 	stw	ra,8(sp)
8113d6f4:	df000115 	stw	fp,4(sp)
8113d6f8:	df000104 	addi	fp,sp,4
8113d6fc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8113d700:	d1600d04 	addi	r5,gp,-32716
8113d704:	e13fff17 	ldw	r4,-4(fp)
8113d708:	11459840 	call	81145984 <alt_dev_llist_insert>
}
8113d70c:	e037883a 	mov	sp,fp
8113d710:	dfc00117 	ldw	ra,4(sp)
8113d714:	df000017 	ldw	fp,0(sp)
8113d718:	dec00204 	addi	sp,sp,8
8113d71c:	f800283a 	ret

8113d720 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8113d720:	defffd04 	addi	sp,sp,-12
8113d724:	de00012e 	bgeu	sp,et,8113d72c <alt_irq_init+0xc>
8113d728:	003b68fa 	trap	3
8113d72c:	dfc00215 	stw	ra,8(sp)
8113d730:	df000115 	stw	fp,4(sp)
8113d734:	df000104 	addi	fp,sp,4
8113d738:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8113d73c:	114634c0 	call	8114634c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8113d740:	00800044 	movi	r2,1
8113d744:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8113d748:	0001883a 	nop
8113d74c:	e037883a 	mov	sp,fp
8113d750:	dfc00117 	ldw	ra,4(sp)
8113d754:	df000017 	ldw	fp,0(sp)
8113d758:	dec00204 	addi	sp,sp,8
8113d75c:	f800283a 	ret

8113d760 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8113d760:	defffe04 	addi	sp,sp,-8
8113d764:	de00012e 	bgeu	sp,et,8113d76c <alt_sys_init+0xc>
8113d768:	003b68fa 	trap	3
8113d76c:	dfc00115 	stw	ra,4(sp)
8113d770:	df000015 	stw	fp,0(sp)
8113d774:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8113d778:	01c0fa04 	movi	r7,1000
8113d77c:	01800304 	movi	r6,12
8113d780:	000b883a 	mov	r5,zero
8113d784:	01200034 	movhi	r4,32768
8113d788:	21022004 	addi	r4,r4,2176
8113d78c:	1142ab80 	call	81142ab8 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8113d790:	018002c4 	movi	r6,11
8113d794:	000b883a 	mov	r5,zero
8113d798:	01204574 	movhi	r4,33045
8113d79c:	21334f04 	addi	r4,r4,-12996
8113d7a0:	1141da40 	call	81141da4 <altera_avalon_jtag_uart_init>
8113d7a4:	01204574 	movhi	r4,33045
8113d7a8:	21334504 	addi	r4,r4,-13036
8113d7ac:	113d6e40 	call	8113d6e4 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8113d7b0:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
8113d7b4:	018003c4 	movi	r6,15
8113d7b8:	000b883a 	mov	r5,zero
8113d7bc:	01204574 	movhi	r4,33045
8113d7c0:	21376a04 	addi	r4,r4,-8792
8113d7c4:	1142c640 	call	81142c64 <altera_avalon_uart_init>
8113d7c8:	01204574 	movhi	r4,33045
8113d7cc:	21376004 	addi	r4,r4,-8832
8113d7d0:	113d6e40 	call	8113d6e4 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
8113d7d4:	00a04574 	movhi	r2,33045
8113d7d8:	10b79404 	addi	r2,r2,-8624
8113d7dc:	10c00717 	ldw	r3,28(r2)
8113d7e0:	00a04574 	movhi	r2,33045
8113d7e4:	10b79404 	addi	r2,r2,-8624
8113d7e8:	10800817 	ldw	r2,32(r2)
8113d7ec:	100d883a 	mov	r6,r2
8113d7f0:	180b883a 	mov	r5,r3
8113d7f4:	01204574 	movhi	r4,33045
8113d7f8:	21379404 	addi	r4,r4,-8624
8113d7fc:	11454ec0 	call	811454ec <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8113d800:	00a04574 	movhi	r2,33045
8113d804:	10b7ad04 	addi	r2,r2,-8524
8113d808:	10c00717 	ldw	r3,28(r2)
8113d80c:	00a04574 	movhi	r2,33045
8113d810:	10b7ad04 	addi	r2,r2,-8524
8113d814:	10800817 	ldw	r2,32(r2)
8113d818:	100d883a 	mov	r6,r2
8113d81c:	180b883a 	mov	r5,r3
8113d820:	01204574 	movhi	r4,33045
8113d824:	2137ad04 	addi	r4,r4,-8524
8113d828:	11454ec0 	call	811454ec <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8113d82c:	01204574 	movhi	r4,33045
8113d830:	2137c604 	addi	r4,r4,-8424
8113d834:	113d6e40 	call	8113d6e4 <alt_dev_reg>
}
8113d838:	0001883a 	nop
8113d83c:	e037883a 	mov	sp,fp
8113d840:	dfc00117 	ldw	ra,4(sp)
8113d844:	df000017 	ldw	fp,0(sp)
8113d848:	dec00204 	addi	sp,sp,8
8113d84c:	f800283a 	ret

8113d850 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8113d850:	defffa04 	addi	sp,sp,-24
8113d854:	de00012e 	bgeu	sp,et,8113d85c <Write_Sector_Data+0xc>
8113d858:	003b68fa 	trap	3
8113d85c:	dfc00515 	stw	ra,20(sp)
8113d860:	df000415 	stw	fp,16(sp)
8113d864:	df000404 	addi	fp,sp,16
8113d868:	e13ffe15 	stw	r4,-8(fp)
8113d86c:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113d870:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
8113d874:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
8113d878:	10001e26 	beq	r2,zero,8113d8f4 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8113d87c:	00803fc4 	movi	r2,255
8113d880:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113d884:	d0a0aa17 	ldw	r2,-32088(gp)
8113d888:	e13ffe17 	ldw	r4,-8(fp)
8113d88c:	e0ffff17 	ldw	r3,-4(fp)
8113d890:	20c7883a 	add	r3,r4,r3
8113d894:	1806927a 	slli	r3,r3,9
8113d898:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8113d89c:	d0a0a917 	ldw	r2,-32092(gp)
8113d8a0:	00c00604 	movi	r3,24
8113d8a4:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113d8a8:	d0a0a617 	ldw	r2,-32104(gp)
8113d8ac:	1080002b 	ldhuio	r2,0(r2)
8113d8b0:	10bfffcc 	andi	r2,r2,65535
8113d8b4:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8113d8b8:	e0bffd0b 	ldhu	r2,-12(fp)
8113d8bc:	10bfffcc 	andi	r2,r2,65535
8113d8c0:	1080010c 	andi	r2,r2,4
8113d8c4:	103ff81e 	bne	r2,zero,8113d8a8 <__reset+0xfb11d8a8>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8113d8c8:	e0bffd0b 	ldhu	r2,-12(fp)
8113d8cc:	10bfffcc 	andi	r2,r2,65535
8113d8d0:	1080040c 	andi	r2,r2,16
8113d8d4:	1000071e 	bne	r2,zero,8113d8f4 <Write_Sector_Data+0xa4>
        {
            result = true;
8113d8d8:	00800044 	movi	r2,1
8113d8dc:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113d8e0:	d020af15 	stw	zero,-32068(gp)
            current_sector_index = sector_index+partition_offset;
8113d8e4:	e0fffe17 	ldw	r3,-8(fp)
8113d8e8:	e0bfff17 	ldw	r2,-4(fp)
8113d8ec:	1885883a 	add	r2,r3,r2
8113d8f0:	d0a0b015 	stw	r2,-32064(gp)
        }
    }
    return result;
8113d8f4:	e0bffc17 	ldw	r2,-16(fp)
}
8113d8f8:	e037883a 	mov	sp,fp
8113d8fc:	dfc00117 	ldw	ra,4(sp)
8113d900:	df000017 	ldw	fp,0(sp)
8113d904:	dec00204 	addi	sp,sp,8
8113d908:	f800283a 	ret

8113d90c <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8113d90c:	defffd04 	addi	sp,sp,-12
8113d910:	de00012e 	bgeu	sp,et,8113d918 <Save_Modified_Sector+0xc>
8113d914:	003b68fa 	trap	3
8113d918:	dfc00215 	stw	ra,8(sp)
8113d91c:	df000115 	stw	fp,4(sp)
8113d920:	df000104 	addi	fp,sp,4
    bool result = true;
8113d924:	00800044 	movi	r2,1
8113d928:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8113d92c:	d0a0af17 	ldw	r2,-32068(gp)
8113d930:	10000526 	beq	r2,zero,8113d948 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
8113d934:	d0a0b017 	ldw	r2,-32064(gp)
8113d938:	000b883a 	mov	r5,zero
8113d93c:	1009883a 	mov	r4,r2
8113d940:	113d8500 	call	8113d850 <Write_Sector_Data>
8113d944:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8113d948:	e0bfff17 	ldw	r2,-4(fp)
}
8113d94c:	e037883a 	mov	sp,fp
8113d950:	dfc00117 	ldw	ra,4(sp)
8113d954:	df000017 	ldw	fp,0(sp)
8113d958:	dec00204 	addi	sp,sp,8
8113d95c:	f800283a 	ret

8113d960 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8113d960:	defffa04 	addi	sp,sp,-24
8113d964:	de00012e 	bgeu	sp,et,8113d96c <Read_Sector_Data+0xc>
8113d968:	003b68fa 	trap	3
8113d96c:	dfc00515 	stw	ra,20(sp)
8113d970:	df000415 	stw	fp,16(sp)
8113d974:	df000404 	addi	fp,sp,16
8113d978:	e13ffe15 	stw	r4,-8(fp)
8113d97c:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8113d980:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
8113d984:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
8113d988:	10002726 	beq	r2,zero,8113da28 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
8113d98c:	00803fc4 	movi	r2,255
8113d990:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
8113d994:	d0a0af17 	ldw	r2,-32068(gp)
8113d998:	10000726 	beq	r2,zero,8113d9b8 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8113d99c:	d0a0b017 	ldw	r2,-32064(gp)
8113d9a0:	000b883a 	mov	r5,zero
8113d9a4:	1009883a 	mov	r4,r2
8113d9a8:	113d8500 	call	8113d850 <Write_Sector_Data>
8113d9ac:	1000021e 	bne	r2,zero,8113d9b8 <Read_Sector_Data+0x58>
            {
                return false;
8113d9b0:	0005883a 	mov	r2,zero
8113d9b4:	00001d06 	br	8113da2c <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113d9b8:	d0a0aa17 	ldw	r2,-32088(gp)
8113d9bc:	e13ffe17 	ldw	r4,-8(fp)
8113d9c0:	e0ffff17 	ldw	r3,-4(fp)
8113d9c4:	20c7883a 	add	r3,r4,r3
8113d9c8:	1806927a 	slli	r3,r3,9
8113d9cc:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8113d9d0:	d0a0a917 	ldw	r2,-32092(gp)
8113d9d4:	00c00444 	movi	r3,17
8113d9d8:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113d9dc:	d0a0a617 	ldw	r2,-32104(gp)
8113d9e0:	1080002b 	ldhuio	r2,0(r2)
8113d9e4:	10bfffcc 	andi	r2,r2,65535
8113d9e8:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8113d9ec:	e0bffd0b 	ldhu	r2,-12(fp)
8113d9f0:	10bfffcc 	andi	r2,r2,65535
8113d9f4:	1080010c 	andi	r2,r2,4
8113d9f8:	103ff81e 	bne	r2,zero,8113d9dc <__reset+0xfb11d9dc>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8113d9fc:	e0bffd0b 	ldhu	r2,-12(fp)
8113da00:	10bfffcc 	andi	r2,r2,65535
8113da04:	1080040c 	andi	r2,r2,16
8113da08:	1000071e 	bne	r2,zero,8113da28 <Read_Sector_Data+0xc8>
		{
			result = true;
8113da0c:	00800044 	movi	r2,1
8113da10:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113da14:	d020af15 	stw	zero,-32068(gp)
            current_sector_index = sector_index+partition_offset;
8113da18:	e0fffe17 	ldw	r3,-8(fp)
8113da1c:	e0bfff17 	ldw	r2,-4(fp)
8113da20:	1885883a 	add	r2,r3,r2
8113da24:	d0a0b015 	stw	r2,-32064(gp)
		}
	}
	return result;
8113da28:	e0bffc17 	ldw	r2,-16(fp)
}
8113da2c:	e037883a 	mov	sp,fp
8113da30:	dfc00117 	ldw	ra,4(sp)
8113da34:	df000017 	ldw	fp,0(sp)
8113da38:	dec00204 	addi	sp,sp,8
8113da3c:	f800283a 	ret

8113da40 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8113da40:	defffb04 	addi	sp,sp,-20
8113da44:	de00012e 	bgeu	sp,et,8113da4c <get_cluster_flag+0xc>
8113da48:	003b68fa 	trap	3
8113da4c:	dfc00415 	stw	ra,16(sp)
8113da50:	df000315 	stw	fp,12(sp)
8113da54:	df000304 	addi	fp,sp,12
8113da58:	e13ffe15 	stw	r4,-8(fp)
8113da5c:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8113da60:	e0bffe17 	ldw	r2,-8(fp)
8113da64:	1004d23a 	srli	r2,r2,8
8113da68:	d0e0ac17 	ldw	r3,-32080(gp)
8113da6c:	10c5883a 	add	r2,r2,r3
8113da70:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113da74:	00a045b4 	movhi	r2,33046
8113da78:	109e3d04 	addi	r2,r2,30964
8113da7c:	10801117 	ldw	r2,68(r2)
8113da80:	e0fffd17 	ldw	r3,-12(fp)
8113da84:	1885883a 	add	r2,r3,r2
8113da88:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
8113da8c:	d0a0b017 	ldw	r2,-32064(gp)
8113da90:	e0fffd17 	ldw	r3,-12(fp)
8113da94:	18800726 	beq	r3,r2,8113dab4 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113da98:	e0bffd17 	ldw	r2,-12(fp)
8113da9c:	000b883a 	mov	r5,zero
8113daa0:	1009883a 	mov	r4,r2
8113daa4:	113d9600 	call	8113d960 <Read_Sector_Data>
8113daa8:	1000021e 	bne	r2,zero,8113dab4 <get_cluster_flag+0x74>
        {
            return false;
8113daac:	0005883a 	mov	r2,zero
8113dab0:	00000d06 	br	8113dae8 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
8113dab4:	e0bffe17 	ldw	r2,-8(fp)
8113dab8:	10803fcc 	andi	r2,r2,255
8113dabc:	1085883a 	add	r2,r2,r2
8113dac0:	1007883a 	mov	r3,r2
8113dac4:	d0a0ae17 	ldw	r2,-32072(gp)
8113dac8:	10800a17 	ldw	r2,40(r2)
8113dacc:	1885883a 	add	r2,r3,r2
8113dad0:	1080002b 	ldhuio	r2,0(r2)
8113dad4:	10bfffcc 	andi	r2,r2,65535
8113dad8:	1007883a 	mov	r3,r2
8113dadc:	e0bfff17 	ldw	r2,-4(fp)
8113dae0:	10c0000d 	sth	r3,0(r2)
    return true;
8113dae4:	00800044 	movi	r2,1
}
8113dae8:	e037883a 	mov	sp,fp
8113daec:	dfc00117 	ldw	ra,4(sp)
8113daf0:	df000017 	ldw	fp,0(sp)
8113daf4:	dec00204 	addi	sp,sp,8
8113daf8:	f800283a 	ret

8113dafc <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8113dafc:	defffa04 	addi	sp,sp,-24
8113db00:	de00012e 	bgeu	sp,et,8113db08 <mark_cluster+0xc>
8113db04:	003b68fa 	trap	3
8113db08:	dfc00515 	stw	ra,20(sp)
8113db0c:	df000415 	stw	fp,16(sp)
8113db10:	df000404 	addi	fp,sp,16
8113db14:	e13ffd15 	stw	r4,-12(fp)
8113db18:	2805883a 	mov	r2,r5
8113db1c:	e1bfff15 	stw	r6,-4(fp)
8113db20:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
8113db24:	e0bffd17 	ldw	r2,-12(fp)
8113db28:	1004d23a 	srli	r2,r2,8
8113db2c:	d0e0ac17 	ldw	r3,-32080(gp)
8113db30:	10c5883a 	add	r2,r2,r3
8113db34:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8113db38:	e0bfff17 	ldw	r2,-4(fp)
8113db3c:	10000726 	beq	r2,zero,8113db5c <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113db40:	00a045b4 	movhi	r2,33046
8113db44:	109e3d04 	addi	r2,r2,30964
8113db48:	10801117 	ldw	r2,68(r2)
8113db4c:	e0fffc17 	ldw	r3,-16(fp)
8113db50:	1885883a 	add	r2,r3,r2
8113db54:	e0bffc15 	stw	r2,-16(fp)
8113db58:	00000606 	br	8113db74 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8113db5c:	00a045b4 	movhi	r2,33046
8113db60:	109e3d04 	addi	r2,r2,30964
8113db64:	10801217 	ldw	r2,72(r2)
8113db68:	e0fffc17 	ldw	r3,-16(fp)
8113db6c:	1885883a 	add	r2,r3,r2
8113db70:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
8113db74:	d0a0b017 	ldw	r2,-32064(gp)
8113db78:	e0fffc17 	ldw	r3,-16(fp)
8113db7c:	18800726 	beq	r3,r2,8113db9c <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113db80:	e0bffc17 	ldw	r2,-16(fp)
8113db84:	000b883a 	mov	r5,zero
8113db88:	1009883a 	mov	r4,r2
8113db8c:	113d9600 	call	8113d960 <Read_Sector_Data>
8113db90:	1000021e 	bne	r2,zero,8113db9c <mark_cluster+0xa0>
        {
            return false;
8113db94:	0005883a 	mov	r2,zero
8113db98:	00000d06 	br	8113dbd0 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8113db9c:	e0bffd17 	ldw	r2,-12(fp)
8113dba0:	10803fcc 	andi	r2,r2,255
8113dba4:	1085883a 	add	r2,r2,r2
8113dba8:	1007883a 	mov	r3,r2
8113dbac:	d0a0ae17 	ldw	r2,-32072(gp)
8113dbb0:	10800a17 	ldw	r2,40(r2)
8113dbb4:	1885883a 	add	r2,r3,r2
8113dbb8:	1007883a 	mov	r3,r2
8113dbbc:	e0bffe0f 	ldh	r2,-8(fp)
8113dbc0:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
8113dbc4:	00800044 	movi	r2,1
8113dbc8:	d0a0af15 	stw	r2,-32068(gp)
    return true;
8113dbcc:	00800044 	movi	r2,1
}
8113dbd0:	e037883a 	mov	sp,fp
8113dbd4:	dfc00117 	ldw	ra,4(sp)
8113dbd8:	df000017 	ldw	fp,0(sp)
8113dbdc:	dec00204 	addi	sp,sp,8
8113dbe0:	f800283a 	ret

8113dbe4 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
8113dbe4:	defff704 	addi	sp,sp,-36
8113dbe8:	de00012e 	bgeu	sp,et,8113dbf0 <Check_for_Master_Boot_Record+0xc>
8113dbec:	003b68fa 	trap	3
8113dbf0:	dfc00815 	stw	ra,32(sp)
8113dbf4:	df000715 	stw	fp,28(sp)
8113dbf8:	df000704 	addi	fp,sp,28
	bool result = false;
8113dbfc:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8113dc00:	000b883a 	mov	r5,zero
8113dc04:	0009883a 	mov	r4,zero
8113dc08:	113d9600 	call	8113d960 <Read_Sector_Data>
8113dc0c:	10005a26 	beq	r2,zero,8113dd78 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8113dc10:	d0a0ae17 	ldw	r2,-32072(gp)
8113dc14:	10800a17 	ldw	r2,40(r2)
8113dc18:	10807f84 	addi	r2,r2,510
8113dc1c:	1080002b 	ldhuio	r2,0(r2)
8113dc20:	10bfffcc 	andi	r2,r2,65535
8113dc24:	10bfffcc 	andi	r2,r2,65535
8113dc28:	10a0001c 	xori	r2,r2,32768
8113dc2c:	10a00004 	addi	r2,r2,-32768
8113dc30:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
8113dc34:	e0bffb17 	ldw	r2,-20(fp)
8113dc38:	10ffffcc 	andi	r3,r2,65535
8113dc3c:	00aa9554 	movui	r2,43605
8113dc40:	18804d1e 	bne	r3,r2,8113dd78 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113dc44:	e03ffa15 	stw	zero,-24(fp)
8113dc48:	00004806 	br	8113dd6c <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8113dc4c:	e0bffa17 	ldw	r2,-24(fp)
8113dc50:	1004913a 	slli	r2,r2,4
8113dc54:	10806f84 	addi	r2,r2,446
8113dc58:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8113dc5c:	d0a0ae17 	ldw	r2,-32072(gp)
8113dc60:	10c00a17 	ldw	r3,40(r2)
8113dc64:	e0bffc17 	ldw	r2,-16(fp)
8113dc68:	1885883a 	add	r2,r3,r2
8113dc6c:	10800104 	addi	r2,r2,4
8113dc70:	10800023 	ldbuio	r2,0(r2)
8113dc74:	10803fcc 	andi	r2,r2,255
8113dc78:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8113dc7c:	e0bffd07 	ldb	r2,-12(fp)
8113dc80:	10800060 	cmpeqi	r2,r2,1
8113dc84:	1000091e 	bne	r2,zero,8113dcac <Check_for_Master_Boot_Record+0xc8>
8113dc88:	e0bffd07 	ldb	r2,-12(fp)
8113dc8c:	10800120 	cmpeqi	r2,r2,4
8113dc90:	1000061e 	bne	r2,zero,8113dcac <Check_for_Master_Boot_Record+0xc8>
8113dc94:	e0bffd07 	ldb	r2,-12(fp)
8113dc98:	108001a0 	cmpeqi	r2,r2,6
8113dc9c:	1000031e 	bne	r2,zero,8113dcac <Check_for_Master_Boot_Record+0xc8>
8113dca0:	e0bffd07 	ldb	r2,-12(fp)
8113dca4:	10800398 	cmpnei	r2,r2,14
8113dca8:	10002d1e 	bne	r2,zero,8113dd60 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8113dcac:	d0a0ae17 	ldw	r2,-32072(gp)
8113dcb0:	10c00a17 	ldw	r3,40(r2)
8113dcb4:	e0bffc17 	ldw	r2,-16(fp)
8113dcb8:	1885883a 	add	r2,r3,r2
8113dcbc:	10800284 	addi	r2,r2,10
8113dcc0:	1080002b 	ldhuio	r2,0(r2)
8113dcc4:	10bfffcc 	andi	r2,r2,65535
8113dcc8:	1006943a 	slli	r3,r2,16
8113dccc:	d0a0ae17 	ldw	r2,-32072(gp)
8113dcd0:	11000a17 	ldw	r4,40(r2)
8113dcd4:	e0bffc17 	ldw	r2,-16(fp)
8113dcd8:	2085883a 	add	r2,r4,r2
8113dcdc:	10800204 	addi	r2,r2,8
8113dce0:	1080002b 	ldhuio	r2,0(r2)
8113dce4:	10bfffcc 	andi	r2,r2,65535
8113dce8:	10bfffcc 	andi	r2,r2,65535
8113dcec:	1884b03a 	or	r2,r3,r2
8113dcf0:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
8113dcf4:	d0a0ae17 	ldw	r2,-32072(gp)
8113dcf8:	10c00a17 	ldw	r3,40(r2)
8113dcfc:	e0bffc17 	ldw	r2,-16(fp)
8113dd00:	1885883a 	add	r2,r3,r2
8113dd04:	10800384 	addi	r2,r2,14
8113dd08:	1080002b 	ldhuio	r2,0(r2)
8113dd0c:	10bfffcc 	andi	r2,r2,65535
8113dd10:	1006943a 	slli	r3,r2,16
8113dd14:	d0a0ae17 	ldw	r2,-32072(gp)
8113dd18:	11000a17 	ldw	r4,40(r2)
8113dd1c:	e0bffc17 	ldw	r2,-16(fp)
8113dd20:	2085883a 	add	r2,r4,r2
8113dd24:	10800304 	addi	r2,r2,12
8113dd28:	1080002b 	ldhuio	r2,0(r2)
8113dd2c:	10bfffcc 	andi	r2,r2,65535
8113dd30:	10bfffcc 	andi	r2,r2,65535
8113dd34:	1884b03a 	or	r2,r3,r2
8113dd38:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8113dd3c:	e0bfff17 	ldw	r2,-4(fp)
8113dd40:	0080070e 	bge	zero,r2,8113dd60 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8113dd44:	00800044 	movi	r2,1
8113dd48:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8113dd4c:	e0bfff17 	ldw	r2,-4(fp)
8113dd50:	d0a0ad15 	stw	r2,-32076(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8113dd54:	e0bffe17 	ldw	r2,-8(fp)
8113dd58:	d0a0ac15 	stw	r2,-32080(gp)
						break;
8113dd5c:	00000606 	br	8113dd78 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113dd60:	e0bffa17 	ldw	r2,-24(fp)
8113dd64:	10800044 	addi	r2,r2,1
8113dd68:	e0bffa15 	stw	r2,-24(fp)
8113dd6c:	e0bffa17 	ldw	r2,-24(fp)
8113dd70:	10800110 	cmplti	r2,r2,4
8113dd74:	103fb51e 	bne	r2,zero,8113dc4c <__reset+0xfb11dc4c>
				}
			}
		}
	}

	return result;
8113dd78:	e0bff917 	ldw	r2,-28(fp)
}
8113dd7c:	e037883a 	mov	sp,fp
8113dd80:	dfc00117 	ldw	ra,4(sp)
8113dd84:	df000017 	ldw	fp,0(sp)
8113dd88:	dec00204 	addi	sp,sp,8
8113dd8c:	f800283a 	ret

8113dd90 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8113dd90:	defff804 	addi	sp,sp,-32
8113dd94:	de00012e 	bgeu	sp,et,8113dd9c <Read_File_Record_At_Offset+0xc>
8113dd98:	003b68fa 	trap	3
8113dd9c:	dfc00715 	stw	ra,28(sp)
8113dda0:	df000615 	stw	fp,24(sp)
8113dda4:	df000604 	addi	fp,sp,24
8113dda8:	e13ffc15 	stw	r4,-16(fp)
8113ddac:	e17ffd15 	stw	r5,-12(fp)
8113ddb0:	e1bffe15 	stw	r6,-8(fp)
8113ddb4:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8113ddb8:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113ddbc:	e0bffc17 	ldw	r2,-16(fp)
8113ddc0:	108007cc 	andi	r2,r2,31
8113ddc4:	10008d1e 	bne	r2,zero,8113dffc <Read_File_Record_At_Offset+0x26c>
8113ddc8:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
8113ddcc:	10008b26 	beq	r2,zero,8113dffc <Read_File_Record_At_Offset+0x26c>
8113ddd0:	d0a0a517 	ldw	r2,-32108(gp)
8113ddd4:	10008926 	beq	r2,zero,8113dffc <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113ddd8:	e03ffb15 	stw	zero,-20(fp)
8113dddc:	00001106 	br	8113de24 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8113dde0:	e0fffc17 	ldw	r3,-16(fp)
8113dde4:	e0bffb17 	ldw	r2,-20(fp)
8113dde8:	1885883a 	add	r2,r3,r2
8113ddec:	1007883a 	mov	r3,r2
8113ddf0:	d0a0ae17 	ldw	r2,-32072(gp)
8113ddf4:	10800a17 	ldw	r2,40(r2)
8113ddf8:	1885883a 	add	r2,r3,r2
8113ddfc:	10800023 	ldbuio	r2,0(r2)
8113de00:	10803fcc 	andi	r2,r2,255
8113de04:	1009883a 	mov	r4,r2
8113de08:	e0fffd17 	ldw	r3,-12(fp)
8113de0c:	e0bffb17 	ldw	r2,-20(fp)
8113de10:	1885883a 	add	r2,r3,r2
8113de14:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113de18:	e0bffb17 	ldw	r2,-20(fp)
8113de1c:	10800044 	addi	r2,r2,1
8113de20:	e0bffb15 	stw	r2,-20(fp)
8113de24:	e0bffb17 	ldw	r2,-20(fp)
8113de28:	10800210 	cmplti	r2,r2,8
8113de2c:	103fec1e 	bne	r2,zero,8113dde0 <__reset+0xfb11dde0>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113de30:	e03ffb15 	stw	zero,-20(fp)
8113de34:	00001306 	br	8113de84 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8113de38:	e0fffc17 	ldw	r3,-16(fp)
8113de3c:	e0bffb17 	ldw	r2,-20(fp)
8113de40:	1885883a 	add	r2,r3,r2
8113de44:	1007883a 	mov	r3,r2
8113de48:	d0a0ae17 	ldw	r2,-32072(gp)
8113de4c:	10800a17 	ldw	r2,40(r2)
8113de50:	1885883a 	add	r2,r3,r2
8113de54:	10800204 	addi	r2,r2,8
8113de58:	10800023 	ldbuio	r2,0(r2)
8113de5c:	10803fcc 	andi	r2,r2,255
8113de60:	1009883a 	mov	r4,r2
8113de64:	e0fffd17 	ldw	r3,-12(fp)
8113de68:	e0bffb17 	ldw	r2,-20(fp)
8113de6c:	1885883a 	add	r2,r3,r2
8113de70:	10800204 	addi	r2,r2,8
8113de74:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113de78:	e0bffb17 	ldw	r2,-20(fp)
8113de7c:	10800044 	addi	r2,r2,1
8113de80:	e0bffb15 	stw	r2,-20(fp)
8113de84:	e0bffb17 	ldw	r2,-20(fp)
8113de88:	108000d0 	cmplti	r2,r2,3
8113de8c:	103fea1e 	bne	r2,zero,8113de38 <__reset+0xfb11de38>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8113de90:	d0a0ae17 	ldw	r2,-32072(gp)
8113de94:	10c00a17 	ldw	r3,40(r2)
8113de98:	e0bffc17 	ldw	r2,-16(fp)
8113de9c:	1885883a 	add	r2,r3,r2
8113dea0:	108002c4 	addi	r2,r2,11
8113dea4:	10800023 	ldbuio	r2,0(r2)
8113dea8:	10803fcc 	andi	r2,r2,255
8113deac:	1007883a 	mov	r3,r2
8113deb0:	e0bffd17 	ldw	r2,-12(fp)
8113deb4:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8113deb8:	d0a0ae17 	ldw	r2,-32072(gp)
8113debc:	10c00a17 	ldw	r3,40(r2)
8113dec0:	e0bffc17 	ldw	r2,-16(fp)
8113dec4:	1885883a 	add	r2,r3,r2
8113dec8:	10800384 	addi	r2,r2,14
8113decc:	1080002b 	ldhuio	r2,0(r2)
8113ded0:	10bfffcc 	andi	r2,r2,65535
8113ded4:	1007883a 	mov	r3,r2
8113ded8:	e0bffd17 	ldw	r2,-12(fp)
8113dedc:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8113dee0:	d0a0ae17 	ldw	r2,-32072(gp)
8113dee4:	10c00a17 	ldw	r3,40(r2)
8113dee8:	e0bffc17 	ldw	r2,-16(fp)
8113deec:	1885883a 	add	r2,r3,r2
8113def0:	10800404 	addi	r2,r2,16
8113def4:	1080002b 	ldhuio	r2,0(r2)
8113def8:	10bfffcc 	andi	r2,r2,65535
8113defc:	1007883a 	mov	r3,r2
8113df00:	e0bffd17 	ldw	r2,-12(fp)
8113df04:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8113df08:	d0a0ae17 	ldw	r2,-32072(gp)
8113df0c:	10c00a17 	ldw	r3,40(r2)
8113df10:	e0bffc17 	ldw	r2,-16(fp)
8113df14:	1885883a 	add	r2,r3,r2
8113df18:	10800484 	addi	r2,r2,18
8113df1c:	1080002b 	ldhuio	r2,0(r2)
8113df20:	10bfffcc 	andi	r2,r2,65535
8113df24:	1007883a 	mov	r3,r2
8113df28:	e0bffd17 	ldw	r2,-12(fp)
8113df2c:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8113df30:	d0a0ae17 	ldw	r2,-32072(gp)
8113df34:	10c00a17 	ldw	r3,40(r2)
8113df38:	e0bffc17 	ldw	r2,-16(fp)
8113df3c:	1885883a 	add	r2,r3,r2
8113df40:	10800584 	addi	r2,r2,22
8113df44:	1080002b 	ldhuio	r2,0(r2)
8113df48:	10bfffcc 	andi	r2,r2,65535
8113df4c:	1007883a 	mov	r3,r2
8113df50:	e0bffd17 	ldw	r2,-12(fp)
8113df54:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8113df58:	d0a0ae17 	ldw	r2,-32072(gp)
8113df5c:	10c00a17 	ldw	r3,40(r2)
8113df60:	e0bffc17 	ldw	r2,-16(fp)
8113df64:	1885883a 	add	r2,r3,r2
8113df68:	10800604 	addi	r2,r2,24
8113df6c:	1080002b 	ldhuio	r2,0(r2)
8113df70:	10bfffcc 	andi	r2,r2,65535
8113df74:	1007883a 	mov	r3,r2
8113df78:	e0bffd17 	ldw	r2,-12(fp)
8113df7c:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
8113df80:	d0a0ae17 	ldw	r2,-32072(gp)
8113df84:	10c00a17 	ldw	r3,40(r2)
8113df88:	e0bffc17 	ldw	r2,-16(fp)
8113df8c:	1885883a 	add	r2,r3,r2
8113df90:	10800684 	addi	r2,r2,26
8113df94:	1080002b 	ldhuio	r2,0(r2)
8113df98:	10bfffcc 	andi	r2,r2,65535
8113df9c:	1007883a 	mov	r3,r2
8113dfa0:	e0bffd17 	ldw	r2,-12(fp)
8113dfa4:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8113dfa8:	d0a0ae17 	ldw	r2,-32072(gp)
8113dfac:	10c00a17 	ldw	r3,40(r2)
8113dfb0:	e0bffc17 	ldw	r2,-16(fp)
8113dfb4:	1885883a 	add	r2,r3,r2
8113dfb8:	10800704 	addi	r2,r2,28
8113dfbc:	10800037 	ldwio	r2,0(r2)
8113dfc0:	1007883a 	mov	r3,r2
8113dfc4:	e0bffd17 	ldw	r2,-12(fp)
8113dfc8:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8113dfcc:	e0bffd17 	ldw	r2,-12(fp)
8113dfd0:	e0fffe17 	ldw	r3,-8(fp)
8113dfd4:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8113dfd8:	e0bffd17 	ldw	r2,-12(fp)
8113dfdc:	e0ffff17 	ldw	r3,-4(fp)
8113dfe0:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
8113dfe4:	e0bffc17 	ldw	r2,-16(fp)
8113dfe8:	1007883a 	mov	r3,r2
8113dfec:	e0bffd17 	ldw	r2,-12(fp)
8113dff0:	10c00c0d 	sth	r3,48(r2)
		result = true;
8113dff4:	00800044 	movi	r2,1
8113dff8:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8113dffc:	e0bffa17 	ldw	r2,-24(fp)
}
8113e000:	e037883a 	mov	sp,fp
8113e004:	dfc00117 	ldw	ra,4(sp)
8113e008:	df000017 	ldw	fp,0(sp)
8113e00c:	dec00204 	addi	sp,sp,8
8113e010:	f800283a 	ret

8113e014 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
8113e014:	defff904 	addi	sp,sp,-28
8113e018:	de00012e 	bgeu	sp,et,8113e020 <Write_File_Record_At_Offset+0xc>
8113e01c:	003b68fa 	trap	3
8113e020:	dfc00615 	stw	ra,24(sp)
8113e024:	df000515 	stw	fp,20(sp)
8113e028:	df000504 	addi	fp,sp,20
8113e02c:	e13ffe15 	stw	r4,-8(fp)
8113e030:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113e034:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113e038:	e0bffe17 	ldw	r2,-8(fp)
8113e03c:	108007cc 	andi	r2,r2,31
8113e040:	1000931e 	bne	r2,zero,8113e290 <Write_File_Record_At_Offset+0x27c>
8113e044:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
8113e048:	10009126 	beq	r2,zero,8113e290 <Write_File_Record_At_Offset+0x27c>
8113e04c:	d0a0a517 	ldw	r2,-32108(gp)
8113e050:	10008f26 	beq	r2,zero,8113e290 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113e054:	e03ffc15 	stw	zero,-16(fp)
8113e058:	00001f06 	br	8113e0d8 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8113e05c:	e0bffc17 	ldw	r2,-16(fp)
8113e060:	10800044 	addi	r2,r2,1
8113e064:	e0ffff17 	ldw	r3,-4(fp)
8113e068:	1885883a 	add	r2,r3,r2
8113e06c:	10800003 	ldbu	r2,0(r2)
8113e070:	10803fcc 	andi	r2,r2,255
8113e074:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8113e078:	e0bffd0f 	ldh	r2,-12(fp)
8113e07c:	1004923a 	slli	r2,r2,8
8113e080:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8113e084:	e0ffff17 	ldw	r3,-4(fp)
8113e088:	e0bffc17 	ldw	r2,-16(fp)
8113e08c:	1885883a 	add	r2,r3,r2
8113e090:	10800003 	ldbu	r2,0(r2)
8113e094:	10c03fcc 	andi	r3,r2,255
8113e098:	e0bffd0b 	ldhu	r2,-12(fp)
8113e09c:	1884b03a 	or	r2,r3,r2
8113e0a0:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8113e0a4:	e0fffe17 	ldw	r3,-8(fp)
8113e0a8:	e0bffc17 	ldw	r2,-16(fp)
8113e0ac:	1885883a 	add	r2,r3,r2
8113e0b0:	1007883a 	mov	r3,r2
8113e0b4:	d0a0ae17 	ldw	r2,-32072(gp)
8113e0b8:	10800a17 	ldw	r2,40(r2)
8113e0bc:	1885883a 	add	r2,r3,r2
8113e0c0:	1007883a 	mov	r3,r2
8113e0c4:	e0bffd0f 	ldh	r2,-12(fp)
8113e0c8:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113e0cc:	e0bffc17 	ldw	r2,-16(fp)
8113e0d0:	10800084 	addi	r2,r2,2
8113e0d4:	e0bffc15 	stw	r2,-16(fp)
8113e0d8:	e0bffc17 	ldw	r2,-16(fp)
8113e0dc:	10800210 	cmplti	r2,r2,8
8113e0e0:	103fde1e 	bne	r2,zero,8113e05c <__reset+0xfb11e05c>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113e0e4:	e03ffc15 	stw	zero,-16(fp)
8113e0e8:	00001306 	br	8113e138 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8113e0ec:	e0fffe17 	ldw	r3,-8(fp)
8113e0f0:	e0bffc17 	ldw	r2,-16(fp)
8113e0f4:	1885883a 	add	r2,r3,r2
8113e0f8:	1007883a 	mov	r3,r2
8113e0fc:	d0a0ae17 	ldw	r2,-32072(gp)
8113e100:	10800a17 	ldw	r2,40(r2)
8113e104:	1885883a 	add	r2,r3,r2
8113e108:	10800204 	addi	r2,r2,8
8113e10c:	1009883a 	mov	r4,r2
8113e110:	e0ffff17 	ldw	r3,-4(fp)
8113e114:	e0bffc17 	ldw	r2,-16(fp)
8113e118:	1885883a 	add	r2,r3,r2
8113e11c:	10800204 	addi	r2,r2,8
8113e120:	10800003 	ldbu	r2,0(r2)
8113e124:	10803fcc 	andi	r2,r2,255
8113e128:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113e12c:	e0bffc17 	ldw	r2,-16(fp)
8113e130:	10800044 	addi	r2,r2,1
8113e134:	e0bffc15 	stw	r2,-16(fp)
8113e138:	e0bffc17 	ldw	r2,-16(fp)
8113e13c:	108000d0 	cmplti	r2,r2,3
8113e140:	103fea1e 	bne	r2,zero,8113e0ec <__reset+0xfb11e0ec>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8113e144:	d0a0ae17 	ldw	r2,-32072(gp)
8113e148:	10c00a17 	ldw	r3,40(r2)
8113e14c:	e0bffe17 	ldw	r2,-8(fp)
8113e150:	1885883a 	add	r2,r3,r2
8113e154:	108002c4 	addi	r2,r2,11
8113e158:	1007883a 	mov	r3,r2
8113e15c:	e0bfff17 	ldw	r2,-4(fp)
8113e160:	108002c3 	ldbu	r2,11(r2)
8113e164:	10803fcc 	andi	r2,r2,255
8113e168:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
8113e16c:	d0a0ae17 	ldw	r2,-32072(gp)
8113e170:	10c00a17 	ldw	r3,40(r2)
8113e174:	e0bffe17 	ldw	r2,-8(fp)
8113e178:	1885883a 	add	r2,r3,r2
8113e17c:	10800384 	addi	r2,r2,14
8113e180:	1007883a 	mov	r3,r2
8113e184:	e0bfff17 	ldw	r2,-4(fp)
8113e188:	1080030b 	ldhu	r2,12(r2)
8113e18c:	10bfffcc 	andi	r2,r2,65535
8113e190:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8113e194:	d0a0ae17 	ldw	r2,-32072(gp)
8113e198:	10c00a17 	ldw	r3,40(r2)
8113e19c:	e0bffe17 	ldw	r2,-8(fp)
8113e1a0:	1885883a 	add	r2,r3,r2
8113e1a4:	10800404 	addi	r2,r2,16
8113e1a8:	1007883a 	mov	r3,r2
8113e1ac:	e0bfff17 	ldw	r2,-4(fp)
8113e1b0:	1080038b 	ldhu	r2,14(r2)
8113e1b4:	10bfffcc 	andi	r2,r2,65535
8113e1b8:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
8113e1bc:	d0a0ae17 	ldw	r2,-32072(gp)
8113e1c0:	10c00a17 	ldw	r3,40(r2)
8113e1c4:	e0bffe17 	ldw	r2,-8(fp)
8113e1c8:	1885883a 	add	r2,r3,r2
8113e1cc:	10800484 	addi	r2,r2,18
8113e1d0:	1007883a 	mov	r3,r2
8113e1d4:	e0bfff17 	ldw	r2,-4(fp)
8113e1d8:	1080040b 	ldhu	r2,16(r2)
8113e1dc:	10bfffcc 	andi	r2,r2,65535
8113e1e0:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
8113e1e4:	d0a0ae17 	ldw	r2,-32072(gp)
8113e1e8:	10c00a17 	ldw	r3,40(r2)
8113e1ec:	e0bffe17 	ldw	r2,-8(fp)
8113e1f0:	1885883a 	add	r2,r3,r2
8113e1f4:	10800584 	addi	r2,r2,22
8113e1f8:	1007883a 	mov	r3,r2
8113e1fc:	e0bfff17 	ldw	r2,-4(fp)
8113e200:	1080048b 	ldhu	r2,18(r2)
8113e204:	10bfffcc 	andi	r2,r2,65535
8113e208:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
8113e20c:	d0a0ae17 	ldw	r2,-32072(gp)
8113e210:	10c00a17 	ldw	r3,40(r2)
8113e214:	e0bffe17 	ldw	r2,-8(fp)
8113e218:	1885883a 	add	r2,r3,r2
8113e21c:	10800604 	addi	r2,r2,24
8113e220:	1007883a 	mov	r3,r2
8113e224:	e0bfff17 	ldw	r2,-4(fp)
8113e228:	1080050b 	ldhu	r2,20(r2)
8113e22c:	10bfffcc 	andi	r2,r2,65535
8113e230:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
8113e234:	d0a0ae17 	ldw	r2,-32072(gp)
8113e238:	10c00a17 	ldw	r3,40(r2)
8113e23c:	e0bffe17 	ldw	r2,-8(fp)
8113e240:	1885883a 	add	r2,r3,r2
8113e244:	10800684 	addi	r2,r2,26
8113e248:	1007883a 	mov	r3,r2
8113e24c:	e0bfff17 	ldw	r2,-4(fp)
8113e250:	1080058b 	ldhu	r2,22(r2)
8113e254:	10bfffcc 	andi	r2,r2,65535
8113e258:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
8113e25c:	d0a0ae17 	ldw	r2,-32072(gp)
8113e260:	10c00a17 	ldw	r3,40(r2)
8113e264:	e0bffe17 	ldw	r2,-8(fp)
8113e268:	1885883a 	add	r2,r3,r2
8113e26c:	10800704 	addi	r2,r2,28
8113e270:	1007883a 	mov	r3,r2
8113e274:	e0bfff17 	ldw	r2,-4(fp)
8113e278:	10800617 	ldw	r2,24(r2)
8113e27c:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
8113e280:	00800044 	movi	r2,1
8113e284:	d0a0af15 	stw	r2,-32068(gp)
        result = true;
8113e288:	00800044 	movi	r2,1
8113e28c:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
8113e290:	e0bffb17 	ldw	r2,-20(fp)
}
8113e294:	e037883a 	mov	sp,fp
8113e298:	dfc00117 	ldw	ra,4(sp)
8113e29c:	df000017 	ldw	fp,0(sp)
8113e2a0:	dec00204 	addi	sp,sp,8
8113e2a4:	f800283a 	ret

8113e2a8 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8113e2a8:	defff904 	addi	sp,sp,-28
8113e2ac:	de00012e 	bgeu	sp,et,8113e2b4 <Check_for_DOS_FAT+0xc>
8113e2b0:	003b68fa 	trap	3
8113e2b4:	dfc00615 	stw	ra,24(sp)
8113e2b8:	df000515 	stw	fp,20(sp)
8113e2bc:	df000504 	addi	fp,sp,20
8113e2c0:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8113e2c4:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8113e2c8:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
8113e2cc:	e17fff17 	ldw	r5,-4(fp)
8113e2d0:	0009883a 	mov	r4,zero
8113e2d4:	113d9600 	call	8113d960 <Read_Sector_Data>
8113e2d8:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
8113e2dc:	d0a0ae17 	ldw	r2,-32072(gp)
8113e2e0:	10800a17 	ldw	r2,40(r2)
8113e2e4:	10807f84 	addi	r2,r2,510
8113e2e8:	1080002b 	ldhuio	r2,0(r2)
8113e2ec:	10bfffcc 	andi	r2,r2,65535
8113e2f0:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
8113e2f4:	e0bffe0f 	ldh	r2,-8(fp)
8113e2f8:	10ffffcc 	andi	r3,r2,65535
8113e2fc:	00aa9554 	movui	r2,43605
8113e300:	1881841e 	bne	r3,r2,8113e914 <Check_for_DOS_FAT+0x66c>
8113e304:	e0bffb17 	ldw	r2,-20(fp)
8113e308:	10018226 	beq	r2,zero,8113e914 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
8113e30c:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
8113e310:	d0a0ae17 	ldw	r2,-32072(gp)
8113e314:	10800a17 	ldw	r2,40(r2)
8113e318:	10800023 	ldbuio	r2,0(r2)
8113e31c:	10803fcc 	andi	r2,r2,255
8113e320:	1007883a 	mov	r3,r2
8113e324:	00a045b4 	movhi	r2,33046
8113e328:	109e3d04 	addi	r2,r2,30964
8113e32c:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
8113e330:	d0a0ae17 	ldw	r2,-32072(gp)
8113e334:	10800a17 	ldw	r2,40(r2)
8113e338:	10800044 	addi	r2,r2,1
8113e33c:	10800023 	ldbuio	r2,0(r2)
8113e340:	10803fcc 	andi	r2,r2,255
8113e344:	1007883a 	mov	r3,r2
8113e348:	00a045b4 	movhi	r2,33046
8113e34c:	109e3d04 	addi	r2,r2,30964
8113e350:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8113e354:	d0a0ae17 	ldw	r2,-32072(gp)
8113e358:	10800a17 	ldw	r2,40(r2)
8113e35c:	10800084 	addi	r2,r2,2
8113e360:	10800023 	ldbuio	r2,0(r2)
8113e364:	10803fcc 	andi	r2,r2,255
8113e368:	1007883a 	mov	r3,r2
8113e36c:	00a045b4 	movhi	r2,33046
8113e370:	109e3d04 	addi	r2,r2,30964
8113e374:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8113e378:	e03ffc15 	stw	zero,-16(fp)
8113e37c:	00001106 	br	8113e3c4 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
8113e380:	d0a0ae17 	ldw	r2,-32072(gp)
8113e384:	10c00a17 	ldw	r3,40(r2)
8113e388:	e0bffc17 	ldw	r2,-16(fp)
8113e38c:	1885883a 	add	r2,r3,r2
8113e390:	108000c4 	addi	r2,r2,3
8113e394:	10800023 	ldbuio	r2,0(r2)
8113e398:	10803fcc 	andi	r2,r2,255
8113e39c:	1009883a 	mov	r4,r2
8113e3a0:	00a045b4 	movhi	r2,33046
8113e3a4:	109e3d04 	addi	r2,r2,30964
8113e3a8:	e0fffc17 	ldw	r3,-16(fp)
8113e3ac:	10c5883a 	add	r2,r2,r3
8113e3b0:	108000c4 	addi	r2,r2,3
8113e3b4:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8113e3b8:	e0bffc17 	ldw	r2,-16(fp)
8113e3bc:	10800044 	addi	r2,r2,1
8113e3c0:	e0bffc15 	stw	r2,-16(fp)
8113e3c4:	e0bffc17 	ldw	r2,-16(fp)
8113e3c8:	10800210 	cmplti	r2,r2,8
8113e3cc:	103fec1e 	bne	r2,zero,8113e380 <__reset+0xfb11e380>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8113e3d0:	d0a0ae17 	ldw	r2,-32072(gp)
8113e3d4:	10800a17 	ldw	r2,40(r2)
8113e3d8:	10800304 	addi	r2,r2,12
8113e3dc:	10800023 	ldbuio	r2,0(r2)
8113e3e0:	10803fcc 	andi	r2,r2,255
8113e3e4:	1004923a 	slli	r2,r2,8
8113e3e8:	1007883a 	mov	r3,r2
8113e3ec:	d0a0ae17 	ldw	r2,-32072(gp)
8113e3f0:	10800a17 	ldw	r2,40(r2)
8113e3f4:	108002c4 	addi	r2,r2,11
8113e3f8:	10800023 	ldbuio	r2,0(r2)
8113e3fc:	10803fcc 	andi	r2,r2,255
8113e400:	10803fcc 	andi	r2,r2,255
8113e404:	1080201c 	xori	r2,r2,128
8113e408:	10bfe004 	addi	r2,r2,-128
8113e40c:	1884b03a 	or	r2,r3,r2
8113e410:	1007883a 	mov	r3,r2
8113e414:	00a045b4 	movhi	r2,33046
8113e418:	109e3d04 	addi	r2,r2,30964
8113e41c:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8113e420:	d0a0ae17 	ldw	r2,-32072(gp)
8113e424:	10800a17 	ldw	r2,40(r2)
8113e428:	10800344 	addi	r2,r2,13
8113e42c:	10800023 	ldbuio	r2,0(r2)
8113e430:	10803fcc 	andi	r2,r2,255
8113e434:	1007883a 	mov	r3,r2
8113e438:	00a045b4 	movhi	r2,33046
8113e43c:	109e3d04 	addi	r2,r2,30964
8113e440:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8113e444:	d0a0ae17 	ldw	r2,-32072(gp)
8113e448:	10800a17 	ldw	r2,40(r2)
8113e44c:	10800384 	addi	r2,r2,14
8113e450:	1080002b 	ldhuio	r2,0(r2)
8113e454:	10bfffcc 	andi	r2,r2,65535
8113e458:	1007883a 	mov	r3,r2
8113e45c:	00a045b4 	movhi	r2,33046
8113e460:	109e3d04 	addi	r2,r2,30964
8113e464:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8113e468:	d0a0ae17 	ldw	r2,-32072(gp)
8113e46c:	10800a17 	ldw	r2,40(r2)
8113e470:	10800404 	addi	r2,r2,16
8113e474:	10800023 	ldbuio	r2,0(r2)
8113e478:	10803fcc 	andi	r2,r2,255
8113e47c:	1007883a 	mov	r3,r2
8113e480:	00a045b4 	movhi	r2,33046
8113e484:	109e3d04 	addi	r2,r2,30964
8113e488:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
8113e48c:	d0a0ae17 	ldw	r2,-32072(gp)
8113e490:	10800a17 	ldw	r2,40(r2)
8113e494:	10800484 	addi	r2,r2,18
8113e498:	10800023 	ldbuio	r2,0(r2)
8113e49c:	10803fcc 	andi	r2,r2,255
8113e4a0:	1004923a 	slli	r2,r2,8
8113e4a4:	1007883a 	mov	r3,r2
8113e4a8:	d0a0ae17 	ldw	r2,-32072(gp)
8113e4ac:	10800a17 	ldw	r2,40(r2)
8113e4b0:	10800444 	addi	r2,r2,17
8113e4b4:	10800023 	ldbuio	r2,0(r2)
8113e4b8:	10803fcc 	andi	r2,r2,255
8113e4bc:	10803fcc 	andi	r2,r2,255
8113e4c0:	1884b03a 	or	r2,r3,r2
8113e4c4:	1007883a 	mov	r3,r2
8113e4c8:	00a045b4 	movhi	r2,33046
8113e4cc:	109e3d04 	addi	r2,r2,30964
8113e4d0:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8113e4d4:	d0a0ae17 	ldw	r2,-32072(gp)
8113e4d8:	10800a17 	ldw	r2,40(r2)
8113e4dc:	10800504 	addi	r2,r2,20
8113e4e0:	10800023 	ldbuio	r2,0(r2)
8113e4e4:	10803fcc 	andi	r2,r2,255
8113e4e8:	1004923a 	slli	r2,r2,8
8113e4ec:	1007883a 	mov	r3,r2
8113e4f0:	d0a0ae17 	ldw	r2,-32072(gp)
8113e4f4:	10800a17 	ldw	r2,40(r2)
8113e4f8:	108004c4 	addi	r2,r2,19
8113e4fc:	10800023 	ldbuio	r2,0(r2)
8113e500:	10803fcc 	andi	r2,r2,255
8113e504:	10803fcc 	andi	r2,r2,255
8113e508:	1884b03a 	or	r2,r3,r2
8113e50c:	1007883a 	mov	r3,r2
8113e510:	00a045b4 	movhi	r2,33046
8113e514:	109e3d04 	addi	r2,r2,30964
8113e518:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
8113e51c:	d0a0ae17 	ldw	r2,-32072(gp)
8113e520:	10800a17 	ldw	r2,40(r2)
8113e524:	10800544 	addi	r2,r2,21
8113e528:	10800023 	ldbuio	r2,0(r2)
8113e52c:	10803fcc 	andi	r2,r2,255
8113e530:	1007883a 	mov	r3,r2
8113e534:	00a045b4 	movhi	r2,33046
8113e538:	109e3d04 	addi	r2,r2,30964
8113e53c:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8113e540:	d0a0ae17 	ldw	r2,-32072(gp)
8113e544:	10800a17 	ldw	r2,40(r2)
8113e548:	10800584 	addi	r2,r2,22
8113e54c:	1080002b 	ldhuio	r2,0(r2)
8113e550:	10bfffcc 	andi	r2,r2,65535
8113e554:	1007883a 	mov	r3,r2
8113e558:	00a045b4 	movhi	r2,33046
8113e55c:	109e3d04 	addi	r2,r2,30964
8113e560:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8113e564:	d0a0ae17 	ldw	r2,-32072(gp)
8113e568:	10800a17 	ldw	r2,40(r2)
8113e56c:	10800604 	addi	r2,r2,24
8113e570:	1080002b 	ldhuio	r2,0(r2)
8113e574:	10bfffcc 	andi	r2,r2,65535
8113e578:	1007883a 	mov	r3,r2
8113e57c:	00a045b4 	movhi	r2,33046
8113e580:	109e3d04 	addi	r2,r2,30964
8113e584:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8113e588:	d0a0ae17 	ldw	r2,-32072(gp)
8113e58c:	10800a17 	ldw	r2,40(r2)
8113e590:	10800684 	addi	r2,r2,26
8113e594:	1080002b 	ldhuio	r2,0(r2)
8113e598:	10bfffcc 	andi	r2,r2,65535
8113e59c:	1007883a 	mov	r3,r2
8113e5a0:	00a045b4 	movhi	r2,33046
8113e5a4:	109e3d04 	addi	r2,r2,30964
8113e5a8:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
8113e5ac:	d0a0ae17 	ldw	r2,-32072(gp)
8113e5b0:	10800a17 	ldw	r2,40(r2)
8113e5b4:	10800704 	addi	r2,r2,28
8113e5b8:	10800037 	ldwio	r2,0(r2)
8113e5bc:	1007883a 	mov	r3,r2
8113e5c0:	00a045b4 	movhi	r2,33046
8113e5c4:	109e3d04 	addi	r2,r2,30964
8113e5c8:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
8113e5cc:	d0a0ae17 	ldw	r2,-32072(gp)
8113e5d0:	10800a17 	ldw	r2,40(r2)
8113e5d4:	10800804 	addi	r2,r2,32
8113e5d8:	10800037 	ldwio	r2,0(r2)
8113e5dc:	1007883a 	mov	r3,r2
8113e5e0:	00a045b4 	movhi	r2,33046
8113e5e4:	109e3d04 	addi	r2,r2,30964
8113e5e8:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
8113e5ec:	d0a0ae17 	ldw	r2,-32072(gp)
8113e5f0:	10800a17 	ldw	r2,40(r2)
8113e5f4:	10800904 	addi	r2,r2,36
8113e5f8:	10800023 	ldbuio	r2,0(r2)
8113e5fc:	10803fcc 	andi	r2,r2,255
8113e600:	1007883a 	mov	r3,r2
8113e604:	00a045b4 	movhi	r2,33046
8113e608:	109e3d04 	addi	r2,r2,30964
8113e60c:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8113e610:	d0a0ae17 	ldw	r2,-32072(gp)
8113e614:	10800a17 	ldw	r2,40(r2)
8113e618:	10800944 	addi	r2,r2,37
8113e61c:	10800023 	ldbuio	r2,0(r2)
8113e620:	10803fcc 	andi	r2,r2,255
8113e624:	1007883a 	mov	r3,r2
8113e628:	00a045b4 	movhi	r2,33046
8113e62c:	109e3d04 	addi	r2,r2,30964
8113e630:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
8113e634:	d0a0ae17 	ldw	r2,-32072(gp)
8113e638:	10800a17 	ldw	r2,40(r2)
8113e63c:	10800984 	addi	r2,r2,38
8113e640:	10800023 	ldbuio	r2,0(r2)
8113e644:	10803fcc 	andi	r2,r2,255
8113e648:	1007883a 	mov	r3,r2
8113e64c:	00a045b4 	movhi	r2,33046
8113e650:	109e3d04 	addi	r2,r2,30964
8113e654:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8113e658:	00a045b4 	movhi	r2,33046
8113e65c:	109e3d04 	addi	r2,r2,30964
8113e660:	1080040b 	ldhu	r2,16(r2)
8113e664:	10ffffcc 	andi	r3,r2,65535
8113e668:	00a045b4 	movhi	r2,33046
8113e66c:	109e3d04 	addi	r2,r2,30964
8113e670:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8113e674:	00a045b4 	movhi	r2,33046
8113e678:	109e3d04 	addi	r2,r2,30964
8113e67c:	10c01117 	ldw	r3,68(r2)
8113e680:	00a045b4 	movhi	r2,33046
8113e684:	109e3d04 	addi	r2,r2,30964
8113e688:	1080068b 	ldhu	r2,26(r2)
8113e68c:	10bfffcc 	andi	r2,r2,65535
8113e690:	1887883a 	add	r3,r3,r2
8113e694:	00a045b4 	movhi	r2,33046
8113e698:	109e3d04 	addi	r2,r2,30964
8113e69c:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8113e6a0:	00a045b4 	movhi	r2,33046
8113e6a4:	109e3d04 	addi	r2,r2,30964
8113e6a8:	10c01217 	ldw	r3,72(r2)
8113e6ac:	00a045b4 	movhi	r2,33046
8113e6b0:	109e3d04 	addi	r2,r2,30964
8113e6b4:	1080068b 	ldhu	r2,26(r2)
8113e6b8:	10bfffcc 	andi	r2,r2,65535
8113e6bc:	1887883a 	add	r3,r3,r2
8113e6c0:	00a045b4 	movhi	r2,33046
8113e6c4:	109e3d04 	addi	r2,r2,30964
8113e6c8:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
8113e6cc:	00a045b4 	movhi	r2,33046
8113e6d0:	109e3d04 	addi	r2,r2,30964
8113e6d4:	10c01317 	ldw	r3,76(r2)
8113e6d8:	00a045b4 	movhi	r2,33046
8113e6dc:	109e3d04 	addi	r2,r2,30964
8113e6e0:	1080050b 	ldhu	r2,20(r2)
8113e6e4:	10bfffcc 	andi	r2,r2,65535
8113e6e8:	1008917a 	slli	r4,r2,5
8113e6ec:	00a045b4 	movhi	r2,33046
8113e6f0:	109e3d04 	addi	r2,r2,30964
8113e6f4:	1080030b 	ldhu	r2,12(r2)
8113e6f8:	10bfffcc 	andi	r2,r2,65535
8113e6fc:	2085283a 	div	r2,r4,r2
8113e700:	1887883a 	add	r3,r3,r2
8113e704:	00a045b4 	movhi	r2,33046
8113e708:	109e3d04 	addi	r2,r2,30964
8113e70c:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8113e710:	00a045b4 	movhi	r2,33046
8113e714:	109e3d04 	addi	r2,r2,30964
8113e718:	1080058b 	ldhu	r2,22(r2)
8113e71c:	10bfffcc 	andi	r2,r2,65535
8113e720:	10000b26 	beq	r2,zero,8113e750 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
8113e724:	00a045b4 	movhi	r2,33046
8113e728:	109e3d04 	addi	r2,r2,30964
8113e72c:	1080058b 	ldhu	r2,22(r2)
8113e730:	10ffffcc 	andi	r3,r2,65535
8113e734:	00a045b4 	movhi	r2,33046
8113e738:	109e3d04 	addi	r2,r2,30964
8113e73c:	10800383 	ldbu	r2,14(r2)
8113e740:	10803fcc 	andi	r2,r2,255
8113e744:	1885283a 	div	r2,r3,r2
8113e748:	e0bffd15 	stw	r2,-12(fp)
8113e74c:	00000906 	br	8113e774 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8113e750:	00a045b4 	movhi	r2,33046
8113e754:	109e3d04 	addi	r2,r2,30964
8113e758:	10c00917 	ldw	r3,36(r2)
8113e75c:	00a045b4 	movhi	r2,33046
8113e760:	109e3d04 	addi	r2,r2,30964
8113e764:	10800383 	ldbu	r2,14(r2)
8113e768:	10803fcc 	andi	r2,r2,255
8113e76c:	1885203a 	divu	r2,r3,r2
8113e770:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
8113e774:	e0bffd17 	ldw	r2,-12(fp)
8113e778:	1083fdc8 	cmpgei	r2,r2,4087
8113e77c:	1000051e 	bne	r2,zero,8113e794 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8113e780:	00a045b4 	movhi	r2,33046
8113e784:	109e3d04 	addi	r2,r2,30964
8113e788:	00c00304 	movi	r3,12
8113e78c:	10c01085 	stb	r3,66(r2)
8113e790:	00000c06 	br	8113e7c4 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
8113e794:	e0bffd17 	ldw	r2,-12(fp)
8113e798:	00fffb54 	movui	r3,65517
8113e79c:	18800516 	blt	r3,r2,8113e7b4 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8113e7a0:	00a045b4 	movhi	r2,33046
8113e7a4:	109e3d04 	addi	r2,r2,30964
8113e7a8:	00c00404 	movi	r3,16
8113e7ac:	10c01085 	stb	r3,66(r2)
8113e7b0:	00000406 	br	8113e7c4 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
8113e7b4:	00a045b4 	movhi	r2,33046
8113e7b8:	109e3d04 	addi	r2,r2,30964
8113e7bc:	00c00804 	movi	r3,32
8113e7c0:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
8113e7c4:	e03ffc15 	stw	zero,-16(fp)
8113e7c8:	00001106 	br	8113e810 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8113e7cc:	d0a0ae17 	ldw	r2,-32072(gp)
8113e7d0:	10c00a17 	ldw	r3,40(r2)
8113e7d4:	e0bffc17 	ldw	r2,-16(fp)
8113e7d8:	1885883a 	add	r2,r3,r2
8113e7dc:	108009c4 	addi	r2,r2,39
8113e7e0:	10800023 	ldbuio	r2,0(r2)
8113e7e4:	10803fcc 	andi	r2,r2,255
8113e7e8:	1009883a 	mov	r4,r2
8113e7ec:	00a045b4 	movhi	r2,33046
8113e7f0:	109e3d04 	addi	r2,r2,30964
8113e7f4:	e0fffc17 	ldw	r3,-16(fp)
8113e7f8:	10c5883a 	add	r2,r2,r3
8113e7fc:	10800ac4 	addi	r2,r2,43
8113e800:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
8113e804:	e0bffc17 	ldw	r2,-16(fp)
8113e808:	10800044 	addi	r2,r2,1
8113e80c:	e0bffc15 	stw	r2,-16(fp)
8113e810:	e0bffc17 	ldw	r2,-16(fp)
8113e814:	10800110 	cmplti	r2,r2,4
8113e818:	103fec1e 	bne	r2,zero,8113e7cc <__reset+0xfb11e7cc>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113e81c:	e03ffc15 	stw	zero,-16(fp)
8113e820:	00001106 	br	8113e868 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
8113e824:	d0a0ae17 	ldw	r2,-32072(gp)
8113e828:	10c00a17 	ldw	r3,40(r2)
8113e82c:	e0bffc17 	ldw	r2,-16(fp)
8113e830:	1885883a 	add	r2,r3,r2
8113e834:	10800ac4 	addi	r2,r2,43
8113e838:	10800023 	ldbuio	r2,0(r2)
8113e83c:	10803fcc 	andi	r2,r2,255
8113e840:	1009883a 	mov	r4,r2
8113e844:	00a045b4 	movhi	r2,33046
8113e848:	109e3d04 	addi	r2,r2,30964
8113e84c:	e0fffc17 	ldw	r3,-16(fp)
8113e850:	10c5883a 	add	r2,r2,r3
8113e854:	10800bc4 	addi	r2,r2,47
8113e858:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113e85c:	e0bffc17 	ldw	r2,-16(fp)
8113e860:	10800044 	addi	r2,r2,1
8113e864:	e0bffc15 	stw	r2,-16(fp)
8113e868:	e0bffc17 	ldw	r2,-16(fp)
8113e86c:	108002d0 	cmplti	r2,r2,11
8113e870:	103fec1e 	bne	r2,zero,8113e824 <__reset+0xfb11e824>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113e874:	e03ffc15 	stw	zero,-16(fp)
8113e878:	00001106 	br	8113e8c0 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8113e87c:	d0a0ae17 	ldw	r2,-32072(gp)
8113e880:	10c00a17 	ldw	r3,40(r2)
8113e884:	e0bffc17 	ldw	r2,-16(fp)
8113e888:	1885883a 	add	r2,r3,r2
8113e88c:	10800d84 	addi	r2,r2,54
8113e890:	10800023 	ldbuio	r2,0(r2)
8113e894:	10803fcc 	andi	r2,r2,255
8113e898:	1009883a 	mov	r4,r2
8113e89c:	00a045b4 	movhi	r2,33046
8113e8a0:	109e3d04 	addi	r2,r2,30964
8113e8a4:	e0fffc17 	ldw	r3,-16(fp)
8113e8a8:	10c5883a 	add	r2,r2,r3
8113e8ac:	10800e84 	addi	r2,r2,58
8113e8b0:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113e8b4:	e0bffc17 	ldw	r2,-16(fp)
8113e8b8:	10800044 	addi	r2,r2,1
8113e8bc:	e0bffc15 	stw	r2,-16(fp)
8113e8c0:	e0bffc17 	ldw	r2,-16(fp)
8113e8c4:	10800210 	cmplti	r2,r2,8
8113e8c8:	103fec1e 	bne	r2,zero,8113e87c <__reset+0xfb11e87c>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113e8cc:	e03ffc15 	stw	zero,-16(fp)
8113e8d0:	00000a06 	br	8113e8fc <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
8113e8d4:	00a045b4 	movhi	r2,33046
8113e8d8:	109e5204 	addi	r2,r2,31048
8113e8dc:	e0fffc17 	ldw	r3,-16(fp)
8113e8e0:	180691ba 	slli	r3,r3,6
8113e8e4:	10c5883a 	add	r2,r2,r3
8113e8e8:	10800f04 	addi	r2,r2,60
8113e8ec:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113e8f0:	e0bffc17 	ldw	r2,-16(fp)
8113e8f4:	10800044 	addi	r2,r2,1
8113e8f8:	e0bffc15 	stw	r2,-16(fp)
8113e8fc:	e0bffc17 	ldw	r2,-16(fp)
8113e900:	10800510 	cmplti	r2,r2,20
8113e904:	103ff31e 	bne	r2,zero,8113e8d4 <__reset+0xfb11e8d4>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8113e908:	00800044 	movi	r2,1
8113e90c:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8113e910:	00000106 	br	8113e918 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
8113e914:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8113e918:	e0bffb17 	ldw	r2,-20(fp)
}
8113e91c:	e037883a 	mov	sp,fp
8113e920:	dfc00117 	ldw	ra,4(sp)
8113e924:	df000017 	ldw	fp,0(sp)
8113e928:	dec00204 	addi	sp,sp,8
8113e92c:	f800283a 	ret

8113e930 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8113e930:	defffc04 	addi	sp,sp,-16
8113e934:	de00012e 	bgeu	sp,et,8113e93c <Look_for_FAT16+0xc>
8113e938:	003b68fa 	trap	3
8113e93c:	dfc00315 	stw	ra,12(sp)
8113e940:	df000215 	stw	fp,8(sp)
8113e944:	df000204 	addi	fp,sp,8
	bool result = false;
8113e948:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8113e94c:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
8113e950:	10002e26 	beq	r2,zero,8113ea0c <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
8113e954:	d0a0a817 	ldw	r2,-32096(gp)
8113e958:	1080000b 	ldhu	r2,0(r2)
8113e95c:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8113e960:	d020ac15 	stw	zero,-32080(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
8113e964:	d020ad15 	stw	zero,-32076(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8113e968:	e0bfff0f 	ldh	r2,-4(fp)
8113e96c:	10002716 	blt	r2,zero,8113ea0c <Look_for_FAT16+0xdc>
8113e970:	e0bfff0b 	ldhu	r2,-4(fp)
8113e974:	10bfffcc 	andi	r2,r2,65535
8113e978:	1083000c 	andi	r2,r2,3072
8113e97c:	10830020 	cmpeqi	r2,r2,3072
8113e980:	1000221e 	bne	r2,zero,8113ea0c <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
8113e984:	e0bfff0b 	ldhu	r2,-4(fp)
8113e988:	10bfffcc 	andi	r2,r2,65535
8113e98c:	1083000c 	andi	r2,r2,3072
8113e990:	10810018 	cmpnei	r2,r2,1024
8113e994:	1000031e 	bne	r2,zero,8113e9a4 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8113e998:	0009883a 	mov	r4,zero
8113e99c:	113e2a80 	call	8113e2a8 <Check_for_DOS_FAT>
8113e9a0:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
8113e9a4:	e0bfff0b 	ldhu	r2,-4(fp)
8113e9a8:	10bfffcc 	andi	r2,r2,65535
8113e9ac:	1083000c 	andi	r2,r2,3072
8113e9b0:	1000061e 	bne	r2,zero,8113e9cc <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
8113e9b4:	113dbe40 	call	8113dbe4 <Check_for_Master_Boot_Record>
8113e9b8:	10000426 	beq	r2,zero,8113e9cc <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8113e9bc:	d0a0ac17 	ldw	r2,-32080(gp)
8113e9c0:	1009883a 	mov	r4,r2
8113e9c4:	113e2a80 	call	8113e2a8 <Check_for_DOS_FAT>
8113e9c8:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8113e9cc:	e0bffe17 	ldw	r2,-8(fp)
8113e9d0:	10800058 	cmpnei	r2,r2,1
8113e9d4:	10000d1e 	bne	r2,zero,8113ea0c <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8113e9d8:	00a045b4 	movhi	r2,33046
8113e9dc:	109e3d04 	addi	r2,r2,30964
8113e9e0:	10801083 	ldbu	r2,66(r2)
8113e9e4:	10803fcc 	andi	r2,r2,255
8113e9e8:	10800420 	cmpeqi	r2,r2,16
8113e9ec:	1000021e 	bne	r2,zero,8113e9f8 <Look_for_FAT16+0xc8>
				{
					result = false;
8113e9f0:	e03ffe15 	stw	zero,-8(fp)
8113e9f4:	00000506 	br	8113ea0c <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8113e9f8:	00a045b4 	movhi	r2,33046
8113e9fc:	109e3d04 	addi	r2,r2,30964
8113ea00:	1080058b 	ldhu	r2,22(r2)
8113ea04:	10bfffcc 	andi	r2,r2,65535
8113ea08:	d0a0ad15 	stw	r2,-32076(gp)
				}
			}
		}
	}
	return result;
8113ea0c:	e0bffe17 	ldw	r2,-8(fp)
}
8113ea10:	e037883a 	mov	sp,fp
8113ea14:	dfc00117 	ldw	ra,4(sp)
8113ea18:	df000017 	ldw	fp,0(sp)
8113ea1c:	dec00204 	addi	sp,sp,8
8113ea20:	f800283a 	ret

8113ea24 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
8113ea24:	defffb04 	addi	sp,sp,-20
8113ea28:	de00012e 	bgeu	sp,et,8113ea30 <filename_to_upper_case+0xc>
8113ea2c:	003b68fa 	trap	3
8113ea30:	dfc00415 	stw	ra,16(sp)
8113ea34:	df000315 	stw	fp,12(sp)
8113ea38:	df000304 	addi	fp,sp,12
8113ea3c:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8113ea40:	e13fff17 	ldw	r4,-4(fp)
8113ea44:	111dcc00 	call	8111dcc0 <strlen>
8113ea48:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8113ea4c:	e03ffd15 	stw	zero,-12(fp)
8113ea50:	00001e06 	br	8113eacc <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
8113ea54:	e0bffd17 	ldw	r2,-12(fp)
8113ea58:	e0ffff17 	ldw	r3,-4(fp)
8113ea5c:	1885883a 	add	r2,r3,r2
8113ea60:	10800003 	ldbu	r2,0(r2)
8113ea64:	10803fcc 	andi	r2,r2,255
8113ea68:	1080201c 	xori	r2,r2,128
8113ea6c:	10bfe004 	addi	r2,r2,-128
8113ea70:	10801850 	cmplti	r2,r2,97
8113ea74:	1000121e 	bne	r2,zero,8113eac0 <filename_to_upper_case+0x9c>
8113ea78:	e0bffd17 	ldw	r2,-12(fp)
8113ea7c:	e0ffff17 	ldw	r3,-4(fp)
8113ea80:	1885883a 	add	r2,r3,r2
8113ea84:	10800003 	ldbu	r2,0(r2)
8113ea88:	10803fcc 	andi	r2,r2,255
8113ea8c:	1080201c 	xori	r2,r2,128
8113ea90:	10bfe004 	addi	r2,r2,-128
8113ea94:	10801ec8 	cmpgei	r2,r2,123
8113ea98:	1000091e 	bne	r2,zero,8113eac0 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8113ea9c:	e0bffd17 	ldw	r2,-12(fp)
8113eaa0:	e0ffff17 	ldw	r3,-4(fp)
8113eaa4:	1885883a 	add	r2,r3,r2
8113eaa8:	e0fffd17 	ldw	r3,-12(fp)
8113eaac:	e13fff17 	ldw	r4,-4(fp)
8113eab0:	20c7883a 	add	r3,r4,r3
8113eab4:	18c00003 	ldbu	r3,0(r3)
8113eab8:	18fff804 	addi	r3,r3,-32
8113eabc:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8113eac0:	e0bffd17 	ldw	r2,-12(fp)
8113eac4:	10800044 	addi	r2,r2,1
8113eac8:	e0bffd15 	stw	r2,-12(fp)
8113eacc:	e0fffd17 	ldw	r3,-12(fp)
8113ead0:	e0bffe17 	ldw	r2,-8(fp)
8113ead4:	18bfdf16 	blt	r3,r2,8113ea54 <__reset+0xfb11ea54>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8113ead8:	0001883a 	nop
8113eadc:	e037883a 	mov	sp,fp
8113eae0:	dfc00117 	ldw	ra,4(sp)
8113eae4:	df000017 	ldw	fp,0(sp)
8113eae8:	dec00204 	addi	sp,sp,8
8113eaec:	f800283a 	ret

8113eaf0 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8113eaf0:	defff804 	addi	sp,sp,-32
8113eaf4:	de00012e 	bgeu	sp,et,8113eafc <check_file_name_for_FAT16_compliance+0xc>
8113eaf8:	003b68fa 	trap	3
8113eafc:	dfc00715 	stw	ra,28(sp)
8113eb00:	df000615 	stw	fp,24(sp)
8113eb04:	df000604 	addi	fp,sp,24
8113eb08:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8113eb0c:	e13fff17 	ldw	r4,-4(fp)
8113eb10:	111dcc00 	call	8111dcc0 <strlen>
8113eb14:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8113eb18:	00bfffc4 	movi	r2,-1
8113eb1c:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8113eb20:	00bfffc4 	movi	r2,-1
8113eb24:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8113eb28:	00800044 	movi	r2,1
8113eb2c:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8113eb30:	e03ffa15 	stw	zero,-24(fp)
8113eb34:	00006d06 	br	8113ecec <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8113eb38:	e0bffa17 	ldw	r2,-24(fp)
8113eb3c:	e0ffff17 	ldw	r3,-4(fp)
8113eb40:	1885883a 	add	r2,r3,r2
8113eb44:	10800003 	ldbu	r2,0(r2)
8113eb48:	10803fcc 	andi	r2,r2,255
8113eb4c:	1080201c 	xori	r2,r2,128
8113eb50:	10bfe004 	addi	r2,r2,-128
8113eb54:	10800820 	cmpeqi	r2,r2,32
8113eb58:	10003e1e 	bne	r2,zero,8113ec54 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113eb5c:	e0bffa17 	ldw	r2,-24(fp)
8113eb60:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
8113eb64:	e0bffb17 	ldw	r2,-20(fp)
8113eb68:	1880121e 	bne	r3,r2,8113ebb4 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113eb6c:	e0bffa17 	ldw	r2,-24(fp)
8113eb70:	e0ffff17 	ldw	r3,-4(fp)
8113eb74:	1885883a 	add	r2,r3,r2
8113eb78:	10800003 	ldbu	r2,0(r2)
8113eb7c:	10803fcc 	andi	r2,r2,255
8113eb80:	1080201c 	xori	r2,r2,128
8113eb84:	10bfe004 	addi	r2,r2,-128
8113eb88:	10801720 	cmpeqi	r2,r2,92
8113eb8c:	1000311e 	bne	r2,zero,8113ec54 <check_file_name_for_FAT16_compliance+0x164>
8113eb90:	e0bffa17 	ldw	r2,-24(fp)
8113eb94:	e0ffff17 	ldw	r3,-4(fp)
8113eb98:	1885883a 	add	r2,r3,r2
8113eb9c:	10800003 	ldbu	r2,0(r2)
8113eba0:	10803fcc 	andi	r2,r2,255
8113eba4:	1080201c 	xori	r2,r2,128
8113eba8:	10bfe004 	addi	r2,r2,-128
8113ebac:	10800be0 	cmpeqi	r2,r2,47
8113ebb0:	1000281e 	bne	r2,zero,8113ec54 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113ebb4:	e0fffa17 	ldw	r3,-24(fp)
8113ebb8:	e0bffc17 	ldw	r2,-16(fp)
8113ebbc:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113ebc0:	10800258 	cmpnei	r2,r2,9
8113ebc4:	1000091e 	bne	r2,zero,8113ebec <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113ebc8:	e0bffa17 	ldw	r2,-24(fp)
8113ebcc:	e0ffff17 	ldw	r3,-4(fp)
8113ebd0:	1885883a 	add	r2,r3,r2
8113ebd4:	10800003 	ldbu	r2,0(r2)
8113ebd8:	10803fcc 	andi	r2,r2,255
8113ebdc:	1080201c 	xori	r2,r2,128
8113ebe0:	10bfe004 	addi	r2,r2,-128
8113ebe4:	10800b98 	cmpnei	r2,r2,46
8113ebe8:	10001a1e 	bne	r2,zero,8113ec54 <check_file_name_for_FAT16_compliance+0x164>
8113ebec:	e0fffb17 	ldw	r3,-20(fp)
8113ebf0:	e0bffc17 	ldw	r2,-16(fp)
8113ebf4:	18801926 	beq	r3,r2,8113ec5c <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113ebf8:	e0fffa17 	ldw	r3,-24(fp)
8113ebfc:	e0bffc17 	ldw	r2,-16(fp)
8113ec00:	1885c83a 	sub	r2,r3,r2
8113ec04:	10800110 	cmplti	r2,r2,4
8113ec08:	1000141e 	bne	r2,zero,8113ec5c <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113ec0c:	e0bffa17 	ldw	r2,-24(fp)
8113ec10:	e0ffff17 	ldw	r3,-4(fp)
8113ec14:	1885883a 	add	r2,r3,r2
8113ec18:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113ec1c:	10803fcc 	andi	r2,r2,255
8113ec20:	1080201c 	xori	r2,r2,128
8113ec24:	10bfe004 	addi	r2,r2,-128
8113ec28:	10801720 	cmpeqi	r2,r2,92
8113ec2c:	10000b1e 	bne	r2,zero,8113ec5c <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113ec30:	e0bffa17 	ldw	r2,-24(fp)
8113ec34:	e0ffff17 	ldw	r3,-4(fp)
8113ec38:	1885883a 	add	r2,r3,r2
8113ec3c:	10800003 	ldbu	r2,0(r2)
8113ec40:	10803fcc 	andi	r2,r2,255
8113ec44:	1080201c 	xori	r2,r2,128
8113ec48:	10bfe004 	addi	r2,r2,-128
8113ec4c:	10800be0 	cmpeqi	r2,r2,47
8113ec50:	1000021e 	bne	r2,zero,8113ec5c <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
8113ec54:	e03ffd15 	stw	zero,-12(fp)
            break;
8113ec58:	00002706 	br	8113ecf8 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8113ec5c:	e0bffa17 	ldw	r2,-24(fp)
8113ec60:	e0ffff17 	ldw	r3,-4(fp)
8113ec64:	1885883a 	add	r2,r3,r2
8113ec68:	10800003 	ldbu	r2,0(r2)
8113ec6c:	10803fcc 	andi	r2,r2,255
8113ec70:	1080201c 	xori	r2,r2,128
8113ec74:	10bfe004 	addi	r2,r2,-128
8113ec78:	10801720 	cmpeqi	r2,r2,92
8113ec7c:	1000091e 	bne	r2,zero,8113eca4 <check_file_name_for_FAT16_compliance+0x1b4>
8113ec80:	e0bffa17 	ldw	r2,-24(fp)
8113ec84:	e0ffff17 	ldw	r3,-4(fp)
8113ec88:	1885883a 	add	r2,r3,r2
8113ec8c:	10800003 	ldbu	r2,0(r2)
8113ec90:	10803fcc 	andi	r2,r2,255
8113ec94:	1080201c 	xori	r2,r2,128
8113ec98:	10bfe004 	addi	r2,r2,-128
8113ec9c:	10800bd8 	cmpnei	r2,r2,47
8113eca0:	1000041e 	bne	r2,zero,8113ecb4 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
8113eca4:	e0bffa17 	ldw	r2,-24(fp)
8113eca8:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
8113ecac:	e0bffa17 	ldw	r2,-24(fp)
8113ecb0:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
8113ecb4:	e0bffa17 	ldw	r2,-24(fp)
8113ecb8:	e0ffff17 	ldw	r3,-4(fp)
8113ecbc:	1885883a 	add	r2,r3,r2
8113ecc0:	10800003 	ldbu	r2,0(r2)
8113ecc4:	10803fcc 	andi	r2,r2,255
8113ecc8:	1080201c 	xori	r2,r2,128
8113eccc:	10bfe004 	addi	r2,r2,-128
8113ecd0:	10800b98 	cmpnei	r2,r2,46
8113ecd4:	1000021e 	bne	r2,zero,8113ece0 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8113ecd8:	e0bffa17 	ldw	r2,-24(fp)
8113ecdc:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8113ece0:	e0bffa17 	ldw	r2,-24(fp)
8113ece4:	10800044 	addi	r2,r2,1
8113ece8:	e0bffa15 	stw	r2,-24(fp)
8113ecec:	e0fffa17 	ldw	r3,-24(fp)
8113ecf0:	e0bffe17 	ldw	r2,-8(fp)
8113ecf4:	18bf9016 	blt	r3,r2,8113eb38 <__reset+0xfb11eb38>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8113ecf8:	e0bffe17 	ldw	r2,-8(fp)
8113ecfc:	10bfffc4 	addi	r2,r2,-1
8113ed00:	e0ffff17 	ldw	r3,-4(fp)
8113ed04:	1885883a 	add	r2,r3,r2
8113ed08:	10800003 	ldbu	r2,0(r2)
8113ed0c:	10803fcc 	andi	r2,r2,255
8113ed10:	1080201c 	xori	r2,r2,128
8113ed14:	10bfe004 	addi	r2,r2,-128
8113ed18:	10801720 	cmpeqi	r2,r2,92
8113ed1c:	10000a1e 	bne	r2,zero,8113ed48 <check_file_name_for_FAT16_compliance+0x258>
8113ed20:	e0bffe17 	ldw	r2,-8(fp)
8113ed24:	10bfffc4 	addi	r2,r2,-1
8113ed28:	e0ffff17 	ldw	r3,-4(fp)
8113ed2c:	1885883a 	add	r2,r3,r2
8113ed30:	10800003 	ldbu	r2,0(r2)
8113ed34:	10803fcc 	andi	r2,r2,255
8113ed38:	1080201c 	xori	r2,r2,128
8113ed3c:	10bfe004 	addi	r2,r2,-128
8113ed40:	10800bd8 	cmpnei	r2,r2,47
8113ed44:	1000011e 	bne	r2,zero,8113ed4c <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8113ed48:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8113ed4c:	e0bffd17 	ldw	r2,-12(fp)
}
8113ed50:	e037883a 	mov	sp,fp
8113ed54:	dfc00117 	ldw	ra,4(sp)
8113ed58:	df000017 	ldw	fp,0(sp)
8113ed5c:	dec00204 	addi	sp,sp,8
8113ed60:	f800283a 	ret

8113ed64 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8113ed64:	defffb04 	addi	sp,sp,-20
8113ed68:	de00012e 	bgeu	sp,et,8113ed70 <get_dir_divider_location+0xc>
8113ed6c:	003b68fa 	trap	3
8113ed70:	dfc00415 	stw	ra,16(sp)
8113ed74:	df000315 	stw	fp,12(sp)
8113ed78:	df000304 	addi	fp,sp,12
8113ed7c:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
8113ed80:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8113ed84:	e13fff17 	ldw	r4,-4(fp)
8113ed88:	111dcc00 	call	8111dcc0 <strlen>
8113ed8c:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
8113ed90:	e03ffd15 	stw	zero,-12(fp)
8113ed94:	00001506 	br	8113edec <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8113ed98:	e0bffd17 	ldw	r2,-12(fp)
8113ed9c:	e0ffff17 	ldw	r3,-4(fp)
8113eda0:	1885883a 	add	r2,r3,r2
8113eda4:	10800003 	ldbu	r2,0(r2)
8113eda8:	10803fcc 	andi	r2,r2,255
8113edac:	1080201c 	xori	r2,r2,128
8113edb0:	10bfe004 	addi	r2,r2,-128
8113edb4:	10801720 	cmpeqi	r2,r2,92
8113edb8:	10000f1e 	bne	r2,zero,8113edf8 <get_dir_divider_location+0x94>
8113edbc:	e0bffd17 	ldw	r2,-12(fp)
8113edc0:	e0ffff17 	ldw	r3,-4(fp)
8113edc4:	1885883a 	add	r2,r3,r2
8113edc8:	10800003 	ldbu	r2,0(r2)
8113edcc:	10803fcc 	andi	r2,r2,255
8113edd0:	1080201c 	xori	r2,r2,128
8113edd4:	10bfe004 	addi	r2,r2,-128
8113edd8:	10800be0 	cmpeqi	r2,r2,47
8113eddc:	1000061e 	bne	r2,zero,8113edf8 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
8113ede0:	e0bffd17 	ldw	r2,-12(fp)
8113ede4:	10800044 	addi	r2,r2,1
8113ede8:	e0bffd15 	stw	r2,-12(fp)
8113edec:	e0fffd17 	ldw	r3,-12(fp)
8113edf0:	e0bffe17 	ldw	r2,-8(fp)
8113edf4:	18bfe816 	blt	r3,r2,8113ed98 <__reset+0xfb11ed98>
        {
            break;
        }
    }
    
    if (index == length)
8113edf8:	e0fffd17 	ldw	r3,-12(fp)
8113edfc:	e0bffe17 	ldw	r2,-8(fp)
8113ee00:	1880021e 	bne	r3,r2,8113ee0c <get_dir_divider_location+0xa8>
    {
        index = -1;
8113ee04:	00bfffc4 	movi	r2,-1
8113ee08:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8113ee0c:	e0bffd17 	ldw	r2,-12(fp)
}
8113ee10:	e037883a 	mov	sp,fp
8113ee14:	dfc00117 	ldw	ra,4(sp)
8113ee18:	df000017 	ldw	fp,0(sp)
8113ee1c:	dec00204 	addi	sp,sp,8
8113ee20:	f800283a 	ret

8113ee24 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
8113ee24:	defffa04 	addi	sp,sp,-24
8113ee28:	de00012e 	bgeu	sp,et,8113ee30 <match_file_record_to_name_ext+0xc>
8113ee2c:	003b68fa 	trap	3
8113ee30:	df000515 	stw	fp,20(sp)
8113ee34:	df000504 	addi	fp,sp,20
8113ee38:	e13ffd15 	stw	r4,-12(fp)
8113ee3c:	e17ffe15 	stw	r5,-8(fp)
8113ee40:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8113ee44:	00800044 	movi	r2,1
8113ee48:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8113ee4c:	e03ffc15 	stw	zero,-16(fp)
8113ee50:	00004606 	br	8113ef6c <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8113ee54:	e0fffd17 	ldw	r3,-12(fp)
8113ee58:	e0bffc17 	ldw	r2,-16(fp)
8113ee5c:	1885883a 	add	r2,r3,r2
8113ee60:	10800003 	ldbu	r2,0(r2)
8113ee64:	10803fcc 	andi	r2,r2,255
8113ee68:	10801870 	cmpltui	r2,r2,97
8113ee6c:	1000101e 	bne	r2,zero,8113eeb0 <match_file_record_to_name_ext+0x8c>
8113ee70:	e0fffd17 	ldw	r3,-12(fp)
8113ee74:	e0bffc17 	ldw	r2,-16(fp)
8113ee78:	1885883a 	add	r2,r3,r2
8113ee7c:	10800003 	ldbu	r2,0(r2)
8113ee80:	10803fcc 	andi	r2,r2,255
8113ee84:	10801ee8 	cmpgeui	r2,r2,123
8113ee88:	1000091e 	bne	r2,zero,8113eeb0 <match_file_record_to_name_ext+0x8c>
8113ee8c:	e0fffd17 	ldw	r3,-12(fp)
8113ee90:	e0bffc17 	ldw	r2,-16(fp)
8113ee94:	1885883a 	add	r2,r3,r2
8113ee98:	10800003 	ldbu	r2,0(r2)
8113ee9c:	10bff804 	addi	r2,r2,-32
8113eea0:	10c03fcc 	andi	r3,r2,255
8113eea4:	18c0201c 	xori	r3,r3,128
8113eea8:	18ffe004 	addi	r3,r3,-128
8113eeac:	00000706 	br	8113eecc <match_file_record_to_name_ext+0xa8>
8113eeb0:	e0fffd17 	ldw	r3,-12(fp)
8113eeb4:	e0bffc17 	ldw	r2,-16(fp)
8113eeb8:	1885883a 	add	r2,r3,r2
8113eebc:	10800003 	ldbu	r2,0(r2)
8113eec0:	10c03fcc 	andi	r3,r2,255
8113eec4:	18c0201c 	xori	r3,r3,128
8113eec8:	18ffe004 	addi	r3,r3,-128
8113eecc:	e0bffc17 	ldw	r2,-16(fp)
8113eed0:	e13ffe17 	ldw	r4,-8(fp)
8113eed4:	2085883a 	add	r2,r4,r2
8113eed8:	10800003 	ldbu	r2,0(r2)
8113eedc:	10803fcc 	andi	r2,r2,255
8113eee0:	1080201c 	xori	r2,r2,128
8113eee4:	10bfe004 	addi	r2,r2,-128
8113eee8:	10801850 	cmplti	r2,r2,97
8113eeec:	1000121e 	bne	r2,zero,8113ef38 <match_file_record_to_name_ext+0x114>
8113eef0:	e0bffc17 	ldw	r2,-16(fp)
8113eef4:	e13ffe17 	ldw	r4,-8(fp)
8113eef8:	2085883a 	add	r2,r4,r2
8113eefc:	10800003 	ldbu	r2,0(r2)
8113ef00:	10803fcc 	andi	r2,r2,255
8113ef04:	1080201c 	xori	r2,r2,128
8113ef08:	10bfe004 	addi	r2,r2,-128
8113ef0c:	10801ec8 	cmpgei	r2,r2,123
8113ef10:	1000091e 	bne	r2,zero,8113ef38 <match_file_record_to_name_ext+0x114>
8113ef14:	e0bffc17 	ldw	r2,-16(fp)
8113ef18:	e13ffe17 	ldw	r4,-8(fp)
8113ef1c:	2085883a 	add	r2,r4,r2
8113ef20:	10800003 	ldbu	r2,0(r2)
8113ef24:	10bff804 	addi	r2,r2,-32
8113ef28:	10803fcc 	andi	r2,r2,255
8113ef2c:	1080201c 	xori	r2,r2,128
8113ef30:	10bfe004 	addi	r2,r2,-128
8113ef34:	00000706 	br	8113ef54 <match_file_record_to_name_ext+0x130>
8113ef38:	e0bffc17 	ldw	r2,-16(fp)
8113ef3c:	e13ffe17 	ldw	r4,-8(fp)
8113ef40:	2085883a 	add	r2,r4,r2
8113ef44:	10800003 	ldbu	r2,0(r2)
8113ef48:	10803fcc 	andi	r2,r2,255
8113ef4c:	1080201c 	xori	r2,r2,128
8113ef50:	10bfe004 	addi	r2,r2,-128
8113ef54:	18800226 	beq	r3,r2,8113ef60 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8113ef58:	e03ffb15 	stw	zero,-20(fp)
			break;
8113ef5c:	00000606 	br	8113ef78 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
8113ef60:	e0bffc17 	ldw	r2,-16(fp)
8113ef64:	10800044 	addi	r2,r2,1
8113ef68:	e0bffc15 	stw	r2,-16(fp)
8113ef6c:	e0bffc17 	ldw	r2,-16(fp)
8113ef70:	10800210 	cmplti	r2,r2,8
8113ef74:	103fb71e 	bne	r2,zero,8113ee54 <__reset+0xfb11ee54>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113ef78:	e03ffc15 	stw	zero,-16(fp)
8113ef7c:	00004a06 	br	8113f0a8 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
8113ef80:	e0fffd17 	ldw	r3,-12(fp)
8113ef84:	e0bffc17 	ldw	r2,-16(fp)
8113ef88:	1885883a 	add	r2,r3,r2
8113ef8c:	10800204 	addi	r2,r2,8
8113ef90:	10800003 	ldbu	r2,0(r2)
8113ef94:	10803fcc 	andi	r2,r2,255
8113ef98:	10801870 	cmpltui	r2,r2,97
8113ef9c:	1000121e 	bne	r2,zero,8113efe8 <match_file_record_to_name_ext+0x1c4>
8113efa0:	e0fffd17 	ldw	r3,-12(fp)
8113efa4:	e0bffc17 	ldw	r2,-16(fp)
8113efa8:	1885883a 	add	r2,r3,r2
8113efac:	10800204 	addi	r2,r2,8
8113efb0:	10800003 	ldbu	r2,0(r2)
8113efb4:	10803fcc 	andi	r2,r2,255
8113efb8:	10801ee8 	cmpgeui	r2,r2,123
8113efbc:	10000a1e 	bne	r2,zero,8113efe8 <match_file_record_to_name_ext+0x1c4>
8113efc0:	e0fffd17 	ldw	r3,-12(fp)
8113efc4:	e0bffc17 	ldw	r2,-16(fp)
8113efc8:	1885883a 	add	r2,r3,r2
8113efcc:	10800204 	addi	r2,r2,8
8113efd0:	10800003 	ldbu	r2,0(r2)
8113efd4:	10bff804 	addi	r2,r2,-32
8113efd8:	10c03fcc 	andi	r3,r2,255
8113efdc:	18c0201c 	xori	r3,r3,128
8113efe0:	18ffe004 	addi	r3,r3,-128
8113efe4:	00000806 	br	8113f008 <match_file_record_to_name_ext+0x1e4>
8113efe8:	e0fffd17 	ldw	r3,-12(fp)
8113efec:	e0bffc17 	ldw	r2,-16(fp)
8113eff0:	1885883a 	add	r2,r3,r2
8113eff4:	10800204 	addi	r2,r2,8
8113eff8:	10800003 	ldbu	r2,0(r2)
8113effc:	10c03fcc 	andi	r3,r2,255
8113f000:	18c0201c 	xori	r3,r3,128
8113f004:	18ffe004 	addi	r3,r3,-128
8113f008:	e0bffc17 	ldw	r2,-16(fp)
8113f00c:	e13fff17 	ldw	r4,-4(fp)
8113f010:	2085883a 	add	r2,r4,r2
8113f014:	10800003 	ldbu	r2,0(r2)
8113f018:	10803fcc 	andi	r2,r2,255
8113f01c:	1080201c 	xori	r2,r2,128
8113f020:	10bfe004 	addi	r2,r2,-128
8113f024:	10801850 	cmplti	r2,r2,97
8113f028:	1000121e 	bne	r2,zero,8113f074 <match_file_record_to_name_ext+0x250>
8113f02c:	e0bffc17 	ldw	r2,-16(fp)
8113f030:	e13fff17 	ldw	r4,-4(fp)
8113f034:	2085883a 	add	r2,r4,r2
8113f038:	10800003 	ldbu	r2,0(r2)
8113f03c:	10803fcc 	andi	r2,r2,255
8113f040:	1080201c 	xori	r2,r2,128
8113f044:	10bfe004 	addi	r2,r2,-128
8113f048:	10801ec8 	cmpgei	r2,r2,123
8113f04c:	1000091e 	bne	r2,zero,8113f074 <match_file_record_to_name_ext+0x250>
8113f050:	e0bffc17 	ldw	r2,-16(fp)
8113f054:	e13fff17 	ldw	r4,-4(fp)
8113f058:	2085883a 	add	r2,r4,r2
8113f05c:	10800003 	ldbu	r2,0(r2)
8113f060:	10bff804 	addi	r2,r2,-32
8113f064:	10803fcc 	andi	r2,r2,255
8113f068:	1080201c 	xori	r2,r2,128
8113f06c:	10bfe004 	addi	r2,r2,-128
8113f070:	00000706 	br	8113f090 <match_file_record_to_name_ext+0x26c>
8113f074:	e0bffc17 	ldw	r2,-16(fp)
8113f078:	e13fff17 	ldw	r4,-4(fp)
8113f07c:	2085883a 	add	r2,r4,r2
8113f080:	10800003 	ldbu	r2,0(r2)
8113f084:	10803fcc 	andi	r2,r2,255
8113f088:	1080201c 	xori	r2,r2,128
8113f08c:	10bfe004 	addi	r2,r2,-128
8113f090:	18800226 	beq	r3,r2,8113f09c <match_file_record_to_name_ext+0x278>
        {
            match = false;
8113f094:	e03ffb15 	stw	zero,-20(fp)
			break;
8113f098:	00000606 	br	8113f0b4 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113f09c:	e0bffc17 	ldw	r2,-16(fp)
8113f0a0:	10800044 	addi	r2,r2,1
8113f0a4:	e0bffc15 	stw	r2,-16(fp)
8113f0a8:	e0bffc17 	ldw	r2,-16(fp)
8113f0ac:	108000d0 	cmplti	r2,r2,3
8113f0b0:	103fb31e 	bne	r2,zero,8113ef80 <__reset+0xfb11ef80>
        {
            match = false;
			break;
        }
    }
	return match;
8113f0b4:	e0bffb17 	ldw	r2,-20(fp)
}
8113f0b8:	e037883a 	mov	sp,fp
8113f0bc:	df000017 	ldw	fp,0(sp)
8113f0c0:	dec00104 	addi	sp,sp,4
8113f0c4:	f800283a 	ret

8113f0c8 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8113f0c8:	deffe704 	addi	sp,sp,-100
8113f0cc:	de00012e 	bgeu	sp,et,8113f0d4 <get_home_directory_cluster_for_file+0xc>
8113f0d0:	003b68fa 	trap	3
8113f0d4:	dfc01815 	stw	ra,96(sp)
8113f0d8:	df001715 	stw	fp,92(sp)
8113f0dc:	df001704 	addi	fp,sp,92
8113f0e0:	e13ffd15 	stw	r4,-12(fp)
8113f0e4:	e17ffe15 	stw	r5,-8(fp)
8113f0e8:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
8113f0ec:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
8113f0f0:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
8113f0f4:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8113f0f8:	e13ffd17 	ldw	r4,-12(fp)
8113f0fc:	113ed640 	call	8113ed64 <get_dir_divider_location>
8113f100:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
8113f104:	00012f06 	br	8113f5c4 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113f108:	00800804 	movi	r2,32
8113f10c:	e0bff905 	stb	r2,-28(fp)
8113f110:	00800804 	movi	r2,32
8113f114:	e0bff945 	stb	r2,-27(fp)
8113f118:	00800804 	movi	r2,32
8113f11c:	e0bff985 	stb	r2,-26(fp)
8113f120:	00800804 	movi	r2,32
8113f124:	e0bff9c5 	stb	r2,-25(fp)
8113f128:	00800804 	movi	r2,32
8113f12c:	e0bffa05 	stb	r2,-24(fp)
8113f130:	00800804 	movi	r2,32
8113f134:	e0bffa45 	stb	r2,-23(fp)
8113f138:	00800804 	movi	r2,32
8113f13c:	e0bffa85 	stb	r2,-22(fp)
8113f140:	00800804 	movi	r2,32
8113f144:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
8113f148:	00800804 	movi	r2,32
8113f14c:	e0bffb05 	stb	r2,-20(fp)
8113f150:	00800804 	movi	r2,32
8113f154:	e0bffb45 	stb	r2,-19(fp)
8113f158:	00800804 	movi	r2,32
8113f15c:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
8113f160:	00bfffc4 	movi	r2,-1
8113f164:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
8113f168:	e0bfea17 	ldw	r2,-88(fp)
8113f16c:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113f170:	e03fec15 	stw	zero,-80(fp)
8113f174:	00002d06 	br	8113f22c <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
8113f178:	e0ffec17 	ldw	r3,-80(fp)
8113f17c:	e0bfed17 	ldw	r2,-76(fp)
8113f180:	1885883a 	add	r2,r3,r2
8113f184:	1007883a 	mov	r3,r2
8113f188:	e0bffd17 	ldw	r2,-12(fp)
8113f18c:	10c5883a 	add	r2,r2,r3
8113f190:	10800003 	ldbu	r2,0(r2)
8113f194:	10803fcc 	andi	r2,r2,255
8113f198:	1080201c 	xori	r2,r2,128
8113f19c:	10bfe004 	addi	r2,r2,-128
8113f1a0:	10800b98 	cmpnei	r2,r2,46
8113f1a4:	1000031e 	bne	r2,zero,8113f1b4 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8113f1a8:	e0bfec17 	ldw	r2,-80(fp)
8113f1ac:	e0bfee15 	stw	r2,-72(fp)
8113f1b0:	00001b06 	br	8113f220 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
8113f1b4:	e0bfee17 	ldw	r2,-72(fp)
8113f1b8:	10000c0e 	bge	r2,zero,8113f1ec <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
8113f1bc:	e0ffec17 	ldw	r3,-80(fp)
8113f1c0:	e0bfed17 	ldw	r2,-76(fp)
8113f1c4:	1885883a 	add	r2,r3,r2
8113f1c8:	1007883a 	mov	r3,r2
8113f1cc:	e0bffd17 	ldw	r2,-12(fp)
8113f1d0:	10c5883a 	add	r2,r2,r3
8113f1d4:	10c00003 	ldbu	r3,0(r2)
8113f1d8:	e13ff904 	addi	r4,fp,-28
8113f1dc:	e0bfec17 	ldw	r2,-80(fp)
8113f1e0:	2085883a 	add	r2,r4,r2
8113f1e4:	10c00005 	stb	r3,0(r2)
8113f1e8:	00000d06 	br	8113f220 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
8113f1ec:	e0ffec17 	ldw	r3,-80(fp)
8113f1f0:	e0bfee17 	ldw	r2,-72(fp)
8113f1f4:	1885c83a 	sub	r2,r3,r2
8113f1f8:	e13fec17 	ldw	r4,-80(fp)
8113f1fc:	e0ffed17 	ldw	r3,-76(fp)
8113f200:	20c7883a 	add	r3,r4,r3
8113f204:	1809883a 	mov	r4,r3
8113f208:	e0fffd17 	ldw	r3,-12(fp)
8113f20c:	1907883a 	add	r3,r3,r4
8113f210:	18c00003 	ldbu	r3,0(r3)
8113f214:	e13ffb04 	addi	r4,fp,-20
8113f218:	2085883a 	add	r2,r4,r2
8113f21c:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113f220:	e0bfec17 	ldw	r2,-80(fp)
8113f224:	10800044 	addi	r2,r2,1
8113f228:	e0bfec15 	stw	r2,-80(fp)
8113f22c:	e0ffec17 	ldw	r3,-80(fp)
8113f230:	e0bfeb17 	ldw	r2,-84(fp)
8113f234:	18bfd016 	blt	r3,r2,8113f178 <__reset+0xfb11f178>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
8113f238:	e0bfea17 	ldw	r2,-88(fp)
8113f23c:	10005c1e 	bne	r2,zero,8113f3b0 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113f240:	00a045b4 	movhi	r2,33046
8113f244:	109e3d04 	addi	r2,r2,30964
8113f248:	1080050b 	ldhu	r2,20(r2)
8113f24c:	10bfffcc 	andi	r2,r2,65535
8113f250:	1006917a 	slli	r3,r2,5
8113f254:	00a045b4 	movhi	r2,33046
8113f258:	109e3d04 	addi	r2,r2,30964
8113f25c:	1080030b 	ldhu	r2,12(r2)
8113f260:	10bfffcc 	andi	r2,r2,65535
8113f264:	1885283a 	div	r2,r3,r2
8113f268:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113f26c:	e03ff015 	stw	zero,-64(fp)
8113f270:	00003b06 	br	8113f360 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8113f274:	00a045b4 	movhi	r2,33046
8113f278:	109e3d04 	addi	r2,r2,30964
8113f27c:	10c01317 	ldw	r3,76(r2)
8113f280:	e0bff017 	ldw	r2,-64(fp)
8113f284:	1885883a 	add	r2,r3,r2
8113f288:	1007883a 	mov	r3,r2
8113f28c:	d0a0ac17 	ldw	r2,-32080(gp)
8113f290:	100b883a 	mov	r5,r2
8113f294:	1809883a 	mov	r4,r3
8113f298:	113d9600 	call	8113d960 <Read_Sector_Data>
8113f29c:	10003426 	beq	r2,zero,8113f370 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113f2a0:	e03ff115 	stw	zero,-60(fp)
8113f2a4:	00002506 	br	8113f33c <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113f2a8:	e0bff117 	ldw	r2,-60(fp)
8113f2ac:	1004917a 	slli	r2,r2,5
8113f2b0:	e0fff017 	ldw	r3,-64(fp)
8113f2b4:	180f883a 	mov	r7,r3
8113f2b8:	000d883a 	mov	r6,zero
8113f2bc:	e17fff17 	ldw	r5,-4(fp)
8113f2c0:	1009883a 	mov	r4,r2
8113f2c4:	113dd900 	call	8113dd90 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113f2c8:	e0bfff17 	ldw	r2,-4(fp)
8113f2cc:	10800003 	ldbu	r2,0(r2)
8113f2d0:	10803fcc 	andi	r2,r2,255
8113f2d4:	10803960 	cmpeqi	r2,r2,229
8113f2d8:	1000151e 	bne	r2,zero,8113f330 <get_home_directory_cluster_for_file+0x268>
8113f2dc:	e0bfff17 	ldw	r2,-4(fp)
8113f2e0:	10800003 	ldbu	r2,0(r2)
8113f2e4:	10803fcc 	andi	r2,r2,255
8113f2e8:	10001126 	beq	r2,zero,8113f330 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113f2ec:	e0fffb04 	addi	r3,fp,-20
8113f2f0:	e0bff904 	addi	r2,fp,-28
8113f2f4:	180d883a 	mov	r6,r3
8113f2f8:	100b883a 	mov	r5,r2
8113f2fc:	e13fff17 	ldw	r4,-4(fp)
8113f300:	113ee240 	call	8113ee24 <match_file_record_to_name_ext>
8113f304:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8113f308:	e0bff817 	ldw	r2,-32(fp)
8113f30c:	10000826 	beq	r2,zero,8113f330 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
8113f310:	e0bfff17 	ldw	r2,-4(fp)
8113f314:	1080058b 	ldhu	r2,22(r2)
8113f318:	10bfffcc 	andi	r2,r2,65535
8113f31c:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
8113f320:	e0bfff17 	ldw	r2,-4(fp)
8113f324:	00c00044 	movi	r3,1
8113f328:	10c00a15 	stw	r3,40(r2)
                                break;
8113f32c:	00000606 	br	8113f348 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113f330:	e0bff117 	ldw	r2,-60(fp)
8113f334:	10800044 	addi	r2,r2,1
8113f338:	e0bff115 	stw	r2,-60(fp)
8113f33c:	e0bff117 	ldw	r2,-60(fp)
8113f340:	10800410 	cmplti	r2,r2,16
8113f344:	103fd81e 	bne	r2,zero,8113f2a8 <__reset+0xfb11f2a8>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
8113f348:	e0ffef17 	ldw	r3,-68(fp)
8113f34c:	e0bfea17 	ldw	r2,-88(fp)
8113f350:	1880091e 	bne	r3,r2,8113f378 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113f354:	e0bff017 	ldw	r2,-64(fp)
8113f358:	10800044 	addi	r2,r2,1
8113f35c:	e0bff015 	stw	r2,-64(fp)
8113f360:	e0fff017 	ldw	r3,-64(fp)
8113f364:	e0bff717 	ldw	r2,-36(fp)
8113f368:	18bfc216 	blt	r3,r2,8113f274 <__reset+0xfb11f274>
8113f36c:	00000306 	br	8113f37c <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
8113f370:	0001883a 	nop
8113f374:	00000106 	br	8113f37c <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
8113f378:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
8113f37c:	e0ffef17 	ldw	r3,-68(fp)
8113f380:	e0bfea17 	ldw	r2,-88(fp)
8113f384:	18800826 	beq	r3,r2,8113f3a8 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113f388:	e0bfef17 	ldw	r2,-68(fp)
8113f38c:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113f390:	e0ffed17 	ldw	r3,-76(fp)
8113f394:	e0bfeb17 	ldw	r2,-84(fp)
8113f398:	1885883a 	add	r2,r3,r2
8113f39c:	10800044 	addi	r2,r2,1
8113f3a0:	e0bfed15 	stw	r2,-76(fp)
8113f3a4:	00007d06 	br	8113f59c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113f3a8:	0005883a 	mov	r2,zero
8113f3ac:	00009106 	br	8113f5f4 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
8113f3b0:	e0bfea17 	ldw	r2,-88(fp)
8113f3b4:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113f3b8:	e0bff417 	ldw	r2,-48(fp)
8113f3bc:	10ffff84 	addi	r3,r2,-2
8113f3c0:	00a045b4 	movhi	r2,33046
8113f3c4:	109e3d04 	addi	r2,r2,30964
8113f3c8:	10800383 	ldbu	r2,14(r2)
8113f3cc:	10803fcc 	andi	r2,r2,255
8113f3d0:	1885383a 	mul	r2,r3,r2
8113f3d4:	1007883a 	mov	r3,r2
8113f3d8:	00a045b4 	movhi	r2,33046
8113f3dc:	109e3d04 	addi	r2,r2,30964
8113f3e0:	10801417 	ldw	r2,80(r2)
8113f3e4:	1885883a 	add	r2,r3,r2
8113f3e8:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f3ec:	e03ff215 	stw	zero,-56(fp)
8113f3f0:	00003606 	br	8113f4cc <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113f3f4:	e0fff217 	ldw	r3,-56(fp)
8113f3f8:	e0bff517 	ldw	r2,-44(fp)
8113f3fc:	1885883a 	add	r2,r3,r2
8113f400:	d0e0ac17 	ldw	r3,-32080(gp)
8113f404:	180b883a 	mov	r5,r3
8113f408:	1009883a 	mov	r4,r2
8113f40c:	113d9600 	call	8113d960 <Read_Sector_Data>
8113f410:	10003526 	beq	r2,zero,8113f4e8 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113f414:	e03ff315 	stw	zero,-52(fp)
8113f418:	00002306 	br	8113f4a8 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113f41c:	e0bff317 	ldw	r2,-52(fp)
8113f420:	1004917a 	slli	r2,r2,5
8113f424:	e0fff417 	ldw	r3,-48(fp)
8113f428:	e13ff217 	ldw	r4,-56(fp)
8113f42c:	200f883a 	mov	r7,r4
8113f430:	180d883a 	mov	r6,r3
8113f434:	e17fff17 	ldw	r5,-4(fp)
8113f438:	1009883a 	mov	r4,r2
8113f43c:	113dd900 	call	8113dd90 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113f440:	e0bfff17 	ldw	r2,-4(fp)
8113f444:	10800003 	ldbu	r2,0(r2)
8113f448:	10803fcc 	andi	r2,r2,255
8113f44c:	10803960 	cmpeqi	r2,r2,229
8113f450:	1000121e 	bne	r2,zero,8113f49c <get_home_directory_cluster_for_file+0x3d4>
8113f454:	e0bfff17 	ldw	r2,-4(fp)
8113f458:	10800003 	ldbu	r2,0(r2)
8113f45c:	10803fcc 	andi	r2,r2,255
8113f460:	10000e26 	beq	r2,zero,8113f49c <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8113f464:	e0fffb04 	addi	r3,fp,-20
8113f468:	e0bff904 	addi	r2,fp,-28
8113f46c:	180d883a 	mov	r6,r3
8113f470:	100b883a 	mov	r5,r2
8113f474:	e13fff17 	ldw	r4,-4(fp)
8113f478:	113ee240 	call	8113ee24 <match_file_record_to_name_ext>
8113f47c:	e0bff615 	stw	r2,-40(fp)
                                if (match)
8113f480:	e0bff617 	ldw	r2,-40(fp)
8113f484:	10000526 	beq	r2,zero,8113f49c <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8113f488:	e0bfff17 	ldw	r2,-4(fp)
8113f48c:	1080058b 	ldhu	r2,22(r2)
8113f490:	10bfffcc 	andi	r2,r2,65535
8113f494:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8113f498:	00000606 	br	8113f4b4 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113f49c:	e0bff317 	ldw	r2,-52(fp)
8113f4a0:	10800044 	addi	r2,r2,1
8113f4a4:	e0bff315 	stw	r2,-52(fp)
8113f4a8:	e0bff317 	ldw	r2,-52(fp)
8113f4ac:	10800410 	cmplti	r2,r2,16
8113f4b0:	103fda1e 	bne	r2,zero,8113f41c <__reset+0xfb11f41c>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
8113f4b4:	e0ffef17 	ldw	r3,-68(fp)
8113f4b8:	e0bfea17 	ldw	r2,-88(fp)
8113f4bc:	18800c1e 	bne	r3,r2,8113f4f0 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f4c0:	e0bff217 	ldw	r2,-56(fp)
8113f4c4:	10800044 	addi	r2,r2,1
8113f4c8:	e0bff215 	stw	r2,-56(fp)
8113f4cc:	00a045b4 	movhi	r2,33046
8113f4d0:	109e3d04 	addi	r2,r2,30964
8113f4d4:	10800383 	ldbu	r2,14(r2)
8113f4d8:	10803fcc 	andi	r2,r2,255
8113f4dc:	e0fff217 	ldw	r3,-56(fp)
8113f4e0:	18bfc416 	blt	r3,r2,8113f3f4 <__reset+0xfb11f3f4>
8113f4e4:	00000306 	br	8113f4f4 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
8113f4e8:	0001883a 	nop
8113f4ec:	00000106 	br	8113f4f4 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
8113f4f0:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
8113f4f4:	e0ffef17 	ldw	r3,-68(fp)
8113f4f8:	e0bfea17 	ldw	r2,-88(fp)
8113f4fc:	1880141e 	bne	r3,r2,8113f550 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
8113f500:	e0bfef17 	ldw	r2,-68(fp)
8113f504:	e0fffc04 	addi	r3,fp,-16
8113f508:	180b883a 	mov	r5,r3
8113f50c:	1009883a 	mov	r4,r2
8113f510:	113da400 	call	8113da40 <get_cluster_flag>
8113f514:	10000c26 	beq	r2,zero,8113f548 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113f518:	e0bffc0b 	ldhu	r2,-16(fp)
8113f51c:	10bfffcc 	andi	r2,r2,65535
8113f520:	10fffe0c 	andi	r3,r2,65528
8113f524:	00bffe14 	movui	r2,65528
8113f528:	1880021e 	bne	r3,r2,8113f534 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
8113f52c:	0005883a 	mov	r2,zero
8113f530:	00003006 	br	8113f5f4 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
8113f534:	e0bffc0b 	ldhu	r2,-16(fp)
8113f538:	10bfffcc 	andi	r2,r2,65535
8113f53c:	10bffe0c 	andi	r2,r2,65528
8113f540:	e0bfef15 	stw	r2,-68(fp)
8113f544:	00000206 	br	8113f550 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
8113f548:	0005883a 	mov	r2,zero
8113f54c:	00002906 	br	8113f5f4 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8113f550:	e0bff417 	ldw	r2,-48(fp)
8113f554:	00fffdd4 	movui	r3,65527
8113f558:	18800316 	blt	r3,r2,8113f568 <get_home_directory_cluster_for_file+0x4a0>
8113f55c:	e0ffef17 	ldw	r3,-68(fp)
8113f560:	e0bfea17 	ldw	r2,-88(fp)
8113f564:	18bf9426 	beq	r3,r2,8113f3b8 <__reset+0xfb11f3b8>
            if (new_cluster != home_dir_cluster)
8113f568:	e0ffef17 	ldw	r3,-68(fp)
8113f56c:	e0bfea17 	ldw	r2,-88(fp)
8113f570:	18800826 	beq	r3,r2,8113f594 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113f574:	e0bfef17 	ldw	r2,-68(fp)
8113f578:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113f57c:	e0ffed17 	ldw	r3,-76(fp)
8113f580:	e0bfeb17 	ldw	r2,-84(fp)
8113f584:	1885883a 	add	r2,r3,r2
8113f588:	10800044 	addi	r2,r2,1
8113f58c:	e0bfed15 	stw	r2,-76(fp)
8113f590:	00000206 	br	8113f59c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113f594:	0005883a 	mov	r2,zero
8113f598:	00001606 	br	8113f5f4 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
8113f59c:	e0bfed17 	ldw	r2,-76(fp)
8113f5a0:	e0fffd17 	ldw	r3,-12(fp)
8113f5a4:	1885883a 	add	r2,r3,r2
8113f5a8:	1009883a 	mov	r4,r2
8113f5ac:	113ed640 	call	8113ed64 <get_dir_divider_location>
8113f5b0:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
8113f5b4:	e0bfeb17 	ldw	r2,-84(fp)
8113f5b8:	1000020e 	bge	r2,zero,8113f5c4 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
8113f5bc:	00800044 	movi	r2,1
8113f5c0:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
8113f5c4:	e0bfeb17 	ldw	r2,-84(fp)
8113f5c8:	00becf16 	blt	zero,r2,8113f108 <__reset+0xfb11f108>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
8113f5cc:	e0bffe17 	ldw	r2,-8(fp)
8113f5d0:	e0ffea17 	ldw	r3,-88(fp)
8113f5d4:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
8113f5d8:	e0bfea17 	ldw	r2,-88(fp)
8113f5dc:	1000041e 	bne	r2,zero,8113f5f0 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
8113f5e0:	e0bfff17 	ldw	r2,-4(fp)
8113f5e4:	10000a15 	stw	zero,40(r2)
		result = true;
8113f5e8:	00800044 	movi	r2,1
8113f5ec:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
8113f5f0:	e0bfe917 	ldw	r2,-92(fp)
}
8113f5f4:	e037883a 	mov	sp,fp
8113f5f8:	dfc00117 	ldw	ra,4(sp)
8113f5fc:	df000017 	ldw	fp,0(sp)
8113f600:	dec00204 	addi	sp,sp,8
8113f604:	f800283a 	ret

8113f608 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
8113f608:	deffe804 	addi	sp,sp,-96
8113f60c:	de00012e 	bgeu	sp,et,8113f614 <find_file_in_directory+0xc>
8113f610:	003b68fa 	trap	3
8113f614:	dfc01715 	stw	ra,92(sp)
8113f618:	df001615 	stw	fp,88(sp)
8113f61c:	df001604 	addi	fp,sp,88
8113f620:	e13ffd15 	stw	r4,-12(fp)
8113f624:	e17ffe15 	stw	r5,-8(fp)
8113f628:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
8113f62c:	e13ffe17 	ldw	r4,-8(fp)
8113f630:	113ed640 	call	8113ed64 <get_dir_divider_location>
8113f634:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
8113f638:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113f63c:	00800804 	movi	r2,32
8113f640:	e0bff905 	stb	r2,-28(fp)
8113f644:	00800804 	movi	r2,32
8113f648:	e0bff945 	stb	r2,-27(fp)
8113f64c:	00800804 	movi	r2,32
8113f650:	e0bff985 	stb	r2,-26(fp)
8113f654:	00800804 	movi	r2,32
8113f658:	e0bff9c5 	stb	r2,-25(fp)
8113f65c:	00800804 	movi	r2,32
8113f660:	e0bffa05 	stb	r2,-24(fp)
8113f664:	00800804 	movi	r2,32
8113f668:	e0bffa45 	stb	r2,-23(fp)
8113f66c:	00800804 	movi	r2,32
8113f670:	e0bffa85 	stb	r2,-22(fp)
8113f674:	00800804 	movi	r2,32
8113f678:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
8113f67c:	00800804 	movi	r2,32
8113f680:	e0bffb05 	stb	r2,-20(fp)
8113f684:	00800804 	movi	r2,32
8113f688:	e0bffb45 	stb	r2,-19(fp)
8113f68c:	00800804 	movi	r2,32
8113f690:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
8113f694:	00bfffc4 	movi	r2,-1
8113f698:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
8113f69c:	e0bffd17 	ldw	r2,-12(fp)
8113f6a0:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
8113f6a4:	e13ffe17 	ldw	r4,-8(fp)
8113f6a8:	111dcc00 	call	8111dcc0 <strlen>
8113f6ac:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
8113f6b0:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8113f6b4:	00000b06 	br	8113f6e4 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8113f6b8:	e0ffeb17 	ldw	r3,-84(fp)
8113f6bc:	e0bfea17 	ldw	r2,-88(fp)
8113f6c0:	1885883a 	add	r2,r3,r2
8113f6c4:	10800044 	addi	r2,r2,1
8113f6c8:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
8113f6cc:	e0bfeb17 	ldw	r2,-84(fp)
8113f6d0:	e0fffe17 	ldw	r3,-8(fp)
8113f6d4:	1885883a 	add	r2,r3,r2
8113f6d8:	1009883a 	mov	r4,r2
8113f6dc:	113ed640 	call	8113ed64 <get_dir_divider_location>
8113f6e0:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
8113f6e4:	e0bfea17 	ldw	r2,-88(fp)
8113f6e8:	00bff316 	blt	zero,r2,8113f6b8 <__reset+0xfb11f6b8>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113f6ec:	e0bfeb17 	ldw	r2,-84(fp)
8113f6f0:	e0bfee15 	stw	r2,-72(fp)
8113f6f4:	00002706 	br	8113f794 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8113f6f8:	e0bfee17 	ldw	r2,-72(fp)
8113f6fc:	e0fffe17 	ldw	r3,-8(fp)
8113f700:	1885883a 	add	r2,r3,r2
8113f704:	10800003 	ldbu	r2,0(r2)
8113f708:	10803fcc 	andi	r2,r2,255
8113f70c:	1080201c 	xori	r2,r2,128
8113f710:	10bfe004 	addi	r2,r2,-128
8113f714:	10800b98 	cmpnei	r2,r2,46
8113f718:	1000031e 	bne	r2,zero,8113f728 <find_file_in_directory+0x120>
        {
            ext_index = index;
8113f71c:	e0bfee17 	ldw	r2,-72(fp)
8113f720:	e0bfec15 	stw	r2,-80(fp)
8113f724:	00001806 	br	8113f788 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
8113f728:	e0bfec17 	ldw	r2,-80(fp)
8113f72c:	10000b0e 	bge	r2,zero,8113f75c <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8113f730:	e0ffee17 	ldw	r3,-72(fp)
8113f734:	e0bfeb17 	ldw	r2,-84(fp)
8113f738:	1885c83a 	sub	r2,r3,r2
8113f73c:	e0ffee17 	ldw	r3,-72(fp)
8113f740:	e13ffe17 	ldw	r4,-8(fp)
8113f744:	20c7883a 	add	r3,r4,r3
8113f748:	18c00003 	ldbu	r3,0(r3)
8113f74c:	e13ff904 	addi	r4,fp,-28
8113f750:	2085883a 	add	r2,r4,r2
8113f754:	10c00005 	stb	r3,0(r2)
8113f758:	00000b06 	br	8113f788 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8113f75c:	e0ffee17 	ldw	r3,-72(fp)
8113f760:	e0bfec17 	ldw	r2,-80(fp)
8113f764:	1885c83a 	sub	r2,r3,r2
8113f768:	10bfffc4 	addi	r2,r2,-1
8113f76c:	e0ffee17 	ldw	r3,-72(fp)
8113f770:	e13ffe17 	ldw	r4,-8(fp)
8113f774:	20c7883a 	add	r3,r4,r3
8113f778:	18c00003 	ldbu	r3,0(r3)
8113f77c:	e13ffb04 	addi	r4,fp,-20
8113f780:	2085883a 	add	r2,r4,r2
8113f784:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113f788:	e0bfee17 	ldw	r2,-72(fp)
8113f78c:	10800044 	addi	r2,r2,1
8113f790:	e0bfee15 	stw	r2,-72(fp)
8113f794:	e0ffee17 	ldw	r3,-72(fp)
8113f798:	e0bff417 	ldw	r2,-48(fp)
8113f79c:	18bfd616 	blt	r3,r2,8113f6f8 <__reset+0xfb11f6f8>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8113f7a0:	e0bffd17 	ldw	r2,-12(fp)
8113f7a4:	1000461e 	bne	r2,zero,8113f8c0 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113f7a8:	00a045b4 	movhi	r2,33046
8113f7ac:	109e3d04 	addi	r2,r2,30964
8113f7b0:	1080050b 	ldhu	r2,20(r2)
8113f7b4:	10bfffcc 	andi	r2,r2,65535
8113f7b8:	1006917a 	slli	r3,r2,5
8113f7bc:	00a045b4 	movhi	r2,33046
8113f7c0:	109e3d04 	addi	r2,r2,30964
8113f7c4:	1080030b 	ldhu	r2,12(r2)
8113f7c8:	10bfffcc 	andi	r2,r2,65535
8113f7cc:	1885283a 	div	r2,r3,r2
8113f7d0:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113f7d4:	e03ff015 	stw	zero,-64(fp)
8113f7d8:	00003506 	br	8113f8b0 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113f7dc:	00a045b4 	movhi	r2,33046
8113f7e0:	109e3d04 	addi	r2,r2,30964
8113f7e4:	10c01317 	ldw	r3,76(r2)
8113f7e8:	e0bff017 	ldw	r2,-64(fp)
8113f7ec:	1885883a 	add	r2,r3,r2
8113f7f0:	1007883a 	mov	r3,r2
8113f7f4:	d0a0ac17 	ldw	r2,-32080(gp)
8113f7f8:	100b883a 	mov	r5,r2
8113f7fc:	1809883a 	mov	r4,r3
8113f800:	113d9600 	call	8113d960 <Read_Sector_Data>
8113f804:	10009626 	beq	r2,zero,8113fa60 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113f808:	e03ff115 	stw	zero,-60(fp)
8113f80c:	00002006 	br	8113f890 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113f810:	e0bff117 	ldw	r2,-60(fp)
8113f814:	1004917a 	slli	r2,r2,5
8113f818:	e0fff017 	ldw	r3,-64(fp)
8113f81c:	180f883a 	mov	r7,r3
8113f820:	000d883a 	mov	r6,zero
8113f824:	e17fff17 	ldw	r5,-4(fp)
8113f828:	1009883a 	mov	r4,r2
8113f82c:	113dd900 	call	8113dd90 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113f830:	e0bfff17 	ldw	r2,-4(fp)
8113f834:	10800003 	ldbu	r2,0(r2)
8113f838:	10803fcc 	andi	r2,r2,255
8113f83c:	10803960 	cmpeqi	r2,r2,229
8113f840:	1000101e 	bne	r2,zero,8113f884 <find_file_in_directory+0x27c>
8113f844:	e0bfff17 	ldw	r2,-4(fp)
8113f848:	10800003 	ldbu	r2,0(r2)
8113f84c:	10803fcc 	andi	r2,r2,255
8113f850:	10000c26 	beq	r2,zero,8113f884 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
8113f854:	e0fffb04 	addi	r3,fp,-20
8113f858:	e0bff904 	addi	r2,fp,-28
8113f85c:	180d883a 	mov	r6,r3
8113f860:	100b883a 	mov	r5,r2
8113f864:	e13fff17 	ldw	r4,-4(fp)
8113f868:	113ee240 	call	8113ee24 <match_file_record_to_name_ext>
8113f86c:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8113f870:	e0bff817 	ldw	r2,-32(fp)
8113f874:	10000326 	beq	r2,zero,8113f884 <find_file_in_directory+0x27c>
                        {
                            result = true;
8113f878:	00800044 	movi	r2,1
8113f87c:	e0bfef15 	stw	r2,-68(fp)
                            break;
8113f880:	00000606 	br	8113f89c <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113f884:	e0bff117 	ldw	r2,-60(fp)
8113f888:	10800044 	addi	r2,r2,1
8113f88c:	e0bff115 	stw	r2,-60(fp)
8113f890:	e0bff117 	ldw	r2,-60(fp)
8113f894:	10800410 	cmplti	r2,r2,16
8113f898:	103fdd1e 	bne	r2,zero,8113f810 <__reset+0xfb11f810>
            }
            else
            {
                break;
            }
            if (result)
8113f89c:	e0bfef17 	ldw	r2,-68(fp)
8113f8a0:	1000711e 	bne	r2,zero,8113fa68 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113f8a4:	e0bff017 	ldw	r2,-64(fp)
8113f8a8:	10800044 	addi	r2,r2,1
8113f8ac:	e0bff015 	stw	r2,-64(fp)
8113f8b0:	e0fff017 	ldw	r3,-64(fp)
8113f8b4:	e0bff717 	ldw	r2,-36(fp)
8113f8b8:	18bfc816 	blt	r3,r2,8113f7dc <__reset+0xfb11f7dc>
8113f8bc:	00006b06 	br	8113fa6c <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113f8c0:	e0bfed17 	ldw	r2,-76(fp)
8113f8c4:	10ffff84 	addi	r3,r2,-2
8113f8c8:	00a045b4 	movhi	r2,33046
8113f8cc:	109e3d04 	addi	r2,r2,30964
8113f8d0:	10800383 	ldbu	r2,14(r2)
8113f8d4:	10803fcc 	andi	r2,r2,255
8113f8d8:	1885383a 	mul	r2,r3,r2
8113f8dc:	1007883a 	mov	r3,r2
8113f8e0:	00a045b4 	movhi	r2,33046
8113f8e4:	109e3d04 	addi	r2,r2,30964
8113f8e8:	10801417 	ldw	r2,80(r2)
8113f8ec:	1885883a 	add	r2,r3,r2
8113f8f0:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f8f4:	e03ff215 	stw	zero,-56(fp)
8113f8f8:	00003306 	br	8113f9c8 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113f8fc:	e0fff217 	ldw	r3,-56(fp)
8113f900:	e0bff517 	ldw	r2,-44(fp)
8113f904:	1885883a 	add	r2,r3,r2
8113f908:	d0e0ac17 	ldw	r3,-32080(gp)
8113f90c:	180b883a 	mov	r5,r3
8113f910:	1009883a 	mov	r4,r2
8113f914:	113d9600 	call	8113d960 <Read_Sector_Data>
8113f918:	10003226 	beq	r2,zero,8113f9e4 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113f91c:	e03ff315 	stw	zero,-52(fp)
8113f920:	00002106 	br	8113f9a8 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113f924:	e0bff317 	ldw	r2,-52(fp)
8113f928:	1004917a 	slli	r2,r2,5
8113f92c:	e0ffed17 	ldw	r3,-76(fp)
8113f930:	e13ff217 	ldw	r4,-56(fp)
8113f934:	200f883a 	mov	r7,r4
8113f938:	180d883a 	mov	r6,r3
8113f93c:	e17fff17 	ldw	r5,-4(fp)
8113f940:	1009883a 	mov	r4,r2
8113f944:	113dd900 	call	8113dd90 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113f948:	e0bfff17 	ldw	r2,-4(fp)
8113f94c:	10800003 	ldbu	r2,0(r2)
8113f950:	10803fcc 	andi	r2,r2,255
8113f954:	10803960 	cmpeqi	r2,r2,229
8113f958:	1000101e 	bne	r2,zero,8113f99c <find_file_in_directory+0x394>
8113f95c:	e0bfff17 	ldw	r2,-4(fp)
8113f960:	10800003 	ldbu	r2,0(r2)
8113f964:	10803fcc 	andi	r2,r2,255
8113f968:	10000c26 	beq	r2,zero,8113f99c <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113f96c:	e0fffb04 	addi	r3,fp,-20
8113f970:	e0bff904 	addi	r2,fp,-28
8113f974:	180d883a 	mov	r6,r3
8113f978:	100b883a 	mov	r5,r2
8113f97c:	e13fff17 	ldw	r4,-4(fp)
8113f980:	113ee240 	call	8113ee24 <match_file_record_to_name_ext>
8113f984:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8113f988:	e0bff617 	ldw	r2,-40(fp)
8113f98c:	10000326 	beq	r2,zero,8113f99c <find_file_in_directory+0x394>
                            {                               
                                result = true;
8113f990:	00800044 	movi	r2,1
8113f994:	e0bfef15 	stw	r2,-68(fp)
                                break;
8113f998:	00000606 	br	8113f9b4 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113f99c:	e0bff317 	ldw	r2,-52(fp)
8113f9a0:	10800044 	addi	r2,r2,1
8113f9a4:	e0bff315 	stw	r2,-52(fp)
8113f9a8:	e0bff317 	ldw	r2,-52(fp)
8113f9ac:	10800410 	cmplti	r2,r2,16
8113f9b0:	103fdc1e 	bne	r2,zero,8113f924 <__reset+0xfb11f924>
                }
                else
                {
                    break;
                }
                if (result)
8113f9b4:	e0bfef17 	ldw	r2,-68(fp)
8113f9b8:	10000c1e 	bne	r2,zero,8113f9ec <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f9bc:	e0bff217 	ldw	r2,-56(fp)
8113f9c0:	10800044 	addi	r2,r2,1
8113f9c4:	e0bff215 	stw	r2,-56(fp)
8113f9c8:	00a045b4 	movhi	r2,33046
8113f9cc:	109e3d04 	addi	r2,r2,30964
8113f9d0:	10800383 	ldbu	r2,14(r2)
8113f9d4:	10803fcc 	andi	r2,r2,255
8113f9d8:	e0fff217 	ldw	r3,-56(fp)
8113f9dc:	18bfc716 	blt	r3,r2,8113f8fc <__reset+0xfb11f8fc>
8113f9e0:	00000306 	br	8113f9f0 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
8113f9e4:	0001883a 	nop
8113f9e8:	00000106 	br	8113f9f0 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8113f9ec:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
8113f9f0:	e0bfef17 	ldw	r2,-68(fp)
8113f9f4:	1000141e 	bne	r2,zero,8113fa48 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8113f9f8:	e0bfed17 	ldw	r2,-76(fp)
8113f9fc:	e0fffc04 	addi	r3,fp,-16
8113fa00:	180b883a 	mov	r5,r3
8113fa04:	1009883a 	mov	r4,r2
8113fa08:	113da400 	call	8113da40 <get_cluster_flag>
8113fa0c:	10000c26 	beq	r2,zero,8113fa40 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113fa10:	e0bffc0b 	ldhu	r2,-16(fp)
8113fa14:	10bfffcc 	andi	r2,r2,65535
8113fa18:	10fffe0c 	andi	r3,r2,65528
8113fa1c:	00bffe14 	movui	r2,65528
8113fa20:	1880021e 	bne	r3,r2,8113fa2c <find_file_in_directory+0x424>
					{
						return false;
8113fa24:	0005883a 	mov	r2,zero
8113fa28:	00001106 	br	8113fa70 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8113fa2c:	e0bffc0b 	ldhu	r2,-16(fp)
8113fa30:	10bfffcc 	andi	r2,r2,65535
8113fa34:	10bffe0c 	andi	r2,r2,65528
8113fa38:	e0bfed15 	stw	r2,-76(fp)
8113fa3c:	00000206 	br	8113fa48 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8113fa40:	0005883a 	mov	r2,zero
8113fa44:	00000a06 	br	8113fa70 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8113fa48:	e0bfed17 	ldw	r2,-76(fp)
8113fa4c:	00fffdd4 	movui	r3,65527
8113fa50:	18800616 	blt	r3,r2,8113fa6c <find_file_in_directory+0x464>
8113fa54:	e0bfef17 	ldw	r2,-68(fp)
8113fa58:	103f9926 	beq	r2,zero,8113f8c0 <__reset+0xfb11f8c0>
8113fa5c:	00000306 	br	8113fa6c <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8113fa60:	0001883a 	nop
8113fa64:	00000106 	br	8113fa6c <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8113fa68:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8113fa6c:	e0bfef17 	ldw	r2,-68(fp)
}
8113fa70:	e037883a 	mov	sp,fp
8113fa74:	dfc00117 	ldw	ra,4(sp)
8113fa78:	df000017 	ldw	fp,0(sp)
8113fa7c:	dec00204 	addi	sp,sp,8
8113fa80:	f800283a 	ret

8113fa84 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
8113fa84:	defff504 	addi	sp,sp,-44
8113fa88:	de00012e 	bgeu	sp,et,8113fa90 <find_first_empty_cluster+0xc>
8113fa8c:	003b68fa 	trap	3
8113fa90:	dfc00a15 	stw	ra,40(sp)
8113fa94:	df000915 	stw	fp,36(sp)
8113fa98:	df000904 	addi	fp,sp,36
8113fa9c:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8113faa0:	00a045b4 	movhi	r2,33046
8113faa4:	109e3d04 	addi	r2,r2,30964
8113faa8:	10801117 	ldw	r2,68(r2)
8113faac:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
8113fab0:	00800084 	movi	r2,2
8113fab4:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8113fab8:	00bfffc4 	movi	r2,-1
8113fabc:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
8113fac0:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
8113fac4:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8113fac8:	00a045b4 	movhi	r2,33046
8113facc:	109e3d04 	addi	r2,r2,30964
8113fad0:	10801417 	ldw	r2,80(r2)
8113fad4:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8113fad8:	00a045b4 	movhi	r2,33046
8113fadc:	109e3d04 	addi	r2,r2,30964
8113fae0:	1080058b 	ldhu	r2,22(r2)
8113fae4:	10bfffcc 	andi	r2,r2,65535
8113fae8:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8113faec:	00a045b4 	movhi	r2,33046
8113faf0:	109e3d04 	addi	r2,r2,30964
8113faf4:	10800917 	ldw	r2,36(r2)
8113faf8:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8113fafc:	e0bffd17 	ldw	r2,-12(fp)
8113fb00:	e0fffe17 	ldw	r3,-8(fp)
8113fb04:	18800b2e 	bgeu	r3,r2,8113fb34 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113fb08:	e0fffd17 	ldw	r3,-12(fp)
8113fb0c:	e0bffc17 	ldw	r2,-16(fp)
8113fb10:	1887c83a 	sub	r3,r3,r2
8113fb14:	00a045b4 	movhi	r2,33046
8113fb18:	109e3d04 	addi	r2,r2,30964
8113fb1c:	10800383 	ldbu	r2,14(r2)
8113fb20:	10803fcc 	andi	r2,r2,255
8113fb24:	1885203a 	divu	r2,r3,r2
8113fb28:	10800044 	addi	r2,r2,1
8113fb2c:	e0bffb15 	stw	r2,-20(fp)
8113fb30:	00002a06 	br	8113fbdc <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113fb34:	e0fffe17 	ldw	r3,-8(fp)
8113fb38:	e0bffc17 	ldw	r2,-16(fp)
8113fb3c:	1887c83a 	sub	r3,r3,r2
8113fb40:	00a045b4 	movhi	r2,33046
8113fb44:	109e3d04 	addi	r2,r2,30964
8113fb48:	10800383 	ldbu	r2,14(r2)
8113fb4c:	10803fcc 	andi	r2,r2,255
8113fb50:	1885203a 	divu	r2,r3,r2
8113fb54:	10800044 	addi	r2,r2,1
8113fb58:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113fb5c:	00001f06 	br	8113fbdc <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8113fb60:	e0bff717 	ldw	r2,-36(fp)
8113fb64:	d0e0ac17 	ldw	r3,-32080(gp)
8113fb68:	180b883a 	mov	r5,r3
8113fb6c:	1009883a 	mov	r4,r2
8113fb70:	113d9600 	call	8113d960 <Read_Sector_Data>
8113fb74:	10001426 	beq	r2,zero,8113fbc8 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8113fb78:	e0bff817 	ldw	r2,-32(fp)
8113fb7c:	10803fcc 	andi	r2,r2,255
8113fb80:	1085883a 	add	r2,r2,r2
8113fb84:	1007883a 	mov	r3,r2
8113fb88:	d0a0ae17 	ldw	r2,-32072(gp)
8113fb8c:	10800a17 	ldw	r2,40(r2)
8113fb90:	1885883a 	add	r2,r3,r2
8113fb94:	1080002b 	ldhuio	r2,0(r2)
8113fb98:	10bfffcc 	andi	r2,r2,65535
8113fb9c:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8113fba0:	e0bff90f 	ldh	r2,-28(fp)
8113fba4:	10000726 	beq	r2,zero,8113fbc4 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8113fba8:	e0bff817 	ldw	r2,-32(fp)
8113fbac:	10800044 	addi	r2,r2,1
8113fbb0:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
8113fbb4:	e0bff817 	ldw	r2,-32(fp)
8113fbb8:	10803fcc 	andi	r2,r2,255
8113fbbc:	103fee1e 	bne	r2,zero,8113fb78 <__reset+0xfb11fb78>
8113fbc0:	00000106 	br	8113fbc8 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
8113fbc4:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8113fbc8:	e0bff90f 	ldh	r2,-28(fp)
8113fbcc:	10000926 	beq	r2,zero,8113fbf4 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
8113fbd0:	e0bff717 	ldw	r2,-36(fp)
8113fbd4:	10800044 	addi	r2,r2,1
8113fbd8:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113fbdc:	00a045b4 	movhi	r2,33046
8113fbe0:	109e3d04 	addi	r2,r2,30964
8113fbe4:	10c01217 	ldw	r3,72(r2)
8113fbe8:	e0bff717 	ldw	r2,-36(fp)
8113fbec:	18bfdc1e 	bne	r3,r2,8113fb60 <__reset+0xfb11fb60>
8113fbf0:	00000106 	br	8113fbf8 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
8113fbf4:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8113fbf8:	e0bff90f 	ldh	r2,-28(fp)
8113fbfc:	1000081e 	bne	r2,zero,8113fc20 <find_first_empty_cluster+0x19c>
8113fc00:	e0bff90f 	ldh	r2,-28(fp)
8113fc04:	e0fffb17 	ldw	r3,-20(fp)
8113fc08:	18800536 	bltu	r3,r2,8113fc20 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8113fc0c:	e0bfff17 	ldw	r2,-4(fp)
8113fc10:	e0fff817 	ldw	r3,-32(fp)
8113fc14:	10c00015 	stw	r3,0(r2)
		result = true;
8113fc18:	00800044 	movi	r2,1
8113fc1c:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8113fc20:	e0bffa17 	ldw	r2,-24(fp)
}
8113fc24:	e037883a 	mov	sp,fp
8113fc28:	dfc00117 	ldw	ra,4(sp)
8113fc2c:	df000017 	ldw	fp,0(sp)
8113fc30:	dec00204 	addi	sp,sp,8
8113fc34:	f800283a 	ret

8113fc38 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8113fc38:	defff604 	addi	sp,sp,-40
8113fc3c:	de00012e 	bgeu	sp,et,8113fc44 <find_first_empty_record_in_a_subdirectory+0xc>
8113fc40:	003b68fa 	trap	3
8113fc44:	dfc00915 	stw	ra,36(sp)
8113fc48:	df000815 	stw	fp,32(sp)
8113fc4c:	df000804 	addi	fp,sp,32
8113fc50:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
8113fc54:	00bfffc4 	movi	r2,-1
8113fc58:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8113fc5c:	e0bfff17 	ldw	r2,-4(fp)
8113fc60:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113fc64:	e0bff917 	ldw	r2,-28(fp)
8113fc68:	10ffff84 	addi	r3,r2,-2
8113fc6c:	00a045b4 	movhi	r2,33046
8113fc70:	109e3d04 	addi	r2,r2,30964
8113fc74:	10800383 	ldbu	r2,14(r2)
8113fc78:	10803fcc 	andi	r2,r2,255
8113fc7c:	1885383a 	mul	r2,r3,r2
8113fc80:	1007883a 	mov	r3,r2
8113fc84:	00a045b4 	movhi	r2,33046
8113fc88:	109e3d04 	addi	r2,r2,30964
8113fc8c:	10801417 	ldw	r2,80(r2)
8113fc90:	1885883a 	add	r2,r3,r2
8113fc94:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113fc98:	e03ffa15 	stw	zero,-24(fp)
8113fc9c:	00002c06 	br	8113fd50 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113fca0:	e0fffa17 	ldw	r3,-24(fp)
8113fca4:	e0bffc17 	ldw	r2,-16(fp)
8113fca8:	1885883a 	add	r2,r3,r2
8113fcac:	d0e0ac17 	ldw	r3,-32080(gp)
8113fcb0:	180b883a 	mov	r5,r3
8113fcb4:	1009883a 	mov	r4,r2
8113fcb8:	113d9600 	call	8113d960 <Read_Sector_Data>
8113fcbc:	10002b26 	beq	r2,zero,8113fd6c <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113fcc0:	e03ffb15 	stw	zero,-20(fp)
8113fcc4:	00001c06 	br	8113fd38 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113fcc8:	e0bffb17 	ldw	r2,-20(fp)
8113fccc:	1004917a 	slli	r2,r2,5
8113fcd0:	1007883a 	mov	r3,r2
8113fcd4:	d0a0ae17 	ldw	r2,-32072(gp)
8113fcd8:	10800a17 	ldw	r2,40(r2)
8113fcdc:	1885883a 	add	r2,r3,r2
8113fce0:	10800023 	ldbuio	r2,0(r2)
8113fce4:	10803fcc 	andi	r2,r2,255
8113fce8:	10803fcc 	andi	r2,r2,255
8113fcec:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
8113fcf0:	e0bffd0b 	ldhu	r2,-12(fp)
8113fcf4:	10803960 	cmpeqi	r2,r2,229
8113fcf8:	1000021e 	bne	r2,zero,8113fd04 <find_first_empty_record_in_a_subdirectory+0xcc>
8113fcfc:	e0bffd0b 	ldhu	r2,-12(fp)
8113fd00:	10000a1e 	bne	r2,zero,8113fd2c <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
8113fd04:	e0bffa17 	ldw	r2,-24(fp)
8113fd08:	1006913a 	slli	r3,r2,4
8113fd0c:	e0bffb17 	ldw	r2,-20(fp)
8113fd10:	1885883a 	add	r2,r3,r2
8113fd14:	1006943a 	slli	r3,r2,16
8113fd18:	e0bff917 	ldw	r2,-28(fp)
8113fd1c:	1884b03a 	or	r2,r3,r2
8113fd20:	e0bff815 	stw	r2,-32(fp)
                        return result;
8113fd24:	e0bff817 	ldw	r2,-32(fp)
8113fd28:	00005306 	br	8113fe78 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113fd2c:	e0bffb17 	ldw	r2,-20(fp)
8113fd30:	10800044 	addi	r2,r2,1
8113fd34:	e0bffb15 	stw	r2,-20(fp)
8113fd38:	e0bffb17 	ldw	r2,-20(fp)
8113fd3c:	10800410 	cmplti	r2,r2,16
8113fd40:	103fe11e 	bne	r2,zero,8113fcc8 <__reset+0xfb11fcc8>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113fd44:	e0bffa17 	ldw	r2,-24(fp)
8113fd48:	10800044 	addi	r2,r2,1
8113fd4c:	e0bffa15 	stw	r2,-24(fp)
8113fd50:	00a045b4 	movhi	r2,33046
8113fd54:	109e3d04 	addi	r2,r2,30964
8113fd58:	10800383 	ldbu	r2,14(r2)
8113fd5c:	10803fcc 	andi	r2,r2,255
8113fd60:	e0fffa17 	ldw	r3,-24(fp)
8113fd64:	18bfce16 	blt	r3,r2,8113fca0 <__reset+0xfb11fca0>
8113fd68:	00000106 	br	8113fd70 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8113fd6c:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8113fd70:	e0bff817 	ldw	r2,-32(fp)
8113fd74:	1000390e 	bge	r2,zero,8113fe5c <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8113fd78:	e0bff917 	ldw	r2,-28(fp)
8113fd7c:	e0fffd84 	addi	r3,fp,-10
8113fd80:	180b883a 	mov	r5,r3
8113fd84:	1009883a 	mov	r4,r2
8113fd88:	113da400 	call	8113da40 <get_cluster_flag>
8113fd8c:	10003126 	beq	r2,zero,8113fe54 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113fd90:	e0bffd8b 	ldhu	r2,-10(fp)
8113fd94:	10bfffcc 	andi	r2,r2,65535
8113fd98:	10fffe0c 	andi	r3,r2,65528
8113fd9c:	00bffe14 	movui	r2,65528
8113fda0:	18802e1e 	bne	r3,r2,8113fe5c <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8113fda4:	e0bffe04 	addi	r2,fp,-8
8113fda8:	1009883a 	mov	r4,r2
8113fdac:	113fa840 	call	8113fa84 <find_first_empty_cluster>
8113fdb0:	10002326 	beq	r2,zero,8113fe40 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113fdb4:	e0bff917 	ldw	r2,-28(fp)
8113fdb8:	e0fffe17 	ldw	r3,-8(fp)
8113fdbc:	18ffffcc 	andi	r3,r3,65535
8113fdc0:	18e0001c 	xori	r3,r3,32768
8113fdc4:	18e00004 	addi	r3,r3,-32768
8113fdc8:	01800044 	movi	r6,1
8113fdcc:	180b883a 	mov	r5,r3
8113fdd0:	1009883a 	mov	r4,r2
8113fdd4:	113dafc0 	call	8113dafc <mark_cluster>
8113fdd8:	10001926 	beq	r2,zero,8113fe40 <find_first_empty_record_in_a_subdirectory+0x208>
8113fddc:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113fde0:	01800044 	movi	r6,1
8113fde4:	017fffc4 	movi	r5,-1
8113fde8:	1009883a 	mov	r4,r2
8113fdec:	113dafc0 	call	8113dafc <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113fdf0:	10001326 	beq	r2,zero,8113fe40 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113fdf4:	e0bff917 	ldw	r2,-28(fp)
8113fdf8:	e0fffe17 	ldw	r3,-8(fp)
8113fdfc:	18ffffcc 	andi	r3,r3,65535
8113fe00:	18e0001c 	xori	r3,r3,32768
8113fe04:	18e00004 	addi	r3,r3,-32768
8113fe08:	000d883a 	mov	r6,zero
8113fe0c:	180b883a 	mov	r5,r3
8113fe10:	1009883a 	mov	r4,r2
8113fe14:	113dafc0 	call	8113dafc <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113fe18:	10000926 	beq	r2,zero,8113fe40 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113fe1c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
8113fe20:	000d883a 	mov	r6,zero
8113fe24:	017fffc4 	movi	r5,-1
8113fe28:	1009883a 	mov	r4,r2
8113fe2c:	113dafc0 	call	8113dafc <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113fe30:	10000326 	beq	r2,zero,8113fe40 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
8113fe34:	113d90c0 	call	8113d90c <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8113fe38:	e0bffe17 	ldw	r2,-8(fp)
8113fe3c:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8113fe40:	e0bffd8b 	ldhu	r2,-10(fp)
8113fe44:	10bfffcc 	andi	r2,r2,65535
8113fe48:	10bffe0c 	andi	r2,r2,65528
8113fe4c:	e0bff915 	stw	r2,-28(fp)
8113fe50:	00000206 	br	8113fe5c <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8113fe54:	00bfffc4 	movi	r2,-1
8113fe58:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8113fe5c:	e0bff917 	ldw	r2,-28(fp)
8113fe60:	00fffdd4 	movui	r3,65527
8113fe64:	18800316 	blt	r3,r2,8113fe74 <find_first_empty_record_in_a_subdirectory+0x23c>
8113fe68:	e0bff817 	ldw	r2,-32(fp)
8113fe6c:	10bfffe0 	cmpeqi	r2,r2,-1
8113fe70:	103f7c1e 	bne	r2,zero,8113fc64 <__reset+0xfb11fc64>
    return result; 
8113fe74:	e0bff817 	ldw	r2,-32(fp)
}
8113fe78:	e037883a 	mov	sp,fp
8113fe7c:	dfc00117 	ldw	ra,4(sp)
8113fe80:	df000017 	ldw	fp,0(sp)
8113fe84:	dec00204 	addi	sp,sp,8
8113fe88:	f800283a 	ret

8113fe8c <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
8113fe8c:	defff904 	addi	sp,sp,-28
8113fe90:	de00012e 	bgeu	sp,et,8113fe98 <find_first_empty_record_in_root_directory+0xc>
8113fe94:	003b68fa 	trap	3
8113fe98:	dfc00615 	stw	ra,24(sp)
8113fe9c:	df000515 	stw	fp,20(sp)
8113fea0:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113fea4:	00a045b4 	movhi	r2,33046
8113fea8:	109e3d04 	addi	r2,r2,30964
8113feac:	1080050b 	ldhu	r2,20(r2)
8113feb0:	10bfffcc 	andi	r2,r2,65535
8113feb4:	1006917a 	slli	r3,r2,5
8113feb8:	00a045b4 	movhi	r2,33046
8113febc:	109e3d04 	addi	r2,r2,30964
8113fec0:	1080030b 	ldhu	r2,12(r2)
8113fec4:	10bfffcc 	andi	r2,r2,65535
8113fec8:	1885283a 	div	r2,r3,r2
8113fecc:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
8113fed0:	00bfffc4 	movi	r2,-1
8113fed4:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113fed8:	e03ffb15 	stw	zero,-20(fp)
8113fedc:	00002d06 	br	8113ff94 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113fee0:	00a045b4 	movhi	r2,33046
8113fee4:	109e3d04 	addi	r2,r2,30964
8113fee8:	10c01317 	ldw	r3,76(r2)
8113feec:	e0bffb17 	ldw	r2,-20(fp)
8113fef0:	1885883a 	add	r2,r3,r2
8113fef4:	1007883a 	mov	r3,r2
8113fef8:	d0a0ac17 	ldw	r2,-32080(gp)
8113fefc:	100b883a 	mov	r5,r2
8113ff00:	1809883a 	mov	r4,r3
8113ff04:	113d9600 	call	8113d960 <Read_Sector_Data>
8113ff08:	10002626 	beq	r2,zero,8113ffa4 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113ff0c:	e03ffc15 	stw	zero,-16(fp)
8113ff10:	00001a06 	br	8113ff7c <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113ff14:	e0bffc17 	ldw	r2,-16(fp)
8113ff18:	1004917a 	slli	r2,r2,5
8113ff1c:	1007883a 	mov	r3,r2
8113ff20:	d0a0ae17 	ldw	r2,-32072(gp)
8113ff24:	10800a17 	ldw	r2,40(r2)
8113ff28:	1885883a 	add	r2,r3,r2
8113ff2c:	10800023 	ldbuio	r2,0(r2)
8113ff30:	10803fcc 	andi	r2,r2,255
8113ff34:	10803fcc 	andi	r2,r2,255
8113ff38:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8113ff3c:	e0bfff0b 	ldhu	r2,-4(fp)
8113ff40:	10803960 	cmpeqi	r2,r2,229
8113ff44:	1000021e 	bne	r2,zero,8113ff50 <find_first_empty_record_in_root_directory+0xc4>
8113ff48:	e0bfff0b 	ldhu	r2,-4(fp)
8113ff4c:	1000081e 	bne	r2,zero,8113ff70 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
8113ff50:	e0bffb17 	ldw	r2,-20(fp)
8113ff54:	1006913a 	slli	r3,r2,4
8113ff58:	e0bffc17 	ldw	r2,-16(fp)
8113ff5c:	1885883a 	add	r2,r3,r2
8113ff60:	1004943a 	slli	r2,r2,16
8113ff64:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8113ff68:	e0bffe17 	ldw	r2,-8(fp)
8113ff6c:	00000f06 	br	8113ffac <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113ff70:	e0bffc17 	ldw	r2,-16(fp)
8113ff74:	10800044 	addi	r2,r2,1
8113ff78:	e0bffc15 	stw	r2,-16(fp)
8113ff7c:	e0bffc17 	ldw	r2,-16(fp)
8113ff80:	10800410 	cmplti	r2,r2,16
8113ff84:	103fe31e 	bne	r2,zero,8113ff14 <__reset+0xfb11ff14>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113ff88:	e0bffb17 	ldw	r2,-20(fp)
8113ff8c:	10800044 	addi	r2,r2,1
8113ff90:	e0bffb15 	stw	r2,-20(fp)
8113ff94:	e0fffb17 	ldw	r3,-20(fp)
8113ff98:	e0bffd17 	ldw	r2,-12(fp)
8113ff9c:	18bfd016 	blt	r3,r2,8113fee0 <__reset+0xfb11fee0>
8113ffa0:	00000106 	br	8113ffa8 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8113ffa4:	0001883a 	nop
        }
    }
    return result;
8113ffa8:	e0bffe17 	ldw	r2,-8(fp)
}
8113ffac:	e037883a 	mov	sp,fp
8113ffb0:	dfc00117 	ldw	ra,4(sp)
8113ffb4:	df000017 	ldw	fp,0(sp)
8113ffb8:	dec00204 	addi	sp,sp,8
8113ffbc:	f800283a 	ret

8113ffc0 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
8113ffc0:	defffa04 	addi	sp,sp,-24
8113ffc4:	de00012e 	bgeu	sp,et,8113ffcc <convert_filename_to_name_extension+0xc>
8113ffc8:	003b68fa 	trap	3
8113ffcc:	df000515 	stw	fp,20(sp)
8113ffd0:	df000504 	addi	fp,sp,20
8113ffd4:	e13ffd15 	stw	r4,-12(fp)
8113ffd8:	e17ffe15 	stw	r5,-8(fp)
8113ffdc:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
8113ffe0:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
8113ffe4:	e03ffb15 	stw	zero,-20(fp)
8113ffe8:	00002506 	br	81140080 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8113ffec:	e0bffc17 	ldw	r2,-16(fp)
8113fff0:	e0fffd17 	ldw	r3,-12(fp)
8113fff4:	1885883a 	add	r2,r3,r2
8113fff8:	10800003 	ldbu	r2,0(r2)
8113fffc:	10803fcc 	andi	r2,r2,255
81140000:	1080201c 	xori	r2,r2,128
81140004:	10bfe004 	addi	r2,r2,-128
81140008:	10800ba0 	cmpeqi	r2,r2,46
8114000c:	1000141e 	bne	r2,zero,81140060 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81140010:	e0bffb17 	ldw	r2,-20(fp)
81140014:	e0fffe17 	ldw	r3,-8(fp)
81140018:	1885883a 	add	r2,r3,r2
8114001c:	e0fffc17 	ldw	r3,-16(fp)
81140020:	e13ffd17 	ldw	r4,-12(fp)
81140024:	20c7883a 	add	r3,r4,r3
81140028:	18c00003 	ldbu	r3,0(r3)
8114002c:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81140030:	e0bffc17 	ldw	r2,-16(fp)
81140034:	e0fffd17 	ldw	r3,-12(fp)
81140038:	1885883a 	add	r2,r3,r2
8114003c:	10800003 	ldbu	r2,0(r2)
81140040:	10803fcc 	andi	r2,r2,255
81140044:	1080201c 	xori	r2,r2,128
81140048:	10bfe004 	addi	r2,r2,-128
8114004c:	10000926 	beq	r2,zero,81140074 <convert_filename_to_name_extension+0xb4>
81140050:	e0bffc17 	ldw	r2,-16(fp)
81140054:	10800044 	addi	r2,r2,1
81140058:	e0bffc15 	stw	r2,-16(fp)
8114005c:	00000506 	br	81140074 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81140060:	e0bffb17 	ldw	r2,-20(fp)
81140064:	e0fffe17 	ldw	r3,-8(fp)
81140068:	1885883a 	add	r2,r3,r2
8114006c:	00c00804 	movi	r3,32
81140070:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81140074:	e0bffb17 	ldw	r2,-20(fp)
81140078:	10800044 	addi	r2,r2,1
8114007c:	e0bffb15 	stw	r2,-20(fp)
81140080:	e0bffb17 	ldw	r2,-20(fp)
81140084:	10800210 	cmplti	r2,r2,8
81140088:	103fd81e 	bne	r2,zero,8113ffec <__reset+0xfb11ffec>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
8114008c:	e0bffc17 	ldw	r2,-16(fp)
81140090:	e0fffd17 	ldw	r3,-12(fp)
81140094:	1885883a 	add	r2,r3,r2
81140098:	10800003 	ldbu	r2,0(r2)
8114009c:	10803fcc 	andi	r2,r2,255
811400a0:	1080201c 	xori	r2,r2,128
811400a4:	10bfe004 	addi	r2,r2,-128
811400a8:	10800b98 	cmpnei	r2,r2,46
811400ac:	1000031e 	bne	r2,zero,811400bc <convert_filename_to_name_extension+0xfc>
811400b0:	e0bffc17 	ldw	r2,-16(fp)
811400b4:	10800044 	addi	r2,r2,1
811400b8:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
811400bc:	e03ffb15 	stw	zero,-20(fp)
811400c0:	00001c06 	br	81140134 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
811400c4:	e0bffc17 	ldw	r2,-16(fp)
811400c8:	e0fffd17 	ldw	r3,-12(fp)
811400cc:	1885883a 	add	r2,r3,r2
811400d0:	10800003 	ldbu	r2,0(r2)
811400d4:	10803fcc 	andi	r2,r2,255
811400d8:	1080201c 	xori	r2,r2,128
811400dc:	10bfe004 	addi	r2,r2,-128
811400e0:	10000c26 	beq	r2,zero,81140114 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
811400e4:	e0bffb17 	ldw	r2,-20(fp)
811400e8:	e0ffff17 	ldw	r3,-4(fp)
811400ec:	1885883a 	add	r2,r3,r2
811400f0:	e0fffc17 	ldw	r3,-16(fp)
811400f4:	e13ffd17 	ldw	r4,-12(fp)
811400f8:	20c7883a 	add	r3,r4,r3
811400fc:	18c00003 	ldbu	r3,0(r3)
81140100:	10c00005 	stb	r3,0(r2)
            local++;
81140104:	e0bffc17 	ldw	r2,-16(fp)
81140108:	10800044 	addi	r2,r2,1
8114010c:	e0bffc15 	stw	r2,-16(fp)
81140110:	00000506 	br	81140128 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81140114:	e0bffb17 	ldw	r2,-20(fp)
81140118:	e0ffff17 	ldw	r3,-4(fp)
8114011c:	1885883a 	add	r2,r3,r2
81140120:	00c00804 	movi	r3,32
81140124:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81140128:	e0bffb17 	ldw	r2,-20(fp)
8114012c:	10800044 	addi	r2,r2,1
81140130:	e0bffb15 	stw	r2,-20(fp)
81140134:	e0bffb17 	ldw	r2,-20(fp)
81140138:	108000d0 	cmplti	r2,r2,3
8114013c:	103fe11e 	bne	r2,zero,811400c4 <__reset+0xfb1200c4>
        {
            extension[counter] = ' ';
        }
    }

}
81140140:	0001883a 	nop
81140144:	e037883a 	mov	sp,fp
81140148:	df000017 	ldw	fp,0(sp)
8114014c:	dec00104 	addi	sp,sp,4
81140150:	f800283a 	ret

81140154 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81140154:	defff504 	addi	sp,sp,-44
81140158:	de00012e 	bgeu	sp,et,81140160 <create_file+0xc>
8114015c:	003b68fa 	trap	3
81140160:	dfc00a15 	stw	ra,40(sp)
81140164:	df000915 	stw	fp,36(sp)
81140168:	df000904 	addi	fp,sp,36
8114016c:	e13ffd15 	stw	r4,-12(fp)
81140170:	e17ffe15 	stw	r5,-8(fp)
81140174:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81140178:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
8114017c:	e0bffc04 	addi	r2,fp,-16
81140180:	1009883a 	mov	r4,r2
81140184:	113fa840 	call	8113fa84 <find_first_empty_cluster>
81140188:	1000a026 	beq	r2,zero,8114040c <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
8114018c:	e0bfff17 	ldw	r2,-4(fp)
81140190:	10800a17 	ldw	r2,40(r2)
81140194:	1000031e 	bne	r2,zero,811401a4 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81140198:	113fe8c0 	call	8113fe8c <find_first_empty_record_in_root_directory>
8114019c:	e0bff815 	stw	r2,-32(fp)
811401a0:	00000606 	br	811401bc <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
811401a4:	e0bfff17 	ldw	r2,-4(fp)
811401a8:	1080058b 	ldhu	r2,22(r2)
811401ac:	10bfffcc 	andi	r2,r2,65535
811401b0:	1009883a 	mov	r4,r2
811401b4:	113fc380 	call	8113fc38 <find_first_empty_record_in_a_subdirectory>
811401b8:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
811401bc:	e0bff817 	ldw	r2,-32(fp)
811401c0:	10009216 	blt	r2,zero,8114040c <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
811401c4:	e13ffd17 	ldw	r4,-12(fp)
811401c8:	113ed640 	call	8113ed64 <get_dir_divider_location>
811401cc:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
811401d0:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
811401d4:	00000b06 	br	81140204 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
811401d8:	e0fffa17 	ldw	r3,-24(fp)
811401dc:	e0bff917 	ldw	r2,-28(fp)
811401e0:	1885883a 	add	r2,r3,r2
811401e4:	10800044 	addi	r2,r2,1
811401e8:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
811401ec:	e0bffa17 	ldw	r2,-24(fp)
811401f0:	e0fffd17 	ldw	r3,-12(fp)
811401f4:	1885883a 	add	r2,r3,r2
811401f8:	1009883a 	mov	r4,r2
811401fc:	113ed640 	call	8113ed64 <get_dir_divider_location>
81140200:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81140204:	e0bff917 	ldw	r2,-28(fp)
81140208:	00bff316 	blt	zero,r2,811401d8 <__reset+0xfb1201d8>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
8114020c:	e0bffa17 	ldw	r2,-24(fp)
81140210:	e0fffd17 	ldw	r3,-12(fp)
81140214:	1887883a 	add	r3,r3,r2
81140218:	e13ffe17 	ldw	r4,-8(fp)
8114021c:	e0bffe17 	ldw	r2,-8(fp)
81140220:	10800204 	addi	r2,r2,8
81140224:	100d883a 	mov	r6,r2
81140228:	200b883a 	mov	r5,r4
8114022c:	1809883a 	mov	r4,r3
81140230:	113ffc00 	call	8113ffc0 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81140234:	e0bffe17 	ldw	r2,-8(fp)
81140238:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
8114023c:	e0bffe17 	ldw	r2,-8(fp)
81140240:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81140244:	e0bffe17 	ldw	r2,-8(fp)
81140248:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
8114024c:	e0bffe17 	ldw	r2,-8(fp)
81140250:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81140254:	e0bffe17 	ldw	r2,-8(fp)
81140258:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
8114025c:	e0bffe17 	ldw	r2,-8(fp)
81140260:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81140264:	e0bffc17 	ldw	r2,-16(fp)
81140268:	1007883a 	mov	r3,r2
8114026c:	e0bffe17 	ldw	r2,-8(fp)
81140270:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81140274:	e0bffe17 	ldw	r2,-8(fp)
81140278:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
8114027c:	e0fffc17 	ldw	r3,-16(fp)
81140280:	e0bffe17 	ldw	r2,-8(fp)
81140284:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81140288:	e0bffe17 	ldw	r2,-8(fp)
8114028c:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81140290:	e0bffe17 	ldw	r2,-8(fp)
81140294:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81140298:	e0bff817 	ldw	r2,-32(fp)
8114029c:	10ffffcc 	andi	r3,r2,65535
811402a0:	e0bffe17 	ldw	r2,-8(fp)
811402a4:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
811402a8:	e0bff817 	ldw	r2,-32(fp)
811402ac:	1004d43a 	srli	r2,r2,16
811402b0:	1000010e 	bge	r2,zero,811402b8 <create_file+0x164>
811402b4:	108003c4 	addi	r2,r2,15
811402b8:	1005d13a 	srai	r2,r2,4
811402bc:	1007883a 	mov	r3,r2
811402c0:	e0bffe17 	ldw	r2,-8(fp)
811402c4:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
811402c8:	e0bff817 	ldw	r2,-32(fp)
811402cc:	1004d43a 	srli	r2,r2,16
811402d0:	1007883a 	mov	r3,r2
811402d4:	00a00034 	movhi	r2,32768
811402d8:	108003c4 	addi	r2,r2,15
811402dc:	1884703a 	and	r2,r3,r2
811402e0:	1000040e 	bge	r2,zero,811402f4 <create_file+0x1a0>
811402e4:	10bfffc4 	addi	r2,r2,-1
811402e8:	00fffc04 	movi	r3,-16
811402ec:	10c4b03a 	or	r2,r2,r3
811402f0:	10800044 	addi	r2,r2,1
811402f4:	1004917a 	slli	r2,r2,5
811402f8:	1007883a 	mov	r3,r2
811402fc:	e0bffe17 	ldw	r2,-8(fp)
81140300:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81140304:	e0bfff17 	ldw	r2,-4(fp)
81140308:	1080058b 	ldhu	r2,22(r2)
8114030c:	10ffffcc 	andi	r3,r2,65535
81140310:	e0bffe17 	ldw	r2,-8(fp)
81140314:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81140318:	e0bffe17 	ldw	r2,-8(fp)
8114031c:	00c00044 	movi	r3,1
81140320:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81140324:	e0bffe17 	ldw	r2,-8(fp)
81140328:	00c00044 	movi	r3,1
8114032c:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81140330:	e0bffe17 	ldw	r2,-8(fp)
81140334:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81140338:	1000071e 	bne	r2,zero,81140358 <create_file+0x204>
8114033c:	00a045b4 	movhi	r2,33046
81140340:	109e3d04 	addi	r2,r2,30964
81140344:	10c01317 	ldw	r3,76(r2)
81140348:	e0bffe17 	ldw	r2,-8(fp)
8114034c:	10800b17 	ldw	r2,44(r2)
81140350:	1885883a 	add	r2,r3,r2
81140354:	00000f06 	br	81140394 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81140358:	00a045b4 	movhi	r2,33046
8114035c:	109e3d04 	addi	r2,r2,30964
81140360:	10c01417 	ldw	r3,80(r2)
81140364:	e0bffe17 	ldw	r2,-8(fp)
81140368:	10800a17 	ldw	r2,40(r2)
8114036c:	113fff84 	addi	r4,r2,-2
81140370:	00a045b4 	movhi	r2,33046
81140374:	109e3d04 	addi	r2,r2,30964
81140378:	10800383 	ldbu	r2,14(r2)
8114037c:	10803fcc 	andi	r2,r2,255
81140380:	2085383a 	mul	r2,r4,r2
81140384:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81140388:	e0bffe17 	ldw	r2,-8(fp)
8114038c:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81140390:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81140394:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81140398:	e0bffb17 	ldw	r2,-20(fp)
8114039c:	d0e0ac17 	ldw	r3,-32080(gp)
811403a0:	180b883a 	mov	r5,r3
811403a4:	1009883a 	mov	r4,r2
811403a8:	113d9600 	call	8113d960 <Read_Sector_Data>
811403ac:	10001726 	beq	r2,zero,8114040c <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
811403b0:	e0bffe17 	ldw	r2,-8(fp)
811403b4:	10800c0b 	ldhu	r2,48(r2)
811403b8:	10bfffcc 	andi	r2,r2,65535
811403bc:	10a0001c 	xori	r2,r2,32768
811403c0:	10a00004 	addi	r2,r2,-32768
811403c4:	e17ffe17 	ldw	r5,-8(fp)
811403c8:	1009883a 	mov	r4,r2
811403cc:	113e0140 	call	8113e014 <Write_File_Record_At_Offset>
811403d0:	10000e26 	beq	r2,zero,8114040c <create_file+0x2b8>
                {
                    Save_Modified_Sector();
811403d4:	113d90c0 	call	8113d90c <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
811403d8:	e0bffc17 	ldw	r2,-16(fp)
811403dc:	01800044 	movi	r6,1
811403e0:	017fffc4 	movi	r5,-1
811403e4:	1009883a 	mov	r4,r2
811403e8:	113dafc0 	call	8113dafc <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
811403ec:	e0bffc17 	ldw	r2,-16(fp)
811403f0:	000d883a 	mov	r6,zero
811403f4:	017fffc4 	movi	r5,-1
811403f8:	1009883a 	mov	r4,r2
811403fc:	113dafc0 	call	8113dafc <mark_cluster>
81140400:	10000226 	beq	r2,zero,8114040c <create_file+0x2b8>
                    {
                        result = true;
81140404:	00800044 	movi	r2,1
81140408:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
8114040c:	e0bff717 	ldw	r2,-36(fp)
}
81140410:	e037883a 	mov	sp,fp
81140414:	dfc00117 	ldw	ra,4(sp)
81140418:	df000017 	ldw	fp,0(sp)
8114041c:	dec00204 	addi	sp,sp,8
81140420:	f800283a 	ret

81140424 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81140424:	defffb04 	addi	sp,sp,-20
81140428:	de00012e 	bgeu	sp,et,81140430 <copy_file_record_name_to_string+0xc>
8114042c:	003b68fa 	trap	3
81140430:	df000415 	stw	fp,16(sp)
81140434:	df000404 	addi	fp,sp,16
81140438:	e13ffe15 	stw	r4,-8(fp)
8114043c:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81140440:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81140444:	e03ffc15 	stw	zero,-16(fp)
81140448:	00001506 	br	811404a0 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
8114044c:	e0fffe17 	ldw	r3,-8(fp)
81140450:	e0bffc17 	ldw	r2,-16(fp)
81140454:	1885883a 	add	r2,r3,r2
81140458:	10800003 	ldbu	r2,0(r2)
8114045c:	10803fcc 	andi	r2,r2,255
81140460:	10800820 	cmpeqi	r2,r2,32
81140464:	10000b1e 	bne	r2,zero,81140494 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81140468:	e0bffd17 	ldw	r2,-12(fp)
8114046c:	e0ffff17 	ldw	r3,-4(fp)
81140470:	1885883a 	add	r2,r3,r2
81140474:	e13ffe17 	ldw	r4,-8(fp)
81140478:	e0fffc17 	ldw	r3,-16(fp)
8114047c:	20c7883a 	add	r3,r4,r3
81140480:	18c00003 	ldbu	r3,0(r3)
81140484:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81140488:	e0bffd17 	ldw	r2,-12(fp)
8114048c:	10800044 	addi	r2,r2,1
81140490:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81140494:	e0bffc17 	ldw	r2,-16(fp)
81140498:	10800044 	addi	r2,r2,1
8114049c:	e0bffc15 	stw	r2,-16(fp)
811404a0:	e0bffc17 	ldw	r2,-16(fp)
811404a4:	10800210 	cmplti	r2,r2,8
811404a8:	103fe81e 	bne	r2,zero,8114044c <__reset+0xfb12044c>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
811404ac:	e0bffe17 	ldw	r2,-8(fp)
811404b0:	10800203 	ldbu	r2,8(r2)
811404b4:	10803fcc 	andi	r2,r2,255
811404b8:	10800820 	cmpeqi	r2,r2,32
811404bc:	1000241e 	bne	r2,zero,81140550 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
811404c0:	e0bffd17 	ldw	r2,-12(fp)
811404c4:	e0ffff17 	ldw	r3,-4(fp)
811404c8:	1885883a 	add	r2,r3,r2
811404cc:	00c00b84 	movi	r3,46
811404d0:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
811404d4:	e0bffd17 	ldw	r2,-12(fp)
811404d8:	10800044 	addi	r2,r2,1
811404dc:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
811404e0:	e03ffc15 	stw	zero,-16(fp)
811404e4:	00001706 	br	81140544 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
811404e8:	e0fffe17 	ldw	r3,-8(fp)
811404ec:	e0bffc17 	ldw	r2,-16(fp)
811404f0:	1885883a 	add	r2,r3,r2
811404f4:	10800204 	addi	r2,r2,8
811404f8:	10800003 	ldbu	r2,0(r2)
811404fc:	10803fcc 	andi	r2,r2,255
81140500:	10800820 	cmpeqi	r2,r2,32
81140504:	10000c1e 	bne	r2,zero,81140538 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81140508:	e0bffd17 	ldw	r2,-12(fp)
8114050c:	e0ffff17 	ldw	r3,-4(fp)
81140510:	1885883a 	add	r2,r3,r2
81140514:	e13ffe17 	ldw	r4,-8(fp)
81140518:	e0fffc17 	ldw	r3,-16(fp)
8114051c:	20c7883a 	add	r3,r4,r3
81140520:	18c00204 	addi	r3,r3,8
81140524:	18c00003 	ldbu	r3,0(r3)
81140528:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
8114052c:	e0bffd17 	ldw	r2,-12(fp)
81140530:	10800044 	addi	r2,r2,1
81140534:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81140538:	e0bffc17 	ldw	r2,-16(fp)
8114053c:	10800044 	addi	r2,r2,1
81140540:	e0bffc15 	stw	r2,-16(fp)
81140544:	e0bffc17 	ldw	r2,-16(fp)
81140548:	108000d0 	cmplti	r2,r2,3
8114054c:	103fe61e 	bne	r2,zero,811404e8 <__reset+0xfb1204e8>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81140550:	e0bffd17 	ldw	r2,-12(fp)
81140554:	e0ffff17 	ldw	r3,-4(fp)
81140558:	1885883a 	add	r2,r3,r2
8114055c:	10000005 	stb	zero,0(r2)
}
81140560:	0001883a 	nop
81140564:	e037883a 	mov	sp,fp
81140568:	df000017 	ldw	fp,0(sp)
8114056c:	dec00104 	addi	sp,sp,4
81140570:	f800283a 	ret

81140574 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81140574:	defffc04 	addi	sp,sp,-16
81140578:	de00012e 	bgeu	sp,et,81140580 <alt_up_sd_card_open_dev+0xc>
8114057c:	003b68fa 	trap	3
81140580:	dfc00315 	stw	ra,12(sp)
81140584:	df000215 	stw	fp,8(sp)
81140588:	df000204 	addi	fp,sp,8
8114058c:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81140590:	d1600d04 	addi	r5,gp,-32716
81140594:	e13fff17 	ldw	r4,-4(fp)
81140598:	1145a300 	call	81145a30 <alt_find_dev>
8114059c:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
811405a0:	e0bffe17 	ldw	r2,-8(fp)
811405a4:	10001e26 	beq	r2,zero,81140620 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
811405a8:	e0bffe17 	ldw	r2,-8(fp)
811405ac:	10800a17 	ldw	r2,40(r2)
811405b0:	10808d04 	addi	r2,r2,564
811405b4:	d0a0a615 	stw	r2,-32104(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
811405b8:	e0bffe17 	ldw	r2,-8(fp)
811405bc:	10800a17 	ldw	r2,40(r2)
811405c0:	10808904 	addi	r2,r2,548
811405c4:	d0a0a715 	stw	r2,-32100(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
811405c8:	e0bffe17 	ldw	r2,-8(fp)
811405cc:	10800a17 	ldw	r2,40(r2)
811405d0:	10808404 	addi	r2,r2,528
811405d4:	d0a0a815 	stw	r2,-32096(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
811405d8:	e0bffe17 	ldw	r2,-8(fp)
811405dc:	10800a17 	ldw	r2,40(r2)
811405e0:	10808c04 	addi	r2,r2,560
811405e4:	d0a0a915 	stw	r2,-32092(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
811405e8:	e0bffe17 	ldw	r2,-8(fp)
811405ec:	10800a17 	ldw	r2,40(r2)
811405f0:	10808b04 	addi	r2,r2,556
811405f4:	d0a0aa15 	stw	r2,-32088(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
811405f8:	e0bffe17 	ldw	r2,-8(fp)
811405fc:	10800a17 	ldw	r2,40(r2)
81140600:	d0a0ab15 	stw	r2,-32084(gp)
		device_pointer = dev;
81140604:	e0bffe17 	ldw	r2,-8(fp)
81140608:	d0a0ae15 	stw	r2,-32072(gp)
		initialized = false;
8114060c:	d020a415 	stw	zero,-32112(gp)
		is_sd_card_formated_as_FAT16 = false;
81140610:	d020a515 	stw	zero,-32108(gp)
		search_data.valid = false;
81140614:	00a045b4 	movhi	r2,33046
81140618:	109e3804 	addi	r2,r2,30944
8114061c:	10000415 	stw	zero,16(r2)
	}
	return dev;
81140620:	e0bffe17 	ldw	r2,-8(fp)
}
81140624:	e037883a 	mov	sp,fp
81140628:	dfc00117 	ldw	ra,4(sp)
8114062c:	df000017 	ldw	fp,0(sp)
81140630:	dec00204 	addi	sp,sp,8
81140634:	f800283a 	ret

81140638 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81140638:	defffd04 	addi	sp,sp,-12
8114063c:	de00012e 	bgeu	sp,et,81140644 <alt_up_sd_card_is_Present+0xc>
81140640:	003b68fa 	trap	3
81140644:	df000215 	stw	fp,8(sp)
81140648:	df000204 	addi	fp,sp,8
    bool result = false;
8114064c:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81140650:	d0a0ae17 	ldw	r2,-32072(gp)
81140654:	10000826 	beq	r2,zero,81140678 <alt_up_sd_card_is_Present+0x40>
81140658:	d0a0a617 	ldw	r2,-32104(gp)
8114065c:	1080002b 	ldhuio	r2,0(r2)
81140660:	10bfffcc 	andi	r2,r2,65535
81140664:	1080008c 	andi	r2,r2,2
81140668:	10000326 	beq	r2,zero,81140678 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
8114066c:	00800044 	movi	r2,1
81140670:	e0bffe15 	stw	r2,-8(fp)
81140674:	00001e06 	br	811406f0 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81140678:	d0a0a417 	ldw	r2,-32112(gp)
8114067c:	10800058 	cmpnei	r2,r2,1
81140680:	10001b1e 	bne	r2,zero,811406f0 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81140684:	d020a415 	stw	zero,-32112(gp)
		search_data.valid = false;
81140688:	00a045b4 	movhi	r2,33046
8114068c:	109e3804 	addi	r2,r2,30944
81140690:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81140694:	d020a515 	stw	zero,-32108(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81140698:	e03fff15 	stw	zero,-4(fp)
8114069c:	00001106 	br	811406e4 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
811406a0:	00a045b4 	movhi	r2,33046
811406a4:	109e5204 	addi	r2,r2,31048
811406a8:	e0ffff17 	ldw	r3,-4(fp)
811406ac:	180691ba 	slli	r3,r3,6
811406b0:	10c5883a 	add	r2,r2,r3
811406b4:	10800f04 	addi	r2,r2,60
811406b8:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
811406bc:	00a045b4 	movhi	r2,33046
811406c0:	109e5204 	addi	r2,r2,31048
811406c4:	e0ffff17 	ldw	r3,-4(fp)
811406c8:	180691ba 	slli	r3,r3,6
811406cc:	10c5883a 	add	r2,r2,r3
811406d0:	10800e04 	addi	r2,r2,56
811406d4:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
811406d8:	e0bfff17 	ldw	r2,-4(fp)
811406dc:	10800044 	addi	r2,r2,1
811406e0:	e0bfff15 	stw	r2,-4(fp)
811406e4:	e0bfff17 	ldw	r2,-4(fp)
811406e8:	10800510 	cmplti	r2,r2,20
811406ec:	103fec1e 	bne	r2,zero,811406a0 <__reset+0xfb1206a0>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
811406f0:	e0bffe17 	ldw	r2,-8(fp)
}
811406f4:	e037883a 	mov	sp,fp
811406f8:	df000017 	ldw	fp,0(sp)
811406fc:	dec00104 	addi	sp,sp,4
81140700:	f800283a 	ret

81140704 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81140704:	defffd04 	addi	sp,sp,-12
81140708:	de00012e 	bgeu	sp,et,81140710 <alt_up_sd_card_is_FAT16+0xc>
8114070c:	003b68fa 	trap	3
81140710:	dfc00215 	stw	ra,8(sp)
81140714:	df000115 	stw	fp,4(sp)
81140718:	df000104 	addi	fp,sp,4
	bool result = false;
8114071c:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81140720:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
81140724:	10000c26 	beq	r2,zero,81140758 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81140728:	d0a0a417 	ldw	r2,-32112(gp)
8114072c:	1000071e 	bne	r2,zero,8114074c <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81140730:	113e9300 	call	8113e930 <Look_for_FAT16>
81140734:	d0a0a515 	stw	r2,-32108(gp)
			initialized = is_sd_card_formated_as_FAT16;
81140738:	d0a0a517 	ldw	r2,-32108(gp)
8114073c:	d0a0a415 	stw	r2,-32112(gp)
			search_data.valid = false;
81140740:	00a045b4 	movhi	r2,33046
81140744:	109e3804 	addi	r2,r2,30944
81140748:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
8114074c:	d0a0a517 	ldw	r2,-32108(gp)
81140750:	e0bfff15 	stw	r2,-4(fp)
81140754:	00000206 	br	81140760 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81140758:	d020a415 	stw	zero,-32112(gp)
		is_sd_card_formated_as_FAT16 = false;
8114075c:	d020a515 	stw	zero,-32108(gp)
	}

	return result;
81140760:	e0bfff17 	ldw	r2,-4(fp)
}
81140764:	e037883a 	mov	sp,fp
81140768:	dfc00117 	ldw	ra,4(sp)
8114076c:	df000017 	ldw	fp,0(sp)
81140770:	dec00204 	addi	sp,sp,8
81140774:	f800283a 	ret

81140778 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81140778:	deffea04 	addi	sp,sp,-88
8114077c:	de00012e 	bgeu	sp,et,81140784 <alt_up_sd_card_find_first+0xc>
81140780:	003b68fa 	trap	3
81140784:	dfc01515 	stw	ra,84(sp)
81140788:	df001415 	stw	fp,80(sp)
8114078c:	df001404 	addi	fp,sp,80
81140790:	e13ffe15 	stw	r4,-8(fp)
81140794:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81140798:	00800084 	movi	r2,2
8114079c:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811407a0:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
811407a4:	10002426 	beq	r2,zero,81140838 <alt_up_sd_card_find_first+0xc0>
811407a8:	d0a0a517 	ldw	r2,-32108(gp)
811407ac:	10002226 	beq	r2,zero,81140838 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
811407b0:	e0ffee04 	addi	r3,fp,-72
811407b4:	e0bfed04 	addi	r2,fp,-76
811407b8:	180d883a 	mov	r6,r3
811407bc:	100b883a 	mov	r5,r2
811407c0:	e13ffe17 	ldw	r4,-8(fp)
811407c4:	113f0c80 	call	8113f0c8 <get_home_directory_cluster_for_file>
811407c8:	10001926 	beq	r2,zero,81140830 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
811407cc:	e0bfed17 	ldw	r2,-76(fp)
811407d0:	1007883a 	mov	r3,r2
811407d4:	00a045b4 	movhi	r2,33046
811407d8:	109e3804 	addi	r2,r2,30944
811407dc:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
811407e0:	e0bfed17 	ldw	r2,-76(fp)
811407e4:	1007883a 	mov	r3,r2
811407e8:	00a045b4 	movhi	r2,33046
811407ec:	109e3804 	addi	r2,r2,30944
811407f0:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
811407f4:	00a045b4 	movhi	r2,33046
811407f8:	109e3804 	addi	r2,r2,30944
811407fc:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81140800:	00a045b4 	movhi	r2,33046
81140804:	109e3804 	addi	r2,r2,30944
81140808:	00ffffc4 	movi	r3,-1
8114080c:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81140810:	00a045b4 	movhi	r2,33046
81140814:	109e3804 	addi	r2,r2,30944
81140818:	00c00044 	movi	r3,1
8114081c:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81140820:	e13fff17 	ldw	r4,-4(fp)
81140824:	11408500 	call	81140850 <alt_up_sd_card_find_next>
81140828:	e0bfec0d 	sth	r2,-80(fp)
8114082c:	00000206 	br	81140838 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81140830:	00800044 	movi	r2,1
81140834:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81140838:	e0bfec0b 	ldhu	r2,-80(fp)
}
8114083c:	e037883a 	mov	sp,fp
81140840:	dfc00117 	ldw	ra,4(sp)
81140844:	df000017 	ldw	fp,0(sp)
81140848:	dec00204 	addi	sp,sp,8
8114084c:	f800283a 	ret

81140850 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81140850:	deffe404 	addi	sp,sp,-112
81140854:	de00012e 	bgeu	sp,et,8114085c <alt_up_sd_card_find_next+0xc>
81140858:	003b68fa 	trap	3
8114085c:	dfc01b15 	stw	ra,108(sp)
81140860:	df001a15 	stw	fp,104(sp)
81140864:	df001a04 	addi	fp,sp,104
81140868:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
8114086c:	00800084 	movi	r2,2
81140870:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81140874:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
81140878:	1000df26 	beq	r2,zero,81140bf8 <alt_up_sd_card_find_next+0x3a8>
8114087c:	d0a0a517 	ldw	r2,-32108(gp)
81140880:	1000dd26 	beq	r2,zero,81140bf8 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81140884:	00a045b4 	movhi	r2,33046
81140888:	109e3804 	addi	r2,r2,30944
8114088c:	10800417 	ldw	r2,16(r2)
81140890:	1000d726 	beq	r2,zero,81140bf0 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81140894:	00a045b4 	movhi	r2,33046
81140898:	109e3804 	addi	r2,r2,30944
8114089c:	10800117 	ldw	r2,4(r2)
811408a0:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
811408a4:	e0bfe717 	ldw	r2,-100(fp)
811408a8:	1000561e 	bne	r2,zero,81140a04 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811408ac:	00a045b4 	movhi	r2,33046
811408b0:	109e3d04 	addi	r2,r2,30964
811408b4:	1080050b 	ldhu	r2,20(r2)
811408b8:	10bfffcc 	andi	r2,r2,65535
811408bc:	1006917a 	slli	r3,r2,5
811408c0:	00a045b4 	movhi	r2,33046
811408c4:	109e3d04 	addi	r2,r2,30964
811408c8:	1080030b 	ldhu	r2,12(r2)
811408cc:	10bfffcc 	andi	r2,r2,65535
811408d0:	1885283a 	div	r2,r3,r2
811408d4:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
811408d8:	00a045b4 	movhi	r2,33046
811408dc:	109e3804 	addi	r2,r2,30944
811408e0:	10800217 	ldw	r2,8(r2)
811408e4:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
811408e8:	00a045b4 	movhi	r2,33046
811408ec:	109e3804 	addi	r2,r2,30944
811408f0:	1080030b 	ldhu	r2,12(r2)
811408f4:	10bfffcc 	andi	r2,r2,65535
811408f8:	10a0001c 	xori	r2,r2,32768
811408fc:	10a00004 	addi	r2,r2,-32768
81140900:	10800044 	addi	r2,r2,1
81140904:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81140908:	00003606 	br	811409e4 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8114090c:	00a045b4 	movhi	r2,33046
81140910:	109e3d04 	addi	r2,r2,30964
81140914:	10c01317 	ldw	r3,76(r2)
81140918:	e0bfe817 	ldw	r2,-96(fp)
8114091c:	1885883a 	add	r2,r3,r2
81140920:	1007883a 	mov	r3,r2
81140924:	d0a0ac17 	ldw	r2,-32080(gp)
81140928:	100b883a 	mov	r5,r2
8114092c:	1809883a 	mov	r4,r3
81140930:	113d9600 	call	8113d960 <Read_Sector_Data>
81140934:	10002f26 	beq	r2,zero,811409f4 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81140938:	00002306 	br	811409c8 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
8114093c:	e0bfe917 	ldw	r2,-92(fp)
81140940:	1004917a 	slli	r2,r2,5
81140944:	e13fe817 	ldw	r4,-96(fp)
81140948:	e0ffef04 	addi	r3,fp,-68
8114094c:	200f883a 	mov	r7,r4
81140950:	000d883a 	mov	r6,zero
81140954:	180b883a 	mov	r5,r3
81140958:	1009883a 	mov	r4,r2
8114095c:	113dd900 	call	8113dd90 <Read_File_Record_At_Offset>
81140960:	10001626 	beq	r2,zero,811409bc <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81140964:	e0bfef03 	ldbu	r2,-68(fp)
81140968:	10803fcc 	andi	r2,r2,255
8114096c:	10001326 	beq	r2,zero,811409bc <alt_up_sd_card_find_next+0x16c>
81140970:	e0bfef03 	ldbu	r2,-68(fp)
81140974:	10803fcc 	andi	r2,r2,255
81140978:	10803960 	cmpeqi	r2,r2,229
8114097c:	10000f1e 	bne	r2,zero,811409bc <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
81140980:	e0bfe917 	ldw	r2,-92(fp)
81140984:	1007883a 	mov	r3,r2
81140988:	00a045b4 	movhi	r2,33046
8114098c:	109e3804 	addi	r2,r2,30944
81140990:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81140994:	e0ffe817 	ldw	r3,-96(fp)
81140998:	00a045b4 	movhi	r2,33046
8114099c:	109e3804 	addi	r2,r2,30944
811409a0:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
811409a4:	e0bfef04 	addi	r2,fp,-68
811409a8:	e17fff17 	ldw	r5,-4(fp)
811409ac:	1009883a 	mov	r4,r2
811409b0:	11404240 	call	81140424 <copy_file_record_name_to_string>
									return 0;
811409b4:	0005883a 	mov	r2,zero
811409b8:	00009006 	br	81140bfc <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
811409bc:	e0bfe917 	ldw	r2,-92(fp)
811409c0:	10800044 	addi	r2,r2,1
811409c4:	e0bfe915 	stw	r2,-92(fp)
811409c8:	e0bfe917 	ldw	r2,-92(fp)
811409cc:	10800410 	cmplti	r2,r2,16
811409d0:	103fda1e 	bne	r2,zero,8114093c <__reset+0xfb12093c>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
811409d4:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811409d8:	e0bfe817 	ldw	r2,-96(fp)
811409dc:	10800044 	addi	r2,r2,1
811409e0:	e0bfe815 	stw	r2,-96(fp)
811409e4:	e0ffe817 	ldw	r3,-96(fp)
811409e8:	e0bfec17 	ldw	r2,-80(fp)
811409ec:	18bfc716 	blt	r3,r2,8114090c <__reset+0xfb12090c>
811409f0:	00000106 	br	811409f8 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
811409f4:	0001883a 	nop
					}
				}
				result = -1;
811409f8:	00bfffc4 	movi	r2,-1
811409fc:	e0bfe60d 	sth	r2,-104(fp)
81140a00:	00007d06 	br	81140bf8 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81140a04:	00a045b4 	movhi	r2,33046
81140a08:	109e3804 	addi	r2,r2,30944
81140a0c:	1080030b 	ldhu	r2,12(r2)
81140a10:	10bfffcc 	andi	r2,r2,65535
81140a14:	10a0001c 	xori	r2,r2,32768
81140a18:	10a00004 	addi	r2,r2,-32768
81140a1c:	10800044 	addi	r2,r2,1
81140a20:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81140a24:	e0bfe717 	ldw	r2,-100(fp)
81140a28:	10ffff84 	addi	r3,r2,-2
81140a2c:	00a045b4 	movhi	r2,33046
81140a30:	109e3d04 	addi	r2,r2,30964
81140a34:	10800383 	ldbu	r2,14(r2)
81140a38:	10803fcc 	andi	r2,r2,255
81140a3c:	1885383a 	mul	r2,r3,r2
81140a40:	1007883a 	mov	r3,r2
81140a44:	00a045b4 	movhi	r2,33046
81140a48:	109e3d04 	addi	r2,r2,30964
81140a4c:	10801417 	ldw	r2,80(r2)
81140a50:	1885883a 	add	r2,r3,r2
81140a54:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81140a58:	00a045b4 	movhi	r2,33046
81140a5c:	109e3804 	addi	r2,r2,30944
81140a60:	10800217 	ldw	r2,8(r2)
81140a64:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81140a68:	00003806 	br	81140b4c <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81140a6c:	e0ffeb17 	ldw	r3,-84(fp)
81140a70:	e0bfed17 	ldw	r2,-76(fp)
81140a74:	1885883a 	add	r2,r3,r2
81140a78:	d0e0ac17 	ldw	r3,-32080(gp)
81140a7c:	180b883a 	mov	r5,r3
81140a80:	1009883a 	mov	r4,r2
81140a84:	113d9600 	call	8113d960 <Read_Sector_Data>
81140a88:	10003726 	beq	r2,zero,81140b68 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81140a8c:	00002806 	br	81140b30 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
81140a90:	e0bfea17 	ldw	r2,-88(fp)
81140a94:	1004917a 	slli	r2,r2,5
81140a98:	e13fe717 	ldw	r4,-100(fp)
81140a9c:	e17feb17 	ldw	r5,-84(fp)
81140aa0:	e0ffef04 	addi	r3,fp,-68
81140aa4:	280f883a 	mov	r7,r5
81140aa8:	200d883a 	mov	r6,r4
81140aac:	180b883a 	mov	r5,r3
81140ab0:	1009883a 	mov	r4,r2
81140ab4:	113dd900 	call	8113dd90 <Read_File_Record_At_Offset>
81140ab8:	10001a26 	beq	r2,zero,81140b24 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81140abc:	e0bfef03 	ldbu	r2,-68(fp)
81140ac0:	10803fcc 	andi	r2,r2,255
81140ac4:	10001726 	beq	r2,zero,81140b24 <alt_up_sd_card_find_next+0x2d4>
81140ac8:	e0bfef03 	ldbu	r2,-68(fp)
81140acc:	10803fcc 	andi	r2,r2,255
81140ad0:	10803960 	cmpeqi	r2,r2,229
81140ad4:	1000131e 	bne	r2,zero,81140b24 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
81140ad8:	e0ffe717 	ldw	r3,-100(fp)
81140adc:	00a045b4 	movhi	r2,33046
81140ae0:	109e3804 	addi	r2,r2,30944
81140ae4:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
81140ae8:	e0bfea17 	ldw	r2,-88(fp)
81140aec:	1007883a 	mov	r3,r2
81140af0:	00a045b4 	movhi	r2,33046
81140af4:	109e3804 	addi	r2,r2,30944
81140af8:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
81140afc:	e0ffeb17 	ldw	r3,-84(fp)
81140b00:	00a045b4 	movhi	r2,33046
81140b04:	109e3804 	addi	r2,r2,30944
81140b08:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81140b0c:	e0bfef04 	addi	r2,fp,-68
81140b10:	e17fff17 	ldw	r5,-4(fp)
81140b14:	1009883a 	mov	r4,r2
81140b18:	11404240 	call	81140424 <copy_file_record_name_to_string>
										return 0;
81140b1c:	0005883a 	mov	r2,zero
81140b20:	00003606 	br	81140bfc <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81140b24:	e0bfea17 	ldw	r2,-88(fp)
81140b28:	10800044 	addi	r2,r2,1
81140b2c:	e0bfea15 	stw	r2,-88(fp)
81140b30:	e0bfea17 	ldw	r2,-88(fp)
81140b34:	10800410 	cmplti	r2,r2,16
81140b38:	103fd51e 	bne	r2,zero,81140a90 <__reset+0xfb120a90>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81140b3c:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81140b40:	e0bfeb17 	ldw	r2,-84(fp)
81140b44:	10800044 	addi	r2,r2,1
81140b48:	e0bfeb15 	stw	r2,-84(fp)
81140b4c:	00a045b4 	movhi	r2,33046
81140b50:	109e3d04 	addi	r2,r2,30964
81140b54:	10800383 	ldbu	r2,14(r2)
81140b58:	10803fcc 	andi	r2,r2,255
81140b5c:	e0ffeb17 	ldw	r3,-84(fp)
81140b60:	18bfc216 	blt	r3,r2,81140a6c <__reset+0xfb120a6c>
81140b64:	00000106 	br	81140b6c <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81140b68:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81140b6c:	00a045b4 	movhi	r2,33046
81140b70:	109e3d04 	addi	r2,r2,30964
81140b74:	10800383 	ldbu	r2,14(r2)
81140b78:	10803fcc 	andi	r2,r2,255
81140b7c:	e0ffeb17 	ldw	r3,-84(fp)
81140b80:	18801716 	blt	r3,r2,81140be0 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81140b84:	e0bfe717 	ldw	r2,-100(fp)
81140b88:	e0ffee04 	addi	r3,fp,-72
81140b8c:	180b883a 	mov	r5,r3
81140b90:	1009883a 	mov	r4,r2
81140b94:	113da400 	call	8113da40 <get_cluster_flag>
81140b98:	10000f26 	beq	r2,zero,81140bd8 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81140b9c:	e0bfee0b 	ldhu	r2,-72(fp)
81140ba0:	10bfffcc 	andi	r2,r2,65535
81140ba4:	10fffe0c 	andi	r3,r2,65528
81140ba8:	00bffe14 	movui	r2,65528
81140bac:	1880051e 	bne	r3,r2,81140bc4 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
81140bb0:	00bfffc4 	movi	r2,-1
81140bb4:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
81140bb8:	00a045b4 	movhi	r2,33046
81140bbc:	109e3804 	addi	r2,r2,30944
81140bc0:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81140bc4:	e0bfee0b 	ldhu	r2,-72(fp)
81140bc8:	10bfffcc 	andi	r2,r2,65535
81140bcc:	10bffe0c 	andi	r2,r2,65528
81140bd0:	e0bfe715 	stw	r2,-100(fp)
81140bd4:	00000206 	br	81140be0 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
81140bd8:	00bfffc4 	movi	r2,-1
81140bdc:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
81140be0:	e0bfe717 	ldw	r2,-100(fp)
81140be4:	00fffdd4 	movui	r3,65527
81140be8:	18bf8e0e 	bge	r3,r2,81140a24 <__reset+0xfb120a24>
81140bec:	00000206 	br	81140bf8 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81140bf0:	008000c4 	movi	r2,3
81140bf4:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
81140bf8:	e0bfe60b 	ldhu	r2,-104(fp)
}
81140bfc:	e037883a 	mov	sp,fp
81140c00:	dfc00117 	ldw	ra,4(sp)
81140c04:	df000017 	ldw	fp,0(sp)
81140c08:	dec00204 	addi	sp,sp,8
81140c0c:	f800283a 	ret

81140c10 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81140c10:	deffe904 	addi	sp,sp,-92
81140c14:	de00012e 	bgeu	sp,et,81140c1c <alt_up_sd_card_fopen+0xc>
81140c18:	003b68fa 	trap	3
81140c1c:	dfc01615 	stw	ra,88(sp)
81140c20:	df001515 	stw	fp,84(sp)
81140c24:	df001504 	addi	fp,sp,84
81140c28:	e13ffe15 	stw	r4,-8(fp)
81140c2c:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81140c30:	00bfffc4 	movi	r2,-1
81140c34:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81140c38:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
81140c3c:	1000cf26 	beq	r2,zero,81140f7c <alt_up_sd_card_fopen+0x36c>
81140c40:	d0a0a517 	ldw	r2,-32108(gp)
81140c44:	1000cd26 	beq	r2,zero,81140f7c <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81140c48:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81140c4c:	e13ffe17 	ldw	r4,-8(fp)
81140c50:	113ea240 	call	8113ea24 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81140c54:	e13ffe17 	ldw	r4,-8(fp)
81140c58:	113eaf00 	call	8113eaf0 <check_file_name_for_FAT16_compliance>
81140c5c:	1000c726 	beq	r2,zero,81140f7c <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
81140c60:	e0ffee04 	addi	r3,fp,-72
81140c64:	e0bfed04 	addi	r2,fp,-76
81140c68:	180d883a 	mov	r6,r3
81140c6c:	100b883a 	mov	r5,r2
81140c70:	e13ffe17 	ldw	r4,-8(fp)
81140c74:	113f0c80 	call	8113f0c8 <get_home_directory_cluster_for_file>
81140c78:	1000021e 	bne	r2,zero,81140c84 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81140c7c:	e0bfeb0b 	ldhu	r2,-84(fp)
81140c80:	0000bf06 	br	81140f80 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81140c84:	e03fec15 	stw	zero,-80(fp)
81140c88:	00000e06 	br	81140cc4 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
81140c8c:	00a045b4 	movhi	r2,33046
81140c90:	109e5204 	addi	r2,r2,31048
81140c94:	e0ffec17 	ldw	r3,-80(fp)
81140c98:	180691ba 	slli	r3,r3,6
81140c9c:	10c5883a 	add	r2,r2,r3
81140ca0:	10800f04 	addi	r2,r2,60
81140ca4:	10800017 	ldw	r2,0(r2)
81140ca8:	1000031e 	bne	r2,zero,81140cb8 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
81140cac:	e0bfec17 	ldw	r2,-80(fp)
81140cb0:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
81140cb4:	00000606 	br	81140cd0 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81140cb8:	e0bfec17 	ldw	r2,-80(fp)
81140cbc:	10800044 	addi	r2,r2,1
81140cc0:	e0bfec15 	stw	r2,-80(fp)
81140cc4:	e0bfec17 	ldw	r2,-80(fp)
81140cc8:	10800510 	cmplti	r2,r2,20
81140ccc:	103fef1e 	bne	r2,zero,81140c8c <__reset+0xfb120c8c>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
81140cd0:	e0bfeb0f 	ldh	r2,-84(fp)
81140cd4:	1000a916 	blt	r2,zero,81140f7c <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
81140cd8:	e0bfed17 	ldw	r2,-76(fp)
81140cdc:	1009883a 	mov	r4,r2
81140ce0:	e0bfeb0f 	ldh	r2,-84(fp)
81140ce4:	100691ba 	slli	r3,r2,6
81140ce8:	00a045b4 	movhi	r2,33046
81140cec:	109e5204 	addi	r2,r2,31048
81140cf0:	1885883a 	add	r2,r3,r2
81140cf4:	100d883a 	mov	r6,r2
81140cf8:	e17ffe17 	ldw	r5,-8(fp)
81140cfc:	113f6080 	call	8113f608 <find_file_in_directory>
81140d00:	10007b26 	beq	r2,zero,81140ef0 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81140d04:	e0bfff17 	ldw	r2,-4(fp)
81140d08:	10000226 	beq	r2,zero,81140d14 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
81140d0c:	00bfffc4 	movi	r2,-1
81140d10:	00009b06 	br	81140f80 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81140d14:	e13feb0f 	ldh	r4,-84(fp)
81140d18:	e0ffeb0f 	ldh	r3,-84(fp)
81140d1c:	00a045b4 	movhi	r2,33046
81140d20:	109e5204 	addi	r2,r2,31048
81140d24:	180691ba 	slli	r3,r3,6
81140d28:	10c5883a 	add	r2,r2,r3
81140d2c:	10800584 	addi	r2,r2,22
81140d30:	1080000b 	ldhu	r2,0(r2)
81140d34:	10ffffcc 	andi	r3,r2,65535
81140d38:	00a045b4 	movhi	r2,33046
81140d3c:	109e5204 	addi	r2,r2,31048
81140d40:	200891ba 	slli	r4,r4,6
81140d44:	1105883a 	add	r2,r2,r4
81140d48:	10800704 	addi	r2,r2,28
81140d4c:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
81140d50:	e0ffeb0f 	ldh	r3,-84(fp)
81140d54:	00a045b4 	movhi	r2,33046
81140d58:	109e5204 	addi	r2,r2,31048
81140d5c:	180691ba 	slli	r3,r3,6
81140d60:	10c5883a 	add	r2,r2,r3
81140d64:	10800804 	addi	r2,r2,32
81140d68:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
81140d6c:	e0ffeb0f 	ldh	r3,-84(fp)
81140d70:	00a045b4 	movhi	r2,33046
81140d74:	109e5204 	addi	r2,r2,31048
81140d78:	180691ba 	slli	r3,r3,6
81140d7c:	10c5883a 	add	r2,r2,r3
81140d80:	10800904 	addi	r2,r2,36
81140d84:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
81140d88:	e0ffeb0f 	ldh	r3,-84(fp)
81140d8c:	00a045b4 	movhi	r2,33046
81140d90:	109e5204 	addi	r2,r2,31048
81140d94:	180691ba 	slli	r3,r3,6
81140d98:	10c5883a 	add	r2,r2,r3
81140d9c:	10800f04 	addi	r2,r2,60
81140da0:	00c00044 	movi	r3,1
81140da4:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
81140da8:	e0ffeb0f 	ldh	r3,-84(fp)
81140dac:	00a045b4 	movhi	r2,33046
81140db0:	109e5204 	addi	r2,r2,31048
81140db4:	180691ba 	slli	r3,r3,6
81140db8:	10c5883a 	add	r2,r2,r3
81140dbc:	10800e04 	addi	r2,r2,56
81140dc0:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81140dc4:	e03fec15 	stw	zero,-80(fp)
81140dc8:	00004506 	br	81140ee0 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
81140dcc:	e0ffeb0f 	ldh	r3,-84(fp)
81140dd0:	e0bfec17 	ldw	r2,-80(fp)
81140dd4:	18803f26 	beq	r3,r2,81140ed4 <alt_up_sd_card_fopen+0x2c4>
81140dd8:	00a045b4 	movhi	r2,33046
81140ddc:	109e5204 	addi	r2,r2,31048
81140de0:	e0ffec17 	ldw	r3,-80(fp)
81140de4:	180691ba 	slli	r3,r3,6
81140de8:	10c5883a 	add	r2,r2,r3
81140dec:	10800f04 	addi	r2,r2,60
81140df0:	10800017 	ldw	r2,0(r2)
81140df4:	10800058 	cmpnei	r2,r2,1
81140df8:	1000361e 	bne	r2,zero,81140ed4 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81140dfc:	e0ffeb0f 	ldh	r3,-84(fp)
81140e00:	00a045b4 	movhi	r2,33046
81140e04:	109e5204 	addi	r2,r2,31048
81140e08:	180691ba 	slli	r3,r3,6
81140e0c:	10c5883a 	add	r2,r2,r3
81140e10:	10800a04 	addi	r2,r2,40
81140e14:	10c00017 	ldw	r3,0(r2)
81140e18:	00a045b4 	movhi	r2,33046
81140e1c:	109e5204 	addi	r2,r2,31048
81140e20:	e13fec17 	ldw	r4,-80(fp)
81140e24:	200891ba 	slli	r4,r4,6
81140e28:	1105883a 	add	r2,r2,r4
81140e2c:	10800a04 	addi	r2,r2,40
81140e30:	10800017 	ldw	r2,0(r2)
81140e34:	1880271e 	bne	r3,r2,81140ed4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81140e38:	e0ffeb0f 	ldh	r3,-84(fp)
81140e3c:	00a045b4 	movhi	r2,33046
81140e40:	109e5204 	addi	r2,r2,31048
81140e44:	180691ba 	slli	r3,r3,6
81140e48:	10c5883a 	add	r2,r2,r3
81140e4c:	10800b04 	addi	r2,r2,44
81140e50:	10c00017 	ldw	r3,0(r2)
81140e54:	00a045b4 	movhi	r2,33046
81140e58:	109e5204 	addi	r2,r2,31048
81140e5c:	e13fec17 	ldw	r4,-80(fp)
81140e60:	200891ba 	slli	r4,r4,6
81140e64:	1105883a 	add	r2,r2,r4
81140e68:	10800b04 	addi	r2,r2,44
81140e6c:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81140e70:	1880181e 	bne	r3,r2,81140ed4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81140e74:	e0ffeb0f 	ldh	r3,-84(fp)
81140e78:	00a045b4 	movhi	r2,33046
81140e7c:	109e5204 	addi	r2,r2,31048
81140e80:	180691ba 	slli	r3,r3,6
81140e84:	10c5883a 	add	r2,r2,r3
81140e88:	10800c04 	addi	r2,r2,48
81140e8c:	1100000b 	ldhu	r4,0(r2)
81140e90:	00a045b4 	movhi	r2,33046
81140e94:	109e5204 	addi	r2,r2,31048
81140e98:	e0ffec17 	ldw	r3,-80(fp)
81140e9c:	180691ba 	slli	r3,r3,6
81140ea0:	10c5883a 	add	r2,r2,r3
81140ea4:	10800c04 	addi	r2,r2,48
81140ea8:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81140eac:	20ffffcc 	andi	r3,r4,65535
81140eb0:	18e0001c 	xori	r3,r3,32768
81140eb4:	18e00004 	addi	r3,r3,-32768
81140eb8:	10bfffcc 	andi	r2,r2,65535
81140ebc:	10a0001c 	xori	r2,r2,32768
81140ec0:	10a00004 	addi	r2,r2,-32768
81140ec4:	1880031e 	bne	r3,r2,81140ed4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
81140ec8:	00bfff84 	movi	r2,-2
81140ecc:	e0bfeb0d 	sth	r2,-84(fp)
								break;
81140ed0:	00002a06 	br	81140f7c <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81140ed4:	e0bfec17 	ldw	r2,-80(fp)
81140ed8:	10800044 	addi	r2,r2,1
81140edc:	e0bfec15 	stw	r2,-80(fp)
81140ee0:	e0bfec17 	ldw	r2,-80(fp)
81140ee4:	10800510 	cmplti	r2,r2,20
81140ee8:	103fb81e 	bne	r2,zero,81140dcc <__reset+0xfb120dcc>
81140eec:	00002306 	br	81140f7c <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81140ef0:	e0bfff17 	ldw	r2,-4(fp)
81140ef4:	10001f26 	beq	r2,zero,81140f74 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
81140ef8:	e0bfeb0f 	ldh	r2,-84(fp)
81140efc:	100691ba 	slli	r3,r2,6
81140f00:	00a045b4 	movhi	r2,33046
81140f04:	109e5204 	addi	r2,r2,31048
81140f08:	1885883a 	add	r2,r3,r2
81140f0c:	e0ffee04 	addi	r3,fp,-72
81140f10:	180d883a 	mov	r6,r3
81140f14:	100b883a 	mov	r5,r2
81140f18:	e13ffe17 	ldw	r4,-8(fp)
81140f1c:	11401540 	call	81140154 <create_file>
81140f20:	10001126 	beq	r2,zero,81140f68 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81140f24:	e0ffeb0f 	ldh	r3,-84(fp)
81140f28:	00a045b4 	movhi	r2,33046
81140f2c:	109e5204 	addi	r2,r2,31048
81140f30:	180691ba 	slli	r3,r3,6
81140f34:	10c5883a 	add	r2,r2,r3
81140f38:	10800f04 	addi	r2,r2,60
81140f3c:	00c00044 	movi	r3,1
81140f40:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81140f44:	e0ffeb0f 	ldh	r3,-84(fp)
81140f48:	00a045b4 	movhi	r2,33046
81140f4c:	109e5204 	addi	r2,r2,31048
81140f50:	180691ba 	slli	r3,r3,6
81140f54:	10c5883a 	add	r2,r2,r3
81140f58:	10800e04 	addi	r2,r2,56
81140f5c:	00c00044 	movi	r3,1
81140f60:	10c00015 	stw	r3,0(r2)
81140f64:	00000506 	br	81140f7c <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81140f68:	00bfffc4 	movi	r2,-1
81140f6c:	e0bfeb0d 	sth	r2,-84(fp)
81140f70:	00000206 	br	81140f7c <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81140f74:	00bfffc4 	movi	r2,-1
81140f78:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81140f7c:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81140f80:	e037883a 	mov	sp,fp
81140f84:	dfc00117 	ldw	ra,4(sp)
81140f88:	df000017 	ldw	fp,0(sp)
81140f8c:	dec00204 	addi	sp,sp,8
81140f90:	f800283a 	ret

81140f94 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81140f94:	defffd04 	addi	sp,sp,-12
81140f98:	de00012e 	bgeu	sp,et,81140fa0 <alt_up_sd_card_set_attributes+0xc>
81140f9c:	003b68fa 	trap	3
81140fa0:	df000215 	stw	fp,8(sp)
81140fa4:	df000204 	addi	fp,sp,8
81140fa8:	2007883a 	mov	r3,r4
81140fac:	2805883a 	mov	r2,r5
81140fb0:	e0fffe0d 	sth	r3,-8(fp)
81140fb4:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81140fb8:	e0bffe0f 	ldh	r2,-8(fp)
81140fbc:	10001416 	blt	r2,zero,81141010 <alt_up_sd_card_set_attributes+0x7c>
81140fc0:	e0bffe0f 	ldh	r2,-8(fp)
81140fc4:	10800508 	cmpgei	r2,r2,20
81140fc8:	1000111e 	bne	r2,zero,81141010 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81140fcc:	e0fffe0f 	ldh	r3,-8(fp)
81140fd0:	00a045b4 	movhi	r2,33046
81140fd4:	109e5204 	addi	r2,r2,31048
81140fd8:	180691ba 	slli	r3,r3,6
81140fdc:	10c5883a 	add	r2,r2,r3
81140fe0:	10800f04 	addi	r2,r2,60
81140fe4:	10800017 	ldw	r2,0(r2)
81140fe8:	10000926 	beq	r2,zero,81141010 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
81140fec:	e0fffe0f 	ldh	r3,-8(fp)
81140ff0:	e0bfff0b 	ldhu	r2,-4(fp)
81140ff4:	1009883a 	mov	r4,r2
81140ff8:	00a045b4 	movhi	r2,33046
81140ffc:	109e5204 	addi	r2,r2,31048
81141000:	180691ba 	slli	r3,r3,6
81141004:	10c5883a 	add	r2,r2,r3
81141008:	108002c4 	addi	r2,r2,11
8114100c:	11000005 	stb	r4,0(r2)
        }
    }
}
81141010:	0001883a 	nop
81141014:	e037883a 	mov	sp,fp
81141018:	df000017 	ldw	fp,0(sp)
8114101c:	dec00104 	addi	sp,sp,4
81141020:	f800283a 	ret

81141024 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81141024:	defffd04 	addi	sp,sp,-12
81141028:	de00012e 	bgeu	sp,et,81141030 <alt_up_sd_card_get_attributes+0xc>
8114102c:	003b68fa 	trap	3
81141030:	df000215 	stw	fp,8(sp)
81141034:	df000204 	addi	fp,sp,8
81141038:	2005883a 	mov	r2,r4
8114103c:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81141040:	00bfffc4 	movi	r2,-1
81141044:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81141048:	e0bfff0f 	ldh	r2,-4(fp)
8114104c:	10001416 	blt	r2,zero,811410a0 <alt_up_sd_card_get_attributes+0x7c>
81141050:	e0bfff0f 	ldh	r2,-4(fp)
81141054:	10800508 	cmpgei	r2,r2,20
81141058:	1000111e 	bne	r2,zero,811410a0 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8114105c:	e0ffff0f 	ldh	r3,-4(fp)
81141060:	00a045b4 	movhi	r2,33046
81141064:	109e5204 	addi	r2,r2,31048
81141068:	180691ba 	slli	r3,r3,6
8114106c:	10c5883a 	add	r2,r2,r3
81141070:	10800f04 	addi	r2,r2,60
81141074:	10800017 	ldw	r2,0(r2)
81141078:	10000926 	beq	r2,zero,811410a0 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
8114107c:	e0ffff0f 	ldh	r3,-4(fp)
81141080:	00a045b4 	movhi	r2,33046
81141084:	109e5204 	addi	r2,r2,31048
81141088:	180691ba 	slli	r3,r3,6
8114108c:	10c5883a 	add	r2,r2,r3
81141090:	108002c4 	addi	r2,r2,11
81141094:	10800003 	ldbu	r2,0(r2)
81141098:	10803fcc 	andi	r2,r2,255
8114109c:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
811410a0:	e0bffe0b 	ldhu	r2,-8(fp)
}
811410a4:	e037883a 	mov	sp,fp
811410a8:	df000017 	ldw	fp,0(sp)
811410ac:	dec00104 	addi	sp,sp,4
811410b0:	f800283a 	ret

811410b4 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
811410b4:	defffa04 	addi	sp,sp,-24
811410b8:	de00012e 	bgeu	sp,et,811410c0 <alt_up_sd_card_read+0xc>
811410bc:	003b68fa 	trap	3
811410c0:	dfc00515 	stw	ra,20(sp)
811410c4:	df000415 	stw	fp,16(sp)
811410c8:	df000404 	addi	fp,sp,16
811410cc:	2005883a 	mov	r2,r4
811410d0:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
811410d4:	00bfffc4 	movi	r2,-1
811410d8:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811410dc:	e0bfff0f 	ldh	r2,-4(fp)
811410e0:	1000ce16 	blt	r2,zero,8114141c <alt_up_sd_card_read+0x368>
811410e4:	e0bfff0f 	ldh	r2,-4(fp)
811410e8:	10800508 	cmpgei	r2,r2,20
811410ec:	1000cb1e 	bne	r2,zero,8114141c <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
811410f0:	e0ffff0f 	ldh	r3,-4(fp)
811410f4:	00a045b4 	movhi	r2,33046
811410f8:	109e5204 	addi	r2,r2,31048
811410fc:	180691ba 	slli	r3,r3,6
81141100:	10c5883a 	add	r2,r2,r3
81141104:	10800f04 	addi	r2,r2,60
81141108:	10800017 	ldw	r2,0(r2)
8114110c:	1000c326 	beq	r2,zero,8114141c <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81141110:	e0ffff0f 	ldh	r3,-4(fp)
81141114:	00a045b4 	movhi	r2,33046
81141118:	109e5204 	addi	r2,r2,31048
8114111c:	180691ba 	slli	r3,r3,6
81141120:	10c5883a 	add	r2,r2,r3
81141124:	10800904 	addi	r2,r2,36
81141128:	10c00017 	ldw	r3,0(r2)
8114112c:	e13fff0f 	ldh	r4,-4(fp)
81141130:	00a045b4 	movhi	r2,33046
81141134:	109e5204 	addi	r2,r2,31048
81141138:	200891ba 	slli	r4,r4,6
8114113c:	1105883a 	add	r2,r2,r4
81141140:	10800604 	addi	r2,r2,24
81141144:	10800017 	ldw	r2,0(r2)
81141148:	1880b42e 	bgeu	r3,r2,8114141c <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114114c:	00a045b4 	movhi	r2,33046
81141150:	109e3d04 	addi	r2,r2,30964
81141154:	10c01417 	ldw	r3,80(r2)
81141158:	e13fff0f 	ldh	r4,-4(fp)
8114115c:	00a045b4 	movhi	r2,33046
81141160:	109e5204 	addi	r2,r2,31048
81141164:	200891ba 	slli	r4,r4,6
81141168:	1105883a 	add	r2,r2,r4
8114116c:	10800704 	addi	r2,r2,28
81141170:	10800017 	ldw	r2,0(r2)
81141174:	113fff84 	addi	r4,r2,-2
81141178:	00a045b4 	movhi	r2,33046
8114117c:	109e3d04 	addi	r2,r2,30964
81141180:	10800383 	ldbu	r2,14(r2)
81141184:	10803fcc 	andi	r2,r2,255
81141188:	2085383a 	mul	r2,r4,r2
8114118c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81141190:	e13fff0f 	ldh	r4,-4(fp)
81141194:	00a045b4 	movhi	r2,33046
81141198:	109e5204 	addi	r2,r2,31048
8114119c:	200891ba 	slli	r4,r4,6
811411a0:	1105883a 	add	r2,r2,r4
811411a4:	10800804 	addi	r2,r2,32
811411a8:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811411ac:	1885883a 	add	r2,r3,r2
811411b0:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
811411b4:	e0ffff0f 	ldh	r3,-4(fp)
811411b8:	00a045b4 	movhi	r2,33046
811411bc:	109e5204 	addi	r2,r2,31048
811411c0:	180691ba 	slli	r3,r3,6
811411c4:	10c5883a 	add	r2,r2,r3
811411c8:	10800904 	addi	r2,r2,36
811411cc:	10800017 	ldw	r2,0(r2)
811411d0:	10006826 	beq	r2,zero,81141374 <alt_up_sd_card_read+0x2c0>
811411d4:	e0ffff0f 	ldh	r3,-4(fp)
811411d8:	00a045b4 	movhi	r2,33046
811411dc:	109e5204 	addi	r2,r2,31048
811411e0:	180691ba 	slli	r3,r3,6
811411e4:	10c5883a 	add	r2,r2,r3
811411e8:	10800904 	addi	r2,r2,36
811411ec:	10800017 	ldw	r2,0(r2)
811411f0:	10807fcc 	andi	r2,r2,511
811411f4:	10005f1e 	bne	r2,zero,81141374 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
811411f8:	e0ffff0f 	ldh	r3,-4(fp)
811411fc:	00a045b4 	movhi	r2,33046
81141200:	109e5204 	addi	r2,r2,31048
81141204:	180691ba 	slli	r3,r3,6
81141208:	10c5883a 	add	r2,r2,r3
8114120c:	10800804 	addi	r2,r2,32
81141210:	10c00017 	ldw	r3,0(r2)
81141214:	00a045b4 	movhi	r2,33046
81141218:	109e3d04 	addi	r2,r2,30964
8114121c:	10800383 	ldbu	r2,14(r2)
81141220:	10803fcc 	andi	r2,r2,255
81141224:	10bfffc4 	addi	r2,r2,-1
81141228:	1880401e 	bne	r3,r2,8114132c <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8114122c:	e0ffff0f 	ldh	r3,-4(fp)
81141230:	00a045b4 	movhi	r2,33046
81141234:	109e5204 	addi	r2,r2,31048
81141238:	180691ba 	slli	r3,r3,6
8114123c:	10c5883a 	add	r2,r2,r3
81141240:	10800704 	addi	r2,r2,28
81141244:	10800017 	ldw	r2,0(r2)
81141248:	e0fffe04 	addi	r3,fp,-8
8114124c:	180b883a 	mov	r5,r3
81141250:	1009883a 	mov	r4,r2
81141254:	113da400 	call	8113da40 <get_cluster_flag>
81141258:	10003226 	beq	r2,zero,81141324 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8114125c:	e0bffe0b 	ldhu	r2,-8(fp)
81141260:	10bfffcc 	andi	r2,r2,65535
81141264:	10fffe0c 	andi	r3,r2,65528
81141268:	00bffe14 	movui	r2,65528
8114126c:	1880021e 	bne	r3,r2,81141278 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81141270:	00bfffc4 	movi	r2,-1
81141274:	00006a06 	br	81141420 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81141278:	e13fff0f 	ldh	r4,-4(fp)
8114127c:	e0bffe0b 	ldhu	r2,-8(fp)
81141280:	10ffffcc 	andi	r3,r2,65535
81141284:	00a045b4 	movhi	r2,33046
81141288:	109e5204 	addi	r2,r2,31048
8114128c:	200891ba 	slli	r4,r4,6
81141290:	1105883a 	add	r2,r2,r4
81141294:	10800704 	addi	r2,r2,28
81141298:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8114129c:	e0ffff0f 	ldh	r3,-4(fp)
811412a0:	00a045b4 	movhi	r2,33046
811412a4:	109e5204 	addi	r2,r2,31048
811412a8:	180691ba 	slli	r3,r3,6
811412ac:	10c5883a 	add	r2,r2,r3
811412b0:	10800804 	addi	r2,r2,32
811412b4:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811412b8:	00a045b4 	movhi	r2,33046
811412bc:	109e3d04 	addi	r2,r2,30964
811412c0:	10c01417 	ldw	r3,80(r2)
811412c4:	e13fff0f 	ldh	r4,-4(fp)
811412c8:	00a045b4 	movhi	r2,33046
811412cc:	109e5204 	addi	r2,r2,31048
811412d0:	200891ba 	slli	r4,r4,6
811412d4:	1105883a 	add	r2,r2,r4
811412d8:	10800704 	addi	r2,r2,28
811412dc:	10800017 	ldw	r2,0(r2)
811412e0:	113fff84 	addi	r4,r2,-2
811412e4:	00a045b4 	movhi	r2,33046
811412e8:	109e3d04 	addi	r2,r2,30964
811412ec:	10800383 	ldbu	r2,14(r2)
811412f0:	10803fcc 	andi	r2,r2,255
811412f4:	2085383a 	mul	r2,r4,r2
811412f8:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
811412fc:	e13fff0f 	ldh	r4,-4(fp)
81141300:	00a045b4 	movhi	r2,33046
81141304:	109e5204 	addi	r2,r2,31048
81141308:	200891ba 	slli	r4,r4,6
8114130c:	1105883a 	add	r2,r2,r4
81141310:	10800804 	addi	r2,r2,32
81141314:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141318:	1885883a 	add	r2,r3,r2
8114131c:	e0bffd15 	stw	r2,-12(fp)
81141320:	00001406 	br	81141374 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81141324:	00bfff84 	movi	r2,-2
81141328:	00003d06 	br	81141420 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8114132c:	e13fff0f 	ldh	r4,-4(fp)
81141330:	e0ffff0f 	ldh	r3,-4(fp)
81141334:	00a045b4 	movhi	r2,33046
81141338:	109e5204 	addi	r2,r2,31048
8114133c:	180691ba 	slli	r3,r3,6
81141340:	10c5883a 	add	r2,r2,r3
81141344:	10800804 	addi	r2,r2,32
81141348:	10800017 	ldw	r2,0(r2)
8114134c:	10c00044 	addi	r3,r2,1
81141350:	00a045b4 	movhi	r2,33046
81141354:	109e5204 	addi	r2,r2,31048
81141358:	200891ba 	slli	r4,r4,6
8114135c:	1105883a 	add	r2,r2,r4
81141360:	10800804 	addi	r2,r2,32
81141364:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81141368:	e0bffd17 	ldw	r2,-12(fp)
8114136c:	10800044 	addi	r2,r2,1
81141370:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81141374:	d0e0ac17 	ldw	r3,-32080(gp)
81141378:	e0bffd17 	ldw	r2,-12(fp)
8114137c:	1885883a 	add	r2,r3,r2
81141380:	1007883a 	mov	r3,r2
81141384:	d0a0b017 	ldw	r2,-32064(gp)
81141388:	18800726 	beq	r3,r2,811413a8 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8114138c:	d0a0ac17 	ldw	r2,-32080(gp)
81141390:	100b883a 	mov	r5,r2
81141394:	e13ffd17 	ldw	r4,-12(fp)
81141398:	113d9600 	call	8113d960 <Read_Sector_Data>
8114139c:	1000021e 	bne	r2,zero,811413a8 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
811413a0:	00bfff84 	movi	r2,-2
811413a4:	00001e06 	br	81141420 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
811413a8:	d0e0ab17 	ldw	r3,-32084(gp)
811413ac:	e13fff0f 	ldh	r4,-4(fp)
811413b0:	00a045b4 	movhi	r2,33046
811413b4:	109e5204 	addi	r2,r2,31048
811413b8:	200891ba 	slli	r4,r4,6
811413bc:	1105883a 	add	r2,r2,r4
811413c0:	10800904 	addi	r2,r2,36
811413c4:	10800017 	ldw	r2,0(r2)
811413c8:	10807fcc 	andi	r2,r2,511
811413cc:	1885883a 	add	r2,r3,r2
811413d0:	10800023 	ldbuio	r2,0(r2)
811413d4:	10803fcc 	andi	r2,r2,255
811413d8:	10803fcc 	andi	r2,r2,255
811413dc:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
811413e0:	e13fff0f 	ldh	r4,-4(fp)
811413e4:	e0ffff0f 	ldh	r3,-4(fp)
811413e8:	00a045b4 	movhi	r2,33046
811413ec:	109e5204 	addi	r2,r2,31048
811413f0:	180691ba 	slli	r3,r3,6
811413f4:	10c5883a 	add	r2,r2,r3
811413f8:	10800904 	addi	r2,r2,36
811413fc:	10800017 	ldw	r2,0(r2)
81141400:	10c00044 	addi	r3,r2,1
81141404:	00a045b4 	movhi	r2,33046
81141408:	109e5204 	addi	r2,r2,31048
8114140c:	200891ba 	slli	r4,r4,6
81141410:	1105883a 	add	r2,r2,r4
81141414:	10800904 	addi	r2,r2,36
81141418:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
8114141c:	e0bffc0b 	ldhu	r2,-16(fp)
}
81141420:	e037883a 	mov	sp,fp
81141424:	dfc00117 	ldw	ra,4(sp)
81141428:	df000017 	ldw	fp,0(sp)
8114142c:	dec00204 	addi	sp,sp,8
81141430:	f800283a 	ret

81141434 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81141434:	defff804 	addi	sp,sp,-32
81141438:	de00012e 	bgeu	sp,et,81141440 <alt_up_sd_card_write+0xc>
8114143c:	003b68fa 	trap	3
81141440:	dfc00715 	stw	ra,28(sp)
81141444:	df000615 	stw	fp,24(sp)
81141448:	df000604 	addi	fp,sp,24
8114144c:	2007883a 	mov	r3,r4
81141450:	2805883a 	mov	r2,r5
81141454:	e0fffe0d 	sth	r3,-8(fp)
81141458:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
8114145c:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81141460:	e0bffe0f 	ldh	r2,-8(fp)
81141464:	10017716 	blt	r2,zero,81141a44 <alt_up_sd_card_write+0x610>
81141468:	e0bffe0f 	ldh	r2,-8(fp)
8114146c:	10800508 	cmpgei	r2,r2,20
81141470:	1001741e 	bne	r2,zero,81141a44 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81141474:	e0fffe0f 	ldh	r3,-8(fp)
81141478:	00a045b4 	movhi	r2,33046
8114147c:	109e5204 	addi	r2,r2,31048
81141480:	180691ba 	slli	r3,r3,6
81141484:	10c5883a 	add	r2,r2,r3
81141488:	10800f04 	addi	r2,r2,60
8114148c:	10800017 	ldw	r2,0(r2)
81141490:	10016c26 	beq	r2,zero,81141a44 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141494:	00a045b4 	movhi	r2,33046
81141498:	109e3d04 	addi	r2,r2,30964
8114149c:	10c01417 	ldw	r3,80(r2)
811414a0:	e13ffe0f 	ldh	r4,-8(fp)
811414a4:	00a045b4 	movhi	r2,33046
811414a8:	109e5204 	addi	r2,r2,31048
811414ac:	200891ba 	slli	r4,r4,6
811414b0:	1105883a 	add	r2,r2,r4
811414b4:	10800704 	addi	r2,r2,28
811414b8:	10800017 	ldw	r2,0(r2)
811414bc:	113fff84 	addi	r4,r2,-2
811414c0:	00a045b4 	movhi	r2,33046
811414c4:	109e3d04 	addi	r2,r2,30964
811414c8:	10800383 	ldbu	r2,14(r2)
811414cc:	10803fcc 	andi	r2,r2,255
811414d0:	2085383a 	mul	r2,r4,r2
811414d4:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
811414d8:	e13ffe0f 	ldh	r4,-8(fp)
811414dc:	00a045b4 	movhi	r2,33046
811414e0:	109e5204 	addi	r2,r2,31048
811414e4:	200891ba 	slli	r4,r4,6
811414e8:	1105883a 	add	r2,r2,r4
811414ec:	10800804 	addi	r2,r2,32
811414f0:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811414f4:	1885883a 	add	r2,r3,r2
811414f8:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
811414fc:	e0fffe0f 	ldh	r3,-8(fp)
81141500:	00a045b4 	movhi	r2,33046
81141504:	109e5204 	addi	r2,r2,31048
81141508:	180691ba 	slli	r3,r3,6
8114150c:	10c5883a 	add	r2,r2,r3
81141510:	10800904 	addi	r2,r2,36
81141514:	10c00017 	ldw	r3,0(r2)
81141518:	00a045b4 	movhi	r2,33046
8114151c:	109e3d04 	addi	r2,r2,30964
81141520:	1080030b 	ldhu	r2,12(r2)
81141524:	10bfffcc 	andi	r2,r2,65535
81141528:	1889203a 	divu	r4,r3,r2
8114152c:	2085383a 	mul	r2,r4,r2
81141530:	1885c83a 	sub	r2,r3,r2
81141534:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81141538:	e0fffe0f 	ldh	r3,-8(fp)
8114153c:	00a045b4 	movhi	r2,33046
81141540:	109e5204 	addi	r2,r2,31048
81141544:	180691ba 	slli	r3,r3,6
81141548:	10c5883a 	add	r2,r2,r3
8114154c:	10800904 	addi	r2,r2,36
81141550:	10c00017 	ldw	r3,0(r2)
81141554:	e13ffe0f 	ldh	r4,-8(fp)
81141558:	00a045b4 	movhi	r2,33046
8114155c:	109e5204 	addi	r2,r2,31048
81141560:	200891ba 	slli	r4,r4,6
81141564:	1105883a 	add	r2,r2,r4
81141568:	10800604 	addi	r2,r2,24
8114156c:	10800017 	ldw	r2,0(r2)
81141570:	1880672e 	bgeu	r3,r2,81141710 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81141574:	e0fffe0f 	ldh	r3,-8(fp)
81141578:	00a045b4 	movhi	r2,33046
8114157c:	109e5204 	addi	r2,r2,31048
81141580:	180691ba 	slli	r3,r3,6
81141584:	10c5883a 	add	r2,r2,r3
81141588:	10800904 	addi	r2,r2,36
8114158c:	10800017 	ldw	r2,0(r2)
81141590:	1000e126 	beq	r2,zero,81141918 <alt_up_sd_card_write+0x4e4>
81141594:	e0bffc0f 	ldh	r2,-16(fp)
81141598:	1000df1e 	bne	r2,zero,81141918 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8114159c:	e0fffe0f 	ldh	r3,-8(fp)
811415a0:	00a045b4 	movhi	r2,33046
811415a4:	109e5204 	addi	r2,r2,31048
811415a8:	180691ba 	slli	r3,r3,6
811415ac:	10c5883a 	add	r2,r2,r3
811415b0:	10800804 	addi	r2,r2,32
811415b4:	10c00017 	ldw	r3,0(r2)
811415b8:	00a045b4 	movhi	r2,33046
811415bc:	109e3d04 	addi	r2,r2,30964
811415c0:	10800383 	ldbu	r2,14(r2)
811415c4:	10803fcc 	andi	r2,r2,255
811415c8:	10bfffc4 	addi	r2,r2,-1
811415cc:	18803d1e 	bne	r3,r2,811416c4 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
811415d0:	e0fffe0f 	ldh	r3,-8(fp)
811415d4:	00a045b4 	movhi	r2,33046
811415d8:	109e5204 	addi	r2,r2,31048
811415dc:	180691ba 	slli	r3,r3,6
811415e0:	10c5883a 	add	r2,r2,r3
811415e4:	10800704 	addi	r2,r2,28
811415e8:	10800017 	ldw	r2,0(r2)
811415ec:	e0fffc84 	addi	r3,fp,-14
811415f0:	180b883a 	mov	r5,r3
811415f4:	1009883a 	mov	r4,r2
811415f8:	113da400 	call	8113da40 <get_cluster_flag>
811415fc:	10002f26 	beq	r2,zero,811416bc <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81141600:	e0bffc8b 	ldhu	r2,-14(fp)
81141604:	10bfffcc 	andi	r2,r2,65535
81141608:	10bffe28 	cmpgeui	r2,r2,65528
8114160c:	1000c21e 	bne	r2,zero,81141918 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81141610:	e13ffe0f 	ldh	r4,-8(fp)
81141614:	e0bffc8b 	ldhu	r2,-14(fp)
81141618:	10ffffcc 	andi	r3,r2,65535
8114161c:	00a045b4 	movhi	r2,33046
81141620:	109e5204 	addi	r2,r2,31048
81141624:	200891ba 	slli	r4,r4,6
81141628:	1105883a 	add	r2,r2,r4
8114162c:	10800704 	addi	r2,r2,28
81141630:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81141634:	e0fffe0f 	ldh	r3,-8(fp)
81141638:	00a045b4 	movhi	r2,33046
8114163c:	109e5204 	addi	r2,r2,31048
81141640:	180691ba 	slli	r3,r3,6
81141644:	10c5883a 	add	r2,r2,r3
81141648:	10800804 	addi	r2,r2,32
8114164c:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141650:	00a045b4 	movhi	r2,33046
81141654:	109e3d04 	addi	r2,r2,30964
81141658:	10c01417 	ldw	r3,80(r2)
8114165c:	e13ffe0f 	ldh	r4,-8(fp)
81141660:	00a045b4 	movhi	r2,33046
81141664:	109e5204 	addi	r2,r2,31048
81141668:	200891ba 	slli	r4,r4,6
8114166c:	1105883a 	add	r2,r2,r4
81141670:	10800704 	addi	r2,r2,28
81141674:	10800017 	ldw	r2,0(r2)
81141678:	113fff84 	addi	r4,r2,-2
8114167c:	00a045b4 	movhi	r2,33046
81141680:	109e3d04 	addi	r2,r2,30964
81141684:	10800383 	ldbu	r2,14(r2)
81141688:	10803fcc 	andi	r2,r2,255
8114168c:	2085383a 	mul	r2,r4,r2
81141690:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81141694:	e13ffe0f 	ldh	r4,-8(fp)
81141698:	00a045b4 	movhi	r2,33046
8114169c:	109e5204 	addi	r2,r2,31048
811416a0:	200891ba 	slli	r4,r4,6
811416a4:	1105883a 	add	r2,r2,r4
811416a8:	10800804 	addi	r2,r2,32
811416ac:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811416b0:	1885883a 	add	r2,r3,r2
811416b4:	e0bffb15 	stw	r2,-20(fp)
811416b8:	00009706 	br	81141918 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
811416bc:	0005883a 	mov	r2,zero
811416c0:	0000e106 	br	81141a48 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
811416c4:	e13ffe0f 	ldh	r4,-8(fp)
811416c8:	e0fffe0f 	ldh	r3,-8(fp)
811416cc:	00a045b4 	movhi	r2,33046
811416d0:	109e5204 	addi	r2,r2,31048
811416d4:	180691ba 	slli	r3,r3,6
811416d8:	10c5883a 	add	r2,r2,r3
811416dc:	10800804 	addi	r2,r2,32
811416e0:	10800017 	ldw	r2,0(r2)
811416e4:	10c00044 	addi	r3,r2,1
811416e8:	00a045b4 	movhi	r2,33046
811416ec:	109e5204 	addi	r2,r2,31048
811416f0:	200891ba 	slli	r4,r4,6
811416f4:	1105883a 	add	r2,r2,r4
811416f8:	10800804 	addi	r2,r2,32
811416fc:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81141700:	e0bffb17 	ldw	r2,-20(fp)
81141704:	10800044 	addi	r2,r2,1
81141708:	e0bffb15 	stw	r2,-20(fp)
8114170c:	00008206 	br	81141918 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81141710:	e0fffe0f 	ldh	r3,-8(fp)
81141714:	00a045b4 	movhi	r2,33046
81141718:	109e5204 	addi	r2,r2,31048
8114171c:	180691ba 	slli	r3,r3,6
81141720:	10c5883a 	add	r2,r2,r3
81141724:	10800904 	addi	r2,r2,36
81141728:	10800017 	ldw	r2,0(r2)
8114172c:	10007a26 	beq	r2,zero,81141918 <alt_up_sd_card_write+0x4e4>
81141730:	e0bffc0f 	ldh	r2,-16(fp)
81141734:	1000781e 	bne	r2,zero,81141918 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81141738:	e0fffe0f 	ldh	r3,-8(fp)
8114173c:	00a045b4 	movhi	r2,33046
81141740:	109e5204 	addi	r2,r2,31048
81141744:	180691ba 	slli	r3,r3,6
81141748:	10c5883a 	add	r2,r2,r3
8114174c:	10800804 	addi	r2,r2,32
81141750:	10c00017 	ldw	r3,0(r2)
81141754:	00a045b4 	movhi	r2,33046
81141758:	109e3d04 	addi	r2,r2,30964
8114175c:	10800383 	ldbu	r2,14(r2)
81141760:	10803fcc 	andi	r2,r2,255
81141764:	10bfffc4 	addi	r2,r2,-1
81141768:	18803e1e 	bne	r3,r2,81141864 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
8114176c:	e0bffd04 	addi	r2,fp,-12
81141770:	1009883a 	mov	r4,r2
81141774:	113fa840 	call	8113fa84 <find_first_empty_cluster>
81141778:	10003826 	beq	r2,zero,8114185c <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
8114177c:	e0fffe0f 	ldh	r3,-8(fp)
81141780:	00a045b4 	movhi	r2,33046
81141784:	109e5204 	addi	r2,r2,31048
81141788:	180691ba 	slli	r3,r3,6
8114178c:	10c5883a 	add	r2,r2,r3
81141790:	10800704 	addi	r2,r2,28
81141794:	10800017 	ldw	r2,0(r2)
81141798:	e0fffd17 	ldw	r3,-12(fp)
8114179c:	18ffffcc 	andi	r3,r3,65535
811417a0:	18e0001c 	xori	r3,r3,32768
811417a4:	18e00004 	addi	r3,r3,-32768
811417a8:	01800044 	movi	r6,1
811417ac:	180b883a 	mov	r5,r3
811417b0:	1009883a 	mov	r4,r2
811417b4:	113dafc0 	call	8113dafc <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
811417b8:	e0bffd17 	ldw	r2,-12(fp)
811417bc:	01800044 	movi	r6,1
811417c0:	017fffc4 	movi	r5,-1
811417c4:	1009883a 	mov	r4,r2
811417c8:	113dafc0 	call	8113dafc <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
811417cc:	e0fffe0f 	ldh	r3,-8(fp)
811417d0:	00a045b4 	movhi	r2,33046
811417d4:	109e5204 	addi	r2,r2,31048
811417d8:	180691ba 	slli	r3,r3,6
811417dc:	10c5883a 	add	r2,r2,r3
811417e0:	10800704 	addi	r2,r2,28
811417e4:	10800017 	ldw	r2,0(r2)
811417e8:	e0fffd17 	ldw	r3,-12(fp)
811417ec:	18ffffcc 	andi	r3,r3,65535
811417f0:	18e0001c 	xori	r3,r3,32768
811417f4:	18e00004 	addi	r3,r3,-32768
811417f8:	000d883a 	mov	r6,zero
811417fc:	180b883a 	mov	r5,r3
81141800:	1009883a 	mov	r4,r2
81141804:	113dafc0 	call	8113dafc <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81141808:	e0bffd17 	ldw	r2,-12(fp)
8114180c:	000d883a 	mov	r6,zero
81141810:	017fffc4 	movi	r5,-1
81141814:	1009883a 	mov	r4,r2
81141818:	113dafc0 	call	8113dafc <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
8114181c:	e13ffe0f 	ldh	r4,-8(fp)
81141820:	e0fffd17 	ldw	r3,-12(fp)
81141824:	00a045b4 	movhi	r2,33046
81141828:	109e5204 	addi	r2,r2,31048
8114182c:	200891ba 	slli	r4,r4,6
81141830:	1105883a 	add	r2,r2,r4
81141834:	10800704 	addi	r2,r2,28
81141838:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
8114183c:	e0fffe0f 	ldh	r3,-8(fp)
81141840:	00a045b4 	movhi	r2,33046
81141844:	109e5204 	addi	r2,r2,31048
81141848:	180691ba 	slli	r3,r3,6
8114184c:	10c5883a 	add	r2,r2,r3
81141850:	10800804 	addi	r2,r2,32
81141854:	10000015 	stw	zero,0(r2)
81141858:	00001506 	br	811418b0 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
8114185c:	0005883a 	mov	r2,zero
81141860:	00007906 	br	81141a48 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81141864:	e13ffe0f 	ldh	r4,-8(fp)
81141868:	e0fffe0f 	ldh	r3,-8(fp)
8114186c:	00a045b4 	movhi	r2,33046
81141870:	109e5204 	addi	r2,r2,31048
81141874:	180691ba 	slli	r3,r3,6
81141878:	10c5883a 	add	r2,r2,r3
8114187c:	10800904 	addi	r2,r2,36
81141880:	10c00017 	ldw	r3,0(r2)
81141884:	00a045b4 	movhi	r2,33046
81141888:	109e3d04 	addi	r2,r2,30964
8114188c:	1080030b 	ldhu	r2,12(r2)
81141890:	10bfffcc 	andi	r2,r2,65535
81141894:	1887203a 	divu	r3,r3,r2
81141898:	00a045b4 	movhi	r2,33046
8114189c:	109e5204 	addi	r2,r2,31048
811418a0:	200891ba 	slli	r4,r4,6
811418a4:	1105883a 	add	r2,r2,r4
811418a8:	10800804 	addi	r2,r2,32
811418ac:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811418b0:	00a045b4 	movhi	r2,33046
811418b4:	109e3d04 	addi	r2,r2,30964
811418b8:	10c01417 	ldw	r3,80(r2)
811418bc:	e13ffe0f 	ldh	r4,-8(fp)
811418c0:	00a045b4 	movhi	r2,33046
811418c4:	109e5204 	addi	r2,r2,31048
811418c8:	200891ba 	slli	r4,r4,6
811418cc:	1105883a 	add	r2,r2,r4
811418d0:	10800704 	addi	r2,r2,28
811418d4:	10800017 	ldw	r2,0(r2)
811418d8:	113fff84 	addi	r4,r2,-2
811418dc:	00a045b4 	movhi	r2,33046
811418e0:	109e3d04 	addi	r2,r2,30964
811418e4:	10800383 	ldbu	r2,14(r2)
811418e8:	10803fcc 	andi	r2,r2,255
811418ec:	2085383a 	mul	r2,r4,r2
811418f0:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
811418f4:	e13ffe0f 	ldh	r4,-8(fp)
811418f8:	00a045b4 	movhi	r2,33046
811418fc:	109e5204 	addi	r2,r2,31048
81141900:	200891ba 	slli	r4,r4,6
81141904:	1105883a 	add	r2,r2,r4
81141908:	10800804 	addi	r2,r2,32
8114190c:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141910:	1885883a 	add	r2,r3,r2
81141914:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81141918:	d0e0ac17 	ldw	r3,-32080(gp)
8114191c:	e0bffb17 	ldw	r2,-20(fp)
81141920:	1885883a 	add	r2,r3,r2
81141924:	1007883a 	mov	r3,r2
81141928:	d0a0b017 	ldw	r2,-32064(gp)
8114192c:	18800726 	beq	r3,r2,8114194c <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81141930:	d0a0ac17 	ldw	r2,-32080(gp)
81141934:	100b883a 	mov	r5,r2
81141938:	e13ffb17 	ldw	r4,-20(fp)
8114193c:	113d9600 	call	8113d960 <Read_Sector_Data>
81141940:	1000021e 	bne	r2,zero,8114194c <alt_up_sd_card_write+0x518>
                {
					return false;
81141944:	0005883a 	mov	r2,zero
81141948:	00003f06 	br	81141a48 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
8114194c:	d0e0ab17 	ldw	r3,-32084(gp)
81141950:	e0bffc0f 	ldh	r2,-16(fp)
81141954:	1885883a 	add	r2,r3,r2
81141958:	e0ffff07 	ldb	r3,-4(fp)
8114195c:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81141960:	e13ffe0f 	ldh	r4,-8(fp)
81141964:	e0fffe0f 	ldh	r3,-8(fp)
81141968:	00a045b4 	movhi	r2,33046
8114196c:	109e5204 	addi	r2,r2,31048
81141970:	180691ba 	slli	r3,r3,6
81141974:	10c5883a 	add	r2,r2,r3
81141978:	10800904 	addi	r2,r2,36
8114197c:	10800017 	ldw	r2,0(r2)
81141980:	10c00044 	addi	r3,r2,1
81141984:	00a045b4 	movhi	r2,33046
81141988:	109e5204 	addi	r2,r2,31048
8114198c:	200891ba 	slli	r4,r4,6
81141990:	1105883a 	add	r2,r2,r4
81141994:	10800904 	addi	r2,r2,36
81141998:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
8114199c:	e0fffe0f 	ldh	r3,-8(fp)
811419a0:	00a045b4 	movhi	r2,33046
811419a4:	109e5204 	addi	r2,r2,31048
811419a8:	180691ba 	slli	r3,r3,6
811419ac:	10c5883a 	add	r2,r2,r3
811419b0:	10800904 	addi	r2,r2,36
811419b4:	10c00017 	ldw	r3,0(r2)
811419b8:	e13ffe0f 	ldh	r4,-8(fp)
811419bc:	00a045b4 	movhi	r2,33046
811419c0:	109e5204 	addi	r2,r2,31048
811419c4:	200891ba 	slli	r4,r4,6
811419c8:	1105883a 	add	r2,r2,r4
811419cc:	10800604 	addi	r2,r2,24
811419d0:	10800017 	ldw	r2,0(r2)
811419d4:	18801736 	bltu	r3,r2,81141a34 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
811419d8:	e13ffe0f 	ldh	r4,-8(fp)
811419dc:	e0fffe0f 	ldh	r3,-8(fp)
811419e0:	00a045b4 	movhi	r2,33046
811419e4:	109e5204 	addi	r2,r2,31048
811419e8:	180691ba 	slli	r3,r3,6
811419ec:	10c5883a 	add	r2,r2,r3
811419f0:	10800604 	addi	r2,r2,24
811419f4:	10800017 	ldw	r2,0(r2)
811419f8:	10c00044 	addi	r3,r2,1
811419fc:	00a045b4 	movhi	r2,33046
81141a00:	109e5204 	addi	r2,r2,31048
81141a04:	200891ba 	slli	r4,r4,6
81141a08:	1105883a 	add	r2,r2,r4
81141a0c:	10800604 	addi	r2,r2,24
81141a10:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81141a14:	e0fffe0f 	ldh	r3,-8(fp)
81141a18:	00a045b4 	movhi	r2,33046
81141a1c:	109e5204 	addi	r2,r2,31048
81141a20:	180691ba 	slli	r3,r3,6
81141a24:	10c5883a 	add	r2,r2,r3
81141a28:	10800e04 	addi	r2,r2,56
81141a2c:	00c00044 	movi	r3,1
81141a30:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81141a34:	00800044 	movi	r2,1
81141a38:	d0a0af15 	stw	r2,-32068(gp)
			result = true;
81141a3c:	00800044 	movi	r2,1
81141a40:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81141a44:	e0bffa17 	ldw	r2,-24(fp)
}
81141a48:	e037883a 	mov	sp,fp
81141a4c:	dfc00117 	ldw	ra,4(sp)
81141a50:	df000017 	ldw	fp,0(sp)
81141a54:	dec00204 	addi	sp,sp,8
81141a58:	f800283a 	ret

81141a5c <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81141a5c:	defffb04 	addi	sp,sp,-20
81141a60:	de00012e 	bgeu	sp,et,81141a68 <alt_up_sd_card_fclose+0xc>
81141a64:	003b68fa 	trap	3
81141a68:	dfc00415 	stw	ra,16(sp)
81141a6c:	df000315 	stw	fp,12(sp)
81141a70:	df000304 	addi	fp,sp,12
81141a74:	2005883a 	mov	r2,r4
81141a78:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81141a7c:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81141a80:	11406380 	call	81140638 <alt_up_sd_card_is_Present>
81141a84:	10006026 	beq	r2,zero,81141c08 <alt_up_sd_card_fclose+0x1ac>
81141a88:	d0a0a517 	ldw	r2,-32108(gp)
81141a8c:	10005e26 	beq	r2,zero,81141c08 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81141a90:	e0ffff0f 	ldh	r3,-4(fp)
81141a94:	00a045b4 	movhi	r2,33046
81141a98:	109e5204 	addi	r2,r2,31048
81141a9c:	180691ba 	slli	r3,r3,6
81141aa0:	10c5883a 	add	r2,r2,r3
81141aa4:	10800f04 	addi	r2,r2,60
81141aa8:	10800017 	ldw	r2,0(r2)
81141aac:	10005626 	beq	r2,zero,81141c08 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81141ab0:	e0ffff0f 	ldh	r3,-4(fp)
81141ab4:	00a045b4 	movhi	r2,33046
81141ab8:	109e5204 	addi	r2,r2,31048
81141abc:	180691ba 	slli	r3,r3,6
81141ac0:	10c5883a 	add	r2,r2,r3
81141ac4:	10800e04 	addi	r2,r2,56
81141ac8:	10800017 	ldw	r2,0(r2)
81141acc:	10004526 	beq	r2,zero,81141be4 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
81141ad0:	e0ffff0f 	ldh	r3,-4(fp)
81141ad4:	00a045b4 	movhi	r2,33046
81141ad8:	109e5204 	addi	r2,r2,31048
81141adc:	180691ba 	slli	r3,r3,6
81141ae0:	10c5883a 	add	r2,r2,r3
81141ae4:	10800b04 	addi	r2,r2,44
81141ae8:	10800017 	ldw	r2,0(r2)
81141aec:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81141af0:	e0ffff0f 	ldh	r3,-4(fp)
81141af4:	00a045b4 	movhi	r2,33046
81141af8:	109e5204 	addi	r2,r2,31048
81141afc:	180691ba 	slli	r3,r3,6
81141b00:	10c5883a 	add	r2,r2,r3
81141b04:	10800a04 	addi	r2,r2,40
81141b08:	10800017 	ldw	r2,0(r2)
81141b0c:	1000071e 	bne	r2,zero,81141b2c <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81141b10:	00a045b4 	movhi	r2,33046
81141b14:	109e3d04 	addi	r2,r2,30964
81141b18:	10801317 	ldw	r2,76(r2)
81141b1c:	e0fffe17 	ldw	r3,-8(fp)
81141b20:	1885883a 	add	r2,r3,r2
81141b24:	e0bffe15 	stw	r2,-8(fp)
81141b28:	00001406 	br	81141b7c <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81141b2c:	00a045b4 	movhi	r2,33046
81141b30:	109e3d04 	addi	r2,r2,30964
81141b34:	10c01417 	ldw	r3,80(r2)
81141b38:	e0bffe17 	ldw	r2,-8(fp)
81141b3c:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
81141b40:	e13fff0f 	ldh	r4,-4(fp)
81141b44:	00a045b4 	movhi	r2,33046
81141b48:	109e5204 	addi	r2,r2,31048
81141b4c:	200891ba 	slli	r4,r4,6
81141b50:	1105883a 	add	r2,r2,r4
81141b54:	10800a04 	addi	r2,r2,40
81141b58:	10800017 	ldw	r2,0(r2)
81141b5c:	113fff84 	addi	r4,r2,-2
81141b60:	00a045b4 	movhi	r2,33046
81141b64:	109e3d04 	addi	r2,r2,30964
81141b68:	10800383 	ldbu	r2,14(r2)
81141b6c:	10803fcc 	andi	r2,r2,255
81141b70:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81141b74:	1885883a 	add	r2,r3,r2
81141b78:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81141b7c:	e0bffe17 	ldw	r2,-8(fp)
81141b80:	d0e0ac17 	ldw	r3,-32080(gp)
81141b84:	180b883a 	mov	r5,r3
81141b88:	1009883a 	mov	r4,r2
81141b8c:	113d9600 	call	8113d960 <Read_Sector_Data>
81141b90:	10001426 	beq	r2,zero,81141be4 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81141b94:	e0ffff0f 	ldh	r3,-4(fp)
81141b98:	00a045b4 	movhi	r2,33046
81141b9c:	109e5204 	addi	r2,r2,31048
81141ba0:	180691ba 	slli	r3,r3,6
81141ba4:	10c5883a 	add	r2,r2,r3
81141ba8:	10800c04 	addi	r2,r2,48
81141bac:	1080000b 	ldhu	r2,0(r2)
81141bb0:	113fffcc 	andi	r4,r2,65535
81141bb4:	2120001c 	xori	r4,r4,32768
81141bb8:	21200004 	addi	r4,r4,-32768
81141bbc:	e0bfff0f 	ldh	r2,-4(fp)
81141bc0:	100691ba 	slli	r3,r2,6
81141bc4:	00a045b4 	movhi	r2,33046
81141bc8:	109e5204 	addi	r2,r2,31048
81141bcc:	1885883a 	add	r2,r3,r2
81141bd0:	100b883a 	mov	r5,r2
81141bd4:	113e0140 	call	8113e014 <Write_File_Record_At_Offset>
81141bd8:	10000226 	beq	r2,zero,81141be4 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
81141bdc:	113d90c0 	call	8113d90c <Save_Modified_Sector>
81141be0:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81141be4:	e0ffff0f 	ldh	r3,-4(fp)
81141be8:	00a045b4 	movhi	r2,33046
81141bec:	109e5204 	addi	r2,r2,31048
81141bf0:	180691ba 	slli	r3,r3,6
81141bf4:	10c5883a 	add	r2,r2,r3
81141bf8:	10800f04 	addi	r2,r2,60
81141bfc:	10000015 	stw	zero,0(r2)
			result = true;
81141c00:	00800044 	movi	r2,1
81141c04:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81141c08:	e0bffd17 	ldw	r2,-12(fp)
}
81141c0c:	e037883a 	mov	sp,fp
81141c10:	dfc00117 	ldw	ra,4(sp)
81141c14:	df000017 	ldw	fp,0(sp)
81141c18:	dec00204 	addi	sp,sp,8
81141c1c:	f800283a 	ret

81141c20 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81141c20:	defffa04 	addi	sp,sp,-24
81141c24:	de00012e 	bgeu	sp,et,81141c2c <altera_avalon_jtag_uart_read_fd+0xc>
81141c28:	003b68fa 	trap	3
81141c2c:	dfc00515 	stw	ra,20(sp)
81141c30:	df000415 	stw	fp,16(sp)
81141c34:	df000404 	addi	fp,sp,16
81141c38:	e13ffd15 	stw	r4,-12(fp)
81141c3c:	e17ffe15 	stw	r5,-8(fp)
81141c40:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81141c44:	e0bffd17 	ldw	r2,-12(fp)
81141c48:	10800017 	ldw	r2,0(r2)
81141c4c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
81141c50:	e0bffc17 	ldw	r2,-16(fp)
81141c54:	10c00a04 	addi	r3,r2,40
81141c58:	e0bffd17 	ldw	r2,-12(fp)
81141c5c:	10800217 	ldw	r2,8(r2)
81141c60:	100f883a 	mov	r7,r2
81141c64:	e1bfff17 	ldw	r6,-4(fp)
81141c68:	e17ffe17 	ldw	r5,-8(fp)
81141c6c:	1809883a 	mov	r4,r3
81141c70:	11424a40 	call	811424a4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81141c74:	e037883a 	mov	sp,fp
81141c78:	dfc00117 	ldw	ra,4(sp)
81141c7c:	df000017 	ldw	fp,0(sp)
81141c80:	dec00204 	addi	sp,sp,8
81141c84:	f800283a 	ret

81141c88 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81141c88:	defffa04 	addi	sp,sp,-24
81141c8c:	de00012e 	bgeu	sp,et,81141c94 <altera_avalon_jtag_uart_write_fd+0xc>
81141c90:	003b68fa 	trap	3
81141c94:	dfc00515 	stw	ra,20(sp)
81141c98:	df000415 	stw	fp,16(sp)
81141c9c:	df000404 	addi	fp,sp,16
81141ca0:	e13ffd15 	stw	r4,-12(fp)
81141ca4:	e17ffe15 	stw	r5,-8(fp)
81141ca8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81141cac:	e0bffd17 	ldw	r2,-12(fp)
81141cb0:	10800017 	ldw	r2,0(r2)
81141cb4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
81141cb8:	e0bffc17 	ldw	r2,-16(fp)
81141cbc:	10c00a04 	addi	r3,r2,40
81141cc0:	e0bffd17 	ldw	r2,-12(fp)
81141cc4:	10800217 	ldw	r2,8(r2)
81141cc8:	100f883a 	mov	r7,r2
81141ccc:	e1bfff17 	ldw	r6,-4(fp)
81141cd0:	e17ffe17 	ldw	r5,-8(fp)
81141cd4:	1809883a 	mov	r4,r3
81141cd8:	11427680 	call	81142768 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
81141cdc:	e037883a 	mov	sp,fp
81141ce0:	dfc00117 	ldw	ra,4(sp)
81141ce4:	df000017 	ldw	fp,0(sp)
81141ce8:	dec00204 	addi	sp,sp,8
81141cec:	f800283a 	ret

81141cf0 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81141cf0:	defffc04 	addi	sp,sp,-16
81141cf4:	de00012e 	bgeu	sp,et,81141cfc <altera_avalon_jtag_uart_close_fd+0xc>
81141cf8:	003b68fa 	trap	3
81141cfc:	dfc00315 	stw	ra,12(sp)
81141d00:	df000215 	stw	fp,8(sp)
81141d04:	df000204 	addi	fp,sp,8
81141d08:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81141d0c:	e0bfff17 	ldw	r2,-4(fp)
81141d10:	10800017 	ldw	r2,0(r2)
81141d14:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81141d18:	e0bffe17 	ldw	r2,-8(fp)
81141d1c:	10c00a04 	addi	r3,r2,40
81141d20:	e0bfff17 	ldw	r2,-4(fp)
81141d24:	10800217 	ldw	r2,8(r2)
81141d28:	100b883a 	mov	r5,r2
81141d2c:	1809883a 	mov	r4,r3
81141d30:	114233c0 	call	8114233c <altera_avalon_jtag_uart_close>
}
81141d34:	e037883a 	mov	sp,fp
81141d38:	dfc00117 	ldw	ra,4(sp)
81141d3c:	df000017 	ldw	fp,0(sp)
81141d40:	dec00204 	addi	sp,sp,8
81141d44:	f800283a 	ret

81141d48 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81141d48:	defffa04 	addi	sp,sp,-24
81141d4c:	de00012e 	bgeu	sp,et,81141d54 <altera_avalon_jtag_uart_ioctl_fd+0xc>
81141d50:	003b68fa 	trap	3
81141d54:	dfc00515 	stw	ra,20(sp)
81141d58:	df000415 	stw	fp,16(sp)
81141d5c:	df000404 	addi	fp,sp,16
81141d60:	e13ffd15 	stw	r4,-12(fp)
81141d64:	e17ffe15 	stw	r5,-8(fp)
81141d68:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81141d6c:	e0bffd17 	ldw	r2,-12(fp)
81141d70:	10800017 	ldw	r2,0(r2)
81141d74:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81141d78:	e0bffc17 	ldw	r2,-16(fp)
81141d7c:	10800a04 	addi	r2,r2,40
81141d80:	e1bfff17 	ldw	r6,-4(fp)
81141d84:	e17ffe17 	ldw	r5,-8(fp)
81141d88:	1009883a 	mov	r4,r2
81141d8c:	11423ac0 	call	811423ac <altera_avalon_jtag_uart_ioctl>
}
81141d90:	e037883a 	mov	sp,fp
81141d94:	dfc00117 	ldw	ra,4(sp)
81141d98:	df000017 	ldw	fp,0(sp)
81141d9c:	dec00204 	addi	sp,sp,8
81141da0:	f800283a 	ret

81141da4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81141da4:	deffef04 	addi	sp,sp,-68
81141da8:	de00012e 	bgeu	sp,et,81141db0 <altera_avalon_jtag_uart_init+0xc>
81141dac:	003b68fa 	trap	3
81141db0:	dfc01015 	stw	ra,64(sp)
81141db4:	df000f15 	stw	fp,60(sp)
81141db8:	dc400e15 	stw	r17,56(sp)
81141dbc:	dc000d15 	stw	r16,52(sp)
81141dc0:	df000f04 	addi	fp,sp,60
81141dc4:	e13ff715 	stw	r4,-36(fp)
81141dc8:	e17ff815 	stw	r5,-32(fp)
81141dcc:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
81141dd0:	e0bff717 	ldw	r2,-36(fp)
81141dd4:	10800c04 	addi	r2,r2,48
81141dd8:	e0bff215 	stw	r2,-56(fp)
81141ddc:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81141de0:	e0bff60b 	ldhu	r2,-40(fp)
81141de4:	e0fff684 	addi	r3,fp,-38
81141de8:	180b883a 	mov	r5,r3
81141dec:	1009883a 	mov	r4,r2
81141df0:	1135f740 	call	81135f74 <OSFlagCreate>
81141df4:	1007883a 	mov	r3,r2
81141df8:	e0bff217 	ldw	r2,-56(fp)
81141dfc:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81141e00:	e0bff717 	ldw	r2,-36(fp)
81141e04:	10800a04 	addi	r2,r2,40
81141e08:	e0bff315 	stw	r2,-52(fp)
81141e0c:	00800044 	movi	r2,1
81141e10:	e0bff58d 	sth	r2,-42(fp)
81141e14:	e0bff58b 	ldhu	r2,-42(fp)
81141e18:	1009883a 	mov	r4,r2
81141e1c:	1139ed00 	call	81139ed0 <OSSemCreate>
81141e20:	1007883a 	mov	r3,r2
81141e24:	e0bff317 	ldw	r2,-52(fp)
81141e28:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81141e2c:	e0bff717 	ldw	r2,-36(fp)
81141e30:	10800b04 	addi	r2,r2,44
81141e34:	e0bff415 	stw	r2,-48(fp)
81141e38:	00800044 	movi	r2,1
81141e3c:	e0bff50d 	sth	r2,-44(fp)
81141e40:	e0bff50b 	ldhu	r2,-44(fp)
81141e44:	1009883a 	mov	r4,r2
81141e48:	1139ed00 	call	81139ed0 <OSSemCreate>
81141e4c:	1007883a 	mov	r3,r2
81141e50:	e0bff417 	ldw	r2,-48(fp)
81141e54:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81141e58:	e0bff717 	ldw	r2,-36(fp)
81141e5c:	00c00044 	movi	r3,1
81141e60:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81141e64:	e0bff717 	ldw	r2,-36(fp)
81141e68:	10800017 	ldw	r2,0(r2)
81141e6c:	10800104 	addi	r2,r2,4
81141e70:	1007883a 	mov	r3,r2
81141e74:	e0bff717 	ldw	r2,-36(fp)
81141e78:	10800817 	ldw	r2,32(r2)
81141e7c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81141e80:	e0bff817 	ldw	r2,-32(fp)
81141e84:	e0fff917 	ldw	r3,-28(fp)
81141e88:	d8000015 	stw	zero,0(sp)
81141e8c:	e1fff717 	ldw	r7,-36(fp)
81141e90:	01a04534 	movhi	r6,33044
81141e94:	3187dd04 	addi	r6,r6,8052
81141e98:	180b883a 	mov	r5,r3
81141e9c:	1009883a 	mov	r4,r2
81141ea0:	1145cbc0 	call	81145cbc <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81141ea4:	e0bff717 	ldw	r2,-36(fp)
81141ea8:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81141eac:	e0bff717 	ldw	r2,-36(fp)
81141eb0:	10800204 	addi	r2,r2,8
81141eb4:	d0e08317 	ldw	r3,-32244(gp)
81141eb8:	e1fff717 	ldw	r7,-36(fp)
81141ebc:	01a04534 	movhi	r6,33044
81141ec0:	31888c04 	addi	r6,r6,8752
81141ec4:	180b883a 	mov	r5,r3
81141ec8:	1009883a 	mov	r4,r2
81141ecc:	114580c0 	call	8114580c <alt_alarm_start>
81141ed0:	1000040e 	bge	r2,zero,81141ee4 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
81141ed4:	e0fff717 	ldw	r3,-36(fp)
81141ed8:	00a00034 	movhi	r2,32768
81141edc:	10bfffc4 	addi	r2,r2,-1
81141ee0:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81141ee4:	d0a07c83 	ldbu	r2,-32270(gp)
81141ee8:	10803fcc 	andi	r2,r2,255
81141eec:	10800058 	cmpnei	r2,r2,1
81141ef0:	10000f1e 	bne	r2,zero,81141f30 <altera_avalon_jtag_uart_init+0x18c>
81141ef4:	d0e08317 	ldw	r3,-32244(gp)
81141ef8:	00b33374 	movhi	r2,52429
81141efc:	10b33344 	addi	r2,r2,-13107
81141f00:	1888383a 	mulxuu	r4,r3,r2
81141f04:	1885383a 	mul	r2,r3,r2
81141f08:	1021883a 	mov	r16,r2
81141f0c:	2023883a 	mov	r17,r4
81141f10:	8804d0fa 	srli	r2,r17,3
81141f14:	e1fff717 	ldw	r7,-36(fp)
81141f18:	01a044f4 	movhi	r6,33043
81141f1c:	3189a904 	addi	r6,r6,9892
81141f20:	100b883a 	mov	r5,r2
81141f24:	012045b4 	movhi	r4,33046
81141f28:	21061104 	addi	r4,r4,6212
81141f2c:	114580c0 	call	8114580c <alt_alarm_start>
81141f30:	d0a07d03 	ldbu	r2,-32268(gp)
81141f34:	10803fcc 	andi	r2,r2,255
81141f38:	10800058 	cmpnei	r2,r2,1
81141f3c:	1000051e 	bne	r2,zero,81141f54 <altera_avalon_jtag_uart_init+0x1b0>
81141f40:	e0bff717 	ldw	r2,-36(fp)
81141f44:	10800017 	ldw	r2,0(r2)
81141f48:	100b883a 	mov	r5,r2
81141f4c:	e13ff717 	ldw	r4,-36(fp)
81141f50:	113283c0 	call	8113283c <alt_log_jtag_uart_startup_info>
}
81141f54:	0001883a 	nop
81141f58:	e6fffe04 	addi	sp,fp,-8
81141f5c:	dfc00317 	ldw	ra,12(sp)
81141f60:	df000217 	ldw	fp,8(sp)
81141f64:	dc400117 	ldw	r17,4(sp)
81141f68:	dc000017 	ldw	r16,0(sp)
81141f6c:	dec00404 	addi	sp,sp,16
81141f70:	f800283a 	ret

81141f74 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81141f74:	defff204 	addi	sp,sp,-56
81141f78:	de00012e 	bgeu	sp,et,81141f80 <altera_avalon_jtag_uart_irq+0xc>
81141f7c:	003b68fa 	trap	3
81141f80:	dfc00d15 	stw	ra,52(sp)
81141f84:	df000c15 	stw	fp,48(sp)
81141f88:	df000c04 	addi	fp,sp,48
81141f8c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81141f90:	e0bfff17 	ldw	r2,-4(fp)
81141f94:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81141f98:	e0bff617 	ldw	r2,-40(fp)
81141f9c:	10800017 	ldw	r2,0(r2)
81141fa0:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81141fa4:	e0bff717 	ldw	r2,-36(fp)
81141fa8:	e17ff617 	ldw	r5,-40(fp)
81141fac:	1009883a 	mov	r4,r2
81141fb0:	11328900 	call	81132890 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81141fb4:	e0bff717 	ldw	r2,-36(fp)
81141fb8:	10800104 	addi	r2,r2,4
81141fbc:	10800037 	ldwio	r2,0(r2)
81141fc0:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81141fc4:	e0bff817 	ldw	r2,-32(fp)
81141fc8:	1080c00c 	andi	r2,r2,768
81141fcc:	10009126 	beq	r2,zero,81142214 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81141fd0:	e0bff817 	ldw	r2,-32(fp)
81141fd4:	1080400c 	andi	r2,r2,256
81141fd8:	10004726 	beq	r2,zero,811420f8 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
81141fdc:	00800074 	movhi	r2,1
81141fe0:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81141fe4:	e0bff617 	ldw	r2,-40(fp)
81141fe8:	10800d17 	ldw	r2,52(r2)
81141fec:	10800044 	addi	r2,r2,1
81141ff0:	1081ffcc 	andi	r2,r2,2047
81141ff4:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
81141ff8:	e0bff617 	ldw	r2,-40(fp)
81141ffc:	10c00e17 	ldw	r3,56(r2)
81142000:	e0bff917 	ldw	r2,-28(fp)
81142004:	18802726 	beq	r3,r2,811420a4 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81142008:	e0bff717 	ldw	r2,-36(fp)
8114200c:	10800037 	ldwio	r2,0(r2)
81142010:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81142014:	e0bff417 	ldw	r2,-48(fp)
81142018:	10a0000c 	andi	r2,r2,32768
8114201c:	10002326 	beq	r2,zero,811420ac <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81142020:	e0bff617 	ldw	r2,-40(fp)
81142024:	10800d17 	ldw	r2,52(r2)
81142028:	e0fff417 	ldw	r3,-48(fp)
8114202c:	1809883a 	mov	r4,r3
81142030:	e0fff617 	ldw	r3,-40(fp)
81142034:	1885883a 	add	r2,r3,r2
81142038:	10801104 	addi	r2,r2,68
8114203c:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81142040:	e0bff617 	ldw	r2,-40(fp)
81142044:	10800d17 	ldw	r2,52(r2)
81142048:	10800044 	addi	r2,r2,1
8114204c:	10c1ffcc 	andi	r3,r2,2047
81142050:	e0bff617 	ldw	r2,-40(fp)
81142054:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81142058:	e0bff617 	ldw	r2,-40(fp)
8114205c:	10800c17 	ldw	r2,48(r2)
81142060:	e0bffb15 	stw	r2,-20(fp)
81142064:	00800044 	movi	r2,1
81142068:	e0bffc0d 	sth	r2,-16(fp)
8114206c:	00800044 	movi	r2,1
81142070:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81142074:	d0a08c03 	ldbu	r2,-32208(gp)
81142078:	10803fcc 	andi	r2,r2,255
8114207c:	103fd926 	beq	r2,zero,81141fe4 <__reset+0xfb121fe4>
  {
    OSFlagPost (group, flags, opt, &err);
81142080:	e0bffc0b 	ldhu	r2,-16(fp)
81142084:	e0fffc83 	ldbu	r3,-14(fp)
81142088:	e13ffdc4 	addi	r4,fp,-9
8114208c:	200f883a 	mov	r7,r4
81142090:	180d883a 	mov	r6,r3
81142094:	100b883a 	mov	r5,r2
81142098:	e13ffb17 	ldw	r4,-20(fp)
8114209c:	1136b800 	call	81136b80 <OSFlagPost>
      }
811420a0:	003fd006 	br	81141fe4 <__reset+0xfb121fe4>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
811420a4:	0001883a 	nop
811420a8:	00000106 	br	811420b0 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
811420ac:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
811420b0:	e0bff417 	ldw	r2,-48(fp)
811420b4:	10bfffec 	andhi	r2,r2,65535
811420b8:	10000f26 	beq	r2,zero,811420f8 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811420bc:	e0bff617 	ldw	r2,-40(fp)
811420c0:	10c00817 	ldw	r3,32(r2)
811420c4:	00bfff84 	movi	r2,-2
811420c8:	1886703a 	and	r3,r3,r2
811420cc:	e0bff617 	ldw	r2,-40(fp)
811420d0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
811420d4:	e0bff717 	ldw	r2,-36(fp)
811420d8:	10800104 	addi	r2,r2,4
811420dc:	1007883a 	mov	r3,r2
811420e0:	e0bff617 	ldw	r2,-40(fp)
811420e4:	10800817 	ldw	r2,32(r2)
811420e8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811420ec:	e0bff717 	ldw	r2,-36(fp)
811420f0:	10800104 	addi	r2,r2,4
811420f4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
811420f8:	e0bff817 	ldw	r2,-32(fp)
811420fc:	1080800c 	andi	r2,r2,512
81142100:	103fac26 	beq	r2,zero,81141fb4 <__reset+0xfb121fb4>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81142104:	e0bff817 	ldw	r2,-32(fp)
81142108:	1004d43a 	srli	r2,r2,16
8114210c:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81142110:	00002606 	br	811421ac <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81142114:	e0bff717 	ldw	r2,-36(fp)
81142118:	e0fff617 	ldw	r3,-40(fp)
8114211c:	18c01017 	ldw	r3,64(r3)
81142120:	e13ff617 	ldw	r4,-40(fp)
81142124:	20c7883a 	add	r3,r4,r3
81142128:	18c21104 	addi	r3,r3,2116
8114212c:	18c00003 	ldbu	r3,0(r3)
81142130:	18c03fcc 	andi	r3,r3,255
81142134:	18c0201c 	xori	r3,r3,128
81142138:	18ffe004 	addi	r3,r3,-128
8114213c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81142140:	e0bff617 	ldw	r2,-40(fp)
81142144:	10801017 	ldw	r2,64(r2)
81142148:	10800044 	addi	r2,r2,1
8114214c:	10c1ffcc 	andi	r3,r2,2047
81142150:	e0bff617 	ldw	r2,-40(fp)
81142154:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81142158:	e0bff617 	ldw	r2,-40(fp)
8114215c:	10800c17 	ldw	r2,48(r2)
81142160:	e0bffa15 	stw	r2,-24(fp)
81142164:	00800084 	movi	r2,2
81142168:	e0bffd0d 	sth	r2,-12(fp)
8114216c:	00800044 	movi	r2,1
81142170:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81142174:	d0a08c03 	ldbu	r2,-32208(gp)
81142178:	10803fcc 	andi	r2,r2,255
8114217c:	10000826 	beq	r2,zero,811421a0 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81142180:	e0bffd0b 	ldhu	r2,-12(fp)
81142184:	e0fffd83 	ldbu	r3,-10(fp)
81142188:	e13ffe04 	addi	r4,fp,-8
8114218c:	200f883a 	mov	r7,r4
81142190:	180d883a 	mov	r6,r3
81142194:	100b883a 	mov	r5,r2
81142198:	e13ffa17 	ldw	r4,-24(fp)
8114219c:	1136b800 	call	81136b80 <OSFlagPost>

        space--;
811421a0:	e0bff517 	ldw	r2,-44(fp)
811421a4:	10bfffc4 	addi	r2,r2,-1
811421a8:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
811421ac:	e0bff517 	ldw	r2,-44(fp)
811421b0:	10000526 	beq	r2,zero,811421c8 <altera_avalon_jtag_uart_irq+0x254>
811421b4:	e0bff617 	ldw	r2,-40(fp)
811421b8:	10c01017 	ldw	r3,64(r2)
811421bc:	e0bff617 	ldw	r2,-40(fp)
811421c0:	10800f17 	ldw	r2,60(r2)
811421c4:	18bfd31e 	bne	r3,r2,81142114 <__reset+0xfb122114>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
811421c8:	e0bff517 	ldw	r2,-44(fp)
811421cc:	103f7926 	beq	r2,zero,81141fb4 <__reset+0xfb121fb4>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811421d0:	e0bff617 	ldw	r2,-40(fp)
811421d4:	10c00817 	ldw	r3,32(r2)
811421d8:	00bfff44 	movi	r2,-3
811421dc:	1886703a 	and	r3,r3,r2
811421e0:	e0bff617 	ldw	r2,-40(fp)
811421e4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811421e8:	e0bff617 	ldw	r2,-40(fp)
811421ec:	10800017 	ldw	r2,0(r2)
811421f0:	10800104 	addi	r2,r2,4
811421f4:	1007883a 	mov	r3,r2
811421f8:	e0bff617 	ldw	r2,-40(fp)
811421fc:	10800817 	ldw	r2,32(r2)
81142200:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81142204:	e0bff717 	ldw	r2,-36(fp)
81142208:	10800104 	addi	r2,r2,4
8114220c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81142210:	003f6806 	br	81141fb4 <__reset+0xfb121fb4>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81142214:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81142218:	0001883a 	nop
8114221c:	e037883a 	mov	sp,fp
81142220:	dfc00117 	ldw	ra,4(sp)
81142224:	df000017 	ldw	fp,0(sp)
81142228:	dec00204 	addi	sp,sp,8
8114222c:	f800283a 	ret

81142230 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81142230:	defff904 	addi	sp,sp,-28
81142234:	de00012e 	bgeu	sp,et,8114223c <altera_avalon_jtag_uart_timeout+0xc>
81142238:	003b68fa 	trap	3
8114223c:	dfc00615 	stw	ra,24(sp)
81142240:	df000515 	stw	fp,20(sp)
81142244:	df000504 	addi	fp,sp,20
81142248:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
8114224c:	e0bfff17 	ldw	r2,-4(fp)
81142250:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81142254:	e0bffb17 	ldw	r2,-20(fp)
81142258:	10800017 	ldw	r2,0(r2)
8114225c:	10800104 	addi	r2,r2,4
81142260:	10800037 	ldwio	r2,0(r2)
81142264:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81142268:	e0bffc17 	ldw	r2,-16(fp)
8114226c:	1081000c 	andi	r2,r2,1024
81142270:	10000b26 	beq	r2,zero,811422a0 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81142274:	e0bffb17 	ldw	r2,-20(fp)
81142278:	10800017 	ldw	r2,0(r2)
8114227c:	10800104 	addi	r2,r2,4
81142280:	1007883a 	mov	r3,r2
81142284:	e0bffb17 	ldw	r2,-20(fp)
81142288:	10800817 	ldw	r2,32(r2)
8114228c:	10810014 	ori	r2,r2,1024
81142290:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81142294:	e0bffb17 	ldw	r2,-20(fp)
81142298:	10000915 	stw	zero,36(r2)
8114229c:	00002106 	br	81142324 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
811422a0:	e0bffb17 	ldw	r2,-20(fp)
811422a4:	10c00917 	ldw	r3,36(r2)
811422a8:	00a00034 	movhi	r2,32768
811422ac:	10bfff04 	addi	r2,r2,-4
811422b0:	10c01c36 	bltu	r2,r3,81142324 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
811422b4:	e0bffb17 	ldw	r2,-20(fp)
811422b8:	10800917 	ldw	r2,36(r2)
811422bc:	10c00044 	addi	r3,r2,1
811422c0:	e0bffb17 	ldw	r2,-20(fp)
811422c4:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
811422c8:	e0bffb17 	ldw	r2,-20(fp)
811422cc:	10c00917 	ldw	r3,36(r2)
811422d0:	e0bffb17 	ldw	r2,-20(fp)
811422d4:	10800117 	ldw	r2,4(r2)
811422d8:	18801236 	bltu	r3,r2,81142324 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
811422dc:	e0bffb17 	ldw	r2,-20(fp)
811422e0:	10800c17 	ldw	r2,48(r2)
811422e4:	e0bffd15 	stw	r2,-12(fp)
811422e8:	00800104 	movi	r2,4
811422ec:	e0bffe0d 	sth	r2,-8(fp)
811422f0:	00800044 	movi	r2,1
811422f4:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811422f8:	d0a08c03 	ldbu	r2,-32208(gp)
811422fc:	10803fcc 	andi	r2,r2,255
81142300:	10000826 	beq	r2,zero,81142324 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81142304:	e0bffe0b 	ldhu	r2,-8(fp)
81142308:	e0fffe83 	ldbu	r3,-6(fp)
8114230c:	e13ffec4 	addi	r4,fp,-5
81142310:	200f883a 	mov	r7,r4
81142314:	180d883a 	mov	r6,r3
81142318:	100b883a 	mov	r5,r2
8114231c:	e13ffd17 	ldw	r4,-12(fp)
81142320:	1136b800 	call	81136b80 <OSFlagPost>
81142324:	d0a08317 	ldw	r2,-32244(gp)
    }
  }

  return alt_ticks_per_second();
}
81142328:	e037883a 	mov	sp,fp
8114232c:	dfc00117 	ldw	ra,4(sp)
81142330:	df000017 	ldw	fp,0(sp)
81142334:	dec00204 	addi	sp,sp,8
81142338:	f800283a 	ret

8114233c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
8114233c:	defffd04 	addi	sp,sp,-12
81142340:	de00012e 	bgeu	sp,et,81142348 <altera_avalon_jtag_uart_close+0xc>
81142344:	003b68fa 	trap	3
81142348:	df000215 	stw	fp,8(sp)
8114234c:	df000204 	addi	fp,sp,8
81142350:	e13ffe15 	stw	r4,-8(fp)
81142354:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81142358:	00000506 	br	81142370 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8114235c:	e0bfff17 	ldw	r2,-4(fp)
81142360:	1090000c 	andi	r2,r2,16384
81142364:	10000226 	beq	r2,zero,81142370 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81142368:	00bffd44 	movi	r2,-11
8114236c:	00000b06 	br	8114239c <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81142370:	e0bffe17 	ldw	r2,-8(fp)
81142374:	10c01017 	ldw	r3,64(r2)
81142378:	e0bffe17 	ldw	r2,-8(fp)
8114237c:	10800f17 	ldw	r2,60(r2)
81142380:	18800526 	beq	r3,r2,81142398 <altera_avalon_jtag_uart_close+0x5c>
81142384:	e0bffe17 	ldw	r2,-8(fp)
81142388:	10c00917 	ldw	r3,36(r2)
8114238c:	e0bffe17 	ldw	r2,-8(fp)
81142390:	10800117 	ldw	r2,4(r2)
81142394:	18bff136 	bltu	r3,r2,8114235c <__reset+0xfb12235c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81142398:	0005883a 	mov	r2,zero
}
8114239c:	e037883a 	mov	sp,fp
811423a0:	df000017 	ldw	fp,0(sp)
811423a4:	dec00104 	addi	sp,sp,4
811423a8:	f800283a 	ret

811423ac <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
811423ac:	defffa04 	addi	sp,sp,-24
811423b0:	de00012e 	bgeu	sp,et,811423b8 <altera_avalon_jtag_uart_ioctl+0xc>
811423b4:	003b68fa 	trap	3
811423b8:	df000515 	stw	fp,20(sp)
811423bc:	df000504 	addi	fp,sp,20
811423c0:	e13ffd15 	stw	r4,-12(fp)
811423c4:	e17ffe15 	stw	r5,-8(fp)
811423c8:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
811423cc:	00bff9c4 	movi	r2,-25
811423d0:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
811423d4:	e0bffe17 	ldw	r2,-8(fp)
811423d8:	10da8060 	cmpeqi	r3,r2,27137
811423dc:	1800031e 	bne	r3,zero,811423ec <altera_avalon_jtag_uart_ioctl+0x40>
811423e0:	109a80a0 	cmpeqi	r2,r2,27138
811423e4:	1000181e 	bne	r2,zero,81142448 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
811423e8:	00002906 	br	81142490 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
811423ec:	e0bffd17 	ldw	r2,-12(fp)
811423f0:	10c00117 	ldw	r3,4(r2)
811423f4:	00a00034 	movhi	r2,32768
811423f8:	10bfffc4 	addi	r2,r2,-1
811423fc:	18802126 	beq	r3,r2,81142484 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81142400:	e0bfff17 	ldw	r2,-4(fp)
81142404:	10800017 	ldw	r2,0(r2)
81142408:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
8114240c:	e0bffc17 	ldw	r2,-16(fp)
81142410:	10800090 	cmplti	r2,r2,2
81142414:	1000061e 	bne	r2,zero,81142430 <altera_avalon_jtag_uart_ioctl+0x84>
81142418:	e0fffc17 	ldw	r3,-16(fp)
8114241c:	00a00034 	movhi	r2,32768
81142420:	10bfffc4 	addi	r2,r2,-1
81142424:	18800226 	beq	r3,r2,81142430 <altera_avalon_jtag_uart_ioctl+0x84>
81142428:	e0bffc17 	ldw	r2,-16(fp)
8114242c:	00000206 	br	81142438 <altera_avalon_jtag_uart_ioctl+0x8c>
81142430:	00a00034 	movhi	r2,32768
81142434:	10bfff84 	addi	r2,r2,-2
81142438:	e0fffd17 	ldw	r3,-12(fp)
8114243c:	18800115 	stw	r2,4(r3)
      rc = 0;
81142440:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81142444:	00000f06 	br	81142484 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81142448:	e0bffd17 	ldw	r2,-12(fp)
8114244c:	10c00117 	ldw	r3,4(r2)
81142450:	00a00034 	movhi	r2,32768
81142454:	10bfffc4 	addi	r2,r2,-1
81142458:	18800c26 	beq	r3,r2,8114248c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
8114245c:	e0bffd17 	ldw	r2,-12(fp)
81142460:	10c00917 	ldw	r3,36(r2)
81142464:	e0bffd17 	ldw	r2,-12(fp)
81142468:	10800117 	ldw	r2,4(r2)
8114246c:	1885803a 	cmpltu	r2,r3,r2
81142470:	10c03fcc 	andi	r3,r2,255
81142474:	e0bfff17 	ldw	r2,-4(fp)
81142478:	10c00015 	stw	r3,0(r2)
      rc = 0;
8114247c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81142480:	00000206 	br	8114248c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81142484:	0001883a 	nop
81142488:	00000106 	br	81142490 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
8114248c:	0001883a 	nop

  default:
    break;
  }

  return rc;
81142490:	e0bffb17 	ldw	r2,-20(fp)
}
81142494:	e037883a 	mov	sp,fp
81142498:	df000017 	ldw	fp,0(sp)
8114249c:	dec00104 	addi	sp,sp,4
811424a0:	f800283a 	ret

811424a4 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
811424a4:	deffed04 	addi	sp,sp,-76
811424a8:	de00012e 	bgeu	sp,et,811424b0 <altera_avalon_jtag_uart_read+0xc>
811424ac:	003b68fa 	trap	3
811424b0:	dfc01215 	stw	ra,72(sp)
811424b4:	df001115 	stw	fp,68(sp)
811424b8:	df001104 	addi	fp,sp,68
811424bc:	e13ffc15 	stw	r4,-16(fp)
811424c0:	e17ffd15 	stw	r5,-12(fp)
811424c4:	e1bffe15 	stw	r6,-8(fp)
811424c8:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
811424cc:	e0bffd17 	ldw	r2,-12(fp)
811424d0:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
811424d4:	e0bffc17 	ldw	r2,-16(fp)
811424d8:	10800a17 	ldw	r2,40(r2)
811424dc:	e0bff815 	stw	r2,-32(fp)
811424e0:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811424e4:	e0bff90b 	ldhu	r2,-28(fp)
811424e8:	e0fffb04 	addi	r3,fp,-20
811424ec:	180d883a 	mov	r6,r3
811424f0:	100b883a 	mov	r5,r2
811424f4:	e13ff817 	ldw	r4,-32(fp)
811424f8:	113a1f80 	call	8113a1f8 <OSSemPend>

  while (space > 0)
811424fc:	00006106 	br	81142684 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81142500:	e0bffc17 	ldw	r2,-16(fp)
81142504:	10800d17 	ldw	r2,52(r2)
81142508:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
8114250c:	e0bffc17 	ldw	r2,-16(fp)
81142510:	10800e17 	ldw	r2,56(r2)
81142514:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81142518:	e0fff317 	ldw	r3,-52(fp)
8114251c:	e0bff417 	ldw	r2,-48(fp)
81142520:	18800536 	bltu	r3,r2,81142538 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81142524:	e0fff317 	ldw	r3,-52(fp)
81142528:	e0bff417 	ldw	r2,-48(fp)
8114252c:	1885c83a 	sub	r2,r3,r2
81142530:	e0bff115 	stw	r2,-60(fp)
81142534:	00000406 	br	81142548 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81142538:	00c20004 	movi	r3,2048
8114253c:	e0bff417 	ldw	r2,-48(fp)
81142540:	1885c83a 	sub	r2,r3,r2
81142544:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81142548:	e0bff117 	ldw	r2,-60(fp)
8114254c:	10001e26 	beq	r2,zero,811425c8 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81142550:	e0fffe17 	ldw	r3,-8(fp)
81142554:	e0bff117 	ldw	r2,-60(fp)
81142558:	1880022e 	bgeu	r3,r2,81142564 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
8114255c:	e0bffe17 	ldw	r2,-8(fp)
81142560:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81142564:	e0bffc17 	ldw	r2,-16(fp)
81142568:	10c01104 	addi	r3,r2,68
8114256c:	e0bff417 	ldw	r2,-48(fp)
81142570:	1885883a 	add	r2,r3,r2
81142574:	e1bff117 	ldw	r6,-60(fp)
81142578:	100b883a 	mov	r5,r2
8114257c:	e13ff017 	ldw	r4,-64(fp)
81142580:	111d1cc0 	call	8111d1cc <memcpy>
      ptr   += n;
81142584:	e0fff017 	ldw	r3,-64(fp)
81142588:	e0bff117 	ldw	r2,-60(fp)
8114258c:	1885883a 	add	r2,r3,r2
81142590:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81142594:	e0fffe17 	ldw	r3,-8(fp)
81142598:	e0bff117 	ldw	r2,-60(fp)
8114259c:	1885c83a 	sub	r2,r3,r2
811425a0:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811425a4:	e0fff417 	ldw	r3,-48(fp)
811425a8:	e0bff117 	ldw	r2,-60(fp)
811425ac:	1885883a 	add	r2,r3,r2
811425b0:	10c1ffcc 	andi	r3,r2,2047
811425b4:	e0bffc17 	ldw	r2,-16(fp)
811425b8:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
811425bc:	e0bffe17 	ldw	r2,-8(fp)
811425c0:	00bfcf16 	blt	zero,r2,81142500 <__reset+0xfb122500>
811425c4:	00000106 	br	811425cc <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
811425c8:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
811425cc:	e0fff017 	ldw	r3,-64(fp)
811425d0:	e0bffd17 	ldw	r2,-12(fp)
811425d4:	18802e1e 	bne	r3,r2,81142690 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
811425d8:	e0bfff17 	ldw	r2,-4(fp)
811425dc:	1090000c 	andi	r2,r2,16384
811425e0:	10002d1e 	bne	r2,zero,81142698 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
811425e4:	d0a08c03 	ldbu	r2,-32208(gp)
811425e8:	10803fcc 	andi	r2,r2,255
811425ec:	10800058 	cmpnei	r2,r2,1
811425f0:	1000161e 	bne	r2,zero,8114264c <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
811425f4:	e0bffc17 	ldw	r2,-16(fp)
811425f8:	10800c17 	ldw	r2,48(r2)
811425fc:	e0bff215 	stw	r2,-56(fp)
81142600:	00800144 	movi	r2,5
81142604:	e0bff98d 	sth	r2,-26(fp)
81142608:	00bfe0c4 	movi	r2,-125
8114260c:	e0bffa05 	stb	r2,-24(fp)
81142610:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81142614:	d0a08c03 	ldbu	r2,-32208(gp)
81142618:	10803fcc 	andi	r2,r2,255
8114261c:	10001526 	beq	r2,zero,81142674 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81142620:	e0fff98b 	ldhu	r3,-26(fp)
81142624:	e13ffa03 	ldbu	r4,-24(fp)
81142628:	e17ffa8b 	ldhu	r5,-22(fp)
8114262c:	e0bffb44 	addi	r2,fp,-19
81142630:	d8800015 	stw	r2,0(sp)
81142634:	280f883a 	mov	r7,r5
81142638:	200d883a 	mov	r6,r4
8114263c:	180b883a 	mov	r5,r3
81142640:	e13ff217 	ldw	r4,-56(fp)
81142644:	11365580 	call	81136558 <OSFlagPend>
81142648:	00000a06 	br	81142674 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
8114264c:	0001883a 	nop
81142650:	e0bffc17 	ldw	r2,-16(fp)
81142654:	10c00d17 	ldw	r3,52(r2)
81142658:	e0bff317 	ldw	r2,-52(fp)
8114265c:	1880051e 	bne	r3,r2,81142674 <altera_avalon_jtag_uart_read+0x1d0>
81142660:	e0bffc17 	ldw	r2,-16(fp)
81142664:	10c00917 	ldw	r3,36(r2)
81142668:	e0bffc17 	ldw	r2,-16(fp)
8114266c:	10800117 	ldw	r2,4(r2)
81142670:	18bff736 	bltu	r3,r2,81142650 <__reset+0xfb122650>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81142674:	e0bffc17 	ldw	r2,-16(fp)
81142678:	10c00d17 	ldw	r3,52(r2)
8114267c:	e0bff317 	ldw	r2,-52(fp)
81142680:	18800726 	beq	r3,r2,811426a0 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81142684:	e0bffe17 	ldw	r2,-8(fp)
81142688:	00bf9d16 	blt	zero,r2,81142500 <__reset+0xfb122500>
8114268c:	00000506 	br	811426a4 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81142690:	0001883a 	nop
81142694:	00000306 	br	811426a4 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81142698:	0001883a 	nop
8114269c:	00000106 	br	811426a4 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
811426a0:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
811426a4:	e0bffc17 	ldw	r2,-16(fp)
811426a8:	10800a17 	ldw	r2,40(r2)
811426ac:	1009883a 	mov	r4,r2
811426b0:	113a5800 	call	8113a580 <OSSemPost>

  if (ptr != buffer)
811426b4:	e0fff017 	ldw	r3,-64(fp)
811426b8:	e0bffd17 	ldw	r2,-12(fp)
811426bc:	18801826 	beq	r3,r2,81142720 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811426c0:	0005303a 	rdctl	r2,status
811426c4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811426c8:	e0fff717 	ldw	r3,-36(fp)
811426cc:	00bfff84 	movi	r2,-2
811426d0:	1884703a 	and	r2,r3,r2
811426d4:	1001703a 	wrctl	status,r2
  
  return context;
811426d8:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
811426dc:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811426e0:	e0bffc17 	ldw	r2,-16(fp)
811426e4:	10800817 	ldw	r2,32(r2)
811426e8:	10c00054 	ori	r3,r2,1
811426ec:	e0bffc17 	ldw	r2,-16(fp)
811426f0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811426f4:	e0bffc17 	ldw	r2,-16(fp)
811426f8:	10800017 	ldw	r2,0(r2)
811426fc:	10800104 	addi	r2,r2,4
81142700:	1007883a 	mov	r3,r2
81142704:	e0bffc17 	ldw	r2,-16(fp)
81142708:	10800817 	ldw	r2,32(r2)
8114270c:	18800035 	stwio	r2,0(r3)
81142710:	e0bff617 	ldw	r2,-40(fp)
81142714:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142718:	e0bff517 	ldw	r2,-44(fp)
8114271c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81142720:	e0fff017 	ldw	r3,-64(fp)
81142724:	e0bffd17 	ldw	r2,-12(fp)
81142728:	18800426 	beq	r3,r2,8114273c <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
8114272c:	e0fff017 	ldw	r3,-64(fp)
81142730:	e0bffd17 	ldw	r2,-12(fp)
81142734:	1885c83a 	sub	r2,r3,r2
81142738:	00000606 	br	81142754 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
8114273c:	e0bfff17 	ldw	r2,-4(fp)
81142740:	1090000c 	andi	r2,r2,16384
81142744:	10000226 	beq	r2,zero,81142750 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81142748:	00bffd44 	movi	r2,-11
8114274c:	00000106 	br	81142754 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81142750:	00bffec4 	movi	r2,-5
}
81142754:	e037883a 	mov	sp,fp
81142758:	dfc00117 	ldw	ra,4(sp)
8114275c:	df000017 	ldw	fp,0(sp)
81142760:	dec00204 	addi	sp,sp,8
81142764:	f800283a 	ret

81142768 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81142768:	deffed04 	addi	sp,sp,-76
8114276c:	de00012e 	bgeu	sp,et,81142774 <altera_avalon_jtag_uart_write+0xc>
81142770:	003b68fa 	trap	3
81142774:	dfc01215 	stw	ra,72(sp)
81142778:	df001115 	stw	fp,68(sp)
8114277c:	df001104 	addi	fp,sp,68
81142780:	e13ffc15 	stw	r4,-16(fp)
81142784:	e17ffd15 	stw	r5,-12(fp)
81142788:	e1bffe15 	stw	r6,-8(fp)
8114278c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81142790:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81142794:	e0bffd17 	ldw	r2,-12(fp)
81142798:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
8114279c:	e0bffc17 	ldw	r2,-16(fp)
811427a0:	10800b17 	ldw	r2,44(r2)
811427a4:	e0bff815 	stw	r2,-32(fp)
811427a8:	e03ff90d 	sth	zero,-28(fp)
811427ac:	e0bff90b 	ldhu	r2,-28(fp)
811427b0:	e0fffb44 	addi	r3,fp,-19
811427b4:	180d883a 	mov	r6,r3
811427b8:	100b883a 	mov	r5,r2
811427bc:	e13ff817 	ldw	r4,-32(fp)
811427c0:	113a1f80 	call	8113a1f8 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811427c4:	00003706 	br	811428a4 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
811427c8:	e0bffc17 	ldw	r2,-16(fp)
811427cc:	10800f17 	ldw	r2,60(r2)
811427d0:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
811427d4:	e0bffc17 	ldw	r2,-16(fp)
811427d8:	10801017 	ldw	r2,64(r2)
811427dc:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
811427e0:	e0fff417 	ldw	r3,-48(fp)
811427e4:	e0bff017 	ldw	r2,-64(fp)
811427e8:	1880062e 	bgeu	r3,r2,81142804 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
811427ec:	e0fff017 	ldw	r3,-64(fp)
811427f0:	e0bff417 	ldw	r2,-48(fp)
811427f4:	1885c83a 	sub	r2,r3,r2
811427f8:	10bfffc4 	addi	r2,r2,-1
811427fc:	e0bff115 	stw	r2,-60(fp)
81142800:	00000b06 	br	81142830 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81142804:	e0bff017 	ldw	r2,-64(fp)
81142808:	10000526 	beq	r2,zero,81142820 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
8114280c:	00c20004 	movi	r3,2048
81142810:	e0bff417 	ldw	r2,-48(fp)
81142814:	1885c83a 	sub	r2,r3,r2
81142818:	e0bff115 	stw	r2,-60(fp)
8114281c:	00000406 	br	81142830 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81142820:	00c1ffc4 	movi	r3,2047
81142824:	e0bff417 	ldw	r2,-48(fp)
81142828:	1885c83a 	sub	r2,r3,r2
8114282c:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81142830:	e0bff117 	ldw	r2,-60(fp)
81142834:	10001e26 	beq	r2,zero,811428b0 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81142838:	e0fffe17 	ldw	r3,-8(fp)
8114283c:	e0bff117 	ldw	r2,-60(fp)
81142840:	1880022e 	bgeu	r3,r2,8114284c <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81142844:	e0bffe17 	ldw	r2,-8(fp)
81142848:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
8114284c:	e0bffc17 	ldw	r2,-16(fp)
81142850:	10c21104 	addi	r3,r2,2116
81142854:	e0bff417 	ldw	r2,-48(fp)
81142858:	1885883a 	add	r2,r3,r2
8114285c:	e1bff117 	ldw	r6,-60(fp)
81142860:	e17ffd17 	ldw	r5,-12(fp)
81142864:	1009883a 	mov	r4,r2
81142868:	111d1cc0 	call	8111d1cc <memcpy>
      ptr   += n;
8114286c:	e0fffd17 	ldw	r3,-12(fp)
81142870:	e0bff117 	ldw	r2,-60(fp)
81142874:	1885883a 	add	r2,r3,r2
81142878:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
8114287c:	e0fffe17 	ldw	r3,-8(fp)
81142880:	e0bff117 	ldw	r2,-60(fp)
81142884:	1885c83a 	sub	r2,r3,r2
81142888:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8114288c:	e0fff417 	ldw	r3,-48(fp)
81142890:	e0bff117 	ldw	r2,-60(fp)
81142894:	1885883a 	add	r2,r3,r2
81142898:	10c1ffcc 	andi	r3,r2,2047
8114289c:	e0bffc17 	ldw	r2,-16(fp)
811428a0:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811428a4:	e0bffe17 	ldw	r2,-8(fp)
811428a8:	00bfc716 	blt	zero,r2,811427c8 <__reset+0xfb1227c8>
811428ac:	00000106 	br	811428b4 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
811428b0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811428b4:	0005303a 	rdctl	r2,status
811428b8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811428bc:	e0fff717 	ldw	r3,-36(fp)
811428c0:	00bfff84 	movi	r2,-2
811428c4:	1884703a 	and	r2,r3,r2
811428c8:	1001703a 	wrctl	status,r2
  
  return context;
811428cc:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
811428d0:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811428d4:	e0bffc17 	ldw	r2,-16(fp)
811428d8:	10800817 	ldw	r2,32(r2)
811428dc:	10c00094 	ori	r3,r2,2
811428e0:	e0bffc17 	ldw	r2,-16(fp)
811428e4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811428e8:	e0bffc17 	ldw	r2,-16(fp)
811428ec:	10800017 	ldw	r2,0(r2)
811428f0:	10800104 	addi	r2,r2,4
811428f4:	1007883a 	mov	r3,r2
811428f8:	e0bffc17 	ldw	r2,-16(fp)
811428fc:	10800817 	ldw	r2,32(r2)
81142900:	18800035 	stwio	r2,0(r3)
81142904:	e0bff617 	ldw	r2,-40(fp)
81142908:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114290c:	e0bff317 	ldw	r2,-52(fp)
81142910:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81142914:	e0bffe17 	ldw	r2,-8(fp)
81142918:	00802a0e 	bge	zero,r2,811429c4 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
8114291c:	e0bfff17 	ldw	r2,-4(fp)
81142920:	1090000c 	andi	r2,r2,16384
81142924:	10002a1e 	bne	r2,zero,811429d0 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81142928:	d0a08c03 	ldbu	r2,-32208(gp)
8114292c:	10803fcc 	andi	r2,r2,255
81142930:	10800058 	cmpnei	r2,r2,1
81142934:	1000161e 	bne	r2,zero,81142990 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81142938:	e0bffc17 	ldw	r2,-16(fp)
8114293c:	10800c17 	ldw	r2,48(r2)
81142940:	e0bff515 	stw	r2,-44(fp)
81142944:	00800184 	movi	r2,6
81142948:	e0bff98d 	sth	r2,-26(fp)
8114294c:	00bfe0c4 	movi	r2,-125
81142950:	e0bffa05 	stb	r2,-24(fp)
81142954:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81142958:	d0a08c03 	ldbu	r2,-32208(gp)
8114295c:	10803fcc 	andi	r2,r2,255
81142960:	10001526 	beq	r2,zero,811429b8 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81142964:	e0fff98b 	ldhu	r3,-26(fp)
81142968:	e13ffa03 	ldbu	r4,-24(fp)
8114296c:	e17ffa8b 	ldhu	r5,-22(fp)
81142970:	e0bffb04 	addi	r2,fp,-20
81142974:	d8800015 	stw	r2,0(sp)
81142978:	280f883a 	mov	r7,r5
8114297c:	200d883a 	mov	r6,r4
81142980:	180b883a 	mov	r5,r3
81142984:	e13ff517 	ldw	r4,-44(fp)
81142988:	11365580 	call	81136558 <OSFlagPend>
8114298c:	00000a06 	br	811429b8 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81142990:	0001883a 	nop
81142994:	e0bffc17 	ldw	r2,-16(fp)
81142998:	10c01017 	ldw	r3,64(r2)
8114299c:	e0bff017 	ldw	r2,-64(fp)
811429a0:	1880051e 	bne	r3,r2,811429b8 <altera_avalon_jtag_uart_write+0x250>
811429a4:	e0bffc17 	ldw	r2,-16(fp)
811429a8:	10c00917 	ldw	r3,36(r2)
811429ac:	e0bffc17 	ldw	r2,-16(fp)
811429b0:	10800117 	ldw	r2,4(r2)
811429b4:	18bff736 	bltu	r3,r2,81142994 <__reset+0xfb122994>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
811429b8:	e0bffc17 	ldw	r2,-16(fp)
811429bc:	10800917 	ldw	r2,36(r2)
811429c0:	1000051e 	bne	r2,zero,811429d8 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
811429c4:	e0bffe17 	ldw	r2,-8(fp)
811429c8:	00bfb616 	blt	zero,r2,811428a4 <__reset+0xfb1228a4>
811429cc:	00000306 	br	811429dc <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
811429d0:	0001883a 	nop
811429d4:	00000106 	br	811429dc <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811429d8:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811429dc:	e0bffc17 	ldw	r2,-16(fp)
811429e0:	10800b17 	ldw	r2,44(r2)
811429e4:	1009883a 	mov	r4,r2
811429e8:	113a5800 	call	8113a580 <OSSemPost>

  if (ptr != start)
811429ec:	e0fffd17 	ldw	r3,-12(fp)
811429f0:	e0bff217 	ldw	r2,-56(fp)
811429f4:	18800426 	beq	r3,r2,81142a08 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
811429f8:	e0fffd17 	ldw	r3,-12(fp)
811429fc:	e0bff217 	ldw	r2,-56(fp)
81142a00:	1885c83a 	sub	r2,r3,r2
81142a04:	00000606 	br	81142a20 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81142a08:	e0bfff17 	ldw	r2,-4(fp)
81142a0c:	1090000c 	andi	r2,r2,16384
81142a10:	10000226 	beq	r2,zero,81142a1c <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81142a14:	00bffd44 	movi	r2,-11
81142a18:	00000106 	br	81142a20 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
81142a1c:	00bffec4 	movi	r2,-5
}
81142a20:	e037883a 	mov	sp,fp
81142a24:	dfc00117 	ldw	ra,4(sp)
81142a28:	df000017 	ldw	fp,0(sp)
81142a2c:	dec00204 	addi	sp,sp,8
81142a30:	f800283a 	ret

81142a34 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81142a34:	defffa04 	addi	sp,sp,-24
81142a38:	de00012e 	bgeu	sp,et,81142a40 <alt_avalon_timer_sc_irq+0xc>
81142a3c:	003b68fa 	trap	3
81142a40:	dfc00515 	stw	ra,20(sp)
81142a44:	df000415 	stw	fp,16(sp)
81142a48:	df000404 	addi	fp,sp,16
81142a4c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81142a50:	0007883a 	mov	r3,zero
81142a54:	e0bfff17 	ldw	r2,-4(fp)
81142a58:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81142a5c:	e0bfff17 	ldw	r2,-4(fp)
81142a60:	10800104 	addi	r2,r2,4
81142a64:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81142a68:	1132a340 	call	81132a34 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142a6c:	0005303a 	rdctl	r2,status
81142a70:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142a74:	e0fffd17 	ldw	r3,-12(fp)
81142a78:	00bfff84 	movi	r2,-2
81142a7c:	1884703a 	and	r2,r3,r2
81142a80:	1001703a 	wrctl	status,r2
  
  return context;
81142a84:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81142a88:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81142a8c:	11332e40 	call	811332e4 <alt_tick>
81142a90:	e0bffc17 	ldw	r2,-16(fp)
81142a94:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142a98:	e0bffe17 	ldw	r2,-8(fp)
81142a9c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
81142aa0:	0001883a 	nop
81142aa4:	e037883a 	mov	sp,fp
81142aa8:	dfc00117 	ldw	ra,4(sp)
81142aac:	df000017 	ldw	fp,0(sp)
81142ab0:	dec00204 	addi	sp,sp,8
81142ab4:	f800283a 	ret

81142ab8 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
81142ab8:	defff804 	addi	sp,sp,-32
81142abc:	de00012e 	bgeu	sp,et,81142ac4 <alt_avalon_timer_sc_init+0xc>
81142ac0:	003b68fa 	trap	3
81142ac4:	dfc00715 	stw	ra,28(sp)
81142ac8:	df000615 	stw	fp,24(sp)
81142acc:	df000604 	addi	fp,sp,24
81142ad0:	e13ffc15 	stw	r4,-16(fp)
81142ad4:	e17ffd15 	stw	r5,-12(fp)
81142ad8:	e1bffe15 	stw	r6,-8(fp)
81142adc:	e1ffff15 	stw	r7,-4(fp)
81142ae0:	e0bfff17 	ldw	r2,-4(fp)
81142ae4:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
81142ae8:	d0a08317 	ldw	r2,-32244(gp)
81142aec:	1000021e 	bne	r2,zero,81142af8 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81142af0:	e0bffb17 	ldw	r2,-20(fp)
81142af4:	d0a08315 	stw	r2,-32244(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
81142af8:	e0bffc17 	ldw	r2,-16(fp)
81142afc:	10800104 	addi	r2,r2,4
81142b00:	00c001c4 	movi	r3,7
81142b04:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81142b08:	d8000015 	stw	zero,0(sp)
81142b0c:	e1fffc17 	ldw	r7,-16(fp)
81142b10:	01a04534 	movhi	r6,33044
81142b14:	318a8d04 	addi	r6,r6,10804
81142b18:	e17ffe17 	ldw	r5,-8(fp)
81142b1c:	e13ffd17 	ldw	r4,-12(fp)
81142b20:	1145cbc0 	call	81145cbc <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81142b24:	0001883a 	nop
81142b28:	e037883a 	mov	sp,fp
81142b2c:	dfc00117 	ldw	ra,4(sp)
81142b30:	df000017 	ldw	fp,0(sp)
81142b34:	dec00204 	addi	sp,sp,8
81142b38:	f800283a 	ret

81142b3c <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81142b3c:	defffa04 	addi	sp,sp,-24
81142b40:	de00012e 	bgeu	sp,et,81142b48 <altera_avalon_uart_read_fd+0xc>
81142b44:	003b68fa 	trap	3
81142b48:	dfc00515 	stw	ra,20(sp)
81142b4c:	df000415 	stw	fp,16(sp)
81142b50:	df000404 	addi	fp,sp,16
81142b54:	e13ffd15 	stw	r4,-12(fp)
81142b58:	e17ffe15 	stw	r5,-8(fp)
81142b5c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81142b60:	e0bffd17 	ldw	r2,-12(fp)
81142b64:	10800017 	ldw	r2,0(r2)
81142b68:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81142b6c:	e0bffc17 	ldw	r2,-16(fp)
81142b70:	10c00a04 	addi	r3,r2,40
81142b74:	e0bffd17 	ldw	r2,-12(fp)
81142b78:	10800217 	ldw	r2,8(r2)
81142b7c:	100f883a 	mov	r7,r2
81142b80:	e1bfff17 	ldw	r6,-4(fp)
81142b84:	e17ffe17 	ldw	r5,-8(fp)
81142b88:	1809883a 	mov	r4,r3
81142b8c:	11431fc0 	call	811431fc <altera_avalon_uart_read>
      fd->fd_flags);
}
81142b90:	e037883a 	mov	sp,fp
81142b94:	dfc00117 	ldw	ra,4(sp)
81142b98:	df000017 	ldw	fp,0(sp)
81142b9c:	dec00204 	addi	sp,sp,8
81142ba0:	f800283a 	ret

81142ba4 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81142ba4:	defffa04 	addi	sp,sp,-24
81142ba8:	de00012e 	bgeu	sp,et,81142bb0 <altera_avalon_uart_write_fd+0xc>
81142bac:	003b68fa 	trap	3
81142bb0:	dfc00515 	stw	ra,20(sp)
81142bb4:	df000415 	stw	fp,16(sp)
81142bb8:	df000404 	addi	fp,sp,16
81142bbc:	e13ffd15 	stw	r4,-12(fp)
81142bc0:	e17ffe15 	stw	r5,-8(fp)
81142bc4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81142bc8:	e0bffd17 	ldw	r2,-12(fp)
81142bcc:	10800017 	ldw	r2,0(r2)
81142bd0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
81142bd4:	e0bffc17 	ldw	r2,-16(fp)
81142bd8:	10c00a04 	addi	r3,r2,40
81142bdc:	e0bffd17 	ldw	r2,-12(fp)
81142be0:	10800217 	ldw	r2,8(r2)
81142be4:	100f883a 	mov	r7,r2
81142be8:	e1bfff17 	ldw	r6,-4(fp)
81142bec:	e17ffe17 	ldw	r5,-8(fp)
81142bf0:	1809883a 	mov	r4,r3
81142bf4:	11434b00 	call	811434b0 <altera_avalon_uart_write>
      fd->fd_flags);
}
81142bf8:	e037883a 	mov	sp,fp
81142bfc:	dfc00117 	ldw	ra,4(sp)
81142c00:	df000017 	ldw	fp,0(sp)
81142c04:	dec00204 	addi	sp,sp,8
81142c08:	f800283a 	ret

81142c0c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81142c0c:	defffc04 	addi	sp,sp,-16
81142c10:	de00012e 	bgeu	sp,et,81142c18 <altera_avalon_uart_close_fd+0xc>
81142c14:	003b68fa 	trap	3
81142c18:	dfc00315 	stw	ra,12(sp)
81142c1c:	df000215 	stw	fp,8(sp)
81142c20:	df000204 	addi	fp,sp,8
81142c24:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81142c28:	e0bfff17 	ldw	r2,-4(fp)
81142c2c:	10800017 	ldw	r2,0(r2)
81142c30:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81142c34:	e0bffe17 	ldw	r2,-8(fp)
81142c38:	10c00a04 	addi	r3,r2,40
81142c3c:	e0bfff17 	ldw	r2,-4(fp)
81142c40:	10800217 	ldw	r2,8(r2)
81142c44:	100b883a 	mov	r5,r2
81142c48:	1809883a 	mov	r4,r3
81142c4c:	114315c0 	call	8114315c <altera_avalon_uart_close>
}
81142c50:	e037883a 	mov	sp,fp
81142c54:	dfc00117 	ldw	ra,4(sp)
81142c58:	df000017 	ldw	fp,0(sp)
81142c5c:	dec00204 	addi	sp,sp,8
81142c60:	f800283a 	ret

81142c64 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81142c64:	defff304 	addi	sp,sp,-52
81142c68:	de00012e 	bgeu	sp,et,81142c70 <altera_avalon_uart_init+0xc>
81142c6c:	003b68fa 	trap	3
81142c70:	dfc00c15 	stw	ra,48(sp)
81142c74:	df000b15 	stw	fp,44(sp)
81142c78:	df000b04 	addi	fp,sp,44
81142c7c:	e13ffd15 	stw	r4,-12(fp)
81142c80:	e17ffe15 	stw	r5,-8(fp)
81142c84:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81142c88:	e0bffd17 	ldw	r2,-12(fp)
81142c8c:	10800017 	ldw	r2,0(r2)
81142c90:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81142c94:	e0bffd17 	ldw	r2,-12(fp)
81142c98:	10800704 	addi	r2,r2,28
81142c9c:	e0bffa15 	stw	r2,-24(fp)
81142ca0:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81142ca4:	e0bffb0b 	ldhu	r2,-20(fp)
81142ca8:	e0fffc84 	addi	r3,fp,-14
81142cac:	180b883a 	mov	r5,r3
81142cb0:	1009883a 	mov	r4,r2
81142cb4:	1135f740 	call	81135f74 <OSFlagCreate>
81142cb8:	1007883a 	mov	r3,r2
81142cbc:	e0bffa17 	ldw	r2,-24(fp)
81142cc0:	10c00015 	stw	r3,0(r2)
  return err;
81142cc4:	e0bffc83 	ldbu	r2,-14(fp)
81142cc8:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81142ccc:	1000241e 	bne	r2,zero,81142d60 <altera_avalon_uart_init+0xfc>
81142cd0:	e0bffd17 	ldw	r2,-12(fp)
81142cd4:	10800804 	addi	r2,r2,32
81142cd8:	e0bff715 	stw	r2,-36(fp)
81142cdc:	00800044 	movi	r2,1
81142ce0:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81142ce4:	e0bffb8b 	ldhu	r2,-18(fp)
81142ce8:	1009883a 	mov	r4,r2
81142cec:	1139ed00 	call	81139ed0 <OSSemCreate>
81142cf0:	1007883a 	mov	r3,r2
81142cf4:	e0bff717 	ldw	r2,-36(fp)
81142cf8:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81142cfc:	e0bff717 	ldw	r2,-36(fp)
81142d00:	10800017 	ldw	r2,0(r2)
81142d04:	10000226 	beq	r2,zero,81142d10 <altera_avalon_uart_init+0xac>
81142d08:	0005883a 	mov	r2,zero
81142d0c:	00000106 	br	81142d14 <altera_avalon_uart_init+0xb0>
81142d10:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81142d14:	1000121e 	bne	r2,zero,81142d60 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81142d18:	e0bffd17 	ldw	r2,-12(fp)
81142d1c:	10800904 	addi	r2,r2,36
81142d20:	e0bff815 	stw	r2,-32(fp)
81142d24:	00800044 	movi	r2,1
81142d28:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81142d2c:	e0bffc0b 	ldhu	r2,-16(fp)
81142d30:	1009883a 	mov	r4,r2
81142d34:	1139ed00 	call	81139ed0 <OSSemCreate>
81142d38:	1007883a 	mov	r3,r2
81142d3c:	e0bff817 	ldw	r2,-32(fp)
81142d40:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81142d44:	e0bff817 	ldw	r2,-32(fp)
81142d48:	10800017 	ldw	r2,0(r2)
81142d4c:	10000226 	beq	r2,zero,81142d58 <altera_avalon_uart_init+0xf4>
81142d50:	0005883a 	mov	r2,zero
81142d54:	00000106 	br	81142d5c <altera_avalon_uart_init+0xf8>
81142d58:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81142d5c:	10000226 	beq	r2,zero,81142d68 <altera_avalon_uart_init+0x104>
81142d60:	00800044 	movi	r2,1
81142d64:	00000106 	br	81142d6c <altera_avalon_uart_init+0x108>
81142d68:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81142d6c:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81142d70:	e0bff917 	ldw	r2,-28(fp)
81142d74:	10000f1e 	bne	r2,zero,81142db4 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81142d78:	e0bffd17 	ldw	r2,-12(fp)
81142d7c:	00c32004 	movi	r3,3200
81142d80:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81142d84:	e0bff617 	ldw	r2,-40(fp)
81142d88:	10800304 	addi	r2,r2,12
81142d8c:	e0fffd17 	ldw	r3,-12(fp)
81142d90:	18c00117 	ldw	r3,4(r3)
81142d94:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81142d98:	d8000015 	stw	zero,0(sp)
81142d9c:	e1fffd17 	ldw	r7,-12(fp)
81142da0:	01a04534 	movhi	r6,33044
81142da4:	318b7304 	addi	r6,r6,11724
81142da8:	e17fff17 	ldw	r5,-4(fp)
81142dac:	e13ffe17 	ldw	r4,-8(fp)
81142db0:	1145cbc0 	call	81145cbc <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81142db4:	0001883a 	nop
81142db8:	e037883a 	mov	sp,fp
81142dbc:	dfc00117 	ldw	ra,4(sp)
81142dc0:	df000017 	ldw	fp,0(sp)
81142dc4:	dec00204 	addi	sp,sp,8
81142dc8:	f800283a 	ret

81142dcc <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
81142dcc:	defffa04 	addi	sp,sp,-24
81142dd0:	de00012e 	bgeu	sp,et,81142dd8 <altera_avalon_uart_irq+0xc>
81142dd4:	003b68fa 	trap	3
81142dd8:	dfc00515 	stw	ra,20(sp)
81142ddc:	df000415 	stw	fp,16(sp)
81142de0:	df000404 	addi	fp,sp,16
81142de4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
81142de8:	e0bfff17 	ldw	r2,-4(fp)
81142dec:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81142df0:	e0bffc17 	ldw	r2,-16(fp)
81142df4:	10800017 	ldw	r2,0(r2)
81142df8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
81142dfc:	e0bffd17 	ldw	r2,-12(fp)
81142e00:	10800204 	addi	r2,r2,8
81142e04:	10800037 	ldwio	r2,0(r2)
81142e08:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
81142e0c:	e0bffd17 	ldw	r2,-12(fp)
81142e10:	10800204 	addi	r2,r2,8
81142e14:	0007883a 	mov	r3,zero
81142e18:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
81142e1c:	e0bffd17 	ldw	r2,-12(fp)
81142e20:	10800204 	addi	r2,r2,8
81142e24:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81142e28:	e0bffe17 	ldw	r2,-8(fp)
81142e2c:	1080200c 	andi	r2,r2,128
81142e30:	10000326 	beq	r2,zero,81142e40 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81142e34:	e17ffe17 	ldw	r5,-8(fp)
81142e38:	e13ffc17 	ldw	r4,-16(fp)
81142e3c:	1142e700 	call	81142e70 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81142e40:	e0bffe17 	ldw	r2,-8(fp)
81142e44:	1081100c 	andi	r2,r2,1088
81142e48:	10000326 	beq	r2,zero,81142e58 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81142e4c:	e17ffe17 	ldw	r5,-8(fp)
81142e50:	e13ffc17 	ldw	r4,-16(fp)
81142e54:	1142fb00 	call	81142fb0 <altera_avalon_uart_txirq>
  }
  

}
81142e58:	0001883a 	nop
81142e5c:	e037883a 	mov	sp,fp
81142e60:	dfc00117 	ldw	ra,4(sp)
81142e64:	df000017 	ldw	fp,0(sp)
81142e68:	dec00204 	addi	sp,sp,8
81142e6c:	f800283a 	ret

81142e70 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81142e70:	defff904 	addi	sp,sp,-28
81142e74:	de00012e 	bgeu	sp,et,81142e7c <altera_avalon_uart_rxirq+0xc>
81142e78:	003b68fa 	trap	3
81142e7c:	dfc00615 	stw	ra,24(sp)
81142e80:	df000515 	stw	fp,20(sp)
81142e84:	df000504 	addi	fp,sp,20
81142e88:	e13ffe15 	stw	r4,-8(fp)
81142e8c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81142e90:	e0bfff17 	ldw	r2,-4(fp)
81142e94:	108000cc 	andi	r2,r2,3
81142e98:	10003f1e 	bne	r2,zero,81142f98 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81142e9c:	e0bffe17 	ldw	r2,-8(fp)
81142ea0:	10c00317 	ldw	r3,12(r2)
81142ea4:	e0bffe17 	ldw	r2,-8(fp)
81142ea8:	10800217 	ldw	r2,8(r2)
81142eac:	1880121e 	bne	r3,r2,81142ef8 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81142eb0:	e0bffe17 	ldw	r2,-8(fp)
81142eb4:	10800717 	ldw	r2,28(r2)
81142eb8:	e0bffc15 	stw	r2,-16(fp)
81142ebc:	00800044 	movi	r2,1
81142ec0:	e0bffd0d 	sth	r2,-12(fp)
81142ec4:	00800044 	movi	r2,1
81142ec8:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81142ecc:	d0a08c03 	ldbu	r2,-32208(gp)
81142ed0:	10803fcc 	andi	r2,r2,255
81142ed4:	10000826 	beq	r2,zero,81142ef8 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
81142ed8:	e0bffd0b 	ldhu	r2,-12(fp)
81142edc:	e0fffd83 	ldbu	r3,-10(fp)
81142ee0:	e13ffdc4 	addi	r4,fp,-9
81142ee4:	200f883a 	mov	r7,r4
81142ee8:	180d883a 	mov	r6,r3
81142eec:	100b883a 	mov	r5,r2
81142ef0:	e13ffc17 	ldw	r4,-16(fp)
81142ef4:	1136b800 	call	81136b80 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81142ef8:	e0bffe17 	ldw	r2,-8(fp)
81142efc:	10800317 	ldw	r2,12(r2)
81142f00:	10800044 	addi	r2,r2,1
81142f04:	10800fcc 	andi	r2,r2,63
81142f08:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81142f0c:	e0bffe17 	ldw	r2,-8(fp)
81142f10:	10800317 	ldw	r2,12(r2)
81142f14:	e0fffe17 	ldw	r3,-8(fp)
81142f18:	18c00017 	ldw	r3,0(r3)
81142f1c:	18c00037 	ldwio	r3,0(r3)
81142f20:	1809883a 	mov	r4,r3
81142f24:	e0fffe17 	ldw	r3,-8(fp)
81142f28:	1885883a 	add	r2,r3,r2
81142f2c:	10800a04 	addi	r2,r2,40
81142f30:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81142f34:	e0bffe17 	ldw	r2,-8(fp)
81142f38:	e0fffb17 	ldw	r3,-20(fp)
81142f3c:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81142f40:	e0bffe17 	ldw	r2,-8(fp)
81142f44:	10800317 	ldw	r2,12(r2)
81142f48:	10800044 	addi	r2,r2,1
81142f4c:	10800fcc 	andi	r2,r2,63
81142f50:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81142f54:	e0bffe17 	ldw	r2,-8(fp)
81142f58:	10c00217 	ldw	r3,8(r2)
81142f5c:	e0bffb17 	ldw	r2,-20(fp)
81142f60:	18800e1e 	bne	r3,r2,81142f9c <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81142f64:	e0bffe17 	ldw	r2,-8(fp)
81142f68:	10c00117 	ldw	r3,4(r2)
81142f6c:	00bfdfc4 	movi	r2,-129
81142f70:	1886703a 	and	r3,r3,r2
81142f74:	e0bffe17 	ldw	r2,-8(fp)
81142f78:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81142f7c:	e0bffe17 	ldw	r2,-8(fp)
81142f80:	10800017 	ldw	r2,0(r2)
81142f84:	10800304 	addi	r2,r2,12
81142f88:	e0fffe17 	ldw	r3,-8(fp)
81142f8c:	18c00117 	ldw	r3,4(r3)
81142f90:	10c00035 	stwio	r3,0(r2)
81142f94:	00000106 	br	81142f9c <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81142f98:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81142f9c:	e037883a 	mov	sp,fp
81142fa0:	dfc00117 	ldw	ra,4(sp)
81142fa4:	df000017 	ldw	fp,0(sp)
81142fa8:	dec00204 	addi	sp,sp,8
81142fac:	f800283a 	ret

81142fb0 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81142fb0:	defffa04 	addi	sp,sp,-24
81142fb4:	de00012e 	bgeu	sp,et,81142fbc <altera_avalon_uart_txirq+0xc>
81142fb8:	003b68fa 	trap	3
81142fbc:	dfc00515 	stw	ra,20(sp)
81142fc0:	df000415 	stw	fp,16(sp)
81142fc4:	df000404 	addi	fp,sp,16
81142fc8:	e13ffe15 	stw	r4,-8(fp)
81142fcc:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81142fd0:	e0bffe17 	ldw	r2,-8(fp)
81142fd4:	10c00417 	ldw	r3,16(r2)
81142fd8:	e0bffe17 	ldw	r2,-8(fp)
81142fdc:	10800517 	ldw	r2,20(r2)
81142fe0:	18804726 	beq	r3,r2,81143100 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81142fe4:	e0bffe17 	ldw	r2,-8(fp)
81142fe8:	10800617 	ldw	r2,24(r2)
81142fec:	1080008c 	andi	r2,r2,2
81142ff0:	10000326 	beq	r2,zero,81143000 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81142ff4:	e0bfff17 	ldw	r2,-4(fp)
81142ff8:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81142ffc:	10003226 	beq	r2,zero,811430c8 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81143000:	e0bffe17 	ldw	r2,-8(fp)
81143004:	10c00417 	ldw	r3,16(r2)
81143008:	e0bffe17 	ldw	r2,-8(fp)
8114300c:	10800517 	ldw	r2,20(r2)
81143010:	10800044 	addi	r2,r2,1
81143014:	10800fcc 	andi	r2,r2,63
81143018:	1880121e 	bne	r3,r2,81143064 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
8114301c:	e0bffe17 	ldw	r2,-8(fp)
81143020:	10800717 	ldw	r2,28(r2)
81143024:	e0bffc15 	stw	r2,-16(fp)
81143028:	00800084 	movi	r2,2
8114302c:	e0bffd0d 	sth	r2,-12(fp)
81143030:	00800044 	movi	r2,1
81143034:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81143038:	d0a08c03 	ldbu	r2,-32208(gp)
8114303c:	10803fcc 	andi	r2,r2,255
81143040:	10000826 	beq	r2,zero,81143064 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81143044:	e0bffd0b 	ldhu	r2,-12(fp)
81143048:	e0fffd83 	ldbu	r3,-10(fp)
8114304c:	e13ffdc4 	addi	r4,fp,-9
81143050:	200f883a 	mov	r7,r4
81143054:	180d883a 	mov	r6,r3
81143058:	100b883a 	mov	r5,r2
8114305c:	e13ffc17 	ldw	r4,-16(fp)
81143060:	1136b800 	call	81136b80 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81143064:	e0bffe17 	ldw	r2,-8(fp)
81143068:	10800017 	ldw	r2,0(r2)
8114306c:	10800104 	addi	r2,r2,4
81143070:	e0fffe17 	ldw	r3,-8(fp)
81143074:	18c00417 	ldw	r3,16(r3)
81143078:	e13ffe17 	ldw	r4,-8(fp)
8114307c:	20c7883a 	add	r3,r4,r3
81143080:	18c01a04 	addi	r3,r3,104
81143084:	18c00003 	ldbu	r3,0(r3)
81143088:	18c03fcc 	andi	r3,r3,255
8114308c:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81143090:	e0bffe17 	ldw	r2,-8(fp)
81143094:	10800417 	ldw	r2,16(r2)
81143098:	10800044 	addi	r2,r2,1
8114309c:	e0fffe17 	ldw	r3,-8(fp)
811430a0:	18800415 	stw	r2,16(r3)
811430a4:	10c00fcc 	andi	r3,r2,63
811430a8:	e0bffe17 	ldw	r2,-8(fp)
811430ac:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811430b0:	e0bffe17 	ldw	r2,-8(fp)
811430b4:	10800117 	ldw	r2,4(r2)
811430b8:	10c01014 	ori	r3,r2,64
811430bc:	e0bffe17 	ldw	r2,-8(fp)
811430c0:	10c00115 	stw	r3,4(r2)
811430c4:	00000e06 	br	81143100 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
811430c8:	e0bffe17 	ldw	r2,-8(fp)
811430cc:	10800017 	ldw	r2,0(r2)
811430d0:	10800204 	addi	r2,r2,8
811430d4:	10800037 	ldwio	r2,0(r2)
811430d8:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811430dc:	e0bfff17 	ldw	r2,-4(fp)
811430e0:	1082000c 	andi	r2,r2,2048
811430e4:	1000061e 	bne	r2,zero,81143100 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811430e8:	e0bffe17 	ldw	r2,-8(fp)
811430ec:	10c00117 	ldw	r3,4(r2)
811430f0:	00bfefc4 	movi	r2,-65
811430f4:	1886703a 	and	r3,r3,r2
811430f8:	e0bffe17 	ldw	r2,-8(fp)
811430fc:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81143100:	e0bffe17 	ldw	r2,-8(fp)
81143104:	10c00417 	ldw	r3,16(r2)
81143108:	e0bffe17 	ldw	r2,-8(fp)
8114310c:	10800517 	ldw	r2,20(r2)
81143110:	1880061e 	bne	r3,r2,8114312c <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81143114:	e0bffe17 	ldw	r2,-8(fp)
81143118:	10c00117 	ldw	r3,4(r2)
8114311c:	00beefc4 	movi	r2,-1089
81143120:	1886703a 	and	r3,r3,r2
81143124:	e0bffe17 	ldw	r2,-8(fp)
81143128:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114312c:	e0bffe17 	ldw	r2,-8(fp)
81143130:	10800017 	ldw	r2,0(r2)
81143134:	10800304 	addi	r2,r2,12
81143138:	e0fffe17 	ldw	r3,-8(fp)
8114313c:	18c00117 	ldw	r3,4(r3)
81143140:	10c00035 	stwio	r3,0(r2)
}
81143144:	0001883a 	nop
81143148:	e037883a 	mov	sp,fp
8114314c:	dfc00117 	ldw	ra,4(sp)
81143150:	df000017 	ldw	fp,0(sp)
81143154:	dec00204 	addi	sp,sp,8
81143158:	f800283a 	ret

8114315c <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
8114315c:	defffd04 	addi	sp,sp,-12
81143160:	de00012e 	bgeu	sp,et,81143168 <altera_avalon_uart_close+0xc>
81143164:	003b68fa 	trap	3
81143168:	df000215 	stw	fp,8(sp)
8114316c:	df000204 	addi	fp,sp,8
81143170:	e13ffe15 	stw	r4,-8(fp)
81143174:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81143178:	00000506 	br	81143190 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8114317c:	e0bfff17 	ldw	r2,-4(fp)
81143180:	1090000c 	andi	r2,r2,16384
81143184:	10000226 	beq	r2,zero,81143190 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81143188:	00bffd44 	movi	r2,-11
8114318c:	00000606 	br	811431a8 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81143190:	e0bffe17 	ldw	r2,-8(fp)
81143194:	10c00417 	ldw	r3,16(r2)
81143198:	e0bffe17 	ldw	r2,-8(fp)
8114319c:	10800517 	ldw	r2,20(r2)
811431a0:	18bff61e 	bne	r3,r2,8114317c <__reset+0xfb12317c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
811431a4:	0005883a 	mov	r2,zero
}
811431a8:	e037883a 	mov	sp,fp
811431ac:	df000017 	ldw	fp,0(sp)
811431b0:	dec00104 	addi	sp,sp,4
811431b4:	f800283a 	ret

811431b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811431b8:	defffe04 	addi	sp,sp,-8
811431bc:	de00012e 	bgeu	sp,et,811431c4 <alt_get_errno+0xc>
811431c0:	003b68fa 	trap	3
811431c4:	dfc00115 	stw	ra,4(sp)
811431c8:	df000015 	stw	fp,0(sp)
811431cc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811431d0:	d0a01017 	ldw	r2,-32704(gp)
811431d4:	10000326 	beq	r2,zero,811431e4 <alt_get_errno+0x2c>
811431d8:	d0a01017 	ldw	r2,-32704(gp)
811431dc:	103ee83a 	callr	r2
811431e0:	00000106 	br	811431e8 <alt_get_errno+0x30>
811431e4:	d0a07304 	addi	r2,gp,-32308
}
811431e8:	e037883a 	mov	sp,fp
811431ec:	dfc00117 	ldw	ra,4(sp)
811431f0:	df000017 	ldw	fp,0(sp)
811431f4:	dec00204 	addi	sp,sp,8
811431f8:	f800283a 	ret

811431fc <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
811431fc:	deffec04 	addi	sp,sp,-80
81143200:	de00012e 	bgeu	sp,et,81143208 <altera_avalon_uart_read+0xc>
81143204:	003b68fa 	trap	3
81143208:	dfc01315 	stw	ra,76(sp)
8114320c:	df001215 	stw	fp,72(sp)
81143210:	df001204 	addi	fp,sp,72
81143214:	e13ffc15 	stw	r4,-16(fp)
81143218:	e17ffd15 	stw	r5,-12(fp)
8114321c:	e1bffe15 	stw	r6,-8(fp)
81143220:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81143224:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81143228:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
8114322c:	e0bfff17 	ldw	r2,-4(fp)
81143230:	1090000c 	andi	r2,r2,16384
81143234:	1005003a 	cmpeq	r2,r2,zero
81143238:	10803fcc 	andi	r2,r2,255
8114323c:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81143240:	e0bffc17 	ldw	r2,-16(fp)
81143244:	10800817 	ldw	r2,32(r2)
81143248:	e0bff815 	stw	r2,-32(fp)
8114324c:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81143250:	e0bff90b 	ldhu	r2,-28(fp)
81143254:	e0fffb44 	addi	r3,fp,-19
81143258:	180d883a 	mov	r6,r3
8114325c:	100b883a 	mov	r5,r2
81143260:	e13ff817 	ldw	r4,-32(fp)
81143264:	113a1f80 	call	8113a1f8 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81143268:	00001306 	br	811432b8 <altera_avalon_uart_read+0xbc>
    {
      count++;
8114326c:	e0bff017 	ldw	r2,-64(fp)
81143270:	10800044 	addi	r2,r2,1
81143274:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81143278:	e0bffd17 	ldw	r2,-12(fp)
8114327c:	10c00044 	addi	r3,r2,1
81143280:	e0fffd15 	stw	r3,-12(fp)
81143284:	e0fffc17 	ldw	r3,-16(fp)
81143288:	18c00217 	ldw	r3,8(r3)
8114328c:	e13ffc17 	ldw	r4,-16(fp)
81143290:	20c7883a 	add	r3,r4,r3
81143294:	18c00a04 	addi	r3,r3,40
81143298:	18c00003 	ldbu	r3,0(r3)
8114329c:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
811432a0:	e0bffc17 	ldw	r2,-16(fp)
811432a4:	10800217 	ldw	r2,8(r2)
811432a8:	10800044 	addi	r2,r2,1
811432ac:	10c00fcc 	andi	r3,r2,63
811432b0:	e0bffc17 	ldw	r2,-16(fp)
811432b4:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
811432b8:	e0fff017 	ldw	r3,-64(fp)
811432bc:	e0bffe17 	ldw	r2,-8(fp)
811432c0:	1880050e 	bge	r3,r2,811432d8 <altera_avalon_uart_read+0xdc>
811432c4:	e0bffc17 	ldw	r2,-16(fp)
811432c8:	10c00217 	ldw	r3,8(r2)
811432cc:	e0bffc17 	ldw	r2,-16(fp)
811432d0:	10800317 	ldw	r2,12(r2)
811432d4:	18bfe51e 	bne	r3,r2,8114326c <__reset+0xfb12326c>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
811432d8:	e0bff017 	ldw	r2,-64(fp)
811432dc:	10003a1e 	bne	r2,zero,811433c8 <altera_avalon_uart_read+0x1cc>
811432e0:	e0bffc17 	ldw	r2,-16(fp)
811432e4:	10c00217 	ldw	r3,8(r2)
811432e8:	e0bffc17 	ldw	r2,-16(fp)
811432ec:	10800317 	ldw	r2,12(r2)
811432f0:	1880351e 	bne	r3,r2,811433c8 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
811432f4:	e0bff117 	ldw	r2,-60(fp)
811432f8:	1000071e 	bne	r2,zero,81143318 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
811432fc:	11431b80 	call	811431b8 <alt_get_errno>
81143300:	1007883a 	mov	r3,r2
81143304:	008002c4 	movi	r2,11
81143308:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
8114330c:	00800044 	movi	r2,1
81143310:	e0bfef05 	stb	r2,-68(fp)
        break;
81143314:	00003006 	br	811433d8 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143318:	0005303a 	rdctl	r2,status
8114331c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143320:	e0fff517 	ldw	r3,-44(fp)
81143324:	00bfff84 	movi	r2,-2
81143328:	1884703a 	and	r2,r3,r2
8114332c:	1001703a 	wrctl	status,r2
  
  return context;
81143330:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81143334:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81143338:	e0bffc17 	ldw	r2,-16(fp)
8114333c:	10800117 	ldw	r2,4(r2)
81143340:	10c02014 	ori	r3,r2,128
81143344:	e0bffc17 	ldw	r2,-16(fp)
81143348:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114334c:	e0bffc17 	ldw	r2,-16(fp)
81143350:	10800017 	ldw	r2,0(r2)
81143354:	10800304 	addi	r2,r2,12
81143358:	e0fffc17 	ldw	r3,-16(fp)
8114335c:	18c00117 	ldw	r3,4(r3)
81143360:	10c00035 	stwio	r3,0(r2)
81143364:	e0bff417 	ldw	r2,-48(fp)
81143368:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114336c:	e0bff617 	ldw	r2,-40(fp)
81143370:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81143374:	e0bffc17 	ldw	r2,-16(fp)
81143378:	10800717 	ldw	r2,28(r2)
8114337c:	e0bff215 	stw	r2,-56(fp)
81143380:	00800044 	movi	r2,1
81143384:	e0bff98d 	sth	r2,-26(fp)
81143388:	00bfe0c4 	movi	r2,-125
8114338c:	e0bffa05 	stb	r2,-24(fp)
81143390:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81143394:	d0a08c03 	ldbu	r2,-32208(gp)
81143398:	10803fcc 	andi	r2,r2,255
8114339c:	10000a26 	beq	r2,zero,811433c8 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811433a0:	e0fff98b 	ldhu	r3,-26(fp)
811433a4:	e13ffa03 	ldbu	r4,-24(fp)
811433a8:	e17ffa8b 	ldhu	r5,-22(fp)
811433ac:	e0bffb04 	addi	r2,fp,-20
811433b0:	d8800015 	stw	r2,0(sp)
811433b4:	280f883a 	mov	r7,r5
811433b8:	200d883a 	mov	r6,r4
811433bc:	180b883a 	mov	r5,r3
811433c0:	e13ff217 	ldw	r4,-56(fp)
811433c4:	11365580 	call	81136558 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
811433c8:	e0bff017 	ldw	r2,-64(fp)
811433cc:	1000021e 	bne	r2,zero,811433d8 <altera_avalon_uart_read+0x1dc>
811433d0:	e0bffe17 	ldw	r2,-8(fp)
811433d4:	103fb81e 	bne	r2,zero,811432b8 <__reset+0xfb1232b8>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
811433d8:	e0bffc17 	ldw	r2,-16(fp)
811433dc:	10800817 	ldw	r2,32(r2)
811433e0:	1009883a 	mov	r4,r2
811433e4:	113a5800 	call	8113a580 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811433e8:	0005303a 	rdctl	r2,status
811433ec:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811433f0:	e0fff717 	ldw	r3,-36(fp)
811433f4:	00bfff84 	movi	r2,-2
811433f8:	1884703a 	and	r2,r3,r2
811433fc:	1001703a 	wrctl	status,r2
  
  return context;
81143400:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81143404:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81143408:	e0bffc17 	ldw	r2,-16(fp)
8114340c:	10800117 	ldw	r2,4(r2)
81143410:	10c02014 	ori	r3,r2,128
81143414:	e0bffc17 	ldw	r2,-16(fp)
81143418:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114341c:	e0bffc17 	ldw	r2,-16(fp)
81143420:	10800017 	ldw	r2,0(r2)
81143424:	10800304 	addi	r2,r2,12
81143428:	e0fffc17 	ldw	r3,-16(fp)
8114342c:	18c00117 	ldw	r3,4(r3)
81143430:	10c00035 	stwio	r3,0(r2)
81143434:	e0bff417 	ldw	r2,-48(fp)
81143438:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114343c:	e0bff317 	ldw	r2,-52(fp)
81143440:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81143444:	e0bfef03 	ldbu	r2,-68(fp)
81143448:	10000226 	beq	r2,zero,81143454 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
8114344c:	00bffd44 	movi	r2,-11
81143450:	00000106 	br	81143458 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81143454:	e0bff017 	ldw	r2,-64(fp)
  }
}
81143458:	e037883a 	mov	sp,fp
8114345c:	dfc00117 	ldw	ra,4(sp)
81143460:	df000017 	ldw	fp,0(sp)
81143464:	dec00204 	addi	sp,sp,8
81143468:	f800283a 	ret

8114346c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114346c:	defffe04 	addi	sp,sp,-8
81143470:	de00012e 	bgeu	sp,et,81143478 <alt_get_errno+0xc>
81143474:	003b68fa 	trap	3
81143478:	dfc00115 	stw	ra,4(sp)
8114347c:	df000015 	stw	fp,0(sp)
81143480:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81143484:	d0a01017 	ldw	r2,-32704(gp)
81143488:	10000326 	beq	r2,zero,81143498 <alt_get_errno+0x2c>
8114348c:	d0a01017 	ldw	r2,-32704(gp)
81143490:	103ee83a 	callr	r2
81143494:	00000106 	br	8114349c <alt_get_errno+0x30>
81143498:	d0a07304 	addi	r2,gp,-32308
}
8114349c:	e037883a 	mov	sp,fp
811434a0:	dfc00117 	ldw	ra,4(sp)
811434a4:	df000017 	ldw	fp,0(sp)
811434a8:	dec00204 	addi	sp,sp,8
811434ac:	f800283a 	ret

811434b0 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
811434b0:	deffec04 	addi	sp,sp,-80
811434b4:	de00012e 	bgeu	sp,et,811434bc <altera_avalon_uart_write+0xc>
811434b8:	003b68fa 	trap	3
811434bc:	dfc01315 	stw	ra,76(sp)
811434c0:	df001215 	stw	fp,72(sp)
811434c4:	df001204 	addi	fp,sp,72
811434c8:	e13ffc15 	stw	r4,-16(fp)
811434cc:	e17ffd15 	stw	r5,-12(fp)
811434d0:	e1bffe15 	stw	r6,-8(fp)
811434d4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
811434d8:	e0bffe17 	ldw	r2,-8(fp)
811434dc:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
811434e0:	e0bfff17 	ldw	r2,-4(fp)
811434e4:	1090000c 	andi	r2,r2,16384
811434e8:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
811434ec:	e0bffc17 	ldw	r2,-16(fp)
811434f0:	10800917 	ldw	r2,36(r2)
811434f4:	e0bff815 	stw	r2,-32(fp)
811434f8:	e03ff90d 	sth	zero,-28(fp)
811434fc:	e0bff90b 	ldhu	r2,-28(fp)
81143500:	e0fffb44 	addi	r3,fp,-19
81143504:	180d883a 	mov	r6,r3
81143508:	100b883a 	mov	r5,r2
8114350c:	e13ff817 	ldw	r4,-32(fp)
81143510:	113a1f80 	call	8113a1f8 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81143514:	00005106 	br	8114365c <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81143518:	e0bffc17 	ldw	r2,-16(fp)
8114351c:	10800517 	ldw	r2,20(r2)
81143520:	10800044 	addi	r2,r2,1
81143524:	10800fcc 	andi	r2,r2,63
81143528:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
8114352c:	e0bffc17 	ldw	r2,-16(fp)
81143530:	10c00417 	ldw	r3,16(r2)
81143534:	e0bff217 	ldw	r2,-56(fp)
81143538:	1880371e 	bne	r3,r2,81143618 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
8114353c:	e0bff017 	ldw	r2,-64(fp)
81143540:	10000526 	beq	r2,zero,81143558 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81143544:	114346c0 	call	8114346c <alt_get_errno>
81143548:	1007883a 	mov	r3,r2
8114354c:	008002c4 	movi	r2,11
81143550:	18800015 	stw	r2,0(r3)
        break;
81143554:	00004306 	br	81143664 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143558:	0005303a 	rdctl	r2,status
8114355c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143560:	e0fff517 	ldw	r3,-44(fp)
81143564:	00bfff84 	movi	r2,-2
81143568:	1884703a 	and	r2,r3,r2
8114356c:	1001703a 	wrctl	status,r2
  
  return context;
81143570:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81143574:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81143578:	e0bffc17 	ldw	r2,-16(fp)
8114357c:	10800117 	ldw	r2,4(r2)
81143580:	10c11014 	ori	r3,r2,1088
81143584:	e0bffc17 	ldw	r2,-16(fp)
81143588:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114358c:	e0bffc17 	ldw	r2,-16(fp)
81143590:	10800017 	ldw	r2,0(r2)
81143594:	10800304 	addi	r2,r2,12
81143598:	e0fffc17 	ldw	r3,-16(fp)
8114359c:	18c00117 	ldw	r3,4(r3)
811435a0:	10c00035 	stwio	r3,0(r2)
811435a4:	e0bff417 	ldw	r2,-48(fp)
811435a8:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811435ac:	e0bff117 	ldw	r2,-60(fp)
811435b0:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
811435b4:	e0bffc17 	ldw	r2,-16(fp)
811435b8:	10800717 	ldw	r2,28(r2)
811435bc:	e0bff315 	stw	r2,-52(fp)
811435c0:	00800084 	movi	r2,2
811435c4:	e0bff98d 	sth	r2,-26(fp)
811435c8:	00bfe0c4 	movi	r2,-125
811435cc:	e0bffa05 	stb	r2,-24(fp)
811435d0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
811435d4:	d0a08c03 	ldbu	r2,-32208(gp)
811435d8:	10803fcc 	andi	r2,r2,255
811435dc:	10000a26 	beq	r2,zero,81143608 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811435e0:	e0fff98b 	ldhu	r3,-26(fp)
811435e4:	e13ffa03 	ldbu	r4,-24(fp)
811435e8:	e17ffa8b 	ldhu	r5,-22(fp)
811435ec:	e0bffb04 	addi	r2,fp,-20
811435f0:	d8800015 	stw	r2,0(sp)
811435f4:	280f883a 	mov	r7,r5
811435f8:	200d883a 	mov	r6,r4
811435fc:	180b883a 	mov	r5,r3
81143600:	e13ff317 	ldw	r4,-52(fp)
81143604:	11365580 	call	81136558 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81143608:	e0bffc17 	ldw	r2,-16(fp)
8114360c:	10c00417 	ldw	r3,16(r2)
81143610:	e0bff217 	ldw	r2,-56(fp)
81143614:	18bfe726 	beq	r3,r2,811435b4 <__reset+0xfb1235b4>
      }
    }

    count--;
81143618:	e0bfef17 	ldw	r2,-68(fp)
8114361c:	10bfffc4 	addi	r2,r2,-1
81143620:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81143624:	e0bffc17 	ldw	r2,-16(fp)
81143628:	10c00517 	ldw	r3,20(r2)
8114362c:	e0bffd17 	ldw	r2,-12(fp)
81143630:	11000044 	addi	r4,r2,1
81143634:	e13ffd15 	stw	r4,-12(fp)
81143638:	10800003 	ldbu	r2,0(r2)
8114363c:	1009883a 	mov	r4,r2
81143640:	e0bffc17 	ldw	r2,-16(fp)
81143644:	10c5883a 	add	r2,r2,r3
81143648:	10801a04 	addi	r2,r2,104
8114364c:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81143650:	e0bffc17 	ldw	r2,-16(fp)
81143654:	e0fff217 	ldw	r3,-56(fp)
81143658:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
8114365c:	e0bfef17 	ldw	r2,-68(fp)
81143660:	103fad1e 	bne	r2,zero,81143518 <__reset+0xfb123518>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81143664:	e0bffc17 	ldw	r2,-16(fp)
81143668:	10800917 	ldw	r2,36(r2)
8114366c:	1009883a 	mov	r4,r2
81143670:	113a5800 	call	8113a580 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143674:	0005303a 	rdctl	r2,status
81143678:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114367c:	e0fff717 	ldw	r3,-36(fp)
81143680:	00bfff84 	movi	r2,-2
81143684:	1884703a 	and	r2,r3,r2
81143688:	1001703a 	wrctl	status,r2
  
  return context;
8114368c:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81143690:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81143694:	e0bffc17 	ldw	r2,-16(fp)
81143698:	10800117 	ldw	r2,4(r2)
8114369c:	10c11014 	ori	r3,r2,1088
811436a0:	e0bffc17 	ldw	r2,-16(fp)
811436a4:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811436a8:	e0bffc17 	ldw	r2,-16(fp)
811436ac:	10800017 	ldw	r2,0(r2)
811436b0:	10800304 	addi	r2,r2,12
811436b4:	e0fffc17 	ldw	r3,-16(fp)
811436b8:	18c00117 	ldw	r3,4(r3)
811436bc:	10c00035 	stwio	r3,0(r2)
811436c0:	e0bff417 	ldw	r2,-48(fp)
811436c4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811436c8:	e0bff617 	ldw	r2,-40(fp)
811436cc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
811436d0:	e0fffe17 	ldw	r3,-8(fp)
811436d4:	e0bfef17 	ldw	r2,-68(fp)
811436d8:	1885c83a 	sub	r2,r3,r2
}
811436dc:	e037883a 	mov	sp,fp
811436e0:	dfc00117 	ldw	ra,4(sp)
811436e4:	df000017 	ldw	fp,0(sp)
811436e8:	dec00204 	addi	sp,sp,8
811436ec:	f800283a 	ret

811436f0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811436f0:	defffe04 	addi	sp,sp,-8
811436f4:	de00012e 	bgeu	sp,et,811436fc <alt_get_errno+0xc>
811436f8:	003b68fa 	trap	3
811436fc:	dfc00115 	stw	ra,4(sp)
81143700:	df000015 	stw	fp,0(sp)
81143704:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81143708:	d0a01017 	ldw	r2,-32704(gp)
8114370c:	10000326 	beq	r2,zero,8114371c <alt_get_errno+0x2c>
81143710:	d0a01017 	ldw	r2,-32704(gp)
81143714:	103ee83a 	callr	r2
81143718:	00000106 	br	81143720 <alt_get_errno+0x30>
8114371c:	d0a07304 	addi	r2,gp,-32308
}
81143720:	e037883a 	mov	sp,fp
81143724:	dfc00117 	ldw	ra,4(sp)
81143728:	df000017 	ldw	fp,0(sp)
8114372c:	dec00204 	addi	sp,sp,8
81143730:	f800283a 	ret

81143734 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81143734:	defffc04 	addi	sp,sp,-16
81143738:	de00012e 	bgeu	sp,et,81143740 <alt_msgdma_write_standard_descriptor+0xc>
8114373c:	003b68fa 	trap	3
81143740:	df000315 	stw	fp,12(sp)
81143744:	df000304 	addi	fp,sp,12
81143748:	e13ffd15 	stw	r4,-12(fp)
8114374c:	e17ffe15 	stw	r5,-8(fp)
81143750:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81143754:	e0bffd17 	ldw	r2,-12(fp)
81143758:	10800037 	ldwio	r2,0(r2)
8114375c:	1080010c 	andi	r2,r2,4
81143760:	10000226 	beq	r2,zero,8114376c <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81143764:	00bff904 	movi	r2,-28
81143768:	00001506 	br	811437c0 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
8114376c:	e0bfff17 	ldw	r2,-4(fp)
81143770:	10800017 	ldw	r2,0(r2)
81143774:	1007883a 	mov	r3,r2
81143778:	e0bffe17 	ldw	r2,-8(fp)
8114377c:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81143780:	e0bffe17 	ldw	r2,-8(fp)
81143784:	10800104 	addi	r2,r2,4
81143788:	e0ffff17 	ldw	r3,-4(fp)
8114378c:	18c00117 	ldw	r3,4(r3)
81143790:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81143794:	e0bffe17 	ldw	r2,-8(fp)
81143798:	10800204 	addi	r2,r2,8
8114379c:	e0ffff17 	ldw	r3,-4(fp)
811437a0:	18c00217 	ldw	r3,8(r3)
811437a4:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
811437a8:	e0bffe17 	ldw	r2,-8(fp)
811437ac:	10800304 	addi	r2,r2,12
811437b0:	e0ffff17 	ldw	r3,-4(fp)
811437b4:	18c00317 	ldw	r3,12(r3)
811437b8:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
811437bc:	0005883a 	mov	r2,zero
}
811437c0:	e037883a 	mov	sp,fp
811437c4:	df000017 	ldw	fp,0(sp)
811437c8:	dec00104 	addi	sp,sp,4
811437cc:	f800283a 	ret

811437d0 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
811437d0:	defffc04 	addi	sp,sp,-16
811437d4:	de00012e 	bgeu	sp,et,811437dc <alt_msgdma_write_extended_descriptor+0xc>
811437d8:	003b68fa 	trap	3
811437dc:	df000315 	stw	fp,12(sp)
811437e0:	df000304 	addi	fp,sp,12
811437e4:	e13ffd15 	stw	r4,-12(fp)
811437e8:	e17ffe15 	stw	r5,-8(fp)
811437ec:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
811437f0:	e0bffd17 	ldw	r2,-12(fp)
811437f4:	10800037 	ldwio	r2,0(r2)
811437f8:	1080010c 	andi	r2,r2,4
811437fc:	10000226 	beq	r2,zero,81143808 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81143800:	00bff904 	movi	r2,-28
81143804:	00003b06 	br	811438f4 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81143808:	e0bfff17 	ldw	r2,-4(fp)
8114380c:	10800017 	ldw	r2,0(r2)
81143810:	1007883a 	mov	r3,r2
81143814:	e0bffe17 	ldw	r2,-8(fp)
81143818:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
8114381c:	e0bffe17 	ldw	r2,-8(fp)
81143820:	10800104 	addi	r2,r2,4
81143824:	e0ffff17 	ldw	r3,-4(fp)
81143828:	18c00117 	ldw	r3,4(r3)
8114382c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81143830:	e0bffe17 	ldw	r2,-8(fp)
81143834:	10800204 	addi	r2,r2,8
81143838:	e0ffff17 	ldw	r3,-4(fp)
8114383c:	18c00217 	ldw	r3,8(r3)
81143840:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81143844:	e0bffe17 	ldw	r2,-8(fp)
81143848:	10800304 	addi	r2,r2,12
8114384c:	e0ffff17 	ldw	r3,-4(fp)
81143850:	18c0030b 	ldhu	r3,12(r3)
81143854:	18ffffcc 	andi	r3,r3,65535
81143858:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
8114385c:	e0bffe17 	ldw	r2,-8(fp)
81143860:	10800384 	addi	r2,r2,14
81143864:	e0ffff17 	ldw	r3,-4(fp)
81143868:	18c00383 	ldbu	r3,14(r3)
8114386c:	18c03fcc 	andi	r3,r3,255
81143870:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81143874:	e0bffe17 	ldw	r2,-8(fp)
81143878:	108003c4 	addi	r2,r2,15
8114387c:	e0ffff17 	ldw	r3,-4(fp)
81143880:	18c003c3 	ldbu	r3,15(r3)
81143884:	18c03fcc 	andi	r3,r3,255
81143888:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
8114388c:	e0bffe17 	ldw	r2,-8(fp)
81143890:	10800404 	addi	r2,r2,16
81143894:	e0ffff17 	ldw	r3,-4(fp)
81143898:	18c0040b 	ldhu	r3,16(r3)
8114389c:	18ffffcc 	andi	r3,r3,65535
811438a0:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
811438a4:	e0bffe17 	ldw	r2,-8(fp)
811438a8:	10800484 	addi	r2,r2,18
811438ac:	e0ffff17 	ldw	r3,-4(fp)
811438b0:	18c0048b 	ldhu	r3,18(r3)
811438b4:	18ffffcc 	andi	r3,r3,65535
811438b8:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
811438bc:	e0bffe17 	ldw	r2,-8(fp)
811438c0:	10800504 	addi	r2,r2,20
811438c4:	0007883a 	mov	r3,zero
811438c8:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
811438cc:	e0bffe17 	ldw	r2,-8(fp)
811438d0:	10800604 	addi	r2,r2,24
811438d4:	0007883a 	mov	r3,zero
811438d8:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
811438dc:	e0bffe17 	ldw	r2,-8(fp)
811438e0:	10800704 	addi	r2,r2,28
811438e4:	e0ffff17 	ldw	r3,-4(fp)
811438e8:	18c00717 	ldw	r3,28(r3)
811438ec:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
811438f0:	0005883a 	mov	r2,zero
}
811438f4:	e037883a 	mov	sp,fp
811438f8:	df000017 	ldw	fp,0(sp)
811438fc:	dec00104 	addi	sp,sp,4
81143900:	f800283a 	ret

81143904 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81143904:	defff804 	addi	sp,sp,-32
81143908:	de00012e 	bgeu	sp,et,81143910 <alt_msgdma_irq+0xc>
8114390c:	003b68fa 	trap	3
81143910:	dfc00715 	stw	ra,28(sp)
81143914:	df000615 	stw	fp,24(sp)
81143918:	df000604 	addi	fp,sp,24
8114391c:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81143920:	e0bfff17 	ldw	r2,-4(fp)
81143924:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81143928:	e0bffa17 	ldw	r2,-24(fp)
8114392c:	10801783 	ldbu	r2,94(r2)
81143930:	10803fcc 	andi	r2,r2,255
81143934:	10001126 	beq	r2,zero,8114397c <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81143938:	e0bffa17 	ldw	r2,-24(fp)
8114393c:	10800617 	ldw	r2,24(r2)
81143940:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81143944:	1007883a 	mov	r3,r2
81143948:	00bffdc4 	movi	r2,-9
8114394c:	1884703a 	and	r2,r3,r2
81143950:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81143954:	e0bffa17 	ldw	r2,-24(fp)
81143958:	10800617 	ldw	r2,24(r2)
8114395c:	e0fffb17 	ldw	r3,-20(fp)
81143960:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81143964:	e0bffa17 	ldw	r2,-24(fp)
81143968:	10800617 	ldw	r2,24(r2)
8114396c:	10800404 	addi	r2,r2,16
81143970:	00c00044 	movi	r3,1
81143974:	10c00035 	stwio	r3,0(r2)
81143978:	00001106 	br	811439c0 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114397c:	e0bffa17 	ldw	r2,-24(fp)
81143980:	10800317 	ldw	r2,12(r2)
81143984:	10800104 	addi	r2,r2,4
81143988:	10800037 	ldwio	r2,0(r2)
8114398c:	1007883a 	mov	r3,r2
81143990:	00bffbc4 	movi	r2,-17
81143994:	1884703a 	and	r2,r3,r2
81143998:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114399c:	e0bffa17 	ldw	r2,-24(fp)
811439a0:	10800317 	ldw	r2,12(r2)
811439a4:	10800104 	addi	r2,r2,4
811439a8:	e0fffb17 	ldw	r3,-20(fp)
811439ac:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811439b0:	e0bffa17 	ldw	r2,-24(fp)
811439b4:	10800317 	ldw	r2,12(r2)
811439b8:	00c08004 	movi	r3,512
811439bc:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
811439c0:	e0bffa17 	ldw	r2,-24(fp)
811439c4:	10800b17 	ldw	r2,44(r2)
811439c8:	10001226 	beq	r2,zero,81143a14 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811439cc:	0005303a 	rdctl	r2,status
811439d0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811439d4:	e0fffd17 	ldw	r3,-12(fp)
811439d8:	00bfff84 	movi	r2,-2
811439dc:	1884703a 	and	r2,r3,r2
811439e0:	1001703a 	wrctl	status,r2
  
  return context;
811439e4:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
811439e8:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
811439ec:	e0bffa17 	ldw	r2,-24(fp)
811439f0:	10800b17 	ldw	r2,44(r2)
811439f4:	e0fffa17 	ldw	r3,-24(fp)
811439f8:	18c00c17 	ldw	r3,48(r3)
811439fc:	1809883a 	mov	r4,r3
81143a00:	103ee83a 	callr	r2
81143a04:	e0bffc17 	ldw	r2,-16(fp)
81143a08:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143a0c:	e0bffe17 	ldw	r2,-8(fp)
81143a10:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81143a14:	e0bffa17 	ldw	r2,-24(fp)
81143a18:	10801783 	ldbu	r2,94(r2)
81143a1c:	10803fcc 	andi	r2,r2,255
81143a20:	10000a26 	beq	r2,zero,81143a4c <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81143a24:	e0bffa17 	ldw	r2,-24(fp)
81143a28:	10800617 	ldw	r2,24(r2)
81143a2c:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81143a30:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81143a34:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81143a38:	e0bffa17 	ldw	r2,-24(fp)
81143a3c:	10800617 	ldw	r2,24(r2)
81143a40:	e0fffb17 	ldw	r3,-20(fp)
81143a44:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81143a48:	00000c06 	br	81143a7c <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81143a4c:	e0bffa17 	ldw	r2,-24(fp)
81143a50:	10800317 	ldw	r2,12(r2)
81143a54:	10800104 	addi	r2,r2,4
81143a58:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81143a5c:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81143a60:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81143a64:	e0bffa17 	ldw	r2,-24(fp)
81143a68:	10800317 	ldw	r2,12(r2)
81143a6c:	10800104 	addi	r2,r2,4
81143a70:	e0fffb17 	ldw	r3,-20(fp)
81143a74:	10c00035 	stwio	r3,0(r2)
    }

    return;
81143a78:	0001883a 	nop
}
81143a7c:	e037883a 	mov	sp,fp
81143a80:	dfc00117 	ldw	ra,4(sp)
81143a84:	df000017 	ldw	fp,0(sp)
81143a88:	dec00204 	addi	sp,sp,8
81143a8c:	f800283a 	ret

81143a90 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143a90:	defffb04 	addi	sp,sp,-20
81143a94:	de00012e 	bgeu	sp,et,81143a9c <alt_msgdma_construct_standard_descriptor+0xc>
81143a98:	003b68fa 	trap	3
81143a9c:	df000415 	stw	fp,16(sp)
81143aa0:	df000404 	addi	fp,sp,16
81143aa4:	e13ffc15 	stw	r4,-16(fp)
81143aa8:	e17ffd15 	stw	r5,-12(fp)
81143aac:	e1bffe15 	stw	r6,-8(fp)
81143ab0:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81143ab4:	e0bffc17 	ldw	r2,-16(fp)
81143ab8:	10c01217 	ldw	r3,72(r2)
81143abc:	e0800117 	ldw	r2,4(fp)
81143ac0:	18800436 	bltu	r3,r2,81143ad4 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81143ac4:	e0bffc17 	ldw	r2,-16(fp)
81143ac8:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81143acc:	10803fcc 	andi	r2,r2,255
81143ad0:	10000226 	beq	r2,zero,81143adc <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81143ad4:	00bffa84 	movi	r2,-22
81143ad8:	00000e06 	br	81143b14 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
81143adc:	e0bffd17 	ldw	r2,-12(fp)
81143ae0:	e0fffe17 	ldw	r3,-8(fp)
81143ae4:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81143ae8:	e0bffd17 	ldw	r2,-12(fp)
81143aec:	e0ffff17 	ldw	r3,-4(fp)
81143af0:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81143af4:	e0bffd17 	ldw	r2,-12(fp)
81143af8:	e0c00117 	ldw	r3,4(fp)
81143afc:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81143b00:	e0800217 	ldw	r2,8(fp)
81143b04:	10e00034 	orhi	r3,r2,32768
81143b08:	e0bffd17 	ldw	r2,-12(fp)
81143b0c:	10c00315 	stw	r3,12(r2)
    
    return 0;
81143b10:	0005883a 	mov	r2,zero
}
81143b14:	e037883a 	mov	sp,fp
81143b18:	df000017 	ldw	fp,0(sp)
81143b1c:	dec00104 	addi	sp,sp,4
81143b20:	f800283a 	ret

81143b24 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81143b24:	defff604 	addi	sp,sp,-40
81143b28:	de00012e 	bgeu	sp,et,81143b30 <alt_msgdma_construct_extended_descriptor+0xc>
81143b2c:	003b68fa 	trap	3
81143b30:	df000915 	stw	fp,36(sp)
81143b34:	df000904 	addi	fp,sp,36
81143b38:	e13ff715 	stw	r4,-36(fp)
81143b3c:	e17ff815 	stw	r5,-32(fp)
81143b40:	e1bff915 	stw	r6,-28(fp)
81143b44:	e1fffa15 	stw	r7,-24(fp)
81143b48:	e1800317 	ldw	r6,12(fp)
81143b4c:	e1400417 	ldw	r5,16(fp)
81143b50:	e1000517 	ldw	r4,20(fp)
81143b54:	e0c00617 	ldw	r3,24(fp)
81143b58:	e0800717 	ldw	r2,28(fp)
81143b5c:	e1bffb0d 	sth	r6,-20(fp)
81143b60:	e17ffc05 	stb	r5,-16(fp)
81143b64:	e13ffd05 	stb	r4,-12(fp)
81143b68:	e0fffe0d 	sth	r3,-8(fp)
81143b6c:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81143b70:	e0bff717 	ldw	r2,-36(fp)
81143b74:	10c01217 	ldw	r3,72(r2)
81143b78:	e0800117 	ldw	r2,4(fp)
81143b7c:	18801936 	bltu	r3,r2,81143be4 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81143b80:	e13ff717 	ldw	r4,-36(fp)
81143b84:	20801317 	ldw	r2,76(r4)
81143b88:	20c01417 	ldw	r3,80(r4)
81143b8c:	e13ffe0b 	ldhu	r4,-8(fp)
81143b90:	213fffcc 	andi	r4,r4,65535
81143b94:	2015883a 	mov	r10,r4
81143b98:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81143b9c:	1ac01136 	bltu	r3,r11,81143be4 <alt_msgdma_construct_extended_descriptor+0xc0>
81143ba0:	58c0011e 	bne	r11,r3,81143ba8 <alt_msgdma_construct_extended_descriptor+0x84>
81143ba4:	12800f36 	bltu	r2,r10,81143be4 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81143ba8:	e13ff717 	ldw	r4,-36(fp)
81143bac:	20801317 	ldw	r2,76(r4)
81143bb0:	20c01417 	ldw	r3,80(r4)
81143bb4:	e13fff0b 	ldhu	r4,-4(fp)
81143bb8:	213fffcc 	andi	r4,r4,65535
81143bbc:	2011883a 	mov	r8,r4
81143bc0:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81143bc4:	1a400736 	bltu	r3,r9,81143be4 <alt_msgdma_construct_extended_descriptor+0xc0>
81143bc8:	48c0011e 	bne	r9,r3,81143bd0 <alt_msgdma_construct_extended_descriptor+0xac>
81143bcc:	12000536 	bltu	r2,r8,81143be4 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81143bd0:	e0bff717 	ldw	r2,-36(fp)
81143bd4:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81143bd8:	10803fcc 	andi	r2,r2,255
81143bdc:	10800060 	cmpeqi	r2,r2,1
81143be0:	1000021e 	bne	r2,zero,81143bec <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81143be4:	00bffa84 	movi	r2,-22
81143be8:	00002106 	br	81143c70 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
81143bec:	e0bff817 	ldw	r2,-32(fp)
81143bf0:	e0fff917 	ldw	r3,-28(fp)
81143bf4:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
81143bf8:	e0bff817 	ldw	r2,-32(fp)
81143bfc:	e0fffa17 	ldw	r3,-24(fp)
81143c00:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81143c04:	e0bff817 	ldw	r2,-32(fp)
81143c08:	e0c00117 	ldw	r3,4(fp)
81143c0c:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81143c10:	e0bff817 	ldw	r2,-32(fp)
81143c14:	e0fffb0b 	ldhu	r3,-20(fp)
81143c18:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
81143c1c:	e0bff817 	ldw	r2,-32(fp)
81143c20:	e0fffc03 	ldbu	r3,-16(fp)
81143c24:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81143c28:	e0bff817 	ldw	r2,-32(fp)
81143c2c:	e0fffd03 	ldbu	r3,-12(fp)
81143c30:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81143c34:	e0bff817 	ldw	r2,-32(fp)
81143c38:	e0fffe0b 	ldhu	r3,-8(fp)
81143c3c:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
81143c40:	e0bff817 	ldw	r2,-32(fp)
81143c44:	e0ffff0b 	ldhu	r3,-4(fp)
81143c48:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81143c4c:	e0bff817 	ldw	r2,-32(fp)
81143c50:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81143c54:	e0bff817 	ldw	r2,-32(fp)
81143c58:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81143c5c:	e0800217 	ldw	r2,8(fp)
81143c60:	10e00034 	orhi	r3,r2,32768
81143c64:	e0bff817 	ldw	r2,-32(fp)
81143c68:	10c00715 	stw	r3,28(r2)

  return 0 ;
81143c6c:	0005883a 	mov	r2,zero

}
81143c70:	e037883a 	mov	sp,fp
81143c74:	df000017 	ldw	fp,0(sp)
81143c78:	dec00104 	addi	sp,sp,4
81143c7c:	f800283a 	ret

81143c80 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81143c80:	deffee04 	addi	sp,sp,-72
81143c84:	de00012e 	bgeu	sp,et,81143c8c <alt_msgdma_descriptor_async_transfer+0xc>
81143c88:	003b68fa 	trap	3
81143c8c:	dfc01115 	stw	ra,68(sp)
81143c90:	df001015 	stw	fp,64(sp)
81143c94:	df001004 	addi	fp,sp,64
81143c98:	e13ffd15 	stw	r4,-12(fp)
81143c9c:	e17ffe15 	stw	r5,-8(fp)
81143ca0:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81143ca4:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
81143ca8:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
81143cac:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81143cb0:	e0bffd17 	ldw	r2,-12(fp)
81143cb4:	10800317 	ldw	r2,12(r2)
81143cb8:	10800204 	addi	r2,r2,8
81143cbc:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81143cc0:	10bfffcc 	andi	r2,r2,65535
81143cc4:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81143cc8:	e0bffd17 	ldw	r2,-12(fp)
81143ccc:	10800317 	ldw	r2,12(r2)
81143cd0:	10800204 	addi	r2,r2,8
81143cd4:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81143cd8:	1004d43a 	srli	r2,r2,16
81143cdc:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81143ce0:	e0bffd17 	ldw	r2,-12(fp)
81143ce4:	10800917 	ldw	r2,36(r2)
81143ce8:	e0fff417 	ldw	r3,-48(fp)
81143cec:	1880042e 	bgeu	r3,r2,81143d00 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81143cf0:	e0bffd17 	ldw	r2,-12(fp)
81143cf4:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81143cf8:	e0fff317 	ldw	r3,-52(fp)
81143cfc:	18800236 	bltu	r3,r2,81143d08 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
81143d00:	00bff904 	movi	r2,-28
81143d04:	0000a906 	br	81143fac <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81143d08:	e0bffd17 	ldw	r2,-12(fp)
81143d0c:	10801817 	ldw	r2,96(r2)
81143d10:	e0bff615 	stw	r2,-40(fp)
81143d14:	e03ffc0d 	sth	zero,-16(fp)
81143d18:	e0bffc0b 	ldhu	r2,-16(fp)
81143d1c:	e0fffc84 	addi	r3,fp,-14
81143d20:	180d883a 	mov	r6,r3
81143d24:	100b883a 	mov	r5,r2
81143d28:	e13ff617 	ldw	r4,-40(fp)
81143d2c:	113a1f80 	call	8113a1f8 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81143d30:	00800804 	movi	r2,32
81143d34:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143d38:	0005303a 	rdctl	r2,status
81143d3c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143d40:	e0fff717 	ldw	r3,-36(fp)
81143d44:	00bfff84 	movi	r2,-2
81143d48:	1884703a 	and	r2,r3,r2
81143d4c:	1001703a 	wrctl	status,r2
  
  return context;
81143d50:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81143d54:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81143d58:	e0bffd17 	ldw	r2,-12(fp)
81143d5c:	10800317 	ldw	r2,12(r2)
81143d60:	10800104 	addi	r2,r2,4
81143d64:	e0fff117 	ldw	r3,-60(fp)
81143d68:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81143d6c:	e0bffd17 	ldw	r2,-12(fp)
81143d70:	10800317 	ldw	r2,12(r2)
81143d74:	e0fffd17 	ldw	r3,-12(fp)
81143d78:	18c00317 	ldw	r3,12(r3)
81143d7c:	18c00037 	ldwio	r3,0(r3)
81143d80:	10c00035 	stwio	r3,0(r2)
81143d84:	e0bff217 	ldw	r2,-56(fp)
81143d88:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143d8c:	e0bffb17 	ldw	r2,-20(fp)
81143d90:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81143d94:	e0bffe17 	ldw	r2,-8(fp)
81143d98:	10001e26 	beq	r2,zero,81143e14 <alt_msgdma_descriptor_async_transfer+0x194>
81143d9c:	e0bfff17 	ldw	r2,-4(fp)
81143da0:	10001c1e 	bne	r2,zero,81143e14 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81143da4:	00001106 	br	81143dec <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81143da8:	01000044 	movi	r4,1
81143dac:	11319800 	call	81131980 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81143db0:	e0bff00b 	ldhu	r2,-64(fp)
81143db4:	1084e230 	cmpltui	r2,r2,5000
81143db8:	1000091e 	bne	r2,zero,81143de0 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
81143dbc:	01204574 	movhi	r4,33045
81143dc0:	212fdb04 	addi	r4,r4,-16532
81143dc4:	11460d40 	call	811460d4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81143dc8:	e0bffd17 	ldw	r2,-12(fp)
81143dcc:	10801817 	ldw	r2,96(r2)
81143dd0:	1009883a 	mov	r4,r2
81143dd4:	113a5800 	call	8113a580 <OSSemPost>
				
                return -ETIME;
81143dd8:	00bff084 	movi	r2,-62
81143ddc:	00007306 	br	81143fac <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81143de0:	e0bff00b 	ldhu	r2,-64(fp)
81143de4:	10800044 	addi	r2,r2,1
81143de8:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81143dec:	e0bffd17 	ldw	r2,-12(fp)
81143df0:	10c00317 	ldw	r3,12(r2)
81143df4:	e0bffd17 	ldw	r2,-12(fp)
81143df8:	10800417 	ldw	r2,16(r2)
81143dfc:	e1bffe17 	ldw	r6,-8(fp)
81143e00:	100b883a 	mov	r5,r2
81143e04:	1809883a 	mov	r4,r3
81143e08:	11437340 	call	81143734 <alt_msgdma_write_standard_descriptor>
81143e0c:	103fe61e 	bne	r2,zero,81143da8 <__reset+0xfb123da8>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81143e10:	00002706 	br	81143eb0 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81143e14:	e0bffe17 	ldw	r2,-8(fp)
81143e18:	10001f1e 	bne	r2,zero,81143e98 <alt_msgdma_descriptor_async_transfer+0x218>
81143e1c:	e0bfff17 	ldw	r2,-4(fp)
81143e20:	10001d26 	beq	r2,zero,81143e98 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
81143e24:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81143e28:	00001106 	br	81143e70 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81143e2c:	01000044 	movi	r4,1
81143e30:	11319800 	call	81131980 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81143e34:	e0bff00b 	ldhu	r2,-64(fp)
81143e38:	1084e230 	cmpltui	r2,r2,5000
81143e3c:	1000091e 	bne	r2,zero,81143e64 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
81143e40:	01204574 	movhi	r4,33045
81143e44:	212ff104 	addi	r4,r4,-16444
81143e48:	11460d40 	call	811460d4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81143e4c:	e0bffd17 	ldw	r2,-12(fp)
81143e50:	10801817 	ldw	r2,96(r2)
81143e54:	1009883a 	mov	r4,r2
81143e58:	113a5800 	call	8113a580 <OSSemPost>
				
                return -ETIME;
81143e5c:	00bff084 	movi	r2,-62
81143e60:	00005206 	br	81143fac <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81143e64:	e0bff00b 	ldhu	r2,-64(fp)
81143e68:	10800044 	addi	r2,r2,1
81143e6c:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81143e70:	e0bffd17 	ldw	r2,-12(fp)
81143e74:	10c00317 	ldw	r3,12(r2)
81143e78:	e0bffd17 	ldw	r2,-12(fp)
81143e7c:	10800417 	ldw	r2,16(r2)
81143e80:	e1bfff17 	ldw	r6,-4(fp)
81143e84:	100b883a 	mov	r5,r2
81143e88:	1809883a 	mov	r4,r3
81143e8c:	11437d00 	call	811437d0 <alt_msgdma_write_extended_descriptor>
81143e90:	103fe61e 	bne	r2,zero,81143e2c <__reset+0xfb123e2c>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81143e94:	00000606 	br	81143eb0 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81143e98:	e0bffd17 	ldw	r2,-12(fp)
81143e9c:	10801817 	ldw	r2,96(r2)
81143ea0:	1009883a 	mov	r4,r2
81143ea4:	113a5800 	call	8113a580 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81143ea8:	00bfffc4 	movi	r2,-1
81143eac:	00003f06 	br	81143fac <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
81143eb0:	e0bffd17 	ldw	r2,-12(fp)
81143eb4:	10800b17 	ldw	r2,44(r2)
81143eb8:	10001c26 	beq	r2,zero,81143f2c <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81143ebc:	e0bffd17 	ldw	r2,-12(fp)
81143ec0:	10c00d17 	ldw	r3,52(r2)
81143ec4:	e0bff117 	ldw	r2,-60(fp)
81143ec8:	1884b03a 	or	r2,r3,r2
81143ecc:	10800514 	ori	r2,r2,20
81143ed0:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81143ed4:	e0fff117 	ldw	r3,-60(fp)
81143ed8:	00bff7c4 	movi	r2,-33
81143edc:	1884703a 	and	r2,r3,r2
81143ee0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143ee4:	0005303a 	rdctl	r2,status
81143ee8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143eec:	e0fff917 	ldw	r3,-28(fp)
81143ef0:	00bfff84 	movi	r2,-2
81143ef4:	1884703a 	and	r2,r3,r2
81143ef8:	1001703a 	wrctl	status,r2
  
  return context;
81143efc:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81143f00:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81143f04:	e0bffd17 	ldw	r2,-12(fp)
81143f08:	10800317 	ldw	r2,12(r2)
81143f0c:	10800104 	addi	r2,r2,4
81143f10:	e0fff117 	ldw	r3,-60(fp)
81143f14:	10c00035 	stwio	r3,0(r2)
81143f18:	e0bff217 	ldw	r2,-56(fp)
81143f1c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143f20:	e0bff517 	ldw	r2,-44(fp)
81143f24:	1001703a 	wrctl	status,r2
81143f28:	00001b06 	br	81143f98 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
81143f2c:	e0bffd17 	ldw	r2,-12(fp)
81143f30:	10c00d17 	ldw	r3,52(r2)
81143f34:	e0bff117 	ldw	r2,-60(fp)
81143f38:	1884b03a 	or	r2,r3,r2
81143f3c:	10800114 	ori	r2,r2,4
81143f40:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81143f44:	e0fff117 	ldw	r3,-60(fp)
81143f48:	00bff3c4 	movi	r2,-49
81143f4c:	1884703a 	and	r2,r3,r2
81143f50:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143f54:	0005303a 	rdctl	r2,status
81143f58:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143f5c:	e0fffa17 	ldw	r3,-24(fp)
81143f60:	00bfff84 	movi	r2,-2
81143f64:	1884703a 	and	r2,r3,r2
81143f68:	1001703a 	wrctl	status,r2
  
  return context;
81143f6c:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81143f70:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81143f74:	e0bffd17 	ldw	r2,-12(fp)
81143f78:	10800317 	ldw	r2,12(r2)
81143f7c:	10800104 	addi	r2,r2,4
81143f80:	e0fff117 	ldw	r3,-60(fp)
81143f84:	10c00035 	stwio	r3,0(r2)
81143f88:	e0bff217 	ldw	r2,-56(fp)
81143f8c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143f90:	e0bff817 	ldw	r2,-32(fp)
81143f94:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81143f98:	e0bffd17 	ldw	r2,-12(fp)
81143f9c:	10801817 	ldw	r2,96(r2)
81143fa0:	1009883a 	mov	r4,r2
81143fa4:	113a5800 	call	8113a580 <OSSemPost>
    
    return 0;
81143fa8:	0005883a 	mov	r2,zero
}
81143fac:	e037883a 	mov	sp,fp
81143fb0:	dfc00117 	ldw	ra,4(sp)
81143fb4:	df000017 	ldw	fp,0(sp)
81143fb8:	dec00204 	addi	sp,sp,8
81143fbc:	f800283a 	ret

81143fc0 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81143fc0:	deffee04 	addi	sp,sp,-72
81143fc4:	de00012e 	bgeu	sp,et,81143fcc <alt_msgdma_descriptor_sync_transfer+0xc>
81143fc8:	003b68fa 	trap	3
81143fcc:	dfc01115 	stw	ra,68(sp)
81143fd0:	df001015 	stw	fp,64(sp)
81143fd4:	df001004 	addi	fp,sp,64
81143fd8:	e13ffd15 	stw	r4,-12(fp)
81143fdc:	e17ffe15 	stw	r5,-8(fp)
81143fe0:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81143fe4:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
81143fe8:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
81143fec:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81143ff0:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81143ff4:	e0bffd17 	ldw	r2,-12(fp)
81143ff8:	10800317 	ldw	r2,12(r2)
81143ffc:	10800204 	addi	r2,r2,8
81144000:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81144004:	10bfffcc 	andi	r2,r2,65535
81144008:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114400c:	e0bffd17 	ldw	r2,-12(fp)
81144010:	10800317 	ldw	r2,12(r2)
81144014:	10800204 	addi	r2,r2,8
81144018:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114401c:	1004d43a 	srli	r2,r2,16
81144020:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
81144024:	00807804 	movi	r2,480
81144028:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114402c:	00001906 	br	81144094 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
81144030:	01000044 	movi	r4,1
81144034:	11319800 	call	81131980 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81144038:	e0bff10b 	ldhu	r2,-60(fp)
8114403c:	1084e230 	cmpltui	r2,r2,5000
81144040:	1000051e 	bne	r2,zero,81144058 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81144044:	01204574 	movhi	r4,33045
81144048:	21300704 	addi	r4,r4,-16356
8114404c:	11460d40 	call	811460d4 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81144050:	00bff084 	movi	r2,-62
81144054:	0000d706 	br	811443b4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81144058:	e0bff10b 	ldhu	r2,-60(fp)
8114405c:	10800044 	addi	r2,r2,1
81144060:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81144064:	e0bffd17 	ldw	r2,-12(fp)
81144068:	10800317 	ldw	r2,12(r2)
8114406c:	10800204 	addi	r2,r2,8
81144070:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81144074:	10bfffcc 	andi	r2,r2,65535
81144078:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114407c:	e0bffd17 	ldw	r2,-12(fp)
81144080:	10800317 	ldw	r2,12(r2)
81144084:	10800204 	addi	r2,r2,8
81144088:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
8114408c:	1004d43a 	srli	r2,r2,16
81144090:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81144094:	e0bffd17 	ldw	r2,-12(fp)
81144098:	10800917 	ldw	r2,36(r2)
8114409c:	e0fff317 	ldw	r3,-52(fp)
811440a0:	18bfe32e 	bgeu	r3,r2,81144030 <__reset+0xfb124030>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811440a4:	e0bffd17 	ldw	r2,-12(fp)
811440a8:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811440ac:	e0fff217 	ldw	r3,-56(fp)
811440b0:	18bfdf2e 	bgeu	r3,r2,81144030 <__reset+0xfb124030>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
811440b4:	e0bffd17 	ldw	r2,-12(fp)
811440b8:	10801817 	ldw	r2,96(r2)
811440bc:	e0bff815 	stw	r2,-32(fp)
811440c0:	e03ffc0d 	sth	zero,-16(fp)
811440c4:	e0bffc0b 	ldhu	r2,-16(fp)
811440c8:	e0fffc84 	addi	r3,fp,-14
811440cc:	180d883a 	mov	r6,r3
811440d0:	100b883a 	mov	r5,r2
811440d4:	e13ff817 	ldw	r4,-32(fp)
811440d8:	113a1f80 	call	8113a1f8 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811440dc:	0005303a 	rdctl	r2,status
811440e0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811440e4:	e0fffb17 	ldw	r3,-20(fp)
811440e8:	00bfff84 	movi	r2,-2
811440ec:	1884703a 	and	r2,r3,r2
811440f0:	1001703a 	wrctl	status,r2
  
  return context;
811440f4:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
811440f8:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811440fc:	e0bffd17 	ldw	r2,-12(fp)
81144100:	10800317 	ldw	r2,12(r2)
81144104:	10800104 	addi	r2,r2,4
81144108:	00c00804 	movi	r3,32
8114410c:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81144110:	e0bffd17 	ldw	r2,-12(fp)
81144114:	10800317 	ldw	r2,12(r2)
81144118:	e0fffd17 	ldw	r3,-12(fp)
8114411c:	18c00317 	ldw	r3,12(r3)
81144120:	18c00037 	ldwio	r3,0(r3)
81144124:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81144128:	e0bffe17 	ldw	r2,-8(fp)
8114412c:	10001f26 	beq	r2,zero,811441ac <alt_msgdma_descriptor_sync_transfer+0x1ec>
81144130:	e0bfff17 	ldw	r2,-4(fp)
81144134:	10001d1e 	bne	r2,zero,811441ac <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81144138:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114413c:	00001106 	br	81144184 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81144140:	01000044 	movi	r4,1
81144144:	11319800 	call	81131980 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81144148:	e0bff10b 	ldhu	r2,-60(fp)
8114414c:	1084e230 	cmpltui	r2,r2,5000
81144150:	1000091e 	bne	r2,zero,81144178 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81144154:	01204574 	movhi	r4,33045
81144158:	21301b04 	addi	r4,r4,-16276
8114415c:	11460d40 	call	811460d4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81144160:	e0bffd17 	ldw	r2,-12(fp)
81144164:	10801817 	ldw	r2,96(r2)
81144168:	1009883a 	mov	r4,r2
8114416c:	113a5800 	call	8113a580 <OSSemPost>
				
                return -ETIME;
81144170:	00bff084 	movi	r2,-62
81144174:	00008f06 	br	811443b4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81144178:	e0bff10b 	ldhu	r2,-60(fp)
8114417c:	10800044 	addi	r2,r2,1
81144180:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81144184:	e0bffd17 	ldw	r2,-12(fp)
81144188:	10c00317 	ldw	r3,12(r2)
8114418c:	e0bffd17 	ldw	r2,-12(fp)
81144190:	10800417 	ldw	r2,16(r2)
81144194:	e1bffe17 	ldw	r6,-8(fp)
81144198:	100b883a 	mov	r5,r2
8114419c:	1809883a 	mov	r4,r3
811441a0:	11437340 	call	81143734 <alt_msgdma_write_standard_descriptor>
811441a4:	103fe61e 	bne	r2,zero,81144140 <__reset+0xfb124140>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
811441a8:	00002706 	br	81144248 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811441ac:	e0bffe17 	ldw	r2,-8(fp)
811441b0:	10001f1e 	bne	r2,zero,81144230 <alt_msgdma_descriptor_sync_transfer+0x270>
811441b4:	e0bfff17 	ldw	r2,-4(fp)
811441b8:	10001d26 	beq	r2,zero,81144230 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
811441bc:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811441c0:	00001106 	br	81144208 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811441c4:	01000044 	movi	r4,1
811441c8:	11319800 	call	81131980 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811441cc:	e0bff10b 	ldhu	r2,-60(fp)
811441d0:	1084e230 	cmpltui	r2,r2,5000
811441d4:	1000091e 	bne	r2,zero,811441fc <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
811441d8:	01204574 	movhi	r4,33045
811441dc:	21302c04 	addi	r4,r4,-16208
811441e0:	11460d40 	call	811460d4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811441e4:	e0bffd17 	ldw	r2,-12(fp)
811441e8:	10801817 	ldw	r2,96(r2)
811441ec:	1009883a 	mov	r4,r2
811441f0:	113a5800 	call	8113a580 <OSSemPost>
				
                return -ETIME;
811441f4:	00bff084 	movi	r2,-62
811441f8:	00006e06 	br	811443b4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
811441fc:	e0bff10b 	ldhu	r2,-60(fp)
81144200:	10800044 	addi	r2,r2,1
81144204:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81144208:	e0bffd17 	ldw	r2,-12(fp)
8114420c:	10c00317 	ldw	r3,12(r2)
81144210:	e0bffd17 	ldw	r2,-12(fp)
81144214:	10800417 	ldw	r2,16(r2)
81144218:	e1bfff17 	ldw	r6,-4(fp)
8114421c:	100b883a 	mov	r5,r2
81144220:	1809883a 	mov	r4,r3
81144224:	11437d00 	call	811437d0 <alt_msgdma_write_extended_descriptor>
81144228:	103fe61e 	bne	r2,zero,811441c4 <__reset+0xfb1241c4>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114422c:	00000606 	br	81144248 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81144230:	e0bffd17 	ldw	r2,-12(fp)
81144234:	10801817 	ldw	r2,96(r2)
81144238:	1009883a 	mov	r4,r2
8114423c:	113a5800 	call	8113a580 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81144240:	00bfffc4 	movi	r2,-1
81144244:	00005b06 	br	811443b4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81144248:	e0bffd17 	ldw	r2,-12(fp)
8114424c:	10800317 	ldw	r2,12(r2)
81144250:	10800104 	addi	r2,r2,4
81144254:	e0fffd17 	ldw	r3,-12(fp)
81144258:	19000d17 	ldw	r4,52(r3)
8114425c:	00fff2c4 	movi	r3,-53
81144260:	20c6703a 	and	r3,r4,r3
81144264:	18c00114 	ori	r3,r3,4
81144268:	10c00035 	stwio	r3,0(r2)
8114426c:	e0bff517 	ldw	r2,-44(fp)
81144270:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144274:	e0bff717 	ldw	r2,-36(fp)
81144278:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
8114427c:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81144280:	e0bffd17 	ldw	r2,-12(fp)
81144284:	10800317 	ldw	r2,12(r2)
81144288:	10800037 	ldwio	r2,0(r2)
8114428c:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81144290:	00001506 	br	811442e8 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81144294:	01000044 	movi	r4,1
81144298:	11319800 	call	81131980 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114429c:	e0bff10b 	ldhu	r2,-60(fp)
811442a0:	1084e230 	cmpltui	r2,r2,5000
811442a4:	1000091e 	bne	r2,zero,811442cc <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
811442a8:	01204574 	movhi	r4,33045
811442ac:	21303d04 	addi	r4,r4,-16140
811442b0:	11460d40 	call	811460d4 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
811442b4:	e0bffd17 	ldw	r2,-12(fp)
811442b8:	10801817 	ldw	r2,96(r2)
811442bc:	1009883a 	mov	r4,r2
811442c0:	113a5800 	call	8113a580 <OSSemPost>
			
            return -ETIME;
811442c4:	00bff084 	movi	r2,-62
811442c8:	00003a06 	br	811443b4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
811442cc:	e0bff10b 	ldhu	r2,-60(fp)
811442d0:	10800044 	addi	r2,r2,1
811442d4:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
811442d8:	e0bffd17 	ldw	r2,-12(fp)
811442dc:	10800317 	ldw	r2,12(r2)
811442e0:	10800037 	ldwio	r2,0(r2)
811442e4:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
811442e8:	e0fff017 	ldw	r3,-64(fp)
811442ec:	e0bff617 	ldw	r2,-40(fp)
811442f0:	1884703a 	and	r2,r3,r2
811442f4:	1000031e 	bne	r2,zero,81144304 <alt_msgdma_descriptor_sync_transfer+0x344>
811442f8:	e0bff017 	ldw	r2,-64(fp)
811442fc:	1080004c 	andi	r2,r2,1
81144300:	103fe41e 	bne	r2,zero,81144294 <__reset+0xfb124294>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81144304:	e0fff017 	ldw	r3,-64(fp)
81144308:	e0bff617 	ldw	r2,-40(fp)
8114430c:	1884703a 	and	r2,r3,r2
81144310:	10000626 	beq	r2,zero,8114432c <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81144314:	e0bffd17 	ldw	r2,-12(fp)
81144318:	10801817 	ldw	r2,96(r2)
8114431c:	1009883a 	mov	r4,r2
81144320:	113a5800 	call	8113a580 <OSSemPost>
		
        return error;
81144324:	e0bff617 	ldw	r2,-40(fp)
81144328:	00002206 	br	811443b4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
8114432c:	e0bffd17 	ldw	r2,-12(fp)
81144330:	10800317 	ldw	r2,12(r2)
81144334:	10800104 	addi	r2,r2,4
81144338:	10800037 	ldwio	r2,0(r2)
8114433c:	10800814 	ori	r2,r2,32
81144340:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144344:	0005303a 	rdctl	r2,status
81144348:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114434c:	e0fffa17 	ldw	r3,-24(fp)
81144350:	00bfff84 	movi	r2,-2
81144354:	1884703a 	and	r2,r3,r2
81144358:	1001703a 	wrctl	status,r2
  
  return context;
8114435c:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81144360:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81144364:	e0bffd17 	ldw	r2,-12(fp)
81144368:	10800317 	ldw	r2,12(r2)
8114436c:	10800104 	addi	r2,r2,4
81144370:	e0fff417 	ldw	r3,-48(fp)
81144374:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81144378:	e0bffd17 	ldw	r2,-12(fp)
8114437c:	10800317 	ldw	r2,12(r2)
81144380:	e0fffd17 	ldw	r3,-12(fp)
81144384:	18c00317 	ldw	r3,12(r3)
81144388:	18c00037 	ldwio	r3,0(r3)
8114438c:	10c00035 	stwio	r3,0(r2)
81144390:	e0bff517 	ldw	r2,-44(fp)
81144394:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144398:	e0bff917 	ldw	r2,-28(fp)
8114439c:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
811443a0:	e0bffd17 	ldw	r2,-12(fp)
811443a4:	10801817 	ldw	r2,96(r2)
811443a8:	1009883a 	mov	r4,r2
811443ac:	113a5800 	call	8113a580 <OSSemPost>
    
    return 0;
811443b0:	0005883a 	mov	r2,zero

}
811443b4:	e037883a 	mov	sp,fp
811443b8:	dfc00117 	ldw	ra,4(sp)
811443bc:	df000017 	ldw	fp,0(sp)
811443c0:	dec00204 	addi	sp,sp,8
811443c4:	f800283a 	ret

811443c8 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
811443c8:	defff804 	addi	sp,sp,-32
811443cc:	de00012e 	bgeu	sp,et,811443d4 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
811443d0:	003b68fa 	trap	3
811443d4:	dfc00715 	stw	ra,28(sp)
811443d8:	df000615 	stw	fp,24(sp)
811443dc:	df000604 	addi	fp,sp,24
811443e0:	e13ffc15 	stw	r4,-16(fp)
811443e4:	e17ffd15 	stw	r5,-12(fp)
811443e8:	e1bffe15 	stw	r6,-8(fp)
811443ec:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
811443f0:	e0800217 	ldw	r2,8(fp)
811443f4:	d8800115 	stw	r2,4(sp)
811443f8:	e0bfff17 	ldw	r2,-4(fp)
811443fc:	d8800015 	stw	r2,0(sp)
81144400:	e1fffe17 	ldw	r7,-8(fp)
81144404:	000d883a 	mov	r6,zero
81144408:	e17ffd17 	ldw	r5,-12(fp)
8114440c:	e13ffc17 	ldw	r4,-16(fp)
81144410:	1143a900 	call	81143a90 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81144414:	e037883a 	mov	sp,fp
81144418:	dfc00117 	ldw	ra,4(sp)
8114441c:	df000017 	ldw	fp,0(sp)
81144420:	dec00204 	addi	sp,sp,8
81144424:	f800283a 	ret

81144428 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81144428:	defff804 	addi	sp,sp,-32
8114442c:	de00012e 	bgeu	sp,et,81144434 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81144430:	003b68fa 	trap	3
81144434:	dfc00715 	stw	ra,28(sp)
81144438:	df000615 	stw	fp,24(sp)
8114443c:	df000604 	addi	fp,sp,24
81144440:	e13ffc15 	stw	r4,-16(fp)
81144444:	e17ffd15 	stw	r5,-12(fp)
81144448:	e1bffe15 	stw	r6,-8(fp)
8114444c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81144450:	e0800217 	ldw	r2,8(fp)
81144454:	d8800115 	stw	r2,4(sp)
81144458:	e0bfff17 	ldw	r2,-4(fp)
8114445c:	d8800015 	stw	r2,0(sp)
81144460:	000f883a 	mov	r7,zero
81144464:	e1bffe17 	ldw	r6,-8(fp)
81144468:	e17ffd17 	ldw	r5,-12(fp)
8114446c:	e13ffc17 	ldw	r4,-16(fp)
81144470:	1143a900 	call	81143a90 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81144474:	e037883a 	mov	sp,fp
81144478:	dfc00117 	ldw	ra,4(sp)
8114447c:	df000017 	ldw	fp,0(sp)
81144480:	dec00204 	addi	sp,sp,8
81144484:	f800283a 	ret

81144488 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81144488:	defff804 	addi	sp,sp,-32
8114448c:	de00012e 	bgeu	sp,et,81144494 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81144490:	003b68fa 	trap	3
81144494:	dfc00715 	stw	ra,28(sp)
81144498:	df000615 	stw	fp,24(sp)
8114449c:	df000604 	addi	fp,sp,24
811444a0:	e13ffc15 	stw	r4,-16(fp)
811444a4:	e17ffd15 	stw	r5,-12(fp)
811444a8:	e1bffe15 	stw	r6,-8(fp)
811444ac:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
811444b0:	e0800317 	ldw	r2,12(fp)
811444b4:	d8800115 	stw	r2,4(sp)
811444b8:	e0800217 	ldw	r2,8(fp)
811444bc:	d8800015 	stw	r2,0(sp)
811444c0:	e1ffff17 	ldw	r7,-4(fp)
811444c4:	e1bffe17 	ldw	r6,-8(fp)
811444c8:	e17ffd17 	ldw	r5,-12(fp)
811444cc:	e13ffc17 	ldw	r4,-16(fp)
811444d0:	1143a900 	call	81143a90 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
811444d4:	e037883a 	mov	sp,fp
811444d8:	dfc00117 	ldw	ra,4(sp)
811444dc:	df000017 	ldw	fp,0(sp)
811444e0:	dec00204 	addi	sp,sp,8
811444e4:	f800283a 	ret

811444e8 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
811444e8:	defff004 	addi	sp,sp,-64
811444ec:	de00012e 	bgeu	sp,et,811444f4 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
811444f0:	003b68fa 	trap	3
811444f4:	dfc00f15 	stw	ra,60(sp)
811444f8:	df000e15 	stw	fp,56(sp)
811444fc:	df000e04 	addi	fp,sp,56
81144500:	e13ff915 	stw	r4,-28(fp)
81144504:	e17ffa15 	stw	r5,-24(fp)
81144508:	e1bffb15 	stw	r6,-20(fp)
8114450c:	e1fffc15 	stw	r7,-16(fp)
81144510:	e1000317 	ldw	r4,12(fp)
81144514:	e0c00417 	ldw	r3,16(fp)
81144518:	e0800517 	ldw	r2,20(fp)
8114451c:	e13ffd0d 	sth	r4,-12(fp)
81144520:	e0fffe05 	stb	r3,-8(fp)
81144524:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81144528:	e0bffd0b 	ldhu	r2,-12(fp)
8114452c:	e0fffe03 	ldbu	r3,-8(fp)
81144530:	e13fff0b 	ldhu	r4,-4(fp)
81144534:	d9000615 	stw	r4,24(sp)
81144538:	d8000515 	stw	zero,20(sp)
8114453c:	d8c00415 	stw	r3,16(sp)
81144540:	d8000315 	stw	zero,12(sp)
81144544:	d8800215 	stw	r2,8(sp)
81144548:	e0800217 	ldw	r2,8(fp)
8114454c:	d8800115 	stw	r2,4(sp)
81144550:	e0bffc17 	ldw	r2,-16(fp)
81144554:	d8800015 	stw	r2,0(sp)
81144558:	e1fffb17 	ldw	r7,-20(fp)
8114455c:	000d883a 	mov	r6,zero
81144560:	e17ffa17 	ldw	r5,-24(fp)
81144564:	e13ff917 	ldw	r4,-28(fp)
81144568:	1143b240 	call	81143b24 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
8114456c:	e037883a 	mov	sp,fp
81144570:	dfc00117 	ldw	ra,4(sp)
81144574:	df000017 	ldw	fp,0(sp)
81144578:	dec00204 	addi	sp,sp,8
8114457c:	f800283a 	ret

81144580 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81144580:	defff004 	addi	sp,sp,-64
81144584:	de00012e 	bgeu	sp,et,8114458c <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81144588:	003b68fa 	trap	3
8114458c:	dfc00f15 	stw	ra,60(sp)
81144590:	df000e15 	stw	fp,56(sp)
81144594:	df000e04 	addi	fp,sp,56
81144598:	e13ff915 	stw	r4,-28(fp)
8114459c:	e17ffa15 	stw	r5,-24(fp)
811445a0:	e1bffb15 	stw	r6,-20(fp)
811445a4:	e1fffc15 	stw	r7,-16(fp)
811445a8:	e1000317 	ldw	r4,12(fp)
811445ac:	e0c00417 	ldw	r3,16(fp)
811445b0:	e0800517 	ldw	r2,20(fp)
811445b4:	e13ffd0d 	sth	r4,-12(fp)
811445b8:	e0fffe05 	stb	r3,-8(fp)
811445bc:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
811445c0:	e0bffd0b 	ldhu	r2,-12(fp)
811445c4:	e0fffe03 	ldbu	r3,-8(fp)
811445c8:	e13fff0b 	ldhu	r4,-4(fp)
811445cc:	d8000615 	stw	zero,24(sp)
811445d0:	d9000515 	stw	r4,20(sp)
811445d4:	d8000415 	stw	zero,16(sp)
811445d8:	d8c00315 	stw	r3,12(sp)
811445dc:	d8800215 	stw	r2,8(sp)
811445e0:	e0800217 	ldw	r2,8(fp)
811445e4:	d8800115 	stw	r2,4(sp)
811445e8:	e0bffc17 	ldw	r2,-16(fp)
811445ec:	d8800015 	stw	r2,0(sp)
811445f0:	000f883a 	mov	r7,zero
811445f4:	e1bffb17 	ldw	r6,-20(fp)
811445f8:	e17ffa17 	ldw	r5,-24(fp)
811445fc:	e13ff917 	ldw	r4,-28(fp)
81144600:	1143b240 	call	81143b24 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81144604:	e037883a 	mov	sp,fp
81144608:	dfc00117 	ldw	ra,4(sp)
8114460c:	df000017 	ldw	fp,0(sp)
81144610:	dec00204 	addi	sp,sp,8
81144614:	f800283a 	ret

81144618 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81144618:	deffee04 	addi	sp,sp,-72
8114461c:	de00012e 	bgeu	sp,et,81144624 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81144620:	003b68fa 	trap	3
81144624:	dfc01115 	stw	ra,68(sp)
81144628:	df001015 	stw	fp,64(sp)
8114462c:	df001004 	addi	fp,sp,64
81144630:	e13ff715 	stw	r4,-36(fp)
81144634:	e17ff815 	stw	r5,-32(fp)
81144638:	e1bff915 	stw	r6,-28(fp)
8114463c:	e1fffa15 	stw	r7,-24(fp)
81144640:	e1800417 	ldw	r6,16(fp)
81144644:	e1400517 	ldw	r5,20(fp)
81144648:	e1000617 	ldw	r4,24(fp)
8114464c:	e0c00717 	ldw	r3,28(fp)
81144650:	e0800817 	ldw	r2,32(fp)
81144654:	e1bffb0d 	sth	r6,-20(fp)
81144658:	e17ffc05 	stb	r5,-16(fp)
8114465c:	e13ffd05 	stb	r4,-12(fp)
81144660:	e0fffe0d 	sth	r3,-8(fp)
81144664:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81144668:	e0bffb0b 	ldhu	r2,-20(fp)
8114466c:	e0fffc03 	ldbu	r3,-16(fp)
81144670:	e13ffd03 	ldbu	r4,-12(fp)
81144674:	e17ffe0b 	ldhu	r5,-8(fp)
81144678:	e1bfff0b 	ldhu	r6,-4(fp)
8114467c:	d9800615 	stw	r6,24(sp)
81144680:	d9400515 	stw	r5,20(sp)
81144684:	d9000415 	stw	r4,16(sp)
81144688:	d8c00315 	stw	r3,12(sp)
8114468c:	d8800215 	stw	r2,8(sp)
81144690:	e0800317 	ldw	r2,12(fp)
81144694:	d8800115 	stw	r2,4(sp)
81144698:	e0800217 	ldw	r2,8(fp)
8114469c:	d8800015 	stw	r2,0(sp)
811446a0:	e1fffa17 	ldw	r7,-24(fp)
811446a4:	e1bff917 	ldw	r6,-28(fp)
811446a8:	e17ff817 	ldw	r5,-32(fp)
811446ac:	e13ff717 	ldw	r4,-36(fp)
811446b0:	1143b240 	call	81143b24 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
811446b4:	e037883a 	mov	sp,fp
811446b8:	dfc00117 	ldw	ra,4(sp)
811446bc:	df000017 	ldw	fp,0(sp)
811446c0:	dec00204 	addi	sp,sp,8
811446c4:	f800283a 	ret

811446c8 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
811446c8:	defffb04 	addi	sp,sp,-20
811446cc:	de00012e 	bgeu	sp,et,811446d4 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
811446d0:	003b68fa 	trap	3
811446d4:	df000415 	stw	fp,16(sp)
811446d8:	df000404 	addi	fp,sp,16
811446dc:	e13ffc15 	stw	r4,-16(fp)
811446e0:	e17ffd15 	stw	r5,-12(fp)
811446e4:	e1bffe15 	stw	r6,-8(fp)
811446e8:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
811446ec:	e0bffc17 	ldw	r2,-16(fp)
811446f0:	10c01217 	ldw	r3,72(r2)
811446f4:	e0800117 	ldw	r2,4(fp)
811446f8:	18800436 	bltu	r3,r2,8114470c <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
811446fc:	e0bffc17 	ldw	r2,-16(fp)
81144700:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81144704:	10803fcc 	andi	r2,r2,255
81144708:	10000226 	beq	r2,zero,81144714 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114470c:	00bffa84 	movi	r2,-22
81144710:	00001406 	br	81144764 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81144714:	e0bffd17 	ldw	r2,-12(fp)
81144718:	e0fffe17 	ldw	r3,-8(fp)
8114471c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81144720:	e0bffd17 	ldw	r2,-12(fp)
81144724:	e0ffff17 	ldw	r3,-4(fp)
81144728:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114472c:	e0bffd17 	ldw	r2,-12(fp)
81144730:	e0c00117 	ldw	r3,4(fp)
81144734:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81144738:	e0fffd17 	ldw	r3,-12(fp)
8114473c:	e0bffd17 	ldw	r2,-12(fp)
81144740:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81144744:	e0c00217 	ldw	r3,8(fp)
81144748:	00900034 	movhi	r2,16384
8114474c:	10bfffc4 	addi	r2,r2,-1
81144750:	1884703a 	and	r2,r3,r2
81144754:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81144758:	e0bffd17 	ldw	r2,-12(fp)
8114475c:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81144760:	0005883a 	mov	r2,zero
}
81144764:	e037883a 	mov	sp,fp
81144768:	df000017 	ldw	fp,0(sp)
8114476c:	dec00104 	addi	sp,sp,4
81144770:	f800283a 	ret

81144774 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81144774:	defff404 	addi	sp,sp,-48
81144778:	de00012e 	bgeu	sp,et,81144780 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8114477c:	003b68fa 	trap	3
81144780:	df000b15 	stw	fp,44(sp)
81144784:	df000b04 	addi	fp,sp,44
81144788:	e13ff715 	stw	r4,-36(fp)
8114478c:	e17ff815 	stw	r5,-32(fp)
81144790:	e1bff915 	stw	r6,-28(fp)
81144794:	e1fffa15 	stw	r7,-24(fp)
81144798:	e1800517 	ldw	r6,20(fp)
8114479c:	e1400617 	ldw	r5,24(fp)
811447a0:	e1000717 	ldw	r4,28(fp)
811447a4:	e0c00817 	ldw	r3,32(fp)
811447a8:	e0800917 	ldw	r2,36(fp)
811447ac:	e1bffb0d 	sth	r6,-20(fp)
811447b0:	e17ffc05 	stb	r5,-16(fp)
811447b4:	e13ffd05 	stb	r4,-12(fp)
811447b8:	e0fffe0d 	sth	r3,-8(fp)
811447bc:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
811447c0:	e0bff717 	ldw	r2,-36(fp)
811447c4:	10c01217 	ldw	r3,72(r2)
811447c8:	e0800317 	ldw	r2,12(fp)
811447cc:	18801936 	bltu	r3,r2,81144834 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
811447d0:	e13ff717 	ldw	r4,-36(fp)
811447d4:	20801317 	ldw	r2,76(r4)
811447d8:	20c01417 	ldw	r3,80(r4)
811447dc:	e13ffe0b 	ldhu	r4,-8(fp)
811447e0:	213fffcc 	andi	r4,r4,65535
811447e4:	2015883a 	mov	r10,r4
811447e8:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
811447ec:	1ac01136 	bltu	r3,r11,81144834 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
811447f0:	58c0011e 	bne	r11,r3,811447f8 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
811447f4:	12800f36 	bltu	r2,r10,81144834 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811447f8:	e13ff717 	ldw	r4,-36(fp)
811447fc:	20801317 	ldw	r2,76(r4)
81144800:	20c01417 	ldw	r3,80(r4)
81144804:	e13fff0b 	ldhu	r4,-4(fp)
81144808:	213fffcc 	andi	r4,r4,65535
8114480c:	2011883a 	mov	r8,r4
81144810:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81144814:	1a400736 	bltu	r3,r9,81144834 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81144818:	48c0011e 	bne	r9,r3,81144820 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8114481c:	12000536 	bltu	r2,r8,81144834 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81144820:	e0bff717 	ldw	r2,-36(fp)
81144824:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81144828:	10803fcc 	andi	r2,r2,255
8114482c:	10800060 	cmpeqi	r2,r2,1
81144830:	1000021e 	bne	r2,zero,8114483c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81144834:	00bffa84 	movi	r2,-22
81144838:	00003106 	br	81144900 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8114483c:	e0bff817 	ldw	r2,-32(fp)
81144840:	e0fff917 	ldw	r3,-28(fp)
81144844:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81144848:	e0bff817 	ldw	r2,-32(fp)
8114484c:	e0fffa17 	ldw	r3,-24(fp)
81144850:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81144854:	e0bff817 	ldw	r2,-32(fp)
81144858:	e0c00117 	ldw	r3,4(fp)
8114485c:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81144860:	e0bff817 	ldw	r2,-32(fp)
81144864:	e0c00217 	ldw	r3,8(fp)
81144868:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114486c:	e0bff817 	ldw	r2,-32(fp)
81144870:	e0c00317 	ldw	r3,12(fp)
81144874:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81144878:	e0bff817 	ldw	r2,-32(fp)
8114487c:	e0fffb0b 	ldhu	r3,-20(fp)
81144880:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81144884:	e0bff817 	ldw	r2,-32(fp)
81144888:	e0fffc03 	ldbu	r3,-16(fp)
8114488c:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
81144890:	e0bff817 	ldw	r2,-32(fp)
81144894:	e0fffd03 	ldbu	r3,-12(fp)
81144898:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8114489c:	e0bff817 	ldw	r2,-32(fp)
811448a0:	e0fffe0b 	ldhu	r3,-8(fp)
811448a4:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
811448a8:	e0bff817 	ldw	r2,-32(fp)
811448ac:	e0ffff0b 	ldhu	r3,-4(fp)
811448b0:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
811448b4:	e0bff817 	ldw	r2,-32(fp)
811448b8:	1019883a 	mov	r12,r2
811448bc:	001b883a 	mov	r13,zero
811448c0:	e33ff515 	stw	r12,-44(fp)
811448c4:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
811448c8:	e0fff517 	ldw	r3,-44(fp)
811448cc:	e0bff817 	ldw	r2,-32(fp)
811448d0:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
811448d4:	e0fff617 	ldw	r3,-40(fp)
811448d8:	e0bff817 	ldw	r2,-32(fp)
811448dc:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811448e0:	e0c00417 	ldw	r3,16(fp)
811448e4:	00900034 	movhi	r2,16384
811448e8:	10bfffc4 	addi	r2,r2,-1
811448ec:	1884703a 	and	r2,r3,r2
811448f0:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
811448f4:	e0bff817 	ldw	r2,-32(fp)
811448f8:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
811448fc:	0005883a 	mov	r2,zero
}
81144900:	e037883a 	mov	sp,fp
81144904:	df000017 	ldw	fp,0(sp)
81144908:	dec00104 	addi	sp,sp,4
8114490c:	f800283a 	ret

81144910 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
81144910:	defff804 	addi	sp,sp,-32
81144914:	de00012e 	bgeu	sp,et,8114491c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81144918:	003b68fa 	trap	3
8114491c:	dfc00715 	stw	ra,28(sp)
81144920:	df000615 	stw	fp,24(sp)
81144924:	df000604 	addi	fp,sp,24
81144928:	e13ffc15 	stw	r4,-16(fp)
8114492c:	e17ffd15 	stw	r5,-12(fp)
81144930:	e1bffe15 	stw	r6,-8(fp)
81144934:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81144938:	e0800317 	ldw	r2,12(fp)
8114493c:	d8800115 	stw	r2,4(sp)
81144940:	e0800217 	ldw	r2,8(fp)
81144944:	d8800015 	stw	r2,0(sp)
81144948:	e1ffff17 	ldw	r7,-4(fp)
8114494c:	e1bffe17 	ldw	r6,-8(fp)
81144950:	e17ffd17 	ldw	r5,-12(fp)
81144954:	e13ffc17 	ldw	r4,-16(fp)
81144958:	11446c80 	call	811446c8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8114495c:	e037883a 	mov	sp,fp
81144960:	dfc00117 	ldw	ra,4(sp)
81144964:	df000017 	ldw	fp,0(sp)
81144968:	dec00204 	addi	sp,sp,8
8114496c:	f800283a 	ret

81144970 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81144970:	defff804 	addi	sp,sp,-32
81144974:	de00012e 	bgeu	sp,et,8114497c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81144978:	003b68fa 	trap	3
8114497c:	dfc00715 	stw	ra,28(sp)
81144980:	df000615 	stw	fp,24(sp)
81144984:	df000604 	addi	fp,sp,24
81144988:	e13ffc15 	stw	r4,-16(fp)
8114498c:	e17ffd15 	stw	r5,-12(fp)
81144990:	e1bffe15 	stw	r6,-8(fp)
81144994:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81144998:	e0800217 	ldw	r2,8(fp)
8114499c:	d8800115 	stw	r2,4(sp)
811449a0:	e0bfff17 	ldw	r2,-4(fp)
811449a4:	d8800015 	stw	r2,0(sp)
811449a8:	e1fffe17 	ldw	r7,-8(fp)
811449ac:	000d883a 	mov	r6,zero
811449b0:	e17ffd17 	ldw	r5,-12(fp)
811449b4:	e13ffc17 	ldw	r4,-16(fp)
811449b8:	11446c80 	call	811446c8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
811449bc:	e037883a 	mov	sp,fp
811449c0:	dfc00117 	ldw	ra,4(sp)
811449c4:	df000017 	ldw	fp,0(sp)
811449c8:	dec00204 	addi	sp,sp,8
811449cc:	f800283a 	ret

811449d0 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
811449d0:	defff804 	addi	sp,sp,-32
811449d4:	de00012e 	bgeu	sp,et,811449dc <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
811449d8:	003b68fa 	trap	3
811449dc:	dfc00715 	stw	ra,28(sp)
811449e0:	df000615 	stw	fp,24(sp)
811449e4:	df000604 	addi	fp,sp,24
811449e8:	e13ffc15 	stw	r4,-16(fp)
811449ec:	e17ffd15 	stw	r5,-12(fp)
811449f0:	e1bffe15 	stw	r6,-8(fp)
811449f4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
811449f8:	e0800217 	ldw	r2,8(fp)
811449fc:	d8800115 	stw	r2,4(sp)
81144a00:	e0bfff17 	ldw	r2,-4(fp)
81144a04:	d8800015 	stw	r2,0(sp)
81144a08:	000f883a 	mov	r7,zero
81144a0c:	e1bffe17 	ldw	r6,-8(fp)
81144a10:	e17ffd17 	ldw	r5,-12(fp)
81144a14:	e13ffc17 	ldw	r4,-16(fp)
81144a18:	11446c80 	call	811446c8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
81144a1c:	e037883a 	mov	sp,fp
81144a20:	dfc00117 	ldw	ra,4(sp)
81144a24:	df000017 	ldw	fp,0(sp)
81144a28:	dec00204 	addi	sp,sp,8
81144a2c:	f800283a 	ret

81144a30 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
81144a30:	deffee04 	addi	sp,sp,-72
81144a34:	de00012e 	bgeu	sp,et,81144a3c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81144a38:	003b68fa 	trap	3
81144a3c:	dfc01115 	stw	ra,68(sp)
81144a40:	df001015 	stw	fp,64(sp)
81144a44:	df001004 	addi	fp,sp,64
81144a48:	e13ff915 	stw	r4,-28(fp)
81144a4c:	e17ffa15 	stw	r5,-24(fp)
81144a50:	e1bffb15 	stw	r6,-20(fp)
81144a54:	e1fffc15 	stw	r7,-16(fp)
81144a58:	e1000417 	ldw	r4,16(fp)
81144a5c:	e0c00517 	ldw	r3,20(fp)
81144a60:	e0800617 	ldw	r2,24(fp)
81144a64:	e13ffd0d 	sth	r4,-12(fp)
81144a68:	e0fffe05 	stb	r3,-8(fp)
81144a6c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
81144a70:	e0bffd0b 	ldhu	r2,-12(fp)
81144a74:	e0fffe03 	ldbu	r3,-8(fp)
81144a78:	e13fff0b 	ldhu	r4,-4(fp)
81144a7c:	d9000815 	stw	r4,32(sp)
81144a80:	d8000715 	stw	zero,28(sp)
81144a84:	d8c00615 	stw	r3,24(sp)
81144a88:	d8000515 	stw	zero,20(sp)
81144a8c:	d8800415 	stw	r2,16(sp)
81144a90:	e0800317 	ldw	r2,12(fp)
81144a94:	d8800315 	stw	r2,12(sp)
81144a98:	e0800217 	ldw	r2,8(fp)
81144a9c:	d8800215 	stw	r2,8(sp)
81144aa0:	e0bffc17 	ldw	r2,-16(fp)
81144aa4:	d8800115 	stw	r2,4(sp)
81144aa8:	e0bffb17 	ldw	r2,-20(fp)
81144aac:	d8800015 	stw	r2,0(sp)
81144ab0:	000f883a 	mov	r7,zero
81144ab4:	000d883a 	mov	r6,zero
81144ab8:	e17ffa17 	ldw	r5,-24(fp)
81144abc:	e13ff917 	ldw	r4,-28(fp)
81144ac0:	11447740 	call	81144774 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
81144ac4:	e037883a 	mov	sp,fp
81144ac8:	dfc00117 	ldw	ra,4(sp)
81144acc:	df000017 	ldw	fp,0(sp)
81144ad0:	dec00204 	addi	sp,sp,8
81144ad4:	f800283a 	ret

81144ad8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81144ad8:	deffee04 	addi	sp,sp,-72
81144adc:	de00012e 	bgeu	sp,et,81144ae4 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81144ae0:	003b68fa 	trap	3
81144ae4:	dfc01115 	stw	ra,68(sp)
81144ae8:	df001015 	stw	fp,64(sp)
81144aec:	df001004 	addi	fp,sp,64
81144af0:	e13ff915 	stw	r4,-28(fp)
81144af4:	e17ffa15 	stw	r5,-24(fp)
81144af8:	e1bffb15 	stw	r6,-20(fp)
81144afc:	e1fffc15 	stw	r7,-16(fp)
81144b00:	e1000417 	ldw	r4,16(fp)
81144b04:	e0c00517 	ldw	r3,20(fp)
81144b08:	e0800617 	ldw	r2,24(fp)
81144b0c:	e13ffd0d 	sth	r4,-12(fp)
81144b10:	e0fffe05 	stb	r3,-8(fp)
81144b14:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81144b18:	e0bffd0b 	ldhu	r2,-12(fp)
81144b1c:	e0fffe03 	ldbu	r3,-8(fp)
81144b20:	e13fff0b 	ldhu	r4,-4(fp)
81144b24:	d8000815 	stw	zero,32(sp)
81144b28:	d9000715 	stw	r4,28(sp)
81144b2c:	d8000615 	stw	zero,24(sp)
81144b30:	d8c00515 	stw	r3,20(sp)
81144b34:	d8800415 	stw	r2,16(sp)
81144b38:	e0800317 	ldw	r2,12(fp)
81144b3c:	d8800315 	stw	r2,12(sp)
81144b40:	e0800217 	ldw	r2,8(fp)
81144b44:	d8800215 	stw	r2,8(sp)
81144b48:	d8000115 	stw	zero,4(sp)
81144b4c:	d8000015 	stw	zero,0(sp)
81144b50:	e1fffc17 	ldw	r7,-16(fp)
81144b54:	e1bffb17 	ldw	r6,-20(fp)
81144b58:	e17ffa17 	ldw	r5,-24(fp)
81144b5c:	e13ff917 	ldw	r4,-28(fp)
81144b60:	11447740 	call	81144774 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81144b64:	e037883a 	mov	sp,fp
81144b68:	dfc00117 	ldw	ra,4(sp)
81144b6c:	df000017 	ldw	fp,0(sp)
81144b70:	dec00204 	addi	sp,sp,8
81144b74:	f800283a 	ret

81144b78 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81144b78:	deffec04 	addi	sp,sp,-80
81144b7c:	de00012e 	bgeu	sp,et,81144b84 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
81144b80:	003b68fa 	trap	3
81144b84:	dfc01315 	stw	ra,76(sp)
81144b88:	df001215 	stw	fp,72(sp)
81144b8c:	df001204 	addi	fp,sp,72
81144b90:	e13ff715 	stw	r4,-36(fp)
81144b94:	e17ff815 	stw	r5,-32(fp)
81144b98:	e1bff915 	stw	r6,-28(fp)
81144b9c:	e1fffa15 	stw	r7,-24(fp)
81144ba0:	e1800617 	ldw	r6,24(fp)
81144ba4:	e1400717 	ldw	r5,28(fp)
81144ba8:	e1000817 	ldw	r4,32(fp)
81144bac:	e0c00917 	ldw	r3,36(fp)
81144bb0:	e0800a17 	ldw	r2,40(fp)
81144bb4:	e1bffb0d 	sth	r6,-20(fp)
81144bb8:	e17ffc05 	stb	r5,-16(fp)
81144bbc:	e13ffd05 	stb	r4,-12(fp)
81144bc0:	e0fffe0d 	sth	r3,-8(fp)
81144bc4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81144bc8:	e0bffb0b 	ldhu	r2,-20(fp)
81144bcc:	e0fffc03 	ldbu	r3,-16(fp)
81144bd0:	e13ffd03 	ldbu	r4,-12(fp)
81144bd4:	e17ffe0b 	ldhu	r5,-8(fp)
81144bd8:	e1bfff0b 	ldhu	r6,-4(fp)
81144bdc:	d9800815 	stw	r6,32(sp)
81144be0:	d9400715 	stw	r5,28(sp)
81144be4:	d9000615 	stw	r4,24(sp)
81144be8:	d8c00515 	stw	r3,20(sp)
81144bec:	d8800415 	stw	r2,16(sp)
81144bf0:	e0800517 	ldw	r2,20(fp)
81144bf4:	d8800315 	stw	r2,12(sp)
81144bf8:	e0800417 	ldw	r2,16(fp)
81144bfc:	d8800215 	stw	r2,8(sp)
81144c00:	e0800317 	ldw	r2,12(fp)
81144c04:	d8800115 	stw	r2,4(sp)
81144c08:	e0800217 	ldw	r2,8(fp)
81144c0c:	d8800015 	stw	r2,0(sp)
81144c10:	e1fffa17 	ldw	r7,-24(fp)
81144c14:	e1bff917 	ldw	r6,-28(fp)
81144c18:	e17ff817 	ldw	r5,-32(fp)
81144c1c:	e13ff717 	ldw	r4,-36(fp)
81144c20:	11447740 	call	81144774 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
81144c24:	e037883a 	mov	sp,fp
81144c28:	dfc00117 	ldw	ra,4(sp)
81144c2c:	df000017 	ldw	fp,0(sp)
81144c30:	dec00204 	addi	sp,sp,8
81144c34:	f800283a 	ret

81144c38 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81144c38:	defffc04 	addi	sp,sp,-16
81144c3c:	de00012e 	bgeu	sp,et,81144c44 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
81144c40:	003b68fa 	trap	3
81144c44:	df000315 	stw	fp,12(sp)
81144c48:	df000304 	addi	fp,sp,12
81144c4c:	e13ffe15 	stw	r4,-8(fp)
81144c50:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81144c54:	e0bfff17 	ldw	r2,-4(fp)
81144c58:	1000021e 	bne	r2,zero,81144c64 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81144c5c:	00bffa84 	movi	r2,-22
81144c60:	00002f06 	br	81144d20 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81144c64:	e0bfff17 	ldw	r2,-4(fp)
81144c68:	10c00317 	ldw	r3,12(r2)
81144c6c:	e0bfff17 	ldw	r2,-4(fp)
81144c70:	18800226 	beq	r3,r2,81144c7c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81144c74:	00bffa84 	movi	r2,-22
81144c78:	00002906 	br	81144d20 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81144c7c:	e0bffe17 	ldw	r2,-8(fp)
81144c80:	10800017 	ldw	r2,0(r2)
81144c84:	1000051e 	bne	r2,zero,81144c9c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81144c88:	e0bffe17 	ldw	r2,-8(fp)
81144c8c:	e0ffff17 	ldw	r3,-4(fp)
81144c90:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81144c94:	0005883a 	mov	r2,zero
81144c98:	00002106 	br	81144d20 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
81144c9c:	e0bffe17 	ldw	r2,-8(fp)
81144ca0:	10c00017 	ldw	r3,0(r2)
81144ca4:	e0bfff17 	ldw	r2,-4(fp)
81144ca8:	1880021e 	bne	r3,r2,81144cb4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81144cac:	00bffa84 	movi	r2,-22
81144cb0:	00001b06 	br	81144d20 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81144cb4:	e0bffe17 	ldw	r2,-8(fp)
81144cb8:	10800017 	ldw	r2,0(r2)
81144cbc:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81144cc0:	00000906 	br	81144ce8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
81144cc4:	e0bffd17 	ldw	r2,-12(fp)
81144cc8:	10c00317 	ldw	r3,12(r2)
81144ccc:	e0bfff17 	ldw	r2,-4(fp)
81144cd0:	1880021e 	bne	r3,r2,81144cdc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81144cd4:	00bffa84 	movi	r2,-22
81144cd8:	00001106 	br	81144d20 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81144cdc:	e0bffd17 	ldw	r2,-12(fp)
81144ce0:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
81144ce4:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81144ce8:	e0bffd17 	ldw	r2,-12(fp)
81144cec:	10800317 	ldw	r2,12(r2)
81144cf0:	e0fffe17 	ldw	r3,-8(fp)
81144cf4:	18c00017 	ldw	r3,0(r3)
81144cf8:	10fff21e 	bne	r2,r3,81144cc4 <__reset+0xfb124cc4>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
81144cfc:	e0ffff17 	ldw	r3,-4(fp)
81144d00:	e0bffd17 	ldw	r2,-12(fp)
81144d04:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81144d08:	e0bffe17 	ldw	r2,-8(fp)
81144d0c:	10800017 	ldw	r2,0(r2)
81144d10:	1007883a 	mov	r3,r2
81144d14:	e0bfff17 	ldw	r2,-4(fp)
81144d18:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
81144d1c:	0005883a 	mov	r2,zero
}
81144d20:	e037883a 	mov	sp,fp
81144d24:	df000017 	ldw	fp,0(sp)
81144d28:	dec00104 	addi	sp,sp,4
81144d2c:	f800283a 	ret

81144d30 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
81144d30:	defff804 	addi	sp,sp,-32
81144d34:	de00012e 	bgeu	sp,et,81144d3c <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81144d38:	003b68fa 	trap	3
81144d3c:	df000715 	stw	fp,28(sp)
81144d40:	df000704 	addi	fp,sp,28
81144d44:	e13ffe15 	stw	r4,-8(fp)
81144d48:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
81144d4c:	e13fff17 	ldw	r4,-4(fp)
81144d50:	2000021e 	bne	r4,zero,81144d5c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81144d54:	00bffa84 	movi	r2,-22
81144d58:	00005906 	br	81144ec0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
81144d5c:	e13fff17 	ldw	r4,-4(fp)
81144d60:	2015883a 	mov	r10,r4
81144d64:	0017883a 	mov	r11,zero
81144d68:	e2bffc15 	stw	r10,-16(fp)
81144d6c:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81144d70:	e13fff17 	ldw	r4,-4(fp)
81144d74:	21400317 	ldw	r5,12(r4)
81144d78:	e13ffc17 	ldw	r4,-16(fp)
81144d7c:	29000626 	beq	r5,r4,81144d98 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
81144d80:	e13fff17 	ldw	r4,-4(fp)
81144d84:	21400b17 	ldw	r5,44(r4)
81144d88:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81144d8c:	29000226 	beq	r5,r4,81144d98 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81144d90:	00bffa84 	movi	r2,-22
81144d94:	00004a06 	br	81144ec0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81144d98:	e13ffe17 	ldw	r4,-8(fp)
81144d9c:	21000017 	ldw	r4,0(r4)
81144da0:	2000051e 	bne	r4,zero,81144db8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
81144da4:	e0bffe17 	ldw	r2,-8(fp)
81144da8:	e0ffff17 	ldw	r3,-4(fp)
81144dac:	10c00015 	stw	r3,0(r2)
		return 0;
81144db0:	0005883a 	mov	r2,zero
81144db4:	00004206 	br	81144ec0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
81144db8:	e13ffe17 	ldw	r4,-8(fp)
81144dbc:	21400017 	ldw	r5,0(r4)
81144dc0:	e13fff17 	ldw	r4,-4(fp)
81144dc4:	2900021e 	bne	r5,r4,81144dd0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81144dc8:	00bffa84 	movi	r2,-22
81144dcc:	00003c06 	br	81144ec0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81144dd0:	e13ffe17 	ldw	r4,-8(fp)
81144dd4:	21000017 	ldw	r4,0(r4)
81144dd8:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
81144ddc:	e13ffe17 	ldw	r4,-8(fp)
81144de0:	21000017 	ldw	r4,0(r4)
81144de4:	2011883a 	mov	r8,r4
81144de8:	0013883a 	mov	r9,zero
81144dec:	e23ffa15 	stw	r8,-24(fp)
81144df0:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81144df4:	00001806 	br	81144e58 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
81144df8:	e13fff17 	ldw	r4,-4(fp)
81144dfc:	200d883a 	mov	r6,r4
81144e00:	000f883a 	mov	r7,zero
81144e04:	e1bffc15 	stw	r6,-16(fp)
81144e08:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
81144e0c:	e13ff917 	ldw	r4,-28(fp)
81144e10:	21400317 	ldw	r5,12(r4)
81144e14:	e13ffc17 	ldw	r4,-16(fp)
81144e18:	2900061e 	bne	r5,r4,81144e34 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
81144e1c:	e13ff917 	ldw	r4,-28(fp)
81144e20:	21400b17 	ldw	r5,44(r4)
81144e24:	e13ffd17 	ldw	r4,-12(fp)
81144e28:	2900021e 	bne	r5,r4,81144e34 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81144e2c:	00bffa84 	movi	r2,-22
81144e30:	00002306 	br	81144ec0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81144e34:	e13ff917 	ldw	r4,-28(fp)
81144e38:	21000317 	ldw	r4,12(r4)
81144e3c:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81144e40:	e13ff917 	ldw	r4,-28(fp)
81144e44:	21000b17 	ldw	r4,44(r4)
81144e48:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81144e4c:	e13ffc17 	ldw	r4,-16(fp)
81144e50:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81144e54:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81144e58:	e13ff917 	ldw	r4,-28(fp)
81144e5c:	21400317 	ldw	r5,12(r4)
81144e60:	e13ffa17 	ldw	r4,-24(fp)
81144e64:	29000426 	beq	r5,r4,81144e78 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81144e68:	e13ff917 	ldw	r4,-28(fp)
81144e6c:	21400b17 	ldw	r5,44(r4)
81144e70:	e13ffb17 	ldw	r4,-20(fp)
81144e74:	293fe01e 	bne	r5,r4,81144df8 <__reset+0xfb124df8>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81144e78:	e13fff17 	ldw	r4,-4(fp)
81144e7c:	2005883a 	mov	r2,r4
81144e80:	0007883a 	mov	r3,zero
81144e84:	e0bffc15 	stw	r2,-16(fp)
81144e88:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
81144e8c:	e0fffc17 	ldw	r3,-16(fp)
81144e90:	e0bff917 	ldw	r2,-28(fp)
81144e94:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81144e98:	e0fffd17 	ldw	r3,-12(fp)
81144e9c:	e0bff917 	ldw	r2,-28(fp)
81144ea0:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
81144ea4:	e0fffa17 	ldw	r3,-24(fp)
81144ea8:	e0bfff17 	ldw	r2,-4(fp)
81144eac:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
81144eb0:	e0fffb17 	ldw	r3,-20(fp)
81144eb4:	e0bfff17 	ldw	r2,-4(fp)
81144eb8:	10c00b15 	stw	r3,44(r2)
	return 0;
81144ebc:	0005883a 	mov	r2,zero
}
81144ec0:	e037883a 	mov	sp,fp
81144ec4:	df000017 	ldw	fp,0(sp)
81144ec8:	dec00104 	addi	sp,sp,4
81144ecc:	f800283a 	ret

81144ed0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
81144ed0:	defffc04 	addi	sp,sp,-16
81144ed4:	de00012e 	bgeu	sp,et,81144edc <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
81144ed8:	003b68fa 	trap	3
81144edc:	df000315 	stw	fp,12(sp)
81144ee0:	df000304 	addi	fp,sp,12
81144ee4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81144ee8:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
81144eec:	e0bfff17 	ldw	r2,-4(fp)
81144ef0:	1000021e 	bne	r2,zero,81144efc <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81144ef4:	00bffa84 	movi	r2,-22
81144ef8:	00001906 	br	81144f60 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81144efc:	e0bfff17 	ldw	r2,-4(fp)
81144f00:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81144f04:	00000a06 	br	81144f30 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
81144f08:	e0bffd17 	ldw	r2,-12(fp)
81144f0c:	10800717 	ldw	r2,28(r2)
81144f10:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81144f14:	e0bffe17 	ldw	r2,-8(fp)
81144f18:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81144f1c:	e0bffd17 	ldw	r2,-12(fp)
81144f20:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81144f24:	e0bffd17 	ldw	r2,-12(fp)
81144f28:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
81144f2c:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81144f30:	e0bffd17 	ldw	r2,-12(fp)
81144f34:	10c00317 	ldw	r3,12(r2)
81144f38:	e0bfff17 	ldw	r2,-4(fp)
81144f3c:	18bff21e 	bne	r3,r2,81144f08 <__reset+0xfb124f08>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
81144f40:	e0bffd17 	ldw	r2,-12(fp)
81144f44:	10800717 	ldw	r2,28(r2)
81144f48:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81144f4c:	e0bffe17 	ldw	r2,-8(fp)
81144f50:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81144f54:	e0bffd17 	ldw	r2,-12(fp)
81144f58:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
81144f5c:	0005883a 	mov	r2,zero
}
81144f60:	e037883a 	mov	sp,fp
81144f64:	df000017 	ldw	fp,0(sp)
81144f68:	dec00104 	addi	sp,sp,4
81144f6c:	f800283a 	ret

81144f70 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
81144f70:	defff804 	addi	sp,sp,-32
81144f74:	de00012e 	bgeu	sp,et,81144f7c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81144f78:	003b68fa 	trap	3
81144f7c:	df000715 	stw	fp,28(sp)
81144f80:	df000704 	addi	fp,sp,28
81144f84:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81144f88:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
81144f8c:	e13fff17 	ldw	r4,-4(fp)
81144f90:	2000021e 	bne	r4,zero,81144f9c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81144f94:	00bffa84 	movi	r2,-22
81144f98:	00002806 	br	8114503c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81144f9c:	e13fff17 	ldw	r4,-4(fp)
81144fa0:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
81144fa4:	e13fff17 	ldw	r4,-4(fp)
81144fa8:	2005883a 	mov	r2,r4
81144fac:	0007883a 	mov	r3,zero
81144fb0:	e0bffb15 	stw	r2,-20(fp)
81144fb4:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81144fb8:	00001006 	br	81144ffc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
81144fbc:	e0bff917 	ldw	r2,-28(fp)
81144fc0:	10800f17 	ldw	r2,60(r2)
81144fc4:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81144fc8:	e0bffa17 	ldw	r2,-24(fp)
81144fcc:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81144fd0:	e0bff917 	ldw	r2,-28(fp)
81144fd4:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81144fd8:	e0bff917 	ldw	r2,-28(fp)
81144fdc:	10800317 	ldw	r2,12(r2)
81144fe0:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81144fe4:	e0bff917 	ldw	r2,-28(fp)
81144fe8:	10800b17 	ldw	r2,44(r2)
81144fec:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81144ff0:	e0bffd17 	ldw	r2,-12(fp)
81144ff4:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81144ff8:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81144ffc:	e0bff917 	ldw	r2,-28(fp)
81145000:	10c00317 	ldw	r3,12(r2)
81145004:	e0bffb17 	ldw	r2,-20(fp)
81145008:	18800426 	beq	r3,r2,8114501c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114500c:	e0bff917 	ldw	r2,-28(fp)
81145010:	10c00b17 	ldw	r3,44(r2)
81145014:	e0bffc17 	ldw	r2,-16(fp)
81145018:	18bfe81e 	bne	r3,r2,81144fbc <__reset+0xfb124fbc>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8114501c:	e0bff917 	ldw	r2,-28(fp)
81145020:	10800f17 	ldw	r2,60(r2)
81145024:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81145028:	e0bffa17 	ldw	r2,-24(fp)
8114502c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81145030:	e0bff917 	ldw	r2,-28(fp)
81145034:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
81145038:	0005883a 	mov	r2,zero
}
8114503c:	e037883a 	mov	sp,fp
81145040:	df000017 	ldw	fp,0(sp)
81145044:	dec00104 	addi	sp,sp,4
81145048:	f800283a 	ret

8114504c <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114504c:	deffeb04 	addi	sp,sp,-84
81145050:	de00012e 	bgeu	sp,et,81145058 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
81145054:	003b68fa 	trap	3
81145058:	dfc01415 	stw	ra,80(sp)
8114505c:	df001315 	stw	fp,76(sp)
81145060:	df001304 	addi	fp,sp,76
81145064:	e13ffb15 	stw	r4,-20(fp)
81145068:	e17ffc15 	stw	r5,-16(fp)
8114506c:	e1bffd15 	stw	r6,-12(fp)
81145070:	3807883a 	mov	r3,r7
81145074:	e0800217 	ldw	r2,8(fp)
81145078:	e0fffe05 	stb	r3,-8(fp)
8114507c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
81145080:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
81145084:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81145088:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8114508c:	e0bffc17 	ldw	r2,-16(fp)
81145090:	e0bff815 	stw	r2,-32(fp)
81145094:	e0bffd17 	ldw	r2,-12(fp)
81145098:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114509c:	e0bffb17 	ldw	r2,-20(fp)
811450a0:	10801817 	ldw	r2,96(r2)
811450a4:	e0bff615 	stw	r2,-40(fp)
811450a8:	e03ff70d 	sth	zero,-36(fp)
811450ac:	e0bff70b 	ldhu	r2,-36(fp)
811450b0:	e0fffa04 	addi	r3,fp,-24
811450b4:	180d883a 	mov	r6,r3
811450b8:	100b883a 	mov	r5,r2
811450bc:	e13ff617 	ldw	r4,-40(fp)
811450c0:	113a1f80 	call	8113a1f8 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
811450c4:	e0bffb17 	ldw	r2,-20(fp)
811450c8:	10800617 	ldw	r2,24(r2)
811450cc:	10800037 	ldwio	r2,0(r2)
811450d0:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
811450d4:	e0bfed17 	ldw	r2,-76(fp)
811450d8:	1080004c 	andi	r2,r2,1
811450dc:	10000626 	beq	r2,zero,811450f8 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
811450e0:	e0bffb17 	ldw	r2,-20(fp)
811450e4:	10801817 	ldw	r2,96(r2)
811450e8:	1009883a 	mov	r4,r2
811450ec:	113a5800 	call	8113a580 <OSSemPost>
		return -EBUSY;
811450f0:	00bffc04 	movi	r2,-16
811450f4:	00009606 	br	81145350 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811450f8:	00800804 	movi	r2,32
811450fc:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145100:	0005303a 	rdctl	r2,status
81145104:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145108:	e0fff217 	ldw	r3,-56(fp)
8114510c:	00bfff84 	movi	r2,-2
81145110:	1884703a 	and	r2,r3,r2
81145114:	1001703a 	wrctl	status,r2
  
  return context;
81145118:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114511c:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81145120:	e0bffb17 	ldw	r2,-20(fp)
81145124:	10800317 	ldw	r2,12(r2)
81145128:	10800104 	addi	r2,r2,4
8114512c:	e0ffee17 	ldw	r3,-72(fp)
81145130:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
81145134:	e0bffb17 	ldw	r2,-20(fp)
81145138:	10800317 	ldw	r2,12(r2)
8114513c:	e0fffb17 	ldw	r3,-20(fp)
81145140:	18c00317 	ldw	r3,12(r3)
81145144:	18c00037 	ldwio	r3,0(r3)
81145148:	10c00035 	stwio	r3,0(r2)
8114514c:	e0bfef17 	ldw	r2,-68(fp)
81145150:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145154:	e0bff017 	ldw	r2,-64(fp)
81145158:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8114515c:	e0bffb17 	ldw	r2,-20(fp)
81145160:	10800b17 	ldw	r2,44(r2)
81145164:	10002326 	beq	r2,zero,811451f4 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81145168:	e0bffb17 	ldw	r2,-20(fp)
8114516c:	10c00d17 	ldw	r3,52(r2)
81145170:	e0bfee17 	ldw	r2,-72(fp)
81145174:	1884b03a 	or	r2,r3,r2
81145178:	10800514 	ori	r2,r2,20
8114517c:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81145180:	e0ffee17 	ldw	r3,-72(fp)
81145184:	00bff7c4 	movi	r2,-33
81145188:	1884703a 	and	r2,r3,r2
8114518c:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81145190:	e0bfed17 	ldw	r2,-76(fp)
81145194:	10800214 	ori	r2,r2,8
81145198:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114519c:	0005303a 	rdctl	r2,status
811451a0:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811451a4:	e0fff417 	ldw	r3,-48(fp)
811451a8:	00bfff84 	movi	r2,-2
811451ac:	1884703a 	and	r2,r3,r2
811451b0:	1001703a 	wrctl	status,r2
  
  return context;
811451b4:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
811451b8:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811451bc:	e0bffb17 	ldw	r2,-20(fp)
811451c0:	10800317 	ldw	r2,12(r2)
811451c4:	10800104 	addi	r2,r2,4
811451c8:	e0ffee17 	ldw	r3,-72(fp)
811451cc:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811451d0:	e0bffb17 	ldw	r2,-20(fp)
811451d4:	10800617 	ldw	r2,24(r2)
811451d8:	e0ffed17 	ldw	r3,-76(fp)
811451dc:	10c00035 	stwio	r3,0(r2)
811451e0:	e0bfef17 	ldw	r2,-68(fp)
811451e4:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811451e8:	e0bff117 	ldw	r2,-60(fp)
811451ec:	1001703a 	wrctl	status,r2
811451f0:	00002306 	br	81145280 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
811451f4:	e0bffb17 	ldw	r2,-20(fp)
811451f8:	10c00d17 	ldw	r3,52(r2)
811451fc:	e0bfee17 	ldw	r2,-72(fp)
81145200:	1884b03a 	or	r2,r3,r2
81145204:	10800114 	ori	r2,r2,4
81145208:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8114520c:	e0ffee17 	ldw	r3,-72(fp)
81145210:	00bff3c4 	movi	r2,-49
81145214:	1884703a 	and	r2,r3,r2
81145218:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8114521c:	e0ffed17 	ldw	r3,-76(fp)
81145220:	00bffdc4 	movi	r2,-9
81145224:	1884703a 	and	r2,r3,r2
81145228:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114522c:	0005303a 	rdctl	r2,status
81145230:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145234:	e0fff517 	ldw	r3,-44(fp)
81145238:	00bfff84 	movi	r2,-2
8114523c:	1884703a 	and	r2,r3,r2
81145240:	1001703a 	wrctl	status,r2
  
  return context;
81145244:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81145248:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114524c:	e0bffb17 	ldw	r2,-20(fp)
81145250:	10800317 	ldw	r2,12(r2)
81145254:	10800104 	addi	r2,r2,4
81145258:	e0ffee17 	ldw	r3,-72(fp)
8114525c:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81145260:	e0bffb17 	ldw	r2,-20(fp)
81145264:	10800617 	ldw	r2,24(r2)
81145268:	e0ffed17 	ldw	r3,-76(fp)
8114526c:	10c00035 	stwio	r3,0(r2)
81145270:	e0bfef17 	ldw	r2,-68(fp)
81145274:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145278:	e0bff317 	ldw	r2,-52(fp)
8114527c:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81145280:	e0bffb17 	ldw	r2,-20(fp)
81145284:	10800617 	ldw	r2,24(r2)
81145288:	10800104 	addi	r2,r2,4
8114528c:	e0fff817 	ldw	r3,-32(fp)
81145290:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81145294:	e0bffb17 	ldw	r2,-20(fp)
81145298:	10800617 	ldw	r2,24(r2)
8114529c:	10800204 	addi	r2,r2,8
811452a0:	e0fff917 	ldw	r3,-28(fp)
811452a4:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
811452a8:	e0bffe03 	ldbu	r2,-8(fp)
811452ac:	10000426 	beq	r2,zero,811452c0 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
811452b0:	e0bfed17 	ldw	r2,-76(fp)
811452b4:	10800414 	ori	r2,r2,16
811452b8:	e0bfed15 	stw	r2,-76(fp)
811452bc:	00000406 	br	811452d0 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
811452c0:	e0ffed17 	ldw	r3,-76(fp)
811452c4:	00bffbc4 	movi	r2,-17
811452c8:	1884703a 	and	r2,r3,r2
811452cc:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
811452d0:	e0bfff03 	ldbu	r2,-4(fp)
811452d4:	10000e26 	beq	r2,zero,81145310 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
811452d8:	e0bfed17 	ldw	r2,-76(fp)
811452dc:	10800094 	ori	r2,r2,2
811452e0:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
811452e4:	e0bffb17 	ldw	r2,-20(fp)
811452e8:	10800617 	ldw	r2,24(r2)
811452ec:	10800304 	addi	r2,r2,12
811452f0:	10800037 	ldwio	r2,0(r2)
811452f4:	10000a1e 	bne	r2,zero,81145320 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
811452f8:	e0bffb17 	ldw	r2,-20(fp)
811452fc:	10800617 	ldw	r2,24(r2)
81145300:	10800304 	addi	r2,r2,12
81145304:	00c03fc4 	movi	r3,255
81145308:	10c00035 	stwio	r3,0(r2)
8114530c:	00000406 	br	81145320 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81145310:	e0ffed17 	ldw	r3,-76(fp)
81145314:	00bfff44 	movi	r2,-3
81145318:	1884703a 	and	r2,r3,r2
8114531c:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
81145320:	e0bfed17 	ldw	r2,-76(fp)
81145324:	10800054 	ori	r2,r2,1
81145328:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114532c:	e0bffb17 	ldw	r2,-20(fp)
81145330:	10800617 	ldw	r2,24(r2)
81145334:	e0ffed17 	ldw	r3,-76(fp)
81145338:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
8114533c:	e0bffb17 	ldw	r2,-20(fp)
81145340:	10801817 	ldw	r2,96(r2)
81145344:	1009883a 	mov	r4,r2
81145348:	113a5800 	call	8113a580 <OSSemPost>
	 
	 return 0;
8114534c:	0005883a 	mov	r2,zero
}
81145350:	e037883a 	mov	sp,fp
81145354:	dfc00117 	ldw	ra,4(sp)
81145358:	df000017 	ldw	fp,0(sp)
8114535c:	dec00204 	addi	sp,sp,8
81145360:	f800283a 	ret

81145364 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
81145364:	defff704 	addi	sp,sp,-36
81145368:	de00012e 	bgeu	sp,et,81145370 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8114536c:	003b68fa 	trap	3
81145370:	dfc00815 	stw	ra,32(sp)
81145374:	df000715 	stw	fp,28(sp)
81145378:	dc400615 	stw	r17,24(sp)
8114537c:	dc000515 	stw	r16,20(sp)
81145380:	df000704 	addi	fp,sp,28
81145384:	e13ffa15 	stw	r4,-24(fp)
81145388:	e17ffb15 	stw	r5,-20(fp)
8114538c:	3007883a 	mov	r3,r6
81145390:	3805883a 	mov	r2,r7
81145394:	e0fffc05 	stb	r3,-16(fp)
81145398:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8114539c:	e13ffb17 	ldw	r4,-20(fp)
811453a0:	1144ed00 	call	81144ed0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
811453a4:	10000226 	beq	r2,zero,811453b0 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
811453a8:	00bffa84 	movi	r2,-22
811453ac:	00000b06 	br	811453dc <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
811453b0:	e0bffb17 	ldw	r2,-20(fp)
811453b4:	1021883a 	mov	r16,r2
811453b8:	0023883a 	mov	r17,zero
811453bc:	e0fffc03 	ldbu	r3,-16(fp)
811453c0:	e0bffd03 	ldbu	r2,-12(fp)
811453c4:	d8800015 	stw	r2,0(sp)
811453c8:	180f883a 	mov	r7,r3
811453cc:	800b883a 	mov	r5,r16
811453d0:	880d883a 	mov	r6,r17
811453d4:	e13ffa17 	ldw	r4,-24(fp)
811453d8:	114504c0 	call	8114504c <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
811453dc:	e6fffe04 	addi	sp,fp,-8
811453e0:	dfc00317 	ldw	ra,12(sp)
811453e4:	df000217 	ldw	fp,8(sp)
811453e8:	dc400117 	ldw	r17,4(sp)
811453ec:	dc000017 	ldw	r16,0(sp)
811453f0:	dec00404 	addi	sp,sp,16
811453f4:	f800283a 	ret

811453f8 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
811453f8:	defff704 	addi	sp,sp,-36
811453fc:	de00012e 	bgeu	sp,et,81145404 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81145400:	003b68fa 	trap	3
81145404:	dfc00815 	stw	ra,32(sp)
81145408:	df000715 	stw	fp,28(sp)
8114540c:	dc400615 	stw	r17,24(sp)
81145410:	dc000515 	stw	r16,20(sp)
81145414:	df000704 	addi	fp,sp,28
81145418:	e13ffa15 	stw	r4,-24(fp)
8114541c:	e17ffb15 	stw	r5,-20(fp)
81145420:	3007883a 	mov	r3,r6
81145424:	3805883a 	mov	r2,r7
81145428:	e0fffc05 	stb	r3,-16(fp)
8114542c:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81145430:	e13ffb17 	ldw	r4,-20(fp)
81145434:	1144f700 	call	81144f70 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81145438:	10000226 	beq	r2,zero,81145444 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
8114543c:	00bffa84 	movi	r2,-22
81145440:	00000b06 	br	81145470 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81145444:	e0bffb17 	ldw	r2,-20(fp)
81145448:	1021883a 	mov	r16,r2
8114544c:	0023883a 	mov	r17,zero
81145450:	e0fffc03 	ldbu	r3,-16(fp)
81145454:	e0bffd03 	ldbu	r2,-12(fp)
81145458:	d8800015 	stw	r2,0(sp)
8114545c:	180f883a 	mov	r7,r3
81145460:	800b883a 	mov	r5,r16
81145464:	880d883a 	mov	r6,r17
81145468:	e13ffa17 	ldw	r4,-24(fp)
8114546c:	114504c0 	call	8114504c <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81145470:	e6fffe04 	addi	sp,fp,-8
81145474:	dfc00317 	ldw	ra,12(sp)
81145478:	df000217 	ldw	fp,8(sp)
8114547c:	dc400117 	ldw	r17,4(sp)
81145480:	dc000017 	ldw	r16,0(sp)
81145484:	dec00404 	addi	sp,sp,16
81145488:	f800283a 	ret

8114548c <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8114548c:	defffc04 	addi	sp,sp,-16
81145490:	de00012e 	bgeu	sp,et,81145498 <alt_msgdma_open+0xc>
81145494:	003b68fa 	trap	3
81145498:	dfc00315 	stw	ra,12(sp)
8114549c:	df000215 	stw	fp,8(sp)
811454a0:	df000204 	addi	fp,sp,8
811454a4:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
811454a8:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
811454ac:	d1603504 	addi	r5,gp,-32556
811454b0:	e13fff17 	ldw	r4,-4(fp)
811454b4:	1145a300 	call	81145a30 <alt_find_dev>
811454b8:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
811454bc:	e0bffe17 	ldw	r2,-8(fp)
811454c0:	1000041e 	bne	r2,zero,811454d4 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
811454c4:	11436f00 	call	811436f0 <alt_get_errno>
811454c8:	1007883a 	mov	r3,r2
811454cc:	008004c4 	movi	r2,19
811454d0:	18800015 	stw	r2,0(r3)
    }

    return dev;
811454d4:	e0bffe17 	ldw	r2,-8(fp)
}
811454d8:	e037883a 	mov	sp,fp
811454dc:	dfc00117 	ldw	ra,4(sp)
811454e0:	df000017 	ldw	fp,0(sp)
811454e4:	dec00204 	addi	sp,sp,8
811454e8:	f800283a 	ret

811454ec <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
811454ec:	defff604 	addi	sp,sp,-40
811454f0:	de00012e 	bgeu	sp,et,811454f8 <alt_msgdma_init+0xc>
811454f4:	003b68fa 	trap	3
811454f8:	dfc00915 	stw	ra,36(sp)
811454fc:	df000815 	stw	fp,32(sp)
81145500:	df000804 	addi	fp,sp,32
81145504:	e13ffd15 	stw	r4,-12(fp)
81145508:	e17ffe15 	stw	r5,-8(fp)
8114550c:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81145510:	e0bffd17 	ldw	r2,-12(fp)
81145514:	10801783 	ldbu	r2,94(r2)
81145518:	10803fcc 	andi	r2,r2,255
8114551c:	10000b26 	beq	r2,zero,8114554c <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81145520:	e0bffd17 	ldw	r2,-12(fp)
81145524:	10800617 	ldw	r2,24(r2)
81145528:	00c00104 	movi	r3,4
8114552c:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
81145530:	0001883a 	nop
81145534:	e0bffd17 	ldw	r2,-12(fp)
81145538:	10800617 	ldw	r2,24(r2)
8114553c:	10800037 	ldwio	r2,0(r2)
81145540:	1080010c 	andi	r2,r2,4
81145544:	1005d0ba 	srai	r2,r2,2
81145548:	103ffa1e 	bne	r2,zero,81145534 <__reset+0xfb125534>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8114554c:	e0bffd17 	ldw	r2,-12(fp)
81145550:	10800317 	ldw	r2,12(r2)
81145554:	10800104 	addi	r2,r2,4
81145558:	00c00084 	movi	r3,2
8114555c:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81145560:	0001883a 	nop
81145564:	e0bffd17 	ldw	r2,-12(fp)
81145568:	10800317 	ldw	r2,12(r2)
8114556c:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81145570:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81145574:	103ffb1e 	bne	r2,zero,81145564 <__reset+0xfb125564>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81145578:	e0bffd17 	ldw	r2,-12(fp)
8114557c:	10800317 	ldw	r2,12(r2)
81145580:	10800104 	addi	r2,r2,4
81145584:	10800037 	ldwio	r2,0(r2)
81145588:	1007883a 	mov	r3,r2
8114558c:	00bffbc4 	movi	r2,-17
81145590:	1884703a 	and	r2,r3,r2
81145594:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81145598:	e0bff917 	ldw	r2,-28(fp)
8114559c:	10800814 	ori	r2,r2,32
811455a0:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
811455a4:	e0bffd17 	ldw	r2,-12(fp)
811455a8:	10800317 	ldw	r2,12(r2)
811455ac:	10800104 	addi	r2,r2,4
811455b0:	e0fff917 	ldw	r3,-28(fp)
811455b4:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
811455b8:	e0bffd17 	ldw	r2,-12(fp)
811455bc:	10800317 	ldw	r2,12(r2)
811455c0:	e0fffd17 	ldw	r3,-12(fp)
811455c4:	18c00317 	ldw	r3,12(r3)
811455c8:	18c00037 	ldwio	r3,0(r3)
811455cc:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
811455d0:	e0bffd17 	ldw	r2,-12(fp)
811455d4:	10801783 	ldbu	r2,94(r2)
811455d8:	10803fcc 	andi	r2,r2,255
811455dc:	10000826 	beq	r2,zero,81145600 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
811455e0:	e0bffd17 	ldw	r2,-12(fp)
811455e4:	10800617 	ldw	r2,24(r2)
811455e8:	10800404 	addi	r2,r2,16
811455ec:	e0fffd17 	ldw	r3,-12(fp)
811455f0:	18c00617 	ldw	r3,24(r3)
811455f4:	18c00404 	addi	r3,r3,16
811455f8:	18c00037 	ldwio	r3,0(r3)
811455fc:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81145600:	d1603504 	addi	r5,gp,-32556
81145604:	e13ffd17 	ldw	r4,-12(fp)
81145608:	11459840 	call	81145984 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8114560c:	e0bffd17 	ldw	r2,-12(fp)
81145610:	10801804 	addi	r2,r2,96
81145614:	e0bffb15 	stw	r2,-20(fp)
81145618:	00800044 	movi	r2,1
8114561c:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81145620:	e0bffc0b 	ldhu	r2,-16(fp)
81145624:	1009883a 	mov	r4,r2
81145628:	1139ed00 	call	81139ed0 <OSSemCreate>
8114562c:	1007883a 	mov	r3,r2
81145630:	e0bffb17 	ldw	r2,-20(fp)
81145634:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81145638:	e0bffb17 	ldw	r2,-20(fp)
8114563c:	10800017 	ldw	r2,0(r2)
81145640:	10000226 	beq	r2,zero,8114564c <alt_msgdma_init+0x160>
81145644:	0005883a 	mov	r2,zero
81145648:	00000106 	br	81145650 <alt_msgdma_init+0x164>
8114564c:	00bfffc4 	movi	r2,-1
81145650:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81145654:	e0bffa17 	ldw	r2,-24(fp)
81145658:	1000081e 	bne	r2,zero,8114567c <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8114565c:	d8000015 	stw	zero,0(sp)
81145660:	e1fffd17 	ldw	r7,-12(fp)
81145664:	01a04534 	movhi	r6,33044
81145668:	318e4104 	addi	r6,r6,14596
8114566c:	e17fff17 	ldw	r5,-4(fp)
81145670:	e13ffe17 	ldw	r4,-8(fp)
81145674:	1145cbc0 	call	81145cbc <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81145678:	00000406 	br	8114568c <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8114567c:	01204574 	movhi	r4,33045
81145680:	21304f04 	addi	r4,r4,-16068
81145684:	11460d40 	call	811460d4 <alt_printf>
    }
    
    return;
81145688:	0001883a 	nop

}
8114568c:	e037883a 	mov	sp,fp
81145690:	dfc00117 	ldw	ra,4(sp)
81145694:	df000017 	ldw	fp,0(sp)
81145698:	dec00204 	addi	sp,sp,8
8114569c:	f800283a 	ret

811456a0 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
811456a0:	defffb04 	addi	sp,sp,-20
811456a4:	de00012e 	bgeu	sp,et,811456ac <alt_msgdma_register_callback+0xc>
811456a8:	003b68fa 	trap	3
811456ac:	df000415 	stw	fp,16(sp)
811456b0:	df000404 	addi	fp,sp,16
811456b4:	e13ffc15 	stw	r4,-16(fp)
811456b8:	e17ffd15 	stw	r5,-12(fp)
811456bc:	e1bffe15 	stw	r6,-8(fp)
811456c0:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
811456c4:	e0bffc17 	ldw	r2,-16(fp)
811456c8:	e0fffd17 	ldw	r3,-12(fp)
811456cc:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
811456d0:	e0bffc17 	ldw	r2,-16(fp)
811456d4:	e0ffff17 	ldw	r3,-4(fp)
811456d8:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
811456dc:	e0bffc17 	ldw	r2,-16(fp)
811456e0:	e0fffe17 	ldw	r3,-8(fp)
811456e4:	10c00d15 	stw	r3,52(r2)

    return ;
811456e8:	0001883a 	nop
}
811456ec:	e037883a 	mov	sp,fp
811456f0:	df000017 	ldw	fp,0(sp)
811456f4:	dec00104 	addi	sp,sp,4
811456f8:	f800283a 	ret

811456fc <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
811456fc:	defffc04 	addi	sp,sp,-16
81145700:	de00012e 	bgeu	sp,et,81145708 <alt_msgdma_standard_descriptor_async_transfer+0xc>
81145704:	003b68fa 	trap	3
81145708:	dfc00315 	stw	ra,12(sp)
8114570c:	df000215 	stw	fp,8(sp)
81145710:	df000204 	addi	fp,sp,8
81145714:	e13ffe15 	stw	r4,-8(fp)
81145718:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8114571c:	000d883a 	mov	r6,zero
81145720:	e17fff17 	ldw	r5,-4(fp)
81145724:	e13ffe17 	ldw	r4,-8(fp)
81145728:	1143c800 	call	81143c80 <alt_msgdma_descriptor_async_transfer>

}
8114572c:	e037883a 	mov	sp,fp
81145730:	dfc00117 	ldw	ra,4(sp)
81145734:	df000017 	ldw	fp,0(sp)
81145738:	dec00204 	addi	sp,sp,8
8114573c:	f800283a 	ret

81145740 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81145740:	defffc04 	addi	sp,sp,-16
81145744:	de00012e 	bgeu	sp,et,8114574c <alt_msgdma_extended_descriptor_async_transfer+0xc>
81145748:	003b68fa 	trap	3
8114574c:	dfc00315 	stw	ra,12(sp)
81145750:	df000215 	stw	fp,8(sp)
81145754:	df000204 	addi	fp,sp,8
81145758:	e13ffe15 	stw	r4,-8(fp)
8114575c:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81145760:	e1bfff17 	ldw	r6,-4(fp)
81145764:	000b883a 	mov	r5,zero
81145768:	e13ffe17 	ldw	r4,-8(fp)
8114576c:	1143c800 	call	81143c80 <alt_msgdma_descriptor_async_transfer>
}
81145770:	e037883a 	mov	sp,fp
81145774:	dfc00117 	ldw	ra,4(sp)
81145778:	df000017 	ldw	fp,0(sp)
8114577c:	dec00204 	addi	sp,sp,8
81145780:	f800283a 	ret

81145784 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81145784:	defffc04 	addi	sp,sp,-16
81145788:	de00012e 	bgeu	sp,et,81145790 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8114578c:	003b68fa 	trap	3
81145790:	dfc00315 	stw	ra,12(sp)
81145794:	df000215 	stw	fp,8(sp)
81145798:	df000204 	addi	fp,sp,8
8114579c:	e13ffe15 	stw	r4,-8(fp)
811457a0:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
811457a4:	000d883a 	mov	r6,zero
811457a8:	e17fff17 	ldw	r5,-4(fp)
811457ac:	e13ffe17 	ldw	r4,-8(fp)
811457b0:	1143fc00 	call	81143fc0 <alt_msgdma_descriptor_sync_transfer>
}
811457b4:	e037883a 	mov	sp,fp
811457b8:	dfc00117 	ldw	ra,4(sp)
811457bc:	df000017 	ldw	fp,0(sp)
811457c0:	dec00204 	addi	sp,sp,8
811457c4:	f800283a 	ret

811457c8 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
811457c8:	defffc04 	addi	sp,sp,-16
811457cc:	de00012e 	bgeu	sp,et,811457d4 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
811457d0:	003b68fa 	trap	3
811457d4:	dfc00315 	stw	ra,12(sp)
811457d8:	df000215 	stw	fp,8(sp)
811457dc:	df000204 	addi	fp,sp,8
811457e0:	e13ffe15 	stw	r4,-8(fp)
811457e4:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
811457e8:	e1bfff17 	ldw	r6,-4(fp)
811457ec:	000b883a 	mov	r5,zero
811457f0:	e13ffe17 	ldw	r4,-8(fp)
811457f4:	1143fc00 	call	81143fc0 <alt_msgdma_descriptor_sync_transfer>
}
811457f8:	e037883a 	mov	sp,fp
811457fc:	dfc00117 	ldw	ra,4(sp)
81145800:	df000017 	ldw	fp,0(sp)
81145804:	dec00204 	addi	sp,sp,8
81145808:	f800283a 	ret

8114580c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8114580c:	defff504 	addi	sp,sp,-44
81145810:	de00012e 	bgeu	sp,et,81145818 <alt_alarm_start+0xc>
81145814:	003b68fa 	trap	3
81145818:	df000a15 	stw	fp,40(sp)
8114581c:	df000a04 	addi	fp,sp,40
81145820:	e13ffc15 	stw	r4,-16(fp)
81145824:	e17ffd15 	stw	r5,-12(fp)
81145828:	e1bffe15 	stw	r6,-8(fp)
8114582c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
81145830:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81145834:	d0a08317 	ldw	r2,-32244(gp)
  
  if (alt_ticks_per_second ())
81145838:	10003c26 	beq	r2,zero,8114592c <alt_alarm_start+0x120>
  {
    if (alarm)
8114583c:	e0bffc17 	ldw	r2,-16(fp)
81145840:	10003826 	beq	r2,zero,81145924 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81145844:	e0bffc17 	ldw	r2,-16(fp)
81145848:	e0fffe17 	ldw	r3,-8(fp)
8114584c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
81145850:	e0bffc17 	ldw	r2,-16(fp)
81145854:	e0ffff17 	ldw	r3,-4(fp)
81145858:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114585c:	0005303a 	rdctl	r2,status
81145860:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145864:	e0fff917 	ldw	r3,-28(fp)
81145868:	00bfff84 	movi	r2,-2
8114586c:	1884703a 	and	r2,r3,r2
81145870:	1001703a 	wrctl	status,r2
  
  return context;
81145874:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81145878:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8114587c:	d0a08417 	ldw	r2,-32240(gp)
      
      current_nticks = alt_nticks();
81145880:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81145884:	e0fffd17 	ldw	r3,-12(fp)
81145888:	e0bff617 	ldw	r2,-40(fp)
8114588c:	1885883a 	add	r2,r3,r2
81145890:	10c00044 	addi	r3,r2,1
81145894:	e0bffc17 	ldw	r2,-16(fp)
81145898:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8114589c:	e0bffc17 	ldw	r2,-16(fp)
811458a0:	10c00217 	ldw	r3,8(r2)
811458a4:	e0bff617 	ldw	r2,-40(fp)
811458a8:	1880042e 	bgeu	r3,r2,811458bc <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
811458ac:	e0bffc17 	ldw	r2,-16(fp)
811458b0:	00c00044 	movi	r3,1
811458b4:	10c00405 	stb	r3,16(r2)
811458b8:	00000206 	br	811458c4 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
811458bc:	e0bffc17 	ldw	r2,-16(fp)
811458c0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
811458c4:	e0bffc17 	ldw	r2,-16(fp)
811458c8:	d0e01404 	addi	r3,gp,-32688
811458cc:	e0fffa15 	stw	r3,-24(fp)
811458d0:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811458d4:	e0bffb17 	ldw	r2,-20(fp)
811458d8:	e0fffa17 	ldw	r3,-24(fp)
811458dc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811458e0:	e0bffa17 	ldw	r2,-24(fp)
811458e4:	10c00017 	ldw	r3,0(r2)
811458e8:	e0bffb17 	ldw	r2,-20(fp)
811458ec:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811458f0:	e0bffa17 	ldw	r2,-24(fp)
811458f4:	10800017 	ldw	r2,0(r2)
811458f8:	e0fffb17 	ldw	r3,-20(fp)
811458fc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81145900:	e0bffa17 	ldw	r2,-24(fp)
81145904:	e0fffb17 	ldw	r3,-20(fp)
81145908:	10c00015 	stw	r3,0(r2)
8114590c:	e0bff817 	ldw	r2,-32(fp)
81145910:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145914:	e0bff717 	ldw	r2,-36(fp)
81145918:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8114591c:	0005883a 	mov	r2,zero
81145920:	00000306 	br	81145930 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81145924:	00bffa84 	movi	r2,-22
81145928:	00000106 	br	81145930 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8114592c:	00bfde84 	movi	r2,-134
  }
}
81145930:	e037883a 	mov	sp,fp
81145934:	df000017 	ldw	fp,0(sp)
81145938:	dec00104 	addi	sp,sp,4
8114593c:	f800283a 	ret

81145940 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81145940:	defffe04 	addi	sp,sp,-8
81145944:	de00012e 	bgeu	sp,et,8114594c <alt_get_errno+0xc>
81145948:	003b68fa 	trap	3
8114594c:	dfc00115 	stw	ra,4(sp)
81145950:	df000015 	stw	fp,0(sp)
81145954:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81145958:	d0a01017 	ldw	r2,-32704(gp)
8114595c:	10000326 	beq	r2,zero,8114596c <alt_get_errno+0x2c>
81145960:	d0a01017 	ldw	r2,-32704(gp)
81145964:	103ee83a 	callr	r2
81145968:	00000106 	br	81145970 <alt_get_errno+0x30>
8114596c:	d0a07304 	addi	r2,gp,-32308
}
81145970:	e037883a 	mov	sp,fp
81145974:	dfc00117 	ldw	ra,4(sp)
81145978:	df000017 	ldw	fp,0(sp)
8114597c:	dec00204 	addi	sp,sp,8
81145980:	f800283a 	ret

81145984 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81145984:	defffa04 	addi	sp,sp,-24
81145988:	de00012e 	bgeu	sp,et,81145990 <alt_dev_llist_insert+0xc>
8114598c:	003b68fa 	trap	3
81145990:	dfc00515 	stw	ra,20(sp)
81145994:	df000415 	stw	fp,16(sp)
81145998:	df000404 	addi	fp,sp,16
8114599c:	e13ffe15 	stw	r4,-8(fp)
811459a0:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
811459a4:	e0bffe17 	ldw	r2,-8(fp)
811459a8:	10000326 	beq	r2,zero,811459b8 <alt_dev_llist_insert+0x34>
811459ac:	e0bffe17 	ldw	r2,-8(fp)
811459b0:	10800217 	ldw	r2,8(r2)
811459b4:	1000061e 	bne	r2,zero,811459d0 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
811459b8:	11459400 	call	81145940 <alt_get_errno>
811459bc:	1007883a 	mov	r3,r2
811459c0:	00800584 	movi	r2,22
811459c4:	18800015 	stw	r2,0(r3)
    return -EINVAL;
811459c8:	00bffa84 	movi	r2,-22
811459cc:	00001306 	br	81145a1c <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
811459d0:	e0bffe17 	ldw	r2,-8(fp)
811459d4:	e0ffff17 	ldw	r3,-4(fp)
811459d8:	e0fffc15 	stw	r3,-16(fp)
811459dc:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811459e0:	e0bffd17 	ldw	r2,-12(fp)
811459e4:	e0fffc17 	ldw	r3,-16(fp)
811459e8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811459ec:	e0bffc17 	ldw	r2,-16(fp)
811459f0:	10c00017 	ldw	r3,0(r2)
811459f4:	e0bffd17 	ldw	r2,-12(fp)
811459f8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811459fc:	e0bffc17 	ldw	r2,-16(fp)
81145a00:	10800017 	ldw	r2,0(r2)
81145a04:	e0fffd17 	ldw	r3,-12(fp)
81145a08:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81145a0c:	e0bffc17 	ldw	r2,-16(fp)
81145a10:	e0fffd17 	ldw	r3,-12(fp)
81145a14:	10c00015 	stw	r3,0(r2)

  return 0;  
81145a18:	0005883a 	mov	r2,zero
}
81145a1c:	e037883a 	mov	sp,fp
81145a20:	dfc00117 	ldw	ra,4(sp)
81145a24:	df000017 	ldw	fp,0(sp)
81145a28:	dec00204 	addi	sp,sp,8
81145a2c:	f800283a 	ret

81145a30 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
81145a30:	defffa04 	addi	sp,sp,-24
81145a34:	de00012e 	bgeu	sp,et,81145a3c <alt_find_dev+0xc>
81145a38:	003b68fa 	trap	3
81145a3c:	dfc00515 	stw	ra,20(sp)
81145a40:	df000415 	stw	fp,16(sp)
81145a44:	df000404 	addi	fp,sp,16
81145a48:	e13ffe15 	stw	r4,-8(fp)
81145a4c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
81145a50:	e0bfff17 	ldw	r2,-4(fp)
81145a54:	10800017 	ldw	r2,0(r2)
81145a58:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
81145a5c:	e13ffe17 	ldw	r4,-8(fp)
81145a60:	111dcc00 	call	8111dcc0 <strlen>
81145a64:	10800044 	addi	r2,r2,1
81145a68:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81145a6c:	00000d06 	br	81145aa4 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
81145a70:	e0bffc17 	ldw	r2,-16(fp)
81145a74:	10800217 	ldw	r2,8(r2)
81145a78:	e0fffd17 	ldw	r3,-12(fp)
81145a7c:	180d883a 	mov	r6,r3
81145a80:	e17ffe17 	ldw	r5,-8(fp)
81145a84:	1009883a 	mov	r4,r2
81145a88:	11468440 	call	81146844 <memcmp>
81145a8c:	1000021e 	bne	r2,zero,81145a98 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
81145a90:	e0bffc17 	ldw	r2,-16(fp)
81145a94:	00000706 	br	81145ab4 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81145a98:	e0bffc17 	ldw	r2,-16(fp)
81145a9c:	10800017 	ldw	r2,0(r2)
81145aa0:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81145aa4:	e0fffc17 	ldw	r3,-16(fp)
81145aa8:	e0bfff17 	ldw	r2,-4(fp)
81145aac:	18bff01e 	bne	r3,r2,81145a70 <__reset+0xfb125a70>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
81145ab0:	0005883a 	mov	r2,zero
}
81145ab4:	e037883a 	mov	sp,fp
81145ab8:	dfc00117 	ldw	ra,4(sp)
81145abc:	df000017 	ldw	fp,0(sp)
81145ac0:	dec00204 	addi	sp,sp,8
81145ac4:	f800283a 	ret

81145ac8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
81145ac8:	defffb04 	addi	sp,sp,-20
81145acc:	de00012e 	bgeu	sp,et,81145ad4 <alt_find_file+0xc>
81145ad0:	003b68fa 	trap	3
81145ad4:	dfc00415 	stw	ra,16(sp)
81145ad8:	df000315 	stw	fp,12(sp)
81145adc:	df000304 	addi	fp,sp,12
81145ae0:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
81145ae4:	d0a00b17 	ldw	r2,-32724(gp)
81145ae8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81145aec:	00003106 	br	81145bb4 <alt_find_file+0xec>
  {
    len = strlen(next->name);
81145af0:	e0bffd17 	ldw	r2,-12(fp)
81145af4:	10800217 	ldw	r2,8(r2)
81145af8:	1009883a 	mov	r4,r2
81145afc:	111dcc00 	call	8111dcc0 <strlen>
81145b00:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81145b04:	e0bffd17 	ldw	r2,-12(fp)
81145b08:	10c00217 	ldw	r3,8(r2)
81145b0c:	e0bffe17 	ldw	r2,-8(fp)
81145b10:	10bfffc4 	addi	r2,r2,-1
81145b14:	1885883a 	add	r2,r3,r2
81145b18:	10800003 	ldbu	r2,0(r2)
81145b1c:	10803fcc 	andi	r2,r2,255
81145b20:	1080201c 	xori	r2,r2,128
81145b24:	10bfe004 	addi	r2,r2,-128
81145b28:	10800bd8 	cmpnei	r2,r2,47
81145b2c:	1000031e 	bne	r2,zero,81145b3c <alt_find_file+0x74>
    {
      len -= 1;
81145b30:	e0bffe17 	ldw	r2,-8(fp)
81145b34:	10bfffc4 	addi	r2,r2,-1
81145b38:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81145b3c:	e0bffe17 	ldw	r2,-8(fp)
81145b40:	e0ffff17 	ldw	r3,-4(fp)
81145b44:	1885883a 	add	r2,r3,r2
81145b48:	10800003 	ldbu	r2,0(r2)
81145b4c:	10803fcc 	andi	r2,r2,255
81145b50:	1080201c 	xori	r2,r2,128
81145b54:	10bfe004 	addi	r2,r2,-128
81145b58:	10800be0 	cmpeqi	r2,r2,47
81145b5c:	1000081e 	bne	r2,zero,81145b80 <alt_find_file+0xb8>
81145b60:	e0bffe17 	ldw	r2,-8(fp)
81145b64:	e0ffff17 	ldw	r3,-4(fp)
81145b68:	1885883a 	add	r2,r3,r2
81145b6c:	10800003 	ldbu	r2,0(r2)
81145b70:	10803fcc 	andi	r2,r2,255
81145b74:	1080201c 	xori	r2,r2,128
81145b78:	10bfe004 	addi	r2,r2,-128
81145b7c:	10000a1e 	bne	r2,zero,81145ba8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
81145b80:	e0bffd17 	ldw	r2,-12(fp)
81145b84:	10800217 	ldw	r2,8(r2)
81145b88:	e0fffe17 	ldw	r3,-8(fp)
81145b8c:	180d883a 	mov	r6,r3
81145b90:	e17fff17 	ldw	r5,-4(fp)
81145b94:	1009883a 	mov	r4,r2
81145b98:	11468440 	call	81146844 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81145b9c:	1000021e 	bne	r2,zero,81145ba8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
81145ba0:	e0bffd17 	ldw	r2,-12(fp)
81145ba4:	00000706 	br	81145bc4 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
81145ba8:	e0bffd17 	ldw	r2,-12(fp)
81145bac:	10800017 	ldw	r2,0(r2)
81145bb0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81145bb4:	e0fffd17 	ldw	r3,-12(fp)
81145bb8:	d0a00b04 	addi	r2,gp,-32724
81145bbc:	18bfcc1e 	bne	r3,r2,81145af0 <__reset+0xfb125af0>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
81145bc0:	0005883a 	mov	r2,zero
}
81145bc4:	e037883a 	mov	sp,fp
81145bc8:	dfc00117 	ldw	ra,4(sp)
81145bcc:	df000017 	ldw	fp,0(sp)
81145bd0:	dec00204 	addi	sp,sp,8
81145bd4:	f800283a 	ret

81145bd8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
81145bd8:	defff904 	addi	sp,sp,-28
81145bdc:	de00012e 	bgeu	sp,et,81145be4 <alt_get_fd+0xc>
81145be0:	003b68fa 	trap	3
81145be4:	dfc00615 	stw	ra,24(sp)
81145be8:	df000515 	stw	fp,20(sp)
81145bec:	df000504 	addi	fp,sp,20
81145bf0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
81145bf4:	00bffa04 	movi	r2,-24
81145bf8:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
81145bfc:	d0a07a17 	ldw	r2,-32280(gp)
81145c00:	e0bffd15 	stw	r2,-12(fp)
81145c04:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81145c08:	e0bffe0b 	ldhu	r2,-8(fp)
81145c0c:	e0fffe84 	addi	r3,fp,-6
81145c10:	180d883a 	mov	r6,r3
81145c14:	100b883a 	mov	r5,r2
81145c18:	e13ffd17 	ldw	r4,-12(fp)
81145c1c:	113a1f80 	call	8113a1f8 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81145c20:	e03ffb15 	stw	zero,-20(fp)
81145c24:	00001906 	br	81145c8c <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81145c28:	00a04574 	movhi	r2,33045
81145c2c:	10b2be04 	addi	r2,r2,-13576
81145c30:	e0fffb17 	ldw	r3,-20(fp)
81145c34:	18c00324 	muli	r3,r3,12
81145c38:	10c5883a 	add	r2,r2,r3
81145c3c:	10800017 	ldw	r2,0(r2)
81145c40:	10000f1e 	bne	r2,zero,81145c80 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81145c44:	00a04574 	movhi	r2,33045
81145c48:	10b2be04 	addi	r2,r2,-13576
81145c4c:	e0fffb17 	ldw	r3,-20(fp)
81145c50:	18c00324 	muli	r3,r3,12
81145c54:	10c5883a 	add	r2,r2,r3
81145c58:	e0ffff17 	ldw	r3,-4(fp)
81145c5c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
81145c60:	d0e00f17 	ldw	r3,-32708(gp)
81145c64:	e0bffb17 	ldw	r2,-20(fp)
81145c68:	1880020e 	bge	r3,r2,81145c74 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
81145c6c:	e0bffb17 	ldw	r2,-20(fp)
81145c70:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81145c74:	e0bffb17 	ldw	r2,-20(fp)
81145c78:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
81145c7c:	00000606 	br	81145c98 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81145c80:	e0bffb17 	ldw	r2,-20(fp)
81145c84:	10800044 	addi	r2,r2,1
81145c88:	e0bffb15 	stw	r2,-20(fp)
81145c8c:	e0bffb17 	ldw	r2,-20(fp)
81145c90:	10800810 	cmplti	r2,r2,32
81145c94:	103fe41e 	bne	r2,zero,81145c28 <__reset+0xfb125c28>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81145c98:	d0a07a17 	ldw	r2,-32280(gp)
81145c9c:	1009883a 	mov	r4,r2
81145ca0:	113a5800 	call	8113a580 <OSSemPost>

  return rc;
81145ca4:	e0bffc17 	ldw	r2,-16(fp)
}
81145ca8:	e037883a 	mov	sp,fp
81145cac:	dfc00117 	ldw	ra,4(sp)
81145cb0:	df000017 	ldw	fp,0(sp)
81145cb4:	dec00204 	addi	sp,sp,8
81145cb8:	f800283a 	ret

81145cbc <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81145cbc:	defff904 	addi	sp,sp,-28
81145cc0:	de00012e 	bgeu	sp,et,81145cc8 <alt_ic_isr_register+0xc>
81145cc4:	003b68fa 	trap	3
81145cc8:	dfc00615 	stw	ra,24(sp)
81145ccc:	df000515 	stw	fp,20(sp)
81145cd0:	df000504 	addi	fp,sp,20
81145cd4:	e13ffc15 	stw	r4,-16(fp)
81145cd8:	e17ffd15 	stw	r5,-12(fp)
81145cdc:	e1bffe15 	stw	r6,-8(fp)
81145ce0:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
81145ce4:	e0800217 	ldw	r2,8(fp)
81145ce8:	d8800015 	stw	r2,0(sp)
81145cec:	e1ffff17 	ldw	r7,-4(fp)
81145cf0:	e1bffe17 	ldw	r6,-8(fp)
81145cf4:	e17ffd17 	ldw	r5,-12(fp)
81145cf8:	e13ffc17 	ldw	r4,-16(fp)
81145cfc:	1145e8c0 	call	81145e8c <alt_iic_isr_register>
}  
81145d00:	e037883a 	mov	sp,fp
81145d04:	dfc00117 	ldw	ra,4(sp)
81145d08:	df000017 	ldw	fp,0(sp)
81145d0c:	dec00204 	addi	sp,sp,8
81145d10:	f800283a 	ret

81145d14 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
81145d14:	defff904 	addi	sp,sp,-28
81145d18:	de00012e 	bgeu	sp,et,81145d20 <alt_ic_irq_enable+0xc>
81145d1c:	003b68fa 	trap	3
81145d20:	df000615 	stw	fp,24(sp)
81145d24:	df000604 	addi	fp,sp,24
81145d28:	e13ffe15 	stw	r4,-8(fp)
81145d2c:	e17fff15 	stw	r5,-4(fp)
81145d30:	e0bfff17 	ldw	r2,-4(fp)
81145d34:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145d38:	0005303a 	rdctl	r2,status
81145d3c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145d40:	e0fffb17 	ldw	r3,-20(fp)
81145d44:	00bfff84 	movi	r2,-2
81145d48:	1884703a 	and	r2,r3,r2
81145d4c:	1001703a 	wrctl	status,r2
  
  return context;
81145d50:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81145d54:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
81145d58:	00c00044 	movi	r3,1
81145d5c:	e0bffa17 	ldw	r2,-24(fp)
81145d60:	1884983a 	sll	r2,r3,r2
81145d64:	1007883a 	mov	r3,r2
81145d68:	d0a07b17 	ldw	r2,-32276(gp)
81145d6c:	1884b03a 	or	r2,r3,r2
81145d70:	d0a07b15 	stw	r2,-32276(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81145d74:	d0a07b17 	ldw	r2,-32276(gp)
81145d78:	100170fa 	wrctl	ienable,r2
81145d7c:	e0bffc17 	ldw	r2,-16(fp)
81145d80:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145d84:	e0bffd17 	ldw	r2,-12(fp)
81145d88:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81145d8c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
81145d90:	0001883a 	nop
}
81145d94:	e037883a 	mov	sp,fp
81145d98:	df000017 	ldw	fp,0(sp)
81145d9c:	dec00104 	addi	sp,sp,4
81145da0:	f800283a 	ret

81145da4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
81145da4:	defff904 	addi	sp,sp,-28
81145da8:	de00012e 	bgeu	sp,et,81145db0 <alt_ic_irq_disable+0xc>
81145dac:	003b68fa 	trap	3
81145db0:	df000615 	stw	fp,24(sp)
81145db4:	df000604 	addi	fp,sp,24
81145db8:	e13ffe15 	stw	r4,-8(fp)
81145dbc:	e17fff15 	stw	r5,-4(fp)
81145dc0:	e0bfff17 	ldw	r2,-4(fp)
81145dc4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145dc8:	0005303a 	rdctl	r2,status
81145dcc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145dd0:	e0fffb17 	ldw	r3,-20(fp)
81145dd4:	00bfff84 	movi	r2,-2
81145dd8:	1884703a 	and	r2,r3,r2
81145ddc:	1001703a 	wrctl	status,r2
  
  return context;
81145de0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81145de4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
81145de8:	00c00044 	movi	r3,1
81145dec:	e0bffa17 	ldw	r2,-24(fp)
81145df0:	1884983a 	sll	r2,r3,r2
81145df4:	0084303a 	nor	r2,zero,r2
81145df8:	1007883a 	mov	r3,r2
81145dfc:	d0a07b17 	ldw	r2,-32276(gp)
81145e00:	1884703a 	and	r2,r3,r2
81145e04:	d0a07b15 	stw	r2,-32276(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81145e08:	d0a07b17 	ldw	r2,-32276(gp)
81145e0c:	100170fa 	wrctl	ienable,r2
81145e10:	e0bffc17 	ldw	r2,-16(fp)
81145e14:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145e18:	e0bffd17 	ldw	r2,-12(fp)
81145e1c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81145e20:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
81145e24:	0001883a 	nop
}
81145e28:	e037883a 	mov	sp,fp
81145e2c:	df000017 	ldw	fp,0(sp)
81145e30:	dec00104 	addi	sp,sp,4
81145e34:	f800283a 	ret

81145e38 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81145e38:	defffc04 	addi	sp,sp,-16
81145e3c:	de00012e 	bgeu	sp,et,81145e44 <alt_ic_irq_enabled+0xc>
81145e40:	003b68fa 	trap	3
81145e44:	df000315 	stw	fp,12(sp)
81145e48:	df000304 	addi	fp,sp,12
81145e4c:	e13ffe15 	stw	r4,-8(fp)
81145e50:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
81145e54:	000530fa 	rdctl	r2,ienable
81145e58:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
81145e5c:	00c00044 	movi	r3,1
81145e60:	e0bfff17 	ldw	r2,-4(fp)
81145e64:	1884983a 	sll	r2,r3,r2
81145e68:	1007883a 	mov	r3,r2
81145e6c:	e0bffd17 	ldw	r2,-12(fp)
81145e70:	1884703a 	and	r2,r3,r2
81145e74:	1004c03a 	cmpne	r2,r2,zero
81145e78:	10803fcc 	andi	r2,r2,255
}
81145e7c:	e037883a 	mov	sp,fp
81145e80:	df000017 	ldw	fp,0(sp)
81145e84:	dec00104 	addi	sp,sp,4
81145e88:	f800283a 	ret

81145e8c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81145e8c:	defff504 	addi	sp,sp,-44
81145e90:	de00012e 	bgeu	sp,et,81145e98 <alt_iic_isr_register+0xc>
81145e94:	003b68fa 	trap	3
81145e98:	dfc00a15 	stw	ra,40(sp)
81145e9c:	df000915 	stw	fp,36(sp)
81145ea0:	df000904 	addi	fp,sp,36
81145ea4:	e13ffc15 	stw	r4,-16(fp)
81145ea8:	e17ffd15 	stw	r5,-12(fp)
81145eac:	e1bffe15 	stw	r6,-8(fp)
81145eb0:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
81145eb4:	00bffa84 	movi	r2,-22
81145eb8:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
81145ebc:	e0bffd17 	ldw	r2,-12(fp)
81145ec0:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81145ec4:	e0bff817 	ldw	r2,-32(fp)
81145ec8:	10800808 	cmpgei	r2,r2,32
81145ecc:	1000271e 	bne	r2,zero,81145f6c <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145ed0:	0005303a 	rdctl	r2,status
81145ed4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145ed8:	e0fffb17 	ldw	r3,-20(fp)
81145edc:	00bfff84 	movi	r2,-2
81145ee0:	1884703a 	and	r2,r3,r2
81145ee4:	1001703a 	wrctl	status,r2
  
  return context;
81145ee8:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
81145eec:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
81145ef0:	00a045b4 	movhi	r2,33046
81145ef4:	109f9204 	addi	r2,r2,32328
81145ef8:	e0fff817 	ldw	r3,-32(fp)
81145efc:	180690fa 	slli	r3,r3,3
81145f00:	10c5883a 	add	r2,r2,r3
81145f04:	e0fffe17 	ldw	r3,-8(fp)
81145f08:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
81145f0c:	00a045b4 	movhi	r2,33046
81145f10:	109f9204 	addi	r2,r2,32328
81145f14:	e0fff817 	ldw	r3,-32(fp)
81145f18:	180690fa 	slli	r3,r3,3
81145f1c:	10c5883a 	add	r2,r2,r3
81145f20:	10800104 	addi	r2,r2,4
81145f24:	e0ffff17 	ldw	r3,-4(fp)
81145f28:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
81145f2c:	e0bffe17 	ldw	r2,-8(fp)
81145f30:	10000526 	beq	r2,zero,81145f48 <alt_iic_isr_register+0xbc>
81145f34:	e0bff817 	ldw	r2,-32(fp)
81145f38:	100b883a 	mov	r5,r2
81145f3c:	e13ffc17 	ldw	r4,-16(fp)
81145f40:	1145d140 	call	81145d14 <alt_ic_irq_enable>
81145f44:	00000406 	br	81145f58 <alt_iic_isr_register+0xcc>
81145f48:	e0bff817 	ldw	r2,-32(fp)
81145f4c:	100b883a 	mov	r5,r2
81145f50:	e13ffc17 	ldw	r4,-16(fp)
81145f54:	1145da40 	call	81145da4 <alt_ic_irq_disable>
81145f58:	e0bff715 	stw	r2,-36(fp)
81145f5c:	e0bffa17 	ldw	r2,-24(fp)
81145f60:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145f64:	e0bff917 	ldw	r2,-28(fp)
81145f68:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
81145f6c:	e0bff717 	ldw	r2,-36(fp)
}
81145f70:	e037883a 	mov	sp,fp
81145f74:	dfc00117 	ldw	ra,4(sp)
81145f78:	df000017 	ldw	fp,0(sp)
81145f7c:	dec00204 	addi	sp,sp,8
81145f80:	f800283a 	ret

81145f84 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
81145f84:	defff904 	addi	sp,sp,-28
81145f88:	de00012e 	bgeu	sp,et,81145f90 <alt_open_fd+0xc>
81145f8c:	003b68fa 	trap	3
81145f90:	dfc00615 	stw	ra,24(sp)
81145f94:	df000515 	stw	fp,20(sp)
81145f98:	df000504 	addi	fp,sp,20
81145f9c:	e13ffc15 	stw	r4,-16(fp)
81145fa0:	e17ffd15 	stw	r5,-12(fp)
81145fa4:	e1bffe15 	stw	r6,-8(fp)
81145fa8:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
81145fac:	e1bfff17 	ldw	r6,-4(fp)
81145fb0:	e17ffe17 	ldw	r5,-8(fp)
81145fb4:	e13ffd17 	ldw	r4,-12(fp)
81145fb8:	1132e340 	call	81132e34 <open>
81145fbc:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
81145fc0:	e0bffb17 	ldw	r2,-20(fp)
81145fc4:	10001c16 	blt	r2,zero,81146038 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
81145fc8:	00a04574 	movhi	r2,33045
81145fcc:	10b2be04 	addi	r2,r2,-13576
81145fd0:	e0fffb17 	ldw	r3,-20(fp)
81145fd4:	18c00324 	muli	r3,r3,12
81145fd8:	10c5883a 	add	r2,r2,r3
81145fdc:	10c00017 	ldw	r3,0(r2)
81145fe0:	e0bffc17 	ldw	r2,-16(fp)
81145fe4:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
81145fe8:	00a04574 	movhi	r2,33045
81145fec:	10b2be04 	addi	r2,r2,-13576
81145ff0:	e0fffb17 	ldw	r3,-20(fp)
81145ff4:	18c00324 	muli	r3,r3,12
81145ff8:	10c5883a 	add	r2,r2,r3
81145ffc:	10800104 	addi	r2,r2,4
81146000:	10c00017 	ldw	r3,0(r2)
81146004:	e0bffc17 	ldw	r2,-16(fp)
81146008:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114600c:	00a04574 	movhi	r2,33045
81146010:	10b2be04 	addi	r2,r2,-13576
81146014:	e0fffb17 	ldw	r3,-20(fp)
81146018:	18c00324 	muli	r3,r3,12
8114601c:	10c5883a 	add	r2,r2,r3
81146020:	10800204 	addi	r2,r2,8
81146024:	10c00017 	ldw	r3,0(r2)
81146028:	e0bffc17 	ldw	r2,-16(fp)
8114602c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
81146030:	e13ffb17 	ldw	r4,-20(fp)
81146034:	11330d80 	call	811330d8 <alt_release_fd>
  }
} 
81146038:	0001883a 	nop
8114603c:	e037883a 	mov	sp,fp
81146040:	dfc00117 	ldw	ra,4(sp)
81146044:	df000017 	ldw	fp,0(sp)
81146048:	dec00204 	addi	sp,sp,8
8114604c:	f800283a 	ret

81146050 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
81146050:	defffb04 	addi	sp,sp,-20
81146054:	de00012e 	bgeu	sp,et,8114605c <alt_io_redirect+0xc>
81146058:	003b68fa 	trap	3
8114605c:	dfc00415 	stw	ra,16(sp)
81146060:	df000315 	stw	fp,12(sp)
81146064:	df000304 	addi	fp,sp,12
81146068:	e13ffd15 	stw	r4,-12(fp)
8114606c:	e17ffe15 	stw	r5,-8(fp)
81146070:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
81146074:	01c07fc4 	movi	r7,511
81146078:	01800044 	movi	r6,1
8114607c:	e17ffd17 	ldw	r5,-12(fp)
81146080:	01204574 	movhi	r4,33045
81146084:	2132c104 	addi	r4,r4,-13564
81146088:	1145f840 	call	81145f84 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114608c:	01c07fc4 	movi	r7,511
81146090:	000d883a 	mov	r6,zero
81146094:	e17ffe17 	ldw	r5,-8(fp)
81146098:	01204574 	movhi	r4,33045
8114609c:	2132be04 	addi	r4,r4,-13576
811460a0:	1145f840 	call	81145f84 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
811460a4:	01c07fc4 	movi	r7,511
811460a8:	01800044 	movi	r6,1
811460ac:	e17fff17 	ldw	r5,-4(fp)
811460b0:	01204574 	movhi	r4,33045
811460b4:	2132c404 	addi	r4,r4,-13552
811460b8:	1145f840 	call	81145f84 <alt_open_fd>
}  
811460bc:	0001883a 	nop
811460c0:	e037883a 	mov	sp,fp
811460c4:	dfc00117 	ldw	ra,4(sp)
811460c8:	df000017 	ldw	fp,0(sp)
811460cc:	dec00204 	addi	sp,sp,8
811460d0:	f800283a 	ret

811460d4 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
811460d4:	defff204 	addi	sp,sp,-56
811460d8:	de00012e 	bgeu	sp,et,811460e0 <alt_printf+0xc>
811460dc:	003b68fa 	trap	3
811460e0:	dfc00a15 	stw	ra,40(sp)
811460e4:	df000915 	stw	fp,36(sp)
811460e8:	df000904 	addi	fp,sp,36
811460ec:	e13fff15 	stw	r4,-4(fp)
811460f0:	e1400215 	stw	r5,8(fp)
811460f4:	e1800315 	stw	r6,12(fp)
811460f8:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
811460fc:	e0800204 	addi	r2,fp,8
81146100:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
81146104:	e0bfff17 	ldw	r2,-4(fp)
81146108:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114610c:	00006f06 	br	811462cc <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
81146110:	e0bff807 	ldb	r2,-32(fp)
81146114:	10800960 	cmpeqi	r2,r2,37
81146118:	1000041e 	bne	r2,zero,8114612c <alt_printf+0x58>
        {
            alt_putchar(c);
8114611c:	e0bff807 	ldb	r2,-32(fp)
81146120:	1009883a 	mov	r4,r2
81146124:	11463080 	call	81146308 <alt_putchar>
81146128:	00006806 	br	811462cc <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8114612c:	e0bff717 	ldw	r2,-36(fp)
81146130:	10c00044 	addi	r3,r2,1
81146134:	e0fff715 	stw	r3,-36(fp)
81146138:	10800003 	ldbu	r2,0(r2)
8114613c:	e0bff805 	stb	r2,-32(fp)
81146140:	e0bff807 	ldb	r2,-32(fp)
81146144:	10006926 	beq	r2,zero,811462ec <alt_printf+0x218>
            {
                if (c == '%')
81146148:	e0bff807 	ldb	r2,-32(fp)
8114614c:	10800958 	cmpnei	r2,r2,37
81146150:	1000041e 	bne	r2,zero,81146164 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
81146154:	e0bff807 	ldb	r2,-32(fp)
81146158:	1009883a 	mov	r4,r2
8114615c:	11463080 	call	81146308 <alt_putchar>
81146160:	00005a06 	br	811462cc <alt_printf+0x1f8>
                } 
                else if (c == 'c')
81146164:	e0bff807 	ldb	r2,-32(fp)
81146168:	108018d8 	cmpnei	r2,r2,99
8114616c:	1000081e 	bne	r2,zero,81146190 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81146170:	e0bffe17 	ldw	r2,-8(fp)
81146174:	10c00104 	addi	r3,r2,4
81146178:	e0fffe15 	stw	r3,-8(fp)
8114617c:	10800017 	ldw	r2,0(r2)
81146180:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
81146184:	e13ffd17 	ldw	r4,-12(fp)
81146188:	11463080 	call	81146308 <alt_putchar>
8114618c:	00004f06 	br	811462cc <alt_printf+0x1f8>
                }
                else if (c == 'x')
81146190:	e0bff807 	ldb	r2,-32(fp)
81146194:	10801e18 	cmpnei	r2,r2,120
81146198:	1000341e 	bne	r2,zero,8114626c <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114619c:	e0bffe17 	ldw	r2,-8(fp)
811461a0:	10c00104 	addi	r3,r2,4
811461a4:	e0fffe15 	stw	r3,-8(fp)
811461a8:	10800017 	ldw	r2,0(r2)
811461ac:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
811461b0:	e0bffb17 	ldw	r2,-20(fp)
811461b4:	1000031e 	bne	r2,zero,811461c4 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
811461b8:	01000c04 	movi	r4,48
811461bc:	11463080 	call	81146308 <alt_putchar>
                        continue;
811461c0:	00004206 	br	811462cc <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
811461c4:	00800704 	movi	r2,28
811461c8:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
811461cc:	00000306 	br	811461dc <alt_printf+0x108>
                        digit_shift -= 4;
811461d0:	e0bff917 	ldw	r2,-28(fp)
811461d4:	10bfff04 	addi	r2,r2,-4
811461d8:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
811461dc:	00c003c4 	movi	r3,15
811461e0:	e0bff917 	ldw	r2,-28(fp)
811461e4:	1884983a 	sll	r2,r3,r2
811461e8:	1007883a 	mov	r3,r2
811461ec:	e0bffb17 	ldw	r2,-20(fp)
811461f0:	1884703a 	and	r2,r3,r2
811461f4:	103ff626 	beq	r2,zero,811461d0 <__reset+0xfb1261d0>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
811461f8:	00001906 	br	81146260 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
811461fc:	00c003c4 	movi	r3,15
81146200:	e0bff917 	ldw	r2,-28(fp)
81146204:	1884983a 	sll	r2,r3,r2
81146208:	1007883a 	mov	r3,r2
8114620c:	e0bffb17 	ldw	r2,-20(fp)
81146210:	1886703a 	and	r3,r3,r2
81146214:	e0bff917 	ldw	r2,-28(fp)
81146218:	1884d83a 	srl	r2,r3,r2
8114621c:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
81146220:	e0bffc17 	ldw	r2,-16(fp)
81146224:	108002a8 	cmpgeui	r2,r2,10
81146228:	1000041e 	bne	r2,zero,8114623c <alt_printf+0x168>
                            c = '0' + digit;
8114622c:	e0bffc17 	ldw	r2,-16(fp)
81146230:	10800c04 	addi	r2,r2,48
81146234:	e0bff805 	stb	r2,-32(fp)
81146238:	00000306 	br	81146248 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8114623c:	e0bffc17 	ldw	r2,-16(fp)
81146240:	108015c4 	addi	r2,r2,87
81146244:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81146248:	e0bff807 	ldb	r2,-32(fp)
8114624c:	1009883a 	mov	r4,r2
81146250:	11463080 	call	81146308 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81146254:	e0bff917 	ldw	r2,-28(fp)
81146258:	10bfff04 	addi	r2,r2,-4
8114625c:	e0bff915 	stw	r2,-28(fp)
81146260:	e0bff917 	ldw	r2,-28(fp)
81146264:	103fe50e 	bge	r2,zero,811461fc <__reset+0xfb1261fc>
81146268:	00001806 	br	811462cc <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114626c:	e0bff807 	ldb	r2,-32(fp)
81146270:	10801cd8 	cmpnei	r2,r2,115
81146274:	1000151e 	bne	r2,zero,811462cc <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81146278:	e0bffe17 	ldw	r2,-8(fp)
8114627c:	10c00104 	addi	r3,r2,4
81146280:	e0fffe15 	stw	r3,-8(fp)
81146284:	10800017 	ldw	r2,0(r2)
81146288:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114628c:	00000906 	br	811462b4 <alt_printf+0x1e0>
                      alt_putchar(*s++);
81146290:	e0bffa17 	ldw	r2,-24(fp)
81146294:	10c00044 	addi	r3,r2,1
81146298:	e0fffa15 	stw	r3,-24(fp)
8114629c:	10800003 	ldbu	r2,0(r2)
811462a0:	10803fcc 	andi	r2,r2,255
811462a4:	1080201c 	xori	r2,r2,128
811462a8:	10bfe004 	addi	r2,r2,-128
811462ac:	1009883a 	mov	r4,r2
811462b0:	11463080 	call	81146308 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
811462b4:	e0bffa17 	ldw	r2,-24(fp)
811462b8:	10800003 	ldbu	r2,0(r2)
811462bc:	10803fcc 	andi	r2,r2,255
811462c0:	1080201c 	xori	r2,r2,128
811462c4:	10bfe004 	addi	r2,r2,-128
811462c8:	103ff11e 	bne	r2,zero,81146290 <__reset+0xfb126290>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
811462cc:	e0bff717 	ldw	r2,-36(fp)
811462d0:	10c00044 	addi	r3,r2,1
811462d4:	e0fff715 	stw	r3,-36(fp)
811462d8:	10800003 	ldbu	r2,0(r2)
811462dc:	e0bff805 	stb	r2,-32(fp)
811462e0:	e0bff807 	ldb	r2,-32(fp)
811462e4:	103f8a1e 	bne	r2,zero,81146110 <__reset+0xfb126110>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
811462e8:	00000106 	br	811462f0 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
811462ec:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
811462f0:	0001883a 	nop
811462f4:	e037883a 	mov	sp,fp
811462f8:	dfc00117 	ldw	ra,4(sp)
811462fc:	df000017 	ldw	fp,0(sp)
81146300:	dec00504 	addi	sp,sp,20
81146304:	f800283a 	ret

81146308 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81146308:	defffd04 	addi	sp,sp,-12
8114630c:	de00012e 	bgeu	sp,et,81146314 <alt_putchar+0xc>
81146310:	003b68fa 	trap	3
81146314:	dfc00215 	stw	ra,8(sp)
81146318:	df000115 	stw	fp,4(sp)
8114631c:	df000104 	addi	fp,sp,4
81146320:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
81146324:	d0a00517 	ldw	r2,-32748(gp)
81146328:	10800217 	ldw	r2,8(r2)
8114632c:	100b883a 	mov	r5,r2
81146330:	e13fff17 	ldw	r4,-4(fp)
81146334:	111d5d00 	call	8111d5d0 <putc>
#endif
#endif
}
81146338:	e037883a 	mov	sp,fp
8114633c:	dfc00117 	ldw	ra,4(sp)
81146340:	df000017 	ldw	fp,0(sp)
81146344:	dec00204 	addi	sp,sp,8
81146348:	f800283a 	ret

8114634c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114634c:	deffff04 	addi	sp,sp,-4
81146350:	de00012e 	bgeu	sp,et,81146358 <altera_nios2_gen2_irq_init+0xc>
81146354:	003b68fa 	trap	3
81146358:	df000015 	stw	fp,0(sp)
8114635c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81146360:	000170fa 	wrctl	ienable,zero
}
81146364:	0001883a 	nop
81146368:	e037883a 	mov	sp,fp
8114636c:	df000017 	ldw	fp,0(sp)
81146370:	dec00104 	addi	sp,sp,4
81146374:	f800283a 	ret

81146378 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81146378:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114637c:	de002436 	bltu	sp,et,81146410 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81146380:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
81146384:	d1209d17 	ldw	r4,-32140(gp)

      stw ra,  0(sp)
81146388:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114638c:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81146390:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
81146394:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81146398:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114639c:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
811463a0:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
811463a4:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
811463a8:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
811463ac:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
811463b0:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
811463b4:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
811463b8:	11466140 	call	81146614 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
811463bc:	d1209717 	ldw	r4,-32164(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
811463c0:	d1608e87 	ldb	r5,-32198(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
811463c4:	d1209d15 	stw	r4,-32140(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
811463c8:	d1608ec5 	stb	r5,-32197(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
811463cc:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
811463d0:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
811463d4:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
811463d8:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
811463dc:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
811463e0:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
811463e4:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
811463e8:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
811463ec:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
811463f0:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
811463f4:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
811463f8:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
811463fc:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
81146400:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
81146404:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81146408:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8114640c:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81146410:	003da0fa 	break	3

81146414 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
81146414:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81146418:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8114641c:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81146420:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81146424:	11466140 	call	81146614 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81146428:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8114642c:	d4a08c05 	stb	r18,-32208(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81146430:	003fe206 	br	811463bc <__reset+0xfb1263bc>

81146434 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
81146434:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81146438:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8114643c:	10800054 	ori	r2,r2,1
      wrctl status, r2
81146440:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
81146444:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81146448:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114644c:	dec00204 	addi	sp,sp,8

      callr r2
81146450:	103ee83a 	callr	r2

      nop
81146454:	0001883a 	nop

81146458 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81146458:	defff704 	addi	sp,sp,-36
8114645c:	de00012e 	bgeu	sp,et,81146464 <OSTaskStkInit+0xc>
81146460:	003b68fa 	trap	3
81146464:	dfc00815 	stw	ra,32(sp)
81146468:	df000715 	stw	fp,28(sp)
8114646c:	df000704 	addi	fp,sp,28
81146470:	e13ffc15 	stw	r4,-16(fp)
81146474:	e17ffd15 	stw	r5,-12(fp)
81146478:	e1bffe15 	stw	r6,-8(fp)
8114647c:	3805883a 	mov	r2,r7
81146480:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
81146484:	e0fffe17 	ldw	r3,-8(fp)
81146488:	00bfff04 	movi	r2,-4
8114648c:	1884703a 	and	r2,r3,r2
81146490:	10bef704 	addi	r2,r2,-1060
81146494:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81146498:	01810904 	movi	r6,1060
8114649c:	000b883a 	mov	r5,zero
811464a0:	e13ff917 	ldw	r4,-28(fp)
811464a4:	111d31c0 	call	8111d31c <memset>
811464a8:	e0bff917 	ldw	r2,-28(fp)
811464ac:	10c0bb04 	addi	r3,r2,748
811464b0:	e0bff917 	ldw	r2,-28(fp)
811464b4:	10c00115 	stw	r3,4(r2)
811464b8:	e0bff917 	ldw	r2,-28(fp)
811464bc:	10c0d504 	addi	r3,r2,852
811464c0:	e0bff917 	ldw	r2,-28(fp)
811464c4:	10c00215 	stw	r3,8(r2)
811464c8:	e0bff917 	ldw	r2,-28(fp)
811464cc:	10c0ef04 	addi	r3,r2,956
811464d0:	e0bff917 	ldw	r2,-28(fp)
811464d4:	10c00315 	stw	r3,12(r2)
811464d8:	e0fff917 	ldw	r3,-28(fp)
811464dc:	00a04574 	movhi	r2,33045
811464e0:	10b05704 	addi	r2,r2,-16036
811464e4:	18800d15 	stw	r2,52(r3)
811464e8:	e0bff917 	ldw	r2,-28(fp)
811464ec:	00c00044 	movi	r3,1
811464f0:	10c02915 	stw	r3,164(r2)
811464f4:	10002a15 	stw	zero,168(r2)
811464f8:	e0bff917 	ldw	r2,-28(fp)
811464fc:	00ccc384 	movi	r3,13070
81146500:	10c02b0d 	sth	r3,172(r2)
81146504:	e0bff917 	ldw	r2,-28(fp)
81146508:	00eaf344 	movi	r3,-21555
8114650c:	10c02b8d 	sth	r3,174(r2)
81146510:	e0bff917 	ldw	r2,-28(fp)
81146514:	00c48d04 	movi	r3,4660
81146518:	10c02c0d 	sth	r3,176(r2)
8114651c:	e0bff917 	ldw	r2,-28(fp)
81146520:	00f99b44 	movi	r3,-6547
81146524:	10c02c8d 	sth	r3,178(r2)
81146528:	e0bff917 	ldw	r2,-28(fp)
8114652c:	00f7bb04 	movi	r3,-8468
81146530:	10c02d0d 	sth	r3,180(r2)
81146534:	e0bff917 	ldw	r2,-28(fp)
81146538:	00c00144 	movi	r3,5
8114653c:	10c02d8d 	sth	r3,182(r2)
81146540:	e0bff917 	ldw	r2,-28(fp)
81146544:	00c002c4 	movi	r3,11
81146548:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114654c:	e0bff917 	ldw	r2,-28(fp)
81146550:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
81146554:	e0bffa17 	ldw	r2,-24(fp)
81146558:	10bff304 	addi	r2,r2,-52
8114655c:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81146560:	e0bffb17 	ldw	r2,-20(fp)
81146564:	10800c04 	addi	r2,r2,48
81146568:	e0fffc17 	ldw	r3,-16(fp)
8114656c:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81146570:	e0bffb17 	ldw	r2,-20(fp)
81146574:	10800b04 	addi	r2,r2,44
81146578:	e0fffd17 	ldw	r3,-12(fp)
8114657c:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81146580:	e0bffb17 	ldw	r2,-20(fp)
81146584:	10800a04 	addi	r2,r2,40
81146588:	e0fff917 	ldw	r3,-28(fp)
8114658c:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81146590:	00a04534 	movhi	r2,33044
81146594:	10990d04 	addi	r2,r2,25652
81146598:	10c00104 	addi	r3,r2,4
8114659c:	e0bffb17 	ldw	r2,-20(fp)
811465a0:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
811465a4:	e0bffb17 	ldw	r2,-20(fp)
}
811465a8:	e037883a 	mov	sp,fp
811465ac:	dfc00117 	ldw	ra,4(sp)
811465b0:	df000017 	ldw	fp,0(sp)
811465b4:	dec00204 	addi	sp,sp,8
811465b8:	f800283a 	ret

811465bc <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
811465bc:	defffe04 	addi	sp,sp,-8
811465c0:	de00012e 	bgeu	sp,et,811465c8 <OSTaskCreateHook+0xc>
811465c4:	003b68fa 	trap	3
811465c8:	df000115 	stw	fp,4(sp)
811465cc:	df000104 	addi	fp,sp,4
811465d0:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
811465d4:	0001883a 	nop
811465d8:	e037883a 	mov	sp,fp
811465dc:	df000017 	ldw	fp,0(sp)
811465e0:	dec00104 	addi	sp,sp,4
811465e4:	f800283a 	ret

811465e8 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
811465e8:	defffe04 	addi	sp,sp,-8
811465ec:	de00012e 	bgeu	sp,et,811465f4 <OSTaskDelHook+0xc>
811465f0:	003b68fa 	trap	3
811465f4:	df000115 	stw	fp,4(sp)
811465f8:	df000104 	addi	fp,sp,4
811465fc:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
81146600:	0001883a 	nop
81146604:	e037883a 	mov	sp,fp
81146608:	df000017 	ldw	fp,0(sp)
8114660c:	dec00104 	addi	sp,sp,4
81146610:	f800283a 	ret

81146614 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
81146614:	deffff04 	addi	sp,sp,-4
81146618:	de00012e 	bgeu	sp,et,81146620 <OSTaskSwHook+0xc>
8114661c:	003b68fa 	trap	3
81146620:	df000015 	stw	fp,0(sp)
81146624:	d839883a 	mov	fp,sp
}
81146628:	0001883a 	nop
8114662c:	e037883a 	mov	sp,fp
81146630:	df000017 	ldw	fp,0(sp)
81146634:	dec00104 	addi	sp,sp,4
81146638:	f800283a 	ret

8114663c <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114663c:	deffff04 	addi	sp,sp,-4
81146640:	de00012e 	bgeu	sp,et,81146648 <OSTaskStatHook+0xc>
81146644:	003b68fa 	trap	3
81146648:	df000015 	stw	fp,0(sp)
8114664c:	d839883a 	mov	fp,sp
}
81146650:	0001883a 	nop
81146654:	e037883a 	mov	sp,fp
81146658:	df000017 	ldw	fp,0(sp)
8114665c:	dec00104 	addi	sp,sp,4
81146660:	f800283a 	ret

81146664 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81146664:	defffe04 	addi	sp,sp,-8
81146668:	de00012e 	bgeu	sp,et,81146670 <OSTimeTickHook+0xc>
8114666c:	003b68fa 	trap	3
81146670:	dfc00115 	stw	ra,4(sp)
81146674:	df000015 	stw	fp,0(sp)
81146678:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114667c:	d0a0b10b 	ldhu	r2,-32060(gp)
81146680:	10800044 	addi	r2,r2,1
81146684:	d0a0b10d 	sth	r2,-32060(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81146688:	d0a0b10b 	ldhu	r2,-32060(gp)
8114668c:	10bfffcc 	andi	r2,r2,65535
81146690:	10807d30 	cmpltui	r2,r2,500
81146694:	1000021e 	bne	r2,zero,811466a0 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81146698:	d020b10d 	sth	zero,-32060(gp)
        OSTmrSignal();
8114669c:	113cfb40 	call	8113cfb4 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
811466a0:	0001883a 	nop
811466a4:	e037883a 	mov	sp,fp
811466a8:	dfc00117 	ldw	ra,4(sp)
811466ac:	df000017 	ldw	fp,0(sp)
811466b0:	dec00204 	addi	sp,sp,8
811466b4:	f800283a 	ret

811466b8 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
811466b8:	deffff04 	addi	sp,sp,-4
811466bc:	de00012e 	bgeu	sp,et,811466c4 <OSInitHookBegin+0xc>
811466c0:	003b68fa 	trap	3
811466c4:	df000015 	stw	fp,0(sp)
811466c8:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
811466cc:	d020b10d 	sth	zero,-32060(gp)
#endif
}
811466d0:	0001883a 	nop
811466d4:	e037883a 	mov	sp,fp
811466d8:	df000017 	ldw	fp,0(sp)
811466dc:	dec00104 	addi	sp,sp,4
811466e0:	f800283a 	ret

811466e4 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
811466e4:	deffff04 	addi	sp,sp,-4
811466e8:	de00012e 	bgeu	sp,et,811466f0 <OSInitHookEnd+0xc>
811466ec:	003b68fa 	trap	3
811466f0:	df000015 	stw	fp,0(sp)
811466f4:	d839883a 	mov	fp,sp
}
811466f8:	0001883a 	nop
811466fc:	e037883a 	mov	sp,fp
81146700:	df000017 	ldw	fp,0(sp)
81146704:	dec00104 	addi	sp,sp,4
81146708:	f800283a 	ret

8114670c <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114670c:	deffff04 	addi	sp,sp,-4
81146710:	de00012e 	bgeu	sp,et,81146718 <OSTaskIdleHook+0xc>
81146714:	003b68fa 	trap	3
81146718:	df000015 	stw	fp,0(sp)
8114671c:	d839883a 	mov	fp,sp
}
81146720:	0001883a 	nop
81146724:	e037883a 	mov	sp,fp
81146728:	df000017 	ldw	fp,0(sp)
8114672c:	dec00104 	addi	sp,sp,4
81146730:	f800283a 	ret

81146734 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
81146734:	defffe04 	addi	sp,sp,-8
81146738:	de00012e 	bgeu	sp,et,81146740 <OSTCBInitHook+0xc>
8114673c:	003b68fa 	trap	3
81146740:	df000115 	stw	fp,4(sp)
81146744:	df000104 	addi	fp,sp,4
81146748:	e13fff15 	stw	r4,-4(fp)
}
8114674c:	0001883a 	nop
81146750:	e037883a 	mov	sp,fp
81146754:	df000017 	ldw	fp,0(sp)
81146758:	dec00104 	addi	sp,sp,4
8114675c:	f800283a 	ret

81146760 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
81146760:	defffe04 	addi	sp,sp,-8
81146764:	de00012e 	bgeu	sp,et,8114676c <alt_exception_cause_generated_bad_addr+0xc>
81146768:	003b68fa 	trap	3
8114676c:	df000115 	stw	fp,4(sp)
81146770:	df000104 	addi	fp,sp,4
81146774:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
81146778:	e0bfff17 	ldw	r2,-4(fp)
8114677c:	10bffe84 	addi	r2,r2,-6
81146780:	10c00428 	cmpgeui	r3,r2,16
81146784:	18001a1e 	bne	r3,zero,811467f0 <alt_exception_cause_generated_bad_addr+0x90>
81146788:	100690ba 	slli	r3,r2,2
8114678c:	00a04534 	movhi	r2,33044
81146790:	1099e804 	addi	r2,r2,26528
81146794:	1885883a 	add	r2,r3,r2
81146798:	10800017 	ldw	r2,0(r2)
8114679c:	1000683a 	jmp	r2
811467a0:	811467e0 	cmpeqi	r4,r16,20895
811467a4:	811467e0 	cmpeqi	r4,r16,20895
811467a8:	811467f0 	cmpltui	r4,r16,20895
811467ac:	811467f0 	cmpltui	r4,r16,20895
811467b0:	811467f0 	cmpltui	r4,r16,20895
811467b4:	811467e0 	cmpeqi	r4,r16,20895
811467b8:	811467e8 	cmpgeui	r4,r16,20895
811467bc:	811467f0 	cmpltui	r4,r16,20895
811467c0:	811467e0 	cmpeqi	r4,r16,20895
811467c4:	811467e0 	cmpeqi	r4,r16,20895
811467c8:	811467f0 	cmpltui	r4,r16,20895
811467cc:	811467e0 	cmpeqi	r4,r16,20895
811467d0:	811467e8 	cmpgeui	r4,r16,20895
811467d4:	811467f0 	cmpltui	r4,r16,20895
811467d8:	811467f0 	cmpltui	r4,r16,20895
811467dc:	811467e0 	cmpeqi	r4,r16,20895
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
811467e0:	00800044 	movi	r2,1
811467e4:	00000306 	br	811467f4 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
811467e8:	0005883a 	mov	r2,zero
811467ec:	00000106 	br	811467f4 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
811467f0:	0005883a 	mov	r2,zero
  }
}
811467f4:	e037883a 	mov	sp,fp
811467f8:	df000017 	ldw	fp,0(sp)
811467fc:	dec00104 	addi	sp,sp,4
81146800:	f800283a 	ret

81146804 <exit>:
81146804:	defffe04 	addi	sp,sp,-8
81146808:	000b883a 	mov	r5,zero
8114680c:	de00012e 	bgeu	sp,et,81146814 <exit+0x10>
81146810:	003b68fa 	trap	3
81146814:	dc000015 	stw	r16,0(sp)
81146818:	dfc00115 	stw	ra,4(sp)
8114681c:	2021883a 	mov	r16,r4
81146820:	11469ac0 	call	811469ac <__call_exitprocs>
81146824:	00a04574 	movhi	r2,33045
81146828:	10b7d504 	addi	r2,r2,-8364
8114682c:	11000017 	ldw	r4,0(r2)
81146830:	20800f17 	ldw	r2,60(r4)
81146834:	10000126 	beq	r2,zero,8114683c <exit+0x38>
81146838:	103ee83a 	callr	r2
8114683c:	8009883a 	mov	r4,r16
81146840:	1146b340 	call	81146b34 <_exit>

81146844 <memcmp>:
81146844:	01c000c4 	movi	r7,3
81146848:	3980192e 	bgeu	r7,r6,811468b0 <memcmp+0x6c>
8114684c:	2144b03a 	or	r2,r4,r5
81146850:	11c4703a 	and	r2,r2,r7
81146854:	10000f26 	beq	r2,zero,81146894 <memcmp+0x50>
81146858:	20800003 	ldbu	r2,0(r4)
8114685c:	28c00003 	ldbu	r3,0(r5)
81146860:	10c0151e 	bne	r2,r3,811468b8 <memcmp+0x74>
81146864:	31bfff84 	addi	r6,r6,-2
81146868:	01ffffc4 	movi	r7,-1
8114686c:	00000406 	br	81146880 <memcmp+0x3c>
81146870:	20800003 	ldbu	r2,0(r4)
81146874:	28c00003 	ldbu	r3,0(r5)
81146878:	31bfffc4 	addi	r6,r6,-1
8114687c:	10c00e1e 	bne	r2,r3,811468b8 <memcmp+0x74>
81146880:	21000044 	addi	r4,r4,1
81146884:	29400044 	addi	r5,r5,1
81146888:	31fff91e 	bne	r6,r7,81146870 <__reset+0xfb126870>
8114688c:	0005883a 	mov	r2,zero
81146890:	f800283a 	ret
81146894:	20c00017 	ldw	r3,0(r4)
81146898:	28800017 	ldw	r2,0(r5)
8114689c:	18bfee1e 	bne	r3,r2,81146858 <__reset+0xfb126858>
811468a0:	31bfff04 	addi	r6,r6,-4
811468a4:	21000104 	addi	r4,r4,4
811468a8:	29400104 	addi	r5,r5,4
811468ac:	39bff936 	bltu	r7,r6,81146894 <__reset+0xfb126894>
811468b0:	303fe91e 	bne	r6,zero,81146858 <__reset+0xfb126858>
811468b4:	003ff506 	br	8114688c <__reset+0xfb12688c>
811468b8:	10c5c83a 	sub	r2,r2,r3
811468bc:	f800283a 	ret

811468c0 <strncpy>:
811468c0:	2906b03a 	or	r3,r5,r4
811468c4:	18c000cc 	andi	r3,r3,3
811468c8:	2005883a 	mov	r2,r4
811468cc:	18002c1e 	bne	r3,zero,81146980 <strncpy+0xc0>
811468d0:	010000c4 	movi	r4,3
811468d4:	21802a2e 	bgeu	r4,r6,81146980 <strncpy+0xc0>
811468d8:	033fbff4 	movhi	r12,65279
811468dc:	02e02074 	movhi	r11,32897
811468e0:	633fbfc4 	addi	r12,r12,-257
811468e4:	5ae02004 	addi	r11,r11,-32640
811468e8:	100f883a 	mov	r7,r2
811468ec:	2a000017 	ldw	r8,0(r5)
811468f0:	3815883a 	mov	r10,r7
811468f4:	4313883a 	add	r9,r8,r12
811468f8:	0206303a 	nor	r3,zero,r8
811468fc:	48c6703a 	and	r3,r9,r3
81146900:	1ac6703a 	and	r3,r3,r11
81146904:	1800261e 	bne	r3,zero,811469a0 <strncpy+0xe0>
81146908:	39c00104 	addi	r7,r7,4
8114690c:	52000015 	stw	r8,0(r10)
81146910:	31bfff04 	addi	r6,r6,-4
81146914:	3811883a 	mov	r8,r7
81146918:	29400104 	addi	r5,r5,4
8114691c:	21bff336 	bltu	r4,r6,811468ec <__reset+0xfb1268ec>
81146920:	30001e26 	beq	r6,zero,8114699c <strncpy+0xdc>
81146924:	29c00003 	ldbu	r7,0(r5)
81146928:	31bfffc4 	addi	r6,r6,-1
8114692c:	40c00044 	addi	r3,r8,1
81146930:	41c00005 	stb	r7,0(r8)
81146934:	39c03fcc 	andi	r7,r7,255
81146938:	39c0201c 	xori	r7,r7,128
8114693c:	39ffe004 	addi	r7,r7,-128
81146940:	29400044 	addi	r5,r5,1
81146944:	38001026 	beq	r7,zero,81146988 <strncpy+0xc8>
81146948:	1811883a 	mov	r8,r3
8114694c:	00000906 	br	81146974 <strncpy+0xb4>
81146950:	29c00003 	ldbu	r7,0(r5)
81146954:	31bfffc4 	addi	r6,r6,-1
81146958:	29400044 	addi	r5,r5,1
8114695c:	41c00005 	stb	r7,0(r8)
81146960:	39c03fcc 	andi	r7,r7,255
81146964:	39c0201c 	xori	r7,r7,128
81146968:	39ffe004 	addi	r7,r7,-128
8114696c:	1811883a 	mov	r8,r3
81146970:	38000526 	beq	r7,zero,81146988 <strncpy+0xc8>
81146974:	18c00044 	addi	r3,r3,1
81146978:	303ff51e 	bne	r6,zero,81146950 <__reset+0xfb126950>
8114697c:	f800283a 	ret
81146980:	1011883a 	mov	r8,r2
81146984:	003fe606 	br	81146920 <__reset+0xfb126920>
81146988:	30000726 	beq	r6,zero,811469a8 <strncpy+0xe8>
8114698c:	198d883a 	add	r6,r3,r6
81146990:	18000005 	stb	zero,0(r3)
81146994:	18c00044 	addi	r3,r3,1
81146998:	19bffd1e 	bne	r3,r6,81146990 <__reset+0xfb126990>
8114699c:	f800283a 	ret
811469a0:	3811883a 	mov	r8,r7
811469a4:	003fdf06 	br	81146924 <__reset+0xfb126924>
811469a8:	f800283a 	ret

811469ac <__call_exitprocs>:
811469ac:	defff504 	addi	sp,sp,-44
811469b0:	de00012e 	bgeu	sp,et,811469b8 <__call_exitprocs+0xc>
811469b4:	003b68fa 	trap	3
811469b8:	df000915 	stw	fp,36(sp)
811469bc:	dd400615 	stw	r21,24(sp)
811469c0:	dc800315 	stw	r18,12(sp)
811469c4:	dfc00a15 	stw	ra,40(sp)
811469c8:	ddc00815 	stw	r23,32(sp)
811469cc:	dd800715 	stw	r22,28(sp)
811469d0:	dd000515 	stw	r20,20(sp)
811469d4:	dcc00415 	stw	r19,16(sp)
811469d8:	dc400215 	stw	r17,8(sp)
811469dc:	dc000115 	stw	r16,4(sp)
811469e0:	d9000015 	stw	r4,0(sp)
811469e4:	2839883a 	mov	fp,r5
811469e8:	04800044 	movi	r18,1
811469ec:	057fffc4 	movi	r21,-1
811469f0:	00a04574 	movhi	r2,33045
811469f4:	10b7d504 	addi	r2,r2,-8364
811469f8:	12000017 	ldw	r8,0(r2)
811469fc:	45005217 	ldw	r20,328(r8)
81146a00:	44c05204 	addi	r19,r8,328
81146a04:	a0001c26 	beq	r20,zero,81146a78 <__call_exitprocs+0xcc>
81146a08:	a0800117 	ldw	r2,4(r20)
81146a0c:	15ffffc4 	addi	r23,r2,-1
81146a10:	b8000d16 	blt	r23,zero,81146a48 <__call_exitprocs+0x9c>
81146a14:	14000044 	addi	r16,r2,1
81146a18:	8421883a 	add	r16,r16,r16
81146a1c:	8421883a 	add	r16,r16,r16
81146a20:	84402004 	addi	r17,r16,128
81146a24:	a463883a 	add	r17,r20,r17
81146a28:	a421883a 	add	r16,r20,r16
81146a2c:	e0001e26 	beq	fp,zero,81146aa8 <__call_exitprocs+0xfc>
81146a30:	80804017 	ldw	r2,256(r16)
81146a34:	e0801c26 	beq	fp,r2,81146aa8 <__call_exitprocs+0xfc>
81146a38:	bdffffc4 	addi	r23,r23,-1
81146a3c:	843fff04 	addi	r16,r16,-4
81146a40:	8c7fff04 	addi	r17,r17,-4
81146a44:	bd7ff91e 	bne	r23,r21,81146a2c <__reset+0xfb126a2c>
81146a48:	00800034 	movhi	r2,0
81146a4c:	10800004 	addi	r2,r2,0
81146a50:	10000926 	beq	r2,zero,81146a78 <__call_exitprocs+0xcc>
81146a54:	a0800117 	ldw	r2,4(r20)
81146a58:	1000301e 	bne	r2,zero,81146b1c <__call_exitprocs+0x170>
81146a5c:	a0800017 	ldw	r2,0(r20)
81146a60:	10003226 	beq	r2,zero,81146b2c <__call_exitprocs+0x180>
81146a64:	a009883a 	mov	r4,r20
81146a68:	98800015 	stw	r2,0(r19)
81146a6c:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
81146a70:	9d000017 	ldw	r20,0(r19)
81146a74:	a03fe41e 	bne	r20,zero,81146a08 <__reset+0xfb126a08>
81146a78:	dfc00a17 	ldw	ra,40(sp)
81146a7c:	df000917 	ldw	fp,36(sp)
81146a80:	ddc00817 	ldw	r23,32(sp)
81146a84:	dd800717 	ldw	r22,28(sp)
81146a88:	dd400617 	ldw	r21,24(sp)
81146a8c:	dd000517 	ldw	r20,20(sp)
81146a90:	dcc00417 	ldw	r19,16(sp)
81146a94:	dc800317 	ldw	r18,12(sp)
81146a98:	dc400217 	ldw	r17,8(sp)
81146a9c:	dc000117 	ldw	r16,4(sp)
81146aa0:	dec00b04 	addi	sp,sp,44
81146aa4:	f800283a 	ret
81146aa8:	a0800117 	ldw	r2,4(r20)
81146aac:	80c00017 	ldw	r3,0(r16)
81146ab0:	10bfffc4 	addi	r2,r2,-1
81146ab4:	15c01426 	beq	r2,r23,81146b08 <__call_exitprocs+0x15c>
81146ab8:	80000015 	stw	zero,0(r16)
81146abc:	183fde26 	beq	r3,zero,81146a38 <__reset+0xfb126a38>
81146ac0:	95c8983a 	sll	r4,r18,r23
81146ac4:	a0806217 	ldw	r2,392(r20)
81146ac8:	a5800117 	ldw	r22,4(r20)
81146acc:	2084703a 	and	r2,r4,r2
81146ad0:	10000b26 	beq	r2,zero,81146b00 <__call_exitprocs+0x154>
81146ad4:	a0806317 	ldw	r2,396(r20)
81146ad8:	2088703a 	and	r4,r4,r2
81146adc:	20000c1e 	bne	r4,zero,81146b10 <__call_exitprocs+0x164>
81146ae0:	89400017 	ldw	r5,0(r17)
81146ae4:	d9000017 	ldw	r4,0(sp)
81146ae8:	183ee83a 	callr	r3
81146aec:	a0800117 	ldw	r2,4(r20)
81146af0:	15bfbf1e 	bne	r2,r22,811469f0 <__reset+0xfb1269f0>
81146af4:	98800017 	ldw	r2,0(r19)
81146af8:	153fcf26 	beq	r2,r20,81146a38 <__reset+0xfb126a38>
81146afc:	003fbc06 	br	811469f0 <__reset+0xfb1269f0>
81146b00:	183ee83a 	callr	r3
81146b04:	003ff906 	br	81146aec <__reset+0xfb126aec>
81146b08:	a5c00115 	stw	r23,4(r20)
81146b0c:	003feb06 	br	81146abc <__reset+0xfb126abc>
81146b10:	89000017 	ldw	r4,0(r17)
81146b14:	183ee83a 	callr	r3
81146b18:	003ff406 	br	81146aec <__reset+0xfb126aec>
81146b1c:	a0800017 	ldw	r2,0(r20)
81146b20:	a027883a 	mov	r19,r20
81146b24:	1029883a 	mov	r20,r2
81146b28:	003fb606 	br	81146a04 <__reset+0xfb126a04>
81146b2c:	0005883a 	mov	r2,zero
81146b30:	003ffb06 	br	81146b20 <__reset+0xfb126b20>

81146b34 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
81146b34:	defffc04 	addi	sp,sp,-16
81146b38:	de00012e 	bgeu	sp,et,81146b40 <_exit+0xc>
81146b3c:	003b68fa 	trap	3
81146b40:	dfc00315 	stw	ra,12(sp)
81146b44:	df000215 	stw	fp,8(sp)
81146b48:	df000204 	addi	fp,sp,8
81146b4c:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
81146b50:	d0a01217 	ldw	r2,-32696(gp)
81146b54:	10800058 	cmpnei	r2,r2,1
81146b58:	1000031e 	bne	r2,zero,81146b68 <_exit+0x34>
81146b5c:	01204574 	movhi	r4,33045
81146b60:	21305804 	addi	r4,r4,-16032
81146b64:	11326440 	call	81132644 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
81146b68:	d0a01217 	ldw	r2,-32696(gp)
81146b6c:	10800058 	cmpnei	r2,r2,1
81146b70:	1000041e 	bne	r2,zero,81146b84 <_exit+0x50>
81146b74:	e17fff17 	ldw	r5,-4(fp)
81146b78:	01204574 	movhi	r4,33045
81146b7c:	21306304 	addi	r4,r4,-15988
81146b80:	11326440 	call	81132644 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
81146b84:	d0a01217 	ldw	r2,-32696(gp)
81146b88:	10800058 	cmpnei	r2,r2,1
81146b8c:	1000031e 	bne	r2,zero,81146b9c <_exit+0x68>
81146b90:	01204574 	movhi	r4,33045
81146b94:	21306e04 	addi	r4,r4,-15944
81146b98:	11326440 	call	81132644 <alt_log_printf_proc>
  ALT_OS_STOP();
81146b9c:	d0208c05 	stb	zero,-32208(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
81146ba0:	d0a01217 	ldw	r2,-32696(gp)
81146ba4:	10800058 	cmpnei	r2,r2,1
81146ba8:	1000031e 	bne	r2,zero,81146bb8 <_exit+0x84>
81146bac:	01204574 	movhi	r4,33045
81146bb0:	21307804 	addi	r4,r4,-15904
81146bb4:	11326440 	call	81132644 <alt_log_printf_proc>
81146bb8:	e0bfff17 	ldw	r2,-4(fp)
81146bbc:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
81146bc0:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
81146bc4:	10000226 	beq	r2,zero,81146bd0 <_exit+0x9c>
    ALT_SIM_FAIL();
81146bc8:	002af070 	cmpltui	zero,zero,43969
81146bcc:	00000106 	br	81146bd4 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
81146bd0:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
81146bd4:	d0a01217 	ldw	r2,-32696(gp)
81146bd8:	10800058 	cmpnei	r2,r2,1
81146bdc:	1000031e 	bne	r2,zero,81146bec <_exit+0xb8>
81146be0:	01204574 	movhi	r4,33045
81146be4:	21308204 	addi	r4,r4,-15864
81146be8:	11326440 	call	81132644 <alt_log_printf_proc>
  while (1);
81146bec:	003fff06 	br	81146bec <__reset+0xfb126bec>
